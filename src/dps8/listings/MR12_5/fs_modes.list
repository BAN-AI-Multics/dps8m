	COMPILATION LISTING OF SEGMENT fs_modes
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-06-29_1716.51_Thu_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       10 
       11 fs_modes: proc (a_segptr, a_mode, a_ex_mode, a_rings, a_code);
       12 
       13 /*	Created 10/11/84 from fs_get by Keith Loepere.
       14*	Modified 4/9/85 to keep mode/ex_mode straight by Keith Loepere.
       15**/
       16 
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
       20*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
       21*     Add warning to fs_modes$locked entrypoint on requirements for properly
       22*     calling the entry.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* This program is used by internal interfaces to look-up access modes
       27*on objects.  It makes no access checks.  Also, it is optimized to examine
       28*kst and sdw fields for access. */
       29 
       30 /* Parameters */
       31 
       32 dcl  a_code			fixed bin (35) parameter;
       33 dcl  a_ex_mode			bit (36) aligned parameter; /* extended access  bits EX ACC */
       34 dcl  a_mode			bit (36) aligned parameter;
       35 dcl  a_rings			(3) fixed bin (3) parameter;
       36 dcl  a_segptr			ptr parameter;
       37 
       38 /* Constants */
       39 
       40 dcl  read_lock			bit (36) aligned static options (constant) init ("0"b);
       41 
       42 /* Variables */
       43 
       44 dcl  code				fixed bin (35);
       45 dcl  dirsw			bit (1) aligned;
       46 dcl  dp				ptr;
       47 dcl  ex_mode			bit (36) aligned;
       48 dcl  have_ep			bit (1) aligned;
       49 dcl  lock_sw			bit (1) aligned;
       50 dcl  mode				bit (36) aligned;
       51 dcl  rb				(3) fixed bin (3);
       52 dcl  ring				fixed bin;
       53 dcl  segno			fixed bin (17);
       54 dcl  segptr			ptr;
       55 
       56 /* External */
       57 
       58 dcl  dseg$			(0:1) fixed bin (71) external;
       59 dcl  error_table_$mylock		fixed bin (35) external;
       60 
       61 /* Entries */
       62 
       63 dcl  get_kstep			entry (fixed bin, ptr, fixed bin (35));
       64 dcl  level$get			entry returns (fixed bin);
       65 dcl  lock$dir_unlock		entry (ptr);
       66 dcl  sum$getbranch_root_my		entry (ptr, bit (36) aligned, ptr, fixed bin (35));
       67 dcl  update_kste_access		entry (ptr, ptr, bit (36) aligned);
       68 
       69 /* Misc */
       70 
       71 dcl  (addr, baseno, binary, fixed, null, ptr) builtin;
       72 
       73 	have_ep = "0"b;
       74 	go to join;
       75 
       76 locked: entry (a_segptr, a_mode, a_ex_mode, a_rings, a_code);
       77 
       78 	have_ep = "1"b;
       79 
       80 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       81 /*							       */
       82 /* WARNING:  When calling fs_modes$locked, sum$getbranch or		       */
       83 /* sum$getbranch_root_my must have been called to obtain a pointer to the    */
       84 /* directory entry corresponding to a_segptr.  This call to sum will lock    */
       85 /* the directory and validate kste.entryp (the pointer to the dir entry      */
       86 /* which is stored within the segment's KST entry).  The directory must      */
       87 /* remain locked until after fs_modes$locked returns, since fs_modes$locked  */
       88 /* uses kste.entryp to obtain a pointer to the dir entry.  Otherwise, the    */
       89 /* dir entry could be moved within the directory by another processor,       */
       90 /* causing fs_modes to reference a garbage location within the directory.    */
       91 /*							       */
       92 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       93 
       94 
       95 join:	segptr = a_segptr;				/* copy arg */
       96 
       97 	call get_kstep (fixed (baseno (segptr), 17), kstep, code); /* get kst entry ptr for this seg */
       98 	if code ^= 0 then go to RETURN;
       99 
      100 	if have_ep then ep = kste.entryp;		/* dir locked => entryp valid */
      101 	else ep = null;
      102 
      103 	dirsw = kstep -> kste.dirsw;			/* pick up directory flag from kst */
      104 
      105 	if kstep -> kste.uid = (36)"1"b then do;	/* special case the root */
      106 	     lock_sw = "0"b;
      107 	     dp = null;				/* get access to root */
      108 	     if kstep -> kste.dtbm = (36)"1"b then call update_kste_access (kstep, ep, mode);
      109 	     mode = RW_ACCESS;			/* raw mode */
      110 	     ex_mode = kstep -> kste.extended_access;	/* pick up directory access */
      111 	     rb (1), rb (2), rb (3) = 7;
      112 	end;
      113 
      114 	else do;					/* if a non directory try to get access from sdw */
      115 	     if dirsw = "0"b then do;			/* before locking the parent */
      116 		dp = null;
      117 		lock_sw = "0"b;
      118 		segno = fixed (baseno (segptr), 17);
      119 		sdwp = addr (dseg$ (segno));
      120 		if sdwp -> sdw.df = "1"b then call get_sdw_access; /* access in sdw is ok, since no setfaults done */
      121 		else do;				/* lock parent to validate the dtbm in kste */
      122 		     call lock_dir;
      123 						/* must update access in kste and change sdw access */
      124 		     if kstep -> kste.dtbm ^= ep -> entry.dtem then
      125 			call update_kste_access (kstep, ep, mode);
      126 		     else mode = kstep -> kste.access;	/* access in kste okay */
      127 		     rb (*) = binary (ep -> entry.ring_brackets (*), 3);
      128 		end;
      129 		ex_mode = kstep -> kste.extended_access;
      130 	     end;
      131 	     else do;
      132 		call lock_dir;
      133 		if kstep -> kste.dtbm ^= ep -> entry.dtem then call update_kste_access (kstep, ep, mode);
      134 		mode = RW_ACCESS;
      135 		ex_mode = kstep -> kste.extended_access;
      136 		rb (*) = binary (kstep -> kste.ex_rb (*), 3); /* factor in extended ring brackets */
      137 	     end;
      138 	end;
      139 
      140 	call compute_effective_mode;
      141 	if dirsw then call compute_effective_dir_mode;
      142 
      143 	if lock_sw then call lock$dir_unlock (dp);
      144 
      145 	a_rings = rb;
      146 	a_mode = mode;
      147 	a_ex_mode = ex_mode;
      148 
      149 RETURN:	a_code = code;
      150 	return;
      151 
      152 get_sdw_access: proc;
      153 	mode = kstep -> kste.access;
      154 	rb (1) = fixed (sdwp -> sdw.r1, 3);
      155 	rb (2) = fixed (sdwp -> sdw.r2, 3);
      156 	rb (3) = fixed (sdwp -> sdw.r3, 3);
      157      end get_sdw_access;
      158 
      159 lock_dir: proc;
      160 
      161 	lock_sw = "0"b;
      162 	if ^have_ep then do;
      163 	     call sum$getbranch_root_my (segptr, (read_lock), ep, code); /* lock parent and get pointer to entry */
      164 	     if code ^= 0 then
      165 		if code ^= error_table_$mylock then go to RETURN;
      166 		else code = 0;			/* allow parent to be locked by us */
      167 	     else lock_sw = "1"b;
      168 	end;
      169 	dp = ptr (ep, 0);				/* get pointer to parent directory */
      170 
      171      end lock_dir;
      172 
      173 compute_effective_mode: proc;
      174 
      175 	ring = level$get ();
      176 	if ring = rb (1) then ;
      177 	else if ring < rb (1) then mode = mode & "101"b;
      178 	else if ring <= rb (2) then mode = mode & "110"b;
      179 	else if ring <= rb (3) then mode = mode & "010"b;
      180 	else mode = "0"b;
      181 
      182      end compute_effective_mode;
      183 
      184 compute_effective_dir_mode: proc;
      185 
      186 	ring = level$get ();
      187 	if ring <= rb (1) then ;
      188 	else if ring <= rb (2) then ex_mode = ex_mode & "100"b;
      189 	else ex_mode = "0"b;
      190 
      191      end compute_effective_dir_mode;
      192  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      192 
      193  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      193 
      194  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  3     2 
  3     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  3     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  3     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  3     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  3     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  3     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  3     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  3    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  3    11 
  3    12 dcl  access_name_type fixed bin static options (constant) init (1);
  3    13 dcl  acle_type fixed bin static options (constant) init (2);
  3    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  3    15 dcl  dir_type fixed bin static options (constant) init (4);
  3    16 dcl  link_type fixed bin static options (constant) init (5);
  3    17 dcl  name_type fixed bin static options (constant) init (6);
  3    18 dcl  seg_type fixed bin static options (constant) init (7);
  3    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  3    20 
  3    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      194 
      195  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  4     2 
  4     3 /*
  4     4*Modified March 1976 by R. Bratt 
  4     5*Modified November 1984 to remove hdr, Keith Loepere. */
  4     6 
  4     7 
  4     8 /****^  HISTORY COMMENTS:
  4     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  4    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  4    11*     Add warning on use of kste.entryp.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 dcl  pds$kstp ext ptr,
  4    16     (kstp, kstep) ptr;
  4    17 
  4    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  4    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  4    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  4    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  4    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  4    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  4    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  4    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  4    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  4    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  4    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  4    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  4    30     2 unused_2 bit (9) unaligned,
  4    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  4    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  4    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  4    34     2 end_of_kst bit (36);
  4    35 
  4    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  4    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  4    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  4    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  4    40     2 entryp ptr unaligned,				/* branch pointer */
  4    41 						/* See WARNING below for requirements to use entryp. */
  4    42     2 uid bit (36) aligned,				/* unique identifier */
  4    43     2 access_information unaligned,
  4    44       3 dtbm bit (36),				/* date time branch modified */
  4    45       3 extended_access bit (33),			/* extended access from the branch */
  4    46       3 access bit (3),				/* rew */
  4    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  4    48     2 pad1 bit (3) unaligned,
  4    49     2 flags unaligned,
  4    50       3 dirsw bit (1),				/* directory switch */
  4    51       3 allow_write bit (1),				/* set if initiated with write permission */
  4    52       3 priv_init bit (1),				/* privileged initiation */
  4    53       3 tms bit (1),				/* transparent modification switch */
  4    54       3 tus bit (1),				/* transparent usage switch */
  4    55       3 tpd bit (1),				/* transparent paging device switch */
  4    56       3 audit bit (1),				/* audit switch */
  4    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  4    58       3 pad bit (3),
  4    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  4    60 
  4    61 
  4    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    63 /*							       */
  4    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  4    65 /* entry associated with the kst entry, you must first validate its value    */
  4    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  4    67 /* the containing directory.  The containing directory must remain locked    */
  4    68 /* during the entire period when kste.entryp and the directory entry are     */
  4    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  4    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  4    71 /* directory since the dir entry could have been moved within the directory  */
  4    72 /* by another processor.					       */
  4    73 /*							       */
  4    74 /* If you only need a pointer to the directory containing the associated     */
  4    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  4    76 /*    pointer (kste.entryp, 0)				       */
  4    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  4    78 /*							       */
  4    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    80 
  4    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      195 
      196  /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  5     2 
  5     3 dcl  sdwp ptr;
  5     4 
  5     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  5     6 
  5     7    (2 add bit (24),					/* main memory address of page table */
  5     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  5     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  5    10     2 df_no bit (2),				/* directed fault number */
  5    11 
  5    12     2 pad1 bit (1),
  5    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  5    14     2 access,					/* access bits */
  5    15       3 read bit (1),				/* read permission bit */
  5    16       3 execute bit (1),				/* execute permission bit */
  5    17       3 write bit (1),				/* write permission bit */
  5    18       3 privileged bit (1),				/* privileged bit */
  5    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  5    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  5    21     2 cache bit (1),				/* cache enable bit */
  5    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  5    23 
  5    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  5    25 
  5    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      196 
      197      end fs_modes;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/00  1716.5  fs_modes.pl1                      >udd>sm>ds>w>ml>fs_modes.pl1
192          1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
193          2    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>incl>dir_entry.incl.pl1
194          3    05/26/77  1022.2  fs_types.incl.pl1                 >ldd>incl>fs_types.incl.pl1
195          4    09/18/86  1408.1  kst.incl.pl1                      >ldd>incl>kst.incl.pl1
196          5    09/14/76  0859.8  sdw.incl.pl1                      >ldd>incl>sdw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 1-11 ref 109 134
a_code                                 parameter       fixed bin(35,0)          dcl 32 set ref 11 76 149*
a_ex_mode                              parameter       bit(36)                  dcl 33 set ref 11 76 147*
a_mode                                 parameter       bit(36)                  dcl 34 set ref 11 76 146*
a_rings                                parameter       fixed bin(3,0)           array dcl 35 set ref 11 76 145*
a_segptr                               parameter       pointer                  dcl 36 ref 11 76 95
access                    6(33)        based           bit(3)                   level 3 packed packed unaligned dcl 4-36 ref 126 153
access_information        5            based           structure                level 2 packed packed unaligned dcl 4-36
addr                                                   builtin function         dcl 71 ref 119
baseno                                                 builtin function         dcl 71 ref 97 97 118
binary                                                 builtin function         dcl 71 ref 127 136
code                            000100 automatic       fixed bin(35,0)          dcl 44 set ref 97* 98 149 163* 164 164 166*
df                        0(33)        based           bit(1)                   level 2 packed packed unaligned dcl 5-5 ref 120
dirsw                     7(12)        based           bit(1)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 4-36 in procedure "fs_modes" ref 103
dirsw                           000101 automatic       bit(1)                   dcl 45 in procedure "fs_modes" set ref 103* 115 141
dp                              000102 automatic       pointer                  dcl 46 set ref 107* 116* 143* 169*
dseg$                           000010 external static fixed bin(71,0)          array dcl 58 set ref 119
dtbm                      5            based           bit(36)                  level 3 packed packed unaligned dcl 4-36 ref 108 124
                                                                                  133
dtem                      3            based           bit(36)                  level 2 dcl 2-8 ref 124 133
entry                                  based           structure                level 1 dcl 2-8
entryp                    3            based           pointer                  level 2 packed packed unaligned dcl 4-36 ref 100
ep                              000120 automatic       pointer                  dcl 2-6 set ref 100* 101* 108* 124 124* 127 133 133*
                                                                                  163* 169
error_table_$mylock             000012 external static fixed bin(35,0)          dcl 59 ref 164
ex_mode                         000104 automatic       bit(36)                  dcl 47 set ref 110* 129* 135* 147 188* 188 189*
ex_rb                     7            based           bit(3)                   array level 3 packed packed unaligned dcl 4-36 ref
                                                                                  136
extended_access           6            based           bit(33)                  level 3 packed packed unaligned dcl 4-36 ref 110 129
                                                                                  135
fixed                                                  builtin function         dcl 71 ref 97 97 118 154 155 156
flags                     7(12)        based           structure                level 2 packed packed unaligned dcl 4-36
get_kstep                       000014 constant        entry                    external dcl 63 ref 97
have_ep                         000105 automatic       bit(1)                   dcl 48 set ref 73* 78* 100 162
kste                                   based           structure                level 1 dcl 4-36
kstep                           000122 automatic       pointer                  dcl 4-15 set ref 97* 100 103 105 108 108* 110 124
                                                                                  124* 126 129 133 133* 135 136 153
level$get                       000016 constant        entry                    external dcl 64 ref 175 186
lock$dir_unlock                 000020 constant        entry                    external dcl 65 ref 143
lock_sw                         000106 automatic       bit(1)                   dcl 49 set ref 106* 117* 143 161* 167*
mode                            000107 automatic       bit(36)                  dcl 50 set ref 108* 109* 124* 126* 133* 134* 146
                                                                                  153* 177* 177 178* 178 179* 179 180*
null                                                   builtin function         dcl 71 ref 101 107 116
ptr                                                    builtin function         dcl 71 ref 169
r1                        0(24)        based           bit(3)                   level 2 packed packed unaligned dcl 5-5 ref 154
r2                        0(27)        based           bit(3)                   level 2 packed packed unaligned dcl 5-5 ref 155
r3                        0(30)        based           bit(3)                   level 2 packed packed unaligned dcl 5-5 ref 156
rb                              000110 automatic       fixed bin(3,0)           array dcl 51 set ref 111* 111* 111* 127* 136* 145
                                                                                  154* 155* 156* 176 177 178 179 187 188
read_lock                              constant        bit(36)                  initial dcl 40 ref 163
ring                            000113 automatic       fixed bin(17,0)          dcl 52 set ref 175* 176 177 178 179 186* 187 188
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 2-8 ref
                                                                                  127
sdw                                    based           structure                level 1 dcl 5-5
sdwp                            000124 automatic       pointer                  dcl 5-3 set ref 119* 120 154 155 156
segno                           000114 automatic       fixed bin(17,0)          dcl 53 set ref 118* 119
segptr                          000116 automatic       pointer                  dcl 54 set ref 95* 97 97 118 163*
sum$getbranch_root_my           000022 constant        entry                    external dcl 66 ref 163
uid                       4            based           bit(36)                  level 2 dcl 4-36 ref 105
update_kste_access              000024 constant        entry                    external dcl 67 ref 108 124 133

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 3-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 3-4
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 3-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 3-6
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 3-10
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 3-7
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 3-8
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 3-9
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
access_name_type                       internal static fixed bin(17,0)          initial dcl 3-12
acle_type                              internal static fixed bin(17,0)          initial dcl 3-13
dir_header_type                        internal static fixed bin(17,0)          initial dcl 3-14
dir_type                               internal static fixed bin(17,0)          initial dcl 3-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 3-19
kst                                    based           structure                level 1 dcl 4-18
kstp                                   automatic       pointer                  dcl 4-15
link_type                              internal static fixed bin(17,0)          initial dcl 3-16
name_type                              internal static fixed bin(17,0)          initial dcl 3-17
pds$kstp                               external static pointer                  dcl 4-15
sdwa                                   based           structure                array level 1 dcl 5-24
seg_type                               internal static fixed bin(17,0)          initial dcl 3-18

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN                          000336 constant        label                    dcl 149 ref 98 164
compute_effective_dir_mode      000460 constant        entry                    internal dcl 184 ref 141
compute_effective_mode          000424 constant        entry                    internal dcl 173 ref 140
fs_modes                        000017 constant        entry                    external dcl 11
get_sdw_access                  000342 constant        entry                    internal dcl 152 ref 120
join                            000037 constant        label                    dcl 95 ref 74
lock_dir                        000365 constant        entry                    internal dcl 159 ref 122 132
locked                          000030 constant        entry                    external dcl 76

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       620         646     504         630
Length      1112     504        26         230     114           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fs_modes                            142 external procedure  is an external procedure.  
get_sdw_access                          internal procedure  shares stack frame of external procedure fs_modes.  
lock_dir                                internal procedure  shares stack frame of external procedure fs_modes.  
compute_effective_mode                  internal procedure  shares stack frame of external procedure fs_modes.  
compute_effective_dir_mode              internal procedure  shares stack frame of external procedure fs_modes.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fs_modes                 000100 code                        fs_modes
                         000101 dirsw                       fs_modes
                         000102 dp                          fs_modes
                         000104 ex_mode                     fs_modes
                         000105 have_ep                     fs_modes
                         000106 lock_sw                     fs_modes
                         000107 mode                        fs_modes
                         000110 rb                          fs_modes
                         000113 ring                        fs_modes
                         000114 segno                       fs_modes
                         000116 segptr                      fs_modes
                         000120 ep                          fs_modes
                         000122 kstep                       fs_modes
                         000124 sdwp                        fs_modes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_kstep                     level$get                     lock$dir_unlock               sum$getbranch_root_my
update_kste_access

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         error_table_$mylock


CONSTANTS
000503  aa     777777777777

000000  aa     404000000021

000001  aa     464000000000

000002  aa     514000000044

000003  aa     404000000043

000004  aa     077777000043
000005  aa     000001000000

000006  aa     404100000003
000007  aa     000000000001
000010  aa     000000000003
000011  aa     000000000001

BEGIN PROCEDURE fs_modes
ENTRY TO fs_modes                                           STATEMENT 1 ON LINE 11
fs_modes: proc (a_segptr, a_mode, a_ex_mode, a_rings, a_code);

000012  at     000005000001
000013  tt     000002000002
000014  tt     000006000003
000015  ta     000012000000
000016  da     000103300000
000017  aa   000220 6270 00	eax7 	144
000020  aa  7 00034 3521 20	epp2 	pr7|28,*
000021  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000022  aa     000012000000
000023  aa     000000000000
						STATEMENT 1 ON LINE 73
	have_ep = "0"b;

000024  aa  6 00105 4501 00	stz  	pr6|69		have_ep
						STATEMENT 1 ON LINE 74
	go to join;

000025  aa   000012 7100 04	tra  	10,ic		000037
ENTRY TO locked                                             STATEMENT 1 ON LINE 76
locked: entry (a_segptr, a_mode, a_ex_mode, a_rings, a_code);

000026  ta     000012000000
000027  da     000110300000
000030  aa   000220 6270 00	eax7 	144
000031  aa  7 00034 3521 20	epp2 	pr7|28,*
000032  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000033  aa     000012000000
000034  aa     000000000000
						STATEMENT 1 ON LINE 78
	have_ep = "1"b;

000035  aa   400000 2350 03	lda  	131072,du
000036  aa  6 00105 7551 00	sta  	pr6|69		have_ep
						STATEMENT 1 ON LINE 95
join:	segptr = a_segptr;

000037  aa  6 00032 3735 20	epp7 	pr6|26,*
000040  aa  7 00002 3715 20	epp5 	pr7|2,*		a_segptr
000041  aa  5 00000 3715 20	epp5 	pr5|0,*		a_segptr
000042  aa  6 00116 6515 00	spri5	pr6|78		segptr
						STATEMENT 1 ON LINE 97
	call get_kstep (fixed (baseno (segptr), 17), kstep, code);

000043  aa  5 00000 2131 00	epaq 	pr5|0		segptr
000044  aa   077777 3750 03	ana  	32767,du
000045  aa   000066 7730 00	lrl  	54
000046  aa  6 00160 7561 00	stq  	pr6|112
000047  aa  6 00160 3521 00	epp2 	pr6|112
000050  aa  6 00164 2521 00	spri2	pr6|116
000051  aa  6 00122 3521 00	epp2 	pr6|82		kstep
000052  aa  6 00166 2521 00	spri2	pr6|118
000053  aa  6 00100 3521 00	epp2 	pr6|64		code
000054  aa  6 00170 2521 00	spri2	pr6|120
000055  aa  6 00161 7561 00	stq  	pr6|113
000056  aa  6 00162 6211 00	eax1 	pr6|114
000057  aa   014000 4310 07	fld  	6144,dl
000060  aa  6 00044 3701 20	epp4 	pr6|36,*
000061  la  4 00014 3521 20	epp2 	pr4|12,*		get_kstep
000062  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 98
	if code ^= 0 then go to RETURN;

000063  aa  6 00100 2361 00	ldq  	pr6|64		code
000064  aa   000252 6010 04	tnz  	170,ic		000336
						STATEMENT 1 ON LINE 100
	if have_ep then ep = kste.entryp;

000065  aa  6 00105 2351 00	lda  	pr6|69		have_ep
000066  aa   000005 6000 04	tze  	5,ic		000073
000067  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000070  aa  7 00003 7671 00	lprp7	pr7|3		kste.entryp
000071  aa  6 00120 6535 00	spri7	pr6|80		ep
000072  aa   000003 7100 04	tra  	3,ic		000075
						STATEMENT 1 ON LINE 101
	else ep = null;

000073  aa   777711 2370 04	ldaq 	-55,ic		000004 = 077777000043 000001000000
000074  aa  6 00120 7571 00	staq 	pr6|80		ep
						STATEMENT 1 ON LINE 103
	dirsw = kstep -> kste.dirsw;

000075  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000076  aa  7 00007 2351 00	lda  	pr7|7		kste.dirsw
000077  aa   000014 7350 00	als  	12
000100  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000101  aa  6 00101 7551 00	sta  	pr6|65		dirsw
						STATEMENT 1 ON LINE 105
	if kstep -> kste.uid = (36)"1"b then do;

000102  aa  7 00004 2351 00	lda  	pr7|4		kste.uid
000103  aa   000400 1150 04	cmpa 	256,ic		000503 = 777777777777
000104  aa   000035 6010 04	tnz  	29,ic		000141
						STATEMENT 1 ON LINE 106
	     lock_sw = "0"b;

000105  aa  6 00106 4501 00	stz  	pr6|70		lock_sw
						STATEMENT 1 ON LINE 107
	     dp = null;

000106  aa   777676 2370 04	ldaq 	-66,ic		000004 = 077777000043 000001000000
000107  aa  6 00102 7571 00	staq 	pr6|66		dp
						STATEMENT 1 ON LINE 108
	     if kstep -> kste.dtbm = (36)"1"b then call update_kste_access (kstep, ep, mode);

000110  aa  7 00005 2351 00	lda  	pr7|5		kste.dtbm
000111  aa   000372 1150 04	cmpa 	250,ic		000503 = 777777777777
000112  aa   000014 6010 04	tnz  	12,ic		000126
000113  aa  6 00122 3521 00	epp2 	pr6|82		kstep
000114  aa  6 00164 2521 00	spri2	pr6|116
000115  aa  6 00120 3521 00	epp2 	pr6|80		ep
000116  aa  6 00166 2521 00	spri2	pr6|118
000117  aa  6 00107 3521 00	epp2 	pr6|71		mode
000120  aa  6 00170 2521 00	spri2	pr6|120
000121  aa  6 00162 6211 00	eax1 	pr6|114
000122  aa   014000 4310 07	fld  	6144,dl
000123  aa  6 00044 3701 20	epp4 	pr6|36,*
000124  la  4 00024 3521 20	epp2 	pr4|20,*		update_kste_access
000125  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 109
	     mode = RW_ACCESS;

000126  aa   500000 2350 03	lda  	163840,du
000127  aa  6 00107 7551 00	sta  	pr6|71		mode
						STATEMENT 1 ON LINE 110
	     ex_mode = kstep -> kste.extended_access;

000130  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000131  aa  7 00006 2351 00	lda  	pr7|6		kste.extended_access
000132  aa  0 00102 3771 00	anaq 	pr0|66		= 777777777770 000000000000
000133  aa  6 00104 7551 00	sta  	pr6|68		ex_mode
						STATEMENT 1 ON LINE 111
	     rb (1), rb (2), rb (3) = 7;

000134  aa   000007 2360 07	ldq  	7,dl
000135  aa  6 00110 7561 00	stq  	pr6|72		rb
000136  aa  6 00111 7561 00	stq  	pr6|73		rb
000137  aa  6 00112 7561 00	stq  	pr6|74		rb
						STATEMENT 1 ON LINE 112
	end;

000140  aa   000146 7100 04	tra  	102,ic		000306
						STATEMENT 1 ON LINE 114
	else do;

						STATEMENT 1 ON LINE 115
	     if dirsw = "0"b then do;

000141  aa  6 00101 2351 00	lda  	pr6|65		dirsw
000142  aa   000075 6010 04	tnz  	61,ic		000237
						STATEMENT 1 ON LINE 116
		dp = null;

000143  aa   777641 2370 04	ldaq 	-95,ic		000004 = 077777000043 000001000000
000144  aa  6 00102 7571 00	staq 	pr6|66		dp
						STATEMENT 1 ON LINE 117
		lock_sw = "0"b;

000145  aa  6 00106 4501 00	stz  	pr6|70		lock_sw
						STATEMENT 1 ON LINE 118
		segno = fixed (baseno (segptr), 17);

000146  aa  6 00161 2361 00	ldq  	pr6|113
000147  aa  6 00114 7561 00	stq  	pr6|76		segno
						STATEMENT 1 ON LINE 119
		sdwp = addr (dseg$ (segno));

000150  aa   000001 7360 00	qls  	1
000151  aa  6 00044 3701 20	epp4 	pr6|36,*
000152  la  4 00010 3715 66	epp5 	pr4|8,*ql		dseg$
000153  aa  6 00124 6515 00	spri5	pr6|84		sdwp
						STATEMENT 1 ON LINE 120
		if sdwp -> sdw.df = "1"b then call get_sdw_access;

000154  aa  5 00000 2351 00	lda  	pr5|0		sdw.df
000155  aa   000041 7350 00	als  	33
000156  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000157  aa   400000 1150 03	cmpa 	131072,du
000160  aa   000003 6010 04	tnz  	3,ic		000163
000161  aa   000161 6700 04	tsp4 	113,ic		000342
000162  aa   000050 7100 04	tra  	40,ic		000232
						STATEMENT 1 ON LINE 121
		else do;

						STATEMENT 1 ON LINE 122
		     call lock_dir;

000163  aa   000202 6700 04	tsp4 	130,ic		000365
						STATEMENT 1 ON LINE 124
		     if kstep -> kste.dtbm ^= ep -> entry.dtem then
			call update_kste_access (kstep, ep, mode);

000164  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000165  aa  7 00005 2351 00	lda  	pr7|5		kste.dtbm
000166  aa  6 00120 3715 20	epp5 	pr6|80,*		ep
000167  aa  5 00003 1151 00	cmpa 	pr5|3		entry.dtem
000170  aa   000015 6000 04	tze  	13,ic		000205
000171  aa  6 00122 3521 00	epp2 	pr6|82		kstep
000172  aa  6 00164 2521 00	spri2	pr6|116
000173  aa  6 00120 3521 00	epp2 	pr6|80		ep
000174  aa  6 00166 2521 00	spri2	pr6|118
000175  aa  6 00107 3521 00	epp2 	pr6|71		mode
000176  aa  6 00170 2521 00	spri2	pr6|120
000177  aa  6 00162 6211 00	eax1 	pr6|114
000200  aa   014000 4310 07	fld  	6144,dl
000201  aa  6 00044 3701 20	epp4 	pr6|36,*
000202  la  4 00024 3521 20	epp2 	pr4|20,*		update_kste_access
000203  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000204  aa   000005 7100 04	tra  	5,ic		000211
						STATEMENT 1 ON LINE 126
		     else mode = kstep -> kste.access;

000205  aa  7 00006 2351 00	lda  	pr7|6		kste.access
000206  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
000207  aa   000041 7370 00	lls  	33
000210  aa  6 00107 7551 00	sta  	pr6|71		mode
						STATEMENT 1 ON LINE 127
		     rb (*) = binary (ep -> entry.ring_brackets (*), 3);

000211  aa   000001 2360 07	ldq  	1,dl
000212  aa  6 00126 7561 00	stq  	pr6|86
000213  aa   000000 0110 03	nop  	0,du
000214  aa  6 00126 2361 00	ldq  	pr6|86
000215  aa   000003 4020 07	mpy  	3,dl
000216  aa  6 00120 3735 20	epp7 	pr6|80,*		ep
000217  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000220  aa  7 00034 66 0003	descb	pr7|28(33),3	entry.ring_brackets
000221  aa  6 00056 00 0044	descb	pr6|46,36
000222  aa  6 00056 2351 00	lda  	pr6|46
000223  aa   000105 7730 00	lrl  	69
000224  aa  6 00126 7271 00	lxl7 	pr6|86
000225  aa  6 00107 7561 17	stq  	pr6|71,7		rb
000226  aa  6 00126 2361 00	ldq  	pr6|86
000227  aa  6 00126 0541 00	aos  	pr6|86
000230  aa   000003 1160 07	cmpq 	3,dl
000231  aa   777763 6040 04	tmi  	-13,ic		000214
						STATEMENT 1 ON LINE 128
		end;

						STATEMENT 1 ON LINE 129
		ex_mode = kstep -> kste.extended_access;

000232  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000233  aa  7 00006 2351 00	lda  	pr7|6		kste.extended_access
000234  aa  0 00102 3771 00	anaq 	pr0|66		= 777777777770 000000000000
000235  aa  6 00104 7551 00	sta  	pr6|68		ex_mode
						STATEMENT 1 ON LINE 130
	     end;

000236  aa   000050 7100 04	tra  	40,ic		000306
						STATEMENT 1 ON LINE 131
	     else do;

						STATEMENT 1 ON LINE 132
		call lock_dir;

000237  aa   000126 6700 04	tsp4 	86,ic		000365
						STATEMENT 1 ON LINE 133
		if kstep -> kste.dtbm ^= ep -> entry.dtem then call update_kste_access (kstep, ep, mode);

000240  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000241  aa  7 00005 2351 00	lda  	pr7|5		kste.dtbm
000242  aa  6 00120 3715 20	epp5 	pr6|80,*		ep
000243  aa  5 00003 1151 00	cmpa 	pr5|3		entry.dtem
000244  aa   000014 6000 04	tze  	12,ic		000260
000245  aa  6 00122 3521 00	epp2 	pr6|82		kstep
000246  aa  6 00164 2521 00	spri2	pr6|116
000247  aa  6 00120 3521 00	epp2 	pr6|80		ep
000250  aa  6 00166 2521 00	spri2	pr6|118
000251  aa  6 00107 3521 00	epp2 	pr6|71		mode
000252  aa  6 00170 2521 00	spri2	pr6|120
000253  aa  6 00162 6211 00	eax1 	pr6|114
000254  aa   014000 4310 07	fld  	6144,dl
000255  aa  6 00044 3701 20	epp4 	pr6|36,*
000256  la  4 00024 3521 20	epp2 	pr4|20,*		update_kste_access
000257  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 134
		mode = RW_ACCESS;

000260  aa   500000 2350 03	lda  	163840,du
000261  aa  6 00107 7551 00	sta  	pr6|71		mode
						STATEMENT 1 ON LINE 135
		ex_mode = kstep -> kste.extended_access;

000262  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000263  aa  7 00006 2351 00	lda  	pr7|6		kste.extended_access
000264  aa  0 00102 3771 00	anaq 	pr0|66		= 777777777770 000000000000
000265  aa  6 00104 7551 00	sta  	pr6|68		ex_mode
						STATEMENT 1 ON LINE 136
		rb (*) = binary (kstep -> kste.ex_rb (*), 3);

000266  aa   000001 2360 07	ldq  	1,dl
000267  aa  6 00126 7561 00	stq  	pr6|86
000270  aa  6 00126 2361 00	ldq  	pr6|86
000271  aa   000003 4020 07	mpy  	3,dl
000272  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000273  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000274  aa  7 00006 66 0003	descb	pr7|6(33),3	kste.ex_rb
000275  aa  6 00056 00 0044	descb	pr6|46,36
000276  aa  6 00056 2351 00	lda  	pr6|46
000277  aa   000105 7730 00	lrl  	69
000300  aa  6 00126 7271 00	lxl7 	pr6|86
000301  aa  6 00107 7561 17	stq  	pr6|71,7		rb
000302  aa  6 00126 2361 00	ldq  	pr6|86
000303  aa  6 00126 0541 00	aos  	pr6|86
000304  aa   000003 1160 07	cmpq 	3,dl
000305  aa   777763 6040 04	tmi  	-13,ic		000270
						STATEMENT 1 ON LINE 137
	     end;

						STATEMENT 1 ON LINE 138
	end;

						STATEMENT 1 ON LINE 140
	call compute_effective_mode;

000306  aa   000116 6700 04	tsp4 	78,ic		000424
						STATEMENT 1 ON LINE 141
	if dirsw then call compute_effective_dir_mode;

000307  aa  6 00101 2351 00	lda  	pr6|65		dirsw
000310  aa   000002 6000 04	tze  	2,ic		000312
000311  aa   000147 6700 04	tsp4 	103,ic		000460
						STATEMENT 1 ON LINE 143
	if lock_sw then call lock$dir_unlock (dp);

000312  aa  6 00106 2351 00	lda  	pr6|70		lock_sw
000313  aa   000010 6000 04	tze  	8,ic		000323
000314  aa  6 00102 3521 00	epp2 	pr6|66		dp
000315  aa  6 00164 2521 00	spri2	pr6|116
000316  aa  6 00162 6211 00	eax1 	pr6|114
000317  aa   004000 4310 07	fld  	2048,dl
000320  aa  6 00044 3701 20	epp4 	pr6|36,*
000321  la  4 00020 3521 20	epp2 	pr4|16,*		lock$dir_unlock
000322  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 145
	a_rings = rb;

000323  aa  6 00032 3735 20	epp7 	pr6|26,*
000324  aa  7 00010 3715 20	epp5 	pr7|8,*
000325  aa  6 00110 2371 00	ldaq 	pr6|72		rb
000326  aa  5 00000 7551 00	sta  	pr5|0		a_rings
000327  aa  5 00001 7561 00	stq  	pr5|1		a_rings
000330  aa  6 00112 2351 00	lda  	pr6|74		rb
000331  aa  5 00002 7551 00	sta  	pr5|2		a_rings
						STATEMENT 1 ON LINE 146
	a_mode = mode;

000332  aa  6 00107 2351 00	lda  	pr6|71		mode
000333  aa  7 00004 7551 20	sta  	pr7|4,*		a_mode
						STATEMENT 1 ON LINE 147
	a_ex_mode = ex_mode;

000334  aa  6 00104 2351 00	lda  	pr6|68		ex_mode
000335  aa  7 00006 7551 20	sta  	pr7|6,*		a_ex_mode
						STATEMENT 1 ON LINE 149
RETURN:	a_code = code;

000336  aa  6 00100 2361 00	ldq  	pr6|64		code
000337  aa  6 00032 3735 20	epp7 	pr6|26,*
000340  aa  7 00012 7561 20	stq  	pr7|10,*		a_code
						STATEMENT 1 ON LINE 150
	return;

000341  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 197
     end fs_modes;

BEGIN PROCEDURE get_sdw_access
ENTRY TO get_sdw_access                                     STATEMENT 1 ON LINE 152
get_sdw_access: proc;

000342  aa  6 00130 6501 00	spri4	pr6|88
						STATEMENT 1 ON LINE 153
	mode = kstep -> kste.access;

000343  aa  6 00122 3735 20	epp7 	pr6|82,*		kstep
000344  aa  7 00006 2351 00	lda  	pr7|6		kste.access
000345  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
000346  aa   000041 7370 00	lls  	33
000347  aa  6 00107 7551 00	sta  	pr6|71		mode
						STATEMENT 1 ON LINE 154
	rb (1) = fixed (sdwp -> sdw.r1, 3);

000350  aa  6 00124 2351 20	lda  	pr6|84,*		sdw.r1
000351  aa   000030 7350 00	als  	24
000352  aa   000105 7730 00	lrl  	69
000353  aa  6 00110 7561 00	stq  	pr6|72		rb
						STATEMENT 1 ON LINE 155
	rb (2) = fixed (sdwp -> sdw.r2, 3);

000354  aa  6 00124 2351 20	lda  	pr6|84,*		sdw.r2
000355  aa   000033 7350 00	als  	27
000356  aa   000105 7730 00	lrl  	69
000357  aa  6 00111 7561 00	stq  	pr6|73		rb
						STATEMENT 1 ON LINE 156
	rb (3) = fixed (sdwp -> sdw.r3, 3);

000360  aa  6 00124 2351 20	lda  	pr6|84,*		sdw.r3
000361  aa   000036 7350 00	als  	30
000362  aa   000105 7730 00	lrl  	69
000363  aa  6 00112 7561 00	stq  	pr6|74		rb
						STATEMENT 1 ON LINE 157
     end get_sdw_access;

000364  aa  6 00130 6101 00	rtcd 	pr6|88
  END PROCEDURE get_sdw_access
BEGIN PROCEDURE lock_dir
ENTRY TO lock_dir                                           STATEMENT 1 ON LINE 159
lock_dir: proc;

000365  aa  6 00136 6501 00	spri4	pr6|94
						STATEMENT 1 ON LINE 161
	lock_sw = "0"b;

000366  aa  6 00106 4501 00	stz  	pr6|70		lock_sw
						STATEMENT 1 ON LINE 162
	if ^have_ep then do;

000367  aa  6 00105 2351 00	lda  	pr6|69		have_ep
000370  aa   000031 6010 04	tnz  	25,ic		000421
						STATEMENT 1 ON LINE 163
	     call sum$getbranch_root_my (segptr, (read_lock), ep, code);

000371  aa   000000 2350 07	lda  	0,dl
000372  aa  6 00172 7551 00	sta  	pr6|122
000373  aa  6 00116 3521 00	epp2 	pr6|78		segptr
000374  aa  6 00176 2521 00	spri2	pr6|126
000375  aa  6 00172 3521 00	epp2 	pr6|122
000376  aa  6 00200 2521 00	spri2	pr6|128
000377  aa  6 00120 3521 00	epp2 	pr6|80		ep
000400  aa  6 00202 2521 00	spri2	pr6|130
000401  aa  6 00100 3521 00	epp2 	pr6|64		code
000402  aa  6 00204 2521 00	spri2	pr6|132
000403  aa  6 00174 6211 00	eax1 	pr6|124
000404  aa   020000 4310 07	fld  	8192,dl
000405  aa  6 00044 3701 20	epp4 	pr6|36,*
000406  la  4 00022 3521 20	epp2 	pr4|18,*		sum$getbranch_root_my
000407  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 164
	     if code ^= 0 then
		if code ^= error_table_$mylock then go to RETURN;

000410  aa  6 00100 2361 00	ldq  	pr6|64		code
000411  aa   000006 6000 04	tze  	6,ic		000417
000412  aa  6 00044 3701 20	epp4 	pr6|36,*
000413  la  4 00012 1161 20	cmpq 	pr4|10,*		error_table_$mylock
000414  aa   777722 6010 04	tnz  	-46,ic		000336
						STATEMENT 1 ON LINE 166
		else code = 0;

000415  aa  6 00100 4501 00	stz  	pr6|64		code
000416  aa   000003 7100 04	tra  	3,ic		000421
						STATEMENT 1 ON LINE 167
	     else lock_sw = "1"b;

000417  aa   400000 2350 03	lda  	131072,du
000420  aa  6 00106 7551 00	sta  	pr6|70		lock_sw
						STATEMENT 1 ON LINE 168
	end;

						STATEMENT 1 ON LINE 169
	dp = ptr (ep, 0);

000421  aa  6 00120 3525 20	epbp2	pr6|80,*		ep
000422  aa  6 00102 2521 00	spri2	pr6|66		dp
						STATEMENT 1 ON LINE 171
     end lock_dir;

000423  aa  6 00136 6101 00	rtcd 	pr6|94
  END PROCEDURE lock_dir
BEGIN PROCEDURE compute_effective_mode
ENTRY TO compute_effective_mode                             STATEMENT 1 ON LINE 173
compute_effective_mode: proc;

000424  aa  6 00144 6501 00	spri4	pr6|100
						STATEMENT 1 ON LINE 175
	ring = level$get ();

000425  aa  6 00113 3521 00	epp2 	pr6|75		ring
000426  aa  6 00210 2521 00	spri2	pr6|136
000427  aa  6 00206 6211 00	eax1 	pr6|134
000430  aa   004000 4310 07	fld  	2048,dl
000431  aa  6 00044 3701 20	epp4 	pr6|36,*
000432  la  4 00016 3521 20	epp2 	pr4|14,*		level$get
000433  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 176
	if ring = rb (1) then ;

000434  aa  6 00113 2361 00	ldq  	pr6|75		ring
000435  aa  6 00110 1161 00	cmpq 	pr6|72		rb
000436  aa   000002 6010 04	tnz  	2,ic		000440
000437  aa   000020 7100 04	tra  	16,ic		000457
						STATEMENT 1 ON LINE 177
	else if ring < rb (1) then mode = mode & "101"b;

000440  aa   000004 6050 04	tpl  	4,ic		000444
000441  aa   500000 2350 03	lda  	163840,du
000442  aa  6 00107 3551 00	ansa 	pr6|71		mode
000443  aa   000014 7100 04	tra  	12,ic		000457
						STATEMENT 1 ON LINE 178
	else if ring <= rb (2) then mode = mode & "110"b;

000444  aa  6 00111 1161 00	cmpq 	pr6|73		rb
000445  aa   000004 6054 04	tpnz 	4,ic		000451
000446  aa   600000 2350 03	lda  	196608,du
000447  aa  6 00107 3551 00	ansa 	pr6|71		mode
000450  aa   000007 7100 04	tra  	7,ic		000457
						STATEMENT 1 ON LINE 179
	else if ring <= rb (3) then mode = mode & "010"b;

000451  aa  6 00112 1161 00	cmpq 	pr6|74		rb
000452  aa   000004 6054 04	tpnz 	4,ic		000456
000453  aa   200000 2350 03	lda  	65536,du
000454  aa  6 00107 3551 00	ansa 	pr6|71		mode
000455  aa   000002 7100 04	tra  	2,ic		000457
						STATEMENT 1 ON LINE 180
	else mode = "0"b;

000456  aa  6 00107 4501 00	stz  	pr6|71		mode
						STATEMENT 1 ON LINE 182
     end compute_effective_mode;

000457  aa  6 00144 6101 00	rtcd 	pr6|100
  END PROCEDURE compute_effective_mode
BEGIN PROCEDURE compute_effective_dir_mode
ENTRY TO compute_effective_dir_mode                         STATEMENT 1 ON LINE 184
compute_effective_dir_mode: proc;

000460  aa  6 00152 6501 00	spri4	pr6|106
						STATEMENT 1 ON LINE 186
	ring = level$get ();

000461  aa  6 00113 3521 00	epp2 	pr6|75		ring
000462  aa  6 00214 2521 00	spri2	pr6|140
000463  aa  6 00212 6211 00	eax1 	pr6|138
000464  aa   004000 4310 07	fld  	2048,dl
000465  aa  6 00044 3701 20	epp4 	pr6|36,*
000466  la  4 00016 3521 20	epp2 	pr4|14,*		level$get
000467  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 187
	if ring <= rb (1) then ;

000470  aa  6 00113 2361 00	ldq  	pr6|75		ring
000471  aa  6 00110 1161 00	cmpq 	pr6|72		rb
000472  aa   000002 6054 04	tpnz 	2,ic		000474
000473  aa   000007 7100 04	tra  	7,ic		000502
						STATEMENT 1 ON LINE 188
	else if ring <= rb (2) then ex_mode = ex_mode & "100"b;

000474  aa  6 00111 1161 00	cmpq 	pr6|73		rb
000475  aa   000004 6054 04	tpnz 	4,ic		000501
000476  aa   400000 2350 03	lda  	131072,du
000477  aa  6 00104 3551 00	ansa 	pr6|68		ex_mode
000500  aa   000002 7100 04	tra  	2,ic		000502
						STATEMENT 1 ON LINE 189
	else ex_mode = "0"b;

000501  aa  6 00104 4501 00	stz  	pr6|68		ex_mode
						STATEMENT 1 ON LINE 191
     end compute_effective_dir_mode;

000502  aa  6 00152 6101 00	rtcd 	pr6|106
  END PROCEDURE compute_effective_dir_mode
  END PROCEDURE fs_modes


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
