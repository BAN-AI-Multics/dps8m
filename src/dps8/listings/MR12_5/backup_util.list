	COMPILATION LISTING OF SEGMENT backup_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0933.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* Utility procedure for backup reloader. */
       14 backup_util: proc (dname, ename);
       15 
       16 /* Created by R H Campbell. */
       17 /* Modified 2 April 1970, R H Campbell. */
       18 /* Modified 21 October 1970, R. J. Feiertag to scrunch ring brackets. */
       19 /* modified on 12.11.72 by A. Downing to increase the size of (name_area) */
       20 /* modified by Kobziar on 11-20-73 to not print err for obsolete CACLs */
       21 /* last modified by Kobziar 10-21-74 to add access_mode arg to $build_tree call */
       22 /* last modified by R. Bratt 7-18-75 to remove pre 18-0 dinosaurs */
       23 /* MCR 4310 add missing options to map 01/28/80 S. Herbst */
       24 /* Modified: 17 November 1980 by G. Palter to allow backup_util$add_names to be called with other than the primary name */
       25 /* obsolete and useless $replace_acl entry removed 5/3/82 BIM */
       26 
       27 dcl (dname character (168),				/* directory path name */
       28      ename character (32)) aligned;			/* entry name */
       29 
       30 
       31 dcl (i, j, k, l) fixed bin,				/* Temporary storage. */
       32      a_code fixed bin,				/* return status code */
       33      code fixed bin,				/* file system error code */
       34      access_class bit (72) aligned,			/* access_class of path */
       35      esw fixed bin,					/* Entry switch */
       36      area_ptr ptr,					/* ptr to system_free_area */
       37      ix pointer;					/* Pointer to array element. */
       38 
       39 dcl (error_table_$moderr, error_table_$user_not_found, error_table_$nonamerr,
       40      error_table_$logical_volume_not_connected, error_table_$vtoce_connection_fail,
       41      error_table_$logical_volume_not_defined,
       42      error_table_$noentry, error_table_$bad_ring_brackets, error_table_$incorrect_access, error_table_$no_info,
       43      error_table_$fulldir, error_table_$segnamedup, error_table_$namedup, error_table_$safety_sw_on,
       44      error_table_$copy_sw_on) fixed bin ext;
       45 
       46 dcl  init static bit (1) initial ("1"b),		/* Flag to cause static initialization. */
       47      group_id static character (32) aligned;		/* Our name.project.tag. */
       48 
       49 dcl 1 name (1) based (np) aligned,
       50     2 size bit (17),
       51     2 string character (32);
       52 
       53 dcl 1 stat_area,					/* structure returned by status_ for get_real_name */
       54     2 (pad1 bit (18),
       55      nrp bit (18),
       56      pad2 bit (108)) unaligned;
       57 
       58 dcl  names (1) char (32) based;			/* primary entry name */
       59 
       60 dcl (oldp, newp) ptr,				/* pathnames for get_primary name */
       61     (oldn based (oldp), newn based (newp)) char (168),
       62      newl fixed bin;				/* length of revised pathname */
       63 
       64 dcl (dir, work) char (168), ent char (32);		/* workspace */
       65 
       66 dcl  backup_map_$fs_error_line entry (fixed bin, char (*) aligned, char (168) aligned, char (32) aligned),
       67      backup_map_$name_line entry (pointer, fixed binary),
       68      backup_load_dir_list$build_tree entry (char (*) aligned, char (*) aligned, fixed bin,
       69      fixed bin (24), fixed bin (2), char (*) aligned, bit (72) aligned, fixed bin),
       70     (backup_util$delete_name, backup_util$give_access) entry (char (168) aligned, char (32) aligned, fixed bin);
       71 
       72 dcl  get_group_id_ entry returns (character (32)),
       73      get_system_free_area_ entry returns (ptr),
       74      hcs_$add_acl_entries entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin),
       75      hcs_$add_dir_acl_entries entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin),
       76      hcs_$status_minf entry (char (*) aligned, char (*) aligned, fixed bin (1), fixed bin (2), fixed bin (24), fixed bin),
       77      hcs_$chname_file entry (char (*) aligned, char (*) aligned, char (*) aligned, char (*) aligned, fixed binary),
       78     (hcs_$del_dir_tree, hcs_$delentry_file) entry (char (*) aligned, char (*) aligned, fixed binary),
       79      hcs_$status_ entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin),
       80      hcs_$get_access_class entry (char (*) aligned, char (*) aligned, bit (72) aligned, fixed bin),
       81      hcs_$set_copysw entry (char (*) aligned, char (*) aligned, bit (1), fixed bin),
       82      hcs_$set_safety_sw entry (char (*) aligned, char (*) aligned, bit (1), fixed bin);
       83 
       84 
       85 dcl (addr, empty, fixed, index, length, min, pointer, substr, rtrim) builtin;
       86 
  1     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  1     6*     install(87-03-30,MR12.1-1018):
  1     7*     added a writing_map switch to indicate when the dump map is being written.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  1    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  1    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  1    14 
  1    15 /* Hierarchy dumper/reloader static data */
  1    16 
  1    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  1    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  1    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  1    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  1    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  1    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  1    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  1    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  1    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  1    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  1    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  1    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  1    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  1    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  1    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  1    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  1    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  1    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  1    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  1    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  1    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  1    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  1    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  1    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  1    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  1    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  1    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  1    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  1    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  1    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  1    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  1    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  1    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  1    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  1    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  1    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  1    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  1    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  1    55*						   requests satisfied (loading) */
  1    56      bk_ss_$operator char(32),			/* operator name */
  1    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  1    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  1    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  1    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  1    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  1    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  1    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  1    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  1    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  1    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  1    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  1    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  1    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  1    70      bk_ss_$rname char(168),				/* retrieval file name */
  1    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  1    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  1    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  1    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  1    75      bk_ss_$segptr pointer,
  1    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  1    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  1    78      bk_ss_$sp pointer,
  1    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  1    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  1    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  1    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  1    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  1    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  1    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  1    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  1    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  1    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  1    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  1    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  1    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  1    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  1    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  1    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  1    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  1    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  1    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  1    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  1    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  1   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  1   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  1   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  1   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  1   104 	external static;
  1   105 
  1   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
       87 
  2     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  2     2 /* format: style3,indcomtxt,idind30 */
  2     3 
  2     4 declare   acl_ptr                       pointer;
  2     5 declare   acl_count                     fixed bin;
  2     6 
  2     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  2     8           2 version                     char (8) aligned,
  2     9           2 count                       fixed bin,
  2    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  2    11 
  2    12 declare 1 general_acl_entry             based,
  2    13           2 access_name                 character (32) unaligned,
  2    14           2 mode                        bit (36) aligned,
  2    15           2 status_code                 fixed bin (35);
  2    16 
  2    17 
  2    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  2    19           2 version                     char (8) aligned,
  2    20           2 count                       fixed bin,
  2    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  2    22 
  2    23 declare 1 general_extended_acl_entry    aligned based,
  2    24           2 access_name                 character (32) unaligned,
  2    25           2 mode                        bit (36) aligned,
  2    26           2 extended_mode               bit (36) aligned,
  2    27           2 status_code                 fixed bin (35);
  2    28 
  2    29 
  2    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  2    31           2 version                     char (8) aligned,
  2    32           2 count                       fixed bin,
  2    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  2    34 
  2    35 declare 1 general_delete_acl_entry      aligned based,
  2    36           2 access_name                 character (32) unaligned,
  2    37           2 status_code                 fixed bin (35);
  2    38 
  2    39 
  2    40 declare 1 segment_acl                   aligned based (acl_ptr),
  2    41           2 version                     fixed bin,
  2    42           2 count                       fixed bin,
  2    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  2    44 
  2    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  2    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  2    47 
  2    48 
  2    49 declare 1 directory_acl                 aligned based (acl_ptr),
  2    50           2 version                     fixed bin,
  2    51           2 count                       fixed bin,
  2    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  2    53 
  2    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  2    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  2    56 
  2    57 
  2    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  2    59           2 version                     fixed bin,
  2    60           2 count                       fixed bin,
  2    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  2    62 
  2    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  2    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  2    65 
  2    66 
  2    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  2    68           DIR_ACL_VERSION_1             init ("dra1"),
  2    69           DELETE_ACL_VERSION_1          init ("dla1"))
  2    70                                         char (4) int static options (constant);
  2    71 
  2    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  2    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  2    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  2    75                                         char (8) internal static options (constant);
  2    76 
  2    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  2    78 
  2    79 /* End include file acl_structures.incl.pl1 */
       88 
       89   
       90 add_names: entry (dname, ename, np, nnames, list_names);	/* Entry to add all names to entry. */
       91 
       92 dcl  np ptr,					/* Pointer to names. */
       93      nnames fixed bin,				/* Number of names. */
       94      list_names bit (1);				/* Flag to enable writing of names. */
       95 	do i = 1 to nnames;
       96 	     ix = addr (np -> name (i));		/* Get pointer to this array element. */
       97 	     if (ename ^= ix -> name(1).string) then do;	/* not added yet */
       98 		if bk_ss_$no_reload then go to print_name;   /* Not reloading so print the name only */
       99 add:		call hcs_$chname_file (dname, ename, "", ix -> name (1).string, code); /* Try to add the name. */
      100 		if code = error_table_$namedup then do;	/* Was name already in directory? */
      101 		     call backup_util$delete_name (dname, ix -> name (1).string, code);    /* Try to remove the name. */
      102 		     if code = 0 then go to add;	/* Removal successful? */
      103 		end;				/* Any errors here will be reported by delete_name. */
      104 		else if code = error_table_$segnamedup then; /* Leave name already on branch */
      105 		else if code ^= 0 then		/* If unsuccessful, don't write name line. */
      106 		     call backup_map_$fs_error_line (code, "chname_file in add_names", dname, ix -> name (1).string);
      107 		else if bk_ss_$mapsw & list_names then	/* Write the name if map desired. */
      108 print_name:	     call backup_map_$name_line (addr (ix -> name (1).string), fixed (ix -> name (1).size, 17));
      109 	     end;
      110 	end;
      111 	return;					/* Return to caller. */
      112 
      113 
      114 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      115 delete_name: entry (dname, ename, a_code);		/* Entry to remove offending name from directory. */
      116 	call hcs_$chname_file (dname, ename, ename, "", code); /* Try to remove the name from its entry. */
      117 	if code = error_table_$nonamerr then do;	/* Is it the last name on its entry? */
      118 delete:	     call hcs_$delentry_file (dname, ename, code); /* try simple delete first */
      119 	     if code = error_table_$moderr | code = error_table_$incorrect_access then do; /* Do we have right access? */
      120 get_access:	call backup_util$give_access (dname, ename, code); /* Try to change it. */
      121 		if code = 0 then go to delete;	/* try again if changed successfully */
      122 	     end;
      123 	     else if code = error_table_$safety_sw_on then do; /* Turn off the safety switch, else if necessary. */
      124 		call hcs_$set_safety_sw (dname, ename, "0"b, code);
      125 		if code = 0 then go to delete;	/* Try again if successful. */
      126 		call backup_map_$fs_error_line (code, "backup_util$delete_name", dname, ename);
      127 	     end;
      128 	     else if code = error_table_$copy_sw_on then do; /* Turn off copy switch */
      129 		call hcs_$set_copysw (dname, ename, "0"b, code);
      130 		if code = 0 then go to delete;
      131 		call backup_map_$fs_error_line (code, "backup_util$delete_name", dname, ename);
      132 	     end;
      133 	     else if code = error_table_$user_not_found then go to get_access; /* Were we on the ACL at all? */
      134 	     else if code = error_table_$fulldir then do; /* was it a non-empty directory? */
      135 		call hcs_$del_dir_tree (dname, ename, code); /* yes, delete inferior entries */
      136 		if code = 0 then go to delete;
      137 		call backup_map_$fs_error_line (code, "backup_util$delete_name", dname, ename);
      138 	     end;
      139 	     else if code ^= 0 then			/* If unsuccessful, give error comment. */
      140 		call backup_map_$fs_error_line (code, "backup_util$delete_name", dname, ename);
      141 	end;
      142 	else if code ^= 0 then			/* If unexpected error, give error comment. */
      143 	     call backup_map_$fs_error_line (code, "backup_util$delete_name", dname, ename);
      144 	a_code = code;				/* return status */
      145 	return;					/* Return to caller. */
      146 
      147 
      148 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      149 
      150 
      151 give_access: entry (dname, ename, a_code);		/* Entry to give ourselves access to entry. */
      152 
      153 dcl  seg_aclp ptr int static,
      154      dir_aclp ptr int static;
      155 
      156 dcl 1 seg_acl (1) aligned like segment_acl_entry int static;
      157 dcl 1 dir_acl (1) aligned like directory_acl_entry int static;
      158 
      159 dcl  type fixed bin (2),
      160      bitcnt fixed bin (24);
      161 
      162 	if init then do;				/* Must we initialize? */
      163 	     group_id = get_group_id_ ();		/* Get our ID code. */
      164 	     seg_acl.access_name (1),
      165 		dir_acl.access_name (1) = group_id;
      166 	     seg_acl.mode = "111"b;
      167 	     seg_acl.extended_mode = ""b;
      168 	     dir_acl.mode = "111"b;
      169 	     seg_aclp = addr (seg_acl);
      170 	     dir_aclp = addr (dir_acl);
      171 	     init = ""b;				/* Clear flag. */
      172 	end;
      173 	call hcs_$status_minf (dname, ename, 1, type, bitcnt, code);
      174 	if code ^= 0 then
      175 	     if code = error_table_$logical_volume_not_defined then code = 0;
      176 	     else if code = error_table_$logical_volume_not_connected then code = 0;
      177 	     else if code = error_table_$vtoce_connection_fail then code = 0;
      178 	     else go to ret;
      179 	if type = 0 then go to ret;
      180 	if type = 1 then call hcs_$add_acl_entries (dname, ename, seg_aclp, 1, code); /* put us on ACL */
      181 	else call hcs_$add_dir_acl_entries (dname, ename, dir_aclp, 1, code);
      182 
      183 	if code = error_table_$no_info | code = error_table_$incorrect_access then do;
      184 	     call hcs_$get_access_class (dname, "", access_class, code);
      185 	     if code ^= 0 then access_class = "0"b;	/* try with this value */
      186 	     call backup_load_dir_list$build_tree (dname, "", 3, 0, 0, "", access_class, code);
      187 	end;					/* If we cannot get access, then recurse. */
      188 ret:	a_code = code;				/* Return status */
      189 	return;					/* Return to caller. */
      190 
      191 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      192 
      193 
      194 
      195 
      196 get_real_name: entry (oldp, newp, newl, a_code);		/* entry to get a "more proper" version of a pathname */
      197 	l = 0;					/* l is current length of output pathname */
      198 	work = "";				/* new pathname built here, level by level */
      199 	i = index (oldn, " ");			/* determine length of old pathname */
      200 	if i = 0 then i = 169;			/* it may be the full 168 */
      201 	j = 1;					/* current position on input pathname */
      202 	do while (j < i - 1);			/* scan entire input name */
      203 	     k = index (substr (oldn, j), ">");		/* find next directory level */
      204 	     if k = 0 then go to done;		/* if there isn't one, scan is finished */
      205 	     dir = substr (oldn, 1, j + k - 2);		/* save directories so far seen */
      206 	     j = j + k;				/* move along input */
      207 	     if j = 2 then dir = ">";			/* status wants a trailing ">" only for the root */
      208 	     k = index (substr (oldn, j), ">");		/* next level is entry name for this level */
      209 	     if k = 0 then ent = substr (oldn, j, i - j); /* if there isn't another level, use remainder of input */
      210 	     else ent = substr (oldn, j, k - 1);	/* otherwise characters up to next ">" */
      211 	     area_ptr = get_system_free_area_ ();
      212 	     call hcs_$status_ (dir, ent, 1, addr (stat_area), area_ptr, code); /* get the names of this entity */
      213 	     if code ^= 0 then
      214 		if code = error_table_$logical_volume_not_connected then code = 0;
      215 		else if code = error_table_$logical_volume_not_defined then code = 0;
      216 		else if code = error_table_$vtoce_connection_fail then code = 0;
      217 		else do;				/* if something was wrong */
      218 		     if code ^= error_table_$noentry then go to grn_ret; /* it had better be entry not found */
      219 		     work = substr (work, 1, l) || ">" || substr (oldn, j, i - j); /* it was, tack on unfound part of input */
      220 		     l = l + i - j + 1;		/* compute total length of result */
      221 		     go to done;			/* job is done */
      222 		end;
      223 	     work = substr (work, 1, l) || ">" || pointer (area_ptr, stat_area.nrp) -> names (1);
      224 	     l = index (work, " ") - 1;		/* new length with new primary name appended */
      225 	end;
      226 done:	code = 0;					/* return zero if nothing was done */
      227 	newl = l;					/* set the length argument */
      228 	if oldn = work then go to grn_ret;		/* see if anything useful was accomplished */
      229 	if l = 0 then go to grn_ret;			/* pathname didn't have any ">"s */
      230 	newn = work;				/* hand over the new pathname */
      231 	code = 1;					/* and say we did so */
      232 grn_ret:	a_code = code;				/* Return status code */
      233 	return;
      234 
      235 
      236 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      237 
      238 
      239 idline:	entry (rfile, rdate, linep, n);		/* entry to format retriever's signature line */
      240 
      241 dcl (rfile, rdate) char (*),				/* retrieval control file, retriever version */
      242      linep ptr,
      243      line char (300) based (linep),			/* output line */
      244      n fixed bin;					/* its length */
      245 	call append (rtrim (bk_ss_$myname));		/* insert our name in id line */
      246 	call append ((rdate));			/* add version of loader */
      247 	if rfile ^= "" then call append (rtrim (rfile));	/* control file to be used */
      248 	call append ("map");			/* Report map option setting */
      249 	if bk_ss_$quotasw then call append ("quota");	/* Report setting of quota restoration switch. */
      250 	else call append ("noquota");
      251 	if bk_ss_$onlysw then call append ("first");	/* Report satisfaction criterion */
      252 	else call append ("last");
      253 	if bk_ss_$trimsw then call append ("trim");	/* Report pruning option setting. */
      254 	else call append ("notrim");
      255 	if bk_ss_$debugsw then call append ("debug");	/* Report debug mode setting. */
      256 	if bk_ss_$dir_trim then call append ("dir_trim");	/* for reload system release */
      257 	if bk_ss_$err_onlinesw then call append ("error_on");
      258 	if bk_ss_$ignore_dates then call append ("ignore_dates");  /* for reload system release */
      259 	if bk_ss_$no_primary then call append ("noprimary");  /* do not use primary pathnames */
      260 	if bk_ss_$no_reload then call append ("noreload");  /* testing reloader */
      261 	if bk_ss_$no_setlvid then call append ("nosetlvid");  /* don't set logical voilume id */
      262 	if bk_ss_$qchecksw then call append ("qcheck");	/* check quotas */
      263 	else call append ("noqcheck");		/* default */
      264 	return;
      265 
      266 
      267 append:	procedure (string);				/* Append string to identification line */
      268 
      269 dcl  string character (*) aligned;			/* What to append. */
      270 	     if n < length (line) then do;		/* Is there room in buffer? */
      271 		n = n + 1;			/* Count it. */
      272 		substr (line, n, 1) = " ";		/* Prepend a blank. */
      273 		i = min (length (line) - n, length (string)); /* Don't overflow. */
      274 		substr (line, n + 1, i) = string;	/* Append this string. */
      275 		n = n + i;			/* Count length. */
      276 	     end;
      277 	end append;
      278 
      279      end backup_util;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0809.5  backup_util.pl1                   >spec>install>1111>backup_util.pl1
87           1    04/02/87  2006.7  bk_ss_.incl.pl1                   >ldd>include>bk_ss_.incl.pl1
88           2    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(17,0)          dcl 31 set ref 115 144* 151 188* 196 232*
access_class                    000106 automatic       bit(72)                  dcl 31 set ref 184* 185* 186*
access_name                     000026 internal static char(32)                 array level 2 in structure "seg_acl" packed packed
                                                                                  unaligned dcl 156 in procedure "backup_util" set
                                                                                  ref 164*
access_name                     000041 internal static char(32)                 array level 2 in structure "dir_acl" packed packed
                                                                                  unaligned dcl 157 in procedure "backup_util" set
                                                                                  ref 164*
addr                                                   builtin function         dcl 85 ref 96 107 107 169 170 212 212
area_ptr                        000110 automatic       pointer                  dcl 31 set ref 211* 212* 223
backup_load_dir_list$build_tree 000114 constant        entry                    external dcl 66 ref 186
backup_map_$fs_error_line       000110 constant        entry                    external dcl 66 ref 105 126 131 137 139 142
backup_map_$name_line           000112 constant        entry                    external dcl 66 ref 107
backup_util$delete_name         000116 constant        entry                    external dcl 66 ref 101
backup_util$give_access         000120 constant        entry                    external dcl 66 ref 120
bitcnt                          000255 automatic       fixed bin(24,0)          dcl 159 set ref 173*
bk_ss_$debugsw                  000152 external static bit(1)                   dcl 1-17 ref 255
bk_ss_$dir_trim                 000154 external static bit(1)                   dcl 1-17 ref 256
bk_ss_$err_onlinesw             000156 external static bit(1)                   dcl 1-17 ref 257
bk_ss_$ignore_dates             000160 external static bit(1)                   dcl 1-17 ref 258
bk_ss_$mapsw                    000162 external static bit(1)                   dcl 1-17 ref 107
bk_ss_$myname                   000164 external static char(16)                 packed unaligned dcl 1-17 ref 245 245
bk_ss_$no_primary               000166 external static bit(1)                   dcl 1-17 ref 259
bk_ss_$no_reload                000170 external static bit(1)                   dcl 1-17 ref 98 260
bk_ss_$no_setlvid               000172 external static bit(1)                   dcl 1-17 ref 261
bk_ss_$onlysw                   000174 external static bit(1)                   dcl 1-17 ref 251
bk_ss_$qchecksw                 000176 external static bit(1)                   dcl 1-17 ref 262
bk_ss_$quotasw                  000200 external static bit(1)                   dcl 1-17 ref 249
bk_ss_$trimsw                   000202 external static bit(1)                   dcl 1-17 ref 253
code                            000104 automatic       fixed bin(17,0)          dcl 31 set ref 99* 100 101* 102 104 105 105* 116*
                                                                                  117 118* 119 119 120* 121 123 124* 125 126* 128
                                                                                  129* 130 131* 133 134 135* 136 137* 139 139* 142
                                                                                  142* 144 173* 174 174 174* 176 176* 177 177* 180*
                                                                                  181* 183 183 184* 185 186* 188 212* 213 213 213*
                                                                                  215 215* 216 216* 218 226* 231* 232
delete_acl_entry                       based           structure                level 1 dcl 2-63
dir                             000120 automatic       char(168)                packed unaligned dcl 64 set ref 205* 207* 212*
dir_acl                         000041 internal static structure                array level 1 dcl 157 set ref 170
dir_aclp                        000024 internal static pointer                  dcl 153 set ref 170* 181*
directory_acl_entry                    based           structure                level 1 dcl 2-54
dname                                  parameter       char(168)                dcl 27 set ref 14 90 99* 101* 105* 115 116* 118*
                                                                                  120* 124* 126* 129* 131* 135* 137* 139* 142* 151
                                                                                  173* 180* 181* 184* 186*
ename                                  parameter       char(32)                 dcl 27 set ref 14 90 97 99* 115 116* 116* 118* 120*
                                                                                  124* 126* 129* 131* 135* 137* 139* 142* 151 173*
                                                                                  180* 181*
ent                             000244 automatic       char(32)                 packed unaligned dcl 64 set ref 209* 210* 212*
error_table_$copy_sw_on         000106 external static fixed bin(17,0)          dcl 39 ref 128
error_table_$fulldir            000076 external static fixed bin(17,0)          dcl 39 ref 134
error_table_$incorrect_access   000072 external static fixed bin(17,0)          dcl 39 ref 119 183
error_table_$logical_volume_not_connected
                                000062 external static fixed bin(17,0)          dcl 39 ref 176 213
error_table_$logical_volume_not_defined
                                000066 external static fixed bin(17,0)          dcl 39 ref 174 215
error_table_$moderr             000054 external static fixed bin(17,0)          dcl 39 ref 119
error_table_$namedup            000102 external static fixed bin(17,0)          dcl 39 ref 100
error_table_$no_info            000074 external static fixed bin(17,0)          dcl 39 ref 183
error_table_$noentry            000070 external static fixed bin(17,0)          dcl 39 ref 218
error_table_$nonamerr           000060 external static fixed bin(17,0)          dcl 39 ref 117
error_table_$safety_sw_on       000104 external static fixed bin(17,0)          dcl 39 ref 123
error_table_$segnamedup         000100 external static fixed bin(17,0)          dcl 39 ref 104
error_table_$user_not_found     000056 external static fixed bin(17,0)          dcl 39 ref 133
error_table_$vtoce_connection_fail
                                000064 external static fixed bin(17,0)          dcl 39 ref 177 216
extended_mode            11     000026 internal static bit(36)                  array level 2 dcl 156 set ref 167*
fixed                                                  builtin function         dcl 85 ref 107 107
general_acl_entry                      based           structure                level 1 unaligned dcl 2-12
general_delete_acl_entry               based           structure                level 1 dcl 2-35
general_extended_acl_entry             based           structure                level 1 dcl 2-23
get_group_id_                   000122 constant        entry                    external dcl 72 ref 163
get_system_free_area_           000124 constant        entry                    external dcl 72 ref 211
group_id                        000011 internal static char(32)                 dcl 46 set ref 163* 164
hcs_$add_acl_entries            000126 constant        entry                    external dcl 72 ref 180
hcs_$add_dir_acl_entries        000130 constant        entry                    external dcl 72 ref 181
hcs_$chname_file                000134 constant        entry                    external dcl 72 ref 99 116
hcs_$del_dir_tree               000136 constant        entry                    external dcl 72 ref 135
hcs_$delentry_file              000140 constant        entry                    external dcl 72 ref 118
hcs_$get_access_class           000144 constant        entry                    external dcl 72 ref 184
hcs_$set_copysw                 000146 constant        entry                    external dcl 72 ref 129
hcs_$set_safety_sw              000150 constant        entry                    external dcl 72 ref 124
hcs_$status_                    000142 constant        entry                    external dcl 72 ref 212
hcs_$status_minf                000132 constant        entry                    external dcl 72 ref 173
i                               000100 automatic       fixed bin(17,0)          dcl 31 set ref 95* 96* 199* 200 200* 202 209 219 220
                                                                                  273* 274 275
index                                                  builtin function         dcl 85 ref 199 203 208 224
init                            000010 internal static bit(1)                   initial packed unaligned dcl 46 set ref 162 171*
ix                              000112 automatic       pointer                  dcl 31 set ref 96* 97 99 101 105 107 107 107 107
j                               000101 automatic       fixed bin(17,0)          dcl 31 set ref 201* 202 203 205 206* 206 207 208 209
                                                                                  209 210 219 219 220
k                               000102 automatic       fixed bin(17,0)          dcl 31 set ref 203* 204 205 206 208* 209 210
l                               000103 automatic       fixed bin(17,0)          dcl 31 set ref 197* 219 220* 220 223 224* 227 229
length                                                 builtin function         dcl 85 ref 270 273 273
line                                   based           char(300)                packed unaligned dcl 241 set ref 270 272* 273 274*
linep                                  parameter       pointer                  dcl 241 ref 239 270 272 273 274
list_names                             parameter       bit(1)                   packed unaligned dcl 92 ref 90 107
min                                                    builtin function         dcl 85 ref 273
mode                     10     000026 internal static bit(36)                  array level 2 in structure "seg_acl" dcl 156
                                                                                  in procedure "backup_util" set ref 166*
mode                     10     000041 internal static bit(36)                  array level 2 in structure "dir_acl" dcl 157
                                                                                  in procedure "backup_util" set ref 168*
n                                      parameter       fixed bin(17,0)          dcl 241 set ref 239 270 271* 271 272 273 274 275*
                                                                                  275
name                                   based           structure                array level 1 dcl 49 set ref 96
names                                  based           char(32)                 array packed unaligned dcl 58 ref 223
newl                                   parameter       fixed bin(17,0)          dcl 60 set ref 196 227*
newn                                   based           char(168)                packed unaligned dcl 60 set ref 230*
newp                                   parameter       pointer                  dcl 60 ref 196 230
nnames                                 parameter       fixed bin(17,0)          dcl 92 ref 90 95
np                                     parameter       pointer                  dcl 92 ref 90 96
nrp                       0(18) 000114 automatic       bit(18)                  level 2 packed packed unaligned dcl 53 set ref 223
oldn                                   based           char(168)                packed unaligned dcl 60 ref 199 203 205 208 209 210
                                                                                  219 228
oldp                                   parameter       pointer                  dcl 60 ref 196 199 203 205 208 209 210 219 228
pointer                                                builtin function         dcl 85 ref 223
rdate                                  parameter       char                     packed unaligned dcl 241 ref 239 246
rfile                                  parameter       char                     packed unaligned dcl 241 ref 239 247 247 247
rtrim                                                  builtin function         dcl 85 ref 245 245 247 247
seg_acl                         000026 internal static structure                array level 1 dcl 156 set ref 169
seg_aclp                        000022 internal static pointer                  dcl 153 set ref 169* 180*
segment_acl_entry                      based           structure                level 1 dcl 2-45
size                                   based           bit(17)                  array level 2 dcl 49 set ref 107 107
stat_area                       000114 automatic       structure                level 1 packed packed unaligned dcl 53 set ref 212
                                                                                  212
string                    1            based           char(32)                 array level 2 in structure "name" dcl 49
                                                                                  in procedure "backup_util" set ref 97 99* 101*
                                                                                  105* 107 107
string                                 parameter       char                     dcl 269 in procedure "append" ref 267 273 274
substr                                                 builtin function         dcl 85 set ref 203 205 208 209 210 219 219 223 272*
                                                                                  274*
type                            000254 automatic       fixed bin(2,0)           dcl 159 set ref 173* 179 180
work                            000172 automatic       char(168)                packed unaligned dcl 64 set ref 198* 219* 219 223*
                                                                                  223 224 228 230

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 2-77
DELETE_ACL_VERSION_1                   internal static char(4)                  initial packed unaligned dcl 2-67
DIR_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 2-67
GENERAL_ACL_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 2-72
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial packed unaligned dcl 2-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial packed unaligned dcl 2-72
SEG_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 2-67
acl_count                              automatic       fixed bin(17,0)          dcl 2-5
acl_ptr                                automatic       pointer                  dcl 2-4
bk_ss_$allow_dir_overwrite             external static bit(1)                   dcl 1-17
bk_ss_$areap                           external static pointer                  dcl 1-17
bk_ss_$brief_mapsw                     external static bit(1)                   dcl 1-17
bk_ss_$caller_handles_conditions       external static bit(1)                   dcl 1-17
bk_ss_$check_effective_access          external static bit(1)                   dcl 1-17
bk_ss_$control_name                    external static char(168)                packed unaligned dcl 1-17
bk_ss_$control_ptr                     external static pointer                  dcl 1-17
bk_ss_$cross_retrievesw                external static bit(1)                   dcl 1-17
bk_ss_$data_iocb                       external static pointer                  dcl 1-17
bk_ss_$date                            external static fixed bin(52,0)          dcl 1-17
bk_ss_$datesw                          external static bit(1)                   dcl 1-17
bk_ss_$dont_dump_upgraded_dirs         external static bit(1)                   dcl 1-17
bk_ss_$dprint_destination              external static char(24)                 packed unaligned dcl 1-17
bk_ss_$dprint_destination_setsw        external static bit(1)                   dcl 1-17
bk_ss_$dprint_heading                  external static char(64)                 packed unaligned dcl 1-17
bk_ss_$dprint_heading_setsw            external static bit(1)                   dcl 1-17
bk_ss_$dprint_queue                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$dprint_request_type             external static char(24)                 packed unaligned dcl 1-17
bk_ss_$dprint_request_type_setsw       external static bit(1)                   dcl 1-17
bk_ss_$dprintsw                        external static bit(1)                   dcl 1-17
bk_ss_$dtdsw                           external static bit(1)                   dcl 1-17
bk_ss_$ename                           external static char(32)                 dcl 1-17
bk_ss_$enforce_max_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_min_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_minimum_ring            external static bit(1)                   dcl 1-17
bk_ss_$err_label                       external static label variable           dcl 1-17
bk_ss_$error                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$holdsw                          external static bit(1)                   dcl 1-17
bk_ss_$hp                              external static pointer                  dcl 1-17
bk_ss_$maximum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$maximum_dir_access_class        external static bit(72)                  dcl 1-17
bk_ss_$minimum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$minimum_ring                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$namesw                          external static bit(1)                   dcl 1-17
bk_ss_$no_contin                       external static bit(1)                   dcl 1-17
bk_ss_$no_output                       external static bit(1)                   dcl 1-17
bk_ss_$ntapes                          external static fixed bin(17,0)          dcl 1-17
bk_ss_$operator                        external static char(32)                 packed unaligned dcl 1-17
bk_ss_$path_index                      external static fixed bin(17,0)          dcl 1-17
bk_ss_$pathsw                          external static bit(1)                   dcl 1-17
bk_ss_$preattached                     external static bit(1)                   dcl 1-17
bk_ss_$pvname                          external static char(32)                 dcl 1-17
bk_ss_$pvsw                            external static bit(1)                   dcl 1-17
bk_ss_$restart_dumpsw                  external static bit(1)                   dcl 1-17
bk_ss_$restart_path                    external static char(168)                dcl 1-17
bk_ss_$restart_plen                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$restore_access_class            external static bit(1)                   dcl 1-17
bk_ss_$retrieval_index                 external static fixed bin(17,0)          dcl 1-17
bk_ss_$retrievesw                      external static bit(1)                   dcl 1-17
bk_ss_$rlen                            external static fixed bin(17,0)          dcl 1-17
bk_ss_$rname                           external static char(168)                packed unaligned dcl 1-17
bk_ss_$rsize                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$save_path                       external static char(168)                packed unaligned dcl 1-17
bk_ss_$save_plen                       external static fixed bin(17,0)          dcl 1-17
bk_ss_$save_time                       external static fixed bin(52,0)          dcl 1-17
bk_ss_$segptr                          external static pointer                  dcl 1-17
bk_ss_$set_dtd                         external static bit(1)                   dcl 1-17
bk_ss_$set_dtd_explicit                external static bit(1)                   dcl 1-17
bk_ss_$source_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$sp                              external static pointer                  dcl 1-17
bk_ss_$sub_entry                       external static bit(1)                   dcl 1-17
bk_ss_$sub_entry_errfile               external static bit(1)                   dcl 1-17
bk_ss_$tapesw                          external static bit(1)                   dcl 1-17
bk_ss_$target_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$translate_access_class          external static bit(1)                   dcl 1-17
bk_ss_$upgrade_to_user_auth            external static bit(1)                   dcl 1-17
bk_ss_$user_authorization              external static bit(72)                  dcl 1-17
bk_ss_$user_id                         external static char(32)                 packed unaligned dcl 1-17
bk_ss_$user_ring                       external static fixed bin(17,0)          dcl 1-17
bk_ss_$volume_set_name                 external static char(32)                 packed unaligned dcl 1-17
bk_ss_$wakeup_interval                 external static fixed bin(52,0)          dcl 1-17
bk_ss_$wasnt_known                     external static bit(1)                   dcl 1-17
bk_ss_$writing_map                     external static bit(1)                   dcl 1-17
delete_acl                             based           structure                level 1 dcl 2-58
delete_acl_array                       based           structure                array level 1 dcl 2-64
directory_acl                          based           structure                level 1 dcl 2-49
directory_acl_array                    based           structure                array level 1 dcl 2-55
empty                                                  builtin function         dcl 85
error_table_$bad_ring_brackets         external static fixed bin(17,0)          dcl 39
esw                                    automatic       fixed bin(17,0)          dcl 31
general_acl                            based           structure                level 1 dcl 2-7
general_delete_acl                     based           structure                level 1 dcl 2-30
general_extended_acl                   based           structure                level 1 dcl 2-18
segment_acl                            based           structure                level 1 dcl 2-40
segment_acl_array                      based           structure                array level 1 dcl 2-46

NAMES DECLARED BY EXPLICIT CONTEXT.
add                             000161 constant        label                    dcl 99 ref 102
add_names                       000126 constant        entry                    external dcl 90
append                          002433 constant        entry                    internal dcl 267 ref 245 246 247 248 249 250 251 252
                                                                                  253 254 255 256 257 258 259 260 261 262 263
backup_util                     000113 constant        entry                    external dcl 14
delete                          000377 constant        label                    dcl 118 ref 121 125 130 136
delete_name                     000332 constant        entry                    external dcl 115
done                            001724 constant        label                    dcl 226 ref 204 221
get_access                      000427 constant        label                    dcl 120 ref 133
get_real_name                   001367 constant        entry                    external dcl 196
give_access                     000773 constant        entry                    external dcl 151
grn_ret                         001747 constant        label                    dcl 232 set ref 218 228 229
idline                          001757 constant        entry                    external dcl 239
print_name                      000305 constant        label                    dcl 107 ref 98
ret                             001357 constant        label                    dcl 188 ref 177 179

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3240        3444    2502        3250
Length      3764    2502       204         304     535          44

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
backup_util                         288 external procedure  is an external procedure.  
append                               65 internal procedure  is called during a stack extension.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 init                        backup_util
000011 group_id                    backup_util
000022 seg_aclp                    backup_util
000024 dir_aclp                    backup_util
000026 seg_acl                     backup_util
000041 dir_acl                     backup_util

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
backup_util              000100 i                           backup_util
                         000101 j                           backup_util
                         000102 k                           backup_util
                         000103 l                           backup_util
                         000104 code                        backup_util
                         000106 access_class                backup_util
                         000110 area_ptr                    backup_util
                         000112 ix                          backup_util
                         000114 stat_area                   backup_util
                         000120 dir                         backup_util
                         000172 work                        backup_util
                         000244 ent                         backup_util
                         000254 type                        backup_util
                         000255 bitcnt                      backup_util

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
shorten_stack       ext_entry           ext_entry_desc      int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
backup_load_dir_list$build_tree                             backup_map_$fs_error_line     backup_map_$name_line
backup_util$delete_name       backup_util$give_access       get_group_id_                 get_system_free_area_
hcs_$add_acl_entries          hcs_$add_dir_acl_entries      hcs_$chname_file              hcs_$del_dir_tree
hcs_$delentry_file            hcs_$get_access_class         hcs_$set_copysw               hcs_$set_safety_sw
hcs_$status_                  hcs_$status_minf

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$debugsw                bk_ss_$dir_trim               bk_ss_$err_onlinesw           bk_ss_$ignore_dates
bk_ss_$mapsw                  bk_ss_$myname                 bk_ss_$no_primary             bk_ss_$no_reload
bk_ss_$no_setlvid             bk_ss_$onlysw                 bk_ss_$qchecksw               bk_ss_$quotasw
bk_ss_$trimsw                 error_table_$copy_sw_on       error_table_$fulldir          error_table_$incorrect_access
error_table_$logical_volume_not_connected                   error_table_$logical_volume_not_defined
error_table_$moderr           error_table_$namedup          error_table_$no_info          error_table_$noentry
error_table_$nonamerr         error_table_$safety_sw_on     error_table_$segnamedup       error_table_$user_not_found
error_table_$vtoce_connection_fail




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000107        90 000120        95 000133        96 000143        97 000151        98 000156        99 000161
    100 000213       101 000217       102 000233       103 000235       104 000236       105 000241       107 000275
    110 000323       111 000325       115 000326       116 000342       117 000373       118 000377       119 000421
    120 000427       121 000443       122 000445       123 000446       124 000450       125 000477       126 000501
    127 000532       128 000533       129 000535       130 000564       131 000566       132 000617       133 000620
    134 000622       135 000624       136 000645       137 000647       138 000700       139 000701       141 000733
    142 000734       144 000766       145 000770       151 000771       162 001003       163 001006       164 001020
    166 001031       167 001045       168 001060       169 001073       170 001075       171 001077       173 001100
    174 001137       176 001146       177 001152       179 001155       180 001157       181 001215       183 001250
    184 001256       185 001303       186 001307       188 001357       189 001361       196 001362       197 001377
    198 001400       199 001403       200 001417       201 001422       202 001424       203 001430       204 001452
    205 001453       206 001460       207 001462       208 001470       209 001506       210 001515       211 001521
    212 001530       213 001570       215 001577       216 001603       218 001607       219 001611       220 001647
    221 001655       223 001656       224 001712       225 001723       226 001724       227 001725       228 001730
    229 001736       230 001740       231 001745       232 001747       233 001751       239 001752       245 001777
    246 002032       247 002054       248 002114       249 002127       250 002145       251 002157       252 002175
    253 002207       254 002225       255 002237       256 002254       257 002271       258 002306       259 002325
    260 002345       261 002362       262 002401       263 002417       264 002431       267 002432       270 002446
    271 002453       272 002454       273 002462       274 002470       275 002476       277 002500


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
