	COMPILATION LISTING OF SEGMENT syserr_seg_manager
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1000.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
       13*     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1091):
       14*     Correct error message documentation.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* format: style4 */
       19 
       20 syserr_seg_manager:
       21      procedure ();
       22 
       23 /* *	SYSERR_SEG_MANAGER
       24*   *
       25*   *	This procedure is responsible for all file-system manipulations of
       26*   *	the syserr log segments.  It is responsible for the names of the
       27*   *	segments kept in syserr_log_data.log_name; it is driven by the
       28*   *	swap_time in syserr_log_data when setting and changing the names.
       29*   *	It expects the names to be set appropriately by the first part of
       30*   *	syserr initialization (see init_syserr_log).
       31*   *
       32*   *	This procedure manipulates the file system, and therefore can only
       33*   *	be run in a real process (such as by a gate call) or late in
       34*   *	initialization.
       35*   *
       36*   *	Modification history:
       37*   *	84-10-02, W. Olin Sibert: Separated from syserr_copy, when it was
       38*   *	   pointed out by Benson that the SyserrLogger daemon can't be expected
       39*   *	   to do file system manipulations without a KST.
       40*   *	84-10-15, WOS: Added threshold initialization entrypoints
       41*   *	84-10-17, WOS: Added syserr_seg_manager$verify_lock
       42*   *	84-11-11, WOS: Added console recovery support.
       43*   1985-01-02, BIM: fixed reference to lock for fast lock.
       44*   *	85-02-15, Keith Loepere: don't rename log segs under paged lock.
       45*   This is part of making the paged lock the highest paged
       46*   lock, so that any paged code can write to the paged log.
       47*   *	85-03-03, EJ Sharpe: added verify_sequence entrypoint, format
       48**/
       49 
       50 declare  P_code fixed bin (35) parameter;
       51 declare  P_copy_channel fixed bin (71) parameter;
       52 declare  P_current_log_empty bit (1) aligned parameter;
       53 declare  P_last_history_sequence fixed bin (35) parameter;
       54 declare  P_new_sequence fixed bin (35) parameter;
       55 declare  P_page_threshold fixed bin parameter;
       56 declare  P_recovery_flag bit (1) aligned parameter;
       57 declare  P_swap_time fixed bin (71) parameter;
       58 
       59 declare  code fixed bin (35);
       60 declare  copy_channel fixed bin (71);
       61 declare  current_log_empty bit (1) aligned;
       62 declare  last_history_sequence fixed bin (35);
       63 declare  live_log_ptr pointer;
       64 declare  new_sequence fixed bin (35);
       65 declare  non_live_log fixed bin;
       66 declare  non_live_log_ptr pointer;
       67 declare  non_live_name char (32);
       68 declare  page_threshold fixed bin;
       69 declare  recovery_flag bit (1) aligned;
       70 declare  sequence_increment fixed bin (35);
       71 declare  swap_time fixed bin (71);
       72 
       73 declare  log_data_$syserr_log_dir char (168) external static;
       74 declare  log_data_$syserr_log_empty_name char (32) external static;
       75 declare  log_data_$syserr_log_history_dir char (168) external static;
       76 declare  log_data_$syserr_log_name char (32) external static;
       77 declare  pds$process_group_id char (32) external static;
       78 declare  pds$processid bit (36) aligned external static;
       79 
       80 declare  error_table_$action_not_performed fixed bin (35) external static;
       81 declare  error_table_$log_segment_empty fixed bin (35) external static;
       82 
       83 declare  chname$cfile entry (char (*), char (*), char (*), char (*), fixed bin (35));
       84 declare  level$get entry () returns (fixed bin (3));
       85 declare  level$set entry (fixed bin (3));
       86 declare  log_name_$name entry (char (*), fixed bin (71)) returns (char (32));
       87 declare  log_position_$next_message entry (ptr, ptr, bit (1) aligned);
       88 declare  syserr entry options (variable);
       89 declare  syserr$error_code entry options (variable);
       90 declare  syserr_copy_wired_log$adjust_wired_log_sequence entry (fixed bin (35));
       91 declare  syserr_copy$lock entry ();
       92 declare  syserr_copy$unlock entry ();
       93 declare  syserr_copy$swap_logs entry ();
       94 declare  unique_chars_ entry (bit (*)) returns (char (15));
       95 
       96 declare  WHOAMI char (32) internal static options (constant) init ("syserr_seg_manager");
       97 
       98 declare  (addr, max, min, null) builtin;
       99 
      100 
      101 /* This entrypoint is called late during Collection 2 initialization to
      102*   change the names of the two syserr log segments in >sl1 from their
      103*   SLT names to the appropriate log segment names. The live log becomes
      104*   "syserr_log", and the non-live log becomes "syserr_log.empty" or
      105*   "syserr_log.YYYYMMDD.HHMMSS", depending on whether it has contents.
      106*   The SLT names were placed into syserr_log_data earlier by init_syserr_log,
      107*   which is the only procedure that knows about them. */
      108 
      109 
      110 syserr_seg_manager$initialize_log_names:
      111      entry ();
      112 
      113 	call syserr_copy$lock ();			/* Be polite.... even though this IS initialization */
      114 						/* Besides, if the daemon ran and tried to swap logs.... */
      115 
      116 	call get_log_ptrs ();
      117 
      118 	call get_log_names ();
      119 
      120 	call syserr_copy$unlock ();			/* don't lock directories under paged syserr lock */
      121 
      122 	call set_log_names ();
      123 
      124 	return;
      125 
      126 
      127 /* This entrypoint is called early in Answering Service initialization
      128*   to start the business of copying messages from ring zero into the
      129*   permanent syserr log family in >sc1>syserr_log. The Answering
      130*   Service supplies a threshold for the number of pages of outstanding
      131*   log messages allowed to hang around in ring zero, and an event
      132*   channel over which the copying takes place. To stop copying, this
      133*   entrypoint is called with a channel value of zero. */
      134 
      135 syserr_seg_manager$start_copying:
      136      entry (P_copy_channel, P_page_threshold);
      137 
      138 	copy_channel = P_copy_channel;
      139 	page_threshold = P_page_threshold;
      140 
      141 	call syserr_copy$lock ();
      142 
      143 	call get_log_ptrs ();
      144 
      145 	syserr_log_data.copy_threshold = max (1, min (page_threshold,
      146 	     syserr_log_data.log_size (1), syserr_log_data.log_size (2)) - 1);
      147 	syserr_log_data.copy_channel = copy_channel;
      148 	syserr_log_data.copy_process_id = pds$processid;
      149 
      150 	call syserr_copy$unlock ();
      151 
      152 	return;
      153 
      154 
      155 
      156 
      157 /* This entry is called to turn the wakeups required by console recovery
      158*   on and off. When "recovery mode" is in effect, a wakeup will be sent
      159*   to the copying process whenever a printable message is logged, regardless
      160*   of how full the log partition is. */
      161 
      162 syserr_seg_manager$set_recovery_flag:
      163      entry (P_recovery_flag);
      164 
      165 	recovery_flag = P_recovery_flag;
      166 
      167 	call syserr_copy$lock ();
      168 
      169 	call get_log_ptrs ();
      170 
      171 	syserr_log_data.wakeup_on_printable = recovery_flag;
      172 
      173 	call syserr_copy$unlock ();
      174 
      175 	return;
      176 
      177 
      178 syserr_seg_manager$segment_info:
      179      entry (P_swap_time, P_current_log_empty);
      180 
      181 	call syserr_copy$lock ();
      182 
      183 	call get_log_ptrs ();
      184 
      185 	swap_time = syserr_log_data.swap_time;
      186 	current_log_empty = (live_log_ptr -> log_segment.first_sequence = 0);
      187 
      188 	call syserr_copy$unlock ();
      189 
      190 	P_swap_time = swap_time;
      191 	P_current_log_empty = current_log_empty;
      192 
      193 	return;
      194 
      195 
      196 syserr_seg_manager$swap_logs:				/* Called through hphcs_, to prepare for copying */
      197      entry (P_code);				/* Log is UNLOCKED on entry */
      198 
      199 	call syserr_copy$lock ();
      200 
      201 	call get_log_ptrs ();
      202 
      203 	if (syserr_log_data.swap_time ^= 0) then do;	/* A swap is pending, can't ask for another one */
      204 	     code = error_table_$action_not_performed;
      205 	     call syserr_copy$unlock ();
      206 	end;
      207 
      208 	else if (live_log_ptr -> log_segment.last_sequence = 0) then do; /* Nothing in the live log now, */
      209 	     code = error_table_$log_segment_empty;	/* don't even bother trying to swap */
      210 	     call syserr_copy$unlock ();
      211 	end;
      212 
      213 	else do;					/* Otherwise, there's something there. Swap */
      214 	     call syserr_copy$swap_logs ();		/* Call our counterpart to swap the logs */
      215 
      216 	     call get_log_ptrs ();			/* Get them again, they've changed */
      217 	     live_log_ptr -> log_segment.previous_log_dir = log_data_$syserr_log_dir; /* Until it's copied out */
      218 	     non_live_log_ptr -> log_segment.previous_log_dir = log_data_$syserr_log_history_dir;
      219 
      220 	     call get_log_names ();
      221 
      222 	     call syserr_copy$unlock ();		/* don't lock directories under paged syserr lock */
      223 
      224 	     call set_log_names ();
      225 	     code = 0;
      226 	end;
      227 
      228 	P_code = code;
      229 	return;
      230 
      231 
      232 syserr_seg_manager$reuse_empty_log:			/* Called through hphcs_, once copying has happened */
      233      entry (P_code);				/* Log is UNLOCKED on entry */
      234 
      235 
      236 	call syserr_copy$lock ();
      237 
      238 	call get_log_ptrs ();
      239 
      240 	if (syserr_log_data.swap_time ^= 0) then do;	/* There WAS a pending swap, but it's allegedly done */
      241 	     syserr_log_data.swap_time = 0;		/* Mark that log as empty */
      242 
      243 	     non_live_log_ptr -> log_segment.previous_log_dir = ""; /* Prevent anyone from looking */
      244 	     live_log_ptr -> log_segment.previous_log_dir = log_data_$syserr_log_history_dir;
      245 
      246 	     call get_log_names ();
      247 
      248 	     call syserr_copy$unlock ();		/* don't lock directories under paged syserr lock */
      249 
      250 	     call set_log_names ();			/* Finally, reset the names */
      251 	end;
      252 
      253 	else do;
      254 	     code = error_table_$action_not_performed;	/* No, there wasn't */
      255 	     call syserr_copy$unlock ();
      256 	end;
      257 
      258 	P_code = code;
      259 	return;
      260 
      261 
      262 /* This entry is called by verify_lock to find out whether the syserr log
      263*   is locked, and, if so, by whom. It is unlocked if it is locked by the
      264*   faulting process, and copy signalling is turned off if the faulting
      265*   process is the copier. This entry *should* see very little use, since
      266*   in the new mechanism, the copier only does name swapping while the log
      267*   is locked, and does the copying itself from ring four. */
      268 
      269 syserr_seg_manager$verify_lock:
      270      entry () returns (bit (1) aligned);
      271 
      272 /* Don't lock first; if it's not locked by us, it's not our problem */
      273 
      274 	call get_log_ptrs ();
      275 
      276 	if (syserr_log_data.lock.pid ^= pds$processid) then
      277 	     return ("0"b);
      278 
      279 /* It's ours. Fix it */
      280 
      281 	if (syserr_log_data.copy_process_id = pds$processid) then do;
      282 	     call syserr (SYSERR_PRINT_WITH_ALARM,
      283 		"^a: crawlout with syserr log locked. Automatic syserr log copying disabled.", WHOAMI);
      284 
      285 	     syserr_log_data.copy_channel = 0;		/* Turn it off */
      286 	end;
      287 
      288 	call syserr_copy$unlock ();			/* Unlock it, regardless */
      289 
      290 	return ("1"b);
      291 
      292 
      293 /* This entrypoint is called only at answering service initialization time.
      294*   It makes sure that the sequence numbers in the ring 0 paged log (i.e. partition)
      295*   are consistant with what is found in the log history.  If not, we will fix
      296*   the sequence numbers in the partition and call upon syserr_copy to do likewise
      297*   for the wired log.  */
      298 
      299 syserr_seg_manager$verify_sequence:
      300      entry (P_last_history_sequence, P_new_sequence, P_code);
      301 
      302 	last_history_sequence = P_last_history_sequence;
      303 	new_sequence = P_new_sequence;
      304 
      305 	call syserr_copy$lock ();
      306 
      307 	call get_log_ptrs ();
      308 	log_segment_ptr = live_log_ptr;
      309 
      310 /* Check to see that at least one message is in the live log.  There should be
      311*   since init_syserr_log puts one in at system initialization time. */
      312 
      313 	if (log_segment.first_sequence = 0) then do;
      314 	     call syserr (SYSERR_CRASH_SYSTEM, "^a: No messages in live syserr log ^p.", WHOAMI, log_segment_ptr);
      315 	     call syserr_copy$unlock ();
      316 	     P_code = error_table_$action_not_performed;
      317 	     return;
      318 	end;
      319 
      320 	if (log_segment.first_sequence < last_history_sequence) then do;
      321 	     sequence_increment = new_sequence - log_segment.first_sequence;
      322 	     call syserr_copy_wired_log$adjust_wired_log_sequence (sequence_increment);
      323 
      324 /*  Now change all the sequence numbers in the live log segment. */
      325 
      326 	     log_segment.first_sequence = log_segment.first_sequence + sequence_increment;
      327 	     log_segment.last_sequence = log_segment.last_sequence + sequence_increment;
      328 	     call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Log message sequence numbers adjusted (in ^p) beginning at ^d.", WHOAMI, log_segment_ptr, log_segment.first_sequence);
      329 
      330 	     log_message_ptr = null ();		/* Force to first message */
      331 	     call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
      332 	     do while (log_message_ptr ^= null ());
      333 		log_message.sequence = log_message.sequence + sequence_increment;
      334 		call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
      335 	     end;
      336 
      337 /* and now check the non-live log, just in case */
      338 
      339 	     log_segment_ptr = non_live_log_ptr;
      340 
      341 	     if (log_segment.first_sequence ^= 0) then do;
      342 		log_segment.first_sequence = log_segment.first_sequence + sequence_increment;
      343 		log_segment.last_sequence = log_segment.last_sequence + sequence_increment;
      344 		call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Log message sequence numbers adjusted (in ^p) beginning at ^d.", WHOAMI, log_segment_ptr, log_segment.first_sequence);
      345 		log_message_ptr = null ();		/* Force to first message */
      346 		call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
      347 		do while (log_message_ptr ^= null ());
      348 		     log_message.sequence = log_message.sequence + sequence_increment;
      349 		     call log_position_$next_message (log_segment_ptr, log_message_ptr, ("0"b));
      350 		end;
      351 	     end;
      352 	end;
      353 
      354 	call syserr_copy$unlock ();
      355 	P_code = 0;
      356 
      357 	return;
      358 
      359 
      360 get_log_ptrs:
      361      procedure ();
      362 
      363 	syserr_log_data_ptr = addr (syserr_log_data$);
      364 
      365 	non_live_log = 3 - syserr_log_data.live_log;
      366 	live_log_ptr = syserr_log_data.log_ptr (syserr_log_data.live_log);
      367 	non_live_log_ptr = syserr_log_data.log_ptr (non_live_log);
      368 
      369 	return;
      370      end get_log_ptrs;
      371 
      372 
      373 /* These procedures ensure that the log segments have appropriate names.
      374*   They rename the live log to "syserr_log", and rename the non-live log
      375*   either to "syserr_log.empty" or "syserr_log.YYYYMMDD.HHMMSS", depending
      376*   on whether syserr_log_data.swap_time is non-zero. A non-zero value for
      377*   syserr_log_data.swap_time indicates that a swap has happened in ring zero,
      378*   caused by the daemon, but that the non-live log has not yet been copied
      379*   out to ring four.  Notice that the actual renaming is done NOT under the
      380*   paged lock.  This is because the paged lock is higher than the directory
      381*   lock on sl1 needed to rename the logs.  As such, the logs can get swapped
      382*   while we are renaming them.  However, it makes no difference to the user
      383*   ring if they get swapped right after we rename them, or during, since
      384*   user ring accesses to them aren't interlocked against ring 0 swapping
      385*   them anyway.  This can't hurt the Initializer's automatic copying, since
      386*   we won't return until the names are swapped, and swapping of logs could
      387*   occur anytime after this, and the Initializer must be prepared to cope. */
      388 
      389 get_log_names:
      390      procedure ();
      391 
      392 	non_live_log = 3 - syserr_log_data.live_log;
      393 
      394 	if (syserr_log_data.swap_time ^= 0) then
      395 	     non_live_name = log_name_$name (log_data_$syserr_log_name, syserr_log_data.swap_time);
      396 	else non_live_name = log_data_$syserr_log_empty_name;
      397 
      398 	return;
      399 
      400      end get_log_names;
      401 
      402 set_log_names: proc;
      403 
      404 declare  old_level fixed bin (3);
      405 
      406 	old_level = level$get ();			/* Log segments are 0,5,5, so we must run like this */
      407 	call level$set (0);				/* No cleanup handler needed-- ring_alarm will fix it */
      408 
      409 	call rename (1, (unique_chars_ (""b)));		/* Give them unique names briefly in order to avoid name conflicts */
      410 	call rename (2, (unique_chars_ (""b)));
      411 
      412 	call rename (syserr_log_data.live_log, log_data_$syserr_log_name);
      413 	call rename (non_live_log, non_live_name);
      414 
      415 	call level$set (old_level);
      416 
      417 	return;
      418 
      419 
      420 rename:
      421 	procedure (P_log, P_new_name);
      422 
      423 declare  P_log fixed bin parameter;
      424 declare  P_new_name char (32);
      425 
      426 	     if (P_log ^= 1) & (P_log ^= 2) then
      427 		call syserr (SYSERR_CRASH_SYSTEM, "^a: Attempt to rename invalid log index ^d", WHOAMI, P_log);
      428 
      429 	     if (P_new_name = syserr_log_data.log_name (P_log)) then do;
      430 		call syserr (SYSERR_PRINT_ON_CONSOLE, "^a: Attempt to rename log #^d already named ^a", WHOAMI, P_log, P_new_name);
      431 		return;
      432 	     end;
      433 
      434 	     call chname$cfile (syserr_log_data.log_dir,
      435 		syserr_log_data.log_name (P_log), syserr_log_data.log_name (P_log), P_new_name, code);
      436 
      437 	     if (code ^= 0) then
      438 		call syserr$error_code (SYSERR_PRINT_ON_CONSOLE, code, "^a: Cannot rename syserr log #^d from ^a to ^a for ^a",
      439 		     WHOAMI, P_log, syserr_log_data.log_name (P_log), P_new_name, pds$process_group_id);
      440 
      441 	     else syserr_log_data.log_name (P_log) = P_new_name; /* only we use this, so we can set without holding paged lock */
      442 
      443 	     return;
      444 	end rename;
      445      end set_log_names;
      446 
      447 /* format: off */
      448  /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  1     2 
  1     3 declare   log_segment_ptr               pointer;
  1     4 declare   log_segment_max_size          fixed bin (18);
  1     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  1     6 
  1     7 
  1     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  1     9           2 header                      aligned like log_segment_header,
  1    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  1    11 
  1    12 
  1    13 declare 1 log_segment_header            aligned based,
  1    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  1    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  1    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  1    17 
  1    18           2 limits,
  1    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  1    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  1    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  1    22             3 last_time                 fixed bin (71),
  1    23 
  1    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  1    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  1    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  1    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  1    28 
  1    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  1    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  1    31                                                             /* detect all the dead listeners after a reboot */
  1    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  1    33             3 process_id                bit (36) aligned,
  1    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  1    35 
  1    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  1    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  1    38 
  1    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  1    40 
  1    41 
  1    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  1    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  1    44 
  1    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      448 
      449  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  2     2 
  2     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  2     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  2     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  2     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  2     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  2     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  2     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  2    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  2    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  2    12 
  2    13 declare 1 log_message         aligned based (log_message_ptr),
  2    14           2 header            aligned like log_message_header,
  2    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  2    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  2    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  2    18 
  2    19 declare   log_message_ptr pointer;
  2    20 declare   log_message_text_lth fixed bin;
  2    21 declare   log_message_data_class_lth fixed bin;
  2    22 declare   log_message_data_lth fixed bin;
  2    23 
  2    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      449 
      450  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  3     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  3     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  3     4 
  3     5 /* This include file has an ALM version.  Keep 'em in sync! */
  3     6 
  3     7 dcl (
  3     8 
  3     9 /* The following constants define the message action codes.  This indicates
  3    10*how a message is to be handled.  */
  3    11 
  3    12      SYSERR_CRASH_SYSTEM	init (1),			
  3    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  3    14 
  3    15      SYSERR_TERMINATE_PROCESS	init (2),
  3    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  3    17 
  3    18      SYSERR_PRINT_WITH_ALARM	init (3),
  3    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  3    20 
  3    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  3    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  3    23 
  3    24      SYSERR_LOG_OR_PRINT	init (4),
  3    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  3    26 
  3    27      SYSERR_LOG_OR_DISCARD	init (5),
  3    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  3    29 
  3    30 
  3    31 /* The following constants are added to the normal severities to indicate
  3    32*different sorting classes of messages.  */
  3    33 
  3    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  3    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  3    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  3    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  3    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  3    39 	) fixed bin internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      450 
      451  /* BEGIN INCLUDE FILE ... syserr_log_dcls.incl.pl1 ... 84-08-17 ... W. Olin Sibert */
  4     2 /* Modified 1984-12-10, BIM: changed to a fast lock, added error count. */
  4     3 
  4     4 /* The syserr_log_data segment, made reverse-deciduous in >sl1, overlays the
  4     5*   first page of the LOG partition, and contains control information about
  4     6*   the other syserr_log segments. */
  4     7 
  4     8 declare   syserr_log_data$    fixed bin external static;
  4     9 declare   syserr_log_data_ptr pointer;
  4    10 
  4    11 declare 1 syserr_log_data     aligned based (syserr_log_data_ptr),
  4    12           2 version           char (8) unaligned,           /* SYSERR_LOG_DATA_V1 */
  4    13           2 old_init_word     char (4) unaligned,           /* Overlays slog.head.init_word ("INIT") */
  4    14 	2 pad003    	bit (1) aligned,
  4    15 
  4    16           2 live_log          fixed bin,                    /* Identifier of live log (#1 or #2) */
  4    17 	2 pad001		bit (1) aligned,
  4    18           2 error_count       fixed bin (35),               /* errors copying the log */
  4    19           2 swap_time         fixed bin (71),               /* Time of last log swap; zero if other_log_empty */
  4    20 
  4    21           2 messages_copied   fixed bin (35),               /* A meter */
  4    22           2 messages_lost     fixed bin (35),               /* Messages not copied because logs full */
  4    23 
  4    24           2 log_start (2)     fixed bin,                    /* Offset of each log segment in the partition */
  4    25           2 log_size (2)      fixed bin,                    /* Number of pages in each log segment */
  4    26 
  4    27           2 per_bootload,                                   /* Ramaining structure is reinitialized at each boot */
  4    28             3 log_ptr (2) pointer,                          /* Pointer to the three segments in the partition */
  4    29 
  4    30             3 log_name (2) char (32) unaligned,             /* Current names of log segments (by syserr_seg_manager) */
  4    31             3 log_dir char (168) unaligned,                 /* Parent directory */
  4    32 
  4    33             3 lock		aligned,
  4    34 	    4 pid		bit (36) aligned,             /* Standard format wait lock, used when updating log */
  4    35               4 event_id      fixed bin (35),
  4    36               4 notify_requested 
  4    37 	                    bit (1) unaligned,
  4    38 	    4 pad           bit (35) unaligned,
  4    39             3 take_a_fault    bit (1) aligned,              /* Forces a fault if on, for testing fault recovery */
  4    40             3 test_mode       bit (1) aligned,              /* Running in outer-ring test mode */
  4    41 
  4    42             3 copy_disabled   bit (1) aligned,              /* No more messages being copied into live log */
  4    43             3 drop_severity_5 bit (1) aligned,              /* No more severity 5 messages (log is 3/4 full) */
  4    44 	  3 wakeup_on_printable bit (1) aligned,	/* Console recovery: send wakeup for printable message */
  4    45 
  4    46             3 copy_threshold  fixed bin (18),               /* How often to copy to outer ring log segments */
  4    47             3 copy_channel    fixed bin (71),
  4    48             3 copy_process_id bit (36) aligned,
  4    49 
  4    50           2 pad fixed bin (71);                             /* Anything goes, as long as it's under a page */
  4    51 
  4    52 declare   SYSERR_LOG_DATA_V1 char (8) internal static options (constant) init ("syserr01");
  4    53 
  4    54 /* END INCLUDE FILE ... syserr_log_dcls.incl.p1l */
      451 
      452 
      453 /* BEGIN MESSAGE DOCUMENTATION
      454*
      455*   Message:
      456*   syserr_seg_manager: Crawlout with syserr log locked. Automatic syserr log copying disabled.
      457*
      458*   S:     $beep
      459*
      460*   T:     $run
      461*
      462*   M:     An fault has occurred in the Answering Service while copying syserr
      463*   messages from ring zero, and copying from ring zero has been disabled. This
      464*   probably indicates a supervisor logic error.
      465*   This will be followed by a message from verify_lock identifying the fault.
      466*
      467*   A:     Attempt to restart copying, or re-boot the system.
      468*
      469*
      470*   Message:
      471*   syserr_seg_manager: Attempt to rename invalid log index NNNN
      472*
      473*   S:     $crash
      474*
      475*   T:     $run
      476*
      477*   M:     $err
      478*
      479*   A:     $recover
      480*   Reinitialize the LOG partition with the BCE test_disk command if
      481*   this persists
      482*
      483*
      484*   Message:
      485*   syserr_seg_manager: Attempt to rename log #NNNN already named NAME
      486*
      487*   S:     $info
      488*
      489*   T:     $run
      490*
      491*   M:     $err
      492*
      493*   A:     $note
      494*
      495*
      496*   Message:
      497*   syserr_seg_manager: Cannot rename syserr log #NNNN from OLD-NAME to NEW-NAME for USER-NAME
      498*
      499*   S:     $info
      500*
      501*   T:     $run
      502*
      503*   M:     $err
      504*
      505*   A:     $note
      506*
      507*
      508*   Message:
      509*   syserr_seg_manager: No messages in live syserr log PTR.
      510*
      511*   S:     $crash
      512*
      513*   T:     $init
      514*
      515*   M:     $err
      516*   When attempting to verify the message sequence numbers in the live
      517*   syserr log, it was found that no messages were present.  This should
      518*   not hapen at this point because syserr log initialization (init_syserr_log)
      519*   always places a message in the log.
      520*
      521*   A:     $inform
      522*
      523*
      524*   Messaage:
      525*   syserr_seg_manager: Log message sequence numbers adjusted (in PTR) beginning at SEQUENCE.
      526*
      527*   S:	$info
      528*
      529*   T:	$init
      530*
      531*   M:	The sequence numbers in the log partition were found to preceed the
      532*   sequence numbers found in the log history.  Thus, the numbers in the
      533*   partition (and the wired log) were adjusted appropriately.  This
      534*   message indicates the new sequence number where the adjustment started
      535*   for each of the two ring 0 paged logs.  (This will occur after the
      536*   log partition has been damaged or manually cleared).
      537*
      538*   A:	$notify
      539*
      540*   END MESSAGE DOCUMENTATION
      541*   */
      542 
      543      end syserr_seg_manager;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0830.0  syserr_seg_manager.pl1            >special_ldd>install>MR12.3-1114>syserr_seg_manager.pl1
448          1    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
449          2    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
450          3    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
451          4    01/06/85  1422.2  syserr_log_dcls.incl.pl1          >ldd>include>syserr_log_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 50 set ref 196 228* 232 258* 299 316* 355*
P_copy_channel                         parameter       fixed bin(71,0)          dcl 51 ref 135 138
P_current_log_empty                    parameter       bit(1)                   dcl 52 set ref 178 191*
P_last_history_sequence                parameter       fixed bin(35,0)          dcl 53 ref 299 302
P_log                                  parameter       fixed bin(17,0)          dcl 423 set ref 420 426 426 426* 429 430* 434 434
                                                                                  437* 437 441
P_new_name                             parameter       char(32)                 packed unaligned dcl 424 set ref 420 429 430* 434*
                                                                                  437* 441
P_new_sequence                         parameter       fixed bin(35,0)          dcl 54 ref 299 303
P_page_threshold                       parameter       fixed bin(17,0)          dcl 55 ref 135 139
P_recovery_flag                        parameter       bit(1)                   dcl 56 ref 162 165
P_swap_time                            parameter       fixed bin(71,0)          dcl 57 set ref 178 190*
SYSERR_CRASH_SYSTEM             000027 constant        fixed bin(17,0)          initial dcl 3-7 set ref 314* 426*
SYSERR_PRINT_ON_CONSOLE         000021 constant        fixed bin(17,0)          initial dcl 3-7 set ref 328* 344* 430* 437*
SYSERR_PRINT_WITH_ALARM         000022 constant        fixed bin(17,0)          initial dcl 3-7 set ref 282*
WHOAMI                          000000 constant        char(32)                 initial packed unaligned dcl 96 set ref 282* 314*
                                                                                  328* 344* 426* 430* 437*
addr                                                   builtin function         dcl 98 ref 363
chname$cfile                    000030 constant        entry                    external dcl 83 ref 434
code                            000100 automatic       fixed bin(35,0)          dcl 59 set ref 204* 209* 225* 228 254* 258 434* 437
                                                                                  437*
copy_channel            130            based           fixed bin(71,0)          level 3 in structure "syserr_log_data" dcl 4-11
                                                                                  in procedure "syserr_seg_manager" set ref 147*
                                                                                  285*
copy_channel                    000102 automatic       fixed bin(71,0)          dcl 60 in procedure "syserr_seg_manager" set ref
                                                                                  138* 147
copy_process_id         132            based           bit(36)                  level 3 dcl 4-11 set ref 148* 281
copy_threshold          126            based           fixed bin(18,0)          level 3 dcl 4-11 set ref 145*
current_log_empty               000104 automatic       bit(1)                   dcl 61 set ref 186* 191
error_table_$action_not_performed
                                000024 external static fixed bin(35,0)          dcl 80 ref 204 254 316
error_table_$log_segment_empty  000026 external static fixed bin(35,0)          dcl 81 ref 209
first_sequence           56            based           fixed bin(35,0)          level 4 dcl 1-8 set ref 186 313 320 321 326* 326
                                                                                  328* 341 342* 342 344*
header                                 based           structure                level 2 in structure "log_segment" dcl 1-8
                                                                                  in procedure "syserr_seg_manager"
header                                 based           structure                level 2 in structure "log_message" dcl 2-13
                                                                                  in procedure "syserr_seg_manager"
last_history_sequence           000105 automatic       fixed bin(35,0)          dcl 62 set ref 302* 320
last_sequence            57            based           fixed bin(35,0)          level 4 dcl 1-8 set ref 208 327* 327 343* 343
level$get                       000032 constant        entry                    external dcl 84 ref 406
level$set                       000034 constant        entry                    external dcl 85 ref 407 415
limits                   56            based           structure                level 3 dcl 1-8
live_log                  4            based           fixed bin(17,0)          level 2 dcl 4-11 set ref 365 366 392 412*
live_log_ptr                    000106 automatic       pointer                  dcl 63 set ref 186 208 217 244 308 366*
lock                    116            based           structure                level 3 dcl 4-11
log_data_$syserr_log_dir        000010 external static char(168)                packed unaligned dcl 73 ref 217
log_data_$syserr_log_empty_name 000012 external static char(32)                 packed unaligned dcl 74 ref 396
log_data_$syserr_log_history_dir
                                000014 external static char(168)                packed unaligned dcl 75 ref 218 244
log_data_$syserr_log_name       000016 external static char(32)                 packed unaligned dcl 76 set ref 394* 412*
log_dir                  44            based           char(168)                level 3 packed packed unaligned dcl 4-11 set ref
                                                                                  434*
log_message                            based           structure                level 1 dcl 2-13
log_message_header                     based           structure                level 1 dcl 2-3
log_message_ptr                 000134 automatic       pointer                  dcl 2-19 set ref 330* 331* 332 333 333 334* 345*
                                                                                  346* 347 348 348 349*
log_name                 24            based           char(32)                 array level 3 packed packed unaligned dcl 4-11 set
                                                                                  ref 429 434* 434* 437* 441*
log_name_$name                  000036 constant        entry                    external dcl 86 ref 394
log_position_$next_message      000040 constant        entry                    external dcl 87 ref 331 334 346 349
log_ptr                  20            based           pointer                  array level 3 dcl 4-11 ref 366 367
log_segment                            based           structure                level 1 dcl 1-8
log_segment_header                     based           structure                level 1 dcl 1-13
log_segment_ptr                 000132 automatic       pointer                  dcl 1-3 set ref 308* 313 314* 320 321 326 326 327
                                                                                  327 328* 328 331* 334* 339* 341 342 342 343 343
                                                                                  344* 344 346* 349*
log_size                 16            based           fixed bin(17,0)          array level 2 dcl 4-11 ref 145 145
max                                                    builtin function         dcl 98 ref 145
min                                                    builtin function         dcl 98 ref 145
new_sequence                    000110 automatic       fixed bin(35,0)          dcl 64 set ref 303* 321
non_live_log                    000111 automatic       fixed bin(17,0)          dcl 65 set ref 365* 367 392* 413*
non_live_log_ptr                000112 automatic       pointer                  dcl 66 set ref 218 243 339 367*
non_live_name                   000114 automatic       char(32)                 packed unaligned dcl 67 set ref 394* 396* 413*
null                                                   builtin function         dcl 98 ref 330 332 345 347
old_level                       000166 automatic       fixed bin(3,0)           dcl 404 set ref 406* 415*
page_threshold                  000124 automatic       fixed bin(17,0)          dcl 68 set ref 139* 145
pds$process_group_id            000020 external static char(32)                 packed unaligned dcl 77 set ref 437*
pds$processid                   000022 external static bit(36)                  dcl 78 ref 148 276 281
per_bootload             20            based           structure                level 2 dcl 4-11
pid                     116            based           bit(36)                  level 4 dcl 4-11 ref 276
previous_log_dir          4            based           char(168)                level 3 packed packed unaligned dcl 1-8 set ref 217*
                                                                                  218* 243* 244*
recovery_flag                   000125 automatic       bit(1)                   dcl 69 set ref 165* 171
sequence                  1            based           fixed bin(35,0)          level 3 dcl 2-13 set ref 333* 333 348* 348
sequence_increment              000126 automatic       fixed bin(35,0)          dcl 70 set ref 321* 322* 326 327 333 342 343 348
swap_time                10            based           fixed bin(71,0)          level 2 in structure "syserr_log_data" dcl 4-11
                                                                                  in procedure "syserr_seg_manager" set ref 185 203
                                                                                  240 241* 394 394*
swap_time                       000130 automatic       fixed bin(71,0)          dcl 71 in procedure "syserr_seg_manager" set ref
                                                                                  185* 190
syserr                          000042 constant        entry                    external dcl 88 ref 282 314 328 344 426 430
syserr$error_code               000044 constant        entry                    external dcl 89 ref 437
syserr_copy$lock                000050 constant        entry                    external dcl 91 ref 113 141 167 181 199 236 305
syserr_copy$swap_logs           000054 constant        entry                    external dcl 93 ref 214
syserr_copy$unlock              000052 constant        entry                    external dcl 92 ref 120 150 173 188 205 210 222 248
                                                                                  255 288 315 354
syserr_copy_wired_log$adjust_wired_log_sequence
                                000046 constant        entry                    external dcl 90 ref 322
syserr_log_data                        based           structure                level 1 dcl 4-11
syserr_log_data$                000060 external static fixed bin(17,0)          dcl 4-8 set ref 363
syserr_log_data_ptr             000136 automatic       pointer                  dcl 4-9 set ref 145 145 145 147 148 171 185 203 240
                                                                                  241 276 281 285 363* 365 366 366 367 392 394 394
                                                                                  412 429 434 434 434 437 441
unique_chars_                   000056 constant        entry                    external dcl 94 ref 409 410
wakeup_on_printable     125            based           bit(1)                   level 3 dcl 4-11 set ref 171*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 3-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 3-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 3-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 3-7
LOG                                    internal static fixed bin(17,0)          initial dcl 3-7
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 1-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 1-42
LOG_SEGMENT_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 1-5
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_DATA_V1                     internal static char(8)                  initial packed unaligned dcl 4-52
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 3-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 3-7
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 2-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 2-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 2-20
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 1-4

NAMES DECLARED BY EXPLICIT CONTEXT.
get_log_names                   001354 constant        entry                    internal dcl 389 ref 118 220 246
get_log_ptrs                    001334 constant        entry                    internal dcl 360 ref 116 143 169 183 201 216 238 274
                                                                                  307
rename                          001526 constant        entry                    internal dcl 420 ref 409 410 412 413
set_log_names                   001412 constant        entry                    internal dcl 402 ref 122 224 250
syserr_seg_manager              000172 constant        entry                    external dcl 20
syserr_seg_manager$initialize_log_names
                                000203 constant        entry                    external dcl 110
syserr_seg_manager$reuse_empty_log
                                000551 constant        entry                    external dcl 232
syserr_seg_manager$segment_info 000367 constant        entry                    external dcl 178
syserr_seg_manager$set_recovery_flag
                                000323 constant        entry                    external dcl 162
syserr_seg_manager$start_copying
                                000241 constant        entry                    external dcl 135
syserr_seg_manager$swap_logs    000437 constant        entry                    external dcl 196
syserr_seg_manager$verify_lock  000642 constant        entry                    external dcl 269
syserr_seg_manager$verify_sequence
                                000743 constant        entry                    external dcl 299

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2506        2570    1764        2516
Length      3136    1764        62         332     522           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
syserr_seg_manager                  298 external procedure  is an external procedure.  
get_log_ptrs                            internal procedure  shares stack frame of external procedure syserr_seg_manager.  
get_log_names                           internal procedure  shares stack frame of external procedure syserr_seg_manager.  
set_log_names                           internal procedure  shares stack frame of external procedure syserr_seg_manager.  
rename                                  internal procedure  shares stack frame of external procedure syserr_seg_manager.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
syserr_seg_manager       000100 code                        syserr_seg_manager
                         000102 copy_channel                syserr_seg_manager
                         000104 current_log_empty           syserr_seg_manager
                         000105 last_history_sequence       syserr_seg_manager
                         000106 live_log_ptr                syserr_seg_manager
                         000110 new_sequence                syserr_seg_manager
                         000111 non_live_log                syserr_seg_manager
                         000112 non_live_log_ptr            syserr_seg_manager
                         000114 non_live_name               syserr_seg_manager
                         000124 page_threshold              syserr_seg_manager
                         000125 recovery_flag               syserr_seg_manager
                         000126 sequence_increment          syserr_seg_manager
                         000130 swap_time                   syserr_seg_manager
                         000132 log_segment_ptr             syserr_seg_manager
                         000134 log_message_ptr             syserr_seg_manager
                         000136 syserr_log_data_ptr         syserr_seg_manager
                         000166 old_level                   set_log_names

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          signal_op           ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
chname$cfile                  level$get                     level$set                     log_name_$name
log_position_$next_message    syserr                        syserr$error_code             syserr_copy$lock
syserr_copy$swap_logs         syserr_copy$unlock            syserr_copy_wired_log$adjust_wired_log_sequence
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$log_segment_empty
log_data_$syserr_log_dir      log_data_$syserr_log_empty_name
log_data_$syserr_log_history_dir                            log_data_$syserr_log_name     pds$process_group_id
pds$processid                 syserr_log_data$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000171       110 000201       113 000212       116 000216       118 000217       120 000220       122 000225
    124 000226       135 000235       138 000250       139 000253       141 000255       143 000262       145 000263
    147 000300       148 000302       150 000305       152 000311       162 000320       165 000332       167 000336
    169 000343       171 000344       173 000347       175 000354       178 000363       181 000376       183 000403
    185 000404       186 000407       188 000413       190 000420       191 000423       193 000425       196 000434
    199 000451       201 000456       203 000457       204 000462       205 000465       206 000471       208 000472
    209 000475       210 000500       211 000504       214 000505       216 000512       217 000513       218 000521
    220 000526       222 000527       224 000534       225 000535       228 000536       229 000540       232 000547
    236 000563       238 000570       240 000571       241 000574       243 000576       244 000602       246 000610
    248 000611       250 000616       251 000617       254 000620       255 000623       258 000627       259 000631
    269 000640       274 000650       276 000651       281 000667       282 000672       285 000715       288 000720
    290 000725       299 000737       302 000755       303 000760       305 000762       307 000767       308 000770
    313 000772       314 000775       315 001025       316 001032       317 001035       320 001044       321 001046
    322 001054       326 001063       327 001070       328 001074       330 001130       331 001132       332 001147
    333 001154       334 001161       335 001176       339 001177       341 001201       342 001204       343 001210
    344 001214       345 001250       346 001252       347 001267       348 001274       349 001301       350 001316
    354 001317       355 001324       357 001325       360 001334       363 001335       365 001340       366 001343
    367 001347       369 001353       389 001354       392 001355       394 001361       396 001404       398 001411
    402 001412       406 001413       407 001422       409 001432       410 001456       412 001502       413 001514
    415 001516       417 001525       420 001526       426 001530       429 001565       430 001600       431 001632
    434 001633       437 001663       441 001736       443 001747


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
