	COMPILATION LISTING OF SEGMENT rldr_vtoc_header_
	Compiled by: Multics PL/I Compiler, Release 33d, of April 24, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 92-04-27_1329.38_Mon_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1991   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       18*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       19*     Correct error message documentation.
       20*  2) change(86-05-15,Fawcett), approve(86-04-11,MCR7383),
       21*     audit(86-06-03,GWMay), install(86-07-17,MR12.0-1097):
       22*     Add support for 512_WORD_IO devices.
       23*  3) change(91-11-12,Schroth), approve(91-12-02,MCR8253),
       24*     audit(92-04-27,WAAnderson), install(92-04-27,MR12.5-1015):
       25*     Corrected call to rldr_report_$error_output that failed to pass rldr_datap
       26*     as first argument.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       30 
       31 rldr_vtoc_header_: proc;
       32 
       33 /* This routine manages  the vtoc header data base for the volume reloader.
       34*   It also maintains the VTOC map.
       35*
       36*   Probably written by Vinograd.
       37*   Modified April 1982 by J. Bongiovanni for the VTOC Map
       38*   Modified: 03/83 by GA Texada to support multiple physical volume reloading.
       39**/
       40 
       41 dcl code		     fixed bin (35);
       42 dcl old_vtocep	     ptr;
       43 dcl (vtocx, prev_vtocx, n_read, wordx, bitx, pvindex) fixed bin;
       44 dcl 1 free_vtoce	     like vtoce aligned;
       45 dcl 1 old_vtoce	     like vtoce aligned;
       46 dcl 1 l_vtoc_map	     aligned like vtoc_map;
       47 
       48 dcl myname	     char (32) int static init ("rldr_vtoc_header_") options (constant);
       49 
       50 dcl rldr_report_$error_output entry options (variable);
       51 dcl iox_$position	     entry (ptr, fixed bin, fixed bin, fixed bin (35));
       52 dcl iox_$get_chars	     entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
       53 dcl iox_$put_chars	     entry (ptr, ptr, fixed bin, fixed bin (35));
       54 
       55 dcl (addr, divide, mod, size, substr, unspec) builtin;
       56 
       57 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       58 
       59 
       60 open: entry (rldr_datap, pvindex, code);
       61 
       62 /* This entry initializes the vtoc header data base. */
       63 
       64 /* position to sector */
       65     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (DUMPER_BIT_MAP_ADDR), code);
       66     if code ^= 0 then do;
       67         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header position failed on ^a",
       68 	   rldr_data_.pvname (pvindex));
       69         return;
       70       end;
       71 						/* read vtoc header */
       72     call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.vtoc_headerp (pvindex),
       73          size (vtoc_header) * 4, n_read, code);
       74     if code ^= 0 then do;
       75         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header read failed on ^a",
       76 	   rldr_data_.pvname (pvindex));
       77         return;
       78       end;
       79 						/* set static variables */
       80     return;
       81 
       82 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       83 
       84 
       85 update: entry (rldr_datap, pvindex, code);
       86 close: entry (rldr_datap, pvindex, code);
       87 
       88 /* This entry updates the vtoc header on the physical volume from the data base */
       89 
       90 /* position to sector */
       91     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (DUMPER_BIT_MAP_ADDR), code);
       92     if code ^= 0 then do;
       93         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header position failed on ^a",
       94 	   rldr_data_.pvname (pvindex));
       95         return;
       96       end;
       97 						/* write vtoc header */
       98     call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.vtoc_headerp (pvindex),
       99          size (vtoc_header) * 4, code);
      100     if code ^= 0 then
      101       call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header write failed on ^a",
      102 	 rldr_data_.pvname (pvindex));
      103     return;
      104 
      105 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      106 
      107 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      108 
      109 
      110 build_vtoc_map: entry (rldr_datap, pvindex, code);
      111 
      112 /* This entry builds the map of free VTOCEs. init_vol set the VTOC map to
      113*   indicate that all VTOCEs are free. As this is likely no longer the case,
      114*   the map must be built. Each VTOCE in the local control data base is
      115*   examined. If it is not free, it is marked as in-use in the VTOC map. */
      116 
      117 /* set control variables and init structures */
      118     controlp = rldr_data_.controlp (pvindex);
      119     prev_vtocx = 0;
      120     unspec (free_vtoce) = "0"b;
      121     unspec (old_vtoce) = "0"b;
      122     vtocep = addr (free_vtoce);
      123     old_vtocep = addr (old_vtoce);
      124     vtoc_headerp = rldr_data_.vtoc_headerp (pvindex);
      125     vtoc_header.n_free_vtoce, code = 0;
      126     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (VTOC_MAP_ADDR), code);
      127     if code ^= 0 then do;
      128         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map position failed on ^a",
      129 	   rldr_data_.pvname (pvindex));
      130         return;
      131       end;
      132     call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), addr (l_vtoc_map), size (vtoc_map) * 4, n_read, code);
      133     if code ^= 0 then do;
      134         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map read failed on ^a",
      135 	   rldr_data_.pvname (pvindex));
      136         return;
      137       end;
      138     l_vtoc_map.n_free_vtoce = l_vtoc_map.n_vtoce;
      139 						/* scan all free vtoces */
      140     do vtocx = 0 to vtoc_header.n_vtoce - 1;
      141       if rldr_control (vtocx).uid ^= "0"b then do;	/* VTOCE in use */
      142 	l_vtoc_map.n_free_vtoce = l_vtoc_map.n_free_vtoce - 1;
      143 	wordx = divide (vtocx, 32, 17);
      144 	bitx = mod (vtocx, 32);
      145 	bit_map_wordp = addr (l_vtoc_map.bit_map (wordx));
      146 	substr (bit_map_word.bits, bitx + 1, 1) = "0"b;
      147         end;
      148     end;
      149 
      150     call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (VTOC_MAP_ADDR), code);
      151     if code ^= 0 then do;
      152         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map position failed on ^a",
      153 	   rldr_data_.pvname (pvindex));
      154         return;
      155       end;
      156     call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), addr (l_vtoc_map), size (vtoc_map) * 4, code);
      157     if code ^= 0 then do;
      158         call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map write failed on ^a",
      159 	   rldr_data_.pvname (pvindex));
      160         return;
      161       end;
      162     return;
      163 
      164 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      165 
      166 
      167 sector: proc (add) returns (fixed bin);
      168 
      169 /* This proc converts a Multics record number to a sector number */
      170 
      171 dcl add		     fixed bin;
      172 dcl (dev_idx, sector)    fixed bin;
      173 
      174     dev_idx = rldr_data_.disk_type (pvindex);
      175     sector = add * SECTORS_PER_RECORD (dev_idx);
      176     sector = sector + divide (sector, rldr_data_.usable_sectors (pvindex), 17, 0) * rldr_data_.unusable_sectors (pvindex);
      177     return (sector * words_per_sect (dev_idx) * 4);
      178 
      179   end sector;
      180 
  1     1 /* BEGIN INCLUDE FILE ... rldr_data_.incl.pl1 ... March 1976 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  1     6*     audit(86-05-22,GWMay), install(86-07-18,MR12.0-1098):
  1     7*     Add device_name to support the -pvname_device argument to reload.
  1     8*  2) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  1     9*     install(88-10-17,MR12.2-1173):
  1    10*     Added pointer and length values for use as an input_buffer for
  1    11*     intermediate reads.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 /* Severely modified 3/1/83 by GA Texada to support multiple physical */
  1    16 /*          volume reloading.				          */
  1    17 /*          Modified: 3/5/84 by GA Texada to make restart a per pv attribute */
  1    18 /*		  and add stranger flag.			*/
  1    19 
  1    20 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
  1    21 
  1    22 
  1    23 dcl rldr_datap	     ptr,
  1    24   rldr_data_max_pvs	     fixed bin,
  1    25 
  1    26   1 rldr_data_	     aligned based (rldr_datap),
  1    27     2 common	     like rldr_data_common,		/* only one of each needed			*/
  1    28     2 per_pv	     (rldr_data_max_pvs refer (rldr_data_.npvs)) like rldr_data_perpv,
  1    29 
  1    30   1 rldr_data_common     aligned,
  1    31     2 bits,
  1    32     ( 3 save	     bit (1),			/* if on can use disk pack restored by BOS */
  1    33       3 first_volume     bit (1),			/* if on indicates we are on first volume */
  1    34       3 rpv	     bit (1),			/* if on indicates we are reloading rpv */
  1    35       3 data_init	     bit (1),			/* if on data structure initialized to null state */
  1    36       3 arg_init	     bit (1),			/* on if arguments have been processed */
  1    37       3 disable_error_report bit (1),			/* if on will disable error messages */
  1    38       3 no_object	     bit (1),			/* if on only vtoces will be reloaded */
  1    39       3 err_online	     bit (1),			/* if on error messages written to error output */
  1    40       3 detach	     bit (1),			/* if on attached media will  be detached */
  1    41       3 brief	     bit (1),			/* if on brief mode enabled */
  1    42       3 manual	     bit (1),			/* if on operator will select input volumes */
  1    43       3 restart	     bit (1),			/* -restart was supplied			*/
  1    44       3 stranger	     bit (1),			/* ON if the pv's do not belong to the mounted RPV*/
  1    45       3 pad0	     bit (23)) unal,
  1    46       3 old_256K_switch  bit (2) aligned,		/* state of 256KW connection switch before we came along*/
  1    47       (3 last_pvid,					/* pvid of last good object read		*/
  1    48       3 rpv_pvid,					/* rpv pvid */
  1    49       3 rpv_lvid)	     bit (36),			/* rpv lvid */
  1    50       3 last_valid_puid  (0:15) bit (36),		/* last non-zero path uid read from input medium */
  1    51     2 chars,
  1    52     ( 3 sys_dir,					/* directory where vologs are */
  1    53       3 default_sys_dir) char (168),			/* default directory where vologs are */
  1    54       (3 last_valid_vtoce_ename,			/* last valid entry name from VTOCE */
  1    55       3 operator,					/* operator's name or initials */
  1    56       3 io_module)	     char (32),			/* name of io outer module used to read input */
  1    57       (3 input_volume_desc,				/* optional input medium attach description */
  1    58       3 output_volume_desc) char (256),			/* optional output medium attach description */
  1    59     2 fixed,
  1    60     ( 3 num_abandoned,				/* count these as we go along			*/
  1    61       3 last_vtocx,					/* vtocx of last valid object read		*/
  1    62       3 npvs,					/* the number of pv names given to the reload_volume command*/
  1    63       3 rpv_disk_type)   fixed bin,			/* model index of rpv disk drive */
  1    64       (3 start_time,				/* time reload started */
  1    65       3 from_time)	     fixed bin (71),		/*  time from which dump tapes should be skipped */
  1    66       3 input_buffer_len fixed bin (21),		/* length of the data in the read buffer */
  1    67       3 input_buffer_start fixed bin (21),		/* position in read buffer where new data begins */
  1    68     2 ptrs,
  1    69     ( 3 inputvol_iocbp,				/* iocb ptr for input */
  1    70       3 error_iocbp,				/* iocb ptr for error output */
  1    71       3 skip,					/* ptr to skip list */
  1    72       3 volume_record_bp,				/* ptr to temp seg containing most recent volume record */
  1    73       3 infop,					/* ptr to temp seg containig tdump info */
  1    74       3 data_object_bp,				/* ptr to temp seg containing most recent object from input medium */
  1    75       3 input_vol_lstp  ptr,				/* ptr to temp seg containing list of input media */
  1    76       3 input_buffer_ptr)  ptr,			/* ptr to read buffer */
  1    77  
  1    78 
  1    79   1 rldr_data_perpv	     aligned,			/* one entry per physical volume to be reloaded	*/
  1    80     2 flags,
  1    81       3 abandoned	     bit (1) unal,			/* we quit due to some error			*/
  1    82       3 restart	     bit (1),			/* if on unitialized volume ok and reload will restart */
  1    83       3 mbz0	     bit (34) unal,			/* beware, RFU				*/
  1    84     (2 pvname,					/* physical volume name */
  1    85     2 lvname,					/* logical volume name of physical volume being reloaded */
  1    86     2 disk_model)	     char (32),			/* model name of disk drive */
  1    87     2 device_name	     char (8),
  1    88     (2 lvid,					/* logical volume id of volume being reloaded */
  1    89     2 pvid)	     bit (36),			/* physical volume id of volume being reloaded */
  1    90     (2 prev_wordx,					/* index to fsmap */
  1    91     2 prev_bitx,					/* index to fsmap */
  1    92     2 disk_type,					/* model index of disk drive */
  1    93     2 usable_sectors,				/* usable sectors per cylinder of disk pack */
  1    94     2 unusable_sectors,				/* unusable sectors per cylinder of disk pack */
  1    95     2 n_vtoce)	     fixed bin,			/* number of vtoce on disk pack */
  1    96     (2 vtocbp,					/* ptr to vtoc buffer seg */
  1    97     2 vtoc_headerp,					/* ptr to temp seg containing the vtoc header */
  1    98     2 labelp,					/* ptr to temp seg containing pack label */
  1    99     2 bvlp,					/* ptr to volume log */
  1   100     2 outputvol_iocbp,				/* iocb ptr for output */
  1   101     2 controlp,					/* ptr to seg containing reload control info about vtoc */
  1   102     2 vol_mapp)	     ptr,				/* ptr to temp seg containing volume map */
  1   103 
  1   104   1 rldr_data_nulled_pv  aligned int static options (constant),
  1   105     2 flags,
  1   106       3 abandoned	     bit (1) init ("0"b) unal,
  1   107       3 restart	     bit (1) init ("0"b) unal,
  1   108       3 mbz0	     bit (34) init ((34)"0"b) unal,
  1   109       (2 pvname,
  1   110     2 lvname,
  1   111     2 disk_model)	     char (32) init (""),
  1   112     2 device_name	     char (8) init (""),
  1   113     (2 lvid,
  1   114     2 pvid)	     bit (36) init ("0"b),
  1   115     (2 prev_wordx,
  1   116     2 prev_bitx,
  1   117     2 disk_type,
  1   118     2 usable_sectors,
  1   119     2 unusable_sectors,
  1   120     2 n_vtoce)	     fixed bin init (0),
  1   121     (2 vtocbp,
  1   122     2 vtoc_headerp,
  1   123     2 labelp,
  1   124     2 bvlp,
  1   125     2 outputvol_iocbp,
  1   126     2 controlp,
  1   127     2 vol_mapp)	     ptr init (null ());
  1   128 
  1   129 
  1   130 /* END INCLUDE FILE rldr_data_.incl.pl1 */
      181 
      182 
  2     1 /* BEGIN INCLUDE FILE ...  rldr_control.incl.pll ... March 1976 */
  2     2 
  2     3 dcl  controlp ptr;					/* ptr to control segment */
  2     4 
  2     5 dcl 1 rldr_control based (controlp) aligned,		/* structure of control segment for reloader */
  2     6     2 curn_volname char (32),				/* volune name of present input volume */
  2     7     2 dir_num fixed bin,				/* number of directories reloaded */
  2     8     2 dir_rec fixed bin,				/* number of driectory records reloaded */
  2     9     2 seg_num fixed bin,				/* number of segments reloaded */
  2    10     2 seg_rec fixed bin,				/* number of segment records reloaded */
  2    11     2 input_vol_dir_num fixed bin,			/* number of directories reloaded from  input vol */
  2    12     2 input_vol_dir_rec fixed bin,			/* number of driectory records reloaded from  input vol */
  2    13     2 input_vol_seg_num fixed bin,			/* number of segments reloaded from input vol */
  2    14     2 input_vol_seg_rec fixed bin,			/* number of segment records reloaded from input vol */
  2    15     2 num_null_vtoce fixed bin,			/* number of null vtoce reloaded */
  2    16     2 num_rejected fixed bin,				/* number of data objects on input media that were skipped */
  2    17     2 curn_volid bit (36),				/* volume id of present input volume */
  2    18     2 label like label aligned,
  2    19     2 vol_map like  vol_map aligned,
  2    20     2 vtoc_header like  vtoc_header aligned,
  2    21     2 array (0 : 1),				/* look aside memory of vtoces reloaded */
  2    22       3 uid bit (36),				/* uid of reloaded vtoce */
  2    23       3 buffer_idx fixed bin,				/* index in vtoc buffer */
  2    24       3 time_dumped fixed bin(71),			/* time object dumped */
  2    25       3 volid bit (36);				/* volid of input volume vtoce reloaded from */
  2    26 
  2    27 /* END INCLUDE FILE ... rld_control.incl.pl1 */
      183 
      184 
  3     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  3     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  3     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  3     4 
  3     5 dcl  vtocep ptr;
  3     6 
  3     7 dcl 1 vtoce based (vtocep) aligned,
  3     8 
  3     9 
  3    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  3    11 
  3    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  3    13 
  3    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  3    16     2 records bit (9),				/* number of records used by the seg in second storage */
  3    17     2 pad2 bit (9),
  3    18 
  3    19     2 dtu bit (36),					/* date and time segment was last used */
  3    20 
  3    21     2 dtm bit (36),					/* date and time segment was last modified */
  3    22 
  3    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    24     2 deciduous bit (1),				/* true if hc_sdw */
  3    25     2 nid bit (1),					/* no incremental dump switch */
  3    26     2 dnzp bit (1),					/* Dont null zero pages */
  3    27     2 gtpd bit (1),					/* Global transparent paging device */
  3    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  3    29     2 damaged bit (1),				/* TRUE if contents damaged */
  3    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  3    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  3    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  3    33     2 pad3 bit (8),
  3    34     2 dirsw bit (1),				/* directory switch */
  3    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  3    36     2 pad4 bit (16)) unaligned,			/* not used */
  3    37 
  3    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  3    39 
  3    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    41 
  3    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    43 
  3    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  3    45 
  3    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  3    47 
  3    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  3    49 
  3    50 
  3    51 
  3    52 
  3    53 
  3    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  3    55 
  3    56     2 pad6 (10) bit (36),				/* not used */
  3    57 
  3    58     2 ncd bit (1),					/* no complete dump switch */
  3    59     2 pad7 bit (17),
  3    60     2 pad8 bit (18),
  3    61 
  3    62     2 dtd bit (36),					/* date-time-dumped */
  3    63 
  3    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  3    65 
  3    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  3    67 
  3    68 
  3    69 
  3    70 
  3    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  3    72 
  3    73     2 primary_name char (32),				/* primary name of the segment */
  3    74 
  3    75     2 time_created bit (36),				/* time the segment was created */
  3    76 
  3    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  3    78 
  3    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  3    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  3    81 
  3    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  3    83 
  3    84     2 access_class bit (72),				/* access class in branch */
  3    85     2 perm_flags aligned,
  3    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  3    87       3 pad9 bit (35) unal,
  3    88     2 owner bit (36);				/* pvid of this volume */
  3    89 
  3    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  3    91 
  3    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  3    93     2 pad1 bit (7*36),
  3    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    95     2 pad2 bit (184*36);
  3    96 
  3    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      185 
      186 
  4     1 /* Begin fs_dev_types_sector.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  4     7*     Add the sector differance for devices that do 64 word IO and devices that
  4     8*     do 512 word IO.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  4    12*	 need all the data in fs_dev_types. This is also included in
  4    13*	 fs_dev_types.incl.pl1  */
  4    14 
  4    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  4    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  4    17 
  4    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  4    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  4    20 
  4    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  4    22  /* table of # of sectors per record on each device */
  4    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  4    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    25 
  4    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  4    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    28 	
  4    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  4    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  4    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    32 
  4    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  4    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  4    35 
  4    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  4    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  4    38 
  4    39 /* End fs_dev_types_sector.incl.pl1 */
  4    40 
      187 
      188 
  5     1 /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  5     2 
  5     3 
  5     4 
  5     5 
  5     6 /****^  HISTORY COMMENTS:
  5     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  5     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  5     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  5    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  5    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  5    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  5    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  5    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  5    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18 
  5    19 /*
  5    20*   All disk packs have the standard layout described below:
  5    21*
  5    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  5    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  5    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  5    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  5    26*   Record  7		: formerly contained bad track list; no longer used.
  5    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  5    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  5    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  5    30*
  5    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  5    32*   of the particular partition.
  5    33*
  5    34*
  5    35*
  5    36*   A conceptual declaration for a disk pack could be:
  5    37*
  5    38*   dcl 1 disk_pack,
  5    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  5    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  5    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  5    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  5    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  5    44*   2 vtoc_array_records	(8 : n-1),
  5    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  5    46*   3 unused				bit(36 * 64),
  5    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  5    48*
  5    49*
  5    50*
  5    51*
  5    52**/
  5    53 
  5    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  5    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  5    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  5    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  5    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  5    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  5    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  5    61 		         fixed bin (17) int static options (constant);
  5    62 
  5    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  5    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  5    65 /* or the physical volume table entry (pvte) device type.		      */
  5    66 
  5    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  5    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  5    69 
  5    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  5    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  5    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  5    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    76 
  5    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      189 
      190 
  6     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  6     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  6     6*     Add the subvolume info.
  6     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6     9*     Added inconsistent_dbm bit used to determine consistency of volume
  6    10*     dumper bit maps.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  6    14 /* Note: fsout_vol clears pad fields before writing the label */
  6    15 
  6    16 dcl  labelp ptr;
  6    17 
  6    18 dcl 1 label based (labelp) aligned,
  6    19 
  6    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  6    21 
  6    22     2 gcos (5*64) fixed bin,
  6    23 
  6    24 /* Now we have the Multics label */
  6    25 
  6    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  6    27     2 version fixed bin,				/* Version 1 */
  6    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  6    29     2 pv_name char (32),				/* Physical volume name. */
  6    30     2 lv_name char (32),				/* Name of logical volume for pack */
  6    31     2 pvid bit (36),				/* Unique ID of this pack */
  6    32     2 lvid bit (36),				/* unique ID of its logical vol */
  6    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  6    34     2 time_registered fixed bin (71),			/* time imported to system */
  6    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  6    36     2 vol_size fixed bin,				/* total size of volume, in records */
  6    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  6    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  6    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  6    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  6    41     2 flagpad bit (33) unal,
  6    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  6    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  6    44     2 password bit (72),				/* not yet used */
  6    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  6    46     2 this_sv fixed bin,				/* what subvolume number it is */
  6    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  6    48     2 pad1 (13) fixed bin,
  6    49     2 time_mounted fixed bin (71),			/* time mounted */
  6    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  6    51 
  6    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  6    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  6    54* */
  6    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  6    56     2 pad6 fixed bin,				
  6    57 
  6    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  6    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  6    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  6    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  6    62     2 pad1a (2) fixed bin,
  6    63     2 err_hist_size fixed bin,			/* size of pack error history */
  6    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  6    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  6    66     2 pad2 (40) fixed bin,
  6    67     2 root,
  6    68       3 here bit (1),				/* TRUE if the root is on this pack */
  6    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  6    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  6    71       3 pad7 bit (1) aligned,				
  6    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  6    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  6    74       3 esd_state fixed bin,				/* State of esd */
  6    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  6    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  6    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  6    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  6    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  6    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  6    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  6    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  6    83     2 pad3 (52) fixed bin,
  6    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  6    85     2 parts (47),
  6    86       3 part char (4),				/* Name of partition */
  6    87       3 frec fixed bin,				/* First record */
  6    88       3 nrec fixed bin,				/* Number of records */
  6    89       3 pad5 fixed bin,
  6    90     2 pad4 (5*64) fixed bin;
  6    91 
  6    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  6    93 
  6    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      191 
      192 
  7     1 /* BEGIN INCLUDE FILE ... vtoc_header.incl.pl1 */
  7     2 
  7     3 dcl  vtoc_headerp ptr;
  7     4 
  7     5 dcl 1 vtoc_header based (vtoc_headerp) aligned,
  7     6 
  7     7     2 version fixed bin (17),				/* version number. The current version number is 1. * */
  7     8     2 n_vtoce fixed bin (17),				/* number of vtoc entries */
  7     9     2 vtoc_last_recno fixed bin (17),			/* record number of the last record of the vtoc */
  7    10     2 n_free_vtoce fixed bin (17),			/* number of free vtoc entries */
  7    11     2 first_free_vtocx fixed bin (17),			/* index of the first vtoce in the free list */
  7    12     2 pad (3) bit (36),
  7    13     2 dmpr_bit_map (2048 - 8) bit (36);			/* space for dmpr bit map */
  7    14 
  7    15 /* END INCLUDE ... vtoc_header */
  7    16 
      193 
  8     1 /* BEGIN INCLUDE FILE ... vol_map.incl.pl1 */
  8     2 
  8     3 dcl   vol_mapp	ptr;
  8     4 
  8     5 dcl 1 vol_map based (vol_mapp) aligned,
  8     6 
  8     7     2 n_rec fixed bin(17),				/* number of records represented in the map */
  8     8     2 base_add fixed bin(17),				/* record number for first bit in bit map */
  8     9     2 n_free_rec fixed bin(17),			/* number of free records */
  8    10     2 bit_map_n_words fixed bin(17),			/* number of words of the bit map */
  8    11     2 pad (60) bit(36),				/* pad to 64 words */
  8    12     2 bit_map (3*1024 - 64) bit(36) ;			/* bit map - the entire vol map occupies 3 records */
  8    13 
  8    14 /* END INCLUDE ... vol_map */
      194 
  9     1 /*  START OF:	vtoc_map.incl.pl1	... March 1982 ...	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3      dcl	   vtoc_mapp	      ptr;
  9     4      dcl	   bit_map_wordp	      ptr;
  9     5 
  9     6      dcl	   1 vtoc_map	      aligned based (vtoc_mapp),
  9     7 	     2 n_vtoce	      fixed bin,		/* Number of VTOCEs on the device */
  9     8 	     2 n_free_vtoce	      fixed bin,		/* Number of free VTOCEs */
  9     9 	     2 bit_map_n_words    fixed bin,		/* Number of words in the bit map below */
  9    10 	     2 vtoc_last_recno    fixed bin,		/* Last record number in VTOC */
  9    11 	     2 pad	      (4) fixed bin,
  9    12 	     2 bit_map	      (0:1024 - 9) bit (36);	/* This structure consumes exactly 1 page */
  9    13 
  9    14      dcl	   1 bit_map_word	      aligned based (bit_map_wordp),
  9    15 	     2 pad1	      bit (1) unal,
  9    16 	     2 bits	      bit (32) unal,	/* 32 VTOCES ON => free */
  9    17 	     2 pad2	      bit (3) unal;
  9    18 
  9    19 
  9    20 
  9    21 /*  END OF:	vtoc_map.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      195 
      196 
      197 /* BEGIN MESSAGE DOCUMENTATION
      198*
      199*   Message:
      200*   rldr_vtoc_header_: VTOC header position failed
      201*
      202*   S:	$rld_out
      203*
      204*   T:	$reload
      205*
      206*   M:	An error occurred writing out the VTOC header for an output volume.
      207*
      208*   A:	$inform
      209*
      210*
      211*   Message:
      212*   rldr_vtoc_header_: VTOC header read failed
      213*
      214*   S:	$rld_out
      215*
      216*   T:	$reload
      217*
      218*   M:	An error occurred writing out the VTOC header for an output volume.
      219*
      220*   A:	$inform
      221*
      222*
      223*   Message:
      224*   rldr_vtoc_header_: VTOC header position failed
      225*
      226*   S:	$rld_out
      227*
      228*   T:	$reload
      229*
      230*   M:	An error occurred writing out the VTOC header for an output volume.
      231*
      232*   A:	$inform
      233*
      234*
      235*   Message:
      236*   rldr_vtoc_header_: VTOC header write failed
      237*
      238*   S:	$rld_out
      239*
      240*   T:	$reload
      241*
      242*   M:	An error occurred writing out the VTOC header for an output volume.
      243*
      244*   A:	$inform
      245*
      246*
      247*   Message:
      248*   rldr_vtoc_header_: VTOC map position failed
      249*
      250*   S:     $rld_out
      251*
      252*   T:	$reload
      253*
      254*   M:	An error occurred writing out the VTOC map for an output volume.
      255*
      256*   A:	$inform
      257*
      258*   Message:
      259*   rldr_vtoc_header_: VTOC map read failed
      260*
      261*   S:     $rld_out
      262*
      263*   T:	$reload
      264*
      265*   M:	An error occurred reading the VTOC map for an output volume.
      266*
      267*   A:	$inform
      268*
      269*   Message:
      270*   rldr_vtoc_header_: VTOC map write failed
      271*
      272*   S:     $rld_out
      273*
      274*   T:	$reload
      275*
      276*   M:	An error occurred writing out the VTOC map for an output volume.
      277*
      278*   A:	$inform
      279*
      280*
      281*
      282*   END MESSAGE DOCUMENTATION */
      283 
      284   end rldr_vtoc_header_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/27/92  1329.3  rldr_vtoc_header_.pl1             >spec>install>1015>rldr_vtoc_header_.pl1
181          1    10/18/88  1315.0  rldr_data_.incl.pl1               >ldd>incl>rldr_data_.incl.pl1
183          2    04/01/81  0930.5  rldr_control.incl.pl1             >ldd>incl>rldr_control.incl.pl1
185          3    10/04/83  1205.1  vtoce.incl.pl1                    >ldd>incl>vtoce.incl.pl1
187          4    07/24/86  2151.8  fs_dev_types_sector.incl.pl1      >ldd>incl>fs_dev_types_sector.incl.pl1
189          5    10/22/86  1550.1  disk_pack.incl.pl1                >ldd>incl>disk_pack.incl.pl1
191          6    07/21/88  2136.0  fs_vol_label.incl.pl1             >ldd>incl>fs_vol_label.incl.pl1
193          7    05/23/77  1019.3  vtoc_header.incl.pl1              >ldd>incl>vtoc_header.incl.pl1
194          8    04/29/76  1150.5  vol_map.incl.pl1                  >ldd>incl>vol_map.incl.pl1
195          9    05/27/82  1625.9  vtoc_map.incl.pl1                 >ldd>incl>vtoc_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DUMPER_BIT_MAP_ADDR                    constant        fixed bin(17,0)          initial dcl 5-54 set ref 65* 65* 91* 91*
SECTORS_PER_RECORD              000000 constant        fixed bin(17,0)          initial array dcl 5-74 ref 175
VTOC_MAP_ADDR                          constant        fixed bin(17,0)          initial dcl 5-54 set ref 126* 126* 150* 150*
add                                    parameter       fixed bin(17,0)          dcl 171 ref 167 175
addr                                                   builtin function         dcl 55 ref 122 123 132 132 145 156 156
array                 14024            based           structure                array level 2 dcl 2-5
bit_map                  10     000707 automatic       bit(36)                  array level 2 dcl 46 set ref 145
bit_map_word                           based           structure                level 1 dcl 9-14
bit_map_wordp                   003436 automatic       pointer                  dcl 9-4 set ref 145* 146
bits                      0(01)        based           bit(32)                  level 2 packed packed unaligned dcl 9-14 set ref
                                                                                  146*
bitx                            000106 automatic       fixed bin(17,0)          dcl 43 set ref 144* 146
code                                   parameter       fixed bin(35,0)          dcl 41 set ref 60 65* 66 67* 72* 74 75* 85 86 91* 92
                                                                                  93* 98* 100 100* 110 125* 126* 127 128* 132* 133
                                                                                  134* 150* 151 152* 156* 157 158*
controlp                514            based           pointer                  array level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "rldr_vtoc_header_" ref 118
controlp                        003430 automatic       pointer                  dcl 2-3 in procedure "rldr_vtoc_header_" set ref
                                                                                  118* 141
dev_idx                         003450 automatic       fixed bin(17,0)          dcl 172 set ref 174* 175 177
disk_type               475            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 174
divide                                                 builtin function         dcl 55 ref 143 176
free_vtoce                      000107 automatic       structure                level 1 dcl 44 set ref 120* 122
iox_$get_chars                  000014 constant        entry                    external dcl 52 ref 72 132
iox_$position                   000012 constant        entry                    external dcl 51 ref 65 91 126 150
iox_$put_chars                  000016 constant        entry                    external dcl 53 ref 98 156
l_vtoc_map                      000707 automatic       structure                level 1 dcl 46 set ref 132 132 156 156
label                                  based           structure                level 1 dcl 6-18
mod                                                    builtin function         dcl 55 ref 144
myname                          000022 constant        char(32)                 initial packed unaligned dcl 48 set ref 67* 75* 93*
                                                                                  100* 128* 134* 152* 158*
n_free_vtoce              1     000707 automatic       fixed bin(17,0)          level 2 in structure "l_vtoc_map" dcl 46
                                                                                  in procedure "rldr_vtoc_header_" set ref 138* 142*
                                                                                  142
n_free_vtoce              3            based           fixed bin(17,0)          level 2 in structure "vtoc_header" dcl 7-5
                                                                                  in procedure "rldr_vtoc_header_" set ref 125*
n_read                          000104 automatic       fixed bin(17,0)          dcl 43 set ref 72* 132*
n_vtoce                   1            based           fixed bin(17,0)          level 2 in structure "vtoc_header" dcl 7-5
                                                                                  in procedure "rldr_vtoc_header_" ref 140
n_vtoce                         000707 automatic       fixed bin(17,0)          level 2 in structure "l_vtoc_map" dcl 46
                                                                                  in procedure "rldr_vtoc_header_" set ref 138
old_vtoce                       000407 automatic       structure                level 1 dcl 45 set ref 121* 123
old_vtocep                      000100 automatic       pointer                  dcl 42 set ref 123*
outputvol_iocbp         512            based           pointer                  array level 3 dcl 1-23 set ref 65* 72* 91* 98* 126*
                                                                                  132* 150* 156*
per_pv                  434            based           structure                array level 2 dcl 1-23
prev_vtocx                      000103 automatic       fixed bin(17,0)          dcl 43 set ref 119*
pvindex                                parameter       fixed bin(17,0)          dcl 43 ref 60 65 67 72 72 75 85 86 91 93 98 98 100
                                                                                  110 118 124 126 128 132 134 150 152 156 158 174
                                                                                  176 176
pvname                  437            based           char(32)                 array level 3 dcl 1-23 set ref 67* 75* 93* 100* 128*
                                                                                  134* 152* 158*
rldr_control                           based           structure                level 1 dcl 2-5
rldr_data_                             based           structure                level 1 dcl 1-23
rldr_data_common                002710 automatic       structure                level 1 dcl 1-23
rldr_data_perpv                 003344 automatic       structure                level 1 dcl 1-23
rldr_datap                             parameter       pointer                  dcl 1-23 set ref 60 65 67* 67 72 72 75* 75 85 86 91
                                                                                  93* 93 98 98 100* 100 110 118 124 126 128* 128 132
                                                                                  134* 134 150 152* 152 156 158* 158 174 176 176
rldr_report_$error_output       000010 constant        entry                    external dcl 50 ref 67 75 93 100 128 134 152 158
sector                          003451 automatic       fixed bin(17,0)          dcl 172 set ref 175* 176* 176 176 177
size                                                   builtin function         dcl 55 ref 72 98 132 156
substr                                                 builtin function         dcl 55 set ref 146*
uid                   14024            based           bit(36)                  array level 3 dcl 2-5 ref 141
unspec                                                 builtin function         dcl 55 set ref 120* 121*
unusable_sectors        477            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 176
usable_sectors          476            based           fixed bin(17,0)          array level 3 dcl 1-23 ref 176
vol_map                                based           structure                level 1 dcl 8-5
vtoc_header                            based           structure                level 1 dcl 7-5 set ref 72 98
vtoc_headerp                    003434 automatic       pointer                  dcl 7-3 in procedure "rldr_vtoc_header_" set ref 72
                                                                                  98 124* 125 140
vtoc_headerp            504            based           pointer                  array level 3 in structure "rldr_data_" dcl 1-23
                                                                                  in procedure "rldr_vtoc_header_" set ref 72* 98*
                                                                                  124
vtoc_map                               based           structure                level 1 dcl 9-6 ref 132 156
vtoc_mapp                              automatic       pointer                  dcl 9-3 ref 132 156
vtoce                                  based           structure                level 1 dcl 3-7
vtocep                          003432 automatic       pointer                  dcl 3-5 set ref 122*
vtocx                           000102 automatic       fixed bin(17,0)          dcl 43 set ref 140* 141 143 144*
words_per_sect                  000011 constant        fixed bin(17,0)          initial array dcl 4-36 ref 177
wordx                           000105 automatic       fixed bin(17,0)          dcl 43 set ref 143* 145

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 5-54
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 5-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 5-54
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 6-92
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 5-67
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 5-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 5-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 5-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 5-68
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 5-54
labelp                                 automatic       pointer                  dcl 6-16
rldr_data_max_pvs                      automatic       fixed bin(17,0)          dcl 1-23
rldr_data_nulled_pv                    internal static structure                level 1 dcl 1-23
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 4-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 4-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 4-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 4-26
seg_vtoce                              based           structure                level 1 dcl 3-92
vol_mapp                               automatic       pointer                  dcl 8-3
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-29
vtoce_parts                            based           bit(2304)                array dcl 3-90

NAMES DECLARED BY EXPLICIT CONTEXT.
build_vtoc_map                  000553 constant        entry                    external dcl 110
close                           000353 constant        entry                    external dcl 86
open                            000140 constant        entry                    external dcl 60
rldr_vtoc_header_               000126 constant        entry                    external dcl 31
sector                          001237 constant        entry                    internal dcl 167 ref 65 65 91 91 126 126 150 150
update                          000343 constant        entry                    external dcl 85

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1434        1454    1321        1444
Length      2020    1321        20         327     113           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rldr_vtoc_header_                  1873 external procedure  is an external procedure.  
sector                                  internal procedure  shares stack frame of external procedure rldr_vtoc_header_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rldr_vtoc_header_        000100 old_vtocep                  rldr_vtoc_header_
                         000102 vtocx                       rldr_vtoc_header_
                         000103 prev_vtocx                  rldr_vtoc_header_
                         000104 n_read                      rldr_vtoc_header_
                         000105 wordx                       rldr_vtoc_header_
                         000106 bitx                        rldr_vtoc_header_
                         000107 free_vtoce                  rldr_vtoc_header_
                         000407 old_vtoce                   rldr_vtoc_header_
                         000707 l_vtoc_map                  rldr_vtoc_header_
                         002710 rldr_data_common            rldr_vtoc_header_
                         003344 rldr_data_perpv             rldr_vtoc_header_
                         003430 controlp                    rldr_vtoc_header_
                         003432 vtocep                      rldr_vtoc_header_
                         003434 vtoc_headerp                rldr_vtoc_header_
                         003436 bit_map_wordp               rldr_vtoc_header_
                         003450 dev_idx                     sector
                         003451 sector                      sector

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$get_chars                iox_$position                 iox_$put_chars                rldr_report_$error_output

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
001270  aa     000004000000
001271  aa     000000000000
001272  ta     000041000000
001273  aa     000000000000
001274  aa     600000000041
001275  aa     003454000000

001276  aa     000004000000
001277  aa     000000000000
001300  ta     000041000000
001301  aa     000000000000
001302  aa     600000000041
001303  aa     003452000000

001304  aa     000004000000
001305  aa     000000000000
001306  ta     000042000000
001307  aa     000000000000
001310  aa     600000000041
001311  aa     003453000000

001312  aa     000004000000
001313  aa     000000000000
001314  ta     000042000000
001315  aa     000000000000
001316  aa     600000000041
001317  aa     003454000000

000000  aa     000000000000
000001  aa     000000000020
000002  aa     000000000020
000003  aa     000000000020
000004  aa     000000000020
000005  aa     000000000020
000006  aa     000000000020
000007  aa     000000000002
000010  aa     000000000002

000011  aa     000000000000
000012  aa     000000000100
000013  aa     000000000100
000014  aa     000000000100
000015  aa     000000000100
000016  aa     000000000100
000017  aa     000000000100
000020  aa     000000001000
000021  aa     000000001000

000022  aa  162 154 144 162	rldr
000023  aa  137 166 164 157	_vto
000024  aa  143 137 150 145	c_he
000025  aa  141 144 145 162	ader
000026  aa  137 040 040 040	_   
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa  040 040 040 040	    

000032  aa     524000000033

001320  aa     000000000040

000033  aa     524000000032

000034  aa     524000000036

000035  aa     524000000035

000036  aa     524000000040

000037  aa     524000000041

000040  aa     526000000040

000041  aa     000000000006

000042  aa     000000000004

000043  aa     464000000000

000044  aa     404000000021

000045  aa     404000000043

000046  aa  126 124 117 103	VTOC
000047  aa  040 155 141 160	 map
000050  aa  040 167 162 151	 wri
000051  aa  164 145 040 146	te f
000052  aa  141 151 154 145	aile
000053  aa  144 040 157 156	d on
000054  aa  040 136 141 000	 ^a

000055  aa  126 124 117 103	VTOC
000056  aa  040 155 141 160	 map
000057  aa  040 162 145 141	 rea
000060  aa  144 040 146 141	d fa
000061  aa  151 154 145 144	iled
000062  aa  040 157 156 040	 on 
000063  aa  136 141 000 000	^a

000064  aa  126 124 117 103	VTOC
000065  aa  040 155 141 160	 map
000066  aa  040 160 157 163	 pos
000067  aa  151 164 151 157	itio
000070  aa  156 040 146 141	n fa
000071  aa  151 154 145 144	iled
000072  aa  040 157 156 040	 on 
000073  aa  136 141 000 000	^a

000074  aa  126 124 117 103	VTOC
000075  aa  040 150 145 141	 hea
000076  aa  144 145 162 040	der 
000077  aa  167 162 151 164	writ
000100  aa  145 040 146 141	e fa
000101  aa  151 154 145 144	iled
000102  aa  040 157 156 040	 on 
000103  aa  136 141 000 000	^a

000104  aa  126 124 117 103	VTOC
000105  aa  040 150 145 141	 hea
000106  aa  144 145 162 040	der 
000107  aa  162 145 141 144	read
000110  aa  040 146 141 151	 fai
000111  aa  154 145 144 040	led 
000112  aa  157 156 040 136	on ^
000113  aa  141 000 000 000	a

000114  aa  126 124 117 103	VTOC
000115  aa  040 150 145 141	 hea
000116  aa  144 145 162 040	der 
000117  aa  160 157 163 151	posi
000120  aa  164 151 157 156	tion
000121  aa  040 146 141 151	 fai
000122  aa  154 145 144 040	led 
000123  aa  157 156 040 136	on ^
000124  aa  141 000 000 000	a

BEGIN PROCEDURE rldr_vtoc_header_
ENTRY TO rldr_vtoc_header_                                  STATEMENT 1 ON LINE 31
rldr_vtoc_header_: proc;

000125  da     000061200000
000126  aa   003540 6270 00	eax7 	1888
000127  aa  7 00034 3521 20	epp2 	pr7|28,*
000130  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000131  aa     000000000000
000132  aa     000000000000
						STATEMENT 1 ON LINE 60
open: entry (rldr_datap, pvindex, code);

000133  aa   000012 7100 04	tra  	10,ic		000145
ENTRY TO open                                               STATEMENT 1 ON LINE 60
open: entry (rldr_datap, pvindex, code);

000134  at     000003000043
000135  tt     000044000045
000136  ta     000134000000
000137  da     000066300000
000140  aa   003540 6270 00	eax7 	1888
000141  aa  7 00034 3521 20	epp2 	pr7|28,*
000142  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000143  aa     000006000000
000144  aa     000000000000
						STATEMENT 1 ON LINE 65
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (DUMPER_BIT_MAP_ADDR), code);

000145  aa  6 00032 3735 20	epp7 	pr6|26,*
000146  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000147  aa   000064 4020 07	mpy  	52,dl
000150  aa  6 03453 7561 00	stq  	pr6|1835
000151  aa   000002 2360 07	ldq  	2,dl
000152  aa  6 03452 7561 00	stq  	pr6|1834
000153  aa   001137 3520 04	epp2 	607,ic		001312 = 000004000000
000154  aa   001063 6700 04	tsp4 	563,ic		001237
000155  aa  6 00032 3735 20	epp7 	pr6|26,*
000156  aa  6 03453 7271 00	lxl7 	pr6|1835
000157  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000160  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000161  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000162  aa  6 03460 2521 00	spri2	pr6|1840
000163  aa  6 03452 3521 00	epp2 	pr6|1834
000164  aa  6 03462 2521 00	spri2	pr6|1842
000165  aa  6 03454 3521 00	epp2 	pr6|1836
000166  aa  6 03464 2521 00	spri2	pr6|1844
000167  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000170  aa  6 03466 2521 00	spri2	pr6|1846
000171  aa  6 03456 6211 00	eax1 	pr6|1838
000172  aa   020000 4310 07	fld  	8192,dl
000173  aa  6 00044 3701 20	epp4 	pr6|36,*
000174  la  4 00012 3521 20	epp2 	pr4|10,*		iox_$position
000175  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 66
    if code ^= 0 then do;

000176  aa  6 00032 3735 20	epp7 	pr6|26,*
000177  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000200  aa   000044 6000 04	tze  	36,ic		000244
						STATEMENT 1 ON LINE 67
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header position failed on ^a",
	   rldr_data_.pvname (pvindex));

000201  aa   777635 2360 04	ldq  	-99,ic		000036 = 524000000040
000202  aa  6 03454 7561 00	stq  	pr6|1836
000203  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000204  aa   777711 00 0044	desc9a	-55,36		000114 = 126124117103
000205  aa  6 03456 00 0044	desc9a	pr6|1838,36
000206  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000207  aa   000064 4020 07	mpy  	52,dl
000210  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000211  aa  6 03472 2521 00	spri2	pr6|1850
000212  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000213  aa  6 03474 2521 00	spri2	pr6|1852
000214  aa   777606 3520 04	epp2 	-122,ic		000022 = 162154144162
000215  aa  6 03476 2521 00	spri2	pr6|1854
000216  aa  6 03456 3521 00	epp2 	pr6|1838
000217  aa  6 03500 2521 00	spri2	pr6|1856
000220  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000221  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000222  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000223  aa  6 03502 2521 00	spri2	pr6|1858
000224  aa   777617 3520 04	epp2 	-113,ic		000043 = 464000000000
000225  aa  6 03504 2521 00	spri2	pr6|1860
000226  aa   777617 3520 04	epp2 	-113,ic		000045 = 404000000043
000227  aa  6 03506 2521 00	spri2	pr6|1862
000230  aa   777610 3520 04	epp2 	-120,ic		000040 = 526000000040
000231  aa  6 03510 2521 00	spri2	pr6|1864
000232  aa   777605 3520 04	epp2 	-123,ic		000037 = 524000000041
000233  aa  6 03512 2521 00	spri2	pr6|1866
000234  aa  6 03454 3521 00	epp2 	pr6|1836
000235  aa  6 03514 2521 00	spri2	pr6|1868
000236  aa  6 03470 6211 00	eax1 	pr6|1848
000237  aa   024000 4310 07	fld  	10240,dl
000240  aa  6 00044 3701 20	epp4 	pr6|36,*
000241  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
000242  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 69
        return;

000243  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 70
      end;

						STATEMENT 1 ON LINE 72
    call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.vtoc_headerp (pvindex),
         size (vtoc_header) * 4, n_read, code);

000244  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000245  aa   000064 4020 07	mpy  	52,dl
000246  aa   000000 6270 06	eax7 	0,ql
000247  aa   020000 2360 07	ldq  	8192,dl
000250  aa  6 03454 7561 00	stq  	pr6|1836
000251  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000252  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000253  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000254  aa  6 03472 2521 00	spri2	pr6|1850
000255  aa  5 00420 3521 17	epp2 	pr5|272,7		rldr_data_.vtoc_headerp
000256  aa  6 03474 2521 00	spri2	pr6|1852
000257  aa  6 03454 3521 00	epp2 	pr6|1836
000260  aa  6 03476 2521 00	spri2	pr6|1854
000261  aa  6 00104 3521 00	epp2 	pr6|68		n_read
000262  aa  6 03500 2521 00	spri2	pr6|1856
000263  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000264  aa  6 03502 2521 00	spri2	pr6|1858
000265  aa  6 03470 6211 00	eax1 	pr6|1848
000266  aa   024000 4310 07	fld  	10240,dl
000267  aa  6 00044 3701 20	epp4 	pr6|36,*
000270  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$get_chars
000271  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 74
    if code ^= 0 then do;

000272  aa  6 00032 3735 20	epp7 	pr6|26,*
000273  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000274  aa   000044 6000 04	tze  	36,ic		000340
						STATEMENT 1 ON LINE 75
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header read failed on ^a",
	   rldr_data_.pvname (pvindex));

000275  aa   777541 2360 04	ldq  	-159,ic		000036 = 524000000040
000276  aa  6 03454 7561 00	stq  	pr6|1836
000277  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000300  aa   777605 00 0040	desc9a	-123,32		000104 = 126124117103
000301  aa  6 03456 00 0040	desc9a	pr6|1838,32
000302  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000303  aa   000064 4020 07	mpy  	52,dl
000304  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000305  aa  6 03472 2521 00	spri2	pr6|1850
000306  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000307  aa  6 03474 2521 00	spri2	pr6|1852
000310  aa   777512 3520 04	epp2 	-182,ic		000022 = 162154144162
000311  aa  6 03476 2521 00	spri2	pr6|1854
000312  aa  6 03456 3521 00	epp2 	pr6|1838
000313  aa  6 03500 2521 00	spri2	pr6|1856
000314  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000315  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000316  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000317  aa  6 03502 2521 00	spri2	pr6|1858
000320  aa   777523 3520 04	epp2 	-173,ic		000043 = 464000000000
000321  aa  6 03504 2521 00	spri2	pr6|1860
000322  aa   777523 3520 04	epp2 	-173,ic		000045 = 404000000043
000323  aa  6 03506 2521 00	spri2	pr6|1862
000324  aa   777514 3520 04	epp2 	-180,ic		000040 = 526000000040
000325  aa  6 03510 2521 00	spri2	pr6|1864
000326  aa   777507 3520 04	epp2 	-185,ic		000035 = 524000000035
000327  aa  6 03512 2521 00	spri2	pr6|1866
000330  aa  6 03454 3521 00	epp2 	pr6|1836
000331  aa  6 03514 2521 00	spri2	pr6|1868
000332  aa  6 03470 6211 00	eax1 	pr6|1848
000333  aa   024000 4310 07	fld  	10240,dl
000334  aa  6 00044 3701 20	epp4 	pr6|36,*
000335  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
000336  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 77
        return;

000337  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 78
      end;

						STATEMENT 1 ON LINE 80
    return;

000340  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO update                                             STATEMENT 1 ON LINE 85
update: entry (rldr_datap, pvindex, code);

000341  ta     000134000000
000342  da     000073300000
000343  aa   003540 6270 00	eax7 	1888
000344  aa  7 00034 3521 20	epp2 	pr7|28,*
000345  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000346  aa     000006000000
000347  aa     000000000000
						STATEMENT 1 ON LINE 86
close: entry (rldr_datap, pvindex, code);

000350  aa   000010 7100 04	tra  	8,ic		000360
ENTRY TO close                                              STATEMENT 1 ON LINE 86
close: entry (rldr_datap, pvindex, code);

000351  ta     000134000000
000352  da     000100300000
000353  aa   003540 6270 00	eax7 	1888
000354  aa  7 00034 3521 20	epp2 	pr7|28,*
000355  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000356  aa     000006000000
000357  aa     000000000000
						STATEMENT 1 ON LINE 91
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (DUMPER_BIT_MAP_ADDR), code);

000360  aa  6 00032 3735 20	epp7 	pr6|26,*
000361  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000362  aa   000064 4020 07	mpy  	52,dl
000363  aa  6 03452 7561 00	stq  	pr6|1834
000364  aa   000002 2360 07	ldq  	2,dl
000365  aa  6 03454 7561 00	stq  	pr6|1836
000366  aa   000716 3520 04	epp2 	462,ic		001304 = 000004000000
000367  aa   000650 6700 04	tsp4 	424,ic		001237
000370  aa  6 00032 3735 20	epp7 	pr6|26,*
000371  aa  6 03452 7271 00	lxl7 	pr6|1834
000372  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000373  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000374  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000375  aa  6 03460 2521 00	spri2	pr6|1840
000376  aa  6 03454 3521 00	epp2 	pr6|1836
000377  aa  6 03462 2521 00	spri2	pr6|1842
000400  aa  6 03453 3521 00	epp2 	pr6|1835
000401  aa  6 03464 2521 00	spri2	pr6|1844
000402  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000403  aa  6 03466 2521 00	spri2	pr6|1846
000404  aa  6 03456 6211 00	eax1 	pr6|1838
000405  aa   020000 4310 07	fld  	8192,dl
000406  aa  6 00044 3701 20	epp4 	pr6|36,*
000407  la  4 00012 3521 20	epp2 	pr4|10,*		iox_$position
000410  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 92
    if code ^= 0 then do;

000411  aa  6 00032 3735 20	epp7 	pr6|26,*
000412  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000413  aa   000044 6000 04	tze  	36,ic		000457
						STATEMENT 1 ON LINE 93
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header position failed on ^a",
	   rldr_data_.pvname (pvindex));

000414  aa   777422 2360 04	ldq  	-238,ic		000036 = 524000000040
000415  aa  6 03453 7561 00	stq  	pr6|1835
000416  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000417  aa   777476 00 0044	desc9a	-194,36		000114 = 126124117103
000420  aa  6 03456 00 0044	desc9a	pr6|1838,36
000421  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000422  aa   000064 4020 07	mpy  	52,dl
000423  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000424  aa  6 03472 2521 00	spri2	pr6|1850
000425  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000426  aa  6 03474 2521 00	spri2	pr6|1852
000427  aa   777373 3520 04	epp2 	-261,ic		000022 = 162154144162
000430  aa  6 03476 2521 00	spri2	pr6|1854
000431  aa  6 03456 3521 00	epp2 	pr6|1838
000432  aa  6 03500 2521 00	spri2	pr6|1856
000433  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000434  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000435  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000436  aa  6 03502 2521 00	spri2	pr6|1858
000437  aa   777404 3520 04	epp2 	-252,ic		000043 = 464000000000
000440  aa  6 03504 2521 00	spri2	pr6|1860
000441  aa   777404 3520 04	epp2 	-252,ic		000045 = 404000000043
000442  aa  6 03506 2521 00	spri2	pr6|1862
000443  aa   777375 3520 04	epp2 	-259,ic		000040 = 526000000040
000444  aa  6 03510 2521 00	spri2	pr6|1864
000445  aa   777372 3520 04	epp2 	-262,ic		000037 = 524000000041
000446  aa  6 03512 2521 00	spri2	pr6|1866
000447  aa  6 03453 3521 00	epp2 	pr6|1835
000450  aa  6 03514 2521 00	spri2	pr6|1868
000451  aa  6 03470 6211 00	eax1 	pr6|1848
000452  aa   024000 4310 07	fld  	10240,dl
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
000455  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 95
        return;

000456  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 96
      end;

						STATEMENT 1 ON LINE 98
    call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), rldr_data_.vtoc_headerp (pvindex),
         size (vtoc_header) * 4, code);

000457  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000460  aa   000064 4020 07	mpy  	52,dl
000461  aa   000000 6270 06	eax7 	0,ql
000462  aa   020000 2360 07	ldq  	8192,dl
000463  aa  6 03453 7561 00	stq  	pr6|1835
000464  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000465  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000466  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000467  aa  6 03460 2521 00	spri2	pr6|1840
000470  aa  5 00420 3521 17	epp2 	pr5|272,7		rldr_data_.vtoc_headerp
000471  aa  6 03462 2521 00	spri2	pr6|1842
000472  aa  6 03453 3521 00	epp2 	pr6|1835
000473  aa  6 03464 2521 00	spri2	pr6|1844
000474  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000475  aa  6 03466 2521 00	spri2	pr6|1846
000476  aa  6 03456 6211 00	eax1 	pr6|1838
000477  aa   020000 4310 07	fld  	8192,dl
000500  aa  6 00044 3701 20	epp4 	pr6|36,*
000501  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$put_chars
000502  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 100
    if code ^= 0 then
      call rldr_report_$error_output (rldr_datap, code, myname, "VTOC header write failed on ^a",
	 rldr_data_.pvname (pvindex));

000503  aa  6 00032 3735 20	epp7 	pr6|26,*
000504  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000505  aa   000043 6000 04	tze  	35,ic		000550
000506  aa   777330 2360 04	ldq  	-296,ic		000036 = 524000000040
000507  aa  6 03453 7561 00	stq  	pr6|1835
000510  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000511  aa   777364 00 0040	desc9a	-268,32		000074 = 126124117103
000512  aa  6 03456 00 0040	desc9a	pr6|1838,32
000513  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000514  aa   000064 4020 07	mpy  	52,dl
000515  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000516  aa  6 03472 2521 00	spri2	pr6|1850
000517  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000520  aa  6 03474 2521 00	spri2	pr6|1852
000521  aa   777301 3520 04	epp2 	-319,ic		000022 = 162154144162
000522  aa  6 03476 2521 00	spri2	pr6|1854
000523  aa  6 03456 3521 00	epp2 	pr6|1838
000524  aa  6 03500 2521 00	spri2	pr6|1856
000525  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000526  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000527  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000530  aa  6 03502 2521 00	spri2	pr6|1858
000531  aa   777312 3520 04	epp2 	-310,ic		000043 = 464000000000
000532  aa  6 03504 2521 00	spri2	pr6|1860
000533  aa   777312 3520 04	epp2 	-310,ic		000045 = 404000000043
000534  aa  6 03506 2521 00	spri2	pr6|1862
000535  aa   777303 3520 04	epp2 	-317,ic		000040 = 526000000040
000536  aa  6 03510 2521 00	spri2	pr6|1864
000537  aa   777275 3520 04	epp2 	-323,ic		000034 = 524000000036
000540  aa  6 03512 2521 00	spri2	pr6|1866
000541  aa  6 03453 3521 00	epp2 	pr6|1835
000542  aa  6 03514 2521 00	spri2	pr6|1868
000543  aa  6 03470 6211 00	eax1 	pr6|1848
000544  aa   024000 4310 07	fld  	10240,dl
000545  aa  6 00044 3701 20	epp4 	pr6|36,*
000546  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
000547  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 103
    return;

000550  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO build_vtoc_map                                     STATEMENT 1 ON LINE 110
build_vtoc_map: entry (rldr_datap, pvindex, code);

000551  ta     000134000000
000552  da     000107300000
000553  aa   003540 6270 00	eax7 	1888
000554  aa  7 00034 3521 20	epp2 	pr7|28,*
000555  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000556  aa     000006000000
000557  aa     000000000000
						STATEMENT 1 ON LINE 118
    controlp = rldr_data_.controlp (pvindex);

000560  aa  6 00032 3735 20	epp7 	pr6|26,*
000561  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000562  aa   000064 4020 07	mpy  	52,dl
000563  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000564  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000565  aa  5 00430 3535 26	epp3 	pr5|280,ql*	rldr_data_.controlp
000566  aa  6 03430 2535 00	spri3	pr6|1816		controlp
						STATEMENT 1 ON LINE 119
    prev_vtocx = 0;

000567  aa  6 00103 4501 00	stz  	pr6|67		prev_vtocx
						STATEMENT 1 ON LINE 120
    unspec (free_vtoce) = "0"b;

000570  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000571  aa   000000 00 0000	desc9a	0,0
000572  aa  6 00107 00 1400	desc9a	pr6|71,768
						STATEMENT 1 ON LINE 121
    unspec (old_vtoce) = "0"b;

000573  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000574  aa   000000 00 0000	desc9a	0,0
000575  aa  6 00407 00 1400	desc9a	pr6|263,768
						STATEMENT 1 ON LINE 122
    vtocep = addr (free_vtoce);

000576  aa  6 00107 3515 00	epp1 	pr6|71		free_vtoce
000577  aa  6 03432 2515 00	spri1	pr6|1818		vtocep
						STATEMENT 1 ON LINE 123
    old_vtocep = addr (old_vtoce);

000600  aa  6 00407 3535 00	epp3 	pr6|263		old_vtoce
000601  aa  6 00100 2535 00	spri3	pr6|64		old_vtocep
						STATEMENT 1 ON LINE 124
    vtoc_headerp = rldr_data_.vtoc_headerp (pvindex);

000602  aa  5 00420 3515 26	epp1 	pr5|272,ql*	rldr_data_.vtoc_headerp
000603  aa  6 03434 2515 00	spri1	pr6|1820		vtoc_headerp
						STATEMENT 1 ON LINE 125
    vtoc_header.n_free_vtoce, code = 0;

000604  aa  1 00003 4501 00	stz  	pr1|3		vtoc_header.n_free_vtoce
000605  aa  7 00006 4501 20	stz  	pr7|6,*		code
						STATEMENT 1 ON LINE 126
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (VTOC_MAP_ADDR), code);

000606  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000607  aa   000064 4020 07	mpy  	52,dl
000610  aa  6 03454 7561 00	stq  	pr6|1836
000611  aa   000002 2360 07	ldq  	2,dl
000612  aa  6 03453 7561 00	stq  	pr6|1835
000613  aa   000463 3520 04	epp2 	307,ic		001276 = 000004000000
000614  aa   000423 6700 04	tsp4 	275,ic		001237
000615  aa  6 00032 3735 20	epp7 	pr6|26,*
000616  aa  6 03454 7271 00	lxl7 	pr6|1836
000617  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000620  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000621  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
000622  aa  6 03460 2521 00	spri2	pr6|1840
000623  aa  6 03453 3521 00	epp2 	pr6|1835
000624  aa  6 03462 2521 00	spri2	pr6|1842
000625  aa  6 03452 3521 00	epp2 	pr6|1834
000626  aa  6 03464 2521 00	spri2	pr6|1844
000627  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000630  aa  6 03466 2521 00	spri2	pr6|1846
000631  aa  6 03456 6211 00	eax1 	pr6|1838
000632  aa   020000 4310 07	fld  	8192,dl
000633  aa  6 00044 3701 20	epp4 	pr6|36,*
000634  la  4 00012 3521 20	epp2 	pr4|10,*		iox_$position
000635  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 127
    if code ^= 0 then do;

000636  aa  6 00032 3735 20	epp7 	pr6|26,*
000637  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000640  aa   000044 6000 04	tze  	36,ic		000704
						STATEMENT 1 ON LINE 128
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map position failed on ^a",
	   rldr_data_.pvname (pvindex));

000641  aa   777175 2360 04	ldq  	-387,ic		000036 = 524000000040
000642  aa  6 03452 7561 00	stq  	pr6|1834
000643  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000644  aa   777221 00 0040	desc9a	-367,32		000064 = 126124117103
000645  aa  6 03456 00 0040	desc9a	pr6|1838,32
000646  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000647  aa   000064 4020 07	mpy  	52,dl
000650  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000651  aa  6 03472 2521 00	spri2	pr6|1850
000652  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000653  aa  6 03474 2521 00	spri2	pr6|1852
000654  aa   777146 3520 04	epp2 	-410,ic		000022 = 162154144162
000655  aa  6 03476 2521 00	spri2	pr6|1854
000656  aa  6 03456 3521 00	epp2 	pr6|1838
000657  aa  6 03500 2521 00	spri2	pr6|1856
000660  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000661  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000662  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000663  aa  6 03502 2521 00	spri2	pr6|1858
000664  aa   777157 3520 04	epp2 	-401,ic		000043 = 464000000000
000665  aa  6 03504 2521 00	spri2	pr6|1860
000666  aa   777157 3520 04	epp2 	-401,ic		000045 = 404000000043
000667  aa  6 03506 2521 00	spri2	pr6|1862
000670  aa   777150 3520 04	epp2 	-408,ic		000040 = 526000000040
000671  aa  6 03510 2521 00	spri2	pr6|1864
000672  aa   777142 3520 04	epp2 	-414,ic		000034 = 524000000036
000673  aa  6 03512 2521 00	spri2	pr6|1866
000674  aa  6 03452 3521 00	epp2 	pr6|1834
000675  aa  6 03514 2521 00	spri2	pr6|1868
000676  aa  6 03470 6211 00	eax1 	pr6|1848
000677  aa   024000 4310 07	fld  	10240,dl
000700  aa  6 00044 3701 20	epp4 	pr6|36,*
000701  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
000702  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 130
        return;

000703  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 131
      end;

						STATEMENT 1 ON LINE 132
    call iox_$get_chars (rldr_data_.outputvol_iocbp (pvindex), addr (l_vtoc_map), size (vtoc_map) * 4, n_read, code);

000704  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000705  aa   000064 4020 07	mpy  	52,dl
000706  aa  6 00707 3715 00	epp5 	pr6|455		l_vtoc_map
000707  aa  6 03516 6515 00	spri5	pr6|1870
000710  aa   000000 6270 06	eax7 	0,ql
000711  aa   010000 2360 07	ldq  	4096,dl
000712  aa  6 03452 7561 00	stq  	pr6|1834
000713  aa  7 00002 3535 20	epp3 	pr7|2,*		rldr_datap
000714  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
000715  aa  3 00426 3521 17	epp2 	pr3|278,7		rldr_data_.outputvol_iocbp
000716  aa  6 03472 2521 00	spri2	pr6|1850
000717  aa  6 03516 3521 00	epp2 	pr6|1870
000720  aa  6 03474 2521 00	spri2	pr6|1852
000721  aa  6 03452 3521 00	epp2 	pr6|1834
000722  aa  6 03476 2521 00	spri2	pr6|1854
000723  aa  6 00104 3521 00	epp2 	pr6|68		n_read
000724  aa  6 03500 2521 00	spri2	pr6|1856
000725  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000726  aa  6 03502 2521 00	spri2	pr6|1858
000727  aa  6 03470 6211 00	eax1 	pr6|1848
000730  aa   024000 4310 07	fld  	10240,dl
000731  aa  6 00044 3701 20	epp4 	pr6|36,*
000732  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$get_chars
000733  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 133
    if code ^= 0 then do;

000734  aa  6 00032 3735 20	epp7 	pr6|26,*
000735  aa  7 00006 2361 20	ldq  	pr7|6,*		code
000736  aa   000044 6000 04	tze  	36,ic		001002
						STATEMENT 1 ON LINE 134
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map read failed on ^a",
	   rldr_data_.pvname (pvindex));

000737  aa   777077 2360 04	ldq  	-449,ic		000036 = 524000000040
000740  aa  6 03452 7561 00	stq  	pr6|1834
000741  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000742  aa   777114 00 0034	desc9a	-436,28		000055 = 126124117103
000743  aa  6 03456 00 0034	desc9a	pr6|1838,28
000744  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
000745  aa   000064 4020 07	mpy  	52,dl
000746  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
000747  aa  6 03472 2521 00	spri2	pr6|1850
000750  aa  7 00006 3521 20	epp2 	pr7|6,*		code
000751  aa  6 03474 2521 00	spri2	pr6|1852
000752  aa   777050 3520 04	epp2 	-472,ic		000022 = 162154144162
000753  aa  6 03476 2521 00	spri2	pr6|1854
000754  aa  6 03456 3521 00	epp2 	pr6|1838
000755  aa  6 03500 2521 00	spri2	pr6|1856
000756  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
000757  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
000760  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
000761  aa  6 03502 2521 00	spri2	pr6|1858
000762  aa   777061 3520 04	epp2 	-463,ic		000043 = 464000000000
000763  aa  6 03504 2521 00	spri2	pr6|1860
000764  aa   777061 3520 04	epp2 	-463,ic		000045 = 404000000043
000765  aa  6 03506 2521 00	spri2	pr6|1862
000766  aa   777052 3520 04	epp2 	-470,ic		000040 = 526000000040
000767  aa  6 03510 2521 00	spri2	pr6|1864
000770  aa   777043 3520 04	epp2 	-477,ic		000033 = 524000000032
000771  aa  6 03512 2521 00	spri2	pr6|1866
000772  aa  6 03452 3521 00	epp2 	pr6|1834
000773  aa  6 03514 2521 00	spri2	pr6|1868
000774  aa  6 03470 6211 00	eax1 	pr6|1848
000775  aa   024000 4310 07	fld  	10240,dl
000776  aa  6 00044 3701 20	epp4 	pr6|36,*
000777  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
001000  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 136
        return;

001001  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 137
      end;

						STATEMENT 1 ON LINE 138
    l_vtoc_map.n_free_vtoce = l_vtoc_map.n_vtoce;

001002  aa  6 00707 2361 00	ldq  	pr6|455		l_vtoc_map.n_vtoce
001003  aa  6 00710 7561 00	stq  	pr6|456		l_vtoc_map.n_free_vtoce
						STATEMENT 1 ON LINE 140
    do vtocx = 0 to vtoc_header.n_vtoce - 1;

001004  aa  6 03434 3715 20	epp5 	pr6|1820,*	vtoc_headerp
001005  aa  5 00001 2361 00	ldq  	pr5|1		vtoc_header.n_vtoce
001006  aa   000001 1760 07	sbq  	1,dl
001007  aa  6 03440 7561 00	stq  	pr6|1824
001010  aa  6 00102 4501 00	stz  	pr6|66		vtocx
001011  aa   000000 0110 03	nop  	0,du
001012  aa  6 00102 2361 00	ldq  	pr6|66		vtocx
001013  aa  6 03440 1161 00	cmpq 	pr6|1824
001014  aa   000027 6054 04	tpnz 	23,ic		001043
						STATEMENT 1 ON LINE 141
      if rldr_control (vtocx).uid ^= "0"b then do;

001015  aa   000006 4020 07	mpy  	6,dl
001016  aa  6 03452 7561 00	stq  	pr6|1834
001017  aa  6 03430 3735 20	epp7 	pr6|1816,*	controlp
001020  aa  7 14024 2351 06	lda  	pr7|6164,ql	rldr_control.uid
001021  aa   000020 6000 04	tze  	16,ic		001041
						STATEMENT 1 ON LINE 142
	l_vtoc_map.n_free_vtoce = l_vtoc_map.n_free_vtoce - 1;

001022  aa   000001 3360 07	lcq  	1,dl
001023  aa  6 00710 0561 00	asq  	pr6|456		l_vtoc_map.n_free_vtoce
						STATEMENT 1 ON LINE 143
	wordx = divide (vtocx, 32, 17);

001024  aa  6 00102 2361 00	ldq  	pr6|66		vtocx
001025  aa   000040 5060 07	div  	32,dl
001026  aa  6 00105 7561 00	stq  	pr6|69		wordx
						STATEMENT 1 ON LINE 144
	bitx = mod (vtocx, 32);

001027  aa  6 00102 2361 00	ldq  	pr6|66		vtocx
001030  aa   000270 3520 04	epp2 	184,ic		001320 = 000000000040
001031  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001032  aa  6 00106 7561 00	stq  	pr6|70		bitx
						STATEMENT 1 ON LINE 145
	bit_map_wordp = addr (l_vtoc_map.bit_map (wordx));

001033  aa  6 00105 7271 00	lxl7 	pr6|69		wordx
001034  aa  6 00717 3715 17	epp5 	pr6|463,7		l_vtoc_map.bit_map
001035  aa  6 03436 6515 00	spri5	pr6|1822		bit_map_wordp
						STATEMENT 1 ON LINE 146
	substr (bit_map_word.bits, bitx + 1, 1) = "0"b;

001036  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
001037  aa   000000 00 0000	descb	0,0
001040  aa  5 00000 01 0001	descb	pr5|0(1),1	bit_map_word.bits
						STATEMENT 1 ON LINE 147
        end;

						STATEMENT 1 ON LINE 148
    end;

001041  aa  6 00102 0541 00	aos  	pr6|66		vtocx
001042  aa   777750 7100 04	tra  	-24,ic		001012
						STATEMENT 1 ON LINE 150
    call iox_$position (rldr_data_.outputvol_iocbp (pvindex), 2, sector (VTOC_MAP_ADDR), code);

001043  aa  6 00032 3735 20	epp7 	pr6|26,*
001044  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
001045  aa   000064 4020 07	mpy  	52,dl
001046  aa  6 03453 7561 00	stq  	pr6|1835
001047  aa   000002 2360 07	ldq  	2,dl
001050  aa  6 03452 7561 00	stq  	pr6|1834
001051  aa   000217 3520 04	epp2 	143,ic		001270 = 000004000000
001052  aa   000165 6700 04	tsp4 	117,ic		001237
001053  aa  6 00032 3735 20	epp7 	pr6|26,*
001054  aa  6 03453 7271 00	lxl7 	pr6|1835
001055  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001056  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001057  aa  5 00426 3521 17	epp2 	pr5|278,7		rldr_data_.outputvol_iocbp
001060  aa  6 03460 2521 00	spri2	pr6|1840
001061  aa  6 03452 3521 00	epp2 	pr6|1834
001062  aa  6 03462 2521 00	spri2	pr6|1842
001063  aa  6 03454 3521 00	epp2 	pr6|1836
001064  aa  6 03464 2521 00	spri2	pr6|1844
001065  aa  7 00006 3521 20	epp2 	pr7|6,*		code
001066  aa  6 03466 2521 00	spri2	pr6|1846
001067  aa  6 03456 6211 00	eax1 	pr6|1838
001070  aa   020000 4310 07	fld  	8192,dl
001071  aa  6 00044 3701 20	epp4 	pr6|36,*
001072  la  4 00012 3521 20	epp2 	pr4|10,*		iox_$position
001073  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 151
    if code ^= 0 then do;

001074  aa  6 00032 3735 20	epp7 	pr6|26,*
001075  aa  7 00006 2361 20	ldq  	pr7|6,*		code
001076  aa   000044 6000 04	tze  	36,ic		001142
						STATEMENT 1 ON LINE 152
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map position failed on ^a",
	   rldr_data_.pvname (pvindex));

001077  aa   776737 2360 04	ldq  	-545,ic		000036 = 524000000040
001100  aa  6 03454 7561 00	stq  	pr6|1836
001101  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001102  aa   776763 00 0040	desc9a	-525,32		000064 = 126124117103
001103  aa  6 03456 00 0040	desc9a	pr6|1838,32
001104  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
001105  aa   000064 4020 07	mpy  	52,dl
001106  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001107  aa  6 03472 2521 00	spri2	pr6|1850
001110  aa  7 00006 3521 20	epp2 	pr7|6,*		code
001111  aa  6 03474 2521 00	spri2	pr6|1852
001112  aa   776710 3520 04	epp2 	-568,ic		000022 = 162154144162
001113  aa  6 03476 2521 00	spri2	pr6|1854
001114  aa  6 03456 3521 00	epp2 	pr6|1838
001115  aa  6 03500 2521 00	spri2	pr6|1856
001116  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001117  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001120  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001121  aa  6 03502 2521 00	spri2	pr6|1858
001122  aa   776721 3520 04	epp2 	-559,ic		000043 = 464000000000
001123  aa  6 03504 2521 00	spri2	pr6|1860
001124  aa   776721 3520 04	epp2 	-559,ic		000045 = 404000000043
001125  aa  6 03506 2521 00	spri2	pr6|1862
001126  aa   776712 3520 04	epp2 	-566,ic		000040 = 526000000040
001127  aa  6 03510 2521 00	spri2	pr6|1864
001130  aa   776704 3520 04	epp2 	-572,ic		000034 = 524000000036
001131  aa  6 03512 2521 00	spri2	pr6|1866
001132  aa  6 03454 3521 00	epp2 	pr6|1836
001133  aa  6 03514 2521 00	spri2	pr6|1868
001134  aa  6 03470 6211 00	eax1 	pr6|1848
001135  aa   024000 4310 07	fld  	10240,dl
001136  aa  6 00044 3701 20	epp4 	pr6|36,*
001137  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
001140  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 154
        return;

001141  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 155
      end;

						STATEMENT 1 ON LINE 156
    call iox_$put_chars (rldr_data_.outputvol_iocbp (pvindex), addr (l_vtoc_map), size (vtoc_map) * 4, code);

001142  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
001143  aa   000064 4020 07	mpy  	52,dl
001144  aa  6 00707 3715 00	epp5 	pr6|455		l_vtoc_map
001145  aa  6 03516 6515 00	spri5	pr6|1870
001146  aa   000000 6270 06	eax7 	0,ql
001147  aa   010000 2360 07	ldq  	4096,dl
001150  aa  6 03454 7561 00	stq  	pr6|1836
001151  aa  7 00002 3535 20	epp3 	pr7|2,*		rldr_datap
001152  aa  3 00000 3535 20	epp3 	pr3|0,*		rldr_datap
001153  aa  3 00426 3521 17	epp2 	pr3|278,7		rldr_data_.outputvol_iocbp
001154  aa  6 03460 2521 00	spri2	pr6|1840
001155  aa  6 03516 3521 00	epp2 	pr6|1870
001156  aa  6 03462 2521 00	spri2	pr6|1842
001157  aa  6 03454 3521 00	epp2 	pr6|1836
001160  aa  6 03464 2521 00	spri2	pr6|1844
001161  aa  7 00006 3521 20	epp2 	pr7|6,*		code
001162  aa  6 03466 2521 00	spri2	pr6|1846
001163  aa  6 03456 6211 00	eax1 	pr6|1838
001164  aa   020000 4310 07	fld  	8192,dl
001165  aa  6 00044 3701 20	epp4 	pr6|36,*
001166  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$put_chars
001167  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 157
    if code ^= 0 then do;

001170  aa  6 00032 3735 20	epp7 	pr6|26,*
001171  aa  7 00006 2361 20	ldq  	pr7|6,*		code
001172  aa   000044 6000 04	tze  	36,ic		001236
						STATEMENT 1 ON LINE 158
        call rldr_report_$error_output (rldr_datap, code, myname, "VTOC map write failed on ^a",
	   rldr_data_.pvname (pvindex));

001173  aa   776643 2360 04	ldq  	-605,ic		000036 = 524000000040
001174  aa  6 03454 7561 00	stq  	pr6|1836
001175  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001176  aa   776651 00 0034	desc9a	-599,28		000046 = 126124117103
001177  aa  6 03456 00 0034	desc9a	pr6|1838,28
001200  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
001201  aa   000064 4020 07	mpy  	52,dl
001202  aa  7 00002 3521 20	epp2 	pr7|2,*		rldr_datap
001203  aa  6 03472 2521 00	spri2	pr6|1850
001204  aa  7 00006 3521 20	epp2 	pr7|6,*		code
001205  aa  6 03474 2521 00	spri2	pr6|1852
001206  aa   776614 3520 04	epp2 	-628,ic		000022 = 162154144162
001207  aa  6 03476 2521 00	spri2	pr6|1854
001210  aa  6 03456 3521 00	epp2 	pr6|1838
001211  aa  6 03500 2521 00	spri2	pr6|1856
001212  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001213  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001214  aa  5 00353 3521 06	epp2 	pr5|235,ql	rldr_data_.pvname
001215  aa  6 03502 2521 00	spri2	pr6|1858
001216  aa   776625 3520 04	epp2 	-619,ic		000043 = 464000000000
001217  aa  6 03504 2521 00	spri2	pr6|1860
001220  aa   776625 3520 04	epp2 	-619,ic		000045 = 404000000043
001221  aa  6 03506 2521 00	spri2	pr6|1862
001222  aa   776616 3520 04	epp2 	-626,ic		000040 = 526000000040
001223  aa  6 03510 2521 00	spri2	pr6|1864
001224  aa   776606 3520 04	epp2 	-634,ic		000032 = 524000000033
001225  aa  6 03512 2521 00	spri2	pr6|1866
001226  aa  6 03454 3521 00	epp2 	pr6|1836
001227  aa  6 03514 2521 00	spri2	pr6|1868
001230  aa  6 03470 6211 00	eax1 	pr6|1848
001231  aa   024000 4310 07	fld  	10240,dl
001232  aa  6 00044 3701 20	epp4 	pr6|36,*
001233  la  4 00010 3521 20	epp2 	pr4|8,*		rldr_report_$error_output
001234  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 160
        return;

001235  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 161
      end;

						STATEMENT 1 ON LINE 162
    return;

001236  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 284
  end rldr_vtoc_header_;

BEGIN PROCEDURE sector
ENTRY TO sector                                             STATEMENT 1 ON LINE 167
sector: proc (add) returns (fixed bin);

001237  aa  6 03442 6501 00	spri4	pr6|1826
001240  aa  6 03444 2521 00	spri2	pr6|1828
						STATEMENT 1 ON LINE 174
    dev_idx = rldr_data_.disk_type (pvindex);

001241  aa  6 00032 3735 20	epp7 	pr6|26,*
001242  aa  7 00004 2361 20	ldq  	pr7|4,*		pvindex
001243  aa   000064 4020 07	mpy  	52,dl
001244  aa  7 00002 3715 20	epp5 	pr7|2,*		rldr_datap
001245  aa  5 00000 3715 20	epp5 	pr5|0,*		rldr_datap
001246  aa   000000 6260 06	eax6 	0,ql
001247  aa  5 00411 2361 06	ldq  	pr5|265,ql	rldr_data_.disk_type
001250  aa  6 03450 7561 00	stq  	pr6|1832		dev_idx
						STATEMENT 1 ON LINE 175
    sector = add * SECTORS_PER_RECORD (dev_idx);

001251  aa  2 00002 2361 20	ldq  	pr2|2,*		add
001252  aa  6 03450 7271 00	lxl7 	pr6|1832		dev_idx
001253  ta   777777 4020 17	mpy  	-1,7
001254  aa  6 03451 7561 00	stq  	pr6|1833		sector
						STATEMENT 1 ON LINE 176
    sector = sector + divide (sector, rldr_data_.usable_sectors (pvindex), 17, 0) * rldr_data_.unusable_sectors (pvindex);

001255  aa  5 00412 5061 16	div  	pr5|266,6		rldr_data_.usable_sectors
001256  aa  5 00413 4021 16	mpy  	pr5|267,6		rldr_data_.unusable_sectors
001257  aa   000044 7770 00	llr  	36
001260  aa   000044 7330 00	lrs  	36
001261  aa  6 03451 0331 00	adl  	pr6|1833		sector
001262  aa  6 03451 7561 00	stq  	pr6|1833		sector
						STATEMENT 1 ON LINE 177
    return (sector * words_per_sect (dev_idx) * 4);

001263  ta   000010 4020 17	mpy  	8,7
001264  aa   000004 4020 07	mpy  	4,dl
001265  aa  2 00004 7561 20	stq  	pr2|4,*
001266  aa  6 03442 6101 00	rtcd 	pr6|1826
						STATEMENT 1 ON LINE 179
  end sector;

  END PROCEDURE sector
  END PROCEDURE rldr_vtoc_header_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
