	COMPILATION LISTING OF SEGMENT bk_arg_reader_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0933.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 bk_arg_reader_: proc (iac, ialp, ocode);		/* Created by M A Meer in November 1972 */
       15 
       16 /* This routine reads and handles the arguments
       17*   *   for all directly callable dumper and reloader modules.
       18*   *
       19*   *  Usage:  dcl bk_arg_reader_ entry (fixed bin, pointer, fixed bin (35));
       20*   *
       21*   *	call bk_arg_reader_ (iac, ialp, ocode);
       22*   *
       23*   *	where
       24*   *
       25*   *	1) iac		is the first argument to be examined (Input).
       26*   *
       27*   *	2) ialp		is a pointer to the argument list (Input).
       28*   *
       29*   *	3) ocode		is a standard status code (Output).
       30*   *
       31**/
       32 /* -no_primary added 08/03/79 S. Herbst */
       33 /* Error message fixed 01/07/80 S. Herbst */
       34 /* -dprint and -no_dprint added 03/19/80 S. Herbst */
       35 /* -setdtd and -nosetdtd added 07/01/81 S. Herbst */
       36 /* -ds, -he, -q and -rqt added for dprinting maps 12/01/81 S. Herbst */
       37 
       38 dcl  MAX_QUEUES fixed bin int static init (4);		/* highest dprint queue number */
       39 
       40 dcl (iac, ac, al) fixed bin,
       41      arg_array (20) char (32) aligned,
       42     (ocode, code) fixed bin (35),
       43     (ialp, alp, ap) ptr,
       44     (entrysw, interval) fixed bin,
       45     (arg_date, time_now) fixed bin (52),
       46     (cflag, oflag, rflag, tflag, wflag, pvflag) bit (1) aligned init (""b),
       47     (got_queue, got_request_type) bit (1) aligned,
       48     (default_queue, fixed_queue, max_queue) fixed bin,
       49      i fixed bin,
       50      buffer char (168),
       51      generic_type char (32),
       52      local_rqt char (24),
       53     (error_table_$argerr, error_table_$badopt, error_table_$badpath, error_table_$noarg) fixed bin (35) ext,
       54      error_table_$id_not_found fixed bin (35) ext,
       55      arg char (al) based,
       56      op char (32),
       57      op1 char (1);
       58 
       59 dcl  dump fixed bin static init (1),
       60      reload fixed bin static init (2),
       61      array fixed bin static init (3),
       62      norm fixed bin static init (0);
       63 
       64 dcl  com_err_ entry options (variable),
       65      clock_ entry (fixed bin (52)),
       66      convert_date_to_binary_ entry (char (*), fixed bin (52), fixed bin (35)),
       67      cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr),
       68      cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin),
       69      iod_info_$generic_type entry (char (*), char (32), fixed bin (35)),
       70      iod_info_$queue_data entry (char (*), fixed bin, fixed bin, fixed bin (35)),
       71     (index, substr) builtin;
       72 
       73 /*  */
       74 
       75 /* bk_arg_reader_:  entry(iac, ialp, ocode);		This is the entry which begins here */
       76 
       77 	entrysw = norm;				/* regular entry */
       78 	go to common;
       79 
       80 dump_arg_reader: entry (iac, ialp, ocode);
       81 
       82 	entrysw = dump;				/* read dumper args */
       83 	go to common;
       84 
       85 reload_arg_reader: entry (iac, ialp, ocode);
       86 
       87 	entrysw = reload;				/* reload entry */
       88 	goto common;
       89 
       90 array_arg_reader: entry (arg_array, ocode);
       91 
       92 	entrysw = array;
       93 	ac = 0;
       94 
       95 
       96 common:	ocode = 0;				/* set up and copy args */
       97 	if entrysw ^= array then do;
       98 	     ac = iac - 1;				/* first arg to fetch */
       99 	     alp = ialp;				/* arg list pointer */
      100 	end;
      101 	got_queue, got_request_type = "0"b;
      102 	bk_ss_$pathsw = ""b;			/* initialize the path switch */
      103 
      104 start:	ac = ac + 1;				/* get next arg */
      105 	if entrysw ^= array then do;
      106 	     call cu_$arg_ptr_rel (ac, ap, al, code, alp);
      107 	     if code ^= 0 then
      108 		if code = error_table_$noarg then
      109 		     if cflag | oflag | tflag | wflag | rflag | pvflag then go to noarg;
      110 		     else do;
      111 			if got_queue | got_request_type then do;
      112 			     if got_request_type then local_rqt = bk_ss_$dprint_request_type;
      113 			     else local_rqt = "printer";
      114 			     call iod_info_$queue_data (local_rqt, default_queue, max_queue, code);
      115 			     if code ^= 0 then do;
      116 				call com_err_ (code, bk_ss_$myname, "Invalid dprint request_type ^a",
      117 				     local_rqt);
      118 				go to err_ret;
      119 			     end;
      120 			     if bk_ss_$dprint_queue > max_queue then fixed_queue = max_queue;
      121 			     else fixed_queue = 0;
      122 			     if fixed_queue ^= 0 then do;
      123 				call com_err_ (0, bk_ss_$myname,
      124 		     "(warning) Specified queue number ^d is invalid for request type ^a; using ^d instead.",
      125 				     bk_ss_$dprint_queue, local_rqt, fixed_queue);
      126 				bk_ss_$dprint_queue = fixed_queue;
      127 			     end;
      128 			end;
      129 			go to ret;
      130 		     end;
      131 		else do;				/* code other than noargs */
      132 		     call com_err_ (code, bk_ss_$myname);
      133 		     go to err_ret;
      134 		end;
      135 	end;
      136 	else do;					/* handle arg array */
      137 	     if arg_array (ac) = "" | arg_array (ac) = " " then goto start; /* skip null args */
      138 	     al = 32;				/* set default */
      139 	     ap = addr (arg_array (ac));
      140 	end;
      141 
      142 	if cflag then do;				/* this is a control file name */
      143 	     if al = 0 then go to noarg;
      144 	     if entrysw = dump then			/* this is dumper entry */
      145 		if substr (ap -> arg, al-5, 5) ^= ".dump"
      146 		then bk_ss_$control_name = ap -> arg || ".dump";
      147 		else bk_ss_$control_name = ap -> arg;
      148 
      149 	     if entrysw = reload then do;		/* this is a retrieval */
      150 		bk_ss_$retrievesw = "1"b;		/* Let the world know. */
      151 		bk_ss_$qchecksw = "1"b;		/* Don't suspend quotas during retrieve. */
      152 		bk_ss_$rname = ap -> arg;		/* retrieval file name */
      153 		bk_ss_$rsize = al;			/* length of name */
      154 	     end;
      155 
      156 	     cflag = ""b;				/* turn off flag */
      157 	     go to start;
      158 	end;
      159 
      160 	else if oflag then do;			/* this must be operator name */
      161 	     if al = 0 then go to noarg;
      162 	     else bk_ss_$operator = ap -> arg;
      163 	     oflag = ""b;				/* turn off flag */
      164 	     go to start;
      165 	end;
      166 
      167 	else if tflag then do;			/* this must be number of tapes */
      168 	     if al = 0 then bk_ss_$ntapes = 1;		/* default value */
      169 	     else if ap -> arg = "2" then bk_ss_$ntapes = 2;
      170 	     else bk_ss_$ntapes = 1;
      171 	     tflag = ""b;				/* turn off flag */
      172 	     go to start;
      173 	end;
      174 
      175 	else if wflag then do;			/* this must be wakeup interval in minutes */
      176 	     if al = 0 then go to noarg;		/* null arg not allowed */
      177 	     interval = cv_dec_check_ ((ap -> arg), code);
      178 	     if code ^= 0 then do;
      179 bad_interval:	call com_err_ (code, bk_ss_$myname, "Interval number ^a", ap -> arg);
      180 		go to err_ret;
      181 	     end;
      182 	     if interval <= 0 then go to bad_interval;
      183 	     if interval > 360 then go to bad_interval;
      184 	     bk_ss_$wakeup_interval = interval * 60000000; /* interval converted to microseconds */
      185 	     wflag = ""b;
      186 	     go to start;
      187 	end;
      188 
      189 	else if rflag then do;			/* restart at directory given */
      190 	     if al = 0 then go to noarg;
      191 	     if substr (ap -> arg, 1, 1) ^= ">" then do; /* must be pathname */
      192 		code = error_table_$badpath;
      193 		call com_err_ (code, bk_ss_$myname,
      194 		     "Full path of restart directory required. ^a", ap -> arg);
      195 		go to err_ret;
      196 	     end;
      197 	     bk_ss_$restart_dumpsw = "1"b;
      198 	     bk_ss_$restart_path = ap -> arg;
      199 	     bk_ss_$restart_plen = al;
      200 	     rflag = ""b;				/* reset flag */
      201 	     go to start;
      202 	end;
      203 	else if pvflag then do;			/* physical volume recovery */
      204 	     if al = 0 then goto noarg;		/* like all the rest */
      205 	     bk_ss_$pvsw = "1"b;			/* turn on the switch */
      206 	     bk_ss_$pvname = ap -> arg;		/* set the variable */
      207 	     pvflag = "0"b;
      208 	     goto start;
      209 	end;
      210 
      211 	if al > 0 then do;				/*  ignore null arguments  */
      212 	     op, op1 = ap -> arg;			/* extract first characters for comparison */
      213 	     if op1 = "-" then do;			/* only if leading hyphen */
      214 		op, op1 = substr (ap -> arg, 2);	/* drop leading hyphen */
      215 	     end;
      216 
      217 
      218 /* PROCESS ARGUMENTS FOR ALL BACKUP ENTRIES */
      219 
      220 	     if op = "control" then do;		/* Flag next arg as control file name */
      221 		cflag = "1"b;
      222 		go to start;			/* Get next arg */
      223 	     end;
      224 
      225 	     else if op = "operator" then oflag = "1"b;	/* flag next arg as operator name */
      226 
      227 	     else if op = "all" then bk_ss_$datesw, bk_ss_$dtdsw = ""b; /* ignore all date criteria */
      228 
      229 	     else if op = "debug" then do;		/* disable quota, transparent switches */
      230 		bk_ss_$debugsw = "1"b;		/* in user reload ... */
      231 		bk_ss_$trimsw = ""b;		/* don't trim since will be foverwriting */
      232 	     end;
      233 	     else if op = "nodebug" then bk_ss_$debugsw = ""b; /* no debug, default */
      234 
      235 	     else if op = "map" then bk_ss_$mapsw = "1"b; /* output a map */
      236 	     else if op = "nomap" then do;		/* do not output a map */
      237 		bk_ss_$mapsw = ""b;
      238 		bk_ss_$tapesw = "1"b;		/* must have tape or map switch */
      239 	     end;
      240 
      241 	     else if op = "brief_map" | op = "bfmap" then bk_ss_$mapsw, bk_ss_$brief_mapsw = "1"b;
      242 
      243 	     else if op = "destination" | op = "ds" then do;
      244 		bk_ss_$dprint_destination = get_value ("-destination", 24);
      245 		bk_ss_$dprint_destination_setsw = "1"b;
      246 	     end;
      247 
      248 	     else if op = "dprint" | op = "dp" then
      249 		bk_ss_$dprintsw = "1"b;
      250 						/* whether to dprint maps when done */
      251 	     else if op = "header" | op = "he" then do;
      252 		bk_ss_$dprint_heading = get_value ("-header", 64);
      253 		bk_ss_$dprint_heading_setsw = "1"b;
      254 	     end;
      255 
      256 	     else if op = "nodprint" | op = "no_dprint" | op = "ndp" then
      257 		bk_ss_$dprintsw = "0"b;
      258 
      259 	     else if op = "hold" then bk_ss_$holdsw = "1"b; /* do not dismount */
      260 	     else if op = "nohold" then bk_ss_$holdsw = ""b; /* dismount, default */
      261 
      262 	     else if op = "primary" | op = "pri" then bk_ss_$no_primary = "0"b;
      263 						/* whether to use primary pathnames */
      264 	     else if op = "no_primary" | op = "npri" | op = "noprimary" then
      265 		bk_ss_$no_primary = "1"b;
      266 
      267 	     else if op = "pvname" then pvflag = "1"b;	/* enable physival volume recovery */
      268 
      269 	     else if op = "queue" | op = "q" then do;
      270 		buffer = get_value ("-queue", 100);
      271 		i = cv_dec_check_ (buffer, code);
      272 		if code ^= 0 | i < 1 | i > MAX_QUEUES then do;
      273 		     call com_err_ (0, bk_ss_$myname, "Invalid queue number ^a", buffer);
      274 		     go to err_ret;
      275 		end;
      276 		bk_ss_$dprint_queue = i;
      277 		got_queue = "1"b;
      278 	     end;
      279 
      280 	     else if op = "request_type" | op = "rqt" then do;
      281 		buffer = get_value ("-request_type", 24);
      282 		call iod_info_$generic_type (buffer, generic_type, code);
      283 		if code ^= 0 then
      284 		     if code = error_table_$id_not_found then do;
      285 			call com_err_ (0, bk_ss_$myname, "Unknown dprint request type ^a", buffer);
      286 			go to err_ret;
      287 		     end;
      288 		     else call com_err_ (0, bk_ss_$myname, "Warning -- Unable to check request type ^a", buffer);
      289 		else if generic_type ^= "printer" then do;
      290 		     call com_err_ (0, bk_ss_$myname, "Dprint request type ^a is not of generic type ""printer"".",
      291 			buffer);
      292 		     code = 1;
      293 		     go to err_ret;
      294 		end;
      295 		bk_ss_$dprint_request_type = buffer;
      296 		bk_ss_$dprint_request_type_setsw, got_request_type = "1"b;
      297 	     end;
      298 
      299 	     else if op = "error_on" then bk_ss_$err_onlinesw = "1"b; /* output errors online */
      300 	     else if op = "error_of" then bk_ss_$err_onlinesw = ""b; /* output errors into a file */
      301 
      302 	     else if op1 = ">" | op = "retrieve" then do; /* was argument a pathname */
      303 		if bk_ss_$myname = "backup_load" | bk_ss_$myname = "retrieve" then do; /* Is this a retrieval */
      304 		     bk_ss_$retrievesw = "1"b;	/* Tell the world */
      305 		     bk_ss_$qchecksw = "1"b;		/* Don't suspend quotas during retrieve. */
      306 		     bk_ss_$rname = ap -> arg;	/* Save retrieve control seg name */
      307 		     bk_ss_$rsize = al;		/* Save length of name */
      308 		end;
      309 		else if entrysw = dump		/* We must be dumping */
      310 		then do;
      311 		     bk_ss_$pathsw = "1"b;		/* set switch, we have a starting pathname */
      312 		     bk_ss_$save_plen = al;		/* save length of pathname */
      313 		     bk_ss_$save_path = ap -> arg;	/* save pathname of starting directory */
      314 		end;
      315 		else do;				/* not dumping or retrieving */
      316 		     code = error_table_$badopt;
      317 		     call com_err_ ((0), bk_ss_$myname,
      318 			"Pathname argument not accepted by this command. ^a", ap -> arg);
      319 		     go to err_ret;
      320 		end;
      321 	     end;
      322 
      323 /* DUMPER ARGUMENT PROCESSING */
      324 
      325 
      326 	     else if entrysw ^= reload then do;		/* Not reloader entry */
      327 
      328 		if op = "wakeup" then do;		/* Flag next arg as wakeup interval in minutes */
      329 		     if bk_ss_$myname = "start_dump" | bk_ss_$myname = "catchup_dump"
      330 		     then wflag = "1"b;
      331 		     else go to badopt;		/* Illegal arg for other entries */
      332 		     go to start;
      333 		end;
      334 
      335 		else if op = "tapes" then tflag = "1"b; /* flag next arg as number of tapes */
      336 		else if op = "restart" then rflag = "1"b; /* flag next arg as restart pathname */
      337 
      338 		else if op = "1tape" then do;		/* handle a "1tape" arg */
      339 		     bk_ss_$ntapes = 1;		/* insert number of tapes requested */
      340 		     bk_ss_$tapesw = "1"b;		/* set tape option on */
      341 		end;
      342 
      343 		else if op = "2tapes" then do;	/* same as above */
      344 		     bk_ss_$ntapes = 2;
      345 		     bk_ss_$tapesw = "1"b;
      346 		end;
      347 
      348 		else if op = "only" then bk_ss_$onlysw = "1"b; /* suppress hierarchy sweep */
      349 		else if op = "sweep" then bk_ss_$onlysw = ""b; /* sweep hierarchy, default */
      350 
      351 		else if op = "dtd" then bk_ss_$dtdsw = "1"b; /* check if changed since last dumped */
      352 		else if op = "setdtd" then bk_ss_$set_dtd, bk_ss_$set_dtd_explicit = "1"b;  /* always set dtd */
      353 		else if op = "nosetdtd" then do;	/* never set dtd */
      354 		     bk_ss_$set_dtd = "0"b;
      355 		     bk_ss_$set_dtd_explicit = "1"b;
      356 		end;
      357 
      358 		else if op = "tape" then bk_ss_$tapesw = "1"b; /* output a tape, default */
      359 		else if op = "notape" then do;
      360 		     bk_ss_$tapesw = ""b;		/* do not write a tape */
      361 		     bk_ss_$mapsw = "1"b;		/* must have tape or map switch */
      362 		end;
      363 
      364 		else if op = "nooutput" then bk_ss_$no_output = "1"b; /* test run or debugging dumper */
      365 		else if op = "output" then bk_ss_$no_output = "0"b; /* output dumper stuff if tapesw is on */
      366 
      367 		else if op = "nocontin" then bk_ss_$no_contin = "1"b; /* end dump after catchup pass. */
      368 		else if op = "contin" then bk_ss_$no_contin = "0"b; /* continue incremental after catchup pass */
      369 
      370 
      371 		else go to try_date;		/* see if this is a date */
      372 
      373 	     end;					/* END OF DUMPER ARGS */
      374 
      375 /*  PROCESS RELOAD AND RETRIEVE ARGUMENTS */
      376 
      377 
      378 	     else if entrysw = reload then do;
      379 
      380 		if op = "quota" then bk_ss_$quotasw = "1"b; /* set to modify quota on reload */
      381 		else if op = "noquota" then bk_ss_$quotasw = ""b; /* do not modify quota, default */
      382 
      383 		else if op = "trim" then bk_ss_$trimsw = "1"b; /* trim directory on reload */
      384 		else if op = "notrim" then bk_ss_$trimsw = ""b; /* no trim on reload, default */
      385 
      386 		else if op = "reload" then bk_ss_$no_reload = ""b; /* Allow appending and writing in hierarchy */
      387 		else if op = "noreload" then bk_ss_$no_reload = "1"b; /* NO appending or writing in hierarchy */
      388 
      389 		else if op = "first" then bk_ss_$onlysw = "1"b; /* take first occurence on retrieval */
      390 		else if op = "last" then bk_ss_$onlysw = ""b; /* take last occurence on retrieval */
      391 
      392 		else if op = "qcheck" then bk_ss_$qchecksw = "1"b; /* Don't suspend quota checking. */
      393 		else if op = "noqcheck" then bk_ss_$qchecksw = "0"b; /* Suspend quota checking. */
      394 
      395 		else if op = "setlvid" then bk_ss_$no_setlvid = "0"b; /* set sons lvid */
      396 		else if op = "nosetlvid" then bk_ss_$no_setlvid = "1"b; /* don't set sons lvid */
      397 
      398 		else go to try_date;		/* see if this is a date */
      399 
      400 	     end;					/* END OF RELOAD, RETRIEVE ARGS */
      401 
      402 	     else
      403 try_date:	     if op1 <= "9" & op1 >= "0" then do;
      404 convert_date:	call convert_date_to_binary_ (ap -> arg, arg_date, code);
      405 		if code ^= 0 then go to error_print;
      406 		call clock_ (time_now);		/* get current date, time */
      407 		if arg_date > time_now then bk_ss_$date = arg_date-86400000000; /* given date - 24 hours */
      408 		else bk_ss_$date = arg_date;
      409 		bk_ss_$datesw = "1"b;		/* set switch to check date */
      410 	     end;
      411 
      412 	     else do;
      413 		if index (ap -> arg, " ") ^= 0 then go to convert_date; /* possibly a date */
      414 badopt:		code = error_table_$badopt;
      415 error_print:	call com_err_ (code, bk_ss_$myname, ap -> arg);
      416 		go to err_ret;
      417 	     end;
      418 	end;
      419 
      420 	go to start;				/* get next arg */
      421 
      422 noarg:	call com_err_ (error_table_$noarg, bk_ss_$myname, "After -^a", op);
      423 	code = error_table_$argerr;
      424 
      425 
      426 err_ret:	ocode = code;				/* return an error code */
      427 
      428 ret:	return;
      429 
      430 get_value: proc (P_name, P_limit) returns (char (*));
      431 
      432 /* Returns the char string following the current control arg P_name */
      433 
      434 dcl P_name char (*);
      435 dcl P_limit fixed bin;
      436 
      437 	ac = ac + 1;
      438 	if entrysw ^= array then do;
      439 	     call cu_$arg_ptr_rel (ac, ap, al, code, alp);
      440 	     if code ^= 0 then do;
      441 		call com_err_ (0, bk_ss_$myname, "No value specified for ^a", P_name);
      442 		go to err_ret;
      443 	     end;
      444 	     if al > P_limit then do;
      445 		call com_err_ (0, bk_ss_$myname, "Value for ^a exceeds maximum number of characters ^d",
      446 		     P_name, P_limit);
      447 		code = 1;
      448 		go to err_ret;
      449 	     end;
      450 	end;
      451 	else do;					/* array_arg_reader entrypoint */
      452 	     al = 32;
      453 	     ap = addr (arg_array (ac));
      454 	end;
      455 
      456 	return (ap -> arg);
      457 
      458 end get_value;
      459 /*  */
      460 
  1     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  1     6*     install(87-03-30,MR12.1-1018):
  1     7*     added a writing_map switch to indicate when the dump map is being written.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  1    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  1    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  1    14 
  1    15 /* Hierarchy dumper/reloader static data */
  1    16 
  1    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  1    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  1    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  1    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  1    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  1    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  1    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  1    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  1    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  1    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  1    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  1    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  1    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  1    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  1    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  1    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  1    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  1    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  1    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  1    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  1    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  1    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  1    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  1    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  1    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  1    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  1    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  1    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  1    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  1    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  1    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  1    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  1    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  1    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  1    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  1    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  1    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  1    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  1    55*						   requests satisfied (loading) */
  1    56      bk_ss_$operator char(32),			/* operator name */
  1    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  1    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  1    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  1    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  1    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  1    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  1    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  1    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  1    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  1    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  1    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  1    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  1    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  1    70      bk_ss_$rname char(168),				/* retrieval file name */
  1    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  1    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  1    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  1    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  1    75      bk_ss_$segptr pointer,
  1    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  1    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  1    78      bk_ss_$sp pointer,
  1    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  1    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  1    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  1    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  1    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  1    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  1    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  1    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  1    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  1    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  1    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  1    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  1    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  1    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  1    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  1    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  1    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  1    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  1    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  1    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  1    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  1   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  1   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  1   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  1   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  1   104 	external static;
  1   105 
  1   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
      461 
      462 
      463      end bk_arg_reader_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.0  bk_arg_reader_.pl1                >spec>install>1111>bk_arg_reader_.pl1
461          1    04/02/87  2006.7  bk_ss_.incl.pl1                   >ldd>include>bk_ss_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MAX_QUEUES                             constant        fixed bin(17,0)          initial dcl 38 ref 272
P_limit                                parameter       fixed bin(17,0)          dcl 435 set ref 430 444 445*
P_name                                 parameter       char                     packed unaligned dcl 434 set ref 430 441* 445*
ac                              000100 automatic       fixed bin(17,0)          dcl 40 set ref 93* 98* 104* 104 106* 137 137 139
                                                                                  437* 437 439* 453
al                              000101 automatic       fixed bin(17,0)          dcl 40 set ref 106* 138* 143 144 144 144 147 152 153
                                                                                  161 162 168 169 176 177 179 179 190 191 193 193
                                                                                  198 199 204 206 211 212 214 306 307 312 313 317
                                                                                  317 404 404 413 415 415 439* 444 452* 456
alp                             000104 automatic       pointer                  dcl 40 set ref 99* 106* 439*
ap                              000106 automatic       pointer                  dcl 40 set ref 106* 139* 144 144 147 152 162 169 177
                                                                                  179 191 193 198 206 212 214 306 313 317 404 413
                                                                                  415 439* 453* 456
arg                                    based           char                     packed unaligned dcl 40 set ref 144 144 147 152 162
                                                                                  169 177 179* 191 193* 198 206 212 214 306 313 317*
                                                                                  404* 413 415* 456
arg_array                              parameter       char(32)                 array dcl 40 set ref 90 137 137 139 453
arg_date                        000112 automatic       fixed bin(52,0)          dcl 40 set ref 404* 407 407 408
array                                  constant        fixed bin(17,0)          initial dcl 59 ref 92 97 105 438
bk_ss_$brief_mapsw              000040 external static bit(1)                   dcl 1-17 set ref 241*
bk_ss_$control_name             000042 external static char(168)                packed unaligned dcl 1-17 set ref 144* 147*
bk_ss_$date                     000044 external static fixed bin(52,0)          dcl 1-17 set ref 407* 408*
bk_ss_$datesw                   000046 external static bit(1)                   dcl 1-17 set ref 227* 409*
bk_ss_$debugsw                  000050 external static bit(1)                   dcl 1-17 set ref 230* 233*
bk_ss_$dprint_destination       000052 external static char(24)                 packed unaligned dcl 1-17 set ref 244*
bk_ss_$dprint_destination_setsw 000054 external static bit(1)                   dcl 1-17 set ref 245*
bk_ss_$dprint_heading           000056 external static char(64)                 packed unaligned dcl 1-17 set ref 252*
bk_ss_$dprint_heading_setsw     000060 external static bit(1)                   dcl 1-17 set ref 253*
bk_ss_$dprint_queue             000062 external static fixed bin(17,0)          dcl 1-17 set ref 120 123* 126* 276*
bk_ss_$dprint_request_type      000064 external static char(24)                 packed unaligned dcl 1-17 set ref 112 295*
bk_ss_$dprint_request_type_setsw
                                000066 external static bit(1)                   dcl 1-17 set ref 296*
bk_ss_$dprintsw                 000070 external static bit(1)                   dcl 1-17 set ref 248* 256*
bk_ss_$dtdsw                    000072 external static bit(1)                   dcl 1-17 set ref 227* 351*
bk_ss_$err_onlinesw             000074 external static bit(1)                   dcl 1-17 set ref 299* 300*
bk_ss_$holdsw                   000076 external static bit(1)                   dcl 1-17 set ref 259* 260*
bk_ss_$mapsw                    000100 external static bit(1)                   dcl 1-17 set ref 235* 237* 241* 361*
bk_ss_$myname                   000102 external static char(16)                 packed unaligned dcl 1-17 set ref 116* 123* 132*
                                                                                  179* 193* 273* 285* 288* 290* 303 303 317* 329 329
                                                                                  415* 422* 441* 445*
bk_ss_$no_contin                000104 external static bit(1)                   dcl 1-17 set ref 367* 368*
bk_ss_$no_output                000106 external static bit(1)                   dcl 1-17 set ref 364* 365*
bk_ss_$no_primary               000110 external static bit(1)                   dcl 1-17 set ref 262* 264*
bk_ss_$no_reload                000112 external static bit(1)                   dcl 1-17 set ref 386* 387*
bk_ss_$no_setlvid               000114 external static bit(1)                   dcl 1-17 set ref 395* 396*
bk_ss_$ntapes                   000116 external static fixed bin(17,0)          dcl 1-17 set ref 168* 169* 170* 339* 344*
bk_ss_$onlysw                   000120 external static bit(1)                   dcl 1-17 set ref 348* 349* 389* 390*
bk_ss_$operator                 000122 external static char(32)                 packed unaligned dcl 1-17 set ref 162*
bk_ss_$pathsw                   000124 external static bit(1)                   dcl 1-17 set ref 102* 311*
bk_ss_$pvname                   000130 external static char(32)                 dcl 1-17 set ref 206*
bk_ss_$pvsw                     000126 external static bit(1)                   dcl 1-17 set ref 205*
bk_ss_$qchecksw                 000132 external static bit(1)                   dcl 1-17 set ref 151* 305* 392* 393*
bk_ss_$quotasw                  000134 external static bit(1)                   dcl 1-17 set ref 380* 381*
bk_ss_$restart_dumpsw           000136 external static bit(1)                   dcl 1-17 set ref 197*
bk_ss_$restart_path             000140 external static char(168)                dcl 1-17 set ref 198*
bk_ss_$restart_plen             000142 external static fixed bin(17,0)          dcl 1-17 set ref 199*
bk_ss_$retrievesw               000144 external static bit(1)                   dcl 1-17 set ref 150* 304*
bk_ss_$rname                    000146 external static char(168)                packed unaligned dcl 1-17 set ref 152* 306*
bk_ss_$rsize                    000150 external static fixed bin(17,0)          dcl 1-17 set ref 153* 307*
bk_ss_$save_path                000152 external static char(168)                packed unaligned dcl 1-17 set ref 313*
bk_ss_$save_plen                000154 external static fixed bin(17,0)          dcl 1-17 set ref 312*
bk_ss_$set_dtd                  000156 external static bit(1)                   dcl 1-17 set ref 352* 354*
bk_ss_$set_dtd_explicit         000160 external static bit(1)                   dcl 1-17 set ref 352* 355*
bk_ss_$tapesw                   000162 external static bit(1)                   dcl 1-17 set ref 238* 340* 345* 358* 360*
bk_ss_$trimsw                   000164 external static bit(1)                   dcl 1-17 set ref 231* 383* 384*
bk_ss_$wakeup_interval          000166 external static fixed bin(52,0)          dcl 1-17 set ref 184*
buffer                          000132 automatic       char(168)                packed unaligned dcl 40 set ref 270* 271* 273* 281*
                                                                                  282* 285* 288* 290* 295
cflag                           000116 automatic       bit(1)                   initial dcl 40 set ref 40* 107 142 156* 221*
clock_                          000024 constant        entry                    external dcl 64 ref 406
code                            000102 automatic       fixed bin(35,0)          dcl 40 set ref 106* 107 107 114* 115 116* 132* 177*
                                                                                  178 179* 192* 193* 271* 272 282* 283 283 292* 316*
                                                                                  404* 405 414* 415* 423* 426 439* 440 447*
com_err_                        000022 constant        entry                    external dcl 64 ref 116 123 132 179 193 273 285 288
                                                                                  290 317 415 422 441 445
convert_date_to_binary_         000026 constant        entry                    external dcl 64 ref 404
cu_$arg_ptr_rel                 000030 constant        entry                    external dcl 64 ref 106 439
cv_dec_check_                   000032 constant        entry                    external dcl 64 ref 177 271
default_queue                   000126 automatic       fixed bin(17,0)          dcl 40 set ref 114*
dump                                   constant        fixed bin(17,0)          initial dcl 59 ref 82 144 309
entrysw                         000110 automatic       fixed bin(17,0)          dcl 40 set ref 77* 82* 87* 92* 97 105 144 149 309
                                                                                  326 378 438
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 40 ref 423
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 40 ref 316 414
error_table_$badpath            000014 external static fixed bin(35,0)          dcl 40 ref 192
error_table_$id_not_found       000020 external static fixed bin(35,0)          dcl 40 ref 283
error_table_$noarg              000016 external static fixed bin(35,0)          dcl 40 set ref 107 422*
fixed_queue                     000127 automatic       fixed bin(17,0)          dcl 40 set ref 120* 121* 122 123* 126
generic_type                    000204 automatic       char(32)                 packed unaligned dcl 40 set ref 282* 289
got_queue                       000124 automatic       bit(1)                   dcl 40 set ref 101* 111 277*
got_request_type                000125 automatic       bit(1)                   dcl 40 set ref 101* 111 112 296*
i                               000131 automatic       fixed bin(17,0)          dcl 40 set ref 271* 272 272 276
iac                                    parameter       fixed bin(17,0)          dcl 40 ref 14 80 85 98
ialp                                   parameter       pointer                  dcl 40 ref 14 80 85 99
index                                                  builtin function         dcl 64 ref 413
interval                        000111 automatic       fixed bin(17,0)          dcl 40 set ref 177* 182 183 184
iod_info_$generic_type          000034 constant        entry                    external dcl 64 ref 282
iod_info_$queue_data            000036 constant        entry                    external dcl 64 ref 114
local_rqt                       000214 automatic       char(24)                 packed unaligned dcl 40 set ref 112* 113* 114* 116*
                                                                                  123*
max_queue                       000130 automatic       fixed bin(17,0)          dcl 40 set ref 114* 120 120
norm                                   constant        fixed bin(17,0)          initial dcl 59 ref 77
ocode                                  parameter       fixed bin(35,0)          dcl 40 set ref 14 80 85 90 96* 426*
oflag                           000117 automatic       bit(1)                   initial dcl 40 set ref 40* 107 160 163* 225*
op                              000222 automatic       char(32)                 packed unaligned dcl 40 set ref 212* 214* 220 225
                                                                                  227 229 233 235 236 241 241 243 243 248 248 251
                                                                                  251 256 256 256 259 260 262 262 264 264 264 267
                                                                                  269 269 280 280 299 300 302 328 335 336 338 343
                                                                                  348 349 351 352 353 358 359 364 365 367 368 380
                                                                                  381 383 384 386 387 389 390 392 393 395 396 422*
op1                             000232 automatic       char(1)                  packed unaligned dcl 40 set ref 212* 213 214* 302
                                                                                  402 402
pvflag                          000123 automatic       bit(1)                   initial dcl 40 set ref 40* 107 203 207* 267*
reload                                 constant        fixed bin(17,0)          initial dcl 59 ref 87 149 326 378
rflag                           000120 automatic       bit(1)                   initial dcl 40 set ref 40* 107 189 200* 336*
substr                                                 builtin function         dcl 64 ref 144 191 214
tflag                           000121 automatic       bit(1)                   initial dcl 40 set ref 40* 107 167 171* 335*
time_now                        000114 automatic       fixed bin(52,0)          dcl 40 set ref 406* 407
wflag                           000122 automatic       bit(1)                   initial dcl 40 set ref 40* 107 175 185* 329*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
bk_ss_$allow_dir_overwrite             external static bit(1)                   dcl 1-17
bk_ss_$areap                           external static pointer                  dcl 1-17
bk_ss_$caller_handles_conditions       external static bit(1)                   dcl 1-17
bk_ss_$check_effective_access          external static bit(1)                   dcl 1-17
bk_ss_$control_ptr                     external static pointer                  dcl 1-17
bk_ss_$cross_retrievesw                external static bit(1)                   dcl 1-17
bk_ss_$data_iocb                       external static pointer                  dcl 1-17
bk_ss_$dir_trim                        external static bit(1)                   dcl 1-17
bk_ss_$dont_dump_upgraded_dirs         external static bit(1)                   dcl 1-17
bk_ss_$ename                           external static char(32)                 dcl 1-17
bk_ss_$enforce_max_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_min_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_minimum_ring            external static bit(1)                   dcl 1-17
bk_ss_$err_label                       external static label variable           dcl 1-17
bk_ss_$error                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$hp                              external static pointer                  dcl 1-17
bk_ss_$ignore_dates                    external static bit(1)                   dcl 1-17
bk_ss_$maximum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$maximum_dir_access_class        external static bit(72)                  dcl 1-17
bk_ss_$minimum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$minimum_ring                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$namesw                          external static bit(1)                   dcl 1-17
bk_ss_$path_index                      external static fixed bin(17,0)          dcl 1-17
bk_ss_$preattached                     external static bit(1)                   dcl 1-17
bk_ss_$restore_access_class            external static bit(1)                   dcl 1-17
bk_ss_$retrieval_index                 external static fixed bin(17,0)          dcl 1-17
bk_ss_$rlen                            external static fixed bin(17,0)          dcl 1-17
bk_ss_$save_time                       external static fixed bin(52,0)          dcl 1-17
bk_ss_$segptr                          external static pointer                  dcl 1-17
bk_ss_$source_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$sp                              external static pointer                  dcl 1-17
bk_ss_$sub_entry                       external static bit(1)                   dcl 1-17
bk_ss_$sub_entry_errfile               external static bit(1)                   dcl 1-17
bk_ss_$target_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$translate_access_class          external static bit(1)                   dcl 1-17
bk_ss_$upgrade_to_user_auth            external static bit(1)                   dcl 1-17
bk_ss_$user_authorization              external static bit(72)                  dcl 1-17
bk_ss_$user_id                         external static char(32)                 packed unaligned dcl 1-17
bk_ss_$user_ring                       external static fixed bin(17,0)          dcl 1-17
bk_ss_$volume_set_name                 external static char(32)                 packed unaligned dcl 1-17
bk_ss_$wasnt_known                     external static bit(1)                   dcl 1-17
bk_ss_$writing_map                     external static bit(1)                   dcl 1-17

NAMES DECLARED BY EXPLICIT CONTEXT.
array_arg_reader                000531 constant        entry                    external dcl 90
bad_interval                    001224 constant        label                    dcl 179 ref 182 183
badopt                          003153 constant        label                    dcl 414 ref 329
bk_arg_reader_                  000455 constant        entry                    external dcl 14
common                          000545 constant        label                    dcl 96 ref 78 83 88
convert_date                    003070 constant        label                    dcl 404 ref 413
dump_arg_reader                 000473 constant        entry                    external dcl 80
err_ret                         003240 constant        label                    dcl 426 ref 118 133 180 195 274 286 293 319 416 442
                                                                                  448
error_print                     003156 constant        label                    dcl 415 ref 405
get_value                       003244 constant        entry                    internal dcl 430 ref 244 252 270 281
noarg                           003204 constant        label                    dcl 422 ref 107 143 161 176 190 204
reload_arg_reader               000511 constant        entry                    external dcl 85
ret                             003242 constant        label                    dcl 428 set ref 129
start                           000563 constant        label                    dcl 104 ref 137 157 164 172 186 201 208 222 332 420
try_date                        003063 constant        label                    dcl 402 ref 368 396

NAME DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 139 453

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4270        4460    3444        4300
Length      5032    3444       170         335     624           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bk_arg_reader_                      244 external procedure  is an external procedure.  
get_value                           118 internal procedure  uses returns(char(*)) or returns(bit(*)).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bk_arg_reader_           000100 ac                          bk_arg_reader_
                         000101 al                          bk_arg_reader_
                         000102 code                        bk_arg_reader_
                         000104 alp                         bk_arg_reader_
                         000106 ap                          bk_arg_reader_
                         000110 entrysw                     bk_arg_reader_
                         000111 interval                    bk_arg_reader_
                         000112 arg_date                    bk_arg_reader_
                         000114 time_now                    bk_arg_reader_
                         000116 cflag                       bk_arg_reader_
                         000117 oflag                       bk_arg_reader_
                         000120 rflag                       bk_arg_reader_
                         000121 tflag                       bk_arg_reader_
                         000122 wflag                       bk_arg_reader_
                         000123 pvflag                      bk_arg_reader_
                         000124 got_queue                   bk_arg_reader_
                         000125 got_request_type            bk_arg_reader_
                         000126 default_queue               bk_arg_reader_
                         000127 fixed_queue                 bk_arg_reader_
                         000130 max_queue                   bk_arg_reader_
                         000131 i                           bk_arg_reader_
                         000132 buffer                      bk_arg_reader_
                         000204 generic_type                bk_arg_reader_
                         000214 local_rqt                   bk_arg_reader_
                         000222 op                          bk_arg_reader_
                         000232 op1                         bk_arg_reader_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac          tra_ext_1
shorten_stack       ext_entry           int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      convert_date_to_binary_       cu_$arg_ptr_rel
cv_dec_check_                 iod_info_$generic_type        iod_info_$queue_data

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$brief_mapsw            bk_ss_$control_name           bk_ss_$date                   bk_ss_$datesw
bk_ss_$debugsw                bk_ss_$dprint_destination     bk_ss_$dprint_destination_setsw
bk_ss_$dprint_heading         bk_ss_$dprint_heading_setsw   bk_ss_$dprint_queue           bk_ss_$dprint_request_type
bk_ss_$dprint_request_type_setsw                            bk_ss_$dprintsw               bk_ss_$dtdsw
bk_ss_$err_onlinesw           bk_ss_$holdsw                 bk_ss_$mapsw                  bk_ss_$myname
bk_ss_$no_contin              bk_ss_$no_output              bk_ss_$no_primary             bk_ss_$no_reload
bk_ss_$no_setlvid             bk_ss_$ntapes                 bk_ss_$onlysw                 bk_ss_$operator
bk_ss_$pathsw                 bk_ss_$pvname                 bk_ss_$pvsw                   bk_ss_$qchecksw
bk_ss_$quotasw                bk_ss_$restart_dumpsw         bk_ss_$restart_path           bk_ss_$restart_plen
bk_ss_$retrievesw             bk_ss_$rname                  bk_ss_$rsize                  bk_ss_$save_path
bk_ss_$save_plen              bk_ss_$set_dtd                bk_ss_$set_dtd_explicit       bk_ss_$tapesw
bk_ss_$trimsw                 bk_ss_$wakeup_interval        error_table_$argerr           error_table_$badopt
error_table_$badpath          error_table_$id_not_found     error_table_$noarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000441        14 000451        77 000466        78 000470        80 000471        82 000504        83 000506
     85 000507        87 000522        88 000524        90 000525        92 000542        93 000544        96 000545
     97 000546        98 000550        99 000554       101 000557       102 000561       104 000563       105 000564
    106 000567       107 000606       111 000627       112 000633       113 000642       114 000645       115 000670
    116 000672       118 000722       120 000723       121 000732       122 000733       123 000735       126 000774
    129 000777       132 001000       133 001014       135 001015       137 001016       138 001033       139 001036
    142 001040       143 001042       144 001044       147 001074       149 001102       150 001105       151 001110
    152 001111       153 001117       156 001121       157 001122       160 001123       161 001125       162 001127
    163 001135       164 001136       167 001137       168 001141       169 001147       170 001160       171 001163
    172 001164       175 001165       176 001167       177 001171       178 001221       179 001224       180 001262
    182 001263       183 001265       184 001267       185 001272       186 001273       189 001274       190 001276
    191 001300       192 001305       193 001310       195 001342       197 001343       198 001346       199 001352
    200 001353       201 001354       203 001355       204 001357       205 001361       206 001364       207 001371
    208 001372       211 001373       212 001375       213 001411       214 001415       215 001431       220 001432
    221 001436       222 001440       225 001441       227 001450       229 001460       230 001464       231 001467
    232 001470       233 001471       235 001500       236 001510       237 001514       238 001516       239 001520
    241 001521       243 001536       244 001546       245 001607       246 001612       248 001613       251 001627
    252 001637       253 001675       254 001700       256 001701       259 001720       260 001730       262 001737
    264 001752       267 001772       269 002001       270 002011       271 002045       272 002067       273 002076
    274 002127       276 002130       277 002132       278 002134       280 002135       281 002145       282 002203
    283 002225       285 002232       286 002262       288 002263       289 002314       290 002320       292 002351
    293 002353       295 002354       296 002361       297 002364       299 002365       300 002375       302 002404
    303 002413       304 002425       305 002427       306 002430       307 002435       308 002437       309 002440
    311 002443       312 002445       313 002447       314 002453       316 002454       317 002456       319 002510
    321 002511       326 002512       328 002515       329 002521       332 002535       335 002536       336 002545
    338 002554       339 002560       340 002563       341 002565       343 002566       344 002572       345 002575
    346 002577       348 002600       349 002610       351 002617       352 002627       353 002640       354 002644
    355 002646       356 002650       358 002651       359 002661       360 002665       361 002667       362 002671
    364 002672       365 002702       367 002711       368 002721       373 002727       378 002730       380 002731
    381 002741       383 002750       384 002760       386 002767       387 002776       389 003006       390 003016
    392 003025       393 003035       395 003044       396 003053       400 003062       402 003063       404 003070
    405 003114       406 003116       407 003125       408 003134       409 003136       410 003140       413 003141
    414 003153       415 003156       416 003202       420 003203       422 003204       423 003235       426 003240
    428 003242       430 003243       437 003257       438 003261       439 003264       440 003302       441 003305
    442 003340       444 003343       445 003347       447 003405       448 003410       450 003413       452 003414
    453 003416       456 003424


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
