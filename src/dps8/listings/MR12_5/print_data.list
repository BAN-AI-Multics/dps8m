	COMPILATION LISTING OF SEGMENT print_data
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0940.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       13 print_data:
       14      proc (p_stuff, print_data_info_ptr, p_code);
       15 
       16 /*
       17*   This program is for printing p_stuff, a string produced by a "put data",
       18*   in a special format.  print_data_info, based on print_data_info_ptr, is
       19*   used to control the format, as well as select the output switch.
       20*   Written by Lindsey L. Spratt.
       21*   Modified:
       22*   06/21/79  by  Lindsey Spratt; add rtrim(ltrim()) of intervals, check for
       23*   correct print_data_info version, add error code reporting.
       24*   02/15/85 by Chris Jones to clean up properly.
       25**/
       26 
       27 /* Automatic */
       28 
       29 dcl	start_scan_idx	   fixed bin (24);
       30 dcl	code		   fixed bin (35);
       31 dcl	p_code		   fixed bin (35);
       32 dcl	more_intervals	   bit (1);
       33 dcl	first_interval	   bit (1);
       34 dcl	1 item,
       35 	  2 storage_id	   char (256) varying,
       36 	  2 value		   char (1024) varying;
       37 dcl	storage_id_pad	   char (256) varying;
       38 dcl	interval_spec	   char (256) varying;
       39 dcl	first_blank	   fixed bin (35);
       40 dcl	temp_seg_ptrs	   (2) ptr;
       41 dcl	target_ptr	   ptr;
       42 dcl	source_ptr	   ptr;
       43 dcl	current_period	   fixed bin (35);
       44 dcl	current_quote	   fixed bin (35);
       45 dcl	following_quote	   fixed bin (35);
       46 dcl	following_double_quote fixed bin (35);
       47 dcl	temp_value	   char (32) varying;
       48 dcl	more		   bit (1);
       49 dcl	null		   builtin;
       50 dcl	found		   bit (1);
       51 dcl	level		   fixed bin;
       52 dcl	root_of_level_list	   ptr;
       53 dcl	p_stuff		   char (*) varying;
       54 
       55 /* Based */
       56 
       57 dcl	1 level_id	   based,
       58 	  2 str		   char (32) varying,
       59 	  2 next		   ptr;
       60 dcl	temp_seg		   char (sys_info$max_seg_size * 4) varying based;
       61 
       62 /* External */
       63 
       64 dcl	sys_info$max_seg_size  fixed bin (35) ext;
       65 dcl	error_table_$unimplemented_version
       66 			   fixed bin (35) ext;
       67 
       68 /* Entry */
       69 
       70 dcl	ioa_$ioa_switch	   entry options (variable);
       71 dcl	ioa_		   entry options (variable);
       72 dcl	ioa_$rsnnl	   entry options (variable);
       73 dcl	get_temp_segments_	   entry (char (*), pointer dimension (*), fixed bin (35));
       74 dcl	release_temp_segments_ entry (char (*), pointer dimension (*), fixed bin (35));
       75 
       76 /* Builtin */
       77 
       78 dcl	(bin, bit, copy, index, length, ltrim, reverse, rtrim, substr)
       79 			   builtin;
       80 
       81 /* Condition */
       82 
       83 dcl	cleanup		   condition;
       84 
       85 
       86 	if print_data_info.version ^= print_data_info_version_1 then do;
       87 	     p_code = error_table_$unimplemented_version;
       88 	     return;
       89 	end;
       90 
       91 	temp_seg_ptrs (*) = null ();
       92 	root_of_level_list = null ();
       93 
       94 	on cleanup call clean_up;
       95 
       96 	call get_temp_segments_ ("print_data", temp_seg_ptrs, code);
       97 	source_ptr = temp_seg_ptrs (1);
       98 	target_ptr = temp_seg_ptrs (2);
       99 	source_ptr -> temp_seg = p_stuff;
      100 	target_ptr -> temp_seg = "";
      101 	more_intervals = "1"b;
      102 	interval_spec = rtrim (ltrim (print_data_info.intervals));
      103 	start_scan_idx = 1;
      104 	call setup_interval (start_scan_idx);
      105 	first_interval = "1"b;
      106 	do while (more_intervals | first_interval);
      107 	     first_interval = "0"b;			/* The following loop parses a storage_id and a value out of p_stuff.
      108*						   first_blank identifies the end of the storage_id which begins p_stuff. */
      109 
      110 	     first_blank = index (source_ptr -> temp_seg, " ");
      111 	     root_of_level_list = null;
      112 	     do while (first_blank > 0);
      113 		item.storage_id = substr (source_ptr -> temp_seg, 1, first_blank);
      114 						/* p_stuff is set up to begin with the storage_id. */
      115 		current_period = index (item.storage_id, ".");
      116 						/* The storage id is indented two spaces for each level in the id. */
      117 		storage_id_pad = "";
      118 		do level = 1 by 1 while (current_period > 0);
      119 		     temp_value = substr (item.storage_id, 1, current_period - 1);
      120 		     call check_level (temp_value, level, found);
      121 		     item.storage_id = substr (copy (item.storage_id, 1), current_period + 1);
      122 		     if ^found then do;
      123 			temp_value = storage_id_pad || copy (temp_value, 1);
      124 			if print_data_info.output_switch ^= null then
      125 			     call ioa_$ioa_switch (print_data_info.output_switch, "^a", temp_value);
      126 			else call ioa_ ("^a", temp_value);
      127 		     end;
      128 		     storage_id_pad = copy (" ", print_data_info.indentation) || storage_id_pad;
      129 		     current_period = index (item.storage_id, ".");
      130 		end;
      131 		call check_level (item.storage_id, level, found);
      132 		item.storage_id = storage_id_pad || copy (item.storage_id, 1);
      133 		target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, first_blank + 1));
      134 		call switch_source_and_target;	/*  The string is processed for quotes, and quote doubling.  */
      135 
      136 		if substr (source_ptr -> temp_seg, 1, 1) = """" then do;
      137 		     current_quote = 1;
      138 		     more = "1"b;
      139 		     do while (more);
      140 			following_quote =
      141 			     index (substr (source_ptr -> temp_seg, current_quote + 1), """") + current_quote;
      142 			following_double_quote =
      143 			     index (substr (source_ptr -> temp_seg, current_quote + 1), """""") + current_quote;
      144 			if following_double_quote = current_quote | following_quote < following_double_quote then
      145 			     more = "0"b;
      146 			else current_quote = following_quote;
      147 		     end;
      148 		     item.value = substr (source_ptr -> temp_seg, 1, following_quote);
      149 		     source_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, following_quote + 1));
      150 
      151 		     if substr (source_ptr -> temp_seg, 1, 1) = "b" then do;
      152 						/*  Allow for bit strings. */
      153 			item.value = copy (item.value, 1) || "b";
      154 			if print_data_info.flags.octal then do;
      155 			     call ioa_$rsnnl ("^oo", item.value, 0,
      156 				bin (
      157 				bit (substr (item.value, 2, length (item.value) - 3), length (item.value) - 3)));
      158 			end;
      159 			target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, 2));
      160 			call switch_source_and_target;
      161 		     end;
      162 		end;
      163 		else do;
      164 		     first_blank = index (source_ptr -> temp_seg, " ");
      165 		     if first_blank = 0 then
      166 			first_blank = length (source_ptr -> temp_seg);
      167 		     item.value = substr (source_ptr -> temp_seg, 1, first_blank);
      168 		     target_ptr -> temp_seg = ltrim (substr (source_ptr -> temp_seg, first_blank));
      169 		     call switch_source_and_target;
      170 		end;
      171 		if print_data_info.output_switch ^= null then
      172 		     call ioa_$ioa_switch (print_data_info.output_switch, "^a^vt^a", item.storage_id,
      173 			print_data_info.value_column, item.value);
      174 		else call ioa_ ("^a^vt^a", item.storage_id, print_data_info.value_column, item.value);
      175 		first_blank = index (source_ptr -> temp_seg, " ");
      176 	     end;
      177 	     call setup_interval (start_scan_idx);
      178 	end;
      179 	call clean_up;
      180 	return;					/* End of print_data main proc. */
      181 
      182 clean_up:
      183      proc;
      184 
      185 dcl	current_level_ptr	   ptr;
      186 
      187 	do current_level_ptr = root_of_level_list repeat root_of_level_list while (current_level_ptr ^= null ());
      188 	     root_of_level_list = current_level_ptr -> level_id.next;
      189 	     free current_level_ptr -> level_id;
      190 	end;
      191 	call release_temp_segments_ ("print_data", temp_seg_ptrs, (0));
      192 
      193      end clean_up;
      194 
      195 switch_source_and_target:
      196      proc;
      197 dcl	temp_ptr		   ptr;
      198 	temp_ptr = target_ptr;
      199 	target_ptr = source_ptr;
      200 	source_ptr = temp_ptr;
      201      end;
      202 
      203 check_level:
      204      proc (p_str, p_level, p_found);
      205 dcl	p_str		   char (*) varying;
      206 dcl	p_level		   fixed bin;
      207 dcl	p_found		   bit (1);
      208 dcl	idx		   fixed bin;
      209 dcl	next_level_ptr	   ptr;
      210 dcl	current_level_ptr	   ptr;
      211 
      212 	current_level_ptr, next_level_ptr = root_of_level_list;
      213 	do idx = 1 to p_level while (next_level_ptr ^= null);
      214 	     current_level_ptr = next_level_ptr;
      215 	     next_level_ptr = current_level_ptr -> level_id.next;
      216 	end;
      217 	if next_level_ptr ^= null			/* Implies p_level is less than length of level_list. */
      218 	then do;
      219 	     if current_level_ptr -> level_id.str = p_str then do;
      220 		p_found = "1"b;
      221 		return;
      222 	     end;
      223 	     else do;				/* Already printed component at this level is different than current component,
      224*						   so the rest (higher levels) of the level_list is no longer appropriate. */
      225 		current_level_ptr -> level_id.str = p_str;
      226 		current_level_ptr -> level_id.next = null;
      227 		current_level_ptr = next_level_ptr;
      228 		do while (current_level_ptr ^= null);
      229 		     next_level_ptr = current_level_ptr -> level_id.next;
      230 		     free current_level_ptr -> level_id;
      231 		     current_level_ptr = next_level_ptr;
      232 		end;
      233 		p_found = "0"b;
      234 	     end;
      235 	end;
      236 	else if idx = p_level then do;		/* This implies level_list is one shorter than p_level. */
      237 	     allocate level_id set (next_level_ptr);
      238 	     if current_level_ptr ^= null then
      239 		current_level_ptr -> level_id.next = next_level_ptr;
      240 	     else root_of_level_list = next_level_ptr;
      241 	     next_level_ptr -> level_id.str = p_str;
      242 	     next_level_ptr -> level_id.next = null;
      243 	     p_found = "0"b;
      244 	end;
      245 	else do;					/* idx > p_level */
      246 	     current_level_ptr -> level_id.str = p_str;
      247 	     p_found = "0"b;
      248 	end;
      249      end check_level;
      250 
      251 setup_interval:
      252      proc (p_scan_idx);
      253 dcl	p_scan_idx	   fixed bin (24);
      254 dcl	start_scan_idx	   fixed bin (24);
      255 dcl	scan_length	   fixed bin (24);
      256 
      257 	start_scan_idx = p_scan_idx;
      258 	call get_interval (start_scan_idx, scan_length, more_intervals);
      259 	p_scan_idx = scan_length + start_scan_idx;
      260 	source_ptr -> temp_seg = rtrim (ltrim (substr (p_stuff, start_scan_idx, scan_length)));
      261 
      262 /* All occurences of =" are expanded to =<SP>", ("=""" -> "= """).  Since this
      263*   doesn't change number or ordering of quotes, this change does not alter the
      264*   parsing of quoted strings.  It is necessary to insure proper parsing of
      265*   storage id's from their values when their values are strings, bit or
      266*   character.  */
      267 
      268 	start_scan_idx = 1;
      269 	target_ptr -> temp_seg = "";
      270 	scan_length = index (source_ptr -> temp_seg, "=""");
      271 	do while (scan_length > 0);
      272 	     target_ptr -> temp_seg =
      273 		target_ptr -> temp_seg || substr (source_ptr -> temp_seg, start_scan_idx, scan_length);
      274 	     target_ptr -> temp_seg = target_ptr -> temp_seg || " ";
      275 	     start_scan_idx = scan_length + start_scan_idx;
      276 	     scan_length = index (substr (source_ptr -> temp_seg, start_scan_idx), "=""");
      277 	end;
      278 
      279 	target_ptr -> temp_seg = target_ptr -> temp_seg || substr (source_ptr -> temp_seg, start_scan_idx);
      280 	call switch_source_and_target;
      281      end;
      282 
      283 
      284 
      285 get_interval:
      286      proc (p_start_scan_idx, p_scan_length, p_more_intervals);
      287 dcl	p_start_scan_idx	   fixed bin (24);
      288 dcl	p_scan_length	   fixed bin (24);
      289 dcl	p_more_intervals	   bit (1);
      290 dcl	interval		   char (256) varying;
      291 dcl	interval_idx	   fixed bin;
      292 dcl	delimiter_idx	   fixed bin;
      293 dcl	start_scan_idx	   fixed bin (35);
      294 dcl	scan_length	   fixed bin (35);
      295 
      296 	if interval_spec = "" then do;
      297 	     p_more_intervals = "0"b;
      298 	     p_scan_length = length (p_stuff) - p_start_scan_idx;
      299 	     return;
      300 	end;
      301 	interval_idx = index (interval_spec, " ") - 1;
      302 	if interval_idx = -1 then
      303 	     interval_idx = length (interval_spec);
      304 	interval = substr (interval_spec, 1, interval_idx);
      305 	interval_spec = ltrim (substr (copy (interval_spec, 1), interval_idx + 1));
      306 	delimiter_idx = index (interval, "|");
      307 	if delimiter_idx = 0 then do;
      308 	     p_start_scan_idx = index (substr (p_stuff, p_start_scan_idx), interval);
      309 	     p_start_scan_idx = p_start_scan_idx - index (reverse (substr (p_stuff, 1, p_start_scan_idx)), " ");
      310 	     source_ptr -> temp_seg = substr (p_stuff, p_start_scan_idx);
      311 	     p_scan_length = length (p_stuff);
      312 	     interval_spec = "";
      313 	     p_more_intervals = "0"b;
      314 	     return;
      315 	end;
      316 	else if delimiter_idx = 1 then do;
      317 	     p_scan_length = index (substr (p_stuff, p_start_scan_idx), substr (interval, 2));
      318 	     p_scan_length = p_scan_length - index (reverse (substr (p_stuff, p_start_scan_idx, p_scan_length)), " ");
      319 	     source_ptr -> temp_seg = ltrim (rtrim (substr (p_stuff, p_start_scan_idx, p_scan_length)));
      320 	     p_scan_length = p_start_scan_idx + p_scan_length - 1;
      321 	     if interval_spec = "" then
      322 		p_more_intervals = "0"b;
      323 	     else p_more_intervals = "1"b;
      324 	     return;
      325 	end;
      326 	else if delimiter_idx = length (interval) then do;
      327 	     p_start_scan_idx = index (substr (p_stuff, p_start_scan_idx), interval);
      328 	     p_start_scan_idx = p_start_scan_idx - index (reverse (substr (p_stuff, 1, p_start_scan_idx)), " ");
      329 	     source_ptr -> temp_seg = substr (p_stuff, p_start_scan_idx);
      330 	     p_scan_length = length (p_stuff);
      331 	     interval_spec = "";
      332 	     p_more_intervals = "0"b;
      333 	     return;
      334 	end;
      335 	else do;					/* Both a beginning and an end are given for the interval. */
      336 	     start_scan_idx = index (substr (p_stuff, p_start_scan_idx), substr (interval, 1, delimiter_idx - 1));
      337 	     start_scan_idx =
      338 		start_scan_idx - index (reverse (substr (p_stuff, p_start_scan_idx, start_scan_idx)), " ");
      339 	     p_start_scan_idx = start_scan_idx;
      340 	     scan_length = index (substr (p_stuff, p_start_scan_idx), substr (interval, delimiter_idx + 1));
      341 	     scan_length = scan_length - index (reverse (substr (p_stuff, p_start_scan_idx, scan_length)), " ");
      342 	     p_scan_length = scan_length;
      343 	     if interval_spec = "" then
      344 		p_more_intervals = "0"b;
      345 	     else p_more_intervals = "1"b;
      346 	     return;
      347 	end;
      348      end;
      349 
  1     1 /* BEGIN INCLUDE FILE -- print_data_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*          This structure is used by print_data to set various parameters
  1     5*     controlling the format of the output it produces.
  1     6*
  1     7*/* HISTORY:
  1     8*
  1     9*Written by Lindsey L. Spratt, 06/05/79.
  1    10*Modified:
  1    11*02/08/85 by Lindsey L. Spratt:  Fixed the HISTORY and DESCRIPTION sections.
  1    12**/
  1    13 
  1    14 /* format: style3,idind30,indcomtxt */
  1    15 dcl	print_data_info_version_1	fixed bin options (constant) init (1) internal static;
  1    16 
  1    17 dcl	print_data_info_ptr		ptr;
  1    18 dcl	1 print_data_info		based (print_data_info_ptr),
  1    19 	  2 version		fixed bin,
  1    20 	  2 indentation		fixed bin,	/* This sets the number of spaces by which structure level names are indented. */
  1    21 	  2 value_column		fixed bin,	/* This is the column in which the printing of values begins. */
  1    22 	  2 output_switch		ptr,		/* If null, user_output is used. */
  1    23 	  2 flags,
  1    24 	    3 octal		bit (1) unal,	/* Convert bit strings to octal. */
  1    25 	    3 hex			bit (1) unal,	/* hex, ditto */
  1    26 	    3 pad			bit (34) unaligned,
  1    27 	  2 intervals		char (256) varying;
  1    28 
  1    29 /* End include file print_data_info.incl.pl1 */
      350 
      351 
      352      end print_data;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.7  print_data.pl1                    >spec>install>1111>print_data.pl1
350          1    03/06/85  1031.4  print_data_info.incl.pl1          >ldd>include>print_data_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
bin                                                    builtin function         dcl 78 ref 155 155
bit                                                    builtin function         dcl 78 ref 155 155
cleanup                         001044 stack reference condition                dcl 83 ref 94
code                            000101 automatic       fixed bin(35,0)          dcl 30 set ref 96*
copy                                                   builtin function         dcl 78 ref 121 123 128 132 153 305
current_level_ptr               001076 automatic       pointer                  dcl 210 in procedure "check_level" set ref 212* 214*
                                                                                  215 219 225 226 227* 228 229 230 231* 238 238 246
current_level_ptr               000100 automatic       pointer                  dcl 185 in procedure "clean_up" set ref 187* 187*
                                                                                  188 189*
current_period                  001022 automatic       fixed bin(35,0)          dcl 43 set ref 115* 118 119 121 129*
current_quote                   001023 automatic       fixed bin(35,0)          dcl 44 set ref 137* 140 140 142 142 144 146*
delimiter_idx                   001222 automatic       fixed bin(17,0)          dcl 292 set ref 306* 307 316 326 336 340
error_table_$unimplemented_version
                                000012 external static fixed bin(35,0)          dcl 65 ref 87
first_blank                     001010 automatic       fixed bin(35,0)          dcl 39 set ref 110* 112 113 133 164* 165 165* 167
                                                                                  168 175*
first_interval                  000103 automatic       bit(1)                   packed unaligned dcl 33 set ref 105* 106 107*
flags                     6            based           structure                level 2 packed packed unaligned dcl 1-18
following_double_quote          001025 automatic       fixed bin(35,0)          dcl 46 set ref 142* 144 144
following_quote                 001024 automatic       fixed bin(35,0)          dcl 45 set ref 140* 144 146 148 149
found                           001040 automatic       bit(1)                   packed unaligned dcl 50 set ref 120* 122 131*
get_temp_segments_              000022 constant        entry                    external dcl 73 ref 96
idx                             001072 automatic       fixed bin(17,0)          dcl 208 set ref 213* 236
indentation               1            based           fixed bin(17,0)          level 2 dcl 1-18 ref 128
index                                                  builtin function         dcl 78 ref 110 115 129 140 142 164 175 270 276 301
                                                                                  306 308 309 317 318 327 328 336 337 340 341
interval                        001120 automatic       varying char(256)        dcl 290 set ref 304* 306 308 317 326 327 336 340
interval_idx                    001221 automatic       fixed bin(17,0)          dcl 291 set ref 301* 302 302* 304 305
interval_spec                   000707 automatic       varying char(256)        dcl 38 set ref 102* 296 301 302 304 305* 305 312*
                                                                                  321 331* 343
intervals                 7            based           varying char(256)        level 2 dcl 1-18 ref 102
ioa_                            000016 constant        entry                    external dcl 71 ref 126 174
ioa_$ioa_switch                 000014 constant        entry                    external dcl 70 ref 124 171
ioa_$rsnnl                      000020 constant        entry                    external dcl 72 ref 155
item                            000104 automatic       structure                level 1 unaligned dcl 34
length                                                 builtin function         dcl 78 ref 155 155 155 155 165 298 302 311 326 330
level                           001041 automatic       fixed bin(17,0)          dcl 51 set ref 118* 120* 131*
level_id                               based           structure                level 1 unaligned dcl 57 set ref 189 230 237
ltrim                                                  builtin function         dcl 78 ref 102 133 149 159 168 260 305 319
more                            001037 automatic       bit(1)                   packed unaligned dcl 48 set ref 138* 139 144*
more_intervals                  000102 automatic       bit(1)                   packed unaligned dcl 32 set ref 101* 106 258*
next                     12            based           pointer                  level 2 dcl 57 set ref 188 215 226* 229 238* 242*
next_level_ptr                  001074 automatic       pointer                  dcl 209 set ref 212* 213 214 215* 217 227 229* 231
                                                                                  237* 238 240 241 242
null                                                   builtin function         dcl 49 ref 91 92 111 124 171 187 213 217 226 228 238
                                                                                  242
octal                     6            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 154
output_switch             4            based           pointer                  level 2 dcl 1-18 set ref 124 124* 171 171*
p_code                                 parameter       fixed bin(35,0)          dcl 31 set ref 13 87*
p_found                                parameter       bit(1)                   packed unaligned dcl 207 set ref 203 220* 233* 243*
                                                                                  247*
p_level                                parameter       fixed bin(17,0)          dcl 206 ref 203 213 236
p_more_intervals                       parameter       bit(1)                   packed unaligned dcl 289 set ref 285 297* 313* 321*
                                                                                  323* 332* 343* 345*
p_scan_idx                             parameter       fixed bin(24,0)          dcl 253 set ref 251 257 259*
p_scan_length                          parameter       fixed bin(24,0)          dcl 288 set ref 285 298* 311* 317* 318* 318 318 319
                                                                                  320* 320 330* 342*
p_start_scan_idx                       parameter       fixed bin(24,0)          dcl 287 set ref 285 298 308* 308 309* 309 309 310
                                                                                  317 318 319 320 327* 327 328* 328 328 329 336 337
                                                                                  339* 340 341
p_str                                  parameter       varying char             dcl 205 ref 203 219 225 241 246
p_stuff                                parameter       varying char             dcl 53 ref 13 99 260 298 308 309 310 311 317 318 319
                                                                                  327 328 329 330 336 337 340 341
print_data_info                        based           structure                level 1 unaligned dcl 1-18
print_data_info_ptr                    parameter       pointer                  dcl 1-17 ref 13 86 102 124 124 128 154 171 171 171
                                                                                  174
print_data_info_version_1              constant        fixed bin(17,0)          initial dcl 1-15 ref 86
release_temp_segments_          000024 constant        entry                    external dcl 74 ref 191
reverse                                                builtin function         dcl 78 ref 309 318 328 337 341
root_of_level_list              001042 automatic       pointer                  dcl 52 set ref 92* 111* 187 188* 190 212 240*
rtrim                                                  builtin function         dcl 78 ref 102 260 319
scan_length                     001224 automatic       fixed bin(35,0)          dcl 294 in procedure "get_interval" set ref 340*
                                                                                  341* 341 341 342
scan_length                     001111 automatic       fixed bin(24,0)          dcl 255 in procedure "setup_interval" set ref 258*
                                                                                  259 260 270* 271 272 275 276*
source_ptr                      001020 automatic       pointer                  dcl 42 set ref 97* 99 110 113 133 136 140 142 148
                                                                                  149 149 151 159 164 165 167 168 175 199 200* 260
                                                                                  270 272 276 279 310 319 329
start_scan_idx                  000100 automatic       fixed bin(24,0)          dcl 29 in procedure "print_data" set ref 103* 104*
                                                                                  177*
start_scan_idx                  001223 automatic       fixed bin(35,0)          dcl 293 in procedure "get_interval" set ref 336*
                                                                                  337* 337 337 339
start_scan_idx                  001110 automatic       fixed bin(24,0)          dcl 254 in procedure "setup_interval" set ref 257*
                                                                                  258* 259 260 268* 272 275* 275 276 279
storage_id                      000104 automatic       varying char(256)        level 2 dcl 34 set ref 113* 115 119 121* 121 129
                                                                                  131* 132* 132 171* 174*
storage_id_pad                  000606 automatic       varying char(256)        dcl 37 set ref 117* 123 128* 128 132
str                                    based           varying char(32)         level 2 dcl 57 set ref 219 225* 241* 246*
substr                                                 builtin function         dcl 78 ref 113 119 121 133 136 140 142 148 149 151
                                                                                  155 155 159 167 168 260 272 276 279 304 305 308
                                                                                  309 310 317 317 318 319 327 328 329 336 336 337
                                                                                  340 340 341
sys_info$max_seg_size           000010 external static fixed bin(35,0)          dcl 64 ref 99 100 133 149 159 168 260 269 272 274
                                                                                  279 310 319 329
target_ptr                      001016 automatic       pointer                  dcl 41 set ref 98* 100 133 159 168 198 199* 269 272
                                                                                  272 274 274 279 279
temp_ptr                        001062 automatic       pointer                  dcl 197 set ref 198* 200
temp_seg                               based           varying char             dcl 60 set ref 99* 100* 110 113 133* 133 136 140 142
                                                                                  148 149* 149 151 159* 159 164 165 167 168* 168 175
                                                                                  260* 269* 270 272* 272 272 274* 274 276 279* 279
                                                                                  279 310* 319* 329*
temp_seg_ptrs                   001012 automatic       pointer                  array dcl 40 set ref 91* 96* 97 98 191*
temp_value                      001026 automatic       varying char(32)         dcl 47 set ref 119* 120* 123* 123 124* 126*
value                   101     000104 automatic       varying char(1024)       level 2 dcl 34 set ref 148* 153* 153 155* 155 155
                                                                                  155 155 155 155 167* 171* 174*
value_column              2            based           fixed bin(17,0)          level 2 dcl 1-18 set ref 171* 174*
version                                based           fixed bin(17,0)          level 2 dcl 1-18 ref 86

NAMES DECLARED BY EXPLICIT CONTEXT.
check_level                     001444 constant        entry                    internal dcl 203 ref 120 131
clean_up                        001356 constant        entry                    internal dcl 182 ref 94 179
get_interval                    002057 constant        entry                    internal dcl 285 ref 258
print_data                      000041 constant        entry                    external dcl 13
setup_interval                  001644 constant        entry                    internal dcl 251 ref 104 177
switch_source_and_target        001434 constant        entry                    internal dcl 195 ref 134 160 169 280

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3050        3076    2717        3060
Length      3302    2717        26         167     130           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
print_data                          868 external procedure  is an external procedure.  
on unit on line 94                   64 on unit               
clean_up                             84 internal procedure  is called by several nonquick procedures.  
switch_source_and_target                internal procedure  shares stack frame of external procedure print_data.  
check_level                             internal procedure  shares stack frame of external procedure print_data.  
setup_interval                          internal procedure  shares stack frame of external procedure print_data.  
get_interval                            internal procedure  shares stack frame of external procedure print_data.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 current_level_ptr           clean_up
print_data               000100 start_scan_idx              print_data
                         000101 code                        print_data
                         000102 more_intervals              print_data
                         000103 first_interval              print_data
                         000104 item                        print_data
                         000606 storage_id_pad              print_data
                         000707 interval_spec               print_data
                         001010 first_blank                 print_data
                         001012 temp_seg_ptrs               print_data
                         001016 target_ptr                  print_data
                         001020 source_ptr                  print_data
                         001022 current_period              print_data
                         001023 current_quote               print_data
                         001024 following_quote             print_data
                         001025 following_double_quote      print_data
                         001026 temp_value                  print_data
                         001037 more                        print_data
                         001040 found                       print_data
                         001041 level                       print_data
                         001042 root_of_level_list          print_data
                         001062 temp_ptr                    switch_source_and_target
                         001072 idx                         check_level
                         001074 next_level_ptr              check_level
                         001076 current_level_ptr           check_level
                         001110 start_scan_idx              setup_interval
                         001111 scan_length                 setup_interval
                         001120 interval                    get_interval
                         001221 interval_idx                get_interval
                         001222 delimiter_idx               get_interval
                         001223 start_scan_idx              get_interval
                         001224 scan_length                 get_interval

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     alloc_bit_temp      cat_realloc_chars   call_ext_out_desc   call_int_this       call_int_other
return_mac          longbs_to_fx2       enable_op           shorten_stack       ext_entry_desc      int_entry
repeat              set_chars_eis       set_bits_eis        index_chars_eis     any_to_any_truncate_alloc_storage
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_temp_segments_            ioa_                          ioa_$ioa_switch               ioa_$rsnnl
release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version                          sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000035        86 000054        87 000061        88 000063        91 000064        92 000077        94 000101
     96 000123        97 000150        98 000152        99 000154       100 000172       101 000173       102 000175
    103 000233       104 000235       105 000237       106 000241       107 000247       110 000250       111 000263
    112 000265       113 000270       115 000300       117 000312       118 000313       119 000320       120 000330
    121 000333       122 000354       123 000360       124 000412       126 000446       128 000465       129 000515
    130 000530       131 000532       132 000535       133 000567       134 000631       136 000632       137 000637
    138 000641       139 000643       140 000646       142 000667       144 000705       146 000713       147 000715
    148 000716       149 000727       151 000766       153 000772       154 001017       155 001026       158 001105
    159 001106       160 001140       162 001141       164 001142       165 001154       167 001157       168 001166
    169 001236       171 001237       174 001302       175 001331       176 001344       177 001345       178 001347
    179 001350       180 001354       182 001355       187 001363       188 001372       189 001376       190 001400
    191 001404       193 001433       195 001434       198 001435       199 001437       200 001441       201 001443
    203 001444       212 001455       213 001460       214 001475       215 001477       216 001502       217 001504
    219 001510       220 001521       221 001525       225 001526       226 001536       227 001540       228 001542
    229 001546       230 001551       231 001553       232 001555       233 001556       235 001563       236 001564
    237 001570       238 001574       240 001603       241 001604       242 001616       243 001620       244 001624
    246 001625       247 001637       249 001643       251 001644       257 001646       258 001650       259 001652
    260 001656       268 001726       269 001730       270 001731       271 001743       272 001746       274 001772
    275 002001       276 002003       277 002022       279 002023       280 002055       281 002056       285 002057
    296 002061       297 002066       298 002072       299 002077       301 002100       302 002111       304 002115
    305 002124       306 002165       307 002200       308 002201       309 002222       310 002235       311 002257
    312 002261       313 002262       314 002266       316 002267       317 002271       318 002317       319 002333
    320 002402       321 002406       323 002420       324 002424       326 002425       327 002427       328 002450
    329 002463       330 002505       331 002507       332 002510       333 002514       336 002515       337 002540
    339 002560       340 002561       341 002604       342 002624       343 002625       345 002637       346 002643


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
