ASSEMBLY LISTING OF SEGMENT >spec>install>1110>formline_.alm                                                                                                                                        
ASSEMBLED ON:	11/11/89  0944.3 mst Sat
OPTIONS USED:	-target l68                              list symbols 
ASSEMBLED BY:	ALM Version 8.14 March 1989     
ASSEMBLER CREATED:	06/09/89  1002.3 mst Fri

                                     1  " ******************************************************
                                     2  " *                                                    *
                                     3  " * Copyright, (C) Honeywell Bull Inc., 1987           *
                                     4  " *                                                    *
                                     5  " * Copyright (c) 1987 by Massachusetts Institute of   *
                                     6  " * Technology and Honeywell Information Systems, Inc. *
                                     7  " *                                                    *
                                     8  " * Copyright (c) 1972 by Massachusetts Institute of   *
                                     9  " * Technology and Honeywell Information Systems, Inc. *
                                    10  " *                                                    *
                                    11  " ******************************************************
                                    12  
                                    13  " Completely rewritten by B. L. Wolman on 2/3/74 to use EIS
                                    14  " Modified by R. K. Kanodia on 2/27/75   so that in
                                    15  " ASCII strings mlr would not move zero length sring. See the label mc.
                                    16  " Modified March 75 by Larry Johnson to fix several bugs and modify iteration logic
                                    17  " Modified July 75 by Larry Johnson to enable ^p to handle invalid pointers and to
                                    18  "	implement array processing.
                                    19  " Modified August 1976 by Larry Johnson to implement if/then/else and
                                    20  "	case features.
                                    21  " Modified May 1978 by Larry Johnson to support ^np, and to accept character
                                    22  "	arguments for ^d,^f,^e,^o,^[,^vX etc.
                                    23  " Modified September 1978 by Larry Johnson to support all new pl1 and cobol
                                    24  "	data types (primarily unsigned and 4-bit decimal). All argument
                                    25  "	type processing was cleaned up to remove all internal coding
                                    26  "	of data types. The include file std_descriptor_types is used.
                                    27  " Modified November 1978 by Larry Johnson to add ^t. The entire program was
                                    28  "	changed to use a common procedure to move data to the output buffer.
                                    29  " Modified July 1979 by Larry Johnson to implement formline_$switch.  This
                                    30  "	allows formline_ to generate an unlimited amout of output to be
                                    31  "	to be written to an I/O switch instead of using a fixed size buffer
                                    32  "	supplied by the caller.
                                    33  " Modified December 1983 by Keith Loepere so i/o switch write works in bce.
                                    34  " Modified January 29 1984 by Tom Oke to utilize any_to_any_ re-write and
                                    35  "	generic float decimal data type for extended exponent ranges.
                                    36  
                                    37  " call formline_(control,arg,prs,lrs,pad,alp)
                                    38  
                                    39  " control		number of control string in arg list
                                    40  " arg		number of first arg to control list in arg list
                                    41  " prs		pointer to return string (INPUT) aligned
                                    42  " lrs		length of return string in characters
                                    43  " pad		one if padding required otherwise zero
                                    44  " alp		arglist ptr -- optional (default alp is taken from preceding stack frame)
                                    45  
                                    46  " call formline_$switch(control,arg,iocbp,nl,code,alp)
                                    47  
                                    48  " control		as above
                                    49  " arg		as above
                                    50  " iocbp		pointer to iocb of switch to write upon
                                    51  " nl		one if newline required, otherwise 0
                                    52  " code		standard error code, returned by iox_$put_chars
                                    53  " alp		as above, also optional
                                    54  
    000000                          55  	name	formline_
                                    56  
                        000016      57  	entry	formline_		Primary entry, as called by ioa_
                        000012      58  	entry	ge		for output in GEBCD
                        000022      59  	entry	switch		write output directly to I/O switch
                                    60  
                                    61  	tempd	argp,inptr,buffptr
                                    62  	tempd	pal,size,sizesp
                                    63  	tempd	t1,t2,t3,t4
                                    64  	temp	precision,exponent	EXPONENT MUST PRECEED TEMP1
                                    65  	tempd	temp1(8),temp2(9),work(80)
                                    66  
                                    67  	tempd	save_inptr	pointer to after ^ of current cmd
                                    68  	temp	save_inlen	chars remaining after save_inptr
                                    69  	temp	save_x7.x5	temp storage in ext calls X7/du, X5/dl
                                    70  
                                    71  	temp	inlen
                                    72  	temp	dpd,length
                                    73  	temp	entry_switch	-1 for switch, 0 for normal, 1 for ge
                                    74  	temp	default_precision,cur_arg,num_args,no_more_args
                                    75  
                                    76  	temp	movinh		if >0 output movement inhibited by ^0( or bracket
                                    77  	temp	depth		combined depth of parens and brackets
                                    78  	temp	iter_count(4)	count of iterations - goes from negative to 0
                                    79  	temp	iter_pointer(4)	ptr to ctrl string where iteration started
                                    80  	temp	iter_length(4)	chars remaining in control string at iterate start
                                    81  	temp	iter_cur_arg(4)	position in argument list at start of iteration
                                    82  	temp	iter_argp(4)	argument pointer when iteration started
                                    83  	temp	bracket_clause(4)	current clause in brackets
                                    84  	temp	bracket_search(4)	clause that should be performed
                                    85  	temp	brflags(4)	flags for each level of paren and brackket
                        400000      86  	bool	brflags.movinh,400000	setting of movinh from previouss level
                        200000      87  	bool	brflags.iteration,200000	on means in parens, off means in brackets
                        100000      88  	bool	brflags.indefinite,100000	indefinite iteration - no count given
                                    89  
                                    90  
                                    91  	temp	array_in_progress	+ if in array, 0 if not, - if array checking inhibited
                                    92  	temp	array_mult	multiplier (words or bits) to step thru array
                                    93  	temp	array_packed	non-zero if packed array (array_mult in bits)
                                    94  	temp	array_desc	description word is saved here
                                    95  	temp	array_length	total elements in array (product of all dims)
                                    96  	temp	array_position	current position in array
                                    97  
                                    98  	temp	v_not_done	this switch is set if a ^vX was not evaluated because
                                    99  "				the movinh switch prevented an arg fetch
                                   100  
                        000004     101  	equ	max_depth,4	combined max depth of parens and brackets
                                   102  
                                   103  
                                   104  	include	stack_frame
                                   1-1  "
                                   1-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   1-3  "
                                   1-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   1-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   1-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   1-7  "
                        000020     1-8  	equ	stack_frame.prev_sp,16
                        000020     1-9  	equ	stack_frame.condition_word,16
                        000022    1-10  	equ	stack_frame.next_sp,18
                        000022    1-11  	equ	stack_frame.signaller_word,18
                        000024    1-12  	equ	stack_frame.return_ptr,20
                        000026    1-13  	equ	stack_frame.entry_ptr,22
                        000030    1-14  	equ	stack_frame.operator_ptr,24
                        000030    1-15  	equ	stack_frame.lp_ptr,24
                        000032    1-16  	equ	stack_frame.arg_ptr,26
                        000034    1-17  	equ	stack_frame.static_ptr,28
                        000035    1-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    1-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    1-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    1-21  	equ	stack_frame.translator_id,31
                        000040    1-22  	equ	stack_frame.regs,32
                        000060    1-23  	equ	stack_frame.min_length,48
                        000020    1-24  	equ	stack_frame.flag_word,16
                        020000    1-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    1-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    1-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    1-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    1-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    1-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    1-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    1-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  1-33  
                                  1-34  "
                                  1-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  1-36  "
                                   105  	include	stack_header
                                   2-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   2-2  "
                                   2-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   2-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   2-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   2-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   2-7  
                                   2-8  " HISTORY COMMENTS:
                                   2-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  2-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  2-11  "     added the heap_header_ptr definition
                                  2-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  2-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  2-14  "     Modified to support control point management.  These changes were
                                  2-15  "     actually made in February 1985 by G. Palter.
                                  2-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  2-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  2-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  2-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  2-20  "     some space int the stack header and change the cpd_ptr unal to
                                  2-21  "     cpm_data_ptr (ITS pair).
                                  2-22  "                                                      END HISTORY COMMENTS
                                  2-23  
                        000004    2-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    2-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  2-26  
                        000010    2-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    2-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    2-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    2-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    2-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    2-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    2-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    2-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  2-35  
                        000020    2-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    2-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    2-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    2-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  2-40  
                        000030    2-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    2-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    2-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    2-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  2-45  
                        000040    2-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    2-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    2-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    2-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  2-50  
                        000050    2-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    2-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    2-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    2-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  2-55  
                        000060    2-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    2-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    2-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    2-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    2-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    2-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    2-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    2-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    2-64  	equ	stack_header_end,64			length of stack header
                                  2-65  
                                  2-66  
                                  2-67  
                                  2-68  
                        000000    2-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    2-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  2-71  
                                  2-72  "	The  following constant is an offset within the  pl1  operators table.
                                  2-73  "	It  references a  transfer vector table.
                                  2-74  
                        000551    2-75  	bool	tv_offset,551
                                  2-76  
                                  2-77  
                                  2-78  "	The  following constants are offsets within this transfer vector table.
                                  2-79  
                        001170    2-80  	equ	call_offset,tv_offset+271
                        001171    2-81  	equ	push_offset,tv_offset+272
                        001172    2-82  	equ	return_offset,tv_offset+273
                        001173    2-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    2-84  	equ	entry_offset,tv_offset+275
                                  2-85  
                                  2-86  
                                  2-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   106  	include	eis_micro_ops
                        000020     3-1  	bool	insm,020
                        000040     3-2  	bool	enf,040
                        000060     3-3  	bool	ses,060
                        000100     3-4  	bool	mvzb,100
                        000120     3-5  	bool	mvza,120
                        000140     3-6  	bool	mfls,140
                        000160     3-7  	bool	mflc,160
                        000200     3-8  	bool	insb,200
                        000220     3-9  	bool	insa,220
                        000240    3-10  	bool	insn,240
                        000260    3-11  	bool	insp,260
                        000300    3-12  	bool	ign,300
                        000320    3-13  	bool	mvc,320
                        000340    3-14  	bool	mses,340
                        000360    3-15  	bool	mors,360
                        000400    3-16  	bool	lte,400
                        000420    3-17  	bool	cht,420
                                  3-18  "
                        000010    3-19  	bool	if0,10
                        000004    3-20  	bool	if1,4
                        000002    3-21  	bool	if2,2
                        000001    3-22  	bool	if3,1
                                   107  	include	std_descriptor_types
                                   4-1  "     BEGIN INCLUDE FILE std_descriptor_types.incl.alm
                                   4-2  
                                   4-3  "     Defines values of all standard pl1 and cobol descriptor types
                                   4-4  "     Prepared September 1978 by Larry Johnson
                                   4-5  "     Based on the include file std_descriptor_types.incl.pl1
                                   4-6  "     Modified January 1984 by Tom Oke to add hexadecimal data types, float
                                   4-7  "	decimal extended, float decimal generic and float binary generic.
                                   4-8  
                        000001     4-9  	equ	real_fix_bin_1_dtype,1
                        000002    4-10  	equ	real_fix_bin_2_dtype,2
                        000003    4-11  	equ	real_flt_bin_1_dtype,3
                        000004    4-12  	equ	real_flt_bin_2_dtype,4
                        000005    4-13  	equ	cplx_fix_bin_1_dtype,5
                        000006    4-14  	equ	cplx_fix_bin_2_dtype,6
                        000007    4-15  	equ	cplx_flt_bin_1_dtype,7
                        000010    4-16  	equ	cplx_flt_bin_2_dtype,8
                        000011    4-17  	equ	real_fix_dec_9bit_ls_dtype,9
                        000012    4-18  	equ	real_flt_dec_9bit_dtype,10
                        000013    4-19  	equ	cplx_fix_dec_9bit_ls_dtype,11
                        000014    4-20  	equ	cplx_flt_dec_9bit_dtype,12
                        000015    4-21  	equ	pointer_dtype,13
                        000016    4-22  	equ	offset_dtype,14
                        000017    4-23  	equ	label_dtype,15
                        000020    4-24  	equ	entry_dtype,16
                        000021    4-25  	equ	structure_dtype,17
                        000022    4-26  	equ	area_dtype,18
                        000023    4-27  	equ	bit_dtype,19
                        000024    4-28  	equ	varying_bit_dtype,20
                        000025    4-29  	equ	char_dtype,21
                        000026    4-30  	equ	varying_char_dtype,22
                        000027    4-31  	equ	file_dtype,23
                        000035    4-32  	equ	real_fix_dec_9bit_ls_ovrp_dtype,29
                        000036    4-33  	equ	real_fix_dec_9bit_ts_ovrp_dtype,30
                        000041    4-34  	equ	real_fix_bin_1_uns_dtype,33
                        000042    4-35  	equ	real_fix_bin_2_uns_dtype,34
                        000043    4-36  	equ	real_fix_dec_9bit_uns_dtype,35
                        000044    4-37  	equ	real_fix_dec_9bit_ts_dtype,36
                        000046    4-38  	equ	real_fix_dec_4bit_uns_dtype,38
                        000047    4-39  	equ	real_fix_dec_4bit_ts_dtype,39
                        000051    4-40  	equ	real_fix_dec_4bit_ls_dtype,41
                        000052    4-41  	equ	real_flt_dec_4bit_dtype,42
                        000053    4-42  	equ	real_fix_dec_4bit_ba_ls_dtype,43	(ba means byte aligned)
                        000054    4-43  	equ	real_flt_dec_4bit_ba_dtype,44
                        000055    4-44  	equ	cplx_fix_dec_4bit_ba_ls_dtype,45
                        000056    4-45  	equ	cplx_flt_dec_4bit_ba_dtype,46
                        000057    4-46  	equ	real_flt_hex_1_dtype,47
                        000060    4-47  	equ	real_flt_hex_2_dtype,48
                        000061    4-48  	equ	cplx_flt_hex_1_dtype,49
                        000062    4-49  	equ	cplx_flt_hex_2_dtype,50
                        000121    4-50  	equ	real_flt_dec_extended_dtype,81
                        000122    4-51  	equ	cplx_flt_dec_extended_dtype,82
                        000123    4-52  	equ	real_flt_dec_generic_dtype,83
                        000124    4-53  	equ	cplx_flt_dec_generic_dtype,84
                        000125    4-54  	equ	real_flt_bin_generic_dtype,85
                        000126    4-55  	equ	cplx_flt_bin_generic_dtype,86
                                  4-56  
                        000001    4-57  	equ	cobol_comp_6_dtype,1
                        000001    4-58  	equ	cobol_comp_7_dtype,1
                        000011    4-59  	equ	cobol_display_ls_dtype,9
                        000021    4-60  	equ	cobol_structure_dtype,17
                        000025    4-61  	equ	cobol_char_string_dtype,21
                        000035    4-62  	equ	cobol_display_ls_overp_dtype,29
                        000036    4-63  	equ	cobol_display_ts_overp_dtype,30
                        000043    4-64  	equ	cobol_display_uns_dtype,35
                        000044    4-65  	equ	cobol_display_ts_dtype,36
                        000046    4-66  	equ	cobol_comp_5_uns_dtype,38
                        000046    4-67  	equ	cobol_comp_8_uns_dtype,38
                        000047    4-68  	equ	cobol_comp_5_ts_dtype,39
                        000051    4-69  	equ	cobol_comp_8_ls_dtype,41
                        000126    4-70  	equ	max_dtype,86	" we now include flt bin generic
                                  4-71  
                                  4-72  
    000000                        4-73  numeric_dtype_mask:		" mask defining numeric descriptor types
    000000  aa   777700 000317    4-74  	vfd	o12/7777,o16/0,o2/3,o2/0,o4/17	" 1 - 36
    000001  aa   377760 000000    4-75  	vfd	o1/0,o13/17777,o4/0,o18/0		"37 - 72
    000002  aa   001760 000000    4-76  	vfd	o8/0,o6/77,o4/0,o18/000000		"73 -108
                                  4-77  
    000003                        4-78  binary_dtype_mask: 		" mask defining binary descriptor types
    000003  aa   776000 000014    4-79  	vfd	o18/776000,o18/000014		" 1 - 36
    000004  aa   000360 000000    4-80  	vfd	o18/000360,o18/000000		"37 - 72
    000005  aa   000060 000000    4-81  	vfd	o8/000,o4/0,o2/3,o4/0,o18/000000	"73 -108
                                  4-82  
                                  4-83  "     END INCLUDE FILE std_descriptor_types.incl.alm
                                  4-84  
                                   108  
                                   109  " Miscellaneous character definitions
                                   110  
                        000040     111  	bool	blank,040
                        000055     112  	bool	minus,055		-
                        000012     113  	bool	nl,012		new line
                        000011     114  	bool	ht,011		horizontal tab
                        000014     115  	bool	ff,014		Form-feed/new-page
                        000016     116  	bool	rs,016		redshift
                        000017     117  	bool	bs,017		black shift
                        000060     118  	bool	zero,60		0
                        000056     119  	bool	.,56		period
                        000053     120  	bool	plus,53		+
                        000052     121  	bool	star,52		*
                        000050     122  	bool	lp,50		(
                        000051     123  	bool	rp,51		)
                        000136     124  	bool	esc,136		^
                        000174     125  	bool	bar,174		|
                        000145     126  	bool	e,145		e
                        000166     127  	bool	v,166		v
                                   128  
                                   129  "	Version II descriptor types
                                   130  
                        000001     131  	bool	packed,1
                                   132  	even
    000006  aa   077777 000043     133  nullptr:	its	-1,1		a null pointer
    000007  aa   000001 000000 
    000010  aa   077777 000077     134  ptrmask:	oct	077777000077,777777077077 a pointer mask
    000011  aa   777777 077077 
                                   135  
    000012  aa   000540 6270 00    136  ge:	save
    000013  aa  7 00040 2721 20
    000014  aa   000001 2350 07    137  	lda	1,dl
    000015  0a   000025 7100 00    138  	tra	form
                                   139  
    000016                         140  formline_:
    000016  aa   000540 6270 00    141  	save
    000017  aa  7 00040 2721 20
    000020  aa   000000 2350 07    142  	lda	0,dl
    000021  0a   000025 7100 00    143  	tra	form
                                   144  
    000022  aa   000540 6270 00    145  switch:	save
    000023  aa  7 00040 2721 20
    000024  aa   000001 3350 07    146  	lca	1,dl
                                   147  
    000025  aa  6 00407 7551 00    148  form:	sta	entry_switch	save setting of output switch
                                   149  
    000026  aa  0 00000 2221 00    150  	ldx2	ap|0		get current arglist header
    000027  aa   000014 1020 03    151  	cmpx2	12,du		six arguments?
    000030  0a   000040 6010 00    152  	tnz	no_alp		No
                                   153  
    000031  aa  0 00014 2371 20    154  	ldaq	ap|12,*		Yes, get arglist ptr
    000032  0a   000006 6770 00    155  	eraq	nullptr		Is it null?
    000033  0a   000010 3770 00    156  	anaq	ptrmask		mask out non-unique ptr bits
    000034  0a   000040 6000 00    157  	tze	no_alp		it's null
                                   158  
    000035  aa  0 00014 3521 20    159  	eppbp	ap|12,*		get ptr to arg 6
    000036  aa  2 00000 3521 20    160  	eppbp	bp|0,*		get arglist ptr supplied by caller
    000037  0a   000042 7100 00    161  	tra	*+3
                                   162  
    000040  aa  6 00020 3521 20    163  no_alp:	eppbp	sp|stack_frame.prev_sp,* go back one stack frame
    000041  aa  2 00032 3521 20    164  	eppbp	bp|stack_frame.arg_ptr,* get arglist ptr from this frame
                                   165  
    000042  aa  6 00056 2521 00    166  	spribp	pal		pointer to arg list
    000043  aa  2 00000 2371 00    167  	ldaq	bp|0		get header of arg list
    000044  aa  6 00412 7551 00    168  	sta	num_args		save 2*number of args
    000045  aa  6 00412 2261 00    169  	ldx6	num_args
    000046  0a   000053 6010 00    170  	tnz	args		are there args
    000047  aa  6 00407 2341 00    171  	szn	entry_switch	switch entry?
    000050  0a   000103 6040 00    172  	tmi	setup_output
    000051  aa  0 00010 4501 20    173  	stz	ap|8,*		return null string
    000052  aa  7 00042 7101 20    174  	return			we are done
    000053  aa   000010 3150 07    175  args:	cana	=o10,dl		account for space used for internal
    000054  0a   000056 6000 00    176  	tze	*+2		procedures in computing
    000055  aa   000002 6350 01    177  	eaa	2,au
    000056  aa  6 00405 7551 00    178  	sta	dpd		displacement to descriptor pointers
                                   179  "
                                   180  "	get ptr to and length of control string
                                   181  "
    000057  aa   000001 3350 07    182  	lca	1,dl		load a -1
    000060  aa  6 00456 7551 00    183  	sta	array_in_progress	inhibit getarg from checking for arrays
    000061  aa  0 00002 2351 20    184  	lda	ap|2,*
    000062  aa   000001 7350 00    185  	als	1
    000063  aa   000000 6260 05    186  	eax6	0,al
    000064  0a   002450 7020 00    187  	tsx2	getarg
    000065  aa  6 00456 4501 00    188  	stz	array_in_progress	we care about arrays now
    000066  0a   002625 6220 00    189  	eax2	cstype		we want char string
    000067  0a   002605 7030 00    190  	tsx3	fillin
    000070  0a   000211 7100 00    191  	tra	done		exit if not char string
    000071  aa  6 00052 2521 00    192  	spri2	inptr		save ptr and length
    000072  aa  6 00404 7561 00    193  	stq	inlen
                                   194  
    000073  aa  6 00413 4501 00    195  	stz	no_more_args	init to "there are more args"
    000074  aa  0 00004 2351 20    196  	lda	ap|4,*		get number of first arg
    000075  aa   000001 1750 07    197  	sba	1,dl		start 1 before 1st arg so "nextarg" will be the first
    000076  aa   000001 7350 00    198  	als	1		multiply by 2
    000077  aa   000000 6260 05    199  	eax6	0,al		and move to x6
    000100  aa  6 00411 7461 00    200  	stx6	cur_arg
                                   201  
    000101  aa  6 00415 4501 00    202  	stz	depth		init nesting depth
    000102  aa  6 00414 4501 00    203  	stz	movinh		output movement not inhibited
                                   204  "
                                   205  "	set up output string
                                   206  "
    000103                         207  setup_output:
    000103  aa  6 00517 4501 00    208  	stz	out_moved		number of characters stored
    000104  aa   000001 2350 07    209  	lda	1,dl		starting column
    000105  aa  6 00516 7551 00    210  	sta	out_column
    000106  aa  6 00521 4501 00    211  	stz	out_to_borrow
    000107  aa  6 00407 2341 00    212  	szn	entry_switch	which entry?
    000110  0a   000137 6050 00    213  	tpl	not_switch
    000111  aa  0 00006 3521 20    214  	epp2	ap|6,*		ptr to switch argument
    000112  aa  6 00504 2521 00    215  	spri2	put_chars_arglist+2	setup argument list for put_chars
    000113  aa  6 00517 3521 00    216  	epp2	out_moved
    000114  aa  6 00510 2521 00    217  	spri2	put_chars_arglist+6
    000115  aa  0 00012 3521 20    218  	epp2	ap|10,*		address of error code
    000116  aa  6 00512 2521 00    219  	spri2	put_chars_arglist+8
    000117  aa  6 00512 4501 20    220  	stz	put_chars_arglist+8,*	zero error code
    000120  4a  4 00010 2351 20    221  	lda	sys_info$service_system
    000121  0a   000126 6010 00    222  	tnz	call_iox
    000122  aa  6 00504 3535 20    223  	epp3	put_chars_arglist+2,*	-> bce_iocb_ptr
    000123  aa  3 00000 3535 20    224  	epp3	pr3|0,*			-> bce_iocb
    000124  aa  3 00000 3535 20    225  	epp3	pr3|0,*			-> io routine
    000125  aa   000002 7100 04    226  	tra	2,ic
    000126  4a  4 00012 3535 20    227  call_iox:	epp3	iox_$put_chars
    000127  aa  6 00514 2535 00    228  	spri3	put_chars_codeptr
    000130  0a   003212 2350 00    229  	lda	=o000010000004	arglist header
    000131  aa  6 00502 7551 00    230  	sta	put_chars_arglist
    000132  aa  6 00503 4501 00    231  	stz	put_chars_arglist+1
    000133  aa   000400 2360 07    232  	ldq	256,dl		use 256 character buffer in stack
    000134  aa  6 00520 7561 00    233  	stq	out_left
    000135  aa  6 00522 7561 00    234  	stq	out_size
    000136  0a   000144 7100 00    235  	tra	grow_stack
    000137                         236  not_switch:
    000137  aa  0 00010 2361 20    237  	ldq	ap|8,*		set size
    000140  aa  6 00520 7561 00    238  	stq	out_left
    000141  aa  6 00522 7561 00    239  	stq	out_size
    000142  aa  6 00407 2341 00    240  	szn	entry_switch	is this 6-bit mode?
    000143  0a   000155 6000 00    241  	tze	notge		no, skip
    000144                         242  grow_stack: 
    000144  aa   000003 0760 07    243  	adq	3,dl		convert char count to word count
    000145  aa   000002 7320 00    244  	qrs	2
    000146  aa   000017 0760 07    245  	adq	15,dl		make multiple of 16
    000147  aa   777760 3760 07    246  	anq	=o777760,dl
    000150  aa  7 00024 3535 20    247  	epp3	sb|stack_header.stack_end_ptr,*	extend stack
    000151  aa  3 00000 3521 06    248  	epp2	3|0,ql		by enough to hold output
    000152  aa  7 00024 2521 00    249  	spri2	sb|stack_header.stack_end_ptr
    000153  aa  6 00022 2521 00    250  	spri2	sp|stack_frame.next_sp
    000154  0a   000157 7100 00    251  	tra	setout		join common section
    000155  aa  0 00006 3535 20    252  notge:	epp3	ap|6,*		not 6-bit, get ptr to caller's buffer
    000156  aa  3 00000 3535 20    253  	epp3	3|0,*
    000157  aa  6 00500 2535 00    254  setout:	spri3	out_next
    000160  aa  6 00054 2535 00    255  	spri3	buffptr		save ptr to buffer
    000161  aa  6 00412 2221 00    256  	ldx2	num_args
    000162  0a   000211 6000 00    257  	tze	done
                                   258  "
                                   259  "	locate next ^ in control string
                                   260  "
    000163  0a   002435 7020 00    261  nextarg:	tsx2	getargptr		get ptr to next arg
    000164  aa  6 00052 3521 20    262  loop:	epp2	inptr,*		get ptr to input
                                   263  
    000165  aa  6 00404 2351 00    264  	lda	inlen
    000166  0a   000174 6000 00    265  	tze	no_control	no ^ if zero length string
    000167  aa  0 00003 1245 40    266  	scm	(pr,rl),(du)	look for a ^
    000170  aa   200000 000005     267  	desc9a	2|0,al
    000171  aa   136000 000000     268  	vfd	o9/esc,27/0
    000172  aa  6 00064 0001 00    269  	arg	t1
    000173  0a   000236 6070 00    270  	ttf	have_control
                                   271  "
                                   272  "	no ^ found in rest of string, copy rest of control string into output
                                   273  "
    000174                         274  no_control:
    000174  aa  6 00404 2361 00    275  	ldq	inlen		remaining length
    000175  aa   000000 2350 07    276  	lda	0,dl
    000176  0a   002164 7020 00    277  	tsx2	move_to_outbuf
    000177  aa  6 00407 2341 00    278  	szn	entry_switch	$switch entry?
    000200  0a   000214 6040 00    279  	tmi	finish_switch	yes, nothing to return
    000201  aa  6 00517 2361 00    280  	ldq	out_moved		total characters generated
    000202  aa  0 00010 7561 20    281  	stq	ap|8,*		return to caller
    000203  aa  0 00012 2341 20    282  	szn	ap|10,*		padding requested?
    000204  0a   000211 6000 00    283  	tze	done		no
    000205  aa  6 00520 2351 00    284  	lda	out_left		move blanks to rest of buffer
    000206  aa   000000 2360 07    285  	ldq	0,dl
    000207  aa  6 00414 4501 00    286  	stz	movinh		don't let this be inhibited
    000210  0a   002164 7020 00    287  	tsx2	move_to_outbuf
                                   288  
                                   289  
    000211  aa  6 00407 2341 00    290  done:	szn	entry_switch	should we convert go GEBCD?
    000212  0a   000235 6000 00    291  	tze	thru		no
    000213  0a   000225 6054 00    292  	tpnz	convert_ge
    000214                         293  finish_switch:
    000214  aa  0 00010 2341 20    294  	szn	ap|8,*		need to append nl?
    000215  0a   000223 6000 00    295  	tze	skip_newline	no
    000216  aa  6 00414 4501 00    296  	stz	movinh		in case output inhibited
    000217  0a   000705 3520 00    297  	epp2	new_line_char
    000220  aa   000001 2350 07    298  	lda	1,dl
    000221  aa   000001 2360 07    299  	ldq	1,dl
    000222  0a   002164 7020 00    300  	tsx2	move_to_outbuf
    000223                         301  skip_newline:
    000223  0a   002406 7020 00    302  	tsx2	put_chars_buffer
    000224  0a   000235 7100 00    303  	tra	thru
    000225                         304  convert_ge:
    000225  aa  0 00010 2361 20    305  	ldq	ap|8,*		get number of chars (including padding)
    000226  aa  0 00006 3535 20    306  	epp3	ap|6,*		get ptr to beginning of caller's buffer
    000227  aa  3 00000 3535 20    307  	epp3	3|0,*
    000230  aa  6 00054 3521 20    308  	epp2	buffptr,*		get ptr to 6-bit buffer
    000231  aa  0 00140 1605 40    309  	mvt	(pr,rl),(pr,rl)	now translate to GEBCD in caller's buffer
    000232  aa   200000 000006     310  	desc9a	2|0,ql
    000233  aa   300000 020006     311  	desc6a	3|0,ql
    000234  0a   003130 0000 00    312  	arg	ascii_to_gebcd
                                   313  "
    000235  aa  7 00042 7101 20    314  thru:	return			and exit
                                   315  "
                                   316  "	move string of characters before the ^
                                   317  "
    000236                         318  have_control:
    000236  aa  6 00064 2361 00    319  	ldq	t1		get number of chars preceding the ^
    000237  0a   000245 6000 00    320  	tze	hc1		no work to do if zero
    000240  aa   000000 2350 07    321  	lda	0,dl
    000241  0a   002164 7020 00    322  	tsx2	move_to_outbuf
    000242  aa  6 00064 3351 00    323  	lca	t1		-number of chars moved
    000243  aa  6 00404 0551 00    324  	asa	inlen
    000244  aa  2 00000 5205 05    325  	s9bd	2|0,al		bump ptr
                                   326  
    000245  aa   000001 3350 07    327  hc1:	lca	1,dl		account for the ^
    000246  aa  2 00000 5205 05    328  	s9bd	2|0,al
    000247  aa  6 00404 0551 00    329  	asa	inlen
                                   330  "
                                   331  "	pick up size(s) from field
                                   332  "
    000250  aa  6 00400 2521 00    333  	spri2	save_inptr	save current location in control string
    000251  aa  6 00404 2351 00    334  	lda	inlen
    000252  aa  6 00402 7551 00    335  	sta	save_inlen
    000253  0a   000363 6000 00    336  	tze	bad_field		must have some
    000254                         337  rescan_control:
    000254  aa   000000 6200 00    338  	eax0	0		x0 counts chars in field
    000255  aa  6 00464 4501 00    339  	stz	v_not_done	reset this switch
    000256  aa   000100 1004 00    340  	mlr	(0),(pr),fill(0)	zero size,size+1,sizesp,sizesp+1
    000257  aa   000000 000000     341  	vfd	36/0
    000260  aa   600060 000020     342  	desc9a	size,4*4
    000261  aa   000000 6240 00    343  	eax4	0		set for first size
    000262  0a   002641 7050 00    344  	tsx5	getsize
    000263  aa  0 56000 1065 10    345  	cmpc	(pr,x0),(),fill(.)	is char "."?
    000264  aa   200000 000001     346  	desc9a	2|0,1
    000265  aa   000000 000000     347  	vfd	36/0
    000266  0a   000274 6010 00    348  	tnz	check_key		no, don't try for second size
    000267  aa   000001 0600 03    349  	adx0	1,du		account for the period
    000270  aa   000001 1750 07    350  	sba	1,dl
    000271  0a   000363 6000 00    351  	tze	bad_field
    000272  aa   000001 6240 00    352  	eax4	1		set for second size
    000273  0a   002641 7050 00    353  	tsx5	getsize
    000274                         354  check_key:
    000274  aa   000110 1244 00    355  	scm	(0),(pr,x0)
    000275  0a   000355 000030     356  	desc9a	keys,key_length
    000276  aa   200000 000001     357  	desc9a	2|0,1
    000277  aa  6 00064 0001 00    358  	arg	t1
    000300  0a   000363 6064 00    359  	ttn	bad_field		error if key not known
                                   360  "
                                   361  "	field ok, make sure we have an arg if we need one
                                   362  "
    000301  aa  6 00064 7261 00    363  	lxl6	t1		get position in key string
    000302  aa  6 00414 2341 00    364  	szn	movinh		is output inhibited by ^0(?
    000303  0a   000312 6000 00    365  	tze	arg_start		no
    000304  aa   000011 1060 03    366  	cmpx6	arg2-arg1,du	see if this op is performed
    000305  0a   000310 6040 00    367  	tmi	arg_dummy		no, setup dummy one
    000306  aa   000016 1060 03    368  	cmpx6	arg4-arg1,du
    000307  0a   000316 6040 00    369  	tmi	argok		always perform this
    000310                         370  arg_dummy:
    000310  aa   000030 2260 03    371  	ldx6	dumtra-arg1,du	set up dummy tra
    000311  0a   000316 7100 00    372  	tra	argok		and go adjust pointers
    000312                         373  arg_start:
    000312  aa   000015 1060 03    374  	cmpx6	arg3-arg1,du	do we need an arg?
    000313  aa   000003 6040 04    375  	tmi	3,ic		no, skip check
    000314  aa  6 00413 2341 00    376  	szn	no_more_args
    000315  0a   000363 6010 00    377  	tnz	bad_field
    000316  aa   000001 0600 03    378  argok:	adx0	1,du		account for field
    000317  aa   000001 1750 07    379  	sba	1,dl
    000320  aa  2 00000 5005 10    380  	a9bd	2|0,0
    000321  aa  6 00052 2521 00    381  	spri2	inptr
    000322  aa  6 00404 7551 00    382  	sta	inlen
    000323  0a   000324 7100 16    383  	tra	*+1,6		dispatch
    000324  0a   000665 7100 00    384  arg1:	tra	put_control	|
    000325  0a   000665 7100 00    385  	tra	put_control	/
    000326  0a   000665 7100 00    386  	tra	put_control	-
    000327  0a   000665 7100 00    387  	tra	put_control	R
    000330  0a   000665 7100 00    388  	tra	put_control	B
    000331  0a   000665 7100 00    389  	tra	put_control	^
    000332  0a   000706 7100 00    390  	tra	put_blanks	x
    000333  0a   000612 7100 00    391  	tra	skip		s
    000334  0a   000715 7100 00    392  	tra	tab_to_column	t
    000335  0a   000374 7100 00    393  arg2:	tra	lp_iterate	(
    000336  0a   000442 7100 00    394  	tra	rp_iterate	)
    000337  0a   000564 7100 00    395  	tra	semi_colon	;
    000340  0a   000555 7100 00    396  	tra	right_bracket	]
    000341  0a   000506 7100 00    397  arg3:	tra	left_bracket	[
    000342  0a   001637 7100 00    398  arg4:	tra	put_chars		a
    000343  0a   001743 7100 00    399  	tra	put_decimal	d
    000344  0a   001743 7100 00    400  	tra	put_decimal	i
    000345  0a   001561 7100 00    401  	tra	put_octal		o
    000346  0a   001434 7100 00    402  	tra	put_pointer	p
    000347  0a   001607 7100 00    403  	tra	put_octal_word	w
    000350  0a   000736 7100 00    404  	tra	put_float		f
    000351  0a   001150 7100 00    405  	tra	put_exponential	e
    000352  0a   001671 7100 00    406  	tra	put_acc		A
    000353  0a   001702 7100 00    407  	tra	put_bits		b
    000354  0a   000164 7100 00    408  dumtra:	tra	loop		dummy tra
                                   409  
                                   410  "	The order of the above tra's obviously must correspond to the string
                                   411  "	of keys below. New control types must be positioned so that
                                   412  "	the following relations hold:
                                   413  "	  arg1<=X<arg3  means no argument required for control op
                                   414  "	  arg2<=X<arg4  means that the control op must always be performed,
                                   415  "		      even if output is inhibited
                                   416  "	Note that these ranges overlap.
                                   417  
    000355  aa  174 057 055 122    418  keys:	aci	"|/-RB^xst();][adiopwfeAb"
    000356  aa  102 136 170 163
    000357  aa  164 050 051 073
    000360  aa  135 133 141 144
    000361  aa  151 157 160 167
    000362  aa  146 145 101 142
                                   419  "
                        000030     420  	equ	key_length,24
                                   421  "
                                   422  "	we come here when the field is bad.  move a ^ to output
                                   423  "	and then go look for another field.  when the next field
                                   424  "	(or end of string) is found, the characters of this field
                                   425  "	will get copied to target
                                   426  "
    000363                         427  bad_field:
    000363  aa  6 00400 3521 20    428  	epp2	save_inptr,*	backup pointer
    000364  aa  6 00052 2521 00    429  	spri2	inptr
    000365  aa  6 00402 2351 00    430  	lda	save_inlen	chars left in string
    000366  aa  6 00404 7551 00    431  	sta	inlen
    000367  aa   000001 2350 07    432  	lda	1,dl		move 1 character
    000370  aa   000001 2360 07    433  	ldq	1,dl
    000371  0a   003213 3520 00    434  	epp2	=a^
    000372  0a   002164 7020 00    435  	tsx2	move_to_outbuf
    000373  0a   000164 7100 00    436  	tra	loop		go look for another field
                                   437  "
                                   438  "	start iteration block
                                   439  "
    000374                         440  lp_iterate:
    000374  0a   000422 7020 00    441  	tsx2	get_depth_start	get current nest index
    000375  aa   200000 2650 03    442  	orx5	brflags.iteration,du	this is iteration (not brackets)
    000376  aa   400000 3050 03    443  	canx5	brflags.movinh,du	is output already inhibited?
    000377  0a   000407 6010 00    444  	tnz	lp_iterate2	yes, go do this level once
    000400  aa  6 00062 2341 00    445  	szn	sizesp		was iteration count given?
    000401  0a   000404 6010 00    446  	tnz	lp_iterate4	yes
    000402  aa   100000 2650 03    447  	orx5	brflags.indefinite,du
    000403  0a   000410 7100 00    448  	tra	lp_iterate3
    000404                         449  lp_iterate4:
    000404  aa  6 00060 3361 00    450  	lcq	size		negative of count given
    000405  0a   000410 6010 00    451  	tnz	lp_iterate3
    000406  aa  6 00414 0541 00    452  	aos	movinh		^0( inhibits output
    000407                         453  lp_iterate2:
    000407  aa   000001 3360 07    454  	lcq	1,dl		do loop once
    000410                         455  lp_iterate3:
    000410  aa  6 00452 7451 16    456  	stx5	brflags,6		save flags
    000411  aa  6 00416 7561 16    457  	stq	iter_count,6	save_count
    000412  aa  6 00404 2351 00    458  	lda	inlen		characters remaining in control string
    000413  aa  6 00426 7551 16    459  	sta	iter_length,6	save for end of iteration
    000414  aa  6 00422 5421 16    460  	sprp2	iter_pointer,6	save current control string pointer
    000415  aa  6 00411 2251 00    461  	ldx5	cur_arg		current argument list offset
    000416  aa  6 00432 7451 16    462  	stx5	iter_cur_arg,6	needed for end of iteration test
    000417  aa  6 00050 3521 20    463  	epp2	argp,*		need arg pointer at end too
    000420  aa  6 00436 5421 16    464  	sprp2	iter_argp,6
    000421  0a   000164 7100 00    465  	tra	loop		done
                                   466  
                                   467  "	subroutine called at start of parens or brackets to setup current level
                                   468  
    000422                         469  get_depth_start:
    000422  aa  6 00415 2261 00    470  	ldx6	depth		current depth
    000423  aa   000001 0660 03    471  	adx6	1,du
    000424  aa   000004 1060 03    472  	cmpx6	max_depth,du	too many?
    000425  0a   000363 6054 00    473  	tpnz	bad_field		yes
    000426  aa  6 00415 7461 00    474  	stx6	depth
    000427  aa   000001 1660 03    475  	sbx6	1,du		better index for tables
    000430  aa   000000 2250 03    476  	ldx5	0,du		initialize flag register
    000431  aa  6 00414 2341 00    477  	szn	movinh		output inhibited from previous level?
    000432  aa   000002 6000 04    478  	tze	2,ic		no
    000433  aa   400000 2650 03    479  	orx5	brflags.movinh,du
    000434  aa   000000 7100 12    480  	tra	0,2
                                   481  
                                   482  "	subroutine called for end of parens or brackets to setup current level
                                   483  
    000435                         484  get_depth_end:
    000435  aa  6 00415 2261 00    485  	ldx6	depth		current depth
    000436  0a   000363 6044 00    486  	tmoz	bad_field		nothing in progress
    000437  aa   000001 1660 03    487  	sbx6	1,du
    000440  aa  6 00452 2251 16    488  	ldx5	brflags,6		setup flags for current level also
    000441  aa   000000 7100 12    489  	tra	0,2
                                   490  "
                                   491  "	finish iteration block
                                   492  "
    000442                         493  rp_iterate:
    000442  0a   000435 7020 00    494  	tsx2	get_depth_end	get current depth
    000443  aa   200000 3050 03    495  	canx5	brflags.iteration,du	really in iteration?
    000444  0a   000363 6000 00    496  	tze	bad_field
    000445  aa   100000 3050 03    497  	canx5	brflags.indefinite,du	is there a count?
    000446  0a   000464 6010 00    498  	tnz	rp_inf		no, use special end test
    000447  aa  6 00416 2351 16    499  	lda	iter_count,6	get remaining count
    000450  aa   000001 0750 07    500  	ada	1,dl		count another iteration
    000451  0a   000467 6050 00    501  	tpl	rp1		branch if done
    000452  0a   000475 7020 00    502  	tsx2	arg_used_test	see if iteration will require an argument
    000453  0a   000456 7100 00    503  	tra	do_rp		no, it will not, so ok to repeat
    000454  aa  6 00413 2341 00    504  rp_test:	szn	no_more_args	are there more arguments?
    000455  0a   000467 6010 00    505  	tnz	rp1		no, dont repeat the iteration
    000456  aa  6 00416 7551 16    506  do_rp:	sta	iter_count,6	store remaining count
    000457  aa  6 00422 7621 16    507  	lprp2	iter_pointer,6	load input ptr again
    000460  aa  6 00426 2361 16    508  	ldq	iter_length,6	load back length
    000461  aa  6 00052 2521 00    509  	spri2	inptr		reset input pointer
    000462  aa  6 00404 7561 00    510  	stq	inlen		reset input length
    000463  0a   000164 7100 00    511  	tra	loop		back for next arg
                                   512  
    000464  0a   000475 7020 00    513  rp_inf:	tsx2	arg_used_test	will iteration require an arg
    000465  0a   000467 7100 00    514  	tra	rp1		no, cant loop forever
    000466  0a   000454 7100 00    515  	tra	rp_test		repeat only if args remain
                                   516  "
                                   517  "	done with iteration block or right bracket
                                   518  "
    000467  aa  6 00414 4501 00    519  rp1:	stz	movinh		this will allow output now
    000470  aa   400000 3050 03    520  	canx5	brflags.movinh,du	unless inhibited from lower lovel
    000471  aa   000002 6000 04    521  	tze	2,ic
    000472  aa  6 00414 0541 00    522  	aos	movinh
    000473  aa  6 00415 7461 00    523  	stx6	depth
    000474  0a   000164 7100 00    524  	tra	loop
                                   525  
                                   526  "	This subroutine compares the current argument being processed with the one
                                   527  "	that was current when the loop began. If they are the same, the return is
                                   528  "	to 0,2. Otherwise, the return is to 1,2.
                                   529  
    000475                         530  arg_used_test:
    000475  aa  6 00411 2251 00    531  	ldx5	cur_arg		current offset in argument list
    000476  aa  6 00432 1051 16    532  	cmpx5	iter_cur_arg,6	same as when loop started?
    000477  aa   000001 6010 12    533  	tnz	1,2		no, do the skip return
                                   534  "	if offset is same, the actual argument may be different because
                                   535  "	an array is being scanned.
    000500  aa  6 00050 3521 20    536  	epp2	argp,*		current argument pointer
    000501  aa  6 00072 5421 00    537  	sprp2	t4		store in packed form
    000502  aa  6 00072 2361 00    538  	ldq	t4		get packed pointer
    000503  aa  6 00436 1161 16    539  	cmpq	iter_argp,6	same as beginning pointr?
    000504  aa   000000 6000 12    540  	tze	0,2		yes, loop definitely did not need arg
    000505  aa   000001 7100 12    541  	tra	1,2		skip return, arg was used
                                   542  "
                                   543  "	start if/then/else or case selection (left bracket)
                                   544  
    000506                         545  left_bracket:
    000506  aa   000000 2360 07    546  	ldq	0,dl
    000507  aa  6 00414 2341 00    547  	szn	movinh		is output already inhibited?
    000510  0a   000542 6010 00    548  	tnz	left_bracket4	yes, go to 0th clause (dont get arg)
    000511  0a   002625 6220 00    549  	eax2	cstype		check for character arg
    000512  0a   002605 7030 00    550  	tsx3	fillin
    000513  0a   000525 7100 00    551  	tra	left_bracket5	no
    000514  aa  0 40000 1065 40    552  	cmpc	(pr,rl),(),fill(blank)	check for false
    000515  aa   200000 000006     553  	desc9a	2|0,ql
    000516  0a   000562 000005     554  	desc9a	false,5
    000517  0a   000534 6000 00    555  	tze	left_bracket6	it is, treat like zero bit string
    000520  aa  0 40000 1065 40    556  	cmpc	(pr,rl),(),fill(blank)	check for true
    000521  aa   200000 000006     557  	desc9a	2|0,ql
    000522  0a   000561 000004     558  	desc9a	true,4
    000523  0a   000536 6000 00    559  	tze	left_bracket3	it is, treat like non-zero bit
    000524  0a   000540 7100 00    560  	tra	left_bracket2	go treat as character digits
    000525                         561  left_bracket5:
    000525  0a   002627 6220 00    562  	eax2	bstype		param to test for bit argument
    000526  0a   002605 7030 00    563  	tsx3	fillin		do the test
    000527  0a   000540 7100 00    564  	tra	left_bracket2	not a bit string argument
    000530  aa  0 00000 0665 40    565  	cmpb	(pr,rl),(),fill(0)	check bit string for all zero
    000531  aa   200000 000006     566  	descb	2|0,ql
    000532  aa   000000 000000     567  	descb	0,0
    000533  0a   000536 6010 00    568  	tnz	left_bracket3	string is non-zero
    000534                         569  left_bracket6:
    000534  aa   000002 2360 07    570  	ldq	2,dl		zero string is "else", do second clause
    000535  0a   000542 7100 00    571  	tra	left_bracket4
    000536                         572  left_bracket3:
    000536  aa   000001 2360 07    573  	ldq	1,dl		non-zero string is "then", do first clause
    000537  0a   000542 7100 00    574  	tra	left_bracket4
    000540                         575  left_bracket2:
    000540  0a   001774 7050 00    576  	tsx5	load_fixed_bin
    000541  0a   000363 7100 00    577  	tra	bad_field		error
    000542                         578  left_bracket4:
    000542  0a   000422 7020 00    579  	tsx2	get_depth_start	setup current depth
    000543  aa  6 00452 7451 16    580  	stx5	brflags,6		save flags in stack
    000544  aa  6 00446 7561 16    581  	stq	bracket_search,6	save clause number to execute
    000545  aa   000001 2360 07    582  	ldq	1,dl		initialize current clause number
    000546  aa  6 00442 7561 16    583  	stq	bracket_clause,6
    000547  aa  6 00446 1161 16    584  	cmpq	bracket_search,6	should 1st clause be executed?
    000550  aa   000002 6000 04    585  	tze	2,ic		yes
    000551  aa  6 00414 0541 00    586  	aos	movinh		inhibit output until right clause found
    000552  aa   400000 3050 03    587  	canx5	brflags.movinh,du	output previously inhibited?
    000553  0a   000164 6010 00    588  	tnz	loop		yes, dont advance arg pointer
    000554  0a   000163 7100 00    589  	tra	nextarg
                                   590  
                                   591  "	end of if/then/else or case section
                                   592  
    000555                         593  right_bracket:
    000555  0a   000435 7020 00    594  	tsx2	get_depth_end	set up currnt level
    000556  aa   200000 3050 03    595  	canx5	brflags.iteration,du	is this matching a (?
    000557  0a   000363 6010 00    596  	tnz	bad_field		yes, error 
    000560  0a   000467 7100 00    597  	tra	rp1		terminate
    000561  aa  164 162 165 145    598  true:	aci	"true"
    000562  aa  146 141 154 163    599  false:	aci	"false"
    000563  aa  145 000 000 000
                                   600  "
                                   601  "	clause delimiter (semi_colon)
                                   602  
    000564                         603  semi_colon:
    000564  0a   000435 7020 00    604  	tsx2	get_depth_end
    000565  aa   200000 3050 03    605  	canx5	brflags.iteration,du	be sure not between iterations
    000566  0a   000363 6010 00    606  	tnz	bad_field
    000567  aa   400000 3050 03    607  	canx5	brflags.movinh,du	is output inhibited from previous level
    000570  0a   000164 6010 00    608  	tnz	loop		yes, it shouldn't be changed here
    000571  aa  6 00464 2341 00    609  	szn	v_not_done	did scan fail to get value becuase of movinh?
    000572  0a   000606 6010 00    610  	tnz	semi_colon2	yes, special stuff to do
    000573  aa  6 00060 2361 00    611  	ldq	size		number of clauses to advance
    000574  aa  6 00062 2341 00    612  	szn	sizesp		was it specified?
    000575  aa   000002 6010 04    613  	tnz	2,ic		yes
    000576  aa   000001 2360 07    614  	ldq	1,dl		no, assume 1
    000577  aa  6 00442 0761 16    615  	adq	bracket_clause,6	compute new clause number
    000600  aa  6 00442 7561 16    616  	stq	bracket_clause,6
    000601  aa  6 00414 4501 00    617  	stz	movinh		enable output
    000602  aa  6 00446 1161 16    618  	cmpq	bracket_search,6	should it be enabled?
    000603  aa   000002 6000 04    619  	tze	2,ic		yes, right clause has been found
    000604  aa  6 00414 0541 00    620  	aos	movinh		disable output
    000605  0a   000164 7100 00    621  	tra	loop
                                   622  
                                   623  "	come here when given "^v;" and the and the 'v' was not evaluated
                                   624  "	because the movinh switch suppressed fetching the required arg.
                                   625  "	reset movinh and rescan the control op.
                                   626  
    000606                         627  semi_colon2:
    000606  aa  6 00414 4501 00    628  	stz	movinh
    000607  aa  6 00402 2351 00    629  	lda	save_inlen	reset length
    000610  aa  6 00400 3521 20    630  	epp2	save_inptr,*	and pointer (to after the ^)
    000611  0a   000254 7100 00    631  	tra	rescan_control
                                   632  "
                                   633  "	skip forward over arguments
                                   634  "
    000612  aa  6 00413 2341 00    635  skip:	szn	no_more_args	any more arguments?
    000613  0a   000164 6010 00    636  	tnz	loop		no, so done
    000614  aa  6 00062 2341 00    637  	szn	sizesp		was ^_ns given?
    000615  0a   000620 6010 00    638  	tnz	skip2		yes
    000616  aa   000001 2350 07    639  	lda	1,dl		default is 1
    000617  aa  6 00060 7551 00    640  	sta	size
    000620  aa  6 00060 2351 00    641  skip2:	lda	size		this is now number of ^s to do
    000621  0a   000164 6000 00    642  	tze	loop		done if 0
    000622  aa  6 00456 2341 00    643  	szn	array_in_progress	doing an array now?
    000623  0a   000632 6010 00    644  	tnz	skip_array	yes
    000624  aa   000001 1750 07    645  	sba	1,dl		account for ^s about to be done
    000625  aa  6 00060 7551 00    646  	sta	size		number remaining to do
    000626  0a   002435 7020 00    647  skip3:	tsx2	getargptr		step to next argument
    000627  aa  6 00413 2341 00    648  	szn	no_more_args	see if found last one
    000630  0a   000164 6010 00    649  	tnz	loop		all done
    000631  0a   000620 7100 00    650  	tra	skip2		back to do another ^s
                                   651  
                                   652  "	here to step pointer thru ^_ns array elements
                                   653  
    000632                         654  skip_array:
    000632  aa  6 00462 2361 00    655  	ldq	array_length	length of array
    000633  aa  6 00463 1761 00    656  	sbq	array_position	subtract current position
    000634  aa   000001 0760 07    657  	adq	1,dl		this gives number of array elements
    000635  aa  6 00060 1161 00    658  	cmpq	size		is skip small enough to stay in array
    000636  0a   000644 6054 00    659  	tpnz	step_array	yes
    000637  aa  6 00072 7561 00    660  	stq	t4		number of ^s rest of array will satisfy
    000640  aa  6 00072 1751 00    661  	sba	t4		this is remaining ^s to do
    000641  aa  6 00060 7551 00    662  	sta	size		save this number
    000642  aa  6 00456 4501 00    663  	stz	array_in_progress	no longer processing array
    000643  0a   000626 7100 00    664  	tra	skip3		go back for next argument
    000644                         665  step_array:
    000644  aa  6 00463 0551 00    666  	asa	array_position	adjust current position
    000645  aa   000044 7730 00    667  	lrl	36		get elements skipped in q
    000646  aa  6 00457 4021 00    668  	mpy	array_mult	convert to words or bits
    000647  aa  6 00050 3521 20    669  	eppbp	argp,*		pointer to current element
    000650  aa  6 00460 2341 00    670  	szn	array_packed	is this packed array?
    000651  0a   000654 6010 00    671  	tnz	step_packed_array	yes
    000652  aa  2 00000 3521 06    672  	eppbp	bp|0,ql		add words to pointer
    000653  aa   000002 7100 04    673  	tra	2,ic		go store result
    000654                         674  step_packed_array:
    000654  aa  2 00000 5035 06    675  	abd	bp|0,ql		make bit adjustment in packed array
    000655  aa  6 00050 2521 00    676  	spribp	argp		store result
    000656  0a   000164 7100 00    677  	tra	loop		and done
                                   678  "
                                   679  "	put out special character
                                   680  "
    000657  0a   002435 7020 00    681  mismatch:	tsx2	getargptr		skip bad argument
    000660  aa   000006 2260 03    682  	ldx6	6,du		get special code for arg mismatch
    000661  aa  6 00060 2341 00    683  	szn	size		be sure at least one char is sent
    000662  aa   000002 6010 04    684  	tnz	2,ic
    000663  aa  6 00060 0541 00    685  	aos	size
    000664  aa  6 00062 0541 00    686  	aos	sizesp
                                   687  "
    000665                         688  put_control:
    000665  aa  6 00062 2341 00    689  	szn	sizesp		was size specified
    000666  aa   000002 6010 04    690  	tnz	2,ic		yes, skip
    000667  aa  6 00060 0541 00    691  	aos	size		no, use size = 1
    000670  aa  6 00060 2341 00    692  	szn	size		check for zero
    000671  0a   000164 6000 00    693  	tze	loop
    000672  0a   000703 3520 00    694  	epp2	fill_chars	point at appropriate fill character
    000673  aa  2 00000 5005 16    695  	a9bd	2|0,6
    000674                         696  put_control_loop:
    000674  aa   000001 2350 07    697  	lda	1,dl		move 1 character
    000675  aa   000001 2360 07    698  	ldq	1,dl
    000676  0a   002164 7020 00    699  	tsx2	move_to_outbuf
    000677  aa   000001 3350 07    700  	lca	1,dl
    000700  aa  6 00060 0551 00    701  	asa	size
    000701  0a   000674 6054 00    702  	tpnz	put_control_loop	loop for count requested
    000702  0a   000164 7100 00    703  	tra	loop
                                   704  
    000703                         705  fill_chars:
    000703  aa   014012 011016     706  	vfd	9/ff,9/nl,9/ht,9/rs,9/bs,9/esc,9/star
    000704  aa   017136 052000 
    000705                         707  new_line_char:
    000705  aa   012000 000000     708  	vfd	9/nl,27/0
                                   709  
                                   710  "
                                   711  "	optimized routine for blanks, with one call to move characters
                                   712  
    000706                         713  put_blanks:
    000706  aa   000000 2360 07    714  	ldq	0,dl		no source
    000707  aa  6 00060 2351 00    715  	lda	size
    000710  aa  6 00062 2341 00    716  	szn	sizesp		size given?
    000711  aa   000002 6010 04    717  	tnz	2,ic		yes
    000712  aa   000001 2350 07    718  	lda	1,dl		just do 1
    000713  0a   002164 7020 00    719  	tsx2	move_to_outbuf
    000714  0a   000164 7100 00    720  	tra	loop
                                   721  "
                                   722  "	tab to specified column
                                   723  
    000715                         724  tab_to_column:
    000715  aa  6 00060 2341 00    725  	szn	size		valid column specified?
    000716  0a   000363 6000 00    726  	tze	bad_field		no, error
    000717  aa  6 00063 2341 00    727  	szn	sizesp+1		minimum count secified?
    000720  aa   000002 6010 04    728  	tnz	2,ic		yes
    000721  aa  6 00061 0541 00    729  	aos	size+1		no, assume 1
    000722  aa  6 00060 2351 00    730  	lda	size		column requested
    000723  aa  6 00516 1751 00    731  	sba	out_column	this given number of columns short
    000724  aa  6 00061 1151 00    732  	cmpa	size+1		put out at least minumem spaces
    000725  aa   000002 6050 04    733  	tpl	2,ic
    000726  aa  6 00061 2351 00    734  	lda	size+1
    000727  aa   000000 2360 07    735  	ldq	0,dl		no source chars
    000730  aa  6 00521 4501 00    736  	stz	out_to_borrow	we must ignore borrow and goto column
    000731  0a   002164 7020 00    737  	tsx2	move_to_outbuf	insert spaces
    000732  aa  6 00516 2351 00    738  	lda	out_column	compute overshoot
    000733  aa  6 00060 1751 00    739  	sba	size		ideally, this is zero
    000734  aa  6 00521 7551 00    740  	sta	out_to_borrow	but if not, steal from next field
    000735  0a   000164 7100 00    741  	tra	loop
                                   742  "
                                   743  "	put out F format
                                   744  "
    000736                         745  put_float:
    000736  0a   001403 7020 00    746  	tsx2	compute_precision	compute default precision, leave in q
    000737  aa  6 00062 2341 00    747  	szn	sizesp		was first size specified
    000740  0a   001045 6010 00    748  	tnz	nf		yes, skip
    000741  aa  6 00063 2341 00    749  	szn	sizesp+1		no, was second size specified
    000742  0a   001054 6010 00    750  	tnz	.df		yes, skip
                                   751  "
                                   752  "	have ^f case (or continuation of ^nf case)
                                   753  "	number of digits to use is in q
                                   754  "
    000743  0a   001252 7050 00    755  f1:	tsx5	convert_to_float_dec
    000744  0a   001042 7100 00    756  	tra	f_zero
    000745  0a   001233 6054 00    757  	tpnz	e_format		positive exponent means E format needed
    000746  aa  6 00074 0751 00    758  	ada	precision		get number of digits before decimal point
    000747  0a   001023 6040 00    759  	tmi	f2		special action if negative
    000750  aa   000001 6250 05    760  	eax5	1,al		count decimal point
    000751  aa  0 56140 1005 40    761  	mlr	(pr,rl),(pr,rl),fill(.)	move ddd.
    000752  aa   600076 200005     762  	desc9a	temp1(1),al
    000753  aa   600116 000015     763  	desc9a	temp2,x5
    000754  aa  6 00075 3361 00    764  	lcq	exponent		get number of digits after .
    000755  0a   000775 6000 00    765  	tze	gl		skip if none
    000756  4a  4 00014 3535 20    766  	epp3	pl1_operators_$tct_octal_060
    000757  aa  0 00000 1655 55    767  	tctr	(pr,rl,x5)	count number of trailing zeros
    000760  aa   600076 000006     768  	desc9a	temp1,ql
    000761  aa  3 00000 0001 00    769  	arg	3|0
    000762  aa  6 00066 0001 00    770  	arg	t2
    000763  0a   000775 6064 00    771  	ttn	gl		skip if fractional part all zeros
    000764  aa  6 00140 7551 00    772  	sta	work		save number of digits before .
    000765  aa   000177 2350 07    773  	lda	=o177,dl		isolate number of trailing zeros
    000766  aa  6 00066 3551 00    774  	ansa	t2
    000767  aa  6 00066 1761 00    775  	sbq	t2		compute number of digits to move
    000770  aa  0 00155 1005 55    776  	mlr	(pr,rl,x5),(pr,rl,x5)
    000771  aa   600076 000006     777  	desc9a	temp1,ql
    000772  aa   600116 000006     778  	desc9a	temp2,ql
    000773  aa  6 00140 0761 00    779  	adq	work		get number of digits moved
    000774  aa   000044 7370 00    780  	lls	36		and shift to position
    000775  aa   000001 0750 07    781  gl:	ada	1,dl		get length of number string
                                   782  "
    000776                         783  prefix_sign:
    000776  aa  6 00116 3521 00    784  	epp2	temp2		get ptr to result
    000777  aa   000001 6270 00    785  	eax7	1		get 1 so we can diddle pr
    001000  aa  0 56000 1065 00    786  	cmpc	(pr),(0),fill(.)	is first character a decimal point
    001001  aa   200000 000001     787  	desc9a	2|0,1
    001002  aa   000000 000000     788  	vfd	36/0
    001003  0a   001011 6010 00    789  	tnz	check_sign	no, skip
    001004  aa   060100 1004 00    790  	mlr	(),(pr),fill(zero)	change .ddd to 0.ddd
    001005  aa   000000 000000     791  	vfd	36/0
    001006  aa   277777 600001     792  	desc9a	2|-1(3),1
    001007  aa   000001 0750 07    793  	ada	1,dl		adjust field length
    001010  aa  2 00000 5205 17    794  	s9bd	2|0,x7		and ptr
    001011                         795  check_sign:
    001011  aa  0 55000 1065 00    796  	cmpc	(pr),(0),fill(minus)	was input negative
    001012  aa   600076 000001     797  	desc9a	temp1,1
    001013  aa   000000 000000     798  	vfd	36/0
    001014  0a   001753 6010 00    799  	tnz	move		positive, skip
    001015                         800  prefix_minus:
    001015  aa   055100 1004 00    801  	mlr	(),(pr),fill(minus)	prefix minus sign
    001016  aa   000000 000000     802  	vfd	36/0
    001017  aa   277777 600001     803  	desc9a	2|-1(3),1
    001020  aa   000001 0750 07    804  	ada	1,dl		adjust field length
    001021  aa  2 00000 5205 17    805  	s9bd	2|0,x7
    001022  0a   001753 7100 00    806  	tra	move		and go move number
                                   807  "
                                   808  "	try putting all of precision after the decimal point
                                   809  "
    001023  aa   000000 5310 00    810  f2:	neg	0		get number of zeros required after decimal point
    001024  4a  4 00014 3535 20    811  	epp3	pl1_operators_$tct_octal_060
    001025  aa  0 00000 1655 40    812  	tctr	(pr,rl)		count trailing zeros
    001026  aa   600076 200006     813  	desc9a	temp1(1),ql
    001027  aa  3 00000 0001 00    814  	arg	3|0
    001030  aa  6 00066 0001 00    815  	arg	t2
    001031  aa   000177 2360 07    816  	ldq	=o177,dl		isolate number of trailing zeros
    001032  aa  6 00066 3561 00    817  	ansq	t2
    001033  aa  6 00066 1151 00    818  	cmpa	t2		can we use f format
    001034  0a   001233 6054 00    819  	tpnz	e_format		no, switch to E format
    001035  aa  6 00074 2361 00    820  	ldq	precision		get back precision
    001036  aa  6 00075 3351 00    821  	lca	exponent
    001037  aa  6 00066 1751 00    822  	sba	t2		get rid of trailing zeros
    001040  aa  6 00061 7551 00    823  	sta	size+1
    001041  0a   001060 7100 00    824  	tra	.df1
                                   825  "
                                   826  "	have value of 0 for ^f or ^nf case
                                   827  "
    001042  0a   003214 3520 00    828  f_zero:	epp2	=a0.
    001043  aa   000002 2350 07    829  	lda	2,dl
    001044  0a   001753 7100 00    830  	tra	move
                                   831  "
    001045  aa  6 00063 2341 00    832  nf:	szn	sizesp+1		first size given, was second?
    001046  0a   001052 6010 00    833  	tnz	n.df
                                   834  "
                                   835  "	have ^nf case, use n-1 digits
                                   836  "
    001047  aa  6 00060 2361 00    837  	ldq	size
    001050  aa   000001 1760 07    838  	sbq	1,dl
    001051  0a   000743 7100 00    839  	tra	f1		go join ^f case with precision in q
                                   840  "
                                   841  "	have ^n.df case, use n-1 digits
                                   842  "
    001052  aa  6 00060 2361 00    843  n.df:	ldq	size
    001053  aa   000001 1760 07    844  	sbq	1,dl
                                   845  "
                                   846  "	have ^.df case or continuation of ^n.df case, number of digits is in q
                                   847  "
    001054  aa  6 00061 1161 00    848  .df:	cmpq	size+1		make sure field is big enough
    001055  0a   001131 6040 00    849  	tmi	punt+1
    001056  0a   001252 7050 00    850  	tsx5	convert_to_float_dec	convert
    001057  0a   001133 7100 00    851  	tra	ndf_zero		special action if zero
    001060  aa  6 00067 7541 00    852  .df1:	sti	t2+1		save indicators
    001061  aa   004000 6340 07    853  	ldi	=o4000,dl		prevent overflow fault
    001062  aa  6 00061 2351 00    854  	lda	size+1		get d
    001063  aa  6 00070 1751 00    855  	sba	t3		adjust for exponent correction
    001064  aa   000377 3750 07    856  	ana	=o377,dl		mask to 8 bits
    001065  0a   003215 2750 00    857  	ora	=a+01 		make value 1ed
    001066  aa  6 00066 7551 00    858  	sta	t2		save
    001067  aa   000001 0760 07    859  	adq	1,dl		get precision+1
    001070  aa   000001 6350 06    860  	eaa	1,ql		get precision+2
    001071  aa  1 40340 2265 00    861  	mp3d	(pr),(pr,rl),(pr,rl),round	move to fixed scaled temp
    001072  aa   600066 000004     862  	desc9fl	t2,4
    001073  aa   600076 000001     863  	desc9fl	temp1,au
    001074  aa   600076 010006     864  	desc9ls	temp1,ql
    001075  0a   001130 6170 00    865  	tov	punt		can't use this format if overflow on move
    001076  aa  6 00067 6341 00    866  	ldi	t2+1		restore indicators
    001077  aa  6 00074 2351 00    867  	lda	precision		get number of digits to left of .
    001100  aa  6 00061 1751 00    868  	sba	size+1
    001101  aa   000000 6260 05    869  	eax6	0,al		remember for later
    001102  0a   001120 6000 00    870  	tze	f3		and skip if none
    001103  4a  4 00014 3535 20    871  	epp3	pl1_operators_$tct_octal_060
    001104  aa  0 00000 1645 40    872  	tct	(pr,rl)		count leading zeros
    001105  aa   600076 200005     873  	desc9a	temp1(1),al
    001106  aa  3 00000 0001 00    874  	arg	3|0
    001107  aa  6 00066 0001 00    875  	arg	t2
    001110  aa   000177 2360 07    876  	ldq	=o177,dl		isolate count of zeros
    001111  aa  6 00066 3561 00    877  	ansq	t2
    001112  aa  6 00066 1751 00    878  	sba	t2		get number of non-zero chars
    001113  0a   001120 6000 00    879  	tze	f3		skip if none
    001114  aa  6 00066 2361 00    880  	ldq	t2		get number of zeros
    001115  aa  0 00140 1005 46    881  	mlr	(pr,rl,ql),(pr,rl)	move non-zero chars
    001116  aa   600076 200005     882  	desc9a	temp1(1),al
    001117  aa   600116 000005     883  	desc9a	temp2,al
                                   884  "
                                   885  "	chars to left of . have been moved, number is in a
                                   886  "
    001120  aa  6 00061 2361 00    887  f3:	ldq	size+1		get number of digits after .
    001121  aa   000001 6270 06    888  	eax7	1,ql		include .
    001122  aa  0 56145 1015 56    889  	mrl	(pr,rl,x6),(pr,rl,al),fill(.)	move digits with . on left
    001123  aa   600076 200006     890  	desc9a	temp1(1),ql
    001124  aa   600116 000017     891  	desc9a	temp2,x7
    001125  aa  6 00061 0751 00    892  f4:	ada	size+1		form total length of field
    001126  aa   000001 0750 07    893  	ada	1,dl
    001127  0a   000776 7100 00    894  	tra	prefix_sign	go put on sign
                                   895  "
    001130  aa  6 00067 6341 00    896  punt:	ldi	t2+1		can't use this format
    001131  aa  6 00060 4501 00    897  	stz	size
    001132  0a   001150 7100 00    898  	tra	put_exponential
                                   899  "
                                   900  "	value for .df or n.df format is zero
                                   901  "
    001133  aa   000000 2350 07    902  ndf_zero:	lda	0,dl		assume no zero left of decimal
    001134  aa  6 00061 2361 00    903  	ldq	size+1		get number of digits after .
    001135  aa  6 00074 1161 00    904  	cmpq	precision		is there room for 0 to left?
    001136  aa   000005 6050 04    905  	tpl	5,ic		no, skip
    001137  aa   060100 1004 00    906  	mlr	(),(pr),fill(zero)	move zero
    001140  aa   000000 000000     907  	vfd	36/0
    001141  aa   600116 000001     908  	desc9a	temp2,1
    001142  aa   000001 0750 07    909  	ada	1,dl		account for the zero
    001143  aa   000001 6270 06    910  	eax7	1,ql		get number of zeros plus .
    001144  aa   060145 1004 00    911  	mlr	(),(pr,rl,al),fill(zero)	move . with zero fill
    001145  0a   001231 400001     912  	desc9a	ec1(2),1
    001146  aa   600116 000017     913  	desc9a	temp2,x7
    001147  0a   001125 7100 00    914  	tra	f4		go finish up
                                   915  "
                                   916  "	put out E format
                                   917  "
    001150                         918  put_exponential:
    001150  aa  6 00060 2361 00    919  	ldq	size		use appropriate digits if size is zero
    001151  aa   000002 6010 04    920  	tnz	2,ic
    001152  0a   001403 7020 00    921  	tsx2	compute_precision
    001153  0a   001252 7050 00    922  e0:	tsx5	convert_to_float_dec	convert to decimal
    001154  0a   001226 7100 00    923  	tra	e_zero		special case if zero
    001155  4a  4 00014 3535 20    924  e1:	epp3	pl1_operators_$tct_octal_060
    001156  aa  0 00000 1655 40    925  	tctr	(pr,rl)		count trailing zeros
    001157  aa   600076 200006     926  	desc9a	temp1(1),ql
    001160  aa  3 00000 0001 00    927  	arg	3|0
    001161  aa  6 00066 0001 00    928  	arg	t2
    001162  aa   000177 2350 07    929  	lda	=o177,dl
    001163  aa  6 00066 3551 00    930  	ansa	t2
    001164  aa  6 00066 1761 00    931  	sbq	t2		compute number of digits to edit
    001165  aa  6 00410 7561 00    932  	stq	default_precision
    001166  aa   000001 0760 07    933  	adq	1,dl		get precision+1
    001167  aa   000001 6240 06    934  	eax4	1,ql		get precision+2
    001170  aa  1 40000 0245 40    935  	mvne	(pr,rl),(),(pr,rl)	generate sd.ddd
    001171  aa   600076 010006     936  	desc9ls	temp1,ql
    001172  0a   003174 000010     937  	desc9a	float_edit,8
    001173  aa   600140 000014     938  	desc9a	work,x4
    001174  aa  6 00074 2361 00    939  	ldq	precision		get true exponent
    001175  aa   000001 1760 07    940  	sbq	1,dl
    001176  aa  6 00075 0561 00    941  	asq	exponent
    001177  aa  0 00100 3015 00    942  	btd	(pr),(pr)		convert exponent to decimal
    001200  aa   600075 000004     943  	desc9a	exponent,4
    001201  aa   600076 010013     944  	desc9ls	temp1,11
    001202  aa  1 00000 0245 00    945  	mvne	(pr),(),(pr)	edit to remove leading zeros
    001203  aa   600076 010013     946  	desc9ls	temp1,11
    001204  0a   003176 000005     947  	desc9a	exp_edit,5
    001205  aa   600116 000013     948  	desc9a	temp2,11
    001206  aa   000013 2360 07    949  	ldq	11,dl		remove leading blanks
    001207  0a   002153 7050 00    950  	tsx5	strip_blanks
    001210  aa   000001 6230 05    951  	eax3	1,al		get 1+number of chars in exponent
    001211  aa  1 45154 1015 40    952  	mrl	(pr,rl),(pr,rl,x4),fill(e)	move exponent prefixed by "e"
    001212  aa   200000 000005     953  	desc9a	2|0,al
    001213  aa   600140 000013     954  	desc9a	work,x3
    001214  aa  6 00410 0551 00    955  	asa	default_precision	update true char count
    001215  aa  6 00410 2361 00    956  	ldq	default_precision	length of field is default_precision+3
    001216  aa   000003 0760 07    957  	adq	3,dl
    001217  aa  6 00140 3521 00    958  	epp2	work		get ptr to result
    001220  aa  6 00062 2341 00    959  e2:	szn	sizesp		was size specified
    001221  aa   000002 6010 04    960  	tnz	2,ic
    001222  aa  6 00060 7561 00    961  	stq	size		no, set field size
    001223  aa  6 00060 2351 00    962  	lda	size		get size of field to be filled
    001224  0a   002164 7020 00    963  	tsx2	move_to_outbuf
    001225  0a   000163 7100 00    964  	tra	nextarg
                                   965  "
                                   966  "	value is zero
                                   967  "
    001226  0a   001231 3520 00    968  e_zero:	epp2	ec1
    001227  aa   000005 2360 07    969  	ldq	5,dl
    001230  0a   001220 7100 00    970  	tra	e2		go output
                                   971  "
    001231  aa  040 060 056 145    972  ec1:	aci	" 0.e0"
    001232  aa  060 000 000 000
                                   973  "
                                   974  "	can't use F format, convert to E format
                                   975  "
    001233                         976  e_format:
    001233  aa  6 00060 4501 00    977  	stz	size		act as if size not given
    001234  aa  6 00410 2361 00    978  	ldq	default_precision	get default precision
    001235  aa  6 00074 1161 00    979  	cmpq	precision		check current precision
    001236  0a   001155 6000 00    980  	tze	e1		save, nothing to do
    001237  0a   001153 6050 00    981  	tpl	e0		current smaller, start from beginning
    001240  aa   000002 0760 07    982  	adq	2,dl		get default precision+2
    001241  aa  6 00074 2351 00    983  	lda	precision		get current precision+2
    001242  aa   000002 0750 07    984  	ada	2,dl
    001243  aa  0 00340 3005 40    985  	mvn	(pr,rl),(pr,rl),round	round to default precision
    001244  aa   600076 000005     986  	desc9fl	temp1,al
    001245  aa   600076 000006     987  	desc9fl	temp1,ql
    001246  aa   000002 1760 07    988  	sbq	2,dl		get back default pecision
    001247  aa  6 00074 7561 00    989  	stq	precision		save new precision
    001250  0a   001423 7020 00    990  	tsx2	extract_exponent
    001251  0a   001155 7100 00    991  	tra	e1		go do formatting
                                   992  "
                                   993  "	routine to convert input argument to float
                                   994  "	decimal in temp1.  entered with desired output
                                   995  "	precision in q and source type in x7.
                                   996  "	return with same precision value in q
                                   997  "	and exponent in a.  return is 0,5 if source value
                                   998  "	is 0 and 1,5 if source not 0.
                                   999  "	at return indicators correspond to exponent value.
                                  1000  "
    001252                        1001  convert_to_float_dec:
    001252  aa  6 00403 4451 00   1002  	sxl5	save_x7.x5	save return
    001253  aa   000001 6250 00   1003  	eax5	1		specify rounding
    001254  aa   000246 6260 00   1004  	eax6	2*real_flt_dec_generic_dtype	set target type
                                  1005  "
                                  1006  "	convert to decimal
                                  1007  "
    001255                        1008  convert_to_decimal:
    001255  aa   000073 1160 07   1009  	cmpq	59,dl		make sure max not exceeded
    001256  aa   000002 6044 04   1010  	tmoz	2,ic
    001257  aa   000073 2360 07   1011  	ldq	59,dl
    001260  aa  6 00074 7561 00   1012  	stq	precision		save precision
                                  1013  
    001261  0a   002631 7030 00   1014  	tsx3	test_numeric	see if numeric
    001262  0a   001264 7100 00   1015  	tra	*+2		it isn't, try other stuff
    001263  0a   001267 7100 00   1016  	tra	cv_check_ok	good numeric, proceed
    001264  0a   002625 6220 00   1017  	eax2	cstype		try character
    001265  0a   002605 7030 00   1018  	tsx3	fillin
    001266  0a   000657 7100 00   1019  	tra	mismatch		not character, error
    001267                        1020  cv_check_ok:
    001267  aa  6 00076 3515 00   1021  	epp1	temp1		target ptr
    001270  aa   000246 1060 03   1022  	cmpx6	2*real_flt_dec_generic_dtype,du  see if generic type
    001271  0a   001273 6010 00   1023  	tnz	cv_not_generic	not generic type
    001272  aa  6 00075 3515 00   1024  	epp1	exponent		point to exponent of generic decimal
    001273                        1025  cv_not_generic:
    001273  aa  6 00050 3535 20   1026  	epp3	argp,*		source ptr
    001274  aa  6 00140 3715 00   1027  	epp5	work		scratch area
    001275  0a   001275 3520 00   1028  	epp2	*		set ptr to base of ourselves
    001276  aa  6 00046 2525 00   1029  	spbp2	sp|38		text base pptr
    001277  aa  6 00406 2351 00   1030  	lda	length		get input length & precision
    001300  aa   000014 7730 00   1031  	lrl	12		get scale in left of q, precision in right
    001301  aa   000006 7720 00   1032  	qrl	6
    001302  aa   000014 7730 00   1033  	lrl	12
    001303  aa   000006 7320 00   1034  	qrs	6
    001304  aa  6 00074 2351 00   1035  	lda	precision		target
    001305  aa  6 00403 7471 00   1036  	stx7	save_x7.x5	any_to_any_ may change this
    001306  0a   001355 7160 15   1037  	xec	call_any_to_any_,5	call truncate or round entry
    001307  aa  6 00000 3731 00   1038  	epbp7	sp|0
    001310  aa  6 00403 7251 00   1039  	lxl5	save_x7.x5	restore return offset
    001311  aa  6 00403 2271 00   1040  	ldx7	save_x7.x5
    001312  aa  6 00074 2361 00   1041  	ldq	precision		get target precision
    001313  4a  4 00014 3535 20   1042  	epp3	pl1_operators_$tct_octal_060
    001314  aa  0 00000 1645 40   1043  	tct	(pr,rl)		count leading zeros in decimal value
    001315  aa   600076 200006    1044  	desc9a	temp1(1),ql
    001316  aa  3 00000 0001 00   1045  	arg	3|0
    001317  aa  6 00064 0001 00   1046  	arg	t1
    001320  aa   000000 6064 15   1047  	ttn	0,5		special return if all zero
    001321  aa   000246 1060 03   1048  	cmpx6	2*real_flt_dec_generic_dtype,du d is this float
    001322  aa   000001 6010 15   1049  	tnz	1,5		no, exit
    001323  aa  6 00064 2351 00   1050  	lda	t1
    001324  aa   000077 3750 07   1051  	ana	=o77,dl
    001325  aa  6 00070 7551 00   1052  	sta	t3		save exponent correction
    001326  0a   001335 6000 00   1053  	tze	getexp		skip if no leading zeros
    001327  aa   000000 6220 05   1054  	eax2	0,al		save number of leading zeros
    001330  aa   000000 5310 00   1055  	neg	0		get number of chars afterward
    001331  aa  6 00074 0751 00   1056  	ada	precision
    001332  aa  0 60140 1005 52   1057  	mlr	(pr,rl,x2),(pr,rl),fill(zero)	shift number to left
    001333  aa   600076 200005    1058  	desc9a	temp1(1),al
    001334  aa   600076 200006    1059  	desc9a	temp1(1),ql
                                  1060  
                                  1061  "     We require a true hardware floating representation for ^n.df format
                                  1062  "     determination at ".df1:".  We setup this exponent as the true exp if
                                  1063  "     within range of fixed bin (7), or with (2**7)-1 appropriately signed.
                                  1064  "     .df1: uses the overflow indication used to determine if e-format needs
                                  1065  "     to be used.
                                  1066  
    001335  aa  6 00075 2351 00   1067  getexp:	lda	exponent		move in real exponent
    001336  aa  6 00403 7551 00   1068  	sta	save_x7.x5	setup for hardware exponent
    001337  aa   000177 2350 07   1069  	lda	=127,dl		force high hardware exp
    001340  aa  6 00075 4051 00   1070  	cmg	exponent		in range?
    001341  0a   001346 6050 00   1071  	tpl	getexp.in_range	in range - take normal exponent
    001342  aa  6 00075 1151 00   1072  	cmpa	exponent		see if we store negative exponent
    001343  0a   001345 6040 00   1073  	tmi	getexp.pos	set positive maximum exponent
    001344  aa   777601 2350 07   1074  	lda	=-127,dl		set negative maximum exponent
    001345                        1075  getexp.pos:
    001345  aa  6 00403 7551 00   1076  	sta	save_x7.x5
                                  1077  
    001346                        1078  getexp.in_range:
    001346  aa  6 00075 2351 00   1079  	lda	exponent		convert exponent to signed value
    001347  aa  6 00070 1751 00   1080  	sba	t3		subtract correction
    001350  aa  6 00075 7551 00   1081  	sta	exponent
    001351  aa  0 00106 1005 00   1082  	mlr	(pr),(pr,ql)	set hardware exponent - needed in ^n.df
    001352  aa   600403 600001    1083  	desc9a	save_x7.x5(3),1
    001353  aa   600076 200001    1084  	desc9a	temp1(1),1
    001354  aa   000001 7100 15   1085  	tra	1,5		take normal return
                                  1086  
                                  1087  "	select proper any to any call
                                  1088  
    001355                        1089  call_any_to_any_:
    001355  4a  4 00016 7001 20   1090  	tsx0	any_to_any_$any_to_any_truncate_
    001356  4a  4 00020 7001 20   1091  	tsx0	any_to_any_$any_to_any_round_
                                  1092  "
                                  1093  "	convert input argument to fixed decimal
                                  1094  "	we try to do this without any_to_any_ if at all possible
                                  1095  "	so that wired ring0 code can use it.
                                  1096  "
    001357                        1097  convert_to_fixed_dec:
    001357  aa  6 00403 4451 00   1098  	sxl5	save_x7.x5	save return
    001360  0a   002625 6220 00   1099  	eax2	cstype		try character first
    001361  0a   002605 7030 00   1100  	tsx3	fillin
    001362  0a   001364 7100 00   1101  	tra	*+2		not character
    001363  0a   001377 7100 00   1102  	tra	ctfd		it is character, use any_to_any_
                                  1103  
    001364  0a   001774 7050 00   1104  	tsx5	load_fixed_bin	take our best shot
    001365  0a   001377 7100 00   1105  	tra	ctfd		too hard, let any_to_any_ do it
    001366  aa  6 00104 7571 00   1106  	staq	temp1+6
    001367  aa  6 00050 3521 20   1107  	epp2	argp,*		get ptr to arg
    001370  aa   000027 2360 07   1108  	ldq	23,dl		use precision 23 in simple case
    001371  aa  6 00403 7251 00   1109  	lxl5	save_x7.x5	get return address
    001372  aa  0 00100 3015 00   1110  	btd	(pr),(pr)		convert as if input were fixed bin(71)
    001373  aa   600104 000010    1111  	desc9a	temp1+6,8
    001374  aa   600076 010030    1112  	desc9ls	temp1,24
    001375  aa   000000 6000 15   1113  	tze	0,5		special exit if zero
    001376  aa   000001 7100 15   1114  	tra	1,5		normal exit
                                  1115  
    001377  aa   000000 6250 00   1116  ctfd:	eax5	0		no rounding
    001400  aa   000022 6260 00   1117  	eax6	2*real_fix_dec_9bit_ls_dtype	set type
    001401  aa   000073 2360 07   1118  	ldq	59,dl		precisison
    001402  0a   001255 7100 00   1119  	tra	convert_to_decimal
                                  1120  "
                                  1121  "	compute decimal_precision = ceil(binary_precision/3.32)
                                  1122  "
    001403                        1123  compute_precision:
    001403  aa  6 00406 2361 00   1124  	ldq	length		get length from descriptor
    001404  aa   007777 3760 07   1125  	anq	=o7777,dl		isolate precision
    001405  aa   000000 6350 17   1126  	eaa	0,7		get argument type
    001406  aa   000023 7710 00   1127  	arl	18+1		leave just type
    001407  aa   000001 1750 07   1128  	sba	1,dl
    001410  aa   000000 0664 05   1129  	cmpb	(al),(),fill(0)	is this binary?
    001411  0a   000003 000001    1130  	descb	binary_dtype_mask,1
    001412  aa   000000 000000    1131  	descb	0,0
    001413  0a   001421 6000 00   1132  	tze	set_dp		not binary use precision as is
    001414  0a   003216 4020 00   1133  	mpy	=.301205b-1
    001415  aa   000000 1160 07   1134  	cmpq	0,dl
    001416  aa   000002 6000 04   1135  	tze	2,ic
    001417  aa   000001 0750 07   1136  	ada	1,dl
    001420  aa   000044 7330 00   1137  	lrs	36		get decimal precision in q
    001421                        1138  set_dp:
    001421  aa  6 00410 7561 00   1139  	stq	default_precision	save default precision
    001422  aa   000000 7100 12   1140  	tra	0,2
                                  1141  
                                  1142  
                                  1143  
                                  1144  "	routine to extract exponent from float dec value
                                  1145  "	in temp1 with precision given in q
                                  1146  "
    001423                        1147  extract_exponent:
    001423  aa  0 00100 1005 06   1148  	mlr	(pr,ql),(pr)	extract exponent
    001424  aa   600076 200001    1149  	desc9a	temp1(1),1
    001425  aa   600075 000001    1150  	desc9a	exponent,1
    001426  aa  6 00075 2351 00   1151  	lda	exponent		convert exponent to signed value
    001427  aa   000001 7350 00   1152  	als	1
    001430  aa   000034 7310 00   1153  	ars	28
    001431  aa  6 00070 1751 00   1154  	sba	t3		subtract correction
    001432  aa  6 00075 7551 00   1155  	sta	exponent
    001433  aa   000000 7100 12   1156  	tra	0,2
                                  1157  "
                                  1158  "	put out ptr
                                  1159  "
    001434                        1160  put_pointer:
    001434  aa   000032 1070 03   1161  	cmpx7	2*pointer_dtype,du	is this unpacked case
    001435  0a   001465 6000 00   1162  	tze	pp1		yes, do it
    001436  aa   000036 1070 03   1163  	cmpx7	2*label_dtype,du	is this label var
    001437  0a   001465 6000 00   1164  	tze	pp1		yes, dofirst pointer
    001440  aa   000040 1070 03   1165  	cmpx7	2*entry_dtype,du	is this entry var
    001441  0a   001465 6000 00   1166  	tze	pp1		yes, do first pointer
    001442  aa   000033 1070 03   1167  	cmpx7	2*pointer_dtype+packed,du	is this packed case
    001443  0a   000657 6010 00   1168  	tnz	mismatch		have mismatch if not packed
                                  1169  
                                  1170  "	start here with packed pointer
                                  1171  
    001444  aa  6 00050 3521 20   1172  	epp2	argp,*		address of the packed pointer
    001445  aa  0 03100 0605 00   1173  	csl	(pr),(pr),bool(3)	copy to a word aligned place
    001446  aa   200000 000044    1174  	descb	2|0,36
    001447  aa   600071 000044    1175  	descb	t3+1,36
    001450  aa  6 00071 2351 00   1176  	lda	t3+1
    001451  aa   000000 6360 00   1177  	eaq	0		zero the q
    001452  aa   000022 7730 00   1178  	lrl	18		word offset in q-upper
    001453  aa   000003 7710 00   1179  	arl	3		get bit offset in position
    001454  aa   077000 3750 07   1180  	ana	=o077000,dl	isolate bit offset
    001455  aa  6 00070 7551 00   1181  	sta	t3		store bit offset
    001456  aa  6 00070 2761 00   1182  	orq	t3		bit offset in right place in q
    001457  aa  6 00071 2351 00   1183  	lda	t3+1		get origional pointer
    001460  aa   007777 3750 03   1184  	ana	=o007777,du	keep only segment
    001461  aa   007777 1150 03   1185  	cmpa	=o007777,du	is in packed form of -1?
    001462  aa   000002 6010 04   1186  	tnz	2,ic		no
    001463  aa   077777 2350 03   1187  	lda	=o077777,du	use standard form of -1
    001464  0a   001467 7100 00   1188  	tra	pp2		join common case
                                  1189  
                                  1190  "	start here with unpacked pointer
                                  1191  
    001465  aa  6 00050 2371 20   1192  pp1:	ldaq	argp,*		get unpacked ptr
    001466  0a   000010 3770 00   1193  	anaq	ptrmask		remove un-important bits
                                  1194  
                                  1195  "
                                  1196  "	common packed and unpacked pointer section
                                  1197  
    001467  aa  6 00070 7571 00   1198  pp2:	staq	t3
    001470  aa  6 00064 4501 00   1199  	stz	t1		init output char count
    001471  0a   001535 7020 00   1200  	tsx2	octal_field	put out 6 digits of seg number from au
    001472  aa   174105 1004 00   1201  	mlr	(),(pr,al),fill(bar)	append a |
    001473  aa   000000 000000    1202  	vfd	36/0
    001474  aa   600140 000001    1203  	desc9a	work,1
    001475  aa  6 00064 0541 00   1204  	aos	t1		account for |
    001476  aa  6 00071 2351 00   1205  	lda	t3+1		put out 6 digits of word offset from au
    001477  0a   001535 7020 00   1206  	tsx2	octal_field
    001500  aa  0 00100 3015 00   1207  	btd	(pr),(pr)		convert bit offset to decimal
    001501  aa   600071 400001    1208  	desc9a	t3+1(2),1
    001502  aa   600076 030002    1209  	desc9ns	temp1,2
    001503  0a   001527 6000 00   1210  	tze	ptr_done		done if bit offset is zero
    001504  aa   050105 1004 00   1211  	mlr	(),(pr,al),fill(lp)	append a (
    001505  aa   000000 000000    1212  	vfd	36/0
    001506  aa   600140 000001    1213  	desc9a	work,1
    001507  aa   000001 0750 07   1214  	ada	1,dl		account for (
    001510  aa   000000 6260 00   1215  	eax6	0		assume bit offset is really 2 digits
    001511  aa   000002 2360 07   1216  	ldq	2,dl
    001512  aa  0 60000 1065 00   1217  	cmpc	(pr),(),fill(zero)	is first character a 0?
    001513  aa   600076 000001    1218  	desc9a	temp1,1
    001514  aa   000000 000000    1219  	vfd	36/0
    001515  aa   000003 6010 04   1220  	tnz	3,ic		skip if non-zero
    001516  aa   000001 6260 00   1221  	eax6	1		really only 1 digit
    001517  aa   000001 2360 07   1222  	ldq	1,dl
    001520  aa   000001 6270 06   1223  	eax7	1,ql		get number of digits + 1
    001521  aa  0 51145 1005 56   1224  	mlr	(pr,rl,x6),(pr,rl,al),fill(rp)	add digits followed by )
    001522  aa   600076 000006    1225  	desc9a	temp1,ql
    001523  aa   600140 000017    1226  	desc9a	work,x7
    001524  aa  6 00064 7551 00   1227  	sta	t1		get final count
    001525  aa  6 00064 0561 00   1228  	asq	t1
    001526  aa  6 00064 0541 00   1229  	aos	t1
    001527                        1230  ptr_done:
    001527  aa  6 00140 3521 00   1231  	epp2	work		and go move to target
    001530  aa  6 00064 2361 00   1232  	ldq	t1		number of characters in edited pointer
    001531  aa  6 00060 2351 00   1233  	lda	size		use field width given
    001532  0a   002164 7020 00   1234  	tsx2	move_to_outbuf
    001533  0a   000163 7100 00   1235  	tra	nextarg
                                  1236  "
                                  1237  "	routine to put out from 1 to 6 chars of octal from contents of au
                                  1238  "	into work area.  t1 gives numbers of chars already in work,
                                  1239  "	t1 is updated and left in a at exit
                                  1240  "
    001534  aa   000000 0110 03   1241  	odd			to force rpd odd
    001535                        1242  octal_field:
    001535  aa   000003 6210 00   1243  	eax1	3		init rpd loop
    001536  aa   000022 7710 00   1244  	arl	18		shift au to position
                                  1245  	odd
    001537  aa   015600 5602 00   1246  	rpd	6,0
    001540  aa   000000 7730 11   1247  	lrl	0,1
    001541  aa   000000 7720 11   1248  	qrl	0,1
    001542  0a   003217 2760 00   1249  	orq	=o606060606060	form 6-bit ascii
    001543  aa  6 00076 7561 00   1250  	stq	temp1		save
    001544  aa  1 00000 0205 00   1251  	mve	(pr),(),(pr)	convert to 9-bit ascii with leading blanks
    001545  aa   600076 020006    1252  	desc6a	temp1,6
    001546  0a   003172 000002    1253  	desc9a	oct_edit6,2
    001547  aa   600116 000006    1254  	desc9a	temp2,6
    001550  aa   000006 2360 07   1255  	ldq	6,dl		remove leading blanks
    001551  0a   002153 7050 00   1256  	tsx5	strip_blanks
    001552  aa  6 00064 2361 00   1257  	ldq	t1		get offset to use
    001553  aa  0 00146 1005 40   1258  	mlr	(pr,rl),(pr,rl,ql)	move to work area
    001554  aa   200000 000005    1259  	desc9a	2|0,al
    001555  aa   600140 000005    1260  	desc9a	work,al
    001556  aa  6 00064 0751 00   1261  	ada	t1		update count
    001557  aa  6 00064 7551 00   1262  	sta	t1
    001560  aa   000000 7100 12   1263  	tra	0,2		return to caller
                                  1264  "
                                  1265  "	put out fixed binary integer in signed octal
                                  1266  "
    001561                        1267  put_octal:
    001561  0a   001774 7050 00   1268  	tsx5	load_fixed_bin	load input
    001562  0a   000657 7100 00   1269  	tra	mismatch		bad data type
    001563  aa  6 00064 7571 00   1270  	staq	t1		remember whole value
    001564  aa   000000 7330 00   1271  	lrs	0		test sign
    001565  aa   000002 6050 04   1272  	tpl	2,ic		get abs value
    001566  aa   000000 5330 00   1273  	negl	0
    001567  aa  6 00066 7571 00   1274  	staq	t2		save abs value
    001570  aa  6 00076 3521 00   1275  	epp2	temp1		get ptr to where we want octal
    001571  0a   002140 7050 00   1276  	tsx5	octal		convert first word to 12 digits of octal
    001572  aa  6 00101 3521 00   1277  	epp2	temp1+3		convert 2nd word
    001573  aa  6 00067 2351 00   1278  	lda	t2+1
    001574  0a   002140 7050 00   1279  	tsx5	octal
    001575  aa  1 00000 0245 00   1280  	mvne	(pr),(),(pr)	edit leading zeros into blanks
    001576  aa   600076 030030    1281  	desc9ns	temp1,24
    001577  0a   003173 000003    1282  	desc9a	oct_edit24,3
    001600  aa   600116 000030    1283  	desc9a	temp2,24
    001601  aa   000030 2360 07   1284  	ldq	24,dl		remove leading blanks
    001602  0a   002153 7050 00   1285  	tsx5	strip_blanks
    001603  aa  6 00064 2341 00   1286  	szn	t1		was input negative
    001604  0a   001753 6050 00   1287  	tpl	move		move if positive
    001605  aa   000001 6270 00   1288  	eax7	1
    001606  0a   001015 7100 00   1289  	tra	prefix_minus	put on sign if negative
                                  1290  "
                                  1291  "	put out single word in unsigned octal
                                  1292  "
    001607                        1293  put_octal_word:
    001607  aa  6 00050 2351 20   1294  	lda	argp,*		get word for output
    001610  aa  6 00076 3521 00   1295  	epp2	temp1		get where to put chars
    001611  0a   002140 7050 00   1296  	tsx5	octal
    001612  aa   000014 2350 07   1297  	lda	12,dl		assume size of 12
    001613  aa  6 00062 2341 00   1298  	szn	sizesp		was size specified
    001614  0a   001753 6000 00   1299  	tze	move		no
    001615  aa  6 00060 1151 00   1300  	cmpa	size		size greater than 12?
    001616  0a   001753 6044 00   1301  	tmoz	move		yes, go move with leading spaces
                                  1302  "
                                  1303  "	size < 12, see if we can drop leading zeros
                                  1304  "
    001617  4a  4 00014 3535 20   1305  	epp3	pl1_operators_$tct_octal_060
    001620  aa  0 00000 1645 00   1306  	tct	(pr)		count leading zeros
    001621  aa   600076 000014    1307  	desc9a	temp1,12
    001622  aa  3 00000 0001 00   1308  	arg	3|0
    001623  aa  6 00064 0001 00   1309  	arg	t1
    001624  aa   000177 2360 07   1310  	ldq	=o177,dl		isolate number of leading zeros
    001625  aa  6 00064 3561 00   1311  	ansq	t1
    001626  aa  6 00060 1751 00   1312  	sba	size		get 12-size
    001627  aa  6 00064 1151 00   1313  	cmpa	t1		get min(#zeros,12-size)
    001630  aa   000002 6040 04   1314  	tmi	2,ic
    001631  aa  6 00064 2351 00   1315  	lda	t1
    001632  aa  2 00000 5005 05   1316  	a9bd	2|0,al		adjust ptr
    001633  aa   000000 5310 00   1317  	neg	0		compute new field size
    001634  aa   000014 0750 07   1318  	ada	12,dl
    001635  aa  6 00060 7551 00   1319  	sta	size
    001636  0a   001753 7100 00   1320  	tra	move
                                  1321  "
                                  1322  "	put out ascii string
                                  1323  "
    001637                        1324  put_chars:
    001637  0a   002625 6220 00   1325  	eax2	cstype		we want char info
    001640  0a   002605 7030 00   1326  	tsx3	fillin		go get info about string
    001641  0a   000657 7100 00   1327  	tra	mismatch		error if not right type
                                  1328  "
                                  1329  "	remove trailing blanks from string
                                  1330  "
    001642  4a  4 00022 3535 20   1331  	epp3	pl1_operators_$tct_octal_040
    001643  aa  0 00000 1655 40   1332  	tctr	(pr,rl)		scan backward over blanks
    001644  aa   200000 000006    1333  	desc9a	2|0,ql
    001645  aa  3 00000 0001 00   1334  	arg	3|0
    001646  aa  6 00066 0001 00   1335  	arg	t2
    001647  0a   003220 2350 00   1336  	lda	=o77777777	isolate chars skipped
    001650  aa  6 00066 3551 00   1337  	ansa	t2
    001651  aa  6 00066 1761 00   1338  	sbq	t2		adjust length
    001652  aa  6 00516 2351 00   1339  	lda	out_column	save starting columen
    001653  aa  6 00476 7551 00   1340  	sta	save_out_column
    001654  aa   000000 2350 07   1341  	lda	0,dl		no specifiec length
                                  1342  "
                                  1343  "	move characters pointed at by pr2 into output
                                  1344  "
    001655  0a   002164 7020 00   1345  	tsx2	move_to_outbuf
    001656  aa  6 00062 2341 00   1346  	szn	sizesp		column width specified?
    001657  0a   000163 6000 00   1347  	tze	nextarg		no
    001660  aa  6 00477 2341 00   1348  	szn	newline_moved	any newlines, or friends in data?
    001661  0a   000163 6010 00   1349  	tnz	nextarg		yes, don't try any column adjusting
    001662  aa  6 00476 2351 00   1350  	lda	save_out_column	starting column
    001663  aa  6 00060 0751 00   1351  	ada	size		target column
    001664  aa  6 00516 1751 00   1352  	sba	out_column	amount we are short
    001665  0a   000163 6044 00   1353  	tmoz	nextarg		at or past target
    001666  aa   000000 2360 07   1354  	ldq	0,dl
    001667  0a   002164 7020 00   1355  	tsx2	move_to_outbuf	move spaces to reach descired column
    001670  0a   000163 7100 00   1356  	tra	nextarg
                                  1357  "
                                  1358  "	put out ACC string
                                  1359  "
    001671                        1360  put_acc:
    001671  aa  6 00050 3521 20   1361  	epp2	argp,*		get ptr to acc
    001672  aa  2 00000 3521 20   1362  	epp2	2|0,*
    001673  aa  2 00000 2361 00   1363  	ldq	bp|0		extract the size
    001674  aa   000033 7720 00   1364  	qrl	27
    001675  aa   000000 2350 07   1365  	lda	0,dl
    001676  aa   000001 6260 00   1366  	eax6	1		adjust ptr
    001677  aa  2 00000 5005 16   1367  	a9bd	2|0,6
    001700  0a   002164 7020 00   1368  	tsx2	move_to_outbuf
    001701  0a   000163 7100 00   1369  	tra	nextarg
                                  1370  "
                                  1371  "
                                  1372  "	put out bit string
                                  1373  "
    001702  0a   002627 6220 00   1374  put_bits:	eax2	bstype		want info about bit strings
    001703  0a   002605 7030 00   1375  	tsx3	fillin		go get length in q
    001704  0a   000657 7100 00   1376  	tra	mismatch
    001705  aa  6 00061 2351 00   1377  	lda	size+1		do we have byte size specified
    001706  aa   000002 6054 04   1378  	tpnz	2,ic		yes
    001707  aa   000001 2350 07   1379  	lda	1,dl		no, use 1 bit byte
    001710  aa   000004 1150 07   1380  	cmpa	4,dl		is byte size too big?
    001711  aa   000002 6044 04   1381  	tmoz	2,ic
    001712  aa   000004 2350 07   1382  	lda	4,dl		yes, use hex
    001713  aa  6 00061 7551 00   1383  	sta	size+1		save correct byte size
    001714  aa  6 00061 5061 00   1384  	div	size+1		get number output chars to generate
    001715  aa  6 00062 2341 00   1385  	szn	sizesp		was field size specified
    001716  aa   000004 6000 04   1386  	tze	4,ic		no, skip
    001717  aa  6 00060 1161 00   1387  	cmpq	size		is number greater than size
    001720  aa   000003 6044 04   1388  	tmoz	3,ic
    001721  aa  6 00060 2361 00   1389  	ldq	size		yes, just use size specified
    001722  aa  6 00060 7561 00   1390  	stq	size		save correct field size
    001723  aa  6 00061 7271 00   1391  	lxl7	size+1		get byte size
    001724  aa  2 00000 3715 00   1392  	epp5	2|0		pointer to bit string
    001725                        1393  bit_convert:
    001725  aa  0 03100 0615 40   1394  	csr	(pr,rl),(pr),fill(0),bool(3)	move byte to right end of word
    001726  aa   500000 000017    1395  	descb	5|0,x7
    001727  aa   600076 000044    1396  	descb	temp1,36
    001730  aa  6 00076 7251 00   1397  	lxl5	temp1		load right adjusted byte
    001731  0a   002661 3520 00   1398  	epp2	bit_alpha		get address of converted character
    001732  aa  2 00000 5005 15   1399  	a9bd	2|0,5
    001733  aa   000001 2360 07   1400  	ldq	1,dl		move 1 character
    001734  aa   000001 2350 07   1401  	lda	1,dl		no padding
    001735  0a   002164 7020 00   1402  	tsx2	move_to_outbuf
    001736  aa  5 00000 5035 17   1403  	abd	5|0,7		bump bit address
    001737  aa   000001 3350 07   1404  	lca	1,dl
    001740  aa  6 00060 0551 00   1405  	asa	size		count bytes
    001741  0a   001725 6054 00   1406  	tpnz	bit_convert
    001742  0a   000163 7100 00   1407  	tra	nextarg
                                  1408  "
                                  1409  "	put out fixed binary number in decimal
                                  1410  "
    001743                        1411  put_decimal:
    001743  0a   001357 7050 00   1412  	tsx5	convert_to_fixed_dec	get decimal
    001744  0a   001771 7100 00   1413  	tra	i_zero		skip if zero
    001745  aa   000001 0760 07   1414  	adq	1,dl		get precision + 1
    001746  aa  1 40000 0245 40   1415  	mvne	(pr,rl),(),(pr,rl)	get rid of leading zeros and plus sign
    001747  aa   600076 010006    1416  	desc9ls	temp1,ql
    001750  0a   003170 000006    1417  	desc9a	int_edit,6
    001751  aa   600116 000006    1418  	desc9a	temp2,ql
    001752  0a   002153 7050 00   1419  	tsx5	strip_blanks	go remove blanks
                                  1420  "
                                  1421  "	routine to move string into output with padding on left
                                  1422  "	entered with pr2 pointing at string to move, length of string in a
                                  1423  "
    001753  aa  6 00064 7551 00   1424  move:	sta	t1		save character width
    001754  aa  6 00062 2341 00   1425  	szn	sizesp		was size specified
    001755  aa   000002 6010 04   1426  	tnz	2,ic		yes
    001756  aa  6 00060 7551 00   1427  	sta	size		no, set size appropriately
    001757  aa  6 00060 1151 00   1428  	cmpa	size		is actual field bigger than specified size
    001760  0a   001765 6050 00   1429  	tpl	movea		no leading spaces needed
    001761  aa  6 00060 1751 00   1430  	sba	size
    001762  aa   000000 5310 00   1431  	neg	0		count of leading spaces
    001763  aa   000000 2360 07   1432  	ldq	0,dl		no source characters for spaces
    001764  0a   002164 7020 00   1433  	tsx2	move_to_outbuf
    001765  aa  6 00064 2361 00   1434  movea:	ldq	t1		get field size
    001766  aa   000000 2350 07   1435  	lda	0,dl
    001767  0a   002164 7020 00   1436  	tsx2	move_to_outbuf
    001770  0a   000163 7100 00   1437  	tra	nextarg
                                  1438  
                                  1439  "
                                  1440  "	have 0 value for i format
                                  1441  "
    001771  0a   003214 3520 00   1442  i_zero:	epp2	=a0.
    001772  aa   000001 2350 07   1443  	lda	1,dl
    001773  0a   001753 7100 00   1444  	tra	move
                                  1445  "
                                  1446  "	routine to load fixed bin input arg into aq
                                  1447  "
    001774                        1448  load_fixed_bin:
    001774  0a   002631 7030 00   1449  	tsx3	test_numeric	see if numeric value first
    001775  0a   002057 7100 00   1450  	tra	load_fixed_bit	go try bit
    001776  aa   000000 6350 17   1451  	eaa	0,7		pick up type
    001777  aa   000023 7710 00   1452  	arl	18+1		align and drop packed bit
    002000  aa   000000 2230 03   1453  	ldx3	0,du		0 here means signed
    002001  0a   002026 6360 00   1454  	eaq	load_single	routine for simple signed
    002002  aa   000001 1150 07   1455  	cmpa	real_fix_bin_1_dtype,dl
    002003  0a   002017 6000 00   1456  	tze	load_fixed_ok
    002004  0a   002034 6360 00   1457  	eaq	load_double	routine for double prec signed
    002005  aa   000002 1150 07   1458  	cmpa	real_fix_bin_2_dtype,dl
    002006  0a   002017 6000 00   1459  	tze	load_fixed_ok
    002007  aa   000001 2230 03   1460  	ldx3	1,du		1 here means unsigned
    002010  0a   002031 6360 00   1461  	eaq	load_single_uns
    002011  aa   000041 1150 07   1462  	cmpa	real_fix_bin_1_uns_dtype,dl
    002012  0a   002017 6000 00   1463  	tze	load_fixed_ok
    002013  0a   002034 6360 00   1464  	eaq	load_double
    002014  aa   000042 1150 07   1465  	cmpa	real_fix_bin_2_uns_dtype,dl
    002015  0a   002017 6000 00   1466  	tze	load_fixed_ok
    002016  aa   000000 7100 15   1467  	tra	0,5		non-skip for bad type
                                  1468  
    002017                        1469  load_fixed_ok:
    002017  aa  6 00406 2351 00   1470  	lda	length		be sure no scale 
    002020  aa   000014 7710 00   1471  	arl	12
    002021  aa   007777 3750 07   1472  	ana	=o7777,dl
    002022  aa   000000 6010 15   1473  	tnz	0,5		cant handle non zero scale
    002023  aa   000001 3070 03   1474  	canx7	packed,du		unaligned argument?
    002024  0a   002036 6010 00   1475  	tnz	load_packed_fixed_bin yes
    002025  aa   000000 7100 02   1476  	tra	0,qu		go to handler previously set
                                  1477  
    002026                        1478  load_single:
    002026  aa  6 00050 2351 20   1479  	lda	argp,*		arg is unpacked single precision
    002027  aa   000044 7330 00   1480  	lrs	36
    002030  aa   000001 7100 15   1481  	tra	1,5
                                  1482  
    002031                        1483  load_single_uns:
    002031  aa  6 00050 2361 20   1484  	ldq	argp,*
    002032  aa   000000 2350 07   1485  	lda	0,dl
    002033  aa   000001 7100 15   1486  	tra	1,5
                                  1487  
    002034                        1488  load_double:
    002034  aa  6 00050 2371 20   1489  	ldaq	argp,*
    002035  aa   000001 7100 15   1490  	tra	1,5
                                  1491  "
                                  1492  "	arg is packed, move to aligned temp and then load
                                  1493  "
    002036                        1494  load_packed_fixed_bin:
    002036  aa  6 00406 2351 00   1495  	lda	length		get length
    002037  aa   007777 3750 07   1496  	ana	=o7777,dl
    002040                        1497  load_fixed_bit_join: 
    002040  0a   002053 7160 13   1498  	xec	get_fixed_bin_size,x3 compute field width
    002041  aa   000022 7350 00   1499  	als	18		shift to au
    002042  aa  6 00066 7551 00   1500  	sta	t2		and save
    002043  aa  6 00050 3521 20   1501  	epp2	argp,*		load ptr to arg (including bit offset)
    002044  aa  0 03140 0605 40   1502  	csl	(pr,rl),(pr,rl),bool(3)	move to aligned temp
    002045  aa   200000 000001    1503  	descb	2|0,au
    002046  aa   600064 000001    1504  	descb	t1,au
    002047  aa  6 00064 2371 00   1505  	ldaq	t1		load the aligned value
    002050  aa  6 00066 3221 00   1506  	lcx2	t2		get -(width)
    002051  0a   002055 7160 13   1507  	xec	shift_fixed_bin_field,x3	shift value to position
    002052  aa   000001 7100 15   1508  	tra	1,5		and return
                                  1509  
    002053                        1510  get_fixed_bin_size:
    002053  aa   000001 0750 07   1511  	ada	1,dl		for signed, add 1
    002054  aa   000000 0750 07   1512  	ada	0,dl		for unsigned, do nothing
    002055                        1513  shift_fixed_bin_field:
    002055  aa   000110 7330 12   1514  	lrs	72,2		for signed, use arithmetic shift
    002056  aa   000110 7730 12   1515  	lrl	72,2		for unsigned, use logical shift
                                  1516  
                                  1517  "	try to load a bit string. If it is short enough (<= 72)
                                  1518  "	it is treated like unsigned binary
                                  1519  
    002057                        1520  load_fixed_bit:
    002057  0a   002627 6220 00   1521  	eax2	bstype		see if bit string first
    002060  0a   002605 7030 00   1522  	tsx3	fillin
    002061  0a   002067 7100 00   1523  	tra	load_fixed_char	no, try charracter
    002062  aa   000110 1160 07   1524  	cmpq	72,dl		see if short enough
    002063  aa   000000 6050 15   1525  	tpl	0,5		cant handle it
    002064  aa   000044 7370 00   1526  	lls	36		get length in a
    002065  aa   000001 2230 03   1527  	ldx3	1,du		code for unsigned
    002066  0a   002040 7100 00   1528  	tra	load_fixed_bit_join
                                  1529  "
                                  1530  "
                                  1531  "	try arg as character
                                  1532  "
    002067                        1533  load_fixed_char:
    002067  0a   002625 6220 00   1534  	eax2	cstype		address of character codes
    002070  0a   002605 7030 00   1535  	tsx3	fillin		get pointer and length
    002071  aa   000000 7100 15   1536  	tra	0,5		not character, error
    002072  aa  6 00066 4501 00   1537  	stz	t2		0 will mean positive
    002073  aa   000000 1160 07   1538  	cmpq	0,dl		any chars?
    002074  0a   002135 6000 00   1539  	tze	load_fixed_zero	no, return 0
    002075  aa  0 53000 1065 00   1540  	cmpc	(pr),(),fill(plus)	leading +?
    002076  aa   200000 000001    1541  	desc9a	2|0,1
    002077  aa   000000 000000    1542  	oct	0
    002100  0a   002106 6000 00   1543  	tze	load_fixed_skip_sign yes
    002101  aa  0 55000 1065 00   1544  	cmpc	(pr),(),fill(minus)	leading -?
    002102  aa   200000 000001    1545  	desc9a	2|0,1
    002103  aa   000000 000000    1546  	oct	0
    002104  0a   002111 6010 00   1547  	tnz	load_fixed_digits	no
    002105  aa  6 00066 0541 00   1548  	aos	t2		flag meaning minus
    002106                        1549  load_fixed_skip_sign:
    002106  aa   000001 2350 07   1550  	lda	1,dl
    002107  aa  2 00000 5005 05   1551  	a9bd	2|0,al		bump pointer over sign
    002110  aa   000001 1760 07   1552  	sbq	1,dl		decrement length
    002111                        1553  load_fixed_digits:
    002111  aa   000000 1160 07   1554  	cmpq	0,dl
    002112  0a   002135 6000 00   1555  	tze	load_fixed_zero	no digits left
    002113  aa  6 00064 7561 00   1556  	stq	t1		copy of count
    002114  aa   000000 2350 07   1557  	lda	0,dl		index during loop
    002115                        1558  load_fixed_scan:
    002115  aa   000105 1244 00   1559  	scm	(),(pr,al)	check each char for a digit
    002116  0a   002661 000012    1560  	desc9a	digits,10
    002117  aa   200000 000001    1561  	desc9a	2|0,1
    002120  aa  6 00065 0001 00   1562  	arg	t1+1
    002121  0a   002135 6064 00   1563  	ttn	load_fixed_zero
    002122  aa   000001 0750 07   1564  	ada	1,dl		to next character
    002123  aa  6 00064 1151 00   1565  	cmpa	t1
    002124  0a   002115 6040 00   1566  	tmi	load_fixed_scan
    002125  aa  0 00100 3055 40   1567  	dtb	(pr,rl),(pr)	convert to binary
    002126  aa   200000 030006    1568  	desc9ns	2|0,ql,0
    002127  aa   600064 000010    1569  	desc9a	t1,8
    002130  aa  6 00064 2371 00   1570  	ldaq	t1
    002131  aa  6 00066 2341 00   1571  	szn	t2		should it be -?
    002132  0a   002134 6000 00   1572  	tze	*+2		no
    002133  aa  6 00064 3371 00   1573  	lcaq	t1		use complement
    002134  aa   000001 7100 15   1574  	tra	1,5
    002135                        1575  load_fixed_zero:
    002135  aa   000000 2350 07   1576  	lda	0,dl
    002136  aa   000000 2360 07   1577  	ldq	0,dl
    002137  aa   000001 7100 15   1578  	tra	1,5
                                  1579  "
                                  1580  "	routine to convert fixed bin in a into 12 digits of octal
                                  1581  "	in aligned storage pointed at by pr2
                                  1582  "
                                  1583  	even			to make rpd odd
    002140  aa   000002 6260 00   1584  octal:	eax6	3-1		init count
    002141  aa   000006 6210 00   1585  	eax1	6		init shifts
    002142  aa   000003 6220 00   1586  	eax2	3
                                  1587  	odd
    002143  aa   011600 5602 00   1588  octal1:	rpd	4,0
    002144  aa   000000 7730 12   1589  	lrl	0,2
    002145  aa   000000 7720 11   1590  	qrl	0,1
    002146  0a   003221 2760 00   1591  	orq	=a0000		make into ascii
    002147  aa  2 00000 7561 16   1592  	stq	2|0,6		save
    002150  aa   777777 6260 16   1593  	eax6	-1,6
    002151  0a   002143 6050 00   1594  	tpl	octal1
    002152  aa   000000 7100 15   1595  	tra	0,5
                                  1596  "
                                  1597  "	routine to strip leading blanks from string in temp2
                                  1598  "	entered with length of input string in q
                                  1599  "	returns with ptr to first non-blank in pr2 and length in a
                                  1600  "
    002153                        1601  strip_blanks:
    002153  aa  0 00003 1255 40   1602  	scmr	(pr,rl),(du)		find number of non-blank characters
    002154  aa   600116 000006    1603  	desc9a	temp2,ql
    002155  aa   040000 000000    1604  	vfd	o9/blank
    002156  aa  6 00066 0001 00   1605  	arg	t2
    002157  aa  6 00066 1761 00   1606  	sbq	t2
    002160  aa  6 00116 3521 00   1607  	epp2	temp2		get ptr to first non-blank
    002161  aa  2 00000 5005 06   1608  	a9bd	2|0,ql
    002162  aa  6 00066 2351 00   1609  	lda	t2		get number of chars to output
    002163  aa   000000 7100 15   1610  	tra	0,5
                                  1611  "
                                  1612  "	move characters to output buffer.
                                  1613  "	called with:
                                  1614  "	 q = length of source
                                  1615  "	 a = length of target (> source indicates pad with blanks)
                                  1616  "	 pr2 -> source
                                  1617  
    002164                        1618  move_to_outbuf:
    002164  aa  6 00414 2341 00   1619  	szn	movinh		is output inhibited?
    002165  aa   000000 6010 12   1620  	tnz	0,2		yes, just return
    002166  aa  6 00523 7421 00   1621  	stx2	out_save_x2
    002167  aa  6 00470 2521 00   1622  	spri2	out_save_pr2
    002170  aa  6 00477 4501 00   1623  	stz	newline_moved
    002171  aa  6 00466 7571 00   1624  	staq	move_temp
    002172  aa  6 00467 1751 00   1625  	sba	move_temp+1	compute amount of padding requested
    002173  aa   000002 6050 04   1626  	tpl	2,ic
    002174  aa   000000 2350 07   1627  	lda	0,dl		none
    002175  aa  6 00474 7551 00   1628  	sta	move_padding	save for later
    002176  aa   000000 1160 07   1629  	cmpq	0,dl		any source characters?
    002177  0a   002332 6000 00   1630  	tze	move_source_done	no
    002200  aa  6 00521 2351 00   1631  	lda	out_to_borrow	do we need to borrow any leading spaces?
    002201  0a   002227 6000 00   1632  	tze	move_the_stuff		no
    002202  aa  6 00467 1151 00   1633  	cmpa	move_temp+1	need to borrow more that source length?
    002203  aa   000002 6040 04   1634  	tmi	2,ic		no
    002204  aa  6 00467 2351 00   1635  	lda	move_temp+1	just try for source length
    002205  4a  4 00022 3535 20   1636  	epp3	pl1_operators_$tct_octal_040
    002206  aa  0 00000 1645 40   1637  	tct	(pr,rl)
    002207  aa   200000 000005    1638  	desc9a	2|0,al
    002210  aa  3 00000 0001 00   1639  	arg	3|0
    002211  aa  6 00475 0001 00   1640  	arg	tct_result
    002212  aa   000003 6064 04   1641  	ttn	3,ic		source is all blank
    002213  aa  6 00475 2351 00   1642  	lda	tct_result	get blank count
    002214  0a   003222 3750 00   1643  	ana	=o777777777
    002215  aa   000000 1150 07   1644  	cmpa	0,dl		any leading blanks?
    002216  0a   002226 6000 00   1645  	tze	nothing_to_borrow
    002217  aa  6 00466 7551 00   1646  	sta	move_temp		amount borrowed
    002220  aa  6 00466 1761 00   1647  	sbq	move_temp		adjust source length
    002221  aa  2 00000 5005 05   1648  	a9bd	2|0,al		adjust source pointer
    002222  aa   000000 5310 00   1649  	neg
    002223  aa  6 00521 0551 00   1650  	asa	out_to_borrow	less to borrow now
    002224  aa   000000 1160 07   1651  	cmpq	0,dl		source exhausted?
    002225  0a   002332 6000 00   1652  	tze	move_source_done	yes
    002226                        1653  nothing_to_borrow:
    002226  aa  6 00521 4501 00   1654  	stz	out_to_borrow	tried as hard as possible
    002227                        1655  move_the_stuff:
    002227  aa  6 00524 7561 00   1656  	stq	left_to_move
    002230  aa  6 00520 1161 00   1657  	cmpq	out_left		will source fit in buffer?
    002231  aa   000002 6040 04   1658  	tmi	2,ic		yes
    002232  aa  6 00520 2361 00   1659  	ldq	out_left		use only what fits
    002233  aa  6 00500 3535 20   1660  	epp3	out_next,*	get current pointer
    002234  aa  0 00140 1005 40   1661  	mlr	(pr,rl),(pr,rl)
    002235  aa   200000 000006    1662  	desc9a	2|0,ql
    002236  aa   300000 000006    1663  	desc9a	3|0,ql
    002237  aa  3 00000 5005 06   1664  	a9bd	3|0,ql		adjust output pointer
    002240  aa  6 00500 2535 00   1665  	spri3	out_next
    002241  aa  2 00000 3535 00   1666  	epp3	2|0		compute adjust input pointer
    002242  aa  3 00000 5005 06   1667  	a9bd	3|0,ql
    002243  aa  6 00472 2535 00   1668  	spri3	rest_of_source
    002244  aa  6 00517 0561 00   1669  	asq	out_moved		accumulate characters moved
    002245  aa  6 00466 7561 00   1670  	stq	move_temp
    002246  aa  6 00466 3351 00   1671  	lca	move_temp
    002247  aa  6 00520 0551 00   1672  	asa	out_left		space left in output buffer
    002250  aa  6 00524 0551 00   1673  	asa	left_to_move
                                  1674  
                                  1675  "	scan output to adjust column position
                                  1676  
    002251                        1677  out_scan:
    002251  aa   000000 1160 07   1678  	cmpq	0,dl		any characters?
    002252  0a   002316 6000 00   1679  	tze	check_more_to_move	no
    002253  aa  0 00000 1645 40   1680  	tct	(pr,rl)		look for interesting characters
    002254  aa   200000 000006    1681  	desc9a	2|0,ql
    002255  0a   002730 0000 00   1682  	arg	out_scan_table
    002256  aa  6 00475 0001 00   1683  	arg	tct_result
    002257  0a   002315 6064 00   1684  	ttn	out_normal	all regular vanilla characters
    002260  aa  6 00475 2351 00   1685  	lda	tct_result	get count of plain characters before interesting one
    002261  0a   003222 3750 00   1686  	ana	=o777777777
    002262  aa  6 00516 0551 00   1687  	asa	out_column	update column position for normal characters
    002263  aa   000001 0750 07   1688  	ada	1,dl		char count including interesting one
    002264  aa  2 00000 5005 05   1689  	a9bd	2|0,al
    002265  aa  6 00466 7551 00   1690  	sta	move_temp
    002266  aa  6 00466 1761 00   1691  	sbq	move_temp		remaining characters to scan
    002267  aa  6 00475 2351 00   1692  	lda	tct_result
    002270  aa   000033 7710 00   1693  	arl	27		isolate tct result code
    002271  0a   002271 7100 05   1694  	tra	*,al		branch based on character found
    002272  0a   002275 7100 00   1695  	tra	out_newline
    002273  0a   002301 7100 00   1696  	tra	out_backspace
    002274  0a   002304 7100 00   1697  	tra	out_tab
                                  1698  
    002275                        1699  out_newline:
    002275  aa   000001 2350 07   1700  	lda	1,dl		set column back to 1
    002276  aa  6 00516 7551 00   1701  	sta	out_column
    002277  aa  6 00477 0541 00   1702  	aos	newline_moved	remember this
    002300  0a   002251 7100 00   1703  	tra	out_scan
    002301                        1704  out_backspace:
    002301  aa   000001 3350 07   1705  	lca	1,dl		back up one column
    002302  aa  6 00516 0551 00   1706  	asa	out_column
    002303  0a   002251 7100 00   1707  	tra	out_scan
                                  1708  
    002304  aa  6 00466 7561 00   1709  out_tab:	stq	move_temp
    002305  aa  6 00516 2361 00   1710  	ldq	out_column	get current column
    002306  aa   000011 0760 07   1711  	adq	9,dl		compute next tab stop
    002307  aa   000012 5060 07   1712  	div	10,dl
    002310  aa   000012 4020 07   1713  	mpy	10,dl
    002311  aa   000001 0760 07   1714  	adq	1,dl
    002312  aa  6 00516 7561 00   1715  	stq	out_column
    002313  aa  6 00466 2361 00   1716  	ldq	move_temp
    002314  0a   002251 7100 00   1717  	tra	out_scan
                                  1718  
    002315                        1719  out_normal:
    002315  aa  6 00516 0561 00   1720  	asq	out_column	regular characters take 1 column each
                                  1721  
    002316                        1722  check_more_to_move:
    002316  aa  6 00407 2341 00   1723  	szn	entry_switch	switch entry?
    002317  0a   002332 6050 00   1724  	tpl	move_source_done	no
    002320  aa  6 00524 2341 00   1725  	szn	left_to_move	more stuff?
    002321  0a   002332 6000 00   1726  	tze	move_source_done	no
    002322  0a   002406 7020 00   1727  	tsx2	put_chars_buffer	dump what we have
    002323  aa  6 00524 2361 00   1728  	ldq	left_to_move
    002324  aa  6 00472 3521 20   1729  	epp2	rest_of_source,*
    002325  aa  6 00522 1161 00   1730  	cmpq	out_size		very big string to write?
    002326  0a   002227 6044 00   1731  	tmoz	move_the_stuff	no, routine stuff
    002327  0a   002431 7020 00   1732  	tsx2	put_chars_string	write it all in one iox_ call
    002330  aa  6 00524 0321 00   1733  	ldqc	left_to_move	length to scan
    002331  0a   002251 7100 00   1734  	tra	out_scan		must scan to keep column accurate
    002332                        1735  move_source_done:
    002332  aa  6 00520 2341 00   1736  	szn	out_left		buffer full?
    002333  0a   002337 6010 00   1737  	tnz	check_padding	no
    002334  aa  6 00407 2341 00   1738  	szn	entry_switch
    002335  0a   000211 6050 00   1739  	tpl	done		not switch entry
    002336  0a   002406 7020 00   1740  	tsx2	put_chars_buffer
    002337                        1741  check_padding: 
    002337  aa  6 00474 2351 00   1742  	lda	move_padding	any padding needed at end?
    002340  0a   002376 6000 00   1743  	tze	move_output_return	no
    002341  aa  6 00521 1151 00   1744  	cmpa	out_to_borrow	see if some of these can be borrowed
    002342  0a   002346 6040 00   1745  	tmi	move_borrows_all	we should steal them all
    002343  aa  6 00521 1751 00   1746  	sba	out_to_borrow	reduce by needed columns
    002344  aa  6 00521 4501 00   1747  	stz	out_to_borrow
    002345  0a   002351 7100 00   1748  	tra	move_the_padding
    002346                        1749  move_borrows_all:
    002346  aa   000000 5310 00   1750  	neg
    002347  aa  6 00521 0551 00   1751  	asa	out_to_borrow	less to borrow later
    002350  0a   002376 7100 00   1752  	tra	move_output_return
    002351                        1753  move_the_padding:
    002351  aa  6 00524 7551 00   1754  	sta	left_to_move
    002352  aa  6 00520 1151 00   1755  	cmpa	out_left		room to do it all?
    002353  aa   000002 6040 04   1756  	tmi	2,ic		yes
    002354  aa  6 00520 2351 00   1757  	lda	out_left
    002355  aa  6 00500 3535 20   1758  	epp3	out_next,*
    002356  aa   040140 1004 00   1759  	mlr	(),(pr,rl),fill(blank)
    002357  aa   000000 000000    1760  	desc9a	0,0
    002360  aa   300000 000005    1761  	desc9a	3|0,al
    002361  aa  3 00000 5005 05   1762  	a9bd	3|0,al
    002362  aa  6 00500 2535 00   1763  	spri3	out_next
    002363  aa  6 00516 0551 00   1764  	asa	out_column	blanks take one column each
    002364  aa  6 00517 0551 00   1765  	asa	out_moved
    002365  aa   000000 5310 00   1766  	neg
    002366  aa  6 00520 0551 00   1767  	asa	out_left
    002367  aa  6 00524 0551 00   1768  	asa	left_to_move
    002370  0a   002376 6000 00   1769  	tze	move_output_return
    002371  aa  6 00407 2341 00   1770  	szn	entry_switch	pswitch entry?
    002372  0a   002376 6050 00   1771  	tpl	move_output_return	no
    002373  0a   002406 7020 00   1772  	tsx2	put_chars_buffer
    002374  aa  6 00524 2351 00   1773  	lda	left_to_move
    002375  0a   002351 7100 00   1774  	tra	move_the_padding
    002376                        1775  move_output_return:
    002376  aa  6 00520 2341 00   1776  	szn	out_left		is buffer fill?
    002377  0a   002403 6054 00   1777  	tpnz	move_output_exit	no
    002400  aa  6 00407 2341 00   1778  	szn	entry_switch	switch entry?
    002401  0a   000211 6050 00   1779  	tpl	done		no
    002402  0a   002406 7020 00   1780  	tsx2	put_chars_buffer
    002403                        1781  move_output_exit: 
    002403  aa  6 00470 3521 20   1782  	epp2	out_save_pr2,*
    002404  aa  6 00523 2221 00   1783  	ldx2	out_save_x2
    002405  aa   000000 7100 12   1784  	tra	0,2		return
                                  1785  
                                  1786  	tempd	move_temp,out_save_pr2,rest_of_source
                                  1787  	temp	move_padding,tct_result,save_out_column,newline_moved
                                  1788  	tempd	out_next,put_chars_arglist(5),put_chars_codeptr
                                  1789  	temp	out_column,out_moved,out_left,out_to_borrow,out_size
                                  1790  	temp	out_save_x2,left_to_move
                                  1791  "
                                  1792  "	subroutine to dump and reset the buffer
                                  1793  
    002406                        1794  put_chars_buffer:
    002406  aa  6 00517 2341 00   1795  	szn	out_moved
    002407  aa   000000 6000 12   1796  	tze	0,2
    002410  aa  6 00054 3535 00   1797  	epp3	buffptr
    002411                        1798  put_chars_join:
    002411  aa  6 00506 2535 00   1799  	spri3	put_chars_arglist+4
    002412  aa  6 00000 2541 00   1800  	call	put_chars_codeptr,*(put_chars_arglist)
    002413  aa  6 00502 3501 00
    002414  aa  6 00514 3521 20
    002415  aa  6 00040 7531 00
    002416  aa  7 00036 6701 20
    002417  aa  6 00000 1731 00
    002420  aa  6 00040 0731 00
    002421  aa  6 00512 2341 20   1801  	szn	put_chars_arglist+8,*	error?
    002422  0a   000235 6010 00   1802  	tnz	thru		yes, quit
    002423  aa  6 00517 4501 00   1803  	stz	out_moved		rest all buffer variables
    002424  aa  6 00054 3535 20   1804  	epp3	buffptr,*
    002425  aa  6 00500 2535 00   1805  	spri3	out_next
    002426  aa  6 00522 2361 00   1806  	ldq	out_size
    002427  aa  6 00520 7561 00   1807  	stq	out_left
    002430  aa   000000 7100 12   1808  	tra	0,2
                                  1809  
                                  1810  "	enter here to write a long string
                                  1811  "	q = length
                                  1812  "	pr2 -> data
                                  1813  
    002431                        1814  put_chars_string:
    002431  aa  6 00517 7561 00   1815  	stq	out_moved
    002432  aa  6 00500 2521 00   1816  	spri2	out_next
    002433  aa  6 00500 3535 00   1817  	epp3	out_next
    002434  0a   002411 7100 00   1818  	tra	put_chars_join
                                  1819  "
                                  1820  "	routine to get ptr to next argument
                                  1821  "
    002435                        1822  getargptr:
    002435  aa  6 00456 2341 00   1823  	szn	array_in_progress	are we stepping thru an array?
    002436  0a   002545 6010 00   1824  	tnz	get_next_array	yes
    002437                        1825  advance_cur_arg:
    002437  aa  6 00411 2261 00   1826  	ldx6	cur_arg
    002440  aa   000002 0260 03   1827  	adlx6	2,du		update arg counter
    002441  aa  6 00411 7461 00   1828  	stx6	cur_arg
    002442  aa  6 00412 1061 00   1829  	cmpx6	num_args		are there any more?
    002443  0a   002450 6044 00   1830  	tmoz	getarg		yes
    002444  aa  6 00413 0541 00   1831  	aos	no_more_args	no more, say so
    002445  0a   000006 3520 20   1832  	epp2	nullptr,*		set null argp so not same as last time
    002446  aa  6 00050 2521 00   1833  	spri2	argp
    002447  aa   000000 7100 12   1834  	tra	0,2		and return
    002450  aa  6 00056 3521 76   1835  getarg:	eppbp	pal,*6		get ptr to arg ptr
    002451  aa  6 00405 2261 00   1836  	ldx6	dpd		get descriptor offset
    002452  aa  2 00000 2351 36   1837  	lda	bp|0,6*		get the descriptor
    002453  0a   002477 6040 00   1838  	tmi	ga2		skip if Version 2
                                  1839  
                                  1840  "	process version 1 desciriptor
                                  1841  
    002454  aa   000022 7730 00   1842  	lrl	18		save length field
    002455  aa   000003 7710 00   1843  	arl	3		isolate type field
    002456  aa   000020 1150 07   1844  	cmpa	=16,dl		convert to Version 2 types
    002457  aa   000004 6044 04   1845  	tmoz	4,ic
    002460  aa   000040 1150 07   1846  	cmpa	=32,dl
    002461  0a   002470 6050 00   1847  	tpl	ga3
    002462  aa   000020 1750 07   1848  	sba	=16,dl
    002463  aa   077777 3760 03   1849  	anq	=o77777,du	erase "decimal" bit
    002464  aa   000005 1150 07   1850  	cmpa	5,dl		is this arithmetic data
    002465  aa   000002 6050 04   1851  	tpl	2,ic		no, skip
    002466  0a   002600 2360 05   1852  	ldq	v1prec-1,al	yes, get normal v1 precision
    002467  0a   002475 7100 00   1853  	tra	ga1
    002470  aa   001002 1150 07   1854  ga3:	cmpa	=514,dl
    002471  aa   000003 6010 04   1855  	tnz	3,ic
    002472  aa   000021 2350 07   1856  	lda	=17,dl
    002473  0a   002475 7100 00   1857  	tra	ga1
    002474  0a   001560 2350 05   1858  	lda	cvtype-518,al
    002475  aa   000013 7350 00   1859  ga1:	als	11		make it look like Version 2
    002476  aa   000022 7370 00   1860  	lls	18
                                  1861  
                                  1862  "	process version 2 descriptor
                                  1863  
    002477  aa   001700 3150 03   1864  ga2:	cana	=o001700,du	is this an array?
    002500  0a   002512 6010 00   1865  	tnz	begin_array	yes, special processing required
    002501  aa  2 00000 3521 20   1866  ga5:	eppbp	bp|0,*		get pointer to argument
    002502  aa  6 00050 2521 00   1867  	spribp	argp		and save
    002503  aa   000030 7730 00   1868  ga4:	lrl	24		save 24 bit length field
    002504  aa   000014 7720 00   1869  	qrl	12
    002505  aa  6 00406 7561 00   1870  	stq	length
    002506  aa   000004 7710 00   1871  	arl	4		isolate type field
    002507  aa   000177 3750 07   1872  	ana	=o177,dl
    002510  aa   000000 6270 05   1873  	eax7	0,al		and leave in x7
    002511  aa   000000 7100 12   1874  	tra	0,2		all done
                                  1875  
                                  1876  "
                                  1877  "	come here to begin the processing or an array. The extents of the array
                                  1878  "	must be detemined and the increment (words or bits) to step thru the array
                                  1879  "	must be found.
                                  1880  
    002512                        1881  begin_array:
    002512  aa  6 00461 7551 00   1882  	sta	array_desc	save a copy of the descriptor
    002513  aa  6 00072 2535 00   1883  	spri3	t4		save this pointer so i can use it
    002514  aa  2 00000 3535 36   1884  	epp3	bp|0,6*		this points to first word of descriptor
    002515  aa  3 00003 2361 00   1885  	ldq	3|3		get multiplier (may be words or bits)
    002516  aa  6 00457 7561 00   1886  	stq	array_mult	and save
    002517  aa  6 00460 4501 00   1887  	stz	array_packed	set switch to un-packed array
    002520  aa   002000 3150 03   1888  	cana	=o002000,du	test for packed array
    002521  aa   000002 6000 04   1889  	tze	2,ic		it is not packed
    002522  aa  6 00460 0541 00   1890  	aos	array_packed	this means array_mult is bits, not words
    002523  aa   000030 7710 00   1891  	arl	24		get numbers of dims in al
    002524  aa   000017 3750 07   1892  	ana	=o17,dl		just that number
    002525  aa   000000 6270 05   1893  	eax7	0,al		number of dims to x7
    002526  aa   000001 2350 07   1894  	lda	1,dl
    002527  aa  6 00462 7551 00   1895  	sta	array_length	initialize array length
    002530  aa  6 00463 7551 00   1896  	sta	array_position	and position
    002531                        1897  array_calc:
    002531  aa  3 00002 2361 00   1898  	ldq	3|2		upper bound of this dimension
    002532  aa  3 00001 1761 00   1899  	sbq	3|1		minus lower dimension
    002533  aa   000001 0760 07   1900  	adq	1,dl		+1 gives number of elements
    002534  aa  6 00462 4021 00   1901  	mpy	array_length	total length is product of dims
    002535  aa  6 00462 7561 00   1902  	stq	array_length
    002536  aa  3 00003 3535 00   1903  	epp3	3|3		step to next desc
    002537  aa   000001 1270 03   1904  	sblx7	1,du		count dimension processed
    002540  0a   002531 6010 00   1905  	tnz	array_calc	loop if more
    002541  aa  6 00072 3535 20   1906  	epp3	t4,*		restore the pointer
    002542  aa  6 00461 2351 00   1907  	lda	array_desc	restore origional descriptor
    002543  aa  6 00456 0541 00   1908  	aos	array_in_progress	now processing an array
    002544  0a   002501 7100 00   1909  	tra	ga5		go setup type and length
                                  1910  
                                  1911  "
                                  1912  "	come here to step to next element of an array during array processing
                                  1913  
    002545                        1914  get_next_array:
    002545  aa  6 00463 2351 00   1915  	lda	array_position	current loc
    002546  aa   000001 0750 07   1916  	ada	1,dl		advance by 1
    002547  aa  6 00462 1151 00   1917  	cmpa	array_length	check for end
    002550  aa   000003 6044 04   1918  	tmoz	3,ic		not past end
    002551  aa  6 00456 4501 00   1919  	stz	array_in_progress	done array processing
    002552  0a   002437 7100 00   1920  	tra	advance_cur_arg	go get next arg
                                  1921  
    002553  aa  6 00463 7551 00   1922  	sta	array_position	store updated position
    002554  aa  6 00457 2351 00   1923  	lda	array_mult	increment to be added to pointer (words or bits)
    002555  aa  6 00050 3521 20   1924  	eppbp	argp,*		get current pointdr
    002556  aa  6 00460 2341 00   1925  	szn	array_packed	is this a packed array?
    002557  aa   000003 6010 04   1926  	tnz	3,ic		yes
    002560  aa  2 00000 3521 05   1927  	eppbp	bp|0,al		do word addition
    002561  aa   000002 7100 04   1928  	tra	2,ic
    002562  aa  2 00000 5035 05   1929  	abd	bp|0,al		do bit adjustment
    002563  aa  6 00050 2521 00   1930  	spribp	argp		store adjusted pointer
    002564  aa  6 00461 2351 00   1931  	lda	array_desc	get origional descriptor
    002565  0a   002503 7100 00   1932  	tra	ga4		go process length and type
                                  1933  
                                  1934  
                                  1935  "
                                  1936  "	table to convert some Version I descriptor types to Version I types
                                  1937  "
    002566  aa   000000 000022    1938  cvtype:	dec	18,19,21,20,22,17,18,19,21,20,22
    002567  aa   000000 000023 
    002570  aa   000000 000025 
    002571  aa   000000 000024 
    002572  aa   000000 000026 
    002573  aa   000000 000021 
    002574  aa   000000 000022 
    002575  aa   000000 000023 
    002576  aa   000000 000025 
    002577  aa   000000 000024 
    002600  aa   000000 000026 
                                  1939  "
                                  1940  "	normal precisions for v1 data
                                  1941  "
    002601  aa   000043 000000    1942  v1prec:	dec	35b17,71b17,27b17,63b17
    002602  aa   000107 000000 
    002603  aa   000033 000000 
    002604  aa   000077 000000 
                                  1943  "
                                  1944  "	routine to get ptr to and length of string in arg list
                                  1945  "	x2 points at table of either char types or bit types
                                  1946  "	return 0,3 if not bit|char and return 1,3 if ok
                                  1947  "
    002605  aa  6 00406 2361 00   1948  fillin:	ldq	length		get length
    002606  aa  6 00050 3521 20   1949  	epp2	argp,*		get ptr to argument
    002607  aa   000000 6350 17   1950  	eaa	0,7		copy type codes
    002610  aa   777776 3750 03   1951  	ana	=o777776,du	erase packed bit
    002611  aa   000001 6000 13   1952  	tze	1,3		allow 0 type because of pl1 bug in returns(char(*))
    002612  aa   000000 1150 12   1953  	cmpa	0,2		is it varying
    002613  0a   002617 6000 00   1954  	tze	fill_varying	yes, skip
    002614  aa   000001 1150 12   1955  	cmpa	1,2		is this non-varying
    002615  aa   000001 6000 13   1956  	tze	1,3		yes, return
    002616  aa   000000 7100 13   1957  	tra	0,3		no, error
    002617                        1958  fill_varying:
                                  1959  "				the Q now holds the declared max length
    002617  aa  2 77777 1161 00   1960  	cmpq	bp|-1		if the current length is greater than the max
    002620  aa   000001 6040 13   1961  	tmi	1,3		then return the max length
    002621  aa  2 77777 2361 00   1962  	ldq	bp|-1		otherwise pick up the current length
    002622  aa   000001 6050 13   1963  	tpl	1,3		check for garbage (negative number). return if ok
    002623  aa  6 00406 2361 00   1964  	ldq	length		use max length. negative number causes blowups
    002624  aa   000001 7100 13   1965  	tra	1,3		return
                                  1966  "
    002625  aa   000054 000000    1967  cstype:	vfd	17/varying_char_dtype  char varying
    002626  aa   000052 000000    1968  	vfd	17/char_dtype	char non-varying
                                  1969  "
    002627  aa   000050 000000    1970  bstype:	vfd	17/varying_bit_dtype  bit varying
    002630  aa   000046 000000    1971  	vfd	17/bit_dtype	bit non-varying
                                  1972  
                                  1973  "	test arg for numeric. skip return if it is
                                  1974  
    002631                        1975  test_numeric: 
    002631  aa   000000 6350 17   1976  	eaa	0,7		get arg type in a
    002632  aa   000023 7310 00   1977  	ars	18+1		align and drop packed bit
    002633  aa   000001 1750 07   1978  	sba	1,dl		bit offsets start at 0
    002634  aa   000000 0664 05   1979  	cmpb	(al),(),fill(0)	test for numeric argument
    002635  0a   000000 000001    1980  	descb	numeric_dtype_mask,1
    002636  aa   000000 000000    1981  	descb	0,0
    002637  aa   000001 6010 13   1982  	tnz	1,3		it is numeric
    002640  aa   000000 7100 13   1983  	tra	0,3		it isn't
                                  1984  "
                                  1985  "	subroutine to get size from control field
                                  1986  "	entered with	pr2 & x0 pointing at next char of input
                                  1987  "		 	remaining number of chars in input in a
                                  1988  "			x4 = 0 | 1
                                  1989  "	this routine transfers to bad_field if string ends early
                                  1990  "	or if arg is not available for variable size specification
                                  1991  "
    002641  aa  1 66000 1065 10   1992  getsize:	cmpc	(pr,x0),(),fill(v)	is this "v"
    002642  aa   200000 000001    1993  	desc9a	2|0,1
    002643  aa   000000 000000    1994  	vfd	36/0
    002644  0a   002676 6000 00   1995  	tze	varsize		yes, size given by variable in arglist
                                  1996  "
                                  1997  "	not variable, look for string of digits
                                  1998  "
    002645  aa   000000 6210 00   1999  	eax1	0		init digit count
    002646  aa   000000 6220 10   2000  	eax2	0,0		remember where string starts
    002647                        2001  nextdigit:
    002647  aa   000110 1244 00   2002  	scm	(),(pr,x0)	is this character a digit
    002650  0a   002661 000012    2003  	desc9a	digits,10
    002651  aa   200000 000001    2004  	desc9a	2|0,1
    002652  aa  6 00064 0001 00   2005  	arg	t1
    002653  0a   002665 6064 00   2006  	ttn	getsize1		not a digit, skip
    002654  aa   000001 0610 03   2007  	adx1	1,du		bump digit count
    002655  aa   000001 0600 03   2008  	adx0	1,du		account for the digit
    002656  aa   000001 1750 07   2009  	sba	1,dl
    002657  0a   000363 6000 00   2010  	tze	bad_field
    002660  0a   002647 7100 00   2011  	tra	nextdigit		look for another digit
                                  2012  "
    002661                        2013  bit_alpha:
    002661  aa  060 061 062 063   2014  digits:	aci	"0123456789ABCDEF"
    002662  aa  064 065 066 067
    002663  aa  070 071 101 102
    002664  aa  103 104 105 106
                                  2015  "
                                  2016  "	have string of 0 or more digits
                                  2017  "
    002665  aa   000000 1010 03   2018  getsize1:	cmpx1	0,du		do we have any digits
    002666  aa   000000 6000 15   2019  	tze	0,5		no, return
    002667  aa  6 00062 5541 14   2020  	stc1	sizesp,4		yes, remember size specified
    002670  aa  0 00100 3055 52   2021  	dtb	(pr,rl,x2),(pr)	convert digits to binary
    002671  aa   200000 030011    2022  	desc9ns	2|0,x1,0
    002672  aa   600064 000004    2023  	desc9a	t1,4
    002673  aa  6 00064 2361 00   2024  	ldq	t1		store size
    002674  aa  6 00060 7561 14   2025  	stq	size,4
    002675  aa   000000 7100 15   2026  	tra	0,5		and return
                                  2027  "
                                  2028  "	size is given by variable
                                  2029  "
    002676  aa  6 00414 2341 00   2030  varsize:	szn	movinh		is output inhibited by ^0(?
    002677  0a   002702 6000 00   2031  	tze	varsize1		no
    002700  aa  6 00464 0541 00   2032  	aos	v_not_done	set flag to remember this
    002701  0a   002725 7100 00   2033  	tra	varsize2
                                  2034  
    002702  aa  6 00413 2341 00   2035  varsize1:	szn	no_more_args	error if no arg to be used
    002703  0a   000363 6010 00   2036  	tnz	bad_field
    002704  aa  6 00062 5541 14   2037  	stc1	sizesp,4		remember size specified
    002705  aa  6 00140 2521 00   2038  	spri2	work		save some stuff during calls which follow
    002706  aa  6 00142 7551 00   2039  	sta	work+2
    002707  aa  6 00143 7451 00   2040  	stx5	work+3
    002710  0a   001774 7050 00   2041  	tsx5	load_fixed_bin	get value of arg
    002711  0a   000363 7100 00   2042  	tra	bad_field		not numeric
    002712  aa   000000 7330 00   2043  	lrs	0		test for negative
    002713  aa   000002 6050 04   2044  	tpl	2,ic		"normalize" it
    002714  aa   000110 7730 00   2045  	lrl	72
    002715  aa   000000 7320 00   2046  	qrs	0
    002716  aa   000002 6050 04   2047  	tpl	2,ic
    002717  aa   000000 2360 07   2048  	ldq	0,dl
    002720  aa  6 00060 7561 14   2049  	stq	size,4		save size for caller
    002721  0a   002435 7020 00   2050  	tsx2	getargptr		step to next arg
    002722  aa  6 00143 2251 00   2051  	ldx5	work+3		restore saved stuff
    002723  aa  6 00142 2351 00   2052  	lda	work+2
    002724  aa  6 00140 3521 20   2053  	epp2	work,*
    002725  aa   000001 0600 03   2054  varsize2:	adx0	1,du		account for the v
    002726  aa   000001 1750 07   2055  	sba	1,dl
    002727  aa   000000 7100 15   2056  	tra	0,5		and return
                                  2057  "
                                  2058  
    002730                        2059  out_scan_table:
    002730  aa   000000 000000    2060  	oct	000000000000,000000000000	000 - 007
    002731  aa   000000 000000 
    002732  aa   002003 001001    2061  	oct	002003001001,001001000000	010 - 017
    002733  aa   001001 000000 
                        000174    2062  	dup	124			020 - 777
    002734  aa   000000 000000    2063  	oct	0
                                  2064  	dupend
    002735  aa   000000 000000          	oct	0
    002736  aa   000000 000000          	oct	0
    002737  aa   000000 000000          	oct	0
    002740  aa   000000 000000          	oct	0
    002741  aa   000000 000000          	oct	0
    002742  aa   000000 000000          	oct	0
    002743  aa   000000 000000          	oct	0
    002744  aa   000000 000000          	oct	0
    002745  aa   000000 000000          	oct	0
    002746  aa   000000 000000          	oct	0
    002747  aa   000000 000000          	oct	0
    002750  aa   000000 000000          	oct	0
    002751  aa   000000 000000          	oct	0
    002752  aa   000000 000000          	oct	0
    002753  aa   000000 000000          	oct	0
    002754  aa   000000 000000          	oct	0
    002755  aa   000000 000000          	oct	0
    002756  aa   000000 000000          	oct	0
    002757  aa   000000 000000          	oct	0
    002760  aa   000000 000000          	oct	0
    002761  aa   000000 000000          	oct	0
    002762  aa   000000 000000          	oct	0
    002763  aa   000000 000000          	oct	0
    002764  aa   000000 000000          	oct	0
    002765  aa   000000 000000          	oct	0
    002766  aa   000000 000000          	oct	0
    002767  aa   000000 000000          	oct	0
    002770  aa   000000 000000          	oct	0
    002771  aa   000000 000000          	oct	0
    002772  aa   000000 000000          	oct	0
    002773  aa   000000 000000          	oct	0
    002774  aa   000000 000000          	oct	0
    002775  aa   000000 000000          	oct	0
    002776  aa   000000 000000          	oct	0
    002777  aa   000000 000000          	oct	0
    003000  aa   000000 000000          	oct	0
    003001  aa   000000 000000          	oct	0
    003002  aa   000000 000000          	oct	0
    003003  aa   000000 000000          	oct	0
    003004  aa   000000 000000          	oct	0
    003005  aa   000000 000000          	oct	0
    003006  aa   000000 000000          	oct	0
    003007  aa   000000 000000          	oct	0
    003010  aa   000000 000000          	oct	0
    003011  aa   000000 000000          	oct	0
    003012  aa   000000 000000          	oct	0
    003013  aa   000000 000000          	oct	0
    003014  aa   000000 000000          	oct	0
    003015  aa   000000 000000          	oct	0
    003016  aa   000000 000000          	oct	0
    003017  aa   000000 000000          	oct	0
    003020  aa   000000 000000          	oct	0
    003021  aa   000000 000000          	oct	0
    003022  aa   000000 000000          	oct	0
    003023  aa   000000 000000          	oct	0
    003024  aa   000000 000000          	oct	0
    003025  aa   000000 000000          	oct	0
    003026  aa   000000 000000          	oct	0
    003027  aa   000000 000000          	oct	0
    003030  aa   000000 000000          	oct	0
    003031  aa   000000 000000          	oct	0
    003032  aa   000000 000000          	oct	0
    003033  aa   000000 000000          	oct	0
    003034  aa   000000 000000          	oct	0
    003035  aa   000000 000000          	oct	0
    003036  aa   000000 000000          	oct	0
    003037  aa   000000 000000          	oct	0
    003040  aa   000000 000000          	oct	0
    003041  aa   000000 000000          	oct	0
    003042  aa   000000 000000          	oct	0
    003043  aa   000000 000000          	oct	0
    003044  aa   000000 000000          	oct	0
    003045  aa   000000 000000          	oct	0
    003046  aa   000000 000000          	oct	0
    003047  aa   000000 000000          	oct	0
    003050  aa   000000 000000          	oct	0
    003051  aa   000000 000000          	oct	0
    003052  aa   000000 000000          	oct	0
    003053  aa   000000 000000          	oct	0
    003054  aa   000000 000000          	oct	0
    003055  aa   000000 000000          	oct	0
    003056  aa   000000 000000          	oct	0
    003057  aa   000000 000000          	oct	0
    003060  aa   000000 000000          	oct	0
    003061  aa   000000 000000          	oct	0
    003062  aa   000000 000000          	oct	0
    003063  aa   000000 000000          	oct	0
    003064  aa   000000 000000          	oct	0
    003065  aa   000000 000000          	oct	0
    003066  aa   000000 000000          	oct	0
    003067  aa   000000 000000          	oct	0
    003070  aa   000000 000000          	oct	0
    003071  aa   000000 000000          	oct	0
    003072  aa   000000 000000          	oct	0
    003073  aa   000000 000000          	oct	0
    003074  aa   000000 000000          	oct	0
    003075  aa   000000 000000          	oct	0
    003076  aa   000000 000000          	oct	0
    003077  aa   000000 000000          	oct	0
    003100  aa   000000 000000          	oct	0
    003101  aa   000000 000000          	oct	0
    003102  aa   000000 000000          	oct	0
    003103  aa   000000 000000          	oct	0
    003104  aa   000000 000000          	oct	0
    003105  aa   000000 000000          	oct	0
    003106  aa   000000 000000          	oct	0
    003107  aa   000000 000000          	oct	0
    003110  aa   000000 000000          	oct	0
    003111  aa   000000 000000          	oct	0
    003112  aa   000000 000000          	oct	0
    003113  aa   000000 000000          	oct	0
    003114  aa   000000 000000          	oct	0
    003115  aa   000000 000000          	oct	0
    003116  aa   000000 000000          	oct	0
    003117  aa   000000 000000          	oct	0
    003120  aa   000000 000000          	oct	0
    003121  aa   000000 000000          	oct	0
    003122  aa   000000 000000          	oct	0
    003123  aa   000000 000000          	oct	0
    003124  aa   000000 000000          	oct	0
    003125  aa   000000 000000          	oct	0
    003126  aa   000000 000000          	oct	0
    003127  aa   000000 000000          	oct	0
                                  2065  "
                                  2066  "	table to convert ascii to gebcd
                                  2067  "
    003130                        2068  ascii_to_gebcd:
    003130  aa   020020 020020    2069  	oct	020020020020,020020020020 	000
    003131  aa   020020 020020 
    003132  aa   020020 020020    2070  	oct	020020020020,020020020020 	010
    003133  aa   020020 020020 
    003134  aa   020020 020020    2071  	oct	020020020020,020020020020 	020
    003135  aa   020020 020020 
    003136  aa   020020 020020    2072  	oct	020020020020,020020020020 	030
    003137  aa   020020 020020 
    003140  aa   020020 076013    2073  	oct	020020076013,053074032057 	040
    003141  aa   053074 032057 
    003142  aa   035055 054060    2074  	oct	035055054060,073052033061 	050
    003143  aa   073052 033061 
    003144  aa   000001 002003    2075  	oct	000001002003,004005006007 	060
    003145  aa   004005 006007 
    003146  aa   010011 015056    2076  	oct	010011015056,036075016020 	070
    003147  aa   036075 016020 
    003150  aa   014021 022023    2077  	oct	014021022023,024025026027 	100
    003151  aa   024025 026027 
    003152  aa   030031 041042    2078  	oct	030031041042,043044045046 	110
    003153  aa   043044 045046 
    003154  aa   047050 051062    2079  	oct	047050051062,063064065066 	120
    003155  aa   063064 065066 
    003156  aa   067070 071012    2080  	oct	067070071012,037034020052 	130
    003157  aa   037034 020052 
    003160  aa   037021 022023    2081  	oct	037021022023,024025026027 	140
    003161  aa   024025 026027 
    003162  aa   030031 041042    2082  	oct	030031041042,043044045046 	150
    003163  aa   043044 045046 
    003164  aa   047050 051062    2083  	oct	047050051062,063064065066 	160
    003165  aa   063064 065066 
    003166  aa   067070 071020    2084  	oct	067070071020,040020020020 	170
    003167  aa   040020 020020 
                                  2085  "
                                  2086  "	edit sequences
                                  2087  "
    003170  aa   403040 140140    2088  int_edit:	vfd	9/lte+3,9/blank,9/mfls,9/mfls,9/mfls,9/mfls
    003171  aa   140140 000000 
                                  2089  "
    003172                        2090  oct_edit6:
    003172  aa   105321 000000    2091  	vfd	9/mvzb+5,9/mvc+1
                                  2092  "
    003173                        2093  oct_edit24:
    003173  aa   100107 321000    2094  	vfd	9/mvzb,9/mvzb+7,9/mvc+1
                                  2095  "
    003174                        2096  float_edit:
    003174  aa   403040 141207    2097  	vfd	9/lte+3,9/blank,9/mfls+1,9/insb+7,9/mvc,9/mvc,9/mvc,9/mvc
    003175  aa   320320 320320 
                                  2098  "
    003176  aa   403040 151040    2099  exp_edit:	vfd	9/lte+3,9/blank,9/mfls+9,9/enf,9/mvc+1
    003177  aa   321000 000000 
                                  2100  	end
ENTRY SEQUENCES
     
    003200  5a   000022 0000 00
    003201  aa  7 00046 2721 20
    003202  0a   000016 7100 00
    003203  5a   000016 0000 00
    003204  aa  7 00046 2721 20
    003205  0a   000012 7100 00
    003206  5a   000011 0000 00
    003207  aa  7 00046 2721 20
    003210  0a   000022 7100 00
LITERALS
     
    003212  aa   000010 000004 
    003213  aa   136000 000000 
    003214  aa   060056 000000 
    003215  aa   053060 061000 
    003216  aa   232157 052606 
    003217  aa   606060 606060 
    003220  aa   000077 777777 
    003221  aa   060060 060060 
    003222  aa   000777 777777 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    003223  5a   000003 000000 
    003224  5a   000037 600000 
    003225  aa   000000 000000 
    003226  55   000011 000002 
    003227  5a   000002 400003 
    003230  55   000006 000011 
    003231  aa  011 146 157 162
    003232  aa  155 154 151 156
    003233  aa  145 137 000 000
    003234  55   000016 000003 
    003235  0a   003207 500000 
    003236  55   000014 000003 
    003237  aa  006 163 167 151         switch
    003240  aa  164 143 150 000
    003241  55   000022 000011 
    003242  0a   003204 500000 
    003243  55   000021 000003 
    003244  aa  002 147 145 000         ge
    003245  55   000030 000016 
    003246  0a   003201 500000 
    003247  55   000025 000003 
    003250  aa  011 146 157 162         formline_
    003251  aa  155 154 151 156
    003252  aa  145 137 000 000
    003253  55   000002 000022 
    003254  6a   000000 400002 
    003255  55   000033 000003 
    003256  aa  014 163 171 155         symbol_table
    003257  aa  142 157 154 137
    003260  aa  164 141 142 154
    003261  aa  145 000 000 000

DEFINITIONS HASH TABLE

    003262  aa   000000 000015 
    003263  aa   000000 000000 
    003264  aa   000000 000000 
    003265  5a   000016 000000 
    003266  5a   000022 000000 
    003267  aa   000000 000000 
    003270  aa   000000 000000 
    003271  5a   000030 000000 
    003272  aa   000000 000000 
    003273  aa   000000 000000 
    003274  5a   000011 000000 
    003275  aa   000000 000000 
    003276  aa   000000 000000 
    003277  aa   000000 000000 

EXTERNAL NAMES

    003300  aa  015 164 143 164         tct_octal_040
    003301  aa  137 157 143 164
    003302  aa  141 154 137 060
    003303  aa  064 060 000 000
    003304  aa  021 141 156 171         any_to_any_round_
    003305  aa  137 164 157 137
    003306  aa  141 156 171 137
    003307  aa  162 157 165 156
    003310  aa  144 137 000 000
    003311  aa  024 141 156 171         any_to_any_truncate_
    003312  aa  137 164 157 137
    003313  aa  141 156 171 137
    003314  aa  164 162 165 156
    003315  aa  143 141 164 145
    003316  aa  137 000 000 000
    003317  aa  013 141 156 171         any_to_any_
    003320  aa  137 164 157 137
    003321  aa  141 156 171 137
    003322  aa  015 164 143 164         tct_octal_060
    003323  aa  137 157 143 164
    003324  aa  141 154 137 060
    003325  aa  066 060 000 000
    003326  aa  016 160 154 061         pl1_operators_
    003327  aa  137 157 160 145
    003330  aa  162 141 164 157
    003331  aa  162 163 137 000
    003332  aa  011 160 165 164         put_chars
    003333  aa  137 143 150 141
    003334  aa  162 163 000 000
    003335  aa  004 151 157 170         iox_
    003336  aa  137 000 000 000
    003337  aa  016 163 145 162         service_system
    003340  aa  166 151 143 145
    003341  aa  137 163 171 163
    003342  aa  164 145 155 000
    003343  aa  010 163 171 163         sys_info
    003344  aa  137 151 156 146
    003345  aa  157 000 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    003346  aa   000004 000000 
    003347  55   000103 000055 
    003350  aa   000004 000000 
    003351  55   000074 000061 
    003352  aa   000004 000000 
    003353  55   000074 000066 
    003354  aa   000004 000000 
    003355  55   000103 000077 
    003356  aa   000004 000000 
    003357  55   000112 000107 
    003360  aa   000004 000000 
    003361  55   000120 000114 
    003362  aa   000001 000000 
    003363  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    003364  5a   000123 000000 
    003365  5a   000125 000000 
    003366  5a   000127 000000 
    003367  5a   000131 000000 
    003370  5a   000133 000000 
    003371  5a   000135 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   003223 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000024 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         sys_info|service_system
    000011  5a   000146 0000 00
    000012  9a   777766 0000 46         iox_|put_chars
    000013  5a   000145 0000 00
    000014  9a   777764 0000 46         pl1_operators_|tct_octal_060
    000015  5a   000144 0000 00
    000016  9a   777762 0000 46         any_to_any_|any_to_any_truncate_
    000017  5a   000143 0000 00
    000020  9a   777760 0000 46         any_to_any_|any_to_any_round_
    000021  5a   000142 0000 00
    000022  9a   777756 0000 46         pl1_operators_|tct_octal_040
    000023  5a   000141 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000010 
    000004  aa   000000 117244 
    000005  aa   361023 525721 
    000006  aa   000000 117547 
    000007  aa   253135 767276 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000436 
    000020  aa   000000 000170 
    000021  aa   000407 000402 
    000022  aa   000425 000170 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   070056 061064 
    000030  aa   040115 141162 
    000031  aa   143150 040061 
    000032  aa   071070 071040 
    000033  aa   040040 040040 
    000034  aa   110151 162156 
    000035  aa   145151 163145 
    000036  aa   156056 123171 
    000037  aa   163115 141151 
    000040  aa   156164 056141 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   055164 141162 
    000045  aa   147145 164040 
    000046  aa   154066 070040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040154 151163 
    000057  aa   164040 163171 
    000060  aa   155142 157154 
    000061  aa   163040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000005 
    000066  aa   000112 000040 
    000067  aa   175453 020010 
    000070  aa   000000 117547 
    000071  aa   176210 000000 
    000072  aa   000122 000041 
    000073  aa   052721 247134 
    000074  aa   000000 105272 
    000075  aa   317215 400000 
    000076  aa   000133 000042 
    000077  aa   147777 464111 
    000100  aa   000000 115000 
    000101  aa   507463 000000 
    000102  aa   000144 000043 
    000103  aa   043243 127523 
    000104  aa   000000 101621 
    000105  aa   351624 000000 
    000106  aa   000155 000052 
    000107  aa   131543 247516 
    000110  aa   000000 113154 
    000111  aa   762251 600000 
    000112  aa   076163 160145          >spec>install>1110>formline_.alm
    000113  aa   143076 151156 
    000114  aa   163164 141154 
    000115  aa   154076 061061 
    000116  aa   061060 076146 
    000117  aa   157162 155154 
    000120  aa   151156 145137 
    000121  aa   056141 154155 
    000122  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000123  aa   076151 156143 
    000124  aa   154165 144145 
    000125  aa   076163 164141 
    000126  aa   143153 137146 
    000127  aa   162141 155145 
    000130  aa   056151 156143 
    000131  aa   154056 141154 
    000132  aa   155040 040040 
    000133  aa   076154 144144          >ldd>include>stack_header.incl.alm
    000134  aa   076151 156143 
    000135  aa   154165 144145 
    000136  aa   076163 164141 
    000137  aa   143153 137150 
    000140  aa   145141 144145 
    000141  aa   162056 151156 
    000142  aa   143154 056141 
    000143  aa   154155 040040 
    000144  aa   076154 144144          >ldd>include>eis_micro_ops.incl.alm
    000145  aa   076151 156143 
    000146  aa   154165 144145 
    000147  aa   076145 151163 
    000150  aa   137155 151143 
    000151  aa   162157 137157 
    000152  aa   160163 056151 
    000153  aa   156143 154056 
    000154  aa   141154 155040 
    000155  aa   076154 144144          >ldd>include>std_descriptor_types.incl.alm
    000156  aa   076151 156143 
    000157  aa   154165 144145 
    000160  aa   076163 164144 
    000161  aa   137144 145163 
    000162  aa   143162 151160 
    000163  aa   164157 162137 
    000164  aa   164171 160145 
    000165  aa   163056 151156 
    000166  aa   143154 056141 
    000167  aa   154155 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

          56    .                        formline_:    119,  345,  761,  786,  889.
        1054    .df                      formline_:    750,  848.
        1060    .df1                     formline_:    824,  852.
        2437    advance_cur_arg          formline_:   1825, 1920.
                any_to_any_              formline_:   1090, 1091.
                any_to_any_round_        formline_:   1091.
                any_to_any_truncate_     formline_:   1090.
          22    area_dtype               std_descriptor_types:      26.
         324    arg1                     formline_:    366,  368,  371,  374,  384.
         335    arg2                     formline_:    366,  393.
         341    arg3                     formline_:    374,  397.
         342    arg4                     formline_:    368,  398.
         316    argok                    formline_:    369,  372,  378.
          50    argp                     formline_:     61,  463,  536,  669,  676, 1026, 1107, 1172, 1192, 1294, 1361, 1479,
                                                      1484, 1489, 1501, 1833, 1867, 1924, 1930, 1949.
          53    args                     formline_:    170,  175.
         310    arg_dummy                formline_:    367,  370.
         312    arg_start                formline_:    365,  373.
         475    arg_used_test            formline_:    502,  513,  530.
        2531    array_calc               formline_:   1897, 1905.
         461    array_desc               formline_:     94, 1882, 1907, 1931.
         456    array_in_progress        formline_:     91,  183,  188,  643,  663, 1823, 1908, 1919.
         462    array_length             formline_:     95,  655, 1895, 1901, 1902, 1917.
         457    array_mult               formline_:     92,  668, 1886, 1923.
         460    array_packed             formline_:     93,  670, 1887, 1890, 1925.
         463    array_position           formline_:     96,  656,  666, 1896, 1915, 1922.
        3130    ascii_to_gebcd           formline_:    312, 2068.
         363    bad_field                formline_:    336,  351,  359,  377,  427,  473,  486,  496,  577,  596,  606,  726,
                                                      2010, 2036, 2042.
         174    bar                      formline_:    125, 1201.
        2512    begin_array              formline_:   1865, 1881.
           3    binary_dtype_mask        formline_:   1130,
                                         std_descriptor_types:      78.
        2661    bit_alpha                formline_:   1398, 2013.
        1725    bit_convert              formline_:   1393, 1406.
          23    bit_dtype                formline_:   1971,
                                         std_descriptor_types:      27.
          40    blank                    formline_:    111,  552,  556, 1604, 1759, 2088, 2097, 2099.
         442    bracket_clause           formline_:     83,  583,  615,  616.
         446    bracket_search           formline_:     84,  581,  584,  618.
         452    brflags                  formline_:     85,  456,  488,  580.
      100000    brflags.indefinite       formline_:     88,  447,  497.
      200000    brflags.iteration        formline_:     87,  442,  495,  595,  605.
      400000    brflags.movinh           formline_:     86,  443,  479,  520,  587,  607.
          17    bs                       formline_:    117,  706.
        2627    bstype                   formline_:    562, 1374, 1521, 1970.
          54    buffptr                  formline_:     61,  255,  308, 1797, 1804.
        1355    call_any_to_any_         formline_:   1037, 1089.
         126    call_iox                 formline_:    222,  227.
        1170    call_offset              stack_header:        80.
          25    char_dtype               formline_:   1968,
                                         std_descriptor_types:      29.
         274    check_key                formline_:    348,  354.
        2316    check_more_to_move       formline_:   1679, 1722.
        2337    check_padding            formline_:   1737, 1741.
        1011    check_sign               formline_:    789,  795.
         420    cht                      eis_micro_ops:       17.
          25    cobol_char_string_dtype  std_descriptor_types:      61.
          47    cobol_comp_5_ts_dtype    std_descriptor_types:      68.
          46    cobol_comp_5_uns_dtype   std_descriptor_types:      66.
           1    cobol_comp_6_dtype       std_descriptor_types:      57.
           1    cobol_comp_7_dtype       std_descriptor_types:      58.
          51    cobol_comp_8_ls_dtype    std_descriptor_types:      69.
          46    cobol_comp_8_uns_dtype   std_descriptor_types:      67.
          11    cobol_display_ls_dtype   std_descriptor_types:      59.
          35    cobol_display_ls_overp_dtype   std_descriptor_types:      62.
          44    cobol_display_ts_dtype   std_descriptor_types:      65.
          36    cobol_display_ts_overp_dtype   std_descriptor_types:      63.
          43    cobol_display_uns_dtype  std_descriptor_types:      64.
          21    cobol_structure_dtype    std_descriptor_types:      60.
        1403    compute_precision        formline_:    746,  921, 1123.
         225    convert_ge               formline_:    292,  304.
        1255    convert_to_decimal       formline_:   1008, 1119.
        1357    convert_to_fixed_dec     formline_:   1097, 1412.
        1252    convert_to_float_dec     formline_:    755,  850,  922, 1001.
           5    cplx_fix_bin_1_dtype     std_descriptor_types:      13.
           6    cplx_fix_bin_2_dtype     std_descriptor_types:      14.
          55    cplx_fix_dec_4bit_ba_ls_dtype  std_descriptor_types:      44.
          13    cplx_fix_dec_9bit_ls_dtype     std_descriptor_types:      19.
           7    cplx_flt_bin_1_dtype     std_descriptor_types:      15.
          10    cplx_flt_bin_2_dtype     std_descriptor_types:      16.
         126    cplx_flt_bin_generic_dtype     std_descriptor_types:      55.
          56    cplx_flt_dec_4bit_ba_dtype     std_descriptor_types:      45.
          14    cplx_flt_dec_9bit_dtype  std_descriptor_types:      20.
         122    cplx_flt_dec_extended_dtype    std_descriptor_types:      51.
         124    cplx_flt_dec_generic_dtype     std_descriptor_types:      53.
          61    cplx_flt_hex_1_dtype     std_descriptor_types:      48.
          62    cplx_flt_hex_2_dtype     std_descriptor_types:      49.
        2625    cstype                   formline_:    189,  549, 1017, 1099, 1325, 1534, 1967.
        1377    ctfd                     formline_:   1102, 1105, 1116.
         411    cur_arg                  formline_:     74,  200,  461,  531, 1826, 1828.
        2566    cvtype                   formline_:   1858, 1938.
        1267    cv_check_ok              formline_:   1016, 1020.
        1273    cv_not_generic           formline_:   1023, 1025.
         410    default_precision        formline_:     74,  932,  955,  956,  978, 1139.
         415    depth                    formline_:     77,  202,  470,  474,  485,  523.
        2661    digits                   formline_:   1560, 2003, 2014.
         211    done                     formline_:    191,  257,  283,  290, 1739, 1779.
         456    do_rp                    formline_:    503,  506.
         405    dpd                      formline_:     72,  178, 1836.
         354    dumtra                   formline_:    371,  408.
         145    e                        formline_:    126,  952.
        1153    e0                       formline_:    922,  981.
        1155    e1                       formline_:    924,  980,  991.
        1220    e2                       formline_:    959,  970.
        1231    ec1                      formline_:    912,  968,  972.
          40    enf                      formline_:   2099,
                                         eis_micro_ops:        2.
          20    entry_dtype              formline_:   1165,
                                         std_descriptor_types:      24.
        1174    entry_offset             stack_header:        84.
         407    entry_switch             formline_:     73,  148,  171,  212,  240,  278,  290, 1723, 1738, 1770, 1778.
         136    esc                      formline_:    124,  268,  706.
          75    exponent                 formline_:     64,  764,  821,  941,  943, 1024, 1067, 1070, 1072, 1079, 1081, 1150,
                                                      1151, 1155.
        3176    exp_edit                 formline_:    947, 2099.
        1423    extract_exponent         formline_:    990, 1147.
        1233    e_format                 formline_:    757,  819,  976.
        1226    e_zero                   formline_:    923,  968.
         743    f1                       formline_:    755,  839.
        1023    f2                       formline_:    759,  810.
        1120    f3                       formline_:    870,  879,  887.
        1125    f4                       formline_:    892,  914.
         562    false                    formline_:    554,  599.
          14    ff                       formline_:    115,  706.
          27    file_dtype               std_descriptor_types:      31.
        2605    fillin                   formline_:    190,  550,  563, 1018, 1100, 1326, 1375, 1522, 1535, 1948.
         703    fill_chars               formline_:    694,  705.
        2617    fill_varying             formline_:   1954, 1958.
         214    finish_switch            formline_:    279,  293.
        3174    float_edit               formline_:    937, 2096.
          25    form                     formline_:    138,  143,  148.
          16    formline_                formline_:     57,  140.
        1042    f_zero                   formline_:    756,  828.
        2475    ga1                      formline_:   1853, 1857, 1859.
        2477    ga2                      formline_:   1838, 1864.
        2470    ga3                      formline_:   1847, 1854.
        2503    ga4                      formline_:   1868, 1932.
        2501    ga5                      formline_:   1866, 1909.
          12    ge                       formline_:     58,  136.
        2450    getarg                   formline_:    187, 1830, 1835.
        2435    getargptr                formline_:    261,  647,  681, 1822, 2050.
        1335    getexp                   formline_:   1053, 1067.
        1346    getexp.in_range          formline_:   1071, 1078.
        1345    getexp.pos               formline_:   1073, 1075.
        2641    getsize                  formline_:    344,  353, 1992.
        2665    getsize1                 formline_:   2006, 2018.
         435    get_depth_end            formline_:    484,  494,  594,  604.
         422    get_depth_start          formline_:    441,  469,  579.
        2053    get_fixed_bin_size       formline_:   1498, 1510.
        2545    get_next_array           formline_:   1824, 1914.
         775    gl                       formline_:    765,  771,  781.
         144    grow_stack               formline_:    235,  242.
         236    have_control             formline_:    270,  318.
         245    hc1                      formline_:    320,  327.
          11    ht                       formline_:    114,  706.
          10    if0                      eis_micro_ops:       19.
           4    if1                      eis_micro_ops:       20.
           2    if2                      eis_micro_ops:       21.
           1    if3                      eis_micro_ops:       22.
         300    ign                      eis_micro_ops:       12.
         404    inlen                    formline_:     71,  193,  264,  275,  324,  329,  334,  382,  431,  458,  510.
          52    inptr                    formline_:     61,  192,  262,  381,  429,  509.
         220    insa                     eis_micro_ops:        9.
         200    insb                     formline_:   2097,
                                         eis_micro_ops:        8.
          20    insm                     eis_micro_ops:        1.
         240    insn                     eis_micro_ops:       10.
         260    insp                     eis_micro_ops:       11.
        3170    int_edit                 formline_:   1417, 2088.
                iox_                     formline_:    227.
         436    iter_argp                formline_:     82,  464,  539.
         416    iter_count               formline_:     78,  457,  499,  506.
         432    iter_cur_arg             formline_:     81,  462,  532.
         426    iter_length              formline_:     80,  459,  508.
         422    iter_pointer             formline_:     79,  460,  507.
        1771    i_zero                   formline_:   1413, 1442.
         355    keys                     formline_:    356,  418.
          30    key_length               formline_:    356,  420.
          17    label_dtype              formline_:   1163,
                                         std_descriptor_types:      23.
         506    left_bracket             formline_:    397,  545.
         540    left_bracket2            formline_:    560,  564,  575.
         536    left_bracket3            formline_:    559,  568,  572.
         542    left_bracket4            formline_:    548,  571,  574,  578.
         525    left_bracket5            formline_:    551,  561.
         534    left_bracket6            formline_:    555,  569.
         524    left_to_move             formline_:   1656, 1673, 1725, 1728, 1733, 1754, 1768, 1773, 1790.
         406    length                   formline_:     72, 1030, 1124, 1470, 1495, 1870, 1948, 1964.
        2034    load_double              formline_:   1457, 1464, 1488.
        1774    load_fixed_bin           formline_:    576, 1104, 1268, 1448, 2041.
        2057    load_fixed_bit           formline_:   1450, 1520.
        2040    load_fixed_bit_join      formline_:   1497, 1528.
        2067    load_fixed_char          formline_:   1523, 1533.
        2111    load_fixed_digits        formline_:   1547, 1553.
        2017    load_fixed_ok            formline_:   1456, 1459, 1463, 1466, 1469.
        2115    load_fixed_scan          formline_:   1558, 1566.
        2106    load_fixed_skip_sign     formline_:   1543, 1549.
        2135    load_fixed_zero          formline_:   1539, 1555, 1563, 1575.
        2036    load_packed_fixed_bin    formline_:   1475, 1494.
        2026    load_single              formline_:   1454, 1478.
        2031    load_single_uns          formline_:   1461, 1483.
         164    loop                     formline_:    262,  408,  436,  465,  511,  524,  588,  608,  621,  636,  642,  649,
                                                       677,  693,  703,  720,  741.
          50    lp                       formline_:    122, 1211.
         374    lp_iterate               formline_:    393,  440.
         407    lp_iterate2              formline_:    444,  453.
         410    lp_iterate3              formline_:    448,  451,  455.
         404    lp_iterate4              formline_:    446,  449.
         400    lte                      formline_:   2088, 2097, 2099,
                                         eis_micro_ops:       16.
           4    max_depth                formline_:    101,  472.
         126    max_dtype                std_descriptor_types:      70.
         160    mflc                     eis_micro_ops:        7.
         140    mfls                     formline_:   2088, 2097, 2099,
                                         eis_micro_ops:        6.
          55    minus                    formline_:    112,  796,  801, 1544.
         657    mismatch                 formline_:    681, 1019, 1168, 1269, 1327, 1376.
         360    mors                     eis_micro_ops:       15.
        1753    move                     formline_:    799,  806,  830, 1287, 1299, 1301, 1320, 1424, 1444.
        1765    movea                    formline_:   1429, 1434.
        2346    move_borrows_all         formline_:   1745, 1749.
        2403    move_output_exit         formline_:   1777, 1781.
        2376    move_output_return       formline_:   1743, 1752, 1769, 1771, 1775.
         474    move_padding             formline_:   1628, 1742, 1787.
        2332    move_source_done         formline_:   1630, 1652, 1724, 1726, 1735.
         466    move_temp                formline_:   1624, 1625, 1633, 1635, 1646, 1647, 1670, 1671, 1690, 1691, 1709, 1716, 1786.
        2351    move_the_padding         formline_:   1748, 1753, 1774.
        2227    move_the_stuff           formline_:   1632, 1655, 1731.
        2164    move_to_outbuf           formline_:    277,  287,  300,  322,  435,  699,  719,  737,  963, 1234, 1345, 1355,
                                                      1368, 1402, 1433, 1436, 1618.
         414    movinh                   formline_:     76,  203,  286,  296,  364,  452,  477,  519,  522,  547,  586,  617,
                                                       620,  628, 1619, 2030.
         340    mses                     eis_micro_ops:       14.
         320    mvc                      formline_:   2091, 2094, 2097, 2099,
                                         eis_micro_ops:       13.
         120    mvza                     eis_micro_ops:        5.
         100    mvzb                     formline_:   2091, 2094,
                                         eis_micro_ops:        4.
        1052    n.df                     formline_:    833,  843.
        1133    ndf_zero                 formline_:    851,  902.
         477    newline_moved            formline_:   1348, 1623, 1702, 1787.
         705    new_line_char            formline_:    297,  707.
         163    nextarg                  formline_:    261,  589,  964, 1235, 1347, 1349, 1353, 1356, 1369, 1407, 1437.
        2647    nextdigit                formline_:   2001, 2011.
        1045    nf                       formline_:    748,  832.
          12    nl                       formline_:    113,  706,  708.
         155    notge                    formline_:    241,  252.
        2226    nothing_to_borrow        formline_:   1645, 1653.
         137    not_switch               formline_:    213,  236.
          40    no_alp                   formline_:    152,  157,  163.
         174    no_control               formline_:    265,  274.
         413    no_more_args             formline_:     74,  195,  376,  504,  635,  648, 1831, 2035.
           6    nullptr                  formline_:    133,  155, 1832.
           0    numeric_dtype_mask       formline_:   1980,
                                         std_descriptor_types:      73.
         412    num_args                 formline_:     74,  168,  169,  256, 1829.
        2140    octal                    formline_:   1276, 1279, 1296, 1584.
        2143    octal1                   formline_:   1588, 1594.
        1535    octal_field              formline_:   1200, 1206, 1242.
        3173    oct_edit24               formline_:   1282, 2093.
        3172    oct_edit6                formline_:   1253, 2090.
          16    offset_dtype             std_descriptor_types:      22.
        2301    out_backspace            formline_:   1696, 1704.
         516    out_column               formline_:    210,  731,  738, 1339, 1352, 1687, 1701, 1706, 1710, 1715, 1720, 1764, 1789.
         520    out_left                 formline_:    233,  238,  284, 1657, 1659, 1672, 1736, 1755, 1757, 1767, 1776, 1789, 1807.
         517    out_moved                formline_:    208,  216,  280, 1669, 1765, 1789, 1795, 1803, 1815.
        2275    out_newline              formline_:   1695, 1699.
         500    out_next                 formline_:    254, 1660, 1665, 1758, 1763, 1788, 1805, 1816, 1817.
        2315    out_normal               formline_:   1684, 1719.
         470    out_save_pr2             formline_:   1622, 1782, 1786.
         523    out_save_x2              formline_:   1621, 1783, 1790.
        2251    out_scan                 formline_:   1677, 1703, 1707, 1717, 1734.
        2730    out_scan_table           formline_:   1682, 2059.
         522    out_size                 formline_:    234,  239, 1730, 1789, 1806.
        2304    out_tab                  formline_:   1697, 1709.
         521    out_to_borrow            formline_:    211,  736,  740, 1631, 1650, 1654, 1744, 1746, 1747, 1751, 1789.
           1    packed                   formline_:    131, 1167, 1474.
          56    pal                      formline_:     62,  166, 1835.
                pl1_operators_           formline_:    766,  811,  871,  924, 1042, 1305, 1331, 1636.
          53    plus                     formline_:    120, 1540.
          15    pointer_dtype            formline_:   1161, 1167,
                                         std_descriptor_types:      21.
        1465    pp1                      formline_:   1162, 1164, 1166, 1192.
        1467    pp2                      formline_:   1188, 1198.
          74    precision                formline_:     64,  758,  820,  867,  904,  939,  979,  983,  989, 1012, 1035, 1041, 1056.
        1015    prefix_minus             formline_:    800, 1289.
         776    prefix_sign              formline_:    783,  894.
          10    ptrmask                  formline_:    134,  156, 1193.
        1527    ptr_done                 formline_:   1210, 1230.
        1130    punt                     formline_:    849,  865,  896.
        1171    push_offset              stack_header:        81.
        1671    put_acc                  formline_:    406, 1360.
        1702    put_bits                 formline_:    407, 1374.
         706    put_blanks               formline_:    390,  713.
        1637    put_chars                formline_:    227,  398, 1324.
         502    put_chars_arglist        formline_:    215,  217,  219,  220,  223,  230,  231, 1788, 1799, 1800, 1801.
        2406    put_chars_buffer         formline_:    302, 1727, 1740, 1772, 1780, 1794.
         514    put_chars_codeptr        formline_:    228, 1788, 1800.
        2411    put_chars_join           formline_:   1798, 1818.
        2431    put_chars_string         formline_:   1732, 1814.
         665    put_control              formline_:    384,  385,  386,  387,  388,  389,  688.
         674    put_control_loop         formline_:    696,  702.
        1743    put_decimal              formline_:    399,  400, 1411.
        1150    put_exponential          formline_:    405,  898,  918.
         736    put_float                formline_:    404,  745.
        1561    put_octal                formline_:    401, 1267.
        1607    put_octal_word           formline_:    403, 1293.
        1434    put_pointer              formline_:    402, 1160.
           1    real_fix_bin_1_dtype     formline_:   1455,
                                         std_descriptor_types:       9.
          41    real_fix_bin_1_uns_dtype       formline_:   1462,
                                               std_descriptor_types:      34.
           2    real_fix_bin_2_dtype     formline_:   1458,
                                         std_descriptor_types:      10.
          42    real_fix_bin_2_uns_dtype       formline_:   1465,
                                               std_descriptor_types:      35.
          53    real_fix_dec_4bit_ba_ls_dtype  std_descriptor_types:      42.
          51    real_fix_dec_4bit_ls_dtype     std_descriptor_types:      40.
          47    real_fix_dec_4bit_ts_dtype     std_descriptor_types:      39.
          46    real_fix_dec_4bit_uns_dtype    std_descriptor_types:      38.
          11    real_fix_dec_9bit_ls_dtype     formline_:   1117,
                                               std_descriptor_types:      17.
          35    real_fix_dec_9bit_ls_ovrp_dtype      std_descriptor_types:      32.
          44    real_fix_dec_9bit_ts_dtype     std_descriptor_types:      37.
          36    real_fix_dec_9bit_ts_ovrp_dtype      std_descriptor_types:      33.
          43    real_fix_dec_9bit_uns_dtype    std_descriptor_types:      36.
           3    real_flt_bin_1_dtype     std_descriptor_types:      11.
           4    real_flt_bin_2_dtype     std_descriptor_types:      12.
         125    real_flt_bin_generic_dtype     std_descriptor_types:      54.
          54    real_flt_dec_4bit_ba_dtype     std_descriptor_types:      43.
          52    real_flt_dec_4bit_dtype  std_descriptor_types:      41.
          12    real_flt_dec_9bit_dtype  std_descriptor_types:      18.
         121    real_flt_dec_extended_dtype    std_descriptor_types:      50.
         123    real_flt_dec_generic_dtype     formline_:   1004, 1022, 1048,
                                               std_descriptor_types:      52.
          57    real_flt_hex_1_dtype     std_descriptor_types:      46.
          60    real_flt_hex_2_dtype     std_descriptor_types:      47.
         254    rescan_control           formline_:    337,  631.
         472    rest_of_source           formline_:   1668, 1729, 1786.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
         555    right_bracket            formline_:    396,  593.
          51    rp                       formline_:    123, 1224.
         467    rp1                      formline_:    501,  505,  514,  519,  597.
         464    rp_inf                   formline_:    498,  513.
         442    rp_iterate               formline_:    394,  493.
         454    rp_test                  formline_:    504,  515.
          16    rs                       formline_:    116,  706.
         402    save_inlen               formline_:     68,  335,  430,  629.
         400    save_inptr               formline_:     67,  333,  428,  630.
         476    save_out_column          formline_:   1340, 1350, 1787.
         403    save_x7.x5               formline_:     69, 1002, 1036, 1039, 1040, 1068, 1076, 1083, 1098, 1109.
         564    semi_colon               formline_:    395,  603.
         606    semi_colon2              formline_:    610,  627.
                service_system           formline_:    221.
          60    ses                      eis_micro_ops:        3.
         157    setout                   formline_:    251,  254.
         103    setup_output             formline_:    172,  207.
        1421    set_dp                   formline_:   1132, 1138.
        2055    shift_fixed_bin_field    formline_:   1507, 1513.
          60    size                     formline_:     62,  342,  450,  611,  640,  641,  646,  658,  662,  683,  685,  691,
                                                       692,  701,  715,  725,  729,  730,  732,  734,  739,  823,  837,  843,
                                                       848,  854,  868,  887,  892,  897,  903,  919,  961,  962,  977, 1233,
                                                      1300, 1312, 1319, 1351, 1377, 1383, 1384, 1387, 1389, 1390, 1391, 1405,
                                                      1427, 1428, 1430, 2025, 2049.
          62    sizesp                   formline_:     62,  445,  612,  637,  686,  689,  716,  727,  747,  749,  832,  959,
                                                      1298, 1346, 1385, 1425, 2020, 2037.
         612    skip                     formline_:    391,  635.
         620    skip2                    formline_:    638,  641,  650.
         626    skip3                    formline_:    647,  664.
         632    skip_array               formline_:    644,  654.
         223    skip_newline             formline_:    295,  301.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      formline_:    164,
                                         stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    stack_frame:   13.
          20    stack_frame.flag_word    stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      formline_:    250,
                                         stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   stack_frame:   20.
          20    stack_frame.prev_sp      formline_:    163,
                                         stack_frame:    8.
          40    stack_frame.regs         stack_frame:   22.
          24    stack_frame.return_ptr   stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     formline_:    247,  249,
                                               stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
          52    star                     formline_:    121,  706.
         644    step_array               formline_:    659,  665.
         654    step_packed_array        formline_:    671,  674.
        2153    strip_blanks             formline_:    950, 1256, 1285, 1419, 1601.
          21    structure_dtype          std_descriptor_types:      25.
          22    switch                   formline_:     59,  145.
                sys_info                 formline_:    221.
          64    t1                       formline_:     63,  269,  319,  323,  358,  363, 1046, 1050, 1199, 1204, 1227, 1228,
                                                      1229, 1232, 1257, 1261, 1262, 1270, 1286, 1309, 1311, 1313, 1315, 1424,
                                                      1434, 1504, 1505, 1556, 1562, 1565, 1569, 1570, 1573, 2005, 2023, 2024.
          66    t2                       formline_:     63,  770,  774,  775,  815,  817,  818,  822,  852,  858,  862,  866,
                                                       875,  877,  878,  880,  896,  928,  930,  931, 1274, 1278, 1335, 1337,
                                                      1338, 1500, 1506, 1537, 1548, 1571, 1605, 1606, 1609.
          70    t3                       formline_:     63,  855, 1052, 1080, 1154, 1175, 1176, 1181, 1182, 1183, 1198, 1205, 1208.
          72    t4                       formline_:     63,  537,  538,  660,  661, 1883, 1906.
         715    tab_to_column            formline_:    392,  724.
                tct_octal_040            formline_:   1331, 1636.
                tct_octal_060            formline_:    766,  811,  871,  924, 1042, 1305.
         475    tct_result               formline_:   1640, 1642, 1683, 1685, 1692, 1787.
          76    temp1                    formline_:     65,  762,  768,  777,  797,  813,  863,  864,  873,  882,  890,  926,
                                                       936,  944,  946,  986,  987, 1021, 1044, 1058, 1059, 1084, 1106, 1111,
                                                      1112, 1149, 1209, 1218, 1225, 1250, 1252, 1275, 1277, 1281, 1295, 1307,
                                                      1396, 1397, 1416.
         116    temp2                    formline_:     65,  763,  778,  784,  883,  891,  908,  913,  948, 1254, 1283, 1418,
                                                      1603, 1607.
        2631    test_numeric             formline_:   1014, 1449, 1975.
         235    thru                     formline_:    291,  303,  314, 1802.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
         561    true                     formline_:    558,  598.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
         166    v                        formline_:    127, 1992.
        2601    v1prec                   formline_:   1852, 1942.
        2676    varsize                  formline_:   1995, 2030.
        2702    varsize1                 formline_:   2031, 2035.
        2725    varsize2                 formline_:   2033, 2054.
          24    varying_bit_dtype        formline_:   1970,
                                         std_descriptor_types:      28.
          26    varying_char_dtype       formline_:   1967,
                                         std_descriptor_types:      30.
         464    v_not_done               formline_:     98,  339,  609, 2032.
         140    work                     formline_:     65,  772,  779,  938,  954,  958, 1027, 1203, 1213, 1226, 1231, 1260,
                                                      2038, 2039, 2040, 2051, 2052, 2053.
          60    zero                     formline_:    118,  790,  906,  911, 1057, 1217.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
