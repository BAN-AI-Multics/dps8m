	COMPILATION LISTING OF SEGMENT delentry
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1047.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 delentry: proc;
       15 
       16 /* modified by Kobziar on 11-15-73 not to require "w" on seg in order to delete */
       17 /* last modified April 1975 by R. Bratt for new RNT/KST system             */
       18 /* last modified Feb. 1976 by R. Bratt for pam flush     */
       19 /* last modified April 20, 1976 by R. Bratt to check mountedness of volume */
       20 /* modified 760324 by L. Scheffler to fix call to dir_control_error to call with dp, not ep */
       21 /* last modified April 24, 1976 by R. Bratt to swallow known_in_other_rings code from makeunknown */
       22 /* last modified June 1, 1976 by R. Bratt to call find_$finished when done   */
       23 /* Modified by D.Vinograd 6/76 to add entry retv, used by volume retriever, which deletes without access checking */
       24 /* Modified 4/77 by M. Weaver to replace makeknown by makeknown_ */
       25 /* Modified April 1979 by D. Spector to remove logging of privileged deletions */
       26 /* Modified June 1981 by J. Bongiovanni to call pathname_am$clear when deleting
       27*      per-process directory */
       28 /* Modified June 30 1981 by M. Pierret to remove access checking for priviledged entry.*/
       29 /* Modified 2/82 BIM for new name of side-door dir unlocker. */
       30 /* Modified 9/83 E. N. Kittlitz to handle makeknown_ returning connection_fail */
       31 /* Modified 6/84 Keith Loepere to use the new dc_find. */
       32 /* Modified 10/84 Keith Loepere for auditing of deletions. */
       33 /* Modified 84-11-27 to change access_audit_ arg lists */
       34 /* Modified 85-04-01 Keith Loepere for new access_audit_check_ep_. */
       35 /* Modified 85-05-08 EJ Sharpe: renamed priv_duid to duid_mdir_priv, added duid_mdir entry */
       36 /* Modified 85-05-15 EJ Sharpe: fix so hpdl can delete master dirs */
       37 
       38 /*
       39*   The delentry routine implements the user callable primitives for deleting
       40*   an entry in a directory.
       41*
       42*   Entry: delentry$dfile
       43*
       44*   This entry deletes the entry designamed by the directory pathname, dirname,
       45*   and the entry name, ename.
       46*
       47*   Usage: call delentry$dfile (dirname, ename, code);
       48*
       49*   1) dirname (character (168))		parent directory pathname (Input)
       50*
       51*   2) ename (character(32)			entryname to be deleted (Input)
       52*
       53*   3) code (fixed bin)			return error code (Output)
       54*
       55*
       56*   Entry: delentry$dseg
       57*
       58*   This entry deletes the entry designated by the pointer sp.
       59*
       60*   Usage: call delentry$dseg (sp, code);
       61*
       62*   1) sp (pointer)				pointer to segment to be deleted (Input)
       63*
       64*   2) code (fixed bin)			error code (Output)
       65*
       66*   Note:  If the entry is a segment, then the contents of the segment are deleted
       67*
       68*   before the entry is deleted.  If it is a directory entry then  an error code is returned and
       69*   del_dir_tree must be called.
       70*   */
       71 
       72 /* Parameters */
       73 
       74 dcl  a_code			fixed bin (35) parameter;
       75 dcl  a_dirname			char (*) parameter;
       76 dcl  a_ename			char (*) parameter;
       77 dcl  a_ep				ptr parameter;
       78 dcl  a_sp				ptr parameter;
       79 dcl  a_trp			fixed bin (71) parameter; /* to return time-record product */
       80 dcl  a_uidpath			(0:15) bit (36) aligned parameter;
       81 
       82 /* Variables */
       83 
       84 dcl  acl_count			fixed bin;
       85 dcl  aclep			ptr;
       86 dcl  areap			ptr;
       87 dcl  asize			fixed bin;
       88 dcl  audit_eventflags		bit (36) aligned;
       89 dcl  code				fixed bin (35);
       90 dcl  damaged			bit (1) init ("0"b);/* TRUE if dir uid is 0 */
       91 dcl  dirl				bit (1) init ("0"b);
       92 dcl  dirname			char (168);
       93 dcl  e_sw				fixed bin;
       94 dcl  ename			char (32);
       95 dcl  ignore			fixed bin (35);
       96 dcl  1 mk_info			aligned like makeknown_info;
       97 dcl  mkunk_uid			bit (36) aligned init ("0"b);
       98 dcl  ncnt				fixed bin;
       99 dcl  nnames			fixed bin (18);
      100 dcl  nrp				bit (18) aligned;
      101 dcl  onp				ptr;
      102 dcl  priv_entry			bit (1) init ("0"b);
      103 dcl  pvid				bit (36) aligned;
      104 dcl  1 qcell			like quota_cell aligned automatic;
      105 dcl  ring				fixed bin;
      106 dcl  seg_uid			bit (36) aligned;
      107 dcl  segl				bit (1) init ("0"b);
      108 dcl  segno			fixed bin;
      109 dcl  segptr			ptr init (null);
      110 dcl  sp				ptr;
      111 dcl  trp				fixed bin (71);
      112 dcl  type				fixed bin;
      113 dcl  uidpath			(0:15) bit (36) aligned;
      114 dcl  vtocx			fixed bin;
      115 
      116 /* Constants */
      117 
      118 dcl  directory			init (2) fixed bin static;
      119 dcl  link_br			init (0) fixed bin static;
      120 dcl  file				init (0) fixed bin static;
      121 dcl  read_lock			bit (36) aligned init ("0"b);
      122 dcl  retv				init (3) fixed bin static;
      123 dcl  seg				init (1) fixed bin static;
      124 dcl  segment			init (1) fixed bin static;
      125 dcl  uid_mdir			init (2) fixed bin static;
      126 
      127 /* External */
      128 
      129 dcl  active_hardcore_data$ensize	fixed bin external;
      130 dcl  active_hardcore_data$esize	fixed bin external;
      131 dcl  error_table_$copy_sw_on		fixed bin (35) external;
      132 dcl  error_table_$dirseg		fixed bin (35) external;
      133 dcl  error_table_$fulldir		fixed bin (35) external;
      134 dcl  error_table_$infcnt_non_zero	fixed bin (35) external;
      135 dcl  error_table_$invalidsegno	fixed bin (35) external;
      136 dcl  error_table_$known_in_other_rings	fixed bin (35) external;
      137 dcl  error_table_$lower_ring		fixed bin (35) external;
      138 dcl  error_table_$master_dir		fixed bin (35) external;
      139 dcl  error_table_$safety_sw_on	fixed bin (35) external;
      140 dcl  error_table_$seg_unknown		fixed bin (35) external;
      141 dcl  error_table_$segknown		fixed bin (35) external;
      142 dcl  error_table_$vtoce_connection_fail fixed bin (35) external; ;
      143 dcl  pds$access_authorization		bit (72) aligned external;
      144 dcl  pds$process_group_id		char (24) ext;
      145 dcl  pds$processid			bit (36) aligned ext;
      146 
      147 /* Entries */
      148 
      149 dcl  acc_name_$delete		entry (ptr);
      150 dcl  access_audit_check_ep_$self	entry (bit (36) aligned, bit (36) aligned, ptr) returns (bit (1));
      151 dcl  access_audit_$log_entry_ptr	entry (char (*), fixed bin, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, fixed bin (18), char (*));
      152 dcl  acl_$del_acl			entry (fixed bin, bit (36) aligned, ptr);
      153 dcl  aim_check_$equal		entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      154 dcl  delete_vtoce			entry (ptr, fixed bin (35));
      155 dcl  fs_alloc$free			entry (ptr, fixed bin, ptr);
      156 dcl  hash$out			entry (ptr, ptr, ptr, fixed bin (35));
      157 dcl  level$get			entry returns (fixed bin);
      158 dcl  lock$dir_lock_write		entry (ptr, fixed bin (35));
      159 dcl  lock$dir_unlock		entry (ptr);
      160 dcl  lock$dir_unlock_given_uid	entry (bit (36) aligned);
      161 dcl  makeknown_			entry (ptr, fixed bin, fixed bin, fixed bin (35));
      162 dcl  makeunknown_			entry (fixed bin, bit (36) aligned, bit (1) aligned, fixed bin (35));
      163 dcl  mountedp			entry (bit (36) aligned) returns (fixed bin (35));
      164 dcl  pathname_am$clear		entry (fixed bin (17));
      165 dcl  pathname_am$flush		entry (bit (36) aligned);
      166 dcl  sum$dirmod			entry (ptr);
      167 dcl  syserr			entry options (variable);
      168 dcl  syserr$error_code		entry options (variable);
      169 dcl  terminate_$id			entry (bit (36) aligned, fixed bin, fixed bin (35));
      170 dcl  vtoc_attributes$get_quota	entry (bit (36) aligned, bit (36) aligned, fixed bin, ptr, fixed bin, fixed bin (35));
      171 
      172 /* Misc */
      173 
      174 dcl  (addr, fixed, ptr, rel, null, baseptr, unspec) builtin;
      175 
      176 dcl  bad_dir_			condition;
      177 dcl  seg_fault_error		condition;
      178 
      179 salv_delete_branch: entry (a_ep, a_code);		/* Make branch go awayy */
      180 
      181 	ep = a_ep;
      182 	dp = ptr (ep, 0);
      183 	dirl = "0"b;				/* Don't unlock dir */
      184 	code = 0;
      185 	damaged = "1"b;				/* Couldnt get inferior dir */
      186 	segptr = null;				/* didn't touch inferior */
      187 	segl = "0"b;				/* or lock it */
      188 	if ^entry.bs then type = link_br;
      189 	else if entry.dirsw then type = directory;
      190 	else type = segment;
      191 	go to remove;				/* Remove the branch */
      192 
      193 retv: entry (a_dirname, a_ename, a_code);
      194 
      195 	e_sw = retv;
      196 	goto set_code;
      197 
      198 
      199 priv_dfile: entry (a_dirname, a_ename, a_code);
      200 	priv_entry = "1"b;
      201 
      202 dfile: entry (a_dirname, a_ename, a_code);
      203 	e_sw = file;				/* indicate through which entry point entered */
      204 
      205 set_code: code = 0;					/* clear return status code */
      206 	dirname = a_dirname;			/* copy arguments */
      207 	ename = a_ename;
      208 
      209 	if e_sw ^= retv & ^priv_entry then call dc_find$obj_delete (dirname, ename, DC_FIND_NO_CHASE, ep, code);
      210 	else call dc_find$obj_delete_priv (dirname, ename, DC_FIND_NO_CHASE, ep, code); /* get ptr to entry + lock dir for writing */
      211 	if code ^= 0 then go to ret;
      212 	go to common;
      213 
      214 
      215 dseg: entry (a_sp, a_code);
      216 
      217 	code = 0;					/* clear return status code */
      218 	e_sw = seg;				/* indicate through entry point we entered */
      219 	sp = a_sp;				/* copy arg */
      220 	call dc_find$obj_delete_ptr (sp, ep, code);	/* get ptr to entry + lock for write */
      221 	if code ^= 0 then go to ret;
      222 	go to common;
      223 
      224 duid_mdir_priv: entry (a_uidpath, a_trp, a_code);		/* entry to delete given uidpathname */
      225 
      226 	e_sw = uid_mdir;				/* name type entry */
      227 	uidpath = a_uidpath;			/* copy path */
      228 	call dc_find$obj_delete_priv_uid (uidpath, dirname, ename, ep, code); /* find the thing */
      229 	if code ^= 0 then go to ret;
      230 	priv_entry = "1"b;
      231 	trp = 0;
      232 	goto common;
      233 
      234 duid_mdir: entry (a_uidpath, a_trp, a_code);		/* entry to delete given uidpathname */
      235 
      236 	e_sw = uid_mdir;				/* name type entry */
      237 	uidpath = a_uidpath;			/* copy path */
      238 	call dc_find$obj_delete_uid (uidpath, dirname, ename, ep, code); /* find the thing */
      239 	if code ^= 0 then go to ret;
      240 	trp = 0;
      241 
      242 common:
      243 	dp = ptr (ep, 0);
      244 	dirl = "1"b;
      245 	if ^ep -> entry.bs then do;			/* link case */
      246 	     type = link_br;			/* set type of entry */
      247 	     go to remove;
      248 	end;
      249 	else if ^ep -> entry.dirsw then type = segment;	/* non-directory branch */
      250 	else type = directory;			/* directory branch */
      251 
      252 	if e_sw ^= retv & ^priv_entry then do;
      253 	     ring = level$get ();			/* get validation level */
      254 	     if (type = segment & ring > fixed (ep -> entry.ring_brackets (1), 3)) |
      255 		(type ^= segment & ring > fixed (ep -> entry.ex_ring_brackets (1), 3)) then do;
      256 		code = error_table_$lower_ring;	/* ringbrackets must be consistent with validation level */
      257 		go to finale;
      258 	     end;
      259 
      260 	     if entry.copysw then do;			/* branch cannot be deleted if copy on */
      261 		code = error_table_$copy_sw_on;
      262 		go to finale;
      263 	     end;
      264 	     if entry.safety_sw then do;		/* branch may not be deleted if safety switch on */
      265 		code = error_table_$safety_sw_on;
      266 		go to finale;
      267 	     end;
      268 	end;
      269 						/* If ename is a directory branch, be sure there are */
      270 	if type = directory then do;			/* no entries in that directory before deleting it */
      271 	     if e_sw = seg then do;			/* Forbid use of ptr entry */
      272 		code = error_table_$dirseg;
      273 		go to finale;
      274 	     end;
      275 	     seg_uid = entry.uid;			/* Make sure nobody deletes it */
      276 	     segptr = null;
      277 	     on seg_fault_error begin;
      278 		damaged = "1"b;
      279 		goto dir_glop;
      280 	     end;
      281 	     unspec (mk_info) = "0"b;
      282 	     mk_info.uid = seg_uid;
      283 	     mk_info.entryp = ep;
      284 	     mk_info.dirsw = "1"b;
      285 	     mk_info.allow_write = "1"b;
      286 	     mk_info.activate = "1"b;
      287 	     call makeknown_ (addr (mk_info), segno, (0), code);
      288 	     if code = 0 | code = error_table_$segknown then
      289 		segptr = baseptr (segno);
      290 	     else if code = error_table_$vtoce_connection_fail then damaged = "1"b;
      291 	     else goto finale;
      292 	     call dc_find$finished (dp, "1"b);		/* unlock and unreference (initiated dir will hold parent) - allows seg_fault to work */
      293 	     dirl = "0"b;
      294 	     if damaged then goto dir_glop;		/* skip segfault on next statement */
      295 
      296 	     if segptr -> dir.uid = "0"b then do;	/* If the directory's UID is 0 we cant lock it */
      297 		call syserr (4, "delentry: deleting damaged dir ^a>^a for ^a",
      298 		     dirname, ename, pds$process_group_id);
      299 		damaged = "1"b;			/* .. but then, nobody else can either */
      300 	     end;
      301 	     else do;
      302 		call lock$dir_lock_write (segptr, code);/* Lock the dir to be deleted */
      303 		if code ^= 0 then go to finale;
      304 		segl = "1"b;
      305 	     end;
      306 dir_glop:	     revert seg_fault_error;
      307 	     if e_sw = seg then call dc_find$obj_delete_ptr (sp, ep, code); /* refind dir */
      308 	     else if e_sw = retv | priv_entry then call dc_find$obj_delete_priv (dirname, ename, DC_FIND_NO_CHASE, ep, code);
      309 	     else call dc_find$obj_delete (dirname, ename, DC_FIND_NO_CHASE, ep, code);
      310 	     if code ^= 0 then do;
      311 		if segptr ^= null then do;
      312 		     call lock$dir_unlock (segptr);	/* Gack. How does this happen */
      313 		     call makeunknown_ (segno, "0"b, ("0"b), ignore); /* .. ayway cleanup */
      314 		end;
      315 		go to ret;
      316 	     end;
      317 	     dp = ptr (ep, 0);			/* Regenerate dp just in case */
      318 	     dirl = "1"b;
      319 	     if seg_uid ^= entry.uid then do;		/* Check that our access check above .. */
      320 		code = error_table_$invalidsegno;	/* .. hasn't been interfered with */
      321 		go to finale;			/* nasty */
      322 	     end;
      323 	     if ^damaged then do;			/* Various validity checks. skip for bad dir */
      324 		if segptr -> dir.master_dir then
      325 		     if e_sw ^= uid_mdir & ^priv_entry then do;
      326 			code = error_table_$master_dir; /* Do not delete master directory */
      327 			go to finale;
      328 		     end;
      329 		if segptr -> dir.seg_count ^= 0	/* check if directory has any branches */
      330 		     | segptr -> dir.dir_count ^= 0
      331 		     | segptr -> dir.lcount ^= 0 then do;
      332 
      333 		     code = error_table_$fulldir;
      334 		     if /* tree */ ^aim_check_$equal (pds$access_authorization, segptr -> dir.access_class) then /* audit possible covert channel */
      335 			if ^addr (pds$access_authorization) -> aim_template.privileges.dir then do;
      336 			     audit_eventflags = "0"b;
      337 			     addr (audit_eventflags) -> audit_event_flags.cc_10_100 = "1"b;
      338 			     if access_audit_check_ep_$self (audit_eventflags, access_operations_$fs_obj_delete, ep) then
      339 				call access_audit_$log_entry_ptr
      340 				     ("delentry", level$get (), audit_eventflags, access_operations_$fs_obj_delete, ep, code, null, 0, "");
      341 			end;
      342 		     go to finale;
      343 		end;
      344 		if e_sw = uid_mdir then do;		/* caller wants a time record product */
      345 		     pvid = entry.pvid;
      346 		     vtocx = entry.vtocx;
      347 		     qcp = addr (qcell);
      348 		     call vtoc_attributes$get_quota (seg_uid, pvid, vtocx, qcp, 0, code);
      349 		     if code = 0 then trp = quota_cell.trp; /* save it if i got it */
      350 		end;
      351 	     end;
      352 	end;
      353 
      354 
      355 
      356 /* Everything AOK. Remove segment and branch and go to finale. */
      357 
      358 	if type ^= link_br then do;
      359 	     if priv_entry | type = directory then code = 0; /* only check if unpriv or segment */
      360 	     else code = mountedp (dir.sons_lvid);
      361 	     if code = 0 then do;
      362 		call delete_vtoce (ep, code);
      363 		if code ^= 0 then call syserr$error_code (LOG, code, "delentry: failed to delete_vtoce for ^w ^o.", ep -> entry.pvid, ep -> entry.vtocx);
      364 	     end;
      365 	     if code ^= 0 then			/* error from delete_vtoce prob volume not up */
      366 		if ^priv_entry | code = error_table_$infcnt_non_zero then /* unprivileged attempt or dir contains known inferior segments */
      367 		     go to finale;			/* leave branch intact and return error code */
      368 						/*		else call syserr$error_code (4, code,
      369*						   "delentry: priv_dfile error deleting vtoce for ^a>^a for ^a",
      370*						   dirname, ename, pds$process_group_id);
      371*						   -- Priv deletions used to be logged */
      372 	end;
      373 
      374 remove:
      375 	dir.modify = pds$processid;			/* mark dir unstable */
      376 	nrp = entry.name_brp;			/* get rp to last name */
      377 	areap = ptr (dp, dir.arearp);			/* get ptr to area */
      378 	nnames = fixed (entry.nnames, 18);		/* pick up count of names */
      379 	ncnt = 0;
      380 
      381 name_loop:
      382 	ncnt = ncnt + 1;				/* keep track of number of names deleted */
      383 	if ncnt > nnames then signal bad_dir_;		/* too many times through the loop */
      384 	np = ptr (dp, nrp);				/* get ptr to name entry to be removed */
      385 	if np -> names.type ^= NAME_TYPE
      386 	     | np -> names.owner ^= entry.uid
      387 	     | np -> names.entry_rp ^= rel (ep) then signal bad_dir_;
      388 	call hash$out (dp, addr (np -> names.name), onp, code); /* remove name from hash table */
      389 	if code ^= 0 then call syserr$error_code (4, code, "delentry: error from hash$out on ""^a"" for ^a",
      390 		np -> names.name, pds$process_group_id);
      391 
      392 	if np ^= onp then signal bad_dir_;		/* check that hash table entry and name entry are consistent */
      393 
      394 	nrp = np -> names.bp;			/* get rp to previous name on list */
      395 	if nrp then do;				/* if not primary name stored in the entry */
      396 	     entry.name_brp = nrp;			/* thread name list to entry */
      397 	     call fs_alloc$free (areap, active_hardcore_data$ensize, np); /* free name entry */
      398 	     go to name_loop;			/* continue removing names */
      399 	end;
      400 	entry.name_frp, entry.name_brp = "0"b;		/* clear name threads */
      401 	entry.nnames = 0;				/* zero name count */
      402 
      403 	if type ^= link_br then do;			/* in the branch case free the storage of the acl */
      404 	     aclep = addr (entry.acl_frp);		/* get pointer to start of acl */
      405 	     acl_count = fixed (entry.acle_count, 18);	/* get count of acls assoc with this entry */
      406 	     call acl_$del_acl (acl_count, entry.uid, aclep); /* remove entire acl */
      407 
      408 	     dir.acle_total =			/* decrease count of acl entries in dir header */
      409 		dir.acle_total - acl_count;
      410 
      411 	     entry.acl_frp, entry.acl_brp = "0"b;	/* zero out acl threads */
      412 	     entry.acle_count = 0;			/* zero out acl count in entry */
      413 
      414 	     asize = active_hardcore_data$esize;	/* size of area to be freed is entry size */
      415 						/* delete bc author and update pers and proj name lists */
      416 	     call acc_name_$delete (addr (entry.bc_author));
      417 
      418 	     mkunk_uid = entry.uid;			/* get it unknown later */
      419 	     segptr = null;
      420 	end;
      421 	else do;					/* in link case set pathname size to zero */
      422 	     ep -> link.pathname_size = 0;
      423 	     asize = ep -> link.size;			/* pick up number of words in link entry (for freeing) */
      424 	end;
      425 
      426 	call acc_name_$delete (addr (entry.author));	/* delete author and update pers and proj name lists */
      427 
      428 	if entry.ebrp then ptr (ep, entry.ebrp) -> entry.efrp = entry.efrp; /* unthread the entry */
      429 	if entry.efrp then ptr (ep, entry.efrp) -> entry.ebrp = entry.ebrp;
      430 	if rel (ep) = dir.entrybrp then dir.entrybrp = entry.ebrp;
      431 	if rel (ep) = dir.entryfrp then dir.entryfrp = entry.efrp;
      432 	entry.ebrp, entry.efrp = "0"b;
      433 	if type = link_br then dir.lcount = dir.lcount - 1; /* fix seg, dir, or link_br count in dir */
      434 	else if type = segment then dir.seg_count = dir.seg_count - 1;
      435 	else dir.dir_count = dir.dir_count - 1;
      436 	entry.uid = "0"b;				/* clear uid */
      437 	entry.pvid = "0"b;
      438 	call fs_alloc$free (areap, asize, ep);		/* free the entry */
      439 	if type = directory & ^damaged then do;
      440 	     if ^entry.per_process_sw then call pathname_am$flush (mkunk_uid);
      441 	     else call pathname_am$clear (segno);
      442 	     call lock$dir_unlock_given_uid (seg_uid);
      443 	     segl = "0"b;
      444 	end;
      445 	if dirl then dir.modify = "0"b;		/* If we locked dir, mark as ok now. */
      446 	call sum$dirmod (dp);
      447 
      448 
      449 finale:
      450 	if segl then call lock$dir_unlock_given_uid (seg_uid); /* may not be all there */
      451 	if dirl then do;
      452 	     dir.modify = "0"b;
      453 	     if e_sw ^= seg then call dc_find$finished (dp, "1"b);
      454 	     else call lock$dir_unlock (dp);
      455 						/* dont touch lot unless we locked dir */
      456 	     if segptr ^= null then call makeunknown_ (segno, "0"b, ("0"b), ignore); /* implies dir */
      457 	     else if mkunk_uid ^= "0"b then do;
      458 		call terminate_$id (mkunk_uid, 0, code);
      459 		if code ^= 0 then if code = error_table_$seg_unknown
      460 			| code = error_table_$invalidsegno
      461 			| code = error_table_$known_in_other_rings then code = 0;
      462 		     else call syserr$error_code (4, code, "delentry: error from terminate_ for ^a", pds$process_group_id);
      463 	     end;
      464 	end;
      465 	if e_sw = uid_mdir then a_trp = trp;
      466 ret:
      467 	a_code = code;
      468 	return;
      469 
      470 /* format: off */
      471 
      472  /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
      472 
      473  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  2     2 
  2     3 /* Created 740723 by PG */
  2     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  2     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  2     6 
  2     7 /* This structure defines the components of both an access
  2     8*   class and an access authorization as interpreted by the
  2     9*   Access Isolation Mechanism. */
  2    10 
  2    11 
  2    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  2    13        2 categories bit (36),				/* access categories */
  2    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  2    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  2    16         (3 ipc,					/* interprocess communication privilege */
  2    17          3 dir,					/* directory privilege */
  2    18          3 seg,					/* segment privilege */
  2    19          3 soos,					/* security out-of-service privilege */
  2    20          3 ring1,					/* ring 1 access privilege */
  2    21          3 rcp,					/* RCP resource access privilege */
  2    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  2    23          3 pad bit (11);
  2    24 
  2    25 
  2    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      473 
      474  /* BEGIN include file dc_find_dcls.incl.pl1 */
  3     2 
  3     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  3     4 /* Added a few more, October 1984. */
  3     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  3     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  3     7 
  3     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  3     9 
  3    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  3    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  3    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  3    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  3    14 
  3    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  3    18 
  3    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  3    20 
  3    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  3    22 
  3    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  3    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  3    25 
  3    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  3    27 
  3    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  3    29 
  3    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    32 
  3    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  3    34 
  3    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  3    36 
  3    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  3    38 
  3    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    41 
  3    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    44 
  3    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    47 
  3    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    52 
  3    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  3    58 
  3    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  3    60 
  3    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  3    62 
  3    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  3    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  3    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  3    66 
  3    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  3    68 
  3    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  3    70 
  3    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    72 
  3    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    74 
  3    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  3    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    82 
  3    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    87 
  3    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  3    90 
  3    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  3    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  3    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  3    94 
  3    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    96 
  3    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  3    98 
  3    99 /* END include file dc_find_dcls.incl.pl1 */
      474 
      475  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      475 
      476  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  5     2 /* Modified 8/74 for NSS */
  5     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  5     4 /* Modified 3/82 BIM for change pclock */
  5     5 /* format: style3 */
  5     6 
  5     7 /* Template for the directory header. Length = 64 words. */
  5     8 
  5     9 dcl  dp ptr;
  5    10 
  5    11 dcl 1 dir based (dp) aligned,
  5    12 
  5    13    2 modify bit (36),				/* Process ID of last modifier */
  5    14    2 type bit (18) unaligned,			/* type of object = dir header */
  5    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  5    16     2 dtc (3),					/* date-time checked by salvager array */
  5    17       3 date bit (36),				/* the date */
  5    18       3 error bit (36),				/* what errors were discovered */
  5    19 
  5    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  5    21 
  5    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  5    23 
  5    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  5    25 
  5    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  5    27 
  5    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  5    29     2 version_number fixed bin (17),			/* version number of header */
  5    30 
  5    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  5    32     2 pad2 bit (18),
  5    33 
  5    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  5    35     2 pad3 bit (18),
  5    36 
  5    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  5    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  5    39 
  5    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  5    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  5    42 
  5    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  5    44     2 dir_count fixed bin (17),			/* number of directory branches */
  5    45 
  5    46     2 lcount fixed bin (17),				/* number of links */
  5    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  5    48 
  5    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  5    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  5    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  5    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  5    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  5    54     2 pad4 bit (14),
  5    55 
  5    56     2 iacl_count (0:7),
  5    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  5    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  5    59 
  5    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  5    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  5    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  5    63 
  5    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  5    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  5    66 
  5    67     2 htsize fixed bin (17),				/* size of hash table */
  5    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  5    69 
  5    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  5    71     2 pad6 fixed bin (17),
  5    72 
  5    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  5    74     2 pad7 bit (18)) unaligned,
  5    75 
  5    76     2 dts bit (36),					/* date-time directory last salvaged */
  5    77 
  5    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  5    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  5    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  5    81     2 checksum bit (36),				/* checksummed from uid on */
  5    82     2 owner bit (36);				/* uid of parent dir */
  5    83 
  5    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  5    85 
  5    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      476 
      477  /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  6     2 
  6     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  6     4 
  6     5 
  6     6 dcl 1 link based (ep) aligned,
  6     7 
  6     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  6     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  6    10 
  6    11     2 type bit (18),				/* type = dir link */
  6    12     2 size fixed bin (17),				/* size of link in words */
  6    13 
  6    14     2 uid bit (36),					/* unique id of entry */
  6    15 
  6    16     2 dtem bit (36),				/* date-time entry modified */
  6    17 
  6    18     2 bs bit (1),					/* entry switch = 1 if entry */
  6    19     2 pad0 bit (17),
  6    20     2 nnames fixed bin (17),				/* number of names for this entry */
  6    21 
  6    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  6    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  6    24 
  6    25     2 author,					/* user who created entry */
  6    26       3 pers_rp bit (18),				/* name of user who created entry */
  6    27       3 proj_rp bit (18),				/* project of user who created entry */
  6    28 
  6    29       3 tag char (1),				/* tag of user who created entry */
  6    30       3 pad1 char (3),
  6    31 
  6    32     2 primary_name bit (504),				/* first name on name list */
  6    33 
  6    34     2 dtd bit (36),					/* date time dumped */
  6    35 
  6    36     2 pad2 bit (36),
  6    37 
  6    38 
  6    39 /* the declarations below are only applicable to links */
  6    40 
  6    41     2 pad3 bit (18),
  6    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  6    43 
  6    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  6    45 
  6    46     2 checksum bit (36),				/* checksum from uid */
  6    47 
  6    48     2 owner bit (36);				/* uid of containing directory */
  6    49 
  6    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
      477 
      478  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  7     2 
  7     3 /* Template for names of branches or links. Length = 14 words. */
  7     4 
  7     5 dcl np ptr;
  7     6 
  7     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  7     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  7     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  7    10 
  7    11     2 type bit (18) unaligned,			/* type = dir name */
  7    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  7    13 
  7    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  7    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  7    16 
  7    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  7    18     2 pad3 bit (18) unal,
  7    19 
  7    20     2 name char(32) aligned,
  7    21 
  7    22     2 checksum bit (36),				/* checksum from entry_rp */
  7    23 
  7    24     2 owner bit (36);				/* uid of entry */
  7    25 
  7    26 
  7    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      478 
      479  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
  8     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  8     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
  8     8*                                                   END HISTORY COMMENTS */
  8     9 
  8    10 
  8    11 /* The possible events within the file system; access codes and
  8    12*   detailed operation codes.  October 1984, Keith Loepere. */
  8    13 
  8    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  8    15 
  8    16 /* Major file system operations. */
  8    17 
  8    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
  8    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
  8    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
  8    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
  8    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
  8    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
  8    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
  8    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
  8    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
  8    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
  8    28 
  8    29 /* Detailed operations. */
  8    30 
  8    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
  8    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
  8    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
  8    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
  8    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
  8    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
  8    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
  8    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
  8    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
  8    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
  8    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
  8    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
  8    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
  8    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
  8    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
  8    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
  8    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
  8    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
  8    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
  8    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
  8    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
  8    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
  8    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
  8    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
  8    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
  8    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
  8    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
  8    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
  8    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
  8    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
  8    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
  8    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
  8    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
  8    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
  8    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
  8    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
  8    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
  8    68 
  8    69 /* END include file fs_obj_access_codes.incl.pl1 */
      479 
      480  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  9     2 
  9     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  9     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  9     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  9     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  9     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  9     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  9     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  9    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  9    11 
  9    12 dcl  access_name_type fixed bin static options (constant) init (1);
  9    13 dcl  acle_type fixed bin static options (constant) init (2);
  9    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  9    15 dcl  dir_type fixed bin static options (constant) init (4);
  9    16 dcl  link_type fixed bin static options (constant) init (5);
  9    17 dcl  name_type fixed bin static options (constant) init (6);
  9    18 dcl  seg_type fixed bin static options (constant) init (7);
  9    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  9    20 
  9    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      480 
      481  /*  BEGIN INCLUDE FILE - - - makeknown_info.incl.pl1 - - - last modified March 1975 by R. Bratt - - - */
 10     2 /* Modified October 1984 for explicit activate flag and to remove 
 10     3*   detectable flag, Keith Loepere. */
 10     4 
 10     5 dcl  makeknown_infop ptr;
 10     6 
 10     7 dcl 1 makeknown_info aligned based (makeknown_infop),
 10     8     2 uid bit (36) aligned,
 10     9     2 entryp ptr unaligned,
 10    10     2 flags unaligned,
 10    11       3 dirsw bit (1),
 10    12       3 rsw bit (1),
 10    13       3 allow_write bit (1),
 10    14       3 priv_init bit (1),
 10    15       3 audit bit (1),
 10    16       3 activate bit (1);			/* Use only for directory initiation within directory control */
 10    17 
 10    18 /*   END INCLUDE FILE makeknown_info.incl.pl1 - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      481 
      482  /* BEGIN INCLUDE FILE ... quota_cell.incl.pl1 ... February 1982 */
 11     2 
 11     3 dcl 1 quota_cell based (qcp) aligned,			/* Argument used by vtoc_attributes$(get set)_quota */
 11     4     2 quota fixed bin (35),				/* Record quota */
 11     5     2 used fixed bin (35),				/* Current use */
 11     6     2 received fixed bin (35),			/* Quota moved down */
 11     7     2 tup bit (36),					/* Clock time of update */
 11     8     2 trp fixed bin (71),				/* Time-page-product, in page-seconds */
 11     9     2 pad fixed bin,
 11    10     2 terminal_quota_sw bit (1);			/* TRUE if terminal quota */
 11    11 
 11    12 dcl  qcp ptr;
 11    13 
 11    14 /* END INCLUDE FILE ... quota_cell */
      482 
      483  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 12     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 12     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 12     4 
 12     5 /* This include file has an ALM version.  Keep 'em in sync! */
 12     6 
 12     7 dcl (
 12     8 
 12     9 /* The following constants define the message action codes.  This indicates
 12    10*how a message is to be handled.  */
 12    11 
 12    12      SYSERR_CRASH_SYSTEM	init (1),			
 12    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 12    14 
 12    15      SYSERR_TERMINATE_PROCESS	init (2),
 12    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 12    17 
 12    18      SYSERR_PRINT_WITH_ALARM	init (3),
 12    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 12    20 
 12    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 12    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 12    23 
 12    24      SYSERR_LOG_OR_PRINT	init (4),
 12    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 12    26 
 12    27      SYSERR_LOG_OR_DISCARD	init (5),
 12    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 12    29 
 12    30 
 12    31 /* The following constants are added to the normal severities to indicate
 12    32*different sorting classes of messages.  */
 12    33 
 12    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 12    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 12    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 12    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 12    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 12    39 	) fixed bin internal static options (constant);
 12    40 
 12    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      483 
      484 
      485 /* format: on */
      486 
      487 /* BEGIN MESSAGE DOCUMENTATION
      488*
      489*   Message:
      490*   delentry: deleting damaged dir PATH for USERID
      491*
      492*   S:	$log
      493*
      494*   T:	$run
      495*
      496*   M:	An attempt to delete a directory
      497*   found that the directory header had a zero UID.
      498*   The directory was deleted anyway.
      499*
      500*   A:	$ignore
      501*
      502*   Message:
      503*   delentry: priv_dfile error deleting vtoce for PATH for USERID. ERROR_CODE
      504*
      505*   S:	$log
      506*
      507*   T:	$run
      508*
      509*   M:	A privileged call to delete a segment
      510*   discovered a branch with not VTOC entry.
      511*   This situation is called a "connection failure."
      512*   The branch was deleted anyway.
      513*
      514*   A:	$ignore
      515*
      516*   Message:
      517*   delentry: error from hash$out on "NAME" for USERID. ERROR_CODE
      518*
      519*   S:	$log
      520*
      521*   T:	$run
      522*
      523*   M:	An attempt to delete the entry name NAME from the directory
      524*   hash table failed.
      525*   $err
      526*
      527*   A:	$ignore
      528*
      529*   Message:
      530*   delentry: error from terminate_ for USERID. ERROR_CODE
      531*
      532*   S:	$log
      533*
      534*   T:	$run
      535*
      536*   M:	An error code was returned while trying to
      537*   make a directory unknown
      538*   while deleting it.
      539*   $err
      540*
      541*   A:	$ignore
      542*
      543*   END MESSAGE DOCUMENTATION */
      544 
      545      end delentry;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  delentry.pl1                      >spec>install>1110>delentry.pl1
472          1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
473          2    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
474          3    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
475          4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
476          5    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
477          6    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
478          7    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
479          8    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
480          9    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
481         10    01/30/85  1523.9  makeknown_info.incl.pl1           >ldd>include>makeknown_info.incl.pl1
482         11    05/27/82  1525.9  quota_cell.incl.pl1               >ldd>include>quota_cell.incl.pl1
483         12    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_NO_CHASE                000017 constant        fixed bin(1,0)           initial dcl 3-11 set ref 209* 210* 308* 309*
LOG                             000016 constant        fixed bin(17,0)          initial dcl 12-7 set ref 363*
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 9-8 ref 385
a_code                                 parameter       fixed bin(35,0)          dcl 74 set ref 179 193 199 202 215 224 234 466*
a_dirname                              parameter       char                     packed unaligned dcl 75 ref 193 199 202 206
a_ename                                parameter       char                     packed unaligned dcl 76 ref 193 199 202 207
a_ep                                   parameter       pointer                  dcl 77 ref 179 181
a_sp                                   parameter       pointer                  dcl 78 ref 215 219
a_trp                                  parameter       fixed bin(71,0)          dcl 79 set ref 224 234 465*
a_uidpath                              parameter       bit(36)                  array dcl 80 ref 224 227 234 237
acc_name_$delete                000052 constant        entry                    external dcl 149 ref 416 426
access_audit_$log_entry_ptr     000056 constant        entry                    external dcl 151 ref 338
access_audit_check_ep_$self     000054 constant        entry                    external dcl 150 ref 338
access_class             13            based           bit(72)                  level 2 dcl 5-11 set ref 334*
access_operations_$fs_obj_delete
                                000142 external static bit(36)                  dcl 8-19 set ref 338* 338*
acl_$del_acl                    000060 constant        entry                    external dcl 152 ref 406
acl_brp                  36(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 411*
acl_count                       000100 automatic       fixed bin(17,0)          dcl 84 set ref 405* 406* 408
acl_frp                  36            based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 404
                                                                                  411*
acle_count               35(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-8 set ref 405
                                                                                  412*
acle_total               23(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 set ref
                                                                                  408* 408
aclep                           000102 automatic       pointer                  dcl 85 set ref 404* 406*
activate                  2(05) 000177 automatic       bit(1)                   level 3 packed packed unaligned dcl 96 set ref 286*
active_hardcore_data$ensize     000010 external static fixed bin(17,0)          dcl 129 set ref 397*
active_hardcore_data$esize      000012 external static fixed bin(17,0)          dcl 130 ref 414
addr                                                   builtin function         dcl 174 ref 287 287 334 337 347 388 388 404 416 416
                                                                                  426 426
aim_check_$equal                000062 constant        entry                    external dcl 153 ref 334
aim_template                           based           structure                level 1 dcl 2-12
allow_write               2(02) 000177 automatic       bit(1)                   level 3 packed packed unaligned dcl 96 set ref 285*
areap                           000104 automatic       pointer                  dcl 86 set ref 377* 397* 438*
arearp                   24            based           bit(18)                  level 2 packed packed unaligned dcl 5-11 ref 377
asize                           000106 automatic       fixed bin(17,0)          dcl 87 set ref 414* 423* 438*
audit_event_flags                      based           structure                level 1 dcl 1-5
audit_eventflags                000107 automatic       bit(36)                  dcl 88 set ref 336* 337 338* 338*
author                    6            based           structure                level 2 packed packed unaligned dcl 4-8 set ref 426
                                                                                  426
bad_dir_                        000260 stack reference condition                dcl 176 ref 383 385 392
baseptr                                                builtin function         dcl 174 ref 288
bc_author                37            based           structure                level 2 packed packed unaligned dcl 4-8 set ref 416
                                                                                  416
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 7-7 ref 394
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 188 245
cc_10_100                 0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-5 set ref 337*
code                            000110 automatic       fixed bin(35,0)          dcl 89 set ref 184* 205* 209* 210* 211 217* 220* 221
                                                                                  228* 229 238* 239 256* 261* 265* 272* 287* 288 288
                                                                                  290 302* 303 307* 308* 309* 310 320* 326* 333*
                                                                                  338* 348* 349 359* 360* 361 362* 363 363* 365 365
                                                                                  388* 389 389* 458* 459 459 459 459 459* 462* 466
copysw                   32(03)        based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 260
damaged                         000111 automatic       bit(1)                   initial packed unaligned dcl 90 set ref 90* 185*
                                                                                  278* 290* 294 299* 323 439
dc_find$finished                000126 constant        entry                    external dcl 3-33 ref 292 453
dc_find$obj_delete              000130 constant        entry                    external dcl 3-53 ref 209 309
dc_find$obj_delete_priv         000132 constant        entry                    external dcl 3-54 ref 210 308
dc_find$obj_delete_priv_uid     000136 constant        entry                    external dcl 3-56 ref 228
dc_find$obj_delete_ptr          000140 constant        entry                    external dcl 3-57 ref 220 307
dc_find$obj_delete_uid          000134 constant        entry                    external dcl 3-55 ref 238
delete_vtoce                    000064 constant        entry                    external dcl 154 ref 362
dir                                    based           structure                level 1 dcl 5-11 in procedure "delentry"
dir                       1(19)        based           bit(1)                   level 3 in structure "aim_template" packed packed
                                                                                  unaligned dcl 2-12 in procedure "delentry" ref 334
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 set ref 329
                                                                                  435* 435
directory                              constant        fixed bin(17,0)          initial dcl 118 ref 189 250 270 359 439
dirl                            000112 automatic       bit(1)                   initial packed unaligned dcl 91 set ref 91* 183*
                                                                                  244* 293* 318* 445 451
dirname                         000113 automatic       char(168)                packed unaligned dcl 92 set ref 206* 209* 210* 228*
                                                                                  238* 297* 308* 309*
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "delentry" ref 189 249
dirsw                     2     000177 automatic       bit(1)                   level 3 in structure "mk_info" packed packed
                                                                                  unaligned dcl 96 in procedure "delentry" set ref
                                                                                  284*
dp                              000276 automatic       pointer                  dcl 5-9 set ref 182* 242* 292* 317* 360 374 377 377
                                                                                  384 388* 408 408 430 430 431 431 433 433 434 434
                                                                                  435 435 445 446* 452 453* 454*
e_sw                            000165 automatic       fixed bin(17,0)          dcl 93 set ref 195* 203* 209 218* 226* 236* 252 271
                                                                                  307 308 324 344 453 465
ebrp                      0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 428
                                                                                  428 429* 429 430 432*
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 428*
                                                                                  428 429 429 431 432*
ename                           000166 automatic       char(32)                 packed unaligned dcl 94 set ref 207* 209* 210* 228*
                                                                                  238* 297* 308* 309*
entry                                  based           structure                level 1 dcl 4-8
entry_rp                  2            based           bit(18)                  level 2 packed packed unaligned dcl 7-7 ref 385
entrybrp                 17            based           bit(18)                  level 2 packed packed unaligned dcl 5-11 set ref 430
                                                                                  430*
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 5-11 set ref 431
                                                                                  431*
entryp                    1     000177 automatic       pointer                  level 2 packed packed unaligned dcl 96 set ref 283*
ep                              000274 automatic       pointer                  dcl 4-6 set ref 181* 182 188 189 209* 210* 220* 228*
                                                                                  238* 242 245 249 254 254 260 264 275 283 307* 308*
                                                                                  309* 317 319 338* 338* 345 346 362* 363 363 376
                                                                                  378 385 385 396 400 400 401 404 405 406 411 411
                                                                                  412 416 416 418 422 423 426 426 428 428 428 428
                                                                                  429 429 429 429 430 430 431 431 432 432 436 437
                                                                                  438* 440
error_table_$copy_sw_on         000014 external static fixed bin(35,0)          dcl 131 ref 261
error_table_$dirseg             000016 external static fixed bin(35,0)          dcl 132 ref 272
error_table_$fulldir            000020 external static fixed bin(35,0)          dcl 133 ref 333
error_table_$infcnt_non_zero    000022 external static fixed bin(35,0)          dcl 134 ref 365
error_table_$invalidsegno       000024 external static fixed bin(35,0)          dcl 135 ref 320 459
error_table_$known_in_other_rings
                                000026 external static fixed bin(35,0)          dcl 136 ref 459
error_table_$lower_ring         000030 external static fixed bin(35,0)          dcl 137 ref 256
error_table_$master_dir         000032 external static fixed bin(35,0)          dcl 138 ref 326
error_table_$safety_sw_on       000034 external static fixed bin(35,0)          dcl 139 ref 265
error_table_$seg_unknown        000036 external static fixed bin(35,0)          dcl 140 ref 459
error_table_$segknown           000040 external static fixed bin(35,0)          dcl 141 ref 288
error_table_$vtoce_connection_fail
                                000042 external static fixed bin(35,0)          dcl 142 ref 290
ex_ring_brackets         35(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 4-8 ref
                                                                                  254
file                                   constant        fixed bin(17,0)          initial dcl 120 ref 203
fixed                                                  builtin function         dcl 174 ref 254 254 378 405
flags                     2     000177 automatic       structure                level 2 packed packed unaligned dcl 96
fs_alloc$free                   000066 constant        entry                    external dcl 155 ref 397 438
hash$out                        000070 constant        entry                    external dcl 156 ref 388
ignore                          000176 automatic       fixed bin(35,0)          dcl 95 set ref 313* 456*
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 set ref 329
                                                                                  433* 433
level$get                       000072 constant        entry                    external dcl 157 ref 253 338 338
link                                   based           structure                level 1 dcl 6-6
link_br                                constant        fixed bin(17,0)          initial dcl 119 ref 188 246 358 403 433
lock$dir_lock_write             000074 constant        entry                    external dcl 158 ref 302
lock$dir_unlock                 000076 constant        entry                    external dcl 159 ref 312 454
lock$dir_unlock_given_uid       000100 constant        entry                    external dcl 160 ref 442 449
makeknown_                      000102 constant        entry                    external dcl 161 ref 287
makeknown_info                         based           structure                level 1 dcl 10-7
makeunknown_                    000104 constant        entry                    external dcl 162 ref 313 456
master_dir               24(19)        based           bit(1)                   level 2 packed packed unaligned dcl 5-11 ref 324
mk_info                         000177 automatic       structure                level 1 dcl 96 set ref 281* 287 287
mkunk_uid                       000202 automatic       bit(36)                  initial dcl 97 set ref 97* 418* 440* 457 458*
modify                                 based           bit(36)                  level 2 dcl 5-11 set ref 374* 445* 452*
mountedp                        000106 constant        entry                    external dcl 163 ref 360
name                      4            based           char(32)                 level 2 dcl 7-7 set ref 388 388 389*
name_brp                  5(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 376
                                                                                  396* 400*
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 400*
names                                  based           structure                level 1 dcl 7-7
ncnt                            000203 automatic       fixed bin(17,0)          dcl 98 set ref 379* 381* 381 383
nnames                    4(18)        based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "delentry" set ref 378 401*
nnames                          000204 automatic       fixed bin(18,0)          dcl 99 in procedure "delentry" set ref 378* 383
np                              000300 automatic       pointer                  dcl 7-5 set ref 384* 385 385 385 388 388 389 392 394
                                                                                  397*
nrp                             000205 automatic       bit(18)                  dcl 100 set ref 376* 384 394* 395 396
null                                                   builtin function         dcl 174 ref 109 186 276 311 338 338 419 456
onp                             000206 automatic       pointer                  dcl 101 set ref 388* 392
owner                    15            based           bit(36)                  level 2 dcl 7-7 ref 385
pathname_am$clear               000110 constant        entry                    external dcl 164 ref 441
pathname_am$flush               000112 constant        entry                    external dcl 165 ref 440
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-6 set ref 422*
pds$access_authorization        000044 external static bit(72)                  dcl 143 set ref 334* 334
pds$process_group_id            000046 external static char(24)                 packed unaligned dcl 144 set ref 297* 389* 462*
pds$processid                   000050 external static bit(36)                  dcl 145 ref 374
per_process_sw           32(02)        based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 440
priv_entry                      000210 automatic       bit(1)                   initial packed unaligned dcl 102 set ref 102* 200*
                                                                                  209 230* 252 308 324 359 365
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 2-12
ptr                                                    builtin function         dcl 174 ref 182 242 317 377 384 428 429
pvid                            000211 automatic       bit(36)                  dcl 103 in procedure "delentry" set ref 345* 348*
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "delentry" set ref 345 363*
                                                                                  437*
qcell                           000212 automatic       structure                level 1 dcl 104 set ref 347
qcp                             000302 automatic       pointer                  dcl 11-12 set ref 347* 348* 349
quota_cell                             based           structure                level 1 dcl 11-3
read_lock                       000256 automatic       bit(36)                  initial dcl 121 set ref 121*
rel                                                    builtin function         dcl 174 ref 385 430 431
retv                                   constant        fixed bin(17,0)          initial dcl 122 ref 195 209 252 308
ring                            000222 automatic       fixed bin(17,0)          dcl 105 set ref 253* 254 254
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 4-8 ref
                                                                                  254
safety_sw                32(04)        based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 264
seg                                    constant        fixed bin(17,0)          initial dcl 123 ref 218 271 307 453
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-11 set ref 329
                                                                                  434* 434
seg_fault_error                 000266 stack reference condition                dcl 177 ref 277 306
seg_uid                         000223 automatic       bit(36)                  dcl 106 set ref 275* 282 319 348* 442* 449*
segl                            000224 automatic       bit(1)                   initial packed unaligned dcl 107 set ref 107* 187*
                                                                                  304* 443* 449
segment                                constant        fixed bin(17,0)          initial dcl 124 ref 190 249 254 254 434
segno                           000225 automatic       fixed bin(17,0)          dcl 108 set ref 287* 288 313* 441* 456*
segptr                          000226 automatic       pointer                  initial dcl 109 set ref 109* 186* 276* 288* 296 302*
                                                                                  311 312* 324 329 329 329 334 419* 456
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-6 ref 423
sons_lvid                12            based           bit(36)                  level 2 dcl 5-11 set ref 360*
sp                              000230 automatic       pointer                  dcl 110 set ref 219* 220* 307*
sum$dirmod                      000114 constant        entry                    external dcl 166 ref 446
syserr                          000116 constant        entry                    external dcl 167 ref 297
syserr$error_code               000120 constant        entry                    external dcl 168 ref 363 389 462
terminate_$id                   000122 constant        entry                    external dcl 169 ref 458
trp                       4            based           fixed bin(71,0)          level 2 in structure "quota_cell" dcl 11-3
                                                                                  in procedure "delentry" ref 349
trp                             000232 automatic       fixed bin(71,0)          dcl 111 in procedure "delentry" set ref 231* 240*
                                                                                  349* 465
type                            000234 automatic       fixed bin(17,0)          dcl 112 in procedure "delentry" set ref 188* 189*
                                                                                  190* 246* 249* 250* 254 254 270 358 359 403 433
                                                                                  434 439
type                      1            based           bit(18)                  level 2 in structure "names" packed packed unaligned
                                                                                  dcl 7-7 in procedure "delentry" ref 385
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "delentry" set ref 275 319 385 406* 418 436*
uid                             000177 automatic       bit(36)                  level 2 in structure "mk_info" dcl 96 in procedure
                                                                                  "delentry" set ref 282*
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "delentry" ref 296
uid_mdir                               constant        fixed bin(17,0)          initial dcl 125 ref 226 236 324 344 465
uidpath                         000235 automatic       bit(36)                  array dcl 113 set ref 227* 228* 237* 238*
unspec                                                 builtin function         dcl 174 set ref 281*
vtoc_attributes$get_quota       000124 constant        entry                    external dcl 170 ref 348
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "delentry" set ref 346 363*
vtocx                           000255 automatic       fixed bin(17,0)          dcl 114 in procedure "delentry" set ref 346* 348*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 9-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 9-4
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 12-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 12-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 12-7
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 3-10
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 3-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 3-13
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 9-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 9-6
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 8-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 8-36
FS_OBJ_AUDIT_FLAG_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-67
FS_OBJ_AUTHOR_MOD                      internal static fixed bin(18,0)          initial unsigned dcl 8-46
FS_OBJ_BACKUP_TIMES_MOD                internal static fixed bin(18,0)          initial unsigned dcl 8-48
FS_OBJ_BC_AUTHOR_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-47
FS_OBJ_BC_MOD                          internal static fixed bin(18,0)          initial unsigned dcl 8-32
FS_OBJ_CONNECT                         internal static fixed bin(18,0)          initial unsigned dcl 8-31
FS_OBJ_COPY_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-38
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 8-55
FS_OBJ_CREATE_BRANCH                   internal static fixed bin(18,0)          initial unsigned dcl 8-66
FS_OBJ_DAMAGED_SW_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-39
FS_OBJ_DATES_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 8-49
FS_OBJ_DIR_SALVAGE                     internal static fixed bin(18,0)          initial unsigned dcl 8-56
FS_OBJ_DNZP_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-40
FS_OBJ_DT_DUMPED_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-50
FS_OBJ_ENTRY_BOUND_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 8-41
FS_OBJ_FOR_RELOADER_MOD                internal static fixed bin(18,0)          initial unsigned dcl 8-51
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-65
FS_OBJ_MAX_LEN_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-42
FS_OBJ_MDIR_QUOTA_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-57
FS_OBJ_MOVE_QUOTA                      internal static fixed bin(18,0)          initial unsigned dcl 8-54
FS_OBJ_QUOTA_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 8-58
FS_OBJ_QUOTA_RELOAD                    internal static fixed bin(18,0)          initial unsigned dcl 8-59
FS_OBJ_RECLASSIFY                      internal static fixed bin(18,0)          initial unsigned dcl 8-60
FS_OBJ_RECLASSIFY_NODE                 internal static fixed bin(18,0)          initial unsigned dcl 8-61
FS_OBJ_RENAME                          internal static fixed bin(18,0)          initial unsigned dcl 8-37
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-35
FS_OBJ_SAFETY_SW_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-43
FS_OBJ_SEG_MOVE                        internal static fixed bin(18,0)          initial unsigned dcl 8-62
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-53
FS_OBJ_SYNC_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-44
FS_OBJ_TRP_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 8-63
FS_OBJ_TRUNCATE                        internal static fixed bin(18,0)          initial unsigned dcl 8-33
FS_OBJ_VOLUME_RETRIEVE                 internal static fixed bin(18,0)          initial unsigned dcl 8-64
FS_OBJ_VOL_DUMP_SW_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 8-45
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 9-10
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 12-7
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 9-7
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 9-9
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 12-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 12-7
access_name_type                       internal static fixed bin(17,0)          initial dcl 9-12
access_operations_$fs_obj_access_mod   external static bit(36)                  dcl 8-27
access_operations_$fs_obj_attr_mod     external static bit(36)                  dcl 8-25
access_operations_$fs_obj_contents_mod external static bit(36)                  dcl 8-23
access_operations_$fs_obj_contents_read
                                       external static bit(36)                  dcl 8-22
access_operations_$fs_obj_create       external static bit(36)                  dcl 8-18
access_operations_$fs_obj_initiate     external static bit(36)                  dcl 8-20
access_operations_$fs_obj_prop_read    external static bit(36)                  dcl 8-24
access_operations_$fs_obj_status_mod   external static bit(36)                  dcl 8-26
access_operations_$fs_obj_terminate    external static bit(36)                  dcl 8-21
acle_type                              internal static fixed bin(17,0)          initial dcl 9-13
dc_find$dir_for_append          000000 constant        entry                    external dcl 3-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 3-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 3-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 3-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 3-21
dc_find$dir_read                000000 constant        entry                    external dcl 3-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 3-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 3-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 3-28
dc_find$dir_write               000000 constant        entry                    external dcl 3-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 3-31
dc_find$link_target             000000 constant        entry                    external dcl 3-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 3-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 3-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 3-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 3-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 3-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 3-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 3-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 3-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 3-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 3-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 3-51
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 3-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 3-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 3-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 3-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 3-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 3-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 3-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 3-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 3-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 3-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 3-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 3-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 3-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 3-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 3-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 3-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 3-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 3-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 3-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 3-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 3-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 3-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 3-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 3-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 3-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 3-95
dc_find$seg_fault               000000 constant        entry                    external dcl 3-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 9-14
dir_type                               internal static fixed bin(17,0)          initial dcl 9-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 9-19
link_type                              internal static fixed bin(17,0)          initial dcl 9-16
makeknown_infop                        automatic       pointer                  dcl 10-5
name_type                              internal static fixed bin(17,0)          initial dcl 9-17
seg_type                               internal static fixed bin(17,0)          initial dcl 9-18
version_number_2                       internal static fixed bin(17,0)          initial dcl 5-84

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000573 constant        label                    dcl 242 ref 212 222 232
delentry                        000135 constant        entry                    external dcl 14
dfile                           000303 constant        entry                    external dcl 202
dir_glop                        001110 constant        label                    dcl 306 ref 279 294
dseg                            000416 constant        entry                    external dcl 215
duid_mdir                       000530 constant        entry                    external dcl 234
duid_mdir_priv                  000460 constant        entry                    external dcl 224
finale                          002256 constant        label                    dcl 449 ref 257 262 266 273 290 303 321 327 342 365
name_loop                       001620 constant        label                    dcl 381 ref 398
priv_dfile                      000252 constant        entry                    external dcl 199
remove                          001576 constant        label                    dcl 374 ref 191 247
ret                             002436 constant        label                    dcl 466 set ref 211 221 229 239 315
retv                            000221 constant        entry                    external dcl 193
salv_delete_branch              000150 constant        entry                    external dcl 179
set_code                        000331 constant        label                    dcl 205 ref 196

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3274        3440    2441        3304
Length      4170    2441       144         514     632           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
delentry                            280 external procedure  is an external procedure.  
on unit on line 277                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
delentry                 000100 acl_count                   delentry
                         000102 aclep                       delentry
                         000104 areap                       delentry
                         000106 asize                       delentry
                         000107 audit_eventflags            delentry
                         000110 code                        delentry
                         000111 damaged                     delentry
                         000112 dirl                        delentry
                         000113 dirname                     delentry
                         000165 e_sw                        delentry
                         000166 ename                       delentry
                         000176 ignore                      delentry
                         000177 mk_info                     delentry
                         000202 mkunk_uid                   delentry
                         000203 ncnt                        delentry
                         000204 nnames                      delentry
                         000205 nrp                         delentry
                         000206 onp                         delentry
                         000210 priv_entry                  delentry
                         000211 pvid                        delentry
                         000212 qcell                       delentry
                         000222 ring                        delentry
                         000223 seg_uid                     delentry
                         000224 segl                        delentry
                         000225 segno                       delentry
                         000226 segptr                      delentry
                         000230 sp                          delentry
                         000232 trp                         delentry
                         000234 type                        delentry
                         000235 uidpath                     delentry
                         000255 vtocx                       delentry
                         000256 read_lock                   delentry
                         000274 ep                          delentry
                         000276 dp                          delentry
                         000300 np                          delentry
                         000302 qcp                         delentry

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           signal_op           enable_op
ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_name_$delete              access_audit_$log_entry_ptr   access_audit_check_ep_$self   acl_$del_acl
aim_check_$equal              dc_find$finished              dc_find$obj_delete            dc_find$obj_delete_priv
dc_find$obj_delete_priv_uid   dc_find$obj_delete_ptr        dc_find$obj_delete_uid        delete_vtoce
fs_alloc$free                 hash$out                      level$get                     lock$dir_lock_write
lock$dir_unlock               lock$dir_unlock_given_uid     makeknown_                    makeunknown_
mountedp                      pathname_am$clear             pathname_am$flush             sum$dirmod
syserr                        syserr$error_code             terminate_$id                 vtoc_attributes$get_quota

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$fs_obj_delete                            active_hardcore_data$ensize   active_hardcore_data$esize
error_table_$copy_sw_on       error_table_$dirseg           error_table_$fulldir          error_table_$infcnt_non_zero
error_table_$invalidsegno     error_table_$known_in_other_rings                           error_table_$lower_ring
error_table_$master_dir       error_table_$safety_sw_on     error_table_$seg_unknown      error_table_$segknown
error_table_$vtoce_connection_fail                          pds$access_authorization      pds$process_group_id
pds$processid




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     90 000122        91 000123        97 000124       102 000125       107 000126       109 000127       121 000131
     14 000134       179 000143       181 000161       182 000165       183 000167       184 000170       185 000171
    186 000173       187 000175       188 000176       189 000204       190 000212       191 000214       193 000215
    195 000245       196 000247       199 000250       200 000276       202 000300       203 000327       205 000331
    206 000332       207 000340       209 000345       210 000372       211 000411       212 000413       215 000414
    217 000427       218 000430       219 000432       220 000436       221 000451       222 000453       224 000454
    226 000471       227 000473       228 000500       229 000517       230 000521       231 000523       232 000525
    234 000526       236 000541       237 000543       238 000550       239 000567       240 000571       242 000573
    244 000575       245 000577       246 000603       247 000605       249 000606       250 000614       252 000616
    253 000623       254 000632       256 000653       257 000656       260 000657       261 000663       262 000666
    264 000667       265 000672       266 000675       270 000676       271 000701       272 000704       273 000707
    275 000710       276 000712       277 000714       278 000730       279 000733       281 000736       282 000741
    283 000743       284 000745       285 000747       286 000751       287 000753       288 000773       290 001005
    292 001011       293 001024       294 001025       296 001027       297 001032       299 001070       300 001072
    302 001073       303 001104       304 001106       306 001110       307 001111       308 001130       309 001154
    310 001173       311 001175       312 001201       313 001210       315 001231       317 001232       318 001234
    319 001236       320 001242       321 001245       323 001246       324 001250       326 001261       327 001264
    329 001265       333 001277       334 001302       336 001324       337 001325       338 001327       342 001431
    344 001432       345 001435       346 001437       347 001442       348 001444       349 001466       358 001473
    359 001475       360 001503       361 001515       362 001517       363 001530       365 001567       374 001576
    376 001601       377 001605       378 001613       379 001617       381 001620       383 001621       384 001627
    385 001633       388 001654       389 001674       392 001735       394 001744       395 001747       396 001750
    397 001753       398 001766       400 001767       401 001774       403 001776       404 002000       405 002002
    406 002006       408 002021       411 002027       412 002034       414 002036       416 002041       418 002051
    419 002054       420 002056       422 002057       423 002061       426 002065       428 002076       429 002105
    430 002114       431 002127       432 002135       433 002141       434 002151       435 002161       436 002166
    437 002170       438 002171       439 002204       440 002211       441 002225       442 002234       443 002243
    445 002244       446 002247       449 002256       451 002267       452 002271       453 002272       454 002311
    456 002320       457 002346       458 002350       459 002364       462 002377       465 002430       466 002436
    468 002440


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
