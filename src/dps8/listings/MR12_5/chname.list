	COMPILATION LISTING OF SEGMENT chname
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1048.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4 */
       14 chname: proc;
       15 
       16 /*	Last modified (Date and reasons):
       17*   by Keith Loepere to provide audit info and to change PAM to use uid's, November 1984.
       18*   by Keith Loepere to use the new dc_find, August 1984.
       19*   by BIM 1984 for sst reformat.
       20*   by E. N. Kittlitz, May 1983, search_ast$check.
       21*   by E. N. Kittlitz, March 1983, to not backup entry.dtem.
       22*   by Keith Loepere January 1983 so bad ring bracket error makes it to user.
       23*   by J. Bongiovanni to always flush pam on directory rename
       24*   by THVV for bad_dir_ check, 7/77
       25*   by D. Vinograd to add new entry retv for use by the volume retriever, 9/76
       26*   by S. Barr to use new hash table format, 9/76
       27*   by R. Bratt to call find_$finished, 06/01/76
       28*   by R. Bratt for pam flush, 2/3/76.
       29*   by BSG for NSS, 4/25/75.
       30*   by Bernard S. Greenberg for SST name table, Feb. 18, 1975.
       31*   by Richard H. Gumpertz 9 July 71 to interpret user not on acl as "null 7,7,7" when checking validation level
       32*   by Richard H Gumpertz on 8 July 71 to check brackets for >= validation level
       33**/
       34 
       35 cfile: entry (a_parent, a_ename, a_oldname, a_newname, a_code);
       36 
       37 /*
       38*   This proceedure to used to add, delete, and rename segments. It has two
       39*   entry points. The entry point cfile" takes a directory path name and entry name
       40*   to determine the segment affected while the entry point "cseg" uses a pointer.
       41*
       42*   USAGE:	call chname$cfile(directory_name, entry_name, old_name, new_name, error_code);
       43*
       44*   1. directory_name char(*)		path name of directory in which entry_name is an entry.
       45*
       46*   2. entry_name char(*)		entry name of segment to be changed.
       47*
       48*   3. old_name char(*)			name to be deleted from name list of entry_name.
       49*
       50*   4. new_name char(*)			name to be added to name list of entry_name.
       51*
       52*   5. error_code fixed bin(35)		file system error code (Output).
       53*
       54*   USAGE:	call chname$cseg(segment_pointer, old_name, new_name, error_code);
       55*
       56*   1. segment_pointer pointer		pointer to segment to be changed.
       57*
       58*   2. - 4. Same as above.
       59*
       60*
       61*   NOTE:	1. Caller must have write access with respect to the directory.
       62*
       63**/
       64 
       65 dcl  a_code fixed bin (35);
       66 dcl  a_ename char (*);
       67 dcl  a_ep ptr;
       68 dcl  a_newname char (*);
       69 dcl  a_oldname char (*);
       70 dcl  a_parent char (*);
       71 dcl  a_sp ptr;
       72 
       73 dcl  ep_known fixed bin static init (2) options (constant); ;
       74 dcl  file fixed bin static init (0) options (constant);
       75 dcl  seg fixed bin static init (1) options (constant); ;
       76 
       77 dcl  areap ptr;
       78 dcl  code fixed bin (35);
       79 dcl  ename char (32);
       80 dcl  entry_point fixed bin;
       81 dcl  just_delete_name bit (1) aligned;
       82 dcl  last_namep ptr;
       83 dcl  namecnt fixed bin (18);
       84 dcl  nep ptr;
       85 dcl  new_np ptr;
       86 dcl  newname char (32) aligned;
       87 dcl  newname_p ptr;
       88 dcl  next_np ptr;					/* ptr to next primary name before it is moved in */
       89 dcl  old_np ptr;
       90 dcl  oldname char (32) aligned;
       91 dcl  oldname_p ptr;
       92 dcl  parent char (168);
       93 dcl  pvid bit (36) aligned;
       94 dcl  save_fp bit (18);				/* save of old primary name forward thread */
       95 dcl  sp ptr;
       96 dcl  uid bit (36) aligned;
       97 dcl  vtocx fixed bin;
       98 
       99 dcl  active_hardcore_data$ensize fixed bin external;
      100 dcl  error_table_$bad_ring_brackets fixed bin (35) external;
      101 dcl  error_table_$namedup fixed bin (35) external;
      102 dcl  error_table_$noalloc fixed bin (35) external;
      103 dcl  error_table_$noentry fixed bin (35) external;
      104 dcl  error_table_$nonamerr fixed bin (35) external;
      105 dcl  error_table_$oldnamerr fixed bin (35) external;
      106 dcl  error_table_$segnamedup fixed bin (35) external;
      107 dcl  pds$processid bit (36) aligned ext;
      108 dcl  1 pds$transparent aligned ext,
      109        2 m bit (1) unaligned,
      110        2 u bit (1) unaligned;
      111 dcl  sst$ast_track bit (1) aligned external;
      112 
      113 dcl  change_dtem entry (ptr);
      114 dcl  fs_alloc$alloc entry (ptr, fixed bin, ptr);
      115 dcl  fs_alloc$free entry (ptr, fixed bin, ptr);
      116 dcl  hash$in entry (ptr, ptr, fixed bin (35));
      117 dcl  hash$out entry (ptr, ptr, ptr, fixed bin (35));
      118 dcl  hash$search entry (ptr, ptr, ptr, fixed bin (35));
      119 dcl  level$get entry returns (fixed bin);
      120 dcl  lock$dir_unlock entry (ptr);
      121 dcl  lock$lock_ast entry;
      122 dcl  lock$unlock_ast entry;
      123 dcl  pathname_am$flush entry (bit (36) aligned);
      124 dcl  search_ast$check entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (35)) returns (ptr);
      125 dcl  sum$dirmod entry (ptr);
      126 
      127 dcl  (addr, bin, bit, clock, divide, fixed, null, ptr, rel, rtrim) builtin;
      128 
      129 	entry_point = file;				/* entered via chname entry point */
      130 	parent = a_parent;
      131 	ename = a_ename;
      132 
      133 	go to common;
      134 
      135 cseg: entry (a_sp, a_oldname, a_newname, a_code);
      136 
      137 	entry_point = seg;				/* entered via chname$cseg entry point */
      138 	sp = a_sp;
      139 	goto common;
      140 
      141 retv: entry (a_ep, a_oldname, a_newname, a_code);
      142 
      143 	ep = a_ep;
      144 	dp = ptr (ep, 0);
      145 	entry_point = ep_known;
      146 
      147 common:
      148 	code = 0;
      149 	oldname = a_oldname;
      150 	newname = a_newname;
      151 
      152 	if newname = "" then just_delete_name = "1"b;	/* if no name is to be added, then just remove a name */
      153 	else just_delete_name = "0"b;			/* otherwise adding or replacing a name */
      154 
      155 	if entry_point ^= ep_known then do;
      156 	     if entry_point = file then call dc_find$obj_status_write (parent, ename, 0, FS_OBJ_RENAME, ep, code);
      157 	     else call dc_find$obj_status_write_ptr (sp, FS_OBJ_RENAME, ep, code);
      158 	     dp = ptr (ep, 0);
      159 	     if code ^= 0 then go to finale;
      160 
      161 	     if entry.bs then
      162 		if ^(entry.dirsw) then
      163 		     if fixed (entry.ring_brackets (1), 3) < (level$get ()) then do;
      164 			code = error_table_$bad_ring_brackets;
      165 			go to unlock;
      166 		     end; else ;
      167 		else if fixed (entry.ex_ring_brackets (1), 3) < (level$get ()) then do;
      168 		     code = error_table_$bad_ring_brackets;
      169 		     go to unlock;
      170 		end; else ;
      171 	end;
      172 
      173 	namecnt = fixed (entry.nnames, 18);
      174 
      175 	if namecnt = 1 then if just_delete_name		/* Will there be any names left after oldname is deleted */
      176 	     then do;				/* and no name is added */
      177 		code = error_table_$nonamerr;
      178 		go to unlock;
      179 	     end;
      180 
      181 	areap = ptr (dp, dir.arearp);
      182 
      183 	dir.modify = pds$processid;
      184 
      185 	if just_delete_name then go to delete_name;
      186 
      187 	newname_p = addr (newname);
      188 	call hash$search (dp, newname_p, nep, code);
      189 	if code = 0 then do;
      190 	     if ep = nep then code = error_table_$segnamedup;
      191 	     else code = error_table_$namedup;
      192 	     go to unlock;
      193 	end;
      194 	if code ^= error_table_$noentry then go to unlock;
      195 
      196 	call fs_alloc$alloc (areap, active_hardcore_data$ensize, new_np); /* allocate storage for newname */
      197 	if new_np = null then go to noalloc_err;
      198 
      199 	new_np -> names.name = newname;
      200 
      201 	new_np -> names.entry_rp = rel (ep);
      202 	new_np -> names.type = NAME_TYPE;
      203 	new_np -> names.size = active_hardcore_data$ensize;
      204 	new_np -> names.owner = entry.uid;
      205 
      206 	call hash$in (dp, new_np, code);
      207 	if code ^= 0 then go to hash_error;
      208 
      209 	last_namep = ptr (ep, entry.name_brp);
      210 	new_np -> names.bp = rel (last_namep);
      211 	last_namep -> names.fp = rel (new_np);
      212 	entry.name_brp = rel (new_np);
      213 	namecnt = namecnt + 1;			/* increase count of number of names for "entry" */
      214 
      215 
      216 delete_name: if oldname = "" then go to finish;
      217 
      218 	oldname_p = addr (oldname);
      219 	call hash$search (dp, oldname_p, nep, code);
      220 	if code ^= 0 then go to finish;		/* if name not in hash table (most probably) */
      221 	if ep ^= nep then go to name_err;		/* if name associated with another entry */
      222 
      223 	call hash$out (dp, oldname_p, old_np, code);	/* Hash "oldname" to find its place in the */
      224 	if code ^= 0 then do;			/* hash table and vacate this place. */
      225 name_err:	     code = error_table_$oldnamerr;
      226 	     go to finish;
      227 	end;
      228 
      229 	if old_np -> names.bp then do;		/* not primary name */
      230 	     ptr (old_np, old_np -> names.bp) -> names.fp = old_np -> names.fp;
      231 	     if old_np -> names.fp then ptr (old_np, old_np -> names.fp) -> names.bp = old_np -> names.bp;
      232 	     else entry.name_brp = old_np -> names.bp;
      233 	end;
      234 	else do;
      235 
      236 /* * The name entry for the primary name is stored in the entry structure.  If the name being deleted or changed
      237*   * was the primary name, then the new primary name must be moved into this area.  The steps are:
      238*   *	1. The new primary name is hashed out.
      239*   *	2. The new primary name is threaded out.
      240*   *	3. The contents of the new primary name are copied into the slot in the entry.
      241*   *	4. The new primary name in its new location is hashed in.
      242**/
      243 	     if just_delete_name then next_np = ptr (dp, old_np -> names.fp);
      244 	     else next_np = new_np;
      245 
      246 	     call hash$out (dp, addr (next_np -> names.name), next_np, code);
      247 	     if code ^= 0 then goto finish;
      248 
      249 /* Unthread new primary name. */
      250 
      251 	     if next_np -> names.fp = "0"b
      252 	     then entry.name_brp = next_np -> names.bp;	/* end of chain */
      253 	     else ptr (dp, next_np -> names.fp) -> names.bp = next_np -> names.bp;
      254 	     ptr (dp, next_np -> names.bp) -> names.fp = next_np -> names.fp;
      255 
      256 /* Copy new primary name into entry slot, but save old primary threads. */
      257 
      258 	     save_fp = old_np -> names.fp;
      259 	     old_np -> names = next_np -> names;
      260 	     old_np -> names.fp = save_fp;
      261 	     old_np -> names.bp = "0"b;
      262 
      263 	     call hash$in (dp, old_np, code);
      264 	     if code ^= 0 then goto finish;
      265 	     old_np = next_np;			/* set so space will be freed later */
      266 
      267 	     if entry.bs & sst$ast_track then do;	/* AST names */
      268 		uid = entry.uid;			/* Must extract info before locking AST */
      269 		pvid = entry.pvid;
      270 		vtocx = entry.vtocx;
      271 		temp_entry_name = newname;		/* This is the new name */
      272 		call lock$lock_ast;
      273 		nm_astep = search_ast$check (uid, pvid, vtocx, (0)); /* ignore code since it's just for name table */
      274 		if nm_astep ^= null then
      275 
  1     1 /* Begin include file make_sstnt_entry.incl.pl1 Bernard Greenberg 2/18/75 */
  1     2 /* Modified 84-01-08 BIM for sst$ versus sst. */
  1     3 
  1     4 	/* If the SST name table is enabled, fill in the name table slot. */
  1     5 
  1     6     begin; /* quick */
  1     7        declare sst$ast_track bit (1) aligned external static;
  1     8       
  1     9 	if sst$ast_track then do;
  1    10 
  1    11 	     sstnp = addr (sst_names_$);		/* Establish name seg addressability */
  1    12 	     ptsi_a= bin (nm_astep -> aste.ptsi, 2);	/* Pick up PT size index */
  1    13 	     sstnmx = sstnt.ast_name_offsets (ptsi_a)
  1    14 			+ divide (bin (rel (nm_astep), 18)
  1    15 				- sstnt.ast_offsets (ptsi_a),
  1    16 				sstnt.ast_sizes (ptsi_a), 17, 0);
  1    17 
  1    18 	     sstnp -> sstnt.names (sstnmx) = rtrim (temp_entry_name);
  1    19 
  1    20 	end;
  1    21       end;
  1    22 
  1    23        declare temp_entry_name char (32) aligned;
  1    24 
  1    25 /* End of include file make_sstnt_entry.incl.pl1 */
      276 
      277 		call lock$unlock_ast;
      278 	     end;
      279 	end;
      280 
      281 	namecnt = namecnt - 1;			/* decrease count of number of names for "entry" */
      282 
      283 	call fs_alloc$free (areap, active_hardcore_data$ensize, old_np); /* free storage for "oldname" */
      284 	if entry.dirsw
      285 	then call pathname_am$flush (entry.uid);
      286 
      287 
      288 finish:	entry.nnames = namecnt;
      289 	if ^pds$transparent.m then			/* is it ok to change date */
      290 	     if entry.dtem ^= bit (fixed (clock (), 52), 36) then /* if 'now', don't bother. we're not setfaulting */
      291 		call change_dtem (ep);		/* if old, brighten it up */
      292 	dir.modify = "0"b;
      293 	call sum$dirmod (dp);			/* Notify control that "parent" has been modified */
      294 	go to unlock1;
      295 
      296 /* Error handlers. */
      297 
      298 unlock:	dir.modify = "0"b;
      299 unlock1:	if entry_point ^= ep_known then do;
      300 	     if entry_point = file
      301 	     then call dc_find$finished (dp, "1"b);
      302 	     else call lock$dir_unlock (dp);
      303 	end;
      304 finale:	a_code = code;
      305 	return;
      306 
      307 hash_error:
      308 	call fs_alloc$free (areap, active_hardcore_data$ensize, new_np);
      309 	go to unlock;
      310 noalloc_err:
      311 	code = error_table_$noalloc;
      312 	go to unlock;
      313 
      314 /* format: off */
      315 
      316  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      316 
      317  /* BEGIN include file dc_find_dcls.incl.pl1 */
  3     2 
  3     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  3     4 /* Added a few more, October 1984. */
  3     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  3     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  3     7 
  3     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  3     9 
  3    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  3    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  3    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  3    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  3    14 
  3    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  3    18 
  3    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  3    20 
  3    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  3    22 
  3    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  3    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  3    25 
  3    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  3    27 
  3    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  3    29 
  3    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    32 
  3    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  3    34 
  3    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  3    36 
  3    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  3    38 
  3    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    41 
  3    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    44 
  3    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    47 
  3    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    52 
  3    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  3    58 
  3    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  3    60 
  3    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  3    62 
  3    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  3    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  3    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  3    66 
  3    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  3    68 
  3    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  3    70 
  3    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    72 
  3    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    74 
  3    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  3    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    82 
  3    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    87 
  3    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  3    90 
  3    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  3    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  3    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  3    94 
  3    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    96 
  3    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  3    98 
  3    99 /* END include file dc_find_dcls.incl.pl1 */
      317 
      318  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      318 
      319  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  5     2 /* Modified 8/74 for NSS */
  5     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  5     4 /* Modified 3/82 BIM for change pclock */
  5     5 /* format: style3 */
  5     6 
  5     7 /* Template for the directory header. Length = 64 words. */
  5     8 
  5     9 dcl  dp ptr;
  5    10 
  5    11 dcl 1 dir based (dp) aligned,
  5    12 
  5    13    2 modify bit (36),				/* Process ID of last modifier */
  5    14    2 type bit (18) unaligned,			/* type of object = dir header */
  5    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  5    16     2 dtc (3),					/* date-time checked by salvager array */
  5    17       3 date bit (36),				/* the date */
  5    18       3 error bit (36),				/* what errors were discovered */
  5    19 
  5    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  5    21 
  5    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  5    23 
  5    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  5    25 
  5    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  5    27 
  5    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  5    29     2 version_number fixed bin (17),			/* version number of header */
  5    30 
  5    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  5    32     2 pad2 bit (18),
  5    33 
  5    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  5    35     2 pad3 bit (18),
  5    36 
  5    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  5    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  5    39 
  5    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  5    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  5    42 
  5    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  5    44     2 dir_count fixed bin (17),			/* number of directory branches */
  5    45 
  5    46     2 lcount fixed bin (17),				/* number of links */
  5    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  5    48 
  5    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  5    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  5    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  5    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  5    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  5    54     2 pad4 bit (14),
  5    55 
  5    56     2 iacl_count (0:7),
  5    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  5    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  5    59 
  5    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  5    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  5    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  5    63 
  5    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  5    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  5    66 
  5    67     2 htsize fixed bin (17),				/* size of hash table */
  5    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  5    69 
  5    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  5    71     2 pad6 fixed bin (17),
  5    72 
  5    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  5    74     2 pad7 bit (18)) unaligned,
  5    75 
  5    76     2 dts bit (36),					/* date-time directory last salvaged */
  5    77 
  5    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  5    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  5    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  5    81     2 checksum bit (36),				/* checksummed from uid on */
  5    82     2 owner bit (36);				/* uid of parent dir */
  5    83 
  5    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  5    85 
  5    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      319 
      320  /*     BEGIN INCLUDE FILE ... dir_ht.incl.pl1 */
  6     2 
  6     3 
  6     4 dcl htp ptr;
  6     5 
  6     6 dcl 1 hash_table based (htp) aligned,			/* htp = ptr(dp,active_hardcore_data$htrp) */
  6     7     2 modify bit (36) unal,
  6     8     2 type bit (18) unal,				/* type = dir hash table */
  6     9     2 size fixed bin (17) unal,			/* size of current dir hash table entry */
  6    10     2 name_rp (0:1) bit(18) unal,			/* rel ptr of name entry  */
  6    11     2 checksum bit (36) unal,
  6    12     2 owner bit (36) unal;
  6    13 						/* otherwise rel ptr to name */
  6    14 
  6    15 /*     END INCLUDE FILE ... dir_ht.incl.pl1 */
      320 
      321  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  7     2 
  7     3 /* Template for names of branches or links. Length = 14 words. */
  7     4 
  7     5 dcl np ptr;
  7     6 
  7     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  7     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  7     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  7    10 
  7    11     2 type bit (18) unaligned,			/* type = dir name */
  7    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  7    13 
  7    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  7    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  7    16 
  7    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  7    18     2 pad3 bit (18) unal,
  7    19 
  7    20     2 name char(32) aligned,
  7    21 
  7    22     2 checksum bit (36),				/* checksum from entry_rp */
  7    23 
  7    24     2 owner bit (36);				/* uid of entry */
  7    25 
  7    26 
  7    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      321 
      322  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
  8     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  8     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
  8     8*                                                   END HISTORY COMMENTS */
  8     9 
  8    10 
  8    11 /* The possible events within the file system; access codes and
  8    12*   detailed operation codes.  October 1984, Keith Loepere. */
  8    13 
  8    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  8    15 
  8    16 /* Major file system operations. */
  8    17 
  8    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
  8    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
  8    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
  8    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
  8    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
  8    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
  8    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
  8    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
  8    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
  8    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
  8    28 
  8    29 /* Detailed operations. */
  8    30 
  8    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
  8    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
  8    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
  8    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
  8    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
  8    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
  8    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
  8    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
  8    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
  8    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
  8    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
  8    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
  8    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
  8    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
  8    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
  8    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
  8    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
  8    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
  8    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
  8    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
  8    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
  8    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
  8    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
  8    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
  8    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
  8    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
  8    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
  8    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
  8    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
  8    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
  8    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
  8    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
  8    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
  8    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
  8    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
  8    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
  8    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
  8    68 
  8    69 /* END include file fs_obj_access_codes.incl.pl1 */
      322 
      323  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  9     2 
  9     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  9     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  9     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  9     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  9     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  9     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  9     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  9    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  9    11 
  9    12 dcl  access_name_type fixed bin static options (constant) init (1);
  9    13 dcl  acle_type fixed bin static options (constant) init (2);
  9    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  9    15 dcl  dir_type fixed bin static options (constant) init (4);
  9    16 dcl  link_type fixed bin static options (constant) init (5);
  9    17 dcl  name_type fixed bin static options (constant) init (6);
  9    18 dcl  seg_type fixed bin static options (constant) init (7);
  9    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  9    20 
  9    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      323 
      324  /* Begin include file sstnt.incl.pl1   */
 10     2 
 10     3 /* Created 10/03/74 by Bernard Greenberg */
 10     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
 10     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
 10     6 
 10     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
 10     8 
 10     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
 10    10 
 10    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
 10    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
 10    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
 10    14     2 nentries fixed bin,				/* number of entries in the sstnt */
 10    15     2 pad1 (5) fixed bin,
 10    16 
 10    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
 10    18      ast_name_offsets,				/* Starting index for names at each level */
 10    19      ast_offsets,					/* Starting rel addr of each AST region */
 10    20      pad2) (0 : 3) fixed bin,
 10    21 
 10    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
 10    23 
 10    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
 10    25 
 10    26 dcl  nm_astep ptr;					/* astep to be used */
 10    27 
 10    28 /* End include file sstnt.incl.pl1 */
      324 
      325      end chname;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.4  chname.pl1                        >spec>install>1110>chname.pl1
276          1    07/11/84  0937.3  make_sstnt_entry.incl.pl1         >ldd>include>make_sstnt_entry.incl.pl1
316          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
317          3    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
318          4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
319          5    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
320          6    11/02/76  1414.6  dir_ht.incl.pl1                   >ldd>include>dir_ht.incl.pl1
321          7    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
322          8    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
323          9    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
324         10    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FS_OBJ_RENAME                   000000 constant        fixed bin(18,0)          initial unsigned dcl 8-37 set ref 156* 157*
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 9-8 ref 202
a_code                                 parameter       fixed bin(35,0)          dcl 65 set ref 35 135 141 304*
a_ename                                parameter       char                     packed unaligned dcl 66 ref 35 131
a_ep                                   parameter       pointer                  dcl 67 ref 141 143
a_newname                              parameter       char                     packed unaligned dcl 68 ref 35 135 141 150
a_oldname                              parameter       char                     packed unaligned dcl 69 ref 35 135 141 149
a_parent                               parameter       char                     packed unaligned dcl 70 ref 35 130
a_sp                                   parameter       pointer                  dcl 71 ref 135 138
active_hardcore_data$ensize     000010 external static fixed bin(17,0)          dcl 99 set ref 196* 203 283* 307*
addr                                                   builtin function         dcl 127 ref 187 218 246 246 1-11
areap                           000100 automatic       pointer                  dcl 77 set ref 181* 196* 283* 307*
arearp                   24            based           bit(18)                  level 2 packed packed unaligned dcl 5-11 ref 181
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 10-11 ref 1-13
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 10-11 ref 1-13
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 10-11 ref 1-13
aste                                   based           structure                level 1 dcl 2-11
bin                                                    builtin function         dcl 127 ref 1-12 1-13
bit                                                    builtin function         dcl 127 ref 289
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 7-7 set ref 210*
                                                                                  229 230 231* 231 232 251 253* 253 254 261*
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 161 267
change_dtem                     000036 constant        entry                    external dcl 113 ref 289
clock                                                  builtin function         dcl 127 ref 289
code                            000102 automatic       fixed bin(35,0)          dcl 78 set ref 147* 156* 157* 159 164* 168* 177*
                                                                                  188* 189 190* 191* 194 206* 207 219* 220 223* 224
                                                                                  225* 246* 247 263* 264 304 310*
dc_find$finished                000070 constant        entry                    external dcl 3-33 ref 300
dc_find$obj_status_write        000072 constant        entry                    external dcl 3-83 ref 156
dc_find$obj_status_write_ptr    000074 constant        entry                    external dcl 3-86 ref 157
dir                                    based           structure                level 1 dcl 5-11
dirsw                    32            based           bit(1)                   level 2 packed packed unaligned dcl 4-8 ref 161 284
divide                                                 builtin function         dcl 127 ref 1-13
dp                              000250 automatic       pointer                  dcl 5-9 set ref 144* 158* 181 181 183 188* 206* 219*
                                                                                  223* 243 246* 253 254 263* 292 293* 298 300* 302*
dtem                      3            based           bit(36)                  level 2 dcl 4-8 ref 289
ename                           000103 automatic       char(32)                 packed unaligned dcl 79 set ref 131* 156*
entry                                  based           structure                level 1 dcl 4-8
entry_point                     000113 automatic       fixed bin(17,0)          dcl 80 set ref 129* 137* 145* 155 156 299 300
entry_rp                  2            based           bit(18)                  level 2 packed packed unaligned dcl 7-7 set ref 201*
ep                              000246 automatic       pointer                  dcl 4-6 set ref 143* 144 156* 157* 158 161 161 161
                                                                                  167 173 190 201 204 209 209 212 221 232 251 267
                                                                                  268 269 270 284 284 288 289 289*
ep_known                               constant        fixed bin(17,0)          initial dcl 73 ref 145 155 299
error_table_$bad_ring_brackets  000012 external static fixed bin(35,0)          dcl 100 ref 164 168
error_table_$namedup            000014 external static fixed bin(35,0)          dcl 101 ref 191
error_table_$noalloc            000016 external static fixed bin(35,0)          dcl 102 ref 310
error_table_$noentry            000020 external static fixed bin(35,0)          dcl 103 ref 194
error_table_$nonamerr           000022 external static fixed bin(35,0)          dcl 104 ref 177
error_table_$oldnamerr          000024 external static fixed bin(35,0)          dcl 105 ref 225
error_table_$segnamedup         000026 external static fixed bin(35,0)          dcl 106 ref 190
ex_ring_brackets         35(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 4-8 ref
                                                                                  167
file                                   constant        fixed bin(17,0)          initial dcl 74 ref 129 156 300
fixed                                                  builtin function         dcl 127 ref 161 167 173 289
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 7-7 set ref 211*
                                                                                  230* 230 231 231 243 251 253 254* 254 258 260*
fs_alloc$alloc                  000040 constant        entry                    external dcl 114 ref 196
fs_alloc$free                   000042 constant        entry                    external dcl 115 ref 283 307
hash$in                         000044 constant        entry                    external dcl 116 ref 206 263
hash$out                        000046 constant        entry                    external dcl 117 ref 223 246
hash$search                     000050 constant        entry                    external dcl 118 ref 188 219
just_delete_name                000114 automatic       bit(1)                   dcl 81 set ref 152* 153* 175 185 243
last_namep                      000116 automatic       pointer                  dcl 82 set ref 209* 210 211
level$get                       000052 constant        entry                    external dcl 119 ref 161 167
lock$dir_unlock                 000054 constant        entry                    external dcl 120 ref 302
lock$lock_ast                   000056 constant        entry                    external dcl 121 ref 272
lock$unlock_ast                 000060 constant        entry                    external dcl 122 ref 277
m                               000032 external static bit(1)                   level 2 packed packed unaligned dcl 108 ref 289
modify                                 based           bit(36)                  level 2 dcl 5-11 set ref 183* 292* 298*
name                      4            based           char(32)                 level 2 dcl 7-7 set ref 199* 246 246
name_brp                  5(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-8 set ref 209
                                                                                  212* 232* 251*
namecnt                         000120 automatic       fixed bin(18,0)          dcl 83 set ref 173* 175 213* 213 281* 281 288
names                    30            based           varying char(32)         array level 2 in structure "sstnt" dcl 10-11
                                                                                  in procedure "chname" set ref 1-18*
names                                  based           structure                level 1 dcl 7-7 in procedure "chname" set ref 259*
                                                                                  259
nep                             000122 automatic       pointer                  dcl 84 set ref 188* 190 219* 221
new_np                          000124 automatic       pointer                  dcl 85 set ref 196* 197 199 201 202 203 204 206* 210
                                                                                  211 212 244 307*
newname                         000126 automatic       char(32)                 dcl 86 set ref 150* 152 187 199 271
newname_p                       000136 automatic       pointer                  dcl 87 set ref 187* 188*
next_np                         000140 automatic       pointer                  dcl 88 set ref 243* 244* 246 246 246* 251 251 253
                                                                                  253 254 254 259 265
nm_astep                        000256 automatic       pointer                  dcl 10-26 set ref 273* 274 1-12 1-13
nnames                    4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-8 set ref 173
                                                                                  288*
null                                                   builtin function         dcl 127 ref 197 274
old_np                          000142 automatic       pointer                  dcl 89 set ref 223* 229 230 230 230 231 231 231 231
                                                                                  232 243 258 259 260 261 263* 265* 283*
oldname                         000144 automatic       char(32)                 dcl 90 set ref 149* 216 218
oldname_p                       000154 automatic       pointer                  dcl 91 set ref 218* 219* 223*
owner                    15            based           bit(36)                  level 2 dcl 7-7 set ref 204*
parent                          000156 automatic       char(168)                packed unaligned dcl 92 set ref 130* 156*
pathname_am$flush               000062 constant        entry                    external dcl 123 ref 284
pds$processid                   000030 external static bit(36)                  dcl 107 ref 183
pds$transparent                 000032 external static structure                level 1 dcl 108
ptr                                                    builtin function         dcl 127 ref 144 158 181 209 230 231 243 253 254
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 2-11 ref 1-12
ptsi_a                          000255 automatic       fixed bin(17,0)          dcl 10-24 set ref 1-12* 1-13 1-13 1-13
pvid                            000230 automatic       bit(36)                  dcl 93 in procedure "chname" set ref 269* 273*
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "chname" ref 269
rel                                                    builtin function         dcl 127 ref 201 210 211 212 1-13
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 4-8 ref
                                                                                  161
rtrim                                                  builtin function         dcl 127 ref 1-18
save_fp                         000231 automatic       bit(18)                  packed unaligned dcl 94 set ref 258* 260
search_ast$check                000064 constant        entry                    external dcl 124 ref 273
seg                                    constant        fixed bin(17,0)          initial dcl 75 ref 137
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-7 set ref 203*
sp                              000232 automatic       pointer                  dcl 95 set ref 138* 157*
sst$ast_track                   000100 external static bit(1)                   dcl 1-7 in begin block on line 274 ref 1-9
sst$ast_track                   000034 external static bit(1)                   dcl 111 in procedure "chname" ref 267
sst_names_$                     000076 external static fixed bin(17,0)          dcl 10-7 set ref 1-11
sstnmx                          000254 automatic       fixed bin(17,0)          dcl 10-24 set ref 1-13* 1-18
sstnp                           000252 automatic       pointer                  dcl 10-9 set ref 1-11* 1-13 1-13 1-13 1-18
sstnt                                  based           structure                level 1 dcl 10-11
sum$dirmod                      000066 constant        entry                    external dcl 125 ref 293
temp_entry_name                 000236 automatic       char(32)                 dcl 1-23 set ref 271* 1-18
type                      1            based           bit(18)                  level 2 packed packed unaligned dcl 7-7 set ref 202*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "chname" set ref 204 268 284*
uid                             000234 automatic       bit(36)                  dcl 96 in procedure "chname" set ref 268* 273*
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "chname" ref 270
vtocx                           000235 automatic       fixed bin(17,0)          dcl 97 in procedure "chname" set ref 270* 273*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 9-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 9-4
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 3-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 3-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 3-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 3-13
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 9-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 9-6
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 8-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 8-36
FS_OBJ_AUDIT_FLAG_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-67
FS_OBJ_AUTHOR_MOD                      internal static fixed bin(18,0)          initial unsigned dcl 8-46
FS_OBJ_BACKUP_TIMES_MOD                internal static fixed bin(18,0)          initial unsigned dcl 8-48
FS_OBJ_BC_AUTHOR_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-47
FS_OBJ_BC_MOD                          internal static fixed bin(18,0)          initial unsigned dcl 8-32
FS_OBJ_CONNECT                         internal static fixed bin(18,0)          initial unsigned dcl 8-31
FS_OBJ_COPY_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-38
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 8-55
FS_OBJ_CREATE_BRANCH                   internal static fixed bin(18,0)          initial unsigned dcl 8-66
FS_OBJ_DAMAGED_SW_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-39
FS_OBJ_DATES_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 8-49
FS_OBJ_DIR_SALVAGE                     internal static fixed bin(18,0)          initial unsigned dcl 8-56
FS_OBJ_DNZP_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-40
FS_OBJ_DT_DUMPED_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-50
FS_OBJ_ENTRY_BOUND_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 8-41
FS_OBJ_FOR_RELOADER_MOD                internal static fixed bin(18,0)          initial unsigned dcl 8-51
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-65
FS_OBJ_MAX_LEN_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-42
FS_OBJ_MDIR_QUOTA_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 8-57
FS_OBJ_MOVE_QUOTA                      internal static fixed bin(18,0)          initial unsigned dcl 8-54
FS_OBJ_QUOTA_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 8-58
FS_OBJ_QUOTA_RELOAD                    internal static fixed bin(18,0)          initial unsigned dcl 8-59
FS_OBJ_RECLASSIFY                      internal static fixed bin(18,0)          initial unsigned dcl 8-60
FS_OBJ_RECLASSIFY_NODE                 internal static fixed bin(18,0)          initial unsigned dcl 8-61
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-35
FS_OBJ_SAFETY_SW_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-43
FS_OBJ_SEG_MOVE                        internal static fixed bin(18,0)          initial unsigned dcl 8-62
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 8-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 8-53
FS_OBJ_SYNC_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 8-44
FS_OBJ_TRP_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 8-63
FS_OBJ_TRUNCATE                        internal static fixed bin(18,0)          initial unsigned dcl 8-33
FS_OBJ_VOLUME_RETRIEVE                 internal static fixed bin(18,0)          initial unsigned dcl 8-64
FS_OBJ_VOL_DUMP_SW_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 8-45
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 9-10
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 9-7
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 9-9
access_name_type                       internal static fixed bin(17,0)          initial dcl 9-12
access_operations_$fs_obj_access_mod   external static bit(36)                  dcl 8-27
access_operations_$fs_obj_attr_mod     external static bit(36)                  dcl 8-25
access_operations_$fs_obj_contents_mod external static bit(36)                  dcl 8-23
access_operations_$fs_obj_contents_read
                                       external static bit(36)                  dcl 8-22
access_operations_$fs_obj_create       external static bit(36)                  dcl 8-18
access_operations_$fs_obj_delete       external static bit(36)                  dcl 8-19
access_operations_$fs_obj_initiate     external static bit(36)                  dcl 8-20
access_operations_$fs_obj_prop_read    external static bit(36)                  dcl 8-24
access_operations_$fs_obj_status_mod   external static bit(36)                  dcl 8-26
access_operations_$fs_obj_terminate    external static bit(36)                  dcl 8-21
acle_type                              internal static fixed bin(17,0)          initial dcl 9-13
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
astep                                  automatic       pointer                  dcl 2-9
dc_find$dir_for_append          000000 constant        entry                    external dcl 3-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 3-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 3-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 3-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 3-21
dc_find$dir_read                000000 constant        entry                    external dcl 3-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 3-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 3-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 3-28
dc_find$dir_write               000000 constant        entry                    external dcl 3-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 3-31
dc_find$link_target             000000 constant        entry                    external dcl 3-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 3-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 3-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 3-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 3-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 3-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 3-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 3-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 3-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 3-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 3-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 3-51
dc_find$obj_delete              000000 constant        entry                    external dcl 3-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 3-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 3-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 3-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 3-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 3-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 3-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 3-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 3-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 3-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 3-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 3-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 3-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 3-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 3-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 3-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 3-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 3-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 3-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 3-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 3-76
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 3-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 3-85
dc_find$obj_terminate           000000 constant        entry                    external dcl 3-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 3-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 3-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 3-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 3-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 3-95
dc_find$seg_fault               000000 constant        entry                    external dcl 3-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 9-14
dir_type                               internal static fixed bin(17,0)          initial dcl 9-15
hash_table                             based           structure                level 1 dcl 6-6
hash_table_type                        internal static fixed bin(17,0)          initial dcl 9-19
htp                                    automatic       pointer                  dcl 6-4
link_type                              internal static fixed bin(17,0)          initial dcl 9-16
name_type                              internal static fixed bin(17,0)          initial dcl 9-17
np                                     automatic       pointer                  dcl 7-5
seg_aste                               based           structure                level 1 dcl 2-96
seg_type                               internal static fixed bin(17,0)          initial dcl 9-18
version_number_2                       internal static fixed bin(17,0)          initial dcl 5-84

NAMES DECLARED BY EXPLICIT CONTEXT.
cfile                           000024 constant        entry                    external dcl 35
chname                          000011 constant        entry                    external dcl 14
common                          000165 constant        label                    dcl 147 ref 133 139
cseg                            000102 constant        entry                    external dcl 135
delete_name                     000517 constant        label                    dcl 216 ref 185
finale                          001172 constant        label                    dcl 304 ref 159
finish                          001102 constant        label                    dcl 288 set ref 216 220 226 247 264
hash_error                      001175 constant        label                    dcl 307 set ref 207
name_err                        000567 constant        label                    dcl 225 ref 221
noalloc_err                     001211 constant        label                    dcl 310 set ref 197
retv                            000134 constant        entry                    external dcl 141
unlock                          001141 constant        label                    dcl 298 ref 165 169 178 192 194 309 312
unlock1                         001142 constant        label                    dcl 299 ref 294

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1560        1662    1215        1570
Length      2302    1215       102         403     342           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
chname                              208 external procedure  is an external procedure.  
begin block on line 274                 begin block         shares stack frame of external procedure chname.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
chname                   000100 areap                       chname
                         000102 code                        chname
                         000103 ename                       chname
                         000113 entry_point                 chname
                         000114 just_delete_name            chname
                         000116 last_namep                  chname
                         000120 namecnt                     chname
                         000122 nep                         chname
                         000124 new_np                      chname
                         000126 newname                     chname
                         000136 newname_p                   chname
                         000140 next_np                     chname
                         000142 old_np                      chname
                         000144 oldname                     chname
                         000154 oldname_p                   chname
                         000156 parent                      chname
                         000230 pvid                        chname
                         000231 save_fp                     chname
                         000232 sp                          chname
                         000234 uid                         chname
                         000235 vtocx                       chname
                         000236 temp_entry_name             chname
                         000246 ep                          chname
                         000250 dp                          chname
                         000252 sstnp                       chname
                         000254 sstnmx                      chname
                         000255 ptsi_a                      chname
                         000256 nm_astep                    chname

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           ext_entry_desc      clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
change_dtem                   dc_find$finished              dc_find$obj_status_write      dc_find$obj_status_write_ptr
fs_alloc$alloc                fs_alloc$free                 hash$in                       hash$out
hash$search                   level$get                     lock$dir_unlock               lock$lock_ast
lock$unlock_ast               pathname_am$flush             search_ast$check              sum$dirmod

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_hardcore_data$ensize   error_table_$bad_ring_brackets                              error_table_$namedup
error_table_$noalloc          error_table_$noentry          error_table_$nonamerr         error_table_$oldnamerr
error_table_$segnamedup       pds$processid                 pds$transparent               sst$ast_track
sst$ast_track                 sst_names_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000010        35 000016       129 000057       130 000061       131 000067       133 000074       135 000075
    137 000123       138 000125       139 000131       141 000132       143 000155       144 000161       145 000163
    147 000165       149 000166       150 000176       152 000206       153 000215       155 000216       156 000221
    157 000246       158 000263       159 000265       161 000267       164 000312       165 000315       166 000316
    167 000317       168 000334       169 000337       173 000340       175 000345       177 000351       178 000354
    181 000355       183 000363       185 000366       187 000370       188 000372       189 000406       190 000410
    191 000420       192 000423       194 000424       196 000427       197 000441       199 000445       201 000451
    202 000453       203 000455       204 000460       206 000463       207 000475       209 000477       210 000505
    211 000511       212 000513       213 000516       216 000517       218 000523       219 000525       220 000542
    221 000544       223 000550       224 000565       225 000567       226 000572       229 000573       230 000577
    231 000603       232 000614       233 000617       243 000620       244 000630       246 000632       247 000652
    251 000654       253 000664       254 000670       258 000676       259 000701       260 000706       261 000707
    263 000711       264 000724       265 000726       267 000730       268 000737       269 000741       270 000743
    271 000746       272 000751       273 000755       274 000775    1    9 001001    1   11 001004    1   12 001006
 1   13 001013    1   18 001022       277 001045       281 001052       283 001054       284 001067       288 001102
    289 001105       292 001130       293 001131       294 001140       298 001141       299 001142       300 001145
    302 001163       304 001172       305 001174       307 001175       309 001210       310 001211       312 001214


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
