	COMPILATION LISTING OF SEGMENT pc
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1026.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* format: style2,indcomtxt */
        9 /* use: pl1_macro pc.pl1.pmac  -target l68 */
       10 pc:
       11      procedure;
       12 
       13 /* *	PC -- the utility procedure of pl1 page control.
       14*   *
       15*   *	Last modified (date and reason):
       16*   *
       17*   *      1985-03-28, BIM: assume that all modified pages of synch segments
       18*   *		  are synch held until proven otherwise by page$pwrite.
       19*   *	841220 by Keith Loepere to count dirs pages against its own quota.
       20*   *	840623 by Keith Loepere for nullify entry for bce.
       21*   *	840417 E. A. Ranzenbach to correct page_read zero event problem that caused crashes in the segment mover.
       22*   *      84-01-19 BIM to remove unworkable synch segmove support.
       23*   *      84-01-03 BIM to finish segmove.
       24*   *	831219 by E. N. Kittlitz, for segmove
       25*   *      09/19/83 by E. N. Kittlitz, per UofC SGH, periodically unlock PTL during long flushes.
       26*   *      08/22/83 by E. N. Kittlitz, per UofC GM&SGH, don't hedge-write per-process pages.
       27*   *      10/27/82 by J. Bongiovanni to reset damaged, fm_damaged on truncate
       28*   *               and for synchronized pages
       29*   *      08/17/82 by J. Bongiovanni for scavenger
       30*   *      06/09/82 by J. Bongiovanni to fix shutdown quota problem
       31*   *      03/07/82 by J. Bongiovanni for record stocks
       32*   *      01/23/82 by BIM for truncate_count
       33*   *	12/29/81 by C. Hornig to remove Page Multilevel and fix fencepost error in flush.
       34*   *	08/11/81 by W. Olin Sibert, to fix get_file_map to not report nulled addresses as modified.
       35*   *	   This fix actually provided by Steve Harris, University of Calgary
       36*   *	02/20/81 by W. Olin Sibert, to conditionalize page-multilevel (phase one of ADP conversion)
       37*   *	11/17/80 by ENK for new dtu/dtm calculation
       38*   *	11/06/80 by ENK for loop_up_fms honouring of aste.gtms.
       39*   *	03/16/78 by BSG for phm1, incore null non-reportage.
       40*   *	08/01/77 by Greenberg for badd_types, pc_recover_sst.
       41*   *	05/03/77 by BSG for page$pcleanup
       42*   *	01/27/77 by TVV for non-fatal unprotected addresses
       43*   *	11/01/76 by D. Vinograd to add entry for volume dumper which returns special null addresses
       44*   *	   and does not deposit.
       45*   *	10/31/76 by BSG for truncate_deposit_all entry
       46*   *	05/13/76 by BSG for seg-by-seg PD flush.
       47*   *	04/13/76 by REM for Cleanup Metering
       48*   *	10/11/75 by BSG for fault_time_withdraws
       49*   *	03/04/75 by BSG for new storage system (incl. no pdht).
       50*   *	12/11/74 by BSG for new CME/PTW protocols and new core control.
       51*   *	06/19/74 by BSG for page$pwait and page$cam.
       52*   *	08/21/73 by RBS to put in checks for reused addresses.
       53*   *	08/03/73 by RBS to cause pc$flush to index thru cmes rather than follow threads.
       54*   *	08/10/73 by SHW to use 18 bit device addresses
       55*   *	07/15/73 by RBS to cause pages that are in core to be written to disk by pd_flush_all
       56*   *	10/04/72 by RBS to make page waits go to device control to accomodate bulk store logic
       57*   *	06/06/72 by RBS to modify for follow-on
       58*   *	10/26/71 by RHG to fix move_page_table for pages which are in core when moved
       59*   *	10/07/71 by SHW to add ptwp to pdme (increase entry size to 3 words)
       60*   *	10/05/71 by RHG to initialize pdmap and to skip the first sst.nrecs_pdmap entries in pd_flush_all
       61*   *	09/22/71 by RHG to make null devadds include a ptr for page
       62*   *	09/20/71 by RHG to fix bug in pc$get_file_map which lost all pages of file except first at deactivation
       63*   *	09/03/71 by Steve Webber to make calls to page$withdraw be fixed bin(4), not bit(4)
       64*   *	08/10/71 by Richard H. Gumpertz to add code for page multi-level
       65**/
       66 
       67 	dcl     Astep		 ptr parameter;
       68 	dcl     Copy_Astep		 ptr parameter;
       69 	dcl     File_Mapp		 ptr parameter;
       70 	dcl     Listp		 ptr parameter;
       71 	dcl     Pageno_Listp	 ptr parameter;
       72 	dcl     Deposit_Count	 fixed bin parameter;
       73 	dcl     First_Page		 fixed bin parameter;
       74 	dcl     Last_Page		 fixed bin parameter;
       75 	dcl     N_Pages		 fixed bin parameter;
       76 	dcl     N_In_Core		 fixed bin parameter;
       77 	dcl     Records		 fixed bin parameter;
       78 	dcl     Pvtx		 fixed bin parameter;
       79 	dcl     Vtocx		 fixed bin parameter;
       80 	dcl     Move_Astep		 pointer parameter;
       81 	dcl     Old_Astep		 ptr parameter;
       82 	dcl     New_Astep		 ptr parameter;
       83 	dcl     Code		 fixed bin (35) parameter;
       84 	dcl     New_Vtocx		 fixed bin (17) parameter;
       85 	dcl     New_Pvtx		 fixed bin (17);
       86 
       87 	dcl     (records, first_page, last_page, i)
       88 				 fixed bin;
       89 	dcl     ind		 fixed bin (35);
       90 	dcl     temp_ind		 fixed bin (35);
       91 	dcl     pvtx		 fixed bin;
       92 	dcl     dumper		 bit (1);
       93 	dcl     return_pageno	 bit (1) aligned;
       94 	dcl     add_to_dmpr_map	 bit (1);
       95 	dcl     (getfmap_csl, getfmap_np, getfmap_nrec)
       96 				 fixed bin (9);
       97 	dcl     offed_sw		 bit (1);
       98 	dcl     j			 fixed bin;
       99 	dcl     segmove_records_used	 fixed bin;
      100 	dcl     (cmp, ptwp)		 ptr;
      101 	dcl     curtime		 fixed bin (71);
      102 	dcl     n_in_core		 fixed bin (18);
      103 	dcl     n_io_started	 fixed bin;
      104 	dcl     pageno		 fixed bin;
      105 	dcl     (from_core, count)	 bit (1);
      106 	dcl     (old_astep, new_astep, old_ptp, new_ptp, move_ptp)
      107 				 ptr;
      108 	dcl     oldmask		 fixed bin (71);
      109 	dcl     no_deposit_no_return	 bit (1) aligned;
      110 	dcl     tr_count_sw		 bit (1) aligned;
      111 	dcl     segmove_records_needed fixed bin;
      112 	dcl     segmove_records_in_hand
      113 				 fixed bin;
      114 	dcl     segmove_total_records	 fixed bin;
      115 	dcl     code		 fixed bin (35);
      116 	dcl     new_pvtx		 fixed bin;
      117 	dcl     new_vtocx		 fixed bin;
      118 	dcl     move_tries		 fixed bin;
      119 
      120 	dcl     1 copy_aste		 like aste aligned;
      121 
      122 	dcl     fword		 (0:99) fixed bin based;
      123 
      124 	dcl     Address_Array	 (0:255) bit (22) aligned based (Listp);
      125 	dcl     (deposit_list, segmove_deposit_list)
      126 				 (0:255) bit (22) aligned;
      127 	dcl     rfm		 (0:255) bit (22) aligned;
      128 	dcl     1 Devadd_Array	 (0:255) aligned based (Listp),
      129 		2 record_no	 bit (18) unaligned,
      130 		2 add_type	 bit (4) unaligned;
      131 	dcl     Pageno_List		 (0:255) fixed bin aligned based (Pageno_Listp);
      132 	dcl     pageno_list		 (0:255) fixed bin aligned;
      133 
      134 	dcl     devadd		 bit (22) unaligned;
      135 	dcl     devadd_record_no	 bit (18) unaligned defined (devadd);
      136 	dcl     devadd_record_no_proper
      137 				 bit (17) defined (devadd) pos (2);
      138 	dcl     devadd_add_type	 bit (4) unaligned defined (devadd) position (19);
      139 	dcl     devadd_null_flag	 bit (1) defined (devadd) position (1);
      140 
      141 
      142 	dcl     1 devadd_bits	 unal based (addr (devadd_add_type)) like badd_type;
      143 
      144 
      145 	dcl     cleanup_start_time	 fixed bin (71);	/* Cleanup Metering */
      146 
      147 	dcl     error_table_$bad_arg	 fixed bin (35) ext static;
      148 	dcl     error_table_$action_not_performed
      149 				 fixed bin (35) ext static;
      150 	dcl     error_table_$synch_seg_segmove
      151 				 fixed bin (35) external static;
      152 	dcl     dbm_man$set_incr	 entry (fixed bin, fixed bin, fixed bin (35));
      153 	dcl     (
      154 	        lock$lock_fast,
      155 	        lock$unlock_fast
      156 	        )			 entry (pointer);
      157 	dcl     page$cam		 ext entry;
      158 	dcl     page$deposit_list	 entry (fixed bin, ptr, fixed bin, fixed bin, fixed bin, ptr);
      159 	dcl     page$pcleanup	 entry (ptr, fixed bin);
      160 	dcl     page$pread		 entry (ptr, fixed bin, fixed bin (35));
      161 	dcl     page$pwait		 ext entry (fixed bin (35));
      162 	dcl     page$pwrite		 ext entry (ptr, fixed bin);
      163 	dcl     page$withdraw_list	 entry (fixed bin, ptr, fixed bin, fixed bin, fixed bin (35), fixed bin (35));
      164 	dcl     pmut$lock_ptl	 ext entry (fixed bin (71), ptr);
      165 	dcl     pmut$unlock_ptl	 ext entry (fixed bin (71), ptr);
      166 	dcl     pxss$notify		 ext entry (fixed bin);
      167 	dcl     pxss$relinquish_priority
      168 				 ext entry;
      169 	dcl     quotaw$cu_for_pc	 entry (ptr, fixed bin, bit (1) aligned);
      170 	dcl     syserr		 ext entry options (variable);
      171 	dcl     trace		 ext entry options (variable);
      172 
      173 	dcl     null_devadd_not_in_core
      174 				 bit (36) aligned internal static options (constant) init ("000000000001"b3);
      175 	dcl     line_of_words	 char (23) internal static options (constant) init ("^w ^w ^w ^w ^w ^w ^w ^w");
      176 	dcl     half_line_of_words	 char (11) defined (line_of_words);
      177 
      178 	dcl     (addr, addrel, addwordno, bit, clock, divide, fixed, max, min, null, ptr, rel, size, unspec, wordno)
      179 				 builtin;
      180 
      181 cleanup:
      182      entry (Astep);					/* Entry to get segment out of core. */
      183 						/* Caller guarantees no access to segment */
      184 
      185 /* Note that synchronized pages which are modified and cannot be written yet
      186*   are left in memory. If this happens during shutdown, it is fine. Otherwise,
      187*   the caller must detect this situation and handle it appropriately. It
      188*   can be detected by checking that aste.np is non-zero. */
      189 
      190 	sstp = addr (sst_seg$);
      191 	astep = Astep;
      192 	cmp = sst.cmp;				/* get a pointer to the core map */
      193 	cleanup_start_time = clock ();		/* Cleanup Metering */
      194 
      195 	sst.cleanup_count = sst.cleanup_count + 1;	/* Cleanup Metering */
      196 	call pmut$lock_ptl (oldmask, ptwp);		/* mask */
      197 	records = 0;
      198 	if pc_trace
      199 	then call trace ("cleanup^-^-astep = ^p", astep);
      200 loopc:
      201 	ptp = addrel (astep, sst.astsize);		/* get a pointer to the page table */
      202 	ind = -1;					/* index of page to wait on */
      203 	do i = 0 to sst.pts (fixed (aste.ptsi, 2)) - 1;	/* loop over all pages in the segment */
      204 	     if atptw.core
      205 	     then do;				/* In core, includes all O/S */
      206 
      207 		     if ^ptw.os
      208 		     then do;			/* Not out of service */
      209 			     if ^(ptw.phm | ptw.phm1)
      210 			     then /* Attempt to clean up the page */
      211 				call page$pcleanup (astep, i);
      212 						/* Do it, cam the cache */
      213 						/* He turns off PTW access, SDW'S gone, so no race. */
      214 			     else call page$pwrite (astep, i);
      215 						/* Start a write */
      216 			end;
      217 
      218 		     if ptw.os
      219 		     then ind = fixed (rel (ptp), 18);	/* Set wait event */
      220 
      221 		end;
      222 
      223 	     ptp = addrel (ptp, size (ptw));		/* Next ptw, please */
      224 	end;
      225 
      226 	if ind > 0
      227 	then call wait_then_go_to (loopc);
      228 
      229 	sst.cleanup_real_time = sst.cleanup_real_time /* Cleanup Metering */ + clock () - cleanup_start_time;
      230 						/* Cleanup Metering */
      231 
      232 quit:
      233 	call pmut$unlock_ptl (oldmask, ptwp);		/* unlock and unmask */
      234 	return;
      235 
      236 nullify:
      237      entry (Astep);					/* Entry to nullify a bce/hardcore segment.
      238*						   Part of disk optimization for bce. */
      239 
      240 /* The idea is to mark the pages of the segment unmodified, clean them up
      241*   (to disk) and then mark the disk addresses as null.  This is done just to
      242*   optimize the later filling in of this segment.  We don't guarantee perfection
      243*   in this, but it doesn't matter.  Anyone who calls this ensures that the
      244*   segment is not in use so we don't expect a problem with pages being
      245*   referenced between ptl lockings. */
      246 
      247 /* First unmodify the pages.  Note that os pages are not affected, but these
      248*   either aren't yet modified (being read) or will become unmodified (after
      249*   write). */
      250 
      251 	sstp = addr (sst_seg$);
      252 	astep = Astep;
      253 
      254 	call pmut$lock_ptl (oldmask, ptwp);		/* mask */
      255 	ptp = addrel (astep, sst.astsize);		/* get a pointer to the page table */
      256 	do i = 0 to sst.pts (fixed (aste.ptsi, 2)) - 1;	/* loop over all pages in the segment */
      257 	     if atptw.core
      258 	     then /* In core, includes all O/S */
      259 		if ^ptw.os			/* Not out of service */
      260 		then ptw.phm, ptw.phm1 = "0"b;
      261 
      262 	     ptp = addrel (ptp, size (ptw));		/* Next ptw, please */
      263 	end;
      264 	call pmut$unlock_ptl (oldmask, ptwp);		/* unlock and unmask */
      265 
      266 	call cleanup (astep);			/* free all memory frame; make into disk addresses */
      267 
      268 	call pmut$lock_ptl (oldmask, ptwp);		/* mask */
      269 	ptp = addrel (astep, sst.astsize);		/* get a pointer to the page table */
      270 	do i = 0 to sst.pts (fixed (aste.ptsi, 2)) - 1;	/* loop over all pages in the segment */
      271 	     if atptw.disk
      272 	     then substr (ptw.add, 1, 1) = "1"b;	/* make null */
      273 
      274 	     ptp = addrel (ptp, size (ptw));		/* Next ptw, please */
      275 	end;
      276 	call pmut$unlock_ptl (oldmask, ptwp);		/* unlock and unmask */
      277 	return;
      278 
      279 fill_page_table:
      280      entry (Astep, File_Mapp, N_Pages);
      281 
      282 
      283 	astep = Astep;				/* Copy args */
      284 	fmp = File_Mapp;
      285 	pvtx = astep -> aste.pvtx;
      286 	last_page = N_Pages - 1;			/* arg is csl */
      287 	sstp = addr (sst_seg$);
      288 	records = 0;
      289 
      290 	ptp = addrel (astep, sstp -> sst.astsize);
      291 	do i = 0 to last_page;
      292 	     devadd = file_map.fm (i);		/* No need to lock here */
      293 	     if devadd_null_flag
      294 	     then do;				/* Outside world null address, */
      295 		     devadd_null_flag = "0"b;		/* This is not NULLED, but null. */
      296 		     devadd_add_type = "0000"b;	/* Internal null address representation */
      297 		end;
      298 	     else do;				/* real disk address */
      299 		     devadd_add_type = add_type.disk;	/* Assume protected. */
      300 		     records = records + 1;
      301 		end;
      302 	     ptp -> ptwa_bits (i) = devadd | null_devadd_not_in_core;
      303 						/* save final result in ptw */
      304 	end;
      305 
      306 
      307 	do i = last_page + 1 to sstp -> sst.pts (fixed (astep -> aste.ptsi, 2)) - 1;
      308 						/* Fill up rest of page table with nulls */
      309 	     ptp -> ptwa_bits (i) = null_devadd_not_in_core;
      310 	     ptp -> mptwa (i).devadd = fill_page_table_null_addr;
      311 	end;
      312 	aste.records = bit (fixed (records, 9), 9);
      313 	if pc_trace
      314 	then do;
      315 		call trace ("fill_page_table^-astep = ^p", astep);
      316 		if last_page <= 4
      317 		then call trace (half_line_of_words, ptp -> fword (0), ptp -> fword (1), ptp -> fword (2),
      318 			ptp -> fword (3));
      319 		else do;
      320 			do i = 0 to last_page by 8;
      321 			     call trace (line_of_words, ptp -> fword (i), ptp -> fword (i + 1),
      322 				ptp -> fword (i + 2), ptp -> fword (i + 3), ptp -> fword (i + 4),
      323 				ptp -> fword (i + 5), ptp -> fword (i + 6), ptp -> fword (i + 7));
      324 			end;
      325 		     end;
      326 	     end;
      327 	return;
      328 
      329 truncate:
      330      entry (Astep, First_Page);			/* entry to truncate a page table */
      331 
      332 
      333 	tr_count_sw = "0"b;
      334 	go to truncate_join;
      335 
      336 truncate_count:
      337      entry (Astep, First_Page, N_In_Core);
      338 
      339 
      340 	tr_count_sw = "1"b;
      341 
      342 truncate_join:
      343 	sstp = addr (sst_seg$);			/* get a pointer to the sst */
      344 
      345 	astep = Astep;				/* copy args into wired down stack */
      346 	ptp = addrel (astep, sstp -> sst.astsize);
      347 	cmp = sstp -> sst.cmp;			/* and core map pointer */
      348 	first_page = First_Page;
      349 	last_page = sstp -> sst.pts (fixed (astep -> aste.ptsi, 3)) - 1;
      350 						/* get pt end for last page */
      351 
      352 	records = 0;
      353 	if pc_trace
      354 	then call trace ("truncate^-^-astep = ^p", astep);
      355 
      356 /* the segment has an AST entry -- must clean up page tables and core map */
      357 
      358 	call pmut$lock_ptl (oldmask, ptwp);		/* lock and mask */
      359 
      360 	if pc_trace
      361 	then do;
      362 		if last_page <= 4
      363 		then call trace (half_line_of_words, ptp -> fword (0), ptp -> fword (1), ptp -> fword (2),
      364 			ptp -> fword (3));
      365 		else do;
      366 			do i = 0 to last_page by 8;
      367 			     call trace (line_of_words, ptp -> fword (i), ptp -> fword (i + 1),
      368 				ptp -> fword (i + 2), ptp -> fword (i + 3), ptp -> fword (i + 4),
      369 				ptp -> fword (i + 5), ptp -> fword (i + 6), ptp -> fword (i + 7));
      370 			end;
      371 		     end;
      372 	     end;
      373 	n_in_core = 0;
      374 retry:
      375 	ind = 0;
      376 
      377 	do i = first_page to last_page;		/* loop through all pages going */
      378 	     if ptp -> ptwa (i).os
      379 	     then do;				/* if out of service, must wait for io */
      380 		     ind = fixed (rel (addr (ptp -> ptwa (i))), 18);
      381 						/* get event to wait on */
      382 		     call wait_then_go_to (retry);	/* must go back to top after waiting */
      383 		end;
      384 	     count = "0"b;				/* Assume no truncation */
      385 
      386 /* At this point, page is not o/s. If in core, devadd has core address. */
      387 
      388 	     from_core = atptwa (i).core;		/* Remember in_coreness */
      389 	     devadd = ptp -> mptwa (i).devadd;		/* pick up the device address */
      390 
      391 /* At this point, devadd has disk or null address, unless in core */
      392 
      393 	     if from_core
      394 	     then do;				/* Page is in core */
      395 		     n_in_core = n_in_core + 1;
      396 		     cmep = addr (cmp -> cma (ptp -> core_ptwa (i).frame));
      397 						/* Get pointer to cme */
      398 		     devadd = cmep -> cme.devadd;	/* and get the devadd for cleanup */
      399 		     if ptp -> ptwa (i).wired
      400 		     then sstp -> sst.wired = sstp -> sst.wired - 1;
      401 		     call page$pcleanup (astep, i);	/* Fix up data bases, count quota, csl */
      402 		     count = "0"b;			/* page$cleanup did all work */
      403 		end;
      404 
      405 
      406 /* At this point, page is not in core. devadd has disk, null, or nulled */
      407 
      408 	     if devadd_bits.disk
      409 	     then if ^devadd_null_flag		/* if nulling ... */
      410 		then do;
      411 			devadd_null_flag = "1"b;	/* Null the address */
      412 			count = "1"b;
      413 		     end;
      414 
      415 	     ptp -> mptwa (i).devadd = devadd;		/* Insert right devadd in ptw */
      416 	     if count
      417 	     then records = records + 1;
      418 
      419 	end;
      420 	call loop_up_fms;
      421 	if records ^= 0
      422 	then do;
      423 		astep -> aste.fmchanged = "1"b;	/* Make sure we get an update_vtoce */
      424 		if ^astep -> aste.nqsw
      425 		then if astep -> aste.dirsw
      426 		     then call quotaw$cu_for_pc (astep, -records, "1"b);
      427 		     else if astep -> aste.par_astep
      428 		     then call quotaw$cu_for_pc (ptr (astep, astep -> aste.par_astep), -records, "0"b);
      429 		astep -> aste.records = bit (fixed (fixed (astep -> aste.records, 9) - records, 9), 9);
      430 	     end;
      431 
      432 /* Now update the current segment length */
      433 
      434 	do i = min (first_page - 1, last_page) to 0 by -1;/* min traps truncate to addr > aste size */
      435 	     devadd = ptp -> mptwa (i).devadd;
      436 	     if ptp -> atptwa (i).core
      437 	     then goto update_csl;
      438 	     if devadd_add_type & add_type.non_null
      439 	     then if ^devadd_null_flag
      440 		then go to update_csl;
      441 	end;
      442 update_csl:
      443 	astep -> aste.csl = bit (fixed (i + 1, 9), 9);
      444 
      445 	if first_page = 0
      446 	then do;
      447 		astep -> aste.damaged = "0"b;		/* empty is undamaged */
      448 		astep -> aste.fm_damaged = "0"b;
      449 	     end;
      450 
      451 	call page$cam;				/* make sure our work takes */
      452 	call pmut$unlock_ptl (oldmask, ptwp);		/* unlock and unmask */
      453 	if tr_count_sw
      454 	then N_In_Core = n_in_core;			/* return for meter for callers that want. */
      455 	return;
      456 
      457 dumper_get_file_map:
      458      entry (Astep, Copy_Astep, File_Mapp, Deposit_Count, Listp, Pageno_Listp);
      459 						/* dumper entry for VTOCE update */
      460 
      461 	dumper = "1"b;
      462 	goto get_file_map_common;
      463 
      464 get_file_map:
      465      entry (Astep, Copy_Astep, File_Mapp, Deposit_Count, Listp, Pageno_Listp);
      466 						/* entry for VTOC update */
      467 
      468 
      469 	dumper = "0"b;
      470 get_file_map_common:
      471 	astep = Astep;				/* Copy astep */
      472 	add_to_dmpr_map = "0"b;
      473 	sstp = addr (sst_seg$);			/* get SST base ptr */
      474 	fmp = File_Mapp;
      475 	cmp = sstp -> sst.cmp;			/* get core map ptr */
      476 	last_page = sstp -> sst.pts (fixed (astep -> aste.ptsi, 2)) - 1;
      477 	no_deposit_no_return = (Listp = null) | aste.ddnp;
      478 	getfmap_csl, getfmap_np, getfmap_nrec = 0;	/* Init counters */
      479 	offed_sw = "0"b;				/* Don't need cam */
      480 	return_pageno = (Pageno_Listp ^= null ());
      481 
      482 	call pmut$lock_ptl (oldmask, ptwp);		/* Lock the pagetable lock */
      483 
      484 	sstp = addr (sst_seg$);
      485 	j = 0;					/* Init deposit index */
      486 	do i = 0 to last_page;			/* Walk the table */
      487 	     ptp = addrel (astep, sstp -> sst.astsize + i);
      488 						/* Get one page tbl ptr */
      489 	     devadd = ptp -> mptw.devadd;		/* Get address from ptw */
      490 	     if devadd_bits.disk
      491 	     then do;				/* Disk addr, could be nulled */
      492 		     if devadd_null_flag & ^no_deposit_no_return
      493 		     then do;			/* put in deposit list */
      494 			     devadd_null_flag = "0"b; /* zero the special internal flag */
      495 			     deposit_list (j) = devadd;
      496 						/* set to give to outside world */
      497 			     if return_pageno
      498 			     then pageno_list (j) = i;
      499 
      500 			     j = j + 1;		/* one more depositable address processed */
      501 			     devadd = get_file_map_vt_null_addr;
      502 			     ptp -> mptw.devadd = devadd;
      503 						/* coded null to file map and page table */
      504 			end;
      505 		     else if devadd_null_flag & dumper
      506 		     then devadd = get_file_map_vt_null_addr;
      507 		end;
      508 	     if devadd_bits.core
      509 	     then do;				/* A core address- move on up storage levels */
      510 		     if ptw.phm
      511 		     then do;			/* Must off phm */
      512 			     ptw.phm1 = "1"b;	/* Mark mod status */
      513 			     ptw.phm = "0"b;	/* OFF PHM */
      514 			     offed_sw = "1"b;
      515 			end;
      516 		     cmep = addr (cmp -> cma (core_ptw.frame));
      517 		     devadd = cmep -> cme.devadd;	/* Reconsider this devadd */
      518 		     if devadd_null_flag & ^ptw.phm1 & ^(ptw.os & cme.io)
      519 		     then devadd = get_file_map_vt_null_addr;
      520 						/* This avoids damage to pure nulls incore */
      521 		end;
      522 	     if devadd_null_flag
      523 	     then if dumper
      524 		then devadd = get_file_map_dumper_non_null_addr;
      525 		else do;
      526 			devadd = get_file_map_vt_null_addr;
      527 			devadd_null_flag = "1"b;
      528 		     end;				/* if page is not on disk yet, or trunced,
      529*						   we cannot fault in this page should we crash */
      530 	     else devadd_null_flag = (devadd_add_type = "0000"b);
      531 						/* Set outside-world null representation */
      532 
      533 	     if ^devadd_null_flag
      534 	     then do;				/* Real page */
      535 		     getfmap_nrec = getfmap_nrec + 1;
      536 		     getfmap_csl = i + 1;
      537 		     if atptw.core
      538 		     then getfmap_np = getfmap_np + 1;
      539 		end;
      540 
      541 	     rfm (i) = devadd;			/* Send out agreed-upon devadd */
      542 	end;
      543 	curtime = clock ();				/* loop_up_fms MAY do this, but we must be sure */
      544 	if offed_sw
      545 	then do;
      546 		call loop_up_fms;			/* Pages were noted as modified. */
      547 		call page$cam;			/* We turned off phm bits. */
      548 	     end;
      549 
      550 	if aste.fms
      551 	then add_to_dmpr_map = "1"b;
      552 	if ^aste.gtus
      553 	then if aste.np | aste.infp
      554 	     then /* have pages in, or subordinate astes */
      555 		aste.dtu = bit (fixed (curtime, 52), 52);
      556 						/* call it -in use- */
      557 	copy_aste = astep -> aste;			/* Copy ASTE structure */
      558 
      559 /* Update perishable items consistently to caller */
      560 
      561 	astep -> aste.fms = "0"b;			/* copy_aste has old value - this
      562*						   assignment constitutes segment control's
      563*						   recognition of modification */
      564 	if ^dumper
      565 	then do;
      566 		astep -> aste.fmchanged1 = astep -> aste.fmchanged;
      567 						/* Dont' lose fmchanged until updatev
      568*						   turns this off, but ... */
      569 		astep -> aste.fmchanged = "0"b;	/* turn off p_c maintained bit. */
      570 	     end;
      571 	call pmut$unlock_ptl (oldmask, ptwp);		/* And unlock the pagetables */
      572 						/* Use following items to avoid damaging */
      573 						/* segments with incore nonmod nulls. */
      574 						/* Copy out data to caller */
      575 
      576 	copy_aste.np = bit (fixed (getfmap_np, 9), 9);
      577 	copy_aste.records = bit (fixed (getfmap_nrec, 9), 9);
      578 	copy_aste.csl = bit (fixed (getfmap_csl, 9), 9);
      579 
      580 	unspec (Copy_Astep -> aste) = unspec (copy_aste); /* Copy the s  into our callers copy */
      581 
      582 	do i = 0 to last_page;
      583 	     fmp -> file_map.fm (i) = rfm (i);		/* Upper bits into file map */
      584 	end;
      585 
      586 	do i = 0 to j - 1;				/* copy out depositable addresses */
      587 	     Address_Array (i) = deposit_list (i);
      588 	     if return_pageno
      589 	     then Pageno_List (i) = pageno_list (i);
      590 	end;
      591 	Deposit_Count = j;				/* deposit count */
      592 	if add_to_dmpr_map & ^aste.nid & ^aste.per_process & ^aste.hc_sdw
      593 	then call dbm_man$set_incr (fixed (aste.pvtx, 17), fixed (aste.vtocx, 17), (0));
      594 
      595 	if pc_trace
      596 	then do;
      597 		call trace ("get_file_map^-astep = ^p, fmp = ^p", astep, fmp);
      598 		if last_page <= 4
      599 		then call trace (half_line_of_words, ptp -> fword (0), ptp -> fword (1), ptp -> fword (2),
      600 			ptp -> fword (3));
      601 		else do;
      602 			do i = 0 to last_page by 8;
      603 			     call trace (line_of_words, ptp -> fword (i), ptp -> fword (i + 1),
      604 				ptp -> fword (i + 2), ptp -> fword (i + 3), ptp -> fword (i + 4),
      605 				ptp -> fword (i + 5), ptp -> fword (i + 6), ptp -> fword (i + 7));
      606 			end;
      607 		     end;
      608 	     end;
      609 	return;
      610 
      611 updates:
      612      entry (Astep);					/* Entry to set file modified switches. */
      613 
      614 	astep = Astep;				/* Copy arg to avoid page fault. */
      615 	sstp = addr (sst_seg$);
      616 	call pmut$lock_ptl (oldmask, ptwp);		/* lock and mask */
      617 	call loop_up_fms;
      618 	go to quit;
      619 
      620 update_incore_fms:
      621      entry (Astep);					/* used to get fms as accurate as possible */
      622 
      623 
      624 	astep = Astep;
      625 	sstp = addr (sst_seg$);
      626 	ptp = addrel (astep, sst.astsize);
      627 
      628 	if aste.np = "000"b3
      629 	then return;
      630 	offed_sw = "0"b;
      631 
      632 
      633 	do i = 0 to fixed (aste.csl, 9) - 1;
      634 	     if ptwa (i).phm
      635 	     then do;
      636 		     offed_sw = "1"b;		/* remeber to cam */
      637 		     ptwa (i).phm1 = "1"b;		/* Needed for real write */
      638 		     ptwa (i).phm = "0"b;		/* This statement order is critical */
      639 		end;
      640 	end;
      641 
      642 	if offed_sw
      643 	then do;
      644 		call loop_up_fms;
      645 		call page$cam;
      646 	     end;
      647 
      648 	return;
      649 
      650 loop_up_fms:
      651      proc;					/* Set fms up tree for hierarchy dumper. */
      652 
      653 	dcl     astep1		 pointer;
      654 
      655 	if aste.gtms
      656 	then return;
      657 	curtime = clock ();
      658 	astep1 = astep;
      659 	do while (rel (astep1));
      660 	     astep1 -> aste.fms = "1"b;
      661 	     astep1 -> aste.dtm = bit (fixed (curtime, 52), 52);
      662 	     astep1 = ptr (astep1, astep1 -> aste.par_astep);
      663 	end;
      664 
      665      end loop_up_fms;
      666 
      667 /* You do not have to lock the page table or clear the AM for any of this. Phm1 will
      668*   always be taken as a signal to write, and page$pwrite will turn them both off when
      669*   camming. Once phm1 is on, failure to set phm, for not camming, is invisible. However, we
      670*   do cam at the end so that the next call to this will get phms. */
      671 
      672 flush:
      673      entry;					/* here to write out all of core */
      674 
      675 /* Synchronized pages are handled as follows:
      676*
      677*   flush_core - Page Control (page$pwrite) does the right thing, based on
      678*   the time stamp in the page.
      679*
      680*   flush - Modified synchronized pages are abandoned. This is safe, due to
      681*   Ring-2 Data Management protocols.
      682*
      683**/
      684 
      685 	dcl     flushing_for_pleasure	 bit (1);
      686 	dcl     hedonism		 fixed bin;
      687 	dcl     pleasure_flush_count	 fixed bin;
      688 
      689 	flushing_for_pleasure = "0"b;
      690 	go to flush_join;
      691 
      692 flush_core:
      693      entry;					/* here to start writes for all core. */
      694 
      695 	flushing_for_pleasure = "1"b;
      696 
      697 flush_join:
      698 	sstp = addr (sst_seg$);			/* get pointers, and lock */
      699 	pvt_arrayp = addr (pvt$array);
      700 	cmp = sstp -> sst.cmp;
      701 	if flushing_for_pleasure
      702 	then hedonism = divide (sst.write_limit, 2, 17, 0);
      703 	pleasure_flush_count = 0;
      704 	call pmut$lock_ptl (oldmask, ptwp);		/* lock and mask */
      705 start_flush:
      706 	do i = sst.first_core_block to sst.last_core_block;
      707 						/* index thru all cmes */
      708 	     ind = -1;				/* no wait event */
      709 	     cmep = addr (cmp -> cma (i));
      710 
      711 	     if (cme.ptwp ^= "000000"b3)
      712 	     then do;				/* has real page */
      713 		     ptp = ptr (sstp, cme.ptwp);	/* get ptp */
      714 		     astep = ptr (sstp, cme.astep);	/* get astep */
      715 		     if ^aste.hc_part
      716 		     then do;			/* Don't bother with HC part segs */
      717 			     if ptw.os
      718 			     then ind = fixed (rel (ptp), 18);
      719 						/* if event, wait on it */
      720 			     else do;
      721 				     pageno =
      722 					fixed (rel (ptp), 18) - fixed (rel (astep), 18) - sstp -> sst.astsize;
      723 				     devadd = cme.devadd;
      724 				     if ptw.phm | ptw.phm1
      725 				     then /* Needs writing */
      726 					if drive_ok ((aste.pvtx))
      727 					then /* dont io bad disk */
      728 					     if flushing_for_pleasure
      729 					     then if cme.phm_hedge
      730 						then do;
      731 							call page$pwrite (astep, pageno);
      732 							sst.hedge_writes = sst.hedge_writes + 1;
      733 							pleasure_flush_count = pleasure_flush_count + 1;
      734 						     end;
      735 						else cme.phm_hedge = ^aste.per_process;
      736 						/* change when we prevail across crashes */
      737 						/* if significant, write next time, if not written */
      738 					     else do;
      739 						/* shutdown */
      740 						     if aste.synchronized
      741 						     then ptw.phm, ptw.phm1 = "0"b;
      742 						/* Abandon modified synch pages */
      743 						     else call page$pwrite (astep, pageno);
      744 						end;
      745 				     if ^flushing_for_pleasure
      746 						/* shutdown */
      747 				     then if ^(ptw.phm | ptw.phm1 | ptw.os)
      748 						/* Unmodified */
      749 					then if devadd_null_flag
      750 						/* Null address */
      751 					     then call page$pcleanup (astep, pageno);
      752 						/* Reflect quota */
      753 				     if ptp -> ptw.os
      754 				     then /* if still being written, wait for it */
      755 					ind = fixed (cmp -> cma (i).ptwp, 18);
      756 				     if sstp -> sst.wtct > sstp -> sst.write_limit
      757 				     then /* if too many queued then */
      758 					if (ind > 0) & ^flushing_for_pleasure
      759 					then call wait_then_go_to (start_flush);
      760 						/* wait for one */
      761 				     if pleasure_flush_count >= hedonism
      762 				     then do;	/* All done with PTW */
      763 					     pleasure_flush_count = 0;
      764 						/* time for a nap */
      765 					     call pmut$unlock_ptl (oldmask, ptwp);
      766 					     if flushing_for_pleasure
      767 					     then call pxss$relinquish_priority;
      768 					     call pmut$lock_ptl (oldmask, ptwp);
      769 					end;
      770 				end;
      771 			end;
      772 		end;
      773 	end;					/* end of cme array loop */
      774 
      775 	if (ind > 0) & ^flushing_for_pleasure
      776 	then call wait_then_go_to (start_flush);	/* Wait if shutdown and there is stuff to wait for */
      777 	go to quit;				/* done */
      778 
      779 list_deposited_add:
      780      entry (Astep, First_Page, Last_Page, Records, Listp, Pageno_Listp);
      781 						/* output deposits to seg ctl */
      782 
      783 
      784 	astep = Astep;				/* copy params */
      785 	first_page = First_Page;			/* place to start */
      786 	last_page = Last_Page;			/* place to stop */
      787 	return_pageno = (Pageno_Listp ^= null ());
      788 	sstp = addr (sst_seg$);			/* set up sstp */
      789 	ptp = addrel (astep, sstp -> sst.astsize);
      790 
      791 	records = 0;				/* init count of depositable records */
      792 
      793 	call pmut$lock_ptl (oldmask, ptwp);		/* lock the PTL for real work */
      794 
      795 	if last_page < 0				/* Scan whole page table */
      796 	then last_page = sst.pts (fixed (astep -> aste.ptsi, 2)) - 1;
      797 
      798 	do i = first_page to last_page;		/* loop thru all ptws in ptl */
      799 
      800 	     devadd = ptp -> mptwa (i).devadd;		/* assume devadd in ptw -- */
      801 
      802 /* Any page in core or on the PD which has a nulled address
      803*   has a right to it: hence, we only list those in the PTW */
      804 
      805 	     if devadd_bits.disk
      806 	     then if devadd_null_flag
      807 		then do;				/* a real deposited address */
      808 			deposit_list (records) = devadd;
      809 						/* move to output array */
      810 			if return_pageno
      811 			then pageno_list (records) = i;
      812 			records = records + 1;	/* bump counter */
      813 			ptp -> mptwa (i).devadd, devadd = list_deposit_null_addr;
      814 		     end;
      815 	end;
      816 
      817 	call pmut$unlock_ptl (oldmask, ptwp);		/* unlock the page tables */
      818 	do i = 0 to records - 1;
      819 	     Address_Array (i) = deposit_list (i);	/* return to argument array */
      820 	     if return_pageno
      821 	     then Pageno_List (i) = pageno_list (i);
      822 	end;
      823 
      824 	Records = records;				/* return the count */
      825 	return;
      826 
      827 deposit_list:
      828      entry (Pvtx, Records, Listp, Vtocx, Pageno_Listp);	/* entry to deposit a list of addresses */
      829 
      830 
      831 	records = Records;				/* number of records to be deposited */
      832 	pvtx = Pvtx;				/* phys volume index */
      833 
      834 /* The paged fsdct strategy states that the page table lock need
      835*   not be locked to deposit. Nobody can withdraw our bit unless we
      836*   have a problem, and if we find an unprotected address at
      837*   the time we deposit, this will be the case irrespective
      838*   of the page table lock. */
      839 
      840 	do i = 0 to records - 1;
      841 	     Devadd_Array (i).add_type = add_type.disk;	/* Make up for sins of vtoc_man */
      842 	end;
      843 
      844 	call page$deposit_list ((pvtx), Listp, 1, records, Vtocx, Pageno_Listp);
      845 
      846 	return;
      847 
      848 
      849 /*  Auxiliary entry for truncation/deposition of vtoceless segs */
      850 
      851 truncate_deposit_all:
      852      entry (Astep);
      853 
      854 
      855 	astep = Astep;				/* Copy astep */
      856 
      857 	if aste.uid
      858 	then call syserr (1, "pc: truncate_deposit_all call on VTOCed seg at ^p", astep);
      859 	call truncate (astep, 0);			/* Clean up w.r.t. pc */
      860 
      861 	if aste.hc_sdw
      862 	then return;				/* Don't attempt semi-hc deposit */
      863 
      864 	call list_deposited_add (astep, 0, -1, records, addr (deposit_list), null ());
      865 
      866 	call page$deposit_list ((aste.pvtx), addr (deposit_list), 1, records, -1, null ());
      867 
      868 	return;
      869 
      870 move_page_table:
      871      entry (Old_Astep, New_Astep);
      872 
      873 
      874 	sstp = addr (sst_seg$);
      875 	cmp = sstp -> sst.cmp;
      876 	old_astep = Old_Astep;
      877 	new_astep = New_Astep;
      878 	call pmut$lock_ptl (oldmask, ptwp);		/* lock and mask */
      879 
      880 	if pc_trace
      881 	then call trace ("move_page_table^-old astep = ^p, new astep = ^p", old_astep, new_astep);
      882 
      883 	old_ptp = addrel (old_astep, sstp -> sst.astsize);/* get pointer to old page table */
      884 	new_ptp = addrel (new_astep, sstp -> sst.astsize);/* get pointer to new page table */
      885 	do i = 0 to sstp -> sst.pts (fixed (old_astep -> aste.ptsi, 3)) - 1;
      886 	     new_ptp -> ptwa_bits (i) = old_ptp -> ptwa_bits (i);
      887 						/* copy page table words */
      888 
      889 	     old_ptp -> ptwa_bits (i) = null_devadd_not_in_core;
      890 	     old_ptp -> mptwa (i).devadd = pc_move_page_table_1_null_addr;
      891 	     ptp = addr (new_ptp -> ptwa (i));		/* point to specific ptw */
      892 	     if atptw.core
      893 	     then do;				/* ptw describes core */
      894 		     cmep = addr (cmp -> cma (core_ptw.frame));
      895 						/* address CME */
      896 		     cme.ptwp = rel (ptp);		/* associate CME with new PTW */
      897 		     cme.astep = rel (new_astep);	/* ditto ASTE */
      898 		     devadd = cme.devadd;		/* get devadd from cme if in core */
      899 		     if cme.notify_requested		/* if someone was waiting on old PTW event, then notify .. */
      900 		     then call pxss$notify (fixed (rel (addr (old_ptp -> ptwa (i))), 18));
      901 						/* him, causing him to rewait on new event */
      902 		end;
      903 	     else devadd = mptw.devadd;		/* get devadd out of ptw if not in core */
      904 	end;
      905 
      906 	do i = sstp -> sst.pts (fixed (old_astep -> aste.ptsi, 3))
      907 	     to sstp -> sst.pts (fixed (new_astep -> aste.ptsi, 3)) - 1;
      908 
      909 	     new_ptp -> ptwa_bits (i) = null_devadd_not_in_core;
      910 	     new_ptp -> mptwa (i).devadd = pc_move_page_table_2_null_addr;
      911 	end;
      912 
      913 /* Now copy the old ASTE into the new ASTE, except fp, bp, ptsi and marker */
      914 
      915 	new_astep -> aste_part.two = old_astep -> aste_part.two;
      916 
      917 	go to quit;
      918 
      919 
      920 
      921 segmove:
      922      entry (Move_Astep, Old_Astep, New_Astep, New_Pvtx, New_Vtocx, Records, Listp, Pageno_Listp, Code);
      923 
      924 	astep = Move_Astep;				/* aste under segmove */
      925 	old_astep = Old_Astep;			/* put old addresses here for pcrsst */
      926 	new_astep = New_Astep;			/* put new addresses here for pcrsst or caller to deposit */
      927 	new_pvtx = New_Pvtx;			/* we can reference them without the */
      928 	new_vtocx = New_Vtocx;			/* AST lock */
      929 	sstp = addr (sst_seg$);
      930 	cmp = sst.cmp;
      931 	new_ptp = addwordno (new_astep, sst.astsize);	/* use that page table
      932*						   to store up addresses on new volume */
      933 	old_ptp = addwordno (old_astep, sst.astsize);	/* use that page table
      934*						   to remember old addesses for the purposes of pcrsst */
      935 	move_ptp = addwordno (astep, sst.astsize);	/* this is the page table of affliction. */
      936 
      937 	if astep -> aste.ptsi ^= new_astep -> aste.ptsi | new_astep -> aste.ptsi ^= old_astep -> aste.ptsi
      938 	then do;
      939 		Code = error_table_$bad_arg;
      940 		return;
      941 	     end;
      942 
      943 	last_page = sst.pts (fixed (astep -> aste.ptsi, 2)) - 1;
      944 
      945 	call lock$lock_fast (addr (sst.segmove_lock));	/* Only one at a time */
      946 	sst.segmove_new_addr_astep = new_astep;		/* pc_check_tables_ should deposit anything in here
      947*						   or at least bang on the pvte inconsistency count. */
      948 
      949 	call pmut$lock_ptl (oldmask, ptwp);		/* will be unlocked if we have to wait */
      950 
      951 /**** Note that deposit_list is declared 0:255 and page$deposit_list expects a
      952*      1:256 array. withdraw_list expects 0:255. Shouldn't be any trouble */
      953 
      954 	segmove_records_in_hand = 0;
      955 	segmove_total_records,			/* This many is the grand total that we have accumulated */
      956 	     segmove_records_needed			/** This many are the number that we need to add to the record pile */
      957 	     = fixed (astep -> aste.records, 9);	/* This is the first guess as to the total number of records needed */
      958 						/* However, the guess may be too low since the PTL is unlocked. So */
      959 						/* even when we get records_in_hand up and records_needed to 0, we may */
      960 						/* have to add to total_records and reset records_needed to get the rest */
      961 
      962 
      963 	move_tries = 0;
      964 
      965 augment_record_pile:
      966 /**** + Debug
      967*      call syserr (ANNOUNCE, "pc: (at ARP) aste: np = ^d, records = ^d, csl = ^d", fixed (aste.np), fixed (aste.records), fixed (aste.csl));
      968**/
      969 	code = 0;
      970 	do while (segmove_records_needed > 0 & code = 0); /* keep calling until free_store gives all we want */
      971 	     call page$withdraw_list (new_pvtx, new_ptp, segmove_records_in_hand, segmove_records_needed, ind, code);
      972 						/* since parm(3) is zero based, zero records_in_hand is interpreted */
      973 						/* as "put the next record in slot zero" which deposit addresses as  */
      974 						/* slot one. */
      975 
      976 	     if ind ^= 0
      977 	     then /* wait for volmap */
      978 		call wait_then_go_to (augment_record_pile);
      979 	end;
      980 	if code ^= 0
      981 	then do;					/* out-of-volume */
      982 		Code = code;
      983 		go to SEGMOVE_ABORT_RETURN;
      984 	     end;
      985 
      986 /**** At this point, we own all the records we need. We can release the
      987*      PTL while we drag the segment into memory. */
      988 
      989 /****  NOTE -- at this point new_ptp contains segmove_total_records records.
      990*      segmove_records_needed can be re-used.
      991*      if we find that we need more records, total_records will grow,
      992*      but in_hand will continue to be the number of addresses in new_addr_aste. */
      993 
      994 move_retry:
      995 	segmove_records_needed = 0;			/* re-count the number we need under the PTL */
      996 
      997 /**** + Debug
      998*      call syserr (ANNOUNCE, "pc: (at MRT) aste: np = ^d, records = ^d, csl = ^d", fixed (aste.np), fixed (aste.records), fixed (aste.csl));
      999**/
     1000 
     1001 	move_tries = move_tries + 1;
     1002 	if move_tries > 1000
     1003 	then go to SEGMOVE_ABORT_RETURN;
     1004 
     1005 	n_io_started = 0;
     1006 SEGMOVE_EXAMINE_PAGES:
     1007 	do i = 0 to last_page;			/* get all pages into memory */
     1008 RE_EXAMINE_PAGE:
     1009 	     if move_ptp -> ptwa (i).os
     1010 	     then do;				/* wait for i and  also o (quiesce) */
     1011 
     1012 		     ind = wordno (addr (move_ptp -> ptwa (i)));
     1013 						/* event to wait on */
     1014 		     n_io_started = n_io_started + 1;
     1015 		     if n_io_started > sst.segmove_io_limit
     1016 		     then call wait_then_go_to (move_retry);
     1017 		end;
     1018 	     else if move_ptp -> atptwa (i).disk
     1019 	     then do;
     1020 		     sst.segmove_n_reads = sst.segmove_n_reads + 1;
     1021 		     call page$pread (astep, i, temp_ind);
     1022 						/* put event into temporary... */
     1023 		     if temp_ind ^= 0
     1024 		     then do;
     1025 			     ind = temp_ind;	/* OK to mung it now... */
     1026 			     n_io_started = n_io_started + 1;
     1027 			     if n_io_started > sst.segmove_io_limit
     1028 			     then call wait_then_go_to (move_retry);
     1029 			end;
     1030 		     else go to RE_EXAMINE_PAGE;	/* ZERO! */
     1031 		end;
     1032 	     else if move_ptp -> atptwa (i).core
     1033 	     then do;				/* in memory - keep it there */
     1034 		     segmove_records_needed = segmove_records_needed + 1;
     1035 						/* got another real one in memory */
     1036 		     cmep = addr (cmp -> cma (move_ptp -> core_ptwa (i).frame));
     1037 		     cme.pin_counter = 1000;
     1038 		     if astep -> aste.synchronized & (move_ptp -> core_ptwa (i).phm | move_ptp -> core_ptwa (i).phm1)
     1039 						/* any modified page of a synch segment is held until proven elsewise */
     1040 		     then call segmove_synch_page (astep, cmep, i);
     1041 		end;
     1042 	     else if move_ptp -> ptwa (i).add_type ^= "0000"b
     1043 						/* mysterious non-null */
     1044 	     then /* but unknown! */
     1045 		call syserr (CRASH, "pc$segmove: unexpected address type ^4b", move_ptp -> ptwa (i).add_type);
     1046 	end SEGMOVE_EXAMINE_PAGES;
     1047 
     1048 /**** At arrival here, the PTL is locked (nothing can be evicted)
     1049*      and either all the pages are in memory, or we have some read-ahead
     1050*      activity. */
     1051 
     1052 	if n_io_started > 0
     1053 	then call wait_then_go_to (move_retry);		/* ind is last read ahead page */
     1054 
     1055 	sst.segmove_max_tries = max (move_tries, sst.segmove_max_tries);
     1056 
     1057 /**** No read aheads. all pages found in core, PTL is locked.
     1058*      Start final countdown. Unless, somehow, the segment grew ... */
     1059 
     1060 	if segmove_records_needed > segmove_total_records
     1061 	then do;					/* When we counted under the PTL and made them stand still, we found more of them. */
     1062 		segmove_total_records = segmove_records_needed;
     1063 						/* new count is the right count */
     1064 		segmove_records_needed = segmove_records_needed - segmove_records_in_hand;
     1065 						/* count of additional records required */
     1066 		go to augment_record_pile;		/* get 'em */
     1067 
     1068 	     end;
     1069 
     1070 /**** We have an adequate supply of records on the new volume,
     1071*      and everything is in memory. Here we go... */
     1072 
     1073 /**** Since the move segment page table is in its final state
     1074*      (all addresses null or in core) we can copy all the ptw's
     1075*      to the old_addr_aste. pcrsst will find them there and
     1076*      put them back. All the new addreses have been accumulated
     1077*      in the new_addr_aste, where shutdown can deposit them.
     1078*
     1079*      Thus the rules are:  if new_addr_astep ^= null (), deposit
     1080*      all the non-null addresses in its page table. pc_check_tables_
     1081*      does not currently concern itself with deposits, so these
     1082*      addresses are abandoned.
     1083*
     1084*      if the move_astep ^= null (), then copy the page table
     1085*      from the old_addr_aste to the move_aste. The old_addr_astep
     1086*      is guaranteed to be non-null.
     1087*
     1088*      if the old_addr_astep ^= null(), then zap all its ptw's
     1089*      to be null addresses. */
     1090 
     1091 	sst.segmove_old_addr_astep = old_astep;		/* still full of nulls */
     1092 						/* now, pcrsst will zero all these ptw's */
     1093 
     1094 	begin;					/* copy the page table wholesale from move to old astep */
     1095 	     declare pt		      (0:last_page) bit (36) aligned based;
     1096 	     old_ptp -> pt = move_ptp -> pt;
     1097 	end;					/* this can be copied back verbatim by pc_check_tables_
     1098*						   since we are under the PTL and nothing can change. */
     1099 
     1100 	sst.segmove_pvtx = astep -> aste.pvtx;
     1101 	sst.segmove_vtocx = astep -> aste.vtocx;
     1102 	sst.segmove_astep = astep;			/* now, pcrsst will copy all the devadds from old to here */
     1103 
     1104 /**** Now it only takes one loop to put the new disk devadds into
     1105*      the move aste. */
     1106 
     1107 	segmove_records_used = 0;
     1108 
     1109 	if segmove_total_records < fixed (aste.np)
     1110 	then call syserr (CRASH, "pc$segmove: miscounted pages.");
     1111 
     1112 	do i = 0 to last_page;			/* now swap addresses */
     1113 	     devadd = move_ptp -> mptwa (i).devadd;	/* either core or null */
     1114 /**** + Debug
     1115*      call syserr (ANNOUNCE, "sgm: page ^d ptw devadd ^.3b",
     1116*      i, devadd);
     1117**/
     1118 	     if (devadd_add_type & add_type.core) ^= ""b	/* core */
     1119 	     then do;
     1120 		     if segmove_records_used > segmove_records_in_hand
     1121 		     then call syserr (CRASH, "pc$segmove: out of records during move");
     1122 		     cmep = addr (cmp -> cma (move_ptp -> core_ptwa (i).frame));
     1123 		     move_ptp -> core_ptwa (i).phm1 = "1"b;
     1124 						/* modify! */
     1125 						/* it will get hierarchy incrementalled, which is unfortunate */
     1126 		     segmove_deposit_list (segmove_records_used) = cme.devadd;
     1127 /**** + Debug
     1128*      call syserr (ANNOUNCE, "sgm: old cme devadd ^.3b", cme.devadd);
     1129**/
     1130 		     pageno_list (segmove_records_used) = i;
     1131 		     devadd = new_ptp -> mptwa (segmove_records_used).devadd;
     1132 						/* new record address + disk flag */
     1133 /**** + Debug
     1134*      call syserr (ANNOUNCE, "sgm: new devadd ^.3b", devadd);
     1135**/
     1136 		     new_ptp -> mptwa (segmove_records_used).devadd = segmove_new_addr_null_addr;
     1137 						/* order here is noncritical,
     1138*						   pc check tables will zonk all of these anyway */
     1139 		     devadd_null_flag = "1"b;		/* you're not on disk yet, buddy! */
     1140 		     cme.devadd = devadd;
     1141 		     cme.phm_hedge = "1"b;
     1142 /**** + Debug
     1143*      call syserr (ANNOUNCE, "sgm: new devadd in CME ^.3b", devadd);
     1144**/
     1145 		     cme.pin_counter = 0;		/* don't hold page any longer */
     1146 		     segmove_records_used = segmove_records_used + 1;
     1147 		end;
     1148 	end;
     1149 
     1150 	if sst.crash_test_segmove
     1151 	then call syserr (CRASH, "pc$segmove: crashing in segment mover.");
     1152 
     1153 	astep -> aste.pvtx = new_pvtx;		/* finish the swap */
     1154 	astep -> aste.vtocx = new_vtocx;		/* ... */
     1155 	astep -> aste.fmchanged = "1"b;		/* ... */
     1156 
     1157 	sst.segmove_astep = null;			/* dont fix addresses, pvtx, or vtocx.
     1158*						   and dont copy page table from old_addr_aste */
     1159 	sst.segmove_pvtx = 0;
     1160 	sst.segmove_vtocx = 0;
     1161 
     1162 /**** Now cleanup the old addresses, unbinding them from PTW's etc. */
     1163 
     1164 	begin;
     1165 	     declare pt		      (0:last_page) bit (36) based;
     1166 	     declare px		      fixed bin;
     1167 
     1168 	     declare 1 nptw		      aligned like l68_ptw;
     1169 	     declare ptwp		      pointer;
     1170 
     1171 	     unspec (nptw) = ""b;
     1172 	     nptw.add = segmove_old_addr_null_addr;	/* thats whats left */
     1173 	     do px = 0 to last_page;
     1174 		ptwp = addr (old_ptp -> pt (px));	/* all are core addresses, we are under PTL after verifying that */
     1175 		devadd = ptwp -> mptw.devadd;
     1176 		if (devadd_add_type & add_type.non_null) ^= ""b
     1177 		then do;
     1178 			if (devadd_add_type & add_type.core) = ""b
     1179 			then call syserr (CRASH, "pc$segmove: non-memory PTW in old_addr_aste.");
     1180 			old_ptp -> pt (px) = unspec (nptw);
     1181 		     end;
     1182 	     end;
     1183 	end;
     1184 	sst.segmove_old_addr_astep = null ();
     1185 
     1186 	call pmut$unlock_ptl (oldmask, ptwp);
     1187 
     1188 	if segmove_records_in_hand > segmove_records_used
     1189 	then /* some records on new pvt left over */
     1190 	     call page$deposit_list (new_pvtx, new_ptp, segmove_records_used + 1,
     1191 		segmove_records_in_hand - segmove_records_used, -1, null ());
     1192 
     1193 	call lock$unlock_fast (addr (sst.segmove_lock));
     1194 
     1195 	Address_Array = segmove_deposit_list;		/* out from under PTL */
     1196 	Pageno_List = pageno_list;			/* so we can copy to unwired stack_0 */
     1197 	Records = segmove_records_used;		/* starts at zero, used as index
     1198*						   to zero-based array, then bumped. */
     1199 
     1200 	return;
     1201 
     1202 SEGMOVE_ABORT_RETURN:
     1203 	call pmut$unlock_ptl (oldmask, ptwp);
     1204 	if segmove_records_in_hand > 0
     1205 	then call page$deposit_list (new_pvtx, new_ptp, 1, segmove_records_in_hand, -1, null ());
     1206 						/* Abandon all the records that we collected */
     1207 	if Code = 0
     1208 	then					/** we may have a specific code */
     1209 	     Code = error_table_$action_not_performed;
     1210 	call lock$unlock_fast (addr (sst.segmove_lock));
     1211 	return;
     1212 
     1213 
     1214 segmove_synch_page:
     1215      procedure (astep, cmep, pagex);
     1216 
     1217 	declare (astep, cmep)	 pointer;
     1218 	declare pagex		 fixed bin;
     1219 
     1220 
     1221 
     1222 /**** Call page control to write the page itself. If the synch_hold
     1223*      is legit, then .synch_hold will still be on when pwrite returns.
     1224*      If .synch_hold is off, the page is no longer held. */
     1225 
     1226 	call page$pwrite (astep, pagex);
     1227 
     1228 	if ^cmep -> cme.synch_held
     1229 	then do;
     1230 		sst.segmove_synch_disappeared = sst.segmove_synch_disappeared + 1;
     1231 		return;				/* page is fine, we can move it */
     1232 	     end;
     1233 
     1234 	Code = error_table_$synch_seg_segmove;
     1235 	go to SEGMOVE_ABORT_RETURN;
     1236      end segmove_synch_page;
     1237 
     1238 
     1239 
     1240 drive_ok:
     1241      proc (pvtx) returns (bit (1) aligned);		/* test drive state */
     1242 
     1243 	dcl     pvtx		 fixed bin;
     1244 
     1245 	return (^pvt_array (pvtx).device_inoperative);
     1246 
     1247      end drive_ok;
     1248 
     1249 wait_then_go_to:
     1250      procedure (lab);				/* quick internal proc to trace and wait for
     1251*						   page control events */
     1252 	dcl     lab		 label local;
     1253 
     1254 	if ind = 0
     1255 	then call syserr (CRASH, "pc: waiting for zero event.");
     1256 
     1257 	if pc_trace
     1258 	then call trace ("wait for i/o");
     1259 	call page$cam;				/* make sure any work done so far gets done */
     1260 	call page$pwait (ind);			/* wait for event */
     1261 	go to lab;
     1262 
     1263      end wait_then_go_to;
     1264 
     1265 /* format: off */
     1266  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
     1266 
     1267  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  2     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2     8*     Add the support for subvolumes
  2     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  2    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  2    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  2    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2    14*     Added inconsistent_dbm bit for determining the status of volume
  2    15*     dumper bit maps.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18      dcl	   pvt$array	      aligned external;
  2    19      dcl	   pvt$max_n_entries      fixed bin external;
  2    20 
  2    21      dcl	   pvt_arrayp	      ptr;
  2    22      dcl	   pvtep		      ptr;
  2    23 
  2    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  2    25 
  2    26      dcl	   1 pvte		      based (pvtep) aligned,
  2    27 
  2    28 	     2 pvid	      bit (36),		/* physical volume ID */
  2    29 
  2    30 	     2 lvid	      bit (36),		/* logical volume ID */
  2    31 
  2    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  2    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  2    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  2    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  2    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  2    37 	     2 pad3	      bit (2) unaligned,
  2    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  2    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  2    40 
  2    41 
  2    42 
  2    43 	     2 devname	      char (4),		/* device name */
  2    44 
  2    45 	     (2 device_type	      fixed bin (8),	/* device type */
  2    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  2    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  2    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  2    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  2    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  2    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  2    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  2    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  2    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  2    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  2    56 	     2 scav_check_address
  2    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  2    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  2    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  2    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  2    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  2    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  2    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  2    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  2    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  2    66 
  2    67 
  2    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  2    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  2    70 
  2    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  2    72 
  2    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  2    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  2    75 
  2    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  2    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  2    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  2    79 	     2 records_per_cyl    fixed bin,
  2    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  2    81 	     2 sv_name            char (2) aligned,
  2    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  2    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  2    84 
  2    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  2    86 	     2 pad2	      bit (18) unaligned,
  2    87 
  2    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  2    89 
  2    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  2    91 
  2    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  2    93 
  2    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  2    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  2    96 
  2    97 
  2    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  2    99 
  2   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  2   101 
  2   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  2   103 
  2   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  2   105 
  2   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  2   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  2   108 
  2   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  2   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  2   111 
  2   112 
  2   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  2   114 	   VOLMAP_ASYNC_READ      init (1),
  2   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  2   116 
  2   117 
  2   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1267 
     1268  /* BEGIN INCLUDE FILE cmp.incl.pl1 --- October 1982 */
  3     2 /* Note: This include file has an ALM counterpart NOT made with cif (for historical reasons). Keep it up to date */
  3     3 
  3     4 dcl  cmep ptr;					/* pointer to core map entry */
  3     5 
  3     6 dcl 1 cme based (cmep) aligned,			/* core map entry */
  3     7     2 fp bit (18) unaligned,				/* forward pointer to next entry */
  3     8     2 bp bit (18) unaligned,				/* backward pointer to previous entry */
  3     9 
  3    10     2 devadd bit (22) unaligned,			/* device address of page in the core block */
  3    11     2 pad5 bit (1) unaligned,
  3    12     2 synch_held bit (1) unaligned,			/* Page of synchronized seg held in memory */
  3    13     2 io bit (1) unaligned,				/* input/output indicator 1=output, 0=input */
  3    14     2 pad2 bit (1) unaligned,
  3    15     2 er bit (1) unaligned,				/* indicates error in previous IO activity */
  3    16     2 removing bit (1) unaligned,			/* core is being removed by reconfiguration */
  3    17     2 abs_w bit (1) unaligned,			/* absolute address must not be changed for page */
  3    18     2 abs_usable bit (1) unaligned,			/* page may be assigned with fixed absolute address */
  3    19     2 notify_requested bit (1) unaligned,		/* notify requested on I/O completion */
  3    20     2 pad3 bit (1) unaligned,
  3    21     2 phm_hedge bit (1) unaligned,			/* on => pc$flush_core ought write. */
  3    22     2 contr bit (3) unaligned,			/* controller in which core block is located */
  3    23 
  3    24     2 ptwp bit (18) unaligned,			/* pointer to page table word for the page */
  3    25     2 astep bit (18) unaligned,			/* relative AST entry pointer of page */
  3    26     2 pin_counter fixed bin (17) unaligned,		/* number of times to skip eviction */
  3    27     2 synch_page_entryp bit (18) unaligned;		/* relp to synch page entry */
  3    28 
  3    29 
  3    30 dcl 1 cma (0: 1) based aligned like cme;		/* Core map array */
  3    31 
  3    32 dcl 1 mcme based (cmep) aligned,			/* core map entry for extracting DID */
  3    33     2 pad bit (36) unaligned,
  3    34     2 record_no bit (18) unaligned,			/* record number of device */
  3    35     2 add_type bit (4) unaligned,			/* see add_type.incl.pl1 */
  3    36     2 flags bit (14) unal,
  3    37     2 pad1 bit (18) unal;
  3    38 
  3    39 
  3    40 /* END INCLUDE FILE  cmp.incl.pl1 */
     1268 
     1269  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  4     2 
  4     3 /* Template for an AST entry. Length = 12 words. */
  4     4 
  4     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  4     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  4     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  4     8 
  4     9 dcl  astep ptr;
  4    10 
  4    11 dcl 1 aste based (astep) aligned,
  4    12 
  4    13     (2 fp bit (18),					/* forward  used list rel pointer */
  4    14     2 bp bit (18),					/* backward used list rel pointer */
  4    15 
  4    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  4    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  4    18 
  4    19     2 strp bit (18),				/* rel pointer to process trailer */
  4    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  4    21 
  4    22     2 uid bit (36),					/* segment unique id */
  4    23 
  4    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  4    25     2 pvtx fixed bin (8),				/* physical volume table index */
  4    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    27 
  4    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  4    29     2 init bit (1),					/* used bit - insure 1 lap */
  4    30     2 gtus bit (1),					/* global transparent usage switch */
  4    31     2 gtms bit (1),					/* global transparent modified switch */
  4    32     2 hc bit (1),					/* hard core segment */
  4    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  4    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  4    35     2 write_access_on bit (1),			/* any sdw allows write access */
  4    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  4    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  4    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  4    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  4    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  4    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  4    42     2 pad1 bit (2),					/* OO */
  4    43     2 dius bit (1),					/* dumper in use switch */
  4    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  4    45     2 dmpr_pad bit (1),
  4    46     2 ehs bit (1),					/* entry hold switch */
  4    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  4    48     2 dirsw bit (1),				/* directory switch */
  4    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  4    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  4    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  4    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  4    53 
  4    54     2 dtu bit (36),					/* date and time segment last used */
  4    55 
  4    56     2 dtm bit (36),					/* date and time segment last modified */
  4    57 
  4    58 
  4    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  4    60 
  4    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  4    62 
  4    63     2 csl bit (9),					/* current segment length in 1024 words units */
  4    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  4    65     2 fms bit (1),					/* file modified switch */
  4    66     2 npfs bit (1),					/* no page fault switch */
  4    67     2 gtpd bit (1),					/* global transparent paging device switch */
  4    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  4    69     2 per_process bit (1),				/* use master quota for this entry */
  4    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  4    71     2 pad2 bit (2),
  4    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  4    73     2 np bit (9),					/* number of pages in core */
  4    74 
  4    75 
  4    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  4    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  4    78     2 damaged bit (1),				/* PC declared segment unusable */
  4    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  4    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  4    81     2 pad3 bit (6),					/* OOOOOOOOO */
  4    82     2 ptsi bit (2),					/* page table size index */
  4    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  4    84 
  4    85 
  4    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  4    87 
  4    88 
  4    89 dcl 1 aste_part aligned based (astep),
  4    90 
  4    91     2 one bit (36) unaligned,				/* fp and bp */
  4    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  4    93     2 three bit (8) unaligned;			/* ptsi and marker */
  4    94 
  4    95 
  4    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  4    97     2 pad1 bit (8*36),
  4    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  4    99     2 pad2 bit (3*36);
  4   100 
  4   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
     1269 
     1270  
  5     2 /*   BEGIN INCLUDE FILE fm.incl.pl1     4/08/75     B. Greenberg, for NSS */
  5     3 
  5     4 /* This ffle defines the format of a file map as it appears in a VTOC */
  5     5 
  5     6 dcl  fmp ptr;
  5     7 
  5     8 dcl  1 file_map aligned based (fmp),			/* Outer level file map structure */
  5     9        2 fm (0 : 255) bit (18) unaligned;		/* Address components of file map */
  5    10 
  5    11 /*   END INCLUDE FILE fm.incl.pl1 */
     1270 
     1271  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  6     2 /* Added segmove values, Benson Margulies, 84-01 */
  6     3 
  6     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  6     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  6     6      get_aste_null_addr init			("3770110"b3),
  6     7      make_sdw_null_addr init			("3770120"b3),
  6     8      put_aste_null_addr init			("3770130"b3),
  6     9      page_bad_pd_null_addr init		("3770150"b3),
  6    10      list_deposit_null_addr init		("3770160"b3),
  6    11      get_file_map_null_addr init		("3770170"b3),
  6    12      fill_page_table_null_addr init		("3770200"b3),
  6    13      init_sst_null_addr init			("3770210"b3),
  6    14      get_file_map_vt_null_addr init		("3770220"b3),
  6    15      unprotected_null_addr init		("3770230"b3),
  6    16      page_bad_null_addr init			("3770240"b3),
  6    17      page_problem_null_addr init		("3770250"b3),
  6    18      page_parity_null_addr init		("3770260"b3),
  6    19      page_devparity_null_addr init		("3770270"b3),
  6    20      segmove_old_addr_null_addr init              ("3770300"b3),
  6    21      segmove_new_addr_null_addr init		("3770310"b3),
  6    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  6    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  6    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  6    25 
  6    26 dcl (create_vtoce_null_addr init		("777777"b3),
  6    27      update_vtoce_null_addr init		("777776"b3),
  6    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  6    29      truncate_vtoce_null_addr init		("777002"b3),
  6    30      pv_salv_null_addr init			("777004"b3),
  6    31      pv_scav_null_addr init			("777006"b3),
  6    32      volume_reloader_null_addr init		("777774"b3),
  6    33      volume_retriever_null_addr init		("777773"b3),
  6    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  6    35 
  6    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
     1271 
     1272  
  7     2 	/* BEGIN INCLUDE FILE add_type.incl.pl1 */
  7     3 	/* 02/26/75 by Bernard S. Greenberg */
  7     4 
  7     5 	/* This file provides a structure for checking
  7     6*		PTW/CME address type fields in PL/I */
  7     7 
  7     8 dcl 1 add_type unaligned static internal,
  7     9 	2 core bit (4) init ("1000"b),		/* in core- S/B only in PTW */
  7    10 	2 disk bit (4) init ("0100"b),		/* Disk address */
  7    11 	2 pd   bit (4) init ("0010"b),		/* Paging Device */
  7    12 	2 reserved bit (4) init ("0001"b),		/* Reserved */
  7    13 	2 non_null bit (4) init ("1111"b);		/* Not null address */
  7    14 
  7    15 dcl 1 badd_type unaligned based,
  7    16     2 (core, disk, pd, reserved) bit (1) unaligned;
  7    17 
  7    18 	/* END INCLUDE FILE add_type.incl.pl1 */
     1272 
     1273  /* BEGIN INCLUDE FILE ... ptw.incl.pl1 ... MACRO ... For ADP conversion, 02/26/81 */
     1274 /* Added core_ptwa, Benson Margulies, 84-01 */
     1275 
     1276 dcl  ptp pointer;
     1277 
     1278 
     1279 
     1280      /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  8     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  8     3 
  8     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  8     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  8     6     2 pad1 bit (4) unaligned,
  8     7     2 flags unaligned like l68_ptw_flags;
  8     8 
  8     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  8    10     2 add bit (18) unaligned,
  8    11     2 flags like l68_ptw_flags unaligned;
  8    12 
  8    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  8    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  8    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  8    16 
  8    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  8    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  8    19     2 first bit (1),				/* the page has not yet been written out */
  8    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  8    21 
  8    22     2 pad1 bit (1),
  8    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  8    24     2 phu bit (1),					/* page has been used bit */
  8    25 
  8    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  8    27     2 nypd bit (1), 				/* must be moved to paging device */
  8    28     2 phm bit (1),					/* page has been modified bit */
  8    29 
  8    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  8    31     2 wired bit (1),				/* page is to remain in core */
  8    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  8    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  8    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  8    35 
  8    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
     1280 
     1281 
     1282      dcl 1 ptw aligned based (ptp) like l68_ptw;
     1283      dcl 1 ptw_flags unaligned like l68_ptw_flags based;
     1284 
     1285      dcl 1 core_ptw aligned based (ptp) like l68_core_ptw;
     1286      dcl 1 special_ptw aligned based (ptp) like l68_special_ptw;
     1287      dcl 1 real_disk_ptw aligned based (ptp) like l68_real_disk_ptw;
     1288      dcl 1 null_disk_ptw aligned based (ptp) like l68_null_disk_ptw;
     1289 
     1290 
     1291 
     1292 /* Arrays and overlays for various purposes */
     1293 
     1294 dcl 1 ptwa (0:255) based (ptp) aligned like ptw;		/* page table */
     1295 dcl 1 core_ptwa (0:255) based (ptp) aligned like core_ptw;
     1296 dcl  ptwa_bits (0:255) based (ptp) bit (36) aligned;	/* page table array as raw bits */
     1297 
     1298 dcl 1 mptw based (ptp) aligned,			/* page table word while page is not in core */
     1299     2 devadd bit (22) unaligned,			/* device address where page resides */
     1300     2 pad bit (14) unaligned;
     1301 
     1302 dcl 1 mptwa (0 : 1) based (ptp) aligned,		/* page table while pages are not in core */
     1303     2 devadd bit (22) unaligned,			/* device address where page resides */
     1304     2 pad bit (14) unaligned;
     1305 
     1306 dcl 1 atptw based (ptp) aligned,			/* PL/I has problems on overlay-def based */
     1307     2 add bit (18) unal,
     1308     2 (core, disk, pd, reserved) bit (1) unal,		/* address types */
     1309     2 pad bit (14) unal;
     1310 
     1311 dcl 1 atptwa (0:255) based (ptp) aligned like atptw;
     1312 
     1313 /* END INCLUDE FILE ... ptw.incl.pl1 */
     1314 
     1315  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  9     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  9     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  9     4 
  9     5 /* This include file has an ALM version.  Keep 'em in sync! */
  9     6 
  9     7 dcl (
  9     8 
  9     9 /* The following constants define the message action codes.  This indicates
  9    10*how a message is to be handled.  */
  9    11 
  9    12      SYSERR_CRASH_SYSTEM	init (1),			
  9    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  9    14 
  9    15      SYSERR_TERMINATE_PROCESS	init (2),
  9    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  9    17 
  9    18      SYSERR_PRINT_WITH_ALARM	init (3),
  9    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  9    20 
  9    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  9    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  9    23 
  9    24      SYSERR_LOG_OR_PRINT	init (4),
  9    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  9    26 
  9    27      SYSERR_LOG_OR_DISCARD	init (5),
  9    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  9    29 
  9    30 
  9    31 /* The following constants are added to the normal severities to indicate
  9    32*different sorting classes of messages.  */
  9    33 
  9    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  9    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  9    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  9    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  9    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  9    39 	) fixed bin internal static options (constant);
  9    40 
  9    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     1315 
     1316 
     1317 /* BEGIN MESSAGE DOCUMENTATION
     1318*
     1319*   Message:
     1320*   pc: unprotected address DDDDD in DSKX_NN VTOCX
     1321*
     1322*   S:	$info
     1323*
     1324*   T:	$run
     1325*
     1326*   M:	The disk address DDDDD
     1327*   is not marked as protected
     1328*   in the record usage map for the volume mounted on DSKX_NN.
     1329*   This condition has been discovered
     1330*   while activating the segment with VTOC index VTOCX.
     1331*   The segment's damaged switch is turned on, and a page of zeros will
     1332*   replace the bad address. This condition may be symptomatic of disk
     1333*   or other hardware failure.
     1334*
     1335*   A:	$inform
     1336*
     1337*
     1338*   Message:
     1339*   pc: truncate_deposit_all call on VTOCed seg at ASTEP
     1340*
     1341*   S:	$crash
     1342*
     1343*   T:	$run
     1344*
     1345*   M:	A call to pc$truncate_deposit_all
     1346*   has been made on a segment for which this operation is not allowed.
     1347*   The AST entry at ASTEP should have a zero unique ID
     1348*   but it does not.
     1349*   $err
     1350*   $crashes
     1351*
     1352*   A:	$recover
     1353*
     1354*
     1355*   END MESSAGE DOCUMENTATION */
     1356 
     1357      end pc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  1026.8  pc.pl1                            >spec>install>1111>pc.pl1
1266         1    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
1267         2    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
1268         3    11/23/82  0953.7  cmp.incl.pl1                      >ldd>include>cmp.incl.pl1
1269         4    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
1270         5    04/29/76  1050.1  fm.incl.pl1                       >ldd>include>fm.incl.pl1
1271         6    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
1272         7    09/29/77  1502.7  add_type.incl.pl1                 >ldd>include>add_type.incl.pl1
1280         8    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
1315         9    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Address_Array                          based           bit(22)                  array dcl 124 set ref 587* 819* 1195*
Astep                                  parameter       pointer                  dcl 67 ref 181 191 236 252 279 283 329 336 345 457
                                                                                  464 470 611 614 620 624 779 784 851 855
CRASH                           000032 constant        fixed bin(17,0)          initial dcl 9-7 set ref 1042* 1109* 1120* 1150*
                                                                                  1178* 1254*
Code                                   parameter       fixed bin(35,0)          dcl 83 set ref 921 939* 982* 1207 1207* 1234*
Copy_Astep                             parameter       pointer                  dcl 68 ref 457 464 580
Deposit_Count                          parameter       fixed bin(17,0)          dcl 72 set ref 457 464 591*
Devadd_Array                           based           structure                array level 1 dcl 128
File_Mapp                              parameter       pointer                  dcl 69 ref 279 284 457 464 474
First_Page                             parameter       fixed bin(17,0)          dcl 73 ref 329 336 348 779 785
Last_Page                              parameter       fixed bin(17,0)          dcl 74 ref 779 786
Listp                                  parameter       pointer                  dcl 70 set ref 457 464 477 587 779 819 827 841 844*
                                                                                  921 1195
Move_Astep                             parameter       pointer                  dcl 80 ref 921 924
N_In_Core                              parameter       fixed bin(17,0)          dcl 76 set ref 336 453*
N_Pages                                parameter       fixed bin(17,0)          dcl 75 ref 279 286
New_Astep                              parameter       pointer                  dcl 82 ref 870 877 921 926
New_Pvtx                               parameter       fixed bin(17,0)          dcl 85 ref 921 927
New_Vtocx                              parameter       fixed bin(17,0)          dcl 84 ref 921 928
Old_Astep                              parameter       pointer                  dcl 81 ref 870 876 921 925
Pageno_List                            based           fixed bin(17,0)          array dcl 131 set ref 588* 820* 1196*
Pageno_Listp                           parameter       pointer                  dcl 71 set ref 457 464 480 588 779 787 820 827 844*
                                                                                  921 1196
Pvtx                                   parameter       fixed bin(17,0)          dcl 78 ref 827 832
Records                                parameter       fixed bin(17,0)          dcl 77 set ref 779 824* 827 831 921 1197*
Vtocx                                  parameter       fixed bin(17,0)          dcl 79 set ref 827 844*
add                                    based           bit(18)                  level 2 in structure "ptw" packed packed unaligned
                                                                                  dcl 1282 in procedure "pc" set ref 271*
add                             002273 automatic       bit(18)                  level 2 in structure "nptw" packed packed unaligned
                                                                                  dcl 1168 in begin block on line 1164 set ref 1172*
add_to_dmpr_map                 000111 automatic       bit(1)                   packed unaligned dcl 94 set ref 472* 550* 592
add_type                  0(18)        based           bit(4)                   array level 2 in structure "Devadd_Array" packed
                                                                                  packed unaligned dcl 128 in procedure "pc" set ref
                                                                                  841*
add_type                        000000 constant        structure                level 1 packed packed unaligned dcl 7-8 in procedure
                                                                                  "pc"
add_type                  0(18)        based           bit(4)                   array level 3 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc" set ref 1042
                                                                                  1042*
addr                                                   builtin function         dcl 178 ref 190 251 287 342 380 396 408 473 484 490
                                                                                  508 516 615 625 697 699 709 788 805 864 864 866
                                                                                  866 874 891 894 899 899 929 945 945 1012 1036 1122
                                                                                  1174 1193 1193 1210 1210
addrel                                                 builtin function         dcl 178 ref 200 223 255 262 269 274 290 346 487 626
                                                                                  789 883 884
addwordno                                              builtin function         dcl 178 ref 931 933 935
aste                                   based           structure                level 1 dcl 4-11 set ref 557 580*
aste_part                              based           structure                level 1 dcl 4-89
astep                                  parameter       pointer                  dcl 1217 in procedure "segmove_synch_page" set ref
                                                                                  1214 1226*
astep                     2(18)        based           bit(18)                  level 2 in structure "cme" packed packed unaligned
                                                                                  dcl 3-6 in procedure "pc" set ref 714 897*
astep                           002212 automatic       pointer                  dcl 4-9 in procedure "pc" set ref 191* 198* 200 203
                                                                                  209* 214* 252* 255 256 266* 269 270 283* 285 290
                                                                                  307 312 315* 345* 346 349 353* 401* 423 424 424
                                                                                  424* 427 427 427 427 427 429 429 442 447 448 470*
                                                                                  476 477 487 550 552 552 552 552 557 561 566 566
                                                                                  569 592 592 592 592 592 592 592 597* 614* 624* 626
                                                                                  628 633 655 658 714* 715 721 724 731* 735 740 743*
                                                                                  745* 784* 789 795 855* 857 857* 859* 861 864* 866
                                                                                  924* 935 937 943 955 1021* 1038 1038* 1100 1101
                                                                                  1102 1109 1153 1154 1155
astep1                          002270 automatic       pointer                  dcl 653 set ref 658* 659 660 661 662* 662 662
astsize                  33            based           fixed bin(17,0)          level 2 dcl 1-9 ref 200 255 269 290 346 487 626 721
                                                                                  789 883 884 931 933 935
atptw                                  based           structure                level 1 dcl 1306
atptwa                                 based           structure                array level 1 dcl 1311
badd_type                              based           structure                level 1 packed packed unaligned dcl 7-15
bit                                                    builtin function         dcl 178 ref 312 429 442 552 576 577 578 661
cleanup_count           267            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 195* 195
cleanup_real_time       270            based           fixed bin(71,0)          level 2 dcl 1-9 set ref 229* 229
cleanup_start_time              002176 automatic       fixed bin(71,0)          dcl 145 set ref 193* 229
clock                                                  builtin function         dcl 178 ref 193 229 543 657
cma                                    based           structure                array level 1 dcl 3-30 set ref 396 516 709 894 1036
                                                                                  1122
cme                                    based           structure                level 1 dcl 3-6
cmep                            002210 automatic       pointer                  dcl 3-4 in procedure "pc" set ref 396* 398 516* 517
                                                                                  518 709* 711 713 714 723 724 735 894* 896 897 898
                                                                                  899 1036* 1037 1038* 1122* 1126 1140 1141 1145
cmep                                   parameter       pointer                  dcl 1217 in procedure "segmove_synch_page" ref 1214
                                                                                  1228
cmp                      54            based           pointer                  level 2 in structure "sst" dcl 1-9 in procedure "pc"
                                                                                  ref 192 347 475 700 875 930
cmp                             000120 automatic       pointer                  dcl 100 in procedure "pc" set ref 192* 347* 396 475*
                                                                                  516 700* 709 753 875* 894 930* 1036 1122
code                            000155 automatic       fixed bin(35,0)          dcl 115 set ref 965* 970 971* 980 982
copy_aste                       000161 automatic       structure                level 1 dcl 120 set ref 557* 580
core                      0(18)        based           bit(1)                   array level 2 in structure "atptwa" packed packed
                                                                                  unaligned dcl 1311 in procedure "pc" ref 388 436
                                                                                  1032
core                            000000 constant        bit(4)                   initial level 2 in structure "add_type" packed
                                                                                  packed unaligned dcl 7-8 in procedure "pc" ref
                                                                                  1118 1178
core                      0(18)        based           bit(1)                   level 2 in structure "atptw" packed packed unaligned
                                                                                  dcl 1306 in procedure "pc" ref 204 257 537 892
core                                   based           bit(1)                   level 2 in structure "devadd_bits" packed packed
                                                                                  unaligned dcl 142 in procedure "pc" ref 508
core_ptw                               based           structure                level 1 dcl 1285
core_ptwa                              based           structure                array level 1 dcl 1295
count                           000132 automatic       bit(1)                   packed unaligned dcl 105 set ref 384* 402* 412* 416
crash_test_segmove      571            based           bit(1)                   level 2 dcl 1-9 ref 1150
csl                      12            based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 4-11 in procedure "pc" set ref 442* 633
csl                      12     000161 automatic       bit(9)                   level 2 in structure "copy_aste" packed packed
                                                                                  unaligned dcl 120 in procedure "pc" set ref 578*
curtime                         000124 automatic       fixed bin(71,0)          dcl 101 set ref 543* 552 657* 661
damaged                  13(19)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  447*
dbm_man$set_incr                000016 constant        entry                    external dcl 152 ref 592
ddnp                     12(15)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 477
deposit_list                    000175 automatic       bit(22)                  array dcl 125 set ref 495* 587 808* 819 864 864 866
                                                                                  866
devadd                                 based           bit(22)                  array level 2 in structure "mptwa" packed packed
                                                                                  unaligned dcl 1302 in procedure "pc" set ref 310*
                                                                                  389 415* 435 800 813* 890* 910* 1113 1131 1136*
devadd                    1            based           bit(22)                  level 2 in structure "cme" packed packed unaligned
                                                                                  dcl 3-6 in procedure "pc" set ref 398 517 723 898
                                                                                  1126 1140*
devadd                                 based           bit(22)                  level 2 in structure "mptw" packed packed unaligned
                                                                                  dcl 1298 in procedure "pc" set ref 489 502* 903
                                                                                  1175
devadd                          002175 automatic       bit(22)                  packed unaligned dcl 134 in procedure "pc" set ref
                                                                                  292* 293 293 295* 295 296* 296 299* 299 302 389*
                                                                                  398* 408 408 408 408 411* 411 415 435* 438 438 438
                                                                                  438 489* 490 490 492 492 494* 494 495 501* 502 505
                                                                                  505 505* 508 508 517* 518 518 518* 522 522 522*
                                                                                  526* 527* 527 530* 530 530 530 533 533 541 723*
                                                                                  745 745 800* 805 805 805 805 808 813* 898* 903*
                                                                                  1113* 1118 1118 1131* 1139* 1139 1140 1175* 1176
                                                                                  1176 1178 1178
devadd_add_type                        defined         bit(4)                   packed unaligned dcl 138 set ref 296* 299* 408 438
                                                                                  490 508 530 805 1118 1176 1178
devadd_bits                            based           structure                level 1 packed packed unaligned dcl 142
devadd_null_flag                       defined         bit(1)                   packed unaligned dcl 139 set ref 293 295* 408 411*
                                                                                  438 492 494* 505 518 522 527* 530* 533 745 805
                                                                                  1139*
device_inoperative        4(25)        based           bit(1)                   array level 2 packed packed unaligned dcl 2-24 ref
                                                                                  1245
dirsw                     5(21)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 424
disk                      0(04) 000000 constant        bit(4)                   initial level 2 in structure "add_type" packed
                                                                                  packed unaligned dcl 7-8 in procedure "pc" ref 299
                                                                                  841
disk                      0(19)        based           bit(1)                   level 2 in structure "atptw" packed packed unaligned
                                                                                  dcl 1306 in procedure "pc" ref 271
disk                      0(19)        based           bit(1)                   array level 2 in structure "atptwa" packed packed
                                                                                  unaligned dcl 1311 in procedure "pc" ref 1018
disk                      0(01)        based           bit(1)                   level 2 in structure "devadd_bits" packed packed
                                                                                  unaligned dcl 142 in procedure "pc" ref 408 490
                                                                                  805
divide                                                 builtin function         dcl 178 ref 701
dtm                       7            based           bit(36)                  level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  661*
dtu                       6            based           bit(36)                  level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  552*
dumper                          000107 automatic       bit(1)                   packed unaligned dcl 92 set ref 461* 469* 505 522
                                                                                  564
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 148 ref 1207
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 147 ref 939
error_table_$synch_seg_segmove  000014 external static fixed bin(35,0)          dcl 150 ref 1234
file_map                               based           structure                level 1 dcl 5-8
fill_page_table_null_addr              constant        bit(22)                  initial dcl 6-4 ref 310
first_core_block        220            based           fixed bin(17,0)          level 2 dcl 1-9 ref 705
first_page                      000101 automatic       fixed bin(17,0)          dcl 87 set ref 348* 377 434 445 785* 798
fixed                                                  builtin function         dcl 178 ref 203 218 256 270 307 312 349 380 429 429
                                                                                  442 476 552 576 577 578 592 592 592 592 633 661
                                                                                  717 721 721 753 795 885 899 899 906 906 943 955
                                                                                  1109
flags                     0(18)        based           structure                level 2 in structure "ptw" packed packed unaligned
                                                                                  dcl 1282 in procedure "pc"
flags                     0(18)        based           structure                array level 2 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc"
flags                     0(18)        based           structure                array level 2 in structure "core_ptwa" packed packed
                                                                                  unaligned dcl 1295 in procedure "pc"
flushing_for_pleasure           002200 automatic       bit(1)                   packed unaligned dcl 685 set ref 689* 695* 701 724
                                                                                  745 756 766 775
fm                                     based           bit(18)                  array level 2 packed packed unaligned dcl 5-8 set
                                                                                  ref 292 583*
fm_damaged                5(12)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  448*
fmchanged                12(09)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  423* 566 569* 1155*
fmchanged1               13(18)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref
                                                                                  566*
fmp                             002214 automatic       pointer                  dcl 5-6 set ref 284* 292 474* 583 597*
fms                      12(10)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 550
                                                                                  561* 660*
frame                                  based           fixed bin(14,0)          level 2 in structure "core_ptw" packed packed
                                                                                  unsigned unaligned dcl 1285 in procedure "pc" ref
                                                                                  516 894
frame                                  based           fixed bin(14,0)          array level 2 in structure "core_ptwa" packed packed
                                                                                  unsigned unaligned dcl 1295 in procedure "pc" ref
                                                                                  396 1036 1122
from_core                       000131 automatic       bit(1)                   packed unaligned dcl 105 set ref 388* 393
fword                                  based           fixed bin(17,0)          array dcl 122 set ref 316* 316* 316* 316* 321* 321*
                                                                                  321* 321* 321* 321* 321* 321* 362* 362* 362* 362*
                                                                                  367* 367* 367* 367* 367* 367* 367* 367* 598* 598*
                                                                                  598* 598* 603* 603* 603* 603* 603* 603* 603* 603*
get_file_map_dumper_non_null_addr      constant        bit(22)                  initial dcl 6-4 ref 522
get_file_map_vt_null_addr              constant        bit(22)                  initial dcl 6-4 ref 501 505 518 526
getfmap_csl                     000112 automatic       fixed bin(9,0)           dcl 95 set ref 478* 536* 578
getfmap_np                      000113 automatic       fixed bin(9,0)           dcl 95 set ref 478* 537* 537 576
getfmap_nrec                    000114 automatic       fixed bin(9,0)           dcl 95 set ref 478* 535* 535 577
gtms                      5(03)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 655
gtus                      5(02)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 552
half_line_of_words                     defined         char(11)                 packed unaligned dcl 176 set ref 316* 362* 598*
hc_part                   5(11)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 715
hc_sdw                    5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 592
                                                                                  861
hedge_writes            522            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 732* 732
hedonism                        002201 automatic       fixed bin(17,0)          dcl 686 set ref 701* 761
i                               000103 automatic       fixed bin(17,0)          dcl 87 set ref 203* 209* 214* 256* 270* 291* 292
                                                                                  302* 307* 309 310* 320* 321 321 321 321 321 321
                                                                                  321 321* 366* 367 367 367 367 367 367 367 367*
                                                                                  377* 378 380 388 389 396 399 401* 415* 434* 435
                                                                                  436* 442 486* 487 497 536 541* 582* 583 583* 586*
                                                                                  587 587 588 588* 602* 603 603 603 603 603 603 603
                                                                                  603* 633* 634 637 638* 705* 709 753* 798* 800 810
                                                                                  813* 818* 819 819 820 820* 840* 841* 885* 886 886
                                                                                  889 890 891 899 899* 906* 909 910* 1006* 1008 1012
                                                                                  1018 1021* 1032 1036 1038 1038 1038* 1042 1042*
                                                                                  1112* 1113 1122 1123 1130*
ind                             000104 automatic       fixed bin(35,0)          dcl 89 set ref 202* 218* 226 374* 380* 708* 717*
                                                                                  753* 756 775 971* 976 1012* 1025* 1254 1260*
infp                      1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-11 set ref 552
io                        1(24)        based           bit(1)                   level 2 packed packed unaligned dcl 3-6 ref 518
j                               000116 automatic       fixed bin(17,0)          dcl 98 set ref 485* 495 497 500* 500 586 591
l68_core_ptw                           based           structure                level 1 dcl 8-4
l68_null_disk_ptw                      based           structure                level 1 dcl 8-15
l68_ptw                                based           structure                level 1 dcl 8-9
l68_ptw_flags                          based           structure                level 1 packed packed unaligned dcl 8-17
l68_real_disk_ptw                      based           structure                level 1 dcl 8-14
l68_special_ptw                        based           structure                level 1 dcl 8-13
lab                                    parameter       label variable           local dcl 1252 ref 1249 1261
last_core_block         221            based           fixed bin(17,0)          level 2 dcl 1-9 ref 705
last_page                       000102 automatic       fixed bin(17,0)          dcl 87 set ref 286* 291 307 316 320 349* 362 366 377
                                                                                  434 476* 486 582 598 602 786* 795 795* 798 943*
                                                                                  1006 1096 1112 1173
line_of_words                   000001 constant        char(23)                 initial packed unaligned dcl 175 set ref 316 316
                                                                                  321* 362 362 367* 598 598 603*
list_deposit_null_addr                 constant        bit(22)                  initial dcl 6-4 ref 813
lock$lock_fast                  000020 constant        entry                    external dcl 153 ref 945
lock$unlock_fast                000022 constant        entry                    external dcl 153 ref 1193 1210
max                                                    builtin function         dcl 178 ref 1055
min                                                    builtin function         dcl 178 ref 434
move_ptp                        000144 automatic       pointer                  dcl 106 set ref 935* 1008 1012 1018 1032 1036 1038
                                                                                  1038 1042 1042 1096 1113 1122 1123
move_tries                      000160 automatic       fixed bin(17,0)          dcl 118 set ref 963* 1001* 1001 1002 1055
mptw                                   based           structure                level 1 dcl 1298
mptwa                                  based           structure                array level 1 dcl 1302
n_in_core                       000126 automatic       fixed bin(18,0)          dcl 102 set ref 373* 395* 395 453
n_io_started                    000127 automatic       fixed bin(17,0)          dcl 103 set ref 1005* 1014* 1014 1015 1026* 1026
                                                                                  1027 1052
new_astep                       000136 automatic       pointer                  dcl 106 set ref 877* 880* 884 897 906 915 926* 931
                                                                                  937 937 946
new_ptp                         000142 automatic       pointer                  dcl 106 set ref 884* 886 891 909 910 931* 971* 1131
                                                                                  1136 1188* 1204*
new_pvtx                        000156 automatic       fixed bin(17,0)          dcl 116 set ref 927* 971* 1153 1188* 1204*
new_vtocx                       000157 automatic       fixed bin(17,0)          dcl 117 set ref 928* 1154
nid                       5(17)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 592
no_deposit_no_return            000150 automatic       bit(1)                   dcl 109 set ref 477* 492
non_null                  0(16) 000000 constant        bit(4)                   initial level 2 packed packed unaligned dcl 7-8 ref
                                                                                  438 1176
notify_requested          1(30)        based           bit(1)                   level 2 packed packed unaligned dcl 3-6 ref 899
np                       12(27)        based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 4-11 in procedure "pc" set ref 552 628 1109
np                       12(27) 000161 automatic       bit(9)                   level 2 in structure "copy_aste" packed packed
                                                                                  unaligned dcl 120 in procedure "pc" set ref 576*
nptw                            002273 automatic       structure                level 1 dcl 1168 set ref 1171* 1180
nqsw                      5(20)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 424
null                                                   builtin function         dcl 178 ref 477 480 787 864 864 866 866 1157 1184
                                                                                  1188 1188 1204 1204
null_devadd_not_in_core                constant        bit(36)                  initial dcl 173 ref 302 309 889 909
offed_sw                        000115 automatic       bit(1)                   packed unaligned dcl 97 set ref 479* 514* 544 630*
                                                                                  636* 642
old_astep                       000134 automatic       pointer                  dcl 106 set ref 876* 880* 883 885 906 915 925* 933
                                                                                  937 1091
old_ptp                         000140 automatic       pointer                  dcl 106 set ref 883* 886 889 890 899 899 933* 1096
                                                                                  1174 1180
oldmask                         000146 automatic       fixed bin(71,0)          dcl 108 set ref 196* 232* 254* 264* 268* 276* 358*
                                                                                  452* 482* 571* 616* 704* 765* 768* 793* 817* 878*
                                                                                  949* 1186* 1202*
os                        0(32)        based           bit(1)                   level 3 in structure "ptw" packed packed unaligned
                                                                                  dcl 1282 in procedure "pc" ref 207 218 257 518 717
                                                                                  745 753
os                        0(32)        based           bit(1)                   array level 3 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc" set ref 378
                                                                                  1008
page$cam                        000024 constant        entry                    external dcl 157 ref 451 547 645 1259
page$deposit_list               000026 constant        entry                    external dcl 158 ref 844 866 1188 1204
page$pcleanup                   000030 constant        entry                    external dcl 159 ref 209 401 745
page$pread                      000032 constant        entry                    external dcl 160 ref 1021
page$pwait                      000034 constant        entry                    external dcl 161 ref 1260
page$pwrite                     000036 constant        entry                    external dcl 162 ref 214 731 743 1226
page$withdraw_list              000040 constant        entry                    external dcl 163 ref 971
pageno                          000130 automatic       fixed bin(17,0)          dcl 104 set ref 721* 731* 743* 745*
pageno_list                     001575 automatic       fixed bin(17,0)          array dcl 132 set ref 497* 588 810* 820 1130* 1196
pagex                                  parameter       fixed bin(17,0)          dcl 1218 set ref 1214 1226*
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-11 set ref 427
                                                                                  427 427 662
pc_move_page_table_1_null_addr         constant        bit(22)                  initial dcl 6-4 ref 890
pc_move_page_table_2_null_addr         constant        bit(22)                  initial dcl 6-4 ref 910
pc_trace                564(34)        based           bit(1)                   level 3 packed packed unaligned dcl 1-9 ref 198 313
                                                                                  353 360 595 880 1257
per_process              12(14)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 592
                                                                                  735
phm                       0(29)        based           bit(1)                   array level 3 in structure "core_ptwa" packed packed
                                                                                  unaligned dcl 1295 in procedure "pc" ref 1038
phm                       0(29)        based           bit(1)                   array level 3 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc" set ref 634
                                                                                  638*
phm                       0(29)        based           bit(1)                   level 3 in structure "ptw" packed packed unaligned
                                                                                  dcl 1282 in procedure "pc" set ref 209 257* 510
                                                                                  513* 724 740* 745
phm1                      0(27)        based           bit(1)                   level 3 in structure "ptw" packed packed unaligned
                                                                                  dcl 1282 in procedure "pc" set ref 209 257* 512*
                                                                                  518 724 740* 745
phm1                      0(27)        based           bit(1)                   array level 3 in structure "core_ptwa" packed packed
                                                                                  unaligned dcl 1295 in procedure "pc" set ref 1038
                                                                                  1123*
phm1                      0(27)        based           bit(1)                   array level 3 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc" set ref 637*
phm_hedge                 1(32)        based           bit(1)                   level 2 packed packed unaligned dcl 3-6 set ref 724
                                                                                  735* 1141*
pin_counter               3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-6 set ref
                                                                                  1037* 1145*
pleasure_flush_count            002202 automatic       fixed bin(17,0)          dcl 687 set ref 703* 733* 733 761 763*
pmut$lock_ptl                   000042 constant        entry                    external dcl 164 ref 196 254 268 358 482 616 704 768
                                                                                  793 878 949
pmut$unlock_ptl                 000044 constant        entry                    external dcl 165 ref 232 264 276 452 571 765 817
                                                                                  1186 1202
pt                                     based           bit(36)                  array packed unaligned dcl 1165
                                                                                  in begin block on line 1164 set ref 1174 1180*
pt                                     based           bit(36)                  array dcl 1095 in begin block on line 1094 set ref
                                                                                  1096* 1096
ptp                             002216 automatic       pointer                  dcl 1276 set ref 200* 204 207 209 209 218 218 223*
                                                                                  223 223 255* 257 257 257 257 262* 262 262 269* 271
                                                                                  271 274* 274 274 290* 302 309 310 316 316 316 316
                                                                                  321 321 321 321 321 321 321 321 346* 362 362 362
                                                                                  362 367 367 367 367 367 367 367 367 378 380 388
                                                                                  389 396 399 415 435 436 487* 489 502 510 512 513
                                                                                  516 518 518 537 598 598 598 598 603 603 603 603
                                                                                  603 603 603 603 626* 634 637 638 713* 717 717 721
                                                                                  724 724 740 740 745 745 745 753 789* 800 813 891*
                                                                                  892 894 896 903
ptr                                                    builtin function         dcl 178 ref 427 427 662 713 714
pts                      40            based           fixed bin(17,0)          array level 2 dcl 1-9 ref 203 256 270 307 349 476
                                                                                  795 885 906 906 943
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 4-11 set ref 203
                                                                                  256 270 307 349 476 795 885 906 906 937 937 937
                                                                                  937 943
ptw                                    based           structure                level 1 dcl 1282 set ref 223 262 274
ptwa                                   based           structure                array level 1 dcl 1294 set ref 380 891 899 899 1012
ptwa_bits                              based           bit(36)                  array dcl 1296 set ref 302* 309* 886* 886 889* 909*
ptwp                            000122 automatic       pointer                  dcl 100 in procedure "pc" set ref 196* 232* 254*
                                                                                  264* 268* 276* 358* 452* 482* 571* 616* 704* 765*
                                                                                  768* 793* 817* 878* 949* 1186* 1202*
ptwp                      2            based           bit(18)                  array level 2 in structure "cma" packed packed
                                                                                  unaligned dcl 3-30 in procedure "pc" set ref 753
ptwp                      2            based           bit(18)                  level 2 in structure "cme" packed packed unaligned
                                                                                  dcl 3-6 in procedure "pc" set ref 711 713 896*
ptwp                            002274 automatic       pointer                  dcl 1169 in begin block on line 1164 set ref 1174*
                                                                                  1175
pvt$array                       000062 external static fixed bin(17,0)          dcl 2-18 set ref 699
pvt_array                              based           structure                array level 1 dcl 2-24
pvt_arrayp                      002206 automatic       pointer                  dcl 2-21 set ref 699* 1245
pvte                                   based           structure                level 1 dcl 2-26
pvtx                            000106 automatic       fixed bin(17,0)          dcl 91 in procedure "pc" set ref 285* 832* 844
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 4-11 in procedure "pc" set ref 285 592 592 724
                                                                                  866 1100 1153*
pvtx                                   parameter       fixed bin(17,0)          dcl 1243 in procedure "drive_ok" ref 1240 1245
px                              002272 automatic       fixed bin(17,0)          dcl 1166 set ref 1173* 1174 1180*
pxss$notify                     000046 constant        entry                    external dcl 166 ref 899
pxss$relinquish_priority        000050 constant        entry                    external dcl 167 ref 766
quotaw$cu_for_pc                000052 constant        entry                    external dcl 169 ref 424 427
records                         000100 automatic       fixed bin(17,0)          dcl 87 in procedure "pc" set ref 197* 288* 300* 300
                                                                                  312 352* 416* 416 421 424 427 429 791* 808 810
                                                                                  812* 812 818 824 831* 840 844* 864* 866*
records                  12(18)        based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 4-11 in procedure "pc" set ref 312* 429* 429
                                                                                  955
records                  12(18) 000161 automatic       bit(9)                   level 2 in structure "copy_aste" packed packed
                                                                                  unaligned dcl 120 in procedure "pc" set ref 577*
rel                                                    builtin function         dcl 178 ref 218 380 659 717 721 721 896 897 899 899
return_pageno                   000110 automatic       bit(1)                   dcl 93 set ref 480* 497 588 787* 810 820
rfm                             001175 automatic       bit(22)                  array dcl 127 set ref 541* 583
segmove_astep           555            based           pointer                  level 2 packed packed unaligned dcl 1-9 set ref
                                                                                  1102* 1157*
segmove_deposit_list            000575 automatic       bit(22)                  array dcl 125 set ref 1126* 1195
segmove_io_limit        550            based           fixed bin(17,0)          level 2 dcl 1-9 ref 1015 1027
segmove_lock            545            based           structure                level 2 dcl 1-9 set ref 945 945 1193 1193 1210 1210
segmove_max_tries       554            based           fixed bin(35,0)          level 2 dcl 1-9 set ref 1055* 1055
segmove_n_reads         553            based           fixed bin(35,0)          level 2 dcl 1-9 set ref 1020* 1020
segmove_new_addr_astep
                        561            based           pointer                  level 2 packed packed unaligned dcl 1-9 set ref 946*
segmove_new_addr_null_addr             constant        bit(22)                  initial dcl 6-4 ref 1136
segmove_old_addr_astep
                        560            based           pointer                  level 2 packed packed unaligned dcl 1-9 set ref
                                                                                  1091* 1184*
segmove_old_addr_null_addr             constant        bit(22)                  initial dcl 6-4 ref 1172
segmove_pvtx            556            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 1100* 1159*
segmove_records_in_hand         000153 automatic       fixed bin(17,0)          dcl 112 set ref 954* 971* 1064 1120 1188 1188 1204
                                                                                  1204*
segmove_records_needed          000152 automatic       fixed bin(17,0)          dcl 111 set ref 955* 970 971* 994* 1034* 1034 1060
                                                                                  1062 1064* 1064
segmove_records_used            000117 automatic       fixed bin(17,0)          dcl 99 set ref 1107* 1120 1126 1130 1131 1136 1146*
                                                                                  1146 1188 1188 1188 1197
segmove_synch_disappeared
                        552            based           fixed bin(35,0)          level 2 dcl 1-9 set ref 1230* 1230
segmove_total_records           000154 automatic       fixed bin(17,0)          dcl 114 set ref 955* 1060 1062* 1109
segmove_vtocx           557            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 1101* 1160*
size                                                   builtin function         dcl 178 ref 223 262 274
sst                                    based           structure                level 1 dcl 1-9
sst_seg$                        000060 external static fixed bin(17,0)          dcl 1-6 set ref 190 251 287 342 473 484 615 625 697
                                                                                  788 874 929
sstp                            002204 automatic       pointer                  dcl 1-7 set ref 190* 192 195 195 198 200 203 229 229
                                                                                  251* 255 256 269 270 287* 290 307 313 342* 346 347
                                                                                  349 353 360 399 399 473* 475 476 484* 487 595 615*
                                                                                  625* 626 697* 700 701 705 705 713 714 721 732 732
                                                                                  756 756 788* 789 795 874* 875 880 883 884 885 906
                                                                                  906 929* 930 931 933 935 943 945 945 946 1015 1020
                                                                                  1020 1027 1055 1055 1091 1100 1101 1102 1150 1157
                                                                                  1159 1160 1184 1193 1193 1210 1210 1230 1230 1257
synch_held                1(23)        based           bit(1)                   level 2 packed packed unaligned dcl 3-6 ref 1228
synchronized             13(21)        based           bit(1)                   level 2 packed packed unaligned dcl 4-11 set ref 740
                                                                                  1038
syserr                          000054 constant        entry                    external dcl 170 ref 857 1042 1109 1120 1150 1178
                                                                                  1254
temp_ind                        000105 automatic       fixed bin(35,0)          dcl 90 set ref 1021* 1023 1025
tr_count_sw                     000151 automatic       bit(1)                   dcl 110 set ref 333* 340* 453
trace                           000056 constant        entry                    external dcl 171 ref 198 315 316 321 353 362 367 597
                                                                                  598 603 880 1257
trace_sw                564            based           structure                level 2 dcl 1-9
two                       1            based           bit(388)                 level 2 packed packed unaligned dcl 4-89 set ref
                                                                                  915* 915
uid                       3            based           bit(36)                  level 2 packed packed unaligned dcl 4-11 set ref 857
unspec                                                 builtin function         dcl 178 set ref 580* 580 1171* 1180
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-11 set ref 592
                                                                                  592 1101 1154*
wired                   120            based           fixed bin(17,0)          level 2 in structure "sst" dcl 1-9 in procedure "pc"
                                                                                  set ref 399* 399
wired                     0(31)        based           bit(1)                   array level 3 in structure "ptwa" packed packed
                                                                                  unaligned dcl 1294 in procedure "pc" set ref 399
wordno                                                 builtin function         dcl 178 ref 1012
write_limit             570            based           fixed bin(17,0)          level 2 dcl 1-9 ref 701 756
wtct                     57            based           fixed bin(17,0)          level 2 dcl 1-9 ref 756

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 9-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 9-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 9-7
LOG                                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 9-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 9-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 9-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 2-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 2-113
append_null_addr                       internal static bit(22)                  initial dcl 6-4
asta                                   based           bit(432)                 array dcl 4-86
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 6-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 6-26
devadd_record_no                       defined         bit(18)                  packed unaligned dcl 135
devadd_record_no_proper                defined         bit(17)                  packed unaligned dcl 136
get_aste_null_addr                     internal static bit(22)                  initial dcl 6-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 6-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 6-4
make_sdw_null_addr                     internal static bit(22)                  initial dcl 6-4
mcme                                   based           structure                level 1 dcl 3-32
null_disk_ptw                          based           structure                level 1 dcl 1288
page_bad_null_addr                     internal static bit(22)                  initial dcl 6-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 6-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 6-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 6-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 6-4
ptw_flags                              based           structure                level 1 packed packed unaligned dcl 1283
put_aste_null_addr                     internal static bit(22)                  initial dcl 6-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 6-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 6-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 2-19
pvtep                                  automatic       pointer                  dcl 2-22
real_disk_ptw                          based           structure                level 1 dcl 1287
salv_truncate_null_addr                internal static bit(18)                  initial dcl 6-26
seg_aste                               based           structure                level 1 dcl 4-96
special_ptw                            based           structure                level 1 dcl 1286
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 6-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 6-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 6-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 6-26
volume_reloader_null_addr              internal static bit(18)                  initial dcl 6-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 6-26

NAMES DECLARED BY EXPLICIT CONTEXT.
RE_EXAMINE_PAGE                 004333 constant        label                    dcl 1008 ref 1023
SEGMOVE_ABORT_RETURN            005134 constant        label                    dcl 1202 ref 983 1002 1235
SEGMOVE_EXAMINE_PAGES           004324 constant        label                    dcl 1006
augment_record_pile             004252 constant        label                    dcl 965 ref 976 976 1066
cleanup                         000230 constant        entry                    external dcl 181 ref 266
deposit_list                    003406 constant        entry                    external dcl 827
drive_ok                        005307 constant        entry                    internal dcl 1240 ref 724
dumper_get_file_map             001646 constant        entry                    external dcl 457
fill_page_table                 000615 constant        entry                    external dcl 279
flush                           002646 constant        entry                    external dcl 672
flush_core                      002656 constant        entry                    external dcl 692
flush_join                      002665 constant        label                    dcl 697 ref 690
get_file_map                    001667 constant        entry                    external dcl 464
get_file_map_common             001704 constant        label                    dcl 470 set ref 462
list_deposited_add              003215 constant        entry                    external dcl 779 ref 864
loop_up_fms                     005217 constant        entry                    internal dcl 650 ref 420 546 617 644
loopc                           000307 constant        label                    dcl 200 ref 226 226
move_page_table                 003650 constant        entry                    external dcl 870
move_retry                      004316 constant        label                    dcl 994 ref 1015 1015 1027 1027 1052 1052
nullify                         000430 constant        entry                    external dcl 236
pc                              000217 constant        entry                    external dcl 10
quit                            000414 constant        label                    dcl 232 ref 618 777 917
retry                           001326 constant        label                    dcl 374 ref 382 382
segmove                         004106 constant        entry                    external dcl 921
segmove_synch_page              005252 constant        entry                    internal dcl 1214 ref 1038
start_flush                     002712 constant        label                    dcl 705 ref 756 756 775 775
truncate                        001110 constant        entry                    external dcl 329 ref 859
truncate_count                  001123 constant        entry                    external dcl 336
truncate_deposit_all            003500 constant        entry                    external dcl 851
truncate_join                   001132 constant        label                    dcl 342 ref 334
update_csl                      001576 constant        label                    dcl 442 ref 436 438
update_incore_fms               002564 constant        entry                    external dcl 620
updates                         002534 constant        entry                    external dcl 611
wait_then_go_to                 005322 constant        entry                    internal dcl 1249 ref 226 382 756 775 976 1015 1027
                                                                                  1052

NAME DECLARED BY CONTEXT OR IMPLICATION.
substr                                                 builtin function         ref 271

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6054        6140    5442        6064
Length      6604    5442        64         427     412           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pc                                 1380 external procedure  is an external procedure.  
loop_up_fms                             internal procedure  shares stack frame of external procedure pc.  
begin block on line 1094                begin block         shares stack frame of external procedure pc.  
begin block on line 1164                begin block         shares stack frame of external procedure pc.  
segmove_synch_page                      internal procedure  shares stack frame of external procedure pc.  
drive_ok                                internal procedure  shares stack frame of external procedure pc.  
wait_then_go_to                         internal procedure  shares stack frame of external procedure pc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
pc                       000100 records                     pc
                         000101 first_page                  pc
                         000102 last_page                   pc
                         000103 i                           pc
                         000104 ind                         pc
                         000105 temp_ind                    pc
                         000106 pvtx                        pc
                         000107 dumper                      pc
                         000110 return_pageno               pc
                         000111 add_to_dmpr_map             pc
                         000112 getfmap_csl                 pc
                         000113 getfmap_np                  pc
                         000114 getfmap_nrec                pc
                         000115 offed_sw                    pc
                         000116 j                           pc
                         000117 segmove_records_used        pc
                         000120 cmp                         pc
                         000122 ptwp                        pc
                         000124 curtime                     pc
                         000126 n_in_core                   pc
                         000127 n_io_started                pc
                         000130 pageno                      pc
                         000131 from_core                   pc
                         000132 count                       pc
                         000134 old_astep                   pc
                         000136 new_astep                   pc
                         000140 old_ptp                     pc
                         000142 new_ptp                     pc
                         000144 move_ptp                    pc
                         000146 oldmask                     pc
                         000150 no_deposit_no_return        pc
                         000151 tr_count_sw                 pc
                         000152 segmove_records_needed      pc
                         000153 segmove_records_in_hand     pc
                         000154 segmove_total_records       pc
                         000155 code                        pc
                         000156 new_pvtx                    pc
                         000157 new_vtocx                   pc
                         000160 move_tries                  pc
                         000161 copy_aste                   pc
                         000175 deposit_list                pc
                         000575 segmove_deposit_list        pc
                         001175 rfm                         pc
                         001575 pageno_list                 pc
                         002175 devadd                      pc
                         002176 cleanup_start_time          pc
                         002200 flushing_for_pleasure       pc
                         002201 hedonism                    pc
                         002202 pleasure_flush_count        pc
                         002204 sstp                        pc
                         002206 pvt_arrayp                  pc
                         002210 cmep                        pc
                         002212 astep                       pc
                         002214 fmp                         pc
                         002216 ptp                         pc
                         002270 astep1                      loop_up_fms
                         002272 px                          begin block on line 1164
                         002273 nptw                        begin block on line 1164
                         002274 ptwp                        begin block on line 1164

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_in         call_ext_out_desc   call_ext_out        return_mac
ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dbm_man$set_incr              lock$lock_fast                lock$unlock_fast              page$cam
page$deposit_list             page$pcleanup                 page$pread                    page$pwait
page$pwrite                   page$withdraw_list            pmut$lock_ptl                 pmut$unlock_ptl
pxss$notify                   pxss$relinquish_priority      quotaw$cu_for_pc              syserr
trace

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg
error_table_$synch_seg_segmove                              pvt$array                     sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000216       181 000224       190 000235       191 000237       192 000243       193 000245       195 000247
    196 000251       197 000262       198 000263       200 000307       202 000314       203 000316       204 000331
    207 000334       209 000337       214 000354       218 000365       223 000373       224 000376       226 000400
    229 000407       232 000414       234 000425       236 000426       251 000435       252 000440       254 000444
    255 000454       256 000461       257 000475       262 000507       263 000512       264 000514       266 000525
    268 000533       269 000544       270 000551       271 000565       274 000572       275 000575       276 000577
    277 000610       279 000611       283 000625       284 000631       285 000634       286 000640       287 000643
    288 000646       290 000647       291 000653       292 000661       293 000667       295 000672       296 000674
    297 000676       299 000677       300 000704       302 000705       304 000711       307 000713       309 000731
    310 000733       311 000737       312 000741       313 000750       315 000754       316 000774       320 001027
    321 001035       324 001100       327 001103       329 001104       333 001115       334 001116       336 001117
    340 001130       342 001132       345 001135       346 001141       347 001145       348 001147       349 001151
    352 001157       353 001160       358 001202       360 001213       362 001217       366 001252       367 001257
    370 001322       373 001325       374 001326       377 001327       378 001337       380 001342       382 001346
    384 001354       388 001355       389 001362       393 001365       395 001367       396 001370       398 001375
    399 001400       401 001406       408 001417       411 001426       412 001430       415 001432       416 001437
    419 001442       420 001444       421 001445       423 001447       424 001452       427 001500       429 001525
    434 001540       435 001550       436 001553       438 001557       441 001573       442 001576       445 001606
    447 001610       448 001612       451 001614       452 001621       453 001632       455 001637       457 001640
    461 001662       462 001664       464 001665       469 001703       470 001704       472 001710       473 001711
    474 001714       475 001717       476 001721       477 001730       478 001742       479 001745       480 001746
    482 001753       484 001763       485 001766       486 001767       487 001775       489 002002       490 002005
    492 002011       494 002017       495 002021       497 002024       500 002030       501 002031       502 002033
    504 002036       505 002037       508 002045       510 002051       512 002054       513 002056       514 002060
    516 002062       517 002067       518 002072       522 002110       526 002120       527 002122       528 002124
    530 002125       533 002133       535 002136       536 002137       537 002142       541 002146       542 002151
    543 002153       544 002155       546 002157       547 002160       550 002165       552 002173       557 002212
    561 002215       564 002217       566 002221       569 002226       571 002230       576 002241       577 002246
    578 002254       580 002261       582 002267       583 002275       584 002304       586 002306       587 002315
    588 002320       590 002326       591 002330       592 002333       595 002373       597 002377       598 002422
    602 002455       603 002463       606 002526       609 002531       611 002532       614 002541       615 002545
    616 002550       617 002560       618 002561       620 002562       624 002571       625 002575       626 002600
    628 002604       630 002607       633 002610       634 002621       636 002624       637 002626       638 002630
    640 002632       642 002634       644 002636       645 002637       648 002644       672 002645       689 002653
    690 002654       692 002655       695 002663       697 002665       699 002670       700 002672       701 002674
    703 002701       704 002702       705 002712       708 002723       709 002725       711 002731       713 002734
    714 002737       715 002744       717 002747       721 002756       723 002767       724 002772       731 003014
    732 003025       733 003027       734 003030       735 003031       740 003043       743 003054       745 003065
    753 003110       756 003121       761 003136       763 003141       765 003142       766 003153       768 003162
    773 003173       775 003175       777 003206       779 003207       784 003231       785 003235       786 003237
    787 003241       788 003246       789 003251       791 003255       793 003256       795 003266       798 003300
    800 003307       805 003312       808 003321       810 003324       812 003330       813 003331       815 003341
    817 003343       818 003354       819 003363       820 003366       822 003374       824 003376       825 003400
    827 003401       831 003422       832 003424       840 003427       841 003437       842 003445       844 003447
    846 003475       851 003476       855 003505       857 003511       859 003541       861 003552       864 003556
    866 003605       868 003643       870 003644       874 003662       875 003665       876 003667       877 003672
    878 003675       880 003705       883 003734       884 003741       885 003744       886 003757       889 003761
    890 003763       891 003767       892 003771       894 003774       896 004001       897 004003       898 004006
    899 004011       902 004031       903 004032       904 004035       906 004037       909 004061       910 004063
    911 004067       915 004071       917 004076       921 004077       924 004126       925 004132       926 004135
    927 004140       928 004142       929 004144       930 004147       931 004151       933 004155       935 004160
    937 004163       939 004205       940 004207       943 004210       945 004216       946 004226       949 004231
    954 004242       955 004243       963 004251       965 004252       970 004253       971 004260       976 004301
    979 004310       980 004311       982 004313       983 004315       994 004316      1001 004317      1002 004320
   1005 004323      1006 004324      1008 004333      1012 004337      1014 004343      1015 004344      1017 004356
   1018 004357      1020 004362      1021 004367      1023 004402      1025 004404      1026 004405      1027 004406
   1031 004417      1032 004420      1034 004423      1036 004424      1037 004431      1038 004433      1041 004444
   1042 004445      1046 004476      1052 004500      1055 004507      1060 004515      1062 004520      1064 004521
   1066 004523      1091 004524      1096 004526      1100 004536      1101 004544      1102 004550      1107 004551
   1109 004552      1112 004601      1113 004607      1118 004612      1120 004622      1122 004645      1123 004653
   1126 004655      1130 004661      1131 004663      1136 004666      1139 004672      1140 004674      1141 004700
   1145 004702      1146 004704      1148 004705      1150 004707      1153 004732      1154 004736      1155 004740
   1157 004742      1159 004745      1160 004746      1171 004747      1172 004750      1173 004752      1174 004761
   1175 004763      1176 004766      1178 004777      1180 005024      1182 005031      1184 005033      1186 005036
   1188 005047      1193 005105      1195 005117      1196 005124      1197 005131      1200 005133      1202 005134
   1204 005145      1207 005176      1210 005204      1211 005216       650 005217       655 005220       657 005225
    658 005227       659 005231       660 005234       661 005237       662 005244       663 005250       665 005251
   1214 005252      1226 005254      1228 005266      1230 005274      1231 005301      1234 005302      1235 005306
   1240 005307      1245 005311      1249 005322      1254 005324      1257 005346      1259 005367      1260 005374
   1261 005403


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
