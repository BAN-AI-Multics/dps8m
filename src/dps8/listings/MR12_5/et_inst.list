	COMPILATION LISTING OF SEGMENT et_inst
	Compiled by: Multics PL/I Compiler, Release 27b, of September 15, 1981
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 06/03/82  1022.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 et_inst: procedure (statement, arg_et_data_ptr, code);
       12 
       13 
       14 
       15 /*	This procedure will parse the data in an  "inst"  statement.
       16*   *
       17*   *	Created  Nov, 72  by Bill Silver.
       18*   *
       19*   *
       20*   *
       21*   *	An  "inst"  statement has the following format:
       22*   *
       23*   *	inst	opcode_mnemonic	-option ... -option ... ;
       24*   *
       25*   *	1.  The first field in the statement MUST be  "inst".
       26*   *
       27*   *	2.  The second field in the statement MUST be the mnemonic name
       28*   *	    of a storage type  eis  instruction.  (As opposed to address
       29*   *	    register type  eis  instructions which are not tested by  ET.
       30*   *
       31*   *	3.  Any number of valid  "inst"  statement  option fields may follow.  They may
       32*   *	    be in any order.  Each must begin with a  "-".  The options allowed in an
       33*   *	    "inst"  statement  are:
       34*   *
       35*   *	    a)  -tbA	Used to turn  ON  the  Truncation Bit.
       36*   *			A is either  "y" or "n" and signifies whether or not the instruction
       37*   *			is to take a truncation fault.
       38*   *			"y"  =>  yes,   "n"  =>  no.
       39*   *
       40*   *	    b)  -fb	Used to turn  ON  the  Fill Bit.
       41*   *
       42*   *	    c)  -pb	Used to turn  ON  the  Plus sign Bit.
       43*   *
       44*   *	    d)  -rb	Used to turn  ON  the  Rounding Bit.
       45*   *
       46*   *	    e)  -fcA	Defines the  Fill Character.  A  is the character which will
       47*   *			be used.
       48*   *
       49*   *	    f)  -mcA	Defines the  Mask Character.  A is the character which will
       50*   *			be used.  Note, for both "fc" and "mc" options the character
       51*   *			immediately following the option name will be used.
       52*   *
       53*   *	    g)  -ln X	X defines the  Loop Number.  This is the number of times this
       54*   *			instruction test will be performed.  The default is  1.
       55*   *			The maximum value of  X  is  4.
       56*   *
       57*   *	    h)  -io X	X defines the  Instruction Offset.  It is used to position
       58*   *			the instruction on a page boundary.  The default is  0.  This
       59*   *			will place the instruction at word 0 of the second page
       60*   *			of the instruction area.   X indicates the number of words of
       61*   *			the instruction which will be placed in the first page of the
       62*   *			instruction area.  The maximum value of  X  is  3.
       63*   *
       64*   *	    i)  -nt "A...A" This option defines a  Note.    It can be used to
       65*   *			define each test.  The term consists of a character string
       66*   *			between quotes.  Up to 64 characters may be used.  No embedded
       67*   *			quotes are allowed.
       68*   *
       69*   *	    j)  -bo AAA	This option defines a  Boolean Operator.   AAA is the name of
       70*   *			the operator.  These names are given in the routine which
       71*   *			processes this operator.
       72*   *
       73*   *	    k)  -ir	A  multi-field option which defines the correct state of the
       74*   *			indicator registers after the  eis  instruction has been
       75*   *			executed.  A list of the indicator names is given  in the
       76*   *			routine which processes this option.
       77*   *
       78*   *	    l)  -mfX	A multi-field option which defines the  MF  fields of the instruction.
       79*   *			X  denotes which  MF  field is being defined.  It must be from
       80*   *			1 - 3.  The terms for this option are defined in  et_mf.pl1
       81**/
       82 /* 	*/
       83 /*	The   PARAMETERS  to  et_inst.	*/
       84 
       85 
       86 dcl  statement char (*),				/* The input string containing the
       87*						   *  "inst"  statement to be parsed.  */
       88 
       89      arg_et_data_ptr ptr,				/* The input pointer to   et_data. */
       90 
       91      code fixed bin (35);				/* Error code.  */
       92 
       93 
       94 
       95 
       96 
       97 
       98 /*		AUTOMATIC  DATA		*/
       99 
      100 
      101 /*	The following data items are used in calls to  et_util.  */
      102 
      103 dcl  state_ptr ptr,					/* Pointer to the  "inst"  input statement. */
      104 
      105      start fixed bin (35),				/* The number of characters allready
      106*						   *  processed in the  "inst"  statement.
      107*						   *  The next character is the start of
      108*						   *  the window.  */
      109 
      110      size fixed bin (35),				/* The current size ( in characters )
      111*						   *  of the window on the  "inst"  statement.  */
      112 
      113      next_statement_x fixed bin;			/* Index of the last character in the
      114*						   *  statement - in effect the number of
      115*						   *  characters in the statement.  */
      116 
      117 
      118 
      119 /*	These are some temporary variables. */
      120 
      121 dcl  dec_num fixed bin,				/* Holds converted decimal number.  */
      122 
      123      i fixed bin,					/* Index */
      124 
      125      len fixed bin,					/* Length of a field. */
      126 
      127      num_descs fixed bin,				/* Number of descriptors in the instruction. */
      128 
      129      option_name char (3),				/* Used to save an option name.  */
      130 
      131      option_num fixed bin;				/* Index used when processing options. */
      132 
      133 
      134 
      135 
      136 
      137 /*		BASED  DATA		*/
      138 
      139 
      140 
      141 /*	This is an overlay of the input  "inst"  statement.  It is used to access the input
      142*   *	statement as a stream of characters.  */
      143 
      144 
      145 dcl 1 inst_statement based (state_ptr),
      146 
      147     2 offset char (start),				/* The part of the  "inst"  statement which
      148*						   *  we have already processed. */
      149 
      150     2 window char (size);				/* The part of the  "inst"  statement which
      151*						   *  we are currently accessing.  */
      152 
      153 
      154 
      155 
      156 /*	The following overlays are used to fill in the op code word of the
      157*   *	eis  instruction.  Three are needed because of overlapping fields.
      158**/
      159 
      160 dcl 1 instr_map_1 based (addr (instr_word)) aligned,
      161    (2 fill_mask char (1),				/* Defines both  fill and mask field. */
      162     2 t bit (1),
      163     2 pad1 bit (1),
      164     2 mf2 bit (7),
      165     2 opcode bit (10),
      166     2 pad2 bit (1),
      167     2 mf1 bit (7)) unaligned;
      168 
      169 
      170 dcl 1 instr_map_2 based (addr (instr_word)) aligned,
      171    (2 p_f bit (1),					/* Defines both  f  and  p  bits. */
      172     2 pad1 bit (1),
      173     2 mf3 bit (7),
      174     2 pad2 bit (1),
      175     2 rd bit (1),
      176     2 pad3 bit (25)) unaligned;
      177 
      178 
      179 dcl 1 instr_map_3 based (addr (instr_word)) aligned,
      180    (2 pad1 bit (5),
      181     2 bolr bit (4),
      182     2 pad2 bit (27)) unaligned;
      183 
      184 
      185 
      186 
      187 /*	This is an overlay of a  descriptor  word.   We are only interested in the
      188*   *	address field and the  mf field.
      189**/
      190 
      191 dcl 1 desc_map based aligned,
      192    (2 pad1 bit (3),
      193     2 y fixed bin (14),				/* Address field.  */
      194     2 pad2 bit (11),
      195     2 mf bit (7)) unaligned;
      196 
      197 
      198 /*	This overlay is used to reference a fixed bin word as a bit word.  */
      199 
      200 dcl  bit_word bit (36) aligned based (addr (dec_num));
      201 
      202 
      203 
      204 
      205 
      206 /*		INTERNAL  STATIC  DATA	*/
      207 
      208 
      209 /*	The following table is a list of the option names allowed in an
      210*   *	"inst"  statement.
      211**/
      212 
      213 dcl  option_names (1:12) char (3) internal static
      214      init ("-tb", "-fb", "-pb", "-rb",
      215      "-fc", "-mc", "-ln", "-io",
      216      "-nt", "-bo", "-ir", "-mf");
      217 
      218 
      219 dcl  quote char (1) init ("""") internal static;
      220 
      221 
      222 
      223 /*	This table contains the names of the boolean (BOLR) operations.
      224*   *	The position in the array corresponds to the actual  BOLR  code.
      225**/
      226 
      227 dcl  bolr_names (0:15) char (3) internal static
      228      init ("zer", "and", "axr", "mov",
      229      "xra", "ra2", "xor", "or ",
      230      "nor", "nox", "iv2", "xrx",
      231      "inv", "xxr", "nan", "set");
      232 
      233 
      234 
      235 /*	The following table is used to parse the terms of the  "ir"  option.
      236*   *	These are the names by which the various indicators are known to  ET.
      237*   *	The position within the table corresponds to the bit position of the indicator
      238*   *	in the word that is used to load and store the indicators.
      239**/
      240 
      241 
      242 dcl  ir_names (14) char (2) internal static
      243      init ("zr", "ng", "cr", "ov", "eo", "eu", "om",
      244      "tr", "pe", "pm", "bm", "tn", "mw", "ab");
      245 
      246 
      247 /*	This table is a list of the names of the  4  types of  eis  instructions.  */
      248 
      249 dcl  instr_type_names (4) char (12) aligned internal static
      250      init ("alphanumeric", "numeric     ",
      251      "bit  string ", "conversion  ");
      252 
      253 
      254 /*	This table is a list of the num_chars values that may be assigned to each descriptor.  */
      255 
      256 dcl  num_chars_table (0:3) fixed bin internal static
      257      init (1, 4, 36, -1);
      258 
      259 /*  */
      260 /*		EXTERNAL  DATA		*/
      261 
      262 
      263 
      264 /*	These are the data areas referenced by the initialize instruction.  These
      265*   *	addresses reference the first words of the middle page of each data area.
      266*   *	These data areas are in the same segment  (etx)  as the instruction itself.
      267**/
      268 
      269 dcl (etx$data1, etx$data2, etx$data3,
      270      etx$instruction_area, etx$instr_page_2) external;
      271 
      272 
      273 dcl  com_err_ entry options (variable),
      274 
      275      et_mf entry (char (*), ptr, fixed bin (35)),
      276 
      277      et_util$get_next entry (ptr, fixed bin (35), fixed bin (35), char (*), fixed bin),
      278      et_util$skip entry (ptr, fixed bin (35), fixed bin (35)),
      279      et_util$convert_decimal entry (ptr, fixed bin (35), fixed bin (35), fixed bin, fixed bin (35));
      280 
      281 
      282 
      283 
      284 dcl (addr,
      285      index,
      286      length,
      287      search,
      288      substr) builtin;
      289 						/*  */
  1     1 /*	BEGIN INCLUDE FILE  ...  et_instr_data_map.incl.pl1
  1     2**
  1     3**	Created  Jan, 73  by  Bill Silver.
  1     4**
  1     5**
  1     6**	Below is a map of the data found in et_instr_data.alm.
  1     7**	This is a table of  "eis" multi-word instructions.
  1     8**/
  1     9 
  1    10 
  1    11 
  1    12 dcl	et_instr_data$num_instructions	fixed bin	   external;
  1    13 
  1    14 
  1    15 dcl    1	et_instr_data$instructions( 0:1 )	aligned  external,
  1    16 
  1    17          (2 mnemonic	char(4),		/* Instruction's assembler name.  */
  1    18 
  1    19 	2 opcode		bit(10),		/* Opcode, rightmost bit always ON.  */
  1    20 
  1    21 	2 instr_typex	fixed bin(7),	/* 1 => alphanumeric,  2 => numeric,
  1    22*					*  3 => bit  string    4 => conversion.  */
  1    23 
  1    24 	2 char_sizex (3)	fixed bin(2),	/* Defines the character size for each descriptor.
  1    25*					*  0  =>  1,   1  =>  4,
  1    26*					*  2  =>  36,  3  =>  -1,
  1    27*					*  -1 =>  no descriptor  */
  1    28 
  1    29 	2 mf2_flag	bit(1),		/* 1 => instruction word has  "mf2"  field.
  1    30*					*  0 => descriptor  word has  "mf2"  field.  */
  1    31 
  1    32 	2 mf3_flag	bit(1),		/* 1 => instruction word has  "mf3" field.
  1    33*					*  0 => descriptor  word has  "mf3"  field.  */
  1    34 
  1    35 	2 desc_3_flag	bit(1),		/* 0 => instruction has 2 descriptors.
  1    36*					*  1 => instruction has 3 descriptors.  */
  1    37 
  1    38 	2 test_x		fixed bin(2),	/* The number of the data statement used
  1    39*					*  to input the  test  data.  */
  1    40 
  1    41 	2 result_x	fixed bin(2))	/* The number of the descriptor which
  1    42*					*  references the result data.  */
  1    43 
  1    44 	unaligned;
  1    45 
  1    46 
  1    47 /*	END of INCLUDE FILE  ...  et_instr_data_map.incl.pl1    */
      290 
      291 /* 	*/
  2     1 /*	BEGINNING OF INCLUDE FILE  ...  et_setup_data.incl.pl1
  2     2*   *
  2     3*   *	Created  Jan, 73  by  Bill Silver.
  2     4*   *
  2     5*   *
  2     6*   * 	This include file defines the data that is needed to set up a test of an  eis
  2     7*   *	instruction.  The area where this data actually resides is in  "et".
  2     8**/
  2     9 
  2    10 
  2    11 dcl  et_data_ptr ptr;				/* Pointer to the  et_data  area.  */
  2    12 
  2    13 
  2    14 dcl 1 et_setup_data based (et_data_ptr) aligned,
  2    15 
  2    16     2 next_instruction_x fixed bin,			/* Index in script file of where the next
  2    17*						   *  instruction test begins.  */
  2    18 
  2    19     2 name char (6),				/* Mnemonic name of the instruction
  2    20*						   *  being tested. */
  2    21 
  2    22     2 test_count fixed bin,				/* The number of the current test. */
  2    23 
  2    24     2 note char (64),				/* A NOTE containing a description of the test. */
  2    25 
  2    26     2 loop_count fixed bin,				/* Number of times to execute the same
  2    27*						   *  variation of an instruction.  */
  2    28 
  2    29     2 instr_offset fixed bin,				/* Indicates the position of the eis
  2    30*						   *  instruction within the instruction
  2    31*						   *  area in  etx. */
  2    32 
  2    33     2 instr_num fixed bin,				/* The index of the current instruction's
  2    34*						   *  entry in the  et_instr_data$instruction
  2    35*						   *  array.  */
  2    36 
  2    37     2 instr_type fixed bin,				/* 1  =  alphanumeric   2  =  numeric
  2    38*						   *  3  =  bit  string    4  =  conversion  */
  2    39 
  2    40     2 instr_word bit (36),				/* The instruction word of the  eis
  2    41*						   *  instruction to be tested.  */
  2    42 
  2    43     2 descriptors (3) bit (36),			/* The three possible descriptor words
  2    44*						   *  of the eis instruction.  */
  2    45 
  2    46     2 ind_words (3) bit (36),				/* The three possible indirect words that
  2    47*						   *  may follow the eis instruction.  */
  2    48 
  2    49     2 desc_ptrs (3) ptr,				/* An array of pointers to where any
  2    50*						   *  indirect descriptors must be placed.  */
  2    51 
  2    52     2 mf_ptrs (3) ptr,				/* Pointers to the  mf  fields for each descriptor.
  2    53*						   *  If an entry is null then there is no descriptor
  2    54*						   *  associated with this entry.  */
  2    55 
  2    56     2 num_chars (3) fixed bin,			/* For each descriptor a code indicating what
  2    57*						   *  type of "ta" or "tn" field it may have.  It
  2    58*						   *  implies the number of characters in a word.
  2    59*						   *   1 - descriptor must reference word boundary.
  2    60*						   *   4 - any legal "ta" or "tn" field.
  2    61*						   *       Implies 9 bit  characters as default.
  2    62*						   *  36 - descriptor may reference  bits.
  2    63*						   *  -1 - must use "ta" field of descriptor 1
  2    64*						   *   0 - no descriptor.  */
  2    65 
  2    66     2 data_ptrs (5) ptr,				/* An array of pointers to where
  2    67*						   *  the data for the corresponding
  2    68*						   *  descriptor will go.  It points to
  2    69*						   *  the first word of the data.
  2    70*						   *  Entry (4) is for the test data.
  2    71*						   *  Entry (5) is for the result data.  */
  2    72 
  2    73     2 data_lens (5) fixed bin,			/* An array of lengths of the data fields.
  2    74*						   *  They will always be in units of chars. */
  2    75 
  2    76     2 data_offsets (5) fixed bin,			/* An array of character offsets.  They specify
  2    77*						   *  the character position of the string  in
  2    78*						   *  the first word of the string.  */
  2    79 
  2    80     2 page_faults (14) bit (1) unal,			/* A table of flags which indicate pages
  2    81*						   *  which should take a page fault during
  2    82*						   *  execution of the eis instruction. */
  2    83 
  2    84     2 page_ptrs (14) ptr,				/* A pointer to each page that is used
  2    85*						   *  by the instruction.  Pages not used will
  2    86*						   *  have null entries.  */
  2    87 
  2    88     2 truncation_flag fixed bin,			/* Indicates whether or not the instruction is
  2    89*						   *  going to take a truncation fault.
  2    90*						   *  1  =>  yes,   0  =>  no.  */
  2    91 
  2    92     2 pointers (0:7) ptr,				/* The values of the pointer registers
  2    93*						   *  before the execution of the eis instr. */
  2    94 
  2    95     2 regs,					/* Index, A, and Q registers. */
  2    96       3 x (0:7) fixed bin (17) unaligned,
  2    97       3 A fixed bin (35),
  2    98       3 Q fixed bin (35),
  2    99       3 pad (2) bit (36),
  2   100 
  2   101     2 ir_word bit (36);				/* The settings of the indicator
  2   102*						   *  registers after the eis instruction
  2   103*						   *  has been executed.  */
  2   104 
  2   105 
  2   106 
  2   107 /*	END of INCLUDE FILE  ...  et_setup_data.incl.pl1	*/
      292 
      293 /* 	*/
      294 /*	Set up the window on the input  "inst"  statement.  We will skip the
      295*   *	"inst"  field at the beginning of the statement.
      296**/
      297 
      298 
      299 	state_ptr = addr (statement);
      300 	next_statement_x = length (statement);
      301 
      302 	et_data_ptr = arg_et_data_ptr;		/* Copy this argument. */
      303 
      304 	start = 4;
      305 	size = next_statement_x - 4;
      306 
      307 
      308 /*	Now skip to the mnemonic name field.  */
      309 
      310 	call et_util$skip (state_ptr, start, size);
      311 
      312 	call get_instr_num;				/* The mnemonic name MUST be next. */
      313 
      314 	if code ^= 0
      315 	then return;
      316 
      317 
      318 
      319 
      320 /*	Now initialize the data variables in  et_setup_data.  The initial state of the
      321*   *	instruction and all descriptors is:
      322*   *
      323*   *	1.  There is no register or pointer modification.
      324*   *	2.  There is no register length (RL) modification.
      325*   *	3.  The descriptor is not indirect.
      326*   *	4.  The data referenced via the descriptor is in the same segment as
      327*   *	    the descriptor.  (etx)
      328**/
      329 
      330 /*	Put the instruction name in the  note field.  The rest of the note will
      331*   *	be left blank for now.
      332**/
      333 
      334 	name = et_instr_data$instructions (instr_num).mnemonic;
      335 
      336 	loop_count = 1;				/* The default is to execute the test
      337*						   *  only once.  */
      338 
      339 	instr_offset = 0;				/* Assume instruction goes at word zero
      340*						   *  of middle page.  */
      341 
      342 /*	Clear the instruction word and set up the opcode field.
      343**/
      344 
      345 	instr_word = "0"b;
      346 
      347 	instr_map_1.opcode = et_instr_data$instructions (instr_num).opcode;
      348 
      349 
      350 	instr_type = et_instr_data$instructions (instr_num).instr_typex;
      351 
      352 	do i = 1 to 3;				/* Initially there are no indirect descriptors.  */
      353 	     descriptors (i) = "0"b;
      354 	     ind_words (i) = "0"b;
      355 	     desc_ptrs (i) = null ();
      356 	end;
      357 
      358 	do i = 1 to 5;				/* Entries 1 & 2 will be filled in below. */
      359 	     data_ptrs (i) = null ();
      360 	     data_lens (i) = 0;
      361 	     data_offsets (i) = 0;
      362 	end;
      363 
      364 	do i = 1 to 14;				/* Default is no page faults. */
      365 	     page_faults (i) = "0"b;
      366 	     page_ptrs (i) = null ();
      367 	end;
      368 
      369 	page_ptrs (2) = addr (etx$instr_page_2);	/* This page is usually used. */
      370 
      371 	truncation_flag = 0;
      372 
      373 	do i = 0 to 7;				/* Unused pointer registers are null. */
      374 	     pointers (i) = null ();
      375 	end;
      376 
      377 /*	Unused index registers and A and Q are set to some recognizable but
      378*   *	never valid value  (17777 octal).
      379**/
      380 
      381 	do i = 0 to 7;
      382 	     regs.x (i) = 8191;
      383 	end;
      384 
      385 	regs.A, regs.Q = 8191;
      386 
      387 
      388 /*	All indicators will be initialized to  off  except the  bar mode  indicator which
      389*   *	will be on during normal  Multics operation.
      390**/
      391 
      392 	ir_word = "000000000000000000000000000010000000"b;
      393 
      394 
      395 /*	Now set up the initial values of the data pointers and the descriptors.
      396*   *	The third descriptor is initialized only if this instruction actually has a
      397*   *	third descriptor.
      398**/
      399 	if et_instr_data$instructions (instr_num).desc_3_flag
      400 
      401 	then num_descs = 3;
      402 	else num_descs = 2;
      403 
      404 	data_ptrs (1) = addr (etx$data1);
      405 	data_ptrs (2) = addr (etx$data2);
      406 
      407 	if num_descs = 3
      408 	then data_ptrs (3) = addr (etx$data3);
      409 
      410 	do i = 1 to num_descs;
      411 	     addr (descriptors (i)) -> desc_map.y = fixed (rel (data_ptrs (i)), 14);
      412 	end;
      413 
      414 
      415 /*	Now set up the  mf  pointers.  There must be an  mf  field for each descriptor.
      416*   *	The  mf1 field is always in the instruction word.  The mf2 and mf3 fields may
      417*   *	be in the instruction word or in the descriptor itself.
      418**/
      419 
      420 	mf_ptrs (1) = addr (instr_map_1.mf1);
      421 
      422 	if et_instr_data$instructions (instr_num).mf2_flag
      423 	then mf_ptrs (2) = addr (instr_map_1.mf2);
      424 	else mf_ptrs (2) = addr (addr (descriptors (2)) -> desc_map.mf);
      425 
      426 	if num_descs < 3
      427 
      428 	then mf_ptrs (3) = null ();
      429 
      430 	else if et_instr_data$instructions (instr_num).mf3_flag
      431 	then mf_ptrs (3) = addr (instr_map_2.mf3);
      432 	else mf_ptrs (3) = addr (addr (descriptors (3)) -> desc_map.mf);
      433 
      434 
      435 /*	Now set up the  num_chars  table.  If there is now descriptor 3 then this
      436*   *	entry in the table is zero.
      437**/
      438 
      439 	num_chars (3) = 0;
      440 
      441 	do i = 1 to num_descs;
      442 	     num_chars (i) = num_chars_table (et_instr_data$instructions (instr_num).char_sizex (i));
      443 	end;
      444 
      445 /* 	*/
      446 /*	Now start to process the options.  We will test for each possible option name.
      447*   *	Each iteration of the loop will process one option.
      448**/
      449 
      450 
      451 option_loop:
      452 
      453 
      454 /*	Get the next option name.  If there are no more options then we have finished
      455*   *	with this  "inst"  statement.
      456**/
      457 
      458 	call et_util$get_next (state_ptr, start, size, "-", len);
      459 
      460 	if len = 0 then return;
      461 
      462 /*	We will try to find this option name in our list.  */
      463 
      464 	option_name = substr (window, 1, 3);
      465 
      466 	do option_num = 1 to 12;
      467 
      468 	     if option_names (option_num) = option_name
      469 
      470 	     then do;
      471 		start = start + 3;			/* Move window past option name.  */
      472 		size = size - 3;
      473 		goto option_routine (option_num);	/* Go to correct routine.  */
      474 	     end;
      475 	end;
      476 
      477 
      478 /*	We did not find a valid option name.  There must be an input error.  */
      479 
      480 	code = 201;
      481 	call com_err_ (0, "ET", "^d Illegal option ""^a"" in ""inst"" statement.", code, option_name);
      482 
      483 	return;
      484 						/* 	*/
      485 option_routine (1):					/*  -tb  */
      486 
      487 	if instr_type = 4				/* Illegal only for conversion type. */
      488 	then goto illegal_option;
      489 
      490 	if substr (window, 1, 1) = "y"
      491 	then truncation_flag = 1;
      492 
      493 	start = start + 1;
      494 	size = size - 1;
      495 
      496 	instr_map_1.t = "1"b;
      497 
      498 	goto option_loop;
      499 
      500 
      501 
      502 option_routine (2):					/*  -fb  */
      503 
      504 	if instr_type = 3				/* Legal only for bit string types. */
      505 
      506 	then goto set_fb_pb;
      507 	else goto illegal_option;
      508 
      509 
      510 option_routine (3):					/*  -pb  */
      511 
      512 /*	Legal only for  numeric and conversion types.  */
      513 
      514 	if (instr_type ^= 2) & (instr_type ^= 4)
      515 
      516 	then goto illegal_option;
      517 
      518 
      519 set_fb_pb:
      520 
      521 	instr_map_2.p_f = "1"b;
      522 
      523 	goto option_loop;
      524 
      525 
      526 
      527 option_routine (4):					/*  -rb  */
      528 
      529 	if instr_type ^= 2				/* Legal only for numeric types. */
      530 
      531 	then goto illegal_option;
      532 
      533 	instr_map_2.rd = "1"b;
      534 
      535 	goto option_loop;
      536 
      537 
      538 
      539 option_routine (5):					/*  -fc  */
      540 option_routine (6):					/*  -mc  */
      541 
      542 	if instr_type ^= 1				/* Legal only for alphanumeric types.  */
      543 
      544 	then goto illegal_option;
      545 
      546 	instr_map_1.fill_mask = substr (window, 1, 1);
      547 
      548 	start = start + 1;
      549 	size = size - 1;
      550 
      551 	goto option_loop;
      552 						/*  */
      553 option_routine (7):					/*  -ln  */
      554 option_routine (8):					/*  -io  */
      555 
      556 
      557 /*	Each of these option names must be followed by a decimal term.  */
      558 
      559 	call et_util$skip (state_ptr, start, size);
      560 
      561 	call et_util$convert_decimal (state_ptr, start, size, dec_num, code);
      562 
      563 	if code ^= 0 then goto illegal_term;
      564 
      565 	if option_name = "-ln"
      566 
      567 	then do;
      568 	     if (dec_num < 1) | (dec_num > 4)
      569 	     then goto illegal_term;
      570 	     loop_count = dec_num;
      571 	end;
      572 
      573 /*	This option will position the instruction in the instruction area.  We must
      574*   *	also determine which pages in the instruction area are actually used.   By
      575*   *	default the first page in NOT used and the second page IS used.  If the user
      576*   *	specifies an instruction offset then the first page will be used.
      577**/
      578 
      579 	else do;
      580 	     if (dec_num < 0) | (dec_num > 3)
      581 	     then goto illegal_term;
      582 	     instr_offset = dec_num;
      583 	     if dec_num > 0
      584 	     then page_ptrs (1) = addr (etx$instruction_area);
      585 	end;
      586 
      587 	goto option_loop;
      588 						/*  */
      589 option_routine (9):					/*  -nt  */
      590 
      591 
      592 /*	Look for left hand quote.  */
      593 
      594 	call et_util$skip (state_ptr, start, size);
      595 
      596 	if substr (window, 1, 1) ^= quote
      597 
      598 	then do;
      599 	     code = 208;
      600 	     call com_err_ (0, "ET", "^d Left quote of  -nt  term not found.", code);
      601 	     return;
      602 	end;
      603 
      604 	start = start + 1;
      605 	size = size - 1;
      606 
      607 /*	Now we will move the characters inside the quotes into the note.  If we move more than
      608*   *	the maximum of 64 characters then we will assume that the right quote is not present.
      609**/
      610 
      611 	len = 0;					/* Position in the note string.  */
      612 
      613 	do i = 1 to 65;
      614 
      615 	     if substr (window, i, 1) = quote
      616 
      617 	     then do;				/* Move the window past the right hand quote.
      618*						   *  et_util$skip works funny with quotes.  */
      619 		start = start + i;
      620 		size = size - i;
      621 		goto option_loop;
      622 	     end;
      623 
      624 	     len = len + 1;
      625 
      626 	     substr (note, len, 1) = substr (window, i, 1);
      627 
      628 	end;
      629 
      630 
      631 	code = 209;
      632 	call com_err_ (0, "ET", "^d Right quote missing in  ""-nt"" term  or  term too long.", code);
      633 
      634 	return;
      635 						/*  */
      636 option_routine (10):				/*  -bo  */
      637 
      638 
      639 	if instr_type ^= 3				/* Legal only for bit string types. */
      640 
      641 	then goto illegal_option;
      642 
      643 
      644 /*	Move the window to the start of the  BOLR name term.  */
      645 
      646 	call et_util$skip (state_ptr, start, size);
      647 
      648 	do dec_num = 0 to 15;
      649 
      650 	     if substr (window, 1, 3) = bolr_names (dec_num)
      651 
      652 	     then do;
      653 		instr_map_3.bolr = substr (bit_word, 33, 4);
      654 		goto option_loop;
      655 	     end;
      656 
      657 	end;
      658 
      659 
      660 	code = 210;
      661 
      662 	call com_err_ (0, "ET", "^d BORL name not known: ^a", code, substr (window, 1, 3));
      663 
      664 	return;
      665 						/* 	*/
      666 option_routine (11):				/*  -ir  */
      667 
      668 
      669 
      670 /*	This  routine will parse an  "ir"  option.
      671*   *	An  ir  option has the following format:
      672*   *
      673*   *	-ir	ind . .  ind . . . ind
      674*   *
      675*   *	1.  The first field in the option MUST be the option name "-ir".
      676*   *
      677*   *	2.  Following  may be any number of  ind  terms.   These terms may be in
      678*   *	    any order and may be separated by any number of skip fields.
      679*   *
      680*   *	3.  Each  ind  term is a two character identifier of an indicator
      681*   *	    register.  The  ind  term values which are acceptable are:
      682*   *
      683*   *	    a)	zr  -  zero
      684*   *	    b)	ng  -  negative
      685*   *	    c)	cr  -  carry
      686*   *	    d)	ov  -  overflow
      687*   *	    e)	eo  -  exponent overflow
      688*   *	    f)	eu  -  exponent underflow
      689*   *	    g)	om  -  overflow mask
      690*   *	    h)	tr  -  tally runout
      691*   *	    i)	pe  -  parity error
      692*   *	    j)	pm  -  parity mask
      693*   *	    k)	bm  -  BAR mode  -  Really  NOT BAR mode
      694*   *	    l)	tn  -  truncation
      695*   *	    m)	mw  -  multi-word instruction
      696*   *	    n)	ab  -  ABSOLUTE mode
      697**/
      698 
      699 
      700 
      701 
      702 /*	Now start process the  ind  terms.   */
      703 
      704 
      705 
      706 	do while (code = 0);
      707 
      708 
      709 /*	Move the window to the beginning of the next term.  If we find the beginning of the
      710*   *	next option or we hit the end of the statement then we are finished with this  ir
      711*   *	option.
      712**/
      713 
      714 	     call et_util$skip (state_ptr, start, size);
      715 
      716 	     if (substr (window, 1, 1) = "-") | (substr (window, 1, 1) = ";")
      717 
      718 	     then goto option_loop;
      719 
      720 
      721 	     call parse_ir_ind_term;			/* Find the  ind  term in the ir_names table
      722*						   *  and turn on the appropriate bit. */
      723 
      724 	end;					/* End of the do loop. */
      725 
      726 
      727 /*	To get here there must have been an error.  */
      728 
      729 	return;
      730 						/*  */
      731 option_routine (12):				/*  -mf  */
      732 
      733 
      734 	call et_mf (window, et_data_ptr, code);
      735 
      736 
      737 	if code ^= 0
      738 
      739 	then return;
      740 
      741 	else goto option_loop;
      742 						/* 	*/
      743 get_instr_num: procedure;
      744 
      745 
      746 
      747 /*	This procedure is called to find the entry for this instruction in the et_instr_data
      748*   *	table.  It will return this index in  "instr_num".
      749**/
      750 
      751 
      752 
      753 /*	First get the length of the mnemonic name.  We will search for the next skip character
      754*   *	or  "/" (beginning of a comment)  or ";" (end of statement).  Note, it is valid
      755*   *	to have an  "inst"  statement that has only the mnemonic name.  The length returned
      756*   *	will be one greater than the actual length of the field.
      757**/
      758 
      759 /*	Below we search for: New Line, Tab, Blank, "/", and ";"  */
      760 
      761 	     len = search (window, "
      762 	 /;") - 1;
      763 
      764 	     if (len < 1) | (len > 4)
      765 
      766 	     then do;
      767 		code = 221;
      768 		call com_err_ (0, "ET", "^d Illegal mnemonic name in statement:  ^a",
      769 		     code, window);
      770 		return;
      771 	     end;
      772 
      773 
      774 
      775 /*	Search the table for a matching instruction mnemonic.  */
      776 
      777 
      778 	     do instr_num = 1 to et_instr_data$num_instructions;
      779 
      780 		if substr (window, 1, len) = et_instr_data$instructions (instr_num).mnemonic
      781 
      782 		then return;			/* If we find a match then instr_num
      783*						   *  contains the index we want.  */
      784 	     end;
      785 
      786 
      787 /*	If we get here then there is an error.  We cound not find the mnemonic name
      788*   *	specified in the input  "inst"  statement.
      789**/
      790 
      791 	     code = 222;
      792 
      793 	     call com_err_ (0, "ET", "^d ^a  is not a known  eis  instruction.", code, substr (window, 1, len));
      794 
      795 
      796 
      797 	end get_instr_num;
      798 						/*  */
      799 parse_ir_ind_term: procedure;
      800 
      801 
      802 
      803 /*	This procedure will search the  ir_names table for the current  ind  term.
      804*   *	( the first two characters of window )  If it is found then the corresponding
      805*   *	bit in  ir_word  will be turned on.
      806**/
      807 
      808 
      809 
      810 
      811 	     do i = 1 to 14;
      812 
      813 		if ir_names (i) = substr (window, 1, 2)
      814 
      815 /*	The position of the  ind  term in the table indicates the position of
      816*   *	its corresponding bit in the lower half of the ir_word.   Move the window
      817*   *	past this indicator term.
      818**/
      819 
      820 		then do;
      821 		     substr (ir_word, 18+i, 1) = "1"b;
      822 		     start = start + 2;
      823 		     size = size - 2;
      824 		     return;
      825 		end;
      826 
      827 	     end;					/* End of do loop. */
      828 
      829 /*	This  ind  term was not found in The table. */
      830 
      831 	     code = 231;
      832 	     call com_err_ (0, "ET", "^d Illegal  ir  ind  term: ^a", code, substr (window, 1, 2));
      833 
      834 
      835 	end parse_ir_ind_term;
      836 						/* 	*/
      837 illegal_option:
      838 
      839 	code = 240 + option_num;
      840 
      841 	call com_err_ (0, "ET", "^d "" ^a "" option is illegal for ^a type instruction.",
      842 	     code, option_name, instr_type_names (instr_type));
      843 
      844 	return;
      845 
      846 
      847 
      848 
      849 illegal_term:
      850 
      851 	code = 260 + option_num;
      852 
      853 	call com_err_ (0, "ET", "^d Illegal decimal term (^d) for option ""^a"".",
      854 	     code, dec_num, option_name);
      855 
      856 	return;
      857 
      858 
      859 
      860 
      861 
      862      end et_inst;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/03/82  1022.7  et_inst.pl1                       >spec>on>phx-dir>et_inst.pl1
290          1    05/06/74  1741.2  et_instr_data_map.incl.pl1        >ldd>include>et_instr_data_map.incl.pl1
292          2    06/02/82  1246.3  et_setup_data.incl.pl1            >spec>on>phx-dir>et_setup_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                       170            based           fixed bin(35,0)          level 3 dcl 2-14 set ref 385*
Q                       171            based           fixed bin(35,0)          level 3 dcl 2-14 set ref 385*
addr                                                   builtin function         dcl 284 ref 299 347 369 404 405 407 411 420 420 422
                                                                                  422 424 424 430 430 432 432 496 519 533 546 583
                                                                                  653 653
arg_et_data_ptr                        parameter       pointer                  dcl 86 ref 11 302
bit_word                               based           bit(36)                  dcl 200 ref 653
bolr                      0(05)        based           bit(4)                   level 2 packed unaligned dcl 179 set ref 653*
bolr_names                      000027 constant        char(3)                  initial array unaligned dcl 227 ref 650
char_sizex                1(18) 000052 external static fixed bin(2,0)           array level 2 packed unaligned dcl 1-15 ref 442
code                                   parameter       fixed bin(35,0)          dcl 86 set ref 11 314 480* 481* 561* 563 599* 600*
                                                                                  631* 632* 660* 662* 666 731* 737 767* 768* 791*
                                                                                  793* 831* 832* 837* 841* 849* 853*
com_err_                        000036 constant        entry                    external dcl 273 ref 481 600 632 662 768 793 832 841
                                                                                  853
data_lens                72            based           fixed bin(17,0)          array level 2 dcl 2-14 set ref 360*
data_offsets             77            based           fixed bin(17,0)          array level 2 dcl 2-14 set ref 361*
data_ptrs                60            based           pointer                  array level 2 dcl 2-14 set ref 359* 404* 405* 407*
                                                                                  411
dec_num                         000105 automatic       fixed bin(17,0)          dcl 121 set ref 561* 568 568 570 580 580 582 583
                                                                                  648* 650 653* 853*
desc_3_flag               1(29) 000052 external static bit(1)                   array level 2 packed unaligned dcl 1-15 ref 399
desc_map                               based           structure                level 1 dcl 191
desc_ptrs                40            based           pointer                  array level 2 dcl 2-14 set ref 355*
descriptors              31            based           bit(36)                  array level 2 dcl 2-14 set ref 353* 411 424 432
et_data_ptr                     000114 automatic       pointer                  dcl 2-11 set ref 302* 334 334 336 339 345 347 347
                                                                                  350 350 353 354 355 359 360 361 365 366 369 371
                                                                                  374 382 385 385 392 399 404 405 407 411 411 420
                                                                                  420 422 422 422 424 424 426 430 430 430 432 432
                                                                                  439 442 442 485 490 496 502 510 510 519 527 533
                                                                                  539 546 570 582 583 626 636 653 731* 778 780 821
                                                                                  841
et_instr_data$instructions      000052 external static structure                array level 1 dcl 1-15
et_instr_data$num_instructions  000050 external static fixed bin(17,0)          dcl 1-12 ref 778
et_mf                           000040 constant        entry                    external dcl 273 ref 731
et_setup_data                          based           structure                level 1 dcl 2-14
et_util$convert_decimal         000046 constant        entry                    external dcl 273 ref 561
et_util$get_next                000042 constant        entry                    external dcl 273 ref 451
et_util$skip                    000044 constant        entry                    external dcl 273 ref 310 553 589 646 714
etx$data1                       000024 external static fixed bin(17,0)          dcl 269 set ref 404
etx$data2                       000026 external static fixed bin(17,0)          dcl 269 set ref 405
etx$data3                       000030 external static fixed bin(17,0)          dcl 269 set ref 407
etx$instr_page_2                000034 external static fixed bin(17,0)          dcl 269 set ref 369
etx$instruction_area            000032 external static fixed bin(17,0)          dcl 269 set ref 583
fill_mask                              based           char(1)                  level 2 packed unaligned dcl 160 set ref 546*
i                               000106 automatic       fixed bin(17,0)          dcl 121 set ref 352* 353 354 355* 358* 359 360 361*
                                                                                  364* 365 366* 373* 374* 381* 382* 410* 411 411*
                                                                                  441* 442 442* 613* 615 619 620 626* 811* 813 821*
ind_words                34            based           bit(36)                  array level 2 dcl 2-14 set ref 354*
inst_statement                         based           structure                level 1 packed unaligned dcl 145
instr_map_1                            based           structure                level 1 dcl 160
instr_map_2                            based           structure                level 1 dcl 170
instr_map_3                            based           structure                level 1 dcl 179
instr_num                26            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 334 347 350 399 422 430 442
                                                                                  778* 780*
instr_offset             25            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 339* 582*
instr_type               27            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 350* 485 502 510 510 527
                                                                                  539 636 841
instr_type_names                000010 internal static char(12)                 initial array dcl 249 set ref 841*
instr_typex               1(10) 000052 external static fixed bin(7,0)           array level 2 packed unaligned dcl 1-15 ref 350
instr_word               30            based           bit(36)                  level 2 dcl 2-14 set ref 345* 347 420 422 430 496
                                                                                  519 533 546 653
ir_names                        000020 constant        char(2)                  initial array unaligned dcl 242 ref 813
ir_word                 174            based           bit(36)                  level 2 dcl 2-14 set ref 392* 821*
len                             000107 automatic       fixed bin(17,0)          dcl 121 set ref 451* 460 611* 624* 624 626 761* 764
                                                                                  764 780 793 793
length                                                 builtin function         dcl 284 ref 300
loop_count               24            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 336* 570*
mf                        0(29)        based           bit(7)                   level 2 packed unaligned dcl 191 set ref 424 432
mf1                       0(29)        based           bit(7)                   level 2 packed unaligned dcl 160 set ref 420
mf2                       0(11)        based           bit(7)                   level 2 packed unaligned dcl 160 set ref 422
mf2_flag                  1(27) 000052 external static bit(1)                   array level 2 packed unaligned dcl 1-15 ref 422
mf3                       0(02)        based           bit(7)                   level 2 packed unaligned dcl 170 set ref 430
mf3_flag                  1(28) 000052 external static bit(1)                   array level 2 packed unaligned dcl 1-15 ref 430
mf_ptrs                  46            based           pointer                  array level 2 dcl 2-14 set ref 420* 422* 424* 426*
                                                                                  430* 432*
mnemonic                        000052 external static char(4)                  array level 2 packed unaligned dcl 1-15 ref 334 780
name                      1            based           char(6)                  level 2 dcl 2-14 set ref 334*
next_statement_x                000104 automatic       fixed bin(17,0)          dcl 103 set ref 300* 305
note                      4            based           char(64)                 level 2 dcl 2-14 set ref 626*
num_chars                54            based           fixed bin(17,0)          array level 2 dcl 2-14 set ref 439* 442*
num_chars_table                 000014 constant        fixed bin(17,0)          initial array dcl 256 ref 442
num_descs                       000110 automatic       fixed bin(17,0)          dcl 121 set ref 399* 402* 407 410 426 441
opcode                    0(18)        based           bit(10)                  level 2 in structure "instr_map_1" packed unaligned
                                                                                  dcl 160 in procedure "et_inst" set ref 347*
opcode                    1     000052 external static bit(10)                  array level 2 in structure
                                                                                  "et_instr_data$instructions" packed unaligned
                                                                                  dcl 1-15 in procedure "et_inst" ref 347
option_name                     000111 automatic       char(3)                  unaligned dcl 121 set ref 464* 468 481* 565 841*
                                                                                  853*
option_names                    000043 constant        char(3)                  initial array unaligned dcl 213 ref 468
option_num                      000112 automatic       fixed bin(17,0)          dcl 121 set ref 466* 468 473* 837 849
p_f                                    based           bit(1)                   level 2 packed unaligned dcl 170 set ref 519*
page_faults             104            based           bit(1)                   array level 2 packed unaligned dcl 2-14 set ref 365*
page_ptrs               106            based           pointer                  array level 2 dcl 2-14 set ref 366* 369* 583*
pointers                144            based           pointer                  array level 2 dcl 2-14 set ref 374*
quote                           002416 constant        char(1)                  initial unaligned dcl 219 ref 596 615
rd                        0(10)        based           bit(1)                   level 2 packed unaligned dcl 170 set ref 533*
regs                    164            based           structure                level 2 dcl 2-14
search                                                 builtin function         dcl 284 ref 761
size                            000103 automatic       fixed bin(35,0)          dcl 103 set ref 305* 310* 451* 464 472* 472 490 494*
                                                                                  494 546 549* 549 553* 561* 589* 596 605* 605 615
                                                                                  620* 620 626 646* 650 662 662 714* 716 716 731 731
                                                                                  761 768 768 780 793 793 813 823* 823 832 832
start                           000102 automatic       fixed bin(35,0)          dcl 103 set ref 304* 310* 451* 464 471* 471 490 493*
                                                                                  493 546 548* 548 553* 561* 589* 596 604* 604 615
                                                                                  619* 619 626 646* 650 662 662 714* 716 716 731 761
                                                                                  768 780 793 793 813 822* 822 832 832
state_ptr                       000100 automatic       pointer                  dcl 103 set ref 299* 310* 451* 464 490 546 553* 561*
                                                                                  589* 596 615 626 646* 650 662 662 714* 716 716 731
                                                                                  761 768 780 793 793 813 832 832
statement                              parameter       char                     unaligned dcl 86 set ref 11 299 300
substr                                                 builtin function         dcl 284 set ref 464 490 546 596 615 626* 626 650 653
                                                                                  662 662 716 716 780 793 793 813 821* 832 832
t                         0(09)        based           bit(1)                   level 2 packed unaligned dcl 160 set ref 496*
truncation_flag         142            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 371* 490*
window                                 based           char                     level 2 packed unaligned dcl 145 set ref 464 490 546
                                                                                  596 615 626 650 662 662 716 716 731* 761 768* 780
                                                                                  793 793 813 832 832
x                       164            based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-14 set ref 382*
y                         0(03)        based           fixed bin(14,0)          level 2 packed unaligned dcl 191 set ref 411*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
index                                                  builtin function         dcl 284

NAMES DECLARED BY EXPLICIT CONTEXT.
et_inst                         000253 constant        entry                    external dcl 11
get_instr_num                   001705 constant        entry                    internal dcl 743 ref 312
illegal_option                  001564 constant        label                    dcl 837 ref 485 507 510 527 539 636
illegal_term                    001636 constant        label                    dcl 849 ref 563 568 580
option_loop                     000643 constant        label                    dcl 451 ref 498 523 535 551 587 621 654 716 737
option_routine                  000000 constant        label                    array(12) dcl 485 ref 473
parse_ir_ind_term               002106 constant        entry                    internal dcl 799 ref 721
set_fb_pb                       001044 constant        label                    dcl 519 ref 502

NAMES DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 411
null                                                   builtin function         ref 355 359 366 374 426
rel                                                    builtin function         ref 411

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2566        2642    2421        2576
Length      3074    2421        54         216     144          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
et_inst                             254 external procedure  is an external procedure.  
get_instr_num                           internal procedure  shares stack frame of external procedure et_inst.  
parse_ir_ind_term                       internal procedure  shares stack frame of external procedure et_inst.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 instr_type_names            et_inst

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
et_inst                  000100 state_ptr                   et_inst
                         000102 start                       et_inst
                         000103 size                        et_inst
                         000104 next_statement_x            et_inst
                         000105 dec_num                     et_inst
                         000106 i                           et_inst
                         000107 len                         et_inst
                         000110 num_descs                   et_inst
                         000111 option_name                 et_inst
                         000112 option_num                  et_inst
                         000114 et_data_ptr                 et_inst

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      et_mf                         et_util$convert_decimal       et_util$get_next
et_util$skip

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
et_instr_data$instructions    et_instr_data$num_instructions                              etx$data1
etx$data2                     etx$data3                     etx$instr_page_2              etx$instruction_area




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000247       299 000266       300 000271       302 000272       304 000275       305 000277       310 000302
    312 000314       314 000315       334 000320       336 000332       339 000334       345 000335       347 000336
    350 000346       352 000352       353 000357       354 000361       355 000362       356 000366       358 000370
    359 000375       360 000402       361 000404       362 000405       364 000407       365 000414       366 000420
    367 000424       369 000426       371 000432       373 000433       374 000437       375 000444       381 000446
    382 000452       383 000457       385 000461       392 000465       399 000467       402 000501       404 000503
    405 000505       407 000507       410 000513       411 000521       412 000535       420 000537       422 000544
    424 000563       426 000566       430 000574       432 000605       439 000610       441 000611       442 000620
    443 000641       451 000643       460 000675       464 000677       466 000705       468 000712       471 000717
    472 000723       473 000731       475 000733       480 000735       481 000740       483 000777       485 001000
    490 001004       493 001014       494 001020       496 001026       498 001030       502 001031       507 001035
    510 001036       519 001044       523 001046       527 001047       533 001053       535 001055       539 001056
    546 001062       548 001067       549 001073       551 001101       553 001102       561 001115       563 001135
    565 001140       568 001144       570 001151       571 001153       580 001154       582 001160       583 001162
    587 001167       589 001170       596 001203       599 001211       600 001214       601 001247       604 001250
    605 001254       611 001262       613 001263       615 001270       619 001301       620 001305       621 001313
    624 001314       626 001315       628 001322       631 001324       632 001327       634 001362       636 001363
    646 001367       648 001402       650 001406       653 001415       654 001423       657 001424       660 001426
    662 001431       664 001476       666 001477       714 001502       716 001515       721 001527       724 001530
    729 001531       731 001532       737 001560       837 001564       841 001570       844 001635       849 001636
    853 001641       856 001704       743 001705       761 001706       764 001722       767 001726       768 001731
    770 001775       778 001776       780 002012       784 002027       791 002031       793 002034       797 002104
    799 002106       811 002107       813 002114       821 002123       822 002131       823 002135       824 002143
    827 002144       831 002146       832 002151       835 002215


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
