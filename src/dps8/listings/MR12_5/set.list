	COMPILATION LISTING OF SEGMENT set
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1042.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-07-01,CLJones), approve(86-08-05,MCR7458),
       16*     audit(86-06-30,EJSharpe), install(86-08-19,MR12.0-1120):
       17*     Made damaged and dnzp switch setting respect ring brackets.
       18*  2) change(88-03-14,Lippard), approve(88-05-02,MCR7881),
       19*     audit(88-06-09,Fawcett), install(88-08-02,MR12.2-1074):
       20*     Added audit_flag_path, for setting entry audit switch
       21*     (to cause generation of audit messages for all accesses to the
       22*     object.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 /* format: style4 */
       27 set:
       28      proc;
       29 
       30 /* Modified October 1984, Keith Loepere, for auditing info;
       31*also to not allow the setting of bc for upgraded dirs. */
       32 /* Modified June 1984, Keith Loepere, to use the new dc_find. */
       33 /* Modified February 1984, Lindsey Spratt, changed the dm_gino check to be against the write bracket instead of the read bracket. */
       34 /* Modified August 1983, E. N. Kittlitz, setfaults$if_active pvid, vtocx args */
       35 /* Modified March 1983, E. N. Kittlitz, never set dtem back, delete tpd */
       36 /* Modified February 1983, E. N. Kittlitz, 256K max length. */
       37 /* Modified 30 July, 1981, W. Olin Sibert, to change the rules for damaged switch setting */
       38 /* Modified 800409 by PG to add change_bc entries for WOS */
       39 /* Modified 800314 by PG to add entries to set dnzp switch */
       40 /* Modified 07/18/79 by Steve Webber to disallow setting bit count on directories given a pointer */
       41 /* Modified by D.Vinograd 6/76 to add entry to set volume dump control switches */
       42 /* Modified 05/31/76 by R. Bratt to call find_$finished when done */
       43 /* Modified 04/20/76 by R. Bratt to check mountedness of LV */
       44 /* Modified by R. Bratt for setting branch tpd */
       45 /* Modified for NSS 4/75 by THVV: remove actind, use vtoc/aste */
       46 /* Modified by Kobziar 9/74 to call appropriate entry in access_mode */
       47 /* Modified by E. Stone to add entries to change the entry point bound - Aug 1974 */
       48 /* Modified on 12-4-73 by Kobziar to not check for append perm. to set bc */
       49 
       50 /* parameters */
       51 
       52 dcl  a_audit_flag bit (1) aligned parameter;
       53 dcl  a_auth char (*) parameter;
       54 dcl  a_bitct fixed bin (24) parameter;
       55 dcl  1 a_btimes aligned like based_btimes;
       56 dcl  a_chasesw fixed bin (1) parameter;
       57 dcl  a_code fixed bin (35) parameter;
       58 dcl  a_copy fixed bin (1) parameter;
       59 dcl  a_damaged_sw bit (1) parameter;
       60 dcl  a_date bit (36) parameter;
       61 dcl  a_datep ptr parameter;
       62 dcl  a_delta_bc fixed bin (24) parameter;
       63 dcl  a_dirname char (*) parameter;
       64 dcl  a_dtime fixed bin (52) parameter;			/* time dumped */
       65 dcl  a_ename char (*) parameter;
       66 dcl  a_entry_bound fixed bin (14) parameter;
       67 dcl  a_max_length fixed bin (19) parameter;
       68 dcl  a_new_bc fixed bin (24) parameter;
       69 dcl  a_ncd fixed bin parameter;
       70 dcl  a_nid fixed bin parameter;
       71 dcl  a_old_bc fixed bin (24) parameter;
       72 dcl  a_safety_sw bit (1) parameter;
       73 dcl  a_segptr ptr parameter;
       74 dcl  a_setp ptr parameter;
       75 dcl  a_synchronized_sw bit (1) aligned parameter;
       76 
       77 /* based */
       78 
       79 dcl  1 a_reload_set_info aligned based like reload_set_info;
       80 dcl  1 based_time based aligned,
       81        2 dtem bit (36),
       82        2 dtd bit (36),
       83        2 dtu bit (36),
       84        2 dtm bit (36);
       85 
       86 dcl  1 based_btimes based aligned,			/* times from backup */
       87        2 dtem fixed bin (52),
       88        2 dtd fixed bin (52),
       89        2 dtu fixed bin (52),
       90        2 dtm fixed bin (52);
       91 
       92 /* automatic */
       93 
       94 dcl  1 access_name aligned,				/* 3 part access name - used for author and bc_author */
       95        2 person char (32),
       96        2 project char (32),
       97        2 tag char (1);
       98 dcl  audit_flag bit (1) aligned;
       99 dcl  auth char (32) aligned;
      100 dcl  authp ptr;
      101 dcl  bitct fixed bin (24);
      102 dcl  bs bit (1) aligned;
      103 dcl  1 btimes aligned like based_btimes;
      104 dcl  chasesw fixed bin (1);
      105 dcl  check_rb bit (1) aligned;
      106 dcl  code fixed bin (35);
      107 dcl  copy fixed bin (1);
      108 dcl  damaged_sw bit (1) aligned;
      109 dcl  date bit (36);
      110 dcl  delta_bc fixed bin (24);
      111 dcl  detailed_operation fixed bin (18) uns;
      112 dcl  dirname char (168);
      113 dcl  dirsw bit (1) aligned;
      114 dcl  dtm bit (36) aligned;
      115 dcl  dtu bit (36) aligned;
      116 dcl  ename char (32);
      117 dcl  entry_bound fixed bin (14);
      118 dcl  entry_type fixed bin;
      119 dcl  find_was_called bit (1) aligned;
      120 dcl  max_length fixed bin (19);
      121 dcl  mxl fixed bin (9);
      122 dcl  ncd fixed bin;
      123 dcl  new_bc fixed bin (24);
      124 dcl  nid fixed bin;
      125 dcl  old_bc fixed bin (24);
      126 dcl  1 pc_msk like vtoce_pc_sws aligned;
      127 dcl  1 pc_val like vtoce_pc_sws aligned;
      128 dcl  priv_ml bit (1) aligned init ("0"b);
      129 dcl  pvid bit (36) aligned;
      130 dcl  safety_sw bit (1) aligned;
      131 dcl  segptr ptr;
      132 dcl  setp ptr;
      133 dcl  setting_for_reloader fixed bin init (0);
      134 dcl  synchronized_sw bit (1) aligned;
      135 dcl  1 time aligned like based_time;
      136 dcl  uid bit (36) aligned;
      137 dcl  val fixed bin (17);
      138 dcl  vtocx fixed bin;
      139 
      140 /* constants */
      141 
      142 dcl  Normal_entry fixed bin init (1) static options (constant);
      143 dcl  Set_bc_entry fixed bin init (2) static options (constant);
      144 dcl  Change_bc_entry fixed bin init (3) static options (constant);
      145 dcl  Dsw_entry fixed bin init (4) static options (constant);
      146 dcl  Set_bc_entry_priv fixed bin init (5) static options (constant);
      147 dcl  Normal_priv_entry fixed bin init (6) static options (constant);
      148 
      149 /* external static */
      150 
      151 dcl  error_table_$ai_restricted external fixed bin (35);
      152 dcl  error_table_$argerr external fixed bin (35);
      153 dcl  error_table_$bad_ring_brackets external fixed bin (35);
      154 dcl  error_table_$dirseg external fixed bin (35);
      155 dcl  error_table_$link external fixed bin (35);
      156 dcl  error_table_$not_a_branch external fixed bin (35);
      157 dcl  error_table_$not_dm_ring external fixed bin (35);
      158 dcl  pds$access_name fixed bin (35) external;
      159 dcl  1 pds$transparent ext aligned,
      160        2 m bit (1) unaligned,
      161        2 u bit (1) unaligned;
      162 dcl  sys_info$data_management_ringno fixed bin external;
      163 dcl  sys_info$seg_size_256K fixed bin (19) external;
      164 
      165 /* entries */
      166 
      167 dcl  acc_name_$delete entry (ptr);
      168 dcl  acc_name_$elements entry (ptr, ptr, fixed bin (35));
      169 dcl  acc_name_$encode entry (ptr, ptr, fixed bin (35));
      170 dcl  change_dtem entry (ptr);
      171 dcl  level$get returns (fixed bin (17));
      172 dcl  lock$dir_unlock entry (pointer);
      173 dcl  mountedp entry (bit (36) aligned) returns (fixed bin (35));
      174 dcl  setfaults$if_active entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (1) aligned);
      175 dcl  sum$dirmod entry (pointer);
      176 dcl  vtoc_attributes$reloading entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (9), fixed bin (35));
      177 dcl  vtoc_attributes$set_dates entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
      178 dcl  vtoc_attributes$set_dump_switches entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin, fixed bin, fixed bin (35));
      179 dcl  vtoc_attributes$set_max_lth entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (9), bit (1) aligned, fixed bin (35));
      180 dcl  vtoc_attributes$set_pc_switches entry (bit (36) aligned, bit (36) aligned, fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
      181 
      182 /* builtins */
      183 
      184 dcl  (addr, binary, bit, clock, fixed, divide, length, ptr, string, substr, unspec) builtin;
      185 
      186 /* SET$COPYSW changes the setting of the copy switch in the branch effectively pointed to by
      187*   "entry" in the directory with path name "dirname" to "copy" if caller has
      188*   write permit in the directory. */
      189 
      190 copysw:
      191      entry (a_dirname, a_ename, a_copy, a_code);
      192 
      193 	detailed_operation = FS_OBJ_COPY_SW_MOD;
      194 	copy = a_copy;				/* must copy input arguments into stack before locking */
      195 	chasesw = 1;
      196 	check_rb = "1"b;
      197 	entry_type = Normal_entry;
      198 	call find_entry;
      199 	entry.copysw = bit (copy, 1);
      200 	go to finish;
      201 
      202 /* SET$AUTH changes the auth variable in the entry "ename" in the directory pointed to by
      203*   the pathname "dirname" . The entry is "chased" if the chase switch is on. The caller must
      204*   have write permit on the directory. */
      205 
      206 auth:
      207      entry (a_dirname, a_ename, a_chasesw, a_auth, a_code);
      208 
      209 	detailed_operation = FS_OBJ_AUTHOR_MOD;
      210 	chasesw = a_chasesw;
      211 	auth = a_auth;
      212 	check_rb = "0"b;
      213 	entry_type = Normal_entry;
      214 	call find_entry;
      215 	authp = addr (entry.author);			/* Get pointer to author. */
      216 
      217 set_auth:
      218 	call acc_name_$elements (addr (auth), addr (access_name), code);
      219 	if code ^= 0
      220 	then go to unlock;				/* Break up author into 3 part access name. */
      221 	call acc_name_$delete (authp);		/* Delete previous author if any */
      222 	call acc_name_$encode (authp, addr (access_name), code);
      223 	go to unlock;
      224 
      225 /* SET$BC changes the setting of the bit count item in the branch effectively pointed
      226*   to by "entry" in the directory with path name "dirname" to "bitct"
      227*   if caller has execute permit in the directory and write
      228*   or append permit in the branch. */
      229 
      230 /* SET$BC_SEG is the same as set$bc except that it takes a pointer to a segment rather than
      231*   "dirname" and "entry" as input arguments.  */
      232 
      233 bc_seg_priv:
      234      entry (a_segptr, a_bitct, a_code);			/* privileged bitcount setting - no access check */
      235 
      236 	entry_type = Set_bc_entry_priv;
      237 	go to bc_set_ptr_join;
      238 
      239 bc_seg:
      240      entry (a_segptr, a_bitct, a_code);
      241 
      242 	entry_type = Set_bc_entry;
      243 
      244 bc_set_ptr_join:
      245 	detailed_operation = FS_OBJ_BC_MOD;
      246 	bitct = a_bitct;				/* copy input args */
      247 	check_rb = "0"b;
      248 	call get_entry_ptr;
      249 	if dirsw
      250 	then					/* disallow setting bc on directory given pointer */
      251 	     goto dirseg;
      252 
      253 	go to set_bc;				/* Join common code. */
      254 
      255 bc:
      256      entry (a_dirname, a_ename, a_bitct, a_code);
      257 
      258 	detailed_operation = FS_OBJ_BC_MOD;
      259 	bitct = a_bitct;				/* must copy input arguments into stack before locking */
      260 	chasesw = 1;
      261 	check_rb = "0"b;
      262 	entry_type = Set_bc_entry;
      263 	call find_entry;
      264 
      265 set_bc:
      266 	if entry.dirsw then
      267 	     if binary (entry.ring_brackets (1), 3) > 1 then
      268 		if entry.multiple_class then		/* implies upgraded */
      269 		     go to ai_error;
      270 
      271 	entry.bc = bitct;				/* actually set the bit count in the entry */
      272 
      273 	call acc_name_$delete (addr (entry.bc_author));	/* set the bc author */
      274 	call acc_name_$encode (addr (entry.bc_author), addr (pds$access_name), code);
      275 
      276 	go to finish;
      277 
      278 /* SET$CHANGE_BC_PATH adds a specified amount to the bitcount, and returns the
      279*   old and new bitcount to the caller. It can be used by multiple processes
      280*   to synchronize their writing to an unstructured segment without any other
      281*   locking protocol. */
      282 
      283 change_bc_path:
      284      entry (a_dirname, a_ename, a_delta_bc, a_old_bc, a_new_bc, a_code);
      285 
      286 	detailed_operation = FS_OBJ_BC_MOD;
      287 	delta_bc = a_delta_bc;
      288 	chasesw = 1;
      289 	check_rb = "0"b;
      290 	entry_type = Change_bc_entry;
      291 	call find_entry;
      292 	go to change_bc;
      293 
      294 /* SET$CHANGE_BC_PTR is the same as set$change_bc_path except that it takes
      295*   a pointer to a segment. */
      296 
      297 change_bc_ptr:
      298      entry (a_segptr, a_delta_bc, a_old_bc, a_new_bc, a_code);
      299 
      300 	detailed_operation = FS_OBJ_BC_MOD;
      301 	delta_bc = a_delta_bc;
      302 	check_rb = "0"b;
      303 	entry_type = Change_bc_entry;
      304 	call get_entry_ptr;
      305 	if dirsw
      306 	then go to dirseg;
      307 
      308 change_bc:
      309 	old_bc = entry.bc;
      310 	new_bc, bitct = old_bc + delta_bc;
      311 	go to set_bc;
      312 
      313 /* SET$DTD changes the setting of the date time dumped item in the branch effectively pointed to
      314*   by "entry" in the directory with path name "dirname" to "date"
      315*   if caller has write permit in the directory . */
      316 
      317 /* SET$BACKUP_DUMP_TIME is the same as set$dtd except that it takes a fixed bin (52)
      318*   time instead of a bit (36) file system time.  */
      319 
      320 dtd:
      321      entry (a_dirname, a_ename, a_date, a_code);
      322 
      323 	date = a_date;				/* must copy input argument into stack before locking */
      324 	entry_type = Normal_entry;
      325 	go to set_dtd;				/* Join common code. */
      326 
      327 backup_dump_time:
      328      entry (a_dirname, a_ename, a_dtime, a_code);
      329 
      330 	date = substr (bit (a_dtime, 52), 1, length (date)); /* copy and convert input argument */
      331 	entry_type = Normal_priv_entry;
      332 
      333 set_dtd:
      334 	detailed_operation = FS_OBJ_DT_DUMPED_MOD;
      335 	chasesw = 0;
      336 	check_rb = "0"b;
      337 	call find_entry;
      338 	if bs
      339 	then entry.dtd = date;
      340 	else link.dtd = date;
      341 	go to unlock;
      342 
      343 /* SET$DATES changes the setting of the date time used, date time modified and date time entry modified
      344*   items in the branch effectively pointed to by "entry" in the directory with path name "dirname" to
      345*   "date" if caller has write permit in the directory. */
      346 
      347 dates:
      348      entry (a_dirname, a_ename, a_datep, a_code);
      349 
      350 	detailed_operation = FS_OBJ_DATES_MOD;
      351 	time = a_datep -> based_time;			/* must copy input into stack before locking */
      352 	chasesw = 0;
      353 	check_rb = "0"b;
      354 	entry_type = Normal_entry;
      355 	call find_entry;
      356 	if bs then do;
      357 	     uid = entry.uid;			/* Extract unique ID */
      358 	     pvid = entry.pvid;
      359 	     vtocx = entry.vtocx;
      360 	     dtu = time.dtu;
      361 	     dtm = time.dtm;
      362 	     if dirsw
      363 	     then code = 0;				/* assume RLV is always mounted */
      364 	     else code = mountedp (dir.sons_lvid);	/* only if mounted! */
      365 	     if code = 0
      366 	     then call vtoc_attributes$set_dates (uid, pvid, vtocx, dtu, dtm, code);
      367 	     if code ^= 0
      368 	     then go to unlock;
      369 	     entry.dtem = time.dtem;
      370 	     entry.dtd = time.dtd;
      371 	end;
      372 	else do;
      373 	     link.dtem = time.dtem;
      374 	     link.dtd = time.dtd;
      375 	end;
      376 	go to unlock;
      377 
      378 /* SET$DUMP_SWITCHES is used to set/reset the dump control switches  in the vtoce of
      379*   a branch. The two switches, no_complete_dump and no incremental dump are set on
      380*   if the input is positive, off if negative and not set if zero. */
      381 
      382 volume_dump_switches:
      383      entry (a_dirname, a_ename, a_nid, a_ncd, a_code);
      384 
      385 	detailed_operation = FS_OBJ_VOL_DUMP_SW_MOD;
      386 	chasesw = 1;
      387 	check_rb = "1"b;
      388 	ncd = a_ncd;
      389 	nid = a_nid;
      390 	entry_type = Normal_entry;
      391 	call find_entry;
      392 	if bs then do;
      393 	     uid = entry.uid;
      394 	     pvid = entry.pvid;
      395 	     vtocx = entry.vtocx;
      396 	     if dirsw
      397 	     then code = error_table_$dirseg;
      398 	     else code = mountedp (dir.sons_lvid);
      399 	     if code = 0
      400 	     then call vtoc_attributes$set_dump_switches (uid, pvid, vtocx, nid, ncd, code);
      401 	end;
      402 	else code = error_table_$link;
      403 	goto unlock;
      404 
      405 /* SET$BACKUP_TIMES is used by the reloading process to set the following
      406*   items in a directory branch: date-time entry modified,
      407*   date-time dumped, date-time used, date-time modified.  */
      408 
      409 backup_times:
      410      entry (a_dirname, a_ename, a_btimes, a_code);
      411 
      412 	detailed_operation = FS_OBJ_BACKUP_TIMES_MOD;
      413 	btimes = a_btimes;				/* copy structure argument */
      414 	chasesw = 0;
      415 	check_rb = "0"b;
      416 	entry_type = Normal_entry;
      417 	call find_entry;
      418 	if bs then do;
      419 	     uid = entry.uid;			/* Extract unique ID */
      420 	     pvid = entry.pvid;
      421 	     vtocx = entry.vtocx;
      422 	     dtu = substr (bit (btimes.dtu, 52), 1, length (dtu));
      423 	     dtm = substr (bit (btimes.dtm, 52), 1, length (dtm));
      424 	     if dirsw
      425 	     then code = 0;				/* assume RLV always mounted */
      426 	     else code = mountedp (dir.sons_lvid);	/* only if mounted! */
      427 	     if code = 0
      428 	     then call vtoc_attributes$set_dates (uid, pvid, vtocx, dtu, dtm, code);
      429 	     if code ^= 0
      430 	     then go to unlock;
      431 	     entry.dtem = substr (bit (btimes.dtem, 52), 1, length (entry.dtem));
      432 	     entry.dtd = substr (bit (btimes.dtd, 52), 1, length (entry.dtd));
      433 	end;
      434 	else do;
      435 	     link.dtem = substr (bit (btimes.dtem, 52), 1, length (link.dtem));
      436 	     link.dtd = substr (bit (btimes.dtd, 36), 1, length (link.dtd));
      437 	end;
      438 	go to unlock;
      439 
      440 /* SET$SAFETY_SWITCH_PTR changes the safety switch in the directory entry corresponding
      441*   to the pointer "segptr".  */
      442 
      443 /* SET$_SAFETY_SWITCH_PATH is identical to set$safety_switch pointer except that
      444*   the "ename" and "dirname" are specified instead of a segment pointer.  */
      445 
      446 safety_sw_ptr:
      447      entry (a_segptr, a_safety_sw, a_code);
      448 
      449 	detailed_operation = FS_OBJ_SAFETY_SW_MOD;
      450 	safety_sw = a_safety_sw;
      451 	check_rb = "1"b;
      452 	entry_type = Normal_entry;
      453 	call get_entry_ptr;
      454 	go to set_safety;				/* Join common code. */
      455 
      456 safety_sw_path:
      457      entry (a_dirname, a_ename, a_safety_sw, a_code);
      458 
      459 	detailed_operation = FS_OBJ_SAFETY_SW_MOD;
      460 	safety_sw = a_safety_sw;
      461 	chasesw = 1;
      462 	check_rb = "1"b;
      463 	entry_type = Normal_entry;
      464 	call find_entry;
      465 
      466 set_safety:
      467 	entry.safety_sw = safety_sw;
      468 	go to finish;
      469 
      470 /* SET$AUDIT_FLAG_PATH changes the audit switch in the directory entry for
      471*   the specified path. */
      472 
      473 audit_flag_path:
      474      entry (a_dirname, a_ename, a_audit_flag, a_code);
      475 
      476 	detailed_operation = FS_OBJ_AUDIT_FLAG_MOD;
      477 	audit_flag = a_audit_flag;
      478 	chasesw = 1;
      479 	check_rb = "1"b;
      480 	entry_type = Normal_entry;
      481 	call find_entry;
      482 
      483 set_audit_flag:
      484 	entry.audit_flag = audit_flag;
      485 	go to finish;
      486 
      487 /* SET$DAMAGED_SW_PTR changes the damaged switch in the directory entry corresponding
      488*   to the pointer "segptr".  */
      489 
      490 /* SET$DAMAGED_SW_PATH is identical to set$damaged_sw_ptr except that
      491*   the "ename" and "dirname" are specified instead of a segment pointer.  */
      492 
      493 damaged_sw_ptr:
      494      entry (a_segptr, a_damaged_sw, a_code);
      495 
      496 	detailed_operation = FS_OBJ_DAMAGED_SW_MOD;
      497 	damaged_sw = a_damaged_sw;
      498 	check_rb = "1"b;
      499 	entry_type = Dsw_entry;
      500 	call get_entry_ptr;
      501 	go to set_damaged;				/* Join common code. */
      502 
      503 damaged_sw_path:
      504      entry (a_dirname, a_ename, a_damaged_sw, a_code);
      505 
      506 	detailed_operation = FS_OBJ_DAMAGED_SW_MOD;
      507 	damaged_sw = a_damaged_sw;
      508 	chasesw = 1;
      509 	check_rb = "1"b;
      510 	entry_type = Dsw_entry;
      511 	call find_entry;
      512 
      513 set_damaged:
      514 	unspec (pc_val) = ""b;
      515 	unspec (pc_msk) = ""b;
      516 	pc_val.damaged = damaged_sw;
      517 	pc_msk.damaged = "1"b;
      518 	uid = entry.uid;
      519 	pvid = entry.pvid;
      520 	vtocx = entry.vtocx;
      521 	if dirsw
      522 	then code = 0;
      523 	else code = mountedp (dir.sons_lvid);
      524 	if code = 0
      525 	then call vtoc_attributes$set_pc_switches (uid, pvid, vtocx, string (pc_val), string (pc_msk), code);
      526 	if code ^= 0
      527 	then go to unlock;
      528 	go to finish;
      529 
      530 /* SET$DNZP_SW_PTR changes the dnzp switch in the directory entry corresponding
      531*   to the pointer "segptr".  */
      532 
      533 /* SET$DNZP_SW_PATH is identical to set$dnzp_sw_ptr except that
      534*   the "ename" and "dirname" are specified instead of a segment pointer.  */
      535 
      536 /* parameters */
      537 
      538 declare  a_dnzp_sw bit (1) aligned parameter;
      539 
      540 /* automatic */
      541 
      542 declare  dnzp_sw bit (1) aligned;
      543 
      544 /* program */
      545 
      546 dnzp_sw_ptr:
      547      entry (a_segptr, a_dnzp_sw, a_code);
      548 
      549 	detailed_operation = FS_OBJ_DNZP_MOD;
      550 	dnzp_sw = a_dnzp_sw;
      551 	check_rb = "1"b;
      552 	entry_type = Normal_entry;
      553 	call get_entry_ptr;
      554 	go to set_dnzp;				/* Join common code. */
      555 
      556 dnzp_sw_path:
      557      entry (a_dirname, a_ename, a_dnzp_sw, a_code);
      558 
      559 	detailed_operation = FS_OBJ_DNZP_MOD;
      560 	dnzp_sw = a_dnzp_sw;
      561 	chasesw = 1;
      562 	check_rb = "1"b;
      563 	entry_type = Normal_entry;
      564 	call find_entry;
      565 
      566 set_dnzp:
      567 	if dirsw
      568 	then go to dirseg;				/* Oh no you don't */
      569 
      570 	unspec (pc_val) = ""b;
      571 	unspec (pc_msk) = ""b;
      572 	pc_val.dnzp = dnzp_sw;
      573 	pc_msk.dnzp = "1"b;
      574 	uid = entry.uid;
      575 	pvid = entry.pvid;
      576 	vtocx = entry.vtocx;
      577 	if dirsw
      578 	then code = 0;
      579 	else code = mountedp (dir.sons_lvid);
      580 	if code = 0
      581 	then call vtoc_attributes$set_pc_switches (uid, pvid, vtocx, string (pc_val), string (pc_msk), code);
      582 	if code ^= 0
      583 	then go to unlock;
      584 	go to finish;
      585 
      586 /* SET$SYNCHRONIZED_SW changes the synchronized switch in the VTOCE
      587*   corresponding to the path supplied. This is used by Data Management
      588*   to order writes done by Page Control. */
      589 
      590 synchronized_sw:
      591      entry (a_dirname, a_ename, a_synchronized_sw, a_code);
      592 
      593 	detailed_operation = FS_OBJ_SYNC_SW_MOD;
      594 	synchronized_sw = a_synchronized_sw;
      595 	chasesw = 0;
      596 	check_rb = "1"b;
      597 	entry_type = Normal_entry;
      598 	call find_entry;
      599 
      600 	if dirsw
      601 	then goto dirseg;
      602 
      603 	if fixed (entry.ring_brackets (1), 3) > sys_info$data_management_ringno
      604 	then do;
      605 	     code = error_table_$not_dm_ring;
      606 	     goto unlock;
      607 	end;
      608 
      609 	unspec (pc_val) = ""b;
      610 	unspec (pc_msk) = ""b;
      611 	pc_val.synchronized = synchronized_sw;
      612 	pc_msk.synchronized = "1"b;
      613 	uid = entry.uid;
      614 	pvid = entry.pvid;
      615 	vtocx = entry.vtocx;
      616 	code = mountedp (dir.sons_lvid);
      617 	if code = 0
      618 	then call vtoc_attributes$set_pc_switches (uid, pvid, vtocx, string (pc_val), string (pc_msk), code);
      619 	if code ^= 0 then goto unlock;
      620 	goto finish;
      621 
      622 /* SET$MAX_LENGTH_PTR resets the maximum length of the segment pointed to
      623*   by "segptr" to the "max_length" specified in words.  */
      624 
      625 /* SET$MAX_LENGTH_PATH is identical to set$max_length_ptr except that the
      626*   "ename" and "dirname" of the segment are sepcified instead of the "segptr".  */
      627 
      628 max_length_ptr:
      629      entry (a_segptr, a_max_length, a_code);
      630 
      631 	detailed_operation = FS_OBJ_MAX_LEN_MOD;
      632 	max_length = a_max_length;
      633 	check_rb = "1"b;
      634 	entry_type = Normal_entry;
      635 	call get_entry_ptr;
      636 	go to set_max_length;
      637 
      638 max_length_priv:
      639      entry (a_dirname, a_ename, a_max_length, a_code);
      640 
      641 	priv_ml = "1"b;
      642 	check_rb = "0"b;
      643 	goto cp_ml_args;
      644 
      645 max_length_path:
      646      entry (a_dirname, a_ename, a_max_length, a_code);
      647 	check_rb = "1"b;
      648 
      649 cp_ml_args:
      650 	detailed_operation = FS_OBJ_MAX_LEN_MOD;
      651 	max_length = a_max_length;
      652 	chasesw = 1;
      653 	entry_type = Normal_entry;
      654 	call find_entry;
      655 
      656 set_max_length:
      657 	if dirsw
      658 	then go to dirseg;
      659 	if max_length < 0
      660 	then go to argerr;
      661 	if max_length > sys_info$seg_size_256K
      662 	then go to argerr;
      663 	uid = entry.uid;				/* Extract unique ID */
      664 	pvid = entry.pvid;
      665 	vtocx = entry.vtocx;
      666 	mxl = divide (max_length + 1023, 1024, 9, 0);	/* Correct units */
      667 	code = mountedp (dir.sons_lvid);
      668 	if code = 0
      669 	then call vtoc_attributes$set_max_lth (uid, pvid, vtocx, mxl, priv_ml, code);
      670 	if code ^= 0
      671 	then go to unlock;
      672 	go to finish;
      673 
      674 /* SET$BC_AUTH_PATH is used by the reloader to set the bitcount author of the
      675*   directory entry corresponding to the segment indicated by "ename" and
      676*   "dirname". */
      677 
      678 bc_auth_path:
      679      entry (a_dirname, a_ename, a_auth, a_code);
      680 
      681 	detailed_operation = FS_OBJ_BC_AUTHOR_MOD;
      682 	auth = a_auth;
      683 	chasesw = 1;
      684 	check_rb = "0"b;
      685 	entry_type = Normal_entry;
      686 	call find_entry;				/* no AIM check since privileged entry */
      687 
      688 	authp = addr (entry.bc_author);		/* Get pointer to bit count author. */
      689 	go to set_auth;				/* Join common author-setting code. */
      690 
      691 /* SET$ENTRY_BOUND_PTR sets the entry point bound switch and changes the
      692*   entry point bound of the segment pointed to by "segptr" to the "entry_bound"
      693*   specified in words if "entry_bound" is greater than 0.
      694*   If "entry_bound" equals 0, then the entry point bound switch is reset and
      695*   the entry point bound is changed to 0. */
      696 
      697 /* SET$ENTRY_BOUND_PATH is identical to set$entry_point_ptr except that
      698*   then "dirname" and "ename" of the segment are specified instead of the "segptr". */
      699 
      700 entry_bound_ptr:
      701      entry (a_segptr, a_entry_bound, a_code);
      702 
      703 	detailed_operation = FS_OBJ_ENTRY_BOUND_MOD;
      704 	entry_bound = a_entry_bound;
      705 	check_rb = "1"b;
      706 	entry_type = Normal_entry;
      707 	call get_entry_ptr;
      708 	go to set_call_limiter;
      709 
      710 entry_bound_path:
      711      entry (a_dirname, a_ename, a_entry_bound, a_code);
      712 
      713 	detailed_operation = FS_OBJ_ENTRY_BOUND_MOD;
      714 	entry_bound = a_entry_bound;
      715 	chasesw = 1;
      716 	check_rb = "1"b;
      717 	entry_type = Normal_entry;
      718 	call find_entry;
      719 
      720 set_call_limiter:
      721 	if dirsw
      722 	then go to dirseg;
      723 	if entry_bound < 0
      724 	then go to argerr;				/* Limited to 14 bits in sdw */
      725 	if entry_bound > 16383
      726 	then go to argerr;
      727 	uid = entry.uid;
      728 	pvid = entry.pvid;
      729 	vtocx = entry.vtocx;
      730 	call setfaults$if_active (uid, pvid, vtocx, "0"b);
      731 	if entry_bound = 0 then do;
      732 	     entry.entrypt_sw = "0"b;
      733 	     entry.entrypt_bound = "0"b;
      734 	end;
      735 	else do;
      736 	     entry.entrypt_sw = "1"b;
      737 	     entry.entrypt_bound = bit (entry_bound, 14);
      738 	end;
      739 	go to finish;
      740 
      741 /* SET$SET_FOR_RELOADER  changes a number of variables in the entry "ename" in
      742*   the directory pointed to by the pathname "dirname".
      743*   It also makes one call to set appropriate items in the VTOC.
      744*   The entry is not chased.    The caller must have write permit
      745*   on the directory.  It is intended that that this entry in set
      746*   provide the sum of the functionality of a number of other entries:
      747*   that is the usual checks are made and status codes are returned.
      748*   Because this entry can only be reached through a priviliged gate,
      749*   the max_length is not checked against the current length ---
      750*   this is not only consistent with the privileged set_max_length entry,
      751*   but also with the fact that the dumper will never write more
      752*   meaningfull data than "max_length" to tape */
      753 
      754 set_for_reloader:
      755      entry (a_dirname, a_ename, a_setp, a_code);
      756 
      757 	detailed_operation = FS_OBJ_FOR_RELOADER_MOD;
      758 	setp = a_setp;
      759 	reload_set_info = setp -> a_reload_set_info;	/* copy input before locking */
      760 	if reload_set_info.version ^= reload_set_version_2 then do;
      761 						/* called with bad structure */
      762 	     a_code = error_table_$argerr;
      763 	     return;
      764 	end;
      765 	setting_for_reloader = 1;			/* remember to return info */
      766 	chasesw = 0;
      767 	check_rb = "0"b;
      768 	entry_type = Normal_priv_entry;
      769 	call find_entry;
      770 	uid = entry.uid;				/* Extract unique ID */
      771 	pvid = entry.pvid;
      772 	vtocx = entry.vtocx;
      773 
      774 	if ^bs then do;
      775 	     code = error_table_$not_a_branch;
      776 	     go to unlock;
      777 	end;
      778 
      779 	if reload_set_info.should_set.safety_sw
      780 	then					/* set the safety_sw? */
      781 	     entry.safety_sw = reload_set_info.safety_sw;
      782 
      783 	if reload_set_info.should_set.audit_flag
      784 	then					/* set the audit_flag? */
      785 	     entry.audit_flag = reload_set_info.audit_flag;
      786 
      787 
      788 
      789 	if reload_set_info.should_set.author then do;	/* author? */
      790 	     authp = addr (entry.author);
      791 	     call acc_name_$elements (addr (reload_set_info.author), addr (access_name), reload_set_info.author_code);
      792 	     if reload_set_info.author_code = 0 then do;	/* if no errs proceed */
      793 		call acc_name_$delete (authp);
      794 		call acc_name_$encode (authp, addr (access_name), reload_set_info.author_code);
      795 	     end;
      796 	end;
      797 
      798 	if reload_set_info.should_set.bc_author then do;	/* no AIM check since privileged entry */
      799 	     authp = addr (entry.bc_author);
      800 	     call acc_name_$elements (addr (reload_set_info.bc_author), addr (access_name),
      801 		reload_set_info.bc_author_code);
      802 	     if reload_set_info.bc_author_code = 0 then do;
      803 		call acc_name_$delete (authp);
      804 		call acc_name_$encode (authp, addr (access_name), reload_set_info.bc_author_code);
      805 	     end;
      806 	end;
      807 
      808 /* Now for the tricky part */
      809 /* go to vtoc to set dtm,dtu,mxl */
      810 /* if go to vtoc for mxl,  need not do setfaults here */
      811 /* even if setting entry_bound */
      812 
      813 	if reload_set_info.should_set.dtu
      814 	then dtu = reload_set_info.dtu;		/* dtu = 0 means va$ wont set */
      815 	else dtu = "0"b;
      816 
      817 	if reload_set_info.should_set.dtm
      818 	then dtm = reload_set_info.dtm;		/* dtm = 0 means va$ wont set */
      819 	else dtm = "0"b;
      820 
      821 	mxl = -1;					/* mxl = -1 means va$ wont set, dont setfaults */
      822 	if reload_set_info.should_set.max_length then do;
      823 	     if dirsw
      824 	     then reload_set_info.max_length_code = error_table_$dirseg;
      825 						/* make some checks */
      826 	     else if reload_set_info.max_length < 0
      827 	     then reload_set_info.max_length_code = error_table_$argerr;
      828 	     else mxl = divide (reload_set_info.max_length + 1023, 1024, 9, 0);
      829 	end;
      830 
      831 	if dtm | dtu | mxl >= 0 then do;		/* something to set in vtoc */
      832 	     if dirsw
      833 	     then code = 0;				/* RLV always mounted */
      834 	     else code = mountedp (dir.sons_lvid);	/* check mountedness */
      835 	     if code = 0
      836 	     then call vtoc_attributes$reloading (uid, pvid, vtocx, dtu, dtm, mxl, code);
      837 						/*  NOTE: for  now we are punting the no mounted case */
      838 	end;					/* vtoc_attr has done setfaults if mxl >= 0 */
      839 
      840 	if reload_set_info.should_set.entry_bound then do;/* see about epb */
      841 	     if dirsw
      842 	     then reload_set_info.entry_bound_code = error_table_$dirseg;
      843 	     else if reload_set_info.entry_bound < 0
      844 	     then reload_set_info.entry_bound_code = error_table_$argerr;
      845 	     else if reload_set_info.entry_bound > 16383
      846 	     then reload_set_info.entry_bound_code = error_table_$argerr;
      847 	     else do;				/* we are willing to set it */
      848 		if mxl < 0 | code ^= 0
      849 		then				/* do setfault now, if not already done */
      850 		     call setfaults$if_active (uid, pvid, vtocx, "0"b);
      851 		if reload_set_info.entry_bound = 0 then do;
      852 						/* clear relevant fields */
      853 		     entry.entrypt_sw = "0"b;
      854 		     entry.entrypt_bound = "0"b;
      855 		end;
      856 		else do;
      857 		     entry.entrypt_sw = "1"b;
      858 		     entry.entrypt_bound = bit (reload_set_info.entry_bound, 14);
      859 		end;
      860 	     end;
      861 	end;
      862 
      863 	if reload_set_info.should_set.dtem
      864 	then					/* date time entry modified? */
      865 	     entry.dtem = reload_set_info.dtem;
      866 
      867 	if reload_set_info.should_set.dtd
      868 	then					/* date time dumped? */
      869 	     entry.dtd = reload_set_info.dtd;
      870 
      871 	go to finish;
      872 
      873 /* Update dtem, unlock entry, notify segment control that directory containing
      874*   entry has been modified and return */
      875 
      876 finish:
      877 	if pds$transparent.m = "0"b
      878 	then if entry.dtem ^= bit (binary (clock (), 52), 36)
      879 	     then call change_dtem (ep);
      880 
      881 unlock:
      882 	call sum$dirmod (dp);
      883 	if find_was_called
      884 	then call dc_find$finished (dp, "1"b);
      885 	else call lock$dir_unlock (dp);
      886 
      887 	if setting_for_reloader ^= 0
      888 	then setp -> a_reload_set_info = reload_set_info;
      889 	else if entry_type = Change_bc_entry then do;
      890 	     a_old_bc = old_bc;
      891 	     a_new_bc = new_bc;
      892 	end;
      893 
      894 finale:
      895 	a_code = code;
      896 	return;
      897 
      898 /* Error Handling */
      899 
      900 ai_error: 
      901 	code = error_table_$ai_restricted;
      902 	go to unlock;
      903 
      904 argerr:
      905 	code = error_table_$argerr;
      906 	go to unlock;
      907 
      908 dirseg:
      909 	code = error_table_$dirseg;
      910 	go to unlock;
      911 
      912 bracket_error:
      913 	code = error_table_$bad_ring_brackets;
      914 	goto unlock;
      915 
      916 /* internal procedures */
      917 
      918 find_entry:
      919      proc;					/* get a pointer to the entry and lock the directory */
      920 
      921 	code = 0;
      922 	dirname = a_dirname;
      923 	ename = a_ename;
      924 	if entry_type = Normal_entry then
      925 	     call dc_find$obj_status_write (dirname, ename, chasesw, detailed_operation, ep, code);
      926 	else if entry_type = Set_bc_entry then
      927 	     call dc_find$obj_bc_write (dirname, ename, bitct, ep, code);
      928 	else if entry_type = Change_bc_entry then
      929 	     call dc_find$obj_bc_delta_write (dirname, ename, delta_bc, ep, code);
      930 	else if entry_type = Dsw_entry then		/* allow no m on parent */
      931 	     call dc_find$obj_attributes_write (dirname, ename, chasesw, detailed_operation, ep, code);
      932 	else if entry_type = Set_bc_entry_priv | entry_type = Normal_priv_entry then
      933 	     call dc_find$obj_status_write_priv (dirname, ename, chasesw, detailed_operation, ep, code);
      934 	dp = ptr (ep, 0);
      935 	if code ^= 0
      936 	then go to finale;
      937 	find_was_called = "1"b;
      938 	go to check;
      939 
      940 get_entry_ptr:
      941      entry;					/* get a pointer to the entry and lock the directory */
      942 
      943 	code = 0;
      944 	segptr = a_segptr;
      945 	find_was_called = "0"b;
      946 	if entry_type = Normal_entry then
      947 	     call dc_find$obj_status_write_ptr (segptr, detailed_operation, ep, code);
      948 	else if entry_type = Set_bc_entry then
      949 	     call dc_find$obj_bc_write_ptr (segptr, bitct, ep, code);
      950 	else if entry_type = Change_bc_entry then
      951 	     call dc_find$obj_bc_delta_write_ptr (segptr, delta_bc, ep, code);
      952 	else if entry_type = Dsw_entry then		/* allow no m on parent */
      953 	     call dc_find$obj_attributes_write_ptr (segptr, detailed_operation, ep, code);
      954 	else if entry_type = Set_bc_entry_priv | entry_type = Normal_priv_entry then
      955 	     call dc_find$obj_status_write_priv_ptr (segptr, detailed_operation, ep, code);
      956 	dp = ptr (ep, 0);
      957 	if code ^= 0
      958 	then go to finale;
      959 
      960 check:
      961 	bs = entry.bs;
      962 	dirsw = entry.dirsw;
      963 	if check_rb then do;			/* also need to check ring brackets */
      964 	     val = level$get ();
      965 	     if dirsw then do;
      966 		if val > fixed (entry.ex_ring_brackets (1), 3)
      967 		then go to bracket_error;
      968 	     end;
      969 	     else do;
      970 		if val > fixed (entry.ring_brackets (1), 3)
      971 		then go to bracket_error;
      972 	     end;
      973 	end;
      974 
      975      end find_entry;
      976 
      977 /* include files */
      978 
      979  /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      979 
      980  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      980 
      981  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      981 
      982  /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  4     2 
  4     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  4     4 
  4     5 
  4     6 dcl 1 link based (ep) aligned,
  4     7 
  4     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  4    10 
  4    11     2 type bit (18),				/* type = dir link */
  4    12     2 size fixed bin (17),				/* size of link in words */
  4    13 
  4    14     2 uid bit (36),					/* unique id of entry */
  4    15 
  4    16     2 dtem bit (36),				/* date-time entry modified */
  4    17 
  4    18     2 bs bit (1),					/* entry switch = 1 if entry */
  4    19     2 pad0 bit (17),
  4    20     2 nnames fixed bin (17),				/* number of names for this entry */
  4    21 
  4    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    24 
  4    25     2 author,					/* user who created entry */
  4    26       3 pers_rp bit (18),				/* name of user who created entry */
  4    27       3 proj_rp bit (18),				/* project of user who created entry */
  4    28 
  4    29       3 tag char (1),				/* tag of user who created entry */
  4    30       3 pad1 char (3),
  4    31 
  4    32     2 primary_name bit (504),				/* first name on name list */
  4    33 
  4    34     2 dtd bit (36),					/* date time dumped */
  4    35 
  4    36     2 pad2 bit (36),
  4    37 
  4    38 
  4    39 /* the declarations below are only applicable to links */
  4    40 
  4    41     2 pad3 bit (18),
  4    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  4    43 
  4    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  4    45 
  4    46     2 checksum bit (36),				/* checksum from uid */
  4    47 
  4    48     2 owner bit (36);				/* uid of containing directory */
  4    49 
  4    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
      982 
      983  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
  5     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  5     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
  5     8*                                                   END HISTORY COMMENTS */
  5     9 
  5    10 
  5    11 /* The possible events within the file system; access codes and
  5    12*   detailed operation codes.  October 1984, Keith Loepere. */
  5    13 
  5    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  5    15 
  5    16 /* Major file system operations. */
  5    17 
  5    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
  5    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
  5    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
  5    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
  5    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
  5    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
  5    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
  5    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
  5    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
  5    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
  5    28 
  5    29 /* Detailed operations. */
  5    30 
  5    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
  5    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
  5    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
  5    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
  5    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
  5    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
  5    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
  5    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
  5    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
  5    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
  5    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
  5    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
  5    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
  5    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
  5    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
  5    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
  5    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
  5    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
  5    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
  5    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
  5    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
  5    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
  5    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
  5    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
  5    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
  5    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
  5    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
  5    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
  5    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
  5    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
  5    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
  5    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
  5    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
  5    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
  5    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
  5    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
  5    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
  5    68 
  5    69 /* END include file fs_obj_access_codes.incl.pl1 */
      983 
      984  /*	BEGIN INCLUDE FILE ... reload_set_info.incl.pl1 ... last modified March 1976 by R. Bratt */
  6     2 
  6     3 
  6     4 
  6     5 
  6     6 /****^  HISTORY COMMENTS:
  6     7*  1) change(88-05-11,Lippard), approve(88-05-02,MCR7881),
  6     8*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  6     9*     Add audit_flag and the should_set audit_flag. This changes the version
  6    10*      number to 2.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 
  6    14 /* This structure is input to set$set_for_reloader. */
  6    15 
  6    16 dcl  reload_set_version_2 fixed bin int static init (2);
  6    17 
  6    18 dcl 1 reload_set_info aligned,
  6    19     2 version fixed bin,				/* set by caller, checked by callee */
  6    20     2 should_set,					/* if should_set.item then set item */
  6    21       3 safety_sw bit (1) unal,
  6    22       3 audit_flag bit (1) unal,
  6    23       3 actind bit (1) unal,
  6    24       3 actime bit (1) unal,
  6    25       3 author bit (1) unal,
  6    26       3 bc_author bit (1) unal,
  6    27       3 max_length bit (1) unal,
  6    28       3 entry_bound bit (1) unal,
  6    29       3 dtem bit (1) unal,
  6    30       3 dtd bit (1) unal,
  6    31       3 dtu bit (1) unal,
  6    32       3 dtm bit (1) unal,
  6    33       3 tpd bit (1) unal,
  6    34       3 pad bit (24) unaligned,
  6    35     2 safety_sw bit (1) aligned,			/* safety switch */
  6    36     2 audit_flag bit (1) aligned,			/* segment must be audited */
  6    37     2 actind bit (18) aligned,			/* activity indicator */
  6    38     2 actime bit (36) aligned,			/* activity time */
  6    39     2 author char (32) aligned,
  6    40     2 author_code fixed bin (35),			/* ^0 => erred setting author */
  6    41     2 bc_author char (32) aligned,
  6    42     2 bc_author_code fixed bin (35),			/* ^0 => erred setting bc_author */
  6    43     2 max_length fixed bin (19),
  6    44     2 max_length_code fixed bin (35),			/* ^0 => erred setting max length */
  6    45     2 entry_bound fixed bin (14),
  6    46     2 entry_bound_code fixed bin (35),			/* ^0 => erred setting epb */
  6    47     2 dtem bit (36) aligned,				/* date time dumped */
  6    48     2 dtd bit (36) aligned,				/* date time dumped */
  6    49     2 dtu bit (36) aligned,				/* date time used */
  6    50     2 dtm bit (36) aligned,				/* date time contents modified */
  6    51     2 tpd bit (1) aligned;				/* transparent paging device switch */
  6    52 
  6    53 /* END INCLUDE FILE ... reload_set_info.incl.pl1 */
      984 
      985  /* BEGIN INCLUDE FILE ... vtoce_pc_sws.incl.pl1 */
  7     2 
  7     3 dcl  vpsp ptr;
  7     4 dcl 1 vtoce_pc_sws based (vpsp) aligned,
  7     5     (2 dnzp bit (1),
  7     6     2 gtpd bit (1),
  7     7     2 damaged bit (1),
  7     8     2 synchronized bit (1),
  7     9     2 pad bit (32)) unal;
  7    10 
  7    11 /* END INCLUDE FILE ... vtoce_pc_sws.incl.pl1 */
      985 
      986      end set;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  set.pl1                           >spec>install>1110>set.pl1
979          1    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
980          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
981          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
982          4    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
983          5    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
984          6    08/04/88  2054.1  reload_set_info.incl.pl1          >ldd>include>reload_set_info.incl.pl1
985          7    11/22/82  0955.7  vtoce_pc_sws.incl.pl1             >ldd>include>vtoce_pc_sws.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Change_bc_entry                        constant        fixed bin(17,0)          initial dcl 144 ref 290 303 889 928 950
Dsw_entry                              constant        fixed bin(17,0)          initial dcl 145 ref 499 510 930 952
FS_OBJ_AUDIT_FLAG_MOD                  constant        fixed bin(18,0)          initial unsigned dcl 5-67 ref 476
FS_OBJ_AUTHOR_MOD                      constant        fixed bin(18,0)          initial unsigned dcl 5-46 ref 209
FS_OBJ_BACKUP_TIMES_MOD                constant        fixed bin(18,0)          initial unsigned dcl 5-48 ref 412
FS_OBJ_BC_AUTHOR_MOD                   constant        fixed bin(18,0)          initial unsigned dcl 5-47 ref 681
FS_OBJ_BC_MOD                          constant        fixed bin(18,0)          initial unsigned dcl 5-32 ref 244 258 286 300
FS_OBJ_COPY_SW_MOD                     constant        fixed bin(18,0)          initial unsigned dcl 5-38 ref 193
FS_OBJ_DAMAGED_SW_MOD                  constant        fixed bin(18,0)          initial unsigned dcl 5-39 ref 496 506
FS_OBJ_DATES_MOD                       constant        fixed bin(18,0)          initial unsigned dcl 5-49 ref 350
FS_OBJ_DNZP_MOD                        constant        fixed bin(18,0)          initial unsigned dcl 5-40 ref 549 559
FS_OBJ_DT_DUMPED_MOD                   constant        fixed bin(18,0)          initial unsigned dcl 5-50 ref 333
FS_OBJ_ENTRY_BOUND_MOD                 constant        fixed bin(18,0)          initial unsigned dcl 5-41 ref 703 713
FS_OBJ_FOR_RELOADER_MOD                constant        fixed bin(18,0)          initial unsigned dcl 5-51 ref 757
FS_OBJ_MAX_LEN_MOD                     constant        fixed bin(18,0)          initial unsigned dcl 5-42 ref 631 649
FS_OBJ_SAFETY_SW_MOD                   constant        fixed bin(18,0)          initial unsigned dcl 5-43 ref 449 459
FS_OBJ_SYNC_SW_MOD                     constant        fixed bin(18,0)          initial unsigned dcl 5-44 ref 593
FS_OBJ_VOL_DUMP_SW_MOD                 constant        fixed bin(18,0)          initial unsigned dcl 5-45 ref 385
Normal_entry                           constant        fixed bin(17,0)          initial dcl 142 ref 197 213 324 354 390 416 452 463
                                                                                  480 552 563 597 634 653 685 706 717 924 946
Normal_priv_entry                      constant        fixed bin(17,0)          initial dcl 147 ref 331 768 932 954
Set_bc_entry                           constant        fixed bin(17,0)          initial dcl 143 ref 242 262 926 948
Set_bc_entry_priv                      constant        fixed bin(17,0)          initial dcl 146 ref 236 932 954
a_audit_flag                           parameter       bit(1)                   dcl 52 ref 473 477
a_auth                                 parameter       char                     packed unaligned dcl 53 ref 206 211 678 682
a_bitct                                parameter       fixed bin(24,0)          dcl 54 ref 233 239 246 255 259
a_btimes                               parameter       structure                level 1 dcl 55 ref 409 413
a_chasesw                              parameter       fixed bin(1,0)           dcl 56 ref 206 210
a_code                                 parameter       fixed bin(35,0)          dcl 57 set ref 190 206 233 239 255 283 297 320 327
                                                                                  347 382 409 446 456 473 493 503 546 556 590 628
                                                                                  638 645 678 700 710 754 762* 894*
a_copy                                 parameter       fixed bin(1,0)           dcl 58 ref 190 194
a_damaged_sw                           parameter       bit(1)                   packed unaligned dcl 59 ref 493 497 503 507
a_date                                 parameter       bit(36)                  packed unaligned dcl 60 ref 320 323
a_datep                                parameter       pointer                  dcl 61 ref 347 351
a_delta_bc                             parameter       fixed bin(24,0)          dcl 62 ref 283 287 297 301
a_dirname                              parameter       char                     packed unaligned dcl 63 ref 190 206 255 283 320 327
                                                                                  347 382 409 456 473 503 556 590 638 645 678 710
                                                                                  754 922
a_dnzp_sw                              parameter       bit(1)                   dcl 538 ref 546 550 556 560
a_dtime                                parameter       fixed bin(52,0)          dcl 64 ref 327 330
a_ename                                parameter       char                     packed unaligned dcl 65 ref 190 206 255 283 320 327
                                                                                  347 382 409 456 473 503 556 590 638 645 678 710
                                                                                  754 923
a_entry_bound                          parameter       fixed bin(14,0)          dcl 66 ref 700 704 710 714
a_max_length                           parameter       fixed bin(19,0)          dcl 67 ref 628 632 638 645 651
a_ncd                                  parameter       fixed bin(17,0)          dcl 69 ref 382 388
a_new_bc                               parameter       fixed bin(24,0)          dcl 68 set ref 283 297 891*
a_nid                                  parameter       fixed bin(17,0)          dcl 70 ref 382 389
a_old_bc                               parameter       fixed bin(24,0)          dcl 71 set ref 283 297 890*
a_reload_set_info                      based           structure                level 1 dcl 79 set ref 759 887*
a_safety_sw                            parameter       bit(1)                   packed unaligned dcl 72 ref 446 450 456 460
a_segptr                               parameter       pointer                  dcl 73 ref 233 239 297 446 493 546 628 700 944
a_setp                                 parameter       pointer                  dcl 74 ref 754 758
a_synchronized_sw                      parameter       bit(1)                   dcl 75 ref 590 594
acc_name_$delete                000036 constant        entry                    external dcl 167 ref 221 273 793 803
acc_name_$elements              000040 constant        entry                    external dcl 168 ref 217 791 800
acc_name_$encode                000042 constant        entry                    external dcl 169 ref 222 274 794 804
access_name                     000100 automatic       structure                level 1 dcl 94 set ref 217 217 222 222 791 791 794
                                                                                  794 800 800 804 804
addr                                                   builtin function         dcl 184 ref 215 217 217 217 217 222 222 273 273 274
                                                                                  274 274 274 688 790 791 791 791 791 794 794 799
                                                                                  800 800 800 800 804 804
audit_flag                      000121 automatic       bit(1)                   dcl 98 in procedure "set" set ref 477* 483
audit_flag               32(06)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" set ref 483* 783*
audit_flag                1(01) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 783
audit_flag                4     000304 automatic       bit(1)                   level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 783
auth                            000122 automatic       char(32)                 dcl 99 set ref 211* 217 217 682*
author                    7     000304 automatic       char(32)                 level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 791 791
author                    1(04) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 789
author                    6            based           structure                level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" set ref 215 790
author_code              17     000304 automatic       fixed bin(35,0)          level 2 dcl 6-18 set ref 791* 792 794*
authp                           000132 automatic       pointer                  dcl 100 set ref 215* 221* 222* 688* 790* 793* 794*
                                                                                  799* 803* 804*
based_btimes                           based           structure                level 1 dcl 86
based_time                             based           structure                level 1 dcl 80 ref 351
bc                       40(11)        based           fixed bin(24,0)          level 2 packed packed unaligned dcl 2-8 set ref 271*
                                                                                  308
bc_author                 1(05) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 798
bc_author                20     000304 automatic       char(32)                 level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 800 800
bc_author                37            based           structure                level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" set ref 273 273 274 274
                                                                                  688 799
bc_author_code           30     000304 automatic       fixed bin(35,0)          level 2 dcl 6-18 set ref 800* 802 804*
binary                                                 builtin function         dcl 184 ref 265 876
bit                                                    builtin function         dcl 184 ref 199 330 422 423 431 432 435 436 737 858
                                                                                  876
bitct                           000134 automatic       fixed bin(24,0)          dcl 101 set ref 246* 259* 271 310* 926* 948*
bs                        4            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" ref 960
bs                              000135 automatic       bit(1)                   dcl 102 in procedure "set" set ref 338 356 392 418
                                                                                  774 960*
btimes                          000136 automatic       structure                level 1 dcl 103 set ref 413*
change_dtem                     000044 constant        entry                    external dcl 170 ref 876
chasesw                         000146 automatic       fixed bin(1,0)           dcl 104 set ref 195* 210* 260* 288* 335* 352* 386*
                                                                                  414* 461* 478* 508* 561* 595* 652* 683* 715* 766*
                                                                                  924* 930* 932*
check_rb                        000147 automatic       bit(1)                   dcl 105 set ref 196* 212* 247* 261* 289* 302* 336*
                                                                                  353* 387* 415* 451* 462* 479* 498* 509* 551* 562*
                                                                                  596* 633* 642* 647* 684* 705* 716* 767* 963
clock                                                  builtin function         dcl 184 ref 876
code                            000150 automatic       fixed bin(35,0)          dcl 106 set ref 217* 219 222* 274* 362* 364* 365
                                                                                  365* 367 396* 398* 399 399* 402* 424* 426* 427
                                                                                  427* 429 521* 523* 524 524* 526 577* 579* 580 580*
                                                                                  582 605* 616* 617 617* 619 667* 668 668* 670 775*
                                                                                  832* 834* 835 835* 848 894 900* 904* 908* 912*
                                                                                  921* 924* 926* 928* 930* 932* 935 943* 946* 948*
                                                                                  950* 952* 954* 957
copy                            000151 automatic       fixed bin(1,0)           dcl 107 set ref 194* 199
copysw                   32(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 set ref 199*
damaged                   0(02) 000255 automatic       bit(1)                   level 2 in structure "pc_val" packed packed
                                                                                  unaligned dcl 127 in procedure "set" set ref 516*
damaged                   0(02) 000254 automatic       bit(1)                   level 2 in structure "pc_msk" packed packed
                                                                                  unaligned dcl 126 in procedure "set" set ref 517*
damaged_sw                      000152 automatic       bit(1)                   dcl 108 set ref 497* 507* 516
date                            000153 automatic       bit(36)                  packed unaligned dcl 109 set ref 323* 330* 330 338
                                                                                  340
dc_find$finished                000072 constant        entry                    external dcl 1-33 ref 883
dc_find$obj_attributes_write    000074 constant        entry                    external dcl 1-45 ref 930
dc_find$obj_attributes_write_ptr
                                000076 constant        entry                    external dcl 1-46 ref 952
dc_find$obj_bc_delta_write      000100 constant        entry                    external dcl 1-48 ref 928
dc_find$obj_bc_delta_write_ptr  000102 constant        entry                    external dcl 1-49 ref 950
dc_find$obj_bc_write            000104 constant        entry                    external dcl 1-50 ref 926
dc_find$obj_bc_write_ptr        000106 constant        entry                    external dcl 1-51 ref 948
dc_find$obj_status_write        000110 constant        entry                    external dcl 1-83 ref 924
dc_find$obj_status_write_priv   000112 constant        entry                    external dcl 1-84 ref 932
dc_find$obj_status_write_priv_ptr
                                000114 constant        entry                    external dcl 1-85 ref 954
dc_find$obj_status_write_ptr    000116 constant        entry                    external dcl 1-86 ref 946
delta_bc                        000154 automatic       fixed bin(24,0)          dcl 110 set ref 287* 301* 310 928* 950*
detailed_operation              000155 automatic       fixed bin(18,0)          unsigned dcl 111 set ref 193* 209* 244* 258* 286*
                                                                                  300* 333* 350* 385* 412* 449* 459* 476* 496* 506*
                                                                                  549* 559* 593* 631* 649* 681* 703* 713* 757* 924*
                                                                                  930* 932* 946* 952* 954*
dir                                    based           structure                level 1 dcl 3-11
dirname                         000156 automatic       char(168)                packed unaligned dcl 112 set ref 922* 924* 926* 928*
                                                                                  930* 932*
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" ref 265 962
dirsw                           000230 automatic       bit(1)                   dcl 113 in procedure "set" set ref 249 305 362 396
                                                                                  424 521 566 577 600 656 720 823 832 841 962* 965
divide                                                 builtin function         dcl 184 ref 666 828
dnzp                            000255 automatic       bit(1)                   level 2 in structure "pc_val" packed packed
                                                                                  unaligned dcl 127 in procedure "set" set ref 572*
dnzp                            000254 automatic       bit(1)                   level 2 in structure "pc_msk" packed packed
                                                                                  unaligned dcl 126 in procedure "set" set ref 573*
dnzp_sw                         000277 automatic       bit(1)                   dcl 542 set ref 550* 560* 572
dp                              000302 automatic       pointer                  dcl 3-9 set ref 364 398 426 523 579 616 667 834 881*
                                                                                  883* 885* 934* 956*
dtd                      26            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" set ref 338* 370* 432*
                                                                                  432 867*
dtd                       1(09) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 867
dtd                       1     000270 automatic       bit(36)                  level 2 in structure "time" dcl 135 in procedure
                                                                                  "set" set ref 370 374
dtd                      36     000304 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 867
dtd                      26            based           bit(36)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 4-6 in procedure "set" set ref 340* 374* 436*
                                                                                  436
dtd                       2     000136 automatic       fixed bin(52,0)          level 2 in structure "btimes" dcl 103 in procedure
                                                                                  "set" set ref 432 436
dtem                      1(08) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 863
dtem                      3            based           bit(36)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 4-6 in procedure "set" set ref 373* 435* 435
dtem                            000270 automatic       bit(36)                  level 2 in structure "time" dcl 135 in procedure
                                                                                  "set" set ref 369 373
dtem                     35     000304 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 863
dtem                      3            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "set" set ref 369* 431* 431 863* 876
dtem                            000136 automatic       fixed bin(52,0)          level 2 in structure "btimes" dcl 103 in procedure
                                                                                  "set" set ref 431 435
dtm                       3     000270 automatic       bit(36)                  level 2 in structure "time" dcl 135 in procedure
                                                                                  "set" set ref 361
dtm                       1(11) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 817
dtm                      40     000304 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 817
dtm                       6     000136 automatic       fixed bin(52,0)          level 2 in structure "btimes" dcl 103 in procedure
                                                                                  "set" set ref 423
dtm                             000231 automatic       bit(36)                  dcl 114 in procedure "set" set ref 361* 365* 423*
                                                                                  423 427* 817* 819* 831 835*
dtu                       1(10) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 813
dtu                      37     000304 automatic       bit(36)                  level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 813
dtu                       4     000136 automatic       fixed bin(52,0)          level 2 in structure "btimes" dcl 103 in procedure
                                                                                  "set" set ref 422
dtu                       2     000270 automatic       bit(36)                  level 2 in structure "time" dcl 135 in procedure
                                                                                  "set" set ref 360
dtu                             000232 automatic       bit(36)                  dcl 115 in procedure "set" set ref 360* 365* 422*
                                                                                  422 427* 813* 815* 831 835*
ename                           000233 automatic       char(32)                 packed unaligned dcl 116 set ref 923* 924* 926* 928*
                                                                                  930* 932*
entry                                  based           structure                level 1 dcl 2-8
entry_bound              33     000304 automatic       fixed bin(14,0)          level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 843 845 851 858
entry_bound                     000243 automatic       fixed bin(14,0)          dcl 117 in procedure "set" set ref 704* 714* 723 725
                                                                                  731 737
entry_bound               1(07) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 840
entry_bound_code         34     000304 automatic       fixed bin(35,0)          level 2 dcl 6-18 set ref 841* 843* 845*
entry_type                      000244 automatic       fixed bin(17,0)          dcl 118 set ref 197* 213* 236* 242* 262* 290* 303*
                                                                                  324* 331* 354* 390* 416* 452* 463* 480* 499* 510*
                                                                                  552* 563* 597* 634* 653* 685* 706* 717* 768* 889
                                                                                  924 926 928 930 932 932 946 948 950 952 954 954
entrypt_bound            32(22)        based           bit(14)                  level 2 packed packed unaligned dcl 2-8 set ref 733*
                                                                                  737* 854* 858*
entrypt_sw               32(08)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 set ref 732*
                                                                                  736* 853* 857*
ep                              000300 automatic       pointer                  dcl 2-6 set ref 199 215 265 265 265 271 273 273 274
                                                                                  274 308 338 340 357 358 359 369 370 373 374 393
                                                                                  394 395 419 420 421 431 431 432 432 435 435 436
                                                                                  436 466 483 518 519 520 574 575 576 603 613 614
                                                                                  615 663 664 665 688 727 728 729 732 733 736 737
                                                                                  770 771 772 779 783 790 799 853 854 857 858 863
                                                                                  867 876 876* 924* 926* 928* 930* 932* 934 946*
                                                                                  948* 950* 952* 954* 956 960 962 966 970
error_table_$ai_restricted      000010 external static fixed bin(35,0)          dcl 151 ref 900
error_table_$argerr             000012 external static fixed bin(35,0)          dcl 152 ref 762 826 843 845 904
error_table_$bad_ring_brackets  000014 external static fixed bin(35,0)          dcl 153 ref 912
error_table_$dirseg             000016 external static fixed bin(35,0)          dcl 154 ref 396 823 841 908
error_table_$link               000020 external static fixed bin(35,0)          dcl 155 ref 402
error_table_$not_a_branch       000022 external static fixed bin(35,0)          dcl 156 ref 775
error_table_$not_dm_ring        000024 external static fixed bin(35,0)          dcl 157 ref 605
ex_ring_brackets         35(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 2-8 ref
                                                                                  966
find_was_called                 000245 automatic       bit(1)                   dcl 119 set ref 883 937* 945*
fixed                                                  builtin function         dcl 184 ref 603 966 970
length                                                 builtin function         dcl 184 ref 330 422 423 431 432 435 436
level$get                       000046 constant        entry                    external dcl 171 ref 964
link                                   based           structure                level 1 dcl 4-6
lock$dir_unlock                 000050 constant        entry                    external dcl 172 ref 885
m                               000030 external static bit(1)                   level 2 packed packed unaligned dcl 159 ref 876
max_length                      000246 automatic       fixed bin(19,0)          dcl 120 in procedure "set" set ref 632* 651* 659 661
                                                                                  666
max_length               31     000304 automatic       fixed bin(19,0)          level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 826 828
max_length                1(06) 000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 822
max_length_code          32     000304 automatic       fixed bin(35,0)          level 2 dcl 6-18 set ref 823* 826*
mountedp                        000052 constant        entry                    external dcl 173 ref 364 398 426 523 579 616 667 834
multiple_class           32(05)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 ref 265
mxl                             000247 automatic       fixed bin(9,0)           dcl 121 set ref 666* 668* 821* 828* 831 835* 848
ncd                             000250 automatic       fixed bin(17,0)          dcl 122 set ref 388* 399*
new_bc                          000251 automatic       fixed bin(24,0)          dcl 123 set ref 310* 891
nid                             000252 automatic       fixed bin(17,0)          dcl 124 set ref 389* 399*
old_bc                          000253 automatic       fixed bin(24,0)          dcl 125 set ref 308* 310 890
pc_msk                          000254 automatic       structure                level 1 dcl 126 set ref 515* 524 524 571* 580 580
                                                                                  610* 617 617
pc_val                          000255 automatic       structure                level 1 dcl 127 set ref 513* 524 524 570* 580 580
                                                                                  609* 617 617
pds$access_name                 000026 external static fixed bin(35,0)          dcl 158 set ref 274 274
pds$transparent                 000030 external static structure                level 1 dcl 159
priv_ml                         000256 automatic       bit(1)                   initial dcl 128 set ref 128* 641* 668*
ptr                                                    builtin function         dcl 184 ref 934 956
pvid                            000257 automatic       bit(36)                  dcl 129 in procedure "set" set ref 358* 365* 394*
                                                                                  399* 420* 427* 519* 524* 575* 580* 614* 617* 664*
                                                                                  668* 728* 730* 771* 835* 848*
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" ref 358 394 420 519 575
                                                                                  614 664 728 771
reload_set_info                 000304 automatic       structure                level 1 dcl 6-18 set ref 759* 887
reload_set_version_2                   constant        fixed bin(17,0)          initial dcl 6-16 ref 760
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 2-8 ref
                                                                                  265 603 970
safety_sw                 3     000304 automatic       bit(1)                   level 2 in structure "reload_set_info" dcl 6-18
                                                                                  in procedure "set" set ref 779
safety_sw                 1     000304 automatic       bit(1)                   level 3 in structure "reload_set_info" packed packed
                                                                                  unaligned dcl 6-18 in procedure "set" set ref 779
safety_sw                       000260 automatic       bit(1)                   dcl 130 in procedure "set" set ref 450* 460* 466
safety_sw                32(04)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" set ref 466* 779*
segptr                          000262 automatic       pointer                  dcl 131 set ref 944* 946* 948* 950* 952* 954*
setfaults$if_active             000054 constant        entry                    external dcl 174 ref 730 848
setp                            000264 automatic       pointer                  dcl 132 set ref 758* 759 887
setting_for_reloader            000266 automatic       fixed bin(17,0)          initial dcl 133 set ref 133* 765* 887
should_set                1     000304 automatic       structure                level 2 dcl 6-18
sons_lvid                12            based           bit(36)                  level 2 dcl 3-11 set ref 364* 398* 426* 523* 579*
                                                                                  616* 667* 834*
string                                                 builtin function         dcl 184 ref 524 524 524 524 580 580 580 580 617 617
                                                                                  617 617
substr                                                 builtin function         dcl 184 ref 330 422 423 431 432 435 436
sum$dirmod                      000056 constant        entry                    external dcl 175 ref 881
synchronized              0(03) 000254 automatic       bit(1)                   level 2 in structure "pc_msk" packed packed
                                                                                  unaligned dcl 126 in procedure "set" set ref 612*
synchronized              0(03) 000255 automatic       bit(1)                   level 2 in structure "pc_val" packed packed
                                                                                  unaligned dcl 127 in procedure "set" set ref 611*
synchronized_sw                 000267 automatic       bit(1)                   dcl 134 set ref 594* 611
sys_info$data_management_ringno 000032 external static fixed bin(17,0)          dcl 162 ref 603
sys_info$seg_size_256K          000034 external static fixed bin(19,0)          dcl 163 ref 661
time                            000270 automatic       structure                level 1 dcl 135 set ref 351*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "set" ref 357 393 419 518 574 613 663 727 770
uid                             000274 automatic       bit(36)                  dcl 136 in procedure "set" set ref 357* 365* 393*
                                                                                  399* 419* 427* 518* 524* 574* 580* 613* 617* 663*
                                                                                  668* 727* 730* 770* 835* 848*
unspec                                                 builtin function         dcl 184 set ref 513* 515* 570* 571* 609* 610*
val                             000275 automatic       fixed bin(17,0)          dcl 137 set ref 964* 966 970
version                         000304 automatic       fixed bin(17,0)          level 2 dcl 6-18 set ref 760
vtoc_attributes$reloading       000060 constant        entry                    external dcl 176 ref 835
vtoc_attributes$set_dates       000062 constant        entry                    external dcl 177 ref 365 427
vtoc_attributes$set_dump_switches
                                000064 constant        entry                    external dcl 178 ref 399
vtoc_attributes$set_max_lth     000066 constant        entry                    external dcl 179 ref 668
vtoc_attributes$set_pc_switches 000070 constant        entry                    external dcl 180 ref 524 580 617
vtoce_pc_sws                           based           structure                level 1 dcl 7-4
vtocx                           000276 automatic       fixed bin(17,0)          dcl 138 in procedure "set" set ref 359* 365* 395*
                                                                                  399* 421* 427* 520* 524* 576* 580* 615* 617* 665*
                                                                                  668* 729* 730* 772* 835* 848*
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "set" ref 359 395 421 520 576
                                                                                  615 665 729 772

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 1-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 1-13
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 5-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 5-36
FS_OBJ_CONNECT                         internal static fixed bin(18,0)          initial unsigned dcl 5-31
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 5-55
FS_OBJ_CREATE_BRANCH                   internal static fixed bin(18,0)          initial unsigned dcl 5-66
FS_OBJ_DIR_SALVAGE                     internal static fixed bin(18,0)          initial unsigned dcl 5-56
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 5-65
FS_OBJ_MDIR_QUOTA_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 5-57
FS_OBJ_MOVE_QUOTA                      internal static fixed bin(18,0)          initial unsigned dcl 5-54
FS_OBJ_QUOTA_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 5-58
FS_OBJ_QUOTA_RELOAD                    internal static fixed bin(18,0)          initial unsigned dcl 5-59
FS_OBJ_RECLASSIFY                      internal static fixed bin(18,0)          initial unsigned dcl 5-60
FS_OBJ_RECLASSIFY_NODE                 internal static fixed bin(18,0)          initial unsigned dcl 5-61
FS_OBJ_RENAME                          internal static fixed bin(18,0)          initial unsigned dcl 5-37
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 5-35
FS_OBJ_SEG_MOVE                        internal static fixed bin(18,0)          initial unsigned dcl 5-62
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 5-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 5-53
FS_OBJ_TRP_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 5-63
FS_OBJ_TRUNCATE                        internal static fixed bin(18,0)          initial unsigned dcl 5-33
FS_OBJ_VOLUME_RETRIEVE                 internal static fixed bin(18,0)          initial unsigned dcl 5-64
access_operations_$fs_obj_access_mod   external static bit(36)                  dcl 5-27
access_operations_$fs_obj_attr_mod     external static bit(36)                  dcl 5-25
access_operations_$fs_obj_contents_mod external static bit(36)                  dcl 5-23
access_operations_$fs_obj_contents_read
                                       external static bit(36)                  dcl 5-22
access_operations_$fs_obj_create       external static bit(36)                  dcl 5-18
access_operations_$fs_obj_delete       external static bit(36)                  dcl 5-19
access_operations_$fs_obj_initiate     external static bit(36)                  dcl 5-20
access_operations_$fs_obj_prop_read    external static bit(36)                  dcl 5-24
access_operations_$fs_obj_status_mod   external static bit(36)                  dcl 5-26
access_operations_$fs_obj_terminate    external static bit(36)                  dcl 5-21
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_read                000000 constant        entry                    external dcl 1-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 1-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$link_target             000000 constant        entry                    external dcl 1-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 1-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 1-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 1-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 1-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 1-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 1-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 1-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 1-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 1-76
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 1-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 1-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 1-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84
vpsp                                   automatic       pointer                  dcl 7-3

NAMES DECLARED BY EXPLICIT CONTEXT.
ai_error                        003543 constant        label                    dcl 900 ref 265
argerr                          003547 constant        label                    dcl 904 set ref 659 661 723 725
audit_flag_path                 001512 constant        entry                    external dcl 473
auth                            000122 constant        entry                    external dcl 206
backup_dump_time                000624 constant        entry                    external dcl 327
backup_times                    001204 constant        entry                    external dcl 409
bc                              000323 constant        entry                    external dcl 255
bc_auth_path                    002525 constant        entry                    external dcl 678
bc_seg                          000270 constant        entry                    external dcl 239
bc_seg_priv                     000250 constant        entry                    external dcl 233
bc_set_ptr_join                 000305 constant        label                    dcl 244 ref 237
bracket_error                   003557 constant        label                    dcl 912 ref 966 970
change_bc                       000545 constant        label                    dcl 308 ref 292
change_bc_path                  000442 constant        entry                    external dcl 283
change_bc_ptr                   000514 constant        entry                    external dcl 297
check                           004106 constant        label                    dcl 960 ref 938
copysw                          000043 constant        entry                    external dcl 190
cp_ml_args                      002425 constant        label                    dcl 649 ref 643
damaged_sw_path                 001616 constant        entry                    external dcl 503
damaged_sw_ptr                  001564 constant        entry                    external dcl 493
dates                           000705 constant        entry                    external dcl 347
dirseg                          003553 constant        label                    dcl 908 ref 249 305 566 600 656 720
dnzp_sw_path                    002007 constant        entry                    external dcl 556
dnzp_sw_ptr                     001757 constant        entry                    external dcl 546
dtd                             000563 constant        entry                    external dcl 320
entry_bound_path                002637 constant        entry                    external dcl 710
entry_bound_ptr                 002605 constant        entry                    external dcl 700
finale                          003540 constant        label                    dcl 894 ref 935 957
find_entry                      003563 constant        entry                    internal dcl 918 ref 198 214 263 291 337 355 391 417
                                                                                  464 481 511 564 598 654 686 718 769
finish                          003443 constant        label                    dcl 876 ref 200 276 468 485 528 584 620 672 739 871
get_entry_ptr                   003751 constant        entry                    internal dcl 940 ref 248 304 453 500 553 635 707
max_length_path                 002375 constant        entry                    external dcl 645
max_length_priv                 002341 constant        entry                    external dcl 638
max_length_ptr                  002307 constant        entry                    external dcl 628
safety_sw_path                  001432 constant        entry                    external dcl 456
safety_sw_ptr                   001375 constant        entry                    external dcl 446
set                             000027 constant        entry                    external dcl 27
set_audit_flag                  001553 constant        label                    dcl 483
set_auth                        000176 constant        label                    dcl 217 set ref 689
set_bc                          000363 constant        label                    dcl 265 ref 253 311
set_call_limiter                002700 constant        label                    dcl 720 ref 708
set_damaged                     001662 constant        label                    dcl 513 ref 501
set_dnzp                        002051 constant        label                    dcl 566 ref 554
set_dtd                         000661 constant        label                    dcl 333 ref 325
set_for_reloader                002762 constant        entry                    external dcl 754
set_max_length                  002436 constant        label                    dcl 656 ref 636
set_safety                      001476 constant        label                    dcl 466 ref 454
synchronized_sw                 002145 constant        entry                    external dcl 590
unlock                          003466 constant        label                    dcl 881 ref 219 223 341 367 376 403 429 438 526 582
                                                                                  606 619 670 776 902 906 910 914
volume_dump_switches            001053 constant        entry                    external dcl 382

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5074        5214    4150        5104
Length      5700    4150       120         450     723           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
set                                 322 external procedure  is an external procedure.  
find_entry                              internal procedure  shares stack frame of external procedure set.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
set                      000100 access_name                 set
                         000121 audit_flag                  set
                         000122 auth                        set
                         000132 authp                       set
                         000134 bitct                       set
                         000135 bs                          set
                         000136 btimes                      set
                         000146 chasesw                     set
                         000147 check_rb                    set
                         000150 code                        set
                         000151 copy                        set
                         000152 damaged_sw                  set
                         000153 date                        set
                         000154 delta_bc                    set
                         000155 detailed_operation          set
                         000156 dirname                     set
                         000230 dirsw                       set
                         000231 dtm                         set
                         000232 dtu                         set
                         000233 ename                       set
                         000243 entry_bound                 set
                         000244 entry_type                  set
                         000245 find_was_called             set
                         000246 max_length                  set
                         000247 mxl                         set
                         000250 ncd                         set
                         000251 new_bc                      set
                         000252 nid                         set
                         000253 old_bc                      set
                         000254 pc_msk                      set
                         000255 pc_val                      set
                         000256 priv_ml                     set
                         000257 pvid                        set
                         000260 safety_sw                   set
                         000262 segptr                      set
                         000264 setp                        set
                         000266 setting_for_reloader        set
                         000267 synchronized_sw             set
                         000270 time                        set
                         000274 uid                         set
                         000275 val                         set
                         000276 vtocx                       set
                         000277 dnzp_sw                     set
                         000300 ep                          set
                         000302 dp                          set
                         000304 reload_set_info             set

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ge_a              call_ext_out        return_mac          ext_entry           ext_entry_desc      clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_name_$delete              acc_name_$elements            acc_name_$encode              change_dtem
dc_find$finished              dc_find$obj_attributes_write  dc_find$obj_attributes_write_ptr
dc_find$obj_bc_delta_write    dc_find$obj_bc_delta_write_ptr                              dc_find$obj_bc_write
dc_find$obj_bc_write_ptr      dc_find$obj_status_write      dc_find$obj_status_write_priv
dc_find$obj_status_write_priv_ptr                           dc_find$obj_status_write_ptr  level$get
lock$dir_unlock               mountedp                      setfaults$if_active           sum$dirmod
vtoc_attributes$reloading     vtoc_attributes$set_dates     vtoc_attributes$set_dump_switches
vtoc_attributes$set_max_lth   vtoc_attributes$set_pc_switches

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$argerr           error_table_$bad_ring_brackets
error_table_$dirseg           error_table_$link             error_table_$not_a_branch     error_table_$not_dm_ring
pds$access_name               pds$transparent               sys_info$data_management_ringno
sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    128 000022       133 000023        27 000026       190 000035       193 000067       194 000071       195 000074
    196 000076       197 000100       198 000102       199 000103       200 000114       206 000115       209 000152
    210 000154       211 000157       212 000167       213 000170       214 000172       215 000173       217 000176
    219 000215       221 000217       222 000226       223 000243       233 000244       236 000263       237 000265
    239 000266       242 000303       244 000305       246 000307       247 000311       248 000312       249 000313
    253 000315       255 000316       258 000351       259 000353       260 000355       261 000357       262 000360
    263 000362       265 000363       271 000376       273 000402       274 000413       276 000433       283 000434
    286 000474       287 000476       288 000500       289 000502       290 000503       291 000505       292 000506
    297 000507       300 000533       301 000535       302 000537       303 000540       304 000542       305 000543
    308 000545       310 000552       311 000555       320 000556       323 000607       324 000614       325 000616
    327 000617       330 000650       331 000657       333 000661       335 000663       336 000664       337 000665
    338 000666       340 000674       341 000677       347 000700       350 000731       351 000733       352 000744
    353 000745       354 000746       355 000750       356 000751       357 000753       358 000756       359 000760
    360 000763       361 000765       362 000767       364 000773       365 001005       367 001030       369 001032
    370 001035       371 001037       373 001040       374 001043       376 001045       382 001046       385 001077
    386 001101       387 001103       388 001105       389 001110       390 001112       391 001114       392 001115
    393 001117       394 001122       395 001124       396 001127       398 001135       399 001147       401 001172
    402 001173       403 001176       409 001177       412 001230       413 001232       414 001237       415 001240
    416 001241       417 001243       418 001244       419 001246       420 001251       421 001253       422 001256
    423 001264       424 001272       426 001276       427 001310       429 001333       431 001335       432 001344
    433 001352       435 001353       436 001362       438 001370       446 001371       449 001410       450 001412
    451 001417       452 001421       453 001423       454 001424       456 001425       459 001460       460 001462
    461 001467       462 001471       463 001473       464 001475       466 001476       468 001504       473 001505
    476 001536       477 001540       478 001544       479 001546       480 001550       481 001552       483 001553
    485 001561       493 001562       496 001577       497 001601       498 001606       499 001610       500 001612
    501 001613       503 001614       506 001644       507 001646       508 001653       509 001655       510 001657
    511 001661       513 001662       515 001663       516 001664       517 001671       518 001673       519 001676
    520 001700       521 001703       523 001707       524 001721       526 001750       528 001752       546 001753
    549 001772       550 001774       551 001777       552 002001       553 002003       554 002004       556 002005
    559 002035       560 002037       561 002042       562 002044       563 002046       564 002050       566 002051
    570 002053       571 002054       572 002055       573 002061       574 002063       575 002066       576 002070
    577 002073       579 002077       580 002111       582 002140       584 002142       590 002143       593 002171
    594 002173       595 002177       596 002200       597 002202       598 002204       600 002205       603 002207
    605 002215       606 002217       609 002220       610 002221       611 002222       612 002227       613 002231
    614 002233       615 002235       616 002240       617 002251       619 002300       620 002302       628 002303
    631 002322       632 002324       633 002326       634 002330       635 002332       636 002333       638 002334
    641 002367       642 002371       643 002372       645 002373       647 002423       649 002425       651 002427
    652 002431       653 002433       654 002435       656 002436       659 002440       661 002442       663 002445
    664 002450       665 002452       666 002455       667 002461       668 002472       670 002515       672 002517
    678 002520       681 002555       682 002557       683 002567       684 002571       685 002572       686 002574
    688 002575       689 002600       700 002601       703 002620       704 002622       705 002624       706 002626
    707 002630       708 002631       710 002632       713 002665       714 002667       715 002671       716 002673
    717 002675       718 002677       720 002700       723 002702       725 002704       727 002706       728 002711
    729 002713       730 002716       731 002735       732 002737       733 002742       734 002744       736 002745
    737 002750       739 002757       754 002760       757 003006       758 003010       759 003014       760 003017
    762 003022       763 003025       765 003026       766 003030       767 003031       768 003032       769 003034
    770 003035       771 003040       772 003042       774 003045       775 003047       776 003052       779 003053
    783 003063       789 003073       790 003076       791 003100       792 003117       793 003121       794 003130
    798 003145       799 003150       800 003153       802 003172       803 003174       804 003203       813 003220
    815 003226       817 003227       819 003235       821 003236       822 003240       823 003243       826 003251
    828 003257       831 003262       832 003271       834 003275       835 003307       840 003334       841 003337
    843 003345       845 003353       848 003361       851 003404       853 003406       854 003411       855 003413
    857 003414       858 003417       863 003426       867 003434       871 003442       876 003443       881 003466
    883 003475       885 003513       887 003522       889 003531       890 003534       891 003536       894 003540
    896 003542       900 003543       902 003546       904 003547       906 003552       908 003553       910 003556
    912 003557       914 003562       918 003563       921 003564       922 003565       923 003573       924 003600
    926 003625       928 003647       930 003671       932 003715       934 003742       935 003744       937 003746
    938 003750       940 003751       943 003752       944 003753       945 003757       946 003760       948 004001
    950 004021       952 004041       954 004061       956 004102       957 004104       960 004106       962 004112
    963 004115       964 004117       965 004126       966 004130       968 004136       970 004137       975 004144


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
