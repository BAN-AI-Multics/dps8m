	COMPILATION LISTING OF SEGMENT lv_request_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 08/16/90  1223.2 mdt Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 /* format: off */
       15 
       16 lv_request_: proc (msgp);
       17 	go to interrupt;
       18 
       19 /* lv_request_: a mdxhdx poor man's RCP. Bernard Greenberg 09/09/76. Thanks to THVV's tape_opr_. */
       20 /* Modified July 1977 by T. Casey to add calls to device_acct_ and fix up masking and unmasking */
       21 /* Modified November 1981, E. N. Kittlitz.  user_table_entry conversion. */
       22 /* Modified December 1981, J. Bongiovanni, for poll_mounts, allow mounting LV with no processes attached */
       23 
       24 
       25 /****^  HISTORY COMMENTS:
       26*  1) change(87-04-28,GDixon), approve(87-07-13,MCR7741),
       27*     audit(87-05-07,Parisek), install(87-08-04,MR12.1-1055):
       28*     Updated for change to user_table_entry.incl.pl1.
       29*  2) change(87-07-31,GDixon), approve(87-07-31,MCR7741),
       30*     audit(87-08-03,Parisek), install(87-08-04,MR12.1-1055):
       31*      A) Provide operator message documentation for sys_log_ calls.
       32*      B) Change to use get_userid_$info to provide standard-format group ids
       33*         in error messages.
       34*      C) Reorganization variable declarations according to standards.
       35*      D) Put out LV attach/detach messages in a more standard format similar
       36*         to messages emitted by as_access_audit_.  Some day, we should
       37*         create a new entrypoint in as_access_audit_ to emit these messages.
       38*  3) change(88-04-18,Farley), approve(88-05-26,MCR7880),
       39*     audit(88-05-31,Parisek), install(88-07-05,MR12.2-1052):
       40*     Modified attach_list entry to use standard argument parsing and allow
       41*     multiple LVs (or -all).  Entry is now callable via the Initializer's
       42*     list_lv_attachments (llva) request.  Added "signal_io_" to the
       43*     any_other_handler's list of conditions to pass on, so Initializer I/O
       44*     will work properly.
       45*  4) change(90-07-04,Schroth), approve(90-07-16,MCR8184),
       46*     audit(90-07-30,WAAnderson), install(90-08-16,MR12.4-1024):
       47*     Ensure event call channels are unmasked on exit.
       48*                                                   END HISTORY COMMENTS */
       49 
       50 
       51 /* AUTOMATIC */
       52 
       53 dcl  argl fixed bin (21);
       54 dcl  argp ptr;
       55 dcl  argx fixed bin;
       56 dcl  array (200) fixed bin;				/* return result lvax's from wds */
       57 dcl  d_lvname char (32);				/* dlv time lvname */
       58 dcl  demounting bit (1);				/* interrupt time task */
       59 dcl  dtx fixed bin;
       60 dcl (ec, xec) fixed bin (35);
       61 dcl  ev_calls_masked bit (1) aligned;			/* to remember if we mask event calls */
       62 dcl (i, n) fixed bin;				/* index and length in 'array' array */
       63 dcl  list_all_vols bit (1) aligned;
       64 dcl  lvax fixed bin;				/* lvat index */
       65 dcl  lvname char (32);				/* lv name of interest */
       66 dcl (lvx, pvx) fixed bin;				/* disk table indices */
       67 dcl  my_evchn fixed bin (71);				/* init_time event chan */
       68 dcl  n_devtab_entries fixed bin;
       69 dcl  n_vols_to_list fixed bin;
       70 dcl  nargs fixed bin;
       71 dcl  next_time fixed bin (71);
       72 dcl  pid bit (36) aligned;
       73 dcl  result fixed bin;				/* generated test mhv result */
       74 dcl  shown_lvat_header bit (1);
       75 dcl  status char (25);				/* Status of attachment for report */
       76 dcl  unit_string char (200) varying;
       77 dcl  user_procid bit(36) aligned;
       78 dcl  user_procname char (33);				/* user process name */
       79 dcl  vols_to_list (10) char (32);
       80 dcl  vtlx fixed bin;				/* vols_to_list index */
       81 
       82 dcl 1 devtab_copy (16) aligned,
       83     2 device_id char (8),
       84     2 device_price (0:7) float bin;
       85 
       86 dcl 1 local_lvate aligned like lvate;
       87 
       88 dcl 1 mount_transmission aligned,			/* message sent in bits by lv_request_communicator_ */
       89     2 req char (4) unaligned,				/* "moun", "demo", or "poll" */
       90     2 lvax fixed bin (17) unal,			/* lvat index */
       91     2 other fixed bin (17) unaligned;			/* mbz */
       92 
       93 /* STATIC */
       94 
       95 dcl  ALARM___ char (8) static init ("alarm___") options (constant); /* timer message */
       96 dcl  FALSE bit (1) static init ("0"b) options (constant);
       97 dcl  LV_RING fixed bin init (1) static;			/* ring of lv_request_communicator_ */
       98 dcl  SL0 fixed bin init (0) int static;			/* = SL_LOG_SILENT, log messages only */
       99 dcl  TRUE bit (1) static init ("1"b) options (constant);
      100 dcl  initialized bit (1) static init ("0"b);		/* set up ok */
      101 dcl  myprocessid bit (36) aligned static;		/* for ev msg checks */
      102 dcl  testing bit (1) static init ("0"b);		/* test environment */
      103 
      104 
      105 /* BASED */
      106 
      107 dcl  arg char (argl) based (argp);
      108 
      109 dcl 1 evmessage based (msgp) aligned,			/* ipc message */
      110     2 evchn fixed bin (71),
      111     2 bits bit (72),				/* data */
      112     2 sender bit (36),
      113     2 origin,
      114       3 devs fixed bin (17) unal,
      115       3 ring fixed bin (17) unal;
      116 
      117 /* PARAMETERS */
      118 
      119 dcl  msgp ptr parm;					/* ipc message ptr */
      120 dcl  a_pid bit (36) aligned parm;			/* processid being termed */
      121 dcl  a_lvx fixed bin parm;				/* mhv/dhv communication */
      122 dcl  a_dtp ptr parm;				/* disk_table COPY ptr */
      123 dcl  a_lvname char (*) parm;				/* lv parameter at dhv time */
      124 
      125 /* BUILTINS */
      126 
      127 dcl (addr, addrel, hbound, null, rtrim, unspec) builtin;
      128 
      129 /* ENTRIES & EXTERNAL */
      130 
      131 dcl  as_$find_process entry (bit (36) aligned, fixed bin, ptr);
      132 dcl  com_err_ entry () options (variable);
      133 dcl  condition_ entry (char (*), entry);
      134 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
      135 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      136 dcl (device_acct_$on, device_acct_$off) entry (fixed bin, char (*), ptr);
      137 dcl  disk_table_$dhv entry (char (*));
      138 dcl  disk_table_$dry_run_mhv entry (char (*), fixed bin);
      139 dcl  disk_table_$get_dtp entry returns (ptr);		/* this guy returns a fresh copy each time */
      140 dcl  disk_table_$mhv entry (char (*));
      141 dcl  error_table_$noarg fixed bin (35) ext;
      142 dcl  error_table_$resource_unavailable fixed bin (35) ext;
      143 dcl  get_process_id_ entry returns (bit (36) aligned);
      144 dcl  get_ring_ entry returns (fixed bin);
      145 dcl  get_userid_$info entry (bit(36) aligned, char(*), char(*), char(*), fixed bin, fixed bin, fixed bin, fixed bin(35));
      146 dcl  initializer_mdc_$check_mount entry (fixed bin, char (*), char (*) varying);
      147 dcl  initializer_mdc_$free_lvate entry (fixed bin);
      148 dcl  initializer_mdc_$init_lvat entry (fixed bin (71), fixed bin (35));
      149 dcl  initializer_mdc_$invalidate_lvate entry (fixed bin);
      150 dcl  initializer_mdc_$lvat_scan_lv entry (char (*), (*) fixed bin, fixed bin);
      151 dcl  initializer_mdc_$mhvmessage entry (fixed bin, char (*));
      152 dcl  initializer_mdc_$poll_mounts entry ((*) fixed bin, fixed bin, fixed bin (71));
      153 dcl  initializer_mdc_$respond_mount_lv entry (fixed bin, fixed bin, fixed bin (35), fixed bin (35));
      154 dcl  initializer_mdc_$retrieve_lvate entry (fixed bin, ptr, fixed bin (35));
      155 dcl  initializer_mdc_$scan_process_lvat entry (bit (36) aligned, (*) fixed bin, fixed bin);
      156 dcl  initializer_mdc_$set_lvat_info entry (fixed bin, bit (36) aligned, fixed bin);
      157 dcl  ioa_ entry options (variable);
      158 dcl (ioa_$rsnnl, as_$dump) entry options (variable);
      159 dcl  ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35));
      160 dcl  ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
      161 dcl (ipc_$mask_ev_calls, ipc_$unmask_ev_calls) entry (fixed bin (35));
      162 dcl (sys_log_, sys_log_$error_log) entry options (variable);
      163 dcl  system_info_$device_prices entry (fixed bin, ptr);
      164 dcl  timer_manager_$alarm_wakeup entry (fixed bin(71), bit(2), fixed bin(71));
      165 
      166 
      167 dcl  command_error condition;
      168 
      169 /* --------------------------------------------------------- */
      170 
      171 init1:	entry;
      172 
      173 	SL0 = SL_LOG;				/* for real debugging */
      174 
      175 init:	entry;
      176 
      177 	call ipc_$create_ev_chn (my_evchn, ec);
      178 	call ipc_$decl_ev_call_chn (my_evchn, lv_request_, null, 1, ec);
      179 
      180 	if ec = 0 then call initializer_mdc_$init_lvat (my_evchn, ec);
      181 	if ec ^= 0 then do;
      182 	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
      183 		"Cannot initialize logical volume mounting software.");
      184 	     return;
      185 	end;
      186 
      187 	myprocessid = get_process_id_ ();
      188 
      189 	call system_info_$device_prices (n_devtab_entries, addr (devtab_copy));
      190 	do devtab_ix_lv = 1 to n_devtab_entries		/* look up lv in devtab */
      191 		while (devtab_copy (devtab_ix_lv).device_id ^= dev_id (dev_lv));
      192 	end;
      193 	if devtab_ix_lv = n_devtab_entries + 1 then	/* if not there, we won't charge for logical volumes */
      194 	     devtab_ix_lv = 0;
      195 
      196 	initialized = "1"b;
      197 	return;
      198 
      199 /* --------------------------------------------------------- */
      200 
      201 dhv:	entry (a_lvname);				/* Called to purge lv from table */
      202 
      203 	if ^initialized then return;
      204 	lvname = a_lvname;
      205 	call initializer_mdc_$lvat_scan_lv (lvname, array, n);
      206 	do i = 1 to n;
      207 
      208 	     lvax = array (i);
      209 	     call get (lvax);
      210 	     call find_u (lvate.pid);
      211 
      212 	     if lvate.waiting then do;
      213 		call sys_log_ (SL0,
      214 		     "lv_request_: Denied LV ^a to ^a ^12.3b.", lvname,
      215 		     user_procname, user_procid);
      216 		call initializer_mdc_$respond_mount_lv (lvax, 2, error_table_$resource_unavailable, ec);
      217 		if ec ^= 0 then call beef ("Cancelling pending mount via dlv");
      218 	     end;
      219 	     if lvate.mounted then do;
      220 		call detach;
      221 		call initializer_mdc_$invalidate_lvate (lvax);
      222 	     end;
      223 	end;
      224 	return;
      225 
      226 /* --------------------------------------------------------- */
      227 
      228 attach_list: entry;
      229 
      230 	if ^initialized then do;
      231 	     call ioa_ ("lv_request_: Logical volume software has not been initialized.");
      232 	     return;
      233 	end;
      234 
      235 /* Called on CALL SIDE ONLY, can call ioa_ */
      236 
      237 	call cu_$arg_count (nargs, ec);
      238 	if ec ^= 0 then do;
      239 	     call com_err_ (ec, "lv_request_", "Getting argument count.");
      240 	     return;
      241 	end;
      242 	if nargs < 1 then do;
      243 	     call com_err_ (error_table_$noarg, "lv_request_", "Logical volume name or -all.");
      244 	     return;
      245 	end;
      246 
      247 	list_all_vols = FALSE;
      248 	n_vols_to_list = 0;
      249 	do argx = 1 to nargs;
      250 	     call cu_$arg_ptr (argx, argp, argl, ec);
      251 	     if ec ^= 0 then do;
      252 		call com_err_ (ec, "lv_request_", "Getting arg ^d.", argx);
      253 		return;
      254 	     end;
      255 	     if arg = "-all" | arg = "-a" then list_all_vols = TRUE;
      256 	     else do;
      257 		n_vols_to_list = n_vols_to_list + 1;
      258 		if n_vols_to_list ^> hbound (vols_to_list, 1)
      259 		     then vols_to_list (n_vols_to_list) = arg;
      260 		else do;
      261 		     call ioa_ ("lv_request_: Too many LVs specified. All LVs past ""^a"" will be ignored.", vols_to_list (n_vols_to_list - 1));
      262 		     argx = nargs;			/* simulate end of args */
      263 		     n_vols_to_list = hbound (vols_to_list, 1);
      264 		end;
      265 	     end;
      266 	end;
      267 
      268 	dtp = disk_table_$get_dtp ();
      269 
      270 	shown_lvat_header = "0"b;
      271 	if list_all_vols then
      272 	     do lvx = 1 to dt.n_lv_entries;
      273 	     if dt.lv_array (lvx).used then do;
      274 		lvname = dt.lv_array (lvx).lvname;
      275 		call list_vol_attachments;
      276 	     end;
      277 	end;
      278 
      279 	else do vtlx = 1 to n_vols_to_list;
      280 	     lvname = vols_to_list (vtlx);
      281 	     do lvx = 1 to dt.n_lv_entries
      282 		while (lvname ^= dt.lv_array (lvx).lvname);
      283 	     end;
      284 	     if lvx ^> dt.n_lv_entries then
      285 		call list_vol_attachments;
      286 	     else call ioa_ ("^/LV ""^a"" is not defined.", lvname);
      287 	end;
      288 
      289 	if list_all_vols & ^shown_lvat_header then
      290 	     call ioa_ ("^/No LV Attachments.");
      291 	return;
      292 
      293 /* --------------------------------------------------------- */
      294 
      295 list_vol_attachments: proc;
      296 
      297 	     call initializer_mdc_$lvat_scan_lv (lvname, array, n);
      298 
      299 	     if n = 0 then do;
      300 		if ^list_all_vols then
      301 		     call ioa_ ("^/No attachments to LV ""^a"".", lvname);
      302 		return;
      303 	     end;
      304 
      305 	     call ioa_ ("^/LV ""^a"" Attachments:^/", lvname);
      306 	     if ^shown_lvat_header then do;
      307 		call ioa_ ("User^35tProcess_id^49tStatus^/");
      308 		shown_lvat_header = "1"b;
      309 	     end;
      310 
      311 	     do i = 1 to n;
      312 		lvax = array (i);
      313 		call get (lvax);
      314 		call find_u (lvate.pid);
      315 		if lvate.mounted then status = "In use";
      316 		else if lvate.detach_requested then status = "Detaching";
      317 		else if lvate.waiting | lvate.pending_mount then status = "Waiting for mount";
      318 		else if lvate.invalidated then status = "Invalidated";
      319 		else status = "??????";
      320 
      321 		call ioa_ ("^33a ^12.3b  ^a", user_procname, user_procid,
      322 		     status);
      323 	     end;
      324 
      325 	     return;
      326 	end list_vol_attachments;
      327 
      328 /* --------------------------------------------------------- */
      329 
      330 cleanup_process: entry (a_pid);
      331 
      332 	if ^initialized then return;
      333 	call find_u (a_pid);
      334 	pid = a_pid;
      335 	call initializer_mdc_$scan_process_lvat (pid, array, n);
      336 
      337 	do i = 1 to n;
      338 
      339 	     lvax = array (i);
      340 	     call get (lvax);
      341 	     lvname = lvate.lvname;
      342 	     if lvate.mounted then call detach;
      343 	     call initializer_mdc_$free_lvate (lvax);
      344 	end;
      345 	return;
      346 
      347 /* --------------------------------------------------------- */
      348 
      349 mhv_complete: entry (a_lvx, a_dtp);
      350 
      351 	if ^initialized then return;
      352 	lvx = a_lvx;
      353 	lvname = a_lvname;
      354 	dtp = a_dtp;
      355 	lvep = addr (dt.lv_array (lvx));
      356 	lvname = lve.lvname;
      357 
      358 	call initializer_mdc_$lvat_scan_lv (lvname, array, n);
      359 	do i = 1 to n;
      360 	     lvax = array (i);
      361 	     call get (lvax);
      362 	     if lvate.pending_mount then do;
      363 		call find_u (lvate.pid);
      364 		call initializer_mdc_$respond_mount_lv (lvax, 1, 0, ec);
      365 		if ec ^= 0 then call beef ("Sending mount ready message");
      366 		else call attach;
      367 	     end;
      368 	end;
      369 	return;
      370 
      371 /* --------------------------------------------------------- */
      372 
      373 
      374 interrupt:
      375 
      376 	ev_calls_masked = "0"b;
      377 
      378 	call condition_ ("any_other", any_other_handler);
      379 
      380 	if ^ (evmessage.sender = myprocessid | evmessage.ring = LV_RING) then do;
      381 	     call find_u (evmessage.sender);
      382 	     call sys_log_ (SL0,
      383 		"lv_request_: Spurious wakeup ^24.3b received from ^a ^12.3b ^d",
      384 		evmessage.bits, user_procname, user_procid,
      385 		evmessage.ring);
      386 	     return;
      387 	end;
      388 
      389 
      390 	unspec (mount_transmission) = evmessage.bits;
      391 
      392 	if evmessage.bits = unspec (ALARM___) | mount_transmission.req = "poll"
      393 	     then do;
      394 	     call poll_mounts;
      395 	     return;
      396 	end;
      397 	
      398 
      399 /* must be real requst */
      400 
      401 	if mount_transmission.other ^= 0 | (mount_transmission.req ^= "moun" & mount_transmission.req ^= "demo")
      402 	then do;
      403 	     call sys_log_ (SL_LOG_BEEP,
      404 		"lv_request_ : bad transmission: ^24.3b", evmessage.bits);
      405 	     return;
      406 	end;
      407 
      408 	lvax = mount_transmission.lvax;
      409 	demounting = mount_transmission.req = "demo";
      410 	call get (lvax);
      411 	if xec ^= 0 then do;
      412 badlvax:	     call sys_log_ (SL_LOG_BEEP,
      413 		"lv_request_: bad LV attach table index ^d in ^[demount^;mount^] request",
      414 		lvax, demounting);
      415 	     return;
      416 	end;
      417 
      418 	if evmessage.sender ^= lvate.pid then go to badlvax;
      419 	call find_u (evmessage.sender);
      420 	lvname = lvate.lvname;			/* For attach/detach messages */
      421 
      422 
      423 	if demounting then do;
      424 	     if lvate.mounted then call detach;
      425 	     call initializer_mdc_$free_lvate (lvax);
      426 	     call initializer_mdc_$scan_process_lvat (evmessage.sender, array, n);
      427 	     if n = 0 then do;
      428 		if utep ^= null then ute.lvs_attached = "0"b;
      429 	     end;
      430 	     return;
      431 	end;
      432 
      433 /* Mount a logical volume. */
      434 
      435 	dtp = disk_table_$get_dtp ();
      436 
      437 	do lvx = 1 to dt.n_lv_entries;
      438 	     lvep = addr (dt.lv_array (lvx));
      439 	     if lve.hv_mounted & lve.lvname = lvname then do;
      440 		call initializer_mdc_$set_lvat_info (lvax, lve.lvid, lvx);
      441 		call initializer_mdc_$respond_mount_lv (lvax, 1, 0, ec);
      442 		if ec = 0 then do;
      443 		     call attach;
      444 		     if utep ^= null () then ute.lvs_attached = "1"b;
      445 		end;
      446 		else call beef ("Mount already ready");
      447 		return;
      448 	     end;
      449 	end;
      450 
      451 /*  */
      452 /* Must generate a mhv */
      453 
      454 	ev_calls_masked = "1"b;			/* remember to unmask below */
      455 	call ipc_$mask_ev_calls (ec);			/* Must protect initializer from ioa_ */
      456 	if ec ^= 0 then do;
      457 	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
      458 		"Masking event calls.");
      459 	     go to no_avail;
      460 	end;
      461 
      462 	on command_error;				/* Ignore command errors, too */
      463 						/* distk_table_ is into com_err_. */
      464 
      465 
      466 	call disk_table_$dry_run_mhv (lvname, result);
      467 
      468 	if result = 0 then go to mhv_it;		/* if can hack without dhvs, do it now */
      469 
      470 	do lvx = 1 to dt.n_lv_entries;
      471 	     lvep = addr (dt.lv_array (lvx));
      472 	     if (lve.hv_mounted | lve.mounting) & ^lve.public then do;   /* can only demount in-use privates */
      473 		d_lvname = lve.lvname;
      474 		call initializer_mdc_$lvat_scan_lv (d_lvname, array, n);
      475 		if n = 0 then do;
      476 		     do pvx = 1 to dt.n_entries;
      477 			dtep = addr (dt.array (pvx));
      478 			if dte.lvx = lvx then do;
      479 			     lve.good_candidate = "1"b;
      480 			     dte.used = "0"b;
      481 			     dte.pre_accepted = "1"b;
      482 			end;
      483 		     end;
      484 		     if lve.good_candidate then do;	/* Now try trial mhv */
      485 			call disk_table_$dry_run_mhv (lvname, result);
      486 			if result = 0 then go to dlv_and_mhv;
      487 		     end;
      488 		end;
      489 	     end;
      490 	end;
      491 
      492 /*	No amount of dhvery will make this volume mountable */
      493 
      494 no_avail:
      495 	call sys_log_ (SL0, "No drives available to mount ^a for ^a ^12.3b",
      496 	     lvname, user_procname, user_procid);
      497 	call initializer_mdc_$respond_mount_lv (lvax, 3, error_table_$resource_unavailable, ec);
      498 	if ec ^= 0 then call beef ("Drive availability denial");
      499 unmask:	if ev_calls_masked then			/* if we masked event calls above */
      500 	     call ipc_$unmask_ev_calls ((0));		/* then unmask. otherwise leave mask alone */
      501 	return;
      502 
      503 /*  */
      504 /*  If we dlv marked lve's, there will be enough space */
      505 
      506 dlv_and_mhv:
      507 	n = 0;
      508 	do lvx = 1 to dt.n_lv_entries;
      509 	     lvep = addr (dt.lv_array (lvx));
      510 	     if lve.good_candidate then do;
      511 		n = n + 1;
      512 		array (n) = lvx;
      513 	     end;
      514 	end;
      515 
      516 	do i = 1 to n;
      517 	     lvep = addr (dt.lv_array (array (i)));
      518 	     call disk_table_$dhv ((lve.lvname));
      519 	end;
      520 
      521 /*  See if it all worked */
      522 
      523 	do i = 1 to n;
      524 	     lvep = addr (dt.lv_array (array (i)));
      525 	     if lve.demounting then go to no_avail;
      526 	end;
      527 
      528 /* Drives logically free. Now mhv */
      529 
      530 mhv_it:	call sys_log_ (SL0,
      531 	     "lv_request_: Beginning mount of LV ^a for ^a ^12.3b.",
      532 	     lvname, user_procname, user_procid);
      533 	call disk_table_$mhv (lvname);
      534 
      535 	do lvx = 1 to dt.n_lv_entries;
      536 	     lvep = addr (dt.lv_array (lvx));
      537 	     if lve.lvname = lvname then do;
      538 		if lve.hv_mounted then go to unmask;	/* lv_request_$mhv_complete took care */
      539 		if lve.mounting then do;
      540 		     call initializer_mdc_$respond_mount_lv (lvax, 4, 0, ec);
      541 		     call initializer_mdc_$mhvmessage (lvax, user_procname);
      542 						/* beep beep */
      543 		     if ec ^= 0 then call beef ("Sending response to wait for mount");
      544 		end;
      545 		if utep ^= null () then ute.lvs_attached = "1"b;
      546 		go to unmask;
      547 	     end;
      548 	end;
      549 
      550 	go to no_avail;				/* Somehow didn't make it */
      551 						/*  */
      552 
      553 /* Subroutines */
      554 
      555 beef:	proc (beef);				/* Can't send message */
      556 
      557 dcl  beef char (*);
      558 
      559 	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
      560 		"Cannot send message to ^a ^12.3b: ^a", user_procname,
      561 		user_procid, beef);
      562 
      563 	     return;
      564 	end;
      565 
      566 attach:	proc;
      567 
      568 	     call sys_log_ (SL0,
      569 		"lv_request_: ATTACH^20tLV ^a to ^a ^12.3b.",
      570 		lvname, user_procname, user_procid);
      571 	     if utep ^= null
      572 		then call device_acct_$on (devtab_ix_lv, lvname, utep);
      573 	end;
      574 
      575 detach:	proc;
      576 
      577 	     call sys_log_ (SL0,
      578 		"lv_request_: DETACH^20tLV ^a from ^a ^12.3b.", lvname,
      579 		user_procname, user_procid);
      580 
      581 	     if utep ^= null then
      582 		call device_acct_$off (devtab_ix_lv, lvname, utep);
      583 
      584 	end;
      585 
      586 get:	proc (a_lvax);
      587 
      588 dcl  a_lvax fixed bin;
      589 
      590 	     lvatep = addr (local_lvate);
      591 	     call initializer_mdc_$retrieve_lvate (a_lvax, lvatep, xec);
      592 	end;
      593 
      594 
      595 find_u:	proc (pid);
      596 
      597 dcl  ape char (24);
      598 dcl  aprj char(12);
      599 dcl  tag char(1);
      600 dcl  anon fixed bin;
      601 
      602 dcl  pid bit (36) aligned;
      603 
      604 	     if testing then do;
      605 		call get_userid_$info(pid, ape, aprj, tag, 0, anon, 0, ec);
      606 		if ec = 0 then utep = addrel (null, 1);
      607 		else utep = null;
      608 	     end;
      609 	     else do;
      610 		call as_$find_process (pid, (0), utep);
      611 		if utep ^= null then do;
      612 		     ape = ute.person;
      613 		     aprj = ute.project;
      614 		     tag = ute.tag;
      615 		     anon = ute.anonymous;
      616 		end;
      617 	     end;
      618 	     if utep = null then user_procname = "PROCESSID";
      619 	     else call ioa_$rsnnl("^[*^]^a.^a.^a", user_procname, (0),
      620 		(anon=1), ape, aprj, tag);
      621 	     user_procid = pid;
      622 
      623 	     return;
      624 
      625 	end;
      626 
      627 
      628 any_other_handler: proc (mcp, cname, cop, inp, cont);
      629 
      630 dcl (mcp, cop, inp) ptr, cname char (*), cont bit (1);
      631 
      632 	     if testing | ^initialized
      633 	     | cname = "quit" | cname = "alrm" | cname = "program_interrupt"
      634 	     | cname = "cput" | cname = "signal_io_" then do;
      635 		cont = "1"b;
      636 		return;
      637 	     end;
      638 
      639 	     call sys_log_ (SL_LOG_BEEP,
      640 		"lv_request_: Unexpected condition ^a occurred.", cname);
      641 	     call as_$dump ("lv_request_");
      642 	     ec = 0;
      643 	     do while (ec = 0);			/* be sure to get completely unmasked */
      644 		call ipc_$unmask_ev_calls (ec);
      645 	     end;
      646 	     go to unmask;				/* nonlocal goto. return to ipc_ to get this ev chn uninhibited */
      647 	end;
      648 
      649 
      650 /* Subroutine to check for pending mounts whose timeout has expired */
      651 
      652 poll_mounts:
      653 	proc;
      654 	
      655 	dtp = disk_table_$get_dtp ();
      656 
      657 	call initializer_mdc_$poll_mounts (array, n, next_time);
      658 	if n > 0 
      659 	     then do i = 1 to n;
      660 	     call get (array (i));
      661 	     do lvx = 1 to dt.n_lv_entries
      662 		while (dt.lv_array (lvx).lvname ^= lvate.lvname | ^dt.lv_array (lvx).used);
      663 	     end;
      664 	     if lvx <= dt.n_lv_entries then do;
      665 		unit_string = "";
      666 		do dtx = 1 to dt.n_entries;
      667 		     dtep = addr (dt.array (dtx));
      668 		     if dte.lvx = lvx
      669 			then if dte.pre_accepted
      670 			then unit_string = unit_string || rtrim (dte.pvname) || " (" || rtrim (dte.drive_name) || ") ";
      671 		end;
      672 		if unit_string ^= "" then do;
      673 		     call find_u (lvate.pid);
      674 		     call initializer_mdc_$check_mount (array (i),
      675 			user_procname, unit_string);
      676 		end;
      677 	     end;
      678 	end;
      679 	
      680 	if next_time > 0
      681 	     then call timer_manager_$alarm_wakeup (next_time, "00"b, evmessage.evchn);
      682 
      683 
      684 	end;
      685 
      686 
      687 test:	entry;
      688 
      689 	LV_RING = get_ring_ ();
      690 	testing = "1"b;
      691 	SL0 = SL_LOG;
      692 	return;
      693 
      694 
      695 /* BEGIN MESSAGE DOCUMENTATION
      696*
      697*   Message:
      698*   lv_request_: ERROR_MESSAGE. Cannot initialize logical volume mounting
      699*   software.
      700*
      701*   S:	$as2
      702*
      703*   T:	$init
      704*
      705*   M:	Initialization of the logical volume attach table failed.  
      706*   ERROR_MESSAGE is the text associated with the error code returned by
      707*   initializer_mdc_$init_lvat.
      708*
      709*   A:	$notify_sa
      710*
      711*
      712*   Message:
      713*   lv_request_: Denied LV LVNAME to PERSON.PROJECT.TAG PROCESSID
      714*
      715*   S:	$as0
      716*
      717*   T:	When dismounting a logical volume.
      718*
      719*   M:	The user process identified by PERSON.PROJECT.TAG and PROCESSID
      720*   was waiting to mount a logical volume LVNAME which is being dismounted
      721*   by the operator.  The mount request was therefore denied.
      722*
      723*   A:	$ignore
      724*
      725*   
      726*   Message:
      727*   lv_request_: Spurious wakeup EVENT_MESSAGE received from PERSON.PROJECT.TAG
      728*   PROCESSID RINGNO
      729* 
      730*   S:	$as0
      731*
      732*   T:	When processing a disk mount/demount interrupt.
      733*
      734*   M:	A wakeup was received on the lv_request_ interrupt event channel
      735*   with event data EVENT_MESSAGE from the process with PERSON.PROJECT.TAG,
      736*   PROCESSID and RINGNO.  This message is invalid because it did not come
      737*   from the Initializer, ring 1 environment.
      738*
      739*   A:	$ignore
      740*
      741*
      742*   Message:
      743*   lv_request_: bad transmission:  EVENT_MESSAGE
      744*
      745*   S:	$as2
      746*
      747*   T:	When processing a disk mount/demount interrupt.
      748*
      749*   M:	An unexpected EVENT_MESSAGE was received by the mount/demount
      750*   interrupt handler.  $err
      751*
      752*   A:	$notify_sa
      753*
      754*
      755*   Message:
      756*   lv_request_: bad LV attach table index N in {DE}MOUNT request
      757*
      758*   S:	$as2
      759*
      760*   T:	When processing a disk mount/demount interrupt.
      761*
      762*   M:	The Logical Volume attach table index given in the event message
      763*   associated with the mount or demount interrupt is invalid.  $err
      764*
      765*   A:	$notify_sa
      766*
      767*
      768*   Message:
      769*   lv_request_:  ERROR_MESSAGE.  Masking event calls.
      770*
      771*   S:	$as2
      772*
      773*   T:	When processing a disk mount/demount interrupt.
      774*
      775*   M:	An error occurred while attempting to mask event call wakeups.
      776*   ERROR_MESSAGE is the text associated with the error code returned by
      777*   ipc_$mask_ev_calls.  $err
      778*
      779*   A:	$notify_sa
      780*
      781*
      782*   Message:
      783*   lv_request_: No drives available to mount LV LVNAME for PERSON.PROJECT.TAG
      784*   PROCESSID
      785*
      786*   S:	$as0
      787*
      788*   T:	When processing a disk mount/demount interrupt.
      789*
      790*   M:	Drives needed to mount the volumes of LVNAME were in use or
      791*   deleted.  The logical volume could not be mounted for the process identified
      792*   by PERSON.PROJECT.TAG and PROCESSID.
      793*
      794*   A:	$ignore
      795*
      796*
      797*   Message:
      798*   lv_request_:  Beginning mount of LV LVNAME for PERSON.PROJECT.TAG PROCESSID
      799*
      800*   S:	$as0
      801*
      802*   T:	When processing a disk mount/demount interrupt.
      803*
      804*   M:	The volumes associated with LVNAME are now being mounted for
      805*   the process identified by PERSON.PROJECT.TAG and PROCESSID.
      806*
      807*   A:	$ignore
      808*
      809*
      810*   Message:
      811*   lv_request_: Cannot send message to PERSON.PROJECT.TAG PROCESSID: ADDED_INFO
      812*
      813*   S:	$as2
      814*
      815*   T:	When processing a disk mount/demount interrupt.
      816*
      817*   M:	The Initializer is attempting to respond to a request to mount
      818*   or demount a logical volume, but is unable to send a wakeup to the user
      819*   process.  The process may have logged out.  $err
      820*
      821*   A:	$notify_sa
      822*
      823*
      824*   Message:
      825*   lv_request_: ATTACHED LV LVNAME to PERSON.PROJECT.TAG PROCESSID.
      826*
      827*   S:	$as0
      828*
      829*   T:	When processing a disk mount/demount interrupt.
      830*
      831*   M:	This message records attachment of logical volume LVNAME to the
      832*   process identified by PERSON.PROJECT.TAG and PROCESSID.
      833*
      834*   A:	 $ignore
      835*
      836*
      837*   Message:
      838*   lv_request_: DETACHED LV LVNAME from PERSON.PROJECT.TAG PROCESSID.
      839*
      840*   S:	$as0
      841*
      842*   T:	When processing a disk mount/demount interrupt.
      843*
      844*   M:	This message records detachment of logical volume LVNAME from the
      845*   process identified by PERSON.PROJECT.TAG and PROCESSID.
      846*
      847*   A:	 $ignore
      848*
      849*   
      850*   Message:
      851*   lv_request_: Unexpected condition CONDNAME occurred.
      852*
      853*   S:	$as2
      854*
      855*   T:	When processing a disk mount/demount interrupt.
      856*
      857*   M:	Condition CONDNAME was signalled unexpectedly during a mount or
      858*   demount request.  An answering service dump is created to further document
      859*   the cause of the error.
      860*
      861*   A:	$notify_sa.
      862*
      863*
      864*   END MESSAGE DOCUMENTATION */
      865 
      866  /* BEGIN INCLUDE FILE devid.incl.pl1 */
  1     2 
  1     3 /* Rewritten September 1977 by T. Casey to implement a new method of device charging. */
  1     4 
  1     5 
  1     6 /****^  HISTORY COMMENTS:
  1     7*  1) change(85-10-07,Herbst), approve(87-07-21,MCR7694),
  1     8*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
  1     9*     Add dsa_kbyt, dsa_kpkt and dsa_hour device types.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 /* This include file is used to avoid conflicts between system code and customer
  1    14*   sites over the use of elements of the devtab array in installation_parms.
  1    15*
  1    16*   Sites can define new device types for terminal channel charging (for high-speed
  1    17*   lines, for example), set prices for them in installation_parms, and use their
  1    18*   names in the charge statement in the CMF.
  1    19*
  1    20*   There also exists a set of system-defined devices, such as tape and disk, and
  1    21*   this set must be expandable. Code to charge for each one of these devices is
  1    22*   built into the system. That code can not reference specific elements in the
  1    23*   devtab array, since a site may have used any given element in that array for
  1    24*   one of its own devices. This include file solves that problem.
  1    25*
  1    26*   The dev_id array contains the names of devices for which charging code is
  1    27*   built into the system. That array should be changed whenever new device
  1    28*   charging code is added. The order of device names in that array is insignificant.
  1    29*   The constants with names of the form dev_DEVICE are used for program
  1    30*   readability, to avoid having to reference specific entries in the dev_id
  1    31*   array with numeric constants as subscripts.
  1    32*
  1    33*   The site must define devices of each of the names in the dev_id array, and
  1    34*   set prices for them. Otherwise, no charges will be made for use of those
  1    35*   devices. The ed_installation_parms procedure prints a warning, when
  1    36*   printing device prices, if any of the required devices is not defined.
  1    37*
  1    38*   The static variables with names of the form devtab_ix_DEVICE are used to
  1    39*   hold the subscripts of the respective devices' devtab entries. These variables
  1    40*   must be assigned values at initialization time by the procedures that use them.
  1    41*   These procedures should call system_info_$device_prices to get a copy of devtab,
  1    42*   and then search devtab for a device_id equal to dev_id(dev_DEVICE) and remember
  1    43*   the subscript in devtab_ix_DEVICE. If the device is not defined, the devtab_ix
  1    44*   variable should remain zero, as an indication that charging for the device is
  1    45*   to be bypassed.
  1    46*
  1    47**/
  1    48 dcl  dev_id (8) char (8) aligned int static options (constant) init
  1    49     ("tape", "tape_mt", "disk", "disk_mt", "lv",
  1    50      "dsa_kbyt", "dsa_kpkt", "dsa_hour");
  1    51 
  1    52 dcl  dev_tape fixed bin int static options (constant) init (1);
  1    53 dcl  dev_tape_mt fixed bin int static options (constant) init (2);
  1    54 dcl  dev_disk fixed bin int static options (constant) init (3);
  1    55 dcl  dev_disk_mt fixed bin int static options (constant) init (4);
  1    56 dcl  dev_lv fixed bin int static options (constant) init (5);
  1    57 dcl  dev_dsa_kilobyte fixed bin int static options (constant) init (6);
  1    58 dcl  dev_dsa_kilopacket fixed bin int static options (constant) init (7);
  1    59 dcl  dev_dsa_hour fixed bin int static options (constant) init (8);
  1    60 
  1    61 dcl  devtab_ix_tape fixed bin int static init (0);
  1    62 dcl  devtab_ix_tape_mt fixed bin int static init (0);
  1    63 dcl  devtab_ix_disk fixed bin int static init (0);
  1    64 dcl  devtab_ix_disk_mt fixed bin int static init (0);
  1    65 dcl  devtab_ix_lv fixed bin int static init (0);
  1    66 dcl  devtab_ix_dsa_kilobyte fixed bin int static init (0);
  1    67 dcl  devtab_ix_dsa_kilopacket fixed bin int static init (0);
  1    68 dcl  devtab_ix_dsa_hour fixed bin int static init (0);
  1    69 
  1    70 /* END INCLUDE FILE devid.incl.pl1 */
      866 
      867  /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     7*     Add support for subvolumes.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  2    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  2    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  2    14 
  2    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  2    16 
  2    17 dcl  dtp ptr,
  2    18      dtep ptr,
  2    19      lvep ptr;
  2    20 
  2    21      
  2    22 
  2    23 dcl 1 dt based (dtp) aligned,
  2    24 
  2    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  2    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  2    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  2    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  2    29     2 version fixed bin init (1),
  2    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  2    31     2 pad (2) bit (36),
  2    32     2 array (0 refer (dt.max_n_entries)) like dte,
  2    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  2    34 
  2    35 dcl 1 dte based (dtep) aligned,
  2    36     2 drive_name char (8),				/* device name */
  2    37     (2 device_type fixed bin (8),			/* device type */
  2    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  2    39     2 known bit (1),				/* TRUE if label has been read and checked */
  2    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  2    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  2    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  2    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  2    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  2    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  2    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  2    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  2    48     2 is_sub_vol bit (1),
  2    49     2 pad bit (3),
  2    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  2    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  2    52     2 sv_num  fixed bin unal,				/* this sv number */
  2    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  2    54     2 sv_name   char (2) aligned,
  2    55     2 pvid bit (36),				/* physical volume ID */
  2    56     2 pvname char (32);				/* Physical volume name. */
  2    57 
  2    58 dcl 1 lve based (lvep) aligned,
  2    59     2 lvid bit (36),				/* logical volume ID */
  2    60     (2 used bit (1),				/* TRUE if entry used */
  2    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  2    62     2 public bit (1),				/* TRUE for public vol */
  2    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  2    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  2    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  2    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  2    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  2    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  2    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  2    70     2 pad bit (26)) unal,
  2    71     2 lvname char (32),				/* Logical volume name */
  2    72     2 min_access_class bit (72),			/* Security stuff */
  2    73     2 max_access_class bit (72);			/* .. */
  2    74 
  2    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      867 
      868  /* BEGIN INCLUDE FILE lv_atttbl.incl.pl1 B. Greenberg 09/08/76 */
  3     2 
  3     3 /* This structure is used for communicating logical volume mount requests
  3     4*   from RCP to mdxhdx */
  3     5 
  3     6 dcl  lvatp ptr;
  3     7 
  3     8 dcl 1 lvat based (lvatp) aligned,			/* Logical volume attach table */
  3     9     2 master_pid bit (36) aligned,			/* Processid of mdxhdx process */
  3    10     2 initialized bit (1) aligned,			/* Table has been initted */
  3    11     2 master_evchn fixed bin (71) aligned,		/* Event channel for request wakeups */
  3    12     2 max_n_entries fixed bin,			/* Number of entries  maximum */
  3    13     2 highest_used fixed bin,				/* Highest number used */
  3    14     2 pad(10) fixed bin,
  3    15     2 array like lvate dim (0 refer (lvat.max_n_entries));
  3    16 
  3    17 dcl  lvatep ptr;
  3    18 
  3    19 dcl 1 lvate based (lvatep) aligned,			/* LVAT Entry */
  3    20     2 pid bit (36) aligned,				/* LOCK/PROCESSID */
  3    21     2 state fixed bin,				/* state of attachment */
  3    22     2 code fixed bin (35),				/* error table code if appropriate */
  3    23     2 lvname char (32),				/* Name involved */
  3    24     2 evchn fixed bin (71),				/* Reply channel */
  3    25     2 flags,					/* various flags */
  3    26      3 pending_mount bit (1) unal,			/* Mount pending */
  3    27      3 mount_req_answered bit (1) unal,			/* Inz has answered */
  3    28      3 detach_requested bit (1) unal,			/* detach has been requested */
  3    29      3 mounted bit (1) unal,				/* has been attached */
  3    30      3 waiting bit (1) unal,				/* waiting for mount */
  3    31      3 invalidated bit (1) unal,			/* entry invalidated by Inz */
  3    32      3 pad bit  (30) unal,
  3    33     2 lvx fixed bin,				/* Used when valid */
  3    34     2 lvid bit (36) aligned,				/* Used to validate above */
  3    35     2 mount_request_timeout fixed bin (71);		/* Time to repeat mount message */
  3    36 	
  3    37 
  3    38 /* END INCLUDE FILE lv_atttbl.incl.pl1 */
      868 
      869  /* BEGIN INCLUDE FILE sys_log_constants.incl.pl1 ... 82-09-24 E. N. Kittlitz */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-04-22,GDixon), approve(87-06-10,MCR7708),
  4     6*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
  4     7*     Added sl_info structure and associated named constants for use in calling
  4     8*     sys_log_$general.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 /* format: style4 */
  4    13 
  4    14 dcl  (
  4    15      SL_TYPE_CRASH init (-3),				/* type message with banner & kill system */
  4    16      SL_TYPE_BEEP init (-2),				/* type message with banner */
  4    17      SL_TYPE init (-1),				/* type message */
  4    18      SL_LOG_SILENT init (0),				/* log message */
  4    19      SL_LOG init (1),				/* log & type message */
  4    20      SL_LOG_BEEP init (2),				/* log & type message with banner */
  4    21      SL_LOG_CRASH init (3)				/* log & type message with banner & kill system */
  4    22      ) fixed bin internal static options (constant);
  4    23 
  4    24 dcl  1 sl_info aligned automatic,
  4    25        2 version char(8),			/* structure version       */
  4    26        2 arg_list_ptr ptr,			/* arg_list with values    */
  4    27        2 loc,
  4    28          3 (mode, severity, code, caller, data, class, ioa_msg) fixed bin,
  4    29            /* These flags control where the corresponding data item is found.*/
  4    30 	 /*  -1: data appears in the corresponding structure element below */
  4    31 	 /*   0: data is not present anywhere			       */
  4    32 	 /*  +N: data is Nth item in argument list pointed to by 	       */
  4    33 	 /*      sl_info.arg_list_ptr.  Upon return, data copied into      */
  4    34 	 /*      corresponding structure element.		       */
  4    35 	 /*  if data = +N:					       */
  4    36 	 /*      argN is data_ptr, argN+1 is data_len		       */
  4    37 	 /*  if ioa_msg = +N:				       */
  4    38 	 /*      argN+1, ... argLAST are arguments substituted into the    */
  4    39 	 /*      ioa_msg control string.  The formatted msg is returned.   */
  4    40        2 flags,
  4    41          3 ioa_msg_is_error_code bit(1) unal,	/* ioa_ctl is error code.  */
  4    42          3 flags_pad bit(35) unal,
  4    43        2 mode fixed bin,			/* as-mode, command-mode   */
  4    44        2 severity fixed bin,			/* error severity	       */
  4    45        2 code fixed bin(35),			/* error table code        */
  4    46        2 caller char(65) varying,		/* caller refname$entryname*/
  4    47        2 data,				/* binary data ptr/length  */
  4    48          3 data_ptr ptr,
  4    49          3 data_lth fixed bin(21),
  4    50        2 class char(10) varying,		/* binary data class       */
  4    51        2 ioa_msg char(500) varying;		/* formatted message text  */
  4    52 
  4    53 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    54 /*							       */
  4    55 /* If data values (eg, sl_info.caller) are passed in the argument list,      */
  4    56 /* their data types should be as shown in the structure above, except that   */
  4    57 /* character strings should be char(*) nonvarying.		       */
  4    58 /*							       */
  4    59 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    60 
  4    61 /* value for sl_info.version */
  4    62 dcl  SL_INFO_version_1 char (8) int static options(constant) init("sl_info1");
  4    63 
  4    64 /* values for sl_info.mode */
  4    65 dcl (SL_INFO_as_mode init(1),
  4    66      SL_INFO_command_mode init(2)) fixed bin int static options(constant);
  4    67 
  4    68 /* values for sl_info.loc.(severity code caller data class ioa_ctl arg) */
  4    69 dcl (SL_INFO_arg_given_in_structure init(-1),
  4    70      SL_INFO_arg_not_given init(0)) fixed bin int static options(constant);
  4    71 
  4    72 
  4    73 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    74 /*							       */
  4    75 /* The following static structures are commonly used in the Login Server     */
  4    76 /* user control software.					       */
  4    77 /*							       */
  4    78 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    79 
  4    80 /* Syntax: call Abort (severity, code, ioa_ctl, args);		       */
  4    81 
  4    82 dcl  1 sl_info_sev_code_msg		aligned int static options(constant),
  4    83        2 version char(8)		init ("sl_info1"),
  4    84        2 arg_list_ptr ptr		init (null),
  4    85        2 loc,
  4    86          3 (mode			init (-1),
  4    87 	  severity  		init ( 1),
  4    88 	  code 			init ( 2),
  4    89 	  caller 			init (-1),
  4    90 	  data 			init ( 0),
  4    91 	  class 			init ( 0),
  4    92 	  ioa_msg			init ( 3)) fixed bin,
  4    93        2 flags,
  4    94          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
  4    95          3 flags_pad bit(35) unal	init ("0"b),
  4    96        2 mode fixed bin		init ( 1),
  4    97        2 severity fixed bin		init ( 0),
  4    98        2 code fixed bin(35)		init ( 0),
  4    99        2 caller char(65) varying	init (""),
  4   100        2 data,
  4   101          3 data_ptr ptr		init (null),
  4   102          3 data_lth fixed bin(21)	init ( 0),
  4   103        2 class char(10) varying	init (""),
  4   104        2 ioa_msg char(500) varying	init ("");
  4   105 
  4   106 /* Syntax: call Abort (severity, ioa_ctl, args);			       */
  4   107 
  4   108 dcl  1 sl_info_sev_msg		aligned int static options(constant),
  4   109        2 version char(8)		init ("sl_info1"),
  4   110        2 arg_list_ptr ptr		init (null),
  4   111        2 loc,
  4   112          3 (mode			init (-1),
  4   113 	  severity  		init ( 1),
  4   114 	  code 			init ( 0),
  4   115 	  caller 			init (-1),
  4   116 	  data 			init ( 0),
  4   117 	  class 			init ( 0),
  4   118 	  ioa_msg			init ( 2)) fixed bin,
  4   119        2 flags,
  4   120          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
  4   121          3 flags_pad bit(35) unal	init ("0"b),
  4   122        2 mode fixed bin		init ( 1),
  4   123        2 severity fixed bin		init ( 0),
  4   124        2 code fixed bin(35)		init ( 0),
  4   125        2 caller char(65) varying	init (""),
  4   126        2 data,
  4   127          3 data_ptr ptr		init (null),
  4   128          3 data_lth fixed bin(21)	init ( 0),
  4   129        2 class char(10) varying	init (""),
  4   130        2 ioa_msg char(500) varying	init ("");
  4   131 
  4   132 /* Syntax: call Abort (severity, ioa_ctl_as_error_code, args);	       */
  4   133 
  4   134 dcl  1 sl_info_sev_coded_msg		aligned int static options(constant),
  4   135        2 version char(8)		init ("sl_info1"),
  4   136        2 arg_list_ptr ptr		init (null),
  4   137        2 loc,
  4   138          3 (mode			init (-1),
  4   139 	  severity  		init ( 1),
  4   140 	  code 			init ( 0),
  4   141 	  caller 			init (-1),
  4   142 	  data 			init ( 0),
  4   143 	  class 			init ( 0),
  4   144 	  ioa_msg			init ( 2)) fixed bin,
  4   145        2 flags,
  4   146          3 ioa_msg_is_error_code bit(1) unal init ("1"b),
  4   147          3 flags_pad bit(35) unal	init ("0"b),
  4   148        2 mode fixed bin		init ( 1),
  4   149        2 severity fixed bin		init ( 0),
  4   150        2 code fixed bin(35)		init ( 0),
  4   151        2 caller char(65) varying	init (""),
  4   152        2 data,
  4   153          3 data_ptr ptr		init (null),
  4   154          3 data_lth fixed bin(21)	init ( 0),
  4   155        2 class char(10) varying	init (""),
  4   156        2 ioa_msg char(500) varying	init ("");
  4   157 
  4   158 
  4   159 /* Syntax: call Abort (severity, code, error_return_label, ioa_ctl, args);   */
  4   160 
  4   161 dcl  1 sl_info_sev_code_label_msg	aligned int static options(constant),
  4   162        2 version char(8)		init ("sl_info1"),
  4   163        2 arg_list_ptr ptr		init (null),
  4   164        2 loc,
  4   165          3 (mode			init (-1),
  4   166 	  severity  		init ( 1),
  4   167 	  code 			init ( 2),
  4   168 	  caller 			init (-1),
  4   169 	  data 			init ( 0),
  4   170 	  class 			init ( 0),
  4   171 	  ioa_msg			init ( 4)) fixed bin,
  4   172        2 flags,
  4   173          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
  4   174          3 flags_pad bit(35) unal	init ("0"b),
  4   175        2 mode fixed bin		init ( 1),
  4   176        2 severity fixed bin		init ( 0),
  4   177        2 code fixed bin(35)		init ( 0),
  4   178        2 caller char(65) varying	init (""),
  4   179        2 data,
  4   180          3 data_ptr ptr		init (null),
  4   181          3 data_lth fixed bin(21)	init ( 0),
  4   182        2 class char(10) varying	init (""),
  4   183        2 ioa_msg char(500) varying	init ("");
  4   184 
  4   185 /* Syntax:  call Log_error (code, ioa_ctl, args);			       */
  4   186 
  4   187 dcl  1 sl_info_code_msg		aligned int static options(constant),
  4   188        2 version char(8)		init ("sl_info1"),
  4   189        2 arg_list_ptr ptr		init (null),
  4   190        2 loc,
  4   191          3 (mode			init (-1),
  4   192 	  severity  		init (-1),
  4   193 	  code 			init ( 1),
  4   194 	  caller 			init (-1),
  4   195 	  data 			init ( 0),
  4   196 	  class 			init ( 0),
  4   197 	  ioa_msg			init ( 2)) fixed bin,
  4   198        2 flags,
  4   199          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
  4   200          3 flags_pad bit(35) unal	init ("0"b),
  4   201        2 mode fixed bin		init ( 1),
  4   202        2 severity fixed bin		init ( 0),
  4   203        2 code fixed bin(35)		init ( 0),
  4   204        2 caller char(65) varying	init (""),
  4   205        2 data,
  4   206          3 data_ptr ptr		init (null),
  4   207          3 data_lth fixed bin(21)	init ( 0),
  4   208        2 class char(10) varying	init (""),
  4   209        2 ioa_msg char(500) varying	init ("");
  4   210 
  4   211 
  4   212 /* Syntax:  call Trace (ioa_ctl, args);				       */
  4   213 
  4   214 dcl  1 sl_info_msg			aligned int static options(constant),
  4   215        2 version char(8)		init ("sl_info1"),
  4   216        2 arg_list_ptr ptr		init (null),
  4   217        2 loc,
  4   218          3 (mode			init (-1),
  4   219 	  severity  		init (-1),
  4   220 	  code 			init ( 0),
  4   221 	  caller 			init (-1),
  4   222 	  data 			init ( 0),
  4   223 	  class 			init ( 0),
  4   224 	  ioa_msg			init ( 1)) fixed bin,
  4   225        2 flags,
  4   226          3 ioa_msg_is_error_code bit(1) unal init ("0"b),
  4   227          3 flags_pad bit(35) unal	init ("0"b),
  4   228        2 mode fixed bin		init ( 1),
  4   229        2 severity fixed bin		init ( 0),
  4   230        2 code fixed bin(35)		init ( 0),
  4   231        2 caller char(65) varying	init (""),
  4   232        2 data,
  4   233          3 data_ptr ptr		init (null),
  4   234          3 data_lth fixed bin(21)	init ( 0),
  4   235        2 class char(10) varying	init (""),
  4   236        2 ioa_msg char(500) varying	init ("");
  4   237 
  4   238 /* END INCLUDE FILE sys_log_constants.incl.pl1 */
      869 
      870  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  5     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  5     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  5     8*     attribute switches.
  5     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  5    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  5    12*         be deleted.
  5    13*      B) Add constants identifying attributes that can be changed by user at
  5    14*         login, etc.
  5    15*                                                   END HISTORY COMMENTS */
  5    16 
  5    17 
  5    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  5    19 
  5    20 /* format: style4 */
  5    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  5    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  5    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  5    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  5    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  5    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  5    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  5    28*						   .  of same project (distinct from "nobump") */
  5    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  5    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  5    31        2 multip bit (1),				/* 9  user may have several processes */
  5    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  5    33        2 brief bit (1),				/* 11 no login or logout message */
  5    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  5    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  5    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  5    37        2 sb_ok bit (1),				/* 15 user may be standby */
  5    38        2 pm_ok bit (1),				/* 16 user may be primary */
  5    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  5    40        2 daemon bit (1),				/* 18 user may login as daemon */
  5    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  5    42        2 no_warning bit (1),				/* 20 no warning message */
  5    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  5    44*						   .  in PDT: this user has an individual load control group */
  5    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  5    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  5    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  5    48        2 pad bit (12)) unaligned;
  5    49 
  5    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  5    51     ("none",					/* 0 */
  5    52      "administrator",				/* 1 */
  5    53      "primary_line",				/* 2 */
  5    54      "nobump",					/* 3 */
  5    55      "guaranteed_login",				/* 4 */
  5    56      "anonymous",					/* 5 */
  5    57      "nopreempt",					/* 6 */
  5    58      "nolist",					/* 7 */
  5    59      "dialok",					/* 8 */
  5    60      "multip",					/* 9 */
  5    61      "bumping",					/* 10 */
  5    62      "brief",					/* 11 */
  5    63      "vinitproc",					/* 12 */
  5    64      "vhomedir",					/* 13 */
  5    65      "nostartup",					/* 14 */
  5    66      "no_secondary",				/* 15 */
  5    67      "no_prime",					/* 16 */
  5    68      "no_eo",					/* 17 */
  5    69      "daemon",					/* 18 */
  5    70      "",						/* 19 vdim OBSOLETE */
  5    71      "no_warning",					/* 20 */
  5    72      "igroup",					/* 21 */
  5    73      "save_pdir",					/* 22 */
  5    74      "disconnect_ok",				/* 23 */
  5    75      "save_on_disconnect");				/* 24 */
  5    76 
  5    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  5    78     ("null",					/* 0 */
  5    79      "admin",					/* 1 */
  5    80      "", "",					/* 2 - 3 */
  5    81      "guar",					/* 4 */
  5    82      "anon",					/* 5 */
  5    83      "", "",					/* 6 - 7 */
  5    84      "dial",					/* 8 */
  5    85      "multi_login",					/* 9 */
  5    86      "preempting",					/* 10 */
  5    87      "",						/* 11 */
  5    88      "v_process_overseer",				/* 12 */
  5    89      "v_home_dir",					/* 13 */
  5    90      "no_start_up",					/* 14 */
  5    91      "no_sec",					/* 15 */
  5    92      "no_primary",					/* 16 */
  5    93      "no_edit_only",				/* 17 */
  5    94      "op_login",					/* 18 */
  5    95      "",						/* 19 */
  5    96      "nowarn",					/* 20 */
  5    97      "", "", "",					/* 21 - 23 */
  5    98      "save");					/* 24 */
  5    99 
  5   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  5   101      options(constant) init("000000000010000000010000000000000000"b);
  5   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  5   103 
  5   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  5   105      options(constant) init("000000000010000000010000000000000000"b);
  5   106     /* PDT value for (brief, no_warning) is default */
  5   107 
  5   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  5   109      options(constant) init("000100000110010000010000000000000000"b);	
  5   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  5   111 
  6     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  6     2 
  6     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 /*							       */
  6     5 /* This include file describes the attributes of an absentee job.  It is     */
  6     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  6     7 /* and PIT.incl.pl1.   */
  6     8 /*							       */
  6     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    10 
  6    11 /****^  HISTORY COMMENTS:
  6    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  6    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  6    14*     Separated abs_attributes from the request structure
  6    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  6    16*     used in the ute structure (user_table_entry.incl.pl1).
  6    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  6    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  6    19*     Added ABS_ATTRIBUTE_NAMES array.
  6    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  6    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  6    22*     Added the no_start_up flag. SCP6367
  6    23*                                                   END HISTORY COMMENTS */
  6    24 
  6    25 dcl 1 user_abs_attributes		aligned based,
  6    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  6    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  6    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  6    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  6    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  6    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  6    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  6    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  6    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  6    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  6    36       2 attributes_pad		bit (26) unaligned;
  6    37 
  6    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  6    39 	"restartable",
  6    40 	"user_deferred_until_time",
  6    41 	"proxy",
  6    42 	"set_bit_cnt",
  6    43 	"time_in_gmt",
  6    44 	"user_deferred_indefinitely",
  6    45 	"secondary_ok",
  6    46 	"truncate_absout",
  6    47 	"restarted",
  6    48 	"no_start_up");
  6    49 
  6    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  6    51 
  5   112 
  5   113 
  5   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      870 
      871  /*  BEGIN INCLUDE FILE ... user_table_entry.incl.pl1 */
  7     2 
  7     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 /*							       */
  7     5 /* This include file requires that the user include		       */
  7     6 /* user_attributes.incl.pl1 as well.  It also includes		       */
  7     7 /* abs_attributes.incl.pl1 itself.				       */
  7     8 /*							       */
  7     9 /* This include file must be included to use absentee_user_table.incl.pl1,   */
  7    10 /* answer_table.incl.pl1, and daemon_user_table.incl.pl1.		       */
  7    11 /*							       */
  7    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    13 
  7    14 /****^  HISTORY COMMENTS:
  7    15*  1) change(81-12-21,Gilcrease), approve(86-03-27,MCR7370),
  7    16*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
  7    17*     This comment for hcom.
  7    18*     81-12-21  E. N. Kittlitz. derived from abs_user_tab.incl.pl1,
  7    19*     anstbl.incl.pl1, and dutbl.incl.pl1.
  7    20*     82-01-02 E. N. Kittlitz. user_attributes.incl.pl1 changes
  7    21*     84-04-04 BIM added privileged_dial_server and dial_server_ring
  7    22*     84-07-12 BIM added min_process_authorization
  7    23*     84-12-31 Keith Loepere added pdir_dir_quota
  7    24*     85-01-16 by E. Swenson to add ute.session_uid
  7    25*  2) change(85-11-16,Swenson), approve(87-07-13,MCR7737),
  7    26*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
  7    27*     Added fields for DSA login server support.
  7    28*  3) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
  7    29*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
  7    30*     Add truncate_absout and restarted bit for -truncate absout, SCP6297.
  7    31*  4) change(86-04-09,Herbst), approve(87-07-13,MCR7697),
  7    32*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
  7    33*     Added disconnection_rel_minutes.
  7    34*  5) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  7    35*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    36*     Changed structure under ute.abs_attributes to use like structure in
  7    37*     abs_attributes.incl.pl1.  This allows the same attributes to be used
  7    38*     in abs_message_format.incl.pl1 and pit.incl.pl1 as well as this include
  7    39*     file.
  7    40*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
  7    41*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    42*     Move constants for ute.pw_flags.mask_ctl from answer_table.incl.pl1.
  7    43*  7) change(87-04-16,GDixon), approve(87-07-13,MCR7741),
  7    44*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    45*      A) Global reorganization to locate things by type of data.
  7    46*      B) Eliminate ute.uflags.logged_in.
  7    47*  8) change(87-05-10,GDixon), approve(87-07-13,MCR7741),
  7    48*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    49*      A) Reduced overlength person and project fields to proper length.
  7    50*      B) Adjusted dialed-console section to begin on even word boundary.
  7    51*  9) change(87-05-13,GDixon), approve(87-07-13,MCR7741),
  7    52*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    53*     Add ute.line_type.
  7    54* 10) change(87-11-19,Parisek), approve(88-02-11,MCR7849),
  7    55*     audit(88-02-23,Lippard), install(88-07-13,MR12.2-1047):
  7    56*     Added the lowest_ring element. Used the upper half of ute.highest_ring
  7    57*     for the storage.  SCP6367
  7    58*                                                   END HISTORY COMMENTS */
  7    59 
  7    60 /* format: style4 */
  7    61 
  7    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    63 /*							       */
  7    64 /* Each of the named sections below defines a type of data.  Typing comes    */
  7    65 /* from data associated with the ute entry itself, with the person, with     */
  7    66 /* login argument data, from the main user of the data (eg, dialup_,	       */
  7    67 /* load_ctl_, login server).  Each section begins on a double-word boundary  */
  7    68 /* and is an even number of words long.  The total structure is 300 decimal  */
  7    69 /* words long.						       */
  7    70 /*							       */
  7    71 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    72 
  7    73 
  7    74 dcl  UTE_version_4 fixed bin internal static options (constant) init (4);
  7    75 
  7    76 dcl  utep pointer automatic init (null);
  7    77 
  7    78 dcl  1 ute based (utep) aligned,			/* individual entry in one of the user control tables */
  7    79 
  7    80 /* Variables which give state of this entry */
  7    81        2 active fixed bin,				/* state of entry. 0=>free. see dialup_values.incl.pl1 */
  7    82        2 process_type fixed bin,			/* 1=interactive, 2=absentee, 3=daemon */
  7    83        2 ute_index fixed bin,				/* index of ute in (anstbl autbl dutbl).entry array */
  7    84        2 next_free fixed bin,				/* points to previous free entry */
  7    85 
  7    86 /* Information user gave about person_id associated with this entry. */
  7    87        2 person char (24) unal,			/* user's name */
  7    88        2 project char (12) unal,			/* project of absentee user */
  7    89        2 tag char (1) unal,				/* instance tag - someday will be generated */
  7    90        2 tag_pad bit (27) unal,
  7    91        2 anonymous fixed bin,				/* 1 if anonymous, otherwise 0 */
  7    92        2 login_flags,				/* flags for login data */
  7    93          3 cpw bit (1) unal,				/* flag for wish to change password */
  7    94          3 generate_pw bit (1) unal,			/* flag meaning -generate_pw (-gpw) was used. */
  7    95          3 special_pw unal,				/* dial or slave */
  7    96 	 4 dial_pw bit (1) unal,			/* true if dial -user */
  7    97 	 4 slave_pw bit (1) unal,			/* true if slave -user */
  7    98          3 cdp bit (1) unal,				/* flag for wish to change default project */
  7    99          3 cda bit (1) unal,				/* flag to change default authorization */
  7   100          3 auth_given bit (1) unal,			/* flag to mean -authorization was used. */
  7   101          3 noprint bit (1) unal,			/* used at logout. inhibits printing. */
  7   102          3 operator bit (1) unaligned,			/* user specified -operator on login command line */
  7   103          3 pw_pad bit (25) unal,			/* spare parts */
  7   104          3 mask_ctl bit (2) unal,			/* bits controlling pw mask. See constants, below */
  7   105 						/* Must remain last in pw_flags so it does not */
  7   106 						/* appear in PW_FLAG_VALUES array below. */
  7   107        2 generated_pw char (8) unal,			/* user must type this as new password */
  7   108        2 old_password char (8) unal,			/* must match user's previous password (value scrambled) */
  7   109        2 process_authorization bit (72),		/* access_authorization of this process */
  7   110 
  7   111 /* Information user gave about process associated with this entry. */
  7   112        2 outer_module char (32) unal,			/* Name of console dim */
  7   113        2 home_dir char (64) unal,			/* initial home directory */
  7   114        2 init_proc char (64) unal,			/* name of login responder */
  7   115        2 ip_len fixed bin (17) unal,			/* length of initproc string */
  7   116        2 ss_len fixed bin (17) unal,			/* length of subsystem string */
  7   117        2 ur_at like user_attributes aligned,		/* bits on means attributes given by user */
  7   118        2 at like user_attributes aligned,		/* bits on means attribute is on */
  7   119        2 initial_ring fixed bin,			/* ring process will be started in */
  7   120        2 arg_count fixed bin,				/* number of arguments to absentee control segment */
  7   121        2 ln_args fixed bin,				/* length of string containing arguments */
  7   122        2 arg_lengths_ptr ptr,				/* pointer to array of argument lengths */
  7   123        2 args_ptr ptr,				/* pointer to arguments to absentee control segment */
  7   124 
  7   125 /* Most of the following information is relevant only to absentee processes */
  7   126        2 input_seg char (168) unal,			/* pathname of absentee control segment */
  7   127        2 output_seg char (168) unal,			/* pathname of absentee output file */
  7   128        2 request_id fixed bin (71),			/* time request was entered - used as uid of request */
  7   129        2 reservation_id fixed bin (71),			/* nonzero if job has a resource reservation */
  7   130        2 message_id bit (72),				/* message segment id assoc with absentee request */
  7   131        2 deferred_time fixed bin (71),			/* time at which absentee process should be created */
  7   132        2 max_cpu_time fixed bin (35),			/* maximum number of seconds this process can run */
  7   133        2 queue fixed bin,				/* -1=daemon;0=interactive or foreground;>0=queue no.
  7   134*						   (but see uflags.adjust_abs_q_no). */
  7   135        2 real_queue fixed bin,			/* real queue number; ute.queue gets fudged sometimes */
  7   136        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
  7   137        2 abs_flags,
  7   138          3 abs_run bit (1) unal,			/* on if job was started by abs run command */
  7   139          3 notify bit (1) unal,			/* on if user wants notification at login and logout */
  7   140          3 abs_flags_pad bit (34) unal,
  7   141        2 abs_group char (8) unal,			/* original group before load_ctl_ moves it to absentee group */
  7   142        2 sender char (32) unal,			/* name of RJE station that job is from */
  7   143        2 proxy_person char (28) unal,			/* name of user who actually entered the request, if proxy */
  7   144        2 proxy_project char (9) unal,
  7   145        2 proxy_project_pad char (3) unal,
  7   146        2 abs_pad fixed bin,
  7   147 
  7   148 /* Information about process actually created */
  7   149        2 proc_id bit (36),				/* process id of absentee process */
  7   150        2 session_uid fixed bin (35),			/* Unique authentication session id */
  7   151        2 process_authorization_range (2) bit (72) aligned,
  7   152        2 audit bit (36),				/* audit flags for user */
  7   153        2 lot_size fixed bin,				/* Size of linkage offset table */
  7   154        2 kst_size fixed bin,				/* Size of process known segment table */
  7   155        2 cls_size fixed bin,				/* Size of process combined linkage */
  7   156        2 sus_channel fixed bin (71),			/* event channel on which suspended process is blocked */
  7   157        2 lowest_ring fixed bin (17) unal,		/* lowest ring permitted */
  7   158        2 highest_ring fixed bin (17) unal,		/* highest ring permitted */
  7   159        2 pdir_lvix fixed bin (17) unal,			/* index in disk table of lv where pdir is */
  7   160        2 pdir_quota fixed bin (17) unal,		/* process directory quota */
  7   161        2 pdir_dir_quota fixed bin (17) unal,		/* process directory quota for dirs */
  7   162        2 pdir_pad fixed bin(17) unal,
  7   163        2 process_pad fixed bin,
  7   164 
  7   165 /* Information about primary terminal associated with this entry */
  7   166        2 tty_name char (32) unal,			/* absentee=>"abs1", etc.  daemon=>"bk", etc. */
  7   167        2 terminal_type char (32) unaligned,		/* terminal type */
  7   168        2 line_type fixed bin,				/* line type */
  7   169        2 tty_id_code char (4) unal,			/* "none" for absentee */
  7   170        2 network_connection_type fixed bin,		/* see net_event_message.incl.pl1 */
  7   171        2 channel ptr unal,				/* points to CDT entry for user, if any */
  7   172 
  7   173 /* Variables useful for dialed terminals */
  7   174        2 ndialed_consoles fixed bin,			/* if master, number of slaves */
  7   175        2 dial_qualifier char (22) unal,			/* first argument to dial command */
  7   176        2 dial_server_ring fixed bin (3) unsigned unaligned, /* dial server intends to attach dialing in channels at this ring. */
  7   177        2 dial_server_flags,
  7   178          3 registered_dial_server bit (1) unal,		/* process is a registered dial server */
  7   179          3 privileged_dial_server bit (1) unal,		/* "1"b -> serves range of AIM classes */
  7   180          3 dial_server_flags_pad bit (13) unal,		/* fill out the word */
  7   181        2 dial_ev_chn fixed bin (71),			/* if master, control event channel */
  7   182 
  7   183 /* Information about usage/accounting.  Device usage meters are in a
  7   184*   separate segment, "devtab" */
  7   185        2 pdtep ptr,					/* ptr to user's pdt entry, where usage meters live */
  7   186        2 cpu_this_process fixed bin (71),		/* cpu used so far this process */
  7   187        2 cpu_usage fixed bin (71),			/* total cpu time used in this session */
  7   188        2 mem_usage fixed bin (71),			/* memory usage for previous processes in session */
  7   189        2 mem_this_process fixed bin (71),		/* memory usage at last update */
  7   190        2 last_update_time fixed bin (71),		/* time of last account update */
  7   191        2 session_cost float bin,			/* dollar cost of session, for printing in logout messages */
  7   192        2 ndevices fixed bin,				/* Count of attached devices */
  7   193        2 device_head fixed bin,			/* Table index of head of device chain */
  7   194        2 device_tail fixed bin,			/* Table index of tail of device chain */
  7   195        2 rs_number fixed bin (6) unsigned unal,		/* rate structure number */
  7   196        2 rs_number_pad bit(30) unal,
  7   197        2 usage_pad fixed bin,
  7   198 
  7   199 /* Information for dialup_ (control variables). */
  7   200        2 event fixed bin (71),			/* event associated with channel or user manager */
  7   201        2 uprojp ptr,				/* ptr to user project sat entry */
  7   202        2 login_time fixed bin (71),			/* time when absentee user approved by lg_ctl_ */
  7   203        2 cant_bump_until fixed bin (71),		/* bump-protection clock */
  7   204        2 recent_fatal_error_time fixed bin (71),		/* time of first error in the suspected loop */
  7   205        2 recent_fatal_error_count fixed bin,		/* counter to detect fatal process error loops */
  7   206        2 failure_reason fixed bin,			/* why login refused 1=lg_ctl, 2=act_ctl, 3=load_ctl */
  7   207        2 count fixed bin,				/* counter for logins and dialups */
  7   208        2 n_processes fixed bin,			/* number of processes created in this session */
  7   209        2 lock_value fixed bin,			/* number of locks set for this entry */
  7   210        2 login_result fixed bin,			/* 0=logged in;1=hopeless,hang him up;2=allow another attempt */
  7   211        2 login_code char (8) unal,			/* login command from LOGIN line */
  7   212        2 preempted fixed bin,				/* if ^= 0 user preempted (never for abs) */
  7   213        2 destroy_flag fixed bin,			/* >8 when awaiting destroy */
  7   214        2 logout_type char (4) unal,			/* type of logout */
  7   215        2 logout_index fixed bin,			/* to save logout handler index while waiting for termsgnl */
  7   216        2 disconnection_rel_minutes fixed bin (17) unal,	/* disconnected this many minutes after login_time */
  7   217        2 next_disconnected_ate_index fixed bin (17) unal,	/* thread of list of user's disconnected processes */
  7   218        2 work_class fixed bin,			/* work class used by priority scheduler */
  7   219        2 group char (8) unal,				/* party group identifier */
  7   220        2 whotabx fixed bin,				/* index of user's entry in whotab */
  7   221 
  7   222        2 uflags,					/* Miscellaneous flags */
  7   223          3 dont_call_init_admin bit (1) unal,		/* Call overseer directly */
  7   224          3 ip_given bit (1) unal,			/* user gave an initproc arg on login line */
  7   225          3 ss_given bit (1) unal,			/* initial_procedure contains a subsystem name */
  7   226          3 lvs_attached bit (1) unal,			/* set and used by the lv_request_ procedure */
  7   227          3 send_initial_string bit (1) unal,		/* initial string should be sent after login line read */
  7   228          3 adjust_abs_q_no bit (1) unal,		/* this is an absentee job; user_profile.queue is NOT true Q # */
  7   229          3 foreground_secondary_ok bit (1) unal,		/* ok to login foreground absentee job as secondary */
  7   230          3 foreground_job bit (1) unal,			/* job was originally from foreground queue */
  7   231          3 sus_sent bit (1) unal,			/* sus_ ips signal has been sent to process */
  7   232          3 suspended bit (1) unal,			/* process has responded to sus_ signal */
  7   233          3 ignore_cpulimit bit (1) unal,		/* process is released, but timer can't be turned off */
  7   234          3 deferral_logged bit (1) unal,		/* abs job deferral has already been logged once */
  7   235          3 save_if_disconnected bit (1) unal,		/* user wants process preserved across hangups */
  7   236          3 disconnected bit (1) unal,			/* process is disconnected from terminal */
  7   237          3 disconnected_list bit (1) unal,		/* this ate is on a list of disconnected processes */
  7   238          3 proc_create_ok bit (1) unal,			/* lg_ctl_ has set the process creation variables */
  7   239          3 activity_can_unbump bit (1) unal,		/* only bump pending is for inactivity */
  7   240          3 fpe_causes_logout bit (1) unal,		/* "1"b means don't try to new_proc after fatal process error */
  7   241          3 user_specified_immediate bit (1) unal,		/* "1"b -> don't wait around for process destruction. */
  7   242          3 uflags_pad bit (17) unal,
  7   243 
  7   244 /* Information used by load_ctl_ for the process */
  7   245        2 user_weight fixed bin,			/* usually 10 - used in load control */
  7   246        2 standby_line fixed bin,			/* 0=user has primary line, 1=standby user */
  7   247        2 bump_grace fixed bin (71),			/* bump grace in microseconds */
  7   248 
  7   249 
  7   250 /* Information for login server */
  7   251        2 login_server_info,
  7   252          3 our_handle bit (72) aligned,			/* how LS refers to us. */
  7   253          3 his_handle bit (72) aligned,			/* how we talk to LS */
  7   254          3 termination_event_channel fixed bin (71),	/* for process termination notifications to the LS */
  7   255          3 response_event_channel fixed bin (71),		/* for other communications with the LS */
  7   256          3 process_id bit (36) aligned,			/* process_id of login server */
  7   257        2 ls_pad (5) fixed bin;			/* pad to 300 decimal words */
  7   258 
  7   259 /* values for ute.process_type */
  7   260 
  7   261 dcl  (PT_INTERACTIVE initial (1),
  7   262      PT_ABSENTEE initial (2),
  7   263      PT_DAEMON initial (3)) fixed bin internal static options (constant);
  7   264 
  7   265 dcl  PROCESS_TYPE_NAMES (0:3) char(12) varying int static options(constant) init(
  7   266 	"INVALID-TYPE",
  7   267 	"interactive",
  7   268 	"absentee",
  7   269 	"daemon");
  7   270 
  7   271 dcl  TABLE_NAMES (0:3) char(20) int static options(constant) init(
  7   272 	"UNKNOWN-TABLE",
  7   273 	"answer_table",
  7   274 	"absentee_user_table",
  7   275 	"daemon_user_table");
  7   276 
  7   277 
  7   278 /* values for ute.pw_flags.mask_ctl  */
  7   279 
  7   280 dcl  (DO_MASK init ("00"b),
  7   281      DONT_MASK init ("01"b),
  7   282      DERIVE_MASK init ("10"b)) bit (2) internal static options (constant);
  7   283 
  7   284 dcl  MASK_CTL_NAMES (0:3) char(12) varying int static options(constant) init(
  7   285 	"do_mask", "dont_mask", "derive_mask", "");
  7   286 
  7   287 
  7   288 /* names for ute.pw_flags */
  7   289 
  7   290 dcl  PW_FLAG_NAMES (9) char (12) varying int static options(constant) init(
  7   291 	"cpw",
  7   292 	"generate_pw",
  7   293 	"dial_pw",
  7   294 	"slave_pw",
  7   295 	"cdp",
  7   296 	"cda",
  7   297 	"auth_given",
  7   298 	"noprint",
  7   299 	"operator");
  7   300 
  7   301 /* names for ute.uflags */
  7   302 
  7   303 dcl  UFLAG_NAMES (19) char (24) varying int static options (constant) init (
  7   304 	"dont_call_init_admin",
  7   305 	"ip_given",
  7   306 	"ss_given",
  7   307 	"lvs_attached",
  7   308 	"send_initial_string",
  7   309 	"adjust_abs_q_no",
  7   310 	"foreground_secondary_ok",
  7   311 	"foreground_job",
  7   312 	"sus_sent",
  7   313 	"suspended",
  7   314 	"ignore_cpulimit",
  7   315 	"deferral_logged",
  7   316 	"save_if_disconnected",
  7   317 	"disconnected",
  7   318 	"disconnected_list",
  7   319 	"proc_create_ok",
  7   320 	"activity_can_unbump",
  7   321 	"fpe_causes_logout",
  7   322 	"user_specified_immediate");
  7   323 
  7   324 /* names for ute.abs_flags */
  7   325 
  7   326 dcl  ABS_FLAG_NAMES (2) char (8) varying int static options (constant) init (
  7   327 	"abs_run",
  7   328 	"notify");
  7   329 
  7   330 /* names of ute.dial_server_flags */
  7   331 
  7   332 dcl  DIAL_SERVER_FLAG_NAMES (2) char (12) varying int static options (constant) init (
  7   333 	"registered",
  7   334 	"privileged");
  7   335 
  7   336 /* values of ute.login_result */
  7   337 
  7   338 dcl  LOGIN_RESULT_VALUES (0:2) char(24) varying int static options(constant) init(
  7   339 	"logged in",
  7   340 	"login failed, hangup",
  7   341 	"login failed, try again");
  7   342 
  7   343 /*  END INCLUDE FILE ... user_table_entry.incl.pl1 */
      871 
      872 
      873      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/16/90  1223.2  lv_request_.pl1                   >spec>install>1024>lv_request_.pl1
866          1    08/06/87  1013.4  devid.incl.pl1                    >ldd>include>devid.incl.pl1
867          2    07/24/86  2151.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
868          3    02/09/82  1252.3  lv_atttbl.incl.pl1                >ldd>include>lv_atttbl.incl.pl1
869          4    08/06/87  1013.5  sys_log_constants.incl.pl1        >ldd>include>sys_log_constants.incl.pl1
870          5    08/06/87  1013.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
5-112        6    07/14/88  2115.0  user_abs_attributes.incl.pl1      >ldd>include>user_abs_attributes.incl.pl1
871          7    07/14/88  2115.0  user_table_entry.incl.pl1         >ldd>include>user_table_entry.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALARM___                        000020 constant        char(8)                  initial packed unaligned dcl 95 ref 392
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 96 ref 247
LV_RING                         000010 internal static fixed bin(17,0)          initial dcl 97 set ref 380 689*
SL0                             000011 internal static fixed bin(17,0)          initial dcl 98 set ref 173* 213* 382* 494* 530* 568*
                                                                                  577* 691*
SL_LOG                                 constant        fixed bin(17,0)          initial dcl 4-14 ref 173 691
SL_LOG_BEEP                     000102 constant        fixed bin(17,0)          initial dcl 4-14 set ref 182* 403* 412* 457* 559*
                                                                                  639*
TRUE                                   constant        bit(1)                   initial packed unaligned dcl 99 ref 255
a_dtp                                  parameter       pointer                  dcl 122 ref 349 354
a_lvax                                 parameter       fixed bin(17,0)          dcl 588 set ref 586 591*
a_lvname                               parameter       char                     packed unaligned dcl 123 ref 201 204 353
a_lvx                                  parameter       fixed bin(17,0)          dcl 121 ref 349 352
a_pid                                  parameter       bit(36)                  dcl 120 set ref 330 333* 334
addr                                                   builtin function         dcl 127 ref 189 189 355 438 471 477 509 517 524 536
                                                                                  590 667
addrel                                                 builtin function         dcl 127 ref 606
anon                            001316 automatic       fixed bin(17,0)          dcl 600 set ref 605* 615* 619
anonymous                16            based           fixed bin(17,0)          level 2 dcl 7-78 ref 615
ape                             001304 automatic       char(24)                 packed unaligned dcl 597 set ref 605* 612* 619*
aprj                            001312 automatic       char(12)                 packed unaligned dcl 598 set ref 605* 613* 619*
arg                                    based           char                     packed unaligned dcl 107 ref 255 255 258
argl                            000100 automatic       fixed bin(21,0)          dcl 53 set ref 250* 255 255 258
argp                            000102 automatic       pointer                  dcl 54 set ref 250* 255 255 258
argx                            000104 automatic       fixed bin(17,0)          dcl 55 set ref 249* 250* 252* 262*
array                           000105 automatic       fixed bin(17,0)          array dcl 56 in procedure "lv_request_" set ref 205*
                                                                                  208 297* 312 335* 339 358* 360 426* 474* 512* 517
                                                                                  524 657* 660* 674*
array                    10            based           structure                array level 2 in structure "dt" dcl 2-23
                                                                                  in procedure "lv_request_" set ref 477 667
as_$dump                        000110 constant        entry                    external dcl 158 ref 641
as_$find_process                000016 constant        entry                    external dcl 131 ref 610
beef                                   parameter       char                     packed unaligned dcl 557 set ref 555 559*
bits                      2            based           bit(72)                  level 2 dcl 109 set ref 382* 390 392 403*
cname                                  parameter       char                     packed unaligned dcl 630 set ref 628 632 632 632 632
                                                                                  632 639*
com_err_                        000020 constant        entry                    external dcl 132 ref 239 243 252
command_error                   001176 stack reference condition                dcl 167 ref 462
condition_                      000022 constant        entry                    external dcl 133 ref 378
cont                                   parameter       bit(1)                   packed unaligned dcl 630 set ref 628 635*
cop                                    parameter       pointer                  dcl 630 ref 628
cu_$arg_count                   000024 constant        entry                    external dcl 134 ref 237
cu_$arg_ptr                     000026 constant        entry                    external dcl 135 ref 250
d_lvname                        000415 automatic       char(32)                 packed unaligned dcl 57 set ref 473* 474*
demounting                      000425 automatic       bit(1)                   packed unaligned dcl 58 in procedure "lv_request_"
                                                                                  set ref 409* 412* 423
demounting                1(04)        based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 2-58 in procedure "lv_request_" ref 525
detach_requested         16(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-19 ref 316
dev_id                          000000 constant        char(8)                  initial array dcl 1-48 ref 190
dev_lv                                 constant        fixed bin(17,0)          initial dcl 1-56 ref 190
device_acct_$off                000032 constant        entry                    external dcl 136 ref 581
device_acct_$on                 000030 constant        entry                    external dcl 136 ref 571
device_id                       000710 automatic       char(8)                  array level 2 dcl 82 set ref 190
devtab_copy                     000710 automatic       structure                array level 1 dcl 82 set ref 189 189
devtab_ix_lv                    000015 internal static fixed bin(17,0)          initial dcl 1-65 set ref 190* 190* 193 193* 571*
                                                                                  581*
disk_table_$dhv                 000034 constant        entry                    external dcl 137 ref 518
disk_table_$dry_run_mhv         000036 constant        entry                    external dcl 138 ref 466 485
disk_table_$get_dtp             000040 constant        entry                    external dcl 139 ref 268 435 655
disk_table_$mhv                 000042 constant        entry                    external dcl 140 ref 533
drive_name                             based           char(8)                  level 2 dcl 2-35 ref 668
dt                                     based           structure                level 1 dcl 2-23
dte                                    based           structure                level 1 dcl 2-35
dtep                            001206 automatic       pointer                  dcl 2-17 set ref 477* 478 480 481 667* 668 668 668
                                                                                  668
dtp                             001204 automatic       pointer                  dcl 2-17 set ref 268* 271 273 274 281 281 284 354*
                                                                                  355 435* 437 438 470 471 476 477 508 509 517 524
                                                                                  535 536 655* 661 661 661 664 666 667
dtx                             000426 automatic       fixed bin(17,0)          dcl 59 set ref 666* 667*
ec                              000427 automatic       fixed bin(35,0)          dcl 60 set ref 177* 178* 180 180* 181 182* 216* 217
                                                                                  237* 238 239* 250* 251 252* 364* 365 441* 442 455*
                                                                                  456 457* 497* 498 540* 543 559* 605* 606 642* 643
                                                                                  644*
error_table_$noarg              000044 external static fixed bin(35,0)          dcl 141 set ref 243*
error_table_$resource_unavailable
                                000046 external static fixed bin(35,0)          dcl 142 set ref 216* 497*
ev_calls_masked                 000431 automatic       bit(1)                   dcl 61 set ref 374* 454* 499
evchn                                  based           fixed bin(71,0)          level 2 dcl 109 set ref 680*
evmessage                              based           structure                level 1 dcl 109
flags                    16            based           structure                level 2 dcl 3-19
get_process_id_                 000050 constant        entry                    external dcl 143 ref 187
get_ring_                       000052 constant        entry                    external dcl 144 ref 689
get_userid_$info                000054 constant        entry                    external dcl 145 ref 605
good_candidate            1(05)        based           bit(1)                   level 2 packed packed unaligned dcl 2-58 set ref
                                                                                  479* 484 510
hbound                                                 builtin function         dcl 127 ref 258 263
hv_mounted                1(01)        based           bit(1)                   level 2 packed packed unaligned dcl 2-58 ref 439 472
                                                                                  538
i                               000432 automatic       fixed bin(17,0)          dcl 62 set ref 206* 208* 311* 312* 337* 339* 359*
                                                                                  360* 516* 517* 523* 524* 658* 660 674*
initialized                     000012 internal static bit(1)                   initial packed unaligned dcl 100 set ref 196* 203
                                                                                  230 332 351 632
initializer_mdc_$check_mount    000056 constant        entry                    external dcl 146 ref 674
initializer_mdc_$free_lvate     000060 constant        entry                    external dcl 147 ref 343 425
initializer_mdc_$init_lvat      000062 constant        entry                    external dcl 148 ref 180
initializer_mdc_$invalidate_lvate
                                000064 constant        entry                    external dcl 149 ref 221
initializer_mdc_$lvat_scan_lv   000066 constant        entry                    external dcl 150 ref 205 297 358 474
initializer_mdc_$mhvmessage     000070 constant        entry                    external dcl 151 ref 541
initializer_mdc_$poll_mounts    000072 constant        entry                    external dcl 152 ref 657
initializer_mdc_$respond_mount_lv
                                000074 constant        entry                    external dcl 153 ref 216 364 441 497 540
initializer_mdc_$retrieve_lvate 000076 constant        entry                    external dcl 154 ref 591
initializer_mdc_$scan_process_lvat
                                000100 constant        entry                    external dcl 155 ref 335 426
initializer_mdc_$set_lvat_info  000102 constant        entry                    external dcl 156 ref 440
inp                                    parameter       pointer                  dcl 630 ref 628
invalidated              16(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-19 ref 318
ioa_                            000104 constant        entry                    external dcl 157 ref 231 261 286 289 300 305 307 321
ioa_$rsnnl                      000106 constant        entry                    external dcl 158 ref 619
ipc_$create_ev_chn              000112 constant        entry                    external dcl 159 ref 177
ipc_$decl_ev_call_chn           000114 constant        entry                    external dcl 160 ref 178
ipc_$mask_ev_calls              000116 constant        entry                    external dcl 161 ref 455
ipc_$unmask_ev_calls            000120 constant        entry                    external dcl 161 ref 499 644
list_all_vols                   000434 automatic       bit(1)                   dcl 63 set ref 247* 255* 271 289 300
local_lvate                     001150 automatic       structure                level 1 dcl 86 set ref 590
lv_array                               based           structure                array level 2 dcl 2-23 set ref 355 438 471 509 517
                                                                                  524 536
lvate                                  based           structure                level 1 dcl 3-19
lvatep                          001212 automatic       pointer                  dcl 3-17 set ref 210 212 219 314 315 316 317 317 318
                                                                                  341 342 362 363 418 420 424 590* 591* 661 673
lvax                            000435 automatic       fixed bin(17,0)          dcl 64 in procedure "lv_request_" set ref 208* 209*
                                                                                  216* 221* 312* 313* 339* 340* 343* 360* 361* 364*
                                                                                  408* 410* 412* 425* 440* 441* 497* 540* 541*
lvax                      1     001174 automatic       fixed bin(17,0)          level 2 in structure "mount_transmission" packed
                                                                                  packed unaligned dcl 88 in procedure "lv_request_"
                                                                                  set ref 408
lve                                    based           structure                level 1 dcl 2-58
lvep                            001210 automatic       pointer                  dcl 2-17 set ref 355* 356 438* 439 439 440 471* 472
                                                                                  472 472 473 479 484 509* 510 517* 518 524* 525
                                                                                  536* 537 538 539
lvid                                   based           bit(36)                  level 2 dcl 2-58 set ref 440*
lvname                          000436 automatic       char(32)                 packed unaligned dcl 65 in procedure "lv_request_"
                                                                                  set ref 204* 205* 213* 274* 280* 281 286* 297*
                                                                                  300* 305* 341* 353* 356* 358* 420* 439 466* 485*
                                                                                  494* 530* 533* 537 568* 571* 577* 581*
lvname                                 based           char(32)                 array level 3 in structure "dt" dcl 2-23
                                                                                  in procedure "lv_request_" set ref 274 281 661
lvname                    3            based           char(32)                 level 2 in structure "lvate" dcl 3-19 in procedure
                                                                                  "lv_request_" ref 341 420 661
lvname                    2            based           char(32)                 level 2 in structure "lve" dcl 2-58 in procedure
                                                                                  "lv_request_" ref 356 439 473 518 537
lvs_attached            431(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-78 set ref
                                                                                  428* 444* 545*
lvx                       2(23)        based           fixed bin(11,0)          level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 2-35 in procedure "lv_request_" ref 478 668
lvx                             000446 automatic       fixed bin(17,0)          dcl 66 in procedure "lv_request_" set ref 271* 273
                                                                                  274* 281* 281* 284 352* 355 437* 438 440* 470* 471
                                                                                  478* 508* 509 512* 535* 536* 661* 661 661* 664 668
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 2-23 ref 273 274 281 355 438 471 509 517
                                                                                  524 536 661 661
mcp                                    parameter       pointer                  dcl 630 ref 628
mount_transmission              001174 automatic       structure                level 1 dcl 88 set ref 390*
mounted                  16(03)        based           bit(1)                   level 3 packed packed unaligned dcl 3-19 ref 219 315
                                                                                  342 424
mounting                  1(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-58 ref 472 539
msgp                                   parameter       pointer                  dcl 119 ref 16 380 380 381 382 382 390 392 403 418
                                                                                  419 426 680
my_evchn                        000450 automatic       fixed bin(71,0)          dcl 67 set ref 177* 178* 180*
myprocessid                     000013 internal static bit(36)                  dcl 101 set ref 187* 380
n                               000433 automatic       fixed bin(17,0)          dcl 62 set ref 205* 206 297* 299 311 335* 337 358*
                                                                                  359 426* 427 474* 475 506* 511* 511 512 516 523
                                                                                  657* 658 658
n_devtab_entries                000452 automatic       fixed bin(17,0)          dcl 68 set ref 189* 190 193
n_entries                              based           fixed bin(17,0)          level 2 dcl 2-23 ref 476 666
n_lv_entries              5            based           fixed bin(17,0)          level 2 dcl 2-23 ref 271 281 284 437 470 508 535 661
                                                                                  664
n_vols_to_list                  000453 automatic       fixed bin(17,0)          dcl 69 set ref 248* 257* 257 258 258 261 263* 279
nargs                           000454 automatic       fixed bin(17,0)          dcl 70 set ref 237* 242 249 262
next_time                       000456 automatic       fixed bin(71,0)          dcl 71 set ref 657* 680 680*
null                                                   builtin function         dcl 127 ref 178 178 428 444 545 7-76 571 581 606 607
                                                                                  611 618
origin                    5            based           structure                level 2 dcl 109
other                     1(18) 001174 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 88 set ref 401
pending_mount            16            based           bit(1)                   level 3 packed packed unaligned dcl 3-19 ref 317 362
person                    4            based           char(24)                 level 2 packed packed unaligned dcl 7-78 ref 612
pid                             000460 automatic       bit(36)                  dcl 72 in procedure "lv_request_" set ref 334* 335*
pid                                    parameter       bit(36)                  dcl 602 in procedure "find_u" set ref 595 605* 610*
                                                                                  621
pid                                    based           bit(36)                  level 2 in structure "lvate" dcl 3-19 in procedure
                                                                                  "lv_request_" set ref 210* 314* 363* 418 673*
pre_accepted              2(35)        based           bit(1)                   level 2 packed packed unaligned dcl 2-35 set ref
                                                                                  481* 668
project                  12            based           char(12)                 level 2 packed packed unaligned dcl 7-78 ref 613
public                    1(02)        based           bit(1)                   level 2 packed packed unaligned dcl 2-58 ref 472
pvname                    6            based           char(32)                 level 2 dcl 2-35 ref 668
pvx                             000447 automatic       fixed bin(17,0)          dcl 66 set ref 476* 477*
req                             001174 automatic       char(4)                  level 2 packed packed unaligned dcl 88 set ref 392
                                                                                  401 401 409
result                          000461 automatic       fixed bin(17,0)          dcl 73 set ref 466* 468 485* 486
ring                      5(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 109 set ref 380
                                                                                  382*
rtrim                                                  builtin function         dcl 127 ref 668 668
sender                    4            based           bit(36)                  level 2 dcl 109 set ref 380 381* 418 419* 426*
shown_lvat_header               000462 automatic       bit(1)                   packed unaligned dcl 74 set ref 270* 289 306 308*
status                          000463 automatic       char(25)                 packed unaligned dcl 75 set ref 315* 316* 317* 318*
                                                                                  319* 321*
sys_log_                        000122 constant        entry                    external dcl 162 ref 213 382 403 412 494 530 568 577
                                                                                  639
sys_log_$error_log              000124 constant        entry                    external dcl 162 ref 182 457 559
system_info_$device_prices      000126 constant        entry                    external dcl 163 ref 189
tag                      15            based           char(1)                  level 2 in structure "ute" packed packed unaligned
                                                                                  dcl 7-78 in procedure "lv_request_" ref 614
tag                             001315 automatic       char(1)                  packed unaligned dcl 599 in procedure "find_u" set
                                                                                  ref 605* 614* 619*
testing                         000014 internal static bit(1)                   initial packed unaligned dcl 102 set ref 604 632
                                                                                  690*
timer_manager_$alarm_wakeup     000130 constant        entry                    external dcl 164 ref 680
uflags                  431            based           structure                level 2 dcl 7-78
unit_string                     000472 automatic       varying char(200)        dcl 76 set ref 665* 668* 668 672 674*
unspec                                                 builtin function         dcl 127 set ref 390* 392
used                      2(09)        based           bit(1)                   level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 2-35 in procedure "lv_request_" set ref 480*
used                                   based           bit(1)                   array level 3 in structure "dt" packed packed
                                                                                  unaligned dcl 2-23 in procedure "lv_request_" set
                                                                                  ref 273 661
user_abs_attributes                    based           structure                level 1 dcl 6-25
user_attributes                        based           structure                level 1 dcl 5-21
user_procid                     000555 automatic       bit(36)                  dcl 77 set ref 213* 321* 382* 494* 530* 559* 568*
                                                                                  577* 621*
user_procname                   000556 automatic       char(33)                 packed unaligned dcl 78 set ref 213* 321* 382* 494*
                                                                                  530* 541* 559* 568* 577* 618* 619* 674*
ute                                    based           structure                level 1 dcl 7-78
utep                            001214 automatic       pointer                  initial dcl 7-76 set ref 428 428 444 444 545 545
                                                                                  7-76* 571 571* 581 581* 606* 607* 610* 611 612 613
                                                                                  614 615 618
vols_to_list                    000567 automatic       char(32)                 array packed unaligned dcl 79 set ref 258 258* 261*
                                                                                  263 280
vtlx                            000707 automatic       fixed bin(17,0)          dcl 80 set ref 279* 280*
waiting                  16(04)        based           bit(1)                   level 3 packed packed unaligned dcl 3-19 ref 212 317
xec                             000430 automatic       fixed bin(35,0)          dcl 60 set ref 411 591*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 6-38
ABS_FLAG_NAMES                         internal static varying char(8)          initial array dcl 7-326
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 5-77
DERIVE_MASK                            internal static bit(2)                   initial packed unaligned dcl 7-280
DIAL_SERVER_FLAG_NAMES                 internal static varying char(12)         initial array dcl 7-332
DONT_MASK                              internal static bit(2)                   initial packed unaligned dcl 7-280
DO_MASK                                internal static bit(2)                   initial packed unaligned dcl 7-280
LOGIN_RESULT_VALUES                    internal static varying char(24)         initial array dcl 7-338
MASK_CTL_NAMES                         internal static varying char(12)         initial array dcl 7-284
PROCESS_TYPE_NAMES                     internal static varying char(12)         initial array dcl 7-265
PT_ABSENTEE                            internal static fixed bin(17,0)          initial dcl 7-261
PT_DAEMON                              internal static fixed bin(17,0)          initial dcl 7-261
PT_INTERACTIVE                         internal static fixed bin(17,0)          initial dcl 7-261
PW_FLAG_NAMES                          internal static varying char(12)         initial array dcl 7-290
SL_INFO_arg_given_in_structure         internal static fixed bin(17,0)          initial dcl 4-69
SL_INFO_arg_not_given                  internal static fixed bin(17,0)          initial dcl 4-69
SL_INFO_as_mode                        internal static fixed bin(17,0)          initial dcl 4-65
SL_INFO_command_mode                   internal static fixed bin(17,0)          initial dcl 4-65
SL_INFO_version_1                      internal static char(8)                  initial packed unaligned dcl 4-62
SL_LOG_CRASH                           internal static fixed bin(17,0)          initial dcl 4-14
SL_LOG_SILENT                          internal static fixed bin(17,0)          initial dcl 4-14
SL_TYPE                                internal static fixed bin(17,0)          initial dcl 4-14
SL_TYPE_BEEP                           internal static fixed bin(17,0)          initial dcl 4-14
SL_TYPE_CRASH                          internal static fixed bin(17,0)          initial dcl 4-14
TABLE_NAMES                            internal static char(20)                 initial array packed unaligned dcl 7-271
UFLAG_NAMES                            internal static varying char(24)         initial array dcl 7-303
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 5-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 5-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 5-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 5-50
UTE_version_4                          internal static fixed bin(17,0)          initial dcl 7-74
dev_disk                               internal static fixed bin(17,0)          initial dcl 1-54
dev_disk_mt                            internal static fixed bin(17,0)          initial dcl 1-55
dev_dsa_hour                           internal static fixed bin(17,0)          initial dcl 1-59
dev_dsa_kilobyte                       internal static fixed bin(17,0)          initial dcl 1-57
dev_dsa_kilopacket                     internal static fixed bin(17,0)          initial dcl 1-58
dev_tape                               internal static fixed bin(17,0)          initial dcl 1-52
dev_tape_mt                            internal static fixed bin(17,0)          initial dcl 1-53
devtab_ix_disk                         internal static fixed bin(17,0)          initial dcl 1-63
devtab_ix_disk_mt                      internal static fixed bin(17,0)          initial dcl 1-64
devtab_ix_dsa_hour                     internal static fixed bin(17,0)          initial dcl 1-68
devtab_ix_dsa_kilobyte                 internal static fixed bin(17,0)          initial dcl 1-66
devtab_ix_dsa_kilopacket               internal static fixed bin(17,0)          initial dcl 1-67
devtab_ix_tape                         internal static fixed bin(17,0)          initial dcl 1-61
devtab_ix_tape_mt                      internal static fixed bin(17,0)          initial dcl 1-62
lvat                                   based           structure                level 1 dcl 3-8
lvatp                                  automatic       pointer                  dcl 3-6
sl_info                                automatic       structure                level 1 dcl 4-24
sl_info_code_msg                       internal static structure                level 1 dcl 4-187
sl_info_msg                            internal static structure                level 1 dcl 4-214
sl_info_sev_code_label_msg             internal static structure                level 1 dcl 4-161
sl_info_sev_code_msg                   internal static structure                level 1 dcl 4-82
sl_info_sev_coded_msg                  internal static structure                level 1 dcl 4-134
sl_info_sev_msg                        internal static structure                level 1 dcl 4-108

NAMES DECLARED BY EXPLICIT CONTEXT.
any_other_handler               004425 constant        entry                    internal dcl 628 ref 378 378
attach                          004032 constant        entry                    internal dcl 566 ref 366 443
attach_list                     001230 constant        entry                    external dcl 228
badlvax                         002365 constant        label                    dcl 412 ref 418
beef                            003745 constant        entry                    internal dcl 555 ref 217 365 446 498 543
cleanup_process                 001720 constant        entry                    external dcl 330
detach                          004115 constant        entry                    internal dcl 575 ref 220 342 424
dhv                             001033 constant        entry                    external dcl 201
dlv_and_mhv                     003172 constant        label                    dcl 506 ref 486
find_u                          004220 constant        entry                    internal dcl 595 ref 210 314 333 363 381 419 673
get                             004200 constant        entry                    internal dcl 586 ref 209 313 340 361 410 660
init                            000627 constant        entry                    external dcl 175
init1                           000614 constant        entry                    external dcl 171
interrupt                       002166 constant        label                    dcl 374 ref 17
list_vol_attachments            003520 constant        entry                    internal dcl 295 ref 275 284
lv_request_                     000604 constant        entry                    external dcl 16 ref 178 178
mhv_complete                    002025 constant        entry                    external dcl 349
mhv_it                          003314 constant        label                    dcl 530 ref 468
no_avail                        003074 constant        label                    dcl 494 set ref 459 525 550
poll_mounts                     004562 constant        entry                    internal dcl 652 ref 394
test                            003475 constant        entry                    external dcl 687
unmask                          003157 constant        label                    dcl 499 ref 538 546 646

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5704        6036    5161        5714
Length      6504    5161       132         432     522           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lv_request_                        1085 external procedure  is an external procedure.  
list_vol_attachments                    internal procedure  shares stack frame of external procedure lv_request_.  
on unit on line 462                  64 on unit               
beef                                    internal procedure  shares stack frame of external procedure lv_request_.  
attach                                  internal procedure  shares stack frame of external procedure lv_request_.  
detach                                  internal procedure  shares stack frame of external procedure lv_request_.  
get                                     internal procedure  shares stack frame of external procedure lv_request_.  
find_u                                  internal procedure  shares stack frame of external procedure lv_request_.  
any_other_handler                    92 internal procedure  is assigned to an entry variable.  
poll_mounts                             internal procedure  shares stack frame of external procedure lv_request_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 LV_RING                     lv_request_
000011 SL0                         lv_request_
000012 initialized                 lv_request_
000013 myprocessid                 lv_request_
000014 testing                     lv_request_
000015 devtab_ix_lv                lv_request_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lv_request_              000100 argl                        lv_request_
                         000102 argp                        lv_request_
                         000104 argx                        lv_request_
                         000105 array                       lv_request_
                         000415 d_lvname                    lv_request_
                         000425 demounting                  lv_request_
                         000426 dtx                         lv_request_
                         000427 ec                          lv_request_
                         000430 xec                         lv_request_
                         000431 ev_calls_masked             lv_request_
                         000432 i                           lv_request_
                         000433 n                           lv_request_
                         000434 list_all_vols               lv_request_
                         000435 lvax                        lv_request_
                         000436 lvname                      lv_request_
                         000446 lvx                         lv_request_
                         000447 pvx                         lv_request_
                         000450 my_evchn                    lv_request_
                         000452 n_devtab_entries            lv_request_
                         000453 n_vols_to_list              lv_request_
                         000454 nargs                       lv_request_
                         000456 next_time                   lv_request_
                         000460 pid                         lv_request_
                         000461 result                      lv_request_
                         000462 shown_lvat_header           lv_request_
                         000463 status                      lv_request_
                         000472 unit_string                 lv_request_
                         000555 user_procid                 lv_request_
                         000556 user_procname               lv_request_
                         000567 vols_to_list                lv_request_
                         000707 vtlx                        lv_request_
                         000710 devtab_copy                 lv_request_
                         001150 local_lvate                 lv_request_
                         001174 mount_transmission          lv_request_
                         001204 dtp                         lv_request_
                         001206 dtep                        lv_request_
                         001210 lvep                        lv_request_
                         001212 lvatep                      lv_request_
                         001214 utep                        lv_request_
                         001304 ape                         find_u
                         001312 aprj                        find_u
                         001315 tag                         find_u
                         001316 anon                        find_u

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
as_$dump                      as_$find_process              com_err_                      condition_
cu_$arg_count                 cu_$arg_ptr                   device_acct_$off              device_acct_$on
disk_table_$dhv               disk_table_$dry_run_mhv       disk_table_$get_dtp           disk_table_$mhv
get_process_id_               get_ring_                     get_userid_$info              initializer_mdc_$check_mount
initializer_mdc_$free_lvate   initializer_mdc_$init_lvat    initializer_mdc_$invalidate_lvate
initializer_mdc_$lvat_scan_lv initializer_mdc_$mhvmessage   initializer_mdc_$poll_mounts
initializer_mdc_$respond_mount_lv                           initializer_mdc_$retrieve_lvate
initializer_mdc_$scan_process_lvat                          initializer_mdc_$set_lvat_info
ioa_                          ioa_$rsnnl                    ipc_$create_ev_chn            ipc_$decl_ev_call_chn
ipc_$mask_ev_calls            ipc_$unmask_ev_calls          sys_log_                      sys_log_$error_log
system_info_$device_prices    timer_manager_$alarm_wakeup

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noarg            error_table_$resource_unavailable


CONSTANTS
005106  aa     000002000000
005107  aa     000002000000
005110  aa     600000000041
005111  aa     001344000000
005112  ta     000044000000
005113  aa     000000000000

005114  aa     000002000000
005115  aa     000002000000
005116  aa     600000000041
005117  aa     001344000000
005120  ta     000063000000
005121  aa     000000000000

005122  aa     777377777777

005124  aa     000002000000
005125  aa     000002000000
005126  aa     600000000041
005127  aa     001332000000
005130  ta     000047000000
005131  aa     000000000000

005132  aa     737777777777

005134  aa     000002000000
005135  aa     000002000000
005136  aa     600000000041
005137  aa     001344000000
005140  ta     000061000000
005141  aa     000000000000

005142  aa     000002000000
005143  aa     000002000000
005144  aa     600000000041
005145  aa     001344000000
005146  ta     000072000000
005147  aa     000000000000

005150  aa     000002000000
005151  aa     000000000000
005152  aa     600000000041
005153  aa     000435000000

005154  aa     077777000043
005155  aa     000001000000

000000  aa  164 141 160 145	tape
000001  aa  040 040 040 040	    
000002  aa  164 141 160 145	tape
000003  aa  137 155 164 040	_mt 
000004  aa  144 151 163 153	disk
000005  aa  040 040 040 040	    
000006  aa  144 151 163 153	disk
000007  aa  137 155 164 040	_mt 
000010  aa  154 166 040 040	lv  
000011  aa  040 040 040 040	    
000012  aa  144 163 141 137	dsa_
000013  aa  153 142 171 164	kbyt
000014  aa  144 163 141 137	dsa_
000015  aa  153 160 153 164	kpkt
000016  aa  144 163 141 137	dsa_
000017  aa  150 157 165 162	hour

000020  aa  141 154 141 162	alar
000021  aa  155 137 137 137	m___


000022  aa     530000000310

005156  aa  051 040 000 000	) 

005157  aa  040 050 000 000	 (

000023  aa     410000000107

000024  aa     524000000056

000025  aa  143 160 165 164	cput

000026  aa  141 154 162 155	alrm

000027  aa  161 165 151 164	quit

000030  aa     514000000001

000031  aa     404000000005

000032  aa     524000000015

000033  aa     526000000001

000034  aa     526000000014

000035  aa     526000000030

000036  aa     524000000054

000037  aa     524000000052

000040  aa     524000000044

000041  aa     526000000031

000042  aa     524000000036

000043  aa     524000000030

000044  aa     524000000042

000045  aa     524000000064

000046  aa     524000000055

000047  aa     524000000023

000050  aa     516000000001

000051  aa     524000000046

000052  aa  144 145 155 157	demo

000053  aa  155 157 165 156	moun

000054  aa  160 157 154 154	poll

000055  aa     406000000021

000056  aa     514000000110

000057  aa     500000000000

000060  aa     524000000011

000061  aa     524000000033

000062  aa     524000000024

000063  aa     524000000031

000064  aa     524000000107

005160  aa  055 141 000 000	-a

000065  aa  055 141 154 154	-all

000066  aa     524000000017

000067  aa     524000000034

000070  aa     524000000027

000071  aa     524000000076

000072  aa     524000000040

000073  aa     526000000041

000074  aa     524000000047

000075  aa     526000000040

000076  aa     524000000063

000077  aa     524000000013

000100  aa     404000000043

000101  aa     526077777777

000102  aa     000000000002

000103  aa     404000000021

000104  aa     514000000044

000105  aa     464000000000

000106  aa  077 077 077 077	????
000107  aa  077 077 000 000	??

000110  aa  111 156 040 165	In u
000111  aa  163 145 000 000	se

000112  aa     077777000043
000113  aa     000001000000

000114  aa  163 151 147 156	sign
000115  aa  141 154 137 151	al_i
000116  aa  157 137 000 000	o_

000117  aa  120 122 117 103	PROC
000120  aa  105 123 123 111	ESSI
000121  aa  104 000 000 000	D

000122  aa  111 156 166 141	Inva
000123  aa  154 151 144 141	lida
000124  aa  164 145 144 000	ted

000125  aa  104 145 164 141	Deta
000126  aa  143 150 151 156	chin
000127  aa  147 000 000 000	g

000130  aa  141 156 171 137	any_
000131  aa  157 164 150 145	othe
000132  aa  162 000 000 000	r

000133  aa  154 166 137 162	lv_r
000134  aa  145 161 165 145	eque
000135  aa  163 164 137 000	st_

000136  aa  136 133 052 136	^[*^
000137  aa  135 136 141 056	]^a.
000140  aa  136 141 056 136	^a.^
000141  aa  141 000 000 000	a

000142  aa  136 063 063 141	^33a
000143  aa  040 136 061 062	 ^12
000144  aa  056 063 142 040	.3b 
000145  aa  040 136 141 000	 ^a

000146  aa  107 145 164 164	Gett
000147  aa  151 156 147 040	ing 
000150  aa  141 162 147 040	arg 
000151  aa  136 144 056 000	^d.

000152  aa     404100000021
000153  aa     000000000001
000154  aa     000000000310
000155  aa     000000000001

000156  aa  143 157 155 155	comm
000157  aa  141 156 144 137	and_
000160  aa  145 162 162 157	erro
000161  aa  162 000 000 000	r

000162  aa  160 162 157 147	prog
000163  aa  162 141 155 137	ram_
000164  aa  151 156 164 145	inte
000165  aa  162 162 165 160	rrup
000166  aa  164 000 000 000	t

000167  aa  127 141 151 164	Wait
000170  aa  151 156 147 040	ing 
000171  aa  146 157 162 040	for 
000172  aa  155 157 165 156	moun
000173  aa  164 000 000 000	t

000174  aa  115 141 163 153	Mask
000175  aa  151 156 147 040	ing 
000176  aa  145 166 145 156	even
000177  aa  164 040 143 141	t ca
000200  aa  154 154 163 056	lls.

000201  aa  115 157 165 156	Moun
000202  aa  164 040 141 154	t al
000203  aa  162 145 141 144	read
000204  aa  171 040 162 145	y re
000205  aa  141 144 171 000	ady

000206  aa  136 057 116 157	^/No
000207  aa  040 114 126 040	 LV 
000210  aa  101 164 164 141	Atta
000211  aa  143 150 155 145	chme
000212  aa  156 164 163 056	nts.

000213  aa  136 057 114 126	^/LV
000214  aa  040 042 136 141	 "^a
000215  aa  042 040 101 164	" At
000216  aa  164 141 143 150	tach
000217  aa  155 145 156 164	ment
000220  aa  163 072 136 057	s:^/

000221  aa  107 145 164 164	Gett
000222  aa  151 156 147 040	ing 
000223  aa  141 162 147 165	argu
000224  aa  155 145 156 164	ment
000225  aa  040 143 157 165	 cou
000226  aa  156 164 056 000	nt.

000227  aa  136 057 116 157	^/No
000230  aa  040 141 164 164	 att
000231  aa  141 143 150 155	achm
000232  aa  145 156 164 163	ents
000233  aa  040 164 157 040	 to 
000234  aa  114 126 040 042	LV "
000235  aa  136 141 042 056	^a".

000236  aa  104 162 151 166	Driv
000237  aa  145 040 141 166	e av
000240  aa  141 151 154 141	aila
000241  aa  142 151 154 151	bili
000242  aa  164 171 040 144	ty d
000243  aa  145 156 151 141	enia
000244  aa  154 000 000 000	l

000245  aa  123 145 156 144	Send
000246  aa  151 156 147 040	ing 
000247  aa  155 157 165 156	moun
000250  aa  164 040 162 145	t re
000251  aa  141 144 171 040	ady 
000252  aa  155 145 163 163	mess
000253  aa  141 147 145 000	age

000254  aa  136 057 114 126	^/LV
000255  aa  040 042 136 141	 "^a
000256  aa  042 040 151 163	" is
000257  aa  040 156 157 164	 not
000260  aa  040 144 145 146	 def
000261  aa  151 156 145 144	ined
000262  aa  056 000 000 000	.

000263  aa  114 157 147 151	Logi
000264  aa  143 141 154 040	cal 
000265  aa  166 157 154 165	volu
000266  aa  155 145 040 156	me n
000267  aa  141 155 145 040	ame 
000270  aa  157 162 040 055	or -
000271  aa  141 154 154 056	all.

000272  aa  125 163 145 162	User
000273  aa  136 063 065 164	^35t
000274  aa  120 162 157 143	Proc
000275  aa  145 163 163 137	ess_
000276  aa  151 144 136 064	id^4
000277  aa  071 164 123 164	9tSt
000300  aa  141 164 165 163	atus
000301  aa  136 057 000 000	^/

000302  aa  103 141 156 143	Canc
000303  aa  145 154 154 151	elli
000304  aa  156 147 040 160	ng p
000305  aa  145 156 144 151	endi
000306  aa  156 147 040 155	ng m
000307  aa  157 165 156 164	ount
000310  aa  040 166 151 141	 via
000311  aa  040 144 154 166	 dlv

000312  aa  103 141 156 156	Cann
000313  aa  157 164 040 163	ot s
000314  aa  145 156 144 040	end 
000315  aa  155 145 163 163	mess
000316  aa  141 147 145 040	age 
000317  aa  164 157 040 136	to ^
000320  aa  141 040 136 061	a ^1
000321  aa  062 056 063 142	2.3b
000322  aa  072 040 136 141	: ^a

000323  aa  123 145 156 144	Send
000324  aa  151 156 147 040	ing 
000325  aa  162 145 163 160	resp
000326  aa  157 156 163 145	onse
000327  aa  040 164 157 040	 to 
000330  aa  167 141 151 164	wait
000331  aa  040 146 157 162	 for
000332  aa  040 155 157 165	 mou
000333  aa  156 164 000 000	nt

000334  aa  154 166 137 162	lv_r
000335  aa  145 161 165 145	eque
000336  aa  163 164 137 040	st_ 
000337  aa  072 040 142 141	: ba
000340  aa  144 040 164 162	d tr
000341  aa  141 156 163 155	ansm
000342  aa  151 163 163 151	issi
000343  aa  157 156 072 040	on: 
000344  aa  136 062 064 056	^24.
000345  aa  063 142 000 000	3b

000346  aa  154 166 137 162	lv_r
000347  aa  145 161 165 145	eque
000350  aa  163 164 137 072	st_:
000351  aa  040 104 145 156	 Den
000352  aa  151 145 144 040	ied 
000353  aa  114 126 040 136	LV ^
000354  aa  141 040 164 157	a to
000355  aa  040 136 141 040	 ^a 
000356  aa  136 061 062 056	^12.
000357  aa  063 142 056 000	3b.

000360  aa  154 166 137 162	lv_r
000361  aa  145 161 165 145	eque
000362  aa  163 164 137 072	st_:
000363  aa  040 104 105 124	 DET
000364  aa  101 103 110 136	ACH^
000365  aa  062 060 164 114	20tL
000366  aa  126 040 136 141	V ^a
000367  aa  040 146 162 157	 fro
000370  aa  155 040 136 141	m ^a
000371  aa  040 136 061 062	 ^12
000372  aa  056 063 142 056	.3b.

000373  aa  154 166 137 162	lv_r
000374  aa  145 161 165 145	eque
000375  aa  163 164 137 072	st_:
000376  aa  040 101 124 124	 ATT
000377  aa  101 103 110 136	ACH^
000400  aa  062 060 164 114	20tL
000401  aa  126 040 136 141	V ^a
000402  aa  040 164 157 040	 to 
000403  aa  136 141 040 136	^a ^
000404  aa  061 062 056 063	12.3
000405  aa  142 056 000 000	b.

000406  aa  154 166 137 162	lv_r
000407  aa  145 161 165 145	eque
000410  aa  163 164 137 072	st_:
000411  aa  040 125 156 145	 Une
000412  aa  170 160 145 143	xpec
000413  aa  164 145 144 040	ted 
000414  aa  143 157 156 144	cond
000415  aa  151 164 151 157	itio
000416  aa  156 040 136 141	n ^a
000417  aa  040 157 143 143	 occ
000420  aa  165 162 162 145	urre
000421  aa  144 056 000 000	d.

000422  aa  116 157 040 144	No d
000423  aa  162 151 166 145	rive
000424  aa  163 040 141 166	s av
000425  aa  141 151 154 141	aila
000426  aa  142 154 145 040	ble 
000427  aa  164 157 040 155	to m
000430  aa  157 165 156 164	ount
000431  aa  040 136 141 040	 ^a 
000432  aa  146 157 162 040	for 
000433  aa  136 141 040 136	^a ^
000434  aa  061 062 056 063	12.3
000435  aa  142 000 000 000	b

000436  aa  154 166 137 162	lv_r
000437  aa  145 161 165 145	eque
000440  aa  163 164 137 072	st_:
000441  aa  040 102 145 147	 Beg
000442  aa  151 156 156 151	inni
000443  aa  156 147 040 155	ng m
000444  aa  157 165 156 164	ount
000445  aa  040 157 146 040	 of 
000446  aa  114 126 040 136	LV ^
000447  aa  141 040 146 157	a fo
000450  aa  162 040 136 141	r ^a
000451  aa  040 136 061 062	 ^12
000452  aa  056 063 142 056	.3b.

000453  aa  103 141 156 156	Cann
000454  aa  157 164 040 151	ot i
000455  aa  156 151 164 151	niti
000456  aa  141 154 151 172	aliz
000457  aa  145 040 154 157	e lo
000460  aa  147 151 143 141	gica
000461  aa  154 040 166 157	l vo
000462  aa  154 165 155 145	lume
000463  aa  040 155 157 165	 mou
000464  aa  156 164 151 156	ntin
000465  aa  147 040 163 157	g so
000466  aa  146 164 167 141	ftwa
000467  aa  162 145 056 000	re.

000470  aa  154 166 137 162	lv_r
000471  aa  145 161 165 145	eque
000472  aa  163 164 137 072	st_:
000473  aa  040 123 160 165	 Spu
000474  aa  162 151 157 165	riou
000475  aa  163 040 167 141	s wa
000476  aa  153 145 165 160	keup
000477  aa  040 136 062 064	 ^24
000500  aa  056 063 142 040	.3b 
000501  aa  162 145 143 145	rece
000502  aa  151 166 145 144	ived
000503  aa  040 146 162 157	 fro
000504  aa  155 040 136 141	m ^a
000505  aa  040 136 061 062	 ^12
000506  aa  056 063 142 040	.3b 
000507  aa  136 144 000 000	^d

000510  aa  154 166 137 162	lv_r
000511  aa  145 161 165 145	eque
000512  aa  163 164 137 072	st_:
000513  aa  040 114 157 147	 Log
000514  aa  151 143 141 154	ical
000515  aa  040 166 157 154	 vol
000516  aa  165 155 145 040	ume 
000517  aa  163 157 146 164	soft
000520  aa  167 141 162 145	ware
000521  aa  040 150 141 163	 has
000522  aa  040 156 157 164	 not
000523  aa  040 142 145 145	 bee
000524  aa  156 040 151 156	n in
000525  aa  151 164 151 141	itia
000526  aa  154 151 172 145	lize
000527  aa  144 056 000 000	d.

000530  aa  154 166 137 162	lv_r
000531  aa  145 161 165 145	eque
000532  aa  163 164 137 072	st_:
000533  aa  040 142 141 144	 bad
000534  aa  040 114 126 040	 LV 
000535  aa  141 164 164 141	atta
000536  aa  143 150 040 164	ch t
000537  aa  141 142 154 145	able
000540  aa  040 151 156 144	 ind
000541  aa  145 170 040 136	ex ^
000542  aa  144 040 151 156	d in
000543  aa  040 136 133 144	 ^[d
000544  aa  145 155 157 165	emou
000545  aa  156 164 136 073	nt^;
000546  aa  155 157 165 156	moun
000547  aa  164 136 135 040	t^] 
000550  aa  162 145 161 165	requ
000551  aa  145 163 164 000	est

000552  aa  154 166 137 162	lv_r
000553  aa  145 161 165 145	eque
000554  aa  163 164 137 072	st_:
000555  aa  040 124 157 157	 Too
000556  aa  040 155 141 156	 man
000557  aa  171 040 114 126	y LV
000560  aa  163 040 163 160	s sp
000561  aa  145 143 151 146	ecif
000562  aa  151 145 144 056	ied.
000563  aa  040 101 154 154	 All
000564  aa  040 114 126 163	 LVs
000565  aa  040 160 141 163	 pas
000566  aa  164 040 042 136	t "^
000567  aa  141 042 040 167	a" w
000570  aa  151 154 154 040	ill 
000571  aa  142 145 040 151	be i
000572  aa  147 156 157 162	gnor
000573  aa  145 144 056 000	ed.

BEGIN PROCEDURE lv_request_
PROLOGUE SEQUENCE
000574  aa  6 01331 4401 00	sxl0 	pr6|729
						STATEMENT 1 ON LINE 76 OF FILE 7
000575  aa   777315 2370 04	ldaq 	-307,ic		000112 = 077777000043 000001000000
000576  aa  6 01214 7571 00	staq 	pr6|652		utep
000577  aa  6 01331 7201 00	lxl0 	pr6|729
000600  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO lv_request_                                        STATEMENT 1 ON LINE 16
lv_request_: proc (msgp);

000601  at     000001000105
000602  ta     000601000000
000603  da     000431300000
000604  aa   002100 6270 00	eax7 	1088
000605  aa  7 00034 3521 20	epp2 	pr7|28,*
000606  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000607  aa     000002000000
000610  aa     000000000000
000611  aa   777763 7000 04	tsx0 	-13,ic		000574
						STATEMENT 1 ON LINE 17
	go to interrupt;

000612  aa   001354 7100 04	tra  	748,ic		002166
ENTRY TO init1                                              STATEMENT 1 ON LINE 171
init1:	entry;

000613  da     000436200000
000614  aa   002100 6270 00	eax7 	1088
000615  aa  7 00034 3521 20	epp2 	pr7|28,*
000616  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000617  aa     000000000000
000620  aa     000000000000
000621  aa   777753 7000 04	tsx0 	-21,ic		000574
						STATEMENT 1 ON LINE 173
	SL0 = SL_LOG;

000622  aa   000001 2360 07	ldq  	1,dl
000623  aa  6 00044 3701 20	epp4 	pr6|36,*
000624  ia  4 00011 7561 00	stq  	pr4|9		SL0
						STATEMENT 1 ON LINE 175
init:	entry;

000625  aa   000010 7100 04	tra  	8,ic		000635
ENTRY TO init                                               STATEMENT 1 ON LINE 175
init:	entry;

000626  da     000443200000
000627  aa   002100 6270 00	eax7 	1088
000630  aa  7 00034 3521 20	epp2 	pr7|28,*
000631  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000632  aa     000000000000
000633  aa     000000000000
000634  aa   777740 7000 04	tsx0 	-32,ic		000574
						STATEMENT 1 ON LINE 177
	call ipc_$create_ev_chn (my_evchn, ec);

000635  aa  6 00450 3521 00	epp2 	pr6|296		my_evchn
000636  aa  6 01334 2521 00	spri2	pr6|732
000637  aa  6 00427 3521 00	epp2 	pr6|279		ec
000640  aa  6 01336 2521 00	spri2	pr6|734
000641  aa  6 01332 6211 00	eax1 	pr6|730
000642  aa   010000 4310 07	fld  	4096,dl
000643  aa  6 00044 3701 20	epp4 	pr6|36,*
000644  la  4 00112 3521 20	epp2 	pr4|74,*		ipc_$create_ev_chn
000645  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 178
	call ipc_$decl_ev_call_chn (my_evchn, lv_request_, null, 1, ec);

000646  aa   777736 3520 04	epp2 	-34,ic		000604 = 002100627000
000647  aa  6 01332 2521 00	spri2	pr6|730		cp.316
000650  aa   004304 2370 04	ldaq 	2244,ic		005154 = 077777000043 000001000000
000651  aa  6 01334 7571 00	staq 	pr6|732		cp.316
000652  aa   777240 3734 24	epp7 	-352,ic*
000653  aa  6 01340 6535 00	spri7	pr6|736
000654  aa   000001 2360 07	ldq  	1,dl
000655  aa  6 01342 7561 00	stq  	pr6|738
000656  aa  6 00450 3521 00	epp2 	pr6|296		my_evchn
000657  aa  6 01346 2521 00	spri2	pr6|742
000660  aa  6 01332 3521 00	epp2 	pr6|730		cp.316
000661  aa  6 01350 2521 00	spri2	pr6|744
000662  aa  6 01340 3521 00	epp2 	pr6|736
000663  aa  6 01352 2521 00	spri2	pr6|746
000664  aa  6 01342 3521 00	epp2 	pr6|738
000665  aa  6 01354 2521 00	spri2	pr6|748
000666  aa  6 00427 3521 00	epp2 	pr6|279		ec
000667  aa  6 01356 2521 00	spri2	pr6|750
000670  aa  6 01344 6211 00	eax1 	pr6|740
000671  aa   024000 4310 07	fld  	10240,dl
000672  aa  6 00044 3701 20	epp4 	pr6|36,*
000673  la  4 00114 3521 20	epp2 	pr4|76,*		ipc_$decl_ev_call_chn
000674  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 180
	if ec = 0 then call initializer_mdc_$init_lvat (my_evchn, ec);

000675  aa  6 00427 2361 00	ldq  	pr6|279		ec
000676  aa   000012 6010 04	tnz  	10,ic		000710
000677  aa  6 00450 3521 00	epp2 	pr6|296		my_evchn
000700  aa  6 01334 2521 00	spri2	pr6|732
000701  aa  6 00427 3521 00	epp2 	pr6|279		ec
000702  aa  6 01336 2521 00	spri2	pr6|734
000703  aa  6 01332 6211 00	eax1 	pr6|730
000704  aa   010000 4310 07	fld  	4096,dl
000705  aa  6 00044 3701 20	epp4 	pr6|36,*
000706  la  4 00062 3521 20	epp2 	pr4|50,*		initializer_mdc_$init_lvat
000707  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 181
	if ec ^= 0 then do;

000710  aa  6 00427 2361 00	ldq  	pr6|279		ec
000711  aa   000037 6000 04	tze  	31,ic		000750
						STATEMENT 1 ON LINE 182
	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
		"Cannot initialize logical volume mounting software.");

000712  aa   777221 2350 04	lda  	-367,ic		000133 = 154166137162
000713  aa   777221 2360 04	ldq  	-367,ic		000134 = 145161165145
000714  aa  6 01332 7571 00	staq 	pr6|730
000715  aa   777220 2350 04	lda  	-368,ic		000135 = 163164137000
000716  aa  6 01334 7551 00	sta  	pr6|732
000717  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000720  aa   777534 00 0064	desc9a	-164,52		000453 = 103141156156
000721  aa  6 01360 00 0064	desc9a	pr6|752,52
000722  aa   777160 3520 04	epp2 	-400,ic		000102 = 000000000002
000723  aa  6 01400 2521 00	spri2	pr6|768
000724  aa  6 00427 3521 00	epp2 	pr6|279		ec
000725  aa  6 01402 2521 00	spri2	pr6|770
000726  aa  6 01332 3521 00	epp2 	pr6|730
000727  aa  6 01404 2521 00	spri2	pr6|772
000730  aa  6 01360 3521 00	epp2 	pr6|752
000731  aa  6 01406 2521 00	spri2	pr6|774
000732  aa   777151 3520 04	epp2 	-407,ic		000103 = 404000000021
000733  aa  6 01410 2521 00	spri2	pr6|776
000734  aa   777144 3520 04	epp2 	-412,ic		000100 = 404000000043
000735  aa  6 01412 2521 00	spri2	pr6|778
000736  aa   777141 3520 04	epp2 	-415,ic		000077 = 524000000013
000737  aa  6 01414 2521 00	spri2	pr6|780
000740  aa   777136 3520 04	epp2 	-418,ic		000076 = 524000000063
000741  aa  6 01416 2521 00	spri2	pr6|782
000742  aa  6 01376 6211 00	eax1 	pr6|766
000743  aa   020000 4310 07	fld  	8192,dl
000744  aa  6 00044 3701 20	epp4 	pr6|36,*
000745  la  4 00124 3521 20	epp2 	pr4|84,*		sys_log_$error_log
000746  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 184
	     return;

000747  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 185
	end;

						STATEMENT 1 ON LINE 187
	myprocessid = get_process_id_ ();

000750  aa  6 00044 3701 20	epp4 	pr6|36,*
000751  ia  4 00013 3521 00	epp2 	pr4|11		myprocessid
000752  aa  6 01334 2521 00	spri2	pr6|732
000753  aa  6 01332 6211 00	eax1 	pr6|730
000754  aa   004000 4310 07	fld  	2048,dl
000755  la  4 00050 3521 20	epp2 	pr4|40,*		get_process_id_
000756  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 189
	call system_info_$device_prices (n_devtab_entries, addr (devtab_copy));

000757  aa  6 00710 3735 00	epp7 	pr6|456		devtab_copy
000760  aa  6 01340 6535 00	spri7	pr6|736
000761  aa  6 00452 3521 00	epp2 	pr6|298		n_devtab_entries
000762  aa  6 01334 2521 00	spri2	pr6|732
000763  aa  6 01340 3521 00	epp2 	pr6|736
000764  aa  6 01336 2521 00	spri2	pr6|734
000765  aa  6 01332 6211 00	eax1 	pr6|730
000766  aa   010000 4310 07	fld  	4096,dl
000767  aa  6 00044 3701 20	epp4 	pr6|36,*
000770  la  4 00126 3521 20	epp2 	pr4|86,*		system_info_$device_prices
000771  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 190
	do devtab_ix_lv = 1 to n_devtab_entries		/* look up lv in devtab */
		while (devtab_copy (devtab_ix_lv).device_id ^= dev_id (dev_lv));

000772  aa  6 00452 2361 00	ldq  	pr6|298		n_devtab_entries
000773  aa  6 01216 7561 00	stq  	pr6|654
000774  aa   000001 2360 07	ldq  	1,dl
000775  aa  6 00044 3701 20	epp4 	pr6|36,*
000776  ia  4 00015 7561 00	stq  	pr4|13		devtab_ix_lv
000777  aa   000000 0110 03	nop  	0,du
001000  aa  6 00044 3701 20	epp4 	pr6|36,*
001001  ia  4 00015 2361 00	ldq  	pr4|13		devtab_ix_lv
001002  aa  6 01216 1161 00	cmpq 	pr6|654
001003  aa   000015 6054 04	tpnz 	13,ic		001020
001004  aa   000012 4020 07	mpy  	10,dl
001005  aa   000000 6270 06	eax7 	0,ql
001006  aa   000012 2360 07	ldq  	10,dl
001007  aa   000000 6260 06	eax6 	0,ql
001010  aa  6 00676 2351 17	lda  	pr6|446,7		devtab_copy.device_id
001011  aa  6 00677 2361 17	ldq  	pr6|447,7		devtab_copy.device_id
001012  ta   777776 1150 16	cmpa 	-2,6
001013  aa   000002 6010 04	tnz  	2,ic		001015
001014  ta   777777 1160 16	cmpq 	-1,6
001015  aa   000003 6000 04	tze  	3,ic		001020
						STATEMENT 1 ON LINE 192
	end;

001016  ia  4 00015 0541 00	aos  	pr4|13		devtab_ix_lv
001017  aa   777761 7100 04	tra  	-15,ic		001000
						STATEMENT 1 ON LINE 193
	if devtab_ix_lv = n_devtab_entries + 1 then	/* if not there, we won't charge for logical volumes */
	     devtab_ix_lv = 0;

001020  aa  6 00452 2361 00	ldq  	pr6|298		n_devtab_entries
001021  aa   000001 0760 07	adq  	1,dl
001022  ia  4 00015 1161 00	cmpq 	pr4|13		devtab_ix_lv
001023  aa   000002 6010 04	tnz  	2,ic		001025
001024  ia  4 00015 4501 00	stz  	pr4|13		devtab_ix_lv
						STATEMENT 1 ON LINE 196
	initialized = "1"b;

001025  aa   400000 2350 03	lda  	131072,du
001026  ia  4 00012 7551 00	sta  	pr4|10		initialized
						STATEMENT 1 ON LINE 197
	return;

001027  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO dhv                                                STATEMENT 1 ON LINE 201
dhv:	entry (a_lvname);

001030  at     000001000101
001031  ta     001030000000
001032  da     000446300000
001033  aa   002100 6270 00	eax7 	1088
001034  aa  7 00034 3521 20	epp2 	pr7|28,*
001035  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001036  aa     000002000000
001037  aa     000000000000
001040  aa  6 00042 3735 20	epp7 	pr6|34,*
001041  aa  7 00000 2361 20	ldq  	pr7|0,*
001042  aa   000002 6040 04	tmi  	2,ic		001044
001043  aa   777777 3760 07	anq  	262143,dl
001044  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001045  aa  6 01420 7561 00	stq  	pr6|784
001046  aa   777526 7000 04	tsx0 	-170,ic		000574
						STATEMENT 1 ON LINE 203
	if ^initialized then return;

001047  aa  6 00044 3701 20	epp4 	pr6|36,*
001050  ia  4 00012 2351 00	lda  	pr4|10		initialized
001051  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 204
	lvname = a_lvname;

001052  aa  6 00032 3735 20	epp7 	pr6|26,*
001053  aa  7 00002 3715 20	epp5 	pr7|2,*
001054  aa  6 01420 2361 00	ldq  	pr6|784
001055  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001056  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_lvname
001057  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 205
	call initializer_mdc_$lvat_scan_lv (lvname, array, n);

001060  aa  6 00436 3521 00	epp2 	pr6|286		lvname
001061  aa  6 01400 2521 00	spri2	pr6|768
001062  aa  6 00105 3521 00	epp2 	pr6|69		array
001063  aa  6 01402 2521 00	spri2	pr6|770
001064  aa  6 00433 3521 00	epp2 	pr6|283		n
001065  aa  6 01404 2521 00	spri2	pr6|772
001066  aa   777007 3520 04	epp2 	-505,ic		000075 = 526000000040
001067  aa  6 01406 2521 00	spri2	pr6|774
001070  aa   777062 3520 04	epp2 	-462,ic		000152 = 404100000021
001071  aa  6 01410 2521 00	spri2	pr6|776
001072  aa   777011 3520 04	epp2 	-503,ic		000103 = 404000000021
001073  aa  6 01412 2521 00	spri2	pr6|778
001074  aa  6 01376 6211 00	eax1 	pr6|766
001075  aa   014000 4310 07	fld  	6144,dl
001076  la  4 00066 3521 20	epp2 	pr4|54,*		initializer_mdc_$lvat_scan_lv
001077  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 206
	do i = 1 to n;

001100  aa  6 00433 2361 00	ldq  	pr6|283		n
001101  aa  6 01217 7561 00	stq  	pr6|655
001102  aa   000001 2360 07	ldq  	1,dl
001103  aa  6 00432 7561 00	stq  	pr6|282		i
001104  aa  6 00432 2361 00	ldq  	pr6|282		i
001105  aa  6 01217 1161 00	cmpq 	pr6|655
001106  aa   000120 6054 04	tpnz 	80,ic		001226
						STATEMENT 1 ON LINE 208
	     lvax = array (i);

001107  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
001110  aa  6 00435 7561 00	stq  	pr6|285		lvax
						STATEMENT 1 ON LINE 209
	     call get (lvax);

001111  aa   004037 3520 04	epp2 	2079,ic		005150 = 000002000000
001112  aa   003066 6700 04	tsp4 	1590,ic		004200
						STATEMENT 1 ON LINE 210
	     call find_u (lvate.pid);

001113  aa  6 01212 3521 20	epp2 	pr6|650,*		lvate.pid
001114  aa  6 01334 2521 00	spri2	pr6|732
001115  aa  6 01332 3521 00	epp2 	pr6|730
001116  aa   004000 4310 07	fld  	2048,dl
001117  aa  2 00000 7571 00	staq 	pr2|0
001120  aa   003100 6700 04	tsp4 	1600,ic		004220
						STATEMENT 1 ON LINE 212
	     if lvate.waiting then do;

001121  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
001122  aa  7 00016 2351 00	lda  	pr7|14		lvate.waiting
001123  aa   020000 3150 03	cana 	8192,du
001124  aa   000064 6000 04	tze  	52,ic		001210
						STATEMENT 1 ON LINE 213
		call sys_log_ (SL0,
		     "lv_request_: Denied LV ^a to ^a ^12.3b.", lvname,
		     user_procname, user_procid);

001125  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001126  aa   777221 00 0050	desc9a	-367,40		000346 = 154166137162
001127  aa  6 01344 00 0050	desc9a	pr6|740,40
001130  aa  6 00044 3701 20	epp4 	pr6|36,*
001131  ia  4 00011 3521 00	epp2 	pr4|9		SL0
001132  aa  6 01424 2521 00	spri2	pr6|788
001133  aa  6 01344 3521 00	epp2 	pr6|740
001134  aa  6 01426 2521 00	spri2	pr6|790
001135  aa  6 00436 3521 00	epp2 	pr6|286		lvname
001136  aa  6 01430 2521 00	spri2	pr6|792
001137  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
001140  aa  6 01432 2521 00	spri2	pr6|794
001141  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
001142  aa  6 01434 2521 00	spri2	pr6|796
001143  aa   776740 3520 04	epp2 	-544,ic		000103 = 404000000021
001144  aa  6 01436 2521 00	spri2	pr6|798
001145  aa   776727 3520 04	epp2 	-553,ic		000074 = 524000000047
001146  aa  6 01440 2521 00	spri2	pr6|800
001147  aa   776726 3520 04	epp2 	-554,ic		000075 = 526000000040
001150  aa  6 01442 2521 00	spri2	pr6|802
001151  aa   776722 3520 04	epp2 	-558,ic		000073 = 526000000041
001152  aa  6 01444 2521 00	spri2	pr6|804
001153  aa   776731 3520 04	epp2 	-551,ic		000104 = 514000000044
001154  aa  6 01446 2521 00	spri2	pr6|806
001155  aa  6 01422 6211 00	eax1 	pr6|786
001156  aa   024000 4310 07	fld  	10240,dl
001157  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
001160  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 216
		call initializer_mdc_$respond_mount_lv (lvax, 2, error_table_$resource_unavailable, ec);

001161  aa   000002 2360 07	ldq  	2,dl
001162  aa  6 01421 7561 00	stq  	pr6|785
001163  aa  6 00435 3521 00	epp2 	pr6|285		lvax
001164  aa  6 01346 2521 00	spri2	pr6|742
001165  aa  6 01421 3521 00	epp2 	pr6|785
001166  aa  6 01350 2521 00	spri2	pr6|744
001167  aa  6 00044 3701 20	epp4 	pr6|36,*
001170  la  4 00046 3521 20	epp2 	pr4|38,*		error_table_$resource_unavailable
001171  aa  6 01352 2521 00	spri2	pr6|746
001172  aa  6 00427 3521 00	epp2 	pr6|279		ec
001173  aa  6 01354 2521 00	spri2	pr6|748
001174  aa  6 01344 6211 00	eax1 	pr6|740
001175  aa   020000 4310 07	fld  	8192,dl
001176  la  4 00074 3521 20	epp2 	pr4|60,*		initializer_mdc_$respond_mount_lv
001177  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 217
		if ec ^= 0 then call beef ("Cancelling pending mount via dlv");

001200  aa  6 00427 2361 00	ldq  	pr6|279		ec
001201  aa   000007 6000 04	tze  	7,ic		001210
001202  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001203  aa   777100 00 0040	desc9a	-448,32		000302 = 103141156143
001204  aa  6 01344 00 0040	desc9a	pr6|740,32
001205  aa   003735 3520 04	epp2 	2013,ic		005142 = 000002000000
001206  aa  2 00000 2351 00	lda  	pr2|0
001207  aa   002536 6700 04	tsp4 	1374,ic		003745
						STATEMENT 1 ON LINE 218
	     end;

						STATEMENT 1 ON LINE 219
	     if lvate.mounted then do;

001210  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
001211  aa  7 00016 2351 00	lda  	pr7|14		lvate.mounted
001212  aa   040000 3150 03	cana 	16384,du
001213  aa   000011 6000 04	tze  	9,ic		001224
						STATEMENT 1 ON LINE 220
		call detach;

001214  aa   002701 6700 04	tsp4 	1473,ic		004115
						STATEMENT 1 ON LINE 221
		call initializer_mdc_$invalidate_lvate (lvax);

001215  aa  6 00435 3521 00	epp2 	pr6|285		lvax
001216  aa  6 01334 2521 00	spri2	pr6|732
001217  aa  6 01332 6211 00	eax1 	pr6|730
001220  aa   004000 4310 07	fld  	2048,dl
001221  aa  6 00044 3701 20	epp4 	pr6|36,*
001222  la  4 00064 3521 20	epp2 	pr4|52,*		initializer_mdc_$invalidate_lvate
001223  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 222
	     end;

						STATEMENT 1 ON LINE 223
	end;

001224  aa  6 00432 0541 00	aos  	pr6|282		i
001225  aa   777657 7100 04	tra  	-81,ic		001104
						STATEMENT 1 ON LINE 224
	return;

001226  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO attach_list                                        STATEMENT 1 ON LINE 228
attach_list: entry;

001227  da     000454200000
001230  aa   002100 6270 00	eax7 	1088
001231  aa  7 00034 3521 20	epp2 	pr7|28,*
001232  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001233  aa     000000000000
001234  aa     000000000000
001235  aa   777337 7000 04	tsx0 	-289,ic		000574
						STATEMENT 1 ON LINE 230
	if ^initialized then do;

001236  aa  6 00044 3701 20	epp4 	pr6|36,*
001237  ia  4 00012 2351 00	lda  	pr4|10		initialized
001240  aa   000015 6010 04	tnz  	13,ic		001255
						STATEMENT 1 ON LINE 231
	     call ioa_ ("lv_request_: Logical volume software has not been initialized.");

001241  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001242  aa   777247 00 0100	desc9a	-345,64		000510 = 154166137162
001243  aa  6 01376 00 0100	desc9a	pr6|766,64
001244  aa  6 01376 3521 00	epp2 	pr6|766
001245  aa  6 01334 2521 00	spri2	pr6|732
001246  aa   776623 3520 04	epp2 	-621,ic		000071 = 524000000076
001247  aa  6 01336 2521 00	spri2	pr6|734
001250  aa  6 01332 6211 00	eax1 	pr6|730
001251  aa   004000 4310 07	fld  	2048,dl
001252  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
001253  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 232
	     return;

001254  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 233
	end;

						STATEMENT 1 ON LINE 237
	call cu_$arg_count (nargs, ec);

001255  aa  6 00454 3521 00	epp2 	pr6|300		nargs
001256  aa  6 01334 2521 00	spri2	pr6|732
001257  aa  6 00427 3521 00	epp2 	pr6|279		ec
001260  aa  6 01336 2521 00	spri2	pr6|734
001261  aa  6 01332 6211 00	eax1 	pr6|730
001262  aa   010000 4310 07	fld  	4096,dl
001263  la  4 00024 3521 20	epp2 	pr4|20,*		cu_$arg_count
001264  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 238
	if ec ^= 0 then do;

001265  aa  6 00427 2361 00	ldq  	pr6|279		ec
001266  aa   000033 6000 04	tze  	27,ic		001321
						STATEMENT 1 ON LINE 239
	     call com_err_ (ec, "lv_request_", "Getting argument count.");

001267  aa   776644 2350 04	lda  	-604,ic		000133 = 154166137162
001270  aa   776644 2360 04	ldq  	-604,ic		000134 = 145161165145
001271  aa  6 01332 7571 00	staq 	pr6|730
001272  aa   776643 2350 04	lda  	-605,ic		000135 = 163164137000
001273  aa  6 01334 7551 00	sta  	pr6|732
001274  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001275  aa   776725 00 0030	desc9a	-555,24		000221 = 107145164164
001276  aa  6 01344 00 0030	desc9a	pr6|740,24
001277  aa  6 00427 3521 00	epp2 	pr6|279		ec
001300  aa  6 01400 2521 00	spri2	pr6|768
001301  aa  6 01332 3521 00	epp2 	pr6|730
001302  aa  6 01402 2521 00	spri2	pr6|770
001303  aa  6 01344 3521 00	epp2 	pr6|740
001304  aa  6 01404 2521 00	spri2	pr6|772
001305  aa   776573 3520 04	epp2 	-645,ic		000100 = 404000000043
001306  aa  6 01406 2521 00	spri2	pr6|774
001307  aa   776570 3520 04	epp2 	-648,ic		000077 = 524000000013
001310  aa  6 01410 2521 00	spri2	pr6|776
001311  aa   776557 3520 04	epp2 	-657,ic		000070 = 524000000027
001312  aa  6 01412 2521 00	spri2	pr6|778
001313  aa  6 01376 6211 00	eax1 	pr6|766
001314  aa   014000 4310 07	fld  	6144,dl
001315  aa  6 00044 3701 20	epp4 	pr6|36,*
001316  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001317  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 240
	     return;

001320  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 241
	end;

						STATEMENT 1 ON LINE 242
	if nargs < 1 then do;

001321  aa  6 00454 2361 00	ldq  	pr6|300		nargs
001322  aa   000001 1160 07	cmpq 	1,dl
001323  aa   000033 6050 04	tpl  	27,ic		001356
						STATEMENT 1 ON LINE 243
	     call com_err_ (error_table_$noarg, "lv_request_", "Logical volume name or -all.");

001324  aa   776607 2350 04	lda  	-633,ic		000133 = 154166137162
001325  aa   776607 2360 04	ldq  	-633,ic		000134 = 145161165145
001326  aa  6 01332 7571 00	staq 	pr6|730
001327  aa   776606 2350 04	lda  	-634,ic		000135 = 163164137000
001330  aa  6 01334 7551 00	sta  	pr6|732
001331  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001332  aa   776732 00 0034	desc9a	-550,28		000263 = 114157147151
001333  aa  6 01344 00 0034	desc9a	pr6|740,28
001334  aa  6 00044 3701 20	epp4 	pr6|36,*
001335  la  4 00044 3521 20	epp2 	pr4|36,*		error_table_$noarg
001336  aa  6 01400 2521 00	spri2	pr6|768
001337  aa  6 01332 3521 00	epp2 	pr6|730
001340  aa  6 01402 2521 00	spri2	pr6|770
001341  aa  6 01344 3521 00	epp2 	pr6|740
001342  aa  6 01404 2521 00	spri2	pr6|772
001343  aa   776535 3520 04	epp2 	-675,ic		000100 = 404000000043
001344  aa  6 01406 2521 00	spri2	pr6|774
001345  aa   776532 3520 04	epp2 	-678,ic		000077 = 524000000013
001346  aa  6 01410 2521 00	spri2	pr6|776
001347  aa   776520 3520 04	epp2 	-688,ic		000067 = 524000000034
001350  aa  6 01412 2521 00	spri2	pr6|778
001351  aa  6 01376 6211 00	eax1 	pr6|766
001352  aa   014000 4310 07	fld  	6144,dl
001353  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001354  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 244
	     return;

001355  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 245
	end;

						STATEMENT 1 ON LINE 247
	list_all_vols = FALSE;

001356  aa  6 00434 4501 00	stz  	pr6|284		list_all_vols
						STATEMENT 1 ON LINE 248
	n_vols_to_list = 0;

001357  aa  6 00453 4501 00	stz  	pr6|299		n_vols_to_list
						STATEMENT 1 ON LINE 249
	do argx = 1 to nargs;

001360  aa  6 01220 7561 00	stq  	pr6|656
001361  aa   000001 2360 07	ldq  	1,dl
001362  aa  6 00104 7561 00	stq  	pr6|68		argx
001363  aa   000000 0110 03	nop  	0,du
001364  aa  6 00104 2361 00	ldq  	pr6|68		argx
001365  aa  6 01220 1161 00	cmpq 	pr6|656
001366  aa   000136 6054 04	tpnz 	94,ic		001524
						STATEMENT 1 ON LINE 250
	     call cu_$arg_ptr (argx, argp, argl, ec);

001367  aa  6 00104 3521 00	epp2 	pr6|68		argx
001370  aa  6 01346 2521 00	spri2	pr6|742
001371  aa  6 00102 3521 00	epp2 	pr6|66		argp
001372  aa  6 01350 2521 00	spri2	pr6|744
001373  aa  6 00100 3521 00	epp2 	pr6|64		argl
001374  aa  6 01352 2521 00	spri2	pr6|746
001375  aa  6 00427 3521 00	epp2 	pr6|279		ec
001376  aa  6 01354 2521 00	spri2	pr6|748
001377  aa  6 01344 6211 00	eax1 	pr6|740
001400  aa   020000 4310 07	fld  	8192,dl
001401  aa  6 00044 3701 20	epp4 	pr6|36,*
001402  la  4 00026 3521 20	epp2 	pr4|22,*		cu_$arg_ptr
001403  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 251
	     if ec ^= 0 then do;

001404  aa  6 00427 2361 00	ldq  	pr6|279		ec
001405  aa   000040 6000 04	tze  	32,ic		001445
						STATEMENT 1 ON LINE 252
		call com_err_ (ec, "lv_request_", "Getting arg ^d.", argx);

001406  aa   776525 2350 04	lda  	-683,ic		000133 = 154166137162
001407  aa   776525 2360 04	ldq  	-683,ic		000134 = 145161165145
001410  aa  6 01332 7571 00	staq 	pr6|730
001411  aa   776524 2350 04	lda  	-684,ic		000135 = 163164137000
001412  aa  6 01334 7551 00	sta  	pr6|732
001413  aa   776533 2370 04	ldaq 	-677,ic		000146 = 107145164164 151156147040
001414  aa  6 01344 7571 00	staq 	pr6|740
001415  aa   776533 2370 04	ldaq 	-677,ic		000150 = 141162147040 136144056000
001416  aa  6 01346 7571 00	staq 	pr6|742
001417  aa  6 00427 3521 00	epp2 	pr6|279		ec
001420  aa  6 01400 2521 00	spri2	pr6|768
001421  aa  6 01332 3521 00	epp2 	pr6|730
001422  aa  6 01402 2521 00	spri2	pr6|770
001423  aa  6 01344 3521 00	epp2 	pr6|740
001424  aa  6 01404 2521 00	spri2	pr6|772
001425  aa  6 00104 3521 00	epp2 	pr6|68		argx
001426  aa  6 01406 2521 00	spri2	pr6|774
001427  aa   776451 3520 04	epp2 	-727,ic		000100 = 404000000043
001430  aa  6 01410 2521 00	spri2	pr6|776
001431  aa   776446 3520 04	epp2 	-730,ic		000077 = 524000000013
001432  aa  6 01412 2521 00	spri2	pr6|778
001433  aa   776433 3520 04	epp2 	-741,ic		000066 = 524000000017
001434  aa  6 01414 2521 00	spri2	pr6|780
001435  aa   776446 3520 04	epp2 	-730,ic		000103 = 404000000021
001436  aa  6 01416 2521 00	spri2	pr6|782
001437  aa  6 01376 6211 00	eax1 	pr6|766
001440  aa   020000 4310 07	fld  	8192,dl
001441  aa  6 00044 3701 20	epp4 	pr6|36,*
001442  la  4 00020 3521 20	epp2 	pr4|16,*		com_err_
001443  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 253
		return;

001444  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 254
	     end;

						STATEMENT 1 ON LINE 255
	     if arg = "-all" | arg = "-a" then list_all_vols = TRUE;

001445  aa  6 00102 3735 20	epp7 	pr6|66,*		argp
001446  aa  6 00100 2351 00	lda  	pr6|64		argl
001447  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001450  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
001451  aa   776416 00 0004	desc9a	-754,4		000065 = 055141154154
001452  aa   000005 6000 04	tze  	5,ic		001457
001453  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001454  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
001455  aa   003505 00 0002	desc9a	1861,2		005160 = 055141000000
001456  aa   000004 6010 04	tnz  	4,ic		001462
001457  aa   400000 2350 03	lda  	131072,du
001460  aa  6 00434 7551 00	sta  	pr6|284		list_all_vols
001461  aa   000041 7100 04	tra  	33,ic		001522
						STATEMENT 1 ON LINE 256
	     else do;

						STATEMENT 1 ON LINE 257
		n_vols_to_list = n_vols_to_list + 1;

001462  aa  6 00453 0541 00	aos  	pr6|299		n_vols_to_list
						STATEMENT 1 ON LINE 258
		if n_vols_to_list ^> hbound (vols_to_list, 1)
		     then vols_to_list (n_vols_to_list) = arg;

001463  aa  6 00453 2361 00	ldq  	pr6|299		n_vols_to_list
001464  aa   000012 1160 07	cmpq 	10,dl
001465  aa   000010 6054 04	tpnz 	8,ic		001475
001466  aa   000003 7360 00	qls  	3
001467  aa  6 00557 3715 06	epp5 	pr6|367,ql	vols_to_list
001470  aa  6 00100 2351 00	lda  	pr6|64		argl
001471  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001472  aa  7 00000 00 0005	desc9a	pr7|0,al		arg
001473  aa  5 00000 00 0040	desc9a	pr5|0,32		vols_to_list
001474  aa   000026 7100 04	tra  	22,ic		001522
						STATEMENT 1 ON LINE 260
		else do;

						STATEMENT 1 ON LINE 261
		     call ioa_ ("lv_request_: Too many LVs specified. All LVs past ""^a"" will be ignored.", vols_to_list (n_vols_to_list - 1));

001475  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001476  aa   777055 00 0110	desc9a	-467,72		000552 = 154166137162
001477  aa  6 01376 00 0110	desc9a	pr6|766,72
001500  aa   000003 7360 00	qls  	3
001501  aa  6 01376 3521 00	epp2 	pr6|766
001502  aa  6 01346 2521 00	spri2	pr6|742
001503  aa  6 00547 3521 06	epp2 	pr6|359,ql	vols_to_list
001504  aa  6 01350 2521 00	spri2	pr6|744
001505  aa   776357 3520 04	epp2 	-785,ic		000064 = 524000000107
001506  aa  6 01352 2521 00	spri2	pr6|746
001507  aa   776366 3520 04	epp2 	-778,ic		000075 = 526000000040
001510  aa  6 01354 2521 00	spri2	pr6|748
001511  aa  6 01344 6211 00	eax1 	pr6|740
001512  aa   010000 4310 07	fld  	4096,dl
001513  aa  6 00044 3701 20	epp4 	pr6|36,*
001514  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
001515  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 262
		     argx = nargs;

001516  aa  6 00454 2361 00	ldq  	pr6|300		nargs
001517  aa  6 00104 7561 00	stq  	pr6|68		argx
						STATEMENT 1 ON LINE 263
		     n_vols_to_list = hbound (vols_to_list, 1);

001520  aa   000012 2360 07	ldq  	10,dl
001521  aa  6 00453 7561 00	stq  	pr6|299		n_vols_to_list
						STATEMENT 1 ON LINE 264
		end;

						STATEMENT 1 ON LINE 265
	     end;

						STATEMENT 1 ON LINE 266
	end;

001522  aa  6 00104 0541 00	aos  	pr6|68		argx
001523  aa   777641 7100 04	tra  	-95,ic		001364
						STATEMENT 1 ON LINE 268
	dtp = disk_table_$get_dtp ();

001524  aa  6 01204 3521 00	epp2 	pr6|644		dtp
001525  aa  6 01334 2521 00	spri2	pr6|732
001526  aa  6 01332 6211 00	eax1 	pr6|730
001527  aa   004000 4310 07	fld  	2048,dl
001530  aa  6 00044 3701 20	epp4 	pr6|36,*
001531  la  4 00040 3521 20	epp2 	pr4|32,*		disk_table_$get_dtp
001532  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 270
	shown_lvat_header = "0"b;

001533  aa  6 00462 4501 00	stz  	pr6|306		shown_lvat_header
						STATEMENT 1 ON LINE 271
	if list_all_vols then
	     do lvx = 1 to dt.n_lv_entries;

001534  aa  6 00434 2351 00	lda  	pr6|284		list_all_vols
001535  aa   000041 6000 04	tze  	33,ic		001576
001536  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
001537  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
001540  aa  6 01221 7561 00	stq  	pr6|657
001541  aa   000001 2360 07	ldq  	1,dl
001542  aa  6 00446 7561 00	stq  	pr6|294		lvx
001543  aa   000000 0110 03	nop  	0,du
001544  aa  6 00446 2361 00	ldq  	pr6|294		lvx
001545  aa  6 01221 1161 00	cmpq 	pr6|657
001546  aa   000123 6054 04	tpnz 	83,ic		001671
						STATEMENT 1 ON LINE 273
	     if dt.lv_array (lvx).used then do;

001547  aa   000016 4020 07	mpy  	14,dl
001550  aa  6 01421 7561 00	stq  	pr6|785
001551  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
001552  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
001553  aa   000016 4020 07	mpy  	14,dl
001554  aa   000010 0760 07	adq  	8,dl
001555  aa  6 01375 7561 00	stq  	pr6|765
001556  aa   000001 0760 07	adq  	1,dl
001557  aa  6 01421 0761 00	adq  	pr6|785
001560  aa  7 77762 2351 06	lda  	pr7|-14,ql	dt.used
001561  aa   400000 3150 03	cana 	131072,du
001562  aa   000011 6000 04	tze  	9,ic		001573
						STATEMENT 1 ON LINE 274
		lvname = dt.lv_array (lvx).lvname;

001563  aa  6 01375 2361 00	ldq  	pr6|765
001564  aa   000002 0760 07	adq  	2,dl
001565  aa  6 01421 0761 00	adq  	pr6|785
001566  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lvname
001567  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001570  aa  5 00000 00 0040	desc9a	pr5|0,32		dt.lvname
001571  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 275
		call list_vol_attachments;

001572  aa   001726 6700 04	tsp4 	982,ic		003520
						STATEMENT 1 ON LINE 276
	     end;

						STATEMENT 1 ON LINE 277
	end;

001573  aa  6 00446 0541 00	aos  	pr6|294		lvx
001574  aa   777750 7100 04	tra  	-24,ic		001544
001575  aa   000074 7100 04	tra  	60,ic		001671
						STATEMENT 1 ON LINE 279
	else do vtlx = 1 to n_vols_to_list;

001576  aa  6 00453 2361 00	ldq  	pr6|299		n_vols_to_list
001577  aa  6 01222 7561 00	stq  	pr6|658
001600  aa   000001 2360 07	ldq  	1,dl
001601  aa  6 00707 7561 00	stq  	pr6|455		vtlx
001602  aa  6 00707 2361 00	ldq  	pr6|455		vtlx
001603  aa  6 01222 1161 00	cmpq 	pr6|658
001604  aa   000065 6054 04	tpnz 	53,ic		001671
						STATEMENT 1 ON LINE 280
	     lvname = vols_to_list (vtlx);

001605  aa   000003 7360 00	qls  	3
001606  aa  6 00557 3735 06	epp7 	pr6|367,ql	vols_to_list
001607  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001610  aa  7 00000 00 0040	desc9a	pr7|0,32		vols_to_list
001611  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 281
	     do lvx = 1 to dt.n_lv_entries
		while (lvname ^= dt.lv_array (lvx).lvname);

001612  aa  6 01204 3715 20	epp5 	pr6|644,*		dtp
001613  aa  5 00005 2361 00	ldq  	pr5|5		dt.n_lv_entries
001614  aa  6 01223 7561 00	stq  	pr6|659
001615  aa   000001 2360 07	ldq  	1,dl
001616  aa  6 00446 7561 00	stq  	pr6|294		lvx
001617  aa   000000 0110 03	nop  	0,du
001620  aa  6 00446 2361 00	ldq  	pr6|294		lvx
001621  aa  6 01223 1161 00	cmpq 	pr6|659
001622  aa   000017 6054 04	tpnz 	15,ic		001641
001623  aa   000016 4020 07	mpy  	14,dl
001624  aa  6 01421 7561 00	stq  	pr6|785
001625  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
001626  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
001627  aa   000016 4020 07	mpy  	14,dl
001630  aa   000012 0760 07	adq  	10,dl
001631  aa  6 01421 0761 00	adq  	pr6|785
001632  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lvname
001633  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
001634  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
001635  aa  5 00000 00 0040	desc9a	pr5|0,32		dt.lvname
001636  aa   000003 6000 04	tze  	3,ic		001641
						STATEMENT 1 ON LINE 283
	     end;

001637  aa  6 00446 0541 00	aos  	pr6|294		lvx
001640  aa   777760 7100 04	tra  	-16,ic		001620
						STATEMENT 1 ON LINE 284
	     if lvx ^> dt.n_lv_entries then
		call list_vol_attachments;

001641  aa  6 00446 2361 00	ldq  	pr6|294		lvx
001642  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
001643  aa  7 00005 1161 00	cmpq 	pr7|5		dt.n_lv_entries
001644  aa   000003 6054 04	tpnz 	3,ic		001647
001645  aa   001653 6700 04	tsp4 	939,ic		003520
001646  aa   000021 7100 04	tra  	17,ic		001667
						STATEMENT 1 ON LINE 286
	     else call ioa_ ("^/LV ""^a"" is not defined.", lvname);

001647  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001650  aa   776405 00 0034	desc9a	-763,28		000254 = 136057114126
001651  aa  6 01344 00 0034	desc9a	pr6|740,28
001652  aa  6 01344 3521 00	epp2 	pr6|740
001653  aa  6 01362 2521 00	spri2	pr6|754
001654  aa  6 00436 3521 00	epp2 	pr6|286		lvname
001655  aa  6 01364 2521 00	spri2	pr6|756
001656  aa   776205 3520 04	epp2 	-891,ic		000063 = 524000000031
001657  aa  6 01366 2521 00	spri2	pr6|758
001660  aa   776215 3520 04	epp2 	-883,ic		000075 = 526000000040
001661  aa  6 01370 2521 00	spri2	pr6|760
001662  aa  6 01360 6211 00	eax1 	pr6|752
001663  aa   010000 4310 07	fld  	4096,dl
001664  aa  6 00044 3701 20	epp4 	pr6|36,*
001665  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
001666  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 287
	end;

001667  aa  6 00707 0541 00	aos  	pr6|455		vtlx
001670  aa   777712 7100 04	tra  	-54,ic		001602
						STATEMENT 1 ON LINE 289
	if list_all_vols & ^shown_lvat_header then
	     call ioa_ ("^/No LV Attachments.");

001671  aa  6 00434 2351 00	lda  	pr6|284		list_all_vols
001672  aa   000022 6000 04	tze  	18,ic		001714
001673  aa  6 00462 2351 00	lda  	pr6|306		shown_lvat_header
001674  aa   000020 6010 04	tnz  	16,ic		001714
001675  aa   776311 2370 04	ldaq 	-823,ic		000206 = 136057116157 040114126040
001676  aa  6 01332 7571 00	staq 	pr6|730
001677  aa   776311 2370 04	ldaq 	-823,ic		000210 = 101164164141 143150155145
001700  aa  6 01334 7571 00	staq 	pr6|732
001701  aa   776311 2350 04	lda  	-823,ic		000212 = 156164163056
001702  aa  6 01336 7551 00	sta  	pr6|734
001703  aa  6 01332 3521 00	epp2 	pr6|730
001704  aa  6 01346 2521 00	spri2	pr6|742
001705  aa   776155 3520 04	epp2 	-915,ic		000062 = 524000000024
001706  aa  6 01350 2521 00	spri2	pr6|744
001707  aa  6 01344 6211 00	eax1 	pr6|740
001710  aa   004000 4310 07	fld  	2048,dl
001711  aa  6 00044 3701 20	epp4 	pr6|36,*
001712  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
001713  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 291
	return;

001714  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO cleanup_process                                    STATEMENT 1 ON LINE 330
cleanup_process: entry (a_pid);

001715  at     000001000104
001716  ta     001715000000
001717  da     000463300000
001720  aa   002100 6270 00	eax7 	1088
001721  aa  7 00034 3521 20	epp2 	pr7|28,*
001722  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001723  aa     000002000000
001724  aa     000000000000
001725  aa   776647 7000 04	tsx0 	-601,ic		000574
						STATEMENT 1 ON LINE 332
	if ^initialized then return;

001726  aa  6 00044 3701 20	epp4 	pr6|36,*
001727  ia  4 00012 2351 00	lda  	pr4|10		initialized
001730  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 333
	call find_u (a_pid);

001731  aa  6 00032 3735 20	epp7 	pr6|26,*
001732  aa  7 00002 3521 20	epp2 	pr7|2,*		a_pid
001733  aa  6 01334 2521 00	spri2	pr6|732
001734  aa  6 01332 3521 00	epp2 	pr6|730
001735  aa   004000 4310 07	fld  	2048,dl
001736  aa  2 00000 7571 00	staq 	pr2|0
001737  aa   002261 6700 04	tsp4 	1201,ic		004220
						STATEMENT 1 ON LINE 334
	pid = a_pid;

001740  aa  6 00032 3735 20	epp7 	pr6|26,*
001741  aa  7 00002 2351 20	lda  	pr7|2,*		a_pid
001742  aa  6 00460 7551 00	sta  	pr6|304		pid
						STATEMENT 1 ON LINE 335
	call initializer_mdc_$scan_process_lvat (pid, array, n);

001743  aa  6 00460 3521 00	epp2 	pr6|304		pid
001744  aa  6 01400 2521 00	spri2	pr6|768
001745  aa  6 00105 3521 00	epp2 	pr6|69		array
001746  aa  6 01402 2521 00	spri2	pr6|770
001747  aa  6 00433 3521 00	epp2 	pr6|283		n
001750  aa  6 01404 2521 00	spri2	pr6|772
001751  aa   776133 3520 04	epp2 	-933,ic		000104 = 514000000044
001752  aa  6 01406 2521 00	spri2	pr6|774
001753  aa   776177 3520 04	epp2 	-897,ic		000152 = 404100000021
001754  aa  6 01410 2521 00	spri2	pr6|776
001755  aa   776126 3520 04	epp2 	-938,ic		000103 = 404000000021
001756  aa  6 01412 2521 00	spri2	pr6|778
001757  aa  6 01376 6211 00	eax1 	pr6|766
001760  aa   014000 4310 07	fld  	6144,dl
001761  aa  6 00044 3701 20	epp4 	pr6|36,*
001762  la  4 00100 3521 20	epp2 	pr4|64,*		initializer_mdc_$scan_process_lvat
001763  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 337
	do i = 1 to n;

001764  aa  6 00433 2361 00	ldq  	pr6|283		n
001765  aa  6 01224 7561 00	stq  	pr6|660
001766  aa   000001 2360 07	ldq  	1,dl
001767  aa  6 00432 7561 00	stq  	pr6|282		i
001770  aa  6 00432 2361 00	ldq  	pr6|282		i
001771  aa  6 01224 1161 00	cmpq 	pr6|660
001772  aa   000026 6054 04	tpnz 	22,ic		002020
						STATEMENT 1 ON LINE 339
	     lvax = array (i);

001773  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
001774  aa  6 00435 7561 00	stq  	pr6|285		lvax
						STATEMENT 1 ON LINE 340
	     call get (lvax);

001775  aa   003153 3520 04	epp2 	1643,ic		005150 = 000002000000
001776  aa   002202 6700 04	tsp4 	1154,ic		004200
						STATEMENT 1 ON LINE 341
	     lvname = lvate.lvname;

001777  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
002000  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002001  aa  7 00003 00 0040	desc9a	pr7|3,32		lvate.lvname
002002  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 342
	     if lvate.mounted then call detach;

002003  aa  7 00016 2351 00	lda  	pr7|14		lvate.mounted
002004  aa   040000 3150 03	cana 	16384,du
002005  aa   000002 6000 04	tze  	2,ic		002007
002006  aa   002107 6700 04	tsp4 	1095,ic		004115
						STATEMENT 1 ON LINE 343
	     call initializer_mdc_$free_lvate (lvax);

002007  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002010  aa  6 01334 2521 00	spri2	pr6|732
002011  aa  6 01332 6211 00	eax1 	pr6|730
002012  aa   004000 4310 07	fld  	2048,dl
002013  aa  6 00044 3701 20	epp4 	pr6|36,*
002014  la  4 00060 3521 20	epp2 	pr4|48,*		initializer_mdc_$free_lvate
002015  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 344
	end;

002016  aa  6 00432 0541 00	aos  	pr6|282		i
002017  aa   777751 7100 04	tra  	-23,ic		001770
						STATEMENT 1 ON LINE 345
	return;

002020  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO mhv_complete                                       STATEMENT 1 ON LINE 349
mhv_complete: entry (a_lvx, a_dtp);

002021  at     000002000103
002022  ta     000105000000
002023  ta     002021000000
002024  da     000472300000
002025  aa   002100 6270 00	eax7 	1088
002026  aa  7 00034 3521 20	epp2 	pr7|28,*
002027  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002030  aa     000004000000
002031  aa     000000000000
002032  aa   776542 7000 04	tsx0 	-670,ic		000574
						STATEMENT 1 ON LINE 351
	if ^initialized then return;

002033  aa  6 00044 3701 20	epp4 	pr6|36,*
002034  ia  4 00012 2351 00	lda  	pr4|10		initialized
002035  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 352
	lvx = a_lvx;

002036  aa  6 00032 3735 20	epp7 	pr6|26,*
002037  aa  7 00002 2361 20	ldq  	pr7|2,*		a_lvx
002040  aa  6 00446 7561 00	stq  	pr6|294		lvx
						STATEMENT 1 ON LINE 353
	lvname = a_lvname;

002041  aa  7 00002 3715 20	epp5 	pr7|2,*
002042  aa  6 01420 2351 00	lda  	pr6|784
002043  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002044  aa  5 00000 00 0005	desc9a	pr5|0,al		a_lvname
002045  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 354
	dtp = a_dtp;

002046  aa  7 00004 3535 20	epp3 	pr7|4,*		a_dtp
002047  aa  3 00000 3535 20	epp3 	pr3|0,*		a_dtp
002050  aa  6 01204 2535 00	spri3	pr6|644		dtp
						STATEMENT 1 ON LINE 355
	lvep = addr (dt.lv_array (lvx));

002051  aa   000016 4020 07	mpy  	14,dl
002052  aa  6 01421 7561 00	stq  	pr6|785
002053  aa  3 00001 2361 00	ldq  	pr3|1		dt.max_n_entries
002054  aa   000016 4020 07	mpy  	14,dl
002055  aa   000010 0760 07	adq  	8,dl
002056  aa  6 01421 0761 00	adq  	pr6|785
002057  aa  3 77762 3515 06	epp1 	pr3|-14,ql	dt.lv_array
002060  aa  6 01210 2515 00	spri1	pr6|648		lvep
						STATEMENT 1 ON LINE 356
	lvname = lve.lvname;

002061  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002062  aa  1 00002 00 0040	desc9a	pr1|2,32		lve.lvname
002063  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 358
	call initializer_mdc_$lvat_scan_lv (lvname, array, n);

002064  aa  6 00436 3521 00	epp2 	pr6|286		lvname
002065  aa  6 01400 2521 00	spri2	pr6|768
002066  aa  6 00105 3521 00	epp2 	pr6|69		array
002067  aa  6 01402 2521 00	spri2	pr6|770
002070  aa  6 00433 3521 00	epp2 	pr6|283		n
002071  aa  6 01404 2521 00	spri2	pr6|772
002072  aa   776003 3520 04	epp2 	-1021,ic		000075 = 526000000040
002073  aa  6 01406 2521 00	spri2	pr6|774
002074  aa   776056 3520 04	epp2 	-978,ic		000152 = 404100000021
002075  aa  6 01410 2521 00	spri2	pr6|776
002076  aa   776005 3520 04	epp2 	-1019,ic		000103 = 404000000021
002077  aa  6 01412 2521 00	spri2	pr6|778
002100  aa  6 01376 6211 00	eax1 	pr6|766
002101  aa   014000 4310 07	fld  	6144,dl
002102  la  4 00066 3521 20	epp2 	pr4|54,*		initializer_mdc_$lvat_scan_lv
002103  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 359
	do i = 1 to n;

002104  aa  6 00433 2361 00	ldq  	pr6|283		n
002105  aa  6 01225 7561 00	stq  	pr6|661
002106  aa   000001 2360 07	ldq  	1,dl
002107  aa  6 00432 7561 00	stq  	pr6|282		i
002110  aa  6 00432 2361 00	ldq  	pr6|282		i
002111  aa  6 01225 1161 00	cmpq 	pr6|661
002112  aa   000053 6054 04	tpnz 	43,ic		002165
						STATEMENT 1 ON LINE 360
	     lvax = array (i);

002113  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
002114  aa  6 00435 7561 00	stq  	pr6|285		lvax
						STATEMENT 1 ON LINE 361
	     call get (lvax);

002115  aa   003033 3520 04	epp2 	1563,ic		005150 = 000002000000
002116  aa   002062 6700 04	tsp4 	1074,ic		004200
						STATEMENT 1 ON LINE 362
	     if lvate.pending_mount then do;

002117  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
002120  aa  7 00016 2351 00	lda  	pr7|14		lvate.pending_mount
002121  aa   400000 3150 03	cana 	131072,du
002122  aa   000041 6000 04	tze  	33,ic		002163
						STATEMENT 1 ON LINE 363
		call find_u (lvate.pid);

002123  aa  7 00000 3521 00	epp2 	pr7|0		lvate.pid
002124  aa  6 01334 2521 00	spri2	pr6|732
002125  aa  6 01332 3521 00	epp2 	pr6|730
002126  aa   004000 4310 07	fld  	2048,dl
002127  aa  2 00000 7571 00	staq 	pr2|0
002130  aa   002070 6700 04	tsp4 	1080,ic		004220
						STATEMENT 1 ON LINE 364
		call initializer_mdc_$respond_mount_lv (lvax, 1, 0, ec);

002131  aa   000001 2360 07	ldq  	1,dl
002132  aa  6 01421 7561 00	stq  	pr6|785
002133  aa  6 01375 4501 00	stz  	pr6|765
002134  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002135  aa  6 01346 2521 00	spri2	pr6|742
002136  aa  6 01421 3521 00	epp2 	pr6|785
002137  aa  6 01350 2521 00	spri2	pr6|744
002140  aa  6 01375 3521 00	epp2 	pr6|765
002141  aa  6 01352 2521 00	spri2	pr6|746
002142  aa  6 00427 3521 00	epp2 	pr6|279		ec
002143  aa  6 01354 2521 00	spri2	pr6|748
002144  aa  6 01344 6211 00	eax1 	pr6|740
002145  aa   020000 4310 07	fld  	8192,dl
002146  aa  6 00044 3701 20	epp4 	pr6|36,*
002147  la  4 00074 3521 20	epp2 	pr4|60,*		initializer_mdc_$respond_mount_lv
002150  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 365
		if ec ^= 0 then call beef ("Sending mount ready message");

002151  aa  6 00427 2361 00	ldq  	pr6|279		ec
002152  aa   000010 6000 04	tze  	8,ic		002162
002153  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002154  aa   776072 00 0034	desc9a	-966,28		000245 = 123145156144
002155  aa  6 01344 00 0034	desc9a	pr6|740,28
002156  aa   002756 3520 04	epp2 	1518,ic		005134 = 000002000000
002157  aa  2 00000 2351 00	lda  	pr2|0
002160  aa   001565 6700 04	tsp4 	885,ic		003745
002161  aa   000002 7100 04	tra  	2,ic		002163
						STATEMENT 1 ON LINE 366
		else call attach;

002162  aa   001650 6700 04	tsp4 	936,ic		004032
						STATEMENT 1 ON LINE 367
	     end;

						STATEMENT 1 ON LINE 368
	end;

002163  aa  6 00432 0541 00	aos  	pr6|282		i
002164  aa   777724 7100 04	tra  	-44,ic		002110
						STATEMENT 1 ON LINE 369
	return;

002165  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 374
interrupt:

	ev_calls_masked = "0"b;

002166  aa  6 00431 4501 00	stz  	pr6|281		ev_calls_masked
						STATEMENT 1 ON LINE 378
	call condition_ ("any_other", any_other_handler);

002167  aa   775741 2370 04	ldaq 	-1055,ic		000130 = 141156171137 157164150145
002170  aa  6 01332 7571 00	staq 	pr6|730
002171  aa   162000 2350 03	lda  	58368,du
002172  aa  6 01334 7551 00	sta  	pr6|732
002173  aa   002232 3520 04	epp2 	1178,ic		004425 = 000140627000
002174  aa  6 01344 2521 00	spri2	pr6|740		cp.316
002175  aa  6 01346 6521 00	spri6	pr6|742		cp.316
002176  aa  6 01332 3521 00	epp2 	pr6|730
002177  aa  6 01362 2521 00	spri2	pr6|754
002200  aa  6 01344 3521 00	epp2 	pr6|740		cp.316
002201  aa  6 01364 2521 00	spri2	pr6|756
002202  aa   775656 3520 04	epp2 	-1106,ic		000060 = 524000000011
002203  aa  6 01366 2521 00	spri2	pr6|758
002204  aa   775653 3520 04	epp2 	-1109,ic		000057 = 500000000000
002205  aa  6 01370 2521 00	spri2	pr6|760
002206  aa  6 01360 6211 00	eax1 	pr6|752
002207  aa   010000 4310 07	fld  	4096,dl
002210  aa  6 00044 3701 20	epp4 	pr6|36,*
002211  la  4 00022 3521 20	epp2 	pr4|18,*		condition_
002212  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 380
	if ^ (evmessage.sender = myprocessid | evmessage.ring = LV_RING) then do;

002213  aa  6 00032 3735 20	epp7 	pr6|26,*
002214  aa  7 00002 3715 20	epp5 	pr7|2,*		msgp
002215  aa  5 00000 3715 20	epp5 	pr5|0,*		msgp
002216  aa  5 00004 2351 00	lda  	pr5|4		evmessage.sender
002217  aa  6 00044 3701 20	epp4 	pr6|36,*
002220  ia  4 00013 1151 00	cmpa 	pr4|11		myprocessid
002221  aa   000062 6000 04	tze  	50,ic		002303
002222  aa  5 00005 2351 00	lda  	pr5|5		evmessage.ring
002223  aa   000022 7350 00	als  	18
002224  aa   000066 7330 00	lrs  	54
002225  ia  4 00010 1161 00	cmpq 	pr4|8		LV_RING
002226  aa   000055 6000 04	tze  	45,ic		002303
						STATEMENT 1 ON LINE 381
	     call find_u (evmessage.sender);

002227  aa  5 00004 3521 00	epp2 	pr5|4		evmessage.sender
002230  aa  6 01334 2521 00	spri2	pr6|732
002231  aa  6 01332 3521 00	epp2 	pr6|730
002232  aa   004000 4310 07	fld  	2048,dl
002233  aa  2 00000 7571 00	staq 	pr2|0
002234  aa   001764 6700 04	tsp4 	1012,ic		004220
						STATEMENT 1 ON LINE 382
	     call sys_log_ (SL0,
		"lv_request_: Spurious wakeup ^24.3b received from ^a ^12.3b ^d",
		evmessage.bits, user_procname, user_procid,
		evmessage.ring);

002235  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002236  aa   776233 00 0100	desc9a	-869,64		000470 = 154166137162
002237  aa  6 01376 00 0100	desc9a	pr6|766,64
002240  aa  6 00044 3701 20	epp4 	pr6|36,*
002241  ia  4 00011 3521 00	epp2 	pr4|9		SL0
002242  aa  6 01452 2521 00	spri2	pr6|810
002243  aa  6 01376 3521 00	epp2 	pr6|766
002244  aa  6 01454 2521 00	spri2	pr6|812
002245  aa  6 00032 3735 20	epp7 	pr6|26,*
002246  aa  7 00002 3715 20	epp5 	pr7|2,*		msgp
002247  aa  5 00000 3715 20	epp5 	pr5|0,*		msgp
002250  aa  5 00002 3521 00	epp2 	pr5|2		evmessage.bits
002251  aa  6 01456 2521 00	spri2	pr6|814
002252  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
002253  aa  6 01460 2521 00	spri2	pr6|816
002254  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
002255  aa  6 01462 2521 00	spri2	pr6|818
002256  aa   000022 7270 07	lxl7 	18,dl
002257  aa  5 00005 3521 00	epp2 	pr5|5		evmessage.ring
002260  aa  2 00000 5035 17	abd  	pr2|0,7
002261  aa  6 01464 2521 00	spri2	pr6|820
002262  aa   775621 3520 04	epp2 	-1135,ic		000103 = 404000000021
002263  aa  6 01466 2521 00	spri2	pr6|822
002264  aa   775605 3520 04	epp2 	-1147,ic		000071 = 524000000076
002265  aa  6 01470 2521 00	spri2	pr6|824
002266  aa   775570 3520 04	epp2 	-1160,ic		000056 = 514000000110
002267  aa  6 01472 2521 00	spri2	pr6|826
002270  aa   775603 3520 04	epp2 	-1149,ic		000073 = 526000000041
002271  aa  6 01474 2521 00	spri2	pr6|828
002272  aa   775612 3520 04	epp2 	-1142,ic		000104 = 514000000044
002273  aa  6 01476 2521 00	spri2	pr6|830
002274  aa   775561 3520 04	epp2 	-1167,ic		000055 = 406000000021
002275  aa  6 01500 2521 00	spri2	pr6|832
002276  aa  6 01450 6211 00	eax1 	pr6|808
002277  aa   030000 4310 07	fld  	12288,dl
002300  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
002301  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 386
	     return;

002302  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 387
	end;

						STATEMENT 1 ON LINE 390
	unspec (mount_transmission) = evmessage.bits;

002303  aa  5 00002 2351 00	lda  	pr5|2		evmessage.bits
002304  aa  5 00003 2361 00	ldq  	pr5|3		evmessage.bits
002305  aa  6 01174 7571 00	staq 	pr6|636
						STATEMENT 1 ON LINE 392
	if evmessage.bits = unspec (ALARM___) | mount_transmission.req = "poll"
	     then do;

002306  aa   775512 1170 04	cmpaq	-1206,ic		000020 = 141154141162 155137137137
002307  aa   000004 6000 04	tze  	4,ic		002313
002310  aa  6 01174 2351 00	lda  	pr6|636		mount_transmission.req
002311  aa   775543 1150 04	cmpa 	-1181,ic		000054 = 160157154154
002312  aa   000003 6010 04	tnz  	3,ic		002315
						STATEMENT 1 ON LINE 394
	     call poll_mounts;

002313  aa   002247 6700 04	tsp4 	1191,ic		004562
						STATEMENT 1 ON LINE 395
	     return;

002314  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 396
	end;

						STATEMENT 1 ON LINE 401
	if mount_transmission.other ^= 0 | (mount_transmission.req ^= "moun" & mount_transmission.req ^= "demo")
	then do;

002315  aa  6 01175 2351 00	lda  	pr6|637		mount_transmission.other
002316  aa   000022 7350 00	als  	18
002317  aa   000066 7330 00	lrs  	54
002320  aa   000006 6010 04	tnz  	6,ic		002326
002321  aa  6 01174 2351 00	lda  	pr6|636		mount_transmission.req
002322  aa   775531 1150 04	cmpa 	-1191,ic		000053 = 155157165156
002323  aa   000027 6000 04	tze  	23,ic		002352
002324  aa   775526 1150 04	cmpa 	-1194,ic		000052 = 144145155157
002325  aa   000025 6000 04	tze  	21,ic		002352
						STATEMENT 1 ON LINE 403
	     call sys_log_ (SL_LOG_BEEP,
		"lv_request_ : bad transmission: ^24.3b", evmessage.bits);

002326  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002327  aa   776006 00 0050	desc9a	-1018,40		000334 = 154166137162
002330  aa  6 01344 00 0050	desc9a	pr6|740,40
002331  aa   775551 3520 04	epp2 	-1175,ic		000102 = 000000000002
002332  aa  6 01400 2521 00	spri2	pr6|768
002333  aa  6 01344 3521 00	epp2 	pr6|740
002334  aa  6 01402 2521 00	spri2	pr6|770
002335  aa  5 00002 3521 00	epp2 	pr5|2		evmessage.bits
002336  aa  6 01404 2521 00	spri2	pr6|772
002337  aa   775544 3520 04	epp2 	-1180,ic		000103 = 404000000021
002340  aa  6 01406 2521 00	spri2	pr6|774
002341  aa   775510 3520 04	epp2 	-1208,ic		000051 = 524000000046
002342  aa  6 01410 2521 00	spri2	pr6|776
002343  aa   775513 3520 04	epp2 	-1205,ic		000056 = 514000000110
002344  aa  6 01412 2521 00	spri2	pr6|778
002345  aa  6 01376 6211 00	eax1 	pr6|766
002346  aa   014000 4310 07	fld  	6144,dl
002347  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
002350  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 405
	     return;

002351  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 406
	end;

						STATEMENT 1 ON LINE 408
	lvax = mount_transmission.lvax;

002352  aa  6 01175 2351 00	lda  	pr6|637		mount_transmission.lvax
002353  aa   000066 7330 00	lrs  	54
002354  aa  6 00435 7561 00	stq  	pr6|285		lvax
						STATEMENT 1 ON LINE 409
	demounting = mount_transmission.req = "demo";

002355  aa  6 01174 2351 00	lda  	pr6|636		mount_transmission.req
002356  aa   775474 1150 04	cmpa 	-1220,ic		000052 = 144145155157
002357  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
002360  aa  6 00425 7551 00	sta  	pr6|277		demounting
						STATEMENT 1 ON LINE 410
	call get (lvax);

002361  aa   002567 3520 04	epp2 	1399,ic		005150 = 000002000000
002362  aa   001616 6700 04	tsp4 	910,ic		004200
						STATEMENT 1 ON LINE 411
	if xec ^= 0 then do;

002363  aa  6 00430 2361 00	ldq  	pr6|280		xec
002364  aa   000031 6000 04	tze  	25,ic		002415
						STATEMENT 1 ON LINE 412
badlvax:	     call sys_log_ (SL_LOG_BEEP,
		"lv_request_: bad LV attach table index ^d in ^[demount^;mount^] request",
		lvax, demounting);

002365  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002366  aa   776143 00 0110	desc9a	-925,72		000530 = 154166137162
002367  aa  6 01376 00 0110	desc9a	pr6|766,72
002370  aa   775512 3520 04	epp2 	-1206,ic		000102 = 000000000002
002371  aa  6 01424 2521 00	spri2	pr6|788
002372  aa  6 01376 3521 00	epp2 	pr6|766
002373  aa  6 01426 2521 00	spri2	pr6|790
002374  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002375  aa  6 01430 2521 00	spri2	pr6|792
002376  aa  6 00425 3521 00	epp2 	pr6|277		demounting
002377  aa  6 01432 2521 00	spri2	pr6|794
002400  aa   775503 3520 04	epp2 	-1213,ic		000103 = 404000000021
002401  aa  6 01434 2521 00	spri2	pr6|796
002402  aa  6 01440 2521 00	spri2	pr6|800
002403  aa   775461 3520 04	epp2 	-1231,ic		000064 = 524000000107
002404  aa  6 01436 2521 00	spri2	pr6|798
002405  aa   775443 3520 04	epp2 	-1245,ic		000050 = 516000000001
002406  aa  6 01442 2521 00	spri2	pr6|802
002407  aa  6 01422 6211 00	eax1 	pr6|786
002410  aa   020000 4310 07	fld  	8192,dl
002411  aa  6 00044 3701 20	epp4 	pr6|36,*
002412  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
002413  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 415
	     return;

002414  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 416
	end;

						STATEMENT 1 ON LINE 418
	if evmessage.sender ^= lvate.pid then go to badlvax;

002415  aa  6 00032 3735 20	epp7 	pr6|26,*
002416  aa  7 00002 3715 20	epp5 	pr7|2,*		msgp
002417  aa  5 00000 3715 20	epp5 	pr5|0,*		msgp
002420  aa  5 00004 2351 00	lda  	pr5|4		evmessage.sender
002421  aa  6 01212 1151 20	cmpa 	pr6|650,*		lvate.pid
002422  aa   777743 6010 04	tnz  	-29,ic		002365
						STATEMENT 1 ON LINE 419
	call find_u (evmessage.sender);

002423  aa  5 00004 3521 00	epp2 	pr5|4		evmessage.sender
002424  aa  6 01334 2521 00	spri2	pr6|732
002425  aa  6 01332 3521 00	epp2 	pr6|730
002426  aa   004000 4310 07	fld  	2048,dl
002427  aa  2 00000 7571 00	staq 	pr2|0
002430  aa   001570 6700 04	tsp4 	888,ic		004220
						STATEMENT 1 ON LINE 420
	lvname = lvate.lvname;

002431  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
002432  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002433  aa  7 00003 00 0040	desc9a	pr7|3,32		lvate.lvname
002434  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
						STATEMENT 1 ON LINE 423
	if demounting then do;

002435  aa  6 00425 2351 00	lda  	pr6|277		demounting
002436  aa   400000 3150 03	cana 	131072,du
002437  aa   000052 6000 04	tze  	42,ic		002511
						STATEMENT 1 ON LINE 424
	     if lvate.mounted then call detach;

002440  aa  7 00016 2351 00	lda  	pr7|14		lvate.mounted
002441  aa   040000 3150 03	cana 	16384,du
002442  aa   000002 6000 04	tze  	2,ic		002444
002443  aa   001452 6700 04	tsp4 	810,ic		004115
						STATEMENT 1 ON LINE 425
	     call initializer_mdc_$free_lvate (lvax);

002444  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002445  aa  6 01334 2521 00	spri2	pr6|732
002446  aa  6 01332 6211 00	eax1 	pr6|730
002447  aa   004000 4310 07	fld  	2048,dl
002450  aa  6 00044 3701 20	epp4 	pr6|36,*
002451  la  4 00060 3521 20	epp2 	pr4|48,*		initializer_mdc_$free_lvate
002452  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 426
	     call initializer_mdc_$scan_process_lvat (evmessage.sender, array, n);

002453  aa  6 00032 3735 20	epp7 	pr6|26,*
002454  aa  7 00002 3715 20	epp5 	pr7|2,*		msgp
002455  aa  5 00000 3715 20	epp5 	pr5|0,*		msgp
002456  aa  5 00004 3521 00	epp2 	pr5|4		evmessage.sender
002457  aa  6 01400 2521 00	spri2	pr6|768
002460  aa  6 00105 3521 00	epp2 	pr6|69		array
002461  aa  6 01402 2521 00	spri2	pr6|770
002462  aa  6 00433 3521 00	epp2 	pr6|283		n
002463  aa  6 01404 2521 00	spri2	pr6|772
002464  aa   775420 3520 04	epp2 	-1264,ic		000104 = 514000000044
002465  aa  6 01406 2521 00	spri2	pr6|774
002466  aa   775464 3520 04	epp2 	-1228,ic		000152 = 404100000021
002467  aa  6 01410 2521 00	spri2	pr6|776
002470  aa   775413 3520 04	epp2 	-1269,ic		000103 = 404000000021
002471  aa  6 01412 2521 00	spri2	pr6|778
002472  aa  6 01376 6211 00	eax1 	pr6|766
002473  aa   014000 4310 07	fld  	6144,dl
002474  aa  6 00044 3701 20	epp4 	pr6|36,*
002475  la  4 00100 3521 20	epp2 	pr4|64,*		initializer_mdc_$scan_process_lvat
002476  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 427
	     if n = 0 then do;

002477  aa  6 00433 2361 00	ldq  	pr6|283		n
002500  aa   000010 6010 04	tnz  	8,ic		002510
						STATEMENT 1 ON LINE 428
		if utep ^= null then ute.lvs_attached = "0"b;

002501  aa  6 01214 2371 00	ldaq 	pr6|652		utep
002502  aa   775410 6770 04	eraq 	-1272,ic		000112 = 077777000043 000001000000
002503  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002504  aa   000004 6000 04	tze  	4,ic		002510
002505  aa   002425 2350 04	lda  	1301,ic		005132 = 737777777777
002506  aa  6 01214 3735 20	epp7 	pr6|652,*		utep
002507  aa  7 00431 3551 00	ansa 	pr7|281		ute.lvs_attached
						STATEMENT 1 ON LINE 429
	     end;

						STATEMENT 1 ON LINE 430
	     return;

002510  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 431
	end;

						STATEMENT 1 ON LINE 435
	dtp = disk_table_$get_dtp ();

002511  aa  6 01204 3521 00	epp2 	pr6|644		dtp
002512  aa  6 01334 2521 00	spri2	pr6|732
002513  aa  6 01332 6211 00	eax1 	pr6|730
002514  aa   004000 4310 07	fld  	2048,dl
002515  aa  6 00044 3701 20	epp4 	pr6|36,*
002516  la  4 00040 3521 20	epp2 	pr4|32,*		disk_table_$get_dtp
002517  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 437
	do lvx = 1 to dt.n_lv_entries;

002520  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
002521  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
002522  aa  6 01226 7561 00	stq  	pr6|662
002523  aa   000001 2360 07	ldq  	1,dl
002524  aa  6 00446 7561 00	stq  	pr6|294		lvx
002525  aa   000000 0110 03	nop  	0,du
002526  aa  6 00446 2361 00	ldq  	pr6|294		lvx
002527  aa  6 01226 1161 00	cmpq 	pr6|662
002530  aa   000100 6054 04	tpnz 	64,ic		002630
						STATEMENT 1 ON LINE 438
	     lvep = addr (dt.lv_array (lvx));

002531  aa   000016 4020 07	mpy  	14,dl
002532  aa  6 01375 7561 00	stq  	pr6|765
002533  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
002534  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
002535  aa   000016 4020 07	mpy  	14,dl
002536  aa   000010 0760 07	adq  	8,dl
002537  aa  6 01375 0761 00	adq  	pr6|765
002540  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
002541  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 439
	     if lve.hv_mounted & lve.lvname = lvname then do;

002542  aa  5 00001 2351 00	lda  	pr5|1		lve.hv_mounted
002543  aa   200000 3150 03	cana 	65536,du
002544  aa   000062 6000 04	tze  	50,ic		002626
002545  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
002546  aa  5 00002 00 0040	desc9a	pr5|2,32		lve.lvname
002547  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
002550  aa   000056 6010 04	tnz  	46,ic		002626
						STATEMENT 1 ON LINE 440
		call initializer_mdc_$set_lvat_info (lvax, lve.lvid, lvx);

002551  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002552  aa  6 01346 2521 00	spri2	pr6|742
002553  aa  5 00000 3521 00	epp2 	pr5|0		lve.lvid
002554  aa  6 01350 2521 00	spri2	pr6|744
002555  aa  6 00446 3521 00	epp2 	pr6|294		lvx
002556  aa  6 01352 2521 00	spri2	pr6|746
002557  aa  6 01344 6211 00	eax1 	pr6|740
002560  aa   014000 4310 07	fld  	6144,dl
002561  aa  6 00044 3701 20	epp4 	pr6|36,*
002562  la  4 00102 3521 20	epp2 	pr4|66,*		initializer_mdc_$set_lvat_info
002563  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 441
		call initializer_mdc_$respond_mount_lv (lvax, 1, 0, ec);

002564  aa   000001 2360 07	ldq  	1,dl
002565  aa  6 01375 7561 00	stq  	pr6|765
002566  aa  6 01421 4501 00	stz  	pr6|785
002567  aa  6 00435 3521 00	epp2 	pr6|285		lvax
002570  aa  6 01346 2521 00	spri2	pr6|742
002571  aa  6 01375 3521 00	epp2 	pr6|765
002572  aa  6 01350 2521 00	spri2	pr6|744
002573  aa  6 01421 3521 00	epp2 	pr6|785
002574  aa  6 01352 2521 00	spri2	pr6|746
002575  aa  6 00427 3521 00	epp2 	pr6|279		ec
002576  aa  6 01354 2521 00	spri2	pr6|748
002577  aa  6 01344 6211 00	eax1 	pr6|740
002600  aa   020000 4310 07	fld  	8192,dl
002601  aa  6 00044 3701 20	epp4 	pr6|36,*
002602  la  4 00074 3521 20	epp2 	pr4|60,*		initializer_mdc_$respond_mount_lv
002603  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 442
		if ec = 0 then do;

002604  aa  6 00427 2361 00	ldq  	pr6|279		ec
002605  aa   000012 6010 04	tnz  	10,ic		002617
						STATEMENT 1 ON LINE 443
		     call attach;

002606  aa   001224 6700 04	tsp4 	660,ic		004032
						STATEMENT 1 ON LINE 444
		     if utep ^= null () then ute.lvs_attached = "1"b;

002607  aa  6 01214 2371 00	ldaq 	pr6|652		utep
002610  aa   775302 6770 04	eraq 	-1342,ic		000112 = 077777000043 000001000000
002611  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002612  aa   000013 6000 04	tze  	11,ic		002625
002613  aa   040000 2350 03	lda  	16384,du
002614  aa  6 01214 3735 20	epp7 	pr6|652,*		utep
002615  aa  7 00431 2551 00	orsa 	pr7|281		ute.lvs_attached
						STATEMENT 1 ON LINE 445
		end;

002616  aa   000007 7100 04	tra  	7,ic		002625
						STATEMENT 1 ON LINE 446
		else call beef ("Mount already ready");

002617  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002620  aa   775362 00 0024	desc9a	-1294,20		000201 = 115157165156
002621  aa  6 01332 00 0024	desc9a	pr6|730,20
002622  aa   002302 3520 04	epp2 	1218,ic		005124 = 000002000000
002623  aa  2 00000 2351 00	lda  	pr2|0
002624  aa   001121 6700 04	tsp4 	593,ic		003745
						STATEMENT 1 ON LINE 447
		return;

002625  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 448
	     end;

						STATEMENT 1 ON LINE 449
	end;

002626  aa  6 00446 0541 00	aos  	pr6|294		lvx
002627  aa   777677 7100 04	tra  	-65,ic		002526
						STATEMENT 1 ON LINE 454
	ev_calls_masked = "1"b;

002630  aa   400000 2350 03	lda  	131072,du
002631  aa  6 00431 7551 00	sta  	pr6|281		ev_calls_masked
						STATEMENT 1 ON LINE 455
	call ipc_$mask_ev_calls (ec);

002632  aa  6 00427 3521 00	epp2 	pr6|279		ec
002633  aa  6 01334 2521 00	spri2	pr6|732
002634  aa  6 01332 6211 00	eax1 	pr6|730
002635  aa   004000 4310 07	fld  	2048,dl
002636  aa  6 00044 3701 20	epp4 	pr6|36,*
002637  la  4 00116 3521 20	epp2 	pr4|78,*		ipc_$mask_ev_calls
002640  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 456
	if ec ^= 0 then do;

002641  aa  6 00427 2361 00	ldq  	pr6|279		ec
002642  aa   000042 6000 04	tze  	34,ic		002704
						STATEMENT 1 ON LINE 457
	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
		"Masking event calls.");

002643  aa   775270 2350 04	lda  	-1352,ic		000133 = 154166137162
002644  aa   775270 2360 04	ldq  	-1352,ic		000134 = 145161165145
002645  aa  6 01332 7571 00	staq 	pr6|730
002646  aa   775267 2350 04	lda  	-1353,ic		000135 = 163164137000
002647  aa  6 01334 7551 00	sta  	pr6|732
002650  aa   775324 2370 04	ldaq 	-1324,ic		000174 = 115141163153 151156147040
002651  aa  6 01344 7571 00	staq 	pr6|740
002652  aa   775324 2370 04	ldaq 	-1324,ic		000176 = 145166145156 164040143141
002653  aa  6 01346 7571 00	staq 	pr6|742
002654  aa   775324 2350 04	lda  	-1324,ic		000200 = 154154163056
002655  aa  6 01350 7551 00	sta  	pr6|744
002656  aa   775224 3520 04	epp2 	-1388,ic		000102 = 000000000002
002657  aa  6 01400 2521 00	spri2	pr6|768
002660  aa  6 00427 3521 00	epp2 	pr6|279		ec
002661  aa  6 01402 2521 00	spri2	pr6|770
002662  aa  6 01332 3521 00	epp2 	pr6|730
002663  aa  6 01404 2521 00	spri2	pr6|772
002664  aa  6 01344 3521 00	epp2 	pr6|740
002665  aa  6 01406 2521 00	spri2	pr6|774
002666  aa   775215 3520 04	epp2 	-1395,ic		000103 = 404000000021
002667  aa  6 01410 2521 00	spri2	pr6|776
002670  aa   775210 3520 04	epp2 	-1400,ic		000100 = 404000000043
002671  aa  6 01412 2521 00	spri2	pr6|778
002672  aa   775205 3520 04	epp2 	-1403,ic		000077 = 524000000013
002673  aa  6 01414 2521 00	spri2	pr6|780
002674  aa   775166 3520 04	epp2 	-1418,ic		000062 = 524000000024
002675  aa  6 01416 2521 00	spri2	pr6|782
002676  aa  6 01376 6211 00	eax1 	pr6|766
002677  aa   020000 4310 07	fld  	8192,dl
002700  aa  6 00044 3701 20	epp4 	pr6|36,*
002701  la  4 00124 3521 20	epp2 	pr4|84,*		sys_log_$error_log
002702  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 459
	     go to no_avail;

002703  aa   000171 7100 04	tra  	121,ic		003074
						STATEMENT 1 ON LINE 460
	end;

						STATEMENT 1 ON LINE 462
	on command_error;

002704  aa   000015 7260 07	lxl6 	13,dl
002705  aa   775251 3520 04	epp2 	-1367,ic		000156 = 143157155155
002706  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
002707  aa   000004 7100 04	tra  	4,ic		002713
002710  aa     001176000000
002711  aa   000010 7100 04	tra  	8,ic		002721
BEGIN CONDITION command_error.1
ENTRY TO command_error.1                                    STATEMENT 1 ON LINE 462
	on command_error;

002712  da     000501200000
002713  aa   000100 6270 00	eax7 	64
002714  aa  7 00034 3521 20	epp2 	pr7|28,*
002715  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
002716  aa     000000000000
002717  aa     000000000000
002720  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END CONDITION command_error.1
						STATEMENT 1 ON LINE 466
	call disk_table_$dry_run_mhv (lvname, result);

002721  aa  6 00436 3521 00	epp2 	pr6|286		lvname
002722  aa  6 01346 2521 00	spri2	pr6|742
002723  aa  6 00461 3521 00	epp2 	pr6|305		result
002724  aa  6 01350 2521 00	spri2	pr6|744
002725  aa   775150 3520 04	epp2 	-1432,ic		000075 = 526000000040
002726  aa  6 01352 2521 00	spri2	pr6|746
002727  aa   775154 3520 04	epp2 	-1428,ic		000103 = 404000000021
002730  aa  6 01354 2521 00	spri2	pr6|748
002731  aa  6 01344 6211 00	eax1 	pr6|740
002732  aa   010000 4310 07	fld  	4096,dl
002733  aa  6 00044 3701 20	epp4 	pr6|36,*
002734  la  4 00036 3521 20	epp2 	pr4|30,*		disk_table_$dry_run_mhv
002735  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 468
	if result = 0 then go to mhv_it;

002736  aa  6 00461 2361 00	ldq  	pr6|305		result
002737  aa   000355 6000 04	tze  	237,ic		003314
						STATEMENT 1 ON LINE 470
	do lvx = 1 to dt.n_lv_entries;

002740  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
002741  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
002742  aa  6 01227 7561 00	stq  	pr6|663
002743  aa   000001 2360 07	ldq  	1,dl
002744  aa  6 00446 7561 00	stq  	pr6|294		lvx
002745  aa   000000 0110 03	nop  	0,du
002746  aa  6 00446 2361 00	ldq  	pr6|294		lvx
002747  aa  6 01227 1161 00	cmpq 	pr6|663
002750  aa   000124 6054 04	tpnz 	84,ic		003074
						STATEMENT 1 ON LINE 471
	     lvep = addr (dt.lv_array (lvx));

002751  aa   000016 4020 07	mpy  	14,dl
002752  aa  6 01421 7561 00	stq  	pr6|785
002753  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
002754  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
002755  aa   000016 4020 07	mpy  	14,dl
002756  aa   000010 0760 07	adq  	8,dl
002757  aa  6 01421 0761 00	adq  	pr6|785
002760  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
002761  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 472
	     if (lve.hv_mounted | lve.mounting) & ^lve.public then do;

002762  aa  5 00001 2351 00	lda  	pr5|1		lve.mounting
002763  aa   240000 3150 03	cana 	81920,du
002764  aa   000106 6000 04	tze  	70,ic		003072
002765  aa  5 00001 2351 00	lda  	pr5|1		lve.public
002766  aa   100000 3150 03	cana 	32768,du
002767  aa   000103 6010 04	tnz  	67,ic		003072
						STATEMENT 1 ON LINE 473
		d_lvname = lve.lvname;

002770  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002771  aa  5 00002 00 0040	desc9a	pr5|2,32		lve.lvname
002772  aa  6 00415 00 0040	desc9a	pr6|269,32	d_lvname
						STATEMENT 1 ON LINE 474
		call initializer_mdc_$lvat_scan_lv (d_lvname, array, n);

002773  aa  6 00415 3521 00	epp2 	pr6|269		d_lvname
002774  aa  6 01400 2521 00	spri2	pr6|768
002775  aa  6 00105 3521 00	epp2 	pr6|69		array
002776  aa  6 01402 2521 00	spri2	pr6|770
002777  aa  6 00433 3521 00	epp2 	pr6|283		n
003000  aa  6 01404 2521 00	spri2	pr6|772
003001  aa   775074 3520 04	epp2 	-1476,ic		000075 = 526000000040
003002  aa  6 01406 2521 00	spri2	pr6|774
003003  aa   775147 3520 04	epp2 	-1433,ic		000152 = 404100000021
003004  aa  6 01410 2521 00	spri2	pr6|776
003005  aa   775076 3520 04	epp2 	-1474,ic		000103 = 404000000021
003006  aa  6 01412 2521 00	spri2	pr6|778
003007  aa  6 01376 6211 00	eax1 	pr6|766
003010  aa   014000 4310 07	fld  	6144,dl
003011  aa  6 00044 3701 20	epp4 	pr6|36,*
003012  la  4 00066 3521 20	epp2 	pr4|54,*		initializer_mdc_$lvat_scan_lv
003013  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 475
		if n = 0 then do;

003014  aa  6 00433 2361 00	ldq  	pr6|283		n
003015  aa   000055 6010 04	tnz  	45,ic		003072
						STATEMENT 1 ON LINE 476
		     do pvx = 1 to dt.n_entries;

003016  aa  6 01204 2361 20	ldq  	pr6|644,*		dt.n_entries
003017  aa  6 01230 7561 00	stq  	pr6|664
003020  aa   000001 2360 07	ldq  	1,dl
003021  aa  6 00447 7561 00	stq  	pr6|295		pvx
003022  aa  6 00447 2361 00	ldq  	pr6|295		pvx
003023  aa  6 01230 1161 00	cmpq 	pr6|664
003024  aa   000023 6054 04	tpnz 	19,ic		003047
						STATEMENT 1 ON LINE 477
			dtep = addr (dt.array (pvx));

003025  aa   000016 4020 07	mpy  	14,dl
003026  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003027  aa  7 77772 3735 06	epp7 	pr7|-6,ql		dt.array
003030  aa  6 01206 6535 00	spri7	pr6|646		dtep
						STATEMENT 1 ON LINE 478
			if dte.lvx = lvx then do;

003031  aa  7 00002 2351 00	lda  	pr7|2		dte.lvx
003032  aa   000027 7350 00	als  	23
003033  aa   000074 7330 00	lrs  	60
003034  aa  6 00446 1161 00	cmpq 	pr6|294		lvx
003035  aa   000010 6010 04	tnz  	8,ic		003045
						STATEMENT 1 ON LINE 479
			     lve.good_candidate = "1"b;

003036  aa   010000 2350 03	lda  	4096,du
003037  aa  6 01210 3715 20	epp5 	pr6|648,*		lvep
003040  aa  5 00001 2551 00	orsa 	pr5|1		lve.good_candidate
						STATEMENT 1 ON LINE 480
			     dte.used = "0"b;

003041  aa   002061 2350 04	lda  	1073,ic		005122 = 777377777777
003042  aa  7 00002 3551 00	ansa 	pr7|2		dte.used
						STATEMENT 1 ON LINE 481
			     dte.pre_accepted = "1"b;

003043  aa   000001 2350 07	lda  	1,dl
003044  aa  7 00002 2551 00	orsa 	pr7|2		dte.pre_accepted
						STATEMENT 1 ON LINE 482
			end;

						STATEMENT 1 ON LINE 483
		     end;

003045  aa  6 00447 0541 00	aos  	pr6|295		pvx
003046  aa   777754 7100 04	tra  	-20,ic		003022
						STATEMENT 1 ON LINE 484
		     if lve.good_candidate then do;

003047  aa  6 01210 3735 20	epp7 	pr6|648,*		lvep
003050  aa  7 00001 2351 00	lda  	pr7|1		lve.good_candidate
003051  aa   010000 3150 03	cana 	4096,du
003052  aa   000020 6000 04	tze  	16,ic		003072
						STATEMENT 1 ON LINE 485
			call disk_table_$dry_run_mhv (lvname, result);

003053  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003054  aa  6 01346 2521 00	spri2	pr6|742
003055  aa  6 00461 3521 00	epp2 	pr6|305		result
003056  aa  6 01350 2521 00	spri2	pr6|744
003057  aa   775016 3520 04	epp2 	-1522,ic		000075 = 526000000040
003060  aa  6 01352 2521 00	spri2	pr6|746
003061  aa   775022 3520 04	epp2 	-1518,ic		000103 = 404000000021
003062  aa  6 01354 2521 00	spri2	pr6|748
003063  aa  6 01344 6211 00	eax1 	pr6|740
003064  aa   010000 4310 07	fld  	4096,dl
003065  aa  6 00044 3701 20	epp4 	pr6|36,*
003066  la  4 00036 3521 20	epp2 	pr4|30,*		disk_table_$dry_run_mhv
003067  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 486
			if result = 0 then go to dlv_and_mhv;

003070  aa  6 00461 2361 00	ldq  	pr6|305		result
003071  aa   000101 6000 04	tze  	65,ic		003172
						STATEMENT 1 ON LINE 487
		     end;

						STATEMENT 1 ON LINE 488
		end;

						STATEMENT 1 ON LINE 489
	     end;

						STATEMENT 1 ON LINE 490
	end;

003072  aa  6 00446 0541 00	aos  	pr6|294		lvx
003073  aa   777653 7100 04	tra  	-85,ic		002746
						STATEMENT 1 ON LINE 494
no_avail:
	call sys_log_ (SL0, "No drives available to mount ^a for ^a ^12.3b",
	     lvname, user_procname, user_procid);

003074  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003075  aa   775326 00 0060	desc9a	-1322,48		000422 = 116157040144
003076  aa  6 01344 00 0060	desc9a	pr6|740,48
003077  aa  6 00044 3701 20	epp4 	pr6|36,*
003100  ia  4 00011 3521 00	epp2 	pr4|9		SL0
003101  aa  6 01424 2521 00	spri2	pr6|788
003102  aa  6 01344 3521 00	epp2 	pr6|740
003103  aa  6 01426 2521 00	spri2	pr6|790
003104  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003105  aa  6 01430 2521 00	spri2	pr6|792
003106  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
003107  aa  6 01432 2521 00	spri2	pr6|794
003110  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
003111  aa  6 01434 2521 00	spri2	pr6|796
003112  aa   774771 3520 04	epp2 	-1543,ic		000103 = 404000000021
003113  aa  6 01436 2521 00	spri2	pr6|798
003114  aa   774732 3520 04	epp2 	-1574,ic		000046 = 524000000055
003115  aa  6 01440 2521 00	spri2	pr6|800
003116  aa   774757 3520 04	epp2 	-1553,ic		000075 = 526000000040
003117  aa  6 01442 2521 00	spri2	pr6|802
003120  aa   774753 3520 04	epp2 	-1557,ic		000073 = 526000000041
003121  aa  6 01444 2521 00	spri2	pr6|804
003122  aa   774762 3520 04	epp2 	-1550,ic		000104 = 514000000044
003123  aa  6 01446 2521 00	spri2	pr6|806
003124  aa  6 01422 6211 00	eax1 	pr6|786
003125  aa   024000 4310 07	fld  	10240,dl
003126  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
003127  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 497
	call initializer_mdc_$respond_mount_lv (lvax, 3, error_table_$resource_unavailable, ec);

003130  aa   000003 2360 07	ldq  	3,dl
003131  aa  6 01421 7561 00	stq  	pr6|785
003132  aa  6 00435 3521 00	epp2 	pr6|285		lvax
003133  aa  6 01346 2521 00	spri2	pr6|742
003134  aa  6 01421 3521 00	epp2 	pr6|785
003135  aa  6 01350 2521 00	spri2	pr6|744
003136  aa  6 00044 3701 20	epp4 	pr6|36,*
003137  la  4 00046 3521 20	epp2 	pr4|38,*		error_table_$resource_unavailable
003140  aa  6 01352 2521 00	spri2	pr6|746
003141  aa  6 00427 3521 00	epp2 	pr6|279		ec
003142  aa  6 01354 2521 00	spri2	pr6|748
003143  aa  6 01344 6211 00	eax1 	pr6|740
003144  aa   020000 4310 07	fld  	8192,dl
003145  la  4 00074 3521 20	epp2 	pr4|60,*		initializer_mdc_$respond_mount_lv
003146  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 498
	if ec ^= 0 then call beef ("Drive availability denial");

003147  aa  6 00427 2361 00	ldq  	pr6|279		ec
003150  aa   000007 6000 04	tze  	7,ic		003157
003151  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003152  aa   775065 00 0034	desc9a	-1483,28		000236 = 104162151166
003153  aa  6 01344 00 0034	desc9a	pr6|740,28
003154  aa   001740 3520 04	epp2 	992,ic		005114 = 000002000000
003155  aa  2 00000 2351 00	lda  	pr2|0
003156  aa   000567 6700 04	tsp4 	375,ic		003745
						STATEMENT 1 ON LINE 499
unmask:	if ev_calls_masked then			/* if we masked event calls above */
	     call ipc_$unmask_ev_calls ((0));

003157  aa  6 00431 2351 00	lda  	pr6|281		ev_calls_masked
003160  aa   000011 6000 04	tze  	9,ic		003171
003161  aa  6 01421 4501 00	stz  	pr6|785
003162  aa  6 01421 3521 00	epp2 	pr6|785
003163  aa  6 01334 2521 00	spri2	pr6|732
003164  aa  6 01332 6211 00	eax1 	pr6|730
003165  aa   004000 4310 07	fld  	2048,dl
003166  aa  6 00044 3701 20	epp4 	pr6|36,*
003167  la  4 00120 3521 20	epp2 	pr4|80,*		ipc_$unmask_ev_calls
003170  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 501
	return;

003171  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 506
dlv_and_mhv:
	n = 0;

003172  aa  6 00433 4501 00	stz  	pr6|283		n
						STATEMENT 1 ON LINE 508
	do lvx = 1 to dt.n_lv_entries;

003173  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003174  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
003175  aa  6 01231 7561 00	stq  	pr6|665
003176  aa   000001 2360 07	ldq  	1,dl
003177  aa  6 00446 7561 00	stq  	pr6|294		lvx
003200  aa  6 00446 2361 00	ldq  	pr6|294		lvx
003201  aa  6 01231 1161 00	cmpq 	pr6|665
003202  aa   000023 6054 04	tpnz 	19,ic		003225
						STATEMENT 1 ON LINE 509
	     lvep = addr (dt.lv_array (lvx));

003203  aa   000016 4020 07	mpy  	14,dl
003204  aa  6 01421 7561 00	stq  	pr6|785
003205  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003206  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
003207  aa   000016 4020 07	mpy  	14,dl
003210  aa   000010 0760 07	adq  	8,dl
003211  aa  6 01421 0761 00	adq  	pr6|785
003212  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
003213  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 510
	     if lve.good_candidate then do;

003214  aa  5 00001 2351 00	lda  	pr5|1		lve.good_candidate
003215  aa   010000 3150 03	cana 	4096,du
003216  aa   000005 6000 04	tze  	5,ic		003223
						STATEMENT 1 ON LINE 511
		n = n + 1;

003217  aa  6 00433 0541 00	aos  	pr6|283		n
						STATEMENT 1 ON LINE 512
		array (n) = lvx;

003220  aa  6 00446 2361 00	ldq  	pr6|294		lvx
003221  aa  6 00433 7271 00	lxl7 	pr6|283		n
003222  aa  6 00104 7561 17	stq  	pr6|68,7		array
						STATEMENT 1 ON LINE 513
	     end;

						STATEMENT 1 ON LINE 514
	end;

003223  aa  6 00446 0541 00	aos  	pr6|294		lvx
003224  aa   777754 7100 04	tra  	-20,ic		003200
						STATEMENT 1 ON LINE 516
	do i = 1 to n;

003225  aa  6 00433 2361 00	ldq  	pr6|283		n
003226  aa  6 01232 7561 00	stq  	pr6|666
003227  aa   000001 2360 07	ldq  	1,dl
003230  aa  6 00432 7561 00	stq  	pr6|282		i
003231  aa   000000 0110 03	nop  	0,du
003232  aa  6 00432 2361 00	ldq  	pr6|282		i
003233  aa  6 01232 1161 00	cmpq 	pr6|666
003234  aa   000031 6054 04	tpnz 	25,ic		003265
						STATEMENT 1 ON LINE 517
	     lvep = addr (dt.lv_array (array (i)));

003235  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
003236  aa   000016 4020 07	mpy  	14,dl
003237  aa  6 01421 7561 00	stq  	pr6|785
003240  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003241  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
003242  aa   000016 4020 07	mpy  	14,dl
003243  aa   000010 0760 07	adq  	8,dl
003244  aa  6 01421 0761 00	adq  	pr6|785
003245  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
003246  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 518
	     call disk_table_$dhv ((lve.lvname));

003247  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003250  aa  5 00002 00 0040	desc9a	pr5|2,32		lve.lvname
003251  aa  6 01344 00 0040	desc9a	pr6|740,32
003252  aa  6 01344 3521 00	epp2 	pr6|740
003253  aa  6 01334 2521 00	spri2	pr6|732
003254  aa   774616 3520 04	epp2 	-1650,ic		000072 = 524000000040
003255  aa  6 01336 2521 00	spri2	pr6|734
003256  aa  6 01332 6211 00	eax1 	pr6|730
003257  aa   004000 4310 07	fld  	2048,dl
003260  aa  6 00044 3701 20	epp4 	pr6|36,*
003261  la  4 00034 3521 20	epp2 	pr4|28,*		disk_table_$dhv
003262  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 519
	end;

003263  aa  6 00432 0541 00	aos  	pr6|282		i
003264  aa   777746 7100 04	tra  	-26,ic		003232
						STATEMENT 1 ON LINE 523
	do i = 1 to n;

003265  aa  6 00433 2361 00	ldq  	pr6|283		n
003266  aa  6 01233 7561 00	stq  	pr6|667
003267  aa   000001 2360 07	ldq  	1,dl
003270  aa  6 00432 7561 00	stq  	pr6|282		i
003271  aa   000000 0110 03	nop  	0,du
003272  aa  6 00432 2361 00	ldq  	pr6|282		i
003273  aa  6 01233 1161 00	cmpq 	pr6|667
003274  aa   000020 6054 04	tpnz 	16,ic		003314
						STATEMENT 1 ON LINE 524
	     lvep = addr (dt.lv_array (array (i)));

003275  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
003276  aa   000016 4020 07	mpy  	14,dl
003277  aa  6 01421 7561 00	stq  	pr6|785
003300  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003301  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
003302  aa   000016 4020 07	mpy  	14,dl
003303  aa   000010 0760 07	adq  	8,dl
003304  aa  6 01421 0761 00	adq  	pr6|785
003305  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
003306  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 525
	     if lve.demounting then go to no_avail;

003307  aa  5 00001 2351 00	lda  	pr5|1		lve.demounting
003310  aa   020000 3150 03	cana 	8192,du
003311  aa   777563 6010 04	tnz  	-141,ic		003074
						STATEMENT 1 ON LINE 526
	end;

003312  aa  6 00432 0541 00	aos  	pr6|282		i
003313  aa   777757 7100 04	tra  	-17,ic		003272
						STATEMENT 1 ON LINE 530
mhv_it:	call sys_log_ (SL0,
	     "lv_request_: Beginning mount of LV ^a for ^a ^12.3b.",
	     lvname, user_procname, user_procid);

003314  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003315  aa   775122 00 0064	desc9a	-1454,52		000436 = 154166137162
003316  aa  6 01360 00 0064	desc9a	pr6|752,52
003317  aa  6 00044 3701 20	epp4 	pr6|36,*
003320  ia  4 00011 3521 00	epp2 	pr4|9		SL0
003321  aa  6 01424 2521 00	spri2	pr6|788
003322  aa  6 01360 3521 00	epp2 	pr6|752
003323  aa  6 01426 2521 00	spri2	pr6|790
003324  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003325  aa  6 01430 2521 00	spri2	pr6|792
003326  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
003327  aa  6 01432 2521 00	spri2	pr6|794
003330  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
003331  aa  6 01434 2521 00	spri2	pr6|796
003332  aa   774551 3520 04	epp2 	-1687,ic		000103 = 404000000021
003333  aa  6 01436 2521 00	spri2	pr6|798
003334  aa   774511 3520 04	epp2 	-1719,ic		000045 = 524000000064
003335  aa  6 01440 2521 00	spri2	pr6|800
003336  aa   774537 3520 04	epp2 	-1697,ic		000075 = 526000000040
003337  aa  6 01442 2521 00	spri2	pr6|802
003340  aa   774533 3520 04	epp2 	-1701,ic		000073 = 526000000041
003341  aa  6 01444 2521 00	spri2	pr6|804
003342  aa   774542 3520 04	epp2 	-1694,ic		000104 = 514000000044
003343  aa  6 01446 2521 00	spri2	pr6|806
003344  aa  6 01422 6211 00	eax1 	pr6|786
003345  aa   024000 4310 07	fld  	10240,dl
003346  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
003347  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 533
	call disk_table_$mhv (lvname);

003350  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003351  aa  6 01334 2521 00	spri2	pr6|732
003352  aa   774523 3520 04	epp2 	-1709,ic		000075 = 526000000040
003353  aa  6 01336 2521 00	spri2	pr6|734
003354  aa  6 01332 6211 00	eax1 	pr6|730
003355  aa   004000 4310 07	fld  	2048,dl
003356  aa  6 00044 3701 20	epp4 	pr6|36,*
003357  la  4 00042 3521 20	epp2 	pr4|34,*		disk_table_$mhv
003360  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 535
	do lvx = 1 to dt.n_lv_entries;

003361  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003362  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
003363  aa  6 01234 7561 00	stq  	pr6|668
003364  aa   000001 2360 07	ldq  	1,dl
003365  aa  6 00446 7561 00	stq  	pr6|294		lvx
003366  aa  6 00446 2361 00	ldq  	pr6|294		lvx
003367  aa  6 01234 1161 00	cmpq 	pr6|668
003370  aa   777504 6054 04	tpnz 	-188,ic		003074
						STATEMENT 1 ON LINE 536
	     lvep = addr (dt.lv_array (lvx));

003371  aa   000016 4020 07	mpy  	14,dl
003372  aa  6 01421 7561 00	stq  	pr6|785
003373  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
003374  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
003375  aa   000016 4020 07	mpy  	14,dl
003376  aa   000010 0760 07	adq  	8,dl
003377  aa  6 01421 0761 00	adq  	pr6|785
003400  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lv_array
003401  aa  6 01210 6515 00	spri5	pr6|648		lvep
						STATEMENT 1 ON LINE 537
	     if lve.lvname = lvname then do;

003402  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003403  aa  5 00002 00 0040	desc9a	pr5|2,32		lve.lvname
003404  aa  6 00436 00 0040	desc9a	pr6|286,32	lvname
003405  aa   000064 6010 04	tnz  	52,ic		003471
						STATEMENT 1 ON LINE 538
		if lve.hv_mounted then go to unmask;

003406  aa  5 00001 2351 00	lda  	pr5|1		lve.hv_mounted
003407  aa   200000 3150 03	cana 	65536,du
003410  aa   777547 6010 04	tnz  	-153,ic		003157
						STATEMENT 1 ON LINE 539
		if lve.mounting then do;

003411  aa  5 00001 2351 00	lda  	pr5|1		lve.mounting
003412  aa   040000 3150 03	cana 	16384,du
003413  aa   000046 6000 04	tze  	38,ic		003461
						STATEMENT 1 ON LINE 540
		     call initializer_mdc_$respond_mount_lv (lvax, 4, 0, ec);

003414  aa   000004 2360 07	ldq  	4,dl
003415  aa  6 01421 7561 00	stq  	pr6|785
003416  aa  6 01375 4501 00	stz  	pr6|765
003417  aa  6 00435 3521 00	epp2 	pr6|285		lvax
003420  aa  6 01346 2521 00	spri2	pr6|742
003421  aa  6 01421 3521 00	epp2 	pr6|785
003422  aa  6 01350 2521 00	spri2	pr6|744
003423  aa  6 01375 3521 00	epp2 	pr6|765
003424  aa  6 01352 2521 00	spri2	pr6|746
003425  aa  6 00427 3521 00	epp2 	pr6|279		ec
003426  aa  6 01354 2521 00	spri2	pr6|748
003427  aa  6 01344 6211 00	eax1 	pr6|740
003430  aa   020000 4310 07	fld  	8192,dl
003431  aa  6 00044 3701 20	epp4 	pr6|36,*
003432  la  4 00074 3521 20	epp2 	pr4|60,*		initializer_mdc_$respond_mount_lv
003433  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 541
		     call initializer_mdc_$mhvmessage (lvax, user_procname);

003434  aa  6 00435 3521 00	epp2 	pr6|285		lvax
003435  aa  6 01346 2521 00	spri2	pr6|742
003436  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
003437  aa  6 01350 2521 00	spri2	pr6|744
003440  aa   774443 3520 04	epp2 	-1757,ic		000103 = 404000000021
003441  aa  6 01352 2521 00	spri2	pr6|746
003442  aa   774431 3520 04	epp2 	-1767,ic		000073 = 526000000041
003443  aa  6 01354 2521 00	spri2	pr6|748
003444  aa  6 01344 6211 00	eax1 	pr6|740
003445  aa   010000 4310 07	fld  	4096,dl
003446  aa  6 00044 3701 20	epp4 	pr6|36,*
003447  la  4 00070 3521 20	epp2 	pr4|56,*		initializer_mdc_$mhvmessage
003450  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 543
		     if ec ^= 0 then call beef ("Sending response to wait for mount");

003451  aa  6 00427 2361 00	ldq  	pr6|279		ec
003452  aa   000007 6000 04	tze  	7,ic		003461
003453  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003454  aa   774650 00 0044	desc9a	-1624,36		000323 = 123145156144
003455  aa  6 01344 00 0044	desc9a	pr6|740,36
003456  aa   001430 3520 04	epp2 	792,ic		005106 = 000002000000
003457  aa  2 00000 2351 00	lda  	pr2|0
003460  aa   000265 6700 04	tsp4 	181,ic		003745
						STATEMENT 1 ON LINE 544
		end;

						STATEMENT 1 ON LINE 545
		if utep ^= null () then ute.lvs_attached = "1"b;

003461  aa  6 01214 2371 00	ldaq 	pr6|652		utep
003462  aa   774430 6770 04	eraq 	-1768,ic		000112 = 077777000043 000001000000
003463  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003464  aa   777473 6000 04	tze  	-197,ic		003157
003465  aa   040000 2350 03	lda  	16384,du
003466  aa  6 01214 3735 20	epp7 	pr6|652,*		utep
003467  aa  7 00431 2551 00	orsa 	pr7|281		ute.lvs_attached
						STATEMENT 1 ON LINE 546
		go to unmask;

003470  aa   777467 7100 04	tra  	-201,ic		003157
						STATEMENT 1 ON LINE 547
	     end;

						STATEMENT 1 ON LINE 548
	end;

003471  aa  6 00446 0541 00	aos  	pr6|294		lvx
003472  aa   777674 7100 04	tra  	-68,ic		003366
						STATEMENT 1 ON LINE 550
	go to no_avail;

003473  aa   777401 7100 04	tra  	-255,ic		003074
ENTRY TO test                                               STATEMENT 1 ON LINE 687
test:	entry;

003474  da     000506200000
003475  aa   002100 6270 00	eax7 	1088
003476  aa  7 00034 3521 20	epp2 	pr7|28,*
003477  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003500  aa     000000000000
003501  aa     000000000000
003502  aa   775072 7000 04	tsx0 	-1478,ic		000574
						STATEMENT 1 ON LINE 689
	LV_RING = get_ring_ ();

003503  aa  6 00044 3701 20	epp4 	pr6|36,*
003504  ia  4 00010 3521 00	epp2 	pr4|8		LV_RING
003505  aa  6 01334 2521 00	spri2	pr6|732
003506  aa  6 01332 6211 00	eax1 	pr6|730
003507  aa   004000 4310 07	fld  	2048,dl
003510  la  4 00052 3521 20	epp2 	pr4|42,*		get_ring_
003511  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 690
	testing = "1"b;

003512  aa   400000 2350 03	lda  	131072,du
003513  aa  6 00044 3701 20	epp4 	pr6|36,*
003514  ia  4 00014 7551 00	sta  	pr4|12		testing
						STATEMENT 1 ON LINE 691
	SL0 = SL_LOG;

003515  aa   000001 2360 07	ldq  	1,dl
003516  ia  4 00011 7561 00	stq  	pr4|9		SL0
						STATEMENT 1 ON LINE 692
	return;

003517  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 873
     end;

BEGIN PROCEDURE list_vol_attachments
ENTRY TO list_vol_attachments                               STATEMENT 1 ON LINE 295
list_vol_attachments: proc;

003520  aa  6 01236 6501 00	spri4	pr6|670
						STATEMENT 1 ON LINE 297
	     call initializer_mdc_$lvat_scan_lv (lvname, array, n);

003521  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003522  aa  6 01504 2521 00	spri2	pr6|836
003523  aa  6 00105 3521 00	epp2 	pr6|69		array
003524  aa  6 01506 2521 00	spri2	pr6|838
003525  aa  6 00433 3521 00	epp2 	pr6|283		n
003526  aa  6 01510 2521 00	spri2	pr6|840
003527  aa   774346 3520 04	epp2 	-1818,ic		000075 = 526000000040
003530  aa  6 01512 2521 00	spri2	pr6|842
003531  aa   774421 3520 04	epp2 	-1775,ic		000152 = 404100000021
003532  aa  6 01514 2521 00	spri2	pr6|844
003533  aa   774350 3520 04	epp2 	-1816,ic		000103 = 404000000021
003534  aa  6 01516 2521 00	spri2	pr6|846
003535  aa  6 01502 6211 00	eax1 	pr6|834
003536  aa   014000 4310 07	fld  	6144,dl
003537  aa  6 00044 3701 20	epp4 	pr6|36,*
003540  la  4 00066 3521 20	epp2 	pr4|54,*		initializer_mdc_$lvat_scan_lv
003541  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 299
	     if n = 0 then do;

003542  aa  6 00433 2361 00	ldq  	pr6|283		n
003543  aa   000024 6010 04	tnz  	20,ic		003567
						STATEMENT 1 ON LINE 300
		if ^list_all_vols then
		     call ioa_ ("^/No attachments to LV ""^a"".", lvname);

003544  aa  6 00434 2351 00	lda  	pr6|284		list_all_vols
003545  aa   000021 6010 04	tnz  	17,ic		003566
003546  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003547  aa   774461 00 0034	desc9a	-1743,28		000227 = 136057116157
003550  aa  6 01502 00 0034	desc9a	pr6|834,28
003551  aa  6 01502 3521 00	epp2 	pr6|834
003552  aa  6 01522 2521 00	spri2	pr6|850
003553  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003554  aa  6 01524 2521 00	spri2	pr6|852
003555  aa   774312 3520 04	epp2 	-1846,ic		000067 = 524000000034
003556  aa  6 01526 2521 00	spri2	pr6|854
003557  aa   774316 3520 04	epp2 	-1842,ic		000075 = 526000000040
003560  aa  6 01530 2521 00	spri2	pr6|856
003561  aa  6 01520 6211 00	eax1 	pr6|848
003562  aa   010000 4310 07	fld  	4096,dl
003563  aa  6 00044 3701 20	epp4 	pr6|36,*
003564  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
003565  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 302
		return;

003566  aa  6 01236 6101 00	rtcd 	pr6|670
						STATEMENT 1 ON LINE 303
	     end;

						STATEMENT 1 ON LINE 305
	     call ioa_ ("^/LV ""^a"" Attachments:^/", lvname);

003567  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003570  aa   774424 00 0030	desc9a	-1772,24		000213 = 136057114126
003571  aa  6 01520 00 0030	desc9a	pr6|848,24
003572  aa  6 01520 3521 00	epp2 	pr6|848
003573  aa  6 01504 2521 00	spri2	pr6|836
003574  aa  6 00436 3521 00	epp2 	pr6|286		lvname
003575  aa  6 01506 2521 00	spri2	pr6|838
003576  aa   774245 3520 04	epp2 	-1883,ic		000043 = 524000000030
003577  aa  6 01510 2521 00	spri2	pr6|840
003600  aa   774275 3520 04	epp2 	-1859,ic		000075 = 526000000040
003601  aa  6 01512 2521 00	spri2	pr6|842
003602  aa  6 01502 6211 00	eax1 	pr6|834
003603  aa   010000 4310 07	fld  	4096,dl
003604  aa  6 00044 3701 20	epp4 	pr6|36,*
003605  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
003606  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 306
	     if ^shown_lvat_header then do;

003607  aa  6 00462 2351 00	lda  	pr6|306		shown_lvat_header
003610  aa   000017 6010 04	tnz  	15,ic		003627
						STATEMENT 1 ON LINE 307
		call ioa_ ("User^35tProcess_id^49tStatus^/");

003611  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003612  aa   774461 00 0040	desc9a	-1743,32		000272 = 125163145162
003613  aa  6 01520 00 0040	desc9a	pr6|848,32
003614  aa  6 01520 3521 00	epp2 	pr6|848
003615  aa  6 01504 2521 00	spri2	pr6|836
003616  aa   774224 3520 04	epp2 	-1900,ic		000042 = 524000000036
003617  aa  6 01506 2521 00	spri2	pr6|838
003620  aa  6 01502 6211 00	eax1 	pr6|834
003621  aa   004000 4310 07	fld  	2048,dl
003622  aa  6 00044 3701 20	epp4 	pr6|36,*
003623  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
003624  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 308
		shown_lvat_header = "1"b;

003625  aa   400000 2350 03	lda  	131072,du
003626  aa  6 00462 7551 00	sta  	pr6|306		shown_lvat_header
						STATEMENT 1 ON LINE 309
	     end;

						STATEMENT 1 ON LINE 311
	     do i = 1 to n;

003627  aa  6 00433 2361 00	ldq  	pr6|283		n
003630  aa  6 01244 7561 00	stq  	pr6|676
003631  aa   000001 2360 07	ldq  	1,dl
003632  aa  6 00432 7561 00	stq  	pr6|282		i
003633  aa   000000 0110 03	nop  	0,du
003634  aa  6 00432 2361 00	ldq  	pr6|282		i
003635  aa  6 01244 1161 00	cmpq 	pr6|676
003636  aa   000106 6054 04	tpnz 	70,ic		003744
						STATEMENT 1 ON LINE 312
		lvax = array (i);

003637  aa  6 00104 2361 06	ldq  	pr6|68,ql		array
003640  aa  6 00435 7561 00	stq  	pr6|285		lvax
						STATEMENT 1 ON LINE 313
		call get (lvax);

003641  aa   001307 3520 04	epp2 	711,ic		005150 = 000002000000
003642  aa   000336 6700 04	tsp4 	222,ic		004200
						STATEMENT 1 ON LINE 314
		call find_u (lvate.pid);

003643  aa  6 01212 3521 20	epp2 	pr6|650,*		lvate.pid
003644  aa  6 01522 2521 00	spri2	pr6|850
003645  aa  6 01520 3521 00	epp2 	pr6|848
003646  aa   004000 4310 07	fld  	2048,dl
003647  aa  2 00000 7571 00	staq 	pr2|0
003650  aa   000350 6700 04	tsp4 	232,ic		004220
						STATEMENT 1 ON LINE 315
		if lvate.mounted then status = "In use";

003651  aa  6 01212 3735 20	epp7 	pr6|650,*		lvatep
003652  aa  7 00016 2351 00	lda  	pr7|14		lvate.mounted
003653  aa   040000 3150 03	cana 	16384,du
003654  aa   000005 6000 04	tze  	5,ic		003661
003655  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003656  aa   774233 00 0006	desc9a	-1893,6		000110 = 111156040165
003657  aa  6 00463 00 0031	desc9a	pr6|307,25	status
003660  aa   000031 7100 04	tra  	25,ic		003711
						STATEMENT 1 ON LINE 316
		else if lvate.detach_requested then status = "Detaching";

003661  aa  7 00016 2351 00	lda  	pr7|14		lvate.detach_requested
003662  aa   100000 3150 03	cana 	32768,du
003663  aa   000005 6000 04	tze  	5,ic		003670
003664  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003665  aa   774241 00 0011	desc9a	-1887,9		000125 = 104145164141
003666  aa  6 00463 00 0031	desc9a	pr6|307,25	status
003667  aa   000022 7100 04	tra  	18,ic		003711
						STATEMENT 1 ON LINE 317
		else if lvate.waiting | lvate.pending_mount then status = "Waiting for mount";

003670  aa  7 00016 2351 00	lda  	pr7|14		lvate.pending_mount
003671  aa   420000 3150 03	cana 	139264,du
003672  aa   000005 6000 04	tze  	5,ic		003677
003673  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003674  aa   774274 00 0021	desc9a	-1860,17		000167 = 127141151164
003675  aa  6 00463 00 0031	desc9a	pr6|307,25	status
003676  aa   000013 7100 04	tra  	11,ic		003711
						STATEMENT 1 ON LINE 318
		else if lvate.invalidated then status = "Invalidated";

003677  aa  7 00016 2351 00	lda  	pr7|14		lvate.invalidated
003700  aa   010000 3150 03	cana 	4096,du
003701  aa   000005 6000 04	tze  	5,ic		003706
003702  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003703  aa   774220 00 0013	desc9a	-1904,11		000122 = 111156166141
003704  aa  6 00463 00 0031	desc9a	pr6|307,25	status
003705  aa   000004 7100 04	tra  	4,ic		003711
						STATEMENT 1 ON LINE 319
		else status = "??????";

003706  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003707  aa   774200 00 0006	desc9a	-1920,6		000106 = 077077077077
003710  aa  6 00463 00 0031	desc9a	pr6|307,25	status
						STATEMENT 1 ON LINE 321
		call ioa_ ("^33a ^12.3b  ^a", user_procname, user_procid,
		     status);

003711  aa   774231 2370 04	ldaq 	-1895,ic		000142 = 136063063141 040136061062
003712  aa  6 01520 7571 00	staq 	pr6|848
003713  aa   774231 2370 04	ldaq 	-1895,ic		000144 = 056063142040 040136141000
003714  aa  6 01522 7571 00	staq 	pr6|850
003715  aa  6 01520 3521 00	epp2 	pr6|848
003716  aa  6 01534 2521 00	spri2	pr6|860
003717  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
003720  aa  6 01536 2521 00	spri2	pr6|862
003721  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
003722  aa  6 01540 2521 00	spri2	pr6|864
003723  aa  6 00463 3521 00	epp2 	pr6|307		status
003724  aa  6 01542 2521 00	spri2	pr6|866
003725  aa   774141 3520 04	epp2 	-1951,ic		000066 = 524000000017
003726  aa  6 01544 2521 00	spri2	pr6|868
003727  aa   774144 3520 04	epp2 	-1948,ic		000073 = 526000000041
003730  aa  6 01546 2521 00	spri2	pr6|870
003731  aa   774153 3520 04	epp2 	-1941,ic		000104 = 514000000044
003732  aa  6 01550 2521 00	spri2	pr6|872
003733  aa   774106 3520 04	epp2 	-1978,ic		000041 = 526000000031
003734  aa  6 01552 2521 00	spri2	pr6|874
003735  aa  6 01532 6211 00	eax1 	pr6|858
003736  aa   020000 4310 07	fld  	8192,dl
003737  aa  6 00044 3701 20	epp4 	pr6|36,*
003740  la  4 00104 3521 20	epp2 	pr4|68,*		ioa_
003741  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 323
	     end;

003742  aa  6 00432 0541 00	aos  	pr6|282		i
003743  aa   777671 7100 04	tra  	-71,ic		003634
						STATEMENT 1 ON LINE 325
	     return;

003744  aa  6 01236 6101 00	rtcd 	pr6|670
						STATEMENT 1 ON LINE 326
	end list_vol_attachments;

  END PROCEDURE list_vol_attachments
BEGIN PROCEDURE beef
ENTRY TO beef                                               STATEMENT 1 ON LINE 555
beef:	proc (beef);

003745  aa  6 01246 6501 00	spri4	pr6|678
003746  aa  6 01250 2521 00	spri2	pr6|680
003747  aa  2 00002 3521 01	epp2 	pr2|2,au
003750  aa  6 01252 2521 00	spri2	pr6|682
003751  aa  2 00000 2361 20	ldq  	pr2|0,*
003752  aa   000002 6040 04	tmi  	2,ic		003754
003753  aa   777777 3760 07	anq  	262143,dl
003754  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003755  aa  6 01554 7561 00	stq  	pr6|876
						STATEMENT 1 ON LINE 559
	     call sys_log_$error_log (SL_LOG_BEEP, ec, "lv_request_",
		"Cannot send message to ^a ^12.3b: ^a", user_procname,
		user_procid, beef);

003756  aa   774155 2350 04	lda  	-1939,ic		000133 = 154166137162
003757  aa   774155 2360 04	ldq  	-1939,ic		000134 = 145161165145
003760  aa  6 01556 7571 00	staq 	pr6|878
003761  aa   774154 2350 04	lda  	-1940,ic		000135 = 163164137000
003762  aa  6 01560 7551 00	sta  	pr6|880
003763  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003764  aa   774327 00 0044	desc9a	-1833,36		000312 = 103141156156
003765  aa  6 01562 00 0044	desc9a	pr6|882,36
003766  aa   774114 3520 04	epp2 	-1972,ic		000102 = 000000000002
003767  aa  6 01576 2521 00	spri2	pr6|894
003770  aa  6 00427 3521 00	epp2 	pr6|279		ec
003771  aa  6 01600 2521 00	spri2	pr6|896
003772  aa  6 01556 3521 00	epp2 	pr6|878
003773  aa  6 01602 2521 00	spri2	pr6|898
003774  aa  6 01562 3521 00	epp2 	pr6|882
003775  aa  6 01604 2521 00	spri2	pr6|900
003776  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
003777  aa  6 01606 2521 00	spri2	pr6|902
004000  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
004001  aa  6 01610 2521 00	spri2	pr6|904
004002  aa  6 01250 3735 20	epp7 	pr6|680,*
004003  aa  7 00002 3521 20	epp2 	pr7|2,*		beef
004004  aa  6 01612 2521 00	spri2	pr6|906
004005  aa   774076 3520 04	epp2 	-1986,ic		000103 = 404000000021
004006  aa  6 01614 2521 00	spri2	pr6|908
004007  aa   774071 3520 04	epp2 	-1991,ic		000100 = 404000000043
004010  aa  6 01616 2521 00	spri2	pr6|910
004011  aa   774066 3520 04	epp2 	-1994,ic		000077 = 524000000013
004012  aa  6 01620 2521 00	spri2	pr6|912
004013  aa   774025 3520 04	epp2 	-2027,ic		000040 = 524000000044
004014  aa  6 01622 2521 00	spri2	pr6|914
004015  aa   774056 3520 04	epp2 	-2002,ic		000073 = 526000000041
004016  aa  6 01624 2521 00	spri2	pr6|916
004017  aa   774065 3520 04	epp2 	-1995,ic		000104 = 514000000044
004020  aa  6 01626 2521 00	spri2	pr6|918
004021  aa  6 01252 3715 20	epp5 	pr6|682,*
004022  aa  5 00000 3521 20	epp2 	pr5|0,*
004023  aa  6 01630 2521 00	spri2	pr6|920
004024  aa  6 01574 6211 00	eax1 	pr6|892
004025  aa   034000 4310 07	fld  	14336,dl
004026  aa  6 00044 3701 20	epp4 	pr6|36,*
004027  la  4 00124 3521 20	epp2 	pr4|84,*		sys_log_$error_log
004030  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 563
	     return;

004031  aa  6 01246 6101 00	rtcd 	pr6|678
						STATEMENT 1 ON LINE 564
	end;

  END PROCEDURE beef
BEGIN PROCEDURE attach
ENTRY TO attach                                             STATEMENT 1 ON LINE 566
attach:	proc;

004032  aa  6 01254 6501 00	spri4	pr6|684
						STATEMENT 1 ON LINE 568
	     call sys_log_ (SL0,
		"lv_request_: ATTACH^20tLV ^a to ^a ^12.3b.",
		lvname, user_procname, user_procid);

004033  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004034  aa   774340 00 0054	desc9a	-1824,44		000373 = 154166137162
004035  aa  6 01632 00 0054	desc9a	pr6|922,44
004036  aa  6 00044 3701 20	epp4 	pr6|36,*
004037  ia  4 00011 3521 00	epp2 	pr4|9		SL0
004040  aa  6 01650 2521 00	spri2	pr6|936
004041  aa  6 01632 3521 00	epp2 	pr6|922
004042  aa  6 01652 2521 00	spri2	pr6|938
004043  aa  6 00436 3521 00	epp2 	pr6|286		lvname
004044  aa  6 01654 2521 00	spri2	pr6|940
004045  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
004046  aa  6 01656 2521 00	spri2	pr6|942
004047  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
004050  aa  6 01660 2521 00	spri2	pr6|944
004051  aa   774032 3520 04	epp2 	-2022,ic		000103 = 404000000021
004052  aa  6 01662 2521 00	spri2	pr6|946
004053  aa   773764 3520 04	epp2 	-2060,ic		000037 = 524000000052
004054  aa  6 01664 2521 00	spri2	pr6|948
004055  aa   774020 3520 04	epp2 	-2032,ic		000075 = 526000000040
004056  aa  6 01666 2521 00	spri2	pr6|950
004057  aa   774014 3520 04	epp2 	-2036,ic		000073 = 526000000041
004060  aa  6 01670 2521 00	spri2	pr6|952
004061  aa   774023 3520 04	epp2 	-2029,ic		000104 = 514000000044
004062  aa  6 01672 2521 00	spri2	pr6|954
004063  aa  6 01646 6211 00	eax1 	pr6|934
004064  aa   024000 4310 07	fld  	10240,dl
004065  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
004066  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 571
	     if utep ^= null
		then call device_acct_$on (devtab_ix_lv, lvname, utep);

004067  aa  6 01214 2371 00	ldaq 	pr6|652		utep
004070  aa   774022 6770 04	eraq 	-2030,ic		000112 = 077777000043 000001000000
004071  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004072  aa   000022 6000 04	tze  	18,ic		004114
004073  aa  6 00044 3701 20	epp4 	pr6|36,*
004074  ia  4 00015 3521 00	epp2 	pr4|13		devtab_ix_lv
004075  aa  6 01650 2521 00	spri2	pr6|936
004076  aa  6 00436 3521 00	epp2 	pr6|286		lvname
004077  aa  6 01652 2521 00	spri2	pr6|938
004100  aa  6 01214 3521 00	epp2 	pr6|652		utep
004101  aa  6 01654 2521 00	spri2	pr6|940
004102  aa   774001 3520 04	epp2 	-2047,ic		000103 = 404000000021
004103  aa  6 01656 2521 00	spri2	pr6|942
004104  aa   773771 3520 04	epp2 	-2055,ic		000075 = 526000000040
004105  aa  6 01660 2521 00	spri2	pr6|944
004106  aa   773777 3520 04	epp2 	-2049,ic		000105 = 464000000000
004107  aa  6 01662 2521 00	spri2	pr6|946
004110  aa  6 01646 6211 00	eax1 	pr6|934
004111  aa   014000 4310 07	fld  	6144,dl
004112  la  4 00030 3521 20	epp2 	pr4|24,*		device_acct_$on
004113  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 573
	end;

004114  aa  6 01254 6101 00	rtcd 	pr6|684
  END PROCEDURE attach
BEGIN PROCEDURE detach
ENTRY TO detach                                             STATEMENT 1 ON LINE 575
detach:	proc;

004115  aa  6 01262 6501 00	spri4	pr6|690
						STATEMENT 1 ON LINE 577
	     call sys_log_ (SL0,
		"lv_request_: DETACH^20tLV ^a from ^a ^12.3b.", lvname,
		user_procname, user_procid);

004116  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004117  aa   774242 00 0054	desc9a	-1886,44		000360 = 154166137162
004120  aa  6 01674 00 0054	desc9a	pr6|956,44
004121  aa  6 00044 3701 20	epp4 	pr6|36,*
004122  ia  4 00011 3521 00	epp2 	pr4|9		SL0
004123  aa  6 01712 2521 00	spri2	pr6|970
004124  aa  6 01674 3521 00	epp2 	pr6|956
004125  aa  6 01714 2521 00	spri2	pr6|972
004126  aa  6 00436 3521 00	epp2 	pr6|286		lvname
004127  aa  6 01716 2521 00	spri2	pr6|974
004130  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
004131  aa  6 01720 2521 00	spri2	pr6|976
004132  aa  6 00555 3521 00	epp2 	pr6|365		user_procid
004133  aa  6 01722 2521 00	spri2	pr6|978
004134  aa   773747 3520 04	epp2 	-2073,ic		000103 = 404000000021
004135  aa  6 01724 2521 00	spri2	pr6|980
004136  aa   773700 3520 04	epp2 	-2112,ic		000036 = 524000000054
004137  aa  6 01726 2521 00	spri2	pr6|982
004140  aa   773735 3520 04	epp2 	-2083,ic		000075 = 526000000040
004141  aa  6 01730 2521 00	spri2	pr6|984
004142  aa   773731 3520 04	epp2 	-2087,ic		000073 = 526000000041
004143  aa  6 01732 2521 00	spri2	pr6|986
004144  aa   773740 3520 04	epp2 	-2080,ic		000104 = 514000000044
004145  aa  6 01734 2521 00	spri2	pr6|988
004146  aa  6 01710 6211 00	eax1 	pr6|968
004147  aa   024000 4310 07	fld  	10240,dl
004150  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
004151  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 581
	     if utep ^= null then
		call device_acct_$off (devtab_ix_lv, lvname, utep);

004152  aa  6 01214 2371 00	ldaq 	pr6|652		utep
004153  aa   773737 6770 04	eraq 	-2081,ic		000112 = 077777000043 000001000000
004154  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004155  aa   000022 6000 04	tze  	18,ic		004177
004156  aa  6 00044 3701 20	epp4 	pr6|36,*
004157  ia  4 00015 3521 00	epp2 	pr4|13		devtab_ix_lv
004160  aa  6 01712 2521 00	spri2	pr6|970
004161  aa  6 00436 3521 00	epp2 	pr6|286		lvname
004162  aa  6 01714 2521 00	spri2	pr6|972
004163  aa  6 01214 3521 00	epp2 	pr6|652		utep
004164  aa  6 01716 2521 00	spri2	pr6|974
004165  aa   773716 3520 04	epp2 	-2098,ic		000103 = 404000000021
004166  aa  6 01720 2521 00	spri2	pr6|976
004167  aa   773706 3520 04	epp2 	-2106,ic		000075 = 526000000040
004170  aa  6 01722 2521 00	spri2	pr6|978
004171  aa   773714 3520 04	epp2 	-2100,ic		000105 = 464000000000
004172  aa  6 01724 2521 00	spri2	pr6|980
004173  aa  6 01710 6211 00	eax1 	pr6|968
004174  aa   014000 4310 07	fld  	6144,dl
004175  la  4 00032 3521 20	epp2 	pr4|26,*		device_acct_$off
004176  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 584
	end;

004177  aa  6 01262 6101 00	rtcd 	pr6|690
  END PROCEDURE detach
BEGIN PROCEDURE get
ENTRY TO get                                                STATEMENT 1 ON LINE 586
get:	proc (a_lvax);

004200  aa  6 01270 6501 00	spri4	pr6|696
004201  aa  6 01272 2521 00	spri2	pr6|698
						STATEMENT 1 ON LINE 590
	     lvatep = addr (local_lvate);

004202  aa  6 01150 3735 00	epp7 	pr6|616		local_lvate
004203  aa  6 01212 6535 00	spri7	pr6|650		lvatep
						STATEMENT 1 ON LINE 591
	     call initializer_mdc_$retrieve_lvate (a_lvax, lvatep, xec);

004204  aa  2 00002 3521 20	epp2 	pr2|2,*		a_lvax
004205  aa  6 01740 2521 00	spri2	pr6|992
004206  aa  6 01212 3521 00	epp2 	pr6|650		lvatep
004207  aa  6 01742 2521 00	spri2	pr6|994
004210  aa  6 00430 3521 00	epp2 	pr6|280		xec
004211  aa  6 01744 2521 00	spri2	pr6|996
004212  aa  6 01736 6211 00	eax1 	pr6|990
004213  aa   014000 4310 07	fld  	6144,dl
004214  aa  6 00044 3701 20	epp4 	pr6|36,*
004215  la  4 00076 3521 20	epp2 	pr4|62,*		initializer_mdc_$retrieve_lvate
004216  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 592
	end;

004217  aa  6 01270 6101 00	rtcd 	pr6|696
  END PROCEDURE get
BEGIN PROCEDURE find_u
ENTRY TO find_u                                             STATEMENT 1 ON LINE 595
find_u:	proc (pid);

004220  aa  6 01276 6501 00	spri4	pr6|702
004221  aa  6 01300 2521 00	spri2	pr6|704
						STATEMENT 1 ON LINE 604
	     if testing then do;

004222  aa  6 00044 3701 20	epp4 	pr6|36,*
004223  ia  4 00014 2351 00	lda  	pr4|12		testing
004224  aa   000056 6000 04	tze  	46,ic		004302
						STATEMENT 1 ON LINE 605
		call get_userid_$info(pid, ape, aprj, tag, 0, anon, 0, ec);

004225  aa  6 01746 4501 00	stz  	pr6|998
004226  aa  6 01747 4501 00	stz  	pr6|999
004227  aa  2 00002 3521 20	epp2 	pr2|2,*		pid
004230  aa  6 01752 2521 00	spri2	pr6|1002
004231  aa  6 01304 3521 00	epp2 	pr6|708		ape
004232  aa  6 01754 2521 00	spri2	pr6|1004
004233  aa  6 01312 3521 00	epp2 	pr6|714		aprj
004234  aa  6 01756 2521 00	spri2	pr6|1006
004235  aa  6 01315 3521 00	epp2 	pr6|717		tag
004236  aa  6 01760 2521 00	spri2	pr6|1008
004237  aa  6 01746 3521 00	epp2 	pr6|998
004240  aa  6 01762 2521 00	spri2	pr6|1010
004241  aa  6 01316 3521 00	epp2 	pr6|718		anon
004242  aa  6 01764 2521 00	spri2	pr6|1012
004243  aa  6 01747 3521 00	epp2 	pr6|999
004244  aa  6 01766 2521 00	spri2	pr6|1014
004245  aa  6 00427 3521 00	epp2 	pr6|279		ec
004246  aa  6 01770 2521 00	spri2	pr6|1016
004247  aa   773635 3520 04	epp2 	-2147,ic		000104 = 514000000044
004250  aa  6 01772 2521 00	spri2	pr6|1018
004251  aa   773564 3520 04	epp2 	-2188,ic		000035 = 526000000030
004252  aa  6 01774 2521 00	spri2	pr6|1020
004253  aa   773561 3520 04	epp2 	-2191,ic		000034 = 526000000014
004254  aa  6 01776 2521 00	spri2	pr6|1022
004255  aa   773556 3520 04	epp2 	-2194,ic		000033 = 526000000001
004256  aa  6 02000 2521 00	spri2	pr6|1024
004257  aa   773624 3520 04	epp2 	-2156,ic		000103 = 404000000021
004260  aa  6 02002 2521 00	spri2	pr6|1026
004261  aa  6 02004 2521 00	spri2	pr6|1028
004262  aa  6 02006 2521 00	spri2	pr6|1030
004263  aa   773615 3520 04	epp2 	-2163,ic		000100 = 404000000043
004264  aa  6 02010 2521 00	spri2	pr6|1032
004265  aa  6 01750 6211 00	eax1 	pr6|1000
004266  aa   040000 4310 07	fld  	16384,dl
004267  la  4 00054 3521 20	epp2 	pr4|44,*		get_userid_$info
004270  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 606
		if ec = 0 then utep = addrel (null, 1);

004271  aa  6 00427 2361 00	ldq  	pr6|279		ec
004272  aa   000005 6010 04	tnz  	5,ic		004277
004273  aa   773617 3520 24	epp2 	-2161,ic*
004274  aa   000001 0520 03	adwp2	1,du
004275  aa  6 01214 2521 00	spri2	pr6|652		utep
004276  aa   000040 7100 04	tra  	32,ic		004336
						STATEMENT 1 ON LINE 607
		else utep = null;

004277  aa   773613 2370 04	ldaq 	-2165,ic		000112 = 077777000043 000001000000
004300  aa  6 01214 7571 00	staq 	pr6|652		utep
						STATEMENT 1 ON LINE 608
	     end;

004301  aa   000035 7100 04	tra  	29,ic		004336
						STATEMENT 1 ON LINE 609
	     else do;

						STATEMENT 1 ON LINE 610
		call as_$find_process (pid, (0), utep);

004302  aa  6 01747 4501 00	stz  	pr6|999
004303  aa  2 00002 3521 20	epp2 	pr2|2,*		pid
004304  aa  6 01752 2521 00	spri2	pr6|1002
004305  aa  6 01747 3521 00	epp2 	pr6|999
004306  aa  6 01754 2521 00	spri2	pr6|1004
004307  aa  6 01214 3521 00	epp2 	pr6|652		utep
004310  aa  6 01756 2521 00	spri2	pr6|1006
004311  aa  6 01750 6211 00	eax1 	pr6|1000
004312  aa   014000 4310 07	fld  	6144,dl
004313  la  4 00016 3521 20	epp2 	pr4|14,*		as_$find_process
004314  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 611
		if utep ^= null then do;

004315  aa  6 01214 2371 00	ldaq 	pr6|652		utep
004316  aa   773574 6770 04	eraq 	-2180,ic		000112 = 077777000043 000001000000
004317  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004320  aa   000016 6000 04	tze  	14,ic		004336
						STATEMENT 1 ON LINE 612
		     ape = ute.person;

004321  aa  6 01214 3735 20	epp7 	pr6|652,*		utep
004322  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004323  aa  7 00004 00 0030	desc9a	pr7|4,24		ute.person
004324  aa  6 01304 00 0030	desc9a	pr6|708,24	ape
						STATEMENT 1 ON LINE 613
		     aprj = ute.project;

004325  aa  7 00012 2351 00	lda  	pr7|10		ute.project
004326  aa  7 00013 2361 00	ldq  	pr7|11		ute.project
004327  aa  6 01312 7571 00	staq 	pr6|714		aprj
004330  aa  7 00014 2351 00	lda  	pr7|12		ute.project
004331  aa  6 01314 7551 00	sta  	pr6|716		aprj
						STATEMENT 1 ON LINE 614
		     tag = ute.tag;

004332  aa  7 00015 2351 00	lda  	pr7|13		ute.tag
004333  aa  6 01315 5511 40	stba 	pr6|717,40	tag
						STATEMENT 1 ON LINE 615
		     anon = ute.anonymous;

004334  aa  7 00016 2361 00	ldq  	pr7|14		ute.anonymous
004335  aa  6 01316 7561 00	stq  	pr6|718		anon
						STATEMENT 1 ON LINE 616
		end;

						STATEMENT 1 ON LINE 617
	     end;

						STATEMENT 1 ON LINE 618
	     if utep = null then user_procname = "PROCESSID";

004336  aa  6 01214 2371 00	ldaq 	pr6|652		utep
004337  aa   773553 6770 04	eraq 	-2197,ic		000112 = 077777000043 000001000000
004340  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004341  aa   000005 6010 04	tnz  	5,ic		004346
004342  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004343  aa   773555 00 0011	desc9a	-2195,9		000117 = 120122117103
004344  aa  6 00556 00 0041	desc9a	pr6|366,33	user_procname
004345  aa   000053 7100 04	tra  	43,ic		004420
						STATEMENT 1 ON LINE 619
	     else call ioa_$rsnnl("^[*^]^a.^a.^a", user_procname, (0),
		(anon=1), ape, aprj, tag);

004346  aa   773570 2370 04	ldaq 	-2184,ic		000136 = 136133052136 135136141056
004347  aa  6 01750 7571 00	staq 	pr6|1000
004350  aa   773570 2370 04	ldaq 	-2184,ic		000140 = 136141056136 141000000000
004351  aa  6 01752 7571 00	staq 	pr6|1002
004352  aa  6 01747 4501 00	stz  	pr6|999
004353  aa  6 01316 2361 00	ldq  	pr6|718		anon
004354  aa   000001 1160 07	cmpq 	1,dl
004355  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004356  aa  6 01746 7551 00	sta  	pr6|998
004357  aa  6 01750 3521 00	epp2 	pr6|1000
004360  aa  6 02014 2521 00	spri2	pr6|1036
004361  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
004362  aa  6 02016 2521 00	spri2	pr6|1038
004363  aa  6 01747 3521 00	epp2 	pr6|999
004364  aa  6 02020 2521 00	spri2	pr6|1040
004365  aa  6 01746 3521 00	epp2 	pr6|998
004366  aa  6 02022 2521 00	spri2	pr6|1042
004367  aa  6 01304 3521 00	epp2 	pr6|708		ape
004370  aa  6 02024 2521 00	spri2	pr6|1044
004371  aa  6 01312 3521 00	epp2 	pr6|714		aprj
004372  aa  6 02026 2521 00	spri2	pr6|1046
004373  aa  6 01315 3521 00	epp2 	pr6|717		tag
004374  aa  6 02030 2521 00	spri2	pr6|1048
004375  aa   773435 3520 04	epp2 	-2275,ic		000032 = 524000000015
004376  aa  6 02032 2521 00	spri2	pr6|1050
004377  aa   773474 3520 04	epp2 	-2244,ic		000073 = 526000000041
004400  aa  6 02034 2521 00	spri2	pr6|1052
004401  aa   773430 3520 04	epp2 	-2280,ic		000031 = 404000000005
004402  aa  6 02036 2521 00	spri2	pr6|1054
004403  aa   773425 3520 04	epp2 	-2283,ic		000030 = 514000000001
004404  aa  6 02040 2521 00	spri2	pr6|1056
004405  aa   773430 3520 04	epp2 	-2280,ic		000035 = 526000000030
004406  aa  6 02042 2521 00	spri2	pr6|1058
004407  aa   773425 3520 04	epp2 	-2283,ic		000034 = 526000000014
004410  aa  6 02044 2521 00	spri2	pr6|1060
004411  aa   773422 3520 04	epp2 	-2286,ic		000033 = 526000000001
004412  aa  6 02046 2521 00	spri2	pr6|1062
004413  aa  6 02012 6211 00	eax1 	pr6|1034
004414  aa   034000 4310 07	fld  	14336,dl
004415  aa  6 00044 3701 20	epp4 	pr6|36,*
004416  la  4 00106 3521 20	epp2 	pr4|70,*		ioa_$rsnnl
004417  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 621
	     user_procid = pid;

004420  aa  6 01300 3735 20	epp7 	pr6|704,*
004421  aa  7 00002 2351 20	lda  	pr7|2,*		pid
004422  aa  6 00555 7551 00	sta  	pr6|365		user_procid
						STATEMENT 1 ON LINE 623
	     return;

004423  aa  6 01276 6101 00	rtcd 	pr6|702
						STATEMENT 1 ON LINE 625
	end;

  END PROCEDURE find_u
BEGIN PROCEDURE any_other_handler
ENTRY TO any_other_handler                                  STATEMENT 1 ON LINE 628
any_other_handler: proc (mcp, cname, cop, inp, cont);

004424  da     000516200000
004425  aa   000140 6270 00	eax7 	96
004426  aa  7 00034 3521 20	epp2 	pr7|28,*
004427  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
004430  aa     000012000000
004431  aa     000000000000
004432  aa  6 00042 3735 20	epp7 	pr6|34,*
004433  aa  7 00002 2361 20	ldq  	pr7|2,*
004434  aa   000002 6040 04	tmi  	2,ic		004436
004435  aa   777777 3760 07	anq  	262143,dl
004436  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
004437  aa  6 00100 7561 00	stq  	pr6|64
						STATEMENT 1 ON LINE 632
	     if testing | ^initialized
	     | cname = "quit" | cname = "alrm" | cname = "program_interrupt"
	     | cname = "cput" | cname = "signal_io_" then do;

004440  ia  4 00014 2351 00	lda  	pr4|12		testing
004441  aa   000031 6010 04	tnz  	25,ic		004472
004442  ia  4 00012 2351 00	lda  	pr4|10		initialized
004443  aa   000027 6000 04	tze  	23,ic		004472
004444  aa  6 00032 3715 20	epp5 	pr6|26,*
004445  aa  5 00004 3535 20	epp3 	pr5|4,*
004446  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004447  aa  3 00000 00 0006	desc9a	pr3|0,ql		cname
004450  aa   773361 00 0004	desc9a	-2319,4		000027 = 161165151164
004451  aa   000021 6000 04	tze  	17,ic		004472
004452  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004453  aa  3 00000 00 0006	desc9a	pr3|0,ql		cname
004454  aa   773354 00 0004	desc9a	-2324,4		000026 = 141154162155
004455  aa   000015 6000 04	tze  	13,ic		004472
004456  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004457  aa  3 00000 00 0006	desc9a	pr3|0,ql		cname
004460  aa   773504 00 0021	desc9a	-2236,17		000162 = 160162157147
004461  aa   000011 6000 04	tze  	9,ic		004472
004462  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004463  aa  3 00000 00 0006	desc9a	pr3|0,ql		cname
004464  aa   773343 00 0004	desc9a	-2333,4		000025 = 143160165164
004465  aa   000005 6000 04	tze  	5,ic		004472
004466  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004467  aa  3 00000 00 0006	desc9a	pr3|0,ql		cname
004470  aa   773426 00 0012	desc9a	-2282,10		000114 = 163151147156
004471  aa   000007 6010 04	tnz  	7,ic		004500
						STATEMENT 1 ON LINE 635
		cont = "1"b;

004472  aa  6 00032 3715 20	epp5 	pr6|26,*
004473  aa  5 00012 3535 20	epp3 	pr5|10,*
004474  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
004475  aa   000000 00 0000	descb	0,0
004476  aa  3 00000 00 0001	descb	pr3|0,1		cont
						STATEMENT 1 ON LINE 636
		return;

004477  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 637
	     end;

						STATEMENT 1 ON LINE 639
	     call sys_log_ (SL_LOG_BEEP,
		"lv_request_: Unexpected condition ^a occurred.", cname);

004500  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004501  aa   773706 00 0060	desc9a	-2106,48		000406 = 154166137162
004502  aa  6 00102 00 0060	desc9a	pr6|66,48
004503  aa   773377 3520 04	epp2 	-2305,ic		000102 = 000000000002
004504  aa  6 00120 2521 00	spri2	pr6|80
004505  aa  6 00102 3521 00	epp2 	pr6|66
004506  aa  6 00122 2521 00	spri2	pr6|82
004507  aa  5 00004 3521 20	epp2 	pr5|4,*		cname
004510  aa  6 00124 2521 00	spri2	pr6|84
004511  aa   773372 3520 04	epp2 	-2310,ic		000103 = 404000000021
004512  aa  6 00126 2521 00	spri2	pr6|86
004513  aa   773311 3520 04	epp2 	-2359,ic		000024 = 524000000056
004514  aa  6 00130 2521 00	spri2	pr6|88
004515  aa  7 00002 3521 20	epp2 	pr7|2,*
004516  aa  6 00132 2521 00	spri2	pr6|90
004517  aa  6 00116 6211 00	eax1 	pr6|78
004520  aa   014000 4310 07	fld  	6144,dl
004521  la  4 00122 3521 20	epp2 	pr4|82,*		sys_log_
004522  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 641
	     call as_$dump ("lv_request_");

004523  aa   773410 2350 04	lda  	-2296,ic		000133 = 154166137162
004524  aa   773410 2360 04	ldq  	-2296,ic		000134 = 145161165145
004525  aa  6 00102 7571 00	staq 	pr6|66
004526  aa   773407 2350 04	lda  	-2297,ic		000135 = 163164137000
004527  aa  6 00104 7551 00	sta  	pr6|68
004530  aa  6 00102 3521 00	epp2 	pr6|66
004531  aa  6 00120 2521 00	spri2	pr6|80
004532  aa   773345 3520 04	epp2 	-2331,ic		000077 = 524000000013
004533  aa  6 00122 2521 00	spri2	pr6|82
004534  aa  6 00116 6211 00	eax1 	pr6|78
004535  aa   004000 4310 07	fld  	2048,dl
004536  aa  6 00044 3701 20	epp4 	pr6|36,*
004537  la  4 00110 3521 20	epp2 	pr4|72,*		as_$dump
004540  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 642
	     ec = 0;

004541  aa  6 00040 3735 20	epp7 	pr6|32,*
004542  aa  7 00427 4501 00	stz  	pr7|279		ec
						STATEMENT 1 ON LINE 643
	     do while (ec = 0);

004543  aa   000000 0110 03	nop  	0,du
004544  aa  6 00040 3735 20	epp7 	pr6|32,*
004545  aa  7 00427 2361 00	ldq  	pr7|279		ec
004546  aa   000011 6010 04	tnz  	9,ic		004557
						STATEMENT 1 ON LINE 644
		call ipc_$unmask_ev_calls (ec);

004547  aa  7 00427 3521 00	epp2 	pr7|279		ec
004550  aa  6 00104 2521 00	spri2	pr6|68
004551  aa  6 00102 6211 00	eax1 	pr6|66
004552  aa   004000 4310 07	fld  	2048,dl
004553  aa  6 00044 3701 20	epp4 	pr6|36,*
004554  la  4 00120 3521 20	epp2 	pr4|80,*		ipc_$unmask_ev_calls
004555  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 645
	     end;

004556  aa   777766 7100 04	tra  	-10,ic		004544
						STATEMENT 1 ON LINE 646
	     go to unmask;

004557  aa   776400 3520 04	epp2 	-768,ic		003157 = 600431235100
004560  aa   000001 7270 07	lxl7 	1,dl
004561  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 647
	end;

  END PROCEDURE any_other_handler
BEGIN PROCEDURE poll_mounts
ENTRY TO poll_mounts                                        STATEMENT 1 ON LINE 652
poll_mounts:
	proc;

004562  aa  6 01320 6501 00	spri4	pr6|720
						STATEMENT 1 ON LINE 655
	dtp = disk_table_$get_dtp ();

004563  aa  6 01204 3521 00	epp2 	pr6|644		dtp
004564  aa  6 02052 2521 00	spri2	pr6|1066
004565  aa  6 02050 6211 00	eax1 	pr6|1064
004566  aa   004000 4310 07	fld  	2048,dl
004567  aa  6 00044 3701 20	epp4 	pr6|36,*
004570  la  4 00040 3521 20	epp2 	pr4|32,*		disk_table_$get_dtp
004571  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 657
	call initializer_mdc_$poll_mounts (array, n, next_time);

004572  aa  6 00105 3521 00	epp2 	pr6|69		array
004573  aa  6 02056 2521 00	spri2	pr6|1070
004574  aa  6 00433 3521 00	epp2 	pr6|283		n
004575  aa  6 02060 2521 00	spri2	pr6|1072
004576  aa  6 00456 3521 00	epp2 	pr6|302		next_time
004577  aa  6 02062 2521 00	spri2	pr6|1074
004600  aa   773352 3520 04	epp2 	-2326,ic		000152 = 404100000021
004601  aa  6 02064 2521 00	spri2	pr6|1076
004602  aa   773301 3520 04	epp2 	-2367,ic		000103 = 404000000021
004603  aa  6 02066 2521 00	spri2	pr6|1078
004604  aa   773217 3520 04	epp2 	-2417,ic		000023 = 410000000107
004605  aa  6 02070 2521 00	spri2	pr6|1080
004606  aa  6 02054 6211 00	eax1 	pr6|1068
004607  aa   014000 4310 07	fld  	6144,dl
004610  aa  6 00044 3701 20	epp4 	pr6|36,*
004611  la  4 00072 3521 20	epp2 	pr4|58,*		initializer_mdc_$poll_mounts
004612  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 658
	if n > 0 
	     then do i = 1 to n;

004613  aa  6 00433 2361 00	ldq  	pr6|283		n
004614  aa   000247 6044 04	tmoz 	167,ic		005063
004615  aa  6 01326 7561 00	stq  	pr6|726
004616  aa   000001 2360 07	ldq  	1,dl
004617  aa  6 00432 7561 00	stq  	pr6|282		i
004620  aa  6 00432 2361 00	ldq  	pr6|282		i
004621  aa  6 01326 1161 00	cmpq 	pr6|726
004622  aa   000241 6054 04	tpnz 	161,ic		005063
						STATEMENT 1 ON LINE 660
	     call get (array (i));

004623  aa  6 00104 3521 06	epp2 	pr6|68,ql		array
004624  aa  6 02056 2521 00	spri2	pr6|1070
004625  aa  6 02054 3521 00	epp2 	pr6|1068
004626  aa   004000 4310 07	fld  	2048,dl
004627  aa  2 00000 7571 00	staq 	pr2|0
004630  aa   777350 6700 04	tsp4 	-280,ic		004200
						STATEMENT 1 ON LINE 661
	     do lvx = 1 to dt.n_lv_entries
		while (dt.lv_array (lvx).lvname ^= lvate.lvname | ^dt.lv_array (lvx).used);

004631  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
004632  aa  7 00005 2361 00	ldq  	pr7|5		dt.n_lv_entries
004633  aa  6 01327 7561 00	stq  	pr6|727
004634  aa   000001 2360 07	ldq  	1,dl
004635  aa  6 00446 7561 00	stq  	pr6|294		lvx
004636  aa  6 00446 2361 00	ldq  	pr6|294		lvx
004637  aa  6 01327 1161 00	cmpq 	pr6|727
004640  aa   000031 6054 04	tpnz 	25,ic		004671
004641  aa   000016 4020 07	mpy  	14,dl
004642  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
004643  aa  6 02072 7561 00	stq  	pr6|1082
004644  aa  7 00001 2361 00	ldq  	pr7|1		dt.max_n_entries
004645  aa   000016 4020 07	mpy  	14,dl
004646  aa   000010 0760 07	adq  	8,dl
004647  aa  6 02073 7561 00	stq  	pr6|1083
004650  aa   000002 0760 07	adq  	2,dl
004651  aa  6 02072 0761 00	adq  	pr6|1082
004652  aa  6 02074 7561 00	stq  	pr6|1084
004653  aa  7 77762 3715 06	epp5 	pr7|-14,ql	dt.lvname
004654  aa  6 01212 3535 20	epp3 	pr6|650,*		lvatep
004655  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
004656  aa  5 00000 00 0040	desc9a	pr5|0,32		dt.lvname
004657  aa  3 00003 00 0040	desc9a	pr3|3,32		lvate.lvname
004660  aa   000007 6010 04	tnz  	7,ic		004667
004661  aa  6 02073 2361 00	ldq  	pr6|1083
004662  aa   000001 0760 07	adq  	1,dl
004663  aa  6 02072 0761 00	adq  	pr6|1082
004664  aa  7 77762 2351 06	lda  	pr7|-14,ql	dt.used
004665  aa   400000 3150 03	cana 	131072,du
004666  aa   000003 6010 04	tnz  	3,ic		004671
						STATEMENT 1 ON LINE 663
	     end;

004667  aa  6 00446 0541 00	aos  	pr6|294		lvx
004670  aa   777746 7100 04	tra  	-26,ic		004636
						STATEMENT 1 ON LINE 664
	     if lvx <= dt.n_lv_entries then do;

004671  aa  6 00446 2361 00	ldq  	pr6|294		lvx
004672  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
004673  aa  7 00005 1161 00	cmpq 	pr7|5		dt.n_lv_entries
004674  aa   000165 6054 04	tpnz 	117,ic		005061
						STATEMENT 1 ON LINE 665
		unit_string = "";

004675  aa  6 00472 4501 00	stz  	pr6|314		unit_string
						STATEMENT 1 ON LINE 666
		do dtx = 1 to dt.n_entries;

004676  aa  7 00000 2361 00	ldq  	pr7|0		dt.n_entries
004677  aa  6 01330 7561 00	stq  	pr6|728
004700  aa   000001 2360 07	ldq  	1,dl
004701  aa  6 00426 7561 00	stq  	pr6|278		dtx
004702  aa  6 00426 2361 00	ldq  	pr6|278		dtx
004703  aa  6 01330 1161 00	cmpq 	pr6|728
004704  aa   000120 6054 04	tpnz 	80,ic		005024
						STATEMENT 1 ON LINE 667
		     dtep = addr (dt.array (dtx));

004705  aa   000016 4020 07	mpy  	14,dl
004706  aa  6 01204 3735 20	epp7 	pr6|644,*		dtp
004707  aa  7 77772 3735 06	epp7 	pr7|-6,ql		dt.array
004710  aa  6 01206 6535 00	spri7	pr6|646		dtep
						STATEMENT 1 ON LINE 668
		     if dte.lvx = lvx
			then if dte.pre_accepted
			then unit_string = unit_string || rtrim (dte.pvname) || " (" || rtrim (dte.drive_name) || ") ";

004711  aa  7 00002 2351 00	lda  	pr7|2		dte.lvx
004712  aa   000027 7350 00	als  	23
004713  aa   000074 7330 00	lrs  	60
004714  aa  6 00446 1161 00	cmpq 	pr6|294		lvx
004715  aa   000104 6010 04	tnz  	68,ic		005021
004716  aa  7 00002 2351 00	lda  	pr7|2		dte.pre_accepted
004717  aa   000001 3150 07	cana 	1,dl
004720  aa   000101 6000 04	tze  	65,ic		005021
004721  aa  000 000 165 500	tctr 	(pr)
004722  aa  7 00000 00 0010	desc9a	pr7|0,8		dte.drive_name
004723  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
004724  aa  6 00056 0001 00	arg  	pr6|46
004725  aa  6 00056 2361 00	ldq  	pr6|46
004726  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
004727  aa  6 02072 7561 00	stq  	pr6|1082
004730  aa   000010 2360 07	ldq  	8,dl
004731  aa  6 02072 1761 00	sbq  	pr6|1082
004732  aa  6 02072 7561 00	stq  	pr6|1082
004733  aa  000 000 165 500	tctr 	(pr)
004734  aa  7 00006 00 0040	desc9a	pr7|6,32		dte.pvname
004735  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
004736  aa  6 00056 0001 00	arg  	pr6|46
004737  aa  6 00056 2361 00	ldq  	pr6|46
004740  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
004741  aa  6 02073 7561 00	stq  	pr6|1083
004742  aa   000040 2360 07	ldq  	32,dl
004743  aa  6 02073 1761 00	sbq  	pr6|1083
004744  aa  6 02073 7561 00	stq  	pr6|1083
004745  aa  6 00472 0761 00	adq  	pr6|314		unit_string
004746  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
004747  aa  6 00472 7271 00	lxl7 	pr6|314		unit_string
004750  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
004751  aa  6 00473 00 0017	desc9a	pr6|315,x7	unit_string
004752  aa  2 00000 00 0017	desc9a	pr2|0,x7
004753  aa  6 00472 7271 00	lxl7 	pr6|314		unit_string
004754  aa  6 02073 2351 00	lda  	pr6|1083
004755  aa  040 157 100 540	mlr  	(pr,rl),(pr,rl,x7),fill(040)
004756  aa  7 00006 00 0005	desc9a	pr7|6,al		dte.pvname
004757  aa  2 00000 00 0005	desc9a	pr2|0,al
004760  aa  6 02073 7561 00	stq  	pr6|1083
004761  aa   000002 0760 07	adq  	2,dl
004762  aa  6 02074 7561 00	stq  	pr6|1084
004763  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
004764  aa  6 02073 2351 00	lda  	pr6|1083
004765  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
004766  aa   000172 00 0002	desc9a	122,2		005157 = 040050000000
004767  aa  2 00000 00 0002	desc9a	pr2|0,2
004770  aa  6 02074 2361 00	ldq  	pr6|1084
004771  aa  6 02072 0761 00	adq  	pr6|1082
004772  aa  6 02073 7561 00	stq  	pr6|1083
004773  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
004774  aa  6 02074 2351 00	lda  	pr6|1084
004775  aa  6 02072 2361 00	ldq  	pr6|1082
004776  aa  040 145 100 540	mlr  	(pr,rl),(pr,rl,al),fill(040)
004777  aa  7 00000 00 0006	desc9a	pr7|0,ql		dte.drive_name
005000  aa  2 00000 00 0006	desc9a	pr2|0,ql
005001  aa  6 02073 2361 00	ldq  	pr6|1083
005002  aa   000002 0760 07	adq  	2,dl
005003  aa  6 02074 7561 00	stq  	pr6|1084
005004  aa  0 00606 7001 00	tsx0 	pr0|390		cat_realloc_chars
005005  aa  6 02073 2351 00	lda  	pr6|1083
005006  aa  040 105 100 404	mlr  	(ic),(pr,al),fill(040)
005007  aa   000150 00 0002	desc9a	104,2		005156 = 051040000000
005010  aa  2 00000 00 0002	desc9a	pr2|0,2
005011  aa  6 02074 2361 00	ldq  	pr6|1084
005012  aa   000310 1160 07	cmpq 	200,dl
005013  aa   000002 6040 04	tmi  	2,ic		005015
005014  aa   000310 2360 07	ldq  	200,dl
005015  aa  6 00472 7561 00	stq  	pr6|314		unit_string
005016  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
005017  aa  2 00000 00 0006	desc9a	pr2|0,ql
005020  aa  6 00473 00 0006	desc9a	pr6|315,ql	unit_string
						STATEMENT 1 ON LINE 671
		end;

005021  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
005022  aa  6 00426 0541 00	aos  	pr6|278		dtx
005023  aa   777657 7100 04	tra  	-81,ic		004702
						STATEMENT 1 ON LINE 672
		if unit_string ^= "" then do;

005024  aa  6 00472 7271 00	lxl7 	pr6|314		unit_string
005025  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
005026  aa  6 00473 00 0017	desc9a	pr6|315,x7	unit_string
005027  aa   000131 00 0000	desc9a	89,0		005156 = 051040000000
005030  aa   000031 6000 04	tze  	25,ic		005061
						STATEMENT 1 ON LINE 673
		     call find_u (lvate.pid);

005031  aa  6 01212 3521 20	epp2 	pr6|650,*		lvate.pid
005032  aa  6 02056 2521 00	spri2	pr6|1070
005033  aa  6 02054 3521 00	epp2 	pr6|1068
005034  aa   004000 4310 07	fld  	2048,dl
005035  aa  2 00000 7571 00	staq 	pr2|0
005036  aa   777162 6700 04	tsp4 	-398,ic		004220
						STATEMENT 1 ON LINE 674
		     call initializer_mdc_$check_mount (array (i),
			user_procname, unit_string);

005037  aa  6 00432 7271 00	lxl7 	pr6|282		i
005040  aa  6 00104 3521 17	epp2 	pr6|68,7		array
005041  aa  6 02056 2521 00	spri2	pr6|1070
005042  aa  6 00556 3521 00	epp2 	pr6|366		user_procname
005043  aa  6 02060 2521 00	spri2	pr6|1072
005044  aa  6 00473 3521 00	epp2 	pr6|315		unit_string
005045  aa  6 02062 2521 00	spri2	pr6|1074
005046  aa   773035 3520 04	epp2 	-2531,ic		000103 = 404000000021
005047  aa  6 02064 2521 00	spri2	pr6|1076
005050  aa   773023 3520 04	epp2 	-2541,ic		000073 = 526000000041
005051  aa  6 02066 2521 00	spri2	pr6|1078
005052  aa   772750 3520 04	epp2 	-2584,ic		000022 = 530000000310
005053  aa  6 02070 2521 00	spri2	pr6|1080
005054  aa  6 02054 6211 00	eax1 	pr6|1068
005055  aa   014000 4310 07	fld  	6144,dl
005056  aa  6 00044 3701 20	epp4 	pr6|36,*
005057  la  4 00056 3521 20	epp2 	pr4|46,*		initializer_mdc_$check_mount
005060  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 676
		end;

						STATEMENT 1 ON LINE 677
	     end;

						STATEMENT 1 ON LINE 678
	end;

005061  aa  6 00432 0541 00	aos  	pr6|282		i
005062  aa   777536 7100 04	tra  	-162,ic		004620
						STATEMENT 1 ON LINE 680
	if next_time > 0
	     then call timer_manager_$alarm_wakeup (next_time, "00"b, evmessage.evchn);

005063  aa  6 00456 2371 00	ldaq 	pr6|302		next_time
005064  aa   000020 6044 04	tmoz 	16,ic		005104
005065  aa   000000 2350 07	lda  	0,dl
005066  aa  6 02074 7551 00	sta  	pr6|1084
005067  aa  6 00456 3521 00	epp2 	pr6|302		next_time
005070  aa  6 02056 2521 00	spri2	pr6|1070
005071  aa  6 02074 3521 00	epp2 	pr6|1084
005072  aa  6 02060 2521 00	spri2	pr6|1072
005073  aa  6 00032 3735 20	epp7 	pr6|26,*
005074  aa  7 00002 3715 20	epp5 	pr7|2,*		msgp
005075  aa  5 00000 3521 20	epp2 	pr5|0,*		evmessage.evchn
005076  aa  6 02062 2521 00	spri2	pr6|1074
005077  aa  6 02054 6211 00	eax1 	pr6|1068
005100  aa   014000 4310 07	fld  	6144,dl
005101  aa  6 00044 3701 20	epp4 	pr6|36,*
005102  la  4 00130 3521 20	epp2 	pr4|88,*		timer_manager_$alarm_wakeup
005103  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 684
	end;

005104  aa  6 01320 6101 00	rtcd 	pr6|720
  END PROCEDURE poll_mounts
  END PROCEDURE lv_request_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
