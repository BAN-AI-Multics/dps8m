	COMPILATION LISTING OF SEGMENT act_proc
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1005.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-05-09,Fawcett), approve(88-05-10,MCR7904),
       16*     audit(88-06-24,Farley), install(88-08-22,MR12.2-1087):
       17*     This change provides a cleanup based on the evolution of process creation.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style4 */
       22 
       23 /* ACT_PROC -	Procedure to create and/or activate a process
       24*   .		This procedure assumes that the calling process has directory privileges,
       25*   .		so that it can create the KST, PDS, and PIT in the new, upgraded process directory.
       26*
       27*   Last Modified: (Date and reason)
       28*   08/05/71 by Richard H. Gumpertz to combine pds, pdf
       29*   08/10/72 by Richard G. Bratt to implement "no permanent storage" users
       30*   740726 by PG to add AIM & audit info
       31*   741210 by PG to use privileged initiate on KST, PDS, and PIT.
       32*   750601 by RE Mullen (for priority scheduler) to call set_work_class
       33*   10/13/75 by R. Bratt for prelinking
       34*   760101 by REM for for deadline scheduler
       35*   03/23/76 by S. Webber for new reconfiguration
       36*   02/22/77 by THVV for dsegs with branches
       37*   May 1978 by T. Casey to use active_hardcore_data$pdir_quota as a default value rather than an upper limit on pdir quotas,
       38*   .		giving system and project administrators complete flexibility in using the per-user pdir quota mechanism.
       39*   August 1978 by Greenberg for variable-size DSEG's and KST's.
       40*   May 1979 by Mike Grady for ring 0 stack sharing.
       41*   Modified July 1979 by T. Casey for MR8.0 to add set_pit_tty_info entry point for process preservation across hangups.
       42*   Modified January 1981 by Benson I. Margulies for change of outer module on reconnection.
       43*   Modified February 1983 by E. N. Kittlitz for default kst 256k connection enabling.
       44*   Modified October 1984 by Keith Loepere to use fs_modes.
       45*   Modified 1984-11-11 by E. Swenson for IPC event channel validation;
       46*   act_proc$create initializes apte.ipc_r_offset.
       47*   Modified December 1984 by Keith Loepere to set pds$throttle_segment_state_changes.
       48*   Modified December 1984 by Keith Loepere for pdir_dir_quota.
       49**/
       50 
       51 act_proc: procedure;
       52 
       53 /* Variables */
       54 
       55 dcl  PRELINKED_DIR char (64);
       56 dcl  abs_ptr ptr;
       57 dcl  bc fixed bin (24);
       58 dcl  evolution fixed bin (17);			/* tracks the creation of a process */
       59 dcl  1 branch_info like create_branch_info aligned;	/* need auto store for this structure  */
       60 dcl  clr_size fixed bin;
       61 dcl  code fixed bin (35);
       62 dcl  ignore_code fixed bin (35);
       63 dcl  cp ptr;
       64 dcl  daemon_sw bit (1) aligned;
       65 dcl  dbr fixed bin (71);
       66 dcl  1 dir_acl (3) aligned,				/* structure for placing 3 ACLs on directories */
       67        2 userid char (32),
       68        2 mode bit (36),
       69        2 status_code fixed bin (35);
       70 dcl  dir_aclp ptr;
       71 dcl  dseg_ptr ptr;
       72 dcl  dseg_size fixed bin (19);
       73 dcl  dstep ptr;
       74 dcl  esw fixed bin;
       75 dcl  hd char (32);
       76 dcl  i fixed bin;
       77 dcl  is_absentee bit (1) aligned;
       78 dcl  kst_ptr ptr;
       79 dcl  kst_size fixed bin (19);
       80 dcl  local_audit_event_flags bit (36) aligned;
       81 dcl  lot_size fixed bin;
       82 dcl  max_authorization bit (72) aligned;
       83 dcl  max_lot fixed bin;
       84 dcl  n fixed bin;
       85 dcl  p ptr;
       86 dcl  p1 ptr;
       87 dcl  p2 ptr;
       88 dcl  pdir_dir_quota fixed bin (17);
       89 dcl  pdir_entry char (15);
       90 dcl  pdir_path char (32);
       91 dcl  pdir_quota fixed bin (17);
       92 dcl  pds_astep ptr;
       93 dcl  pds_ptr ptr;
       94 dcl  pid bit (36) aligned;
       95 dcl  process_authorization bit (72) aligned;
       96 dcl  process_group char (32) aligned;
       97 dcl  rings (3) fixed bin (3);
       98 dcl  savring fixed bin;
       99 dcl  1 seg_acl (3) aligned,				/* structure for placing 3 ACLs on segments */
      100        2 userid char (32),
      101        2 mode bit (36),
      102        2 exmode bit (36),
      103        2 status_code fixed bin (35);
      104 dcl  seg_aclp ptr;
      105 dcl  seg_rb (3) fixed bin;
      106 dcl  segno fixed bin;
      107 dcl  stop_type bit (1) aligned;
      108 dcl  template_dsegp ptr;
      109 dcl  template_kstp ptr;
      110 dcl  tsdw fixed bin (71);
      111 dcl  work_class fixed bin;
      112 
      113 /* Based */
      114 
      115 dcl  1 ack_name aligned based,
      116        2 person char (32),
      117        2 project char (32),
      118        2 tag char (1);
      119 dcl  based_dseg (0:n) fixed bin (71) based;
      120 dcl  copy_audit bit (36) aligned based;
      121 dcl  copy_authorization bit (72) aligned based;
      122 dcl  copy_chn_name fixed bin (71) based;
      123 dcl  copy_data (n) fixed bin based;
      124 dcl  copy_dir_name char (32) aligned based;
      125 dcl  copy_dstep bit (18) aligned based;
      126 dcl  copy_event_count fixed bin based;
      127 dcl  copy_group_id char (32) aligned based;
      128 dcl  copy_home_dir char (64) aligned based;
      129 dcl  copy_id bit (36) aligned based;
      130 dcl  copy_prelinked_ring (7) bit (1) unaligned based;
      131 dcl  copy_ptr ptr based;
      132 dcl  copy_ring fixed bin based;
      133 dcl  copy_size (0:7) fixed bin based;
      134 dcl  copy_throttle_seg_state_chg bit (1) aligned based;
      135 dcl  copy_time fixed bin (71) based;
      136 dcl  1 stack aligned based (sb),
      137        2 header like stack_header,
      138        2 first_frame fixed bin;
      139 
      140 /* External */
      141 
      142 dcl  abs_seg$ fixed bin ext;
      143 dcl  active_all_rings_data$default_max_segno fixed bin (17) ext;
      144 dcl  active_all_rings_data$hcscnt fixed bin (18) ext;
      145 dcl  active_all_rings_data$max_segno fixed bin (17) ext;
      146 dcl  active_all_rings_data$stack_base_segno fixed bin (18) ext;
      147 dcl  active_hardcore_data$pdir_dir_quota fixed bin ext;
      148 dcl  active_hardcore_data$pdir_quota fixed bin ext;
      149 dcl  dseg$ fixed bin ext;
      150 dcl  error_table_$ai_restricted fixed bin (35) external static;
      151 dcl  error_table_$apt_full fixed bin (35) external static;
      152 dcl  error_table_$invalid_subsystem fixed bin (35) ext;
      153 dcl  error_table_$smallarg fixed bin (35) external static;
      154 dcl  kst_seg$ fixed bin ext;
      155 dcl  pds$ fixed bin ext;
      156 dcl  pds$access_authorization bit (72) aligned external static;
      157 dcl  1 pds$access_name aligned external,
      158        2 person char (32),
      159        2 project char (32),
      160        2 tag char (1);
      161 dcl  pds$account_id bit (36) aligned external;
      162 dcl  pds$apt_ptr ptr ext;
      163 dcl  pds$audit_flags bit (36) aligned external static;
      164 dcl  pds$clr_stack_size (0:7) fixed bin ext;
      165 dcl  pds$covert_event_count fixed bin ext;
      166 dcl  pds$dstep bit (18) aligned ext;
      167 dcl  pds$first_covert_event_time fixed bin (71) ext;
      168 dcl  pds$highest_ring fixed bin ext;
      169 dcl  pds$home_dir char (168) aligned external;
      170 dcl  pds$initial_procedure ptr ext;
      171 dcl  pds$initial_ring fixed bin ext;
      172 dcl  pds$interrupt_ring fixed bin ext;
      173 dcl  pds$last_sp ptr ext aligned;
      174 dcl  pds$lock_id bit (36) aligned ext;
      175 dcl  pds$lot_stack_size (0:7) fixed bin ext;
      176 dcl  pds$max_access_authorization bit (72) aligned external static;
      177 dcl  pds$max_lot_size (0:7) fixed bin ext;
      178 dcl  pds$prelinked_ring (7) bit (1) unaligned ext;
      179 dcl  pds$process_dir_name char (32) aligned ext;
      180 dcl  pds$process_group_id char (32) aligned ext;
      181 dcl  pds$processid bit (36) aligned ext;
      182 dcl  pds$term_channel fixed bin (71) ext;
      183 dcl  pds$term_proc bit (36) aligned external;
      184 dcl  pds$throttle_segment_state_changes bit (1) aligned ext;
      185 dcl  sst$seg_state_change_limit fixed bin external;
      186 dcl  sys_info$access_class_ceiling bit (72) aligned external static;
      187 dcl  sys_info$default_256K_enable fixed bin ext;
      188 dcl  sys_info$page_size fixed bin ext;
      189 dcl  sys_info$time_of_bootload fixed bin (71) ext;
      190 dcl  tc_data$pdscopyl fixed bin ext;
      191 dcl  tc_data$stat (0:5) fixed bin ext;
      192 dcl  tc_data$timax fixed bin ext;
      193 dcl  template_pds$ fixed bin ext;
      194 
      195 /* Entries */
      196 
      197 dcl  acc_name_$elements entry (ptr, ptr, fixed bin (35));
      198 dcl  access_audit_$check_general_user entry (bit (36) aligned, bit (36) aligned, bit (72) aligned, bit (36) aligned) returns (bit (1) aligned);
      199 dcl  aim_check_$greater_or_equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      200 dcl  append$branchx entry (char (*), char (*), fixed bin (5), (3) fixed bin, char (*) aligned, fixed bin, fixed bin, fixed bin (24), fixed bin (35));
      201 dcl  append$create_branch_ entry (char (*), char (*), ptr, fixed bin (35));
      202 dcl  asd_$replace_dall entry (char (*), char (*), ptr, fixed bin, bit (1) aligned, fixed bin (35));
      203 dcl  asd_$replace_sall entry (char (*), char (*), ptr, fixed bin, bit (1) aligned, fixed bin (35));
      204 dcl  chname$cfile entry (char (*), char (*), char (*), char (*), fixed bin (35));
      205 dcl  delentry$dfile entry (char (*), char (*), fixed bin (35));
      206 dcl  del_dir_tree entry (char (*), char (*), fixed bin (35));
      207 dcl  fs_modes entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
      208 dcl  get_ptrs_$given_astep ext entry (ptr) returns (fixed bin (71));
      209 dcl  getuid ext entry returns (bit (36) aligned);
      210 dcl  grab_aste entry (ptr, fixed bin (18), fixed bin (35)) returns (ptr);
      211 dcl  grab_aste$prewithdraw entry (ptr, fixed bin (18), fixed bin (35)) returns (ptr);
      212 dcl  init_proc entry;
      213 dcl  initiate entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
      214 dcl  initiate$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
      215 dcl  initiate$priv_init entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
      216 dcl  level$get ext entry (fixed bin);
      217 dcl  level$set ext entry (fixed bin);
      218 dcl  pxss$empty_t ext entry (ptr);
      219 dcl  pxss$get_entry ext entry (ptr);
      220 dcl  pxss$set_work_class ext entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      221 dcl  syserr$error_code entry options (variable);
      222 dcl  terminate_$noname ext entry (ptr, fixed bin (35));
      223 dcl  unique_chars_ entry (bit (*)) returns (char (15));
      224 
      225 /* constants */
      226 
      227 dcl  CREATE init (0) fixed bin static options (constant);
      228 dcl  INFO init (1) fixed bin static options (constant);
      229 dcl  NORMAL_EVOLUTION_TERMINATION init (1) fixed bin static options (constant);
      230 dcl  REW_bit bit (5) static options (constant) init ("1110"b);
      231 dcl  RW_mode fixed bin (5) initial (01010b) static options (constant); /* mode bits for segments we create */
      232 dcl  SMA_bit bit (5) static options (constant) init ("111"b);
      233 dcl  SMA_mode fixed bin (5) initial (01011b) static options (constant); /* mode bits for directories we create */
      234 dcl  dir_rb (3) fixed bin static options (constant) init (7, 7, 7);
      235 
      236 /* builtins */
      237 
      238 dcl  (addr, baseno, baseptr, binary, bin, bit, clock, divide, fixed, length, max, min, null, ptr, rel, rtrim, size, string, substr, unspec) builtin;
      239 
      240 /* Parameters */
      241 
      242 dcl  a_code fixed bin (35) parameter;
      243 dcl  ci_ptr ptr parameter;
      244 
      245 create: entry (ci_ptr, a_code);
      246 
      247 
      248 	evolution = NORMAL_EVOLUTION_TERMINATION;	/* the normal evolution exit */
      249 
      250 	esw = CREATE;				/* set entry switch indicating create entry */
      251 	cp = ci_ptr;				/* copy input pointer */
      252 	call level$get (savring);			/* save validation level */
      253 	call level$set (0);				/* and reset to zero */
      254 
      255 /* Validate the process authorization & max authorization against the system access_ceiling */
      256 
      257 	process_authorization = cp -> create_info.process_authorization;
      258 	max_authorization = cp -> create_info.max_process_authorization;
      259 
      260 	if ^aim_check_$greater_or_equal (sys_info$access_class_ceiling, max_authorization)
      261 	then go to return_ai_error;
      262 
      263 	if ^aim_check_$greater_or_equal (max_authorization, process_authorization) then do;
      264 
      265 return_ai_error:
      266 	     code = error_table_$ai_restricted;		/* auth <= max <= ceiling */
      267 	     go to EVOLUTION_CLEANUP (evolution);
      268 	end;
      269 
      270 	call pxss$get_entry (aptep);			/* get an APT entry for the new process */
      271 	if aptep = null then do;			/* if null, no more room */
      272 	     code = error_table_$apt_full;		/* return non-zero code */
      273 	     go to EVOLUTION_CLEANUP (evolution);
      274 	end;
      275 
      276 	evolution = evolution + 1;			/* ADD apte removal */
      277 
      278 	cp -> create_info.processid.rel_apte = rel (aptep); /* return rest of processid */
      279 	pid = string (cp -> create_info.processid);	/* copy the processid */
      280 	pdir_entry = unique_chars_ ((pid));
      281 	pdir_path = ">process_dir_dir>" || pdir_entry;	/* get path name */
      282 
      283 	process_group = cp -> create_info.process_group_id; /* copy process group id */
      284 
      285 	stop_type = "1"b;				/* assume this is answering service 7.4 or higher */
      286 
      287 /* Create an upgraded process directory */
      288 
      289 	pdir_quota = cp -> create_info.record_quota;
      290 	if pdir_quota = 0 then			/* if they blow it with the new pdir quota mechanism */
      291 	     pdir_quota = active_hardcore_data$pdir_quota;/* be reasonable */
      292 	pdir_quota = max (pdir_quota, 20);		/* make sure it's enough to get running */
      293 
      294 	pdir_dir_quota = cp -> create_info.dir_quota;
      295 	if pdir_dir_quota = 0 then
      296 	     pdir_dir_quota = active_hardcore_data$pdir_dir_quota;
      297 	pdir_dir_quota = max (pdir_dir_quota, 10);	/* make sure it's enough to get running */
      298 
      299 	unspec (branch_info) = "0"b;
      300 	branch_info.version = create_branch_version_2;
      301 	branch_info.mode = substr (SMA_bit, 1, length (branch_info.mode));
      302 	branch_info.rings (1) = dir_rb (1);
      303 	branch_info.rings (2) = dir_rb (2);
      304 	branch_info.rings (3) = dir_rb (3);
      305 	branch_info.userid = pds$process_group_id;
      306 	branch_info.switches.dir_sw = "1"b;
      307 	branch_info.switches.copy_sw = "0"b;
      308 	branch_info.switches.chase_sw = "0"b;		/* don't chase links */
      309 	branch_info.parent_ac_sw = "0"b;		/* Upgrade the dir */
      310 	branch_info.switches.priv_upgrade_sw = "0"b;	/* really move quota from >pdd */
      311 	branch_info.bitcnt = 0;
      312 	branch_info.quota = pdir_quota;
      313 	branch_info.dir_quota = pdir_dir_quota;
      314 	branch_info.access_class = process_authorization;
      315 
      316 	call append$create_branch_ (">process_dir_dir", pdir_entry, addr (branch_info), code);
      317 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      318 
      319 
      320 	do i = 1 to 3;				/* set up access control lists */
      321 	     seg_acl (i).mode = REW_bit;		/* Default access for process dir segments is REW */
      322 	     seg_acl (i).exmode = "0"b;		/* and no extended mode set */
      323 	     dir_acl (i).mode = SMA_bit;		/* Default access for process dir is SMA */
      324 	end;
      325 
      326 	evolution = evolution + 1;			/* increment the evolution to include the process_dir */
      327 
      328 	seg_acl (1).userid = process_group;		/* give access to created process first */
      329 	dir_acl (1).userid = process_group;
      330 	seg_acl (2).userid = pds$process_group_id;	/* give access to system control */
      331 	dir_acl (2).userid = pds$process_group_id;
      332 	seg_acl (3).userid = "*.*.*";			/* ... everybody else */
      333 	dir_acl (3).userid = "*.*.*";
      334 	seg_acl (3).mode,				/* give null access to everyone else */
      335 	     dir_acl (3).mode = "0"b;
      336 
      337 	seg_aclp = addr (seg_acl (1).userid);		/* get pointer to segment ACL */
      338 	dir_aclp = addr (dir_acl (1).userid);		/* get pointer to directory ACL */
      339 
      340 	daemon_sw = "1"b;				/* Don't add "*.SysDaemon.*" to ACLs */
      341 	call asd_$replace_dall (">process_dir_dir", pdir_entry, dir_aclp, 3, daemon_sw, code); /* directory branch acl */
      342 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      343 
      344 	call create_hardcore_seg ("dseg", dseg_ptr);	/* create descriptor segment */
      345 	if dseg_ptr = null then go to EVOLUTION_CLEANUP (evolution);
      346 
      347 	evolution = evolution + 1;			/* increment the evolution to show the creation of segments */
      348 
      349 	call create_hardcore_seg ("kst", kst_ptr);	/* create known segment table KST */
      350 	if kst_ptr = null then go to EVOLUTION_CLEANUP (evolution);
      351 
      352 
      353 	call create_hardcore_seg ("pds", pds_ptr);	/* create process data segment (PDS) */
      354 	if pds_ptr = null then go to EVOLUTION_CLEANUP (evolution);
      355 
      356 	n = tc_data$pdscopyl;			/* copy the template PDS */
      357 	pds_ptr -> copy_data = addr (template_pds$) -> copy_data;
      358 
      359 	if cp -> create_info.version > 4
      360 	then PRELINKED_DIR = cp -> create_info.subsystem;
      361 	else PRELINKED_DIR = "";
      362 
      363 	if PRELINKED_DIR ^= "" then do;
      364 	     template_dsegp, template_kstp = null ();	/* init for cleanup */
      365 	     call initiate (PRELINKED_DIR, "template_kst", "", 0, 0, template_kstp, code);
      366 	     if template_kstp = null ()
      367 	     then do;
      368 bad_subsystem:
      369 		code = error_table_$invalid_subsystem;
      370 		go to EVOLUTION_CLEANUP (evolution);
      371 	     end;
      372 	     evolution = evolution + 1;		/* Need to terminate reference to template_kst if abort */
      373 	     if template_kstp -> kst.time_of_bootload ^= sys_info$time_of_bootload | ^template_kstp -> kst.template
      374 	     then go to bad_subsystem;
      375 	     call fs_modes (template_kstp, ("0"b), ("0"b), rings, code);
      376 	     if code ^= 0 | rings (1) ^= 0 then go to bad_subsystem;
      377 	     n = bin (rel (addr (template_kstp -> kst.kst_entry (template_kstp -> kst.highseg + 1))));
      378 	     kst_ptr -> copy_data = template_kstp -> copy_data;
      379 	     ptr (pds_ptr, rel (addr (pds$prelinked_ring))) -> copy_prelinked_ring = kst_ptr -> kst.prelinked_ring;
      380 	     call terminate_$noname (template_kstp, code);
      381 	     if code ^= 0 then go to bad_subsystem;
      382 	     evolution = evolution - 1;		/* decrement because reference to template_kst terminated */
      383 	end;
      384 						/* Compute the sizes and locations of the LOT and CLR */
      385 
      386 	lot_size = cp -> create_info.lot_size;
      387 	clr_size = cp -> create_info.cls_size;
      388 	max_lot = cp -> create_info.kst_size;
      389 	if max_lot = 0 then max_lot = active_all_rings_data$default_max_segno + 1;
      390 	max_lot = min (max_lot, active_all_rings_data$max_segno + 1);
      391 	if max_lot <= active_all_rings_data$hcscnt
      392 	then do;
      393 	     code = error_table_$smallarg;
      394 	     call syserr$error_code (LOG, code, "act_proc: KST size specified (^d) less than minimum (^d). Creating process for ^a.", max_lot, active_all_rings_data$hcscnt, cp -> create_info.process_group_id);
      395 	     go to EVOLUTION_CLEANUP (evolution);
      396 	end;
      397 
      398 /* Now fill in the per-process variables into the new pds */
      399 	if cp -> create_info.lot_in_stack then do;
      400 	     p = ptr (pds_ptr, rel (addr (pds$lot_stack_size (0))));
      401 	     do i = 0 to 7;
      402 		p -> copy_size (i) = lot_size;
      403 	     end;
      404 	end;
      405 
      406 	if cp -> create_info.cls_in_stack then do;
      407 	     p = ptr (pds_ptr, rel (addr (pds$clr_stack_size (0))));
      408 	     do i = 0 to 7;
      409 		p -> copy_size (i) = clr_size;
      410 	     end;
      411 	end;
      412 
      413 	p = ptr (pds_ptr, rel (addr (pds$max_lot_size (0))));
      414 	do i = 0 to 7;
      415 	     p -> copy_size (i) = max_lot;
      416 	end;
      417 
      418 	p = ptr (pds_ptr, rel (addr (pds$processid)));	/* fill in process id */
      419 	p -> copy_id = pid;
      420 
      421 	p = ptr (pds_ptr, rel (addr (pds$lock_id)));
      422 	p -> copy_id = getuid ();			/* Get lock ID */
      423 
      424 	p = ptr (pds_ptr, rel (addr (pds$apt_ptr)));	/* fill in APT entry pointer */
      425 	p -> copy_ptr = aptep;
      426 
      427 	p = ptr (pds_ptr, rel (addr (pds$account_id)));	/* initialize pds$account id */
      428 	p -> copy_id = pds$account_id;
      429 
      430 	p = ptr (pds_ptr, rel (addr (pds$process_dir_name))); /* initialize pds$process_dir_name */
      431 	p -> copy_dir_name = pdir_path;
      432 
      433 	p = ptr (pds_ptr, rel (addr (pds$process_group_id))); /* initialize pds$process_group_id */
      434 	p -> copy_group_id = process_group;
      435 
      436 	p = ptr (pds_ptr, rel (addr (pds$initial_ring))); /* copy intial ring into pds */
      437 	p -> copy_ring = cp -> create_info.initial_ring;
      438 
      439 	p = ptr (pds_ptr, rel (addr (pds$initial_procedure)));
      440 	p -> copy_ptr = addr (init_proc);		/* Set initial procedure for process. */
      441 
      442 	p = ptr (pds_ptr, rel (addr (pds$last_sp)));
      443 	sb = baseptr (active_all_rings_data$stack_base_segno);
      444 	p -> copy_ptr = addr (stack.first_frame);	/* Setup first time stack ptr */
      445 
      446 	p = ptr (pds_ptr, rel (addr (pds$interrupt_ring))); /* copy interrupt ring into pds */
      447 	p -> copy_ring = cp -> create_info.initial_ring;	/* use initial ring for users */
      448 
      449 	p = ptr (pds_ptr, rel (addr (pds$highest_ring))); /* copy highest ring into pds */
      450 	p -> copy_ring = cp -> create_info.highest_ring;
      451 
      452 	p = ptr (pds_ptr, rel (addr (pds$access_name)));	/* fill in 3 part access name in pds */
      453 	call acc_name_$elements (addr (process_group), p, code);
      454 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      455 	if p -> ack_name.tag = "m" then is_absentee = "1"b;
      456 	else is_absentee = "0"b;
      457 
      458 	p1 = ptr (pds_ptr, rel (addr (pds$term_proc)));	/* copy terminate process id into pds */
      459 	p1 -> copy_id = cp -> create_info.term_processid;
      460 
      461 	p1 = ptr (pds_ptr, rel (addr (pds$term_channel)));/* copy terminate channel name into pds */
      462 	p1 -> copy_chn_name = cp -> create_info.term_channel;
      463 
      464 	p = ptr (pds_ptr, rel (addr (pds$access_authorization)));
      465 	p -> copy_authorization = process_authorization;
      466 
      467 	p = ptr (pds_ptr, rel (addr (pds$max_access_authorization)));
      468 	p -> copy_authorization = max_authorization;
      469 
      470 	p = ptr (pds_ptr, rel (addr (pds$audit_flags)));
      471 	p -> copy_audit = cp -> create_info.audit;
      472 
      473 	seg_rb (1) = 0;				/* create pit with rb of (0, 5, 5) */
      474 	seg_rb (2), seg_rb (3) = cp -> create_info.highest_ring;
      475 	pit_ptr = null;
      476 	call append$branchx (pdir_path, "pit", (RW_mode), seg_rb, process_group, 0, 0, 0, code);
      477 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      478 
      479 	call asd_$replace_sall (pdir_path, "pit", seg_aclp, 3, daemon_sw, code);
      480 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      481 
      482 	call initiate$priv_init (pdir_path, "pit", "", 0, 0, pit_ptr, code);
      483 	if pit_ptr = null then go to EVOLUTION_CLEANUP (evolution);
      484 	n = cp -> create_info.words_of_pit;		/* copy the pit template */
      485 	pit_ptr -> copy_data = cp -> create_info.pit_ptr -> copy_data;
      486 	p2 = ptr (pds_ptr, rel (addr (pds$home_dir)));
      487 	if substr (ptr (pit_ptr, cp -> create_info.homedir) -> copy_home_dir, 1, 5) ^= "[pd]>"
      488 	then p2 -> copy_home_dir = ptr (pit_ptr, cp -> create_info.homedir) -> copy_home_dir;
      489 	else do;
      490 	     hd = substr (ptr (pit_ptr, cp -> create_info.homedir) -> copy_home_dir, 6, 32);
      491 	     call append$branchx (pdir_path, hd, (SMA_mode), dir_rb, process_group, 1, 0, 0, code);
      492 	     if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      493 	     call asd_$replace_dall (pdir_path, hd, dir_aclp, 3, daemon_sw, code); /* directory acl */
      494 	     if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      495 						/* fill in true home directory in PIT */
      496 	     p2 -> copy_home_dir = rtrim (pdir_path) || ">" || rtrim (hd);
      497 	     ptr (pit_ptr, cp -> create_info.homedir) -> copy_home_dir = p2 -> copy_home_dir;
      498 	end;
      499 
      500 	call terminate_$noname (pit_ptr, code);		/* terminate copy */
      501 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      502 
      503 	aptep -> apte.processid = pid;		/* set up process id in KPT entry */
      504 
      505 	aptep -> apte.access_authorization = cp -> create_info.process_authorization;
      506 	work_class = cp -> create_info.work_class;	/* Yes */
      507 	call pxss$set_work_class (pid, work_class, 0, code); /* Set it */
      508 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution); /* Unable to set it */
      509 
      510 /*	go to common;				/* go to activate this process */
      511 /**/
      512 /* activate: entry(aaptep, a_code);			/* entry to activate an inactive process */
      513 
      514 /* dcl  aaptep ptr;					/* pointer to KPT (APT) entry */
      515 /* dcl  ACTIVATE init (2) fixed bin static options (constant); */
      516 
      517 /*	esw = ACTIVATE;				/* set entry switch for activate entry */
      518 /*        evolution = NORMAL_EVOLUTION_TERMINATION */
      519 /*	stop_type = "1"b;				/* I guess. */
      520 /*	aptep = aaptep;				/* pick up pointer to KPT entry */
      521 /*	pid = aptep -> apte.processid;		/* pick up process id */
      522 /*	call level$get(savring);			/* save validation level */
      523 /*	call level$set(0);				/* reset validation level to zero */
      524 /*	pdir_entry = unique_chars_((pid));		/* compute process directory entry name */
      525 /*	pdir_path = ">process_dir_dir>" || pdir_entry; */
      526 /*	call initiate$priv_init (pdir_path, "dseg", "", 0, 0, dseg_ptr, code); /* initiate dseg */
      527 /*	if dseg_ptr = null then go to EVOLUTION_CLEANUP (evolution); */
      528 /*	call initiate$priv_init (pdir_path, "kst", "", 0, 0, kst_ptr, code); /* initiate KST */
      529 /*	if kst_ptr = null then go to EVOLUTION_CLEANUP (evolution); */
      530 /*	call initiate$priv_init (pdir_path, "pds", "", 0, 0, pds_ptr, code); /* initiate PDS */
      531 /*	if pds_ptr = null then go to  EVOLUTION_CLEANUP (evolution); */
      532 /* COMMENTED OUT BECAUSE IT'S NOT PRESENTLY USED. */
      533 /* CAUTION: if the activate entry point is ever revieved then PRELINKED_DIR */
      534 /*          must be stored in the guys pds.  Some where the segments need to */
      535 /*	  be terminated if the activation is aborted. This should be in  */
      536 /*	  EVOLUTION_CLEANUP condition by the value of esw */
      537 
      538 common:	abs_ptr = addr (abs_seg$);			/* create process code joins activate code here */
      539 	n = active_all_rings_data$hcscnt - 1;		/* Set up descriptor segment for new process. */
      540 						/* copy all SDW's up to first stacks (ring 0) SDW */
      541 	dseg_ptr -> based_dseg = addr (dseg$) -> based_dseg;
      542 	dseg_size = size (sdw) * max_lot;
      543 	call set_ehs (dseg_ptr, "1"b, divide (dseg_size + sys_info$page_size - 1, sys_info$page_size, 17, 0));
      544 	segno = bin (baseno (addr (dseg$)), 18);	/* Get segno of dseg */
      545 	dseg_ptr -> sdwa (segno).add = addr (tsdw) -> sdw.add; /* Fill in page table addr */
      546 	dseg_ptr -> sdwa (segno).bound = bit (fixed (divide (dseg_size + 15, 16, 17, 0) - 1, 14), 14);
      547 	dseg_ptr -> sdwa (segno).entry_bound = bit (divide (active_all_rings_data$stack_base_segno, 8, 14, 0), 14);
      548 	dstep = astep;				/* Save ptr to ASTE for dseg */
      549 	unspec (dbr) = string (dseg_ptr -> sdwa (segno));
      550 
      551 	if PRELINKED_DIR ^= "" then do;
      552 	     call initiate$initiate_count (PRELINKED_DIR, "template_dseg", "", bc, 0, template_dsegp, code);
      553 	     if template_dsegp = null () then go to bad_subsystem;
      554 	     evolution = evolution + 1;		/* Need to terminate reference to template_dseg if abort */
      555 	     call fs_modes (template_dsegp, ("0"b), ("0"b), rings, code);
      556 	     if code ^= 0 then go to bad_subsystem;
      557 	     if rings (1) ^= 0 then go to bad_subsystem;
      558 	     n = divide (bc, 72, 17, 0) - active_all_rings_data$hcscnt;
      559 	     if n <= 0 then go to bad_subsystem;
      560 	     addr (dseg_ptr -> sdwa (active_all_rings_data$hcscnt)) -> based_dseg =
      561 		addr (template_dsegp -> sdwa (active_all_rings_data$hcscnt)) -> based_dseg;
      562 	     call terminate_$noname (template_dsegp, code);
      563 	     evolution = evolution - 1;		/* decrement because reference to template_dseg terminated */
      564 	end;
      565 
      566 	p = ptr (pds_ptr, rel (addr (pds$dstep)));	/* save pointer to hardcore DST entry */
      567 	p -> copy_dstep = rel (dstep);
      568 	kst_size = size (kst) + size (kste) * (max_lot - active_all_rings_data$hcscnt + 1);
      569 	if kst_ptr -> kst.highseg = 0 then kst_ptr -> kst.highseg = max_lot - 1;
      570 	kst_ptr -> kst.allow_256K_connect = sys_info$default_256K_enable ^= 0;
      571 						/* Init for non pre-linked process */
      572 	call set_ehs (kst_ptr, "0"b, divide (kst_size + sys_info$page_size - 1, sys_info$page_size, 17, 0));
      573 	segno = bin (baseno (addr (kst_seg$)), 18);
      574 	dseg_ptr -> based_dseg (segno) = tsdw;
      575 
      576 	call set_ehs (pds_ptr, "1"b, 4);		/* Force PDS active and prewithdraw */
      577 	segno = bin (baseno (addr (pds$)), 18);
      578 	dseg_ptr -> based_dseg (segno) = tsdw;
      579 	pds_astep = astep;
      580 
      581 	aptep -> apte.timax = tc_data$timax;		/* initialize to default timax */
      582 	aptep -> apte.flags.state = bit (bin (4, 18), 18);/* set execution state to blocked */
      583 	tc_data$stat (4) = tc_data$stat (4) + 1;	/* up count of blocked processes */
      584 	aptep -> apte.asteps.pds = rel (pds_astep);	/* save ptr to PDS-AST entry */
      585 	aptep -> apte.asteps.dseg = rel (dstep);	/* save ptr to hardcore DST entry */
      586 	aptep -> apte.dbr = dbr;			/* save descriptor segment base register value */
      587 	aptep -> apte.flags2.batch = is_absentee;	/* DIGS wants to know .. */
      588 	aptep -> apte.lock_id = ptr (pds_ptr, rel (addr (pds$lock_id))) -> copy_id;
      589 						/* Place in pds as well */
      590 	aptep -> apte.ws_size = 0;			/* assume no pages to start */
      591 	aptep -> apte.term_processid = ptr (pds_ptr, rel (addr (pds$term_proc))) -> copy_id;
      592 	aptep -> apte.term_channel = ptr (pds_ptr, rel (addr (pds$term_channel))) -> copy_chn_name;
      593 	aptep -> apte.deadline,			/* set deadline here */
      594 	     aptep -> apte.state_change_time = clock ();	/* Initialize it */
      595 
      596 	local_audit_event_flags = "0"b;		/* set throttle_segment_state_changes */
      597 	addr (local_audit_event_flags) -> audit_event_flags.grant = "1"b;
      598 	addr (local_audit_event_flags) -> audit_event_flags.cc_10_100 = "1"b;
      599 	ptr (pds_ptr, rel (addr (pds$throttle_segment_state_changes))) -> copy_throttle_seg_state_chg =
      600 	     access_audit_$check_general_user (local_audit_event_flags, "0"b, process_authorization, cp -> create_info.audit);
      601 
      602 	ptr (pds_ptr, rel (addr (pds$covert_event_count))) -> copy_event_count = -sst$seg_state_change_limit; /* page_fault counts up to 0 */
      603 	ptr (pds_ptr, rel (addr (pds$first_covert_event_time))) -> copy_time = clock ();
      604 
      605 /**** Here we set up apte.ipc_r_offset.  This is an 18-bit unsigned
      606*      integer used by IPC to validate event channel names in conjunction
      607*      with apte.ipc_r_factor.  This latter number is determined later,
      608*      when the process first runs, to provide an indeterminate delay between
      609*      the creation of these values.  The delay is necessary to make it
      610*      difficult to guess the value of apte.ipc_r_factor given the value
      611*      of apte.ipc_r_offset. */
      612 
      613 	aptep -> apte.ipc_r_offset =
      614 	     binary (substr (bit (binary (clock (), 54), 54), 37, 18), 18);
      615 
      616 /**** Set the value of apte.ipc_r_factor to zero for debugging purposes
      617*      so that we can determine whether it is getting set or not later. */
      618 
      619 	aptep -> apte.ipc_r_factor = 0;
      620 
      621 	call terminate_$noname (dseg_ptr, code);	/* Terminate dseg */
      622 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      623 	call terminate_$noname (kst_ptr, code);		/* terminate KST */
      624 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      625 	call terminate_$noname (pds_ptr, code);		/* terminate PDS */
      626 	if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      627 
      628 	if esw = CREATE then do;			/* some special stuff left to do if create entry */
      629 
      630 	     if cp -> create_info.timax > 0 then aptep -> apte.timax = cp -> create_info.timax;
      631 	     if cp -> create_info.user_processid ^= " " then do; /* additional name for process directory */
      632 		call chname$cfile (">process_dir_dir", pdir_entry, "", (cp -> create_info.user_processid), code);
      633 		if code ^= 0 then go to EVOLUTION_CLEANUP (evolution);
      634 	     end;
      635 
      636 	end;
      637 
      638 	code = 0;
      639 
      640 	go to EVOLUTION_CLEANUP (NORMAL_EVOLUTION_TERMINATION); /* go set level and return */
      641 
      642 
      643 EVOLUTION_CLEANUP (5):
      644 	if esw = CREATE then do;
      645 	     if template_kstp ^= null ()
      646 	     then call terminate_$noname (template_kstp, ignore_code);
      647 	     if template_dsegp ^= null ()
      648 	     then call terminate_$noname (template_dsegp, ignore_code);
      649 	end;
      650 
      651 EVOLUTION_CLEANUP (4):				/* delete any segments that have been created */
      652 	if esw = CREATE then
      653 	     call del_dir_tree (">process_dir_dir", pdir_entry, ignore_code);
      654 
      655 EVOLUTION_CLEANUP (3):				/* delete the process dir */
      656 	if esw = CREATE then
      657 	     call delentry$dfile (">process_dir_dir", pdir_entry, ignore_code);
      658 
      659 EVOLUTION_CLEANUP (2):				/* Give back the APTE */
      660 	if esw = CREATE then
      661 	     call pxss$empty_t (aptep);
      662 
      663 EVOLUTION_CLEANUP (1):				/* restore validation level */
      664 	call level$set (savring);
      665 						/* tell caller what went wrong if any thing did. */
      666 	a_code = code;
      667 	return;
      668 
      669 set_pit_tty_info: entry (a_pid, a_pitp, a_code);
      670 
      671 dcl  a_pid bit (36) aligned parameter;
      672 dcl  a_pitp ptr parameter;
      673 
      674 dcl  pitp ptr;
      675 
      676 	esw = INFO;
      677 
      678 /* Copy args */
      679 	pid = a_pid;
      680 	pitp = a_pitp;
      681 	code = 0;
      682 						/* Bookkeeping */
      683 
      684 	call level$get (savring);			/* save current validation level and set it to zero */
      685 	call level$set (0);
      686 	evolution = NORMAL_EVOLUTION_TERMINATION;
      687 	pdir_entry = unique_chars_ ((pid));		/* compute entry name of user's pdir */
      688 	pdir_path = ">process_dir_dir>" || pdir_entry;	/* get full pathname of pdir */
      689 	pit_ptr = null;
      690 	call initiate$priv_init (pdir_path, "pit", "", 0, 0, pit_ptr, code); /* initiate exiting pit */
      691 	if pit_ptr = null then go to EVOLUTION_CLEANUP (evolution);
      692 
      693 /* Copy new tty info from template pit into user's pit */
      694 
      695 	pit_ptr -> pit.tty = pitp -> pit.tty;
      696 	pit_ptr -> pit.old_tty = pitp -> pit.old_tty;
      697 	pit_ptr -> pit.terminal_access_class = pitp -> pit.terminal_access_class;
      698 	pit_ptr -> pit.line_type = pitp -> pit.line_type;
      699 	pit_ptr -> pit.term_type_name = pitp -> pit.term_type_name;
      700 	pit_ptr -> pit.service_type = pitp -> pit.service_type;
      701 	pit_ptr -> pit.charge_type = pitp -> pit.charge_type;
      702 	pit_ptr -> pit.tty_answerback = pitp -> pit.tty_answerback;
      703 	pit_ptr -> pit.tty_type = pitp -> pit.tty_type;
      704 	pit_ptr -> pit.outer_module = pitp -> pit.outer_module;
      705 
      706 /* Clean up and return */
      707 
      708 	call terminate_$noname (pit_ptr, code);
      709 	go to EVOLUTION_CLEANUP (evolution);		/* go set level and return */
      710 
      711 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      712 
      713 
      714 
      715 create_hardcore_seg: procedure (seg_name, seg_ptr);	/* internal procedure to create hardcore segments */
      716 
      717 dcl  seg_name char (*) parameter;			/* segment branch name */
      718 dcl  seg_ptr ptr parameter;				/* pointer to segment (returned) */
      719 
      720 	seg_rb (1), seg_rb (2), seg_rb (3) = 0;		/* ring brackets of 0-0-0 on pds and kst */
      721 	seg_ptr = null;
      722 	call append$branchx (pdir_path, seg_name, (RW_mode), seg_rb, process_group, 0, 0, 0, code); /* create branch */
      723 	if code ^= 0 then return;
      724 
      725 	call asd_$replace_sall (pdir_path, seg_name, seg_aclp, 3, daemon_sw, code);
      726 	if code ^= 0 then return;
      727 
      728 	call initiate$priv_init (pdir_path, seg_name, "", 0, 0, seg_ptr, code); /* initiate created segment */
      729 
      730      end create_hardcore_seg;
      731 
      732 set_ehs: proc (segptr, prw, size1);
      733 
      734 dcl  prw bit (1) aligned parameter;
      735 dcl  segptr ptr parameter;
      736 dcl  size1 fixed bin parameter;
      737 
      738 dcl  size2 fixed bin (18);
      739 
      740 	size2 = 1024 * size1;
      741 	if prw then astep = grab_aste$prewithdraw (segptr, size2, code);
      742 	else astep = grab_aste (segptr, size2, code);	/* force activate the entry */
      743 	if code ^= 0 then call syserr$error_code (1, code, "act_proc: from grab_aste");
      744 	tsdw = get_ptrs_$given_astep (astep);
      745 	addr (tsdw) -> sdw.cache = "1"b;		/* KST and PDS are non-shared */
      746 	return;
      747 
      748      end set_ehs;
      749 
      750 /* format: off */
      751  /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
      751 
      752  /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  2     2 
  2     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  2     4 
  2     5 dcl  aptep pointer;
  2     6 
  2     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  2     8     2 thread unaligned,				/* List thread */
  2     9       3 fp bit (18),				/* Forward pointer */
  2    10       3 bp bit (18),				/* Backward pointer */
  2    11     2 flags unaligned,				/* Flags and miscellaneous */
  2    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  2    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  2    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  2    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  2    16       3 hproc bit (1),				/* ON if process is hardcore process */
  2    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  2    18       3 eligible bit (1),				/* ON if process is eligible */
  2    19       3 idle bit (1),				/* ON if  this is an idle process */
  2    20       3 interaction bit (1),				/* ON if process has interacted recently */
  2    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  2    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  2    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  2    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  2    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  2    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  2    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  2    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  2    29       3 firstsw bit (1),				/* OFF until process is intialized */
  2    30       3 state bit (18),				/* execution state */
  2    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  2    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  2    33 						/* bit 18-35: sequential number */
  2    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  2    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  2    36     2 ti fixed bin (35),				/* virtual time since interaction */
  2    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  2    38 
  2    39 /* * * * * * * * */
  2    40 
  2    41     2 ipc_pointers unaligned,
  2    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  2    43       3 pad3 bit (18),
  2    44     2 ips_message bit (36),				/* IPS signals pending */
  2    45     2 asteps unaligned,				/* relative ASTE pointers */
  2    46       3 pds bit (18),				/* PDS (per-process) */
  2    47       3 dseg bit (18),				/* DSEG (per-process) */
  2    48       3 prds bit (18),				/* PRDS (per-processor) */
  2    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  2    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  2    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  2    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  2    53 
  2    54 /* * * * * * * * */
  2    55 
  2    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  2    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  2    58     2 flags2 unaligned,
  2    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  2    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  2    61       3 pad7 bit (7),
  2    62       3 batch bit (1),				/* ON if absentee */
  2    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  2    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  2    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  2    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  2    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  2    68 
  2    69 /* * * * * * */
  2    70 
  2    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  2    72     2 ws_size fixed bin,				/* working set estimate for the process */
  2    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  2    74     2 deadline fixed bin (71),			/* time of next run */
  2    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  2    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  2    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  2    78*						/* reaches this (units = 1/1024 sec) */
  2    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  2    80     2 access_authorization bit (72),			/* authorization of this process */
  2    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  2    82 
  2    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  2    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  2    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  2    86 
  2    87 /*  Cells used to drive and instrument finite-state model for response time
  2    88*    measurement. Maintained by meter_response_time */
  2    89 
  2    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  2    91     2 pad18 bit (18) unaligned,
  2    92     2 number_processing fixed bin (35),			/* Number interactions */
  2    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  2    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  2    95 
  2    96 /* * * * * * */
  2    97 
  2    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  2    99 
  2   100 /*  End of cells for finite-state model */
  2   101 
  2   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  2   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  2   104     2 pad4 bit (28) unaligned,
  2   105     2 ipc_r_offset fixed bin (18) unsigned,
  2   106     2 ipc_r_factor fixed bin (35) unsigned,
  2   107     2 apad (10) fixed bin (35);
  2   108 
  2   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      752 
      753  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      753 
      754  /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  4     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  4     7*       1. Declare version constant properly.
  4     8*       2. Remove version 1 since it was never referenced and to force
  4     9*          callers to upgrade their programs.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  4    14 
  4    15 /* this include files gives the argument structure for create_branch_ */
  4    16 
  4    17 dcl 1 create_branch_info aligned based,
  4    18     2 version fixed bin,				/* set this to the largest value given below */
  4    19     2 switches unaligned,
  4    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  4    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  4    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  4    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  4    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  4    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  4    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  4    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  4    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  4    29     2 userid char (32),				/* user's access control name */
  4    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  4    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  4    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  4    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  4    34 
  4    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  4    36 
  4    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  4    38 
      754 
      755  /* BEGIN INCLUDE FILE ... create_info.incl.pl1 */
  5     2 
  5     3 /* Last Modified on 10/04/72 by Richard G. Bratt to implement "no permanent storage" users
  5     4*   and to reserve space for lot-in-stack and cls-in-stack modifications */
  5     5 /* Modified 740723 by PG to add AIM & audit info */
  5     6 /* Modified May 1975 by R. Mullen to add work_class and change version from 3 to 4 */
  5     7 /* Modified 24 Oct 75 by T. Casey to add subsystem and change version from 4 to 5 */
  5     8 /* Modified 27 Dec 84 by Keith Loepere to add dir_quota and change version to 6. */
  5     9 
  5    10 dcl  version_of_create_info fixed bin int static init (6);	/* Current version number of this structure. */
  5    11 
  5    12 /* Version history:		VERSION	CHANGE
  5    13*   *			   1
  5    14*   *			   2
  5    15*   *			   3	added AIM and audit info - PG - July 75
  5    16*   *			   4	added work_class - TAC - Aug 75
  5    17*   *			   5	added subsystem - TAC - Oct 75
  5    18*   *			   6	added dir_quota - KPL - Dec 84
  5    19*   *
  5    20**/
  5    21 
  5    22 
  5    23 dcl 1 create_info aligned based,			/* structure which is used to transfer */
  5    24 						/* information to act_proc */
  5    25     2 processid,					/* id of process to be created */
  5    26       3 rel_apte bit (18) unaligned,			/* returned from act_proc */
  5    27       3 unique_index bit (18) unaligned,		/* unique number supplied by answering service */
  5    28     2 version fixed bin,				/* identification of this structure */
  5    29     2 term_channel fixed bin (71),			/* channel for signalling process termination */
  5    30     2 term_processid bit (36) aligned,			/* process id of answering service */
  5    31     2 words_of_pit fixed bin,				/* length in words of PIT */
  5    32     2 record_quota fixed bin,				/* disk quota */
  5    33     2 ppml fixed bin,				/* drum quota */
  5    34     2 initial_ring fixed bin (3),			/* initial ring of created process */
  5    35     2 highest_ring fixed bin (3),			/* highest ring a process can transfer out to */
  5    36     2 timax fixed bin,				/* scheduling parameter for the process */
  5    37     2 account_ptr ptr,
  5    38     2 pit_ptr ptr,					/* pointer to pit template */
  5    39     2 process_group_id char (32) aligned,
  5    40     2 user_processid char (32) aligned,
  5    41     2 account_id char (32) aligned,			/* name of account */
  5    42     2 homedir bit (18),				/* offset of homedir name in pit */
  5    43     2 lot_size fixed bin,				/* size of lot */
  5    44     2 cls_size fixed bin,				/* size of initial combined linkage section */
  5    45     2 kst_size fixed bin,				/* number of entries in each kst array */
  5    46     2 dont_call_init_admin bit (1) aligned,		/* the process overseer of this process should be
  5    47*						   called directly from ring 0 */
  5    48     2 lot_in_stack bit (1) aligned,			/* one if lot should go in stack */
  5    49     2 cls_in_stack bit (1) aligned,			/* one if initial cls should go in stack */
  5    50     2 audit bit (36),				/* audit flags for user */
  5    51     2 process_authorization bit (72),			/* access_authorization of this process */
  5    52     2 max_process_authorization bit (72),		/* maximum access authorization of this user. */
  5    53     2 work_class fixed bin,				/* (0 to 16) specifies scheduler group */
  5    54     2 subsystem char (64),				/* directory in which to find prelinked process */
  5    55     2 dir_quota fixed bin;				/* dir quota for pdir */
  5    56 
  5    57 /* END INCLUDE FILE ... create_info.incl.pl1 */
      755 
      756  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  6     2 
  6     3 /*
  6     4*Modified March 1976 by R. Bratt 
  6     5*Modified November 1984 to remove hdr, Keith Loepere. */
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  6    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  6    11*     Add warning on use of kste.entryp.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl  pds$kstp ext ptr,
  6    16     (kstp, kstep) ptr;
  6    17 
  6    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  6    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  6    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  6    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  6    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  6    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  6    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  6    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  6    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  6    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  6    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  6    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  6    30     2 unused_2 bit (9) unaligned,
  6    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  6    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  6    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  6    34     2 end_of_kst bit (36);
  6    35 
  6    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  6    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  6    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  6    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  6    40     2 entryp ptr unaligned,				/* branch pointer */
  6    41 						/* See WARNING below for requirements to use entryp. */
  6    42     2 uid bit (36) aligned,				/* unique identifier */
  6    43     2 access_information unaligned,
  6    44       3 dtbm bit (36),				/* date time branch modified */
  6    45       3 extended_access bit (33),			/* extended access from the branch */
  6    46       3 access bit (3),				/* rew */
  6    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  6    48     2 pad1 bit (3) unaligned,
  6    49     2 flags unaligned,
  6    50       3 dirsw bit (1),				/* directory switch */
  6    51       3 allow_write bit (1),				/* set if initiated with write permission */
  6    52       3 priv_init bit (1),				/* privileged initiation */
  6    53       3 tms bit (1),				/* transparent modification switch */
  6    54       3 tus bit (1),				/* transparent usage switch */
  6    55       3 tpd bit (1),				/* transparent paging device switch */
  6    56       3 audit bit (1),				/* audit switch */
  6    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  6    58       3 pad bit (3),
  6    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  6    60 
  6    61 
  6    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    63 /*							       */
  6    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  6    65 /* entry associated with the kst entry, you must first validate its value    */
  6    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  6    67 /* the containing directory.  The containing directory must remain locked    */
  6    68 /* during the entire period when kste.entryp and the directory entry are     */
  6    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  6    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  6    71 /* directory since the dir entry could have been moved within the directory  */
  6    72 /* by another processor.					       */
  6    73 /*							       */
  6    74 /* If you only need a pointer to the directory containing the associated     */
  6    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  6    76 /*    pointer (kste.entryp, 0)				       */
  6    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  6    78 /*							       */
  6    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    80 
  6    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      756 
      757  /* BEGIN INCLUDE FILE ... pit.incl.pl1 */
  7     2 
  7     3 /****^  ********************************************
  7     4*        *                                          *
  7     5*        * Copyright, (C) Honeywell Bull Inc., 1988 *
  7     6*        *                                          *
  7     7*        ******************************************** */
  7     8 
  7     9 /* Requires user_attributes.incl.pl1 */
  7    10 /* Declaration of the Process Inititalization Table  (PIT) */
  7    11 
  7    12 /****^  HISTORY COMMENTS:
  7    13*  1) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
  7    14*     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
  7    15*     First comment for hcom. Modified 750430 by PG to add terminal_access_class
  7    16*     Modified 6/20/77 by J. Stern to add term_type_name Modified Feb 1980 by M.
  7    17*     B. Armstrong to implement multiple rate structures. (UNCA) Modified by R.
  7    18*     McDonald  May 1980 to include page charges, replaces cpu in iod (UNCA)
  7    19*     Modified by Benson I. Margulies November 1981 do declare pit_$, pit_ptr,
  7    20*     and unaligned character strings. Modified by E. N. Kittlitz January 1982
  7    21*     for user_attributes.incl.pl1 changes Modified by E. N. Kittlitz October
  7    22*     1982 for request_id. Modified by BIM 1984-09-12 for auth range. The max
  7    23*     copies the pds, but this is the only home of the min.
  7    24*  2) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
  7    25*     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
  7    26*               Add the truncate_absout and restarted bits for the
  7    27*               -truncate .absout SCP 6297, version 3.
  7    28*  3) change(86-12-11,GDixon), approve(87-07-16,MCR7741),
  7    29*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  7    30*     Changed structure under pit.abs_attributes to use like structure in
  7    31*     abs_attributes.incl.pl1.  This allows the same attributes to be used
  7    32*     in abs_message_format.incl.pl1 and user_table_entry.incl.pl1 as well as
  7    33*     this include file.
  7    34*  4) change(88-06-03,Parisek), approve(88-06-10,MCR7920),
  7    35*     audit(88-06-23,Hunter), install(87-07-05,MR12.2-1053):
  7    36*     Remove "pitmsg" in END comment string.  pitmsg.incl.pl1 is no longer a
  7    37*     name of pit.incl.pl1.
  7    38*  5) change(88-07-11,Parisek), approve(88-07-11,MCR7849),
  7    39*     audit(88-07-03,Lippard), install(88-07-13,MR12.2-1047):
  7    40*     Removed the ringpad element and added the min_ring & max_ring elements so
  7    41*     users may access their lowest and/or highest possible login ring value.
  7    42*     SCP6367.
  7    43*                                                   END HISTORY COMMENTS */
  7    44 
  7    45 
  7    46 /* format: style4 */
  7    47 declare  pit_$ bit (36) aligned external static;
  7    48 declare  pit_ptr pointer;
  7    49 
  7    50 dcl  1 pit aligned based (pit_ptr),
  7    51        2 version fixed bin,				/* indicates which version of the pit */
  7    52        2 process_type fixed bin,			/* initializer, interactive, or absentee process */
  7    53        2 login_responder char (64) unal,		/* path name of login responder */
  7    54 
  7    55 /*  All of these are going to be word aligned whether or not they are declared aligned,
  7    56*   and unaligning them cleans up code in many places */
  7    57 
  7    58        2 homedir char (64) unal,			/* path name of home directory */
  7    59        2 project char (28) unal,			/* name of this process' project affiliation */
  7    60        2 account char (32) unal,			/* name of account to which this process is charged */
  7    61        2 n_processes fixed bin,			/* number of previous processes for this session */
  7    62        2 login_time fixed bin (71),			/* clock time at login */
  7    63        2 proc_creation_time fixed bin (71),		/* clock time at creation of this process */
  7    64        2 old_proc_cpu fixed bin (71),			/* cpu time used by previous processes in this session */
  7    65        2 user_weight fixed bin,			/* weight of this process */
  7    66        2 anonymous fixed bin,				/* 1 if anonymous user */
  7    67        2 login_name char (28) unal,			/* name of user given at login */
  7    68        2 logout_pid bit (36),				/* process id of answering service */
  7    69        2 logout_channel fixed bin (71),			/* channel for signalling logouts to answering service */
  7    70        2 group char (8) unal,				/* party group */
  7    71        2 min_ring fixed bin,				/* min ring */
  7    72        2 max_ring fixed bin,				/* max ring */
  7    73        2 at like user_attributes aligned,		/* include user_attributes.incl.pl1 */
  7    74        2 whox fixed bin,				/* this process's index in whotab (or 0) */
  7    75        2 outer_module char (32) unaligned,
  7    76        2 pad (2) fixed bin,
  7    77        2 dont_call_init_admin bit (1) aligned,		/* Call process_overseer_ directly */
  7    78        2 terminal_access_class bit (72) aligned,		/* access class of user's terminal */
  7    79        2 dollar_charge float bin,			/* Month-to-date expenditure */
  7    80        2 dollar_limit float bin,			/* Limit stop on usage */
  7    81        2 shift_limit (0:7) float bin,			/* Stops on each shift's usage */
  7    82        2 logins fixed bin,				/* Number of logins this month */
  7    83        2 crashes fixed bin,				/* Number of sessions crashed */
  7    84        2 interactive (0:7),				/* interactive usage by shift */
  7    85          3 charge float bin,				/* Total charge */
  7    86          3 xxx fixed bin,
  7    87          3 cpu fixed bin (71),			/* CPU usage in microseconds */
  7    88          3 core fixed bin (71),			/* Memory usage in page-microseconds */
  7    89          3 connect fixed bin (71),			/* Connect time in microseconds */
  7    90          3 io_ops fixed bin (71),			/* Terminal I/O operations */
  7    91        2 absentee (4),				/* Absentee usage by queue */
  7    92          3 charge float bin,				/* Total absentee charge */
  7    93          3 jobs fixed bin,				/* Number of jobs */
  7    94          3 cpu fixed bin (71),			/* CPU usage in microseconds */
  7    95          3 memory fixed bin (71),			/* Memory usage in mu */
  7    96        2 iod (4),					/* IO Daemon usage, by queue */
  7    97          3 charge float bin,				/* Total charge */
  7    98          3 pieces fixed bin,				/* Number of requests */
  7    99          3 pad fixed bin (35),
  7   100          3 pages fixed bin (35),			/* number of pages output */
  7   101          3 lines fixed bin (71),			/* Record count */
  7   102        2 devices (16) float bin,			/* Usage of attached devices */
  7   103        2 time_last_reset fixed bin (71),		/* time last updated the PDT */
  7   104        2 absolute_limit float bin,			/* Limit, not reset monthly */
  7   105        2 absolute_spent float bin,			/* Spending against this */
  7   106        2 absolute_cutoff fixed bin (71),		/* Spending will be reset on this date */
  7   107        2 absolute_increm fixed bin,			/* .. time increment code. 0 = don't reset */
  7   108        2 rs_number fixed bin (9) unsigned unaligned,	/* rate structure number (0= default rates) */
  7   109        2 pad1a fixed bin (27) unsigned unaligned,		/* remainder of word */
  7   110        2 request_id fixed bin (71),			/* absentee request id */
  7   111        2 authorization_range (2) bit (72) aligned,
  7   112        2 pad1 (73) fixed bin,				/* extra space */
  7   113        2 charge_type fixed bin,			/* device charge type of console */
  7   114        2 term_type_name char (32) unal,			/* terminal type name */
  7   115        2 line_type fixed bin,				/* line type of user's console */
  7   116        2 tty_type fixed bin,				/* old terminal type (obsolete, kept for compatibility) */
  7   117        2 service_type fixed bin,			/* type of service console is performing */
  7   118        2 tty_answerback char (4) unaligned,		/* original answerback of user's console */
  7   119        2 old_tty char (6),				/* (obsolete) attachment name of user's console */
  7   120        2 standby fixed bin,				/* 1 if standby user */
  7   121        2 login_line char (120) unal,			/* line typed at login */
  7   122        2 cant_bump_until fixed bin (71),		/* cannot be preempted until this time (0 for abs) */
  7   123        2 input_seg char (168) unal,			/* path name of absentee input file */
  7   124        2 output_seg char (168) unal,			/* path name of absentee output file */
  7   125        2 max_cpu_time fixed bin,			/* max number of seconds allowed to this absentee proc */
  7   126        2 abs_queue fixed bin,				/* absentee queue if absentee, else -1 */
  7   127        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
  7   128        2 arg_info_ptr fixed bin (18) unsigned,		/* Relative pointer to information on absentee args. */
  7   129        2 old_proc_core fixed bin (71),			/* Memory usage by previous processes in this session */
  7   130        2 old_proc_io_ops fixed bin (71),		/* I/O operations from previous processes in this session */
  7   131        2 tty char (32) unaligned,			/* Attachment name of users channel */
  7   132        2 start_arg_info fixed bin;			/* Put absentee args information here. */
  7   133 
  7   134 
  7   135 /* Structure to contain information on absentee arguments */
  7   136 dcl  1 arg_info aligned based,
  7   137        2 arg_count fixed bin,				/* Number of arguments for replacement in absentee segment */
  7   138        2 ln_args fixed bin,				/* Length of string containing arguments. */
  7   139        2 arg_lengths (25 refer (arg_info.arg_count)) fixed bin, /* Array of argument lengths */
  7   140        2 args char (128 refer (arg_info.ln_args)) unal;
  7   141 						/* Args used for replacement in absentee control segment. */
  7   142 
  7   143 declare PIT_version_3 fixed bin int static options (constant) init (3);
  7   144 
  7   145 /* END INCLUDE FILE ... pit.incl.pl1 */
      757 
      758  /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  8     2 
  8     3 dcl  sdwp ptr;
  8     4 
  8     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  8     6 
  8     7    (2 add bit (24),					/* main memory address of page table */
  8     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  8     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  8    10     2 df_no bit (2),				/* directed fault number */
  8    11 
  8    12     2 pad1 bit (1),
  8    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  8    14     2 access,					/* access bits */
  8    15       3 read bit (1),				/* read permission bit */
  8    16       3 execute bit (1),				/* execute permission bit */
  8    17       3 write bit (1),				/* write permission bit */
  8    18       3 privileged bit (1),				/* privileged bit */
  8    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  8    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  8    21     2 cache bit (1),				/* cache enable bit */
  8    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  8    23 
  8    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  8    25 
  8    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      758 
      759  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  9     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  9     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  9     4 /*	Modified April 1983 by C. Hornig for tasking */
  9     5 
  9     6 /****^  HISTORY COMMENTS:
  9     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  9     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  9     9*     added the heap_header_ptr definition.
  9    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  9    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  9    12*     Modified to support control point management.  These changes were actually
  9    13*     made in February 1985 by G. Palter.
  9    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  9    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  9    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  9    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  9    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  9    19*     (ITS pair).
  9    20*                                                   END HISTORY COMMENTS */
  9    21 
  9    22 /* format: style2 */
  9    23 
  9    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  9    25 
  9    26      dcl	   1 stack_header	      based (sb) aligned,
  9    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  9    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  9    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  9    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  9    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  9    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  9    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  9    34 	     2 pad4	      bit (2) unal,
  9    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  9    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  9    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  9    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  9    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  9    40 	     2 null_ptr	      ptr,		/*  (16)  */
  9    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  9    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  9    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  9    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  9    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  9    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  9    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  9    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  9    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  9    50 	     2 return_no_pop_op_ptr
  9    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  9    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  9    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  9    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  9    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  9    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  9    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  9    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  9    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  9    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  9    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  9    62 	     2 trace,
  9    63 	       3 frames,
  9    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  9    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  9    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  9    67 	     2 pad2	      bit (36),		/*  (61) */
  9    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  9    69 
  9    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  9    71 
  9    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  9    73 						/* (551) octal */
  9    74 
  9    75 
  9    76 /*	The following constants are offsets within this transfer vector table.  */
  9    77 
  9    78      dcl	   (
  9    79 	   call_offset	      fixed bin init (271),
  9    80 	   push_offset	      fixed bin init (272),
  9    81 	   return_offset	      fixed bin init (273),
  9    82 	   return_no_pop_offset   fixed bin init (274),
  9    83 	   entry_offset	      fixed bin init (275)
  9    84 	   )		      internal static;
  9    85 
  9    86 
  9    87 
  9    88 
  9    89 
  9    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  9    91*	move the whole stack header should use this overlay.
  9    92**/
  9    93 
  9    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  9    95 
  9    96 
  9    97 
  9    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      759 
      760  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 10     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 10     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 10     4 
 10     5 /* This include file has an ALM version.  Keep 'em in sync! */
 10     6 
 10     7 dcl (
 10     8 
 10     9 /* The following constants define the message action codes.  This indicates
 10    10*how a message is to be handled.  */
 10    11 
 10    12      SYSERR_CRASH_SYSTEM	init (1),			
 10    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 10    14 
 10    15      SYSERR_TERMINATE_PROCESS	init (2),
 10    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 10    17 
 10    18      SYSERR_PRINT_WITH_ALARM	init (3),
 10    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 10    20 
 10    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 10    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 10    23 
 10    24      SYSERR_LOG_OR_PRINT	init (4),
 10    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 10    26 
 10    27      SYSERR_LOG_OR_DISCARD	init (5),
 10    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 10    29 
 10    30 
 10    31 /* The following constants are added to the normal severities to indicate
 10    32*different sorting classes of messages.  */
 10    33 
 10    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 10    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 10    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 10    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 10    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 10    39 	) fixed bin internal static options (constant);
 10    40 
 10    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      760 
      761  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
 11     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
 11     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
 11     8*     attribute switches.
 11     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 11    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
 11    12*         be deleted.
 11    13*      B) Add constants identifying attributes that can be changed by user at
 11    14*         login, etc.
 11    15*                                                   END HISTORY COMMENTS */
 11    16 
 11    17 
 11    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
 11    19 
 11    20 /* format: style4 */
 11    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
 11    22        (2 administrator bit (1),			/* 1  system administrator privileges */
 11    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
 11    24        2 nobump bit (1),				/* 2  user cannot be bumped */
 11    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
 11    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
 11    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
 11    28*						   .  of same project (distinct from "nobump") */
 11    29        2 nolist bit (1),				/* 7  don't list user on "who" */
 11    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
 11    31        2 multip bit (1),				/* 9  user may have several processes */
 11    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
 11    33        2 brief bit (1),				/* 11 no login or logout message */
 11    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
 11    35        2 vhomedir bit (1),				/* 13 user may change homedir */
 11    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
 11    37        2 sb_ok bit (1),				/* 15 user may be standby */
 11    38        2 pm_ok bit (1),				/* 16 user may be primary */
 11    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
 11    40        2 daemon bit (1),				/* 18 user may login as daemon */
 11    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
 11    42        2 no_warning bit (1),				/* 20 no warning message */
 11    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
 11    44*						   .  in PDT: this user has an individual load control group */
 11    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
 11    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
 11    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
 11    48        2 pad bit (12)) unaligned;
 11    49 
 11    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 11    51     ("none",					/* 0 */
 11    52      "administrator",				/* 1 */
 11    53      "primary_line",				/* 2 */
 11    54      "nobump",					/* 3 */
 11    55      "guaranteed_login",				/* 4 */
 11    56      "anonymous",					/* 5 */
 11    57      "nopreempt",					/* 6 */
 11    58      "nolist",					/* 7 */
 11    59      "dialok",					/* 8 */
 11    60      "multip",					/* 9 */
 11    61      "bumping",					/* 10 */
 11    62      "brief",					/* 11 */
 11    63      "vinitproc",					/* 12 */
 11    64      "vhomedir",					/* 13 */
 11    65      "nostartup",					/* 14 */
 11    66      "no_secondary",				/* 15 */
 11    67      "no_prime",					/* 16 */
 11    68      "no_eo",					/* 17 */
 11    69      "daemon",					/* 18 */
 11    70      "",						/* 19 vdim OBSOLETE */
 11    71      "no_warning",					/* 20 */
 11    72      "igroup",					/* 21 */
 11    73      "save_pdir",					/* 22 */
 11    74      "disconnect_ok",				/* 23 */
 11    75      "save_on_disconnect");				/* 24 */
 11    76 
 11    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
 11    78     ("null",					/* 0 */
 11    79      "admin",					/* 1 */
 11    80      "", "",					/* 2 - 3 */
 11    81      "guar",					/* 4 */
 11    82      "anon",					/* 5 */
 11    83      "", "",					/* 6 - 7 */
 11    84      "dial",					/* 8 */
 11    85      "multi_login",					/* 9 */
 11    86      "preempting",					/* 10 */
 11    87      "",						/* 11 */
 11    88      "v_process_overseer",				/* 12 */
 11    89      "v_home_dir",					/* 13 */
 11    90      "no_start_up",					/* 14 */
 11    91      "no_sec",					/* 15 */
 11    92      "no_primary",					/* 16 */
 11    93      "no_edit_only",				/* 17 */
 11    94      "op_login",					/* 18 */
 11    95      "",						/* 19 */
 11    96      "nowarn",					/* 20 */
 11    97      "", "", "",					/* 21 - 23 */
 11    98      "save");					/* 24 */
 11    99 
 11   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
 11   101      options(constant) init("000000000010000000010000000000000000"b);
 11   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
 11   103 
 11   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
 11   105      options(constant) init("000000000010000000010000000000000000"b);
 11   106     /* PDT value for (brief, no_warning) is default */
 11   107 
 11   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
 11   109      options(constant) init("000100000110010000010000000000000000"b);	
 11   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
 11   111 
 12     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 12     2 
 12     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 12     4 /*							       */
 12     5 /* This include file describes the attributes of an absentee job.  It is     */
 12     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
 12     7 /* and PIT.incl.pl1.   */
 12     8 /*							       */
 12     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 12    10 
 12    11 /****^  HISTORY COMMENTS:
 12    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 12    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 12    14*     Separated abs_attributes from the request structure
 12    15*     (abs_message_format.incl.pl1) so that the identical structure could be
 12    16*     used in the ute structure (user_table_entry.incl.pl1).
 12    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
 12    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 12    19*     Added ABS_ATTRIBUTE_NAMES array.
 12    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
 12    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
 12    22*     Added the no_start_up flag. SCP6367
 12    23*                                                   END HISTORY COMMENTS */
 12    24 
 12    25 dcl 1 user_abs_attributes		aligned based,
 12    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
 12    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
 12    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
 12    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
 12    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
 12    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
 12    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
 12    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
 12    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
 12    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
 12    36       2 attributes_pad		bit (26) unaligned;
 12    37 
 12    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
 12    39 	"restartable",
 12    40 	"user_deferred_until_time",
 12    41 	"proxy",
 12    42 	"set_bit_cnt",
 12    43 	"time_in_gmt",
 12    44 	"user_deferred_indefinitely",
 12    45 	"secondary_ok",
 12    46 	"truncate_absout",
 12    47 	"restarted",
 12    48 	"no_start_up");
 12    49 
 12    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
 12    51 
 11   112 
 11   113 
 11   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      761 
      762 
      763 /* BEGIN MESSAGE DOCUMENTATION
      764*   Message:
      765*   act_proc: from grab_aste ERRORMESSAGE
      766*
      767*   S: $crash
      768*
      769*   T: $run
      770*
      771*   M: In attempting to create a process, the system could not force the
      772*   PDS or descriptor segment of that process to be activated and held active.
      773*   ERRORMESSAGE is an error_table_ message.
      774*   $err
      775*
      776*   A: $recover
      777*
      778*
      779*   Message:
      780*   act_proc: KST size specified (SIZE) less than minimum (MIN_SIZE).
      781*   Creating process for GROUPID.
      782*
      783*   S: $log
      784*
      785*   T: $run
      786*
      787*   M: The project administrator (or system administrator) for user GROUPID
      788*   set the kst_size parameter in the PDT to SIZE, which is less than
      789*   the valid minimum MIN_SIZE. The process is not created. Note that
      790*   a process with MINIMUM KST size will probably not be of any use. The
      791*   minimum useful KST size is on the order of MINIMUM + 50.
      792*
      793*   A: Change the PMF/PDT.
      794*
      795*   END MESSAGE DOCUMENTATION */
      796 /* format: on */
      797 
      798      end act_proc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.6  act_proc.pl1                      >spec>install>1111>act_proc.pl1
751          1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
752          2    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
753          3    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
754          4    03/16/89  2012.8  create_branch_info.incl.pl1       >ldd>include>create_branch_info.incl.pl1
755          5    01/30/85  1523.9  create_info.incl.pl1              >ldd>include>create_info.incl.pl1
756          6    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
757          7    07/14/88  2015.0  pit.incl.pl1                      >ldd>include>pit.incl.pl1
758          8    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
759          9    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
760         10    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
761         11    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
11-112      12    07/14/88  2015.0  user_abs_attributes.incl.pl1      >ldd>include>user_abs_attributes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CREATE                                 constant        fixed bin(17,0)          initial dcl 227 ref 250 628 643 651 655 659
INFO                                   constant        fixed bin(17,0)          initial dcl 228 ref 676
LOG                             000035 constant        fixed bin(17,0)          initial dcl 10-7 set ref 394*
NORMAL_EVOLUTION_TERMINATION           constant        fixed bin(17,0)          initial dcl 229 ref 248 640 686
PRELINKED_DIR                   000100 automatic       char(64)                 packed unaligned dcl 55 set ref 359* 361* 363 365*
                                                                                  551 552*
REW_bit                                constant        bit(5)                   initial packed unaligned dcl 230 ref 321
RW_mode                                constant        fixed bin(5,0)           initial dcl 231 ref 476 722
SMA_bit                                constant        bit(5)                   initial packed unaligned dcl 232 ref 301 323
SMA_mode                               constant        fixed bin(5,0)           initial dcl 233 ref 491
a_code                                 parameter       fixed bin(35,0)          dcl 242 set ref 245 666* 669
a_pid                                  parameter       bit(36)                  dcl 671 ref 669 679
a_pitp                                 parameter       pointer                  dcl 672 ref 669 680
abs_ptr                         000120 automatic       pointer                  dcl 56 set ref 538*
abs_seg$                        000010 external static fixed bin(17,0)          dcl 142 set ref 538
acc_name_$elements              000152 constant        entry                    external dcl 197 ref 453
access_audit_$check_general_user
                                000154 constant        entry                    external dcl 198 ref 599
access_authorization     42            based           bit(72)                  level 2 dcl 2-7 set ref 505*
access_class             20     000124 automatic       bit(72)                  level 2 dcl 59 set ref 314*
ack_name                               based           structure                level 1 dcl 115
active_all_rings_data$default_max_segno
                                000012 external static fixed bin(17,0)          dcl 143 ref 389
active_all_rings_data$hcscnt    000014 external static fixed bin(18,0)          dcl 144 set ref 391 394* 539 558 560 560 568
active_all_rings_data$max_segno 000016 external static fixed bin(17,0)          dcl 145 ref 390
active_all_rings_data$stack_base_segno
                                000020 external static fixed bin(18,0)          dcl 146 ref 443 547
active_hardcore_data$pdir_dir_quota
                                000022 external static fixed bin(17,0)          dcl 147 ref 295
active_hardcore_data$pdir_quota 000024 external static fixed bin(17,0)          dcl 148 ref 290
add                                    based           bit(24)                  array level 2 in structure "sdwa" packed packed
                                                                                  unaligned dcl 8-24 in procedure "act_proc" set ref
                                                                                  545*
add                                    based           bit(24)                  level 2 in structure "sdw" packed packed unaligned
                                                                                  dcl 8-5 in procedure "act_proc" ref 545
addr                                                   builtin function         dcl 238 ref 316 316 337 338 357 377 379 400 407 413
                                                                                  418 421 424 427 430 433 436 439 440 442 444 446
                                                                                  449 452 453 453 458 461 464 467 470 486 538 541
                                                                                  544 545 560 560 566 573 577 588 591 592 597 598
                                                                                  599 602 603 745
aim_check_$greater_or_equal     000156 constant        entry                    external dcl 199 ref 260 263
allow_256K_connect        7(26)        based           bit(1)                   level 2 packed packed unaligned dcl 6-18 set ref
                                                                                  570*
append$branchx                  000160 constant        entry                    external dcl 200 ref 476 491 722
append$create_branch_           000162 constant        entry                    external dcl 201 ref 316
apte                                   based           structure                level 1 dcl 2-7
aptep                           000410 automatic       pointer                  dcl 2-5 set ref 270* 271 278 425 503 505 581 582 584
                                                                                  585 586 587 588 590 591 592 593 593 613 619 630
                                                                                  659*
asd_$replace_dall               000164 constant        entry                    external dcl 202 ref 341 493
asd_$replace_sall               000166 constant        entry                    external dcl 203 ref 479 725
astep                           000412 automatic       pointer                  dcl 3-9 set ref 548 579 741* 742* 744*
asteps                   12            based           structure                level 2 packed packed unaligned dcl 2-7
audit                    57            based           bit(36)                  level 2 dcl 5-23 set ref 471 599*
audit_event_flags                      based           structure                level 1 dcl 1-5
based_dseg                             based           fixed bin(71,0)          array dcl 119 set ref 541* 541 560* 560 574* 578*
baseno                                                 builtin function         dcl 238 ref 544 573 577
baseptr                                                builtin function         dcl 238 ref 443
batch                    21(32)        based           bit(1)                   level 3 packed packed unaligned dcl 2-7 set ref 587*
bc                              000122 automatic       fixed bin(24,0)          dcl 57 set ref 552* 558
bin                                                    builtin function         dcl 238 ref 377 544 573 577 582
binary                                                 builtin function         dcl 238 ref 613 613
bit                                                    builtin function         dcl 238 ref 546 547 582 613
bitcnt                   16     000124 automatic       fixed bin(24,0)          level 2 dcl 59 set ref 311*
bound                     1(01)        based           bit(14)                  array level 2 packed packed unaligned dcl 8-24 set
                                                                                  ref 546*
branch_info                     000124 automatic       structure                level 1 dcl 59 set ref 299* 316 316
cache                     1(21)        based           bit(1)                   level 2 packed packed unaligned dcl 8-5 set ref 745*
cc_10_100                 0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-5 set ref 598*
charge_type             513            based           fixed bin(17,0)          level 2 dcl 7-50 set ref 701* 701
chase_sw                  1(02) 000124 automatic       bit(1)                   level 3 packed packed unaligned dcl 59 set ref 308*
chname$cfile                    000170 constant        entry                    external dcl 204 ref 632
ci_ptr                                 parameter       pointer                  dcl 243 ref 245 251
clock                                                  builtin function         dcl 238 ref 593 603 613
clr_size                        000147 automatic       fixed bin(17,0)          dcl 60 set ref 387* 409
cls_in_stack             56            based           bit(1)                   level 2 dcl 5-23 ref 406
cls_size                 52            based           fixed bin(17,0)          level 2 dcl 5-23 ref 387
code                            000150 automatic       fixed bin(35,0)          dcl 61 set ref 265* 272* 316* 317 341* 342 365* 368*
                                                                                  375* 376 380* 381 393* 394* 453* 454 476* 477 479*
                                                                                  480 482* 491* 492 493* 494 500* 501 507* 508 552*
                                                                                  555* 556 562* 621* 622 623* 624 625* 626 632* 633
                                                                                  638* 666 681* 690* 708* 722* 723 725* 726 728*
                                                                                  741* 742* 743 743*
copy_audit                             based           bit(36)                  dcl 120 set ref 471*
copy_authorization                     based           bit(72)                  dcl 121 set ref 465* 468*
copy_chn_name                          based           fixed bin(71,0)          dcl 122 set ref 462* 592
copy_data                              based           fixed bin(17,0)          array dcl 123 set ref 357* 357 378* 378 485* 485
copy_dir_name                          based           char(32)                 dcl 124 set ref 431*
copy_dstep                             based           bit(18)                  dcl 125 set ref 567*
copy_event_count                       based           fixed bin(17,0)          dcl 126 set ref 602*
copy_group_id                          based           char(32)                 dcl 127 set ref 434*
copy_home_dir                          based           char(64)                 dcl 128 set ref 487 487* 487 490 496* 497* 497
copy_id                                based           bit(36)                  dcl 129 set ref 419* 422* 428* 459* 588 591
copy_prelinked_ring                    based           bit(1)                   array packed unaligned dcl 130 set ref 379*
copy_ptr                               based           pointer                  dcl 131 set ref 425* 440* 444*
copy_ring                              based           fixed bin(17,0)          dcl 132 set ref 437* 447* 450*
copy_size                              based           fixed bin(17,0)          array dcl 133 set ref 402* 409* 415*
copy_sw                   1(01) 000124 automatic       bit(1)                   level 3 packed packed unaligned dcl 59 set ref 307*
copy_throttle_seg_state_chg            based           bit(1)                   dcl 134 set ref 599*
copy_time                              based           fixed bin(71,0)          dcl 135 set ref 603*
cp                              000152 automatic       pointer                  dcl 63 set ref 251* 257 258 278 279 283 289 294 359
                                                                                  359 386 387 388 394 399 406 437 447 450 459 462
                                                                                  471 474 484 485 487 487 490 497 505 506 599 630
                                                                                  630 631 632
create_branch_info                     based           structure                level 1 dcl 4-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 4-35 ref 300
create_info                            based           structure                level 1 dcl 5-23
daemon_sw                       000154 automatic       bit(1)                   dcl 64 set ref 340* 341* 479* 493* 725*
dbr                      44            based           fixed bin(71,0)          level 2 in structure "apte" dcl 2-7 in procedure
                                                                                  "act_proc" set ref 586*
dbr                             000156 automatic       fixed bin(71,0)          dcl 65 in procedure "act_proc" set ref 549* 586
deadline                 34            based           fixed bin(71,0)          level 2 dcl 2-7 set ref 593*
del_dir_tree                    000174 constant        entry                    external dcl 206 ref 651
delentry$dfile                  000172 constant        entry                    external dcl 205 ref 655
dir_acl                         000160 automatic       structure                array level 1 dcl 66
dir_aclp                        000216 automatic       pointer                  dcl 70 set ref 338* 341* 493*
dir_quota                22     000124 automatic       fixed bin(18,0)          level 2 in structure "branch_info" dcl 59
                                                                                  in procedure "act_proc" set ref 313*
dir_quota               105            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 294
dir_rb                          000005 constant        fixed bin(17,0)          initial array dcl 234 set ref 302 303 304 491*
dir_sw                    1     000124 automatic       bit(1)                   level 3 packed packed unaligned dcl 59 set ref 306*
divide                                                 builtin function         dcl 238 ref 543 543 546 547 558 572 572
dseg                     12(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-7 set ref 585*
dseg$                           000026 external static fixed bin(17,0)          dcl 149 set ref 541 544
dseg_ptr                        000220 automatic       pointer                  dcl 71 set ref 344* 345 541 543* 545 546 547 549 560
                                                                                  574 578 621*
dseg_size                       000222 automatic       fixed bin(19,0)          dcl 72 set ref 542* 543 543 546
dstep                           000224 automatic       pointer                  dcl 73 set ref 548* 567 585
entry_bound               1(22)        based           bit(14)                  array level 2 packed packed unaligned dcl 8-24 set
                                                                                  ref 547*
error_table_$ai_restricted      000030 external static fixed bin(35,0)          dcl 150 ref 265
error_table_$apt_full           000032 external static fixed bin(35,0)          dcl 151 ref 272
error_table_$invalid_subsystem  000034 external static fixed bin(35,0)          dcl 152 ref 368
error_table_$smallarg           000036 external static fixed bin(35,0)          dcl 153 ref 393
esw                             000226 automatic       fixed bin(17,0)          dcl 74 set ref 250* 628 643 651 655 659 676*
evolution                       000123 automatic       fixed bin(17,0)          dcl 58 set ref 248* 267 273 276* 276 317 326* 326
                                                                                  342 345 347* 347 350 354 370 372* 372 382* 382 395
                                                                                  454 477 480 483 492 494 501 508 554* 554 563* 563
                                                                                  622 624 626 633 686* 691 709
exmode                   11     000324 automatic       bit(36)                  array level 2 dcl 99 set ref 322*
first_frame             100            based           fixed bin(17,0)          level 2 dcl 136 set ref 444
fixed                                                  builtin function         dcl 238 ref 546
flags                     1            based           structure                level 2 packed packed unaligned dcl 2-7
flags2                   21(18)        based           structure                level 2 packed packed unaligned dcl 2-7
fs_modes                        000176 constant        entry                    external dcl 207 ref 375 555
get_ptrs_$given_astep           000200 constant        entry                    external dcl 208 ref 744
getuid                          000202 constant        entry                    external dcl 209 ref 422
grab_aste                       000204 constant        entry                    external dcl 210 ref 742
grab_aste$prewithdraw           000206 constant        entry                    external dcl 211 ref 741
grant                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 1-5 set ref 597*
hd                              000227 automatic       char(32)                 packed unaligned dcl 75 set ref 490* 491* 493* 496
highest_ring             11            based           fixed bin(3,0)           level 2 dcl 5-23 ref 450 474
highseg                   1            based           fixed bin(17,0)          level 2 dcl 6-18 set ref 377 569 569*
homedir                  50            based           bit(18)                  level 2 dcl 5-23 ref 487 487 490 497
i                               000237 automatic       fixed bin(17,0)          dcl 76 set ref 320* 321 322 323* 401* 402* 408* 409*
                                                                                  414* 415*
ignore_code                     000151 automatic       fixed bin(35,0)          dcl 62 set ref 645* 647* 651* 655*
init_proc                       000210 constant        entry                    external dcl 212 set ref 440
initial_ring             10            based           fixed bin(3,0)           level 2 dcl 5-23 ref 437 447
initiate                        000212 constant        entry                    external dcl 213 ref 365
initiate$initiate_count         000214 constant        entry                    external dcl 214 ref 552
initiate$priv_init              000216 constant        entry                    external dcl 215 ref 482 690 728
ipc_r_factor             65            based           fixed bin(35,0)          level 2 unsigned dcl 2-7 set ref 619*
ipc_r_offset             64            based           fixed bin(18,0)          level 2 unsigned dcl 2-7 set ref 613*
is_absentee                     000240 automatic       bit(1)                   dcl 77 set ref 455* 456* 587
kst                                    based           structure                level 1 dcl 6-18 set ref 568
kst_entry               110            based           structure                array level 2 dcl 6-18 set ref 377
kst_ptr                         000242 automatic       pointer                  dcl 78 set ref 349* 350 378 379 569 569 570 572*
                                                                                  623*
kst_seg$                        000040 external static fixed bin(17,0)          dcl 154 set ref 573
kst_size                        000244 automatic       fixed bin(19,0)          dcl 79 in procedure "act_proc" set ref 568* 572 572
kst_size                 53            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 388
kste                                   based           structure                level 1 dcl 6-36 ref 568
kstep                                  automatic       pointer                  dcl 6-15 ref 568
kstp                                   automatic       pointer                  dcl 6-15 ref 568
length                                                 builtin function         dcl 238 ref 301
level$get                       000220 constant        entry                    external dcl 216 ref 252 684
level$set                       000222 constant        entry                    external dcl 217 ref 253 663 685
line_type               524            based           fixed bin(17,0)          level 2 dcl 7-50 set ref 698* 698
local_audit_event_flags         000245 automatic       bit(36)                  dcl 80 set ref 596* 597 598 599*
lock_id                  15            based           bit(36)                  level 2 dcl 2-7 set ref 588*
lot_in_stack             55            based           bit(1)                   level 2 dcl 5-23 ref 399
lot_size                        000246 automatic       fixed bin(17,0)          dcl 81 in procedure "act_proc" set ref 386* 402
lot_size                 51            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 386
lowseg                                 based           fixed bin(17,0)          level 2 dcl 6-18 ref 377
max                                                    builtin function         dcl 238 ref 292 297
max_authorization               000250 automatic       bit(72)                  dcl 82 set ref 258* 260* 263* 468
max_lot                         000252 automatic       fixed bin(17,0)          dcl 83 set ref 388* 389 389* 390* 390 391 394* 415
                                                                                  542 568 569
max_process_authorization
                         62            based           bit(72)                  level 2 dcl 5-23 ref 258
min                                                    builtin function         dcl 238 ref 390
mode                     10     000160 automatic       bit(36)                  array level 2 in structure "dir_acl" dcl 66
                                                                                  in procedure "act_proc" set ref 323* 334*
mode                      2     000124 automatic       bit(3)                   level 2 in structure "branch_info" packed packed
                                                                                  unaligned dcl 59 in procedure "act_proc" set ref
                                                                                  301* 301
mode                     10     000324 automatic       bit(36)                  array level 2 in structure "seg_acl" dcl 99
                                                                                  in procedure "act_proc" set ref 321* 334*
n                               000253 automatic       fixed bin(17,0)          dcl 84 set ref 356* 357 377* 378 484* 485 539* 541
                                                                                  558* 559 560
null                                                   builtin function         dcl 238 ref 271 345 350 354 364 366 475 483 553 645
                                                                                  647 689 691 721
old_tty                 530            based           char(6)                  level 2 dcl 7-50 set ref 696* 696
outer_module            112            based           char(32)                 level 2 packed packed unaligned dcl 7-50 set ref
                                                                                  704* 704
p                               000254 automatic       pointer                  dcl 85 set ref 400* 402 407* 409 413* 415 418* 419
                                                                                  421* 422 424* 425 427* 428 430* 431 433* 434 436*
                                                                                  437 439* 440 442* 444 446* 447 449* 450 452* 453*
                                                                                  455 464* 465 467* 468 470* 471 566* 567
p1                              000256 automatic       pointer                  dcl 86 set ref 458* 459 461* 462
p2                              000260 automatic       pointer                  dcl 87 set ref 486* 487 496 497
parent_ac_sw              1(04) 000124 automatic       bit(1)                   level 3 packed packed unaligned dcl 59 set ref 309*
pdir_dir_quota                  000262 automatic       fixed bin(17,0)          dcl 88 set ref 294* 295 295* 297* 297 313
pdir_entry                      000263 automatic       char(15)                 packed unaligned dcl 89 set ref 280* 281 316* 341*
                                                                                  632* 651* 655* 687* 688
pdir_path                       000267 automatic       char(32)                 packed unaligned dcl 90 set ref 281* 431 476* 479*
                                                                                  482* 491* 493* 496 688* 690* 722* 725* 728*
pdir_quota                      000277 automatic       fixed bin(17,0)          dcl 91 set ref 289* 290 290* 292* 292 312
pds                      12            based           bit(18)                  level 3 packed packed unaligned dcl 2-7 set ref 584*
pds$                            000042 external static fixed bin(17,0)          dcl 155 set ref 577
pds$access_authorization        000044 external static bit(72)                  dcl 156 set ref 464
pds$access_name                 000046 external static structure                level 1 dcl 157 set ref 452
pds$account_id                  000050 external static bit(36)                  dcl 161 set ref 427 428
pds$apt_ptr                     000052 external static pointer                  dcl 162 set ref 424
pds$audit_flags                 000054 external static bit(36)                  dcl 163 set ref 470
pds$clr_stack_size              000056 external static fixed bin(17,0)          array dcl 164 set ref 407
pds$covert_event_count          000060 external static fixed bin(17,0)          dcl 165 set ref 602
pds$dstep                       000062 external static bit(18)                  dcl 166 set ref 566
pds$first_covert_event_time     000064 external static fixed bin(71,0)          dcl 167 set ref 603
pds$highest_ring                000066 external static fixed bin(17,0)          dcl 168 set ref 449
pds$home_dir                    000070 external static char(168)                dcl 169 set ref 486
pds$initial_procedure           000072 external static pointer                  dcl 170 set ref 439
pds$initial_ring                000074 external static fixed bin(17,0)          dcl 171 set ref 436
pds$interrupt_ring              000076 external static fixed bin(17,0)          dcl 172 set ref 446
pds$last_sp                     000100 external static pointer                  dcl 173 set ref 442
pds$lock_id                     000102 external static bit(36)                  dcl 174 set ref 421 588
pds$lot_stack_size              000104 external static fixed bin(17,0)          array dcl 175 set ref 400
pds$max_access_authorization    000106 external static bit(72)                  dcl 176 set ref 467
pds$max_lot_size                000110 external static fixed bin(17,0)          array dcl 177 set ref 413
pds$prelinked_ring              000112 external static bit(1)                   array packed unaligned dcl 178 set ref 379
pds$process_dir_name            000114 external static char(32)                 dcl 179 set ref 430
pds$process_group_id            000116 external static char(32)                 dcl 180 set ref 305 330 331 433
pds$processid                   000120 external static bit(36)                  dcl 181 set ref 418
pds$term_channel                000122 external static fixed bin(71,0)          dcl 182 set ref 461 592
pds$term_proc                   000124 external static bit(36)                  dcl 183 set ref 458 591
pds$throttle_segment_state_changes
                                000126 external static bit(1)                   dcl 184 set ref 599
pds_astep                       000300 automatic       pointer                  dcl 92 set ref 579* 584
pds_ptr                         000302 automatic       pointer                  dcl 93 set ref 353* 354 357 379 400 407 413 418 421
                                                                                  424 427 430 433 436 439 442 446 449 452 458 461
                                                                                  464 467 470 486 566 576* 588 591 592 599 602 603
                                                                                  625*
pid                             000304 automatic       bit(36)                  dcl 94 set ref 279* 280 419 503 507* 679* 687
pit                                    based           structure                level 1 dcl 7-50
pit_ptr                  16            based           pointer                  level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 485
pit_ptr                         000414 automatic       pointer                  dcl 7-48 in procedure "act_proc" set ref 475* 482*
                                                                                  483 485 487 487 490 497 500* 689* 690* 691 695 696
                                                                                  697 698 699 700 701 702 703 704 708*
pitp                            000406 automatic       pointer                  dcl 674 set ref 680* 695 696 697 698 699 700 701 702
                                                                                  703 704
prelinked_ring            7(18)        based           bit(1)                   array level 2 packed packed unaligned dcl 6-18 ref
                                                                                  379
priv_upgrade_sw           1(03) 000124 automatic       bit(1)                   level 3 packed packed unaligned dcl 59 set ref 310*
process_authorization           000306 automatic       bit(72)                  dcl 95 in procedure "act_proc" set ref 257* 263* 314
                                                                                  465 599*
process_authorization
                         60            based           bit(72)                  level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 257 505
process_group                   000310 automatic       char(32)                 dcl 96 set ref 283* 328 329 434 453 453 476* 491*
                                                                                  722*
process_group_id         20            based           char(32)                 level 2 dcl 5-23 set ref 283 394*
processid                 3            based           bit(36)                  level 2 in structure "apte" dcl 2-7 in procedure
                                                                                  "act_proc" set ref 503*
processid                              based           structure                level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" set ref 279
prw                                    parameter       bit(1)                   dcl 734 ref 732 741
ptr                                                    builtin function         dcl 238 ref 379 400 407 413 418 421 424 427 430 433
                                                                                  436 439 442 446 449 452 458 461 464 467 470 486
                                                                                  487 487 490 497 566 588 591 592 599 602 603
pxss$empty_t                    000224 constant        entry                    external dcl 218 ref 659
pxss$get_entry                  000226 constant        entry                    external dcl 219 ref 270
pxss$set_work_class             000230 constant        entry                    external dcl 220 ref 507
quota                    17     000124 automatic       fixed bin(18,0)          level 2 dcl 59 set ref 312*
record_quota              6            based           fixed bin(17,0)          level 2 dcl 5-23 ref 289
rel                                                    builtin function         dcl 238 ref 278 377 379 400 407 413 418 421 424 427
                                                                                  430 433 436 439 442 446 449 452 458 461 464 467
                                                                                  470 486 566 567 584 585 588 591 592 599 602 603
rel_apte                               based           bit(18)                  level 3 packed packed unaligned dcl 5-23 set ref
                                                                                  278*
rings                     3     000124 automatic       fixed bin(3,0)           array level 2 in structure "branch_info" dcl 59
                                                                                  in procedure "act_proc" set ref 302* 303* 304*
rings                           000320 automatic       fixed bin(3,0)           array dcl 97 in procedure "act_proc" set ref 375*
                                                                                  376 555* 557
rtrim                                                  builtin function         dcl 238 ref 496 496
savring                         000323 automatic       fixed bin(17,0)          dcl 98 set ref 252* 663* 684*
sb                              000416 automatic       pointer                  dcl 9-24 set ref 443* 444
sdw                                    based           structure                level 1 dcl 8-5 set ref 542
sdwa                                   based           structure                array level 1 dcl 8-24 set ref 549 560 560
sdwp                                   automatic       pointer                  dcl 8-3 ref 542
seg_acl                         000324 automatic       structure                array level 1 dcl 99
seg_aclp                        000366 automatic       pointer                  dcl 104 set ref 337* 479* 725*
seg_name                               parameter       char                     packed unaligned dcl 717 set ref 715 722* 725* 728*
seg_ptr                                parameter       pointer                  dcl 718 set ref 715 721* 728*
seg_rb                          000370 automatic       fixed bin(17,0)          array dcl 105 set ref 473* 474* 474* 476* 720* 720*
                                                                                  720* 722*
segno                           000373 automatic       fixed bin(17,0)          dcl 106 set ref 544* 545 546 547 549 573* 574 577*
                                                                                  578
segptr                                 parameter       pointer                  dcl 735 set ref 732 741* 742*
service_type            526            based           fixed bin(17,0)          level 2 dcl 7-50 set ref 700* 700
size                                                   builtin function         dcl 238 ref 542 568 568
size1                                  parameter       fixed bin(17,0)          dcl 736 ref 732 740
size2                           000436 automatic       fixed bin(18,0)          dcl 738 set ref 740* 741* 742*
sst$seg_state_change_limit      000130 external static fixed bin(17,0)          dcl 185 ref 602
stack                                  based           structure                level 1 dcl 136
stack_header                           based           structure                level 1 dcl 9-26
state                     1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-7 set ref 582*
state_change_time        22            based           fixed bin(71,0)          level 2 dcl 2-7 set ref 593*
stop_type                       000374 automatic       bit(1)                   dcl 107 set ref 285*
string                                                 builtin function         dcl 238 ref 279 549
substr                                                 builtin function         dcl 238 ref 301 487 490 613
subsystem                65            based           char(64)                 level 2 dcl 5-23 ref 359
switches                  1     000124 automatic       structure                level 2 packed packed unaligned dcl 59
sys_info$access_class_ceiling   000132 external static bit(72)                  dcl 186 set ref 260*
sys_info$default_256K_enable    000134 external static fixed bin(17,0)          dcl 187 ref 570
sys_info$page_size              000136 external static fixed bin(17,0)          dcl 188 ref 543 543 543 543 572 572 572 572
sys_info$time_of_bootload       000140 external static fixed bin(71,0)          dcl 189 ref 373
syserr$error_code               000232 constant        entry                    external dcl 221 ref 394 743
tag                      20            based           char(1)                  level 2 dcl 115 ref 455
tc_data$pdscopyl                000142 external static fixed bin(17,0)          dcl 190 ref 356
tc_data$stat                    000144 external static fixed bin(17,0)          array dcl 191 set ref 583* 583
tc_data$timax                   000146 external static fixed bin(17,0)          dcl 192 ref 581
template                  7(25)        based           bit(1)                   level 2 packed packed unaligned dcl 6-18 ref 373
template_dsegp                  000376 automatic       pointer                  dcl 108 set ref 364* 552* 553 555* 560 562* 647 647*
template_kstp                   000400 automatic       pointer                  dcl 109 set ref 364* 365* 366 373 373 375* 377 377
                                                                                  378 380* 645 645*
template_pds$                   000150 external static fixed bin(17,0)          dcl 193 set ref 357
term_channel             30            based           fixed bin(71,0)          level 2 in structure "apte" dcl 2-7 in procedure
                                                                                  "act_proc" set ref 592*
term_channel              2            based           fixed bin(71,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 462
term_processid           14            based           bit(36)                  level 2 in structure "apte" dcl 2-7 in procedure
                                                                                  "act_proc" set ref 591*
term_processid            4            based           bit(36)                  level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 459
term_type_name          514            based           char(32)                 level 2 packed packed unaligned dcl 7-50 set ref
                                                                                  699* 699
terminal_access_class
                        125            based           bit(72)                  level 2 dcl 7-50 set ref 697* 697
terminate_$noname               000234 constant        entry                    external dcl 222 ref 380 500 562 621 623 625 645 647
                                                                                  708
timax                     7            based           fixed bin(35,0)          level 2 in structure "apte" dcl 2-7 in procedure
                                                                                  "act_proc" set ref 581* 630*
timax                    12            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 630 630
time_of_bootload          4            based           fixed bin(71,0)          level 2 dcl 6-18 ref 373
tsdw                            000402 automatic       fixed bin(71,0)          dcl 110 set ref 545 574 578 744* 745
tty                     730            based           char(32)                 level 2 packed packed unaligned dcl 7-50 set ref
                                                                                  695* 695
tty_answerback          527            based           char(4)                  level 2 packed packed unaligned dcl 7-50 set ref
                                                                                  702* 702
tty_type                525            based           fixed bin(17,0)          level 2 dcl 7-50 set ref 703* 703
unique_chars_                   000236 constant        entry                    external dcl 223 ref 280 687
unspec                                                 builtin function         dcl 238 set ref 299* 549*
user_abs_attributes                    based           structure                level 1 dcl 12-25
user_attributes                        based           structure                level 1 dcl 11-21
user_processid           30            based           char(32)                 level 2 dcl 5-23 ref 631 632
userid                    6     000124 automatic       char(32)                 level 2 in structure "branch_info" dcl 59
                                                                                  in procedure "act_proc" set ref 305*
userid                          000160 automatic       char(32)                 array level 2 in structure "dir_acl" dcl 66
                                                                                  in procedure "act_proc" set ref 329* 331* 333* 338
userid                          000324 automatic       char(32)                 array level 2 in structure "seg_acl" dcl 99
                                                                                  in procedure "act_proc" set ref 328* 330* 332* 337
version                         000124 automatic       fixed bin(17,0)          level 2 in structure "branch_info" dcl 59
                                                                                  in procedure "act_proc" set ref 300*
version                   1            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 359
words_of_pit              5            based           fixed bin(17,0)          level 2 dcl 5-23 ref 484
work_class                      000404 automatic       fixed bin(17,0)          dcl 111 in procedure "act_proc" set ref 506* 507*
work_class               64            based           fixed bin(17,0)          level 2 in structure "create_info" dcl 5-23
                                                                                  in procedure "act_proc" ref 506
ws_size                  32            based           fixed bin(17,0)          level 2 dcl 2-7 set ref 590*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 12-38
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 11-77
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 10-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 10-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 10-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 10-7
PIT_version_3                          internal static fixed bin(17,0)          initial dcl 7-143
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 10-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 10-7
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 11-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 11-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 11-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 11-50
arg_info                               based           structure                level 1 dcl 7-136
asta                                   based           bit(432)                 array dcl 3-86
aste                                   based           structure                level 1 dcl 3-11
aste_part                              based           structure                level 1 dcl 3-89
call_offset                            internal static fixed bin(17,0)          initial dcl 9-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 9-78
pds$kstp                               external static pointer                  dcl 6-15
pit_$                                  external static bit(36)                  dcl 7-47
push_offset                            internal static fixed bin(17,0)          initial dcl 9-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 9-78
return_offset                          internal static fixed bin(17,0)          initial dcl 9-78
seg_aste                               based           structure                level 1 dcl 3-96
stack_header_overlay                   based           fixed bin(17,0)          array dcl 9-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 9-72
version_of_create_info                 internal static fixed bin(17,0)          initial dcl 5-10

NAMES DECLARED BY EXPLICIT CONTEXT.
EVOLUTION_CLEANUP               000000 constant        label                    array(5) dcl 643 ref 267 273 317 342 345 350 354 370
                                                                                  395 454 477 480 483 492 494 501 508 622 624 626
                                                                                  633 640 691 709
act_proc                        000126 constant        entry                    external dcl 51
bad_subsystem                   000752 constant        label                    dcl 368 ref 373 376 381 553 556 557 559
common                          002254 constant        label                    dcl 538
create                          000140 constant        entry                    external dcl 245
create_hardcore_seg             003512 constant        entry                    internal dcl 715 ref 344 349 353
return_ai_error                 000241 constant        label                    dcl 265 ref 260
set_ehs                         003723 constant        entry                    internal dcl 732 ref 543 572 576
set_pit_tty_info                003277 constant        entry                    external dcl 669

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5240        5500    4132        5250
Length      6320    4132       240         603    1105           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
act_proc                            562 external procedure  is an external procedure.  
create_hardcore_seg                     internal procedure  shares stack frame of external procedure act_proc.  
set_ehs                                 internal procedure  shares stack frame of external procedure act_proc.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
act_proc                 000100 PRELINKED_DIR               act_proc
                         000120 abs_ptr                     act_proc
                         000122 bc                          act_proc
                         000123 evolution                   act_proc
                         000124 branch_info                 act_proc
                         000147 clr_size                    act_proc
                         000150 code                        act_proc
                         000151 ignore_code                 act_proc
                         000152 cp                          act_proc
                         000154 daemon_sw                   act_proc
                         000156 dbr                         act_proc
                         000160 dir_acl                     act_proc
                         000216 dir_aclp                    act_proc
                         000220 dseg_ptr                    act_proc
                         000222 dseg_size                   act_proc
                         000224 dstep                       act_proc
                         000226 esw                         act_proc
                         000227 hd                          act_proc
                         000237 i                           act_proc
                         000240 is_absentee                 act_proc
                         000242 kst_ptr                     act_proc
                         000244 kst_size                    act_proc
                         000245 local_audit_event_flags     act_proc
                         000246 lot_size                    act_proc
                         000250 max_authorization           act_proc
                         000252 max_lot                     act_proc
                         000253 n                           act_proc
                         000254 p                           act_proc
                         000256 p1                          act_proc
                         000260 p2                          act_proc
                         000262 pdir_dir_quota              act_proc
                         000263 pdir_entry                  act_proc
                         000267 pdir_path                   act_proc
                         000277 pdir_quota                  act_proc
                         000300 pds_astep                   act_proc
                         000302 pds_ptr                     act_proc
                         000304 pid                         act_proc
                         000306 process_authorization       act_proc
                         000310 process_group               act_proc
                         000320 rings                       act_proc
                         000323 savring                     act_proc
                         000324 seg_acl                     act_proc
                         000366 seg_aclp                    act_proc
                         000370 seg_rb                      act_proc
                         000373 segno                       act_proc
                         000374 stop_type                   act_proc
                         000376 template_dsegp              act_proc
                         000400 template_kstp               act_proc
                         000402 tsdw                        act_proc
                         000404 work_class                  act_proc
                         000406 pitp                        act_proc
                         000410 aptep                       act_proc
                         000412 astep                       act_proc
                         000414 pit_ptr                     act_proc
                         000416 sb                          act_proc
                         000436 size2                       set_ehs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_name_$elements            access_audit_$check_general_user                            aim_check_$greater_or_equal
append$branchx                append$create_branch_         asd_$replace_dall             asd_$replace_sall
chname$cfile                  del_dir_tree                  delentry$dfile                fs_modes
get_ptrs_$given_astep         getuid                        grab_aste                     grab_aste$prewithdraw
init_proc                     initiate                      initiate$initiate_count       initiate$priv_init
level$get                     level$set                     pxss$empty_t                  pxss$get_entry
pxss$set_work_class           syserr$error_code             terminate_$noname             unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
abs_seg$                      active_all_rings_data$default_max_segno                     active_all_rings_data$hcscnt
active_all_rings_data$max_segno                             active_all_rings_data$stack_base_segno
active_hardcore_data$pdir_dir_quota                         active_hardcore_data$pdir_quota
dseg$                         error_table_$ai_restricted    error_table_$apt_full
error_table_$invalid_subsystem                              error_table_$smallarg         kst_seg$
pds$                          pds$access_authorization      pds$access_name               pds$account_id
pds$apt_ptr                   pds$audit_flags               pds$clr_stack_size            pds$covert_event_count
pds$dstep                     pds$first_covert_event_time   pds$highest_ring              pds$home_dir
pds$initial_procedure         pds$initial_ring              pds$interrupt_ring            pds$last_sp
pds$lock_id                   pds$lot_stack_size            pds$max_access_authorization  pds$max_lot_size
pds$prelinked_ring            pds$process_dir_name          pds$process_group_id          pds$processid
pds$term_channel              pds$term_proc                 pds$throttle_segment_state_changes
sst$seg_state_change_limit    sys_info$access_class_ceiling sys_info$default_256K_enable  sys_info$page_size
sys_info$time_of_bootload     tc_data$pdscopyl              tc_data$stat                  tc_data$timax
template_pds$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     51 000125       245 000133       248 000150       250 000152       251 000154       252 000160       253 000166
    257 000176       258 000202       260 000205       263 000223       265 000241       267 000244       270 000246
    271 000255       272 000261       273 000264       276 000266       278 000267       279 000272       280 000274
    281 000312       283 000320       285 000324       289 000326       290 000330       292 000334       294 000340
    295 000342       297 000346       299 000352       300 000355       301 000357       302 000363       303 000365
    304 000367       305 000371       306 000376       307 000400       308 000402       309 000404       310 000406
    311 000410       312 000411       313 000413       314 000415       316 000417       317 000453       320 000457
    321 000465       322 000470       323 000471       324 000475       326 000477       328 000500       329 000503
    330 000506       331 000513       332 000516       333 000521       334 000524       337 000526       338 000530
    340 000532       341 000534       342 000600       344 000604       345 000611       347 000617       349 000620
    350 000625       353 000633       354 000640       356 000646       357 000651       359 000657       361 000667
    363 000672       364 000676       365 000701       366 000746       368 000752       370 000755       372 000757
    373 000760       375 000770       376 001011       377 001015       378 001031       379 001036       380 001052
    381 001064       382 001066       386 001070       387 001073       388 001075       389 001077       390 001104
    391 001113       393 001115       394 001117       395 001155       399 001157       400 001161       401 001166
    402 001174       403 001177       406 001201       407 001204       408 001212       409 001220       410 001223
    413 001225       414 001233       415 001240       416 001243       418 001245       419 001253       421 001255
    422 001262       424 001272       425 001300       427 001302       428 001307       430 001311       431 001316
    433 001321       434 001326       436 001331       437 001337       439 001343       440 001350       442 001353
    443 001360       444 001364       446 001367       447 001374       449 001400       450 001405       452 001411
    453 001416       454 001436       455 001442       456 001451       458 001452       459 001460       461 001463
    462 001470       464 001472       465 001477       467 001502       468 001507       470 001512       471 001520
    473 001524       474 001525       475 001530       476 001532       477 001613       479 001617       480 001660
    482 001664       483 001730       484 001736       485 001741       486 001747       487 001755       490 001773
    491 001776       492 002052       493 002056       494 002114       496 002120       497 002173       500 002203
    501 002214       503 002220       505 002223       506 002230       507 002232       508 002250       538 002254
    539 002257       541 002262       542 002271       543 002274       544 002305       545 002313       546 002317
    547 002335       548 002347       549 002351       551 002354       552 002360       553 002430       554 002434
    555 002435       556 002457       557 002461       558 002463       559 002470       560 002471       562 002504
    563 002515       566 002517       567 002525       568 002527       569 002544       570 002552       572 002560
    573 002572       574 002600       576 002604       577 002613       578 002621       579 002625       581 002627
    582 002632       583 002637       584 002641       585 002643       586 002646       587 002650       588 002655
    590 002663       591 002664       592 002672       593 002702       596 002706       597 002707       598 002711
    599 002713       602 002746       603 002755       613 002764       619 002775       621 002776       622 003010
    623 003014       624 003025       625 003031       626 003042       628 003046       630 003050       631 003055
    632 003061       633 003123       638 003127       640 003130       643 003132       645 003134       647 003151
    651 003166       655 003217       659 003250       663 003261       666 003270       667 003272       669 003273
    676 003307       679 003311       680 003314       681 003317       684 003320       685 003327       686 003337
    687 003341       688 003360       689 003366       690 003370       691 003434       695 003442       696 003447
    697 003453       698 003457       699 003461       700 003464       701 003466       702 003470       703 003472
    704 003474       708 003477       709 003510       715 003512       720 003523       721 003526       722 003531
    723 003607       725 003612       726 003653       728 003656       730 003722       732 003723       740 003725
    741 003730       742 003751       743 003766       744 004021       745 004032       746 004034


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
