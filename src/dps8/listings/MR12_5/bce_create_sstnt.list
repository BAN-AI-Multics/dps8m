	COMPILATION LISTING OF SEGMENT bce_create_sstnt
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1026.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-01-14,Fawcett), approve(86-04-11,MCR7383),
       12*     audit(86-05-12,Farley), install(86-07-17,MR12.0-1097):
       13*     Add support for devices using 512_WORD_IO
       14*  2) change(87-02-04,Farley), approve(87-04-15,MCR7660),
       15*     audit(87-04-16,Lippard), install(87-04-28,MR12.1-1028):
       16*     Changed to correct the calculation of vtoc_offset.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 bce_create_sstnt: proc (sst_abs_start, sst_abs_end);
       21 
       22 /* Program to generate the sst_names_ segment for Multics within bce.
       23*Written August 1984 by Keith Loepere. */
       24 
       25 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       26 
       27 /* The sst_names_ segment gives the name of the segment corresponding to each 
       28*aste.  The segment may be maintained by Multics, by specifying the "astk"
       29*parm, or by this program.  The sst_names_ maintained by this program fetches
       30*the name for an aste from the corresponding vtoce. */
       31 
       32 /* Parameters */
       33 
       34 dcl  sst_abs_end			fixed bin (26) parameter;
       35 dcl  sst_abs_start			fixed bin (26) parameter;
       36 
       37 /* Constants */
       38 
       39 dcl  ME				char (12) init ("create_sstnt") static options (constant);
       40 dcl  page_table_sizes		(0:3) fixed bin init (4, 16, 64, 256) static options (constant);
       41 
       42 /* Entries */
       43 
       44 dcl  bce_appending_simulation$get_absolute entry (fixed bin (26), fixed bin (18), ptr, fixed bin (35));
       45 dcl  bce_appending_simulation$get_virtual entry (ptr, fixed bin (26), fixed bin (18), ptr, fixed bin (35));
       46 dcl  bce_appending_simulation$new_segment entry (fixed bin (15), ptr, fixed bin (35));
       47 dcl  bce_appending_simulation$put_virtual entry (ptr, fixed bin (26), fixed bin (18), ptr, fixed bin (35));
       48 dcl  bce_check_abort		entry;
       49 dcl  com_err_			entry () options (variable);
       50 dcl  ioa_				entry () options (variable);
       51 dcl  read_disk$read_disk_no_test	entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
       52 
       53 /* Variables */
       54 
       55 dcl  aste_num			fixed bin;	/* loop index on astes in a pool */
       56 dcl  aste_pool			fixed bin;	/* loop index on aste pools */
       57 dcl  code				fixed bin (35);
       58 dcl  1 my_aste			aligned like aste;	/* read in aste */
       59 dcl  1 my_sstnt_seg_info		aligned like seg_info; /* description of sstnt */
       60 dcl  sst_buffer			bit (36 * 1024) aligned; /* fetch the sst a page at a time for efficiency */
       61 dcl  sst_buffer_offset		fixed bin (18);	/* this ptr shows how much of page buffer we've processed */
       62 dcl  sst_name			char (32) var;	/* element of sst_names_ */
       63 dcl  sst_seg_offset			fixed bin (26);	/* of data in sst_buffer */
       64 dcl  sst_sizes			(0:3) fixed bin;	/* size of pools */
       65 dcl  sstnt_buffer			bit (36 * 1024) aligned; /* write the sstnt a page at a time for efficiency */
       66 dcl  sstnt_buffer_offset		fixed bin (18);	/* this ptr shows how much of page buffer we've processed */
       67 dcl  sstnt_header_size		fixed bin (18);	/* everything before the names */
       68 dcl  sstnt_seg_offset		fixed bin (26);	/* of start of data in sstnt_buffer */
       69 dcl  vtoc_offset			fixed bin;	/* offset of desired vtoce within page */
       70 dcl  vtoc_record			bit (36 * 1024) aligned; /* for reading vtoces */
       71 dcl  vtoc_record_num		fixed bin (18);	/* page number holding vtoce */
       72 
       73 /* Misc */
       74 
       75 dcl  addr				builtin;
       76 dcl  addrel			builtin;
       77 dcl  currentsize			builtin;
       78 dcl  divide			builtin;
       79 dcl  max				builtin;
       80 dcl  min				builtin;
       81 dcl  mod				builtin;
       82 dcl  rtrim			builtin;
       83 dcl  segno			builtin;
       84 dcl  size				builtin;
       85 dcl  substr			builtin;
       86 dcl  unspec			builtin;
       87 dcl  wordno			builtin;
       88 
       89 	seg_info_ptr = addr (my_sstnt_seg_info);
       90 	call bce_appending_simulation$new_segment (segno (addr (sst_names_$)), seg_info_ptr, code);
       91 	if code ^= 0 then go to sstnt_error;
       92 
       93 	sstnp = addr (sstnt_buffer);			/* fetch current sst_names_ header */
       94 	sstnt_header_size = wordno (addr (sstnt.names)) - wordno (sstnp);
       95 	call bce_appending_simulation$get_virtual (seg_info_ptr, 0, sstnt_header_size, sstnp, code);
       96 	if code ^= 0 then go to sstnt_error;
       97 
       98 /* Now for some validity checks on sst_names_. */
       99 
      100 	if sstnt.valid & sstnt.multics_or_bce = "mult" then return;
      101 	if sstnt.ast_sizes (0) ^= page_table_sizes (0) + size (aste) |
      102 	     sstnt.ast_sizes (1) ^= page_table_sizes (1) + size (aste) |
      103 	     sstnt.ast_sizes (2) ^= page_table_sizes (2) + size (aste) |
      104 	     sstnt.ast_sizes (3) ^= page_table_sizes (3) + size (aste) then return; /* not initialized */
      105 
      106 	sst_sizes (0) = sstnt.ast_name_offsets (1);	/* size of pools */
      107 	sst_sizes (1) = sstnt.ast_name_offsets (2) - sstnt.ast_name_offsets (1);
      108 	sst_sizes (2) = sstnt.ast_name_offsets (3) - sstnt.ast_name_offsets (2);
      109 	sst_sizes (3) = sstnt.nentries - sstnt.ast_name_offsets (3);
      110 
      111 	if sstnt.ast_offsets (1) ^= sstnt.ast_offsets (0) + /* check pool sizes versus supplied offsets */
      112 	     sst_sizes (0) * (page_table_sizes (0) + size (aste)) then return;
      113 	if sstnt.ast_offsets (2) ^= sstnt.ast_offsets (1) +
      114 	     sst_sizes (1) * (page_table_sizes (1) + size (aste)) then return;
      115 	if sstnt.ast_offsets (3) ^= sstnt.ast_offsets (2) +
      116 	     sst_sizes (2) * (page_table_sizes (2) + size (aste)) then return;
      117 	if sst_abs_end - sst_abs_start + 1 < sstnt.ast_offsets (3) +
      118 	     sst_sizes (3) * (page_table_sizes (3) + size (aste)) then return;
      119 	if seg_info.size < currentsize (sstnt) then return; /* sstnt not big enough for names - not made paged yet? */
      120 
      121 /* We keep a (1 page) buffer of the sst at all times for efficiency.  For our
      122*purposes, we don't need the sst header.  We'll start reading with the start
      123*of the astes.  So, we start by fetching that buffers' worth of the sst that
      124*contains the start of the astes. */
      125 
      126 	sst_seg_offset = sstnt.ast_offsets (0);
      127 	sst_buffer_offset = mod (sst_seg_offset, size (sst_buffer));
      128 	call bce_appending_simulation$get_absolute (sst_abs_start + sst_seg_offset - sst_buffer_offset, size (sst_buffer), addr (sst_buffer), code);
      129 
      130 /* We also keep a (1 page) buffer of the sstnt waiting to be written.  Start
      131*us out as writing after the header (which we'll write later). */
      132 
      133 	sstnt_buffer_offset = sstnt_header_size;
      134 	sstnt_seg_offset = 0;
      135 
      136 	sstnt.multics_or_bce = "bce";
      137 	sstnt.valid = "1"b;
      138 
      139 	call ioa_ ("Filling sst_names_");
      140 
      141 	astep = addr (my_aste);
      142 
      143 /* Read each aste.  For all valid ones, grab the name from the vtoce. */
      144 
      145 	pvt_arrayp = addr (pvt$array);
      146 
      147 	do aste_pool = 0 to 3;
      148 	     do aste_num = 1 to sst_sizes (aste_pool);
      149 		sst_name = "";
      150 		call get_next_aste (page_table_sizes (aste_pool));
      151 		if aste.uid = "0"b then go to next_aste;
      152 		if aste.uid = "777777777777"b3 then do;
      153 		     sst_name = ">";
      154 		     go to next_aste;
      155 		end;
      156 		if aste.hc then go to next_aste;
      157 		if aste.vtocx = -1 then go to next_aste;
      158 		if aste.pvtx > pvt$max_n_entries then goto next_aste;
      159 		pvtep = addr (pvt_array (aste.pvtx));
      160 		vtoc_record_num = VTOC_ORIGIN + divide (aste.vtocx, VTOCES_PER_RECORD (pvte.device_type), 17);
      161 		vtoc_offset = sect_per_vtoc (pvte.device_type) * words_per_sect (pvte.device_type) * mod (aste.vtocx, VTOCES_PER_RECORD (pvte.device_type));
      162 		call read_disk$read_disk_no_test ((aste.pvtx), vtoc_record_num, addr (vtoc_record), code);
      163 		if code ^= 0 then go to next_aste;
      164 		vtocep = addrel (addr (vtoc_record), vtoc_offset);
      165 		sst_name = rtrim (vtoce.primary_name);
      166 
      167 next_aste:	call add_name_to_sstnt;
      168 		call bce_check_abort;
      169 	     end;
      170 	end;
      171 	call add_name_to_sstnt$flush;
      172 	return;
      173 
      174 sstnt_error:
      175 	call com_err_ (code, ME);
      176 	return;
      177 
      178 add_name_to_sstnt: proc;
      179 
      180 /* This subproc adds sst_name to the end of sstnt_buffer.  If this
      181*runs off the end, the current buffer is written and the excess added to the
      182*new buffer's worth. */
      183 
      184 dcl  sst_name_bits			bit (size (sst_name) * 36) aligned based (addr (sst_name));
      185 dcl  words_in_current_page		fixed bin;
      186 dcl  words_in_new_page		fixed bin;
      187 
      188 	words_in_current_page = min (size (sstnt_buffer) - sstnt_buffer_offset, size (sst_name));
      189 	substr (sstnt_buffer, 1 + sstnt_buffer_offset * 36, words_in_current_page * 36) =
      190 	     substr (sst_name_bits, 1, words_in_current_page * 36);
      191 	sstnt_buffer_offset = sstnt_buffer_offset + words_in_current_page;
      192 
      193 	if sstnt_buffer_offset = size (sstnt_buffer) then do;
      194 	     call bce_appending_simulation$put_virtual (seg_info_ptr, sstnt_seg_offset, size (sstnt_buffer), addr (sstnt_buffer), code);
      195 	     sstnt_seg_offset = sstnt_seg_offset + size (sstnt_buffer);
      196 
      197 	     words_in_new_page = size (sst_name) - words_in_current_page;
      198 	     substr (sstnt_buffer, 1, words_in_new_page * 36) =
      199 		substr (sst_name_bits, 1 + words_in_current_page * 36, words_in_new_page * 36);
      200 	     sstnt_buffer_offset = words_in_new_page;
      201 	end;
      202 	return;
      203 
      204 add_name_to_sstnt$flush: entry;
      205 
      206 	call bce_appending_simulation$put_virtual (seg_info_ptr, sstnt_seg_offset, sstnt_buffer_offset, addr (sstnt_buffer), code);
      207 	return;
      208      end add_name_to_sstnt;
      209 
      210 get_next_aste: proc (page_table_size);
      211 
      212 /* This subproc returns the next aste in the sst.  It skips over the page 
      213*table.  It reads in the next page of sst if necessary to do this. */
      214 
      215 dcl  page_table_size		fixed bin parameter;
      216 
      217 dcl  aste_size			fixed bin;
      218 dcl  words_in_current_page		fixed bin;
      219 dcl  words_in_page_to_be_fetched	fixed bin;
      220 dcl  words_to_copy			fixed bin;
      221 
      222 	aste_size = page_table_size + size (aste);
      223 	words_in_current_page = min (size (sst_buffer) - sst_buffer_offset, aste_size);
      224 	words_to_copy = min (words_in_current_page, size (aste));
      225 	substr (unspec (aste), 1, words_to_copy * 36) =
      226 	     substr (sst_buffer, 1 + sst_buffer_offset * 36, words_to_copy * 36);
      227 	sst_seg_offset = sst_seg_offset + words_in_current_page;
      228 	sst_buffer_offset = sst_buffer_offset + words_in_current_page;
      229 
      230 	if sst_buffer_offset >= size (sst_buffer) then do;
      231 	     call bce_appending_simulation$get_absolute (sst_abs_start + sst_seg_offset, size (sst_buffer), addr (sst_buffer), code);
      232 
      233 	     words_in_page_to_be_fetched = aste_size - words_in_current_page;
      234 	     words_to_copy = max (size (aste) - words_in_current_page, 0);
      235 	     substr (unspec (aste), 1 + words_in_current_page * 36, words_to_copy * 36) =
      236 		substr (sst_buffer, 1, words_to_copy * 36);
      237 	     sst_seg_offset = sst_seg_offset + words_in_page_to_be_fetched;
      238 	     sst_buffer_offset = words_in_page_to_be_fetched;
      239 	end;
      240 	return;
      241      end get_next_aste;
      242  /* BEGIN include file bce_appending_seg_info.incl.pl1 */
  1     2 
  1     3 /* Description of data returned by bce_appending_simulation$new_segment. 
  1     4*Keith Loepere, November 1983. */
  1     5 
  1     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  1     7 
  1     8 dcl  seg_info_ptr		        ptr;
  1     9 dcl  1 seg_info		        aligned based (seg_info_ptr),
  1    10        2 sst_data		        aligned like aste,
  1    11        2 page_table		        (0:255) bit (36) aligned,
  1    12        2 sdwi		        aligned like sdw_info;
  1    13 
  1    14  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
  1    14 
  1    15  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  3     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  3     3 
  3     4 dcl  sdw_info_ptr pointer;
  3     5 
  3     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  3     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  3     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  3     9 
  3    10     2 access unaligned,				/* REWP */
  3    11       3 read bit (1) unaligned,
  3    12       3 execute bit (1) unaligned,
  3    13       3 write bit (1) unaligned,
  3    14       3 privileged bit (1) unaligned,
  3    15 
  3    16     2 pad1 bit (32) unaligned,
  3    17 
  3    18     2 rings unaligned,				/* Ring brackets */
  3    19       3 r1 bit (3) unaligned,
  3    20       3 r2 bit (3) unaligned,
  3    21       3 r3 bit (3) unaligned,
  3    22 
  3    23     2 pad2 bit (27) unaligned,
  3    24 
  3    25     2 flags aligned,
  3    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  3    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  3    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  3    29       3 pad3 bit (33) unaligned,
  3    30 
  3    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  3    32 
  3    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
  1    15 
  1    16 
  1    17 /* END include file bce_appending_seg_info.incl.pl1 */
      242 
      243  /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  4     2 
  4     3 
  4     4 
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  4     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  4     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  4    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  4    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  4    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  4    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  4    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  4    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  4    16*                                                   END HISTORY COMMENTS */
  4    17 
  4    18 
  4    19 /*
  4    20*   All disk packs have the standard layout described below:
  4    21*
  4    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  4    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  4    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  4    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  4    26*   Record  7		: formerly contained bad track list; no longer used.
  4    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  4    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  4    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  4    30*
  4    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  4    32*   of the particular partition.
  4    33*
  4    34*
  4    35*
  4    36*   A conceptual declaration for a disk pack could be:
  4    37*
  4    38*   dcl 1 disk_pack,
  4    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  4    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  4    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  4    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  4    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  4    44*   2 vtoc_array_records	(8 : n-1),
  4    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  4    46*   3 unused				bit(36 * 64),
  4    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  4    48*
  4    49*
  4    50*
  4    51*
  4    52**/
  4    53 
  4    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  4    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  4    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  4    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  4    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  4    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  4    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  4    61 		         fixed bin (17) int static options (constant);
  4    62 
  4    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  4    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  4    65 /* or the physical volume table entry (pvte) device type.		      */
  4    66 
  4    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  4    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  4    69 
  4    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  4    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  4    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  4    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    76 
  4    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      243 
      244  /* Begin fs_dev_types_sector.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     7*     Add the sector differance for devices that do 64 word IO and devices that
  5     8*     do 512 word IO.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  5    12*	 need all the data in fs_dev_types. This is also included in
  5    13*	 fs_dev_types.incl.pl1  */
  5    14 
  5    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  5    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  5    17 
  5    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  5    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  5    20 
  5    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  5    22  /* table of # of sectors per record on each device */
  5    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  5    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    25 
  5    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  5    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    28 	
  5    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  5    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  5    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    32 
  5    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  5    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  5    35 
  5    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  5    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  5    38 
  5    39 /* End fs_dev_types_sector.incl.pl1 */
  5    40 
      244 
      245  /* BEGIN include file ptw_info.incl.pl1 */
  6     2 
  6     3 /* Description of the info returned by ptw_util_$dissect.  
  6     4*Keith Loepere, October 1983. */
  6     5 
  6     6 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  6     7 
  6     8 dcl  ptw_info_ptr		        ptr;
  6     9 
  6    10 dcl  1 ptw_info		        aligned based (ptw_info_ptr),
  6    11        2 address		        fixed bin (26),	/* memory or device number */
  6    12        2 add_type		        bit (4) unal,
  6    13        2 null_disk		        bit (1) unal,
  6    14        2 er		        bit (1) unal,
  6    15        2 wired		        bit (1) unal,
  6    16        2 os		        bit (1) unal,
  6    17        2 phu1		        bit (1) unal,	/* used in quantum */
  6    18        2 phm1		        bit (1) unal,	/* modified in quantum */
  6    19        2 valid		        bit (1) unal,
  6    20        2 phu		        bit (1) unal,
  6    21        2 phm		        bit (1) unal;
  6    22 
  6    23 /* END include file ptw_info.incl.pl1 */
      245 
      246  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  7     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7     8*     Add the support for subvolumes
  7     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  7    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  7    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  7    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  7    14*     Added inconsistent_dbm bit for determining the status of volume
  7    15*     dumper bit maps.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18      dcl	   pvt$array	      aligned external;
  7    19      dcl	   pvt$max_n_entries      fixed bin external;
  7    20 
  7    21      dcl	   pvt_arrayp	      ptr;
  7    22      dcl	   pvtep		      ptr;
  7    23 
  7    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  7    25 
  7    26      dcl	   1 pvte		      based (pvtep) aligned,
  7    27 
  7    28 	     2 pvid	      bit (36),		/* physical volume ID */
  7    29 
  7    30 	     2 lvid	      bit (36),		/* logical volume ID */
  7    31 
  7    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  7    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  7    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  7    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  7    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  7    37 	     2 pad3	      bit (2) unaligned,
  7    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  7    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  7    40 
  7    41 
  7    42 
  7    43 	     2 devname	      char (4),		/* device name */
  7    44 
  7    45 	     (2 device_type	      fixed bin (8),	/* device type */
  7    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  7    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  7    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  7    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  7    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  7    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  7    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  7    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  7    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  7    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  7    56 	     2 scav_check_address
  7    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  7    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  7    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  7    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  7    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  7    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  7    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  7    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  7    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  7    66 
  7    67 
  7    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  7    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  7    70 
  7    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  7    72 
  7    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  7    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  7    75 
  7    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  7    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  7    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  7    79 	     2 records_per_cyl    fixed bin,
  7    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  7    81 	     2 sv_name            char (2) aligned,
  7    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  7    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  7    84 
  7    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  7    86 	     2 pad2	      bit (18) unaligned,
  7    87 
  7    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  7    89 
  7    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  7    91 
  7    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  7    93 
  7    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  7    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  7    96 
  7    97 
  7    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  7    99 
  7   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  7   101 
  7   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  7   103 
  7   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  7   105 
  7   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  7   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  7   108 
  7   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  7   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  7   111 
  7   112 
  7   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  7   114 	   VOLMAP_ASYNC_READ      init (1),
  7   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  7   116 
  7   117 
  7   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      246 
      247  /* Begin include file sstnt.incl.pl1   */
  8     2 
  8     3 /* Created 10/03/74 by Bernard Greenberg */
  8     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  8     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  8     6 
  8     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  8     8 
  8     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  8    10 
  8    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  8    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  8    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  8    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  8    15     2 pad1 (5) fixed bin,
  8    16 
  8    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  8    18      ast_name_offsets,				/* Starting index for names at each level */
  8    19      ast_offsets,					/* Starting rel addr of each AST region */
  8    20      pad2) (0 : 3) fixed bin,
  8    21 
  8    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  8    23 
  8    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  8    25 
  8    26 dcl  nm_astep ptr;					/* astep to be used */
  8    27 
  8    28 /* End include file sstnt.incl.pl1 */
      247 
      248  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  9     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  9     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  9     4 
  9     5 dcl  vtocep ptr;
  9     6 
  9     7 dcl 1 vtoce based (vtocep) aligned,
  9     8 
  9     9 
  9    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  9    11 
  9    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  9    13 
  9    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  9    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  9    16     2 records bit (9),				/* number of records used by the seg in second storage */
  9    17     2 pad2 bit (9),
  9    18 
  9    19     2 dtu bit (36),					/* date and time segment was last used */
  9    20 
  9    21     2 dtm bit (36),					/* date and time segment was last modified */
  9    22 
  9    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  9    24     2 deciduous bit (1),				/* true if hc_sdw */
  9    25     2 nid bit (1),					/* no incremental dump switch */
  9    26     2 dnzp bit (1),					/* Dont null zero pages */
  9    27     2 gtpd bit (1),					/* Global transparent paging device */
  9    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  9    29     2 damaged bit (1),				/* TRUE if contents damaged */
  9    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  9    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  9    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  9    33     2 pad3 bit (8),
  9    34     2 dirsw bit (1),				/* directory switch */
  9    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  9    36     2 pad4 bit (16)) unaligned,			/* not used */
  9    37 
  9    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  9    39 
  9    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  9    41 
  9    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  9    43 
  9    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  9    45 
  9    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  9    47 
  9    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  9    49 
  9    50 
  9    51 
  9    52 
  9    53 
  9    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  9    55 
  9    56     2 pad6 (10) bit (36),				/* not used */
  9    57 
  9    58     2 ncd bit (1),					/* no complete dump switch */
  9    59     2 pad7 bit (17),
  9    60     2 pad8 bit (18),
  9    61 
  9    62     2 dtd bit (36),					/* date-time-dumped */
  9    63 
  9    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  9    65 
  9    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  9    67 
  9    68 
  9    69 
  9    70 
  9    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  9    72 
  9    73     2 primary_name char (32),				/* primary name of the segment */
  9    74 
  9    75     2 time_created bit (36),				/* time the segment was created */
  9    76 
  9    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  9    78 
  9    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  9    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  9    81 
  9    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  9    83 
  9    84     2 access_class bit (72),				/* access class in branch */
  9    85     2 perm_flags aligned,
  9    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  9    87       3 pad9 bit (35) unal,
  9    88     2 owner bit (36);				/* pvid of this volume */
  9    89 
  9    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  9    91 
  9    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  9    93     2 pad1 bit (7*36),
  9    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  9    95     2 pad2 bit (184*36);
  9    96 
  9    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      248 
      249      end bce_create_sstnt;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.6  bce_create_sstnt.pl1              >special_ldd>install>MR12.3-1114>bce_create_sstnt.pl1
242          1    07/11/84  0937.3  bce_appending_seg_info.incl.pl1   >ldd>include>bce_appending_seg_info.incl.pl1
1-14         2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
1-15         3    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
243          4    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
244          5    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
245          6    07/11/84  0937.3  ptw_info.incl.pl1                 >ldd>include>ptw_info.incl.pl1
246          7    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
247          8    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
248          9    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ME                              000037 constant        char(12)                 initial packed unaligned dcl 39 set ref 174*
VTOCES_PER_RECORD               000022 constant        fixed bin(17,0)          initial array dcl 4-72 ref 160 161
VTOC_ORIGIN                            constant        fixed bin(17,0)          initial dcl 4-54 ref 160
addr                                                   builtin function         dcl 75 ref 89 90 90 93 94 128 128 141 145 159 162
                                                                                  162 164 189 194 194 198 206 206 231 231
addrel                                                 builtin function         dcl 76 ref 164
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 106 107 107 108 108 109
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 111 111 113 113 115 115
                                                                                  117 126
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 101 101 101 101
aste                                   based           structure                level 1 dcl 2-11 ref 101 101 101 101 111 113 115 117
                                                                                  222 224 225 234 235
aste_num                        000100 automatic       fixed bin(17,0)          dcl 55 set ref 148*
aste_pool                       000101 automatic       fixed bin(17,0)          dcl 56 set ref 147* 148 150*
aste_size                       006622 automatic       fixed bin(17,0)          dcl 217 set ref 222* 223 233
astep                           006570 automatic       pointer                  dcl 2-9 set ref 101 101 101 101 111 113 115 117 141*
                                                                                  151 152 156 157 158 159 160 161 162 222 224 225
                                                                                  234 235
bce_appending_simulation$get_absolute
                                000010 constant        entry                    external dcl 44 ref 128 231
bce_appending_simulation$get_virtual
                                000012 constant        entry                    external dcl 45 ref 95
bce_appending_simulation$new_segment
                                000014 constant        entry                    external dcl 46 ref 90
bce_appending_simulation$put_virtual
                                000016 constant        entry                    external dcl 47 ref 194 206
bce_check_abort                 000020 constant        entry                    external dcl 48 ref 168
code                            000102 automatic       fixed bin(35,0)          dcl 57 set ref 90* 91 95* 96 128* 162* 163 174* 194*
                                                                                  206* 231*
com_err_                        000022 constant        entry                    external dcl 49 ref 174
currentsize                                            builtin function         dcl 77 ref 119
device_type               4            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 7-26 ref 160 161
                                                                                  161 161
divide                                                 builtin function         dcl 78 ref 160
hc                        5(04)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 156
ioa_                            000024 constant        entry                    external dcl 50 ref 139
max                                                    builtin function         dcl 79 ref 234
min                                                    builtin function         dcl 80 ref 188 223 224
mod                                                    builtin function         dcl 81 ref 127 161
multics_or_bce            1            based           char(4)                  level 2 dcl 8-11 set ref 100 136*
my_aste                         000103 automatic       structure                level 1 dcl 58 set ref 141
my_sstnt_seg_info               000117 automatic       structure                level 1 dcl 59 set ref 89
names                    30            based           varying char(32)         array level 2 dcl 8-11 set ref 94
nentries                  2            based           fixed bin(17,0)          level 2 dcl 8-11 ref 109 119
page_table_size                        parameter       fixed bin(17,0)          dcl 215 ref 210 222
page_table_sizes                000033 constant        fixed bin(17,0)          initial array dcl 40 set ref 101 101 101 101 111 113
                                                                                  115 117 150*
primary_name            260            based           char(32)                 level 2 packed packed unaligned dcl 9-7 ref 165
pvt$array                       000030 external static fixed bin(17,0)          dcl 7-18 set ref 145
pvt$max_n_entries               000032 external static fixed bin(17,0)          dcl 7-19 ref 158
pvt_array                              based           structure                array level 1 dcl 7-24 set ref 159
pvt_arrayp                      006572 automatic       pointer                  dcl 7-21 set ref 145* 159
pvte                                   based           structure                level 1 dcl 7-26
pvtep                           006574 automatic       pointer                  dcl 7-22 set ref 159* 160 161 161 161
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 2-11 ref 158 159
                                                                                  162
read_disk$read_disk_no_test     000026 constant        entry                    external dcl 51 ref 162
rtrim                                                  builtin function         dcl 82 ref 165
sdw_info                               based           structure                level 1 dcl 3-6
sdwi                    414            based           structure                level 2 dcl 1-9
sect_per_vtoc                   000011 constant        fixed bin(17,0)          initial array dcl 5-26 ref 161
seg_info                               based           structure                level 1 dcl 1-9
seg_info_ptr                    006566 automatic       pointer                  dcl 1-8 set ref 89* 90* 95* 119 194* 206*
segno                                                  builtin function         dcl 83 ref 90 90
size                                                   builtin function         dcl 84 in procedure "bce_create_sstnt" ref 101 101
                                                                                  101 101 111 113 115 117 127 128 128 188 188 189
                                                                                  193 194 194 195 197 198 222 223 224 230 231 231
                                                                                  234
size                    415            based           fixed bin(19,0)          level 3 in structure "seg_info" dcl 1-9 in procedure
                                                                                  "bce_create_sstnt" ref 119
sst_abs_end                            parameter       fixed bin(26,0)          dcl 34 ref 20 117
sst_abs_start                          parameter       fixed bin(26,0)          dcl 35 ref 20 117 128 231
sst_buffer                      000541 automatic       bit(36864)               dcl 60 set ref 127 128 128 128 128 223 225 230 231
                                                                                  231 231 231 235
sst_buffer_offset               002541 automatic       fixed bin(18,0)          dcl 61 set ref 127* 128 223 225 228* 228 230 238*
sst_name                        002542 automatic       varying char(32)         dcl 62 set ref 149* 153* 165* 188 189 189 197 198
                                                                                  198
sst_name_bits                          based           bit                      dcl 184 ref 189 198
sst_names_$                     000034 external static fixed bin(17,0)          dcl 8-7 set ref 90 90
sst_seg_offset                  002553 automatic       fixed bin(26,0)          dcl 63 set ref 126* 127 128 227* 227 231 237* 237
sst_sizes                       002554 automatic       fixed bin(17,0)          array dcl 64 set ref 106* 107* 108* 109* 111 113 115
                                                                                  117 148
sstnp                           006576 automatic       pointer                  dcl 8-9 set ref 93* 94 94 95* 100 100 101 101 101
                                                                                  101 106 107 107 108 108 109 109 111 111 113 113
                                                                                  115 115 117 119 126 136 137
sstnt                                  based           structure                level 1 dcl 8-11 set ref 119
sstnt_buffer                    002560 automatic       bit(36864)               dcl 65 set ref 93 188 189* 193 194 194 194 194 195
                                                                                  198* 206 206
sstnt_buffer_offset             004560 automatic       fixed bin(18,0)          dcl 66 set ref 133* 188 189 191* 191 193 200* 206*
sstnt_header_size               004561 automatic       fixed bin(18,0)          dcl 67 set ref 94* 95* 133
sstnt_seg_offset                004562 automatic       fixed bin(26,0)          dcl 68 set ref 134* 194* 195* 195 206*
substr                                                 builtin function         dcl 85 set ref 189* 189 198* 198 225* 225 235* 235
uid                       3            based           bit(36)                  level 2 packed packed unaligned dcl 2-11 ref 151 152
unspec                                                 builtin function         dcl 86 ref 225 235
valid                                  based           bit(1)                   level 2 dcl 8-11 set ref 100 137*
vtoc_offset                     004563 automatic       fixed bin(17,0)          dcl 69 set ref 161* 164
vtoc_record                     004564 automatic       bit(36864)               dcl 70 set ref 162 162 164
vtoc_record_num                 006564 automatic       fixed bin(18,0)          dcl 71 set ref 160* 162*
vtoce                                  based           structure                level 1 dcl 9-7
vtocep                          006600 automatic       pointer                  dcl 9-5 set ref 164* 165
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-11 ref 157 160
                                                                                  161
wordno                                                 builtin function         dcl 87 ref 94 94
words_in_current_page           006623 automatic       fixed bin(17,0)          dcl 218 in procedure "get_next_aste" set ref 223*
                                                                                  224 227 228 233 234 235
words_in_current_page           006612 automatic       fixed bin(17,0)          dcl 185 in procedure "add_name_to_sstnt" set ref
                                                                                  188* 189 189 191 197 198
words_in_new_page               006613 automatic       fixed bin(17,0)          dcl 186 set ref 197* 198 198 200
words_in_page_to_be_fetched     006624 automatic       fixed bin(17,0)          dcl 219 set ref 233* 237 238
words_per_sect                  000000 constant        fixed bin(17,0)          initial array dcl 5-36 ref 161
words_to_copy                   006625 automatic       fixed bin(17,0)          dcl 220 set ref 224* 225 225 234* 235 235

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 4-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 4-54
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 4-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 4-54
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 4-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 4-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 4-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 4-54
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 7-113
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 4-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 4-54
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
nm_astep                               automatic       pointer                  dcl 8-26
ptsi_a                                 automatic       fixed bin(17,0)          dcl 8-24
ptw_info                               based           structure                level 1 dcl 6-10
ptw_info_ptr                           automatic       pointer                  dcl 6-8
sdw_info_ptr                           automatic       pointer                  dcl 3-4
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 5-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 5-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 5-33
seg_aste                               based           structure                level 1 dcl 2-96
seg_vtoce                              based           structure                level 1 dcl 9-92
sstnmx                                 automatic       fixed bin(17,0)          dcl 8-24
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 5-29
vtoce_parts                            based           bit(2304)                array dcl 9-90

NAMES DECLARED BY EXPLICIT CONTEXT.
add_name_to_sstnt               000560 constant        entry                    internal dcl 178 ref 167
add_name_to_sstnt$flush         000652 constant        entry                    internal dcl 204 ref 171
bce_create_sstnt                000062 constant        entry                    external dcl 20
get_next_aste                   000675 constant        entry                    internal dcl 210 ref 150
next_aste                       000525 constant        label                    dcl 167 ref 151 154 156 157 158 163
sstnt_error                     000542 constant        label                    dcl 174 ref 91 96

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1154        1212    1006        1164
Length      1562    1006        36         334     146           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bce_create_sstnt                   3538 external procedure  is an external procedure.  
add_name_to_sstnt                       internal procedure  shares stack frame of external procedure bce_create_sstnt.  
get_next_aste                           internal procedure  shares stack frame of external procedure bce_create_sstnt.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bce_create_sstnt         000100 aste_num                    bce_create_sstnt
                         000101 aste_pool                   bce_create_sstnt
                         000102 code                        bce_create_sstnt
                         000103 my_aste                     bce_create_sstnt
                         000117 my_sstnt_seg_info           bce_create_sstnt
                         000541 sst_buffer                  bce_create_sstnt
                         002541 sst_buffer_offset           bce_create_sstnt
                         002542 sst_name                    bce_create_sstnt
                         002553 sst_seg_offset              bce_create_sstnt
                         002554 sst_sizes                   bce_create_sstnt
                         002560 sstnt_buffer                bce_create_sstnt
                         004560 sstnt_buffer_offset         bce_create_sstnt
                         004561 sstnt_header_size           bce_create_sstnt
                         004562 sstnt_seg_offset            bce_create_sstnt
                         004563 vtoc_offset                 bce_create_sstnt
                         004564 vtoc_record                 bce_create_sstnt
                         006564 vtoc_record_num             bce_create_sstnt
                         006566 seg_info_ptr                bce_create_sstnt
                         006570 astep                       bce_create_sstnt
                         006572 pvt_arrayp                  bce_create_sstnt
                         006574 pvtep                       bce_create_sstnt
                         006576 sstnp                       bce_create_sstnt
                         006600 vtocep                      bce_create_sstnt
                         006612 words_in_current_page       add_name_to_sstnt
                         006613 words_in_new_page           add_name_to_sstnt
                         006622 aste_size                   get_next_aste
                         006623 words_in_current_page       get_next_aste
                         006624 words_in_page_to_be_fetched get_next_aste
                         006625 words_to_copy               get_next_aste

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bce_appending_simulation$get_absolute                       bce_appending_simulation$get_virtual
bce_appending_simulation$new_segment                        bce_appending_simulation$put_virtual
bce_check_abort               com_err_                      ioa_                          read_disk$read_disk_no_test

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pvt$array                     pvt$max_n_entries             sst_names_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000056        89 000067        90 000071        91 000111        93 000113        94 000115        95 000125
     96 000146       100 000150       101 000156       106 000202       107 000204       108 000207       109 000212
    111 000215       113 000225       115 000235       117 000245       119 000262       126 000272       127 000274
    128 000277       133 000324       134 000326       136 000327       137 000332       139 000334       141 000350
    145 000352       147 000355       148 000361       149 000371       150 000372       151 000401       152 000404
    153 000406       154 000412       156 000413       157 000416       158 000423       159 000432       160 000437
    161 000446       162 000456       163 000476       164 000500       165 000505       167 000525       168 000527
    169 000534       170 000536       171 000540       172 000541       174 000542       176 000557       178 000560
    188 000561       189 000567       191 000601       193 000604       194 000607       195 000632       197 000634
    198 000637       200 000647       202 000651       204 000652       206 000653       207 000674       210 000675
    222 000677       223 000702       224 000710       225 000714       227 000724       228 000726       230 000727
    231 000732       233 000757       234 000762       235 000770       237 001000       238 001002       240 001003


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
