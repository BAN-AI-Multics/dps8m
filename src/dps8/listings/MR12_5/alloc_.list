ASSEMBLY LISTING OF SEGMENT >spec>install>1110>alloc_.alm                                                                                                                                           
ASSEMBLED ON:	11/11/89  0948.0 mst Sat
OPTIONS USED:	-target l68                              list symbols 
ASSEMBLED BY:	ALM Version 8.14 March 1989     
ASSEMBLER CREATED:	06/09/89  1002.3 mst Fri

                                     1  " ***********************************************************
                                     2  " *                                                         *
                                     3  " * Copyright, (C) Honeywell Bull Inc., 1987                *
                                     4  " *                                                         *
                                     5  " * Copyright, (C) Honeywell Information Systems Inc., 1982 *
                                     6  " *                                                         *
                                     7  " * Copyright (c) 1972 by Massachusetts Institute of        *
                                     8  " * Technology and Honeywell Information Systems, Inc.      *
                                     9  " *                                                         *
                                    10  " ***********************************************************
                                    11  
                                    12  "
                                    13  "	alloc_, freen_, area_
                                    14  "
                                    15  "	This module implements the Multics standard area programs.
                                    16  "
                                    17  "	Initial coding October 1975 by S Webber.
                                    18  "	Modified 3 June 1976 by R Barnes for use with pl1_operators_
                                    19  "		and to properly handle area condition.
                                    20  "	Modified 16 August 1976 by R Barnes to fix more bugs and
                                    21  "		implement extendable no_free areas
                                    22  "	Modified September 1976 by M. Weaver to fix redef entrypoint
                                    23  "	Modified 2 November 1976 by M. Weaver to fix zero_on_free bug
                                    24  "	Modified 16 November 1976 by R. Barnes to fix bug in extensible areas
                                    25  "	Modified 30 November 1976 by M. Asherman to fix bug causing excessive zeroing
                                    26  "		on free, which may cause lockup fault
                                    27  "	Modified 6 January 1977 to fix area retry for subr call
                                    28  "	Modified 3/14/77 (Asherman) to prevent loop creating temp segs on large allocations
                                    29  "	Modified 31 May 1977 by RAB to fix 1628
                                    30  "	Modified 12 July 1977 by RAB to fix a bug in which "lcx3 bp|area.next_virgin"
                                    31  "		got fixedoverflow
                                    32  "	Modified 26 July 1977 by RAB to have alloc_ subr entry init sp|tbp
                                    33  "	Modified 9 August 1977 by RAB to not allow allocations of greater than 2**18 words
                                    34  "	Modified 10 August 1977 by RAB to change size of largest allocation by 2 words
                                    35  "	Modified 13 September 1977 by RAB to fix bug in 9 Aug 1977 change which erroneously
                                    36  "		limited allocations to 2**17 words
                                    37  "	Modified 14 September 1977 by RAB to fix another fixedoverflow bug in freen_1
                                    38  "	Modified 771018 by PG to add optimization to area_assign_ and fix bugs in it.
                                    39  "	Modified 6 September 1978 by RAB to have no_free_alloc do a push if entered by
                                    40  "		external call.  This is necessary so that area can be properly
                                    41  "		signalled and get_next_area_ptr_ can be properly called.
                                    42  "	Modified 800109 by PG to run MLR's in area_assign_ uninhibited (MCR 4292).
                                    43  "	Modified September 1981 by J. Bongiovanni for IPS protection
                                    44  "
                                    45  """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                                    46  "
                                    47  "	The following entries are included:
                                    48  "
                                    49  "	p = alloc_ (size, areap);
                                    50  "	p = alloc_$storage_ (size, areap);
                                    51  "	call freen_ (p);
                                    52  "	call area_ (size, areap);
                                    53  "	call area_$no_freeing (size, areap, extend);
                                    54  "	call area_$redef (size, areap);
                                    55  "	call area_assign_ (new_areap, old_areap);
                                    56  "	call area_$extend (areap, flags);
                                    57  "
                                    58  "	The following segdef's are included for the use of
                                    59  "	pl1_operators_:
                                    60  "
                                    61  "	op_alloc_
                                    62  "	op_storage_
                                    63  "	op_freen_
                                    64  "	op_empty_
                                    65  "
                                    66  " " "  " " " " " " " " " " " " " " " " " " " " " "
                                    67  "
                                    68  "	NOTE	NOTE	NOTE	NOTE	NOTE
                                    69  "
                                    70  "
                                    71  "	This routine is used by pl1_operators_ and MUST be bound in with
                                    72  "	pl1_operators_. It makes references to code in pl1_operators_
                                    73  "	without establishing its linkage pointer and vice versa.
                                    74  "
                                    75  "	NOTE	NOTE	NOTE	NOTE	NOTE
                                    76  "
                                    77  "	This routine assumes index register 6 (x6) is not changed by the
                                    78  "	standard "push" operator. This is because we must remember a
                                    79  "	value set before the push and used after the push and there
                                    80  "	is no convenient place to save it.
                                    81  "
                                    82  "	NOTE	NOTE	NOTE	NOTE	NOTE
                                    83  "
                                    84  "	This routine protects itself from asynchronous reinvocations within
                                    85  "	the same process (IPS signals which interrupt it, and which call
                                    86  "	routines while allocate to the area in allocation at the
                                    87  "	interruption).  It does this by maintaining a counter
                                    88  "	(area.allocation_p_clock), which is incremented by 1 in routines
                                    89  "	which could conflict with allocation if called asynchronously (other
                                    90  "	allocations and frees).  After finding a suitable free block, the
                                    91  "	saved value is checked in inhibited code against the current value in
                                    92  "	the area header.  If different, allocation is retried.  If the same,
                                    93  "	the free block is allocated, unthreaded, etc.  in inhibited code.
                                    94  "
                                    95  "	This routine is NOT protected against multiple invocations
                                    96  "	on different CPUs against the same area. If this is possible
                                    97  "	for a given area, it is the responsibility of the caller
                                    98  "	to make allocation a critical section.
                                    99  "
                                   100  "
                                   101  "	Strategy and conventions.
                                   102  "
                                   103  "	The following register assignments are used within this module:
                                   104  "
                                   105  "	x0	used to indicate whether or not called as an
                                   106  "		operator from a PL/I program. If x0 = 0 then it was called
                                   107  "		explicitly as an external entry. If x0 is nonzero, it is
                                   108  "		the operator return offset used by standard pl1_operators_.
                                   109  "	x1	used as a temporary at various times.
                                   110  "	x2	always points to the block being allocated or freed.
                                   111  "	x3	points to the block after the one pointed to by x2. Also used
                                   112  "		as temporary in certain places.
                                   113  "	x4	Used as a pointer to the block to be unthreaded by the
                                   114  "		unthread subroutine. Also used as a temporary.
                                   115  "	x5	Used to point to the second block after the one pointed to by x2.
                                   116  "		Also used as a temporary.
                                   117  "	x6	Used to indicate whether "area" or "storage" should be signalled.
                                   118  "	x7	Used as temporary.
                                   119  "
                                   120  "	ap	points to argument list. Not changed.
                                   121  "	ab	used to hold the return location for the freen_1 subroutine.
                                   122  "	bp	points at base of area header during execution. At the interface
                                   123  "		level, bp points to the block being freed and is returned as
                                   124  "		a pointer to the allocated block (operators interface only).
                                   125  "	bb	used to hold the return location for the unthread
                                   126  "		subroutine.
                                   127  "	lb	points at words containing ptr to block being freed
                                   128  "
                                   129  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   130  "
                                   131  "
                                   132  "	Format of a block header:
                                   133  "
                                   134  "
                                   135  "	|				|
                                   136  "	|				|
                                   137  "	_|________________________________________|  /_______  pointed to by x2
                                   138  "	|		|		|  \
                                   139  "	|  PREV SIZE	|  CURRENT SIZE	|
                                   140  "	_|____________________|____________________|
                                   141  "	|	| |	|		|
                                   142  "	|   MBZ	|B| Q_NO	|   HEADER PTR	|
                                   143  "	_|__________|__|________|____________________|  /_______  allocated storage starts here
                                   144  "	|		|		|  \
                                   145  "	|  FORWARD POINTER	| BACKWARD POINTER	|
                                   146  "	_|____________________|____________________|
                                   147  "	|				|
                                   148  "	|				|
                                   149  "
                                   150  "
                                   151  "	The FORWARD and BACKWARD pointers are only filled in and meaningful
                                   152  "	if the block is free. If the block is not free, the storage for these
                                   153  "	pointers is the first word available for use by the caller.
                                   154  "	The flag "B" is the busy bit for the _p_r_e_v_i_o_u_s block.
                                   155  "
                                   156  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   157  "
                                   158  "	The following template is used to define area offsets as well as for intialization of a new area.
                                   159  
                                   160  	include	area_structures
                                   1-1  
                                   1-2  
                                   1-3       "BEGIN INCLUDE FILE area_structures.incl.alm
                                   1-4  
                                   1-5  	"Created 10/19/77  1204.6 edt Wed by convert_include_file,
                                   1-6  	"   Version of 03/21/77  1355.7 edt Mon.
                                   1-7  
                                   1-8  	"Made from >udd>m>Green>pl1_bugs>area_structures.incl.pl1,
                                   1-9  	"   modified 10/19/77  1204.6 edt Wed
                                  1-10  
                                  1-11  
                        000001    1-12  	equ	area_version_1,1		"MANIFEST
                                  1-13  
                                  1-14  "
                                  1-15  "	Structure area
                                  1-16  "
                        000030    1-17  	equ	area_size,24
                                  1-18  
                        000000    1-19  	equ	area.version,0
                                  1-20  
                        000001    1-21  	equ	area.last_usable,1		"UPPER
                                  1-22  
                        000002    1-23  	equ	area.next_virgin,2		"UPPER
                                  1-24  
                        000003    1-25  	equ	area.flags,3		"LEVEL 2
                                  1-26  
                        400000    1-27  	bool	area.extend,400000		"DU
                        200000    1-28  	bool	area.zero_on_alloc,200000	"DU
                        100000    1-29  	bool	area.zero_on_free,100000	"DU
                        040000    1-30  	bool	area.dont_free,040000	"DU
                        020000    1-31  	bool	area.defined_by_call,020000	"DU
                        010000    1-32  	bool	area.system,010000		"DU
                        000000    1-33  	equ	area.mbz_shift,0
                                  1-34  
                        000004    1-35  	equ	area.allocation_method,4
                                  1-36  
                        000005    1-37  	equ	area.last_size,5		"UPPER
                                  1-38  
                        000006    1-39  	equ	area.last_block,6		"UPPER
                                  1-40  
                        000007    1-41  	equ	area.freep,7		"LEVEL 2
                                  1-42  
                        000007    1-43  	equ	area.relp,7		"UPPER
                        000007    1-44  	equ	area.max_block_size,7	"LOWER
                                  1-45  
                        000025    1-46  	equ	area.allocation_p_clock,21
                                  1-47  
                        000026    1-48  	equ	area.extend_info,22		"UPPER
                        000026    1-49  	equ	area.recovery_info,22	"LOWER
                                  1-50  
                        000027    1-51  	equ	area.n_allocated,23		"UPPER
                        000027    1-52  	equ	area.n_free,23		"LOWER
                                  1-53  
                        000000    1-54  	equ	STANDARD_ALLOCATION_METHOD,0	"MANIFEST
                        000001    1-55  	equ	NO_FREEING_ALLOCATION_METHOD,1 "MANIFEST
                                  1-56  
                                  1-57  "
                                  1-58  "	Structure extend_block
                                  1-59  "
                        000014    1-60  	equ	extend_block_size,12
                                  1-61  
                        000000    1-62  	equ	extend_block.first_area,0
                        000001    1-63  	equ	extend_block.next_area,1
                        000002    1-64  	equ	extend_block.sequence_no,2
                        000003    1-65  	equ	extend_block.name,3		"DOUBLE
                                  1-66  
                        000002    1-67  	equ	alloc_blkhdrsz,2		"MANIFEST
                                  1-68  
                                  1-69  "
                                  1-70  "	Structure no_free_area
                                  1-71  "
                        000012    1-72  	equ	no_free_area_size,10
                                  1-73  
                        000010    1-74  	equ	no_free_area.current_component,8
                                  1-75  
                                  1-76  "
                                  1-77  "	Structure block
                                  1-78  "
                        000003    1-79  	equ	block_size,3
                                  1-80  
                        000000    1-81  	equ	block.prev_size,0		"UPPER
                        000000    1-82  	equ	block.cur_size,0		"LOWER
                                  1-83  
                        000001    1-84  	equ	block.buddy_pad_word,1
                        000034    1-85  	equ	block.buddy_pad_shift,28
                        000377    1-86  	bool	block.buddy_pad_mask,000377
                        000001    1-87  	equ	block.prev_busy_word,1
                        001000    1-88  	bool	block.prev_busy,001000	"DU
                        000001    1-89  	equ	block.marked_word,1
                        000400    1-90  	bool	block.marked,000400		"DU
                        000001    1-91  	equ	block.q_no_word,1
                        000022    1-92  	equ	block.q_no_shift,18
                        000377    1-93  	bool	block.q_no_mask,000377
                        000001    1-94  	equ	block.header,1		"LOWER
                                  1-95  
                        000002    1-96  	equ	block.fp,2		"UPPER
                        000002    1-97  	equ	block.bp,2		"LOWER
                                  1-98  
                        000010    1-99  	equ	min_block_size,8		"MANIFEST
                                 1-100  
                                 1-101       "END INCLUDE FILE area_structures.incl.alm
                                   161  	include	stack_frame
                                   2-1  "
                                   2-2  "	BEGIN INCLUDE FILE ... stack_frame.incl.alm   6/72 RBS
                                   2-3  "
                                   2-4  " Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr
                                   2-5  " Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager_bit & main_proc_bit
                                   2-6  " Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr
                                   2-7  "
                        000020     2-8  	equ	stack_frame.prev_sp,16
                        000020     2-9  	equ	stack_frame.condition_word,16
                        000022    2-10  	equ	stack_frame.next_sp,18
                        000022    2-11  	equ	stack_frame.signaller_word,18
                        000024    2-12  	equ	stack_frame.return_ptr,20
                        000026    2-13  	equ	stack_frame.entry_ptr,22
                        000030    2-14  	equ	stack_frame.operator_ptr,24
                        000030    2-15  	equ	stack_frame.lp_ptr,24
                        000032    2-16  	equ	stack_frame.arg_ptr,26
                        000034    2-17  	equ	stack_frame.static_ptr,28
                        000035    2-18  	equ	stack_frame.support_ptr,29	" only used by fortran I/O
                        000036    2-19  	equ	stack_frame.on_unit_rel_ptrs,30
                        000037    2-20  	equ	stack_frame.operator_ret_ptr,31
                        000037    2-21  	equ	stack_frame.translator_id,31
                        000040    2-22  	equ	stack_frame.regs,32
                        000060    2-23  	equ	stack_frame.min_length,48
                        000020    2-24  	equ	stack_frame.flag_word,16
                        020000    2-25  	bool	stack_frame.main_proc_bit,020000	(DL)
                        010000    2-26  	bool	stack_frame.run_unit_manager,010000	(DL)
                        004000    2-27  	bool	stack_frame.signal_bit,004000		(DL)
                        002000    2-28  	bool	stack_frame.crawl_out_bit,002000	(DL)
                        001000    2-29  	bool	stack_frame.signaller_bit,001000	(DL)
                        000400    2-30  	bool	stack_frame.link_trap_bit,000400	(DL)
                        000200    2-31  	bool	stack_frame.support_bit,000200	(DL)
                        000100    2-32  	bool	stack_frame.condition_bit,000100	(DL)
                                  2-33  
                                  2-34  "
                                  2-35  "	END INCLUDE FILE  ... stack_frame.incl.alm
                                  2-36  "
                                   162  	include	stack_header
                                   3-1  "	BEGIN INCLUDE FILE ... stack_header.incl.alm  3/72  Bill Silver
                                   3-2  "
                                   3-3  "	modified 7/76 by M. Weaver for *system links and more system use of areas
                                   3-4  "	modified 3/77 by M. Weaver  to add rnt_ptr
                                   3-5  "	modified 7/77 by S. Webber to add run_unit_depth and assign_linkage_ptr
                                   3-6  "	modified 6/83 by J. Ives to add trace_frames and in_trace.
                                   3-7  
                                   3-8  " HISTORY COMMENTS:
                                   3-9  "  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
                                  3-10  "     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
                                  3-11  "     added the heap_header_ptr definition
                                  3-12  "  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
                                  3-13  "     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
                                  3-14  "     Modified to support control point management.  These changes were
                                  3-15  "     actually made in February 1985 by G. Palter.
                                  3-16  "  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
                                  3-17  "     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
                                  3-18  "     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
                                  3-19  "     bit pad after cur_lot_size for the cpm_enabled. This was done to save
                                  3-20  "     some space int the stack header and change the cpd_ptr unal to
                                  3-21  "     cpm_data_ptr (ITS pair).
                                  3-22  "                                                      END HISTORY COMMENTS
                                  3-23  
                        000004    3-24  	equ	stack_header.cpm_data_ptr,4		ptr to control point for this stack
                        000006    3-25  	equ	stack_header.combined_stat_ptr,6	ptr to separate static area
                                  3-26  
                        000010    3-27  	equ	stack_header.clr_ptr,8		ptr to area containing linkage sections
                        000012    3-28  	equ	stack_header.max_lot_size,10		number of words allowed in lot (DU)
                        000012    3-29  	equ	stack_header.main_proc_invoked,10	nonzero if main proc was invoked in run unit (DL)
                        000012    3-30  	equ	stack_header.run_unit_depth,10	number of active run units stacked (DL)
                        000013    3-31  	equ	stack_header.cur_lot_size,11		DU number of words (entries) in lot
                        000013    3-32            equ	stack_header.cpm_enabled,11		DL  non-zero if control point management is enabled
                        000014    3-33  	equ	stack_header.system_free_ptr,12	ptr to system storage area
                        000016    3-34  	equ	stack_header.user_free_ptr,14		ptr to user storage area
                                  3-35  
                        000020    3-36  	equ	stack_header.parent_ptr,16		ptr to parent stack or null
                        000022    3-37  	equ	stack_header.stack_begin_ptr,18	ptr to first stack frame
                        000024    3-38  	equ	stack_header.stack_end_ptr,20		ptr to next useable stack frame
                        000026    3-39  	equ	stack_header.lot_ptr,22		ptr to the lot for the current ring
                                  3-40  
                        000030    3-41  	equ	stack_header.signal_ptr,24		ptr to signal proc for current ring
                        000032    3-42  	equ	stack_header.bar_mode_sp,26		value of sp before entering bar mode
                        000034    3-43  	equ	stack_header.pl1_operators_ptr,28	ptr: pl1_operators_$operator_table
                        000036    3-44  	equ	stack_header.call_op_ptr,30		ptr to standard call operator
                                  3-45  
                        000040    3-46  	equ	stack_header.push_op_ptr,32		ptr to standard push operator
                        000042    3-47  	equ	stack_header.return_op_ptr,34		ptr to standard return operator
                        000044    3-48  	equ	stack_header.ret_no_pop_op_ptr,36	ptr: stand. return/ no pop operator
                        000046    3-49  	equ	stack_header.entry_op_ptr,38		ptr to standard entry operator
                                  3-50  
                        000050    3-51  	equ	stack_header.trans_op_tv_ptr,40	ptr to table of translator operator ptrs
                        000052    3-52  	equ	stack_header.isot_ptr,42		pointer to ISOT
                        000054    3-53  	equ	stack_header.sct_ptr,44		pointer to System Condition Table
                        000056    3-54  	equ	stack_header.unwinder_ptr,46		pointer to unwinder for current ring
                                  3-55  
                        000060    3-56  	equ	stack_header.sys_link_info_ptr,48	ptr to *system link name table
                        000062    3-57  	equ	stack_header.rnt_ptr,50		ptr to reference name table
                        000064    3-58  	equ	stack_header.ect_ptr,52		ptr to event channel table
                        000066    3-59  	equ	stack_header.assign_linkage_ptr,54	ptr to area for hcs_$assign_linkage calls
                        000070    3-60  	equ	stack_header.heap_header_ptr,56	ptr to heap header.
                        000072    3-61  	equ	stack_header.trace_frames,58		stack of trace_catch_ frames
                        000073    3-62  	equ	stach_header.trace_top_ptr,59		trace pointer
                        000074    3-63  	equ	stack_header.in_trace,60		trace antirecurse bit
                        000100    3-64  	equ	stack_header_end,64			length of stack header
                                  3-65  
                                  3-66  
                                  3-67  
                                  3-68  
                        000000    3-69  	equ	trace_frames.count,0		number of trace frames on stack
                        000001    3-70  	equ	trace_frames.top_ptr,1		packed pointer to top one
                                  3-71  
                                  3-72  "	The  following constant is an offset within the  pl1  operators table.
                                  3-73  "	It  references a  transfer vector table.
                                  3-74  
                        000551    3-75  	bool	tv_offset,551
                                  3-76  
                                  3-77  
                                  3-78  "	The  following constants are offsets within this transfer vector table.
                                  3-79  
                        001170    3-80  	equ	call_offset,tv_offset+271
                        001171    3-81  	equ	push_offset,tv_offset+272
                        001172    3-82  	equ	return_offset,tv_offset+273
                        001173    3-83  	equ	return_no_pop_offset,tv_offset+274
                        001174    3-84  	equ	entry_offset,tv_offset+275
                                  3-85  
                                  3-86  
                                  3-87  " 	END INCLUDE FILE stack_header.incl.alm
                                   163  
                                   164  "
                                   165  "	The following must be the same as used by pl1_operators_.
                                   166  "
                        000046     167  	equ	tbp,38
                        000002     168  	equ	buddy_area.size,2
                        000003     169  	equ	buddy_area.inited,3
                                   170  
                        000505     171  	entry	alloc_,storage_,freen_,area_,area_assign_,no_freeing,extend,redef
                        000433     172  	entry	old_alloc_,old_freen_,old_area_
                        000503     173  	segdef	op_alloc_,op_storage_,op_freen_,op_empty_
                                   174  
                                   175  "
                                   176  "	The following EQU's define stack variables used by this program. Since
                                   177  "	the program is called as an operator as well as externally,
                                   178  "	stack variables not used by pl1_operators_ at the time of the
                                   179  "	invocation must be used. The regions chosen are the words from 8 to 15,
                                   180  "	and 56 to 63.
                                   181  "
                                   182  "
                        000010     183  	equ	lsize,8
                        000011     184  	equ	rsize,9
                        000012     185  	equ	blocksize,10
                        000013     186  	equ	temp,11
                        000014     187  	equ	save_x2,12	UPPER
                        000014     188  	equ	save_x6,12	LOWER
                        000014     189  	equ	save_x0,12	LOWER
                        000015     190  	equ	max_size,13
                        000016     191  	equ	save_bp,14
                        000017     192  	equ	free_count,15
                        000054     193  	equ	dtemp1,44		used only for buddy_alloc_op
                        000056     194  	equ	dtemp2,46		..
                        000070     195  	equ	arglist,56
                        000070     196  	equ	saved_p_clock,56	shared with arglist
                        000076     197  	equ	ret_bp,62
                        000010     198  	equ	min_block_size,8	NOTE. this must be at least 8 because
                                   199  				"area.freep has lbound of 4.
                        000001     200  	equ	max_version,1	maximum expected version number
                        000001     201  	equ	max_method,1	maximum expected allocation method
                                   202  
                                   203  
                                   204  "
                                   205  "
                                   206  "	alloc_
                                   207  "	storage_
                                   208  "	op_alloc_
                                   209  "	op_storage_
                                   210  "
                                   211  "	These entries allocate a block of the specified size in the specified
                                   212  "	area. If there is not enough room in the area "area" is signalled
                                   213  "	unless the area is extensible in which case a new component is found
                                   214  "	and the block allocated therein.
                                   215  "
                                   216  "	The storage_ entries signal "storage" instead of "area" but are
                                   217  "	otherwise identical.
                                   218  "
                                   219  "	The alloc_ (and storage_) entry is called as follows:
                                   220  "
                                   221  "	blockp = alloc_ (size, areap)
                                   222  "
                                   223  "	The operator op_alloc_ (and op_storage_) is called as follows:
                                   224  "
                                   225  "	retry:
                                   226  "		ldq	size
                                   227  "		eppbp	area_header
                                   228  "		tsx0	pr0|allocate_op
                                   229  "		tra	retry
                                   230  "
                                   231  "	a pointer to the allocated block is returned in pr2.
                                   232  "
                                   233  "          ________________________________________________
                                   234  "
                                   235  "	The size of the block allocated is increased by 2 to account
                                   236  "	for the block header. A fill word may also be allocated in order
                                   237  "	to insure that all blocks begin on even word boundaries.
                                   238  "
                                   239  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   240  
    000000                         241  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000000                         242  op_storage_:
    000000  aa   000001 6262 00    243  	eax6	1		indicates we signal "storage" if need arises
    000001  0a   000003 7102 00    244  	tra	*+2
    000002                         245  op_alloc_:
    000002  aa   000000 6262 00    246  	eax6	0		indicates we signal "area" if need arises
    000003  aa   000001 6202 10    247  	eax0	1,0		we want to return one word later
    000004  aa  2 00000 2353 00    248  	lda	bp|area.version	check for buddy system areas
    000005  0a   000071 6002 00    249  	tze	buddy_alloc_op	it is buddy system, perform external call
    000006  0a   001120 6042 00    250  	tmi	signal_area_3	"bad_area_format"
    000007  aa   000001 1152 07    251  	cmpa	max_version,dl	check for expected version
    000010  0a   001120 6056 00    252  	tpnz	signal_area_3	"bad_area_format"
    000011  aa  2 00004 2353 00    253  	lda	bp|area.allocation_method
    000012  0a   001120 6042 00    254  	tmi	signal_area_3	"bad_area_format"
    000013  0a   000133 6002 00    255  	tze	standard_alloc_op	standard allocation method wanted
    000014  aa   000001 1152 07    256  	cmpa	max_method,dl	check for expected allocation method
    000015  0a   001120 6056 00    257  	tpnz	signal_area_3	"bad_area_format"
    000016  0a   000050 7102 00    258  	tra	no_free_alloc_op
                                   259  
    000017  aa   000001 6262 00    260  storage_:	eax6	1		indicates we signal "storage" if need arises
    000020  0a   000022 7102 00    261  	tra	*+2
    000021                         262  old_alloc_:
    000021  aa   000000 6262 00    263  alloc_:	eax6	0		indicates we signal "area" if need arises
    000022  aa  0 00004 3523 20    264  	eppbp	ap|4,*		get pointer to area header
    000023  aa  2 00000 3523 20    265  	eppbp	bp|0,*		..
    000024  aa  2 00000 2353 00    266  	lda	bp|area.version	check for old version
    000025  0a   000065 6002 00    267  	tze	buddy_alloc	old version, transfer directly
    000026  0a   000622 6042 00    268  	tmi	signal_area_p3	bad area format, signal "bad_area_format"
    000027  aa   000001 1152 07    269  	cmpa	max_version,dl	see if expected version number
    000030  0a   000622 6056 00    270  	tpnz	signal_area_p3	not expected, signal "bad_area_format"
    000031  aa  2 00004 2353 00    271  	lda	bp|area.allocation_method dispatch on allocation method
    000032  0a   000622 6042 00    272  	tmi	signal_area_p3	"bad_area_format"
    000033  0a   000117 6002 00    273  	tze	standard_alloc	standard allocation method needed
    000034  aa   000001 1152 07    274  	cmpa	max_method,dl	check for expected allocation method
    000035  0a   000622 6056 00    275  	tpnz	signal_area_p3	"bad_area_format"
                                   276  
    000036                         277  no_free_alloc:
    000036  aa   000120 6272 00    278  	push	80		get stack frame
    000037  aa  7 00040 2723 20
    000040  aa   000200 2352 07    279  	lda	stack_frame.support_bit,dl
    000041  aa  6 00020 2553 00    280  	orsa	sp|stack_frame.flag_word
    000042  0a   000042 3526 00    281  	epbpbp	*		give sp|tbp a non-faulting value
    000043  aa  6 00046 2523 00    282  	spribp	sp|tbp		..
    000044  aa  0 00004 3523 20    283  	eppbp	ap|4,*		get area header pointer
    000045  aa  2 00000 3523 20    284  	eppbp	bp|0,*		..
    000046                         285  retry_no_free_alloc_after_area:
    000046  aa   000000 6202 00    286  	eax0	0		indicates we are not an operator ref
    000047  aa  0 00002 2363 20    287  	ldq	ap|2,*		fetch size of block to allocate
                                   288  
    000050                         289  no_free_alloc_op:
    000050  aa   000001 6212 06    290  	eax1	1,ql		force even word alignment
    000051  aa   777776 3612 03    291  	anx1	-2,du		..
    000052  aa  2 00002 2353 00    292  	lda	bp|area.next_virgin	get pointer to new block
    000053  aa  2 00002 0213 00    293  	adlx1	bp|area.next_virgin	calculate what will be next next_virgin
    000054  0a   000372 6032 00    294  	trc	no_room_no_free
    000055  aa  2 00001 1013 00    295  	cmpx1	bp|area.last_usable	see if overflows
    000056  0a   000372 6032 00    296  	trc	no_room_no_free	yes, overflows. Go handle it.
    000057  aa  2 00002 7413 00    297  	stx1	bp|area.next_virgin update next_virgin pointer
    000060  aa  2 00010 3523 61    298  	eppbp	bp|no_free_area.current_component,*au	generate return pointer
    000061  aa   000000 1002 03    299  	cmpx0	0,du		see whether called as operator
    000062  aa  6 00046 6013 70    300  	tnz	sp|tbp,*0		was operator, just return
    000063  aa  0 00006 2523 20    301  	spribp	ap|6,*		external call. return blockp
    000064  aa  7 00042 7103 20    302  	return
                                   303  
    000065                         304  buddy_alloc:
    000065  0a   000067 7162 16    305  	xec	get_ptr,6		get pointer to entry to forward call to
    000066  aa  2 00000 7133 00    306  	callsp	bp|0		transfer forward...
                                   307  
    000067  4a  4 00010 3523 20    308  get_ptr:	eppbp	<buddy_alloc_>|[buddy_alloc_]
    000070  4a  4 00012 3523 20    309  	eppbp	<buddy_alloc_>|[buddy_storage_]
                                   310  
    000071                         311  buddy_alloc_op:
                                   312  "
                                   313  "	We must make an external call to buddy_alloc_$whatever.
                                   314  "
    000071  aa  6 00054 2523 00    315  	spribp	sp|dtemp1		save pointer to area
    000072  aa  6 00010 7533 00    316  	sreg	sp|8		save registers
    000073  aa  6 00000 3733 00    317  	epbpsb	sp|0		get pointer to stack base so we can get lp
    000074  0a   000074 2132 00    318  	epaq	*		get segno of this program
    000075  aa  7 00026 7643 61    319  	lprplp	sb|stack_header.lot_ptr,*au get lp
    000076  aa  6 00015 3523 00    320  	eppbp	sp|13		get pointer to block size (saved in q with regs)
    000077  aa  6 00072 2523 00    321  	spribp	sp|arglist+2	save in argument list
    000100  aa  6 00054 3523 00    322  	eppbp	sp|dtemp1		get pointer to area pointer
    000101  aa  6 00074 2523 00    323  	spribp	sp|arglist+4	save in argument list
    000102  aa  6 00056 3523 00    324  	eppbp	sp|dtemp2		we want  buddy_alloc_ to store blockp here
    000103  aa  6 00076 2523 00    325  	spribp	sp|arglist+6
    000104  aa   014000 4312 07    326  	fld	3*2048,dl		generate arg list header
    000105  aa  6 00070 7573 00    327  	staq	sp|arglist	..
    000106  0a   000067 7162 16    328  	xec	get_ptr,6		get pointer to routine to call
    000107  aa  6 00070 3503 00    329  	eppap	sp|arglist	get pointer to argument list
    000110  aa  6 00024 3573 00    330  	stcd	sp|stack_frame.return_ptr	standard call...
    000111  aa  2 00000 7133 00    331  	callsp	bp|0		..
    000112  aa  6 00010 0733 00    332  	lreg	sp|8		restore registers
    000113  aa  6 00046 3523 20    333  	eppbp	sp|tbp,*		must restore return pointer for pl1 frame
    000114  aa  6 00024 2523 00    334  	spribp	sp|stack_frame.return_ptr	..
    000115  aa  6 00056 3523 20    335  	eppbp	sp|dtemp2,*	get blockp
    000116  aa  6 00046 7103 70    336  	tra	sp|tbp,*0		return to object program
                                   337  " 
    000117                         338  standard_alloc:
    000117  aa   000120 6272 00    339  	push	80		get stack frame large enough
    000120  aa  7 00040 2723 20
    000121  aa   000200 2352 07    340  	lda	stack_frame.support_bit,dl
    000122  aa  6 00020 2553 00    341  	orsa	sp|stack_frame.flag_word
    000123  0a   000123 3526 00    342  	epbpbp	*		give sp|tbp a non-faulting value
    000124  aa  6 00046 2523 00    343  	spribp	sp|tbp		..
    000125  aa  0 00004 3523 20    344  	eppbp	ap|4,*		get area header pointer
    000126  aa  2 00000 3523 20    345  	eppbp	bp|0,*		..
    000127                         346  retry_alloc_after_area:
    000127  aa  0 00002 2363 20    347  	ldq	ap|2,*		get size of block to allocate
    000130  0a   000132 6056 00    348  	tpnz	*+2		positive and nonzero is OK
    000131  aa   000010 2362 07    349  	ldq	min_block_size,dl	if negative or zero use min size
    000132  aa   000000 6202 00    350  	eax0	0		indicates not operator ref
    000133                         351  standard_alloc_op:
    000133  aa   000003 0362 07    352  	adlq	alloc_blkhdrsz+1,dl		1 for rounding
    000134  aa   777777 3162 03    353  	canq	=o777777,du	is the requested block too large to be ever allocated?
    000135  0a   001125 6012 00    354  	tnz	signal_area	yes, then give up.
    000136  aa   777776 3762 07    355  	anq	-2,dl		complete the rounding function
    000137  aa   000022 7362 00    356  	qls	18		left justify for compares
    000140  aa   000010 1162 03    357  	cmpq	min_block_size,du	see if requested block is too small
    000141  0a   000143 6032 00    358  	trc	*+2		large enough, use input value
    000142  aa   000010 2362 03    359  	ldq	min_block_size,du	too small, use minimum value from header
    000143  aa  6 00010 7563 00    360  	stq	sp|lsize		save in left justified form
    000144  aa   000022 7722 00    361  	qrl	18		now right justify
    000145  aa  6 00011 7563 00    362  	stq	sp|rsize		and save in right justified form
                                   363  
                                   364  "	Increment and save a counter identifying this allocation
                                   365  "	instance (uniquely over small intervals of time)
                                   366  
    000146                         367  retry_alloc:
    000146  aa  2 00025 2353 00    368  	lda	bp|area.allocation_p_clock	allocation instance
    000147  aa   000001 0352 07    369  	adla	1,dl		this instance (overflows to 0)
    000150  aa  2 00025 7553 00    370  	sta	bp|area.allocation_p_clock
    000151  aa  6 00070 7553 00    371  	sta	sp|saved_p_clock
                                   372  
                                   373  "
                                   374  "	Now search for a large enough block on the free list.
                                   375  "	First find the appropriate stratum number and save it.
                                   376  "
    000152                         377  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
                                   378  
    000152  aa  6 00011 4311 00    379  	fld	sp|rsize		get desired size
    000153  aa   064000 4110 03    380  	lde	=26b25,du		convert to correct floating pt. value
    000154  aa   400000 4750 03    381  	fad	=0.0e0,du		normalize to get correct exponent
    000155  aa  6 00013 4561 00    382  	ste	sp|temp		get log2 (size)
    000156  aa  6 00013 2361 00    383  	ldq	sp|temp		..
    000157  aa   000012 7720 00    384  	qrl	28-18		leave in q-upper
    000160  aa   000020 1160 03    385  	cmpq	16,du		clip value
    000161  0a   000163 6044 00    386  	tmoz	stratum_loop	if too high
    000162  aa   000020 2360 03    387  	ldq	16,du
    000163                         388  stratum_loop:
    000163  aa  2 00004 2221 02    389  	ldx2	bp|area.freep-3,qu	see if anything in free list
    000164  0a   000215 6000 00    390  	tze	next_stratum	nothing on this free list, try next
    000165  aa  2 00004 7231 02    391  	lxl3	bp|area.freep-3,qu	get max size for this stratum
    000166  0a   000171 6000 00    392  	tze	try		if the field is zero, we don't know max
    000167  aa  6 00010 1031 00    393  	cmpx3	sp|lsize		compare against size we want
    000170  0a   000215 6020 00    394  	tnc	next_stratum	not a large enough block, goto next stratum
    000171  aa  6 00013 7421 00    395  try:	stx2	sp|temp		save pointer to head of free list
    000172  aa   116100 2210 03    396  	ldx1	40000,du		loop check...only allow 40000 steps
    000173  aa  6 00015 4501 00    397  	stz	sp|max_size	initialize cell used in calculating max size
                                   398  "
                                   399  "	Before using the fields in any block, we will check for an IPS
                                   400  "	race (asynchronous invocation).  The reason for this is that
                                   401  "	an asynchronous invocation could have invalidated the block
                                   402  "	we are about to examine.  If this happen, we will retry from
                                   403  "	the beginning.
                                   404  
    000174  aa  6 00070 2351 00    405  	lda	sp|saved_p_clock	to check for IPS race
    000175                         406  test_size:
    000175  aa  2 00025 1151 00    407  	cmpa	bp|area.allocation_p_clock	check for IPS race
    000176  0a   000146 6010 00    408  	tnz	retry_alloc	one has occurred--retry
    000177  aa  2 00000 7231 12    409  	lxl3	bp|block.cur_size,2	get size of this free block from header
    000200  aa  6 00010 1031 00    410  	cmpx3	sp|lsize		see if large enough
    000201  0a   000221 6030 00    411  	trc	large_enough	yes...
    000202  aa  6 00015 1031 00    412  	cmpx3	sp|max_size	update max size value
    000203  0a   000205 6020 00    413  	tnc	*+2		..
    000204  aa  6 00015 7431 00    414  	stx3	sp|max_size	..
    000205  aa  2 00002 2221 12    415  	ldx2	bp|block.fp,2	chain to next free block
    000206  aa  6 00013 1021 00    416  	cmpx2	sp|temp		see if we're back to the beginning
    000207  0a   000213 6000 00    417  	tze	next_stratum_1	yes, try the next stratum
    000210  aa   777777 6210 11    418  	eax1	-1,1		count steps
    000211  0a   000175 6050 00    419  	tpl	test_size		loop back if not too many steps
    000212  0a   001120 7100 00    420  	tra	signal_area_3	signal "bad_area_format"
                                   421  
    000213                         422  next_stratum_1:
    000213  aa  6 00015 2211 00    423  	ldx1	sp|max_size	reset max size for this stratum list
    000214  aa  2 00004 4411 02    424  	sxl1	bp|area.freep-3,qu	..
    000215                         425  next_stratum:
    000215  aa   000001 6360 02    426  	eaq	1,qu		skip to next stratum
    000216  aa   000021 1160 03    427  	cmpq	17,du		see if we've done them all
    000217  0a   000163 6020 00    428  	tnc	stratum_loop	no, keep searching
    000220  0a   000266 7100 00    429  	tra	use_virgin	all used up, take from virgin territory
                                   430  
    000221                         431  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000221                         432  large_enough:
                                   433  
                                   434  "	Check for race with asynchronous invocation (IPS signal)
                                   435  "	Race exists if saved allocation instance doesn't match
                                   436  "	the one in the header.
                                   437  
    000221  aa  6 00070 2353 00    438  	lda	sp|saved_p_clock	saved allocation instance
    000222  aa  2 00025 1153 00    439  	cmpa	bp|area.allocation_p_clock	lose race?
    000223  0a   000146 6012 00    440  	tnz	retry_alloc		yes--retry allocation
                                   441  
    000224  aa   000001 3352 07    442  	lca	1,dl		update free count in header
    000225  aa  2 00027 0553 00    443  	asa	bp|area.n_free	..
    000226  aa   000000 6242 12    444  	eax4	0,2		needed by unthread routine
    000227  0a   001054 2732 00    445  	tspbb	unthread		remove block from free list
    000230  0a   000232 7102 00    446  	tra	*+2		don't save free pointer if nothing in list
    000231  aa  2 00004 7473 02    447  	stx7	bp|area.freep-3,qu	implement roving pointer
    000232                         448  free_merge:
    000232  aa  6 00013 4503 00    449  	stz	sp|temp		save size of the block
    000233  aa  6 00013 7433 00    450  	stx3	sp|temp		..
    000234  aa  6 00013 6243 72    451  	eax4	sp|temp,*2	x4 -> next block after free block
    000235  aa  6 00010 1233 00    452  	sblx3	sp|lsize		get left over size
    000236  aa   000010 1032 03    453  	cmpx3	min_block_size,du	see if left over will be too small
    000237  0a   000263 6046 00    454  	tmoz	correct_size	the block is the right size, take it
    000240  aa  2 00000 7433 14    455  	stx3	bp|block.prev_size,4 save size of left over free block
                                   456  "
                                   457  "	Make a header for the left over block. Also update current header.
                                   458  "
    000241  aa  6 00010 2253 00    459  	ldx5	sp|lsize		get size of current block
    000242  aa  2 00000 4453 12    460  	sxl5	bp|block.cur_size,2	save in current header
    000243  aa  6 00010 6253 72    461  	eax5	sp|lsize,*2	get pointer to left over region
    000244  aa  2 00001 2353 12    462  	lda	bp|block.header,2	calculate header ptr for new block
    000245  aa   777777 3752 07    463  	ana	-1,dl		..
    000246  aa  6 00011 1353 00    464  	sbla	sp|rsize		leaves size of left over region
    000247  aa   001000 2752 03    465  	ora	block.prev_busy,du	turn on busy bit for preceding block
    000250  aa  2 00001 7553 15    466  	sta	bp|block.header,5	assumes busy bit in same word with header ptr
    000251  aa  2 00000 4433 15    467  	sxl3	bp|block.cur_size,5	save size of left over block
    000252  aa  6 00010 2233 00    468  	ldx3	sp|lsize		get size of newly allocated block
    000253  aa  2 00000 7433 15    469  	stx3	bp|block.prev_size,5 save in new header
                                   470  "
                                   471  "	Now make a call to the freen_1 subroutine to free up the left over
                                   472  "	block. We must save bp and x2 which are used by that routine.
                                   473  "
    000254  aa  6 00016 5423 00    474  	sprpbp	sp|save_bp	save what gets wiped by freen_1
    000255  aa  6 00014 7423 00    475  	stx2	sp|save_x2
    000256  aa   000000 6222 15    476  	eax2	0,5		make x2 -> block to be freed
    000257  0a   000705 2712 00    477  	tspab	freen_1		free it up
    000260  aa  6 00016 7623 00    478  	lprpbp	sp|save_bp
    000261  aa  6 00014 2223 00    479  	ldx2	sp|save_x2
    000262  0a   000313 7102 00    480  	tra	return_ptr
                                   481  
    000263                         482  correct_size:
    000263  aa   001000 2352 03    483  	lda	block.prev_busy,du	turn on busy bit for this block
    000264  aa  2 00001 2553 14    484  	orsa	bp|block.prev_busy_word,4	..
    000265  0a   000313 7102 00    485  	tra	return_ptr
                                   486  
    000266                         487  use_virgin:
    000266  aa  2 00001 2353 00    488  	lda	bp|area.last_usable	get size of virgin storage remaining
    000267  aa  2 00002 1353 00    489  	sbla	bp|area.next_virgin	..
    000270  aa  6 00010 1153 00    490  	cmpa	sp|lsize		see if requested size is too large
    000271  0a   000335 6022 00    491  	tnc	no_room		yes, overflow condition
    000272  aa  2 00002 2223 00    492  	ldx2	bp|area.next_virgin	get index to last word used
    000273  aa  2 00005 2233 00    493  	ldx3	bp|area.last_size	generate header for new block
    000274  aa  2 00000 7433 12    494  	stx3	bp|block.prev_size,2 ..
    000275  aa  2 00006 0233 00    495  	adlx3	bp|area.last_block	update pointer to last allocated block
    000276  aa  2 00006 7433 00    496  	stx3	bp|area.last_block	..
    000277  aa  2 00002 2233 00    497  	ldx3	bp|area.next_virgin	(we cannot complement 400000(8) in an xreg)
    000300  aa   400000 1032 03    498  	cmpx3	=o400000,du
    000301  aa   000002 6002 04    499  	tze	2,ic
    000302  aa  2 00002 3233 00    500  	lcx3	bp|area.next_virgin	 ..
    000303  aa  2 00001 4433 12    501  	sxl3	bp|block.header,2	 ..
    000304  aa   001000 2232 03    502  	ldx3	block.prev_busy,du	turn busy bit on for previous block
    000305  aa  2 00001 7433 12    503  	stx3	bp|block.prev_busy_word,2 ..
    000306  aa  6 00011 7233 00    504  	lxl3	sp|rsize		now update area header
    000307  aa  2 00005 7433 00    505  	stx3	bp|area.last_size	..
    000310  aa  2 00000 4433 12    506  	sxl3	bp|block.cur_size,2
    000311  aa  2 00002 0233 00    507  	adlx3	bp|area.next_virgin	update next available pointer
    000312  aa  2 00002 7433 00    508  	stx3	bp|area.next_virgin	..
                                   509  
    000313                         510  return_ptr:
    000313  aa   000001 2352 03    511  	lda	1,du
    000314  aa  2 00027 0553 00    512  	asa	bp|area.n_allocated
    000315  aa  2 00002 4503 12    513  	stz	bp|2,2	always zero this word in case the area is being
                                   514  			"zerod on free to get zero blocks
    000316  aa  2 00003 2353 00    515  	lda	bp|area.flags	now see if we should zero the block
    000317  aa   200000 3152 03    516  	cana	area.zero_on_alloc,du	..
    000320  0a   000330 6002 00    517  	tze	dont_zero		no, just return pointer
    000321  aa  2 00003 3537 12    518  	eppbb	bp|3,2		get pointer to first word to zero
    000322  aa  6 00011 2353 00    519  	lda	sp|rsize		get number of words to clear
    000323  aa   000003 1352 07    520  	sbla	3,dl		don't zero block header
    000324  aa   000002 7352 00    521  	als	2		multiply by 4 for MLR
                                   522  
    000325                         523  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
    000325  aa   000140 1004 00    524  	mlr	(),(pr,rl),fill(0)
    000326  aa   000000 000000     525  	desc9a	0,0
    000327  aa   300000 000005     526  	desc9a	bb|0,al
    000330                         527  dont_zero:
    000330  aa  2 00002 3521 12    528  	eppbp	bp|2,2		get actual pointer to block
    000331  aa   000000 1000 03    529  	cmpx0	0,du		see if operator ref
    000332  aa  6 00046 6011 70    530  	tnz	sp|tbp,*0	 	yes, return immediately
    000333  aa  0 00006 2521 20    531  	spribp	ap|6,*		return it to caller
    000334  aa  7 00042 7101 20    532  	return
                                   533  "
                                   534  "	Come here when there is no room in the current area component
                                   535  "	for the requested allocation. Check to see if the area is
                                   536  "	extensible, and, if so, call to get a pointer to the next
                                   537  "	component of the area.
                                   538  "
    000335                         539  no_room:
    000335  aa  2 00003 2351 00    540  	lda	bp|area.flags	get flags word from header
    000336  aa   400000 3150 03    541  	cana	area.extend,du	see if the area is extensible
    000337  0a   001125 6000 00    542  	tze	signal_area	no, we must signal "area"
    000340  aa  6 00011 2361 00    543  	ldq	sp|rsize		see if allocation is impossibly large (rsize includes header size)
    000341  aa   775733 1160 07    544  	cmpq	262144-1024-area_size-extend_block_size-alloc_blkhdrsz+1,dl  includes extend block and allocated block header overhead
    000342  0a   001125 6030 00    545  	trc	signal_area	block too large even for empty area
                                   546  "
                                   547  "	The area is extensible. Get a pointer to the next component.
                                   548  "
    000343  aa  6 00014 4401 00    549  	sxl0	sp|save_x0
    000344  aa  6 00000 3731 00    550  	epbpsb	sp|0		generate linkage pointer
    000345  0a   000345 2130 00    551  	epaq	*		..
    000346  aa  7 00026 7641 61    552  	lprplp	sb|stack_header.lot_ptr,*au
    000347  aa  6 00016 2521 00    553  	spribp	sp|save_bp		prepare arglist
    000350  aa   000004 2350 03    554  	lda	4,du			..
    000351  aa   000000 2360 03    555  	ldq	0,du
    000352  aa  6 00070 7571 00    556  	staq	sp|arglist
    000353  aa  6 00016 3521 00    557  	eppbp	sp|save_bp	generate argument list
    000354  aa  6 00072 2521 00    558  	spribp	sp|arglist+2
    000355  aa  6 00076 3521 00    559  	eppbp	sp|ret_bp
    000356  aa  6 00074 2521 00    560  	spribp	sp|arglist+4
    000357  aa  6 00070 3501 00    561  	eppap	sp|arglist	..
    000360  aa  6 00024 3571 00    562  	stcd	sp|stack_frame.return_ptr
    000361  4a  4 00014 7131 20    563  	callsp	<get_next_area_ptr_>|[get_next_area_ptr_]
                                   564  
    000362  aa  6 00014 7201 00    565  	lxl0	sp|save_x0
    000363  aa  6 00046 3521 20    566  	eppbp	sp|tbp,*		must restore pl1 frame's return pointer
    000364  aa  6 00024 2521 00    567  	spribp	sp|stack_frame.return_ptr
    000365  aa  6 00076 3521 20    568  	eppbp	sp|ret_bp,*		get pointer to next component
    000366  aa   000000 1000 03    569  	cmpx0	0,du		don't load ap if operator
    000367  0a   000146 6010 00    570  	tnz	retry_alloc
    000370  aa  6 00032 3501 20    571  	eppap	sp|stack_frame.arg_ptr,*	must restore argument list pointer
    000371  0a   000146 7100 00    572  	tra	retry_alloc
                                   573  
    000372                         574  no_room_no_free:
    000372  aa  2 00003 2351 00    575  	lda	bp|area.flags	get flags word from header
    000373  aa   400000 3150 03    576  	cana	area.extend,du	see if the area  is extendable
    000374  0a   001125 6000 00    577  	tze	signal_area	no, we must signal "area"
    000375  aa   775735 1160 07    578  	cmpq	262144-1024-area_size-extend_block_size+1,dl  is size too big for empty area?
    000376  0a   001125 6030 00    579  	trc	signal_area	yes--abort
                                   580  "
                                   581  "	The no_free area area is extendable, get a pointer to the next component
                                   582  "
    000377  aa  6 00010 7531 00    583  	sreg	sp|8
    000400  aa  6 00000 3731 00    584  	epbpsb	sp|0		generate linkage ptr
    000401  0a   000401 2130 00    585  	epaq	*
    000402  aa  7 00026 7641 61    586  	lprplp	sb|stack_header.lot_ptr,*au
    000403  aa  2 00010 3521 00    587  	eppbp	bp|no_free_area.current_component generate arg list
    000404  aa  6 00072 2521 00    588  	spribp	sp|arglist+2
    000405  aa  6 00076 3521 00    589  	eppbp	sp|ret_bp
    000406  aa  6 00074 2521 00    590  	spribp	sp|arglist+4
    000407  aa   010000 4310 07    591  	fld	2*2048,dl
    000410  aa  6 00070 7571 00    592  	staq	sp|arglist
    000411  aa  6 00070 3501 00    593  	eppap	sp|arglist
    000412  aa  6 00024 3571 00    594  	stcd	sp|stack_frame.return_ptr
    000413  4a  4 00014 7131 20    595  	callsp	<get_next_area_ptr_>|[get_next_area_ptr_]
                                   596  
    000414  aa  6 00010 0731 00    597  	lreg	sp|8
    000415  aa  6 00046 3521 20    598  	eppbp	sp|tbp,*		must restore pl1 frame stuff
    000416  aa  6 00024 2521 00    599  	spribp	sp|stack_frame.return_ptr
    000417  aa   000000 1000 03    600  	cmpx0	0,du		don't load ap if operator
    000420  aa   000002 6010 04    601  	tnz	2,ic
    000421  aa  6 00032 3501 20    602  	eppap	sp|stack_frame.arg_ptr,*
                                   603  "
                                   604  "	Hook up new component to first component
                                   605  "
    000422  aa  6 00076 3701 20    606  	epplp	sp|ret_bp,*		get ptr to new component
    000423  aa  4 00026 2351 00    607  	lda	lp|area.extend_info
    000424  aa  4 00000 7621 01    608  	lprpbp	lp|extend_block.first_area,au	get ptr to first component
    000425  aa  2 00010 6501 00    609  	sprilp	bp|no_free_area.current_component
    000426  aa  4 00001 2351 00    610  	lda	lp|area.last_usable	refresh area info
    000427  aa  2 00001 7551 00    611  	sta	bp|area.last_usable	..
    000430  aa  4 00002 2351 00    612  	lda	lp|area.next_virgin	..
    000431  aa  2 00002 7551 00    613  	sta	bp|area.next_virgin	..
    000432  0a   000050 7100 00    614  	tra	no_free_alloc_op	and try again
                                   615  
                                   616  " 
                                   617  "
                                   618  "	area_
                                   619  "	op_empty_
                                   620  "
                                   621  "	These routines initialize a given area in the specified way.
                                   622  "	The various calling sequences are:
                                   623  "
                                   624  "	call area_ (size, areap)
                                   625  "	call area_$no_freeing (size, areap, extend)
                                   626  "	call area_$extend (size, areap)
                                   627  "	call area_$redef (size, areap);
                                   628  "
                                   629  "	The op_empty_ entry is called after loading the bp with a
                                   630  "	pointer to the area and the q-reg with the size.
                                   631  "
                                   632  "		ldq	size
                                   633  "		eppbp	area_header
                                   634  "		tsx0	pr0|empty_operator
                                   635  "
                                   636  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   637  
    000433                         638  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000433                         639  old_area_:
    000433  aa   000000 6212 00    640  area_:	eax1	0		describes type of area being initialized
    000434  aa   000000 6202 00    641  areajoin:	eax0	0		indicates not an operator call
    000435  aa  0 00004 3523 20    642  	eppbp	ap|4,*		get a pointer to what will be the initialized header
    000436  aa  2 00000 3523 20    643  	eppbp	bp|0,*		..
    000437  aa  0 00002 2363 20    644  	ldq	ap|2,*		get size of the area
    000440  0a   000616 6046 00    645  	tmoz	signal_area_p1	bad value
    000441  aa   000022 7362 00    646  op_join:	qls	18		left justify
                                   647  
    000442  4a  4 00016 3537 20    648  	eppbb	<template_area_header>|[template_area_header]
    000443  aa  0 00100 1007 00    649  	mlr	(pr),(pr)
    000444  aa   300000 000140     650  	desc9a	bb|0,area_size*4
    000445  aa   200000 000140     651  	desc9a	bp|0,area_size*4
                                   652  
    000446  aa  2 00001 7563 00    653  	stq	bp|area.last_usable	fill in variable items
    000447  0a   000450 7102 31    654  	tra	*+1,1*		dispatch on initialization type
    000450  0a   000474 0002 00    655  	arg	standard_area
    000451  0a   000453 0002 00    656  	arg	no_free_area
    000452  0a   000461 0002 00    657  	arg	extend_area
                                   658  
    000453                         659  no_free_area:
    000453  aa   040000 2352 03    660  	lda	area.dont_free,du	make sure free requests are ignored
    000454  aa  2 00003 2553 00    661  	orsa	bp|area.flags	..
    000455  aa  2 00010 2523 00    662  	spribp	bp|no_free_area.current_component
    000456  aa  2 00004 0543 00    663  	aos	bp|area.allocation_method set method type to 1
    000457  aa  0 00006 2353 20    664  	lda	ap|6,*		get extend flag
    000460  0a   000474 6002 00    665  	tze	standard_area	extensible area not wanted
                                   666  "
                                   667  "	Now allocate a block large enough to hold the extend information.
                                   668  "
    000461                         669  extend_area:
    000461  aa   400000 2352 03    670  	lda	area.extend,du	set extend flag ON in header
    000462  aa  2 00003 2553 00    671  	orsa	bp|area.flags
    000463  aa   000016 2352 03    672  	lda	extend_block_size+2,du get size for the extend block
    000464  aa  2 00002 2363 00    673  	ldq	bp|area.next_virgin	get start of new last block
    000465  aa  2 00002 0553 00    674  	asa	bp|area.next_virgin	update header for new block
    000466  aa  2 00026 7563 00    675  	stq	bp|area.extend_info	..
    000467  aa  2 00006 7563 00    676  	stq	bp|area.last_block	..
    000470  aa  2 00005 7553 00    677  	sta	bp|area.last_size	..
    000471  0a   001252 3536 20    678  	eppbb	=its(-1,1),*	initialize variables in extend block
    000472  aa  2 00001 5433 02    679  	sprpbb	bp|extend_block.next_area,qu
    000473  aa  2 00000 5423 02    680  	sprpbp	bp|extend_block.first_area,qu
    000474                         681  standard_area:
    000474  aa   000000 1002 03    682  	cmpx0	0,du		see if called as operator
    000475  aa  6 00046 6013 70    683  	tnz	sp|tbp,*0		yes, return in standard way
    000476  aa  7 00044 7103 20    684  	short_return
                                   685  
    000477                         686  no_freeing:
    000477  aa   000001 6212 00    687  	eax1	1		set initialization type
    000500  0a   000434 7102 00    688  	tra	areajoin
    000501                         689  extend:
    000501  aa   000002 6212 00    690  	eax1	2		set initialization type
    000502  0a   000434 7102 00    691  	tra	areajoin
                                   692  
    000503                         693  op_empty_:
    000503  aa   000000 6212 00    694  	eax1	0		set initialization type
    000504  0a   000441 7102 00    695  	tra	op_join
                                   696  
    000505  aa  0 00004 3523 20    697  redef:	eppbp	ap|4,*		get pointer to the area
    000506  aa  2 00000 3523 20    698  	eppbp	bp|0,*		..
    000507  aa  2 00000 2353 00    699  	lda	bp|area.version	check version of area
    000510  4a  4 00020 6003 20    700  	tze	<buddy_area_>|[buddy_redef]
                                   701  
    000511  aa  0 00002 7203 20    702  	lxl0	ap|2,*		get size to redefine area to have
    000512  aa  2 00002 1003 00    703  	cmpx0	bp|area.next_virgin	see if we fit
    000513  0a   000614 6022 00    704  	tnc	signal_area_p0	no, complain by signalling area
    000514  aa  2 00001 7403 00    705  	stx0	bp|area.last_usable	reset end of area
    000515  aa  7 00044 7103 20    706  	short_return
                                   707  
                                   708  "
                                   709  "
                                   710  "	area_assign_
                                   711  "
                                   712  "	This entry copies one area into the storage of an already initialized other area.
                                   713  "	If the receiving area is not large enough, "area" is signalled.
                                   714  "
                                   715  "	call is:
                                   716  "
                                   717  "	call area_assign_ (new_areap, old_areap)
                                   718  "
                                   719  "	where:
                                   720  "		new_areap is the target, pointed to by bp.
                                   721  "		old_areap is the source, pointed to by bb.
                                   722  "
                                   723  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   724  
    000516                         725  area_assign_:
    000516  aa  0 00002 3523 20    726  	eppbp	ap|2,*		get pointer to new area
    000517  aa  2 00000 3523 20    727  	eppbp	bp|0,*		..
    000520  aa  0 00004 3537 20    728  	eppbb	ap|4,*		get pointer to old area
    000521  aa  3 00000 3537 20    729  	eppbb	bb|0,*		..
                                   730  
    000522  aa  2 00000 2353 00    731  	lda	bp|area.version	check new for buddy or empty area
    000523  0a   000561 6002 00    732  	tze	new_is_buddy_or_empty
    000524                         733  new_is_new:
    000524  aa  3 00000 2353 00    734  	lda	bb|area.version	check old for buddy or empty
    000525  0a   000600 6002 00    735  	tze	old_is_buddy_or_empty
    000526                         736  both_are_new:
    000526  aa  3 00002 2353 00    737  	lda	bb|area.next_virgin	see if enough room
    000527  aa  2 00001 1153 00    738  	cmpa	bp|area.last_usable	..
    000530  0a   000532 6002 00    739  	tze	*+2		ok if equal
    000531  0a   000614 6032 00    740  	trc	signal_area_p0
    000532  aa  3 00003 2363 00    741  	ldq	bb|area.flags	check for need to zero past virgin portion
    000533  aa   100000 3162 03    742  	canq	area.zero_on_free,du ..
    000534  0a   000542 6012 00    743  	tnz	assign_and_fill	is zero_on_free...needs fill
    000535  aa   200000 3162 03    744  	canq	area.zero_on_alloc,du check for NO_FREEING & zero_on_alloc
    000536  0a   000552 6002 00    745  	tze	assign_no_fill	isn't zero_on_alloc...don't need fill
    000537  aa  3 00004 2363 00    746  	ldq	bb|area.allocation_method
    000540  aa   000001 1162 07    747  	cmpq	NO_FREEING_ALLOCATION_METHOD,dl
    000541  0a   000552 6012 00    748  	tnz	assign_no_fill	isn't NO_FREEING...doesn't need fill
                                   749  "				fall through...is both zero_on_alloc & NO_FREEING
                                   750  "
    000542                         751  assign_and_fill:
    000542  aa  2 00001 2363 00    752  	ldq	bp|area.last_usable	get length of target (new)
    000543  aa   000020 7732 00    753  	lrl	18-2		get char count in AL, QL
    000544                         754  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
    000544  aa  0 00140 1005 40    755  	mlr	(pr,rl),(pr,rl),fill(000)
    000545  aa   300000 000005     756  	desc9a	bb|0,al		source
    000546  aa   200000 000006     757  	desc9a	bp|0,ql		target
    000547                         758  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000547  aa   000020 7362 00    759  	qls	18-2		restore word count to QU
    000550  aa  2 00001 7563 00    760  	stq	bp|area.last_usable	restore size of area
    000551  aa  7 00044 7103 20    761  	short_return
                                   762  "
    000552                         763  assign_no_fill:
    000552  aa  2 00001 2363 00    764  	ldq	bp|area.last_usable	hold length of target (new)
    000553  aa   000020 7712 00    765  	arl	18-2		get char count in AL
    000554                         766  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
    000554  aa  0 00140 1005 40    767  	mlr	(pr,rl),(pr,rl)
    000555  aa   300000 000005     768  	desc9a	bb|0,al		source
    000556  aa   200000 000005     769  	desc9a	bp|0,al		target
    000557                         770  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000557  aa  2 00001 7563 00    771  	stq	bp|area.last_usable	restore size of area
    000560  aa  7 00044 7103 20    772  	short_return
                                   773  "
    000561                         774  new_is_buddy_or_empty:
    000561  aa  2 00003 2353 00    775  	lda	bp|buddy_area.inited see if empty
    000562  0a   000573 6012 00    776  	tnz	new_is_buddy	not empty, is buddy
    000563  4a  4 00016 3517 20    777  	eppab	<template_area_header>|[template_area_header]
    000564  aa  2 00002 2353 00    778  	lda	bp|buddy_area.size
    000565  aa   000022 7352 00    779  	als	18
    000566                         780  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
    000566  aa  0 00100 1005 00    781  	mlr	(pr),(pr)
    000567  aa   100000 000140     782  	desc9a	ab|0,area_size*4
    000570  aa   200000 000140     783  	desc9a	bp|0,area_size*4
    000571                         784  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000571  aa  2 00001 7553 00    785  	sta	bp|area.last_usable
    000572  0a   000524 7102 00    786  	tra	new_is_new
    000573                         787  new_is_buddy:
    000573  aa  3 00000 2353 00    788  	lda	bb|area.version	check version of old area
    000574  0a   000620 6012 00    789  	tnz	signal_area_p2	old is not buddy - error
    000575  aa  3 00003 2353 00    790  	lda	bb|buddy_area.inited see if empty
    000576  4a  4 00022 6013 20    791  	tnz	<buddy_area_assign_>|[buddy_area_assign_] both are buddy - ok
    000577  0a   000620 7102 00    792  	tra	signal_area_p2	old is empty, new is buddy - error
    000600                         793  old_is_buddy_or_empty:	"already know new is not buddy
    000600  aa  3 00000 2353 00    794  	lda	bb|area.version	check if buddy or empty
    000601  0a   000526 6012 00    795  	tnz	both_are_new
    000602  aa  3 00003 2353 00    796  	lda	bb|buddy_area.inited
    000603  0a   000620 6012 00    797  	tnz	signal_area_p2
    000604  4a  4 00016 3517 20    798  	eppab	<template_area_header>|[template_area_header]
    000605  aa  3 00002 2353 00    799  	lda	bb|buddy_area.size
    000606  aa   000022 7352 00    800  	als	18
    000607                         801  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
    000607  aa  0 00100 1005 00    802  	mlr	(pr),(pr)
    000610  aa   100000 000140     803  	desc9a	ab|0,area_size*4
    000611  aa   300000 000140     804  	desc9a	bb|0,area_size*4
    000612                         805  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000612  aa  3 00001 7553 00    806  	sta	bb|area.last_usable
    000613  0a   000526 7102 00    807  	tra	both_are_new
                                   808  
    000614                         809  signal_area_p0:
    000614  aa   000000 6262 00    810  	eax6	0		"area"
    000615  0a   000623 7102 00    811  	tra	signal_area_p
    000616                         812  signal_area_p1:
    000616  aa   000002 6262 00    813  	eax6	2		"bad_area_initialization"
    000617  0a   000623 7102 00    814  	tra	signal_area_p
    000620                         815  signal_area_p2:
    000620  aa   000003 6262 00    816  	eax6	3		"bad_area_assignment"
    000621  0a   000623 7102 00    817  	tra	signal_area_p
    000622                         818  signal_area_p3:
    000622  aa   000004 6262 00    819  	eax6	4		"bad_area_format"
    000623                         820  signal_area_p:
    000623  aa   000120 6272 00    821  	push	80
    000624  aa  7 00040 2723 20
    000625  aa   000200 2352 07    822  	lda	stack_frame.support_bit,dl
    000626  aa  6 00020 2553 00    823  	orsa	sp|stack_frame.flag_word
    000627  aa   000000 6202 00    824  	eax0	0		indicates not pl1_operator_ call
    000630  0a   001125 7102 00    825  	tra	signal_area
                                   826  
    000631                         827  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
                                   828  " 
                                   829  "
                                   830  "	freen_
                                   831  "	op_freen_
                                   832  "
                                   833  "	These entries free up the block pointed to by the input pointer.
                                   834  "	The block is merged with adjacent blocks if they are free.
                                   835  "
                                   836  "	The call for the external entry is:
                                   837  "
                                   838  "	call freen_ (blockp)
                                   839  "
                                   840  "	The operator entry (op_freen_) is invoked as follows:
                                   841  "
                                   842  "		epplb	addr(pointer to block_to_free)
                                   843  "		tsx0	pr0|free_op
                                   844  "
                                   845  "
                                   846  " " " " " " " " " " " " " " " " " " " " " " " " " " " " " "
                                   847  
    000631                         848  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000631                         849  old_freen_:
    000631                         850  freen_:
    000631  aa  0 00002 3523 20    851  	eppbp	ap|2,*		make a check for buddy area before doing push
    000632  aa  2 00000 3523 20    852  	eppbp	bp|0,*		get pointer to block
    000633  aa  2 77777 2353 00    853  	lda	bp|-1		see if buddy area
    000634  4a  4 00024 6043 20    854  	tmi	<buddy_freen_>|[buddy_freen_] yes, forward the call
    000635  aa   000120 6272 00    855  	push	80		now get a stack frame
    000636  aa  7 00040 2723 20
    000637  aa   000200 2352 07    856  	lda	stack_frame.support_bit,dl
    000640  aa  6 00020 2553 00    857  	orsa	sp|stack_frame.flag_word
    000641  aa  0 00002 3717 20    858  	epplb	ap|2,*		get pointer to block to free
    000642  aa  5 00000 3523 20    859  	eppbp	lb|0,*		..
    000643  aa   000000 6202 00    860  	eax0	0		not operator use
    000644                         861  op_freen_join:
                                   862  "
                                   863  "	Get standard register values. x2 -> block, bp -> header.
                                   864  "
    000644  aa  2 77777 7223 00    865  	lxl2	bp|block.header-2	fetch header pointer from block header
    000645  aa  2 77776 3523 12    866  	eppbp	bp|-2,2		make bp -> header
    000646  aa   777777 6622 03    867  	erx2	-1,du		complement C(x2)
    000647  aa   000001 0222 03    868  	adlx2	1,du		..
                                   869  
    000650  aa  2 00003 2353 00    870  	lda	bp|area.flags	check if freeing is enabled
    000651  aa   040000 3152 03    871  	cana	area.dont_free,du	..
    000652  0a   000656 6012 00    872  	tnz	free_ret		disabled, skip freen_1 subroutine work
                                   873  "
    000653  aa   000001 3352 03    874  	lca	1,du		decrement used blocks
    000654  aa  2 00027 0553 00    875  	asa	bp|area.n_allocated
    000655  0a   000705 2712 00    876  	tspab	freen_1		do the work in this subroutine
    000656                         877  free_ret:
    000656  0a   001252 3536 20    878  	eppbb	=its(-1,1),*	null out return pointer
    000657  aa  5 00000 2537 00    879  	spribb	lb|0		passed by caller
    000660  aa   000000 1002 03    880  	cmpx0	0,du		perform appropriate return
    000661  aa  6 00046 6013 70    881  	tnz	sp|tbp,*0	
    000662  aa  7 00042 7103 20    882  	return
                                   883  
    000663                         884  op_freen_:
    000663  aa  5 00000 3523 20    885  	eppbp	lb|0,*		get pointer to block
    000664  aa  2 77777 2353 00    886  	lda	bp|-1		check if buddy area
    000665  0a   000644 6052 00    887  	tpl	op_freen_join	no, use standard code
                                   888  "
                                   889  "	We were called as operator to free up old style area's block.
                                   890  "	We must make an external call to buddy_freen_.
                                   891  "
    000666  aa  6 00072 6517 00    892  	sprilb	sp|arglist+2	save pointer to block pointer
    000667  aa  6 00010 7533 00    893  	sreg	sp|8		save registers
    000670  aa  6 00000 3733 00    894  	epbpsb	sp|0		get pointer to stack base so we can get lp
    000671  0a   000671 2132 00    895  	epaq	*		get segno of this program
    000672  aa  7 00026 7643 61    896  	lprplp	sb|stack_header.lot_ptr,*au get lp
    000673  aa   000004 2352 03    897  	lda	4,du		generate arg list header
    000674  aa   000000 2362 03    898  	ldq	0,du		..
    000675  aa  6 00070 7573 00    899  	staq	sp|arglist	..
    000676  aa  6 00070 3503 00    900  	eppap	sp|arglist	get pointer to argument list
    000677  aa  6 00024 3573 00    901  	stcd	sp|stack_frame.return_ptr	standard call...
    000700  4a  4 00024 7133 20    902  	callsp	<buddy_freen_>|[buddy_freen_]
    000701  aa  6 00010 0733 00    903  	lreg	sp|8		restore registers
    000702  aa  6 00046 3523 20    904  	eppbp	sp|tbp,*		must restore return pointer for pl1 frame
    000703  aa  6 00024 2523 00    905  	spribp	sp|stack_frame.return_ptr	..
    000704  aa  6 00046 7103 70    906  	tra	sp|tbp,*0		return to object program
                                   907  
                                   908  "
                                   909  "
                                   910  "	Subroutine to free the block pointed to by x2. The base
                                   911  "	of the area is pointed to by bp.
                                   912  "
    000705                         913  freen_1:
    000705                         914  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
                                   915  
    000705  aa   000001 2350 07    916  	lda	1,dl		keep track of how many blocks are freed
    000706  aa  6 00017 7551 00    917  	sta	sp|free_count
    000707  aa  2 00000 2371 12    918  	ldaq	bp|0,2		fetch entire header
    000710  aa   000022 7350 00    919  	als	18		left justify
    000711  aa  6 00012 7551 00    920  	sta	sp|blocksize	save for now in accumulating total
    000712  aa  2 00003 2231 00    921  	ldx3	bp|area.flags	see if must zero block
    000713  aa   100000 3030 03    922  	canx3	area.zero_on_free,du ..
    000714  0a   000723 6000 00    923  	tze	not_zof		dont bother
    000715  aa  2 00000 3701 12    924  	epplp	bp|0,2		pointer to block being freed
    000716  aa   777775 6350 01    925  	eaa	-3,au		count of words to zero
    000717  aa   000002 7350 00    926  	als 	2		count of bytes to zero
    000720  aa   000140 1004 00    927  	mlr	(),(pr,rl)	zero block contents
    000721  aa   000000 000000     928  	desc9a	0,0		zeroes
    000722  aa   400003 000001     929  	desc9a	lp|3,au		bytes to be zeroed after block header
    000723                         930  not_zof:
    000723                         931  	inhibit	on		<+><+><+><+><+><+><+><+><+><+><+>
    000723  aa  2 00025 2353 00    932  	lda	bp|area.allocation_p_clock	guard against IPS race
    000724  aa   000001 0352 07    933  	adla	1,dl			..
    000725  aa  2 00025 7553 00    934  	sta	bp|area.allocation_p_clock	..
    000726  aa  6 00012 6233 72    935  	eax3	sp|blocksize,*2	x3 -> nextblock
    000727  aa   001000 3162 03    936  	canq	block.prev_busy,du	see if previous block is free
    000730  0a   000734 6002 00    937  	tze	prev_free		no
    000731  aa  2 00006 1023 00    938  	cmpx2	bp|area.last_block	see if freeing last block
    000732  0a   001101 6002 00    939  	tze	free_last_block	yes, special case
    000733  0a   000757 7102 00    940  	tra	check_next	no, see if next block is free
    000734                         941  prev_free:
                                   942  "
                                   943  "	The previous block is free. Merge it with the current block.
                                   944  "	Accumulate the size of the ultimate free block in blocksize.
                                   945  "
    000734  aa   000001 3352 07    946  	lca	1,dl		already free, undo previous subtraction
    000735  aa  6 00017 0553 00    947  	asa	sp|free_count	..
    000736  aa  2 00000 2243 12    948  	ldx4	bp|block.prev_size,2 get size of previous block
    000737  aa  6 00013 7443 00    949  	stx4	sp|temp
    000740  aa  6 00012 0243 00    950  	adlx4	sp|blocksize	update blocksize
    000741  aa  6 00012 7443 00    951  	stx4	sp|blocksize	..
    000742  aa  2 00000 4503 12    952  	stz	bp|0,2		in case of zero_on_free
    000743  aa  2 00001 4503 12    953  	stz	bp|1,2		clear intervening header words
    000744  aa  2 00002 4503 12    954  	stz	bp|2,2		 ..
                                   955  "
                                   956  "	Thread previous block out of its free list.
                                   957  "
    000745  aa   000000 6242 12    958  	eax4	0,2		make x4 point to previous block
    000746  aa  6 00013 1243 00    959  	sblx4	sp|temp		..
    000747  0a   001054 2732 00    960  	tspbb	unthread		thread block out of list
    000750  aa   000000 0112 00    961  	nop			"ignore if just zerod list
    000751  aa  2 00006 1023 00    962  	cmpx2	bp|area.last_block	see if we are freeing the last block
    000752  0a   000756 6012 00    963  	tnz	not_last		no, proceed normally
    000753  aa  2 00006 7443 00    964  	stx4	bp|area.last_block	yes, update header variables
    000754  aa   000000 6222 14    965  	eax2	0,4		pretend we are freeing the merged block
    000755  0a   001101 7102 00    966  	tra	free_last_block
                                   967  
    000756  aa   000000 6222 14    968  not_last:	eax2	0,4		pretend we are freeing the merged block
                                   969  
                                   970  "	See if next block is free.
                                   971  
    000757                         972  check_next:
    000757  aa  2 00006 1033 00    973  	cmpx3	bp|area.last_block	see if next block is last in area
    000760  0a   001003 6002 00    974  	tze	next_busy		yes, it therefore can't be free
    000761  aa  2 00000 2373 13    975  	ldaq	bp|0,3		get header for next block
    000762  aa   000022 7352 00    976  	als	18		left justify current size
    000763  aa  6 00013 7553 00    977  	sta	sp|temp		so we can generate a pointer to next header
    000764  aa   000000 6242 13    978  	eax4	0,3		set x4 in case needed by unthread
    000765  aa  6 00013 6253 73    979  	eax5	sp|temp,*3	get pointer to following header
    000766  aa  2 00001 2363 15    980  	ldq	bp|block.prev_busy_word,5	check if block is free
    000767  aa   001000 3162 03    981  	canq	block.prev_busy,du	..
    000770  0a   001003 6012 00    982  	tnz	next_busy
                                   983  "
                                   984  "	Next block is free. Merge it with current block.
                                   985  "
    000771  aa   000001 3362 07    986  	lcq	1,dl
    000772  aa  6 00017 0563 00    987  	asq	sp|free_count
    000773  aa  6 00012 0353 00    988  	adla	sp|blocksize	update size of free block
    000774  aa  6 00012 7553 00    989  	sta	sp|blocksize	..
    000775  0a   001054 2732 00    990  	tspbb	unthread		thread the block out of the free list
    000776  aa   000000 0112 00    991  	nop			"ignore if just zerod list
    000777  aa   000000 6232 15    992  	eax3	0,5		x3 -> next block after free block
    001000  aa  2 00000 4503 14    993  	stz	bp|0,4		in case zero_on_free
    001001  aa  2 00001 4503 14    994  	stz	bp|1,4		clear header of unthreaded block
    001002  aa  2 00002 4503 14    995  	stz	bp|2,4		 ..
                                   996  
    001003                         997  next_busy:
                                   998  
    001003  aa  6 00012 2213 00    999  	ldx1	sp|blocksize	get accumulated size of block being freed
    001004  aa  2 00000 4413 12   1000  	sxl1	bp|block.cur_size,2	update header of block being freed
    001005  aa  2 00000 7413 13   1001  	stx1	bp|block.prev_size,3	..
    001006  aa   001001 3212 03   1002  	lcx1	block.prev_busy+1,du	turn off busy bit
    001007  aa  2 00001 3413 13   1003  	ansx1	bp|block.prev_busy_word,3	..
                                  1004  
                                  1005  
                                  1006  "	Thread the block into free list.
                                  1007  "	First get stratum number for list to thread into.
                                  1008  
    001010  aa  6 00012 2353 00   1009  	lda	sp|blocksize	get size of total block
    001011  aa   000022 7712 00   1010  	arl	18		convert to integer
    001012  aa  6 00013 7553 00   1011  	sta	sp|temp		save integer form
    001013  aa  6 00013 4313 00   1012  	fld	sp|temp		now perform conversion as in alloc_ entry
    001014  aa   064000 4112 03   1013  	lde	=26b25,du		..
    001015  aa   400000 4752 03   1014  	fad	=0.0e0,du		..
    001016  aa  6 00013 4563 00   1015  	ste	sp|temp		..
    001017  aa  6 00013 2363 00   1016  	ldq	sp|temp		..
    001020  aa   000012 7722 00   1017  	qrl	28-18		..
    001021  aa   000020 1162 03   1018  	cmpq	16,du		clip if too high
    001022  0a   001024 6046 00   1019  	tmoz	*+2
    001023  aa   000020 2362 03   1020  	ldq	16,du
    001024  aa  2 00001 3537 12   1021  	eppbb	bp|block.q_no_word,2 get pointer to header for storing q_no
    001025  aa  3 00000 7523 10   1022  	stcq	bb|0,10		save q_no in current header
                                  1023  
    001026  aa  2 00004 2213 02   1024  	ldx1	bp|area.freep-3,qu	get free list pointer
    001027  0a   001047 6002 00   1025  	tze	empty		nothing there yet, special case
    001030  aa  2 00002 7253 11   1026  	lxl5	bp|block.bp,1
    001031  aa  2 00002 4423 11   1027  	sxl2	bp|block.bp,1
    001032  aa  2 00002 7413 12   1028  	stx1	bp|block.fp,2
    001033  aa  2 00002 7423 15   1029  	stx2	bp|block.fp,5
    001034  aa  2 00002 4453 12   1030  	sxl5	bp|block.bp,2
    001035  aa  2 00004 7423 02   1031  	stx2	bp|area.freep-3,qu	roving pointer ...
    001036  aa  2 00004 7253 02   1032  	lxl5	bp|area.freep-3,qu	update max size if needed
    001037  0a   001044 6002 00   1033  	tze	all_done	if zero, must recalculate next full search
    001040  aa  6 00012 1053 00   1034  	cmpx5	sp|blocksize	see if adding largest block
    001041  0a   001044 6032 00   1035  	trc	all_done	no, don't need to change max
    001042  aa  6 00012 2253 00   1036  	ldx5	sp|blocksize	get new max value
    001043  aa  2 00004 4453 02   1037  out:	sxl5	bp|area.freep-3,qu	update max size for this list
    001044  aa  6 00017 2363 00   1038  all_done:	ldq	sp|free_count	update count of free blocks
    001045  aa  2 00027 0563 00   1039  	asq	bp|area.n_free	..
    001046  aa  1 00000 7103 00   1040  	tra	ab|0
                                  1041  
    001047  aa  2 00004 7423 02   1042  empty:	stx2	bp|area.freep-3,qu	set free ptr to single entry in list
    001050  aa  2 00002 7423 12   1043  	stx2	bp|block.fp,2	make entry point to itself
    001051  aa  2 00002 4423 12   1044  	sxl2	bp|block.bp,2	..
    001052  aa  6 00012 2253 00   1045  	ldx5	sp|blocksize	get set to update max free size for this list
    001053  0a   001043 7102 00   1046  	tra	out
                                  1047  
                                  1048  "
                                  1049  "	The following subroutine is used to thread the block pointed to
                                  1050  "	by index 4 out of the free list. If this results in an empty free list,
                                  1051  "	the return is made to bb|0, otherwise, the return is made to
                                  1052  "	bb|1.
                                  1053  "
    001054                        1054  unthread:
    001054  aa  2 00001 2363 14   1055  	ldq	bp|block.q_no_word,4 get stratum number for this free block
    001055  aa   000377 3762 03   1056  	anq	block.q_no_mask,du	..
    001056  aa  2 00004 7273 02   1057  	lxl7	bp|area.freep-3,qu	get max entry in list to see if unthreading largest
    001057  aa  6 00013 7473 00   1058  	stx7	sp|temp		save for compare
    001060  aa  2 00000 7273 14   1059  	lxl7	bp|block.cur_size,4	see if unthreading largest entry
    001061  aa  6 00013 1073 00   1060  	cmpx7	sp|temp		..
    001062  0a   001065 6012 00   1061  	tnz	not_big		not largest, ok
    001063  aa   000000 6272 00   1062  	eax7	0		zero max size to indicate we don't know it
    001064  aa  2 00004 4473 02   1063  	sxl7	bp|area.freep-3,qu	..
    001065  aa  2 00002 2273 14   1064  not_big:	ldx7	bp|block.fp,4	x7 -> next link in free chain
    001066  aa  2 00002 7213 14   1065  	lxl1	bp|block.bp,4	x1 -> previous link in free chain
    001067  aa  2 00002 1043 14   1066  	cmpx4	bp|block.fp,4	are they the same?
    001070  0a   001077 6002 00   1067  	tze	last_free		yes, last free block in free list
    001071  aa  2 00002 7473 11   1068  	stx7	bp|block.fp,1	thread around the block
    001072  aa  2 00002 4413 17   1069  	sxl1	bp|block.bp,7	..
    001073  aa  2 00004 1043 02   1070  	cmpx4	bp|area.freep-3,qu	see if pointing to head of list
    001074  aa  3 00001 6013 00   1071  	tnz	bb|1		no, continue
    001075  aa  2 00004 7473 02   1072  	stx7	bp|area.freep-3,qu	yes, change head of list
    001076  aa  3 00001 7103 00   1073  	tra	bb|1
                                  1074  
    001077  aa  2 00004 4503 02   1075  last_free:stz	bp|area.freep-3,qu	free list now empty, clear pointer word
    001100  aa  3 00000 7103 00   1076  	tra	bb|0		continue
                                  1077  
                                  1078  "
                                  1079  "
                                  1080  "	Come here when freeing the last block before virgin territory.
                                  1081  "
    001101                        1082  free_last_block:
    001101  aa   000001 3362 07   1083  	lcq	1,dl		decrement count of free blocks
    001102  aa  6 00017 0563 00   1084  	asq	sp|free_count
    001103  aa  2 00006 2353 00   1085  	lda	bp|area.last_block	update header of area
    001104  aa  2 00002 7553 00   1086  	sta	bp|area.next_virgin	..
    001105  aa  2 00000 2233 12   1087  	ldx3	bp|block.prev_size,2	get size of previous block for header
    001106  aa  2 00005 7433 00   1088  	stx3	bp|area.last_size	save in header
    001107  aa   777777 6632 03   1089  	erx3	-1,du		complement C(x3)
    001110  aa   000001 0232 03   1090  	adlx3	1,du
    001111  aa  2 00006 0233 00   1091  	adlx3	bp|area.last_block	update pointer to last allocated block
    001112  aa  2 00006 7433 00   1092  	stx3	bp|area.last_block	..
                                  1093  
    001113  aa  6 00012 2353 00   1094  	lda	sp|blocksize	get size of the block
    001114  aa  2 00000 4503 12   1095  	stz	bp|0,2		clear header words--they will be in virgin territory
    001115  aa  2 00001 4503 12   1096  	stz	bp|1,2		 ..
    001116  aa  2 00002 4503 12   1097  	stz	bp|2,2		 ..
    001117  0a   001044 7102 00   1098  	tra	all_done
    001120                        1099  	inhibit	off		<-><-><-><-><-><-><-><-><-><-><->
                                  1100  
                                  1101  
                                  1102  
                                  1103  "
                                  1104  
                                  1105  "
                                  1106  "	Come here when we must signal "area", "storage", or "bad_area_initialization"
                                  1107  "
    001120                        1108  signal_area_3:
    001120  aa   000004 6260 00   1109  	eax6	4		"bad_area_format"
    001121  0a   001125 7100 00   1110  	tra	signal_area
    001122                        1111  signal_area_2:
    001122  aa   000003 6260 00   1112  	eax6	3		"bad_area_assignment"
    001123  0a   001125 7100 00   1113  	tra	signal_area
    001124                        1114  signal_area_1:
    001124  aa   000002 6260 00   1115  	eax6	2		"bad_area_initialization"
    001125                        1116  signal_area:
    001125  aa   000000 1000 03   1117  	cmpx0	0,du		were we called as an operator?
    001126  0a   001132 6000 00   1118  	tze	signal_for_subr	yes, branch
    001127  aa   777777 6200 10   1119  	eax0	-1,0		subtract one to point to retry location in caller
    001130  aa  6 00037 4401 00   1120  	sxl0	sp|stack_frame.operator_ret_ptr	save for call_signal_
    001131  0a   001137 7100 00   1121  	tra	signal_join
    001132                        1122  signal_for_subr:
    001132  aa  6 00014 4461 00   1123  	sxl6	sp|save_x6	save for retry
    001133  0a   001133 6210 00   1124  	eax1	*		set up stack frame for call_signal_
    001134  aa  6 00037 4411 00   1125  	sxl1	sp|stack_frame.operator_ret_ptr
    001135  0a   001135 3524 00   1126  	epbpbp	*
    001136  aa  6 00046 2521 00   1127  	spribp	sp|tbp
    001137                        1128  signal_join:
    001137  0a   001155 3520 36   1129  	eppbp	name,6*		get pointer to name to signal
    001140  0a   001162 2260 16   1130  	ldx6	length,6		get length of name in x6
    001141  aa   001750 2360 07   1131  	ldq	1000,dl		get oncode in q
    001142  4a  4 00026 7011 20   1132  	tsx1	<pl1_operators_>|[call_signal_]
    001143  aa  6 00037 4501 00   1133  	stz	sp|stack_frame.operator_ret_ptr	clear after signal
    001144  aa  6 00010 2201 00   1134  	ldx0	sp|8		restore index 0 saved by call_signal_
    001145  aa  6 00046 6011 70   1135  	tnz	sp|tbp,*0		return to pl1 program to retry allocation
                                  1136  "
    001146  aa  6 00014 7261 00   1137  	lxl6	sp|save_x6	restore for retry
    001147  aa  6 00032 3501 20   1138  	eppap	sp|stack_frame.arg_ptr,*	restore arg pointer
    001150  aa  0 00004 3521 20   1139  	eppbp	ap|4,*		get area header pointer
    001151  aa  2 00000 3521 20   1140  	eppbp	bp|0,*		..
    001152  aa  2 00004 2351 00   1141  	lda	bp|area.allocation_method	see if no_freeing method used
    001153  0a   000127 6000 00   1142  	tze	retry_alloc_after_area	no, go retry it
    001154  0a   000046 7100 00   1143  	tra	retry_no_free_alloc_after_area
                                  1144  
    001155  0a   001167 0000 00   1145  name:	arg	area_name
    001156  0a   001170 0000 00   1146  	arg	storage_name
    001157  0a   001172 0000 00   1147  	arg	area_init_name
    001160  0a   001200 0000 00   1148  	arg	bad_assign_name
    001161  0a   001205 0000 00   1149  	arg	bad_area_format_name
    001162  aa   000004 000000    1150  length:	zero	4,0
    001163  aa   000007 000000    1151  	zero	7,0
    001164  aa   000027 000000    1152  	zero	23,0
    001165  aa   000023 000000    1153  	zero	19,0
    001166  aa   000017 000000    1154  	zero	15,0
    001167  aa  141 162 145 141   1155  area_name:	aci	"area"
    001170  aa  163 164 157 162   1156  storage_name:	aci	"storage"
    001171  aa  141 147 145 000
    001172  aa  142 141 144 137   1157  area_init_name:	aci	"bad_area_initialization"
    001173  aa  141 162 145 141
    001174  aa  137 151 156 151
    001175  aa  164 151 141 154
    001176  aa  151 172 141 164
    001177  aa  151 157 156 000
    001200  aa  142 141 144 137   1158  bad_assign_name:	aci	"bad_area_assignment"
    001201  aa  141 162 145 141
    001202  aa  137 141 163 163
    001203  aa  151 147 156 155
    001204  aa  145 156 164 000
    001205                        1159  bad_area_format_name:
    001205  aa  142 141 144 137   1160  		aci	"bad_area_format"
    001206  aa  141 162 145 141
    001207  aa  137 146 157 162
    001210  aa  155 141 164 000
                                  1161  
                                  1162  	end
ENTRY SEQUENCES
     
    001211  5a   000131 0000 00
    001212  aa  7 00046 2721 20
    001213  0a   000021 7100 00
    001214  5a   000123 0000 00
    001215  aa  7 00046 2721 20
    001216  0a   000017 7100 00
    001217  5a   000116 0000 00
    001220  aa  7 00046 2721 20
    001221  0a   000631 7100 00
    001222  5a   000111 0000 00
    001223  aa  7 00046 2721 20
    001224  0a   000433 7100 00
    001225  5a   000102 0000 00
    001226  aa  7 00046 2721 20
    001227  0a   000516 7100 00
    001230  5a   000074 0000 00
    001231  aa  7 00046 2721 20
    001232  0a   000477 7100 00
    001233  5a   000067 0000 00
    001234  aa  7 00046 2721 20
    001235  0a   000501 7100 00
    001236  5a   000062 0000 00
    001237  aa  7 00046 2721 20
    001240  0a   000505 7100 00
    001241  5a   000054 0000 00
    001242  aa  7 00046 2721 20
    001243  0a   000021 7100 00
    001244  5a   000046 0000 00
    001245  aa  7 00046 2721 20
    001246  0a   000631 7100 00
    001247  5a   000040 0000 00
    001250  aa  7 00046 2721 20
    001251  0a   000433 7100 00
LITERALS
     
    001252  aa   077777 000043 
    001253  aa   000001 000000 
NAME DEFINITIONS FOR ENTRY POINTS AND SEGDEFS

    001254  5a   000003 000000 
    001255  5a   000145 600000 
    001256  aa   000000 000000 
    001257  55   000010 000002 
    001260  5a   000002 400003 
    001261  55   000006 000010 
    001262  aa  006 141 154 154
    001263  aa  157 143 137 000
    001264  55   000016 000003 
    001265  0a   000503 400000 
    001266  55   000013 000003 
    001267  aa  011 157 160 137         op_empty_
    001270  aa  145 155 160 164
    001271  aa  171 137 000 000
    001272  55   000024 000010 
    001273  0a   000663 400000 
    001274  55   000021 000003 
    001275  aa  011 157 160 137         op_freen_
    001276  aa  146 162 145 145
    001277  aa  156 137 000 000
    001300  55   000032 000016 
    001301  0a   000000 400000 
    001302  55   000027 000003 
    001303  aa  013 157 160 137         op_storage_
    001304  aa  163 164 157 162
    001305  aa  141 147 145 137
    001306  55   000040 000024 
    001307  0a   000002 400000 
    001310  55   000035 000003 
    001311  aa  011 157 160 137         op_alloc_
    001312  aa  141 154 154 157
    001313  aa  143 137 000 000
    001314  55   000046 000032 
    001315  0a   001250 500000 
    001316  55   000043 000003 
    001317  aa  011 157 154 144         old_area_
    001320  aa  137 141 162 145
    001321  aa  141 137 000 000
    001322  55   000054 000040 
    001323  0a   001245 500000 
    001324  55   000051 000003 
    001325  aa  012 157 154 144         old_freen_
    001326  aa  137 146 162 145
    001327  aa  145 156 137 000
    001330  55   000062 000046 
    001331  0a   001242 500000 
    001332  55   000057 000003 
    001333  aa  012 157 154 144         old_alloc_
    001334  aa  137 141 154 154
    001335  aa  157 143 137 000
    001336  55   000067 000054 
    001337  0a   001237 500000 
    001340  55   000065 000003 
    001341  aa  005 162 145 144         redef
    001342  aa  145 146 000 000
    001343  55   000074 000062 
    001344  0a   001234 500000 
    001345  55   000072 000003 
    001346  aa  006 145 170 164         extend
    001347  aa  145 156 144 000
    001350  55   000102 000067 
    001351  0a   001231 500000 
    001352  55   000077 000003 
    001353  aa  012 156 157 137         no_freeing
    001354  aa  146 162 145 145
    001355  aa  151 156 147 000
    001356  55   000111 000074 
    001357  0a   001226 500000 
    001360  55   000105 000003 
    001361  aa  014 141 162 145         area_assign_
    001362  aa  141 137 141 163
    001363  aa  163 151 147 156
    001364  aa  137 000 000 000
    001365  55   000116 000102 
    001366  0a   001223 500000 
    001367  55   000114 000003 
    001370  aa  005 141 162 145         area_
    001371  aa  141 137 000 000
    001372  55   000123 000111 
    001373  0a   001220 500000 
    001374  55   000121 000003 
    001375  aa  006 146 162 145         freen_
    001376  aa  145 156 137 000
    001377  55   000131 000116 
    001400  0a   001215 500000 
    001401  55   000126 000003 
    001402  aa  010 163 164 157         storage_
    001403  aa  162 141 147 145
    001404  aa  137 000 000 000
    001405  55   000136 000123 
    001406  0a   001212 500000 
    001407  55   000134 000003 
    001410  aa  006 141 154 154         alloc_
    001411  aa  157 143 137 000
    001412  55   000002 000131 
    001413  6a   000000 400002 
    001414  55   000141 000003 
    001415  aa  014 163 171 155         symbol_table
    001416  aa  142 157 154 137
    001417  aa  164 141 142 154
    001420  aa  145 000 000 000

DEFINITIONS HASH TABLE

    001421  aa   000000 000033 
    001422  5a   000062 000000 
    001423  aa   000000 000000 
    001424  5a   000024 000000 
    001425  5a   000074 000000 
    001426  5a   000010 000000 
    001427  5a   000016 000000 
    001430  5a   000032 000000 
    001431  5a   000116 000000 
    001432  aa   000000 000000 
    001433  aa   000000 000000 
    001434  5a   000067 000000 
    001435  5a   000131 000000 
    001436  5a   000046 000000 
    001437  5a   000040 000000 
    001440  5a   000054 000000 
    001441  5a   000136 000000 
    001442  aa   000000 000000 
    001443  aa   000000 000000 
    001444  5a   000102 000000 
    001445  aa   000000 000000 
    001446  aa   000000 000000 
    001447  5a   000123 000000 
    001450  aa   000000 000000 
    001451  aa   000000 000000 
    001452  aa   000000 000000 
    001453  5a   000111 000000 
    001454  aa   000000 000000 

EXTERNAL NAMES

    001455  aa  014 143 141 154         call_signal_
    001456  aa  154 137 163 151
    001457  aa  147 156 141 154
    001460  aa  137 000 000 000
    001461  aa  016 160 154 061         pl1_operators_
    001462  aa  137 157 160 145
    001463  aa  162 141 164 157
    001464  aa  162 163 137 000
    001465  aa  014 142 165 144         buddy_freen_
    001466  aa  144 171 137 146
    001467  aa  162 145 145 156
    001470  aa  137 000 000 000
    001471  aa  022 142 165 144         buddy_area_assign_
    001472  aa  144 171 137 141
    001473  aa  162 145 141 137
    001474  aa  141 163 163 151
    001475  aa  147 156 137 000
    001476  aa  013 142 165 144         buddy_redef
    001477  aa  144 171 137 162
    001500  aa  145 144 145 146
    001501  aa  013 142 165 144         buddy_area_
    001502  aa  144 171 137 141
    001503  aa  162 145 141 137
    001504  aa  024 164 145 155         template_area_header
    001505  aa  160 154 141 164
    001506  aa  145 137 141 162
    001507  aa  145 141 137 150
    001510  aa  145 141 144 145
    001511  aa  162 000 000 000
    001512  aa  022 147 145 164         get_next_area_ptr_
    001513  aa  137 156 145 170
    001514  aa  164 137 141 162
    001515  aa  145 141 137 160
    001516  aa  164 162 137 000
    001517  aa  016 142 165 144         buddy_storage_
    001520  aa  144 171 137 163
    001521  aa  164 157 162 141
    001522  aa  147 145 137 000
    001523  aa  014 142 165 144         buddy_alloc_
    001524  aa  144 171 137 141
    001525  aa  154 154 157 143
    001526  aa  137 000 000 000

NO TRAP POINTER WORDS

TYPE PAIR BLOCKS

    001527  aa   000004 000000 
    001530  55   000205 000201 
    001531  aa   000004 000000 
    001532  55   000211 000211 
    001533  aa   000004 000000 
    001534  55   000215 000215 
    001535  aa   000004 000000 
    001536  55   000225 000222 
    001537  aa   000004 000000 
    001540  55   000230 000230 
    001541  aa   000004 000000 
    001542  55   000236 000236 
    001543  aa   000004 000000 
    001544  55   000247 000243 
    001545  aa   000004 000000 
    001546  55   000247 000247 
    001547  aa   000001 000000 
    001550  aa   000000 000000 

INTERNAL EXPRESSION WORDS

    001551  5a   000253 000000 
    001552  5a   000255 000000 
    001553  5a   000257 000000 
    001554  5a   000261 000000 
    001555  5a   000263 000000 
    001556  5a   000265 000000 
    001557  5a   000267 000000 
    001560  5a   000271 000000 
    001561  aa   000000 000000 
LINKAGE INFORMATION
      
    000000  aa   000000 000000 
    000001  0a   001254 000000 
    000002  aa   000000 000000 
    000003  aa   000000 000000 
    000004  aa   000000 000000 
    000005  aa   000000 000000 
    000006  22   000010 000030 
    000007  a2   000000 000000 
    000010  9a   777770 0000 46         buddy_alloc_|buddy_alloc_
    000011  5a   000304 0000 00
    000012  9a   777766 0000 46         buddy_alloc_|buddy_storage_
    000013  5a   000303 0000 00
    000014  9a   777764 0000 46         get_next_area_ptr_|get_next_area_ptr_
    000015  5a   000302 0000 00
    000016  9a   777762 0000 46         template_area_header|template_area_header
    000017  5a   000301 0000 00
    000020  9a   777760 0000 46         buddy_area_|buddy_redef
    000021  5a   000300 0000 00
    000022  9a   777756 0000 46         buddy_area_assign_|buddy_area_assign_
    000023  5a   000277 0000 00
    000024  9a   777754 0000 46         buddy_freen_|buddy_freen_
    000025  5a   000276 0000 00
    000026  9a   777752 0000 46         pl1_operators_|call_signal_
    000027  5a   000275 0000 00
SYMBOL INFORMATION
     
SYMBOL TABLE HEADER
     
    000000  aa   000000 000001 
    000001  aa   163171 155142 
    000002  aa   164162 145145 
    000003  aa   000000 000010 
    000004  aa   000000 117244 
    000005  aa   361023 525721 
    000006  aa   000000 117547 
    000007  aa   254634 331473 
    000010  aa   141154 155040 
    000011  aa   040040 040040 
    000012  aa   000024 000040 
    000013  aa   000034 000040 
    000014  aa   000044 000100 
    000015  aa   000002 000002 
    000016  aa   000064 000000 
    000017  aa   000000 000316 
    000020  aa   000000 000152 
    000021  aa   000252 000244 
    000022  aa   000306 000152 
    000023  aa   000064 000000 
    000024  aa   101114 115040 
    000025  aa   126145 162163 
    000026  aa   151157 156040 
    000027  aa   070056 061064 
    000030  aa   040115 141162 
    000031  aa   143150 040061 
    000032  aa   071070 071040 
    000033  aa   040040 040040 
    000034  aa   110151 162156 
    000035  aa   145151 163145 
    000036  aa   156056 123171 
    000037  aa   163115 141151 
    000040  aa   156164 056141 
    000041  aa   040040 040040 
    000042  aa   040040 040040 
    000043  aa   040040 040040 
    000044  aa   055164 141162 
    000045  aa   147145 164040 
    000046  aa   154066 070040 
    000047  aa   040040 040040 
    000050  aa   040040 040040 
    000051  aa   040040 040040 
    000052  aa   040040 040040 
    000053  aa   040040 040040 
    000054  aa   040040 040040 
    000055  aa   040040 040040 
    000056  aa   040154 151163 
    000057  aa   164040 163171 
    000060  aa   155142 157154 
    000061  aa   163040 040040 
    000062  aa   040040 040040 
    000063  aa   040040 040040 
    000064  aa   000000 000001 
    000065  aa   000000 000004 
    000066  aa   000106 000035 
    000067  aa   175453 017763 
    000070  aa   000000 117547 
    000071  aa   176662 600000 
    000072  aa   000116 000045 
    000073  aa   103015 557506 
    000074  aa   000000 110304 
    000075  aa   654042 600000 
    000076  aa   000130 000041 
    000077  aa   052721 247134 
    000100  aa   000000 105272 
    000101  aa   317215 400000 
    000102  aa   000141 000042 
    000103  aa   147777 464111 
    000104  aa   000000 115000 
    000105  aa   507463 000000 
    000106  aa   076163 160145          >spec>install>1110>alloc_.alm
    000107  aa   143076 151156 
    000110  aa   163164 141154 
    000111  aa   154076 061061 
    000112  aa   061060 076141 
    000113  aa   154154 157143 
    000114  aa   137056 141154 
    000115  aa   155040 040040 
    000116  aa   076154 144144          >ldd>include>area_structures.incl.alm
    000117  aa   076151 156143 
    000120  aa   154165 144145 
    000121  aa   076141 162145 
    000122  aa   141137 163164 
    000123  aa   162165 143164 
    000124  aa   165162 145163 
    000125  aa   056151 156143 
    000126  aa   154056 141154 
    000127  aa   155040 040040 
    000130  aa   076154 144144          >ldd>include>stack_frame.incl.alm
    000131  aa   076151 156143 
    000132  aa   154165 144145 
    000133  aa   076163 164141 
    000134  aa   143153 137146 
    000135  aa   162141 155145 
    000136  aa   056151 156143 
    000137  aa   154056 141154 
    000140  aa   155040 040040 
    000141  aa   076154 144144          >ldd>include>stack_header.incl.alm
    000142  aa   076151 156143 
    000143  aa   154165 144145 
    000144  aa   076163 164141 
    000145  aa   143153 137150 
    000146  aa   145141 144145 
    000147  aa   162056 151156 
    000150  aa   143154 056141 
    000151  aa   154155 040040 
               MULTICS ASSEMBLY CROSS REFERENCE LISTING

   Value        Symbol                   Source file   Line number

          21    alloc_                   alloc_:       171,  263.
           2    alloc_blkhdrsz           alloc_:       352,  544,
                                         area_structures:     67.
        1044    all_done                 alloc_:      1033, 1035, 1038, 1098.
           4    area.allocation_method   alloc_:       253,  271,  663,  746, 1141,
                                         area_structures:     35.
          25    area.allocation_p_clock  alloc_:       368,  370,  407,  439,  932,  934,
                                         area_structures:     46.
       20000    area.defined_by_call     area_structures:     31.
       40000    area.dont_free           alloc_:       660,  871,
                                         area_structures:     30.
      400000    area.extend              alloc_:       541,  576,  670,
                                         area_structures:     27.
          26    area.extend_info         alloc_:       607,  675,
                                         area_structures:     48.
           3    area.flags               alloc_:       515,  540,  575,  661,  671,  741,  870,  921,
                                         area_structures:     25.
           7    area.freep               alloc_:       389,  391,  424,  447, 1024, 1031, 1032, 1037, 1042, 1057, 1063, 1070,
                                                      1072, 1075,
                                         area_structures:     41.
           6    area.last_block          alloc_:       495,  496,  676,  938,  962,  964,  973, 1085, 1091, 1092,
                                         area_structures:     39.
           5    area.last_size           alloc_:       493,  505,  677, 1088,
                                         area_structures:     37.
           1    area.last_usable         alloc_:       295,  488,  610,  611,  653,  705,  738,  752,  760,  764,  771,  785,
                                                       806,
                                         area_structures:     21.
           7    area.max_block_size      area_structures:     44.
           0    area.mbz_shift           area_structures:     33.
           2    area.next_virgin         alloc_:       292,  293,  297,  489,  492,  497,  500,  507,  508,  612,  613,  673,
                                                       674,  703,  737, 1086,
                                         area_structures:     23.
          27    area.n_allocated         alloc_:       512,  875,
                                         area_structures:     51.
          27    area.n_free              alloc_:       443, 1039,
                                         area_structures:     52.
          26    area.recovery_info       area_structures:     49.
           7    area.relp                area_structures:     43.
       10000    area.system              area_structures:     32.
           0    area.version             alloc_:       248,  266,  699,  731,  734,  788,  794,
                                         area_structures:     19.
      200000    area.zero_on_alloc       alloc_:       516,  744,
                                         area_structures:     28.
      100000    area.zero_on_free        alloc_:       742,  922,
                                         area_structures:     29.
         434    areajoin                 alloc_:       641,  688,  691.
         433    area_                    alloc_:       171,  640.
         516    area_assign_             alloc_:       171,  725.
        1172    area_init_name           alloc_:      1147, 1157.
        1167    area_name                alloc_:      1145, 1155.
          30    area_size                alloc_:       544,  578,  650,  651,  782,  783,  803,  804,
                                         area_structures:     17.
           1    area_version_1           area_structures:     12.
          70    arglist                  alloc_:       195,  321,  323,  325,  327,  329,  556,  558,  560,  561,  588,  590,
                                                       592,  593,  892,  899,  900.
         542    assign_and_fill          alloc_:       743,  751.
         552    assign_no_fill           alloc_:       745,  748,  763.
        1205    bad_area_format_name     alloc_:      1149, 1159.
        1200    bad_assign_name          alloc_:      1148, 1158.
           2    block.bp                 alloc_:      1026, 1027, 1030, 1044, 1065, 1069,
                                         area_structures:     97.
         377    block.buddy_pad_mask     area_structures:     86.
          34    block.buddy_pad_shift    area_structures:     85.
           1    block.buddy_pad_word     area_structures:     84.
           0    block.cur_size           alloc_:       409,  460,  467,  506, 1000, 1059,
                                         area_structures:     82.
           2    block.fp                 alloc_:       415, 1028, 1029, 1043, 1064, 1066, 1068,
                                         area_structures:     96.
           1    block.header             alloc_:       462,  466,  501,  865,
                                         area_structures:     94.
         400    block.marked             area_structures:     90.
           1    block.marked_word        area_structures:     89.
        1000    block.prev_busy          alloc_:       465,  483,  502,  936,  981, 1002,
                                         area_structures:     88.
           1    block.prev_busy_word     alloc_:       484,  503,  980, 1003,
                                         area_structures:     87.
           0    block.prev_size          alloc_:       455,  469,  494,  948, 1001, 1087,
                                         area_structures:     81.
         377    block.q_no_mask          alloc_:      1056,
                                         area_structures:     93.
          22    block.q_no_shift         area_structures:     92.
           1    block.q_no_word          alloc_:      1021, 1055,
                                         area_structures:     91.
          12    blocksize                alloc_:       185,  920,  935,  950,  951,  988,  989,  999, 1009, 1034, 1036, 1045, 1094.
           3    block_size               area_structures:     79.
         526    both_are_new             alloc_:       736,  795,  807.
          65    buddy_alloc              alloc_:       267,  304.
                buddy_alloc_             alloc_:       308,  309.
          71    buddy_alloc_op           alloc_:       249,  311.
           3    buddy_area.inited        alloc_:       169,  775,  790,  796.
           2    buddy_area.size          alloc_:       168,  778,  799.
                buddy_area_              alloc_:       700.
                buddy_area_assign_       alloc_:       791.
                buddy_freen_             alloc_:       854,  902.
                buddy_redef              alloc_:       700.
                buddy_storage_           alloc_:       309.
        1170    call_offset              stack_header:        80.
                call_signal_             alloc_:      1132.
         757    check_next               alloc_:       940,  972.
         263    correct_size             alloc_:       454,  482.
         330    dont_zero                alloc_:       517,  527.
          54    dtemp1                   alloc_:       193,  315,  322.
          56    dtemp2                   alloc_:       194,  324,  335.
        1047    empty                    alloc_:      1025, 1042.
        1174    entry_offset             stack_header:        84.
         501    extend                   alloc_:       171,  689.
         461    extend_area              alloc_:       657,  669.
           0    extend_block.first_area  alloc_:       608,  680,
                                         area_structures:     62.
           3    extend_block.name        area_structures:     65.
           1    extend_block.next_area   alloc_:       679,
                                         area_structures:     63.
           2    extend_block.sequence_no       area_structures:     64.
          14    extend_block_size        alloc_:       544,  578,  672,
                                         area_structures:     60.
         631    freen_                   alloc_:       171,  850.
         705    freen_1                  alloc_:       477,  876,  913.
          17    free_count               alloc_:       192,  917,  947,  987, 1038, 1084.
        1101    free_last_block          alloc_:       939,  966, 1082.
         232    free_merge               alloc_:       448.
         656    free_ret                 alloc_:       872,  877.
                get_next_area_ptr_       alloc_:       563,  595.
          67    get_ptr                  alloc_:       305,  308,  328.
         221    large_enough             alloc_:       411,  432.
        1077    last_free                alloc_:      1067, 1075.
        1162    length                   alloc_:      1130, 1150.
          10    lsize                    alloc_:       183,  360,  393,  410,  452,  459,  461,  468,  490.
           1    max_method               alloc_:       201,  256,  274.
          15    max_size                 alloc_:       190,  397,  412,  414,  423.
           1    max_version              alloc_:       200,  251,  269.
          10    min_block_size           alloc_:       198,  349,  357,  359,  453,
                                         area_structures:     99.
        1155    name                     alloc_:      1129, 1145.
         573    new_is_buddy             alloc_:       776,  787.
         561    new_is_buddy_or_empty    alloc_:       732,  774.
         524    new_is_new               alloc_:       733,  786.
        1003    next_busy                alloc_:       974,  982,  997.
         215    next_stratum             alloc_:       390,  394,  425.
         213    next_stratum_1           alloc_:       417,  422.
        1065    not_big                  alloc_:      1061, 1064.
         756    not_last                 alloc_:       963,  968.
         723    not_zof                  alloc_:       923,  930.
         477    no_freeing               alloc_:       171,  686.
           1    NO_FREEING_ALLOCATION_METHOD   alloc_:       747,
                                               area_structures:     55.
          36    no_free_alloc            alloc_:       277.
          50    no_free_alloc_op         alloc_:       258,  289,  614.
         453    no_free_area             alloc_:       656,  659.
          10    no_free_area.current_component       alloc_:       298,  587,  609,  662,
                                                     area_structures:     74.
          12    no_free_area_size        area_structures:     72.
         335    no_room                  alloc_:       491,  539.
         372    no_room_no_free          alloc_:       294,  296,  574.
          21    old_alloc_               alloc_:       172,  262.
         433    old_area_                alloc_:       172,  639.
         631    old_freen_               alloc_:       172,  849.
         600    old_is_buddy_or_empty    alloc_:       735,  793.
           2    op_alloc_                alloc_:       173,  245.
         503    op_empty_                alloc_:       173,  693.
         663    op_freen_                alloc_:       173,  884.
         644    op_freen_join            alloc_:       861,  887.
         441    op_join                  alloc_:       646,  695.
           0    op_storage_              alloc_:       173,  242.
        1043    out                      alloc_:      1037, 1046.
                pl1_operators_           alloc_:      1132.
         734    prev_free                alloc_:       937,  941.
        1171    push_offset              stack_header:        81.
         505    redef                    alloc_:       171,  697.
         146    retry_alloc              alloc_:       367,  408,  440,  570,  572.
         127    retry_alloc_after_area   alloc_:       346, 1142.
          46    retry_no_free_alloc_after_area       alloc_:       285, 1143.
        1173    return_no_pop_offset     stack_header:        83.
        1172    return_offset            stack_header:        82.
         313    return_ptr               alloc_:       480,  485,  510.
          76    ret_bp                   alloc_:       197,  559,  568,  589,  606.
          11    rsize                    alloc_:       184,  362,  379,  464,  504,  519,  543.
          70    saved_p_clock            alloc_:       196,  371,  405,  438.
          16    save_bp                  alloc_:       191,  474,  478,  553,  557.
          14    save_x0                  alloc_:       189,  549,  565.
          14    save_x2                  alloc_:       187,  475,  479.
          14    save_x6                  alloc_:       188, 1123, 1137.
        1125    signal_area              alloc_:       354,  542,  545,  577,  579,  825, 1110, 1113, 1116.
        1124    signal_area_1            alloc_:      1114.
        1122    signal_area_2            alloc_:      1111.
        1120    signal_area_3            alloc_:       250,  252,  254,  257,  420, 1108.
         623    signal_area_p            alloc_:       811,  814,  817,  820.
         614    signal_area_p0           alloc_:       704,  740,  809.
         616    signal_area_p1           alloc_:       645,  812.
         620    signal_area_p2           alloc_:       789,  792,  797,  815.
         622    signal_area_p3           alloc_:       268,  270,  272,  275,  818.
        1132    signal_for_subr          alloc_:      1118, 1122.
        1137    signal_join              alloc_:      1121, 1128.
          73    stach_header.trace_top_ptr     stack_header:        62.
          32    stack_frame.arg_ptr      alloc_:       571,  602, 1138,
                                         stack_frame:   16.
         100    stack_frame.condition_bit      stack_frame:   32.
          20    stack_frame.condition_word     stack_frame:    9.
        2000    stack_frame.crawl_out_bit      stack_frame:   28.
          26    stack_frame.entry_ptr    stack_frame:   13.
          20    stack_frame.flag_word    alloc_:       280,  341,  823,  857,
                                         stack_frame:   24.
         400    stack_frame.link_trap_bit      stack_frame:   30.
          30    stack_frame.lp_ptr       stack_frame:   15.
       20000    stack_frame.main_proc_bit      stack_frame:   25.
          60    stack_frame.min_length   stack_frame:   23.
          22    stack_frame.next_sp      stack_frame:   10.
          36    stack_frame.on_unit_rel_ptrs   stack_frame:   19.
          30    stack_frame.operator_ptr       stack_frame:   14.
          37    stack_frame.operator_ret_ptr   alloc_:      1120, 1125, 1133,
                                               stack_frame:   20.
          20    stack_frame.prev_sp      stack_frame:    8.
          40    stack_frame.regs         stack_frame:   22.
          24    stack_frame.return_ptr   alloc_:       330,  334,  562,  567,  594,  599,  901,  905,
                                         stack_frame:   12.
       10000    stack_frame.run_unit_manager   stack_frame:   26.
        1000    stack_frame.signaller_bit      stack_frame:   29.
          22    stack_frame.signaller_word     stack_frame:   11.
        4000    stack_frame.signal_bit   stack_frame:   27.
          34    stack_frame.static_ptr   stack_frame:   17.
         200    stack_frame.support_bit  alloc_:       279,  340,  822,  856,
                                         stack_frame:   31.
          35    stack_frame.support_ptr  stack_frame:   18.
          37    stack_frame.translator_id      stack_frame:   21.
          66    stack_header.assign_linkage_ptr      stack_header:        59.
          32    stack_header.bar_mode_sp       stack_header:        42.
          36    stack_header.call_op_ptr       stack_header:        44.
          10    stack_header.clr_ptr     stack_header:        27.
           6    stack_header.combined_stat_ptr       stack_header:        25.
           4    stack_header.cpm_data_ptr      stack_header:        24.
          13    stack_header.cpm_enabled       stack_header:        32.
          13    stack_header.cur_lot_size      stack_header:        31.
          64    stack_header.ect_ptr     stack_header:        58.
          46    stack_header.entry_op_ptr      stack_header:        49.
          70    stack_header.heap_header_ptr   stack_header:        60.
          74    stack_header.in_trace    stack_header:        63.
          52    stack_header.isot_ptr    stack_header:        52.
          26    stack_header.lot_ptr     alloc_:       319,  552,  586,  896,
                                         stack_header:        39.
          12    stack_header.main_proc_invoked       stack_header:        29.
          12    stack_header.max_lot_size      stack_header:        28.
          20    stack_header.parent_ptr  stack_header:        36.
          34    stack_header.pl1_operators_ptr       stack_header:        43.
          40    stack_header.push_op_ptr       stack_header:        46.
          42    stack_header.return_op_ptr     stack_header:        47.
          44    stack_header.ret_no_pop_op_ptr       stack_header:        48.
          62    stack_header.rnt_ptr     stack_header:        57.
          12    stack_header.run_unit_depth    stack_header:        30.
          54    stack_header.sct_ptr     stack_header:        53.
          30    stack_header.signal_ptr  stack_header:        41.
          22    stack_header.stack_begin_ptr   stack_header:        37.
          24    stack_header.stack_end_ptr     stack_header:        38.
          14    stack_header.system_free_ptr   stack_header:        33.
          60    stack_header.sys_link_info_ptr       stack_header:        56.
          72    stack_header.trace_frames      stack_header:        61.
          50    stack_header.trans_op_tv_ptr   stack_header:        51.
          56    stack_header.unwinder_ptr      stack_header:        54.
          16    stack_header.user_free_ptr     stack_header:        34.
         100    stack_header_end         stack_header:        64.
         117    standard_alloc           alloc_:       273,  338.
           0    STANDARD_ALLOCATION_METHOD     area_structures:     54.
         133    standard_alloc_op        alloc_:       255,  351.
         474    standard_area            alloc_:       655,  665,  681.
          17    storage_                 alloc_:       171,  260.
        1170    storage_name             alloc_:      1146, 1156.
         163    stratum_loop             alloc_:       386,  388,  428.
          46    tbp                      alloc_:       167,  282,  300,  333,  336,  343,  530,  566,  598,  683,  881,  904,
                                                       906, 1127, 1135.
          13    temp                     alloc_:       186,  382,  383,  395,  416,  449,  450,  451,  949,  959,  977,  979,
                                                      1011, 1012, 1015, 1016, 1058, 1060.
                template_area_header     alloc_:       648,  777,  798.
         175    test_size                alloc_:       406,  419.
           0    trace_frames.count       stack_header:        69.
           1    trace_frames.top_ptr     stack_header:        70.
         171    try                      alloc_:       392,  395.
         551    tv_offset                stack_header:        75,   80,   81,   82,   83,   84.
        1054    unthread                 alloc_:       445,  960,  990, 1054.
         266    use_virgin               alloc_:       429,  487.


NO FATAL ERRORS


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
