	COMPILATION LISTING OF SEGMENT pathname_am
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1008.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 /*
       15*   Written March 1975 by R. Bratt
       16*
       17*   Last Modified:
       18*
       19*   Janurary 30 1976 by R. Bratt to flush pam on directory renames and deletions
       20*   May 31 1976 by R. Bratt to implement kst garbage collection
       21*   November 1984 by Keith Loepere to move pam flush buffer to 
       22*     active_hardcore_data.  Also to change to using uid based flushing,
       23*     instead of hierarchy depth.
       24*
       25*   pathname_am  provides an associative memory to remember the correspondence
       26*   between pathnames and directory segment numbers in a process. This associative
       27*   memory is  managed by an lru algorithm.
       28*
       29*   pathname_am$set places a pathname, segment number pair in the associative memory
       30*   USAGE: call pathname_am$set (pathname, segnum);
       31*
       32*   pathname_am$get_segno gets the segment number given a pathname
       33*   USAGE: call pathname_am$get_segno (pathname, segnum);
       34*   NOTE: since segment number associations kept in the pathname associative
       35*   memory are not immune to garbage collection we increment a segment number's
       36*   usage count before returning it.  
       37*
       38*   pathname_am$get_path gets the pathname given a segment number
       39*   USAGE: call pathname_am$get_path (pathname, segnum);
       40*
       41*   pathname_am$clear clears all associations between pathnames and a given segment number
       42*   USAGE: call pathname_am$clear (segnum);
       43*
       44*   pathname_am$flush causes a global flush from a given uid
       45*   USAGE: call pathname_am$flush (uid);
       46*
       47*   pathname char(*) varying --- pathname (no trailing blanks allowed)
       48*   segnum fixed bin(17) --- segment number
       49*   uid bit (36) aligned --- uid of directory
       50*
       51**/
       52 pathname_am: proc;
       53 
       54 /* Parameters */
       55 
       56 dcl  a_pname			char (*) varying parameter;
       57 dcl  a_segnum			fixed bin (17) parameter;
       58 dcl  a_uid			bit (36) aligned parameter;
       59 
       60 /* Variables */
       61 
       62 dcl  flush_level			fixed bin (35);
       63 dcl  hash_slot			fixed bin;
       64 dcl  pam_index			fixed bin;
       65 dcl  plen				fixed bin;
       66 dcl  prevp			ptr;
       67 
       68 /* Entries */
       69 
       70 dcl  kstsrch			entry (bit (36) aligned, fixed bin (17), ptr);
       71 dcl  segno_usage$increment		entry (fixed bin (17), fixed bin (35));
       72 
       73 /* Misc */
       74 
       75 dcl  (addr, baseptr, dimension, length, mod, null, segno, stacq, substr) builtin;
       76 
       77 initialize: entry ();
       78 
       79 	amp = addr (pds$pathname_am);
       80 	call empty_pam;
       81 	pam.sets, pam.gets, pam.hits, pam.getps, pam.hitps, pam.rejects = 0;
       82 	pam.clears, pam.flushes, pam.overflows, pam.overflow_uids, pam.flushed = 0;
       83 	pam.initial_flush_level, pam.flush_level = active_hardcore_data$pam_flush_level;
       84 	return;
       85 
       86 get_segno: entry (a_pname, a_segnum);
       87 
       88 	call update_to_current_flush_level ();
       89 	plen = length (a_pname);
       90 	a_segnum = -1;
       91 	pam.gets = pam.gets + 1;
       92 	if plen > PAM_name_max_lth then return;
       93 	do amep = amp -> ame.fp repeat (ame.fp) while (amep ^= amp);
       94 	     if plen = ame.name_len then
       95 		if a_pname = substr (ame.name, 1, ame.name_len) then do;
       96 		     pam.hits = pam.hits + 1;
       97 		     call segno_usage$increment ((ame.segno), (0)); /* prevent garbage collection */
       98 		     a_segnum = ame.segno;
       99 		     call thread_to_head ();
      100 		     return;
      101 		end;
      102 	end;
      103 	return;
      104 
      105 get_path: entry (a_pname, a_segnum);
      106 
      107 	call update_to_current_flush_level ();
      108 	pam.getps = pam.getps + 1;
      109 	do amep = amp -> ame.fp repeat (ame.fp) while (amep ^= amp);
      110 	     if a_segnum = ame.segno then do;
      111 		pam.hitps = pam.hitps + 1;
      112 		a_pname = substr (ame.name, 1, ame.name_len);
      113 		call thread_to_head ();
      114 		return;
      115 	     end;
      116 	end;
      117 	a_pname = "";
      118 	return;
      119 
      120 set: entry (a_pname, a_segnum);
      121 
      122 	call update_to_current_flush_level ();
      123 	pam.sets = pam.sets + 1;
      124 	plen = length (a_pname);
      125 	if plen > PAM_name_max_lth then do;
      126 	     pam.rejects = pam.rejects + 1;
      127 	     return;
      128 	end;
      129 	amep = amp -> ame.bp;			/* take LRU entry */
      130 	ame.segno = a_segnum;
      131 	substr (ame.name, 1, plen) = a_pname;
      132 	ame.name_len = plen;
      133 	call thread_to_head ();
      134 	return;
      135 
      136 clear: entry (a_segnum);
      137 
      138 	amp = addr (pds$pathname_am);
      139 	pam.clears = pam.clears + 1;
      140 	do pam_index = 1 to dimension (pam.search, 1);
      141 	     if pam.search (pam_index).segno = a_segnum then do;
      142 		pam.cleared = pam.cleared + 1;
      143 		amep = addr (pam.search (pam_index));
      144 		ame.segno = 0;
      145 		ame.name_len = 0;
      146 		call thread_to_tail ();
      147 	     end;
      148 	end;
      149 	return;
      150 
      151 flush: entry (a_uid);
      152 
      153 /* The idea is to record in the circular pam_flush_buffer the uid of the 
      154*directory that was deleted/renamed.  Everyone must make sure no path in
      155*their pam contains this uid before they can use their pam again. */
      156 
      157 	amp = addr (pds$pathname_am);
      158 	do flush_level = active_hardcore_data$pam_flush_level + 1 repeat (active_hardcore_data$pam_flush_level + 1) while (^set_flush_level ());
      159 						/* get a flush buffer slot all to myself */
      160 	end;					/* set associated depth */
      161 	active_hardcore_data$pam_flush_buffer
      162 	     (mod (flush_level, dimension (active_hardcore_data$pam_flush_buffer, 1))) = a_uid;
      163 						/* make sure  others haven't caught up and eaten our slot */
      164 	do while (active_hardcore_data$pam_flush_level - flush_level
      165 	     > dimension (active_hardcore_data$pam_flush_buffer, 1));
      166 	     flush_level = active_hardcore_data$pam_flush_level; /* DAMN!!!! - system will have lost track of uids to flush */
      167 	     active_hardcore_data$pam_flush_buffer
      168 		(mod (flush_level, dimension (active_hardcore_data$pam_flush_buffer, 1))) = (36)"1"b; /* make sure the world knows */
      169 	end;
      170 	return;
      171 
      172 set_flush_level: proc () returns (bit (1) aligned);	/* try to store new flush_level */
      173 
      174 dcl  flush_level_minus_1		fixed bin (35);
      175 
      176 dcl  new_value			bit (36) aligned based (addr (flush_level));
      177 dcl  old_value			bit (36) aligned based (addr (flush_level_minus_1));
      178 dcl  word				bit (36) aligned based (addr (active_hardcore_data$pam_flush_level));
      179 
      180 	flush_level_minus_1 = flush_level - 1;
      181 	return (stacq (word, new_value, old_value));
      182      end;
      183 
      184 empty_pam: proc;
      185 
      186 	prevp = addr (pds$pathname_am);
      187 	do pam_index = 1 to dimension (pam.search, 1);
      188 	     amep = addr (pam.search (pam_index));
      189 	     prevp -> ame.fp = amep;
      190 	     ame.bp = prevp;
      191 	     ame.segno = 0;
      192 	     ame.name_len = 0;
      193 	     prevp = amep;
      194 	end;
      195 	prevp -> ame.fp = amp;
      196 	amp -> ame.bp = prevp;
      197 	return;
      198      end;
      199 
      200 thread_to_head: proc;
      201 
      202 	ame.fp -> ame.bp = ame.bp;			/* thread out */
      203 	ame.bp -> ame.fp = ame.fp;
      204 	ame.fp = amp -> ame.fp;			/* thread back in */
      205 	ame.bp = amp;
      206 	ame.bp -> ame.fp = amep;
      207 	ame.fp -> ame.bp = amep;
      208 	return;
      209      end thread_to_head;
      210 
      211 thread_to_tail: proc;
      212 
      213 	ame.fp -> ame.bp = ame.bp;			/*  thread out */
      214 	ame.bp -> ame.fp = ame.fp;
      215 	ame.bp = amp -> ame.bp;			/* thread back in */
      216 	ame.fp = amp;
      217 	ame.bp -> ame.fp = amep;
      218 	ame.fp -> ame.bp = amep;
      219 	return;
      220      end thread_to_tail;
      221 
      222 update_to_current_flush_level: proc;			/* catch up to global flush level */
      223 
      224 /* Actually, this sub-proc implements the logic to make sure that our pam
      225*doesn't contain any paths which contain a directory that was deleted or 
      226*renamed.  This is done by checking the uidpaths of the paths in our pam against
      227*the list of uids of directories that have been deleted/renamed system wide.
      228*If this list of uids is small enough, we can flush only certain paths.  If
      229*too many directories were deleted/renamed system wide to keep up with, we 
      230*are stuck flushing our entire pam. */
      231 
      232 dcl  ahd_flush_buffer_index		fixed bin;
      233 dcl  current_flush_level		fixed bin (35);
      234 dcl  entryp			ptr;
      235 dcl  num_uids_to_flush		fixed bin;
      236 dcl  pam_index			fixed bin;
      237 dcl  uid				bit (36) aligned;
      238 dcl  uids_to_flush			(15) bit (36) aligned; /* if more than this many uids match in addr space, not worth not flushing all */
      239 dcl  uids_to_flush_index		fixed bin;
      240 
      241 	amp = addr (pds$pathname_am);
      242 	current_flush_level = active_hardcore_data$pam_flush_level;
      243 	if current_flush_level = pam.flush_level then return;
      244 
      245 	if current_flush_level - pam.flush_level ^> dimension (active_hardcore_data$pam_flush_buffer, 1) then do;
      246 						/* not too many uids - looks like we can selectively flush */
      247 	     num_uids_to_flush = 0;
      248 	     do ahd_flush_buffer_index = pam.flush_level + 1 to current_flush_level;
      249 		uid = active_hardcore_data$pam_flush_buffer (mod (ahd_flush_buffer_index, dimension (active_hardcore_data$pam_flush_buffer, 1)));
      250 		if uid = (36)"1"b then go to overflow;
      251 		call kstsrch (uid, hash_slot, kstep);	/* quick check to see if we should consider uid */
      252 		if kstep ^= null then do;		/* appears in our addr space */
      253 		     if num_uids_to_flush >= dimension (uids_to_flush, 1) then do;
      254 			pam.overflow_uids = pam.overflow_uids + 1;
      255 			go to overflow;
      256 		     end;
      257 		     num_uids_to_flush = num_uids_to_flush + 1; /* add to list */
      258 		     uids_to_flush (num_uids_to_flush) = uid;
      259 		end;
      260 	     end;
      261 	     if active_hardcore_data$pam_flush_level - pam.flush_level
      262 		> dimension (active_hardcore_data$pam_flush_buffer, 1) then go to overflow; /* system overwrote where we were looking - sigh */
      263 	end;
      264 	else do;
      265 overflow:						/* complete flush required */
      266 	     pam.overflows = pam.overflows + 1;
      267 	     call empty_pam;
      268 	     pam.flush_level = current_flush_level;
      269 	     return;
      270 	end;
      271 
      272 	if num_uids_to_flush > 0 then do;
      273 	     kstp = pds$kstp;
      274 	     pam.flushes = pam.flushes + 1;
      275 	     do pam_index = 1 to dimension (pam.search, 1);
      276 		if pam.search (pam_index).segno > 0 then
      277 		     do entryp = baseptr (pam.search (pam_index).segno) repeat kste.entryp while (entryp ^= null);
      278 						/* check uid paths of all pam entries */
      279 		     kstep = addr (kst.kst_entry (segno (entryp)));
      280 		     do uids_to_flush_index = 1 to num_uids_to_flush;
      281 			if kste.uid = uids_to_flush (uids_to_flush_index) then do;
      282 			     amep = addr (pam.search (pam_index));
      283 						/* pam entry has a uid => directory in path that was deleted/renamed */
      284 			     pam.flushed = pam.flushed + 1;
      285 			     ame.segno = 0;
      286 			     ame.name_len = 0;
      287 			     call thread_to_tail ();
      288 			     go to next_pam_entry;
      289 			end;
      290 		     end;
      291 		end;
      292 next_pam_entry:
      293 	     end;
      294 	end;
      295 	pam.flush_level = current_flush_level;
      296 	return;
      297      end update_to_current_flush_level;
      298  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  1     2 
  1     3 /*
  1     4*Modified March 1976 by R. Bratt 
  1     5*Modified November 1984 to remove hdr, Keith Loepere. */
  1     6 
  1     7 
  1     8 /****^  HISTORY COMMENTS:
  1     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  1    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  1    11*     Add warning on use of kste.entryp.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 dcl  pds$kstp ext ptr,
  1    16     (kstp, kstep) ptr;
  1    17 
  1    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  1    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  1    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  1    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  1    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  1    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  1    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  1    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  1    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  1    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  1    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  1    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  1    30     2 unused_2 bit (9) unaligned,
  1    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  1    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  1    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  1    34     2 end_of_kst bit (36);
  1    35 
  1    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  1    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  1    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  1    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  1    40     2 entryp ptr unaligned,				/* branch pointer */
  1    41 						/* See WARNING below for requirements to use entryp. */
  1    42     2 uid bit (36) aligned,				/* unique identifier */
  1    43     2 access_information unaligned,
  1    44       3 dtbm bit (36),				/* date time branch modified */
  1    45       3 extended_access bit (33),			/* extended access from the branch */
  1    46       3 access bit (3),				/* rew */
  1    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  1    48     2 pad1 bit (3) unaligned,
  1    49     2 flags unaligned,
  1    50       3 dirsw bit (1),				/* directory switch */
  1    51       3 allow_write bit (1),				/* set if initiated with write permission */
  1    52       3 priv_init bit (1),				/* privileged initiation */
  1    53       3 tms bit (1),				/* transparent modification switch */
  1    54       3 tus bit (1),				/* transparent usage switch */
  1    55       3 tpd bit (1),				/* transparent paging device switch */
  1    56       3 audit bit (1),				/* audit switch */
  1    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  1    58       3 pad bit (3),
  1    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  1    60 
  1    61 
  1    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    63 /*							       */
  1    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  1    65 /* entry associated with the kst entry, you must first validate its value    */
  1    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  1    67 /* the containing directory.  The containing directory must remain locked    */
  1    68 /* during the entire period when kste.entryp and the directory entry are     */
  1    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  1    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  1    71 /* directory since the dir entry could have been moved within the directory  */
  1    72 /* by another processor.					       */
  1    73 /*							       */
  1    74 /* If you only need a pointer to the directory containing the associated     */
  1    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  1    76 /*    pointer (kste.entryp, 0)				       */
  1    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  1    78 /*							       */
  1    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    80 
  1    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      298 
      299  /* BEGIN INCLUDE FILE pathname_am.incl.pl1 MODIFIED Februrary 2, 1976 BY R. Bratt */
  2     2 /* Modified November 1984 by Keith Loepere to change PAM to use uid's. */
  2     3 
  2     4 dcl  active_hardcore_data$pam_flush_level fixed bin (34) ext,
  2     5      active_hardcore_data$pam_flush_buffer (0:31) bit (36) aligned ext;
  2     6 
  2     7 dcl  pds$pathname_am ext;
  2     8 
  2     9 dcl  PAM_name_max_lth fixed bin (17) static options (constant) init (68);
  2    10 
  2    11 dcl  amp ptr;
  2    12 dcl 1 pam aligned based (amp),
  2    13     2 (fp,					/* head of circular pam entry list */
  2    14      bp) ptr unaligned,
  2    15     2 (sets,					/* number of times a pathname was loaded into pam */
  2    16      gets,					/* number of requests for segno given pathname */
  2    17      hits,					/* number of sucessful searches for segno */
  2    18      getps,					/* number of requests for pathname given segno */
  2    19      hitps,					/* number of sucessful searches for pathname */
  2    20      rejects,					/* number of pathnames that were too big to fit in pam */
  2    21      clears,					/* number of times a directory was terminated */
  2    22      cleared,					/* number of entries wiped in clears */
  2    23      flushes,					/* number of times pam was flushed due to directory rename */
  2    24      flushed,					/* number of entries cleared in response to flushes */
  2    25      overflows,					/* number of times entire pam had to be flushed */
  2    26      overflow_uids,					/* number of times too many uids in flush buffer appeared in addr space */
  2    27      initial_flush_level,				/* global pam flush level at process creation time */
  2    28      flush_level) fixed bin (35),			/* last pam flush level seen */
  2    29     2 search (30) aligned,
  2    30       3 fp ptr unaligned,
  2    31       3 bp ptr unaligned,
  2    32       3 segno fixed bin (17) unaligned,
  2    33       3 name_len fixed bin (17) unaligned,
  2    34       3 name char (68);
  2    35 
  2    36 dcl  amep ptr;
  2    37 dcl 1 ame based (amep) like pam.search;
  2    38 
  2    39 /* END INCLUDE FILE pathname_am.incl.pl1             						*/
      299 
      300      end pathname_am;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.4  pathname_am.pl1                   >special_ldd>install>MR12.3-1114>pathname_am.pl1
298          1    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
299          2    01/30/85  1221.4  pathname_am.incl.pl1              >ldd>include>pathname_am.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
PAM_name_max_lth                       constant        fixed bin(17,0)          initial dcl 2-9 ref 92 125
a_pname                                parameter       varying char             dcl 56 set ref 86 89 94 105 112* 117* 120 124 131
a_segnum                               parameter       fixed bin(17,0)          dcl 57 set ref 86 90* 98* 105 110 120 130 136 141
a_uid                                  parameter       bit(36)                  dcl 58 ref 151 161
active_hardcore_data$pam_flush_buffer
                                000020 external static bit(36)                  array dcl 2-4 set ref 161* 161 164 167* 167 245 249
                                                                                  249 261
active_hardcore_data$pam_flush_level
                                000016 external static fixed bin(34,0)          dcl 2-4 set ref 83 158 160 164 166 181 242 261
addr                                                   builtin function         dcl 75 ref 79 138 143 157 181 181 181 186 188 241
                                                                                  279 282
ahd_flush_buffer_index          000160 automatic       fixed bin(17,0)          dcl 232 set ref 248* 249*
ame                                    based           structure                level 1 packed packed unaligned dcl 2-37
amep                            000114 automatic       pointer                  dcl 2-36 set ref 93* 93* 94 94 94 97 98* 102 109*
                                                                                  109* 110 112 112* 116 129* 130 131 132 143* 144
                                                                                  145 188* 189 190 191 192 193 202 202 203 203 204
                                                                                  205 206 206 207 207 213 213 214 214 215 216 217
                                                                                  217 218 218 282* 285 286
amp                             000112 automatic       pointer                  dcl 2-11 set ref 79* 81 81 81 81 81 81 82 82 82 82
                                                                                  82 83 83 91 91 93 93 96 96 108 108 109 109 111 111
                                                                                  123 123 126 126 129 138* 139 139 140 141 142 142
                                                                                  143 157* 187 188 195 196 204 205 215 216 241* 243
                                                                                  245 248 254 254 261 265 265 268 274 274 275 276
                                                                                  276 282 284 284 295
baseptr                                                builtin function         dcl 75 ref 276
cleared                  11            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 142* 142
clears                   10            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 82* 139* 139
current_flush_level             000161 automatic       fixed bin(35,0)          dcl 233 set ref 242* 243 245 248 268 295
dimension                                              builtin function         dcl 75 ref 140 161 164 167 187 245 249 253 261 275
entryp                          000162 automatic       pointer                  dcl 234 in procedure "update_to_current_flush_level"
                                                                                  set ref 276* 276* 279*
entryp                    3            based           pointer                  level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 1-36 in procedure "pathname_am" ref 291
flush_level              17            based           fixed bin(35,0)          level 2 in structure "pam" dcl 2-12 in procedure
                                                                                  "pathname_am" set ref 83* 243 245 248 261 268*
                                                                                  295*
flush_level                     000100 automatic       fixed bin(35,0)          dcl 62 in procedure "pathname_am" set ref 158* 161
                                                                                  164 166* 167 180 181
flush_level_minus_1             000126 automatic       fixed bin(35,0)          dcl 174 set ref 180* 181
flushed                  13            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 82* 284* 284
flushes                  12            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 82* 274* 274
getps                     5            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 108* 108
gets                      3            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 91* 91
hash_slot                       000101 automatic       fixed bin(17,0)          dcl 63 set ref 251*
hitps                     6            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 111* 111
hits                      4            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 96* 96
initial_flush_level      16            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 83*
kst                                    based           structure                level 1 dcl 1-18
kst_entry               110            based           structure                array level 2 dcl 1-18 set ref 279
kste                                   based           structure                level 1 dcl 1-36
kstep                           000110 automatic       pointer                  dcl 1-15 set ref 251* 252 279* 281 291
kstp                            000106 automatic       pointer                  dcl 1-15 set ref 273* 279
kstsrch                         000010 constant        entry                    external dcl 70 ref 251
length                                                 builtin function         dcl 75 ref 89 124
lowseg                                 based           fixed bin(17,0)          level 2 dcl 1-18 ref 279
mod                                                    builtin function         dcl 75 ref 161 167 249
new_value                              based           bit(36)                  dcl 176 ref 181
null                                                   builtin function         dcl 75 ref 252 276
num_uids_to_flush               000164 automatic       fixed bin(17,0)          dcl 235 set ref 247* 253 257* 257 258 272 280
old_value                              based           bit(36)                  dcl 177 ref 181
overflow_uids            15            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 82* 254* 254
overflows                14            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 82* 265* 265
pam                                    based           structure                level 1 dcl 2-12
pam_index                       000102 automatic       fixed bin(17,0)          dcl 64 in procedure "pathname_am" set ref 140* 141
                                                                                  143* 187* 188*
pam_index                       000165 automatic       fixed bin(17,0)          dcl 236 in procedure "update_to_current_flush_level"
                                                                                  set ref 275* 276 276 282*
pds$kstp                        000014 external static pointer                  dcl 1-15 ref 273
pds$pathname_am                 000022 external static fixed bin(17,0)          dcl 2-7 set ref 79 138 157 186 241
plen                            000103 automatic       fixed bin(17,0)          dcl 65 set ref 89* 92 94 124* 125 131 132
prevp                           000104 automatic       pointer                  dcl 66 set ref 186* 189 190 193* 195 196
rejects                   7            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 126* 126
search                   20            based           structure                array level 2 dcl 2-12 set ref 140 143 187 188 275
                                                                                  282
segno                                                  builtin function         dcl 75 in procedure "pathname_am" ref 279
segno                    22            based           fixed bin(17,0)          array level 3 in structure "pam" packed packed
                                                                                  unaligned dcl 2-12 in procedure "pathname_am" set
                                                                                  ref 141 276 276
segno_usage$increment           000012 constant        entry                    external dcl 71 ref 97
sets                      2            based           fixed bin(35,0)          level 2 dcl 2-12 set ref 81* 123* 123
stacq                                                  builtin function         dcl 75 ref 181
substr                                                 builtin function         dcl 75 set ref 94 112 131*
uid                             000166 automatic       bit(36)                  dcl 237 in procedure "update_to_current_flush_level"
                                                                                  set ref 249* 250 251* 258
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 1-36 in procedure
                                                                                  "pathname_am" ref 281
uids_to_flush                   000167 automatic       bit(36)                  array dcl 238 set ref 253 258* 281
uids_to_flush_index             000206 automatic       fixed bin(17,0)          dcl 239 set ref 280* 281*
word                                   based           bit(36)                  dcl 178 ref 181

NAMES DECLARED BY EXPLICIT CONTEXT.
clear                           000413 constant        entry                    external dcl 136
empty_pam                       000573 constant        entry                    internal dcl 184 ref 80 267
flush                           000472 constant        entry                    external dcl 151
get_path                        000213 constant        entry                    external dcl 105
get_segno                       000053 constant        entry                    external dcl 86
initialize                      000016 constant        entry                    external dcl 77
next_pam_entry                  001277 constant        label                    dcl 292 ref 288
overflow                        001152 constant        label                    dcl 265 ref 250 255 261
pathname_am                     000007 constant        entry                    external dcl 52
set                             000321 constant        entry                    external dcl 120
set_flush_level                 000553 constant        entry                    internal dcl 172 ref 158
thread_to_head                  000646 constant        entry                    internal dcl 200 ref 99 113 133
thread_to_tail                  000741 constant        entry                    internal dcl 211 ref 146 287
update_to_current_flush_level   001034 constant        entry                    internal dcl 222 ref 88 107 122

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1456        1502    1315        1466
Length      1726    1315        24         207     140           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pathname_am                         161 external procedure  is an external procedure.  
set_flush_level                         internal procedure  shares stack frame of external procedure pathname_am.  
empty_pam                               internal procedure  shares stack frame of external procedure pathname_am.  
thread_to_head                          internal procedure  shares stack frame of external procedure pathname_am.  
thread_to_tail                          internal procedure  shares stack frame of external procedure pathname_am.  
update_to_current_flush_level           internal procedure  shares stack frame of external procedure pathname_am.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
pathname_am              000100 flush_level                 pathname_am
                         000101 hash_slot                   pathname_am
                         000102 pam_index                   pathname_am
                         000103 plen                        pathname_am
                         000104 prevp                       pathname_am
                         000106 kstp                        pathname_am
                         000110 kstep                       pathname_am
                         000112 amp                         pathname_am
                         000114 amep                        pathname_am
                         000126 flush_level_minus_1         set_flush_level
                         000160 ahd_flush_buffer_index      update_to_current_flush_level
                         000161 current_flush_level         update_to_current_flush_level
                         000162 entryp                      update_to_current_flush_level
                         000164 num_uids_to_flush           update_to_current_flush_level
                         000165 pam_index                   update_to_current_flush_level
                         000166 uid                         update_to_current_flush_level
                         000167 uids_to_flush               update_to_current_flush_level
                         000206 uids_to_flush_index         update_to_current_flush_level

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          mdfx1               ext_entry           ext_entry_desc      stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
kstsrch                       segno_usage$increment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_hardcore_data$pam_flush_buffer                       active_hardcore_data$pam_flush_level
pds$kstp                      pds$pathname_am




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     52 000006        77 000014        79 000023        80 000025        81 000026        82 000035        83 000042
     84 000046        86 000047        88 000071        89 000072        90 000076        91 000100        92 000105
     93 000110        94 000122        96 000144        97 000151        98 000171        99 000200       100 000201
    102 000202       103 000210       105 000211       107 000231       108 000232       109 000237       110 000250
    111 000260       112 000265       113 000303       114 000304       116 000305       117 000313       118 000316
    120 000317       122 000337       123 000340       124 000345       125 000351       126 000353       127 000357
    129 000360       130 000365       131 000373       132 000400       133 000406       134 000407       136 000410
    138 000423       139 000426       140 000432       141 000437       142 000446       143 000452       144 000455
    145 000460       146 000463       148 000464       149 000466       151 000467       157 000477       158 000502
    160 000513       161 000520       164 000527       166 000543       167 000545       169 000551       170 000552
    172 000553       180 000555       181 000563       184 000573       186 000574       187 000577       188 000605
    189 000611       190 000616       191 000622       192 000625       193 000630       194 000631       195 000633
    196 000641       197 000645       200 000646       202 000647       203 000665       204 000702       205 000714
    206 000720       207 000730       208 000740       211 000741       213 000742       214 000760       215 000775
    216 001007       217 001013       218 001023       219 001033       222 001034       241 001035       242 001040
    243 001042       245 001045       247 001057       248 001060       249 001071       250 001076       251 001100
    252 001112       253 001116       254 001121       255 001126       257 001127       258 001130       260 001133
    261 001135       263 001151       265 001152       267 001157       268 001160       269 001163       272 001164
    273 001166       274 001171       275 001175       276 001203       279 001220       280 001233       281 001243
    282 001247       284 001254       285 001261       286 001264       287 001267       288 001270       290 001271
    291 001273       292 001277       295 001301       296 001304


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
