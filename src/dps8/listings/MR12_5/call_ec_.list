	COMPILATION LISTING OF SEGMENT call_ec_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1019.9 mst Sat
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 /*   The purpose of this program is to trap, handle, and report conditions
        9*     signalled while executing an exec_com, and resume execution with the
       10*     next line of the exec_com without aborting it. The callers of this program
       11*     may supply a varying number of arguments just as would be supplied to
       12*     exec_com itself.  A pointer to an argument list is provided for the
       13*     purpose of calling the exec_com_ subroutine which will subsequently
       14*     initiate the processing of the exec_com input lines.  If an error is
       15*     encountered while this interface is being called by a daemon process
       16*     all messages will be placed in the system logs via signal_io_ and
       17*     printed on the message coordinator terminal.  If an error is encountered
       18*     while running in an interactive user process the messages will be
       19*     printed on the user terminal via ioa_.  A temporary command_processor
       20*     and active_functon_processor are established here to determine whether
       21*     the condition error is resulting from a command or active function. The
       22*     process' command_processor and active_function_processor will be restored
       23*     to its original before exiting this program.  An asdump will be created
       24*     in the process' working directory for error conditions other than
       25*     command_error and/or active_function_error.
       26**/
       27      
       28 
       29      
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(87-03-05,Parisek), approve(87-07-23,MCR7716),
       33*     audit(87-07-30,Fawcett), install(87-08-11,MR12.1-1079):
       34*     Program to handle condition errors encountered while executing an
       35*     exec_com. Display error data and continue execution after conditions
       36*     are encountered.
       37*  2) change(87-08-12,Parisek), approve(87-08-12,PBF7716),
       38*     audit(87-08-12,Fawcett), install(87-08-13,MR12.1-1085):
       39*     Changed call to trace_stack to call as_dump_ and only make this call for
       40*     unusual error conditions.
       41*  3) change(87-08-18,Parisek), approve(87-08-18,PBF7716),
       42*     audit(87-09-03,Farley), install(87-09-10,MR12.1-1104):
       43*     Define constant values and check pointer validity before referencing them.
       44*  4) change(87-09-18,Parisek), approve(87-09-18,PBF7716),
       45*     audit(87-09-18,Farley), install(87-09-21,MR12.1-1111):
       46*     Implement a counter that increments each time an error is reported and if
       47*     this counter reaches five, then return thus aborting the exec_com.
       48*                                                   END HISTORY COMMENTS */
       49 
       50 call_ec_:
       51 	proc options (variable);
       52 
       53     dcl   argp                          ptr,
       54           argl                          fixed bin(21),
       55           arg                           char(argl) based(argp),
       56           arg_count                     fixed bin,
       57 	arg_list_ptr                  ptr;
       58 
       59     dcl	RETURN_FALSE_AF_VALUE	label variable,
       60 	code			fixed bin(35),
       61 	error_counter                 fixed bin,	/* Count number of reported errors */
       62 	ec_arg                        char(168),
       63 	ec_dir                        char(168),
       64 	ec_entry                      char(32),
       65 	ec_path                       char(168),
       66 	iop                           ptr,
       67 	last_active_string_len	fixed bin(21),
       68 	last_active_string_ptr	ptr,
       69 	last_command_line_len	fixed bin(21),
       70 	last_command_line_ptr	ptr,
       71 	lg_status                     char(100) aligned,
       72 	old_cp			entry (ptr, fixed bin(21), fixed bin(35)) variable,
       73 	old_eval			entry (ptr, char(*), fixed bin, char(*) var, fixed bin(35)) variable,
       74          (seg_name, seg_name2, seg_name3)
       75 				char(500) aligned,
       76 	seg_ptr			ptr,
       77 	st_status                     char(8) aligned;
       78 
       79     dcl	last_active_string		char(last_active_string_len)
       80 				based(last_active_string_ptr),
       81 	last_command_line		char(last_command_line_len)
       82 				based(last_command_line_ptr);
       83 
       84     dcl  1 ec_info                      aligned like exec_com_info;
       85 
       86     dcl  (addr, length, null, rtrim, substr)
       87 				builtin;
       88 
       89     dcl  (any_other, cleanup, command_abort_, linkage_error, signal_io_)
       90 				condition;
       91 
       92     dcl	com_err_                      entry options (variable),
       93           condition_interpreter_	entry (ptr, ptr, fixed bin, fixed bin, ptr, char(*), ptr, ptr),
       94 	continue_to_signal_		entry (fixed bin(35)),
       95 	convert_status_code_          entry (fixed bin(35), char(8) aligned, char(100) aligned),
       96 	cu_$arg_count                 entry (fixed bin, fixed bin(35)),
       97 	cu_$arg_ptr_rel               entry (fixed bin, ptr, fixed bin(21), fixed bin(35), ptr),
       98 	cu_$arg_list_ptr              entry (ptr),
       99 	cu_$get_command_processor	entry (entry),
      100 	cu_$get_evaluate_active_string
      101 				entry (entry),
      102 	cu_$make_entry_value          entry (ptr, entry),
      103 	cu_$set_command_processor	entry (entry),
      104 	cu_$set_evaluate_active_string
      105 				entry (entry),
      106 	exec_com_			entry (char(*), char(*), char(*), ptr, fixed bin(35)),
      107 	expand_pathname_              entry (char(*), char(*), char(*), fixed bin(35)),
      108 	find_condition_frame_	entry (ptr) returns(ptr),
      109 	find_condition_info_	entry (ptr, ptr, fixed bin(35)),
      110 	get_ppr_			entry (fixed bin, ptr, ptr, char(500) aligned, char(500) aligned,
      111 				     char(500) aligned),
      112 	ioa_$ioa_switch               entry() options(variable),
      113 	ioa_$rsnnl		entry() options(variable),
      114 	pathname_			entry (char(*), char(*)) returns(char(168)),
      115 	sc_signal_io_handler_         entry (),
      116 	as_dump_                      entry (char (*));
      117 	
      118 	
      119     dcl   FALSE			init("0"b) bit(1) int static options(constant),
      120        	NL			char(1) int static options(constant) init("
      121 ");
      122 
      123 /* External */
      124 
      125     dcl   iox_$user_io                  ptr ext static;
      126 
      127 /* Constants */
      128 
      129     dcl   ACTIVE_FUNCT_ERROR_TYPE       fixed bin int static options (constant) init (2),
      130 	ALL_OTHERS_TYPE               fixed bin int static options (constant) init (3),
      131 	COMMAND_ERROR_TYPE            fixed bin int static options (constant) init (1),
      132 	FIRST_EC_ARG                  fixed bin int static options (constant) init (2),
      133 	MAX_ERROR_CNT                 fixed bin int static options (constant) init (5),
      134 	MAX_ERROR_INFO                fixed bin int static options (constant) init (2);
      135 
      136 
      137 	if iox_$user_io = null then do;
      138 	     call com_err_ (0, "call_ec_", "iox_$user_io is null");
      139 						/* Have caller handle this with an asdump */
      140 	     return;
      141 	end;
      142 	else iop = iox_$user_io;
      143 
      144 	call cu_$get_command_processor (old_cp);
      145 	call cu_$get_evaluate_active_string (old_eval);
      146 	on cleanup call janitor();
      147 
      148 	call cu_$arg_count (arg_count, code);		/* If we get any bad codes we'll signal command_error and get an asdump */
      149 	if code ^= 0 then do;
      150 	     call com_err_ (code, "call_ec_", "From cu_$arg_count.");
      151 	     return;
      152 	end;
      153 	call cu_$arg_list_ptr (arg_list_ptr);
      154 
      155 	ec_path, ec_arg = "";
      156 	call cu_$arg_ptr_rel (1, argp, argl, code, arg_list_ptr);
      157 	if code ^= 0 then do;
      158 	     call com_err_ (code, "call_ec_", "From cu_$arg_ptr_rel.");
      159 	     return;
      160 	end;
      161 	ec_path = (arg);
      162 	call expand_pathname_ (ec_path, ec_dir, ec_entry, code);
      163 	if code ^= 0 then do;
      164 	     call com_err_ (code, "call_ec_", "From expand_pathname_.");
      165 	     return;
      166 	end;
      167 	ec_path = pathname_ (ec_dir, rtrim(ec_entry) || ".ec");
      168 
      169 	last_command_line_ptr, last_active_string_ptr = null;
      170 
      171 	on signal_io_ call sc_signal_io_handler_ ();
      172 
      173 	error_counter = 0;				/* Init */
      174 	on any_other begin;
      175 	     error_counter = error_counter + 1;
      176 	     call handle_ec_conditions ();
      177 	     if error_counter = MAX_ERROR_CNT then do;
      178 		call ioa_$ioa_switch (iop, "Aborting the exec_com due to too many error conditions.");
      179 		goto EXIT;
      180 	     end;
      181 	end;
      182 	
      183 
      184 
      185 	call cu_$set_command_processor (call_cp);
      186 	call cu_$set_evaluate_active_string (call_eval);
      187 	ec_info.version = exec_com_info_version_1;
      188 	ec_info.arg_list_ptr = arg_list_ptr;
      189 	ec_info.first_arg = FIRST_EC_ARG;
      190 	ec_info.execute_line = call_cp;
      191 	ec_info.eval_string = call_eval;
      192 	call cu_$make_entry_value (null (), ec_info.ready);
      193 	call cu_$make_entry_value (null (), ec_info.set_ready_mode);
      194 	call cu_$make_entry_value (null (), ec_info.error);
      195 
      196 	call exec_com_ (rtrim(ec_path), "", "call_ec_", addr (ec_info), code);
      197 	if code ^= 0 then
      198 	     call com_err_ (code, "call_ec_", "From exec_com_.");
      199 
      200 EXIT:	call janitor();
      201 	return;
      202 
      203 
      204 handle_ec_conditions:
      205           proc ();
      206 
      207     dcl	type			fixed bin(2);
      208 
      209 	 call find_condition_info_ (null, addr(ci), code);
      210 	 if code = 0 then do;
      211 	      if ci.condition_name = "command_abort_" then do;
      212 		 call begin_error_message(type, "");
      213 		 call ioa_$ioa_switch (iop, "
      214 Error: command_abort_ signalled by call_ec_ not handled by command_processor_.
      215 ******************************");
      216 	      end;
      217 	      else				/* Pass thru standard conditions which should be	*/
      218 		 if ci.condition_name = "alrm"	/* handled by the default error handler.	*/
      219 		 | ci.condition_name = "command_question"
      220 		 | ci.condition_name = "cput"
      221 		 | ci.condition_name = "dm_shutdown_scheduled_"
      222 		 | ci.condition_name = "dm_shutdown_warning_"
      223 		 | ci.condition_name = "dm_user_shutdown_"
      224 		 | ci.condition_name = "end_file"
      225 		 | ci.condition_name = "end_page"
      226 		 | ci.condition_name = "finish"
      227 		 | ci.condition_name = "mme2"
      228 		 | ci.condition_name = "storage"
      229 		 | ci.condition_name = "quit"
      230 		 | ci.condition_name = "sus_"
      231 		 | ci.condition_name = "system_shutdown_scheduled_"
      232 		 | ci.condition_name = "trm_" then
      233 		 call continue_to_signal_ (code);
      234 	      else
      235 		 if condition_default_restart() then do;
      236 						/* Don't signal command_abort_ for errors which	*/
      237 						/* are default_restartable.			*/
      238 		      if ci.condition_name = "command_error" then do;
      239 			 call begin_error_message(type, ci.condition_name);
      240 			 if ci.info_ptr ^= null then
      241 			      if ci.info_ptr->com_af_error_info.errmess_ptr ^= null then do;
      242 				 call ioa_$ioa_switch (iop, "^/^a",
      243 				      com_err_message);
      244 				 ci.info_ptr -> com_af_error_info.print_sw = FALSE;
      245 			      end;
      246 		      end;
      247 		      else do;
      248 			 call begin_error_message(type, ci.condition_name);
      249 			 if ci.info_ptr ^= null then
      250 			      call condition_interpreter_(null, null, 0, 3,
      251 				 ci.mc_ptr, (ci.condition_name),
      252 				 ci.wc_ptr, ci.info_ptr);
      253 		      end;
      254 		      call end_error_message (type, "continues");
      255 		 end;
      256 		 else do;				/* Diagnose all other, unexpected conditions.	*/
      257 		      if ci.condition_name = "active_function_error" then do;
      258 			 call begin_error_message(type, ci.condition_name);
      259 			 if ci.info_ptr ^= null then
      260 			      call ioa_$ioa_switch (iop, "^a",
      261 			      com_err_message);
      262 			 if type = ACTIVE_FUNCT_ERROR_TYPE then do;
      263 			      call end_error_message (type,
      264 				 "continues by returning ""false"" as the
      265 active function value");
      266 			      go to RETURN_FALSE_AF_VALUE;
      267 			 end;
      268 			 else do;
      269 			      if ci.info_ptr ^= null then 
      270 				 ci.info_ptr -> com_af_error_info.print_sw = FALSE;
      271 			      call end_error_message (type, "continues");
      272 			 end;
      273 		      end;
      274 		      else do;
      275 			 call as_dump_ (rtrim(ci.condition_name) || " condition encountered.");
      276 			 call begin_error_message(type, ci.condition_name);
      277 			 if condition_quiet_restart()	
      278 						/* Specially handle conditions that 		*/
      279 			      then do;		/* condition_interpreter_ is silent for.	*/
      280 			      if ci.loc_ptr ^= null then do;
      281 				 seg_ptr = ci.user_loc_ptr;
      282 				 on linkage_error begin;
      283 						/* get_ppr_ may call routines unavailable	*/
      284 				      call format_name (seg_ptr, seg_name);
      285 				      seg_name2, seg_name3 = "";
      286 						/* at the time.  If an error occurs, use 	*/
      287 				      go to QUIET_REVERT;
      288 						/* format_name as a backup name-getter.		*/
      289 				 end;
      290 				 call get_ppr_ (MAX_ERROR_INFO, find_condition_frame_(null),
      291 				      addr(ci), seg_name, seg_name2, seg_name3);
      292 QUIET_REVERT:			 revert linkage_error;
      293 				 call ioa_$ioa_switch (iop,  
      294 				      "^/Error: ^a at ^a ^a ^a",
      295 				      ci.condition_name, seg_name, seg_name2,
      296 				      seg_name3);
      297 			      end;
      298 			      else do;
      299 				 call ioa_$ioa_switch (iop,
      300 				      "Error: ^a at UNKNOWN LOCATION.",
      301 				      ci.condition_name);
      302 			      end;
      303 			       
      304 			      if ci.condition_name = "stringsize" then
      305 				 call end_error_message (type,
      306 				 "continues with truncation of the string");
      307 			      else
      308 				 call end_error_message (type, "continues");
      309 			 end;
      310 			 else do;
      311 			      call condition_interpreter_(null, null, 0, 3,
      312 				 ci.mc_ptr, (ci.condition_name),
      313 				 ci.wc_ptr, ci.info_ptr);
      314 			      call end_error_message (type,
      315 				 "continues with the next line of the exec_com");
      316 			      if last_command_line_ptr ^= null then
      317 				 signal command_abort_;
      318 						/* Then abort the current command line of the ec. */
      319 			 end;
      320 		      end;
      321 		 end;
      322 	      end;
      323         end handle_ec_conditions;
      324 
      325 
      326 begin_error_message:
      327 	proc (case, condition_name);
      328 	
      329     dcl	case			fixed bin(2),
      330 	condition_name		char(*) varying;
      331 
      332 	if last_command_line_ptr ^= null then do;
      333 	   case = COMMAND_ERROR_TYPE;
      334 	   call ioa_$ioa_switch (iop, "
      335 ******************************
      336 While executing the command line:
      337    ^a^[^;
      338 ^]in ^a.ec, an unexpected ^[^a condition^;error^s^] occurred:",
      339 	   last_command_line,
      340 	   substr(last_command_line,length(last_command_line),length(NL))=NL,
      341 	   ec_entry, condition_name^="", condition_name);
      342 	   end;
      343 	else
      344 	if last_active_string_ptr ^= null then do;
      345 	   case = ACTIVE_FUNCT_ERROR_TYPE;
      346 	   call ioa_$ioa_switch (iop, "
      347 ******************************
      348 While evaluating the active string:
      349    ^a^[^;
      350 ^]in ^a.ec, an unexpected ^[^a condition^;error^s^] occurred:",
      351 	      last_active_string,
      352 	      substr(last_active_string,length(last_active_string),
      353 	          length(NL))=NL, ec_entry, condition_name^="",
      354 	      condition_name);
      355 	   end;
      356 	else do;
      357 	   case = ALL_OTHERS_TYPE;
      358 	   call ioa_$ioa_switch (iop, "
      359 ******************************
      360 An unexpected ^[^a condition^;error^s^] occurred in ^a.ec:",
      361 	      condition_name^="", condition_name, ec_entry);
      362 	   end;
      363 	if ci.condition_name = "io_error" then do;
      364 	     call convert_status_code_ (ci.info_ptr -> io_error_info.status.code, st_status, lg_status);
      365 	     call ioa_$ioa_switch (iop, "Status returned by ""io_error"" condition is: ^a", rtrim(lg_status));
      366 	end;
      367 	return;
      368 
      369 end_error_message:
      370 	entry (case, further_action);
      371 	
      372     dcl	further_action		char(*);
      373 	
      374 	call ioa_$ioa_switch (iop, "
      375 ^[Execution of the command^;Evaluation of the active string^;Execution^] ^a.
      376 ******************************^/", case, further_action);
      377 
      378 	end begin_error_message;
      379 
      380 
      381 call_cp:	proc (Aline_ptr, Aline_len, Acode);
      382 
      383     dcl	Aline_ptr			ptr,
      384 	Aline_len			fixed bin(21),
      385 	Acode			fixed bin(35);
      386 
      387 	last_command_line_ptr = Aline_ptr;
      388 	last_command_line_len = Aline_len;
      389 	call old_cp (Aline_ptr, Aline_len, Acode);
      390 	last_command_line_ptr = null;
      391 	end call_cp;
      392 
      393 
      394 call_eval:
      395        	proc (Ainfo_ptr, Aactive_string, Astring_type, Areturn_value, Acode);
      396 
      397     dcl	Ainfo_ptr			ptr,
      398 	Aactive_string		char(*),
      399 	Astring_type		fixed bin,
      400 	Areturn_value		char(*) varying,
      401 	Acode			fixed bin(35);
      402 
      403 	last_active_string_ptr = addr(Aactive_string);
      404 	last_active_string_len = length(Aactive_string);
      405 	RETURN_FALSE_AF_VALUE = RETURN_FALSE;
      406 	call old_eval (Ainfo_ptr, Aactive_string, Astring_type,
      407 	   Areturn_value, Acode);
      408 	last_active_string_ptr = null;
      409 	return;
      410 RETURN_FALSE:
      411 	Areturn_value = "false";
      412 	Acode = 0;
      413 	last_active_string_ptr = null;
      414 	end call_eval;
      415 
      416 
      417 condition_default_restart:
      418 	proc () returns(bit(1));
      419 	if ci.info_ptr ^= null then
      420 	   return (ci.info_ptr -> condition_info_header.default_restart);
      421 	else
      422 	   return (FALSE);
      423 
      424 condition_quiet_restart:
      425 	entry () returns(bit(1));
      426 	if ci.info_ptr ^= null then
      427 	   return (ci.info_ptr -> condition_info_header.quiet_restart);
      428 	else
      429 	   return (FALSE);
      430 	end condition_default_restart;
      431        
      432 
      433 format_name:
      434      proc (p, name);
      435 
      436 	dcl     p			 ptr;
      437 	dcl     code		 fixed bin (35);
      438 	dcl     find_pathname_	 entry (ptr, ptr, fixed bin (35));
      439 	dcl     name		 char (500) aligned;
      440 	dcl     1 name_info		 aligned like find_pathname_info automatic;
      441 
      442 
      443 	call find_pathname_ (p, addr (name_info), code);
      444 
      445 	if name_info.component_ename ^= ""
      446 	then /* use name from bindmap */
      447 	     call ioa_$rsnnl ("^a^a (^a^a^a^a^a)^a", name, 0, name_info.component_ename, name_info.adjusted_offset,
      448 		name_info.dirname, name_info.gt_char, name_info.real_ename, name_info.real_offset,
      449 		name_info.pdir_string, name_info.offset_msg);
      450 	else call ioa_$rsnnl ("^a^a^a^a^a^a", name, 0, name_info.dirname, name_info.gt_char, name_info.real_ename,
      451 		name_info.real_offset, name_info.pdir_string, name_info.offset_msg);
      452 
      453 	return;
      454      end format_name;
      455 
      456 
      457 janitor:	proc;
      458 	call cu_$set_command_processor (old_cp);
      459 	call cu_$set_evaluate_active_string (old_eval);
      460 	end janitor;
      461 
  1     1 /* BEGIN INCLUDE FILE com_af_error_info.incl.pl1 April 81 BIM */
  1     2 /* format: style2 */
  1     3 
  1     4 /* info structures for command error and active function error */
  1     5 /* The include file condition_info_header must be included to use this file */
  1     6 
  1     7      declare com_af_error_info_ptr  pointer;
  1     8      declare 1 com_af_error_info    aligned based (com_af_error_info_ptr),
  1     9 	     2 header	      aligned like condition_info_header,
  1    10 	     2 name_ptr	      ptr,
  1    11 	     2 name_lth	      fixed bin,
  1    12 	     2 errmess_ptr	      ptr,
  1    13 	     2 errmess_lth	      fixed bin (21),
  1    14 	     2 max_errmess_lth    fixed bin (21),
  1    15 	     2 print_sw	      bit (1);		/* set this to inform com_err_ that the msg has been printed */
  1    16 
  1    17 declare com_af_error_info_version_3 internal static options (constant) init (3);
  1    18 
  1    19 /* END INCLUDE FILE com_af_error_info */
      462 
      463 
      464     dcl	com_err_message		char(ci.info_ptr->com_af_error_info.errmess_lth)
      465 				based(ci.info_ptr->com_af_error_info.errmess_ptr);
      466 
  2     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  2     2 
  2     3 /* Structure for find_condition_info_.
  2     4*
  2     5*   Written 1-Mar-79 by M. N. Davidoff.
  2     6**/
  2     7 
  2     8 /* automatic */
  2     9 
  2    10      declare condition_info_ptr     pointer;
  2    11 
  2    12 /* based */
  2    13 
  2    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  2    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 condition_name     char (32) varying,	/* name of condition */
  2    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  2    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  2    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  2    21 	     2 flags	      unaligned,
  2    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  2    23 	       3 pad1	      bit (35),
  2    24 	     2 pad2	      bit (36),
  2    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  2    26 	     2 pad3	      (4) bit (36);
  2    27 
  2    28 /* internal static */
  2    29 
  2    30      declare condition_info_version_1
  2    31 			      fixed binary internal static options (constant) initial (1);
  2    32 
  2    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      467 
      468 
      469     dcl	1 ci			aligned like condition_info;
      470 
      471 
  3     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  3     2 /* format: style2 */
  3     3 
  3     4      declare condition_info_header_ptr
  3     5 			      pointer;
  3     6      declare 1 condition_info_header
  3     7 			      aligned based (condition_info_header_ptr),
  3     8 	     2 length	      fixed bin,		/* length in words of this structure */
  3     9 	     2 version	      fixed bin,		/* version number of this structure */
  3    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  3    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  3    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  3    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  3    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  3    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  3    16 	       3 pad	      bit (32) unaligned,
  3    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  3    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  3    19 
  3    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      472 
      473 
  4     1 /*  BEGIN INCLUDE FILE ... exec_com_info.incl.pl1 */
  4     2 
  4     3 /* Information needed by exec_com_ */
  4     4 
  4     5 declare  exec_com_info_ptr		ptr;
  4     6 	
  4     7 declare  1 exec_com_info		aligned based (exec_com_info_ptr),
  4     8 	 2 version		fixed bin,
  4     9 	 2 arg_list_ptr		ptr,
  4    10 	 2 first_arg		fixed bin,
  4    11 	 2 execute_line		entry (ptr, fixed bin (21), fixed bin (35)),
  4    12 	 2 eval_string		entry (ptr, char (*), fixed bin, char (*) var, fixed bin (35)),
  4    13 	 2 ready			entry (),
  4    14            2 set_ready_mode		entry (1 aligned, 2 bit (1) unal, 2 bit (35) unal),
  4    15 	 2 error			entry options (variable);
  4    16 
  4    17 declare  exec_com_info_version_1	fixed bin internal static init (1);
  4    18 
  4    19 /*   END INCLUDE FILE ... exec_com_info.incl.pl1 */
      474 
      475 
  5     1 /* BEGIN INCLUDE FILE find_pathname_info.incl.pl1 BIM April 1981 */
  5     2 /* format: style2 */
  5     3 
  5     4      declare find_pathname_info_ptr pointer;
  5     5 
  5     6      declare 1 find_pathname_info   aligned based (find_pathname_info_ptr),
  5     7 	     2 strings	      unaligned,
  5     8 	       3 component_ename  character (32),
  5     9 	       3 adjusted_offset  character (7),
  5    10 	       3 dirname	      character (168),
  5    11 	       3 gt_char	      character (1),
  5    12 	       3 real_ename	      character (32),
  5    13 	       3 real_offset      character (7),
  5    14 	       3 pdir_string      character (17),
  5    15 	       3 offset_msg	      character (40),
  5    16 	     2 bin_adjusted_off   fixed bin (18),
  5    17 	     2 bin_real_off	      fixed bin (18);
  5    18 
  5    19 /* END INCLUDE FILE find_pathname_info */
      476 
      477 
  6     1 /* Begin include file: io_error_info.incl.pl1  BIM April 1981 */
  6     2 /* This depends on condition_info_header.incl.pl1 */
  6     3 /* format: style2 */
  6     4 
  6     5      declare   io_error_info_ptr    pointer;
  6     6      declare 1 io_error_info	      aligned based (io_error_info_ptr),
  6     7 	     2 header	      aligned like condition_info_header,
  6     8 	     2 switch_name	      char (32),
  6     9 	     2 status,
  6    10 	       3 code	      fixed bin (35),
  6    11 	       3 IOS_status_bits  bit (36);		/* for compatability */
  6    12 
  6    13 /* end include file, io_error_info.incl.pl1 */
      478 
      479 
  7     1 /* Begin include file ..... iox_modes.incl.pl1 */
  7     2 
  7     3 /* Written by C. D. Tavares, 03/17/75 */
  7     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  7     5 
  7     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  7     7     ("stream_input", "stream_output", "stream_input_output",
  7     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  7     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  7    10      "direct_input", "direct_output", "direct_update");
  7    11 
  7    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  7    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  7    14 
  7    15 dcl (Stream_input initial (1),
  7    16      Stream_output initial (2),
  7    17      Stream_input_output initial (3),
  7    18      Sequential_input initial (4),
  7    19      Sequential_output initial (5),
  7    20      Sequential_input_output initial (6),
  7    21      Sequential_update initial (7),
  7    22      Keyed_sequential_input initial (8),
  7    23      Keyed_sequential_output initial (9),
  7    24      Keyed_sequential_update initial (10),
  7    25      Direct_input initial (11),
  7    26      Direct_output initial (12),
  7    27      Direct_update initial (13)) fixed bin int static options (constant);
  7    28 
  7    29 /* End include file ..... iox_modes.incl.pl1 */
      480 
      481 
      482 
      483 	end call_ec_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0808.7  call_ec_.pl1                      >spec>install>1112>call_ec_.pl1
462          1    06/22/81  1815.3  com_af_error_info.incl.pl1        >ldd>include>com_af_error_info.incl.pl1
467          2    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
472          3    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
474          4    04/13/82  1620.2  exec_com_info.incl.pl1            >ldd>include>exec_com_info.incl.pl1
476          5    07/18/81  1100.0  find_pathname_info.incl.pl1       >ldd>include>find_pathname_info.incl.pl1
478          6    01/06/82  2206.2  io_error_info.incl.pl1            >ldd>include>io_error_info.incl.pl1
480          7    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTIVE_FUNCT_ERROR_TYPE                constant        fixed bin(17,0)          initial dcl 129 ref 262 345
ALL_OTHERS_TYPE                        constant        fixed bin(17,0)          initial dcl 129 ref 357
Aactive_string                         parameter       char                     packed unaligned dcl 397 set ref 394 403 404 406*
Acode                                  parameter       fixed bin(35,0)          dcl 383 in procedure "call_cp" set ref 381 389*
Acode                                  parameter       fixed bin(35,0)          dcl 397 in procedure "call_eval" set ref 394 406*
                                                                                  412*
Ainfo_ptr                              parameter       pointer                  dcl 397 set ref 394 406*
Aline_len                              parameter       fixed bin(21,0)          dcl 383 set ref 381 388 389*
Aline_ptr                              parameter       pointer                  dcl 383 set ref 381 387 389*
Areturn_value                          parameter       varying char             dcl 397 set ref 394 406* 410*
Astring_type                           parameter       fixed bin(17,0)          dcl 397 set ref 394 406*
COMMAND_ERROR_TYPE                     constant        fixed bin(17,0)          initial dcl 129 ref 333
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 119 ref 244 269 421 428
FIRST_EC_ARG                           constant        fixed bin(17,0)          initial dcl 129 ref 189
MAX_ERROR_CNT                          constant        fixed bin(17,0)          initial dcl 129 ref 177
MAX_ERROR_INFO                  000015 constant        fixed bin(17,0)          initial dcl 129 set ref 290*
NL                              004012 constant        char(1)                  initial packed unaligned dcl 119 ref 334 334 346 346
RETURN_FALSE_AF_VALUE           000106 automatic       label variable           dcl 59 set ref 266 405*
action_flags              2            based           structure                level 2 dcl 3-6
addr                                                   builtin function         dcl 86 ref 196 196 209 209 290 290 403 443 443
adjusted_offset          10     000107 automatic       char(7)                  level 3 packed packed unaligned dcl 440 set ref 445*
any_other                       001224 stack reference condition                dcl 89 ref 174
arg                                    based           char                     packed unaligned dcl 53 ref 161
arg_count                       000103 automatic       fixed bin(17,0)          dcl 53 set ref 148*
arg_list_ptr                    000104 automatic       pointer                  dcl 53 in procedure "call_ec_" set ref 153* 156* 188
arg_list_ptr              2     001172 automatic       pointer                  level 2 in structure "ec_info" dcl 84 in procedure
                                                                                  "call_ec_" set ref 188*
argl                            000102 automatic       fixed bin(21,0)          dcl 53 set ref 156* 161
argp                            000100 automatic       pointer                  dcl 53 set ref 156* 161
as_dump_                        000062 constant        entry                    external dcl 92 ref 275
case                                   parameter       fixed bin(2,0)           dcl 329 set ref 326 333* 345* 357* 369 374*
ci                              001246 automatic       structure                level 1 dcl 469 set ref 209 209 290 290
cleanup                         001232 stack reference condition                dcl 89 ref 146
code                            000112 automatic       fixed bin(35,0)          dcl 59 in procedure "call_ec_" set ref 148* 149 150*
                                                                                  156* 157 158* 162* 163 164* 196* 197 197* 209* 210
                                                                                  217*
code                            000106 automatic       fixed bin(35,0)          dcl 437 in procedure "format_name" set ref 443*
code                    115            based           fixed bin(35,0)          level 3 in structure "io_error_info" dcl 6-6
                                                                                  in procedure "call_ec_" set ref 364*
com_af_error_info                      based           structure                level 1 dcl 1-8
com_err_                        000010 constant        entry                    external dcl 92 ref 138 150 158 164 197
com_err_message                        based           char                     packed unaligned dcl 464 set ref 242* 259*
command_abort_                  000000 stack reference condition                dcl 89 ref 316
component_ename                 000107 automatic       char(32)                 level 3 packed packed unaligned dcl 440 set ref 445
                                                                                  445*
condition_info                         based           structure                level 1 dcl 2-14
condition_info_header                  based           structure                level 1 dcl 3-6
condition_interpreter_          000012 constant        entry                    external dcl 92 ref 249 311
condition_name            3     001246 automatic       varying char(32)         level 2 in structure "ci" dcl 469 in procedure
                                                                                  "call_ec_" set ref 211 217 217 217 217 217 217 217
                                                                                  217 217 217 217 217 217 217 217 238 239* 248* 249
                                                                                  257 258* 275 276* 293* 299* 304 311 363
condition_name                         parameter       varying char             dcl 329 in procedure "begin_error_message" set ref
                                                                                  326 334 334* 346 346* 358 358*
continue_to_signal_             000014 constant        entry                    external dcl 92 ref 217
convert_status_code_            000016 constant        entry                    external dcl 92 ref 364
cu_$arg_count                   000020 constant        entry                    external dcl 92 ref 148
cu_$arg_list_ptr                000024 constant        entry                    external dcl 92 ref 153
cu_$arg_ptr_rel                 000022 constant        entry                    external dcl 92 ref 156
cu_$get_command_processor       000026 constant        entry                    external dcl 92 ref 144
cu_$get_evaluate_active_string  000030 constant        entry                    external dcl 92 ref 145
cu_$make_entry_value            000032 constant        entry                    external dcl 92 ref 192 193 194
cu_$set_command_processor       000034 constant        entry                    external dcl 92 ref 185 458
cu_$set_evaluate_active_string  000036 constant        entry                    external dcl 92 ref 186 459
default_restart           2(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-6 ref 419
dirname                  11(27) 000107 automatic       char(168)                level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
ec_arg                          000114 automatic       char(168)                packed unaligned dcl 59 set ref 155*
ec_dir                          000166 automatic       char(168)                packed unaligned dcl 59 set ref 162* 167*
ec_entry                        000240 automatic       char(32)                 packed unaligned dcl 59 set ref 162* 167 334* 346*
                                                                                  358*
ec_info                         001172 automatic       structure                level 1 dcl 84 set ref 196 196
ec_path                         000250 automatic       char(168)                packed unaligned dcl 59 set ref 155* 161* 162* 167*
                                                                                  196 196
errmess_lth             114            based           fixed bin(21,0)          level 2 dcl 1-8 ref 242 242 259 259
errmess_ptr             112            based           pointer                  level 2 dcl 1-8 ref 240 242 259
error                    26     001172 automatic       entry variable           level 2 dcl 84 set ref 194*
error_counter                   000113 automatic       fixed bin(17,0)          dcl 59 set ref 173* 175* 175 177
eval_string              12     001172 automatic       entry variable           level 2 dcl 84 set ref 191*
exec_com_                       000040 constant        entry                    external dcl 92 ref 196
exec_com_info                          based           structure                level 1 dcl 4-7
exec_com_info_version_1                constant        fixed bin(17,0)          initial dcl 4-17 ref 187
execute_line              6     001172 automatic       entry variable           level 2 dcl 84 set ref 190*
expand_pathname_                000042 constant        entry                    external dcl 92 ref 162
find_condition_frame_           000044 constant        entry                    external dcl 92 ref 290 290
find_condition_info_            000046 constant        entry                    external dcl 92 ref 209
find_pathname_                  000066 constant        entry                    external dcl 438 ref 443
find_pathname_info                     based           structure                level 1 dcl 5-6
first_arg                 4     001172 automatic       fixed bin(17,0)          level 2 dcl 84 set ref 189*
further_action                         parameter       char                     packed unaligned dcl 372 set ref 369 374*
get_ppr_                        000050 constant        entry                    external dcl 92 ref 290
gt_char                  63(27) 000107 automatic       char(1)                  level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
info_ptr                 14     001246 automatic       pointer                  level 2 dcl 469 set ref 240 240 242 242 242 244 249
                                                                                  249* 259 259 259 259 269 269 311* 364 419 419 426
                                                                                  426
io_error_info                          based           structure                level 1 dcl 6-6
ioa_$ioa_switch                 000052 constant        entry                    external dcl 92 ref 178 213 242 259 293 299 334 346
                                                                                  358 365 374
ioa_$rsnnl                      000054 constant        entry                    external dcl 92 ref 445 450
iop                             000322 automatic       pointer                  dcl 59 set ref 142* 178* 213* 242* 259* 293* 299*
                                                                                  334* 346* 358* 365* 374*
iox_$user_io                    000064 external static pointer                  dcl 125 ref 137 142
last_active_string                     based           char                     packed unaligned dcl 79 set ref 346* 346 346
last_active_string_len          000324 automatic       fixed bin(21,0)          dcl 59 set ref 346 346 346 346 404*
last_active_string_ptr          000326 automatic       pointer                  dcl 59 set ref 169* 343 346 346 346 403* 408* 413*
last_command_line                      based           char                     packed unaligned dcl 79 set ref 334* 334 334
last_command_line_len           000330 automatic       fixed bin(21,0)          dcl 59 set ref 334 334 334 334 388*
last_command_line_ptr           000332 automatic       pointer                  dcl 59 set ref 169* 316 332 334 334 334 387* 390*
length                                                 builtin function         dcl 86 ref 334 334 346 346 404
lg_status                       000334 automatic       char(100)                dcl 59 set ref 364* 365 365
linkage_error                   000000 stack reference condition                dcl 89 ref 282 292
loc_ptr                  20     001246 automatic       pointer                  level 2 dcl 469 set ref 280
mc_ptr                          001246 automatic       pointer                  level 2 dcl 469 set ref 249* 311*
name                                   parameter       char(500)                dcl 439 set ref 433 445* 450*
name_info                       000107 automatic       structure                level 1 dcl 440 set ref 443 443
null                                                   builtin function         dcl 86 ref 137 169 192 192 193 193 194 194 209 209
                                                                                  240 240 249 249 249 249 249 259 269 280 290 290
                                                                                  290 290 311 311 311 311 316 332 343 390 408 413
                                                                                  419 426
offset_msg              102     000107 automatic       char(40)                 level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
old_cp                          000366 automatic       entry variable           dcl 59 set ref 144* 389 458*
old_eval                        000372 automatic       entry variable           dcl 59 set ref 145* 406 459*
p                                      parameter       pointer                  dcl 436 set ref 433 443*
pathname_                       000056 constant        entry                    external dcl 92 ref 167
pdir_string              75(27) 000107 automatic       char(17)                 level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
print_sw                116            based           bit(1)                   level 2 dcl 1-8 set ref 244* 269*
quiet_restart             2(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-6 ref 426
ready                    16     001172 automatic       entry variable           level 2 dcl 84 set ref 192*
real_ename               64     000107 automatic       char(32)                 level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
real_offset              74     000107 automatic       char(7)                  level 3 packed packed unaligned dcl 440 set ref 445*
                                                                                  450*
rtrim                                                  builtin function         dcl 86 ref 167 196 196 275 365 365
sc_signal_io_handler_           000060 constant        entry                    external dcl 92 ref 171
seg_name                        000376 automatic       char(500)                dcl 59 set ref 284* 290* 293*
seg_name2                       000573 automatic       char(500)                dcl 59 set ref 285* 290* 293*
seg_name3                       000770 automatic       char(500)                dcl 59 set ref 285* 290* 293*
seg_ptr                         001166 automatic       pointer                  dcl 59 set ref 281* 284*
set_ready_mode           22     001172 automatic       entry variable           level 2 dcl 84 set ref 193*
signal_io_                      001240 stack reference condition                dcl 89 ref 171
st_status                       001170 automatic       char(8)                  dcl 59 set ref 364*
status                  115            based           structure                level 2 dcl 6-6
strings                         000107 automatic       structure                level 2 packed packed unaligned dcl 440
substr                                                 builtin function         dcl 86 ref 334 346
type                            000100 automatic       fixed bin(2,0)           dcl 207 set ref 212* 239* 248* 254* 258* 262 263*
                                                                                  271* 276* 304* 307* 314*
user_loc_ptr             24     001246 automatic       pointer                  level 2 dcl 469 set ref 281
version                         001172 automatic       fixed bin(17,0)          level 2 dcl 84 set ref 187*
wc_ptr                   16     001246 automatic       pointer                  level 2 dcl 469 set ref 249* 311*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 7-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 7-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 7-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 7-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 7-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 7-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 7-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 7-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 7-15
Stream                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           call_ec_
                         000103 arg_count                   call_ec_
                         000104 arg_list_ptr                call_ec_
                         000106 RETURN_FALSE_AF_VALUE       call_ec_
                         000112 code                        call_ec_
                         000113 error_counter               call_ec_
                         000114 ec_arg                      call_ec_
                         000166 ec_dir                      call_ec_
                         000240 ec_entry                    call_ec_
                         000250 ec_path                     call_ec_
                         000322 iop                         call_ec_
                         000324 last_active_string_len      call_ec_
                         000326 last_active_string_ptr      call_ec_
                         000330 last_command_line_len       call_ec_
                         000332 last_command_line_ptr       call_ec_
                         000334 lg_status                   call_ec_
                         000366 old_cp                      call_ec_
                         000372 old_eval                    call_ec_
                         000376 seg_name                    call_ec_
                         000573 seg_name2                   call_ec_
                         000770 seg_name3                   call_ec_
                         001166 seg_ptr                     call_ec_
                         001170 st_status                   call_ec_
                         001172 ec_info                     call_ec_
                         001246 ci                          call_ec_
handle_ec_conditions     000100 type                        handle_ec_conditions
on unit on line 282      000106 code                        format_name
                         000107 name_info                   format_name

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     call_ent_var_desc   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1           tra_ext_2
signal_op           enable_op           shorten_stack       ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
as_dump_                      com_err_                      condition_interpreter_        continue_to_signal_
convert_status_code_          cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel
cu_$get_command_processor     cu_$get_evaluate_active_string                              cu_$make_entry_value
cu_$set_command_processor     cu_$set_evaluate_active_string                              exec_com_
expand_pathname_              find_condition_frame_         find_condition_info_          find_pathname_
get_ppr_                      ioa_$ioa_switch               ioa_$rsnnl                    pathname_
sc_signal_io_handler_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     50 000610       137 000616       138 000622       140 000650       142 000651       144 000654       145 000662
    146 000671       148 000713       149 000724       150 000726       151 000757       153 000760       155 000767
    156 000775       157 001016       158 001020       159 001051       161 001052       162 001057       163 001103
    164 001105       165 001136       167 001137       169 001205       171 001211       173 001232       174 001233
    175 001247       176 001251       177 001256       178 001262       179 001302       181 001305       185 001306
    186 001320       187 001332       188 001334       189 001336       190 001340       191 001343       192 001346
    193 001361       194 001374       196 001407       197 001464       200 001520       201 001524       204 001525
    209 001533       210 001553       211 001556       212 001

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
