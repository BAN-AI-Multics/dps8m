	COMPILATION LISTING OF SEGMENT demount_pv
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1003.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-04-07,Fawcett), approve(86-04-11,MCR7383),
       17*     audit(86-05-13,Coppola), install(86-07-17,MR12.0-1097):
       18*     Add support for printing subvolume name.
       19*  2) change(88-05-11,Parisek), approve(88-05-27,MCR7907),
       20*     audit(88-06-02,Fawcett), install(88-09-27,MR12.2-1122):
       21*     Changed to make sure the pack is removable before trying to unload it.
       22*     Declare builtins in the main (outer) block as some are referenced there.
       23*     To conform to configuration management. (phx20612)
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 demount_pv:
       28      procedure (a_pvtx, a_code);
       29 
       30 /*    This procedure implements the hardcore portion of the physical
       31*   volume demounter.  It is called from the hardcore logical  volume
       32*   manager  when  the  latter  is asked to demount a logical volume.
       33*   The current implementation assumes that  no  salvaging  involving
       34*   the   volume   to   be   demounted   is  going  on.  The  current
       35*   implementation also does not attempt to overlap deactivation  I/O
       36*   with outer ring events.
       37*
       38*   This  procedure  is also called at system shutdown time
       39*   to demount the entire storage hierarchy. At this time, it  avoids
       40*   calling  deactivate,  in order to avoid dealing with possibly bad
       41*   threads or trailers.
       42*
       43*   Although this procedure turns on  pvte.being_demounted,
       44*   this bit may turned on by the caller.  demount_pv will deactivate
       45*   all segments residing on physical volumes with this bit on.  When
       46*   parallelism  with  outer-ring  events  is  implemented, this will
       47*   allow total parallelism during multi-volume demounts.
       48*
       49*   Initial coding March 26, 1976 by Bernard Greenberg
       50*   Modified 2/27/77 for drive-down ESD, BSG.
       51*   Modified December 1981 by C. Hornig to remove Page Multilevel.
       52*   Modified March 1982 by J. Bongiovanni for new PVTE
       53*   Modified September 1982 by J. Bongiovanni for scavenger
       54**/
       55 
       56 dcl  sst$astap ptr external;
       57 dcl  sst$astsize fixed bin external;
       58 dcl  1 sst$level (0:3) aligned external,
       59      2 ausedp bit (18) unal,
       60      2 no_aste bit (18) unal;
       61 dcl  sst$pts (0:3) fixed bin external;
       62 dcl  tc_data$system_shutdown ext fixed bin;
       63 dcl  pvt$n_in_use fixed bin external;
       64 
       65 dcl  error_table_$dev_nt_assnd ext fixed bin (35);
       66 dcl  error_table_$scavenge_in_progress ext fixed bin (35);
       67 dcl  error_table_$unable_to_do_io ext fixed bin (35);
       68 dcl  error_table_$vtoc_io_err ext fixed bin (35);
       69 
       70 dcl  get_pvtx$drain_pvtx entry (fixed bin);
       71 dcl  vtoc_man$cleanup_pv entry (fixed bin, fixed bin (35));
       72 dcl  fsout_vol entry (fixed bin, fixed bin);
       73 dcl  (
       74      syserr,
       75      syserr$error_code
       76      ) entry options (variable);
       77 
       78 dcl  (addr, addrel, fixed) builtin;
       79 
       80 dcl  pvtx fixed bin;				/* pvtx being demounted */
       81 dcl  sys_shut bit (1) aligned;			/* ON if system shutdown */
       82 dcl  pic99 pic "99";
       83 dcl  devname char (9);				/* Device name */
       84 dcl  code fixed bin (35);
       85 
       86 
       87 dcl  a_code fixed bin (35);
       88 dcl  a_pvtx fixed bin;
       89 
       90 
       91 
       92 	pvt_arrayp = addr (pvt$array);
       93 	pvtx = a_pvtx;
       94 	pvtep = addr (pvt_array (pvtx));		/* Develop pointers */
       95 
       96 	if ^(pvte.used & pvte.storage_system) then do;
       97 	     a_code = error_table_$dev_nt_assnd;	/* Dont work on bad drives */
       98 	     return;
       99 	     end;
      100 
      101 	if pvte.device_inoperative then do;
      102 	     a_code = error_table_$unable_to_do_io;
      103 	     return;
      104 	     end;
      105 
      106 	if pvte.scavenger_block_rel ^= ""b then do;
      107 	     a_code = error_table_$scavenge_in_progress;
      108 	     return;
      109 	end;
      110 
      111 	pvte.being_demounted = "1"b;			/* Cause all future get_pvtx's
      112*						   and get_pvtx$hold_pvtx's to fail. */
      113 
      114 	pic99 = pvte.logical_area_number;		/* Cons up devname */
      115 	devname = pvte.devname || "_" || pic99 || pvte.sv_name;
      116 
      117 	call get_pvtx$drain_pvtx (pvtx);		/* Wait out all current protectors of this pvtx.
      118*						   When this is finished, no process is in the middle
      119*						   of an indivisible vtoc operation (delete, truncate),
      120*						   and by virtue of previous line,
      121*						   no process can start one */
      122 
      123 	sys_shut = (tc_data$system_shutdown ^= 0);	/* Determine if shutting down system */
      124 						/* */
      125 						/* */
      126 						/* DEACTIVATE_ALL_SEGS will lock the AST.
      127*						   If any process is activating on  this
      128*						   PV, he must either not have yet locked
      129*						   the AST, or has it locked. If he has it locked,
      130*						   DEACTIVATE_ALL_SEGS cannot commence until
      131*						   he releases it. If not, he will find
      132*						   being_demounted on when he gets it, and will fail */
      133 
      134 	call DEACTIVATE_ALL_SEGS;			/*  We have already asserted that no one can
      135*						   activate, so we deactivate all */
      136 
      137 	pvte.being_demounted2 = "1"b;			/* Allow no further vtoc I/O to start */
      138 						/* Vtoc I/O in progress will be allowed to complete.
      139*						   From this point on, divisible calls to
      140*						   vtoc_man (vtoc_attributes, reclassify, etc.),
      141*						   will fail. */
      142 
      143 	call vtoc_man$cleanup_pv (pvtx, code);		/* Await all vtoc I/O which had been started
      144*						   to finish. No new I/O will start. */
      145 
      146 	if code ^= 0 then call syserr$error_code (ANNOUNCE, code, "demount_pv: vtoc cleanup of ^a:", devname);
      147 
      148 	call fsout_vol (pvtx, 1);			/* Write out label, vol map. */
      149 
      150 	if ^sys_shut then do;
      151 	     if ^pvte.permanent then call REWIND_UNLOAD;	/* unload non-perm's, only at non-shut time */
      152 	     call syserr (ANNOUNCE, "demounted ^a", devname);
      153 	     end;
      154 
      155 	call CLEANUP_PVTE;				/* Tuck the bits into bed. */
      156 
      157 	a_code = 0;
      158 	return;
      159 
      160 DEMOUNT_FAILS:					/* Arrive here if cannot demount */
      161 	call UNDO_FOR_LOSSAGE;			/* undo what we have done */
      162 	a_code = code;				/* Reflect error */
      163 	return;
      164 
      165 DEACTIVATE_ALL_SEGS:
      166      procedure;
      167 
      168 /* This procedure deactivates all segments on the physical volume being
      169*   demounted. At the time it has begun by locking the AST lock, it has
      170*   been insured thatno further activations on this instance of this pvte
      171*   can take place.
      172*
      173*   If a system shutdown is taking place, an "in-line deactivate" is
      174*   performed, to avoid dealing with possibly bad data in the ESD case.
      175*
      176**/
      177 
      178 dcl  (px, astx) fixed bin;				/* AST indices */
      179 dcl  tpvtx fixed bin;				/* PVTX of seg under consideration */
      180 dcl  (
      181      lock$lock_ast,
      182      lock$unlock_ast
      183      ) ext entry;
      184 dcl  deactivate entry (ptr, fixed bin (35));
      185 dcl  pc$cleanup entry (ptr);
      186 dcl  update_vtoce$deact entry (ptr, fixed bin (35));
      187 dcl  tpvtep ptr;					/* Corresponding pointer */
      188 
      189 	     astep = sst$astap;			/* WALK the AST, don't "list-hack" it */
      190 	     call lock$lock_ast;
      191 
      192 	     do px = 0 to 3;			/* pool index */
      193 		do astx = 1 to fixed (sst$level.no_aste (px), 18); /* Scan all of this size */
      194 		     if aste.uid ^= "0"b & aste.pvtx ^= 0 /* Elect only fs entries */
      195 		     & (aste.uid = (36)"1"b | aste.par_astep ^= "0"b) /* root or par must be */
      196 						/* These are superfluous gullibility checks
      197*						   to avoid tragedy */
      198 		     & ^aste.hc_sdw			/* Don't update segments in hardcore partition */
      199 		     then if fixed (aste.ptsi, 2) = px then do; /* All ok */
      200 			     tpvtx = aste.pvtx;	/* Get pvtx. */
      201 			     tpvtep = addr (pvt_array (tpvtx));
      202 			     if tpvtep -> pvte.being_demounted then do; /* Get 'em all. */
      203 				aste.fmchanged = aste.fmchanged | aste.fmchanged1; /* Fix window. */
      204 				aste.ddnp = "0"b;		/* Let pc return the addresses. */
      205 				if sys_shut then do;	/* Avoid AST threads. */
      206 				     if ^aste.ehs then call pc$cleanup (astep);
      207 				     call update_vtoce$deact (astep, code); /* Update the vtoce */
      208 				     if code ^= 0 then if code ^= error_table_$vtoc_io_err
      209 				     then if tpvtx = pvtx then go to DEMOUNT_FAILS;
      210 				     aste.uid = "000000000000"b3;	/* Last update here. */
      211 				end;
      212 				else do;
      213 				     call deactivate (astep, code);
      214 				     if code ^= 0 then if tpvtx = pvtx then go to DEMOUNT_FAILS;
      215 				end;
      216 			     end;
      217 			end;
      218 		     else call syserr (CRASH, "demount_pv: ast out of sync");
      219 		     astep = addrel (astep, fixed (sst$pts (px) + sst$astsize, 18));
      220 	     end;
      221 	end;
      222 
      223 	call lock$unlock_ast;
      224 
      225 
      226      end DEACTIVATE_ALL_SEGS;
      227 
      228 CLEANUP_PVTE:
      229      procedure;
      230 
      231 /* This procedure puts the pvt entry of the disk being demounted
      232*   in a credible state for reuse. An fsout_vol has already been done. */
      233 
      234 	     pvte.nleft = 0;			/* Dont let fsdct be used */
      235 	     pvte.n_free_vtoce = 0;			/* or vtoc allocates */
      236 	     pvte.lvid = "0"b;
      237 	     pvte.pvid = "0"b;
      238 	     pvte.being_demounted2 = "0"b;
      239 	     pvte.being_demounted = "0"b;
      240 	     pvte.vacating = "0"b;			/* In case this was going on */
      241 	     pvte.used = "0"b;			/* Drive not used */
      242 	     pvt$n_in_use = pvt$n_in_use - 1;		/* ? */
      243 
      244 	end CLEANUP_PVTE;
      245 
      246 
      247 UNDO_FOR_LOSSAGE: procedure;
      248 
      249 /* This procedure undoes what has been done by the demounter, because
      250*   the volume cannot be demounted due to an entry hold scgment */
      251 
      252 dcl  lock$unlock_ast entry;
      253 
      254 	call lock$unlock_ast;
      255 
      256 
      257 	pvte.being_demounted = "0"b;
      258 
      259      end UNDO_FOR_LOSSAGE;
      260 
      261 REWIND_UNLOAD:
      262      procedure;
      263 
      264 /* This procedure tries to unload the disk pack. */
      265 
      266 dcl  disk_control$unload_drive entry (fixed bin);
      267 dcl  disk_run entry;
      268 
      269           if ^pvte.removable_pack then return;             /* Pack can not be unloaded */
      270 	pvte.testing = "1"b;
      271 	call disk_control$unload_drive (pvtx);
      272 	do while (pvte.testing);			/* Noel has sworn that something will come back */
      273 	     call disk_run;
      274 	end;
      275 
      276 	if pvte.device_inoperative then do;
      277 	     call syserr (BEEP, "demount_pv: Unload ^a for storage system.", devname);
      278 	     pvte.device_inoperative = "0"b;
      279 	     end;
      280 
      281 	return;
      282 
      283      end REWIND_UNLOAD;
      284  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      284 
      285  
  2     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  2     3 
  2     4 dcl  pcwp ptr;					/* pointer to PCW */
  2     5 
  2     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  2     7      (2 command bit (6),				/* device command */
  2     8       2 device bit (6),				/* device code */
  2     9       2 ext bit (6),				/* address extension */
  2    10       2 code bit (3),				/* should be "111"b for PCW */
  2    11       2 mask bit (1),				/* channel mask bit */
  2    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    13       2 chan_cmd bit (6),				/* type of I/O operation */
  2    14       2 count bit (6),				/* record count or control character */
  2    15       2 mbz1 bit (3),
  2    16       2 channel bit (6),				/* channel number */
  2    17       2 mbz2 bit (27)) unal;
  2    18 
  2    19 dcl  idcwp ptr;					/* pointer to IDCW */
  2    20 
  2    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  2    22      (2 command bit (6),				/* device command */
  2    23       2 device bit (6),				/* device code */
  2    24       2 ext bit (6),				/* address extension */
  2    25       2 code bit (3),				/* should be "111"b for PCW */
  2    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  2    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  2    28       2 chan_cmd bit (6),				/* type of I/O operation */
  2    29       2 count bit (6)) unal;				/* record count or control character */
  2    30 
  2    31 /* End include file ...... iom_pcw.incl.pl1 */
  2    32 
      285 
      286  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  3     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3     8*     Add the support for subvolumes
  3     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  3    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  3    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3    14*     Added inconsistent_dbm bit for determining the status of volume
  3    15*     dumper bit maps.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18      dcl	   pvt$array	      aligned external;
  3    19      dcl	   pvt$max_n_entries      fixed bin external;
  3    20 
  3    21      dcl	   pvt_arrayp	      ptr;
  3    22      dcl	   pvtep		      ptr;
  3    23 
  3    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  3    25 
  3    26      dcl	   1 pvte		      based (pvtep) aligned,
  3    27 
  3    28 	     2 pvid	      bit (36),		/* physical volume ID */
  3    29 
  3    30 	     2 lvid	      bit (36),		/* logical volume ID */
  3    31 
  3    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  3    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  3    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  3    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  3    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  3    37 	     2 pad3	      bit (2) unaligned,
  3    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  3    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  3    40 
  3    41 
  3    42 
  3    43 	     2 devname	      char (4),		/* device name */
  3    44 
  3    45 	     (2 device_type	      fixed bin (8),	/* device type */
  3    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  3    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  3    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  3    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  3    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  3    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  3    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  3    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  3    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  3    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  3    56 	     2 scav_check_address
  3    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  3    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  3    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  3    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  3    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  3    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  3    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  3    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  3    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  3    66 
  3    67 
  3    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  3    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  3    70 
  3    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  3    72 
  3    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  3    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  3    75 
  3    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  3    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  3    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  3    79 	     2 records_per_cyl    fixed bin,
  3    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  3    81 	     2 sv_name            char (2) aligned,
  3    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  3    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  3    84 
  3    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  3    86 	     2 pad2	      bit (18) unaligned,
  3    87 
  3    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  3    89 
  3    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  3    91 
  3    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  3    93 
  3    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  3    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  3    96 
  3    97 
  3    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  3    99 
  3   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  3   101 
  3   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  3   103 
  3   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  3   105 
  3   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  3   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  3   108 
  3   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  3   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  3   111 
  3   112 
  3   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  3   114 	   VOLMAP_ASYNC_READ      init (1),
  3   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  3   116 
  3   117 
  3   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      286 
      287  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      287 
      288 
      289 /* BEGIN MESSAGE DOCUMENTATION
      290*
      291*   Message:
      292*   demount_pv: vtoc cleanup of DRIVENAME: ERRORMESSAGE
      293*
      294*   S: $info
      295*
      296*   T: Volume demounting or shutdown.
      297*
      298*   M: An unexpected error was encountered in flushing VTOC information
      299*   out to a volume being shut down or demounted.  The volume will not be demounted.
      300*   message.
      301*
      302*   A: $notify
      303*   Attempt to repeat the demount of the logical volume, if this is not during shutdown.
      304*   The physical volume involved may have to be salvaged.
      305*
      306*   Message:
      307*   demounted DRIVENAME
      308*
      309*   S: $info
      310*
      311*   T: Volume demounting, in response to delete_lv command or user action.
      312*
      313*   M: The disk pack on drive DRIVENAME was successfully demounted.
      314*
      315*   A: $ignore
      316*
      317*   Message:
      318*   demount_pv: ast out of sync
      319*
      320*   S: $crash
      321*
      322*   T: Volume demounting or system shutdown.
      323*
      324*   M: The volume demounter has detected irreparable damage to the
      325*   system segment table (SST).
      326*
      327*   A: Emergency shutdown will fail, and need not be attempted.
      328*   Follow normal recovery procedures for ESD failure.
      329*
      330*   Message:
      331*   demount_pv: ioi_PROGNAME for DRIVENAME: ERRORMESSAGE
      332*
      333*   S: $info
      334*
      335*   T: Volume demounting.
      336*
      337*   M: In attempting to cycle down drive DRIVENAME, an unexpected
      338*   error was received from the I/O Interfacer. The drive may not
      339*   be cycled down.
      340*
      341*   A: Notify the system programming staff. Cycle down the drive if it was not cycled down.
      342*
      343*   END MESSAGE DOCUMENTATION */
      344      end demount_pv;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0838.7  demount_pv.pl1                    >special_ldd>install>MR12.3-1114>demount_pv.pl1
284          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
285          2    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
286          3    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
287          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000006 constant        fixed bin(17,0)          initial dcl 4-7 set ref 146* 152*
BEEP                            000002 constant        fixed bin(17,0)          initial dcl 4-7 set ref 277*
CRASH                           000011 constant        fixed bin(17,0)          initial dcl 4-7 set ref 218*
a_code                                 parameter       fixed bin(35,0)          dcl 87 set ref 27 97* 102* 107* 157* 162*
a_pvtx                                 parameter       fixed bin(17,0)          dcl 88 ref 27 93
addr                                                   builtin function         dcl 78 ref 92 94 201
addrel                                                 builtin function         dcl 78 ref 219
aste                                   based           structure                level 1 dcl 1-11
astep                           000110 automatic       pointer                  dcl 1-9 set ref 189* 194 194 194 194 194 194 200 203
                                                                                  203 203 204 206 206* 207* 210 213* 219* 219
astx                            000125 automatic       fixed bin(17,0)          dcl 178 set ref 193*
being_demounted           4(23)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  111* 202 239* 257*
being_demounted2          4(29)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  137* 238*
code                            000106 automatic       fixed bin(35,0)          dcl 84 set ref 143* 146 146* 162 207* 208 208 213*
                                                                                  214
ddnp                     12(15)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  204*
deactivate                      000054 constant        entry                    external dcl 184 ref 213
device_inoperative        4(25)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref 101
                                                                                  276 278*
devname                   3            based           char(4)                  level 2 in structure "pvte" dcl 3-26 in procedure
                                                                                  "demount_pv" ref 115
devname                         000103 automatic       char(9)                  packed unaligned dcl 83 in procedure "demount_pv"
                                                                                  set ref 115* 146* 152* 277*
disk_control$unload_drive       000064 constant        entry                    external dcl 266 ref 271
disk_run                        000066 constant        entry                    external dcl 267 ref 273
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 206
error_table_$dev_nt_assnd       000024 external static fixed bin(35,0)          dcl 65 ref 97
error_table_$scavenge_in_progress
                                000026 external static fixed bin(35,0)          dcl 66 ref 107
error_table_$unable_to_do_io    000030 external static fixed bin(35,0)          dcl 67 ref 102
error_table_$vtoc_io_err        000032 external static fixed bin(35,0)          dcl 68 ref 208
fixed                                                  builtin function         dcl 78 ref 193 194 219
fmchanged                12(09)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  203* 203
fmchanged1               13(18)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 203
fsout_vol                       000040 constant        entry                    external dcl 72 ref 148
get_pvtx$drain_pvtx             000034 constant        entry                    external dcl 70 ref 117
hc_sdw                    5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 ref 194
lock$lock_ast                   000050 constant        entry                    external dcl 180 ref 190
lock$unlock_ast                 000052 constant        entry                    external dcl 180 in procedure "DEACTIVATE_ALL_SEGS"
                                                                                  ref 223
lock$unlock_ast                 000062 constant        entry                    external dcl 252 in procedure "UNDO_FOR_LOSSAGE" ref
                                                                                  254
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 3-26 ref 114
lvid                      1            based           bit(36)                  level 2 dcl 3-26 set ref 236*
n_free_vtoce              5            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  235*
nleft                     7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  234*
no_aste                   0(18) 000014 external static bit(18)                  array level 2 packed packed unaligned dcl 58 ref 193
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 194
pc$cleanup                      000056 constant        entry                    external dcl 185 ref 206
permanent                 4(20)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 ref 151
pic99                           000102 automatic       picture(2)               packed unaligned dcl 82 set ref 114* 115
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 1-11 ref 194
pvid                                   based           bit(36)                  level 2 dcl 3-26 set ref 237*
pvt$array                       000046 external static fixed bin(17,0)          dcl 3-18 set ref 92
pvt$n_in_use                    000022 external static fixed bin(17,0)          dcl 63 set ref 242* 242
pvt_array                              based           structure                array level 1 dcl 3-24 set ref 94 201
pvt_arrayp                      000112 automatic       pointer                  dcl 3-21 set ref 92* 94 201
pvte                                   based           structure                level 1 dcl 3-26
pvtep                           000114 automatic       pointer                  dcl 3-22 set ref 94* 96 96 101 106 111 114 115 115
                                                                                  137 151 234 235 236 237 238 239 240 241 257 269
                                                                                  270 272 276 278
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "demount_pv" ref 194 200
pvtx                            000100 automatic       fixed bin(17,0)          dcl 80 in procedure "demount_pv" set ref 93* 94 117*
                                                                                  143* 148* 208 214 271*
px                              000124 automatic       fixed bin(17,0)          dcl 178 set ref 192* 193 194 219*
removable_pack            2(05)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 ref 269
scavenger_block_rel      33(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-26 ref 106
sst$astap                       000010 external static pointer                  dcl 56 ref 189
sst$astsize                     000012 external static fixed bin(17,0)          dcl 57 ref 219
sst$level                       000014 external static structure                array level 1 dcl 58
sst$pts                         000016 external static fixed bin(17,0)          array dcl 61 ref 219
storage_system            4(19)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 ref 96
sv_name                  15            based           char(2)                  level 2 dcl 3-26 ref 115
sys_shut                        000101 automatic       bit(1)                   dcl 81 set ref 123* 150 205
syserr                          000042 constant        entry                    external dcl 73 ref 152 218 277
syserr$error_code               000044 constant        entry                    external dcl 73 ref 146
tc_data$system_shutdown         000020 external static fixed bin(17,0)          dcl 62 ref 123
testing                   4(21)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  270* 272
tpvtep                          000130 automatic       pointer                  dcl 187 set ref 201* 202
tpvtx                           000126 automatic       fixed bin(17,0)          dcl 179 set ref 200* 201 208 214
uid                       3            based           bit(36)                  level 2 packed packed unaligned dcl 1-11 set ref 194
                                                                                  194 210*
update_vtoce$deact              000060 constant        entry                    external dcl 186 ref 207
used                      4(18)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref 96
                                                                                  241*
vacating                  4(31)        based           bit(1)                   level 2 packed packed unaligned dcl 3-26 set ref
                                                                                  240*
vtoc_man$cleanup_pv             000036 constant        entry                    external dcl 71 ref 143

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 3-113
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
idcw                                   based           structure                level 1 dcl 2-21
idcwp                                  automatic       pointer                  dcl 2-19
pcw                                    based           structure                level 1 dcl 2-6
pcwp                                   automatic       pointer                  dcl 2-4
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 3-19
seg_aste                               based           structure                level 1 dcl 1-96

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP_PVTE                    000525 constant        entry                    internal dcl 228 ref 155
DEACTIVATE_ALL_SEGS             000310 constant        entry                    internal dcl 165 ref 134
DEMOUNT_FAILS                   000303 constant        label                    dcl 160 ref 208 214
REWIND_UNLOAD                   000562 constant        entry                    internal dcl 261 ref 151
UNDO_FOR_LOSSAGE                000550 constant        entry                    internal dcl 247 ref 160
demount_pv                      000053 constant        entry                    external dcl 27

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1150        1240     657        1160
Length      1530     657        70         254     270           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
demount_pv                          210 external procedure  is an external procedure.  
DEACTIVATE_ALL_SEGS                     internal procedure  shares stack frame of external procedure demount_pv.  
CLEANUP_PVTE                            internal procedure  shares stack frame of external procedure demount_pv.  
UNDO_FOR_LOSSAGE                        internal procedure  shares stack frame of external procedure demount_pv.  
REWIND_UNLOAD                           internal procedure  shares stack frame of external procedure demount_pv.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
demount_pv               000100 pvtx                        demount_pv
                         000101 sys_shut                    demount_pv
                         000102 pic99                       demount_pv
                         000103 devname                     demount_pv
                         000106 code                        demount_pv
                         000110 astep                       demount_pv
                         000112 pvt_arrayp                  demount_pv
                         000114 pvtep                       demount_pv
                         000124 px                          DEACTIVATE_ALL_SEGS
                         000125 astx                        DEACTIVATE_ALL_SEGS
                         000126 tpvtx                       DEACTIVATE_ALL_SEGS
                         000130 tpvtep                      DEACTIVATE_ALL_SEGS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
deactivate                    disk_control$unload_drive     disk_run                      fsout_vol
get_pvtx$drain_pvtx           lock$lock_ast                 lock$unlock_ast               lock$unlock_ast
pc$cleanup                    syserr                        syserr$error_code             update_vtoce$deact
vtoc_man$cleanup_pv

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dev_nt_assnd     error_table_$scavenge_in_progress                           error_table_$unable_to_do_io
error_table_$vtoc_io_err      pvt$array                     pvt$n_in_use                  sst$astap
sst$astsize                   sst$level                     sst$pts                       tc_data$system_shutdown




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000047        92 000060        93 000062        94 000065        96 000070        97 000074        98 000076
    101 000077       102 000102       103 000104       106 000105       107 000110       108 000112       111 000113
    114 000115       115 000131       117 000147       123 000155       134 000161       137 000162       143 000165
    146 000176       148 000230       150 000243       151 000245       152 000252       155 000277       157 000300
    158 000302       160 000303       162 000304       163 000307       165 000310       189 000311       190 000315
    192 000321       193 000325       194 000337       200 000365       201 000367       202 000373       203 000376
    204 000403       205 000405       206 000407       207 000421       208 000432       210 000442       211 000444
    213 000445       214 000456       217 000463       218 000464       219 000504       220 000513       221 000515
    223 000517       226 000524       228 000525       234 000526       235 000531       236 000532       237 000533
    238 000534       239 000536       240 000540       241 000542       242 000544       244 000547       247 000550
    254 000551       257 000556       259 000561       261 000562       269 000563       270 000570       271 000572
    272 000601       273 000606       274 000613       276 000614       277 000617       278 000643       281 000646


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
