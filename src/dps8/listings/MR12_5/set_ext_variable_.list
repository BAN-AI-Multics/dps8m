	COMPILATION LISTING OF SEGMENT set_ext_variable_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0955.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-13,Zwick),
       16*     install(86-11-20,MR12.0-1222):
       17*     added the entrypoint star_heap to perform the look up and allocation of
       18*     heap links. This is called by the user and by link_snap. Reorganized this
       19*     routine to allow the changes to follow the existing methodology used in
       20*     the program.
       21*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420), audit(86-11-13,Zwick),
       22*     install(86-11-20,MR12.0-1222):
       23*     changed the calling sequence of list_init_ to include a segment pointer.
       24*     changed the parameter list of the following entrypoints (for_linker
       25*     star_heap) to include a segment pointer. Added an entrypoint named pointer
       26*     to allow system links to have pointer initialization.
       27*  3) change(86-06-24,DGHowe), approve(86-06-24,MCR7421), audit(86-11-13,Zwick),
       28*     install(86-11-20,MR12.0-1222):
       29*     removed the entrypoint allocate as it was not being used by the routine it
       30*     was meant for.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 /* MODIFICATION NOTICES -------------------------------------
       35*
       36*   Written by M. Weaver in 1976.
       37*   Modified by M. Jordan 1981 to add $locate
       38*   Modified by M. Weaver December 1982 to call fortran_storage_manager_ for
       39*    	LIST_TEMPLATE_INIT and to add entries for the linker and the trap 
       40*	procedure
       41*   Modified by T. Oke January 27 1983 to fix list_init_ ref to node_ptr to ref
       42*	  p (which is the real pointer to the node at that point).
       43*   Modified by M. Weaver February 1983 to set have_vla_variables flag
       44*   Modified by M. Weaver December 1984 to catch the 
       45*	  malformed_list_template_entry_ condition
       46*   ------------------------------------------------------------ */
       47 
       48 
       49 /* format: style3,^indnoniterdo */
       50 
       51 /* ENTRYPOINTS in set_ext_variable_
       52*   set_ext_variable_ called by users to find or allocate *system variables
       53*   locate		 called to find *system links on the name table
       54*   for_linker	 called by link snap to allocate or find *system links
       55*   star_heap	 called by link snap to allocate or find *heap links.
       56*   pointer	 called by the user to allcoate or find *system variables
       57*		 allows for pointer initialization via list_init_
       58**/
       59 
       60 set_ext_variable_:
       61      proc (a_ext_name, a_init_info_ptr, a_sb, a_found_sw, a_node_ptr, a_code);
       62 
       63 
       64 
       65 /* This procedure looks up the *system link symbol name in the name table.
       66*   If the name is not found, the variable is added.
       67*   If the requested size is larger, an error is returned.
       68*
       69*   This entry is not called in ring 0 because it calls fortran_storage_manager_
       70*   directly to allocate the variable if the size > sys_info_$max_seg_size.
       71*   This entry is intended to be called by set_fortran_common and by
       72*   fortran_storage_ in the normal case.
       73**/
       74 
       75 /* parameters */
       76 
       77 dcl	a_ext_name	char (*) parameter;		/* variable name */
       78 dcl	a_found_sw	bit (1) aligned parameter;	/* is it found */
       79 dcl	a_code		fixed bin (35) parameter;	/* system error code */
       80 dcl	a_def_ptr		pointer parameter;		/* ptr to the def for the lk */
       81 dcl	a_node_ptr	pointer parameter;		/* returned ptr to the target*/
       82 dcl	a_link_ptr	pointer parameter;		/* */
       83 dcl	a_mc_ptr		pointer parameter;		/* ptr to the machine conds */
       84 dcl	a_seg_ptr		pointer parameter;		/* ptr to segmetn containing the reference */
       85 dcl	a_type_ptr	pointer parameter;		/* ptr to type pair */
       86 
       87 dcl	a_init_info_ptr	pointer parameter;		/* pointer to init info */
       88 dcl	a_sb		pointer parameter;		/* pointer to stack header */
       89 
       90 /* local vars */
       91 
       92 dcl	found		bit (1);			/* temp found bit */
       93 dcl	hash_index	fixed bin (6);		/* index into hash table for the ext name */
       94 dcl	heap_header_ptr	pointer;			/* ptr to heap header */
       95 dcl	is_heap_link	bit (1) init ("0"b);	/* specifies we are working on a heap link */
       96 dcl	i		fixed bin;		/* used in loop to init hash table */
       97 dcl	called_by_linker	bit (1) aligned;		/* bits specifying called info */
       98 dcl	loop_count	fixed bin;		/* number of times we have performed a look up loop */
       99 dcl	nchars		fixed bin;		/* length of ext name */
      100 dcl	(new_ptr, table_ptr)
      101 			pointer;			/* ptr to variable and var table */
      102 dcl	ring_no		fixed bin;
      103 dcl	seg_ptr		pointer automatic;		/* autmatic var for seg ptr value */
      104 dcl	(t1, t2, t3, t4)	fixed bin (71);		/* clock times for calculating meters */
      105 dcl	var_ptr		pointer;			/* points to variable_node */
      106 dcl	vsize		fixed bin (35);		/* size of variable to allocate */
      107 dcl	where_to_allocate_ptr
      108 			pointer automatic;		/* ptr to area where we should allocate our structs */
      109 
      110 
      111 
      112 /* based */
      113 
      114 dcl	based_area	area (vsize) based;		/* an overlay area to allocate in */
      115 dcl	variable		(vsize) fixed bin (35) based; /* the actual variable */
      116 
      117 /* conditions */
      118 
      119 dcl	area		condition;
      120 dcl	bad_area_format	condition;
      121 
      122 
      123 /* external routines */
      124 
      125 dcl	cu_$level_get	entry (fixed bin);
      126 dcl	hcs_$make_seg	entry (char (*), char (*), char (*), fixed bin (5), pointer, fixed bin (35));
      127 dcl	unique_chars_	entry (bit (*)) returns (char (15));
      128 dcl	fortran_storage_manager_$alloc
      129 			entry (fixed bin, pointer, pointer);
      130 dcl	heap_manager_$create_heap_for_set_ext_var
      131 			entry (pointer, fixed bin, pointer, fixed bin (35));
      132 dcl	list_init_$variable_already_zero
      133 			entry (pointer, pointer, fixed bin (35), pointer, pointer, fixed bin (35));
      134 dcl	trap_caller_caller_ entry (pointer, pointer, pointer, pointer, pointer, pointer, fixed bin (35));
      135 
      136 /* external variables */
      137 
      138 dcl	(
      139 	error_table_$invalid_heap,
      140 	error_table_$invalid_heap_var_size,
      141 	error_table_$bigger_ext_variable,
      142 	error_table_$notalloc,
      143 	error_table_$noalloc,
      144 	error_table_$defs_loop,
      145 	error_table_$no_ext_sym,
      146 	error_table_$bad_link_target_init_info
      147 	)		ext fixed bin (35);
      148 dcl	sys_info$max_seg_size
      149 			fixed bin (19) ext;
      150 dcl	pl1_operators_$VLA_words_per_seg_
      151 			fixed bin (19) ext;
      152 
      153 
      154 
      155 /*		BUILTIN FUNCTIONS		*/
      156 
      157 
      158 dcl	(addr, bin, clock, divide, empty,  hbound, lbound,
      159 	 length, max, multiply, null, ptr, rtrim, substr,
      160 	 unspec, vclock)		builtin;
      161 
      162 
      163 /* set_ext_variable_ starts here .. set initial values for check bits */
      164 
      165 	called_by_linker = "0"b;			/* this entry called outside ring 0 */
      166 	is_heap_link = "0"b;
      167 	seg_ptr = null ();				/* can't do ptr init */
      168 	where_to_allocate_ptr = a_sb -> stack_header.user_free_ptr;
      169 	table_ptr = a_sb -> stack_header.sys_link_info_ptr;
      170 
      171 /* this is a block of common code used by set_ext_var$allocate and 
      172*   set_ext_var$for_linker and set_ext_var$star_heap.
      173*
      174*   we check for no var table and make sure the init info passed to us is
      175*   valid
      176**/
      177 
      178 JOIN:
      179 	a_found_sw = "0"b;
      180 	a_node_ptr = null;
      181 	a_code = 0;
      182 
      183 
      184 	on bad_area_format, area
      185 	     begin;
      186 		a_code = error_table_$notalloc;
      187 		goto ERROR;
      188 	     end;
      189 
      190 	nchars = length (rtrim (a_ext_name));
      191 	hash_index = HASH ();
      192 
      193 /* check init info setting vsize if 0 no init and we set an error
      194*   after allocating the table if it doesnot exist
      195**/
      196 
      197 	if a_init_info_ptr ^= null
      198 	then do;
      199 	     vsize = a_init_info_ptr -> init_info.size;
      200 	     if a_ext_name = "blnk*com"
      201 	     then vsize = max (sys_info$max_seg_size - 50, vsize);
      202 	     if vsize < 0
      203 	     then do;
      204 		a_code = error_table_$bad_link_target_init_info;
      205 		return;
      206 	     end;
      207 	end;
      208 	else vsize = 0;				/*  = a_def_ptr indicates no init info, don't create */
      209 
      210 /* If invoked from the user ring, there is a small window here.  The
      211*   user can quit while we are in the trap procedure and invoke a
      212*   program which causes the variable (or one with the same name) to be
      213*   allocated.  However the same thing can happen (with a smaller
      214*   window) when set_ext_variable_ is called in the user ring.  I don't
      215*   think that this will be a problem in practice. 
      216**/
      217 
      218 
      219 	if table_ptr = null ()
      220 	then do;
      221 	     allocate variable_table_header in (where_to_allocate_ptr -> based_area) set (table_ptr);
      222 	     if ^is_heap_link
      223 	     then a_sb -> stack_header.sys_link_info_ptr = table_ptr;
      224 	     else heap_header_ptr -> heap_header.heap_name_list_ptr = table_ptr;
      225 
      226 /* initialize table  */
      227 
      228 	     do i = lbound (table_ptr -> variable_table_header.hash_table, 1)
      229 		to hbound (table_ptr -> variable_table_header.hash_table, 1);
      230 		table_ptr -> variable_table_header.hash_table (i) = null;
      231 	     end;
      232 	end;
      233 	else do;					/* search only if table was already initialized */
      234 	     call LOOKUP ();
      235 	     if a_code ^= 0
      236 	     then return;
      237 	     a_found_sw = found;
      238 	     if found
      239 	     then do;
      240 		if vsize > var_ptr -> variable_node.vbl_size
      241 		then a_code = error_table_$bigger_ext_variable;
      242 		return;
      243 	     end;
      244 	end;
      245 
      246 /* no existing variable by this name; must allocate */
      247 
      248 	if vsize = 0 & ^is_heap_link
      249 	then do;					/* no init info; can't create */
      250 	     a_code = error_table_$no_ext_sym;
      251 	     return;
      252 	end;
      253 	else if ((vsize = 0) | (vsize > (sys_info$max_seg_size - 50))) & is_heap_link
      254 	then do;
      255 	     a_code = error_table_$invalid_heap_var_size;
      256 	     return;
      257 	end;
      258 
      259 
      260 /* Check for valid initialization types before allocating and threading so
      261*   we won't have to undo the allocation. */
      262 
      263 	if (a_init_info_ptr -> init_info.type ^= NO_INIT) & (a_init_info_ptr -> init_info.type ^= TEMPLATE_INIT)
      264 	     & (a_init_info_ptr -> init_info.type ^= EMPTY_AREA_INIT)
      265 	     & (a_init_info_ptr -> init_info.type ^= LIST_TEMPLATE_INIT)
      266 	then do;
      267 	     a_code = error_table_$bad_link_target_init_info;
      268 	     return;
      269 	end;
      270 
      271 
      272 /* allocate the var node and check for valid init type. call out if
      273*   we have a vla -- to fortran_storage_manager (this will not return to here)
      274*   if doen via trap caller caller. other wise allocate the variable it self and
      275*   add it to the variable name list at its hash index
      276**/
      277 
      278 	t3 = vclock ();
      279 
      280 	allocate variable_node in (where_to_allocate_ptr -> based_area) set (var_ptr);
      281 
      282 	if vsize > sys_info$max_seg_size
      283 	then do;
      284 	     if (a_init_info_ptr -> init_info.type ^= NO_INIT)
      285 		& (a_init_info_ptr -> init_info.type ^= LIST_TEMPLATE_INIT)
      286 	     then do;				/* multi_seg variable can't have template or be an area */
      287 		free var_ptr -> variable_node;
      288 		a_code = error_table_$bad_link_target_init_info;
      289 		return;
      290 	     end;
      291 	     if called_by_linker
      292 	     then call trap_caller_caller_ (a_mc_ptr, null, a_def_ptr, a_type_ptr, a_link_ptr, null, a_code);
      293 	     else call fortran_storage_manager_$alloc (
      294 		     divide (vsize + pl1_operators_$VLA_words_per_seg_ - 1, pl1_operators_$VLA_words_per_seg_, 17),
      295 		     var_ptr, new_ptr);
      296 	end;
      297 
      298 	else if vsize > (sys_info$max_seg_size - 50)
      299 	then do;
      300 	     call hcs_$make_seg ("", unique_chars_ (""b) || "linker", "", 01110b, new_ptr, a_code);
      301 	     if a_code ^= 0
      302 	     then do;
      303 		free var_ptr -> variable_node;
      304 		a_code = error_table_$noalloc;
      305 		return;
      306 	     end;
      307 	end;
      308 
      309 /* *heap links should always come here as they can not be bigger than 
      310*   mxsegsiz-50 */
      311 
      312 	else allocate variable in (where_to_allocate_ptr -> based_area) set (new_ptr);
      313 
      314 	var_ptr -> variable_node.forward_thread = table_ptr -> variable_table_header.hash_table (hash_index);
      315 	table_ptr -> variable_table_header.hash_table (hash_index) = var_ptr;
      316 	var_ptr -> variable_node.name_size = nchars;
      317 	var_ptr -> variable_node.name = substr (a_ext_name, 1, nchars);
      318 	var_ptr -> variable_node.vbl_ptr = new_ptr;
      319 	var_ptr -> variable_node.vbl_size = vsize;
      320 	var_ptr -> variable_node.init_type = a_init_info_ptr -> init_info.type;
      321 	var_ptr -> variable_node.init_ptr = a_init_info_ptr;
      322 	if seg_ptr ^= null ()
      323 	then var_ptr -> variable_node.seg_ptr = ptr (seg_ptr, 0);
      324 	else var_ptr -> variable_node.seg_ptr = null ();
      325 	if vsize > sys_info$max_seg_size
      326 	then table_ptr -> variable_table_header.flags.have_vla_variables = "1"b;
      327 						/* let run_ know to clean up */
      328 
      329 /* Initialize the variable.
      330**/
      331 
      332 	if a_init_info_ptr -> init_info.type ^= 0
      333 	then do;
      334 	     if a_init_info_ptr -> init_info.type = EMPTY_AREA_INIT
      335 	     then var_ptr -> variable_node.vbl_ptr -> based_area = empty ();
      336 	     else if a_init_info_ptr -> init_info.type = TEMPLATE_INIT
      337 	     then var_ptr -> variable_node.vbl_ptr -> variable = a_init_info_ptr -> init_info.init_template;
      338 	     else if a_init_info_ptr -> init_info.type = LIST_TEMPLATE_INIT
      339 	     then do;
      340 		call list_init_$variable_already_zero (var_ptr -> variable_node.vbl_ptr,
      341 		     addr (a_init_info_ptr -> list_init_info.template), vsize, a_sb, seg_ptr, a_code);
      342 		if a_code ^= 0
      343 		then go to FINISH_METERS;		/* might as well fill in meters */
      344 	     end;
      345 	end;
      346 
      347 FINISH_METERS:					/* complete the metering information. generally this is the number of ext vars
      348*   and how long it takes to work on them
      349**/
      350 	t4 = vclock ();
      351 	table_ptr -> variable_table_header.total_allocation_time =
      352 	     table_ptr -> variable_table_header.total_allocation_time + t4 - t3;
      353 	table_ptr -> variable_table_header.total_allocated_size =
      354 	     table_ptr -> variable_table_header.total_allocated_size + vsize;
      355 	table_ptr -> variable_table_header.number_of_variables =
      356 	     table_ptr -> variable_table_header.number_of_variables + 1;
      357 	table_ptr -> variable_table_header.cur_num_of_variables =
      358 	     table_ptr -> variable_table_header.cur_num_of_variables + 1;
      359 	var_ptr -> variable_node.time_allocated = clock ();
      360 	a_node_ptr = var_ptr;
      361 
      362 
      363 ERROR:						/* nonlocal label for condition handlers */
      364 	return;
      365 
      366 /* NOTE the code removed from the following space was documented out
      367*   for the following reason and was deleted to clean up the code.
      368*
      369*   Following is the code  that was used to automatically reallocate
      370*   the variable's storage if the new size is larger than the old size.
      371*   It was removed because it had bad side effects-- programs saved 
      372*   pointers to the original storage and got faults at some indefinite
      373*   time after the reallocation.
      374*
      375*  It is impossible to guarantee that a user will not reference the 
      376*  reallocated area via an automatic pointer.
      377*
      378**/
      379 
      380 /* this fuction performs the hashing alogorithm */
      381 
      382 HASH:
      383      proc () returns (fixed bin (6));
      384 
      385 
      386 dcl	tname		char (16);
      387 dcl	w		(4) fixed bin (30) based (addr (tname));
      388 dcl	hash_temp		fixed bin (71);
      389 dcl	hash_index	fixed bin (6);
      390 
      391 
      392 	tname = a_ext_name;
      393 	hash_temp = multiply ((w (1) + w (2)), (w (3) + w (4)), 71);
      394 	hash_index = bin (substr (unspec (hash_temp), 31, 6), 6);
      395 
      396 	return (hash_index);
      397 
      398 
      399      end HASH;
      400 
      401 /* this funciton looks through a index into the hash table for a specific name
      402*   it expects a_ext_name and table_ptr to be set elsewhere. it sets found and 
      403*   a_node_ptr if the name is found on the name list
      404**/
      405 LOOKUP:
      406      proc ();
      407 
      408 
      409 	found = "0"b;
      410 
      411 	table_ptr -> variable_table_header.number_of_searches =
      412 	     table_ptr -> variable_table_header.number_of_searches + 1;
      413 	t1 = vclock ();
      414 	loop_count = 0;
      415 	do var_ptr = table_ptr -> variable_table_header.hash_table (hash_index)
      416 	     repeat (var_ptr -> variable_node.forward_thread) while (var_ptr ^= null ());
      417 	     loop_count = loop_count + 1;
      418 	     if loop_count > 200
      419 	     then do;
      420 		a_code = error_table_$defs_loop;
      421 		return;
      422 	     end;
      423 	     table_ptr -> variable_table_header.number_of_steps =
      424 		table_ptr -> variable_table_header.number_of_steps + 1;
      425 	     if var_ptr -> variable_node.name_size = nchars
      426 	     then if var_ptr -> variable_node.name = a_ext_name
      427 		then do;
      428 		     t2 = vclock ();		/* done searching */
      429 		     table_ptr -> variable_table_header.total_search_time =
      430 			table_ptr -> variable_table_header.total_search_time + t2 - t1;
      431 		     a_node_ptr = var_ptr;
      432 		     found = "1"b;
      433 		     return;
      434 		end;
      435 	end;					/* of searching */
      436 
      437 	t2 = vclock ();
      438 	table_ptr -> variable_table_header.total_search_time =
      439 	     table_ptr -> variable_table_header.total_search_time + t2 - t1;
      440 
      441 	return;
      442 
      443 
      444      end LOOKUP;
      445 
      446 /* END LOCAL ROUTINES ------------------------------------------------- */
      447 
      448 /* EXTERNAL ENTRYPOINTS ----------------------------------------------- */
      449 
      450 /* locate is used to find ext vars on the external var list and returns a ptr
      451*   to them in a_node_ptr; It expects the var to exist as well as the var table
      452*
      453*   parameters
      454*   a_ext_name       variable name to be found
      455*   a_sb		stack base ptr of callers stack
      456*   a_node_ptr	ptr to variable (Output)
      457*   a_code		system error code
      458*
      459**/
      460 
      461 locate:
      462      entry (a_ext_name, a_sb, a_node_ptr, a_code);
      463 
      464 
      465 	a_node_ptr = null ();
      466 	a_code = 0;
      467 	table_ptr = a_sb -> stack_header.sys_link_info_ptr;
      468 
      469 	if table_ptr = null ()
      470 	then do;
      471 NOT_FOUND:
      472 	     a_code = error_table_$no_ext_sym;
      473 	     return;
      474 	end;
      475 
      476 	nchars = length (rtrim (a_ext_name));
      477 	hash_index = HASH ();
      478 	call LOOKUP ();				/* now try to find the variable */
      479 	if a_code ^= 0
      480 	then return;				/* some error has occured */
      481 	if ^found
      482 	then goto NOT_FOUND;			/* the symbol was not found */
      483 
      484 	return;
      485 
      486 
      487 /* for_linker
      488*   This entry must be called when in ring 0 and only in ring 0.
      489*   If a multi_segment variable is to be created, this entry traps out
      490*   to fortran_storage_ in the user ring, which in turn calls
      491*   set_ext_variable_$allocate.
      492*
      493*   parameters
      494*     a_ext_name      the name of the variable (Input)
      495*     a_init_info_ptr a pointer to initialization informatio for the 
      496*		 variable (Input)
      497*     a_sb		 a pointer to the targets stack header ie in the
      498*		 ring where the link was faulted (Input)
      499*     a_seg_ptr	 pointer to the seg containing the ext reference (Input)
      500*     a_found_sw	 specifies if the variable was found (Output)
      501*     a_node_ptr	 a pointer to the target variable (Output)
      502*     a_code	 a system error_code (Output)
      503*     a_mc_ptr	 a pointer to the machine conditions for 
      504*		 trap_caller_caller_
      505*     a_def_ptr	 passed on to trap_caller_caller_
      506*     a_type_ptr	 passed on to trap_caller_caller_
      507*     a_link_ptr	 passed on to trap_caller_caller_
      508**/
      509 
      510 for_linker:
      511      entry (a_ext_name, a_init_info_ptr, a_sb, a_seg_ptr, a_found_sw, a_node_ptr, a_code, a_mc_ptr, a_def_ptr, a_type_ptr,
      512 	a_link_ptr);
      513 
      514 	called_by_linker = "1"b;
      515 	is_heap_link = "0"b;
      516 	seg_ptr = a_seg_ptr;
      517 	where_to_allocate_ptr = a_sb -> stack_header.user_free_ptr;
      518 	table_ptr = a_sb -> stack_header.sys_link_info_ptr;
      519 
      520 	goto JOIN;
      521 
      522 /* star_heap
      523*   allocates and initializes heap variables or finds them on the
      524*   existing heap list and returns a pointer to the target in a_node_ptr
      525*
      526*   paramters
      527*     a_ext_name      the name of the variable (Input)
      528*     a_init_info_ptr a pointer to initialization information for the 
      529*		 variable (Input)
      530*     a_sb		 a pointer to the targets stack header ie in the
      531*		 ring where the link was faulted (Input)
      532*     a_seg_ptr	 pointer to the seg containing the ext reference (Input)
      533*     a_found_sw	 specifies if the variable was found (Output)
      534*     a_node_ptr	 a pointer to the target variable (Output)
      535*     a_code	 a system error_code (Output)
      536**/
      537 
      538 star_heap:
      539      entry (a_ext_name, a_init_info_ptr, a_sb, a_seg_ptr, a_found_sw, a_node_ptr, a_code);
      540 
      541 /* initialize values required by the general code */
      542 
      543 	called_by_linker = "0"b;
      544 	is_heap_link = "1"b;
      545 	a_found_sw = "0"b;
      546 	a_node_ptr = null;
      547 	seg_ptr = a_seg_ptr;
      548 	vsize = 0;
      549 	a_code = 0;
      550 
      551 	on bad_area_format, area
      552 	     begin;
      553 		a_code = error_table_$notalloc;
      554 		goto ERROR;
      555 	     end;
      556 
      557 
      558 /* check and see if we have a heap area defined 
      559**/
      560 
      561 	heap_header_ptr = a_sb -> stack_header.heap_header_ptr;
      562 	if heap_header_ptr = null ()
      563 	then do;
      564 
      565 /* if we do not have a heap it means we have been entered either from a non
      566*   C program or someone is executing a C program without using main_.
      567*   This is not nice but we set up a heap level 0 anyway....
      568*   This is similar to heap_manager_$push_heap_level but not quite the
      569*   same in that it is using level 0....
      570**/
      571 	     a_code = 0;
      572 	     call cu_$level_get (ring_no);		/* get ring no for Heap area owner name */
      573 	     call heap_manager_$create_heap_for_set_ext_var (a_sb, ring_no, heap_header_ptr, a_code);
      574 	     if a_code ^= 0 then
      575 		return;
      576 	end;
      577 	if (heap_header_ptr -> heap_header.version ^= heap_header_version_1)
      578 	then do;
      579 	     a_code = error_table_$invalid_heap;
      580 	     return;
      581 	end;
      582 
      583 	where_to_allocate_ptr = a_sb -> stack_header.heap_header_ptr -> heap_header.area_ptr;
      584 
      585 	table_ptr = heap_header_ptr -> heap_header.heap_name_list_ptr;
      586 
      587 	goto JOIN;
      588 
      589 /* allows *system variable to have pointer initialization using 
      590*   the list_init_template structure. finds or allocates *system variables.
      591*
      592*   paramters
      593*     a_ext_name      the name of the variable (Input)
      594*     a_init_info_ptr a pointer to initialization information for the 
      595*		 variable (Input)
      596*     a_sb		 a pointer to the targets stack header ie in the
      597*		 ring where the link was faulted (Input)
      598*     a_seg_ptr	 pointer to the seg containing the ext reference (Input)
      599*     a_found_sw	 specifies if the variable was found (Output)
      600*     a_node_ptr	 a pointer to the target variable (Output)
      601*     a_code	 a system error_code (Output)
      602**/
      603 
      604 pointer:
      605      entry (a_ext_name, a_init_info_ptr, a_sb, a_seg_ptr, a_found_sw, a_node_ptr, a_code);
      606 
      607 
      608 	called_by_linker = "0"b;			/* this entry called outside ring 0 */
      609 	is_heap_link = "0"b;
      610 	seg_ptr = a_seg_ptr;
      611 	where_to_allocate_ptr = a_sb -> stack_header.user_free_ptr;
      612 	table_ptr = a_sb -> stack_header.sys_link_info_ptr;
      613 	goto JOIN;
      614 
      615 
      616 /* END EXTERNAL ENTRYPOINTS --------------------------------------- */
      617 
      618 /* INCLUDE FILES -------------------------------------------------- */
  1     1 /* BEGIN INCLUDE FILE ... system_link_names.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396), audit(86-11-12,Zwick),
  1     6*     install(86-11-20,MR12.0-1222):
  1     7*     added the declaration of the heap_header.
  1     8*  2) change(86-10-20,DGHowe), approve(86-10-20,MCR7420), audit(86-11-12,Zwick),
  1     9*     install(86-11-20,MR12.0-1222):
  1    10*     add the seg ptr to the variable node structure.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 
  1    14 /* created by M. Weaver 7/28/76 */
  1    15 /* Modified: 82-11-19 by T. Oke to add LIST_TEMPLATE_INIT. */
  1    16 /* Modified 02/11/83 by M. Weaver to add have_vla_variables flag */
  1    17 
  1    18 
  1    19 dcl 1 variable_table_header aligned based,	/* header for name table */
  1    20      2 hash_table (0:63) ptr unaligned,		/* hash table for variable nodes */
  1    21      2 total_search_time fixed bin (71),	/* total time to search for variables */
  1    22      2 total_allocation_time fixed bin (71),	/* total time spent allocating and initializing nodes and variables */
  1    23      2 number_of_searches fixed bin,		/* number of times names were looked up */
  1    24      2 number_of_variables fixed bin (35),	/* number of variables allocated by the linker, incl deletions */
  1    25      2 flags unaligned,
  1    26         3 have_vla_variables bit (1) unaligned,	/* on if some variables are > sys_info$max_seg_size */
  1    27         3 pad bit (11) unaligned,
  1    28      2 cur_num_of_variables fixed bin (24) unal,	/* current number of variables allocated */
  1    29      2 number_of_steps fixed bin,		/* total number of nodes looked at */
  1    30      2 total_allocated_size fixed bin (35);	/* current amount of storage in user area */
  1    31 
  1    32 
  1    33 dcl 1 variable_node aligned based,		/* individual variable information */
  1    34      2 forward_thread ptr unaligned,		/* thread to next node off same hash bucket */
  1    35      2 vbl_size fixed bin (24) unsigned unaligned, /* length in words of variable */
  1    36      2 init_type fixed bin (11) unaligned,	/* 0=not init; 3=init template; 4=area 5=list_template*/
  1    37      2 time_allocated fixed bin (71),		/* time when variable was allocated */
  1    38      2 vbl_ptr ptr,				/* pointer to variable's storage */
  1    39      2 init_ptr ptr,			/* pointer to original init info in object seg */
  1    40      2 name_size fixed bin(21) aligned,		/* length of name in characters */
  1    41      2 name char (nchars refer (variable_node.name_size)), /* name of variable */
  1    42      2 seg_ptr  pointer;
  1    43 
  1    44 /* variable_node.seg_ptr
  1    45*   Is a pointer to the segment containing the initialization information
  1    46*   for this variable. It is used as a segment base pointer for external
  1    47*   pointer initialization via list_init_.
  1    48*
  1    49*   The init_ptr can not be used as a reference to the defining segment
  1    50*   due to the possibility of set_fortran_common being used to initialize
  1    51*   the external variables. sfc will generate an initialization information
  1    52*   structure if multiple intialization sizes are found in the specified 
  1    53*   segments. sfc stores the address of this structure in the init_ptr field.
  1    54*   This is one reason why sfc does not perform external pointer 
  1    55*   initialization.
  1    56*
  1    57*   The seg_ptr is set to point at the segment used to define the 
  1    58*   initialization information. term_ sets this field to null on termination
  1    59*   due to the possiblity of executing a different segment which defines
  1    60*   initialization information. In this way the seg_ptr field will either
  1    61*   be valid or null.
  1    62**/
  1    63 
  1    64 dcl 1 heap_header based,
  1    65      2 version            char(8),                /* specifies the verison of the header */
  1    66      2 heap_name_list_ptr pointer,		/* points to the variable_table_header for this heap */
  1    67      2 previous_heap_ptr  pointer,		/* points to the previous heap or is null */
  1    68      2 area_ptr	      pointer,		/* points to the heap area */
  1    69      2 execution_level    fixed bin (17);	/* specifies the execution level this header deals with */
  1    70 
  1    71 dcl heap_header_version_1 char(8) static options (constant)
  1    72 			    init ("Heap_v01");
  1    73 	
  1    74 
  1    75 /* END INCLUDE FILE ... system_link_names.incl.pl1 */
      619 
      620 
  2     1 /* Begin include file ... system_link_init_info.incl.pl1 ... 5/6/80 MRJ */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     8*     Modified to declare DEFERRED_INIT type constant.
  2     9*  2) change(86-06-24,DGHowe), approve(86-06-24,MCR7420), audit(86-11-12,Zwick),
  2    10*     install(86-11-20,MR12.0-1222):
  2    11*     added the external pointer initialization structure and the constants
  2    12*     required to use them.
  2    13*                                                   END HISTORY COMMENTS */
  2    14 
  2    15 
  2    16 /* Modified: 82-11-17 by T. Oke to add list_init_info and LIST_TEMPLATE_INIT. */
  2    17 
  2    18 /* format: style3,idind25 */
  2    19 
  2    20 /* NOTE --------------------------------------------------
  2    21*   the following structures defining initialization information can also
  2    22*   be found in fortran_storage.incl.pl1  definition_dcls.incl.pl1
  2    23*   and should be kept equivalent
  2    24*   -------------------------------------------------------
  2    25**/
  2    26 
  2    27 dcl	init_info_ptr	     ptr;			/* ptr to structure below */
  2    28 dcl	init_size		     fixed bin (35);	/* size (in words) of initialization template */
  2    29 
  2    30 dcl	1 init_info	     aligned based (init_info_ptr),
  2    31 	  2 size		     fixed bin (35),	/* size (in words) of data */
  2    32 	  2 type		     fixed bin,		/* type of initialization: see below */
  2    33 	  2 init_template	     (init_size refer (init_info.size)) fixed bin (35);
  2    34 
  2    35 dcl	1 init_info_single_word  aligned based (init_info_ptr),
  2    36 						/* for convenience of people like ssi */
  2    37 	  2 size		     fixed bin (19),	/* = 1 */
  2    38 	  2 type		     fixed bin,		/* = TEMPLATE_INIT */
  2    39 	  2 init_template	     (1) fixed bin (35);	/* = value */
  2    40 
  2    41 dcl	1 list_init_info	     aligned based,
  2    42 	  2 size		     fixed bin (35),	/* length of variable */
  2    43 	  2 type		     fixed bin,		/* LIST_TEMPLATE_INIT */
  2    44 	  2 pad		     bit (18) unaligned,
  2    45 	  2 list_size	     fixed bin (18) unsigned unaligned,
  2    46 						/* size in words of template */
  2    47 	  2 template	     (0 refer (list_init_info.list_size)) bit (36);
  2    48 						/* first create_entry position */
  2    49 
  2    50 /* A list template consists of a series of entries with the following
  2    51*   description, concatenated together.  n_bits and datum are bit items,
  2    52*   to permit a wide range of inputs.
  2    53*
  2    54*   1.  A 'repeat' of '0' signifies skipping of 'n_bits' bits.
  2    55*   2.  A 'n_bits' of '0' signifies the last item of the list.
  2    56*
  2    57*   COMMON, VLA's, and LA's are presumed to start at the base pointer
  2    58*   of their particular storage section. */
  2    59 
  2    60 dcl	1 list_template_entry    aligned based,
  2    61 	  2 n_bits	     fixed bin (35) aligned,	/* size of datum */
  2    62 	  2 mbz		     bit (3) unaligned,	/* future expansion */
  2    63 	  2 init_type	     fixed bin (3) unsigned unaligned, /* 0 normal init, 1 ptr init, 2 packed ptr init */
  2    64 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2    65 						/* number of times to repeat datum */
  2    66 	  2 datum		     bit (init_n_bits_in_datum refer (list_template_entry.n_bits));
  2    67 
  2    68 /* list_template_entry_ptr is defined such that it can be used as an
  2    69*   automatic definition overlay with a fixed size datum. it has a declared 
  2    70*   size of 72 to allow for the its pointer sixe of 72 bits.
  2    71**/
  2    72 
  2    73 dcl	1 list_template_entry_ptr	aligned based,
  2    74 	  2 n_bits	     fixed bin (35) aligned,
  2    75 	  2 mbz		     bit(3) unaligned,
  2    76 	  2 init_type	     fixed bin (3) unsigned unaligned,
  2    77 	  2 repeat	     fixed bin (30) unsigned unaligned,
  2    78 	  2 datum		     bit(72);
  2    79 
  2    80 /* the pointer_init_template represents the initialization information
  2    81*   for ITS and packed pointers.  Both pointer types require the entire
  2    82*   72 bit structure.
  2    83**/
  2    84 
  2    85 dcl       1 pointer_init_template  based,
  2    86 	  2 ptr_type	     fixed bin (18) unsigned unaligned,  /* 0 text section, 1 linkage section, 2 static section */
  2    87 	  2 section_offset	     fixed bin (18) unsigned unaligned,  /* offset to item in specified section */
  2    88 	  2 word_offset	     fixed bin (18) unsigned unaligned,  /* word offset from section item to target */
  2    89 	  2 mbz		     bit (12) unaligned,
  2    90 	  2 bit_offset	     fixed bin (6) unsigned unaligned;   /* bit offset from section item|word offset to target */
  2    91 
  2    92 
  2    93 dcl	init_n_bits_in_datum     fixed bin (35);
  2    94 
  2    95 dcl	NO_INIT		     fixed bin static options (constant) init (0);
  2    96 dcl	TEMPLATE_INIT	     fixed bin static options (constant) init (3);
  2    97 dcl	EMPTY_AREA_INIT	     fixed bin static options (constant) init (4);
  2    98 dcl	LIST_TEMPLATE_INIT	     fixed bin static options (constant) init (5);
  2    99 dcl	INIT_DEFERRED	     fixed bin static options (constant) init (6);
  2   100 dcl	ITS_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(1);
  2   101 dcl	PACKED_PTR_INIT	     fixed bin (3) unsigned static options (constant) init(2);
  2   102 dcl	PTR_INIT_TEXT	     fixed bin (17) static options (constant) init(0);
  2   103 dcl	PTR_INIT_LOT	     fixed bin (17) static options (constant) init(1);
  2   104 dcl	PTR_INIT_ISOT	     fixed bin (17) static options (constant) init(2);
  2   105 	
  2   106 
  2   107 /* End include file ... system_link_init_info.incl.pl1 */
      621 
      622 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      623 
      624 
      625      end set_ext_variable_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.9  set_ext_variable_.pl1             >spec>install>1110>set_ext_variable_.pl1
619          1    11/24/86  1226.9  system_link_names.incl.pl1        >ldd>include>system_link_names.incl.pl1
621          2    11/24/86  1226.9  system_link_init_info.incl.pl1    >ldd>include>system_link_init_info.incl.pl1
623          3    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EMPTY_AREA_INIT                        constant        fixed bin(17,0)          initial dcl 2-97 ref 263 334
LIST_TEMPLATE_INIT                     constant        fixed bin(17,0)          initial dcl 2-98 ref 263 284 338
NO_INIT                                constant        fixed bin(17,0)          initial dcl 2-95 ref 263 284
TEMPLATE_INIT                          constant        fixed bin(17,0)          initial dcl 2-96 ref 263 336
a_code                                 parameter       fixed bin(35,0)          dcl 79 set ref 60 181* 186* 204* 235 240* 250* 255*
                                                                                  267* 288* 291* 300* 301 304* 340* 342 420* 461
                                                                                  466* 471* 479 510 538 549* 553* 571* 573* 574 579*
                                                                                  604
a_def_ptr                              parameter       pointer                  dcl 80 set ref 291* 510
a_ext_name                             parameter       char                     packed unaligned dcl 77 ref 60 190 200 317 392 425
                                                                                  461 476 510 538 604
a_found_sw                             parameter       bit(1)                   dcl 78 set ref 60 178* 237* 510 538 545* 604
a_init_info_ptr                        parameter       pointer                  dcl 87 ref 60 197 199 263 263 263 263 284 284 320
                                                                                  321 332 334 336 336 338 340 340 510 538 604
a_link_ptr                             parameter       pointer                  dcl 82 set ref 291* 510
a_mc_ptr                               parameter       pointer                  dcl 83 set ref 291* 510
a_node_ptr                             parameter       pointer                  dcl 81 set ref 60 180* 360* 431* 461 465* 510 538
                                                                                  546* 604
a_sb                                   parameter       pointer                  dcl 88 set ref 60 168 169 222 340* 461 467 510 517
                                                                                  518 538 561 573* 583 604 611 612
a_seg_ptr                              parameter       pointer                  dcl 84 ref 510 516 538 547 604 610
a_type_ptr                             parameter       pointer                  dcl 85 set ref 291* 510
addr                                                   builtin function         dcl 158 ref 340 340 393 393 393 393
area                            000140 stack reference condition                dcl 119 ref 184 551
area_ptr                  6            based           pointer                  level 2 dcl 1-64 ref 583
bad_area_format                 000146 stack reference condition                dcl 120 ref 184 551
based_area                             based           area                     dcl 114 set ref 221 280 312 334*
bin                                                    builtin function         dcl 158 ref 394
called_by_linker                000106 automatic       bit(1)                   dcl 97 set ref 165* 291 514* 543* 608*
clock                                                  builtin function         dcl 158 ref 359
cu_$level_get                   000010 constant        entry                    external dcl 125 ref 572
cur_num_of_variables    106(12)        based           fixed bin(24,0)          level 2 packed packed unaligned dcl 1-19 set ref
                                                                                  357* 357
divide                                                 builtin function         dcl 158 ref 293 293
empty                                                  builtin function         dcl 158 ref 334
error_table_$bad_link_target_init_info
                                000044 external static fixed bin(35,0)          dcl 138 ref 204 267 288
error_table_$bigger_ext_variable
                                000032 external static fixed bin(35,0)          dcl 138 ref 240
error_table_$defs_loop          000040 external static fixed bin(35,0)          dcl 138 ref 420
error_table_$invalid_heap       000026 external static fixed bin(35,0)          dcl 138 ref 579
error_table_$invalid_heap_var_size
                                000030 external static fixed bin(35,0)          dcl 138 ref 255
error_table_$no_ext_sym         000042 external static fixed bin(35,0)          dcl 138 ref 250 471
error_table_$noalloc            000036 external static fixed bin(35,0)          dcl 138 ref 304
error_table_$notalloc           000034 external static fixed bin(35,0)          dcl 138 ref 186 553
flags                   106            based           structure                level 2 packed packed unaligned dcl 1-19
fortran_storage_manager_$alloc  000016 constant        entry                    external dcl 128 ref 293
forward_thread                         based           pointer                  level 2 packed packed unaligned dcl 1-33 set ref
                                                                                  314* 435
found                           000100 automatic       bit(1)                   packed unaligned dcl 92 set ref 237 238 409* 432*
                                                                                  481
hash_index                      000202 automatic       fixed bin(6,0)           dcl 389 in procedure "HASH" set ref 394* 396
hash_index                      000101 automatic       fixed bin(6,0)           dcl 93 in procedure "set_ext_variable_" set ref 191*
                                                                                  314 315 415 477*
hash_table                             based           pointer                  array level 2 packed packed unaligned dcl 1-19 set
                                                                                  ref 228 228 230* 314 315* 415
hash_temp                       000200 automatic       fixed bin(71,0)          dcl 388 set ref 393* 394
have_vla_variables      106            based           bit(1)                   level 3 packed packed unaligned dcl 1-19 set ref
                                                                                  325*
hbound                                                 builtin function         dcl 158 ref 228
hcs_$make_seg                   000012 constant        entry                    external dcl 126 ref 300
heap_header                            based           structure                level 1 unaligned dcl 1-64
heap_header_ptr                 000102 automatic       pointer                  dcl 94 in procedure "set_ext_variable_" set ref 224
                                                                                  561* 562 573* 577 585
heap_header_ptr          70            based           pointer                  level 2 in structure "stack_header" dcl 3-26
                                                                                  in procedure "set_ext_variable_" ref 561 583
heap_header_version_1           000000 constant        char(8)                  initial packed unaligned dcl 1-71 ref 577
heap_manager_$create_heap_for_set_ext_var
                                000020 constant        entry                    external dcl 130 ref 573
heap_name_list_ptr        2            based           pointer                  level 2 dcl 1-64 set ref 224* 585
i                               000105 automatic       fixed bin(17,0)          dcl 96 set ref 228* 230*
init_info                              based           structure                level 1 dcl 2-30
init_ptr                  6            based           pointer                  level 2 dcl 1-33 set ref 321*
init_template             2            based           fixed bin(35,0)          array level 2 dcl 2-30 ref 336
init_type                 1(24)        based           fixed bin(11,0)          level 2 packed packed unaligned dcl 1-33 set ref
                                                                                  320*
is_heap_link                    000104 automatic       bit(1)                   initial packed unaligned dcl 95 set ref 95* 166* 222
                                                                                  248 253 515* 544* 609*
lbound                                                 builtin function         dcl 158 ref 228
length                                                 builtin function         dcl 158 ref 190 476
list_init_$variable_already_zero
                                000022 constant        entry                    external dcl 132 ref 340
list_init_info                         based           structure                level 1 dcl 2-41
loop_count                      000107 automatic       fixed bin(17,0)          dcl 98 set ref 414* 417* 417 418
max                                                    builtin function         dcl 158 ref 200
multiply                                               builtin function         dcl 158 ref 393
name                     11            based           char                     level 2 dcl 1-33 set ref 317* 425
name_size                10            based           fixed bin(21,0)          level 2 dcl 1-33 set ref 280* 287 303 316* 317 322
                                                                                  324 425 425
nchars                          000110 automatic       fixed bin(17,0)          dcl 99 set ref 190* 280 280 316 317 425 476*
new_ptr                         000112 automatic       pointer                  dcl 100 set ref 293* 300* 312* 318
null                                                   builtin function         dcl 158 ref 167 180 197 219 230 291 291 291 291 322
                                                                                  324 415 465 469 546 562
number_of_searches      104            based           fixed bin(17,0)          level 2 dcl 1-19 set ref 411* 411
number_of_steps         110            based           fixed bin(17,0)          level 2 dcl 1-19 set ref 423* 423
number_of_variables     105            based           fixed bin(35,0)          level 2 dcl 1-19 set ref 355* 355
pl1_operators_$VLA_words_per_seg_
                                000050 external static fixed bin(19,0)          dcl 150 ref 293 293 293 293
ptr                                                    builtin function         dcl 158 ref 322
ring_no                         000116 automatic       fixed bin(17,0)          dcl 102 set ref 572* 573*
rtrim                                                  builtin function         dcl 158 ref 190 476
seg_ptr                                based           pointer                  level 2 in structure "variable_node" dcl 1-33
                                                                                  in procedure "set_ext_variable_" set ref 322* 324*
seg_ptr                         000120 automatic       pointer                  dcl 103 in procedure "set_ext_variable_" set ref
                                                                                  167* 322 322 340* 516* 547* 610*
size                                   based           fixed bin(35,0)          level 2 dcl 2-30 ref 199 336
stack_header                           based           structure                level 1 dcl 3-26
substr                                                 builtin function         dcl 158 ref 317 394
sys_info$max_seg_size           000046 external static fixed bin(19,0)          dcl 148 ref 200 253 282 298 325
sys_link_info_ptr        60            based           pointer                  level 2 dcl 3-26 set ref 169 222* 467 518 612
t1                              000122 automatic       fixed bin(71,0)          dcl 104 set ref 413* 429 438
t2                              000124 automatic       fixed bin(71,0)          dcl 104 set ref 428* 429 437* 438
t3                              000126 automatic       fixed bin(71,0)          dcl 104 set ref 278* 351
t4                              000130 automatic       fixed bin(71,0)          dcl 104 set ref 347* 351
table_ptr                       000114 automatic       pointer                  dcl 100 set ref 169* 219 221* 222 224 228 228 230
                                                                                  314 315 325 351 351 353 353 355 355 357 357 411
                                                                                  411 415 423 423 429 429 438 438 467* 469 518* 585*
                                                                                  612*
template                  3            based           bit(36)                  array level 2 dcl 2-41 set ref 340 340
time_allocated            2            based           fixed bin(71,0)          level 2 dcl 1-33 set ref 359*
tname                           000174 automatic       char(16)                 packed unaligned dcl 386 set ref 392* 393 393 393
                                                                                  393
total_allocated_size    111            based           fixed bin(35,0)          level 2 dcl 1-19 set ref 353* 353
total_allocation_time
                        102            based           fixed bin(71,0)          level 2 dcl 1-19 set ref 351* 351
total_search_time       100            based           fixed bin(71,0)          level 2 dcl 1-19 set ref 429* 429 438* 438
trap_caller_caller_             000024 constant        entry                    external dcl 134 ref 291
type                      1            based           fixed bin(17,0)          level 2 dcl 2-30 ref 263 263 263 263 284 284 320 332
                                                                                  334 336 338
unique_chars_                   000014 constant        entry                    external dcl 127 ref 300
unspec                                                 builtin function         dcl 158 ref 394
user_free_ptr            16            based           pointer                  level 2 dcl 3-26 ref 168 517 611
var_ptr                         000132 automatic       pointer                  dcl 105 set ref 240 280* 287 293* 303 314 315 316
                                                                                  317 318 319 320 321 322 324 334 336 340 359 360
                                                                                  415* 415* 425 425 431* 435
variable                               based           fixed bin(35,0)          array dcl 115 set ref 312 336*
variable_node                          based           structure                level 1 dcl 1-33 set ref 280 287 303
variable_table_header                  based           structure                level 1 dcl 1-19 set ref 221
vbl_ptr                   4            based           pointer                  level 2 dcl 1-33 set ref 318* 334 336 340*
vbl_size                  1            based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 1-33
                                                                                  set ref 240 319*
vclock                                                 builtin function         dcl 158 ref 278 347 413 428 437
version                                based           char(8)                  level 2 packed packed unaligned dcl 1-64 ref 577
vsize                           000134 automatic       fixed bin(35,0)          dcl 106 set ref 199* 200* 200 202 208* 240 248 253
                                                                                  253 282 293 293 298 312 319 325 334 336 340* 353
                                                                                  548*
w                                      based           fixed bin(30,0)          array dcl 387 ref 393 393 393 393
where_to_allocate_ptr           000136 automatic       pointer                  dcl 107 set ref 168* 221 280 312 517* 583* 611*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
INIT_DEFERRED                          internal static fixed bin(17,0)          initial dcl 2-99
ITS_PTR_INIT                           internal static fixed bin(3,0)           initial unsigned dcl 2-100
PACKED_PTR_INIT                        internal static fixed bin(3,0)           initial unsigned dcl 2-101
PTR_INIT_ISOT                          internal static fixed bin(17,0)          initial dcl 2-104
PTR_INIT_LOT                           internal static fixed bin(17,0)          initial dcl 2-103
PTR_INIT_TEXT                          internal static fixed bin(17,0)          initial dcl 2-102
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
init_info_ptr                          automatic       pointer                  dcl 2-27
init_info_single_word                  based           structure                level 1 dcl 2-35
init_n_bits_in_datum                   automatic       fixed bin(35,0)          dcl 2-93
init_size                              automatic       fixed bin(35,0)          dcl 2-28
list_template_entry                    based           structure                level 1 dcl 2-60
list_template_entry_ptr                based           structure                level 1 dcl 2-73
pointer_init_template                  based           structure                level 1 packed packed unaligned dcl 2-85
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
sb                                     automatic       pointer                  dcl 3-24
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           000773 constant        label                    dcl 363 ref 187 554
FINISH_METERS                   000741 constant        label                    dcl 347 set ref 342
HASH                            001364 constant        entry                    internal dcl 382 ref 191 477
JOIN                            000101 constant        label                    dcl 178 set ref 520 587 613
LOOKUP                          001410 constant        entry                    internal dcl 405 ref 234 478
NOT_FOUND                       001036 constant        label                    dcl 471 ref 481
for_linker                      001077 constant        entry                    external dcl 510
locate                          001001 constant        entry                    external dcl 461
pointer                         001322 constant        entry                    external dcl 604
set_ext_variable_               000042 constant        entry                    external dcl 60
star_heap                       001150 constant        entry                    external dcl 538

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2022        2074    1504        2032
Length      2366    1504        52         256     315           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
set_ext_variable_                   201 external procedure  is an external procedure.  
on unit on line 184                  64 on unit               
HASH                                    internal procedure  shares stack frame of external procedure set_ext_variable_.  
LOOKUP                                  internal procedure  shares stack frame of external procedure set_ext_variable_.  
on unit on line 551                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
set_ext_variable_        000100 found                       set_ext_variable_
                         000101 hash_index                  set_ext_variable_
                         000102 heap_header_ptr             set_ext_variable_
                         000104 is_heap_link                set_ext_variable_
                         000105 i                           set_ext_variable_
                         000106 called_by_linker            set_ext_variable_
                         000107 loop_count                  set_ext_variable_
                         000110 nchars                      set_ext_variable_
                         000112 new_ptr                     set_ext_variable_
                         000114 table_ptr                   set_ext_variable_
                         000116 ring_no                     set_ext_variable_
                         000120 seg_ptr                     set_ext_variable_
                         000122 t1                          set_ext_variable_
                         000124 t2                          set_ext_variable_
                         000126 t3                          set_ext_variable_
                         000130 t4                          set_ext_variable_
                         000132 var_ptr                     set_ext_variable_
                         000134 vsize                       set_ext_variable_
                         000136 where_to_allocate_ptr       set_ext_variable_
                         000174 tname                       HASH
                         000200 hash_temp                   HASH
                         000202 hash_index                  HASH

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           bound_ck_signal
enable_op           ext_entry_desc      int_entry           divide_fx3          op_alloc_           op_freen_
op_empty_           clock_mac           vclock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 fortran_storage_manager_$alloc                              hcs_$make_seg
heap_manager_$create_heap_for_set_ext_var                   list_init_$variable_already_zero
trap_caller_caller_           unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_link_target_init_info                      error_table_$bigger_ext_variable
error_table_$defs_loop        error_table_$invalid_heap     error_table_$invalid_heap_var_size
error_table_$no_ext_sym       error_table_$noalloc          error_table_$notalloc
pl1_operators_$VLA_words_per_seg_                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     95 000031        60 000034       165 000067       166 000070       167 000071       168 000073       169 000077
    178 000101       180 000102       181 000104       184 000105       186 000121       187 000124       184 000127
    190 000134       191 000151       197 000153       199 000160       200 000163       202 000200       204 000202
    205 000205       207 000206       208 000207       219 000210       221 000214       222 000221       224 000227
    228 000231       230 000235       231 000240       232 000242       234 000243       235 000244       237 000246
    238 000250       240 000251       242 000261       248 000262       250 000270       251 000273       253 000274
    255 000305       256 000310       263 000311       267 000324       268 000327       278 000330       280 000332
    282 000347       284 000353       287 000362       288 000373       289 000376       291 000377       293 000427
    296 000453       298 000454       300 000460       301 000540       303 000542       304 000554       305 000557
    307 000560       312 000561       314 000566       315 000571       316 000573       317 000575       318 000602
    319 000604       320 000607       321 000613       322 000614       324 000631       325 000642       332 000651
    334 000655       336 000663       338 000713       340 000715       342 000737       347 000741       351 000743
    353 000747       355 000753       357 000757       359 000767       360 000772       363 000773       461 000774
    465 001024       466 001026       467 001027       469 001033       471 001036       473 001041       476 001042
    477 001057       478 001061       479 001062       481 001064       484 001066       510 001067       514 001124
    515 001126       516 001127       517 001133       518 001137       520 001141       538 001142       543 001175
    544 001176       545 001200       546 001201       547 001203       548 001207       549 001210       551 001211
    553 001225       554 001230       551 001233       561 001240       562 001244       571 001250       572 001251
    573 001260       574 001275       577 001277       579 001304       580 001307       583 001310       585 001315
    587 001317       604 001320       608 001347       609 001350       610 001351       611 001355       612 001361
    613 001363       382 001364       392 001366       393 001374       394 001403       396 001406       405 001410
    409 001411       411 001412       413 001414       414 001416       415 001417       417 001426       418 001427
    420 001432       421 001435       423 001436       425 001440       428 001453       429 001455       431 001461
    432 001462       433 001464       435 001465       437 001470       438 001472       441 001476


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
