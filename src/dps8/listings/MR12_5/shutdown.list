	COMPILATION LISTING OF SEGMENT shutdown
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1041.9 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       13 shutdown:
       14      procedure ();
       15 
       16 /* Procedure to stop the system in preparation for File System Shutdown.
       17*   This can be called only from the Initializer. After setting CPU
       18*   required to the bootload CPU, it stops all CPUs and disables traffic
       19*   control. It calls shutdown_file_system, switching stacks along the
       20*   way to inzr_stk0.
       21*
       22*   This is called only during normal shutdown.  During emergency shutdown,
       23*   shutdown_file_system is called directly.
       24*
       25*   For the new Storage System, Bernard Greenberg, 10/20/75
       26*   For demountable volumes, BSG 03/26/76
       27*   For new flags in flagbox, 9/30/76 by Noel I. Morris
       28*   For shutdown with downed drives, BSG 02/26/77
       29*   For shutdown which doesn't give up, W. Olin Sibert, 05/18/81
       30*   For set_procs_required, J. Bongiovanni, October 1981
       31*   To remove Page Multilevel, C. Hornig, December 1981.
       32*   To remove File System shutdown, J. Bongiovanni, March 1982
       33*   To shutdown scavenger, J. Bongiovanni, September 1982
       34*   To call stop_cpu$shutdown instead of stop_cpu, Chris Jones, April 1984
       35**/
       36 
       37 
       38 /****^  HISTORY COMMENTS:
       39*  1) change(86-09-23,Beattie), approve(86-08-11,MCR7517),
       40*     audit(86-10-23,Fawcett), install(86-11-03,MR12.0-1206):
       41*     No BOS support for MR12.
       42*                                                   END HISTORY COMMENTS */
       43 
       44 
       45 dcl	pds$processid	   bit (36) aligned external;
       46 
       47 dcl	condition_	   entry (char (*), entry);
       48 dcl	disk_emergency$test_all_drives
       49 			   entry;
       50 dcl	scavenger$shutdown	   entry;
       51 dcl	set_procs_required	   entry (bit (8) aligned, fixed bin (35));
       52 dcl	stop_cpu$shutdown	   ext entry (fixed bin (2), fixed bin (35));
       53 dcl	switch_shutdown_file_system
       54 			   entry;
       55 dcl	syserr		   entry options (variable);
       56 dcl	syserr$error_code	   entry options (variable);
       57 dcl	tc_shutdown	   ext entry;
       58 
       59 dcl	tc_data$initializer_id bit (36) aligned external;
       60 
       61 dcl	code		   fixed bin (35);
       62 dcl	i		   fixed bin (2);
       63 dcl	cpu_mask		   bit (8) aligned;
       64 
       65 dcl	LETTERS		   char (8) internal static options (constant) init ("ABCDEFGH");
       66 dcl	my_name		   char (8) internal static options (constant) init ("shutdown");
       67 
       68 dcl	(null, stackbaseptr, substr)
       69 			   builtin;
       70 
       71 /**/
       72 
       73 	if pds$processid ^= tc_data$initializer_id then
       74 	     return;				/* Only initializer can perform shutdown (trad.) */
       75 
       76 
       77 	stackbaseptr () -> stack_header.stack_begin_ptr -> stack_frame.prev_sp = null ();
       78 						/* Guarantee that we shall never leave ring zero again */
       79 
       80 	call condition_ ("any_other", shutdown_failed);	/* Don't let anything untoward happen, either */
       81 
       82 /* Now stop all CPU's other than the bootload one we are returning to */
       83 
       84 	cpu_mask = "0"b;
       85 	substr (cpu_mask, scs$bos_processor_tag + 1, 1) = "1"b;
       86 	call set_procs_required (cpu_mask, code);
       87 	if code ^= 0 then				/* Couldn't run on bootload CPU */
       88 	     call syserr$error_code (CRASH, code, "^a: Cannot run on CPU ^a (bootload CPU). Dump and try ESD.", my_name,
       89 		substr (LETTERS, scs$bos_processor_tag + 1, 1));
       90 
       91 	do i = 0 to 7;
       92 	     if i ^= scs$bos_processor_tag then do;
       93 		if scs$processor_data (i).online then do;
       94 		     call stop_cpu$shutdown (i, code);
       95 		     if code ^= 0 then
       96 			call syserr (ANNOUNCE, "^a: Could not stop CPU ^a.", my_name, substr (LETTERS, i + 1, 1));
       97 		end;
       98 	     end;
       99 	end;
      100 
      101 /* Determine downed drives. Done in wired_shutdown in ESD case */
      102 
      103 	call disk_emergency$test_all_drives;
      104 
      105 /* Now stop other processes */
      106 
      107 	call tc_shutdown;
      108 
      109 /*  After traffic control is shut down, reset any scavenges in progress  */
      110 
      111 	call scavenger$shutdown;
      112 
      113 /* Switch stacks to inzr_stk0 and shutdown File System */
      114 
      115 	call switch_shutdown_file_system;
      116 
      117 /**/
      118 
      119 shutdown_failed:
      120      proc (a_mcptr, a_condition, a_coptr, a_infoptr, a_continue) options (non_quick);
      121 
      122 dcl	a_mcptr		   pointer parameter;
      123 dcl	a_condition	   char (*) parameter;
      124 dcl	a_coptr		   pointer parameter;
      125 dcl	a_infoptr		   pointer parameter;
      126 dcl	a_continue	   bit (1) aligned parameter;
      127 
      128 /* This procedure is called if any signallable faults occur in shutdown,
      129*   and simply crashes the system, in the hope that an ESD will be more
      130*   successful. */
      131 
      132 	do while ("1"b);
      133 	     call syserr (CRASH,
      134 		"^a: Condition ^a signalled during shutdown. Normal shutdown failed. Get a dump, and try an ESD.",
      135 		my_name, a_condition);
      136 	end;
      137 
      138      end shutdown_failed;
      139 
      140 
  1     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  1     2 /* format: style4 */
  1     3 
  1     4 /* Information about system controllers */
  1     5 
  1     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  1     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  1     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  1     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  1    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  1    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  1    12          3 mbz bit (3) unaligned,
  1    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  1    14        2 info aligned,
  1    15          3 online bit (1) unaligned,			/* ON if controller is online */
  1    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  1    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  1    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  1    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  1    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  1    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  1    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  1    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  1    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  1    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  1    26          3 type bit (4) unaligned,			/* Model number for this controller */
  1    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  1    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  1    29          3 mbz bit (13) unaligned,
  1    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  1    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  1    32 
  1    33 /* Information about CPUs */
  1    34 
  1    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  1    36        (
  1    37        2 online bit (1),				/* "1"b if CPU is online */
  1    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  1    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  1    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  1    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  1    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  1    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  1    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  1    45        2 mbz1 bit (6),
  1    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  1    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  1    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  1    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  1    50        2 mbz2 bit (12),
  1    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  1    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  1    53        2 controller_port fixed bin (3) unsigned
  1    54        ) unaligned;					/* Port on controller */
  1    55 
  1    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  1    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  1    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  1    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  1    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  1    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  1    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  1    63        2 pad bit (12) unaligned;
  1    64 
  1    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  1    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  1    67        2 cow,
  1    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  1    69          3 mbz1 bit (13) unaligned,
  1    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  1    71          3 mbz2 bit (2) unaligned,
  1    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  1    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  1    74          3 mbz3 bit (3) unaligned,
  1    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  1    76 
  1    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  1    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  1    79        2 pad bit (12) unal,
  1    80        2 tag bit (6) unal;				/* Better be zero. */
  1    81 
  1    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  1    83        2 pad bit (36) aligned,
  1    84        2 cow,					/* Connect operand word, in odd location. */
  1    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  1    86          3 mbz1 bit (13) unaligned,
  1    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  1    88          3 mbz2 bit (9) unaligned,
  1    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  1    90 
  1    91 /* MASKS and PATTERNS */
  1    92 
  1    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  1    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  1    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  1    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  1    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  1    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  1    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  1   100 
  1   101 /* CAM and CACHE clear info */
  1   102 
  1   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  1   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  1   105 
  1   106 /* MASKING INSTRUCTIONS & POINTERS */
  1   107 
  1   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  1   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  1   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  1   111 
  1   112 /* MISCELLANEOUS */
  1   113 
  1   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  1   115        (
  1   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  1   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  1   118        2 pad1 bit (4),
  1   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  1   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  1   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  1   122        2 mask_cpu fixed bin (5)
  1   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  1   124 
  1   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  1   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  1   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  1   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  1   129 
  1   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  1   131 
  1   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  1   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  1   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  1   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  1   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  1   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  1   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  1   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  1   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  1   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  1   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  1   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  1   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  1   145 
  1   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  1   147 
  1   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  1   149 
  1   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  1   151 
  1   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  1   153 
  1   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  1   155 						/* Which ports have expanders */
  1   156 
  1   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  1   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  1   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  1   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  1   161 
  1   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  1   163 
  1   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  1   165 						/* Controller size on config card */
  1   166 
  1   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  1   168 
  1   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  1   170 						/* PTWs for SCAS pages */
  1   171 
  1   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  1   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  1   174 
  1   175 
  1   176 dcl  (
  1   177      IOM_PORT init (1),
  1   178      CPU_PORT init (2),
  1   179      BULK_PORT init (3)
  1   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  1   181 
  1   182 
  1   183 /* END INCLUDE FILE scs.incl.pl1 */
      141 
      142 
  2     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  2     2 
  2     3 /* format: off */
  2     4 
  2     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  2     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  2     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  2     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  2     9 
  2    10 
  2    11 /****^  HISTORY COMMENTS:
  2    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  2    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  2    14*     Modified to add constants for the translator_id field in the stack_frame
  2    15*     structure.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  2    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  2    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  2    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  2    23 
  2    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  2    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  2    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  2    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  2    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  2    29 
  2    30 
  2    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  2    32 
  2    33 dcl  stack_frame_min_length fixed bin static init(48);
  2    34 
  2    35 
  2    36 dcl 1 stack_frame based(sp) aligned,
  2    37     2 pointer_registers(0 : 7) ptr,
  2    38     2 prev_sp pointer,
  2    39     2 next_sp pointer,
  2    40     2 return_ptr pointer,
  2    41     2 entry_ptr pointer,
  2    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  2    43     2 arg_ptr pointer,
  2    44     2 static_ptr ptr unaligned,
  2    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  2    46     2 on_unit_relp1 bit(18) unaligned,
  2    47     2 on_unit_relp2 bit(18) unaligned,
  2    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  2    49*						   0 => PL/I version II
  2    50*						   1 => ALM
  2    51*						   2 => PL/I version I   
  2    52*						   3 => signal caller frame
  2    53*						   4 => signaller frame */
  2    54     2 operator_return_offset bit(18) unaligned,
  2    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  2    56     2 a bit(36),					/* accumulator */
  2    57     2 q bit(36),					/* q-register */
  2    58     2 e bit(36),					/* exponent */
  2    59     2 timer bit(27) unaligned,				/* timer */
  2    60     2 pad bit(6) unaligned,
  2    61     2 ring_alarm_reg bit(3) unaligned;
  2    62 
  2    63 
  2    64 dcl 1 stack_frame_flags based(sp) aligned,
  2    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  2    66     2 xx0 bit(22) unal,
  2    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  2    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  2    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  2    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  2    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  2    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  2    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  2    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  2    75     2 xx0a bit(6) unal,
  2    76     2 xx1 fixed bin,
  2    77     2 xx2 fixed bin,
  2    78     2 xx3 bit(25) unal,
  2    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  2    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  2    81     2 xx3a bit(9) unaligned,
  2    82     2 xx4(9) bit(72) aligned,
  2    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  2    84*						*  operator puts a pointer to the base of
  2    85*						*  the calling procedure here. (text base ptr)  */
  2    86     2 xx5 bit(72) aligned,
  2    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  2    88 
  2    89 /* format: on */
  2    90 
  2    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      143 
      144 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      145 
      146 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      147 
      148 
      149 /**/
      150 
      151 /* BEGIN MESSAGE DOCUMENTATION
      152*
      153*   Message:
      154*   shutdown: Could not stop CPU TAG.
      155*
      156*   S: $info
      157*
      158*   T: System shutdown.
      159*
      160*   M: Shutdown stops all but the bootload processor. The CPU whose
      161*   tag is TAG could not be stopped.
      162*
      163*   A: $note
      164*   If shutdown fails, put all CPU's other than the
      165*   bootload processor in step, return to BCE manually, and
      166*   attempt an ESD.
      167*
      168*   Message:
      169*   shutdown: Condition CCCC signalled during shutdown. Normal shutdown
      170*   failed. Get a dump, and try an ESD.
      171*
      172*   S: $crash
      173*
      174*   T: System shutdown
      175*
      176*   M: During the attempt to shut down the system, an unexpected condition
      177*   has been signalled. This may result from hardware problems, or a logic
      178*   error in the supervisor. The system crashes and returns to BCE, whereupon
      179*   an ESD should be attempted in order to finish flushing Multics
      180*   information from main memory. Because of the difference in implementation
      181*   between normal shutdown and ESD, it is possible that ESD will not
      182*   encounter the same problem, and instead be successful.
      183*
      184*   Message:
      185*   shutdown: Cannot run on CPU X (bootload CPU). Dump and try ESD. ERRORMESSAGE
      186*
      187*   S: $crash
      188*
      189*   T: System shutdown
      190*
      191*   M: During an attempt to shut down the system, the system could not run
      192*   on the bootload CPU. This problem may be due to hardware or software
      193*   problems.  The system will attempt to crash, which it may not complete.
      194*
      195*   A: If the system does not complete its attempt to crash, it should
      196*   be crashed manually. It may be necessary to change the bootload CPU
      197*   manually. This can be done by putting all CPUs into STEP mode, manually
      198*   assigning an interrupt mask to the new bootload CPU from the bootload SCU
      199*   maintenance panel, taking only the new bootload CPU out of STEP mode, and
      200*   doing an EXECUTE SWITCHES on that CPU.  Once the system has crashed
      201*   successfully, an ESD should be attempted.  This will most likely succeed.
      202*
      203*   END MESSAGE DOCUMENTATION */
      204 
      205      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.6  shutdown.pl1                      >spec>install>1110>shutdown.pl1
141          1    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
143          2    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
145          3    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
147          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000016 constant        fixed bin(17,0)          initial dcl 4-7 set ref 95*
CRASH                           000021 constant        fixed bin(17,0)          initial dcl 4-7 set ref 87* 133*
LETTERS                         000002 constant        char(8)                  initial packed unaligned dcl 65 ref 87 87 95 95
a_condition                            parameter       char                     packed unaligned dcl 123 set ref 119 133*
a_continue                             parameter       bit(1)                   dcl 126 ref 119
a_coptr                                parameter       pointer                  dcl 124 ref 119
a_infoptr                              parameter       pointer                  dcl 125 ref 119
a_mcptr                                parameter       pointer                  dcl 122 ref 119
code                            000100 automatic       fixed bin(35,0)          dcl 61 set ref 86* 87 87* 94* 95
condition_                      000012 constant        entry                    external dcl 47 ref 80
cpu_mask                        000102 automatic       bit(8)                   dcl 63 set ref 84* 85* 86*
disk_emergency$test_all_drives  000014 constant        entry                    external dcl 48 ref 103
i                               000101 automatic       fixed bin(2,0)           dcl 62 set ref 91* 92 93 94* 95 95*
my_name                         000000 constant        char(8)                  initial packed unaligned dcl 66 set ref 87* 95* 133*
null                                                   builtin function         dcl 68 ref 77
online                          000036 external static bit(1)                   array level 2 packed packed unaligned dcl 1-35 ref
                                                                                  93
pds$processid                   000010 external static bit(36)                  dcl 45 ref 73
prev_sp                  20            based           pointer                  level 2 dcl 2-36 set ref 77*
scavenger$shutdown              000016 constant        entry                    external dcl 50 ref 111
scs$bos_processor_tag           000040 external static fixed bin(3,0)           dcl 1-137 ref 85 87 87 92
scs$processor_data              000036 external static structure                array level 1 dcl 1-35
set_procs_required              000020 constant        entry                    external dcl 51 ref 86
stack_begin_ptr          22            based           pointer                  level 2 dcl 3-26 ref 77
stack_frame                            based           structure                level 1 dcl 2-36
stack_header                           based           structure                level 1 dcl 3-26
stackbaseptr                                           builtin function         dcl 68 ref 77
stop_cpu$shutdown               000022 constant        entry                    external dcl 52 ref 94
substr                                                 builtin function         dcl 68 set ref 85* 87 87 95 95
switch_shutdown_file_system     000024 constant        entry                    external dcl 53 ref 115
syserr                          000026 constant        entry                    external dcl 55 ref 95 133
syserr$error_code               000030 constant        entry                    external dcl 56 ref 87
tc_data$initializer_id          000034 external static bit(36)                  dcl 59 ref 73
tc_shutdown                     000032 constant        entry                    external dcl 57 ref 107

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 1-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 1-176
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 1-176
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 2-19
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 2-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 2-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 2-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 2-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 2-27
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
sb                                     automatic       pointer                  dcl 3-24
scs$bos_restart_flags                  external static bit(8)                   dcl 1-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 1-103
scs$cam_wait                           external static bit(8)                   dcl 1-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 1-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 1-152
scs$connect_lock                       external static bit(36)                  dcl 1-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 1-164
scs$controller_data                    external static structure                array level 1 dcl 1-6
scs$cow                                external static structure                array level 1 dcl 1-65
scs$cow_ptrs                           external static structure                array level 1 dcl 1-77
scs$cpu_test_mask                      external static bit(72)                  dcl 1-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 1-99
scs$cycle_priority_template            external static bit(7)                   dcl 1-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 1-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 1-140
scs$faults_initialized                 external static bit(1)                   dcl 1-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 1-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 1-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 1-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 1-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 1-97
scs$open_level                         external static bit(72)                  dcl 1-94
scs$port_addressing_word               external static bit(3)                   array dcl 1-148
scs$port_data                          external static structure                array level 1 dcl 1-56
scs$processor                          external static bit(8)                   dcl 1-143
scs$processor_data_switch_value        external static bit(36)                  dcl 1-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 1-142
scs$processor_start_mask               external static bit(72)                  dcl 1-95
scs$processor_start_pattern            external static bit(36)                  dcl 1-98
scs$processor_start_wait               external static bit(8)                   dcl 1-144
scs$processor_switch_compare           external static bit(36)                  array dcl 1-159
scs$processor_switch_data              external static bit(36)                  array dcl 1-157
scs$processor_switch_mask              external static bit(36)                  array dcl 1-160
scs$processor_switch_template          external static bit(36)                  array dcl 1-158
scs$processor_test_data                external static structure                level 1 dcl 1-114
scs$read_mask                          external static bit(36)                  array dcl 1-109
scs$reconfig_general_cow               external static structure                level 1 dcl 1-82
scs$reconfig_lock                      external static bit(36)                  dcl 1-133
scs$reconfig_locker_id                 external static char(32)                 dcl 1-167
scs$scas_page_table                    external static bit(36)                  array dcl 1-169
scs$set_cycle_switches                 external static bit(1)                   dcl 1-173
scs$set_mask                           external static bit(36)                  array dcl 1-108
scs$sys_level                          external static bit(72)                  dcl 1-93
scs$sys_trouble_pending                external static bit(1)                   dcl 1-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 1-146
scs$trouble_flags                      external static bit(8)                   dcl 1-134
sp                                     automatic       pointer                  dcl 2-31
stack_frame_flags                      based           structure                level 1 dcl 2-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 2-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72

NAMES DECLARED BY EXPLICIT CONTEXT.
shutdown                        000106 constant        entry                    external dcl 13
shutdown_failed                 000340 constant        entry                    internal dcl 119 ref 80 80

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       604         646     410         614
Length      1116     410        42         233     173           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
shutdown                            124 external procedure  is an external procedure.  
shutdown_failed                     108 internal procedure  is assigned to an entry variable, and is declared options(non_quick).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
shutdown                 000100 code                        shutdown
                         000101 i                           shutdown
                         000102 cpu_mask                    shutdown

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    disk_emergency$test_all_drives                              scavenger$shutdown
set_procs_required            stop_cpu$shutdown             switch_shutdown_file_system   syserr
syserr$error_code             tc_shutdown

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pds$processid                 scs$bos_processor_tag         scs$processor_data            tc_data$initializer_id




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000105        73 000113        77 000116        80 000122        84 000145        85 000146        86 000153
     87 000163        91 000226        92 000233        93 000236        94 000241        95 000251        99 000310
    103 000312       107 000317       111 000324       115 000331       205 000336       119 000337       132 000353
    133 000354       136 000406       138 000407


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
