	COMPILATION LISTING OF SEGMENT get_aste
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1023.1 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 get_aste:
       14      procedure (csl) returns (ptr);
       15 
       16 dcl csl fixed bin (17) parameter;
       17 
       18 /*
       19*   astep = get_aste (csl)
       20*   astep = get_aste$synchronized (csl);
       21*
       22*   FUNCTION -
       23*
       24*   The procedure "get_aste" returns a pointer to  a  free  ASTE  whose  page  table
       25*   length  is  equal to or greater than the input argument "csl". If it cannot find
       26*   such an ASTE, it returns a null pointer.
       27*
       28*   "get_aste" does not concern itself with the AST lock. It  assumes  there  is  no
       29*   race  condition.  It is the responsibility of the caller to issue the call after
       30*   the AST has been locked and to unlock it upon return, as soon as it is  safe  to
       31*   do  so.  Of  course,  the  initializer  or  shutdown may call "get_aste" without
       32*   locking the AST since they know they are alone.
       33*
       34*   The ASTE is threaded in the circular list, at the end.
       35*
       36*   All items of the ASTE are zero with the exception of fb and bp which thread  the
       37*   ASTE  in  the  circular list, and ptsi and marker which are engraved in the ASTE
       38*   forever.
       39*
       40*   All PTW's are initialized with a page not in core flag and  with  a  coded  null
       41*   device address.
       42*
       43*   IMPLEMENTATION -
       44*
       45*   First,  the  argument "csl" is used to determine what is the appropriate size of
       46*   the page table. Then the circular list associated with the  determined  size  is
       47*   scanned,  starting  from  the ASTE which happens to be pointed to by the current
       48*   pointer associated with this list.
       49*
       50*   If there is a free ASTE at the head of the list, it will be selected.
       51*   Otherwise, the list is searched for an ASTE which is not entry-held,
       52*   has no inferiors, no pages in memory, and aste.init not set.  ASTE's
       53*   which are rejected have their file maps updated if aste.fmchanged = "1"b.
       54*
       55*   If no ASTE's are found above, a much more careful search is done.
       56*   The estimated cost of deactivating each segment is computed by computing
       57*   a 'cost' equal to the sum of pages used, pages modified, and 1 for the
       58*   VTOCE I/O.  The cost for a directory also includes the sum of the costs
       59*   of its inferiors.  The segment with the lowest cost will be selected.
       60*
       61*   The selected segment is deactivated with the "deactivate" routine.
       62*   If this segment is a directory with active inferiors, all inferiors
       63*   are also deactivated (in a bottom-up manner, thereby adhering to the
       64*   dictum that all ancestor segments of an active segment must be active).
       65*
       66*   No matter if the selected ASTE was free or if it has been deactivated, it is now
       67*   threaded in the list, at the FIRST position. It is  put  at  the  last  position
       68*   merely by moving the current position forward by 1 position.
       69*
       70*   Synchronized segments are special-cased. If the per-pool limit on these
       71*   is exceeded, only synchronized segments are considered for deactivation.
       72*
       73*   MODIFICATIONS -
       74*
       75*   04/08/75 Totally rewritten by Andre Bensoussan for the new storage system.
       76*   06/76 by D.Vinograd to skip ast entries in use by the volume dumper
       77*   03/23/77 by Greenberg for get_aste$flush_ast_pool
       78*   10/07/80 by C. Hornig for new replacement algorithm
       79*   03/21/81 W. Olin Sibert, for ADP PTWs
       80*   04/19/81 by W. Olin Sibert, to get rid of aste.ic
       81*   05/31/81 by J. Bongiovanni to return null ptr on invalid csl
       82*   10/25/82 by J. Bongiovanni for synchronized segments
       83**/
       84 
       85 dcl N_PROTECTED_ASTES fixed bin static options (constant) init (4);
       86 
       87 dcl (fastep, lastep, mp_astep) ptr;
       88 dcl aste_count fixed bin;
       89 dcl (cost_total, best_cost) fixed bin;
       90 dcl pts fixed bin;
       91 dcl code fixed bin (35);
       92 dcl ptsi fixed bin (3);
       93 dcl ptp pointer;
       94 dcl synchronized_call bit (1) aligned;
       95 dcl synchronized_only bit (1) aligned;
       96 
       97 dcl error_table_$deact_in_mem fixed bin (35) external;
       98 dcl pds$process_group_id char (32) external;
       99 dcl sys_info$system_type fixed bin external static;
      100 
      101 dcl deactivate entry (ptr, fixed bin (35));
      102 dcl hc_dm_util$check_activate entry (fixed bin (3), fixed bin (35));
      103 dcl hc_dm_util$activate entry (fixed bin (3));
      104 dcl syserr entry options (variable);
      105 dcl syserr$error_code entry options (variable);
      106 dcl update_vtoce entry (ptr);
      107 
      108 dcl (addr, addrel, binary, hbound, lbound, null, pointer, rel) builtin;
      109 
      110 
      111 /* * * * * * * * * * GET_ASTE * * * * * * * * */
      112 
      113           synchronized_call = "0"b;
      114           goto common;
      115 
      116 synchronized:
      117 	entry (csl) returns (ptr);
      118 
      119 	synchronized_call = "1"b;
      120 
      121 common:	
      122 	sstp = addr (sst_seg$);			/* get a pointer to the SST */
      123 
      124 	do ptsi = hbound (sst.pts, 1) by -1 to lbound (sst.pts, 1) + 1 while (csl <= sst.pts (ptsi - 1));
      125 	end;					/* search for the correct index */
      126 
      127 	pts = sst.pts (ptsi);			/* save real size of the page table array */
      128 
      129 	if csl > pts then do;			/* invalid csl				*/
      130 	     call syserr (0, "get_aste: Invalid csl ^d", csl);
      131 	     return (null());
      132 	end;
      133 
      134 
      135 	sst.aneedsize (ptsi) = sst.aneedsize (ptsi) + 1;	/* meter */
      136 
      137 	if sst.ausedp (ptsi) = ""b then goto err_out;	/* none on the list */
      138 
      139 	synchronized_only = "0"b;
      140 	if synchronized_call then do;
      141 	     sst.synch_activations = sst.synch_activations + 1;
      142 	     call hc_dm_util$check_activate (ptsi, code);
      143 	     if code ^= 0 then synchronized_only = "1"b;
      144 	end;
      145 
      146 /*   First, check the beginning of the aste list for a free aste.				
      147*     During deactivation, put_aste threads the newly-freed aste				
      148*     to the beginning of the list								
      149*											*/
      150 	
      151 
      152 	fastep, lastep, astep = pointer (sstp, sst.ausedp (ptsi));
      153 				
      154 
      155 	if ^aste.usedf & ^synchronized_only then do;
      156 	     sst.stepsa = sst.stepsa + 1;
      157 	     sst.asteps (ptsi) = sst.asteps (ptsi) + 1;
      158 return_aste:
      159 	     sst.ausedp (ptsi) = aste.fp;		/* Move current ptr forward by 1 position */
      160 	     if synchronized_call
      161 		then call hc_dm_util$activate (ptsi);
      162 	     return (astep);			/* Return astep - ASTE is now last in list */
      163 	     end;
      164 
      165 /*   Next, protect a number of aste's from being deactivated during this
      166*     this call to get_aste.  The number of protected aste's is given
      167*     by the constant N_PROTECTED_ASTES; the aste's protected are those
      168*     in the list immediately preceding the current position (and hence,
      169*     the protected aste's are those activated most recently).  The purpose
      170*     of this protection is to prevent "ping-ponging" of aste's, a phenomenon
      171*     wherein the system hangs on a single instruction (e.g., a multi-word EIS
      172*     instruction referencing multiple segments alternately taking segment
      173*     faults on two segments, where the segment fault of one causes
      174*     deactivation of the other segment).							*/
      175 
      176 	do aste_count = 1 to N_PROTECTED_ASTES;		/* walk back to protect */
      177 	     astep = pointer (astep, aste.bp);		/* recently used ASTE's */
      178 	     if ^aste.usedf & ^synchronized_only then goto return_aste;
      179 	     if astep = fastep then goto small_ast;	/* ridiculous */
      180 	end;
      181 small_ast:
      182 	lastep = astep;
      183 
      184 /*   This is the main loop of aste allocation.  The entire list is walked
      185*     (except for aste's which have been protected above) until one of the
      186*     following happens:
      187*
      188*          1. an aste is found which can be deactivated (entry-hold-switch,
      189*             dumper-in-use, ddnp, and deact_error all off), is not in
      190*             "grace" lap (the first lap after activation), has no active
      191*             inferiors, and no pages in memory.
      192*
      193*          2. the end of the list is reached.
      194*
      195*     With reasonable number of aste's in the pools (set via the SST card),
      196*     and normal system behavior, an aste should almost always be found
      197*     in this loop										*/
      198 	
      199 
      200 	do astep = fastep repeat (pointer (astep, aste.fp)) while (aste.fp ^= rel (lastep));
      201 	     if ^aste.usedf & ^synchronized_only then goto return_aste;  /* aste free -allocate it			*/
      202 	     
      203 
      204 	     sst.stepsa = sst.stepsa + 1;		/* count total steps			*/
      205 	     sst.asteps (ptsi) = sst.asteps (ptsi) + 1;	/* count steps for this size */
      206 
      207 	     if aste.dius then do;			/* volume dumper is using it */
      208 		sst.askipdius = sst.askipdius + 1;
      209 		goto skip;
      210 		end;
      211 
      212 	     if aste.ehs | aste.ddnp | aste.deact_error then do;
      213 						/* Check for ehs = entry_hold, or ddnp
      214*						   without that, which = being prewithdrawn. */
      215 		sst.askipsehs = sst.askipsehs + 1;
      216 		go to skip;
      217 		end;
      218 
      219 	     if aste.init then do;			/* check for grace lap flag */
      220 		aste.init = "0"b;			/* turn off flag */
      221 		sst.askipsinit = sst.askipsinit + 1;
      222 		go to skip;
      223 		end;
      224 
      225 	     if (aste.np ^= ""b) | (aste.infp ^= ""b) then do; /* check for no inferiors, no pages in memory*/
      226 		sst.askipslevel = sst.askipslevel + 1;
      227 		goto skip;
      228 		end;
      229 
      230 	     if synchronized_only & ^aste.synchronized then do;	/* check for synch seg restrictions */
      231 		sst.synch_skips = sst.synch_skips + 1;
      232 		goto skip;
      233 	     end;
      234 
      235 	     sst.ausedp (ptsi) = rel (astep);
      236 	     call my_deactivate (astep, code);
      237 	     if code = 0 then goto return_aste;
      238 
      239 skip:
      240 	     if aste.fmchanged & ^aste.per_process then do;
      241 						/* check for AST trickle */
      242 		call update_vtoce (astep);		/* update the vtoc entry */
      243 		sst.updates = sst.updates + 1;
      244 		end;
      245 	end;
      246 
      247 /*   This is the tough search.  At this point we are willing to do a lot
      248*     more work to find the right aste to deactivate.  We assume that this
      249*     search is rarely needed, and so we are not concerned with the overhead
      250*     involved.  
      251*
      252*     In this search, the entire aste list is walked (again, excepting aste's
      253*     which are protected for this call to get_aste), and a cost is computed
      254*     for deactivating each aste which can be deactivated.  Since we are in
      255*     desparate straights, we are willing to deactivate inferiors (if necessary).
      256*     However, the restrictions of entry-hold switch, dumper-in-use, ddnp,
      257*     and deact_error still apply; further, an aste cannot be deactivated if
      258*     any of these conditions prevent an inferior from being deactivated.
      259*     After a walk of the entire list, the aste with the lowest cost is
      260*     deactivated (following a bottom-up deactivation of all of its inferiors).
      261*
      262*     Synchronized segments are special-cased if the per-pool limit on these
      263*     is exceeded. The first such segment which can be deactivated is deactivated.
      264*     This logic is a hedge against flooding the system with de-facto entry-held
      265*     segments. It is expected to be executed rarely.
      266**/
      267 
      268 deact_error:
      269 	best_cost = 1f16b;
      270 	mp_astep = null ();
      271 	do astep = fastep repeat (pointer (astep, aste.fp)) while (aste.fp ^= rel (lastep));
      272 	     cost_total = 0;
      273 	     if ^synchronized_only then do;		/* Normal case */
      274 		call check (astep, code);		/* calculate the cost */
      275 		if code ^= 0 then goto ddir_loop;
      276 		call walk_ast (check, code);		/* check the inferior hierarchy */
      277 		if code ^= 0 then goto ddir_loop;
      278 		
      279 		if cost_total < best_cost then do;
      280 		     best_cost = cost_total;
      281 		     mp_astep = astep;
      282 		end;
      283 	     end;
      284 	     else do;				/* Synchronized only */
      285 		call check (astep, code);
      286 		if code ^= 0 then goto ddir_loop;
      287 		sst.ausedp (ptsi) = rel (astep);
      288 		call my_deactivate (astep, code);
      289 		if code = 0 then goto return_aste;
      290 	     end;
      291 ddir_loop:
      292 	end;
      293 
      294 	if mp_astep = null () then do;		/* didn't find anything */
      295 err_out:
      296 	     if ^synchronized_only then
      297 		call syserr (0, "get_aste: No removable ^dk AST entries.", pts);
      298 	     else call syserr (4, "get_aste: No removable ^dk synchronized AST entries.", pts);
      299 	     return (null ());
      300 	     end;
      301 
      302 	astep = mp_astep;
      303 	call walk_ast (my_deactivate, code);		/* deactivate all inferiors */
      304 	if code ^= 0 then goto deact_error;
      305 
      306 	sst.ausedp (ptsi) = rel (astep);
      307 	call my_deactivate (astep, code);
      308 	if code ^= 0 then goto deact_error;
      309 
      310 	sst.asearches = sst.asearches + 1;
      311 	sst.acost = sst.acost + best_cost;
      312 
      313 	goto return_aste;
      314 
      315 /* * * * * * * * * * WALK_AST * * * * * * * * * */
      316 
      317 walk_ast:
      318      procedure (Proc, Code);
      319 dcl Proc variable entry (ptr, fixed bin (35)) parameter;
      320 dcl Code fixed bin (35) parameter;
      321 dcl inf_astep ptr;
      322 dcl next_astep ptr;
      323 dcl brother bit (1) aligned;
      324 
      325 /* This procedure walks the tree of active inferiors of an active directory,
      326*   calling the supplied procedure on each branch.  The branches are processed
      327*   bottom-up. */
      328 
      329 	Code = 0;
      330 	inf_astep = astep;
      331 find_son:						/* walk to the bottom of the subtree */
      332 	do while (inf_astep -> aste.infp ^= ""b);
      333 	     inf_astep = pointer (inf_astep, inf_astep -> aste.infp);
      334 	end;
      335 process_aste:
      336 	if inf_astep = astep then return;		/* we have walked the whole tree */
      337 	if inf_astep -> aste.infl ^= ""b then do;	/* next do his brother */
      338 	     next_astep = pointer (inf_astep, inf_astep -> aste.infl);
      339 	     brother = "1"b;	
      340 	     end;
      341 	else do;
      342 	     next_astep = pointer (inf_astep, inf_astep -> aste.par_astep);
      343 	     brother = "0"b;
      344 	     end;
      345 	call Proc (inf_astep, Code);			/* process the branch */
      346 	if Code ^= 0 then return;
      347 	inf_astep = next_astep;
      348 	if brother then goto find_son;
      349 	else goto process_aste;
      350      end walk_ast;
      351 
      352 
      353 
      354 /* * * * * * * * * * CHECK * * * * * * * * * * */
      355 
      356 check:
      357      procedure (Astep, Code);
      358 dcl Astep ptr parameter;
      359 dcl Code fixed bin (35) parameter;
      360 
      361 dcl pn fixed bin;
      362 
      363 /* check makes sure that a directory can be deactivated safely 
      364*   It also increments the cost function.  At the same time, it checks
      365*   whether this aste (an inferior to the one being considered for
      366*   deactivation) is in the same aste pool as the aste being considered.
      367*   If it is, a non-zero code is returned, since we know that there is
      368*   an aste in the pool with lower cost than the one being considered currently
      369*   (namely, this one).									*/
      370      
      371 
      372 	if (Astep -> aste.ehs) | (Astep -> aste.ddnp) | (Astep -> aste.dius) | (Astep -> aste.deact_error)
      373 	then goto cant_do_it;
      374 	if synchronized_only & ^(Astep -> aste.synchronized)
      375 	then goto cant_do_it;
      376 	if (binary (Astep -> aste.ptsi) = ptsi) & (astep ^= Astep) then do;
      377 cant_do_it:
      378 	     Code = -1;
      379 	     return;
      380 	     end;
      381 
      382 	Code = 0;
      383 	ptp = addrel (Astep, sst.astsize);		/* Start with page zero */
      384 	cost_total = cost_total + 1;			/* Costs one for the ASTE itself */
      385 
      386 	do pn = 1 to pts;
      387 	     cost_total = cost_total + ptw_cost (ptp);
      388 	     ptp = addrel (ptp, 1);
      389 	     end;
      390 
      391 	if cost_total > best_cost then Code = -1;	/* aste being considered cannot win		*/
      392 
      393      end check;
      394 
      395 
      396 /* * * * * * * * * * PTW_COST * * * * * * * * * */
      397 
      398 ptw_cost: proc (Ptwp) returns (fixed bin);
      399 
      400 /* This procedure returns the "cost" of flushing one PTW. If the PTW
      401*   has not been used or modified, the cost is zero. If it has been either
      402*   used or modified, the cost is one. If it has been both, the cost is two.
      403*   */
      404 
      405 dcl  Ptwp pointer parameter;
      406 
      407 dcl  used bit (1) aligned;
      408 dcl  mod bit (1) aligned;
      409 
      410 
      411 	if sys_info$system_type = ADP_SYSTEM then
      412 	     used = (Ptwp -> adp_ptw.phu) | (Ptwp -> adp_ptw.phu1);
      413 	else used = (Ptwp -> l68_ptw.phu) | (Ptwp -> l68_ptw.phu1);
      414 
      415 	if sys_info$system_type = ADP_SYSTEM then
      416 	     mod = (Ptwp -> adp_ptw.phm) | (Ptwp -> adp_ptw.phm1);
      417 	else mod = (Ptwp -> l68_ptw.phm) | (Ptwp -> l68_ptw.phm1);
      418 
      419 	if (used & mod) then return (2);
      420 	else if (used | mod) then return (1);
      421 	else return (0);
      422 
      423 	end ptw_cost;
      424 
      425 
      426 
      427 
      428 /* * * * * * * * * * MY_DEACTIVATE * * * * * * * * * * */
      429 
      430 /* Internal procedure to deactivate an aste.
      431*   If an error of any sort occurs here, a message is printed on the console,
      432*   and the flag aste.deact_error is set so that this aste will be skipped
      433*   in the aste replacement search.  This flag is reset by flush_ast_pool.				*/
      434      
      435 
      436 my_deactivate:
      437      procedure (Astep, Code);
      438 dcl Astep ptr parameter;
      439 dcl Code fixed bin (35) parameter;
      440 
      441 	call deactivate (Astep, Code);
      442 	if Code ^= 0 then 
      443 	     if ^(Astep -> aste.synchronized) | (Code ^= error_table_$deact_in_mem) then do;
      444 	     Astep -> aste.deact_error = "1"b;
      445 	     call syserr$error_code (3, Code,
      446 		"get_aste: Error deactivating ^w (VTOCE ^o on pvt ^o) to free ^dK ASTE for ^a.", Astep -> aste.uid,
      447 		Astep -> aste.vtocx, Astep -> aste.pvtx, pts, pds$process_group_id);
      448 	     end;
      449      end my_deactivate;
      450 
      451  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
      451 
      452  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      452 
      453  /* BEGIN INCLUDE FILE ... system_types.incl.pl1 ... 03/23/81 ... W. Olin Sibert */
  3     2 
  3     3 dcl  L68_SYSTEM	fixed bin (17) internal static options (constant) init (1);
  3     4 dcl  ADP_SYSTEM	fixed bin (17) internal static options (constant) init (2);
  3     5 
  3     6 dcl  SYSTEM_TYPE_NAME (2) char (8) internal static options (constant) init
  3     7     ("Level68", "ADP");
  3     8 
  3     9 /* END INCLUDE FILE ... system_types.incl.pl1 */
      453 
      454  /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  4     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  4     3 
  4     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  4     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  4     6     2 pad1 bit (4) unaligned,
  4     7     2 flags unaligned like l68_ptw_flags;
  4     8 
  4     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  4    10     2 add bit (18) unaligned,
  4    11     2 flags like l68_ptw_flags unaligned;
  4    12 
  4    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  4    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  4    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  4    16 
  4    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  4    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  4    19     2 first bit (1),				/* the page has not yet been written out */
  4    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  4    21 
  4    22     2 pad1 bit (1),
  4    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  4    24     2 phu bit (1),					/* page has been used bit */
  4    25 
  4    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  4    27     2 nypd bit (1), 				/* must be moved to paging device */
  4    28     2 phm bit (1),					/* page has been modified bit */
  4    29 
  4    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  4    31     2 wired bit (1),				/* page is to remain in core */
  4    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  4    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  4    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  4    35 
  4    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
      454 
      455  /* BEGIN INCLUDE FILE ... ptw.adp.incl.pl1 ... 02/11/81, for ADP conversion */
  5     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  5     3 
  5     4 dcl 1 adp_core_ptw aligned based (ptp), 		/* PTW for in-core page */
  5     5     2 pad1 bit (2) unaligned,
  5     6     2 frame fixed bin (16) unsigned unaligned,		/* Core frame number */
  5     7     2 flags like adp_ptw_flags unaligned;		/* add_type = "00"b; */
  5     8 
  5     9 dcl 1 adp_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  5    10     2 add bit (18) unaligned,
  5    11     2 flags like adp_ptw_flags unaligned;
  5    12 
  5    13 dcl 1 adp_special_ptw aligned based (ptp) like adp_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  5    14 dcl 1 adp_real_disk_ptw aligned based (ptp) like adp_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  5    15 dcl 1 adp_null_disk_ptw aligned based (ptp) like adp_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  5    16 
  5    17 dcl 1 adp_ptw_flags unaligned based,			/* Common lower halfword for ADP PTW */
  5    18    (2 add_type bit (4),				/* See specific declarations */
  5    19     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  5    20     2 wired bit (1),				/* page is to remain in core */
  5    21     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  5    22     2 phu1 bit (1), 				/* page has been used in the quantum */
  5    23     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  5    24 
  5    25     2 unusable1 bit (3),				/* Shares hardware byte */
  5    26     2 valid bit (1),				/* "1"b if page is in core */
  5    27     2 write bit (1),				/* "1"b if page may be written into */
  5    28     2 unusable2 bit (1),				/* Shares hardware byte */
  5    29     2 iox bit (1),					/* "1"b if page is to be present to IOX */
  5    30     2 phm bit (1),					/* page has been modified bit */
  5    31     2 phu bit (1)) unaligned; 			/* page has been used bit */
  5    32 
  5    33 /* END INCLUDE FILE ... ptw.adp.incl.pl1 */
      455 
      456 
      457 /*  */
      458 
      459 /* BEGIN MESSAGE DOCUMENTATION
      460*
      461*   Message:
      462*   get_aste: no removable XXXk ast entries
      463*
      464*   S: $info
      465*
      466*   T: $run
      467*
      468*   M: An AST entry was needed for a segment of size XXX k, but no free
      469*   entries of that size were present, and no segments occupying such
      470*   entries could be deactivated. This could be symptomatic of a
      471*   logic problem, but may also indicate a grossly mistuned AST.
      472*
      473*   A: 
      474*   Substantially increase the number of AST entries of this size as
      475*   given on the SST CONFIG card. If the problem persists, contact the
      476*   system programming staff.
      477*
      478*   Message:
      479*   get_aste: no removable XXXk synchronized AST entries
      480*
      481*   S: $log
      482*
      483*   T: $run
      484*
      485*   M: An AST entry was needed for a synchronized segment of size XXX k, and
      486*   the per-ASTE-pool limit on synchronized segments was reached. No synchronized
      487*   segments in that pool could be deactivated.
      488*
      489*   A: Contact the system programming staff.
      490*
      491*   Message:
      492*   get_aste: Invalid csl x
      493*
      494*   S:     $log
      495*
      496*   T:     $run
      497*
      498*   M:     get_aste was called to activate a segment with x pages,
      499*which is larger than the maximum segment size.  This is indicative
      500*of hardware or software failure (a typical problem is an invalid
      501*VTOCE).
      502*
      503*   A:     If the problem persists, contact the system programming staff.
      504*
      505*
      506*   Message:
      507*   get_aste: Error deactivating UUUU (vtoc V of pvt PV) to free XXXk ASTE for USERNAME.
      508*
      509*   S: $log
      510*
      511*   T: $run
      512*
      513*   M: The system encountered an error deactivating an AST entry which was
      514*   selected for deactivation by the AST replacement algorithm.  The AST
      515*   on which the error was encountered will be flagged to be ingored by
      516*   further passes of the algorithm; this flag will be reset during the next
      517*   run of flush_ast_pool.
      518*
      519*   A: If the problem persists, contact the system programming staff.
      520*
      521*   END MESSAGE DOCUMENTATION */
      522 
      523      end get_aste;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0807.4  get_aste.pl1                      >spec>install>1112>get_aste.pl1
451          1    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
452          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
453          3    06/19/81  2115.0  system_types.incl.pl1             >ldd>include>system_types.incl.pl1
454          4    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
455          5    03/27/82  0430.2  ptw.adp.incl.pl1                  >ldd>include>ptw.adp.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADP_SYSTEM                             constant        fixed bin(17,0)          initial dcl 3-4 ref 411 415
Astep                                  parameter       pointer                  dcl 358 in procedure "check" ref 356 372 372 372 372
                                                                                  374 376 376 383
Astep                                  parameter       pointer                  dcl 438 in procedure "my_deactivate" set ref 436
                                                                                  441* 442 444 445 445 445
Code                                   parameter       fixed bin(35,0)          dcl 439 in procedure "my_deactivate" set ref 436
                                                                                  441* 442 442 445*
Code                                   parameter       fixed bin(35,0)          dcl 359 in procedure "check" set ref 356 377* 382*
                                                                                  391*
Code                                   parameter       fixed bin(35,0)          dcl 320 in procedure "walk_ast" set ref 317 329*
                                                                                  345* 346
N_PROTECTED_ASTES                      constant        fixed bin(17,0)          initial dcl 85 ref 176
Proc                                   parameter       entry variable           dcl 319 ref 317 345
Ptwp                                   parameter       pointer                  dcl 405 ref 398 411 411 413 413 415 415 417 417
acost                   241            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 311* 311
addr                                                   builtin function         dcl 108 ref 121
addrel                                                 builtin function         dcl 108 ref 383 388
adp_ptw                                based           structure                level 1 dcl 5-9
adp_ptw_flags                          based           structure                level 1 packed packed unaligned dcl 5-17
aneedsize               230            based           fixed bin(17,0)          array level 2 dcl 1-9 set ref 135* 135
asearches               236            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 310* 310
askipdius               243            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 208* 208
askipsehs               235            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 215* 215
askipsinit              240            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 221* 221
askipslevel             237            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 226* 226
aste                                   based           structure                level 1 dcl 2-11
aste_count                      000106 automatic       fixed bin(17,0)          dcl 88 set ref 176*
astep                           000122 automatic       pointer                  dcl 2-9 set ref 152* 155 158 162 177* 177 177 178
                                                                                  179 181 200* 200* 201 207 212 212 212 219 220 225
                                                                                  225 230 235 236* 239 239 242* 245 245 271* 271*
                                                                                  274* 281 285* 287 288* 291 291 302* 306 307* 330
                                                                                  335 376
asteps                  254            based           fixed bin(17,0)          array level 2 dcl 1-9 set ref 157* 157 205* 205
astsize                  33            based           fixed bin(17,0)          level 2 dcl 1-9 ref 383
ausedp                   44            based           bit(18)                  array level 3 packed packed unaligned dcl 1-9 set
                                                                                  ref 137 152 158* 235* 287* 306*
best_cost                       000110 automatic       fixed bin(17,0)          dcl 89 set ref 268* 279 280* 311 391
binary                                                 builtin function         dcl 108 ref 376
bp                        0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 177
brother                         000140 automatic       bit(1)                   dcl 323 set ref 339* 343* 348
code                            000112 automatic       fixed bin(35,0)          dcl 91 set ref 142* 143 236* 237 274* 275 276* 277
                                                                                  285* 286 288* 289 303* 304 307* 308
cost_total                      000107 automatic       fixed bin(17,0)          dcl 89 set ref 272* 279 280 384* 384 387* 387 391
csl                                    parameter       fixed bin(17,0)          dcl 16 set ref 13 116 124 129 130*
ddnp                     12(15)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 212 372
deact_error               5(10)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref 212
                                                                                  372 444*
deactivate                      000016 constant        entry                    external dcl 101 ref 441
dius                      5(16)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 207 372
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 212 372
error_table_$deact_in_mem       000010 external static fixed bin(35,0)          dcl 97 ref 442
fastep                          000100 automatic       pointer                  dcl 87 set ref 152* 179 200 271
flags                     0(18)        based           structure                level 2 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 4-9 in procedure "get_aste"
flags                     0(18)        based           structure                level 2 in structure "adp_ptw" packed packed
                                                                                  unaligned dcl 5-9 in procedure "get_aste"
fmchanged                12(09)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 239
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 158 200
                                                                                  245 271 291
hbound                                                 builtin function         dcl 108 ref 124
hc_dm_util$activate             000022 constant        entry                    external dcl 103 ref 160
hc_dm_util$check_activate       000020 constant        entry                    external dcl 102 ref 142
inf_astep                       000134 automatic       pointer                  dcl 321 set ref 330* 331 333* 333 333 335 337 338
                                                                                  338 342 342 345* 347*
infl                      1            based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 337 338
infp                      1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 225 331
                                                                                  333
init                      5(01)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref 219
                                                                                  220*
l68_ptw                                based           structure                level 1 dcl 4-9
l68_ptw_flags                          based           structure                level 1 packed packed unaligned dcl 4-17
lastep                          000102 automatic       pointer                  dcl 87 set ref 152* 181* 200 271
lbound                                                 builtin function         dcl 108 ref 124
level                    44            based           structure                array level 2 dcl 1-9
mod                             000111 automatic       bit(1)                   dcl 408 set ref 415* 417* 419 420
mp_astep                        000104 automatic       pointer                  dcl 87 set ref 270* 281* 294 302
next_astep                      000136 automatic       pointer                  dcl 322 set ref 338* 342* 347
np                       12(27)        based           bit(9)                   level 2 packed packed unaligned dcl 2-11 ref 225
null                                                   builtin function         dcl 108 ref 131 270 294 299
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 342
pds$process_group_id            000012 external static char(32)                 packed unaligned dcl 98 set ref 445*
per_process              12(14)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 239
phm                       0(34)        based           bit(1)                   level 3 in structure "adp_ptw" packed packed
                                                                                  unaligned dcl 5-9 in procedure "get_aste" ref 415
phm                       0(29)        based           bit(1)                   level 3 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 4-9 in procedure "get_aste" ref 417
phm1                      0(27)        based           bit(1)                   level 3 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 4-9 in procedure "get_aste" ref 417
phm1                      0(26)        based           bit(1)                   level 3 in structure "adp_ptw" packed packed
                                                                                  unaligned dcl 5-9 in procedure "get_aste" ref 415
phu                       0(26)        based           bit(1)                   level 3 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 4-9 in procedure "get_aste" ref 413
phu                       0(35)        based           bit(1)                   level 3 in structure "adp_ptw" packed packed
                                                                                  unaligned dcl 5-9 in procedure "get_aste" ref 411
phu1                      0(30)        based           bit(1)                   level 3 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 4-9 in procedure "get_aste" ref 413
phu1                      0(25)        based           bit(1)                   level 3 in structure "adp_ptw" packed packed
                                                                                  unaligned dcl 5-9 in procedure "get_aste" ref 411
pn                              000100 automatic       fixed bin(17,0)          dcl 361 set ref 386*
pointer                                                builtin function         dcl 108 ref 152 177 245 291 333 338 342
ptp                             000114 automatic       pointer                  dcl 93 set ref 383* 387* 388* 388
pts                      40            based           fixed bin(17,0)          array level 2 in structure "sst" dcl 1-9
                                                                                  in procedure "get_aste" ref 124 124 124 127
pts                             000111 automatic       fixed bin(17,0)          dcl 90 in procedure "get_aste" set ref 127* 129 295*
                                                                                  298* 386 445*
ptsi                            000113 automatic       fixed bin(3,0)           dcl 92 in procedure "get_aste" set ref 124* 124* 127
                                                                                  135 135 137 142* 152 157 157 158 160* 205 205 235
                                                                                  287 306 376
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "get_aste" ref 376
pvtx                      4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  445*
rel                                                    builtin function         dcl 108 ref 200 235 271 287 306
sst                                    based           structure                level 1 dcl 1-9
sst_seg$                        000032 external static fixed bin(17,0)          dcl 1-6 set ref 121
sstp                            000120 automatic       pointer                  dcl 1-7 set ref 121* 124 124 124 127 135 135 137 141
                                                                                  141 152 152 156 156 157 157 158 204 204 205 205
                                                                                  208 208 215 215 221 221 226 226 231 231 235 243
                                                                                  243 287 306 310 310 311 311 383
stepsa                  234            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 156* 156 204* 204
synch_activations       102            based           fixed bin(35,0)          level 2 dcl 1-9 set ref 141* 141
synch_skips             103            based           fixed bin(35,0)          level 2 dcl 1-9 set ref 231* 231
synchronized             13(21)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 230 374
                                                                                  442
synchronized_call               000116 automatic       bit(1)                   dcl 94 set ref 113* 119* 140 160
synchronized_only               000117 automatic       bit(1)                   dcl 95 set ref 139* 143* 155 178 201 230 273 295 374
sys_info$system_type            000014 external static fixed bin(17,0)          dcl 99 ref 411 415
syserr                          000024 constant        entry                    external dcl 104 ref 130 295 298
syserr$error_code               000026 constant        entry                    external dcl 105 ref 445
uid                       3            based           bit(36)                  level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  445*
update_vtoce                    000030 constant        entry                    external dcl 106 ref 242
updates                 245            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 243* 243
used                            000110 automatic       bit(1)                   dcl 407 set ref 411* 413* 419 420
usedf                     5            based           bit(1)                   level 2 packed packed unaligned dcl 2-11 ref 155 178
                                                                                  201
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  445*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
L68_SYSTEM                             internal static fixed bin(17,0)          initial dcl 3-3
SYSTEM_TYPE_NAME                       internal static char(8)                  initial array packed unaligned dcl 3-6
adp_core_ptw                           based           structure                level 1 dcl 5-4
adp_null_disk_ptw                      based           structure                level 1 dcl 5-15
adp_real_disk_ptw                      based           structure                level 1 dcl 5-14
adp_special_ptw                        based           structure                level 1 dcl 5-13
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
l68_core_ptw                           based           structure                level 1 dcl 4-4
l68_null_disk_ptw                      based           structure                level 1 dcl 4-15
l68_real_disk_ptw                      based           structure                level 1 dcl 4-14
l68_special_ptw                        based           structure                level 1 dcl 4-13
seg_aste                               based           structure                level 1 dcl 2-96

NAMES DECLARED BY EXPLICIT CONTEXT.
cant_do_it                      001060 constant        label                    dcl 377 ref 372 374
check                           001015 constant        entry                    internal dcl 356 ref 274 276 276 285
common                          000125 constant        label                    dcl 121 ref 114
ddir_loop                       000576 constant        label                    dcl 291 ref 275 277 286
deact_error                     000476 constant        label                    dcl 268 ref 304 308
err_out                         000610 constant        label                    dcl 295 ref 137
find_son                        000734 constant        label                    dcl 331 ref 348
get_aste                        000105 constant        entry                    external dcl 13
my_deactivate                   001234 constant        entry                    internal dcl 436 ref 236 288 303 303 307
process_aste                    000744 constant        label                    dcl 335 ref 349
ptw_cost                        001132 constant        entry                    internal dcl 398 ref 387
return_aste                     000264 constant        label                    dcl 158 ref 178 201 237 289 313
skip                            000450 constant        label                    dcl 239 ref 209 216 222 227 232
small_ast                       000335 constant        label                    dcl 181 ref 179
synchronized                    000116 constant        entry                    external dcl 116
walk_ast                        000727 constant        entry                    internal dcl 317 ref 276 303

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1540        1574    1357        1550
Length      2052    1357        34         242     161           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_aste                            144 external procedure  is an external procedure.  
walk_ast                                internal procedure  shares stack frame of external procedure get_aste.  
check                                87 internal procedure  is assigned to an entry variable.  
ptw_cost                                internal procedure  shares stack frame of internal procedure check.  
my_deactivate                       126 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
check                    000100 pn                          check
                         000110 used                        ptw_cost
                         000111 mod                         ptw_cost
get_aste                 000100 fastep                      get_aste
                         000102 lastep                      get_aste
                         000104 mp_astep                    get_aste
                         000106 aste_count                  get_aste
                         000107 cost_total                  get_aste
                         000110 best_cost                   get_aste
                         000111 pts                         get_aste
                         000112 code                        get_aste
                         000113 ptsi                        get_aste
                         000114 ptp                         get_aste
                         000116 synchronized_call           get_aste
                         000117 synchronized_only           get_aste
                         000120 sstp                        get_aste
                         000122 astep                       get_aste
                         000134 inf_astep                   walk_ast
                         000136 next_astep                  walk_ast
                         000140 brother                     walk_ast

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        call_int_this       return_mac          ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
deactivate                    hc_dm_util$activate           hc_dm_util$check_activate     syserr
syserr$error_code             update_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$deact_in_mem     pds$process_group_id          sst_seg$                      sys_info$system_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000101       113 000112       114 000113       116 000114       119 000123       121 000125       124 000130
    125 000145       127 000150       129 000154       130 000157       131 000207       135 000213       137 000214
    139 000217       140 000220       141 000222       142 000226       143 000237       152 000243       155 000255
    156 000262       157 000263       158 000264       160 000271       162 000302       176 000306       177 000315
    178 000322       179 000327       180 000333       181 000335       200 000337       201 000350       204 000356
    205 000360       207 000362       208 000365       209 000366       212 000367       215 000400       216 000401
    219 000402       220 000405       221 000407       222 000410       225 000411       226 000417       227 000420
    230 000421       231 000426       232 000432       235 000433       236 000436       237 000446       239 000450
    242 000457       243 000466       245 000470       268 000476       270 000500       271 000502       272 000512
    273 000513       274 000515       275 000525       276 000527       277 000534       279 000536       280 000541
    281 000542       283 000544       285 000545       286 000555       287 000557       288 000564       289 000574
    291 000576       294 000604       295 000610       298 000640       299 000666       302 000672       303 000674
    304 000701       306 000703       307 000710       308 000720       310 000722       311 000724       313 000726
    317 000727       329 000731       330 000732       331 000734       333 000741       334 000743       335 000744
    337 000751       338 000756       339 000761       340 000763       342 000764       343 000771       345 000772
    346 001003       347 001007       348 001011       349 001013       356 001014       372 001022       374 001036
    376 001044       377 001060       379 001062       382 001063       383 001064       384 001070       386 001071
    387 001101       388 001115       389 001120       391 001122       393 001131       398 001132       411 001134
    413 001152       415 001164       417 001202       419 001214       420 001222       421 001231       436 001233
    441 001241       442 001252       444 001265       445 001267       449 001346


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
