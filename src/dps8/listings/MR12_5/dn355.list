          COMPILATION LISTING OF SEGMENT dn355
          Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
          Compiled at: Installation and location
          Compiled on: 12/16/17  0837.6 pst Sat
              Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,insnl,delnl,^ifthendo */
       14 dn355:
       15      procedure;
       16           return;                                           /* should never be called here */
       17 
       18 /*        Date last modified and reason
       19*
       20*   Written 10/08/74 by F. A. Canali for new tty dim
       21*   Modified by Robert Coren and Mike Grady to fix bugs and add features
       22*   Modified by Robert Coren 10/08/75 for multiple 355s
       23*   Modified by J. Stern 04/22/77 to introduce WTCBs
       24*   Modified by J. Stern 06/23/77 to behave correctly when no submailboxes available
       25*   Modified by J. Stern 07/28/77 to use all 3 words of command data in submailbox
       26*   Modified Jan.-Feb. 1978 to use variable-size output buffers and fix some bugs
       27*   Modified 3/13/78 by Robert Coren to use clock builtin instead of clock_ and to get correct
       28*   time at hangup_fnp_lines entry
       29*   Modified August 1978 by Robert Coren for demultiplexing
       30*   Modified November 8, 1978 by Robert Coren to introduce FNP-initiated mailboxes
       31*   Modified July 2 1979 by B. Greenberg for negotiated echo.
       32*   Modified March 1980 by Robert Coren to eliminate use of circular buffer.
       33*   Modified April 1980 by Robert Coren to add metering information.
       34*   Modified 1980 December by Art Beattie to ignore interrupts in invalid levels.  Also allowed command_data for
       35*   send_wcd operations to be 216 bits long (6 * 36-bit word).  Corrected error message documentation.
       36*   Modified December 1980 by Robert Coren to handle report_meters opcode
       37*   Modified April 1981 by Chris Jones for io_manager conversion
       38*   Modified September 1981 by Robert Coren to record character counts in LCTE meters and to force COLTS buffer size to maximum
       39*   Modified February 1982 by C. Hornig for MR10 io_manager.
       40*   Modified June 1982 by Robert Coren to process "line_masked" opcode.
       41*   Modified 1984-07-28 BIM for dn355_boot_interrupt$system_fault.
       42*   Modified 1984-07-30 BIM for paged mode IOM.
       43*   Modified September 1984 by Robert Coren to use include file to define delay queue entries
       44**/
       45 
       46 /****^  HISTORY COMMENTS:
       47*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
       48*     audit(86-06-19,Beattie), install(86-07-08,MR12.0-1089):
       49*     To handle 8-word echo-break tables.
       50*  2) change(86-06-19,Kissel), approve(86-07-30,MCR7475), audit(86-09-04,Coren),
       51*     install(86-10-09,MR12.0-1181):
       52*     Changed to support the new tty event message format declared in
       53*     net_event_message.incl.pl1 which replaces tty_event_message.incl.pl1.
       54*  3) change(87-07-20,Farley), approve(88-02-24,MCR7791),
       55*     audit(88-03-09,Beattie), install(88-03-15,MR12.2-1035):
       56*     Changed no response loop to use a real time constant and retry the timeout
       57*     or error one time along with reporting the problem.  If no response occurs
       58*     after the retry then the FNP will be crashed.
       59*                                                   END HISTORY COMMENTS */
       60 
       61 interrupt:
       62      entry (x_dno, x_level, x_status);                      /* entry from iom_manager */
       63 
       64 dcl  x_dno fixed bin (35);                                  /* index from assignment time */
       65 dcl  x_level fixed bin (3);                                 /* interrupt level */
       66 dcl  x_status bit (36) aligned;                             /* status after special or fault */
       67 
       68           if tc_data$system_shutdown ^= 0
       69           then return;                                      /* ignore 355's if shut down in progress */
       70           interrupt_entry = "1"b;
       71 
       72           call setup;
       73           level = x_level;                                  /* copy level to local stack */
       74           if datanet_info.trace
       75           then do;
       76                if level ^= 3 | ^fnp_info.running
       77                then syserr_severity = just_tell;
       78                else syserr_severity = log;
       79                call syserr (syserr_severity,
       80                     "dn355: FNP ^a level ^d status ^w^[ running^]^[ bootloading^]^[ t_and_d_in_progress^]", fnp_name,
       81                     level, x_status, fnp_info.running, fnp_info.bootloading, fnp_info.t_and_d_in_progress);
       82           end;
       83           if level ^= 3 & level ^= 7
       84           then do;                                          /* if not a good interrupt level */
       85                call syserr (beeper, "dn355: FNP ^a invalid interrupt level ^o", fnp_name, level);
       86                if fnp_info.bootloading
       87                then if level = 1                            /* system fault */
       88                     then call dn355_boot_interrupt$system_fault (dno);
       89                return;                                      /* lets hope its benign */
       90           end;
       91 
       92           if (^fnp_info.t_and_d_in_progress) & (^fnp_info.running) & (^fnp_info.bootloading)
       93           then return;                                      /* spurious interrupt */
       94 
       95           if ^stac (addr (lcte.lock), pds$processid)        /* somebody else has it */
       96           then do;
       97 
       98                do while (^stac (addr (fnp_info.queue_lock), pds$processid));
       99                end;
      100 
      101                if level = 7
      102                then fnp_info.level_7_pending = "1"b;
      103                else fnp_info.level_3_pending = "1"b;
      104 
      105                if stac (addr (lcte.lock), pds$processid)    /* in case it got unlocked meanwhile */
      106                then call process_int_queue ("0"b);
      107 
      108                else if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
      109                then call syserr (crash_system, "dn355: inconsistent queue lock");
      110           end;
      111 
      112           else do;
      113                call process_int (level);
      114 
      115                do while (^stac (addr (fnp_info.queue_lock), pds$processid));
      116                end;                                         /* check the queue to see if anything came in while we had the loc
k */
      117 
      118                call process_int_queue ("0"b);
      119           end;
      120 
      121           return;
      122 
      123 global_exit:                                                /* if abort out of an internal proc */
      124           if interrupt_entry
      125           then do;
      126                if stacq (lcte.lock, "0"b, pds$processid)    /* make sure we undo anything we did */
      127                then if lcte.notify_reqd
      128                     then do;
      129                          lcte.notify_reqd = "0"b;
      130                          call pxss$notify (tty_ev);
      131                     end;
      132 
      133                lcte.locked_for_interrupt = "0"b;
      134 
      135           end;
      136           return;
      137 
      138 /* entry to send a command to the FNP */
      139 send_wcd:
      140      entry (a_fnpp, a_pcbp, opa, chrsa, data);
      141 
      142 dcl  a_fnpp ptr,                                            /* parameters */
      143      a_pcbp ptr,
      144      opa fixed bin (8),
      145      data bit (*),
      146      chrsa fixed bin (8);                                   /* numeric */
      147 
      148 dcl  tdata bit (8 * 36);                                    /* could be up to 8 words for set_echnego_break_table */
      149 dcl  data_len fixed bin (8);
      150 
      151           pcbp = a_pcbp;
      152           go to send_join;
      153 
      154 send_global_wcd:
      155      entry (a_fnpp, opa, chrsa, data);
      156 
      157           pcbp = null ();
      158 
      159 send_join:
      160           interrupt_entry = "0"b;
      161           fnpp = a_fnpp;
      162           ttybp = addr (tty_buf$);                          /* get ptr to tty buf */
      163           infop = addr (dn355_data$);                       /* and dn 355 info */
      164           lctep = fnp_info.lcte_ptr;
      165           operation = opa;                                  /* and copy op to local stack */
      166           if ^fnp_info.running                              /* can't talk to it if it's not listening */
      167           then return;
      168 
      169           no_response = "0"b;
      170           dno = fnp_info.fnp_number;
      171           mbxp = fnp_info.mbx_pt;                           /* get pointer to mailbox */
      172           data_len = min (length (tdata), chrsa);           /* compute bit length of command data */
      173           if data_len > 0
      174           then tdata = substr (data, 1, data_len);
      175           else tdata = "0"b;
      176 
      177           i = index (used_string, "0"b);                    /* find a free sub mbx */
      178           if i = 0                                          /* no submailbox */
      179           then do;
      180                call make_q_entry (operation, data_len, tdata);
      181                fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
      182                                                             /* form q entry element from data */
      183           end;
      184 
      185           else do;                                          /* we have a sub mbx, ship it off to the 355 */
      186                subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));
      187                                                             /* get sub mbx addr */
      188                if pcbp ^= null ()
      189                then do;
      190                     string (sub_mbx.line_number) = string (pcb.line_number);
      191                                                             /* move line number to sub mbx */
      192                     devx = pcb.devx;
      193                end;
      194 
      195                else string (sub_mbx.line_number) = "0"b;    /* unless no pcb (global call) */
      196 
      197                sub_mbx.op_code = operation;                 /* set sub mbx op */
      198                sub_mbx.cmd_data_len = divide (data_len, 6, 17, 0);
      199                                                             /* set data length */
      200                if operation = accept_direct_output          /* if output op */
      201                then do;
      202                     if ^pcb.flags.dialed                    /* output without a dialup? */
      203                     then call throw_away_output;            /* discard it */
      204 
      205                     else call process_send_output (i - 1, "0"b);
      206                end;
      207 
      208                else if operation = set_echnego_break_table
      209                then do;
      210                     if pcb.flags.dialed
      211                     then call send_echo_table (i - 1, tdata);
      212                end;
      213 
      214                else do;
      215                     sub_mbx.io_cmd = wcd;                   /* set write control data cmd */
      216                     smbx_cmd_data_long = substr (tdata, 1, data_len);
      217                                                             /* move command data to sub mbx */
      218                     call send_mbx (i - 1);                  /* ship the mbx off to the 355 */
      219                     fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
      220                end;
      221 
      222 
      223                if no_response
      224                then call report_fnp_no_response;
      225           end;
      226 
      227 
      228           return;                                           /* return to caller */
      229 
      230 process_interrupt_queue:
      231      entry (x_dno);
      232 
      233           interrupt_entry = "0"b;
      234           call setup;
      235           on cleanup call check_lock;
      236           masked = "1"b;                                    /* have to mask and wire while holding queue lock */
      237           call pmut$wire_and_mask (wire_arg, wire_ptr);
      238 
      239           do while (^stac (addr (fnp_info.queue_lock), pds$processid));
      240           end;
      241           queue_locked = "1"b;
      242 
      243           call process_int_queue ("1"b);
      244           return;
      245 
      246 setup:
      247      proc;
      248 
      249           ttybp = addr (tty_buf$);                          /* get addr of tty buffer segment */
      250           dno = x_dno;                                      /* copy 355 number to local stack */
      251           infop = addr (dn355_data$);                       /* get address of 355 info segment */
      252 
      253           fnpp = addr (datanet_info.per_datanet (dno));
      254           fnp_name = fnp_info.fnp_tag;
      255           mbxp = fnp_info.mbx_pt;                           /* get mailbox pointer */
      256           lctep = fnp_info.lcte_ptr;
      257 
      258           return;
      259      end setup;
      260 
      261 process_int_queue:
      262      proc (caller_masked);
      263 
      264 /* called with queue locked. Empties the queue, and must unlock it when done */
      265 
      266 dcl  caller_masked bit (1);                                 /* indicates whether caller explicitly called pmut$wire_and_mask *
/
      267 
      268           do while (dequeue (level));
      269                fnp_info.processed_from_q = fnp_info.processed_from_q + 1;
      270                                                             /* meter */
      271                if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
      272                then call syserr (crash_system, "dn355: inconsistent queue lock");
      273 
      274                queue_locked = "0"b;
      275                if caller_masked
      276                then call pmut$unwire_unmask (wire_arg, wire_ptr);
      277                masked = "0"b;
      278 
      279                call process_int (level);
      280 
      281                if caller_masked
      282                then do;                                     /* if we unmasked, we have to mask again */
      283                     masked = "1"b;
      284                     call pmut$wire_and_mask (wire_arg, wire_ptr);
      285                end;
      286 
      287                do while (^stac (addr (fnp_info.queue_lock), pds$processid));
      288                end;
      289                queue_locked = "1"b;
      290           end;
      291 
      292           lcte.locked_for_interrupt = "0"b;
      293           if ^stacq (lcte.lock, "0"b, pds$processid)
      294           then call syserr (crash_system, "dn355: LCTE lock ^^= processid");
      295 
      296           if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
      297           then call syserr (crash_system, "dn355: inconsistent queue lock");
      298 
      299           queue_locked = "0"b;
      300           if caller_masked
      301           then call pmut$unwire_unmask (wire_arg, wire_ptr);
      302           masked = "0"b;
      303 
      304           if lcte.notify_reqd
      305           then do;
      306                lcte.notify_reqd = "0"b;
      307                call pxss$notify (tty_ev);
      308           end;
      309 
      310           return;
      311 
      312 dequeue:
      313           proc (a_level) returns (bit (1));
      314 
      315 dcl  a_level fixed bin;
      316 
      317                if fnp_info.level_3_pending
      318                then do;
      319                     fnp_info.level_3_pending = "0"b;
      320                     a_level = 3;
      321                     return ("1"b);
      322                end;
      323 
      324                else if fnp_info.level_7_pending
      325                then do;
      326                     fnp_info.level_7_pending = "0"b;
      327                     a_level = 7;
      328                     return ("1"b);
      329                end;
      330 
      331                else return ("0"b);
      332 
      333           end /* dequeue */;
      334      end /* process_int_queue */;
      335 
      336 process_int:
      337      proc (a_level);
      338 
      339 /* internal procedure to process an interrupt, either when it occurs or from the queue */
      340 
      341 dcl  a_level fixed bin;
      342 
      343           level = a_level;
      344 
      345           lcte.locked_for_interrupt = "1"b;
      346           if level = 7
      347           then do;                                          /* emergency interrupt */
      348 
      349                if fnp_info.t_and_d_in_progress
      350                then do;
      351                     if fnp_info.t_and_d_lev_7_occurred
      352                     then return;
      353                     fnp_info.t_and_d_lev_7_occurred = "1"b;
      354 t_and_d_join:
      355                     if fnp_info.t_and_d_notify_requested
      356                     then do;
      357                          call pxss$notify (tty_ev);
      358                          fnp_info.t_and_d_notify_requested = "0"b;
      359                     end;
      360                     unspec (auto_net_event_message) = "0"b;
      361                     auto_net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;
      362                     auto_net_event_message.network_type = MCS_NETWORK_TYPE;
      363                     auto_net_event_message.handle = dno;
      364                     auto_net_event_message.type = level;
      365                     unspec (net_event_message_arg) = unspec (auto_net_event_message);
      366                     call pxss$unique_ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan,
      367                          net_event_message_arg, 0);
      368                     return;
      369                end;
      370 
      371 /* figure out reason for crash according to data in mailbox header */
      372 
      373                fault_type = datanet_mbx.crash_data.fault_code;
      374                if fault_type > hbound (dn355_messages$fault_names, 1) | fault_type < 0
      375                then fault_name = "unknown fault";
      376                else fault_name = dn355_messages$fault_names (fault_type);
      377 
      378                call syserr (beeper, "dn355: emergency interrupt from FNP ^a: ^a", fnp_info.fnp_tag, fault_name);
      379 
      380                if datanet_mbx.crash_data.ic ^= 0
      381                then call syserr (just_tell, "FNP instruction counter = ^6o", datanet_mbx.crash_data.ic);
      382 
      383                if fault_type = iom_channel_fault
      384                then call syserr (just_tell, "channel ^o, fault status = ^6o", datanet_mbx.crash_data.fault_word,
      385                          datanet_mbx.crash_data.iom_fault_status);
      386 
      387                else if fault_type = illegal_opcode
      388                then if dn355_word.opcode = die_code         /* did 355 crash deliberately? */
      389                     then do;
      390                          modulep = addr (dn355_messages$per_module);
      391                          module_num = fixed (dn355_word.modnum, 4);
      392                          if module_num > 0 & module_num <= hbound (dn355_modules.list_offset, 1)
      393                               & dn355_word.crash_code > 0 & dn355_word.crash_code <= hbound (modulep -> message_offset, 1)
      394                          then do;
      395                               reasonp = ptr (modulep, dn355_modules.list_offset (module_num));
      396                               reasonp = ptr (reasonp, reasonp -> message_offset (dn355_word.crash_code));
      397 
      398                               call syserr (just_tell, "^a: ^a", dn355_modules.name (module_num), dn355_reason.msg);
      399                          end;
      400                     end;
      401 
      402                call report_fnp_crash;                       /* report it and hang up lines */
      403                return;                                      /* done with this interrupt */
      404           end;
      405 
      406 /* level must be 3, a normal everyday 355 interrupt */
      407 
      408           if fnp_info.bootloading                           /* if this is bootload status */
      409           then do;
      410                call dn355_boot_interrupt (dno);             /* let special routine figure it out */
      411                return;
      412           end;
      413 
      414           if fnp_info.t_and_d_in_progress
      415           then do;
      416                if fnp_info.t_and_d_lev_3_occurred
      417                then return;
      418                fnp_info.t_and_d_lev_3_occurred = "1"b;
      419                go to t_and_d_join;
      420           end;
      421 
      422           if ^fnp_info.running                              /* if this interrupt is premature, ignore it */
      423           then return;
      424 
      425           no_response = "0"b;                               /* initially */
      426 
      427           if fnp_info.count > 0                             /* had we had to wait for a free mbx? */
      428           then call process_q;
      429 
      430 /* process any submailboxes which have been returned by the 355 */
      431 
      432           timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));/* get timw and clear */
      433 
      434           do i = 0 to 7;                                    /* loop over submailbox indicators */
      435 
      436                if timwb (i) & ^no_response
      437                then do;                                     /* if mailbox was returned by 355 then we have something to do */
      438 
      439                     subp = addr (datanet_mbx.dn355_sub_mbxes (i));
      440                                                             /* get pointer to sub mailbox */
      441                     datanet_mbx.mbx_used_flags.used (i) = "0"b;
      442                                                             /* clear submailbox used flag */
      443                     datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;
      444                     fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
      445                     fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;
      446 
      447                     if sub_mbx.io_cmd = wcd
      448                     then do;
      449                          if sub_mbx.op_code = dump_mem | sub_mbx.op_code = patch_mem
      450                          then do;
      451                               fnp_info.dump_patch_in_progress = "0"b;
      452                               call pxss$notify (FNP_DUMP_PATCH_EVENT);
      453                          end;
      454 
      455                          else if sub_mbx.op_code = report_meters
      456                          then do;
      457                               call get_line_number;
      458                               if devx = -1
      459                               then if fnp_info.get_meters_waiting
      460                                                             /* fnp_multiplexer is waiting for global meters */
      461                                    then do;
      462                                         fnp_info.get_meters_waiting = "0"b;
      463                                         call pxss$notify (FNP_METER_EVENT);
      464                                    end;
      465                                    else ;                   /* copy_meters for whole FNP shouldn't arise */
      466 
      467                               else if pcb.get_meters_waiting/* waiting for channel's meters */
      468                               then do;
      469                                    pcb.get_meters_waiting = "0"b;
      470                                    call pxss$notify (FNP_METER_EVENT);
      471                               end;
      472 
      473                               else pcb.copied_meters_ready = "1"b;
      474                                                             /* must be copy_meters, mark it so call side can copy them to unwi
red */
      475                          end;
      476                     end;                                    /* just free submbx */
      477 
      478                     else do;
      479                          call get_line_number;
      480                          if sub_mbx.io_cmd = wtx
      481                          then do;                           /* check for write text */
      482 
      483                               pcb.output_mbx_pending = "0"b;
      484                               dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (i));
      485                               chain_head_ptr = ptr (ttybp, bin (dcw_list (1).dcw_ptr, 18) - (tty_buf.absorig + dataoff));
      486                               call tty_space_man$free_chain ((pcb.devx), OUTPUT, chain_head_ptr);
      487                                                             /* and the output chain */
      488 
      489                               if sub_mbx.command_data (1) ^= "0"b
      490                                                             /* immediate send-output */
      491                               then call process_send_output (i, "1"b);
      492 
      493                          end;
      494 
      495 
      496 
      497                          else do;
      498                               call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o",
      499                                    sub_mbx.io_cmd, fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));
      500                                                             /* complain */
      501                               call report_fnp_crash;        /* act as if FNP crashed */
      502                               return;
      503                          end;
      504                     end;
      505                end;
      506           end;
      507 
      508           do i = 8 to 11;                                   /* now look at FNP-initiated mailboxes */
      509                if timwb (i) & ^no_response
      510                then do;
      511                     subp = addr (datanet_mbx.fnp_sub_mbxes (i - 8));
      512                     call get_line_number;
      513 
      514                     if sub_mbx.io_cmd = rcd
      515                     then do;                                /* check for control stuff */
      516 
      517                          if (sub_mbx.op_code = accept_direct_input) | (sub_mbx.op_code = send_output)
      518                               | (sub_mbx.op_code = input_in_mailbox)
      519                          then do;
      520                               fnp_info.bleft_355 = fnp_sub_mbx.n_free_buffers - 4;
      521                                                             /* get the buffer count from 355 */
      522 
      523                               if fnp_info.bleft_355 < 0
      524                               then                          /* if above was too much correction */
      525                                    fnp_info.bleft_355 = 0;  /* make it safe */
      526 
      527 
      528                               if fnp_info.free_size > 16000000000
      529                               then do;
      530                                    fnp_info.free_size = 0;
      531                                    fnp_info.free_count = 0;
      532                               end;
      533 
      534                               fnp_info.free_size = fnp_info.free_size + fnp_info.bleft_355;
      535                               fnp_info.free_count = fnp_info.free_count + 1;
      536                          end;
      537 
      538                          if sub_mbx.op_code = accept_direct_input | sub_mbx.op_code = input_in_mailbox
      539                          then fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;
      540                          else fnp_info.input_control_transactions = fnp_info.input_control_transactions + 1;
      541 
      542                          if sub_mbx.op_code = accept_new_terminal
      543                          then do;                           /* check for new terminal on line */
      544 
      545 
      546                               pcb.line_type, dialup_info.line_type = bin (sub_mbx.command_data (1), 17);
      547                               if sub_mbx.command_data (2)
      548                               then pcb.baud_rate = baud_table (bin (sub_mbx.command_data (2), 17));
      549 
      550                               do j = 1 to n_sync_line_types while (sync_line_type (j) ^= pcb.line_type);
      551                               end;
      552                               pcb.sync_line = (j <= n_sync_line_types);
      553 
      554                               if ^pcb.sync_line             /* asynchronous */
      555                               then bits_per_char = 10;
      556                               else bits_per_char = 8;       /* assumption for synchronous lines */
      557 
      558                               max_buf_chars =
      559                                    divide (divide (pcb.baud_rate, bits_per_char, 17, 0), buf_per_second, 17, 0);
      560                               pcb.max_buf_size = min (16 * divide (max_buf_chars + 67, 64, 17, 0), 128);
      561                                                             /* round up to multiple of 16 words */
      562                               if pcb.line_type = LINE_COLTS
      563                               then pcb.max_buf_size = 128;  /* COLTS channel always gets big buffers */
      564 
      565                               dialup_info.baud_rate = pcb.baud_rate;
      566                               dialup_info.max_buf_size = pcb.max_buf_size;
      567                               dialup_info.buffer_pad = 0;
      568                               dialup_info.receive_mode_device = (dialup_info.line_type = LINE_ETX);
      569                               dialup_info.pad = "0"b;
      570                               pcb.dialed = "1"b;
      571 
      572                               sub_mbx.op_code = terminal_accepted;
      573                                                             /* inform 355 that term is ok */
      574                               sub_mbx.cmd_data_len = 3;     /* we will put write buffer threshold in command data */
      575                               if ^pcb.high_speed            /* less than 1200 baud */
      576                               then addr (sub_mbx.command_data) -> unal_number = 2;
      577                                                             /* set low write buffer threshold */
      578                               else addr (sub_mbx.command_data) -> unal_number = 4;
      579                                                             /* set high write buffer threshold */
      580                               sub_mbx.io_cmd = wcd;
      581                               call return_mbx (i);
      582                               interrupt_info = unspec (dialup_info);
      583                               call channel_manager$interrupt (devx, DIALUP, interrupt_info);
      584 
      585                          end;
      586 
      587 
      588                          else if sub_mbx.op_code = disconnected_line
      589                          then do;                           /* see if line just hung up */
      590                               pcb.dialed = "0"b;
      591                               call throw_away_output;
      592                               call channel_manager$interrupt (devx, HANGUP, ""b);
      593                               call free_mbx (i);
      594 
      595                          end;
      596 
      597                          else if sub_mbx.op_code = wru_timeout
      598                          then do;                           /* 355 couldn't get answerback */
      599                               if pcb.dialed
      600                               then call channel_manager$interrupt (devx, WRU_TIMEOUT, ""b);
      601                               call free_mbx (i);
      602                          end;
      603 
      604                          else if sub_mbx.op_code = break_condition
      605                          then do;                           /* check for break */
      606 
      607                               if pcb.dialed
      608                               then do;
      609                                    if pcb.hndlquit
      610                                    then call throw_away_output;
      611                                    call channel_manager$interrupt (devx, QUIT, ""b);
      612                               end;
      613                               call free_mbx (i);
      614                          end;
      615 
      616 
      617                          else if sub_mbx.op_code = send_output
      618                          then do;                           /* is this request for output? */
      619 
      620                               call free_mbx (i);
      621                               if pcb.dialed
      622                               then call process_send_output (-1, "1"b);
      623                                                             /* -1 indicates no current mailbox */
      624                          end;
      625 
      626 
      627                          else if sub_mbx.op_code = accept_direct_input
      628                          then do;                           /* check for input from terminal */
      629 
      630                               if pcb.dialed
      631                               then call process_accept_input;
      632 
      633                               else do;
      634                                    sub_mbx.io_cmd = wcd;    /* we'll tell him to hang up */
      635                                    sub_mbx.op_code = disconnect_this_line;
      636                                    call return_mbx (i);
      637                               end;
      638                          end;
      639 
      640                          else if sub_mbx.op_code = error_message
      641                          then do;                           /* error message from 355 */
      642                               offset = bin (error_msg.data (1), 18);
      643                                                             /* get which error message this is */
      644                               if offset > 0 & offset <= hbound (dn355_messages$error_messages, 1)
      645                               then do;
      646                                    offset = dn355_messages$error_messages (offset);
      647                                                             /* offset of message */
      648                                    reasonp = addr (dn355_messages$error_messages);
      649                                                             /* get ptr */
      650                                    reasonp = ptr (reasonp, offset);
      651                                                             /* now we have message */
      652                                    reason_msg = dn355_reason.msg;
      653                               end;
      654 
      655                               else reason_msg = "unrecognized error ^o ^o ^o";
      656 
      657                               do ix = 1 to 3;
      658                                    full_words (ix) = bin (error_msg.data (ix + 1), 18);
      659                               end;
      660                               call syserr (just_tell, "dn355: Message from FNP ^a: " || reason_msg, fnp_info.fnp_tag,
      661                                    full_words);
      662                               call free_mbx (i);
      663                          end;
      664 
      665                          else if sub_mbx.op_code = input_in_mailbox
      666                          then do;
      667                               if pcb.dialed
      668                               then call process_input_in_mbx;
      669                               else do;
      670                                    sub_mbx.io_cmd = wcd;    /* tell him to give up */
      671                                    sub_mbx.op_code = disconnect_this_line;
      672                                    call return_mbx (i);
      673                               end;
      674                          end;
      675 
      676                          else if sub_mbx.op_code >= first_acu_op_code & sub_mbx.op_code <= last_acu_op_code
      677                          then do;                           /* acu failure */
      678                               interrupt_info = bit (bin (sub_mbx.op_code, 9));
      679                               call channel_manager$interrupt (devx, DIAL_STATUS, interrupt_info);
      680                               call free_mbx (i);
      681                          end;
      682 
      683                          else if sub_mbx.op_code = line_status
      684                          then do;                           /* some status from fnp */
      685                               interrupt_info = substr (unspec (sub_mbx.command_data), 1, 72);
      686                               call channel_manager$interrupt (devx, LINE_STATUS, interrupt_info);
      687                               call free_mbx (i);
      688                          end;
      689 
      690                          else if sub_mbx.op_code = ack_echnego_init
      691                          then do;
      692                               call free_mbx (i);
      693                               call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_INIT, "0"b);
      694                          end;
      695 
      696                          else if sub_mbx.op_code = ack_echnego_stop
      697                          then do;
      698                               call free_mbx (i);
      699                               call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_STOP, "0"b);
      700                          end;
      701 
      702                          else if sub_mbx.op_code = line_masked
      703                          then do;                           /* see if channel was masked */
      704                               pcb.dialed, pcb.listen = "0"b;
      705                               call throw_away_output;
      706                               call syserr (just_tell,
      707                                    "dn355: FNP masked channel ^a.h^d^[0^;^]^d for excessive interrupts", fnp_info.fnp_tag,
      708                                    binary (sub_mbx.line_number.la_no, 3), (binary (sub_mbx.line_number.slot_no, 6) < 10),
      709                                    binary (sub_mbx.line_number.slot_no, 6));
      710                               call channel_manager$interrupt (devx, MASKED, ""b);
      711                               call free_mbx (i);
      712 
      713                          end;
      714 
      715                          else do;
      716                               call syserr (beeper, "dn355: unrecognized op code ^o with rcd from FNP ^a for devx ^o",
      717                                    sub_mbx.op_code, fnp_info.fnp_tag, devx);
      718                                                             /* someone goofed */
      719                               call report_fnp_crash;
      720                               return;
      721                          end;
      722                     end;
      723 
      724 
      725 
      726                     else if sub_mbx.io_cmd = rtx
      727                     then call process_rtx;                  /* check for read text */
      728 
      729                     else do;
      730                          call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o", sub_mbx.io_cmd,
      731                               fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));
      732                                                             /* complain */
      733                          call report_fnp_crash;             /* give up on this FNP */
      734                          return;
      735                     end;
      736                end;
      737           end;
      738 
      739 
      740           if ^no_response                                   /* assuming we believe FNP is still there */
      741           then if fnp_info.count > 0
      742                then call process_q;
      743 
      744 
      745           if no_response                                    /* if someone discovered that the FNP was gone */
      746           then call report_fnp_no_response;
      747 
      748           return;
      749      end /* process_int */;
      750 
      751 process_q:
      752      proc;
      753 
      754 /* process the queue of mailbox operations that could not be performed
      755*   because no mailboxes wre available
      756**/
      757 
      758           q_first = fnp_info.cur_ptr;
      759           q_count = fnp_info.count;
      760           i = 1;                                            /* preset while variable */
      761 
      762           do while (q_count > 0 & i > 0);
      763                i = index (used_string, "0"b);
      764                if i > 0                                     /* now we can have one */
      765                then do;
      766                     subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));
      767                     qptr = ptr (ttybp, q_first);
      768                     if q_entry.pcb_offset ^= "0"b           /* for a specific channel */
      769                     then do;
      770                          pcbp = ptr (ttybp, q_entry.pcb_offset);
      771                          string (sub_mbx.line_number) = string (pcb.line_number);
      772                          devx = pcb.devx;
      773                     end;
      774                     else string (sub_mbx.line_number) = ""b;
      775 
      776                     if q_entry.opcode = accept_direct_output
      777                     then if pcb.dialed
      778                          then call process_send_output (i - 1, "0"b);
      779                          else ;
      780 
      781                     else if q_entry.opcode = set_echnego_break_table
      782                     then if pcb.dialed
      783                          then call send_echo_table (i - 1, q_entry.cmd_data);
      784                          else ;
      785 
      786                     else do;
      787                          sub_mbx.io_cmd = wcd;
      788                          sub_mbx.op_code = q_entry.opcode;
      789                          sub_mbx.cmd_data_len = divide (q_entry.cmd_count, 6, 8, 0);
      790                          smbx_cmd_data_long = substr (q_entry.cmd_data, 1, q_entry.cmd_count);
      791                          call send_mbx (i - 1);
      792                          fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
      793                     end;
      794 
      795                     if no_response                          /* give up in this case */
      796                     then go to update_q_ptrs;
      797 
      798                     q_first = q_entry.next;                 /* on to next queue entry */
      799                     q_count = q_count - 1;
      800                     call tty_space_man$free_space (size (q_entry), qptr);
      801                end;
      802 
      803                else fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
      804           end;
      805 
      806 update_q_ptrs:
      807           fnp_info.cur_ptr = q_first;
      808           fnp_info.count = q_count;
      809           if q_count = 0
      810           then fnp_info.last_ptr = 0;
      811 
      812           return;
      813      end /* process_q */;
      814 
      815 /* internal subroutine to process send output */
      816 
      817 process_send_output:
      818      proc (a_mbx_num, interrupt_entry);
      819 
      820 dcl  a_mbx_num fixed bin;                                   /* -1 indicates mailbox not already allocated */
      821 dcl  mbx_num fixed bin;
      822 dcl  interrupt_entry bit (1) aligned;                       /* indicates whether or not called on interrupt side */
      823 
      824           mbx_num = a_mbx_num;
      825           if pcb.end_frame | pcb.output_mbx_pending         /* if we're waiting for form-feed  or we got delayed */
      826           then do;
      827                pcb.flags.send_output = "1"b;                /* we'll want output eventually */
      828                return;                                      /* don't do anything else */
      829           end;
      830 
      831           if pcb.write_first = 0
      832           then do;
      833                pcb.flags.send_output = "1"b;                /* if no output then just set flag */
      834                call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
      835           end;
      836 
      837           else do;
      838                if mbx_num = -1                              /* caller didn't supply one */
      839                then do;
      840                     mbx_num = index (used_string, "0"b) - 1;/* find a free one */
      841 
      842                     if mbx_num = -1                         /* still? we didn't get one */
      843                     then do;
      844                          call make_q_entry (accept_direct_output, 0, ""b);
      845                          fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;
      846                          return;                            /* we'll catch it later */
      847                     end;
      848                     else do;
      849                          subp = addr (datanet_mbx.dn355_sub_mbxes (mbx_num));
      850                          string (sub_mbx.line_number) = string (pcb.line_number);
      851                     end;
      852                end;
      853 
      854 
      855                pcb.flags.send_output = "0"b;                /* make sure flag clear */
      856                dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));
      857 
      858                sub_mbx.data_addr = bit (bin (bin (rel (dcwlptr), 18) + tty_buf.absorig, 18), 18);
      859                output_limit =
      860                     max (
      861                     min (divide ((fnp_info.bleft_355 - tc_data$fnp_buffer_threshold) * 60, output_bpart, 17, 0),
      862                     max_chain_len * 4 * (pcb.max_buf_size - 1)), 1);
      863 
      864                output_chars = 0;                            /* none so far */
      865                continue = "1"b;
      866                do j = 1 to max_chain_len while (pcb.write_first ^= 0 & output_chars < output_limit & continue);
      867                                                             /* set up dcw list */
      868                     dcw_list (j).dcw_ptr = bit (bin (pcb.write_first + dataoff + tty_buf.absorig, 18), 18);
      869                                                             /* set dcw abs addr */
      870                     blockp = ptr (ttybp, pcb.write_first);  /* get ptr to buffer */
      871                     if buffer.tally = 0                     /* we don't want this in a dcw */
      872                     then call syserr (crash_system, "dn355: output buffer at ^o has zero tally", pcb.write_first);
      873 
      874                     dcw_list (j).dcw_tally = bit (buffer.tally, 9);
      875                                                             /* set dcw tally from buffer */
      876                     dcw_list (j).pad = "0"b;                /* 355 depends on this */
      877                     pcb.write_first = buffer.next;          /* now bump to next buffer */
      878                     pcb.write_cnt = pcb.write_cnt - buffer.tally;
      879                                                             /* decrement count of chars in chain */
      880                     output_chars = output_chars + buffer.tally;
      881                                                             /* keep count of characters sent */
      882                     if buffer.flags.end_of_page             /* if this buffer fills a page/screen */
      883                     then do;
      884                          pcb.flags.end_frame = "1"b;        /* remember it */
      885                          continue = "0"b;                   /* terminate the loop */
      886                     end;
      887                end;
      888 
      889                chain_len = max (j - 1, 1);                  /* this is now the length of the chain */
      890 
      891                sub_mbx.word_cnt = chain_len;                /* we have maximum length dcw list */
      892                sub_mbx.op_code = accept_direct_output;      /* and do not have last buffer */
      893                sub_mbx.command_data (1) = "0"b;             /* make sure it starts clean */
      894                sub_mbx.io_cmd = wtx;                        /* set write text io command */
      895                pcb.output_mbx_pending = "1"b;
      896                buffer.next = 0;                             /* indicate end of active write block */
      897                call send_mbx (mbx_num);                     /* ship sub mbx off to 355 */
      898                fnp_info.output_data_transactions = fnp_info.output_data_transactions + 1;
      899                lcte.meters.out_bytes = lcte.meters.out_bytes + output_chars;
      900                                                             /* meter */
      901 
      902                if /* tree */ pcb.write_first = 0
      903                then do;                                     /* see if we ran out of buffers */
      904                     pcb.write_last = 0;                     /* zero ptr to last */
      905                     if interrupt_entry
      906                     then call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
      907                                                             /* wakeup the user */
      908                end;
      909                else if chain_len < max_chain_len & ^pcb.flags.end_frame
      910                                                             /* must have stopped because there wasn't enough space */
      911                     then fnp_info.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output + 1;
      912           end;
      913 
      914           return;                                           /* and return to caller */
      915      end;
      916 
      917 /* internal subroutine to process set_echnego_break_table operation */
      918 
      919 /* Because the echo table is 8 words long, it won't fit in a sub_mbx, so we
      920*   have to send the FNP the address so it can read the table. To avoid extra
      921*   storage overhead, and the necessity of freeing storage when the operation
      922*   completes, the table is put in the dcw_list area corresponding to the mailbox. */
      923 
      924 send_echo_table:
      925      procedure (mbx_num, table_bits);
      926 
      927 dcl  mbx_num fixed bin;
      928 dcl  table_bits bit (8 * 36);
      929 
      930 dcl  table_ptr pointer;
      931 dcl  bits_to_send bit (8 * 36) based;
      932 
      933           if ^pcb.dialed
      934           then return;
      935           table_ptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));
      936           table_ptr -> bits_to_send = table_bits;
      937           sub_mbx.op_code = set_echnego_break_table;
      938           sub_mbx.io_cmd = wcd;
      939           sub_mbx.data_addr = bit (bin (bin (rel (table_ptr), 18) + tty_buf.absorig, 18), 18);
      940           sub_mbx.word_cnt = 8;
      941 
      942           call send_mbx (mbx_num);
      943           fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;
      944           return;
      945      end send_echo_table;
      946 
      947 /* internal procedure to respond to accept_input mailbox */
      948 
      949 process_accept_input:
      950      proc;
      951 
      952 dcl  tally fixed bin;
      953 dcl  buf_size fixed bin;
      954 dcl  prev_blockp ptr;
      955 
      956           input_count = input_sub_mbx.n_chars;              /* get char count */
      957           j = divide (input_count + 3, 4, 17, 0);           /* compute number of words of circular buffer needed */
      958 
      959           if enough_input_space (j) & pcb.read_first = 0
      960           then do;
      961                do k = 1 to input_sub_mbx.n_buffers;
      962                     tally = input_sub_mbx.dcw (k).tally;
      963                     buf_size = 16 * divide (tally + 67, 64, 17, 0);
      964                                                             /* get next higher multiple of 16 words */
      965                     call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);
      966                     if blockp = null ()                     /* couldn't get the space */
      967                     then do;
      968                          if pcb.read_first ^= 0             /* if we started building a chain */
      969                          then call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));
      970                          pcb.read_first = 0;
      971                          go to reject;
      972                     end;
      973 
      974                     if pcb.read_first = 0
      975                     then pcb.read_first = bin (rel (blockp));
      976                     else prev_blockp -> buffer.next = bin (rel (blockp));
      977 
      978                     buffer.tally = tally;
      979                     input_sub_mbx.dcw (k).abs_addr =
      980                          bit (bin (tty_buf.absorig + bin (rel (addr (buffer.chars))), 24), 24);
      981                                                             /* point DCW at data portion of buffer */
      982                     prev_blockp = blockp;
      983                end;
      984 
      985                pcb.read_last = bin (rel (blockp));
      986 
      987                sub_mbx.op_code = input_accepted;            /* inform 355 that we will take input now */
      988                sub_mbx.io_cmd = rtx;
      989                call return_mbx (i);
      990           end;
      991 
      992           else do;
      993 reject:
      994                sub_mbx.io_cmd = wcd;
      995                sub_mbx.op_code = reject_request_temp;       /* inform 355 that we can not accept input
      996*                                                               at the present time */
      997                call return_mbx (i);
      998                fnp_info.input_reject_count = fnp_info.input_reject_count + 1;
      999                call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);
     1000           end;
     1001 
     1002      end /* process_accept_input */;
     1003 
     1004 /* internal proc to process rtx */
     1005 process_rtx:
     1006      proc;
     1007 
     1008 dcl  real_word_cnt fixed bin;
     1009 dcl  n_words fixed bin;
     1010 dcl  buf_size fixed bin;
     1011 dcl  source_ptr ptr;
     1012 dcl  target_ptr ptr;
     1013 
     1014           fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;
     1015           real_word_cnt = input_sub_mbx.n_chars;
     1016           lcte.meters.in_bytes = lcte.meters.in_bytes + real_word_cnt;
     1017           rtx_info.break_char = substr (input_sub_mbx.command_data, 18, 1);
     1018           call check_ff ("0"b);                             /* see if input ends with a form feed */
     1019           input_count = real_word_cnt;
     1020           if input_count ^= 0                               /* must have been a single FF that we discarded */
     1021           then do;
     1022                rtx_info.output_in_fnp = substr (input_sub_mbx.command_data, 17, 1);
     1023                rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);
     1024                rtx_info.input_count = input_count;
     1025                rtx_info.chain_head = bit (pcb.read_first, 18);
     1026                rtx_info.chain_tail = bit (pcb.read_last, 18);
     1027                interrupt_info = unspec (rtx_info);
     1028                call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
     1029           end;
     1030 
     1031           else call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));
     1032 
     1033           pcb.read_first, pcb.read_last = 0;
     1034 
     1035           call free_mbx (i);
     1036 
     1037           return;                                           /* and return to caller */
     1038 
     1039 process_input_in_mbx:
     1040      entry;
     1041 
     1042 /* we will copy input directly from mailbox into one buffer (if possible) */
     1043 
     1044           numchars = fnp_sub_mbx.n_chars;
     1045           rtx_info.break_char = substr (fnp_sub_mbx.command_data, 18, 1);
     1046           call check_ff ("1"b);
     1047           if numchars > 0
     1048           then do;
     1049                n_words = divide (numchars + 3, 4, 17, 0);
     1050                if enough_input_space (n_words)
     1051                then do;
     1052                     buf_size = 16 * (divide (n_words + 17, 16, 17, 0));
     1053                                                             /* get next multiple of 16 words */
     1054                     call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);
     1055                     if blockp = null
     1056                     then go to not_enough_space;
     1057 
     1058                     source_ptr = addr (fnp_sub_mbx.input_data);
     1059                     target_ptr = addr (buffer.chars);
     1060                     target_ptr -> chars = source_ptr -> chars;
     1061                     buffer.tally = numchars;
     1062                     rtx_info.output_in_fnp = substr (fnp_sub_mbx.command_data, 17, 1);
     1063                     rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);
     1064                     rtx_info.input_count = numchars;
     1065                     rtx_info.chain_head, rtx_info.chain_tail = rel (blockp);
     1066                                                             /* only one buffer */
     1067                     lcte.meters.in_bytes = lcte.meters.in_bytes + numchars;
     1068                     interrupt_info = unspec (rtx_info);
     1069                     call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);
     1070                     call free_mbx (i);
     1071                end;
     1072 
     1073                else do;                                     /* space test failed */
     1074 not_enough_space:
     1075                     sub_mbx.io_cmd = wcd;                   /* tell him we can't take it */
     1076                     sub_mbx.op_code = reject_request_temp;
     1077                     call return_mbx (i);
     1078                     call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);
     1079                end;
     1080           end;
     1081 
     1082           else call free_mbx (i);                           /* nothing there except form_feed */
     1083           return;
     1084 
     1085 check_ff:
     1086           proc (in_mbx);                                    /* internal procedure to check input for form-feed */
     1087 
     1088 dcl  in_mbx bit (1);
     1089 
     1090                rtx_info.formfeed_present = "0"b;            /* for now */
     1091                if pcb.sync_line                             /* form feeds not interesting in this case */
     1092                then return;
     1093 
     1094                if in_mbx
     1095                then do;
     1096                     bufp = addr (fnp_sub_mbx.input_data);
     1097                     chars_left = numchars;
     1098                end;
     1099 
     1100                else do;
     1101                     blockp = ptr (ttybp, pcb.read_last);
     1102                     chars_left = buffer.tally;
     1103                     bufp = addr (buffer.chars);
     1104                end;
     1105 
     1106                if substr (bufp -> input_chars, chars_left, 1) = form_feed
     1107                                                             /* yup, input ends with FF */
     1108                then rtx_info.formfeed_present = "1"b;
     1109                if pcb.flags.end_frame & rtx_info.break_char /* time to restart suspended output */
     1110                then do;
     1111                     if (chars_left <= 2)
     1112                     then if verify (substr (bufp -> input_chars, 1, chars_left), ff_cr_lf) = 0
     1113                          then do;                           /* this input is just to restart output, discard it */
     1114                               if in_mbx
     1115                               then numchars = 0;
     1116                               else real_word_cnt = 0;
     1117                          end;
     1118                     pcb.flags.end_frame = "0"b;
     1119                     if pcb.flags.send_output                /* more output to ship */
     1120                     then if pcb.write_first ^= 0            /* it's waiting in tty_buf */
     1121                          then call make_q_entry (accept_direct_output, 0, ""b);
     1122                                                             /* we'll get to it shortly */
     1123                          else call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);
     1124                end;
     1125 
     1126           end /* check_ff */;
     1127 
     1128      end /* process_rtx */;
     1129 
     1130 /* internal proc to check if this channel can have input space */
     1131 
     1132 enough_input_space:
     1133      proc (count) returns (bit (1));
     1134 
     1135 dcl  count fixed bin;
     1136 
     1137           lctp = tty_buf.lct_ptr;
     1138           chan_lctep = addr (lct.lcte_array (devx));
     1139           return (chan_lctep -> lcte.input_words + count <= divide (tty_buf.bleft, input_bpart, 17, 0));
     1140      end /* enough_input_space */;
     1141 
     1142 
     1143 /* internal proc to put an element onto delay queue */
     1144 
     1145 make_q_entry:
     1146      proc (opc, cnt, databits);
     1147 
     1148 dcl  (opc, cnt) fixed bin (8),                              /* parameters */
     1149      databits bit (8 * 36);
     1150 
     1151           call tty_space_man$get_space (size (q_entry), new_qp);
     1152           if new_qp = null
     1153           then do;
     1154                call syserr (crash_system, "dn355: unable to allocate block for delay queue");
     1155                return;
     1156           end;
     1157 
     1158           new_qrel = bin (rel (new_qp));
     1159           if fnp_info.cur_ptr = 0                           /* nothing in the queue yet */
     1160           then fnp_info.cur_ptr = new_qrel;
     1161           else do;
     1162                qptr = ptr (ttybp, fnp_info.last_ptr);
     1163                q_entry.next = new_qrel;                     /* make the preceding entry point to the new one */
     1164           end;
     1165 
     1166           fnp_info.last_ptr = new_qrel;
     1167           qptr = new_qp;
     1168           fnp_info.count = fnp_info.count + 1;
     1169           fnp_info.q_entries_made = fnp_info.q_entries_made + 1;
     1170 
     1171           q_entry.opcode = opc;                             /* set q element op code */
     1172           q_entry.cmd_count = cnt;                          /* and command count */
     1173           if pcbp ^= null ()
     1174           then q_entry.pcb_offset = rel (pcbp);
     1175           else q_entry.pcb_offset = "0"b;
     1176           q_entry.next = 0;
     1177           q_entry.cmd_data = databits;                      /* move data to q element */
     1178           return;                                           /* return to caller */
     1179      end;
     1180 
     1181 /* internal procedure to derive devx & PCB pointer from mailbox line number */
     1182 
     1183 get_line_number:
     1184      proc;
     1185 
     1186 dcl  x fixed bin;
     1187 
     1188           if string (sub_mbx.line_number) = "0"b
     1189           then do;                                          /* some type of global request */
     1190                do x = 1 to hbound (global_opcodes, 1) while (sub_mbx.op_code ^= global_opcodes (x));
     1191                end;                                         /* make sure it really is */
     1192                if x > hbound (global_opcodes, 1)
     1193                then do;                                     /* else can the FNP */
     1194                     call syserr (beeper, "dn355: line number of 0 with non-global opcode in submbx ^o, FNP ^a", i,
     1195                          fnp_info.fnp_tag);
     1196                     call report_fnp_crash;
     1197                     go to global_exit;
     1198                end;
     1199 
     1200                pcbp = null;
     1201                devx = -1;
     1202           end;
     1203 
     1204           else do;
     1205                n_pcbs = fnp_info.no_of_channels;
     1206                if string (sub_mbx.line_number) = TANDD_LINE_NUMBER
     1207                                                             /* don't decode this, go straight to it */
     1208                then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (fnp_info.tandd_pcbx));
     1209                else do;
     1210                     lano = sub_mbx.line_number.la_no;       /* get line adapter number for devx lookup */
     1211                     if sub_mbx.is_hsla
     1212                     then j = fnp_info.hsla_idx (fixed (lano));
     1213                     else j = fnp_info.lsla_idx (fixed (lano));
     1214                                                             /* get starting position */
     1215                     do j = j to n_pcbs;                     /* loop thru devx table */
     1216                          pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
     1217                          if string (pcb.line_number) = string (sub_mbx.line_number)
     1218                          then go to match;                  /* check for right slot */
     1219                     end;
     1220                     call syserr (beeper, "dn355: no slot number match for sub mbx ^o, FNP ^a", i, fnp_info.fnp_tag);
     1221                                                             /* bitch */
     1222                     call report_fnp_crash;
     1223                     go to global_exit;
     1224                end;
     1225 
     1226 match:
     1227                devx = pcb.devx;                             /* copy devx to automatic */
     1228 
     1229           end;
     1230           return;
     1231 
     1232      end /* get_line_number */;
     1233 
     1234 
     1235 /* internal procedure to ship sub mbx off to 355 */
     1236 send_mbx:
     1237 return_mbx:
     1238      proc (a_mbx_no);
     1239 
     1240 dcl  a_mbx_no fixed bin;
     1241 dcl  mbx_no fixed bin;
     1242 dcl  pcw_error bit (1);
     1243 dcl  timeout_time fixed bin (71);
     1244 dcl  1 ima aligned like io_manager_arg;
     1245 
     1246           mbx_no = a_mbx_no;
     1247           go to test_pcw;
     1248 
     1249 free_mbx:
     1250      entry (a_mbx_no);                                      /* this for those which haven't been rewritten */
     1251 
     1252           mbx_no = a_mbx_no + 4;                            /* use different interrupt level for freeing */
     1253 
     1254 test_pcw:
     1255           if ^fnp_info.io_manager_assigned
     1256           then do;
     1257                no_response = "1"b;                          /* lie, but effectively */
     1258                return;
     1259           end;
     1260 
     1261           no_response = "0"b;
     1262           if datanet_mbx.dia_pcw.command ^= "0"b
     1263           then do;                                          /* first a quick check to save time */
     1264 wait_for_response:
     1265                timeout_time = clock () + TWO_SECONDS;
     1266                do while ((clock () < timeout_time) & (datanet_mbx.dia_pcw.command ^= "0"b));
     1267                                                             /* loop until dia picks up last command */
     1268                end;
     1269                if datanet_mbx.dia_pcw.error | datanet_mbx.dia_pcw.command ^= "0"b
     1270                then do;
     1271                     if ^no_response
     1272                     then do;
     1273                          pcw_error = datanet_mbx.dia_pcw.error;
     1274                          no_response = "1"b;
     1275                          datanet_mbx.dia_pcw.error = "0"b;
     1276                          string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));
     1277                                                             /* recompute parity */
     1278                          ima.chx = fnp_info.io_manager_chx;
     1279                          ima.ptp = fnp_info.ptp;
     1280                          call io_manager$connect_direct (ima);
     1281                                                             /* re-kick FNP */
     1282                          call syserr (just_tell,
     1283                               "dn355: ^[Error^;Timeout^] sending mailbox interrupt to FNP ^a, will retry.", pcw_error,
     1284                               fnp_info.fnp_tag);
     1285                          goto wait_for_response;
     1286                     end;
     1287                end;
     1288                else goto send_new_connect;
     1289           end;
     1290           else do;
     1291 send_new_connect:
     1292                no_response = "0"b;
     1293 
     1294                if mbx_no < 8                                /* one of ours */
     1295                then do;
     1296                     datanet_mbx.mbx_used_flags.used (mbx_no) = "1"b;
     1297                     datanet_mbx.num_in_use = datanet_mbx.num_in_use + 1;
     1298                     fnp_info.max_mbx_in_use = max (fnp_info.max_mbx_in_use, datanet_mbx.num_in_use);
     1299                     fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;
     1300                     fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;
     1301                end;                                         /* set used flag */
     1302                string (datanet_mbx.dia_pcw) = initial_pcw;  /* initialize pcw */
     1303                datanet_mbx.dia_pcw.mbx_no = bit (fixed (mbx_no, 6), 6);
     1304                                                             /* set sub mbx number */
     1305 
     1306                string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));
     1307                                                             /* set the parity bit; bit 22 */
     1308 
     1309                ima.chx = fnp_info.io_manager_chx;
     1310                ima.ptp = fnp_info.ptp;
     1311                call io_manager$connect_direct (ima);        /* kick 355 */
     1312 
     1313                return;                                      /* return to caller */
     1314           end;
     1315      end send_mbx;
     1316 
     1317 /* entry and internal proc to hangup all lines on an FNP */
     1318 
     1319 hangup_fnp_lines:
     1320      entry (a_fnp_no);
     1321 
     1322 dcl  a_fnp_no fixed bin;
     1323 
     1324           ttybp = addr (tty_buf$);
     1325           infop = addr (dn355_data$);
     1326           call hangup_fnp (a_fnp_no);
     1327           return;
     1328 
     1329 
     1330 hangup_fnp:
     1331      proc (fnp_no);
     1332 
     1333 dcl  fnp_no fixed bin;
     1334 
     1335           fnpp = addr (datanet_info.per_datanet (fnp_no));
     1336           n_pcbs = fnp_info.no_of_channels;
     1337           do j = 1 to n_pcbs;
     1338                pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
     1339                if pcb.dialed
     1340                then do;
     1341                     call throw_away_output;
     1342                     call channel_manager$interrupt ((pcb.devx), CRASH, ""b);
     1343                end;
     1344           end;
     1345 
     1346           if fnp_info.count > 0                             /* get rid of any outstanding delay queue entries */
     1347           then do;
     1348                q_count = fnp_info.count;
     1349                q_first = fnp_info.cur_ptr;
     1350                do q_count = q_count to 0 by -1 while (q_first ^= 0);
     1351                     qptr = ptr (ttybp, q_first);            /* get real pointer to queue entry */
     1352                     q_first = qptr -> q_entry.next;         /* save pointer to next one */
     1353                     call tty_space_man$free_space (size (q_entry), qptr);
     1354                end;
     1355 
     1356                fnp_info.count, fnp_info.cur_ptr, fnp_info.last_ptr = 0;
     1357           end;
     1358 
     1359      end;
     1360 
     1361 
     1362 
     1363 throw_away_output:
     1364      proc;
     1365 
     1366 /* throws away pending write chain on quit and hangup */
     1367 
     1368           if pcb.write_first ^= 0
     1369           then do;
     1370                call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
     1371                pcb.write_first, pcb.write_last, pcb.write_cnt = 0;
     1372 
     1373           end;
     1374 
     1375           pcb.end_frame = "0"b;
     1376 
     1377           return;
     1378      end /* throw_away_output */;
     1379 
     1380 /* internal procedure to report that DIA never set PCW to 0 */
     1381 
     1382 report_fnp_no_response:
     1383      proc;
     1384 
     1385           call syserr (beeper, "dn355: FNP ^a did not respond to mailbox interrupt", fnp_info.fnp_tag);
     1386           call report_fnp_crash;                            /* treat it like a crash */
     1387           return;
     1388 
     1389      end /* report_fnp_no_response */;
     1390 
     1391 
     1392 /* internal procedure to tell initializer and clean up when FNP crashes */
     1393 
     1394 report_fnp_crash:
     1395      proc;
     1396 
     1397           fnp_info.running = "0"b;                          /* it isn't any more */
     1398           if fnp_info.dump_patch_in_progress                /* somebody's waiting for this */
     1399           then call pxss$notify (FNP_DUMP_PATCH_EVENT);     /* don't let them wait forever */
     1400 
     1401           if ^fnp_info.bootloading                          /* if we weren't still loading it */
     1402           then                                              /* now report hangups for all lines that were dialed to it */
     1403                call hangup_fnp (dno);
     1404           else fnp_info.bootloading = "0"b;
     1405 
     1406           auto_fnp_msg.state = FNP_DOWN;                    /* tell the responsible process */
     1407           auto_fnp_msg.fnp_no = dno;
     1408           auto_fnp_msg.flags = "0"b;
     1409           unspec (fnp_event_message) = unspec (auto_fnp_msg);
     1410           call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, fnp_event_message, 0);
     1411 
     1412           return;
     1413 
     1414      end report_fnp_crash;
     1415 check_lock:
     1416      proc;
     1417 
     1418 /* the cleanup procedure -- makes sure we don't crawl out with lock set */
     1419 
     1420           if queue_locked
     1421           then call syserr (crash_system, "dn355: attempted crawlout with FNP queue locked");
     1422 
     1423           else if masked
     1424           then call pmut$unwire_unmask (wire_arg, wire_ptr);/* it's probably too late, but just in case */
     1425 
     1426           return;
     1427      end check_lock;
     1428 
     1429 /* Main program declarations */
     1430 
     1431 dcl  (dcwlptr, bufp, qptr) ptr,                             /* random pointers used */
     1432      timw fixed bin (24),                                   /* local slot for mailbox timw */
     1433      (level, dno, i, ix, q_first, q_count, chars_left, numchars, k, j, chain_len) fixed bin,
     1434                                                             /* random halfwords used */
     1435      devx fixed bin,                                        /* index of current channel */
     1436      operation fixed bin (8),                               /* local slot for delay queue operation */
     1437      lano bit (3) unal;                                     /* local slot for line number */
     1438 dcl  fnp_name char (1) aligned;                             /* for syserr calls */
     1439 
     1440 dcl  no_response bit (1) aligned;                           /* set by send_mbx to indicate that DIA didn't respond */
     1441 
     1442 dcl  interrupt_entry bit (1);                               /* whether entered through dn355$interrupt */
     1443 
     1444 dcl  input_count fixed bin;                                 /* count sent with accept_dir_input */
     1445 
     1446 dcl  chan_lctep ptr;                                        /* pointer to subchannel's LCTE */
     1447 dcl  chain_head_ptr ptr;                                    /* pointer to output chain to be freed */
     1448 dcl  output_limit fixed bin;                                /* maximum number of output chars to be sent at once */
     1449 dcl  output_chars fixed bin;                                /* number of output chars sent so far */
     1450 
     1451 dcl  bits_per_char fixed bin;
     1452 dcl  max_buf_chars fixed bin;                               /* number of characters to go in largest buffer at this speed */
     1453 
     1454 dcl  wire_arg fixed bin (71);
     1455 dcl  wire_ptr ptr;
     1456 dcl  masked bit (1);
     1457 dcl  queue_locked bit (1);
     1458 dcl  continue bit (1);                                      /* for premature termination of loops */
     1459 
     1460 dcl  offset fixed bin;                                      /* offset of error message in dn355_messages */
     1461 dcl  syserr_severity fixed bin (35);
     1462 
     1463 /* Codes used for syserr are declared here because syserr_constants.incl.pl1 cannot
     1464*   be used, owing to a naming conflict with mcs_interrupt_info.incl.pl1.
     1465**/
     1466 
     1467 dcl  (
     1468      dataoff init (1),                                      /* offset in buffer of data */
     1469      max_chain_len init (16),                               /* maximum dcw chain length */
     1470      just_tell init (0),                                    /* syserr message, no alarm */
     1471      beeper init (3),                                       /* syserr ring beeper */
     1472      log init (4),
     1473      crash_system init (1)
     1474      ) fixed bin int static options (constant);             /* argument to syserr */
     1475 
     1476 dcl  FNP_DOWN fixed bin int static options (constant) init (2);
     1477 
     1478 dcl  initial_pcw bit (36) int static init ("000000000000000000000000000000111001"b);
     1479                                                             /* initial dia pcw */
     1480 dcl  TANDD_LINE_NUMBER bit (10) int static options (constant) init ((10)"1"b);
     1481                                                             /* i.e., 1777 octal */
     1482 dcl  TWO_SECONDS fixed bin (71) int static options (constant) init (2000000);
     1483                                                             /* used to wait for DIA to clear PCW */
     1484 
     1485 dcl  timwb (0:11) bit (1) based (addr (timw)),              /* timw as a bit array */
     1486      used_string bit (8) based (addr (datanet_mbx.mbx_used_flags.used (0)));
     1487                                                             /* mailbox used flags as a bit string */
     1488 
     1489 dcl  (addr, binary, substr, stac, stacq, string, ptr, rel, index, fixed, divide, bin, max, min, null, length, bit, unspec,
     1490      hbound, size, verify, clock) builtin;                  /* builtin functions used */
     1491 
     1492 dcl  unal_number fixed bin (17) unal based,                 /* handy way of referencing an unaligned number */
     1493      chars char (numchars) based;                           /* handy way of moving character strings */
     1494 
     1495 dcl  input_chars char (chars_left) based;                   /* for scanning entire input */
     1496 
     1497 dcl  smbx_cmd_data_long bit (216) unaligned based (addr (sub_mbx.command_data));
     1498 
     1499 dcl  tc_data$system_shutdown ext fixed bin;                 /* external variables used */
     1500 dcl  tc_data$fnp_buffer_threshold ext static fixed bin;
     1501 dcl  pds$processid bit (36) aligned ext static;
     1502 
     1503 dcl  ff_cr_lf char (3) int static options (constant) init ("
     1504 ");
     1505 
     1506 dcl  form_feed init ("") char (1) int static options (constant);
     1507 
     1508 dcl  syserr entry options (variable),                       /* external entries called */
     1509      ldac entry (ptr) returns (fixed bin (24)),
     1510      dn355_util$compute_parity entry (bit (36)) returns (bit (36)),
     1511      (
     1512      dn355_boot_interrupt,
     1513      dn355_boot_interrupt$system_fault
     1514      ) entry (fixed bin),
     1515      pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     1516      pxss$unique_ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35)),
     1517      pxss$notify entry (fixed bin);
     1518 
     1519 dcl  pmut$wire_and_mask entry (fixed bin (71), ptr);
     1520 dcl  pmut$unwire_unmask entry (fixed bin (71), ptr);
     1521 dcl  1 auto_net_event_message aligned like net_event_message;
     1522 dcl  1 auto_fnp_msg aligned like fnp_msg;
     1523 dcl  fnp_event_message fixed bin (71);
     1524 
     1525 dcl  1 dcw_list (max_chain_len) aligned based (dcwlptr),    /* dcw list for output */
     1526        2 dcw_ptr bit (18) unal,                             /* pointer to buffer */
     1527        2 pad bit (9) unal,                                  /* unused */
     1528        2 dcw_tally bit (9) unal;                            /* tally */
     1529 
     1530 dcl  1 dcw_list_array (0:7) aligned based,
     1531        2 dcw_list_template (max_chain_len) like dcw_list;
     1532 
     1533 dcl  1 q_entry aligned like fnp_queue_entry based (qptr);
     1534 
     1535 dcl  new_qp ptr;                                            /* temporary to newly-allocated block */
     1536 dcl  new_qrel fixed bin;
     1537 
     1538 dcl  1 dn355_word unal based (addr (datanet_mbx.fault_word)),
     1539                                                             /* format of 355 crash word */
     1540        2 modnum bit (4),                                    /* module number (1 - 8) */
     1541        2 opcode fixed bin (4),
     1542        2 crash_code fixed bin (8);                          /* used to index list of messages */
     1543 
     1544 dcl  fault_type fixed bin;                                  /* 355 fault code */
     1545 dcl  fault_name char (16);                                  /* 355 fault name */
     1546 dcl  module_num fixed bin;                                  /* 355 module number */
     1547 
     1548 dcl  iom_channel_fault fixed bin int static init (9);
     1549 dcl  illegal_opcode fixed bin int static init (3);
     1550 dcl  die_code fixed bin int static init (9);
     1551 
     1552 dcl  1 error_msg aligned based (addr (sub_mbx.command_data (1))),
     1553                                                             /* error message data */
     1554        2 data (4) bit (18) unal;
     1555 
     1556 dcl  full_words (3) fixed bin;
     1557 
     1558 dcl  reason_msg char (64);
     1559 
     1560 dcl  cleanup condition;
     1561 
  1     1 /* BEGIN INCLUDE FILE ... baud_rates.incl.pl1 */
  1     2 
  1     3 /* Defines valid baud rate values for communications channels */
  1     4 
  1     5 /* Created by somebody a long time ago */
  1     6 /* Modified April 1982 by Robert Coren to add speeds above 9600 (up to 72000) */
  1     7 
  1     8 dcl  baud_table (15) fixed bin int static options (constant) init
  1     9      (110, 133, 150, 300, 600, 1200, 1800, 2400, 4800, 7200,
  1    10       9600, 19200, 40800, 50000, 72000);
  1    11 
  1    12 /* END INCLUDE FILE ... baud_rates.incl.pl1 */
     1562 
     1563 
  2     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  2     2 
  2     3 /* Created 8/25/78 by J. Stern */
  2     4 
  2     5 
  2     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  2     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  2     8 
  2     9 /* call channel_manager$write (devx, output_ptr, code) */
  2    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  2    11 
  2    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  2    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  2    14 
  2    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  2    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  2    17 
  2    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  2    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  2    20 
  2    21 /* call channel_manager$get_modes (devx, modes, code) */
  2    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  2    23 
  2    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  2    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  2    26 
  2    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  2    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  2    29 
  2    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  2    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  2    32 
  2    33 
  2    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
     1564 
     1565 
  3     1 /*  BEGIN dn355_data.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  3     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  3     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  3     9*     implementation.
  3    10*  2) change(89-03-20,Parisek), approve(89-06-06,MCR8110),
  3    11*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
  3    12*     Add support of protocol mpx.
  3    13*                                                   END HISTORY COMMENTS */
  3    14 
  3    15 
  3    16 /* Date Last Modified and Reason
  3    17*
  3    18*   Created 07/25/74 by R. B. Snyder for new ttydim.
  3    19*   Modified 06/23/77 by J. Stern to add channel_work_reqd and cwork_count
  3    20*   Modified 08/14/78 by Robert Coren to remove devx_tab and invent PCBs
  3    21*   Modified 79 May 14 by Art Beattie to add fnp_mem_size
  3    22*   Modified December 1979 by Robert Coren to add FNP queue lock
  3    23*   Modified January 1980 by Larry Johnson to increase max number of FNPs to 8
  3    24*   Modified 02/12/80 by Robert Coren to add dcw_list_array_ptr
  3    25*   Modified 03/06/80 by Robert Coren to add some metering info
  3    26*   Modified 12/10/80 by Robert Coren to add get_meters_waiting flag
  3    27*   Modified 83-12-16 BIM to use a chanid instead of iom/channel fb's.
  3    28*   Modified 1984-07-26 BIM for paged iom.
  3    29*   Modified in September 1985 for the DN7100 version interim.
  3    30**/
  3    31 
  3    32 /* LOCKING RULES: A fnp is locked by its LCTE unless its LCTE is uninitialized.
  3    33*   In that case, the configuration_lock must be held.
  3    34*   if tty_lock$lock_lcte returns io_no_permission, then the caller must
  3    35*   lock$lock_fast the configuration lock and retry the LCTE lock. If
  3    36*   the lcte is now initialized, too bad. Otherwise, the config lock protects.
  3    37*
  3    38*   Configuration locking is interesting to init_multiplexer and
  3    39*   all of fnp t&d and reconfiguration. The guts of the multiplexer
  3    40*   pay no attention to it. Thus, if the LCTE can be locked, it MUST be
  3    41*   locked before changing the io_manager_assigned flag. */
  3    42 
  3    43 /* format: style4,delnl,insnl,^ifthendo */
  3    44 
  3    45 dcl  max_no_355s fixed bin int static init (8) options (constant);
  3    46                                                             /* max no of 355s we can handle (arbitrary) */
  3    47 dcl  dn355_data$ external fixed bin;
  3    48 
  3    49 dcl  infop pointer;
  3    50 dcl  fnpp ptr;
  3    51 
  3    52 dcl  1 datanet_info aligned based (infop),
  3    53        2 configuration_lock aligned,
  3    54          3 pid bit (36) aligned,
  3    55          3 event bit (36) aligned,
  3    56          3 flags aligned,
  3    57            4 notify_sw bit (1) unaligned,
  3    58            4 pad bit (35) aligned,
  3    59        2 no_of_355s fixed bin,                              /* no. of FNP's */
  3    60        2 trace bit (1) aligned,                             /* watch events on console */
  3    61        2 debug_stop bit (1) aligned,                        /* crash on errors */
  3    62        2 uncp_bufp ptr,                                     /* pointer to the circular buffer */
  3    63        2 protocol_datap ptr,                                /* pointer to protocol_mpx data */
  3    64        2 pad1 (6) bit (36) aligned,
  3    65        2 per_datanet (max_no_355s) aligned like fnp_info;   /* data per datanet */
  3    66 
  3    67 dcl  1 fnp_info aligned based (fnpp),                       /* structure for each FNP */
  3    68        2 mbx_pt pointer,                                    /* pointer to mailbox NULL if not in config */
  3    69        2 pcb_array_ptr pointer,                             /* pointer to array of physical channel blocks */
  3    70        2 dcw_list_array_ptr pointer,                        /* pointer to array of space reserved for output DCW lists */
  3    71        2 no_of_channels fixed bin,                          /* number of channels on this FNP */
  3    72        2 fnp_id,
  3    73          3 fnp_tag char (1) unaligned,                      /* letter identifying FNP */
  3    74          3 fnp_number fixed bin (9) unsigned unaligned,     /* sequence number of FNP */
  3    75          3 padc bit (18) unaligned,
  3    76        2 io_chanid char (8) aligned,
  3    77        2 io_manager_chx fixed bin (35),                     /* devx for DIA on iom */
  3    78        2 lsla_idx (0:5) fixed bin aligned,                  /* index into PCB array for lsla lines */
  3    79        2 hsla_idx (0:2) fixed bin aligned,                  /* index into PCB array for hsla lines */
  3    80        2 count fixed bin,                                   /* number of items in delay queue */
  3    81        2 cur_ptr fixed bin,                                 /* offset in tty_buf of next delay queue element */
  3    82        2 last_ptr fixed bin,                                /* offset in tty_buf of last delay queue element */
  3    83        2 bleft_355 fixed bin,                               /* number of free buffers in this 355 */
  3    84        2 flags,
  3    85          3 work_reqd bit (1) unaligned,                     /* mailbox messages queued up */
  3    86          3 bootloading bit (1) unaligned,                   /* currently being bootloaded */
  3    87          3 running bit (1) unaligned,                       /* this FNP is running */
  3    88          3 wired bit (1) unaligned,                         /* bootload buffer is wired */
  3    89          3 dump_patch_in_progress bit (1) unaligned,        /* a dump or patch order is in progress */
  3    90          3 level_3_pending bit (1) unaligned,               /* level 3 interrupt pending */
  3    91          3 level_7_pending bit (1) unaligned,               /* level 7 interrupt pending */
  3    92          3 dump_patch_disabled bit (1) unaligned,           /* dump & patch orders disabled because of timeout */
  3    93          3 t_and_d_in_progress bit (1) unaligned,           /* T & D using FNP */
  3    94          3 t_and_d_lev_3_occurred bit (1) unaligned,        /* A level 3 occurred */
  3    95          3 t_and_d_lev_7_occurred bit (1) unaligned,
  3    96          3 t_and_d_notify_requested bit (1) unaligned,
  3    97          3 t_and_d_assigned bit (1) unaligned,              /* AS has given fnp to process */
  3    98          3 get_meters_waiting bit (1) unaligned,            /* waiting for meter copy to complete */
  3    99          3 padb bit (7) unaligned,
  3   100          3 active_dial unaligned,
  3   101             4 active_bit (15) bit (1) unaligned,            /* ON if the process is active */
  3   102        2 lcte_ptr ptr,                                      /* pointer to this FNP's LCT entry */
  3   103        2 astep ptr,                                         /* pointer to aste of wired bootload buffer */
  3   104        2 boot_ev_chan fixed bin (71),                       /* event channel over which to signal bootload completion */
  3   105        2 boot_process_id bit (36),                          /* process that initiated bootload */
  3   106        2 version char (4),                                  /* version id of core image */
  3   107        2 fnp_mem_size fixed bin (18) unsigned,              /* memory size of this FNP in 18-bit words */
  3   108        2 queue_lock bit (36) aligned,                       /* lock for interrupt queue */
  3   109        2 dump_patch_lock bit (36),                          /* lock for fnp_dump or _patch operation */
  3   110        2 q_entries_made fixed bin (35),                     /* count of delay queue entries made */
  3   111        2 input_reject_count fixed bin,                      /* number of times input rejected */
  3   112        2 processed_from_q fixed bin (35),                   /* number of interrupts processed from queue */
  3   113        2 fnp_channel_locked fixed bin (35),                 /* number of times dn355 found per-FNP lock locked */
  3   114        2 input_data_transactions fixed bin (35),            /* number of mailbox transactions for input */
  3   115        2 output_data_transactions fixed bin (35),           /* number of mailbox transactions for output */
  3   116        2 input_control_transactions fixed bin (35),         /* number of mailbox transactions for inbound control info */
  3   117        2 output_control_transactions fixed bin (35),        /* number of mailbox transactions for outbound control info */
  3   118        2 cumulative_mbx_in_use fixed bin (35),              /* cumulative count of number of outbound mailboxes in use */
  3   119        2 max_mbx_in_use fixed bin,                          /* maximum number of mailboxes in use at any given time */
  3   120        2 mbx_in_use_updated fixed bin (35),                 /* number of increments to cumulative_mbx_in_use */
  3   121        2 mbx_unavailable fixed bin (35),                    /* number of times had to queue mailbox transaction because none a
vailable */
  3   122        2 free_size fixed bin (35),                          /* cumulative amount of bleft_355 */
  3   123        2 free_count fixed bin,                              /* number of adds to above */
  3   124        2 fnp_space_restricted_output fixed bin (35),        /* number of times available FNP space restricted amount of output
 sent */
  3   125        2 tandd_pcbx fixed bin,                              /* index of PCB for COLTS channel */
  3   126        2 n_pages_wired fixed bin,                           /* pages wired for loading */
  3   127        2 config_flags aligned,
  3   128          3 available bit (1) unaligned,                     /* reconfig says "yes" */
  3   129          3 io_manager_assigned bit (1) unaligned,           /* We have channel assigned to us */
  3   130          3 pad bit (34) unaligned,
  3   131        2 uncp_pcbx1 fixed bin (17) unaligned,               /* For the DN7100 */
  3   132        2 uncp_pcbx2 fixed bin (17) unaligned,               /* For the DN7100 */  
  3   133        2 ptx fixed bin,                                     /* page table index, used only at bootload */
  3   134        2 ptp pointer unaligned;                             /* page table for this FNP */
  3   135 
  3   136 /**** The following named constants are used to lay out the
  3   137*      iom page tables. Each FNP has to have its own page
  3   138*      table because there is not enough room to have eight different
  3   139*      bootload images of 32 K and > 64 K of tty_buf 
  3   140*
  3   141*      THE MAX TTY BUF LENGTH IS 192 K words. We could have another 16 K
  3   142*      easily, and then after that it would get hard. */ 
  3   143 
  3   144 /**** The layout
  3   145*
  3   146*      Page   I/O address   Memory address     Comments
  3   147*      ----      ------     --------------     --------
  3   148*      0              0       xxxxxx           invalid PTW
  3   149*      1           2000         2000           write-enabled (mailbox)
  3   150*      2           4000         4000           write-enabled (mailbox)
  3   151*      3           6000         6000           write-enabled (mailbox)
  3   152*      4          10000       as needed        bootload image segment page 0
  3   153*      ....        ....         ....           ....
  3   154*      35        110000       as needed        bootload image segment page 31
  3   155*      36        112000       xxxxxx           invalid PTW
  3   156*      ...         ....         ....           ....
  3   157*      63        160000         ....           invalid PTW
  3   158*      64        200000       as needed        tty_buf page 0
  3   159*      ...         ....         ....           ....
  3   160*      127       260000       as needed        tty_buf page 63
  3   161*      255       ......        .....           tty_buf page 191
  3   162**/
  3   163 
  3   164 /**** We assume that the page table starts at all zeros. */
  3   165 
  3   166 declare  FIRST_BOOTLOAD_PAGEX fixed bin init (4) int static options (constant);
  3   167 declare  FIRST_TTY_BUF_PAGEX fixed bin init (64) int static options (constant);
  3   168 
  3   169 /* End include file dn355_data.incl.pl1 */
     1566 
     1567 
  4     1 /*                            BEGIN dn355_mailbox.incl.pl1                      */
  4     2 
  4     3 /* Date Last Modified and Reason
  4     4*   Created 07/25/74 by R. B. Snyder for new ttydim.
  4     5*   Modified 08/20/75 by Mike Grady to prepare for multiple 355's
  4     6*   Modified 11/08/78 by Robert Coren to introduce FNP-controlled mailboxes
  4     7*   Modified 02/19/80 by Robert Coren to specify format of accept_input mailbox
  4     8*   Modified 04/23/80 by Robert Coren to replace lock with num_in_use
  4     9*   Modified 09/21/82 by Robert Coren to make subfields of crash_data be fixed bin (18) unsigned
  4    10*   */
  4    11 
  4    12 dcl 1 datanet_mbx aligned based (mbxp),                     /* declaration of 355 mailbox */
  4    13     2 dia_pcw aligned,                                      /* Peripheral Control Word for DIA */
  4    14       3 zero bit (18) unaligned,
  4    15       3 error bit (1) unaligned,                            /* set to "1"b if error on connect */
  4    16       3 pad1 bit (5) unaligned,
  4    17       3 mbx_no bit (6) unaligned,                           /* number of submbx being sent to 355 */
  4    18       3 command bit (6) unaligned,                          /* always 71 (octal) */
  4    19     2 mailbox_requests fixed bin,                           /* 0 mod 256K cnt of mbx requests by 355 */
  4    20     2 term_inpt_mpx_wd bit (36) aligned,                    /* terminate interrupt multiplex word */
  4    21     2 last_mbx_req_count fixed bin,                         /* previous value of mailbox_requests */
  4    22     2 num_in_use fixed bin,                                 /* number of submailboxes currently in use */
  4    23     2 mbx_used_flags,                                       /* one bit for each mailbox */
  4    24       3 used (0:7) bit (1) unaligned,                       /* "1"b means this mbx is being used */
  4    25       3 pad2 bit (28) unaligned,
  4    26     2 crash_data,                                           /* data for 355 emergency interrupt */
  4    27       3 fault_code fixed bin (18) unal unsigned,
  4    28       3 ic fixed bin (18) unal unsigned,
  4    29       3 iom_fault_status fixed bin (18) unal unsigned,
  4    30       3 fault_word fixed bin (18) unal unsigned,            /* contains either faulting instruction or iomchannel no */
  4    31     2 dn355_sub_mbxes (0:7) aligned,                        /* 8 CS-initiated submailboxes */
  4    32       3 pad4 (8) fixed bin,                                 /* eight words each */
  4    33     2 fnp_sub_mbxes (0:3) aligned,                          /* 4 FNP-initiated mailboxes */
  4    34       3 pad5 (28) fixed bin;                                /* 28 words each */
  4    35 
  4    36 dcl 1 sub_mbx aligned based (subp),                         /* declaration of a submailbox */
  4    37     2 dn355_no bit (3) unaligned,                           /* 355 number */
  4    38     2 pad1 bit (5) unaligned,
  4    39     2 line_number unaligned,                                /* line number assigned by 355 */
  4    40       3 is_hsla bit (1) unaligned,                          /* on if hsla, off if lsla */
  4    41       3 la_no bit (3) unaligned,                            /* line adapter (high or low speed) number */
  4    42       3 slot_no bit (6) unaligned,                          /* physical slot/subchannel number */
  4    43     2 terminal_id bit (18) unaligned,                       /* not used */
  4    44 
  4    45     2 terminal_type bit (9) unaligned,                      /* unused */
  4    46     2 cmd_data_len fixed bin (8) unaligned,                 /* no. of 6 bit chars in command data */
  4    47     2 op_code fixed bin (8) unaligned,                      /* op code */
  4    48     2 io_cmd fixed bin (8) unaligned,                       /* i/o cmd */
  4    49 
  4    50     2 command_data (3) bit (36) unaligned,                  /* data associated with op code */
  4    51 
  4    52     2 address unal,                                         /* dcw buffer or circular queue address */
  4    53       3 data_addr bit (18) unaligned,                       /* data address */
  4    54       3 word_cnt fixed bin (18) unsigned unaligned,         /* data length */
  4    55     2 pad3 bit (72) unaligned;
  4    56 
  4    57 /* The structure below defines the long form of submailbox used by the FNP. Note that
  4    58*   the declaration of command_data and input_data is that used for the input_in_mailbox
  4    59*   operation; other FNP-initiated operations use the command_data format described by
  4    60*   the above (short mailbox) structure
  4    61**/
  4    62 
  4    63 dcl 1 fnp_sub_mbx aligned based (subp),                     /* format used for FNP-controlled mailbox */
  4    64     2 dn355_no bit (3) unaligned,                           /* as above */
  4    65     2 pad1 bit (5) unaligned,
  4    66     2 line_number unaligned,                                /* as above */
  4    67       3 is_hsla bit (1) unaligned,
  4    68       3 la_no bit (3) unaligned,
  4    69       3 slot_no bit (6) unaligned,
  4    70     2 n_free_buffers fixed bin (17) unaligned,              /* number of free blocks in FNP at present */
  4    71 
  4    72     2 pad3 bit (9) unaligned,
  4    73     2 n_chars fixed bin (9) unsigned unaligned,             /* number of data characters (if input) */
  4    74     2 op_code fixed bin (9) unsigned unaligned,             /* as above */
  4    75     2 io_cmd fixed bin (9) unsigned unaligned,              /* as above */
  4    76 
  4    77     2 input_data char (100) unaligned,                      /* input characters for input_in_mailbox op */
  4    78     2 command_data bit (36) unaligned;                      /* shouldn't need more than one word */
  4    79 
  4    80 /* The structure below defines the format of a long submailbox used for an accept_input operation
  4    81*   when the data is too long to fit directly in the mailbox. command_data and n_chars occupy the same position as for input_in
_mailbox, above.
  4    82**/
  4    83 
  4    84 dcl 1 input_sub_mbx aligned based (subp),
  4    85     2 pad1 bit (8) unaligned,
  4    86     2 line_number unaligned like sub_mbx.line_number,
  4    87     2 n_free_buffers fixed bin (17) unaligned,              /* number of free blocks in FNP at present */
  4    88 
  4    89     2 n_chars fixed bin (17) unaligned,                     /* total number of data characters */
  4    90     2 op_code fixed bin (9) unsigned unaligned,
  4    91     2 io_cmd fixed bin (9) unsigned unaligned,
  4    92 
  4    93     2 n_buffers fixed bin,                                  /* number of buffers in this input chain */
  4    94     2 dcw (24),                                             /* "pseudo-DCWs"  used to specify buffer addresses and tallies */
  4    95       3 abs_addr bit (24) unaligned,                        /* supplied by CS */
  4    96       3 tally fixed bin (12) unsigned unaligned,            /* in characters, supplied by FNP */
  4    97     2 command_data bit (36) unaligned;                      /* as above */
  4    98 
  4    99 dcl  subp pointer;
  4   100 dcl  mbxp pointer;
  4   101 
  4   102 /*                            END dn355_mailbox.incl.pl1                        */
     1568 
     1569 
  5     1           /* BEGIN INCLUDE FILE ... dn355_messages.incl.pl1 */
  5     2 
  5     3           /* created 1/31/75 by Robert S. Coren
  5     4*          *  modified 5/19/76 by Robert S. Coren to add bootload messages
  5     5*          *  Modified 1979 June 8 by Art Beattie to add messages to config_messages.
  5     6*          */
  5     7 
  5     8           /* This include file describes the data segment used in interpreting
  5     9*          *  the info returned with an emergency interrupt from the 355,
  5    10*          *  as well as error message mailboxes and bootload interrupts
  5    11*          */
  5    12 
  5    13 dcl  dn355_messages$fault_names (0:10) char(16) aligned external;     /* names associated with 355 fault codes */
  5    14 
  5    15 dcl  dn355_messages$per_module fixed bin external;          /* names and messages associated with 355 modules */
  5    16 
  5    17 dcl  dn355_messages$error_messages (10) fixed bin ext;      /* error_messages sent from the 355 */
  5    18 
  5    19 dcl  dn355_messages$boot_messages (0:4) fixed bin external; /* messages describing major bootload status */
  5    20 
  5    21 dcl  dn355_messages$config_messages (0:15) fixed bin external; /* messages describing configuration errors */
  5    22 
  5    23 dcl  modulep ptr;
  5    24 dcl  reasonp ptr;
  5    25 
  5    26 
  5    27           /* list of module names and message list offsets */
  5    28 
  5    29 dcl  1 dn355_modules (9) based (modulep) aligned,
  5    30           2 name char(12),
  5    31           2 list_offset fixed bin;
  5    32 
  5    33           /* list of message offsets */
  5    34 
  5    35 dcl  message_offset (22) fixed bin based;
  5    36 
  5    37 
  5    38           /* crash messages for each module */
  5    39 
  5    40 dcl  1 dn355_reason aligned based (reasonp),
  5    41           2 length fixed bin (8) unal,
  5    42           2 msg char(0 refer (dn355_reason.length)) unal;
  5    43 
  5    44 
  5    45           /* END INCLUDE FILE ... dn355_messages.incl.pl1 */
     1570 
     1571 
  6     1 /* Begin include file fnp_mpx_msg_.incl.pl1 BIM 83-12-20 */
  6     2 /* Message from ring 0 fnp mpx to user ring mpx manager */
  6     3 /* format: style3 */
  6     4 
  6     5 dcl       fnp_msg_ptr         pointer;
  6     6 dcl       1 fnp_msg           aligned based (fnp_msg_ptr),
  6     7             2 fnp_no          fixed bin (17) unal,
  6     8             2 state           fixed bin (17) unal,
  6     9             2 flags           unaligned,
  6    10               3 deconfigured  bit,
  6    11               3 pad           bit (35);
  6    12 
  6    13 /* End include file fnp_mpx_msg_.incl.pl1 */
     1572 
     1573 
  7     1 /* BEGIN INCLUDE FILE...fnp_queue_entry.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
  7     7*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
  7     8*     To increase the size of cmd_data to allow for 8-word echo-break tables.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 /* This include file defines the delay queue entries used by dn355 when an outbound
  7    13*   mailbox is unavailable */
  7    14 
  7    15 /* Extracted from dn355.pl1 by Robert Coren, September 1984 */
  7    16 
  7    17 dcl  fnp_qptr pointer;
  7    18 
  7    19 dcl  1 fnp_queue_entry based (fnp_qptr) aligned,            /* definition of delay queue entry */
  7    20        2 opcode fixed bin (8) unal,                         /* opcode */
  7    21        2 cmd_count fixed bin (8) unal,                      /* count of valid command data */
  7    22        2 pcb_offset bit (18) unal,                          /* PCB of channel */
  7    23        2 cmd_data bit (8 * 36) unal,                        /* 8 words of command data */
  7    24        2 next fixed bin;                                    /* offset of next queue entry */
  7    25 
  7    26 /* END INCLUDE FILE...fnp_queue_entry.incl.pl1 */
     1574 
     1575 
  8     1 /* Begin include file io_manager_dcls.incl.pl1 */
  8     2 
  8     3 /* Written by Charles Hornig, late 1980 and early 1981 */
  8     4 /* Modified for MR10 interface, February 1982 */
  8     5 /* Channel reconfiguration entries added by Chris Jones, January 1984 */
  8     6 
  8     7 /* These entries are callable on unwired stacks. */
  8     8 
  8     9 /* call io_manager$assign (Chx, Channel, Handler, Index, Statusp, Code); */
  8    10 dcl  io_manager$assign
  8    11           entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  8    12           fixed bin (35), ptr, fixed bin (35));
  8    13 
  8    14 /* call io_manager$assign_add (Chx, Channel, Handler, Index, Statusp, Code); */
  8    15 dcl  io_manager$assign_add
  8    16           entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
  8    17           fixed bin (35), ptr, fixed bin (35));
  8    18 
  8    19 /* call io_manager$unassign (Chx, Code); */
  8    20 dcl  io_manager$unassign entry (fixed bin (35), fixed bin (35));
  8    21 
  8    22 /* call io_manager$unassign_delete (Chx, Code); */
  8    23 dcl  io_manager$unassign_delete entry (fixed bin (35), fixed bin (35));
  8    24 
  8    25 /* call io_manager$connect (Io_manager_arg); */
  8    26 dcl  io_manager$connect entry (1 aligned like io_manager_arg);
  8    27 
  8    28 /* call io_manager$connect_abs (Io_manager_arg); */
  8    29 dcl  io_manager$connect_abs entry (1 aligned like io_manager_arg);
  8    30 
  8    31 /* call io_manager$connect_direct (Io_manager_arg); */
  8    32 dcl  io_manager$connect_direct entry (1 aligned like io_manager_arg);
  8    33 
  8    34 /* call io_manager$get_status (Chx, Io_status_entry_ptr); */
  8    35 dcl  io_manager$get_status entry (fixed bin (35), ptr);
  8    36 
  8    37 /* call io_manager$mask (Chx); */
  8    38 dcl  io_manager$mask entry (fixed bin (35));
  8    39 
  8    40 /* call io_manager$ignore_interrupt (); */
  8    41 dcl  io_manager$ignore_interrupt entry (fixed bin (35), fixed bin (3), bit (36) aligned);
  8    42 
  8    43 /* call io_manager$data_tdcw (Io_manager_arg);
  8    44*   dcl  io_manager$data_tdcw entry (1 aligned like io_manager_arg);
  8    45*
  8    46*   /* call io_manager$workspace_tdcw (Io_manager_arg); */
  8    47 dcl  io_manager$workspace_tdcw entry (1 aligned like io_manager_arg);
  8    48 
  8    49 dcl  io_manager_arg_ptr ptr;
  8    50 dcl  1 io_manager_arg aligned based (io_manager_arg_ptr),
  8    51        2 chx fixed bin (35),                                /* channel index from io_manager$assign */
  8    52        2 bound fixed bin (19),                              /* workspace size */
  8    53        2 pcw bit (36) aligned,                              /* or IDCW */
  8    54        2 listx fixed bin (18),                              /* DCW list offset */
  8    55        2 ptp ptr,                                           /* page table pointer */
  8    56        2 listp ptr,                                         /* DCW list pointer */
  8    57        2 dcw_pair_ptr ptr;                                  /* DCW pair pointer */
  8    58 
  8    59 /* End include file io_manager_dcls.incl.pl1 */
     1576 
     1577 
  9     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  9     2 
  9     3 /* Created by J. Stern 7/26/78 */
  9     4 /* Metering information added by C. Hornig, March 1980. */
  9     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  9     6 
  9     7 dcl  lctp ptr;                                              /* ptr to logical channel table */
  9     8 dcl  lctep ptr;                                             /* ptr to logical channel table entry */
  9     9 dcl  lct_size fixed bin;                                    /* size of lcte_array when allocated */
  9    10 
  9    11 dcl 1 lct aligned based (lctp),                             /* logical channel table */
  9    12     2 max_no_lctes fixed bin,                               /* maximum number of lct entries */
  9    13     2 cur_no_lctes fixed bin,                               /* current number of lct entries used */
  9    14     2 lcnt_ptr ptr,                                         /* ptr to logical channel name table */
  9    15     2 queue_lock bit (36),                                  /* lock used to serialize queueing operations */
  9    16     2 pad (11) fixed bin,
  9    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  9    18 
  9    19 
  9    20 dcl 1 lcte aligned based (lctep),                           /* logical channel table entry */
  9    21     2 lock bit (36),                                        /* channel lock */
  9    22     2 data_base_ptr ptr unal,                               /* ptr to channel data base */
  9    23     2 channel_type fixed bin (8) unal,                      /* identifies channel manager program */
  9    24     2 flags unal,
  9    25       3 entry_in_use bit (1) unal,                          /* ON if this entry in use */
  9    26       3 initialized bit (1) unal,                           /* ON if this channel initialized */
  9    27       3 notify_reqd bit (1) unal,                           /* ON if must notify when unlocking this channel */
  9    28       3 locked_for_interrupt bit (1) unal,                  /* ON if lock set by interrupt handler */
  9    29       3 space_needed bit (1) unal,                          /* ON if this channel needs buffer space */
  9    30       3 special_lock bit (1) unal,                          /* ON if lock is managed by multiplexer */
  9    31       3 trace_force bit (1) unal,                           /* ON to trace based on next bit only */
  9    32                                                             /* OFF to XOR next bit with tty_buf.default_tracing */
  9    33       3 trace bit (1) unal,                                 /* ON to trace this channel */
  9    34       3 unused bit (1) unal,
  9    35     2 physical_channel_devx fixed bin (17) unal,            /* devx of physical chan from which logical chan is derived */
  9    36     2 major_channel_info,
  9    37       3 major_channel_devx fixed bin unal,                  /* major channel device index */
  9    38       3 subchannel fixed bin (17) unal,                     /* subchannel id (or data ptr) wrt major channel */
  9    39     2 queue_entries,
  9    40       3 queue_head bit (18) unal,                           /* ptr to first queue entry for this channel */
  9    41       3 queue_tail bit (18) unal,                           /* ptr to last queue entry for this channel */
  9    42     2 word_counts,
  9    43       3 input_words fixed bin (17) unal,                    /* number of input words charged to this channel */
  9    44       3 output_words fixed bin (17) unal,                   /* number of output words charged to this channel */
  9    45 
  9    46     2 meters,
  9    47       3 in_bytes fixed bin (35),
  9    48       3 out_bytes fixed bin (35),
  9    49       3 in,
  9    50         4 calls fixed bin (35),
  9    51         4 interrupts fixed bin (35),
  9    52         4 call_time fixed bin (71),
  9    53         4 interrupt_time fixed bin (71),
  9    54       3 out like lcte.meters.in,
  9    55       3 control like lcte.meters.in,
  9    56     2 saved_meters_ptr ptr,                                 /* pointer to unwired copy of meters saved at last dialup */
  9    57 
  9    58     2 timer_offset bit (18) aligned,                        /* Head of list of timers for this channel */
  9    59 
  9    60     2 pad (3) fixed bin (35);
  9    61 
  9    62 
  9    63 dcl  lcntp ptr;                                             /* ptr to logical channel name table */
  9    64 
  9    65 dcl 1 lcnt aligned based (lcntp),                           /* logical channel name table */
  9    66     2 names (lct.max_no_lctes) char (32) unal;              /* channel names */
  9    67 
  9    68 dcl 1 saved_meters aligned based like lcte.meters;          /* meters saved at dialup, allocated in tty_area */
  9    69 
  9    70 
  9    71 /* END INCLUDE FILE ... lct.incl.pl1 */
     1578 
     1579 
 10     1 /* BEGIN INCLUDE FILE ... line_types.incl.pl1  */
 10     2 
 10     3 /* Written  November 10 1975 by Paul Green */
 10     4 /* Modified October 1978 by Larry Johnson to include line_type_names */
 10     5 /* Modified 12/19/78 by J. Stern to add POLLED_VIP line type */
 10     6 /* Modified 9/27/79 by J. Stern to add X25LAP line type */
 10     7 /* Modified Spring 1981 by Charles Hornig to add HDLC line type */
 10     8 /* Modified May 1981 by Robert Coren to add COLTS line type */
 10     9 /* Modified September 1984 by Robert Coren to correctly count VIP as a synchronous line type */
 10    10 
 10    11 
 10    12 /****^  HISTORY COMMENTS:
 10    13*  1) change(86-02-25,Negaret), approve(87-07-13,MCR7679),
 10    14*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    15*     Add a DSA line type.
 10    16*  2) change(87-03-17,Beattie), approve(87-07-13,MCR7656),
 10    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    18*     Add HASP_OPR to identify HASP workstation consoles with login service.
 10    19*                                                   END HISTORY COMMENTS */
 10    20 
 10    21 
 10    22 declare   (LINE_MC            initial (-2),
 10    23            LINE_TELNET        initial (-1),
 10    24            LINE_UNKNOWN       initial (0),
 10    25            LINE_ASCII         initial (1),
 10    26            LINE_1050          initial (2),
 10    27            LINE_2741          initial (3),
 10    28            LINE_ARDS          initial (4),
 10    29            LINE_SYNCH         initial (5),
 10    30            LINE_G115          initial (6),
 10    31            LINE_BSC           initial (7),
 10    32            LINE_ETX           initial (8),
 10    33            LINE_VIP           initial (9),
 10    34            LINE_ASYNC1        initial (10),
 10    35            LINE_ASYNC2        initial (11),
 10    36            LINE_ASYNC3        initial (12),
 10    37            LINE_SYNC1         initial (13),
 10    38            LINE_SYNC2         initial (14),
 10    39            LINE_SYNC3         initial (15),
 10    40            LINE_POLLED_VIP    initial (16),
 10    41            LINE_X25LAP        initial (17),
 10    42            LINE_HDLC          initial (18),
 10    43            LINE_COLTS         initial (19),
 10    44            LINE_DSA           initial (20),
 10    45            LINE_HASP_OPR      initial (21)
 10    46           ) fixed bin internal static options (constant);
 10    47 
 10    48 dcl  max_line_type fixed bin int static options (constant) init (21);
 10    49 
 10    50 declare  n_sync_line_types fixed bin int static options (constant) init (10);
 10    51 
 10    52 declare  sync_line_type (10) fixed bin int static options (constant) init (5, 6, 7, 9, 13, 14, 15, 16, 17, 18);
 10    53 
 10    54 dcl  line_types (-2:21) char (16) int static options (constant) init (
 10    55      "MC",                                                  /* -2 */
 10    56      "TELNET",                                              /* -1 */
 10    57      "none",                                                /* 0 */
 10    58      "ASCII",                                               /* 1 */
 10    59      "1050",                                                /* 2 */
 10    60      "2741",                                                /* 3 */
 10    61      "ARDS",                                                /* 4 */
 10    62      "Sync",                                                /* 5 */
 10    63      "G115",                                                /* 6 */
 10    64      "BSC",                                                 /* 7 */
 10    65      "202ETX",                                              /* 8 */
 10    66      "VIP",                                                 /* 9 */
 10    67      "ASYNC1",                                              /* 10 */
 10    68      "ASYNC2",                                              /* 11 */
 10    69      "ASYNC3",                                              /* 12 */
 10    70      "SYNC1",                                               /* 13 */
 10    71      "SYNC2",                                               /* 14 */
 10    72      "SYNC3",                                               /* 15 */
 10    73      "POLLED_VIP",                                          /* 16 */
 10    74      "X25LAP",                                              /* 17 */
 10    75      "HDLC",                                                /* 18 */
 10    76      "COLTS",                                               /* 19 */
 10    77      "DSA",                                                 /* 20 */
 10    78      "HASP_OPR");                                           /* 21 */
 10    79 
 10    80 /* END INCLUDE FILE ... line_types.incl.pl1  */
     1580 
     1581 
 11     1 /*                  BEGIN mailbox_ops.incl.pl1
 11     2*
 11     3*   Created 8/15/74 by F. A. Canali
 11     4*   Modified 12/01/75 by J. Goldman for dial out
 11     5*   Modified 8/24/76 by Robert Coren to add dont_accept_calls and blast
 11     6*   Modified 7/28/77 by J. Stern to add set_delay_table
 11     7*   Modified 2/6/78 by Robert Coren to add sync_msg_size
 11     8*   Modified 6/29/79 by B. Greenberg for FNP echo negotiation
 11     9*   Modified Oct. 1979 by Robert Coren to add oflow & iflow modes
 11    10*   Modified 1/21/80 by Robert Coren to add parity controls 
 11    11*   Modified 12/10/80 by Robert Coren to add report_meters
 11    12*   */
 11    13 
 11    14 dcl (                                                       /* declaration of submailbox io commands */
 11    15 
 11    16      rcd init (1),                                          /* read control data */
 11    17      rtx init (2),                                          /* read text */
 11    18      wcd init (3),                                          /* write control data */
 11    19      wtx init (4)                                           /* write text */
 11    20 
 11    21      ) fixed bin (8) int static options (constant);
 11    22 
 11    23 
 11    24 dcl (                                                       /* declaration of submailbox op codes sent by 6180 to 355 */
 11    25 
 11    26      terminal_accepted init (0),                            /* a dialed terminal has been accepted */
 11    27      disconnect_this_line init (1),                         /* hang up a line */
 11    28      disconnect_all_lines init (2),                         /* hang up all lines */
 11    29      dont_accept_calls init (3),                            /* the 6180 is no longer accepting terminals */
 11    30      accept_calls init (4),                                 /* the 6180 is ready to accept terminals */
 11    31      input_accepted init (5),                               /* the 6180 will accept input and has reserved
 11    32*                                                               space in its circular buffer */
 11    33      set_line_type init (6),                                /* set the line type */
 11    34      enter_receive init (7),                                /* give the line to the terminal */
 11    35      set_framing_chars init (8),                            /* set characters for block transfer */
 11    36      blast init (9),                                        /* BOS blast message */
 11    37      accept_direct_output init (10),                        /* the 6180 has an output request */
 11    38      accept_last_output init (11),                          /* same as above but the 355 may
 11    39*                                                               unlock the keyboard and accept input
 11    40*                                                               when the output transmission is through */
 11    41      dial init (12),                                        /* use command data to dial a phone number */
 11    42      reject_request_temp init (14),                         /* an input request can not be serviced */
 11    43      terminal_rejected init (16),                           /* a dial up has been rejected */
 11    44      disconnect_accepted init (17),                         /* the 6180 recognizes a disconnection */
 11    45      init_complete init (18),                               /* 6180 system initialization is complete */
 11    46      dump_mem init (19),                                    /* dump 355 memory */
 11    47      patch_mem init (20),                                   /* patch 355 memory */
 11    48      fnp_break init (21),                                   /* to control fnp break points */
 11    49      line_control init (22),                                /* line control order to fnp */
 11    50      sync_msg_size init (23),                               /* set message size for sync line */
 11    51      set_echnego_break_table init (24),                     /* send over echo negotiation break table */
 11    52      start_negotiated_echo init (25),                       /* attempt to start FNP echoing for ech. nego. */
 11    53      stop_negotiated_echo init (26),                        /* 6180 wants FNP to stop negotiated echo */
 11    54      init_echo_negotiation init (27),                       /* synchronize echo negotiation ctrs. */
 11    55      break_acknowledged init (29),                          /* the 6180 recognizes a break for a terminal */
 11    56      input_fc_chars init (30),                              /* set input flow control chars */
 11    57      output_fc_chars init (31),                             /* set output flow control chars */
 11    58      alter_parameters init (34),                            /* request to alter 355 parms for a terminal */
 11    59      checksum_error init (35),                              /* submailbox has a checksum error */
 11    60      report_meters init (36),                               /* get meters from FNP */
 11    61      set_delay_table init (37)                              /* tells 355 to set new delay table for channel */
 11    62      ) fixed bin (8) int static options (constant);
 11    63 
 11    64 
 11    65 dcl (                                                       /* submailbox op codes sent from 355 to 6180 */
 11    66 
 11    67      accept_new_terminal init (64),                         /* a terminal has dialed up */
 11    68      disconnected_line init (65),                           /* a terminal has been hung up */
 11    69      input_in_mailbox init (66),                            /* this mailbox contains input */
 11    70      line_masked init (67),                                 /* channel was masked for excessive interrupts */
 11    71      s6180_params init (68),                                /* return bcount */
 11    72      send_output init (69),                                 /* I am ready to send to a terminal */
 11    73      ack_echnego_init init (70),                            /* I have zeroed my ech. nego. ctr. */
 11    74      ack_echnego_stop init (71),                            /* I have sent all that I have echoed. */
 11    75      connect_to_slave init (73),                            /* a dialup sequence has been completed */
 11    76      accept_direct_input init (74),                         /* HEY! here's some input for you */
 11    77      break_condition init (75),                             /* a break has been hit for a terminl */
 11    78      wru_timeout init (76),                                 /* no answerback */
 11    79      error_message init (77),                               /* error message from the 355 */
 11    80      first_acu_op_code init (80),
 11    81      acu_no_power init (80),                                /* power indicator of auto-call unit is off */
 11    82      acu_line_occupied init (81),                           /* auto-call unit's line is being used */
 11    83      acu_dial_failure init (82),                            /* dial out failed */
 11    84      acu_no_good init (83),                                 /* invalid dial out attempt */
 11    85      last_acu_op_code init (83),
 11    86      line_status init (84)                                  /* line status reported by fnp */
 11    87      ) fixed bin (8) int static options (constant);
 11    88 
 11    89 dcl (                                                       /* declaration of sub operations for alter parameters */
 11    90 
 11    91      Breakchar init (1),                                    /* specifies break character */
 11    92      Nocontrol init (2),                                    /* enter/leave nocontrol mode */
 11    93      Fullduplex init (3),                                   /* perform character echoing */
 11    94      Break init (4),                              /* send line break to terminal */
 11    95      Errormsg init (5),                                     /* indicates error detected by 355 */
 11    96      Meter init (6),                                        /* read metering info */
 11    97      Sensepos init (7),                                     /* sense position of carrier */
 11    98      Crecho init (8),                                       /* enter/leave crecho mode */
 11    99      Lfecho init (9),                                       /* enter/leave line feed echo mode */
 11   100      Lock init (10),                                        /* lock keyboard */
 11   101      Msg init (11),                                         /* precanned msg for dialing terminals */
 11   102      Upstate init (12),                                     /* are you up? */
 11   103      Dumpoutput init (13),                                  /* throw away output */
 11   104      Tabecho init (14),                                     /* echo tabs */
 11   105      Setbusy init (15),                                     /* force dataset busy */
 11   106      Listen init (16),                                      /* answer the phone */
 11   107      Hndlquit init (17),                                    /* send newline on receipt of quit */
 11   108      Chngstring init (18),                                  /* printer addressing string definition */
 11   109      Wru init (19),                                         /* read answerback */
 11   110      Echoplex init (20),                                    /* enter/leave echoplex mode */
 11   111      Xmit_hold init (21),                                   /* start/stop transmit hold */
 11   112      Dumpinput init (22),                                   /* throw away input */
 11   113      Replay init (23),                                      /* replay interrupted input */
 11   114      Polite init (24),                                      /* write only if at left margin */
 11   115      Block_xfer init (25),                                  /* block transfer or "frame" mode */
 11   116      Set_buffer_size init (26),                             /* set input buffer size */
 11   117      Breakall init (27),                                    /* break on all characters */
 11   118      Prefixnl init (28),                                    /* prefix output with newlines if input present */
 11   119      Input_flow_control init (29),                          /* iflow mode */
 11   120      Output_flow_control init (30),                         /* oflow mode */
 11   121      Odd_parity init (31),                                  /* generate odd parity */
 11   122      Eight_bit_in init (32),                                /* 8bit mode */
 11   123      Eight_bit_out init (33)                                /* no_outp mode */
 11   124      ) fixed bin (8) int static options (constant);
 11   125 
 11   126 dcl  global_opcodes (9) fixed bin (8) int static options (constant) init (
 11   127      2,                                                     /* disconnect_all_lines */
 11   128      3,                                                     /* dont_accept_calls */
 11   129      4,                                                     /* accept_calls */
 11   130      9,                                                     /* blast */
 11   131      19,                                                    /* dump_mem */
 11   132      20,                                                    /* patch_mem */
 11   133      21,                                                    /* fnp_break */
 11   134      36,                                                    /* report_meters */
 11   135      77);                                                   /* error_message */
 11   136 
 11   137 /* END of mailbox_ops.incl.pl1 */
     1582 
     1583 
 12     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
 12     2 
 12     3 /* Defines constants and structures  used by MCS interrupt handlers */
 12     4 
 12     5 /* Created 08/21/78 by Robert Coren */
 12     6 /* Echo negotiation types added sometime by Bernie Greenberg */
 12     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
 12     8 /* MASKED type added June 23, 1982, by Robert Coren */
 12     9 
 12    10 dcl  DIALUP fixed bin int static options (constant) init (1);
 12    11 dcl  HANGUP fixed bin int static options (constant) init (2);
 12    12 dcl  CRASH fixed bin int static options (constant) init (3);
 12    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
 12    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
 12    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
 12    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
 12    17 dcl  QUIT fixed bin int static options (constant) init (8);
 12    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
 12    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
 12    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
 12    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
 12    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
 12    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
 12    24 dcl  TIMER fixed bin int static options (constant) init (15);
 12    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
 12    26 dcl  MASKED fixed bin int static options (constant) init (17);
 12    27 
 12    28 dcl  interrupt_info bit (72) aligned;
 12    29 
 12    30 dcl 1 dialup_info aligned,                                  /* for use with DIALUP interrupt */
 12    31     2 line_type fixed bin (9) unal uns,
 12    32     2 buffer_pad fixed bin (9) unal uns,                    /* free space multiplexer would like in output bufs */
 12    33     2 baud_rate fixed bin (18) unal uns,
 12    34     2 max_buf_size fixed bin (9) unal uns,
 12    35     2 receive_mode_device bit (1) unal,                     /* device must be told to enter receive mode */
 12    36     2 pad bit (26) unal;
 12    37 
 12    38 dcl 1 rtx_info aligned,                                     /* for use with ACCEPT_INPUT interrupt */
 12    39     2 input_chain unaligned,
 12    40       3 chain_head bit (18) unaligned,
 12    41       3 chain_tail bit (18) unaligned,
 12    42     2 input_count fixed bin (18) unal uns,
 12    43     2 flags unaligned,
 12    44       3 break_char bit (1),                                 /* data contains a break character */
 12    45       3 output_in_fnp bit (1),                              /* there is output in the FNP */
 12    46       3 output_in_ring_0 bit (1),                           /* there is output in ring 0 */
 12    47       3 formfeed_present bit (1),                           /* input contains a formfeed character */
 12    48       3 pad bit (14);
 12    49 
 12    50 dcl 1 timer_info aligned,                                   /* Info supplied with TIMER interrupt */
 12    51     2 id bit (36) aligned,                                  /* ID which was supplied in call to mcs_timer$set */
 12    52     2 subchan_idx fixed bin;                                /* Index of subchannel on whose behalf timer was set */
 12    53 
 12    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
     1584 
     1585 
 13     1 /*        BEGIN INCLUDE FILE ... net_event_message.incl.pl1 */
 13     2 
 13     3 /****^  HISTORY COMMENTS:
 13     4*  1) change(86-07-30,Kissel), approve(86-07-30,MCR7475), audit(86-08-04,Coren),
 13     5*     install(86-10-09,MR12.0-1181):
 13     6*     This include file was formerly tty_event_message.incl.pl1.  It has been
 13     7*     updated with different fields and new constants, and renamed to
 13     8*     net_event_message.incl.pl1
 13     9*  2) change(87-04-20,GDixon), approve(87-07-13,MCR7694),
 13    10*     audit(87-06-24,Hartogs), install(87-08-04,MR12.1-1056):
 13    11*     Add NETWORK_TYPE_VALUES array.
 13    12*                                                   END HISTORY COMMENTS */
 13    13 
 13    14 /*        describes event message passed with wakeups from the tty DIM */
 13    15 /*        Created 5/24/76 by Robert S. Coren */
 13    16 
 13    17 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */
 13    18 
 13    19 dcl  net_event_message_arg           fixed bin (71);        /* For calling IPC */
 13    20 dcl  NET_EVENT_MESSAGE_VERSION_1     bit (2) internal static options (constant) init ("10"b);
 13    21 
 13    22 dcl  1 net_event_message             aligned based (addr (net_event_message_arg)),
 13    23        2 version                     bit (2) unaligned,     /* Currently version 1 */
 13    24        2 reason                      bit (16) unaligned,    /* Additional info about the event */
 13    25        2 pad                         bit (6) unaligned,     /* Must be zero */
 13    26        2 network_type                fixed bin (4) unsigned unaligned,
 13    27                                                             /* See below for constants */
 13    28        2 type                        fixed bin (8) unsigned unaligned,
 13    29                                                             /* Type of interrupt, see below */
 13    30        2 handle                      fixed bin (35) aligned;/* Caller's handle (devx for MCS, handle for DSA) */
 13    31 
 13    32 /* Network type constants */
 13    33 
 13    34 dcl  MCS_NETWORK_TYPE                fixed bin (4) unsigned internal static options (constant) init (0);
 13    35 dcl  DSA_NETWORK_TYPE                fixed bin (4) unsigned internal static options (constant) init (1);
 13    36 dcl  MOWSE_NETWORK_TYPE              fixed bin (4) unsigned internal static options (constant) init (2);
 13    37 
 13    38 dcl  NETWORK_TYPE_VALUES (0:2) char(8) varying int static options(constant) init(
 13    39           "MCS",
 13    40           "DSA",
 13    41           "MOWSE");
 13    42 
 13    43 
 13    44 /* MCS event message type constants */
 13    45 
 13    46 dcl  MAX_MCS_EVENT_MSG_TYPE          fixed bin internal static options (constant) init (8);
 13    47 
 13    48 dcl  MCS_UNSPECIFIED_MSG             fixed bin internal static options (constant) init (0);
 13    49                                                             /* used for "start" order, etc. */
 13    50 dcl  MCS_DIALUP_MSG                  fixed bin internal static options (constant) init (1);
 13    51                                                             /* dialup */
 13    52 dcl  MCS_HANGUP_MSG                  fixed bin internal static options (constant) init (2);
 13    53                                                             /* hangup */
 13    54 dcl  MCS_DIALOUT_MSG                 fixed bin internal static options (constant) init (3);
 13    55                                                             /* dialout status returned */
 13    56 dcl  MCS_QUIT_MSG                    fixed bin internal static options (constant) init (4);
 13    57                                                             /* quit */
 13    58 dcl  MCS_READ_MSG                    fixed bin internal static options (constant) init (5);
 13    59                                                             /* input arrived */
 13    60 dcl  MCS_WRITE_MSG                   fixed bin internal static options (constant) init (6);
 13    61                                                             /* output completed */
 13    62 dcl  MCS_LINE_STATUS_MSG             fixed bin internal static options (constant) init (7);
 13    63                                                             /* control tables sent status */
 13    64 dcl  MCS_MASKED_MSG                  fixed bin internal static options (constant) init (8);
 13    65                                                             /* channel masked by FNP */
 13    66 
 13    67 dcl  MCS_MSG_TYPE_TO_PNAME           (0:8) char (20) internal static options (constant) init ("unspecified",
 13    68                                                             /*  0 */
 13    69                                      "dialup",              /*  1 */
 13    70                                      "hangup",              /*  2 */
 13    71                                      "dialout status",      /*  3 */
 13    72                                      "quit",                /*  4 */
 13    73                                      "read",                /*  5 */
 13    74                                      "write",               /*  6 */
 13    75                                      "line status",         /*  7 */
 13    76                                      "masked");             /*  8 */
 13    77 
 13    78 /* DSA event message type constants */
 13    79 
 13    80 dcl  MAX_DSA_EVENT_MSG_TYPE          fixed bin internal static options (constant) init (19);
 13    81 
 13    82 dcl  DSA_UNSPECIFIED_MSG             fixed bin (8) uns internal static options (constant) init (0);
 13    83 dcl  DSA_ATTENTION_MSG               fixed bin (8) uns internal static options (constant) init (1);
 13    84 dcl  DSA_DATA_ATTENTION_MSG          fixed bin (8) uns internal static options (constant) init (2);
 13    85 dcl  DSA_DEMAND_RELEASE_SRU_MSG      fixed bin (8) uns internal static options (constant) init (3);
 13    86 dcl  DSA_DEMAND_TURN_MSG             fixed bin (8) uns internal static options (constant) init (4);
 13    87 dcl  DSA_DEMAND_TURN_ACK_MSG         fixed bin (8) uns internal static options (constant) init (5);
 13    88 dcl  DSA_PURGE_MSG                   fixed bin (8) uns internal static options (constant) init (6);
 13    89 dcl  DSA_RECOVER_MSG                 fixed bin (8) uns internal static options (constant) init (7);
 13    90 dcl  DSA_RECOVER_ACK_MSG             fixed bin (8) uns internal static options (constant) init (8);
 13    91 dcl  DSA_RELEASE_SRU_MSG             fixed bin (8) uns internal static options (constant) init (9);
 13    92 dcl  DSA_RESUME_MSG                  fixed bin (8) uns internal static options (constant) init (10);
 13    93 dcl  DSA_RESUME_ACK_MSG              fixed bin (8) uns internal static options (constant) init (11);
 13    94 dcl  DSA_SUSPEND_MSG                 fixed bin (8) uns internal static options (constant) init (12);
 13    95 dcl  DSA_SUSPEND_ACK_MSG             fixed bin (8) uns internal static options (constant) init (13);
 13    96 dcl  DSA_TERM_ABNORMAL_MSG           fixed bin (8) uns internal static options (constant) init (14);
 13    97 dcl  DSA_ESTABLISHMENT_MSG           fixed bin (8) uns internal static options (constant) init (15);
 13    98 dcl  DSA_TERMINATED_MSG              fixed bin (8) uns internal static options (constant) init (16);
 13    99 dcl  DSA_USER_UNASSIGN_MSG           fixed bin (8) uns internal static options (constant) init (17);
 13   100 dcl  DSA_DATA_INPUT_MSG              fixed bin (8) uns internal static options (constant) init (18);
 13   101 dcl  DSA_DATA_OUTPUT_MSG             fixed bin (8) uns internal static options (constant) init (19);
 13   102 
 13   103 dcl  DSA_MSG_TYPE_TO_PNAME           (0:19) char (20) internal static options (constant) init ("unspecified",
 13   104                                                             /*  0 */
 13   105                                      "attention",           /*  1 */
 13   106                                      "data_attention",      /*  2 */
 13   107                                      "demand_release_sru",  /*  3 */
 13   108                                      "demand_turn",         /*  4 */
 13   109                                      "demand_turn_ack",     /*  5 */
 13   110                                      "purge",               /*  6 */
 13   111                                      "recover",             /*  7 */
 13   112                                      "recover_ack",         /*  8 */
 13   113                                      "release_sru",         /*  9 */
 13   114                                      "resume",              /* 10 */
 13   115                                      "resume_ack",          /* 11 */
 13   116                                      "suspend",             /* 12 */
 13   117                                      "suspend_ack",         /* 13 */
 13   118                                      "terminate_abnormal",  /* 14 */
 13   119                                      "establishment",       /* 15 */
 13   120                                      "terminated",          /* 16 */
 13   121                                      "user_unassign",       /* 17 */
 13   122                                      "data input",          /* 18 */
 13   123                                      "data output");        /* 19 */
 13   124 
 13   125 /*        END INCLUDE FILE ... net_event_message.incl.pl1 */
     1586 
     1587 
 14     1 /*        BEGIN INCLUDE FILE ... pcb.incl.pl1 */
 14     2 
 14     3 
 14     4 
 14     5 /****^  HISTORY COMMENTS:
 14     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
 14     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
 14     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
 14     9*     implementation.
 14    10*                                                   END HISTORY COMMENTS */
 14    11 
 14    12 
 14    13 /*  Created 08/14/78 by Robert S. Coren */
 14    14 /*  Modified 02/19/80 by Robert S. Coren to add read_first & read_last */
 14    15 /*  Modified 12/10/80 by Robert S. Coren to add metering stuff */
 14    16 /*  Modified May 1981 by Robert S.Coren to add tandd_attached flag */
 14    17 /*  Modified in February 1982 to add: dumpout, turn, enter_receive_pending,
 14    18*             connection_type, send_lf, extra_nl,lfecho flags for DN7100 */
 14    19 
 14    20 /* Describes physical channel blocks for FNP channels */
 14    21 
 14    22 dcl  n_pcbs fixed bin;
 14    23 dcl  pcbp ptr;
 14    24 
 14    25 dcl 1 pcb_array (n_pcbs) based aligned like pcb;
 14    26 
 14    27 dcl 1 pcb aligned based (pcbp),                             /* physical channel block declaration */
 14    28     2 channel_desc unaligned,
 14    29       3 devx fixed bin (17),                                /* index of LCT entry */
 14    30       3 subchan fixed bin (7) unaligned,                    /* logical subchannel/lsla slot # correspondence */
 14    31       3 line_number unal,                                   /* regular line number */
 14    32         4 is_hsla bit (1) unaligned,                        /* on if hsla, off if lsla */
 14    33         4 la_no bit (3) unaligned,                          /* line adapter (high or low speed) number */
 14    34         4 slot_no bit (6) unaligned,                        /* physical slot or subchannel number */
 14    35     2 write_first fixed bin (17) unaligned,                 /* offset of first buffer in output chain */
 14    36     2 write_last fixed bin (17) unaligned,                  /* offset of last buffer in output chain */
 14    37     2 baud_rate fixed bin (17) unaligned,                   /* baud rate of channel */
 14    38     2 line_type fixed bin (17) unaligned,                   /* line type */
 14    39     2 max_buf_size fixed bin (17) unaligned,                /* largest buffer to be allocated for output */
 14    40     2 write_cnt fixed bin (17) unaligned,                   /* number of characters in write chain */
 14    41     2 flags unaligned,
 14    42       3 listen bit (1),                                     /* channel is ready for dialup */
 14    43       3 dialed bit (1),                                     /* channel is dialed up or connected */
 14    44       3 send_output bit (1),                                /* channel is ready for output */
 14    45       3 high_speed bit (1),                                 /* needs large send_out threshold */
 14    46       3 sync_line bit (1),                                  /* synchronous channel */
 14    47       3 end_frame bit (1),                                  /* channel is waiting for formfeed */
 14    48       3 hndlquit bit (1),                                   /* channel in hndlquit mode */
 14    49       3 breakall_enabled bit (1),                           /* breakall mode allowed for this channel */
 14    50       3 output_mbx_pending bit (1),                         /* A wtx mbx has been sent, but not relinquished */
 14    51       3 copied_meters_ready bit (1),                        /* copy_meters operation has completed */
 14    52       3 get_meters_waiting bit (1),                         /* waiting for get_meters operation to complete */
 14    53       3 tandd_attached bit (1),                             /* this channel is in use by T & D */
 14    54       3 enter_receive_pending bit (1),                      /* enter_receive is waiting for send */
 14    55       3 turn bit (1),                                       /* Multics owns the turn */
 14    56       3 extra_nl bit (1),                                   /* add NL at end of buffer  (read) */
 14    57       3 send_lf bit (1),                                    /* send lf after read  */
 14    58       3 lfecho bit (1),                                     /* Validate lfecho mode */
 14    59       3 dumpout bit (1),                                    /* To purge first write after special dial */
 14    60       3 buffer_flag bit (1),                                /* Utilisation of a buffer in place of the circular buffer. */
 14    61       3 connection_type bit (2),                            /* For full-duplex */
 14    62       3 padb bit (6),
 14    63       3 uncp_pcbx fixed bin (9) unal uns,                   /* To manage the full duplex with the datanet 7100 */
 14    64     2 read_first fixed bin (18) unsigned unaligned,         /* head of read chain (while reading from FNP) */
 14    65     2 read_last fixed bin (18) unsigned unaligned,          /* tail of read chain (likewise) */
 14    66     2 saved_meters_ptr pointer unaligned,                   /* pointer to (unwired) copy of meters at last dialup */
 14    67     2 copied_meters_offset fixed bin (18) unsigned;         /* offset in tty_buf of buffer meters copied to */
 14    68 
 14    69 /* END INCLUDE FILE ... pcb.incl.pl1 */
     1588 
     1589 
 15     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
 15     2 
 15     3 /* Date Last Modified and Reason
 15     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
 15     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
 15     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
 15     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
 15     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
 15     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
 15    10*   Modified November 1979 by C. Hornig for MCS tracing.
 15    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
 15    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
 15    13*   Modified March 1980 by Robert Coren to reorganize metering information
 15    14*   Modified December 1980 by Robert Coren to add FNP-specific events
 15    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
 15    16*   Modified November 1984 by Robert Coren to add tty_area_lock
 15    17**/
 15    18 
 15    19 dcl  ttybp ptr,
 15    20      tty_buf$ ext static,                                   /* tty buffer segment */
 15    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
 15    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
 15    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
 15    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
 15    25 
 15    26 
 15    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
 15    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
 15    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
 15    30 
 15    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
 15    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
 15    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
 15    34 
 15    35 dcl 1 tty_buf aligned based (ttybp),                        /* declaration of tty buffer seg */
 15    36     2 slock bit (36),                                       /* per system lock */
 15    37     2 absorig fixed bin (24),                               /* abs address of this seg */
 15    38     2 borig bit (18),                                       /* index of start of buffer area */
 15    39     2 bleft fixed bin (18),                                 /* words left in pool */
 15    40     2 free bit (18),                                        /* pointer to start of free pool */
 15    41     2 fnp_config_flags (8) bit (1) unal,                    /* flag(i) ON if fnp(i) configured */
 15    42     2 padb1 bit (28) unaligned,
 15    43     2 lct_ptr ptr,                                          /* pointer to logical channel table */
 15    44 
 15    45     2 nrawread fixed bin (35),                              /* number of raw chars input, total */
 15    46     2 nrawwrite fixed bin (35),                             /* number of raw characters output */
 15    47     2 ninchars fixed bin (35),                              /* total input chars after conversion */
 15    48     2 noutchars fixed bin (35),                             /* total output chars before conversion */
 15    49     2 readblocked fixed bin (35),                           /* number of times go input blocked */
 15    50     2 nblocked fixed bin (35),                              /* number of times process output blocked */
 15    51     2 minbuf fixed bin (18),                                /* min output buffer size */
 15    52     2 totbuf fixed bin (35),                                /* divide by nblocked to get ave buffer size */
 15    53 
 15    54     2 preconverted fixed bin (35),                          /* number of converted chars held in tty_buf */
 15    55     2 input_restart fixed bin,                              /* number of times tty_read had to start over */
 15    56     2 output_restart fixed bin,                             /* number of times tty_write has had to start over */
 15    57     2 output_buffer_overflow fixed bin,                     /* number of times tty_write has run out of buffers */
 15    58     2 read_time fixed bin (71),                             /* total time spent in tty_read */
 15    59     2 write_time fixed bin (71),                            /* total time spent in tty_write */
 15    60 
 15    61     2 read_calls fixed bin (35),                            /* number of calls to tty_read */
 15    62     2 write_calls fixed bin (35),                           /* number of calls to tty_write */
 15    63     2 bfx fixed bin,                                        /* used in calls to iobm */
 15    64     2 nquits fixed bin (35),                                /* number of quits */
 15    65     2 space_needed_data,
 15    66       3 space_needed bit (1) unal,                          /* space_needed bit on in at least 1 lcte */
 15    67       3 space_needed_calls fixed bin (34) unal,             /* meter of uses of this facility */
 15    68     2 space_lock_count fixed bin (35),                      /* count of times tty_buf.slock locked */
 15    69     2 space_lock_wait_count fixed bin (35),                 /* count of times necessary to loop to lock it */
 15    70     2 space_lock_wait_time fixed bin (35),                  /* total time looped trying to lock it */
 15    71 
 15    72     2 alloc_calls fixed bin (35),                           /* total number of allocations performed in tty_buf */
 15    73     2 free_calls fixed bin (35),                            /* total number of freeings in tty_buf */
 15    74     2 alloc_time fixed bin (35),                            /* time spent masked in tty_space_man$get entries */
 15    75     2 free_time fixed bin (35),                             /* time spent masked in tty_space_man$free entries */
 15    76     2 total_alloc_steps fixed bin (35),                     /* number of steps thru free chain while doing above */
 15    77     2 alloc_failures fixed bin (35),                        /* number of unsuccessful attempts to allocate space */
 15    78     2 cumulative_input_space fixed bin (71),                /* cumulative amount of space allocated for input */
 15    79 
 15    80     2 cumulative_output_space fixed bin (71),               /* cumulative amount of space allocated for output */
 15    81     2 cumulative_control_space fixed bin (71),              /* cumulative amount of space allocated by tty_space_man$get_space
 */
 15    82     2 input_space_updates fixed bin (35),                   /* number of increments to cumulative_input_space */
 15    83     2 output_space_updates fixed bin (35),                  /* number of increments to cumulative_output_space */
 15    84     2 control_space_updates fixed bin (35),                 /* number of increments to cumulative_control_space */
 15    85     2 minimum_free_space fixed bin (18),                    /* smallest amount of free space ever available */
 15    86 
 15    87     2 current_input_space fixed bin (18),                   /* amount of space currently allocated for input */
 15    88     2 current_output_space fixed bin (18),                  /* amount of space currently allocated for output */
 15    89     2 current_control_space fixed bin (18),                 /* amount of space currently allocated by get_space */
 15    90     2 tty_lock_calls fixed bin (35),                        /* number of calls to tty_lock$lock entries */
 15    91     2 found_channel_locked fixed bin (35),                  /* number of times tty_lock found channel already locked */
 15    92     2 max_wait_time fixed bin (35),                         /* longest time waited for any channel lock */
 15    93     2 total_wait_time fixed bin (71),                       /* total amount of time spent waiting for channel locks */
 15    94 
 15    95     2 echo_neg_time fixed bin (71),                         /* cumulative time spent doing echo negotiation */
 15    96     2 echo_neg_interrupts fixed bin (35),                   /* Echo-negotiated shipments */
 15    97     2 echo_neg_r0_chars fixed bin (35),                     /* Chars echoed by ring 0 */
 15    98     2 echo_neg_mux_chars fixed bin (35),                    /* Chars echoed by mux */
 15    99     2 echo_neg_sndopt_restarts fixed bin (35),              /* Echo reinits */
 15   100     2 echo_neg_mux_nonecho fixed bin (35),
 15   101     2 echo_neg_entries fixed bin (35),                      /* Entries into negotiate */
 15   102 
 15   103     2 echo_neg_mux_inhibit bit (1) aligned,                 /* For testing */
 15   104     2 n_queued_interrupts fixed bin (35),                   /* number of interrupts queued by tty_lock */
 15   105     2 trace unaligned,                                      /* tracing information */
 15   106       3 flags,
 15   107       4 enable bit,                                         /* global tracing control */
 15   108       4 default_mode bit,                                   /* whether to trace channels by default */
 15   109       4 read bit,                                           /* read */
 15   110       4 write bit,                                          /* write */
 15   111       4 data bit,                                           /* buffers on reads and writes */
 15   112       4 control bit,                                        /* control, priv_control, and hpriv_control */
 15   113       4 modes bit,                                          /* (get set check)_modes */
 15   114       4 interrupt bit,                                      /* interrupt, interrupt_later */
 15   115       4 init bit,                                           /* init_multiplexer, terminate_multiplexer */
 15   116       4 start bit,                                          /* start, stop */
 15   117       4 shutdown bit,                                       /* shutdown */
 15   118       4 space_man bit,                                      /* tty_space_man$* */
 15   119       4 pad_flags bit (6),
 15   120       3 data_offset bit (18),                               /* offset of tracing data */
 15   121 
 15   122     2 recoverable_error_severity fixed bin,                 /* Syserr severity for recoverable MCS errors */
 15   123 
 15   124     2 timer_lock bit (36) aligned,                          /* Lock owned by mcs_timer */
 15   125     2 next_timer_offset bit (18) aligned,                   /* Offset of next timer to come due */
 15   126     2 timer_count fixed bin,                                /* Number of timers outstanding */
 15   127     2 timer_process bit (36) aligned,                       /* Who is doing timers? */
 15   128 
 15   129     2 timer_ev_chn fixed bin (71),                          /* How get get him */
 15   130     2 timer_lock_wait_time fixed bin (71),                  /* CPU time spent spinning on timer lock */
 15   131 
 15   132     2 timer_lock_count fixed bin (35),                      /* Number of times timer lock locked */
 15   133     2 timer_lock_wait_count fixed bin (35),                 /* Number of times imer lock waited on */
 15   134     2 timer_call_time fixed bin (71),                       /* CPU time spent in call side timer operations */
 15   135 
 15   136     2 timer_polling_time fixed bin (71),                    /* CPU time spent polling (including channel_manager) */
 15   137     2 timer_set_calls fixed bin (35),                       /* Number of calls to mcs_timer$set, set_wired */
 15   138     2 timer_reset_calls fixed bin (35),                     /* Number of calls to mcs_timer$reset, reset_wired */
 15   139 
 15   140     2 timer_change_calls fixed bin (35),                    /* Number of calls to mcs_timer$change, change_wired */
 15   141     2 timer_poll_calls fixed bin (35),                      /* Number of calls to mcs_timer$poll */
 15   142     2 timer_error_calls fixed bin (35),                     /* Number of mcs_timer calls ending with recoverable errors */
 15   143     2 timer_duplicate_pollings fixed bin (35),              /* Number of timer polling found in progress on other CPU */
 15   144 
 15   145     2 tty_area_lock like hc_fast_lock,                      /* to prevent contention in allocating/freeing in tty_area */
 15   146 
 15   147     2 pad2 (13) fixed bin (35),
 15   148 
 15   149     2 free_space fixed bin;                                 /* start of free space region */
 15   150 
 15   151 
 16     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
 16     2 
 16     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
 16     4 
 16     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
 16     6 
 16     7 /* format: style3 */
 16     8 
 16     9 declare   lock_ptr            pointer;
 16    10 declare   1 hc_fast_lock      aligned based (lock_ptr),
 16    11             2 pid             bit (36) aligned,             /* holder of lock */
 16    12             2 event           bit (36) aligned,             /* event associated with lock */
 16    13             2 flags           aligned,
 16    14               3 notify_sw     bit (1) unaligned,
 16    15               3 pad           bit (35) unaligned;           /* certain locks use this pad, like dirs */
 16    16 
 16    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
 15   152 
 15   153 
 15   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
     1590 
     1591 
 17     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
 17     2 
 17     3 
 17     4 
 17     5 /****^  HISTORY COMMENTS:
 17     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
 17     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
 17     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
 17     9*     implementation.
 17    10*                                                   END HISTORY COMMENTS */
 17    11 
 17    12 
 17    13 /*
 17    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
 17    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
 17    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
 17    17**/
 17    18 
 17    19 dcl  blockp ptr;                                            /* pointer which block entry is based on */
 17    20 dcl  free_blockp ptr;                                       /* pointer to head of free space chain */
 17    21 
 17    22 
 17    23 dcl 1 free_block aligned based (free_blockp),               /* format of start of free block */
 17    24     2 next bit (18),                                        /* foward pointer to next free block */
 17    25     2 size fixed bin;                                       /* number of words in this block */
 17    26 
 17    27 
 17    28 dcl 1 buffer based (blockp) aligned,                        /* buffer definition */
 17    29     2 next fixed bin (18) unal uns,                         /* addr of next buffer */
 17    30     2 flags unaligned,
 17    31       3 end_of_page bit (1) unaligned,                      /* buffer contains end of page */
 17    32       3 converted bit (1) unaligned,                        /* buffer contains converted input */
 17    33       3 break bit (1) unaligned,                            /* buffer contains break character */
 17    34       3 mark bit (1) unaligned,                             /* buffer contains first character after "mark" */
 17    35       3 turn bit (1) unaligned,                             /* ON if the turn must be sent */
 17    36       3 pad bit (1) unaligned,
 17    37     2 size_code fixed bin (3) unal uns,                     /* (nwords/16) - 1 */
 17    38     2 tally fixed bin (9) unal uns,                         /* number of characters in buffer */
 17    39     2 chars (0:59) char (1) unaligned;                      /* room for 60 data characters */
 17    40 
 17    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
 17    42 
 17    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
 17    44 
 17    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
     1592 
     1593 
 18     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
 18     2 
 18     3 /* This include file declares all the entries in tty_space_man and defines the constants
 18     4**  to be used for the flags argument
 18     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
 18     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
 18     7**   Modified April 1981 by Robert Coren to add switch_chain entry
 18     8**/
 18     9 
 18    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
 18    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
 18    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
 18    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
 18    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
 18    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
 18    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
 18    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
 18    18 dcl  tty_space_man$needs_space entry (fixed bin);
 18    19 
 18    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
 18    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
 18    22 
 18    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
     1594 
     1595 
     1596 /* BEGIN MESSAGE DOCUMENTATION
     1597*
     1598*   Message:
     1599*   dn355: FNP X invalid interrupt level N
     1600*
     1601*   S:  $beep
     1602*
     1603*   T:  $run
     1604*
     1605*   M:  An FNP interrupt has been received from frontend X with an invalid
     1606*   interrupt level of octal value N and will be ignored.  If this message is
     1607*   displayed when a DN6670 is being powered up, this message can be ignored.
     1608*   If this message occurs under any other circumstances, there might be
     1609*   something wrong with the system's interface with the FNP and should be
     1610*   investigated by FE representatives.
     1611*
     1612*   A:  $inform
     1613*
     1614*
     1615*   Message:
     1616*   dn355: emergency interrupt from FNP X: FAULT
     1617*   .br
     1618*   FNP instruction counter = IC
     1619*   .br
     1620*   channel CHN, fault status = FS
     1621*   .br
     1622*   FNP_MODULE: REASON_FOR_CRASH
     1623*
     1624*   S:  $beep
     1625*
     1626*   T:  $run
     1627*
     1628*   M:  An emergency interrupt has been received from FNP X indicating
     1629*   it has crashed.  All lines dialed to FNP X will be hung up.  The
     1630*   crash was nominally caused by a fault of type FAULT.  Lines
     1631*   following the first line of the message appear only in certain cases
     1632*   and provide additional information about the nature of the crash.
     1633*
     1634*   A:  The system will automatically attempt to reboot the crashed FNP.
     1635*   Subsequent messages will indicate the success or failure of this attempt.
     1636*   No action is required now, but action may be required if the
     1637*   automatic reboot fails.
     1638*
     1639*
     1640*   Message:
     1641*   dn355: no slot number match for sub mbx N, FNP X
     1642*
     1643*   S:  $beeper
     1644*
     1645*   T:  $run
     1646*
     1647*   M:  An error has occurred processing submailbox N for FNP X.
     1648*   The submailbox indicates a line number for which no match could
     1649*   be found.
     1650*
     1651*   A:  $inform
     1652*
     1653*
     1654*   Message:
     1655*   dn355: Message from FNP X: MESSAGE
     1656*
     1657*   S:  $info
     1658*
     1659*   T:  $run
     1660*
     1661*   M:  An error has been detected by FNP X as explained by MESSAGE.
     1662*
     1663*   A:  No action is required by the operator to deal with the error mentioned
     1664*   in the message.  Action may be required by appropriate personnel to correct
     1665*   the problem that caused the error and undo what the FNP may have done to
     1666*   continue operation.  This may require shutting down the FNP for repairs by
     1667*   Field Engineering and reboot of the FNP to restore full operation.
     1668*
     1669*
     1670*   Message:
     1671*   dn355: FNP masked channel NAME for excessive interrupts
     1672*
     1673*   S:  $info
     1674*
     1675*   T:  $run
     1676*
     1677*   M:  The FNP has masked the channel whose name is NAME because it was
     1678*   generating interrupts faster than they could be handled.
     1679*
     1680*   A: The interruptions can be caused by any number of problems.  This
     1681*   can be caused by the dataset leads changing too fast for the FNP
     1682*   software to handle properly; disconnecting or connecting FNP cables,
     1683*   powering off or on a hardwired terminal, a bad modem, etc.  It is
     1684*   also possible that the FNP channel hardware is defective.  Future
     1685*   attempts to use this channel may possibly crash the FNP.  CS
     1686*   representatives may need to be called to investigate.  An "attach"
     1687*   command will be necessary to put the channel back in service.
     1688*
     1689*
     1690*   Message:
     1691*   dn355: unrecognized op code OPCODE with rcd from FNP X for devx N
     1692*
     1693*   S:  $beeper
     1694*
     1695*   T:  $run
     1696*
     1697*   M:  An invalid op code, OPCODE, has been received from FNP X for device
     1698*   index N in a mailbox containing an rcd (read control data) command.
     1699*
     1700*   A:  $inform
     1701*
     1702*
     1703*   Message:
     1704*   dn355: unrecognized io command C from FNP X for line N
     1705*
     1706*   S:  $beeper
     1707*
     1708*   T:  $run
     1709*
     1710*   M:  An invalid io command was received from FNP X for line N. C is the
     1711*   octal representation of the command.
     1712*
     1713*   A:  $inform
     1714*
     1715*
     1716*   Message:
     1717*   dn355: output buffer at N has zero tally
     1718*
     1719*   S:  $crash
     1720*
     1721*   T:  $run
     1722*
     1723*   M:  An output buffer with a zero tally has been found at offset N
     1724*   in the segment tty_buf.
     1725*
     1726*   A:  $inform
     1727*
     1728*
     1729*   Message:
     1730*   dn355: unable to allocate block for delay queue
     1731*
     1732*   S:  $crash
     1733*
     1734*   T:  $run
     1735*
     1736*   M: There was insufficient space left in tty_buf to allocate a block
     1737*   in which to build a delay queue.
     1738*
     1739*   A:  $inform
     1740*
     1741*
     1742*   Message:
     1743*   dn355: FNP X did not respond to mailbox interrupt
     1744*
     1745*   S:  $beep
     1746*
     1747*   T:  $run
     1748*
     1749*   M:  An attempt to interrupt FNP X was unsuccessful. The FNP is assumed
     1750*   to be down.
     1751*
     1752*   A:  The system will automatically attempt to reboot the crashed FNP.
     1753*   Subsequent messages will indicate the success or failure of this attempt.
     1754*   No action is required now, but action may be required if the
     1755*   automatic reboot fails.
     1756*
     1757*
     1758*   Message:
     1759*   dn355: inconsistent queue lock
     1760*
     1761*   S:  $crash
     1762*
     1763*   T:  $run
     1764*
     1765*   M:  A process attempted to unlock the interrupt queue lock without having it
     1766*   locked.
     1767*
     1768*   A:  $inform
     1769*
     1770*
     1771*   Message:
     1772*   dn355: LCTE lock ^= processid
     1773*
     1774*   S:     $crash
     1775*
     1776*   T:     $run
     1777*
     1778*   M:  The FNP channel lock did not contain the processid of the process
     1779*   attempting to unlock it.
     1780*
     1781*
     1782*   Message:
     1783*   dn355: attempted crawlout with FNP queue locked
     1784*
     1785*   S:     $crash
     1786*
     1787*   T:     $run
     1788*
     1789*   M:     An attempt was made to crawl out while an FNP queue lock (a processor
     1790*   lock) was locked.
     1791*
     1792*   A:     $inform
     1793*
     1794*
     1795*   Message:
     1796*   dn355: line number of 0 with non-global opcode in submbx N, FNP X
     1797*
     1798*   S:  $beeper
     1799*
     1800*   T:  $run
     1801*
     1802*   M:  Mailbox N from FNP X contained a non-global opcode which requires a
     1803*   non-zero line number.
     1804*
     1805*
     1806*   Message:
     1807*   dn355: FNP X level L status S STATE
     1808*
     1809*   S:   $info
     1810*
     1811*   T:   $run
     1812*
     1813*   M:   An interrupt at a level other than 3 (or possibly at level 3 if the
     1814*   FNP is not running) was received from FNP X. S is an octal representation
     1815*   of the status accompanying the interrupt. STATE indicates the current state
     1816*   of the FNP: running, bootloading, or in T&D. This message only appears if
     1817*   tracing is enabled for the specified FNP.
     1818*
     1819*   A:   None required.
     1820*
     1821*
     1822*   Message:
     1823*   dn355: Error sending mailbox interrupt to FNP X, will retry.
     1824*
     1825*   S:  $info
     1826*
     1827*   T:  $run
     1828*
     1829*   M:  An error has been detected in the transmission of a mailbox interrupt
     1830*   to the FNP.  The transmission will be retried once.
     1831*
     1832*   A:  None required.
     1833*
     1834*
     1835*   Message:
     1836*   dn355: Timeout sending mailbox interrupt to FNP X, will retry.
     1837*
     1838*   S:  $info
     1839*
     1840*   T:  $run
     1841*
     1842*   M:  The FNP did not respond within 2 seconds to the previously
     1843*   sent mailbox interrupt.  The transmission will be retried once.
     1844*
     1845*   A:  None required.
     1846*
     1847*
     1848*   END MESSAGE DOCUMENTATION */
     1849 
     1850 
     1851      end dn355;
          SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME                              PATHNAME
             0    12/16/17  0837.6  dn355.pl1                         >user_dir_dir>SysAdmin>Repair>foo>dn355.pl1
1562         1    05/28/82  1234.9  baud_rates.incl.pl1               >ldd>include>baud_rates.incl.pl1
1564         2    05/06/80  0858.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
1566         3    10/26/89  1911.9  dn355_data.incl.pl1               >ldd>include>dn355_data.incl.pl1
1568         4    10/20/82  0838.5  dn355_mailbox.incl.pl1            >ldd>include>dn355_mailbox.incl.pl1
1570         5    09/12/79  1708.7  dn355_messages.incl.pl1           >ldd>include>dn355_messages.incl.pl1
1572         6    07/11/84  0837.3  fnp_mpx_msg_.incl.pl1             >ldd>include>fnp_mpx_msg_.incl.pl1
1574         7    07/10/86  1915.0  fnp_queue_entry.incl.pl1          >ldd>include>fnp_queue_entry.incl.pl1
1576         8    07/11/84  0837.3  io_manager_dcls.incl.pl1          >ldd>include>io_manager_dcls.incl.pl1
1578         9    11/08/82  0905.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
1580        10    08/06/87  0813.4  line_types.incl.pl1               >ldd>include>line_types.incl.pl1
1582        11    10/20/82  0838.6  mailbox_ops.incl.pl1              >ldd>include>mailbox_ops.incl.pl1
1584        12    10/20/82  0838.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
1586        13    08/06/87  0813.5  net_event_message.incl.pl1        >ldd>include>net_event_message.incl.pl1
1588        14    07/21/88  1936.0  pcb.incl.pl1                      >ldd>include>pcb.incl.pl1
1590        15    01/06/85  1322.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
15-152      16    01/06/85  1322.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
1592        17    07/21/88  1936.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
1594        18    06/18/81  0800.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
          NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER               OFFSET    LOC STORAGE CLASS   DATA TYPE                ATTRIBUTES AND REFERENCES
                                                                                (* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCEPT_INPUT                    000102 constant        fixed bin(17,0)          initial dcl 12-15 set ref 1028* 1069*
ACKNOWLEDGE_ECHNEGO_INIT        000001 constant        fixed bin(17,0)          initial dcl 12-22 set ref 693*
ACKNOWLEDGE_ECHNEGO_STOP        000013 constant        fixed bin(17,0)          initial dcl 12-23 set ref 699*
CRASH                           000126 constant        fixed bin(17,0)          initial dcl 12-12 set ref 1342*
DIALUP                          000131 constant        fixed bin(17,0)          initial dcl 12-10 set ref 583*
DIAL_STATUS                     000101 constant        fixed bin(17,0)          initial dcl 12-19 set ref 679*
FNP_DOWN                               constant        fixed bin(17,0)          initial dcl 1476 ref 1406
FNP_DUMP_PATCH_EVENT            000115 constant        fixed bin(17,0)          initial dcl 15-31 set ref 452* 1398*
FNP_METER_EVENT                 000000 constant        fixed bin(17,0)          initial dcl 15-32 set ref 463* 470*
HANGUP                          000002 constant        fixed bin(17,0)          initial dcl 12-11 set ref 592*
INPUT                           000046 constant        bit(1)                   initial packed unaligned dcl 18-20 set ref 965* 968*
                                                                                  1031* 1054*
INPUT_REJECTED                  000106 constant        fixed bin(17,0)          initial dcl 12-16 set ref 999* 1078*
LINE_COLTS                             constant        fixed bin(17,0)          initial dcl 10-22 ref 562
LINE_ETX                               constant        fixed bin(17,0)          initial dcl 10-22 ref 568
LINE_STATUS                     000120 constant        fixed bin(17,0)          initial dcl 12-18 set ref 686*
MASKED                          000103 constant        fixed bin(17,0)          initial dcl 12-26 set ref 710*
MCS_NETWORK_TYPE                       constant        fixed bin(4,0)           initial unsigned dcl 13-34 ref 362
NET_EVENT_MESSAGE_VERSION_1            constant        bit(2)                   initial packed unaligned dcl 13-20 ref 361
OUTPUT                          000111 constant        bit(1)                   initial packed unaligned dcl 18-21 set ref 486*
                                                                                  1370*
QUIT                            000114 constant        fixed bin(17,0)          initial dcl 12-17 set ref 611*
SEND_OUTPUT                     000113 constant        fixed bin(17,0)          initial dcl 12-13 set ref 834* 905* 1123*
TANDD_LINE_NUMBER                      constant        bit(10)                  initial packed unaligned dcl 1480 ref 1206
TWO_SECONDS                     000046 constant        fixed bin(71,0)          initial dcl 1482 ref 1264
WRU_TIMEOUT                     000065 constant        fixed bin(17,0)          initial dcl 12-20 set ref 599*
a_fnp_no                               parameter       fixed bin(17,0)          dcl 1322 set ref 1319 1326*
a_fnpp                                 parameter       pointer                  dcl 142 ref 139 154 161
a_level                                parameter       fixed bin(17,0)          dcl 341 in procedure "process_int" ref 336 343
a_level                                parameter       fixed bin(17,0)          dcl 315 in procedure "dequeue" set ref 312 320* 327*
a_mbx_no                               parameter       fixed bin(17,0)          dcl 1240 ref 1236 1236 1246 1249 1252
a_mbx_num                              parameter       fixed bin(17,0)          dcl 820 ref 817 824
a_pcbp                                 parameter       pointer                  dcl 142 ref 139 151
abs_addr                  3            based           bit(24)                  array level 3 packed packed unaligned dcl 4-84 set
                                                                                  ref 979*
absorig                   1            based           fixed bin(24,0)          level 2 dcl 15-35 ref 485 858 868 939 979
accept_direct_input                    constant        fixed bin(8,0)           initial dcl 11-65 ref 517 538 627
accept_direct_output                   constant        fixed bin(8,0)           initial dcl 11-24 set ref 200 776 844* 892 1119*
accept_new_terminal                    constant        fixed bin(8,0)           initial dcl 11-65 ref 542
ack_echnego_init                       constant        fixed bin(8,0)           initial dcl 11-65 ref 690
ack_echnego_stop                       constant        fixed bin(8,0)           initial dcl 11-65 ref 696
addr                                                   builtin function         dcl 1489 ref 95 98 105 115 162 163 177 186 216 239
                                                                                  249 251 253 287 387 390 391 392 392 396 432 432
                                                                                  436 439 484 509 511 575 578 642 648 658 763 766
                                                                                  790 840 849 856 935 979 1058 1059 1096 1103 1138
                                                                                  1206 1216 1324 1325 1335 1338
address                   5            based           structure                level 2 packed packed unaligned dcl 4-36
auto_fnp_msg                    000170 automatic       structure                level 1 dcl 1522 set ref 1409
auto_net_event_message          000166 automatic       structure                level 1 dcl 1521 set ref 360* 365
baud_rate                 0(18) 000260 automatic       fixed bin(18,0)          level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 12-30 in procedure "dn355"
                                                                                  set ref 565*
baud_rate                 2            based           fixed bin(17,0)          level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" set ref 547* 558
                                                                                  565
baud_table                      000026 constant        fixed bin(17,0)          initial array dcl 1-8 ref 547
beeper                          000126 constant        fixed bin(17,0)          initial dcl 1467 set ref 85* 378* 498* 716* 730*
                                                                                  1194* 1220* 1385*
bin                                                    builtin function         dcl 1489 ref 485 498 498 546 547 642 658 678 730 730
                                                                                  858 858 868 939 939 974 976 979 979 985 1158
binary                                                 builtin function         dcl 1489 ref 706 706 706 706 706
bit                                                    builtin function         dcl 1489 ref 678 858 868 874 939 979 1025 1026 1303
bits_per_char                   000152 automatic       fixed bin(17,0)          dcl 1451 set ref 554* 556* 558
bits_to_send                           based           bit(288)                 packed unaligned dcl 931 set ref 936*
bleft                     3            based           fixed bin(18,0)          level 2 dcl 15-35 ref 1139
bleft_355                27            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 520* 523 523* 534 859
blockp                          000274 automatic       pointer                  dcl 17-19 set ref 870* 871 874 877 878 880 882 896
                                                                                  965* 966 974 976 978 979 982 985 1054* 1055 1059
                                                                                  1061 1065 1101* 1102 1103
boot_ev_chan             36            based           fixed bin(71,0)          level 2 dcl 3-67 set ref 366* 1410*
boot_process_id          40            based           bit(36)                  level 2 dcl 3-67 set ref 366* 1410*
bootloading              30(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 79*
                                                                                  86 92 408 1401 1404*
break_char                1(18) 000262 automatic       bit(1)                   level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1017* 1045* 1109
break_condition                        constant        fixed bin(8,0)           initial dcl 11-65 ref 604
buf_per_second                         constant        fixed bin(17,0)          initial dcl 15-29 ref 558
buf_size                        000412 automatic       fixed bin(17,0)          dcl 1010 in procedure "process_rtx" set ref 1052*
                                                                                  1054*
buf_size                        000375 automatic       fixed bin(17,0)          dcl 953 in procedure "process_accept_input" set ref
                                                                                  963* 965*
buffer                                 based           structure                level 1 dcl 17-28
buffer_pad                0(09) 000260 automatic       fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 12-30
                                                                                  set ref 567*
bufp                            000114 automatic       pointer                  dcl 1431 set ref 1096* 1103* 1106 1111
caller_masked                          parameter       bit(1)                   packed unaligned dcl 266 ref 261 275 281 300
chain_head                      000262 automatic       bit(18)                  level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1025* 1065*
chain_head_ptr                  000146 automatic       pointer                  dcl 1447 set ref 485* 486*
chain_len                       000133 automatic       fixed bin(17,0)          dcl 1431 set ref 889* 891 909
chain_tail                0(18) 000262 automatic       bit(18)                  level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1026* 1065*
chan_lctep                      000144 automatic       pointer                  dcl 1446 set ref 1138* 1139
channel_desc                           based           structure                level 2 packed packed unaligned dcl 14-27
channel_manager$interrupt       000042 constant        entry                    external dcl 2-25 ref 583 592 599 611 679 686 693
                                                                                  699 710 834 905 999 1028 1069 1078 1123 1342
chars                     1            based           char(1)                  array level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 17-28 in procedure "dn355" set ref
                                                                                  979 1059 1103
chars                                  based           char                     packed unaligned dcl 1492 in procedure "dn355" set
                                                                                  ref 1060* 1060
chars_left                      000127 automatic       fixed bin(17,0)          dcl 1431 set ref 1097* 1102* 1106 1106 1111 1111
                                                                                  1111
chrsa                                  parameter       fixed bin(8,0)           dcl 142 ref 139 154 172
chx                             000464 automatic       fixed bin(35,0)          level 2 dcl 1244 set ref 1278* 1309*
cleanup                         000230 stack reference condition                dcl 1560 ref 235
clock                                                  builtin function         dcl 1489 ref 1264 1266
cmd_count                 0(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1533 set ref 789
                                                                                  790 1172*
cmd_data                  1            based           bit(288)                 level 2 packed packed unaligned dcl 1533 set ref
                                                                                  781* 790 1177*
cmd_data_len              1(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 4-36 set ref
                                                                                  198* 574* 789*
cnt                                    parameter       fixed bin(8,0)           dcl 1148 ref 1145 1172
command                   0(30)        based           bit(6)                   level 3 packed packed unaligned dcl 4-12 set ref
                                                                                  1262 1266 1269
command_data             33            based           bit(36)                  level 2 in structure "input_sub_mbx" packed packed
                                                                                  unaligned dcl 4-84 in procedure "dn355" ref 1017
                                                                                  1022
command_data             33            based           bit(36)                  level 2 in structure "fnp_sub_mbx" packed packed
                                                                                  unaligned dcl 4-63 in procedure "dn355" ref 1045
                                                                                  1062
command_data              2            based           bit(36)                  array level 2 in structure "sub_mbx" packed packed
                                                                                  unaligned dcl 4-36 in procedure "dn355" set ref
                                                                                  216 489 546 547 547 575 578 642 658 685 790 893*
config_flags             66            based           structure                level 2 dcl 3-67
continue                        000162 automatic       bit(1)                   packed unaligned dcl 1458 set ref 865* 866 885*
copied_meters_ready       4(09)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  473*
count                                  parameter       fixed bin(17,0)          dcl 1135 in procedure "enough_input_space" ref 1132
                                                                                  1139
count                    24            based           fixed bin(17,0)          level 2 in structure "fnp_info" dcl 3-67
                                                                                  in procedure "dn355" set ref 427 740 759 808*
                                                                                  1168* 1168 1346 1348 1356*
crash_code                0(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1538 ref 392 392
                                                                                  396
crash_data                6            based           structure                level 2 dcl 4-12
crash_system                    000131 constant        fixed bin(17,0)          initial dcl 1467 set ref 108* 271* 293* 296* 871*
                                                                                  1154* 1420*
cumulative_mbx_in_use
                         55            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 444* 444 1299* 1299
cur_ptr                  25            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 758 806* 1159 1159* 1349
                                                                                  1356*
data                                   parameter       bit                      packed unaligned dcl 142 in procedure "dn355" ref
                                                                                  139 154 173
data                                   based           bit(18)                  array level 2 in structure "error_msg" packed packed
                                                                                  unaligned dcl 1552 in procedure "dn355" ref 642
                                                                                  658
data_addr                 5            based           bit(18)                  level 3 packed packed unaligned dcl 4-36 set ref
                                                                                  858* 939*
data_len                        000110 automatic       fixed bin(8,0)           dcl 149 set ref 172* 173 173 180* 198 216
databits                               parameter       bit(288)                 packed unaligned dcl 1148 ref 1145 1177
datanet_info                           based           structure                level 1 dcl 3-52
datanet_mbx                            based           structure                level 1 dcl 4-12
dataoff                                constant        fixed bin(17,0)          initial dcl 1467 ref 485 868
dcw                       3            based           structure                array level 2 dcl 4-84
dcw_list                               based           structure                array level 1 dcl 1525
dcw_list_array                         based           structure                array level 1 dcl 1530 set ref 484 856 935
dcw_list_array_ptr        4            based           pointer                  level 2 dcl 3-67 ref 484 856 935
dcw_ptr                                based           bit(18)                  array level 2 packed packed unaligned dcl 1525 set
                                                                                  ref 485 868*
dcw_tally                 0(27)        based           bit(9)                   array level 2 packed packed unaligned dcl 1525 set
                                                                                  ref 874*
dcwlptr                         000112 automatic       pointer                  dcl 1431 set ref 484* 485 856* 858 868 874 876
devx                            000134 automatic       fixed bin(17,0)          dcl 1431 in procedure "dn355" set ref 192* 458 583*
                                                                                  592* 599* 611* 679* 686* 693* 699* 710* 716* 772*
                                                                                  834* 905* 965* 968* 999* 1028* 1031* 1054* 1069*
                                                                                  1078* 1123* 1138 1201* 1226*
devx                                   based           fixed bin(17,0)          level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" ref 192 486 772
                                                                                  1226 1342 1370
dia_pcw                                based           structure                level 2 dcl 4-12 set ref 1276* 1276 1276 1302* 1306*
                                                                                  1306 1306
dialed                    4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  202 210 570* 590* 599 607 621 630 667 704* 776 781
                                                                                  933 1339
dialup_info                     000260 automatic       structure                level 1 dcl 12-30 set ref 582
die_code                               constant        fixed bin(17,0)          initial dcl 1550 ref 387
disconnect_this_line                   constant        fixed bin(8,0)           initial dcl 11-24 ref 635 671
disconnected_line                      constant        fixed bin(8,0)           initial dcl 11-65 ref 588
divide                                                 builtin function         dcl 1489 ref 198 558 558 560 789 859 957 963 1049
                                                                                  1052 1139
dn355_boot_interrupt            000024 constant        entry                    external dcl 1508 ref 410
dn355_boot_interrupt$system_fault
                                000026 constant        entry                    external dcl 1508 ref 86
dn355_data$                     000044 external static fixed bin(17,0)          dcl 3-47 set ref 163 251 1325
dn355_messages$error_messages   000052 external static fixed bin(17,0)          array dcl 5-17 set ref 644 646 648
dn355_messages$fault_names      000046 external static char(16)                 array dcl 5-13 ref 374 376
dn355_messages$per_module       000050 external static fixed bin(17,0)          dcl 5-15 set ref 390
dn355_modules                          based           structure                array level 1 dcl 5-29
dn355_reason                           based           structure                level 1 dcl 5-40
dn355_sub_mbxes          10            based           structure                array level 2 dcl 4-12 set ref 186 439 766 849
dn355_util$compute_parity       000022 constant        entry                    external dcl 1508 ref 1276 1306
dn355_word                             based           structure                level 1 packed packed unaligned dcl 1538
dno                             000122 automatic       fixed bin(17,0)          dcl 1431 set ref 86* 170* 250* 253 363 410* 1401*
                                                                                  1407
dump_mem                               constant        fixed bin(8,0)           initial dcl 11-24 ref 449
dump_patch_in_progress
                         30(04)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref
                                                                                  451* 1398
end_frame                 4(05)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  825 884* 909 1109 1118* 1375*
end_of_page               0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 17-28 ref 882
error                     0(18)        based           bit(1)                   level 3 packed packed unaligned dcl 4-12 set ref
                                                                                  1269 1273 1275*
error_message                          constant        fixed bin(8,0)           initial dcl 11-65 ref 640
error_msg                              based           structure                level 1 dcl 1552
fault_code                6            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 4-12
                                                                                  ref 373
fault_name                      000200 automatic       char(16)                 packed unaligned dcl 1545 set ref 374* 376* 378*
fault_type                      000177 automatic       fixed bin(17,0)          dcl 1544 set ref 373* 374 374 376 383 387
fault_word                7(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 4-12
                                                                                  set ref 383* 387 391 392 392 396
ff_cr_lf                        000045 constant        char(3)                  initial packed unaligned dcl 1503 ref 1111
first_acu_op_code                      constant        fixed bin(8,0)           initial dcl 11-65 ref 676
fixed                                                  builtin function         dcl 1489 ref 391 1211 1213 1303
flags                     1(18) 000262 automatic       structure                level 2 in structure "rtx_info" packed packed
                                                                                  unaligned dcl 12-38 in procedure "dn355"
flags                     1     000170 automatic       structure                level 2 in structure "auto_fnp_msg" packed packed
                                                                                  unaligned dcl 1522 in procedure "dn355" set ref
                                                                                  1408*
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 17-28 in procedure "dn355"
flags                    30            based           structure                level 2 in structure "fnp_info" dcl 3-67
                                                                                  in procedure "dn355"
flags                     2(09)        based           structure                level 2 in structure "lcte" packed packed unaligned
                                                                                  dcl 9-20 in procedure "dn355"
flags                     4            based           structure                level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355"
fnp_event_message               000172 automatic       fixed bin(71,0)          dcl 1523 set ref 1409* 1410*
fnp_id                    7            based           structure                level 2 dcl 3-67
fnp_info                               based           structure                level 1 dcl 3-67
fnp_msg                                based           structure                level 1 dcl 6-6
fnp_name                        000137 automatic       char(1)                  dcl 1438 set ref 79* 85* 254*
fnp_no                          000170 automatic       fixed bin(17,0)          level 2 in structure "auto_fnp_msg" packed packed
                                                                                  unaligned dcl 1522 in procedure "dn355" set ref
                                                                                  1407*
fnp_no                                 parameter       fixed bin(17,0)          dcl 1333 in procedure "hangup_fnp" ref 1330 1335
fnp_number                7(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 3-67
                                                                                  ref 170
fnp_queue_entry                        based           structure                level 1 dcl 7-19
fnp_space_restricted_output
                         63            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 909* 909
fnp_sub_mbx                            based           structure                level 1 dcl 4-63
fnp_sub_mbxes           110            based           structure                array level 2 dcl 4-12 set ref 511
fnp_tag                   7            based           char(1)                  level 3 packed packed unaligned dcl 3-67 set ref 254
                                                                                  378* 498* 660* 706* 716* 730* 1194* 1220* 1282*
                                                                                  1385*
fnpp                            000240 automatic       pointer                  dcl 3-50 set ref 76 79 79 79 86 92 92 92 98 101 103
                                                                                  108 115 161* 164 166 170 171 181 181 219 219 239
                                                                                  253* 254 255 256 269 269 271 287 296 317 319 324
                                                                                  326 349 351 353 354 358 366 366 378 408 414 416
                                                                                  418 422 427 444 444 445 445 451 458 462 484 498
                                                                                  520 523 523 528 530 531 534 534 534 535 535 538
                                                                                  538 540 540 660 706 716 730 740 758 759 792 792
                                                                                  803 803 806 808 809 845 845 856 859 898 898 909
                                                                                  909 935 943 943 998 998 1014 1014 1159 1159 1162
                                                                                  1166 1168 1168 1169 1169 1194 1205 1206 1206 1211
                                                                                  1213 1216 1220 1254 1278 1279 1282 1298 1298 1299
                                                                                  1299 1300 1300 1309 1310 1335* 1336 1338 1346 1348
                                                                                  1349 1356 1356 1356 1385 1397 1398 1401 1404 1410
                                                                                  1410
form_feed                       007452 constant        char(1)                  initial packed unaligned dcl 1506 ref 1106
formfeed_present          1(21) 000262 automatic       bit(1)                   level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1090* 1106*
free_count               62            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 531* 535* 535
free_size                61            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 528 530* 534* 534
full_words                      000205 automatic       fixed bin(17,0)          array dcl 1556 set ref 658* 660*
get_meters_waiting        4(10)        based           bit(1)                   level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" set ref 467 469*
get_meters_waiting       30(13)        based           bit(1)                   level 3 in structure "fnp_info" packed packed
                                                                                  unaligned dcl 3-67 in procedure "dn355" set ref
                                                                                  458 462*
global_opcodes                  000002 constant        fixed bin(8,0)           initial array dcl 11-126 ref 1190 1190 1192
handle                    1     000166 automatic       fixed bin(35,0)          level 2 dcl 1521 set ref 363*
hbound                                                 builtin function         dcl 1489 ref 374 392 392 644 1190 1192
hc_fast_lock                           based           structure                level 1 dcl 16-10
high_speed                4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 ref 575
hndlquit                  4(06)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 ref 609
hsla_idx                 21            based           fixed bin(17,0)          array level 2 dcl 3-67 ref 1211
i                               000123 automatic       fixed bin(17,0)          dcl 1431 set ref 177* 178 186 205 210 218 434* 436
                                                                                  439 441 484 489* 508* 509 511 581* 593* 601* 613*
                                                                                  620* 636* 662* 672* 680* 687* 692* 698* 711* 760*
                                                                                  762 763* 764 766 776 781 791 989* 997* 1035* 1070*
                                                                                  1077* 1082* 1194* 1220*
ic                        6(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 4-12
                                                                                  set ref 380 380*
illegal_opcode                         constant        fixed bin(17,0)          initial dcl 1549 ref 387
ima                             000464 automatic       structure                level 1 dcl 1244 set ref 1280* 1311*
in                        2            based           structure                level 2 in structure "saved_meters" dcl 9-68
                                                                                  in procedure "dn355"
in                       30            based           structure                array level 4 in structure "lct" dcl 9-11
                                                                                  in procedure "dn355"
in                       10            based           structure                level 3 in structure "lcte" dcl 9-20 in procedure
                                                                                  "dn355"
in_bytes                  6            based           fixed bin(35,0)          level 3 dcl 9-20 set ref 1016* 1016 1067* 1067
in_mbx                                 parameter       bit(1)                   packed unaligned dcl 1088 ref 1085 1094 1114
index                                                  builtin function         dcl 1489 ref 177 763 840
infop                           000236 automatic       pointer                  dcl 3-49 set ref 74 163* 251* 253 1325* 1335
initial_pcw                     000050 constant        bit(36)                  initial packed unaligned dcl 1478 ref 1302
input_accepted                         constant        fixed bin(8,0)           initial dcl 11-24 ref 987
input_bpart                            constant        fixed bin(18,0)          initial dcl 15-19 ref 1139
input_chain                     000262 automatic       structure                level 2 packed packed unaligned dcl 12-38
input_chars                            based           char                     packed unaligned dcl 1495 ref 1106 1111
input_control_transactions
                         53            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 540* 540
input_count               1     000262 automatic       fixed bin(18,0)          level 2 in structure "rtx_info" packed packed
                                                                                  unsigned unaligned dcl 12-38 in procedure "dn355"
                                                                                  set ref 1024* 1064*
input_count                     000142 automatic       fixed bin(17,0)          dcl 1444 in procedure "dn355" set ref 956* 957 1019*
                                                                                  1020 1024
input_data                2            based           char(100)                level 2 packed packed unaligned dcl 4-63 set ref
                                                                                  1058 1096
input_data_transactions
                         51            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 538* 538 1014* 1014
input_in_mailbox                       constant        fixed bin(8,0)           initial dcl 11-65 ref 517 538 665
input_reject_count       46            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 998* 998
input_sub_mbx                          based           structure                level 1 dcl 4-84
input_words               5            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 9-20 ref 1139
interrupt_entry                        parameter       bit(1)                   dcl 822 in procedure "process_send_output" ref 817
                                                                                  905
interrupt_entry                 000141 automatic       bit(1)                   packed unaligned dcl 1442 in procedure "dn355" set
                                                                                  ref 70* 123 159* 233*
interrupt_info                  000256 automatic       bit(72)                  dcl 12-28 set ref 582* 583* 678* 679* 685* 686*
                                                                                  1027* 1028* 1068* 1069*
io_cmd                    1(27)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 4-36 set ref
                                                                                  215* 447 480 498* 514 580* 634* 670* 726 730* 787*
                                                                                  894* 938* 988* 993* 1074*
io_manager$connect_direct       000054 constant        entry                    external dcl 8-32 ref 1280 1311
io_manager_arg                         based           structure                level 1 dcl 8-50
io_manager_assigned      66(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 ref 1254
io_manager_chx           12            based           fixed bin(35,0)          level 2 dcl 3-67 ref 1278 1309
iom_channel_fault                      constant        fixed bin(17,0)          initial dcl 1548 ref 383
iom_fault_status          7            based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 4-12
                                                                                  set ref 383*
is_hsla                   0(08)        based           bit(1)                   level 3 packed packed unaligned dcl 4-36 set ref
                                                                                  1211
ix                              000124 automatic       fixed bin(17,0)          dcl 1431 set ref 657* 658 658*
j                               000132 automatic       fixed bin(17,0)          dcl 1431 set ref 550* 550* 552 866* 868 874 876* 889
                                                                                  957* 959* 1211* 1213* 1215* 1215* 1216* 1337*
                                                                                  1338*
just_tell                       000112 constant        fixed bin(17,0)          initial dcl 1467 set ref 76 380* 383* 398* 660* 706*
                                                                                  1282*
k                               000131 automatic       fixed bin(17,0)          dcl 1431 set ref 961* 962 979*
la_no                     0(09)        based           bit(3)                   level 3 packed packed unaligned dcl 4-36 set ref 706
                                                                                  706 1210
lano                            000136 automatic       bit(3)                   packed unaligned dcl 1431 set ref 1210* 1211 1213
last_acu_op_code                       constant        fixed bin(8,0)           initial dcl 11-65 ref 676
last_ptr                 26            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 809* 1162 1166* 1356*
lct                                    based           structure                level 1 dcl 9-11
lct_ptr                   6            based           pointer                  level 2 dcl 15-35 ref 1137
lcte                                   based           structure                level 1 dcl 9-20
lcte_array               20            based           structure                array level 2 dcl 9-11 set ref 1138
lcte_ptr                 32            based           pointer                  level 2 dcl 3-67 ref 164 256
lctep                           000254 automatic       pointer                  dcl 9-8 set ref 95 105 126 126 129 133 164* 256* 292
                                                                                  293 304 306 345 899 899 1016 1016 1067 1067
lctp                            000252 automatic       pointer                  dcl 9-7 set ref 1137* 1138
ldac                            000020 constant        entry                    external dcl 1508 ref 432
length                                 based           fixed bin(8,0)           level 2 in structure "dn355_reason" packed packed
                                                                                  unaligned dcl 5-40 in procedure "dn355" ref 398
                                                                                  398 652
length                                                 builtin function         dcl 1489 in procedure "dn355" ref 172
level                           000121 automatic       fixed bin(17,0)          dcl 1431 set ref 73* 76 79* 83 83 85* 86 101 113*
                                                                                  268* 279* 343* 346 364
level_3_pending          30(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref
                                                                                  103* 317 319*
level_7_pending          30(06)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref
                                                                                  101* 324 326*
line_masked                            constant        fixed bin(8,0)           initial dcl 11-65 ref 702
line_number               0(08)        based           structure                level 2 in structure "sub_mbx" packed packed
                                                                                  unaligned dcl 4-36 in procedure "dn355" set ref
                                                                                  190* 195* 498 498 730 730 771* 774* 850* 1188 1206
                                                                                  1217
line_number               0(26)        based           structure                level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" ref 190 771 850
                                                                                  1217
line_status                            constant        fixed bin(8,0)           initial dcl 11-65 ref 683
line_type                       000260 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 12-30 in procedure "dn355"
                                                                                  set ref 546* 568
line_type                 2(18)        based           fixed bin(17,0)          level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" set ref 546* 550
                                                                                  562
list_offset               3            based           fixed bin(17,0)          array level 2 dcl 5-29 ref 392 395
listen                    4            based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  704*
lock                                   based           bit(36)                  level 2 dcl 9-20 set ref 95 105 126 293
locked_for_interrupt      2(12)        based           bit(1)                   level 3 packed packed unaligned dcl 9-20 set ref
                                                                                  133* 292* 345*
log                                    constant        fixed bin(17,0)          initial dcl 1467 ref 78
lsla_idx                 13            based           fixed bin(17,0)          array level 2 dcl 3-67 ref 1213
masked                          000160 automatic       bit(1)                   packed unaligned dcl 1456 set ref 236* 277* 283*
                                                                                  302* 1423
max                                                    builtin function         dcl 1489 ref 859 889 1298
max_buf_chars                   000153 automatic       fixed bin(17,0)          dcl 1452 set ref 558* 560
max_buf_size              3            based           fixed bin(17,0)          level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" set ref 560* 562*
                                                                                  566 859
max_buf_size              1     000260 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 12-30 in procedure "dn355"
                                                                                  set ref 566*
max_chain_len                          constant        fixed bin(17,0)          initial dcl 1467 ref 859 866 909 1525 1530
max_mbx_in_use           56            based           fixed bin(17,0)          level 2 dcl 3-67 set ref 1298* 1298
max_no_355s                            internal static fixed bin(17,0)          initial dcl 3-45 ref 3-52
mbx_in_use_updated       57            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 445* 445 1300* 1300
mbx_no                          000460 automatic       fixed bin(17,0)          dcl 1241 in procedure "return_mbx" set ref 1246*
                                                                                  1252* 1294 1296 1303
mbx_no                    0(24)        based           bit(6)                   level 3 in structure "datanet_mbx" packed packed
                                                                                  unaligned dcl 4-12 in procedure "dn355" set ref
                                                                                  1303*
mbx_num                         000354 automatic       fixed bin(17,0)          dcl 821 in procedure "process_send_output" set ref
                                                                                  824* 838 840* 842 849 856 897*
mbx_num                                parameter       fixed bin(17,0)          dcl 927 in procedure "send_echo_table" set ref 924
                                                                                  935 942*
mbx_pt                                 based           pointer                  level 2 dcl 3-67 ref 171 255
mbx_unavailable          60            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 181* 181 803* 803 845* 845
mbx_used_flags            5            based           structure                level 2 dcl 4-12
mbxp                            000244 automatic       pointer                  dcl 4-100 set ref 171* 177 186 255* 373 380 380 383
                                                                                  383 387 391 392 392 396 432 432 439 441 443 443
                                                                                  444 511 763 766 840 849 1262 1266 1269 1269 1273
                                                                                  1275 1276 1276 1276 1296 1297 1297 1298 1299 1302
                                                                                  1303 1306 1306 1306
message_offset                         based           fixed bin(17,0)          array dcl 5-35 ref 392 396
meters                    6            based           structure                level 2 in structure "lcte" dcl 9-20 in procedure
                                                                                  "dn355"
meters                   26            based           structure                array level 3 in structure "lct" dcl 9-11
                                                                                  in procedure "dn355"
min                                                    builtin function         dcl 1489 ref 172 560 859
modnum                                 based           bit(4)                   level 2 packed packed unaligned dcl 1538 ref 391
module_num                      000204 automatic       fixed bin(17,0)          dcl 1546 set ref 391* 392 392 395 398
modulep                         000246 automatic       pointer                  dcl 5-23 set ref 390* 392 392 395 395 398
msg                       0(09)        based           char                     level 2 packed packed unaligned dcl 5-40 set ref
                                                                                  398* 652
n_buffers                 2            based           fixed bin(17,0)          level 2 dcl 4-84 ref 961
n_chars                   1(09)        based           fixed bin(9,0)           level 2 in structure "fnp_sub_mbx" packed packed
                                                                                  unsigned unaligned dcl 4-63 in procedure "dn355"
                                                                                  ref 1044
n_chars                   1            based           fixed bin(17,0)          level 2 in structure "input_sub_mbx" packed packed
                                                                                  unaligned dcl 4-84 in procedure "dn355" ref 956
                                                                                  1015
n_free_buffers            0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-63 ref 520
n_pcbs                          000266 automatic       fixed bin(17,0)          dcl 14-22 set ref 1205* 1215 1336* 1337
n_sync_line_types                      constant        fixed bin(17,0)          initial dcl 10-50 ref 550 552
n_words                         000411 automatic       fixed bin(17,0)          dcl 1009 set ref 1049* 1050* 1052
name                                   based           char(12)                 array level 2 dcl 5-29 set ref 398*
net_event_message                      based           structure                level 1 dcl 13-22
net_event_message_arg           000264 automatic       fixed bin(71,0)          dcl 13-19 set ref 365* 366*
network_type              0(24) 000166 automatic       fixed bin(4,0)           level 2 packed packed unsigned unaligned dcl 1521
                                                                                  set ref 362*
new_qp                          000174 automatic       pointer                  dcl 1535 set ref 1151* 1152 1158 1167
new_qrel                        000176 automatic       fixed bin(17,0)          dcl 1536 set ref 1158* 1159 1163 1166
next                     11            based           fixed bin(17,0)          level 2 in structure "q_entry" dcl 1533 in procedure
                                                                                  "dn355" set ref 798 1163* 1176* 1352
next                                   based           fixed bin(18,0)          level 2 in structure "buffer" packed packed unsigned
                                                                                  unaligned dcl 17-28 in procedure "dn355" set ref
                                                                                  877 896* 976*
no_of_channels            6            based           fixed bin(17,0)          level 2 dcl 3-67 ref 1205 1336
no_response                     000140 automatic       bit(1)                   dcl 1440 set ref 169* 223 425* 436 509 740 745 795
                                                                                  1257* 1261* 1271 1274* 1291*
notify_reqd               2(11)        based           bit(1)                   level 3 packed packed unaligned dcl 9-20 set ref 126
                                                                                  129* 304 306*
null                                                   builtin function         dcl 1489 ref 157 188 966 1055 1152 1173 1200
num_in_use                4            based           fixed bin(17,0)          level 2 dcl 4-12 set ref 443* 443 444 1297* 1297
                                                                                  1298 1299
numchars                        000130 automatic       fixed bin(17,0)          dcl 1431 set ref 1044* 1047 1049 1060 1060 1061 1064
                                                                                  1067 1097 1114*
offset                          000163 automatic       fixed bin(17,0)          dcl 1460 set ref 642* 644 644 646* 646 650
op_code                   1(18)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 4-36 set ref
                                                                                  197* 449 449 455 517 517 517 538 538 542 572* 588
                                                                                  597 604 617 627 635* 640 665 671* 676 676 678 683
                                                                                  690 696 702 716* 788* 892* 937* 987* 995* 1076*
                                                                                  1190
opa                                    parameter       fixed bin(8,0)           dcl 142 ref 139 154 165
opc                                    parameter       fixed bin(8,0)           dcl 1148 ref 1145 1171
opcode                                 based           fixed bin(8,0)           level 2 in structure "q_entry" packed packed
                                                                                  unaligned dcl 1533 in procedure "dn355" set ref
                                                                                  776 781 788 1171*
opcode                    0(04)        based           fixed bin(4,0)           level 2 in structure "dn355_word" packed packed
                                                                                  unaligned dcl 1538 in procedure "dn355" ref 387
operation                       000135 automatic       fixed bin(8,0)           dcl 1431 set ref 165* 180* 197 200 208
out_bytes                 7            based           fixed bin(35,0)          level 3 dcl 9-20 set ref 899* 899
output_bpart                           constant        fixed bin(18,0)          initial dcl 15-19 ref 859
output_chars                    000151 automatic       fixed bin(17,0)          dcl 1449 set ref 864* 866 880* 880 899
output_control_transactions
                         54            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 219* 219 792* 792 943* 943
output_data_transactions
                         52            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 898* 898
output_in_fnp             1(19) 000262 automatic       bit(1)                   level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1022* 1062*
output_in_ring_0          1(20) 000262 automatic       bit(1)                   level 3 packed packed unaligned dcl 12-38 set ref
                                                                                  1023* 1063*
output_limit                    000150 automatic       fixed bin(17,0)          dcl 1448 set ref 859* 866
output_mbx_pending        4(08)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  483* 825 895*
pad                       1(10) 000260 automatic       bit(26)                  level 2 in structure "dialup_info" packed packed
                                                                                  unaligned dcl 12-30 in procedure "dn355" set ref
                                                                                  569*
pad                       0(18)        based           bit(9)                   array level 2 in structure "dcw_list" packed packed
                                                                                  unaligned dcl 1525 in procedure "dn355" set ref
                                                                                  876*
patch_mem                              constant        fixed bin(8,0)           initial dcl 11-24 ref 449
pcb                                    based           structure                level 1 dcl 14-27
pcb_array                              based           structure                array level 1 dcl 14-25 set ref 1206 1216 1338
pcb_array_ptr             2            based           pointer                  level 2 dcl 3-67 ref 1206 1216 1338
pcb_offset                0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1533 set ref 768
                                                                                  770 1173* 1175*
pcbp                            000270 automatic       pointer                  dcl 14-23 set ref 151* 157* 188 190 192 202 210 467
                                                                                  469 473 483 486 546 547 550 552 554 558 560 562
                                                                                  562 565 566 570 575 590 599 607 609 621 630 667
                                                                                  704 704 770* 771 772 776 781 825 825 827 831 833
                                                                                  850 855 859 866 868 870 871 877 878 878 884 895
                                                                                  902 904 909 933 959 968 968 968 970 974 974 985
                                                                                  1023 1025 1026 1031 1031 1033 1033 1063 1091 1101
                                                                                  1109 1118 1119 1119 1173 1173 1200* 1206* 1216*
                                                                                  1217 1226 1338* 1339 1342 1368 1370 1370 1370 1371
                                                                                  1371 1371 1375
pcw_error                       000461 automatic       bit(1)                   packed unaligned dcl 1242 set ref 1273* 1282*
pds$processid                   000014 external static bit(36)                  dcl 1501 ref 95 98 105 108 115 126 239 271 287 293
                                                                                  296
per_datanet              22            based           structure                array level 2 dcl 3-52 set ref 253 1335
pmut$unwire_unmask              000040 constant        entry                    external dcl 1520 ref 275 300 1423
pmut$wire_and_mask              000036 constant        entry                    external dcl 1519 ref 237 284
prev_blockp                     000376 automatic       pointer                  dcl 954 set ref 976 982*
processed_from_q         47            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 269* 269
ptp                       4     000464 automatic       pointer                  level 2 in structure "ima" dcl 1244 in procedure
                                                                                  "return_mbx" set ref 1279* 1310*
ptp                      71            based           pointer                  level 2 in structure "fnp_info" packed packed
                                                                                  unaligned dcl 3-67 in procedure "dn355" ref 1279
                                                                                  1310
ptr                                                    builtin function         dcl 1489 ref 395 396 485 650 767 770 870 968 968
                                                                                  1031 1031 1101 1162 1351 1370 1370
pxss$notify                     000034 constant        entry                    external dcl 1508 ref 130 307 357 452 463 470 1398
pxss$ring_0_wakeup              000030 constant        entry                    external dcl 1508 ref 1410
pxss$unique_ring_0_wakeup       000032 constant        entry                    external dcl 1508 ref 366
q_count                         000126 automatic       fixed bin(17,0)          dcl 1431 set ref 759* 762 799* 799 808 809 1348*
                                                                                  1350* 1350*
q_entries_made           45            based           fixed bin(35,0)          level 2 dcl 3-67 set ref 1169* 1169
q_entry                                based           structure                level 1 dcl 1533 set ref 800 800 1151 1151 1353 1353
q_first                         000125 automatic       fixed bin(17,0)          dcl 1431 set ref 758* 767 798* 806 1349* 1350 1351
                                                                                  1352*
qptr                            000116 automatic       pointer                  dcl 1431 set ref 767* 768 770 776 781 781 788 789
                                                                                  790 790 798 800 800 800* 1151 1151 1162* 1163
                                                                                  1167* 1171 1172 1173 1175 1176 1177 1351* 1352
                                                                                  1353 1353 1353*
queue_lock               43            based           bit(36)                  level 2 dcl 3-67 set ref 98 108 115 239 271 287 296
queue_locked                    000161 automatic       bit(1)                   packed unaligned dcl 1457 set ref 241* 274* 289*
                                                                                  299* 1420
rcd                                    constant        fixed bin(8,0)           initial dcl 11-14 ref 514
read_first                5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 14-27
                                                                                  set ref 959 968 968 968 970* 974 974* 1025 1031
                                                                                  1031 1033*
read_last                 5(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 14-27
                                                                                  set ref 985* 1026 1033* 1101
real_word_cnt                   000410 automatic       fixed bin(17,0)          dcl 1008 set ref 1015* 1016 1019 1116*
reason_msg                      000210 automatic       char(64)                 packed unaligned dcl 1558 set ref 652* 655* 660
reasonp                         000250 automatic       pointer                  dcl 5-24 set ref 395* 396* 396 396 398 648* 650* 650
                                                                                  652
receive_mode_device       1(09) 000260 automatic       bit(1)                   level 2 packed packed unaligned dcl 12-30 set ref
                                                                                  568*
reject_request_temp             000013 constant        fixed bin(8,0)           initial dcl 11-24 ref 995 1076
rel                                                    builtin function         dcl 1489 ref 858 939 974 976 979 985 1065 1158 1173
report_meters                          constant        fixed bin(8,0)           initial dcl 11-24 ref 455
rtx                                    constant        fixed bin(8,0)           initial dcl 11-14 ref 726 988
rtx_info                        000262 automatic       structure                level 1 dcl 12-38 set ref 1027 1068
running                  30(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 76
                                                                                  79* 92 166 422 1397*
send_output                            constant        fixed bin(8,0)           initial dcl 11-65 in procedure "dn355" ref 517 617
send_output               4(02)        based           bit(1)                   level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 14-27 in procedure "dn355" set ref 827* 833*
                                                                                  855* 1119
set_echnego_break_table                constant        fixed bin(8,0)           initial dcl 11-24 ref 208 781 937
size                                                   builtin function         dcl 1489 ref 800 800 1151 1151 1353 1353
slot_no                   0(12)        based           bit(6)                   level 3 packed packed unaligned dcl 4-36 set ref 706
                                                                                  706 706
smbx_cmd_data_long                     based           bit(216)                 packed unaligned dcl 1497 set ref 216* 790*
source_ptr                      000414 automatic       pointer                  dcl 1011 set ref 1058* 1060
stac                                                   builtin function         dcl 1489 ref 95 98 105 115 239 287
stacq                                                  builtin function         dcl 1489 ref 108 126 271 293 296
state                     0(18) 000170 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 1522 set ref
                                                                                  1406*
string                                                 builtin function         dcl 1489 set ref 190* 190 195* 498 498 730 730 771*
                                                                                  771 774* 850* 850 1188 1206 1217 1217 1276* 1276
                                                                                  1276 1302* 1306* 1306 1306
sub_mbx                                based           structure                level 1 dcl 4-36
subp                            000242 automatic       pointer                  dcl 4-99 set ref 186* 190 195 197 198 215 216 439*
                                                                                  447 449 449 455 480 489 498 498 498 511* 514 517
                                                                                  517 517 520 538 538 542 546 547 547 572 574 575
                                                                                  578 580 588 597 604 617 627 634 635 640 642 658
                                                                                  665 670 671 676 676 678 683 685 690 696 702 706
                                                                                  706 706 706 706 716 726 730 730 730 766* 771 774
                                                                                  787 788 789 790 849* 850 858 891 892 893 894 937
                                                                                  938 939 940 956 961 962 979 987 988 993 995 1015
                                                                                  1017 1022 1044 1045 1058 1062 1074 1076 1096 1188
                                                                                  1190 1206 1210 1211 1217
substr                                                 builtin function         dcl 1489 ref 173 216 685 790 1017 1022 1045 1062
                                                                                  1106 1111
sync_line                 4(04)        based           bit(1)                   level 3 packed packed unaligned dcl 14-27 set ref
                                                                                  552* 554 1091
sync_line_type                  000014 constant        fixed bin(17,0)          initial array dcl 10-52 ref 550
syserr                          000016 constant        entry                    external dcl 1508 ref 79 85 108 271 293 296 378 380
                                                                                  383 398 498 660 706 716 730 871 1154 1194 1220
                                                                                  1282 1385 1420
syserr_severity                 000164 automatic       fixed bin(35,0)          dcl 1461 set ref 76* 78* 79*
t_and_d_in_progress      30(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 79*
                                                                                  92 349 414
t_and_d_lev_3_occurred
                         30(09)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 416
                                                                                  418*
t_and_d_lev_7_occurred
                         30(10)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 351
                                                                                  353*
t_and_d_notify_requested
                         30(11)        based           bit(1)                   level 3 packed packed unaligned dcl 3-67 set ref 354
                                                                                  358*
table_bits                             parameter       bit(288)                 packed unaligned dcl 928 ref 924 936
table_ptr                       000364 automatic       pointer                  dcl 930 set ref 935* 936 939
tally                     0(27)        based           fixed bin(9,0)           level 2 in structure "buffer" packed packed unsigned
                                                                                  unaligned dcl 17-28 in procedure "dn355" set ref
                                                                                  871 874 878 880 978* 1061* 1102
tally                     3(24)        based           fixed bin(12,0)          array level 3 in structure "input_sub_mbx" packed
                                                                                  packed unsigned unaligned dcl 4-84 in procedure
                                                                                  "dn355" ref 962
tally                           000374 automatic       fixed bin(17,0)          dcl 952 in procedure "process_accept_input" set ref
                                                                                  962* 963 978
tandd_pcbx               64            based           fixed bin(17,0)          level 2 dcl 3-67 ref 1206
target_ptr                      000416 automatic       pointer                  dcl 1012 set ref 1059* 1060
tc_data$fnp_buffer_threshold    000012 external static fixed bin(17,0)          dcl 1500 ref 859
tc_data$system_shutdown         000010 external static fixed bin(17,0)          dcl 1499 ref 68
tdata                           000100 automatic       bit(288)                 packed unaligned dcl 148 set ref 172 173* 175* 180*
                                                                                  210* 216
term_inpt_mpx_wd          2            based           bit(36)                  level 2 dcl 4-12 set ref 432 432
terminal_accepted                      constant        fixed bin(8,0)           initial dcl 11-24 ref 572
timeout_time                    000462 automatic       fixed bin(71,0)          dcl 1243 set ref 1264* 1266
timw                            000120 automatic       fixed bin(24,0)          dcl 1431 set ref 432* 436 509
timwb                                  based           bit(1)                   array packed unaligned dcl 1485 ref 436 509
trace                     5            based           bit(1)                   level 2 dcl 3-52 ref 74
tty_buf                                based           structure                level 1 dcl 15-35
tty_buf$                        000056 external static fixed bin(17,0)          dcl 15-19 set ref 162 249 1324
tty_ev                          000050 constant        fixed bin(17,0)          initial dcl 15-19 set ref 130* 307* 357*
tty_space_man$free_chain        000066 constant        entry                    external dcl 18-16 ref 486 968 1031 1370
tty_space_man$free_space        000062 constant        entry                    external dcl 18-12 ref 800 1353
tty_space_man$get_buffer        000064 constant        entry                    external dcl 18-13 ref 965 1054
tty_space_man$get_space         000060 constant        entry                    external dcl 18-10 ref 1151
ttybp                           000272 automatic       pointer                  dcl 15-19 set ref 162* 249* 485 485 767 770 858 868
                                                                                  870 939 968 968 979 1031 1031 1101 1137 1139 1162
                                                                                  1324* 1351 1370 1370
type                      0(28) 000166 automatic       fixed bin(8,0)           level 2 packed packed unsigned unaligned dcl 1521
                                                                                  set ref 364*
unal_number                            based           fixed bin(17,0)          packed unaligned dcl 1492 set ref 575* 578*
unspec                                                 builtin function         dcl 1489 set ref 360* 365* 365 582 685 1027 1068
                                                                                  1409* 1409
used                      5            based           bit(1)                   array level 3 packed packed unaligned dcl 4-12 set
                                                                                  ref 177 441* 763 840 1296*
used_string                            based           bit(8)                   packed unaligned dcl 1485 ref 177 763 840
verify                                                 builtin function         dcl 1489 ref 1111
version                         000166 automatic       bit(2)                   level 2 packed packed unaligned dcl 1521 set ref
                                                                                  361*
wcd                                    constant        fixed bin(8,0)           initial dcl 11-14 ref 215 447 580 634 670 787 938
                                                                                  993 1074
wire_arg                        000154 automatic       fixed bin(71,0)          dcl 1454 set ref 237* 275* 284* 300* 1423*
wire_ptr                        000156 automatic       pointer                  dcl 1455 set ref 237* 275* 284* 300* 1423*
word_cnt                  5(18)        based           fixed bin(18,0)          level 3 packed packed unsigned unaligned dcl 4-36
                                                                                  set ref 891* 940*
word_counts               5            based           structure                level 2 dcl 9-20
write_cnt                 3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-27 set ref
                                                                                  878* 878 1371*
write_first               1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-27 set ref
                                                                                  831 866 868 870 871* 877* 902 1023 1063 1119 1368
                                                                                  1370 1370 1371*
write_last                1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 14-27 set ref
                                                                                  904* 1371*
wru_timeout                            constant        fixed bin(8,0)           initial dcl 11-65 ref 597
wtx                                    constant        fixed bin(8,0)           initial dcl 11-14 ref 480 894
x                               000450 automatic       fixed bin(17,0)          dcl 1186 set ref 1190* 1190* 1192
x_dno                                  parameter       fixed bin(35,0)          dcl 64 ref 61 230 250
x_level                                parameter       fixed bin(3,0)           dcl 65 ref 61 73
x_status                               parameter       bit(36)                  dcl 66 set ref 61 79*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Block_xfer                             internal static fixed bin(8,0)           initial dcl 11-89
Break                                  internal static fixed bin(8,0)           initial dcl 11-89
Breakall                               internal static fixed bin(8,0)           initial dcl 11-89
Breakchar                              internal static fixed bin(8,0)           initial dcl 11-89
Chngstring                             internal static fixed bin(8,0)           initial dcl 11-89
Crecho                                 internal static fixed bin(8,0)           initial dcl 11-89
DSA_ATTENTION_MSG                      internal static fixed bin(8,0)           initial unsigned dcl 13-83
DSA_DATA_ATTENTION_MSG                 internal static fixed bin(8,0)           initial unsigned dcl 13-84
DSA_DATA_INPUT_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 13-100
DSA_DATA_OUTPUT_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-101
DSA_DEMAND_RELEASE_SRU_MSG             internal static fixed bin(8,0)           initial unsigned dcl 13-85
DSA_DEMAND_TURN_ACK_MSG                internal static fixed bin(8,0)           initial unsigned dcl 13-87
DSA_DEMAND_TURN_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-86
DSA_ESTABLISHMENT_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 13-97
DSA_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 13-103
DSA_NETWORK_TYPE                       internal static fixed bin(4,0)           initial unsigned dcl 13-35
DSA_PURGE_MSG                          internal static fixed bin(8,0)           initial unsigned dcl 13-88
DSA_RECOVER_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-90
DSA_RECOVER_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 13-89
DSA_RELEASE_SRU_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-91
DSA_RESUME_ACK_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 13-93
DSA_RESUME_MSG                         internal static fixed bin(8,0)           initial unsigned dcl 13-92
DSA_SUSPEND_ACK_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-95
DSA_SUSPEND_MSG                        internal static fixed bin(8,0)           initial unsigned dcl 13-94
DSA_TERMINATED_MSG                     internal static fixed bin(8,0)           initial unsigned dcl 13-98
DSA_TERM_ABNORMAL_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 13-96
DSA_UNSPECIFIED_MSG                    internal static fixed bin(8,0)           initial unsigned dcl 13-82
DSA_USER_UNASSIGN_MSG                  internal static fixed bin(8,0)           initial unsigned dcl 13-99
Dumpinput                              internal static fixed bin(8,0)           initial dcl 11-89
Dumpoutput                             internal static fixed bin(8,0)           initial dcl 11-89
Echoplex                               internal static fixed bin(8,0)           initial dcl 11-89
Eight_bit_in                           internal static fixed bin(8,0)           initial dcl 11-89
Eight_bit_out                          internal static fixed bin(8,0)           initial dcl 11-89
Errormsg                               internal static fixed bin(8,0)           initial dcl 11-89
FIRST_BOOTLOAD_PAGEX                   internal static fixed bin(17,0)          initial dcl 3-166
FIRST_TTY_BUF_PAGEX                    internal static fixed bin(17,0)          initial dcl 3-167
Fullduplex                             internal static fixed bin(8,0)           initial dcl 11-89
Hndlquit                               internal static fixed bin(8,0)           initial dcl 11-89
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 12-14
Input_flow_control                     internal static fixed bin(8,0)           initial dcl 11-89
LINE_1050                              internal static fixed bin(17,0)          initial dcl 10-22
LINE_2741                              internal static fixed bin(17,0)          initial dcl 10-22
LINE_ARDS                              internal static fixed bin(17,0)          initial dcl 10-22
LINE_ASCII                             internal static fixed bin(17,0)          initial dcl 10-22
LINE_ASYNC1                            internal static fixed bin(17,0)          initial dcl 10-22
LINE_ASYNC2                            internal static fixed bin(17,0)          initial dcl 10-22
LINE_ASYNC3                            internal static fixed bin(17,0)          initial dcl 10-22
LINE_BSC                               internal static fixed bin(17,0)          initial dcl 10-22
LINE_DSA                               internal static fixed bin(17,0)          initial dcl 10-22
LINE_G115                              internal static fixed bin(17,0)          initial dcl 10-22
LINE_HASP_OPR                          internal static fixed bin(17,0)          initial dcl 10-22
LINE_HDLC                              internal static fixed bin(17,0)          initial dcl 10-22
LINE_MC                                internal static fixed bin(17,0)          initial dcl 10-22
LINE_POLLED_VIP                        internal static fixed bin(17,0)          initial dcl 10-22
LINE_SYNC1                             internal static fixed bin(17,0)          initial dcl 10-22
LINE_SYNC2                             internal static fixed bin(17,0)          initial dcl 10-22
LINE_SYNC3                             internal static fixed bin(17,0)          initial dcl 10-22
LINE_SYNCH                             internal static fixed bin(17,0)          initial dcl 10-22
LINE_TELNET                            internal static fixed bin(17,0)          initial dcl 10-22
LINE_UNKNOWN                           internal static fixed bin(17,0)          initial dcl 10-22
LINE_VIP                               internal static fixed bin(17,0)          initial dcl 10-22
LINE_X25LAP                            internal static fixed bin(17,0)          initial dcl 10-22
Lfecho                                 internal static fixed bin(8,0)           initial dcl 11-89
Listen                                 internal static fixed bin(8,0)           initial dcl 11-89
Lock                                   internal static fixed bin(8,0)           initial dcl 11-89
MAX_DSA_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 13-80
MAX_MCS_EVENT_MSG_TYPE                 internal static fixed bin(17,0)          initial dcl 13-46
MCS_DIALOUT_MSG                        internal static fixed bin(17,0)          initial dcl 13-54
MCS_DIALUP_MSG                         internal static fixed bin(17,0)          initial dcl 13-50
MCS_HANGUP_MSG                         internal static fixed bin(17,0)          initial dcl 13-52
MCS_LINE_STATUS_MSG                    internal static fixed bin(17,0)          initial dcl 13-62
MCS_MASKED_MSG                         internal static fixed bin(17,0)          initial dcl 13-64
MCS_MSG_TYPE_TO_PNAME                  internal static char(20)                 initial array packed unaligned dcl 13-67
MCS_QUIT_MSG                           internal static fixed bin(17,0)          initial dcl 13-56
MCS_READ_MSG                           internal static fixed bin(17,0)          initial dcl 13-58
MCS_UNSPECIFIED_MSG                    internal static fixed bin(17,0)          initial dcl 13-48
MCS_WRITE_MSG                          internal static fixed bin(17,0)          initial dcl 13-60
MOWSE_NETWORK_TYPE                     internal static fixed bin(4,0)           initial unsigned dcl 13-36
Meter                                  internal static fixed bin(8,0)           initial dcl 11-89
Msg                                    internal static fixed bin(8,0)           initial dcl 11-89
NETWORK_TYPE_VALUES                    internal static varying char(8)          initial array dcl 13-38
Nocontrol                              internal static fixed bin(8,0)           initial dcl 11-89
Odd_parity                             internal static fixed bin(8,0)           initial dcl 11-89
Output_flow_control                    internal static fixed bin(8,0)           initial dcl 11-89
Polite                                 internal static fixed bin(8,0)           initial dcl 11-89
Prefixnl                               internal static fixed bin(8,0)           initial dcl 11-89
Replay                                 internal static fixed bin(8,0)           initial dcl 11-89
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 12-21
Sensepos                               internal static fixed bin(8,0)           initial dcl 11-89
Set_buffer_size                        internal static fixed bin(8,0)           initial dcl 11-89
Setbusy                                internal static fixed bin(8,0)           initial dcl 11-89
TIMER                                  internal static fixed bin(17,0)          initial dcl 12-24
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 15-33
Tabecho                                internal static fixed bin(8,0)           initial dcl 11-89
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 12-25
Upstate                                internal static fixed bin(8,0)           initial dcl 11-89
Wru                                    internal static fixed bin(8,0)           initial dcl 11-89
Xmit_hold                              internal static fixed bin(8,0)           initial dcl 11-89
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 15-19
accept_calls                           internal static fixed bin(8,0)           initial dcl 11-24
accept_last_output                     internal static fixed bin(8,0)           initial dcl 11-24
acu_dial_failure                       internal static fixed bin(8,0)           initial dcl 11-65
acu_line_occupied                      internal static fixed bin(8,0)           initial dcl 11-65
acu_no_good                            internal static fixed bin(8,0)           initial dcl 11-65
acu_no_power                           internal static fixed bin(8,0)           initial dcl 11-65
alter_parameters                       internal static fixed bin(8,0)           initial dcl 11-24
blast                                  internal static fixed bin(8,0)           initial dcl 11-24
break_acknowledged                     internal static fixed bin(8,0)           initial dcl 11-24
bsizec                                 internal static fixed bin(17,0)          initial dcl 15-28
channel_manager$check_modes     000000 constant        entry                    external dcl 2-19
channel_manager$control         000000 constant        entry                    external dcl 2-13
channel_manager$get_modes       000000 constant        entry                    external dcl 2-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 2-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 2-31
channel_manager$read            000000 constant        entry                    external dcl 2-7
channel_manager$set_modes       000000 constant        entry                    external dcl 2-16
channel_manager$write           000000 constant        entry                    external dcl 2-10
checksum_error                         internal static fixed bin(8,0)           initial dcl 11-24
connect_to_slave                       internal static fixed bin(8,0)           initial dcl 11-65
dial                                   internal static fixed bin(8,0)           initial dcl 11-24
disconnect_accepted                    internal static fixed bin(8,0)           initial dcl 11-24
disconnect_all_lines                   internal static fixed bin(8,0)           initial dcl 11-24
dn355_messages$boot_messages           external static fixed bin(17,0)          array dcl 5-19
dn355_messages$config_messages         external static fixed bin(17,0)          array dcl 5-21
dont_accept_calls                      internal static fixed bin(8,0)           initial dcl 11-24
enter_receive                          internal static fixed bin(8,0)           initial dcl 11-24
fnp_break                              internal static fixed bin(8,0)           initial dcl 11-24
fnp_msg_ptr                            automatic       pointer                  dcl 6-5
fnp_qptr                               automatic       pointer                  dcl 7-17
free_block                             based           structure                level 1 dcl 17-23
free_blockp                            automatic       pointer                  dcl 17-20
init_complete                          internal static fixed bin(8,0)           initial dcl 11-24
init_echo_negotiation                  internal static fixed bin(8,0)           initial dcl 11-24
input_fc_chars                         internal static fixed bin(8,0)           initial dcl 11-24
io_manager$assign               000000 constant        entry                    external dcl 8-10
io_manager$assign_add           000000 constant        entry                    external dcl 8-15
io_manager$connect              000000 constant        entry                    external dcl 8-26
io_manager$connect_abs          000000 constant        entry                    external dcl 8-29
io_manager$get_status           000000 constant        entry                    external dcl 8-35
io_manager$ignore_interrupt     000000 constant        entry                    external dcl 8-41
io_manager$mask                 000000 constant        entry                    external dcl 8-38
io_manager$unassign             000000 constant        entry                    external dcl 8-20
io_manager$unassign_delete      000000 constant        entry                    external dcl 8-23
io_manager$workspace_tdcw       000000 constant        entry                    external dcl 8-47
io_manager_arg_ptr                     automatic       pointer                  dcl 8-49
lcnt                                   based           structure                level 1 dcl 9-65
lcntp                                  automatic       pointer                  dcl 9-63
lct_size                               automatic       fixed bin(17,0)          dcl 9-9
line_control                           internal static fixed bin(8,0)           initial dcl 11-24
line_types                             internal static char(16)                 initial array packed unaligned dcl 10-54
lock_ptr                               automatic       pointer                  dcl 16-9
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 17-43
max_line_type                          internal static fixed bin(17,0)          initial dcl 10-48
output_fc_chars                        internal static fixed bin(8,0)           initial dcl 11-24
qblock_size                            internal static fixed bin(17,0)          initial dcl 15-27
s6180_params                           internal static fixed bin(8,0)           initial dcl 11-65
saved_meters                           based           structure                level 1 dcl 9-68
set_delay_table                        internal static fixed bin(8,0)           initial dcl 11-24
set_framing_chars                      internal static fixed bin(8,0)           initial dcl 11-24
set_line_type                          internal static fixed bin(8,0)           initial dcl 11-24
start_negotiated_echo                  internal static fixed bin(8,0)           initial dcl 11-24
stop_negotiated_echo                   internal static fixed bin(8,0)           initial dcl 11-24
sync_msg_size                          internal static fixed bin(8,0)           initial dcl 11-24
terminal_rejected                      internal static fixed bin(8,0)           initial dcl 11-24
timer_info                             automatic       structure                level 1 dcl 12-50
tty_space_man$free_buffer       000000 constant        entry                    external dcl 18-14
tty_space_man$get_chain         000000 constant        entry                    external dcl 18-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 18-11
tty_space_man$needs_space       000000 constant        entry                    external dcl 18-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 18-17

NAMES DECLARED BY EXPLICIT CONTEXT.
check_ff                        005536 constant        entry                    internal dcl 1085 ref 1018 1046
check_lock                      007004 constant        entry                    internal dcl 1415 ref 235
dequeue                         001747 constant        entry                    internal dcl 312 ref 268
dn355                           000530 constant        entry                    external dcl 14
enough_input_space              005667 constant        entry                    internal dcl 1132 ref 959 1050
free_mbx                        006262 constant        entry                    internal dcl 1249 ref 593 601 613 620 662 680 687
                                                                                  692 698 711 1035 1070 1082
get_line_number                 006043 constant        entry                    internal dcl 1183 ref 457 479 512
global_exit                     001046 constant        label                    dcl 123 ref 1197 1223
hangup_fnp                      006512 constant        entry                    internal dcl 1330 ref 1326 1401
hangup_fnp_lines                001442 constant        entry                    external dcl 1319
interrupt                       000542 constant        entry                    external dcl 61
make_q_entry                    005717 constant        entry                    internal dcl 1145 ref 180 844 1119
match                           006246 constant        label                    dcl 1226 ref 1217
not_enough_space                005506 constant        label                    dcl 1074 ref 1055
process_accept_input            004763 constant        entry                    internal dcl 949 ref 630
process_input_in_mbx            005340 constant        entry                    internal dcl 1039 ref 667
process_int                     002007 constant        entry                    internal dcl 336 ref 113 279
process_int_queue               001510 constant        entry                    internal dcl 261 ref 105 118 243
process_interrupt_queue         001357 constant        entry                    external dcl 230
process_q                       004070 constant        entry                    internal dcl 751 ref 427 740
process_rtx                     005204 constant        entry                    internal dcl 1005 ref 726
process_send_output             004304 constant        entry                    internal dcl 817 ref 205 489 621 776
reject                          005155 constant        label                    dcl 993 ref 971
report_fnp_crash                006722 constant        entry                    internal dcl 1394 ref 402 501 719 733 1196 1222 1386
report_fnp_no_response          006672 constant        entry                    internal dcl 1382 ref 223 745
return_mbx                      006252 constant        entry                    internal dcl 1236 ref 581 636 672 989 997 1077
send_echo_table                 004707 constant        entry                    internal dcl 924 ref 210 781
send_global_wcd                 001134 constant        entry                    external dcl 154
send_join                       001155 constant        label                    dcl 159 set ref 152
send_mbx                        006255 constant        entry                    internal dcl 1236 ref 218 791 897 942
send_new_connect                006421 constant        label                    dcl 1291 ref 1269
send_wcd                        001103 constant        entry                    external dcl 139
setup                           001464 constant        entry                    internal dcl 246 ref 72 234
t_and_d_join                    002032 constant        label                    dcl 354 ref 419
test_pcw                        006270 constant        label                    dcl 1254 ref 1247
throw_away_output               006630 constant        entry                    internal dcl 1363 ref 202 591 609 705 1341
update_q_ptrs                   004274 constant        label                    dcl 806 ref 795
wait_for_response               006303 constant        label                    dcl 1264 ref 1285

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.
STORAGE REQUIREMENTS FOR THIS PROGRAM.

          Object    Text      Link      Symbol    Defs      Static
Start          0       0     10034       10124    7454       10044
Length     10772    7454        70         632     360           0

BLOCK NAME                   STACK SIZE     TYPE            WHY NONQUICK/WHO SHARES STACK FRAME
dn355                               844 external procedure  is an external procedure.  
on unit on line 235                  92 on unit
setup                                   internal procedure  shares stack frame of external procedure dn355.  
process_int_queue                       internal procedure  shares stack frame of external procedure dn355.  
dequeue                                 internal procedure  shares stack frame of external procedure dn355.  
process_int                             internal procedure  shares stack frame of external procedure dn355.  
process_q                               internal procedure  shares stack frame of external procedure dn355.  
process_send_output                     internal procedure  shares stack frame of external procedure dn355.  
send_echo_table                         internal procedure  shares stack frame of external procedure dn355.  
process_accept_input                    internal procedure  shares stack frame of external procedure dn355.  
process_rtx                             internal procedure  shares stack frame of external procedure dn355.  
check_ff                                internal procedure  shares stack frame of external procedure dn355.  
enough_input_space                      internal procedure  shares stack frame of external procedure dn355.  
make_q_entry                            internal procedure  shares stack frame of external procedure dn355.  
get_line_number                         internal procedure  shares stack frame of external procedure dn355.  
return_mbx                              internal procedure  shares stack frame of external procedure dn355.  
hangup_fnp                              internal procedure  shares stack frame of external procedure dn355.  
throw_away_output                       internal procedure  shares stack frame of external procedure dn355.  
report_fnp_no_response                  internal procedure  shares stack frame of external procedure dn355.  
report_fnp_crash                        internal procedure  shares stack frame of external procedure dn355.  
check_lock                              internal procedure  shares stack frame of on unit on line 235.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dn355                    000100 tdata                       dn355
                         000110 data_len                    dn355
                         000112 dcwlptr                     dn355
                         000114 bufp                        dn355
                         000116 qptr                        dn355
                         000120 timw                        dn355
                         000121 level                       dn355
                         000122 dno                         dn355
                         000123 i                           dn355
                         000124 ix                          dn355
                         000125 q_first                     dn355
                         000126 q_count                     dn355
                         000127 chars_left                  dn355
                         000130 numchars                    dn355
                         000131 k                           dn355
                         000132 j                           dn355
                         000133 chain_len                   dn355
                         000134 devx                        dn355
                         000135 operation                   dn355
                         000136 lano                        dn355
                         000137 fnp_name                    dn355
                         000140 no_response                 dn355
                         000141 interrupt_entry             dn355
                         000142 input_count                 dn355
                         000144 chan_lctep                  dn355
                         000146 chain_head_ptr              dn355
                         000150 output_limit                dn355
                         000151 output_chars                dn355
                         000152 bits_per_char               dn355
                         000153 max_buf_chars               dn355
                         000154 wire_arg                    dn355
                         000156 wire_ptr                    dn355
                         000160 masked                      dn355
                         000161 queue_locked                dn355
                         000162 continue                    dn355
                         000163 offset                      dn355
                         000164 syserr_severity             dn355
                         000166 auto_net_event_message      dn355
                         000170 auto_fnp_msg                dn355
                         000172 fnp_event_message           dn355
                         000174 new_qp                      dn355
                         000176 new_qrel                    dn355
                         000177 fault_type                  dn355
                         000200 fault_name                  dn355
                         000204 module_num                  dn355
                         000205 full_words                  dn355
                         000210 reason_msg                  dn355
                         000236 infop                       dn355
                         000240 fnpp                        dn355
                         000242 subp                        dn355
                         000244 mbxp                        dn355
                         000246 modulep                     dn355
                         000250 reasonp                     dn355
                         000252 lctp                        dn355
                         000254 lctep                       dn355
                         000256 interrupt_info              dn355
                         000260 dialup_info                 dn355
                         000262 rtx_info                    dn355
                         000264 net_event_message_arg       dn355
                         000266 n_pcbs                      dn355
                         000270 pcbp                        dn355
                         000272 ttybp                       dn355
                         000274 blockp                      dn355
                         000354 mbx_num                     process_send_output
                         000364 table_ptr                   send_echo_table
                         000374 tally                       process_accept_input
                         000375 buf_size                    process_accept_input
                         000376 prev_blockp                 process_accept_input
                         000410 real_word_cnt               process_rtx
                         000411 n_words                     process_rtx
                         000412 buf_size                    process_rtx
                         000414 source_ptr                  process_rtx
                         000416 target_ptr                  process_rtx
                         000450 x                           get_line_number
                         000460 mbx_no                      return_mbx
                         000461 pcw_error                   return_mbx
                         000462 timeout_time                return_mbx
                         000464 ima                         return_mbx

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              r_ne_as             r_le_a              call_ext_out_desc   call_ext_out
return_mac          stac_mac            enable_op           ext_entry           ext_entry_desc      int_entry
index_bs_1_eis      stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$interrupt     dn355_boot_interrupt          dn355_boot_interrupt$system_fault
dn355_util$compute_parity     io_manager$connect_direct     ldac                          pmut$unwire_unmask
pmut$wire_and_mask            pxss$notify                   pxss$ring_0_wakeup            pxss$unique_ring_0_wakeup
syserr                        tty_space_man$free_chain      tty_space_man$free_space      tty_space_man$get_buffer
tty_space_man$get_space

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dn355_data$                   dn355_messages$error_messages dn355_messages$fault_names    dn355_messages$per_module
pds$processid                 tc_data$fnp_buffer_threshold  tc_data$system_shutdown       tty_buf$


CONSTANTS
007046  aa     000002000000
007047  aa     000000000000
007050  aa     600000000041
007051  aa     000122000000

007052  aa     777777377777

007054  aa     000006000000
007055  aa     000000000000
007056  ta     000101000000
007057  aa     000000000000
007060  aa     600000000041
007061  aa     001210000000
007062  aa     600000000041
007063  aa     001212000000

007064  aa  777 777 777 777
007065  aa  777 777 777 777
007066  aa  777 777 000 777
007067  aa  000 000 777 777
007070  aa  777 777 777 777
007071  aa  777 777 777 777
007072  aa  777 777 777 777
007073  aa  777 777 777 777
007074  aa  777 777 777 777
007075  aa  777 777 777 777
007076  aa  777 777 777 777
007077  aa  777 777 777 777
007100  aa  777 777 777 777
007101  aa  777 777 777 777
007102  aa  777 777 777 777
007103  aa  777 777 777 777
007104  aa  777 777 777 777
007105  aa  777 777 777 777
007106  aa  777 777 777 777
007107  aa  777 777 777 777
007110  aa  777 777 777 777
007111  aa  777 777 777 777
007112  aa  777 777 777 777
007113  aa  777 777 777 777
007114  aa  777 777 777 777
007115  aa  777 777 777 777
007116  aa  777 777 777 777
007117  aa  777 777 777 777
007120  aa  777 777 777 777
007121  aa  777 777 777 777
007122  aa  777 777 777 777
007123  aa  777 777 777 777
007124  aa  777 777 777 777
007125  aa  777 777 777 777
007126  aa  777 777 777 777
007127  aa  777 777 777 777
007130  aa  777 777 777 777
007131  aa  777 777 777 777
007132  aa  777 777 777 777
007133  aa  777 777 777 777
007134  aa  777 777 777 777
007135  aa  777 777 777 777
007136  aa  777 777 777 777
007137  aa  777 777 777 777
007140  aa  777 777 777 777
007141  aa  777 777 777 777
007142  aa  777 777 777 777
007143  aa  777 777 777 777
007144  aa  777 777 777 777
007145  aa  777 777 777 777
007146  aa  777 777 777 777
007147  aa  777 777 777 777
007150  aa  777 777 777 777
007151  aa  777 777 777 777
007152  aa  777 777 777 777
007153  aa  777 777 777 777
007154  aa  777 777 777 777
007155  aa  777 777 777 777
007156  aa  777 777 777 777
007157  aa  777 777 777 777
007160  aa  777 777 777 777
007161  aa  777 777 777 777
007162  aa  777 777 777 777
007163  aa  777 777 777 777
007164  aa  777 777 777 777
007165  aa  777 777 777 777
007166  aa  777 777 777 777
007167  aa  777 777 777 777
007170  aa  777 777 777 777
007171  aa  777 777 777 777
007172  aa  777 777 777 777
007173  aa  777 777 777 777
007174  aa  777 777 777 777
007175  aa  777 777 777 777
007176  aa  777 777 777 777
007177  aa  777 777 777 777
007200  aa  777 777 777 777
007201  aa  777 777 777 777
007202  aa  777 777 777 777
007203  aa  777 777 777 777
007204  aa  777 777 777 777
007205  aa  777 777 777 777
007206  aa  777 777 777 777
007207  aa  777 777 777 777
007210  aa  777 777 777 777
007211  aa  777 777 777 777
007212  aa  777 777 777 777
007213  aa  777 777 777 777
007214  aa  777 777 777 777
007215  aa  777 777 777 777
007216  aa  777 777 777 777
007217  aa  777 777 777 777
007220  aa  777 777 777 777
007221  aa  777 777 777 777
007222  aa  777 777 777 777
007223  aa  777 777 777 777
007224  aa  777 777 777 777
007225  aa  777 777 777 777
007226  aa  777 777 777 777
007227  aa  777 777 777 777
007230  aa  777 777 777 777
007231  aa  777 777 777 777
007232  aa  777 777 777 777
007233  aa  777 777 777 777
007234  aa  777 777 777 777
007235  aa  777 777 777 777
007236  aa  777 777 777 777
007237  aa  777 777 777 777
007240  aa  777 777 777 777
007241  aa  777 777 777 777
007242  aa  777 777 777 777
007243  aa  777 777 777 777
007244  aa  777 777 777 777
007245  aa  777 777 777 777
007246  aa  777 777 777 777
007247  aa  777 777 777 777
007250  aa  777 777 777 777
007251  aa  777 777 777 777
007252  aa  777 777 777 777
007253  aa  777 777 777 777
007254  aa  777 777 777 777
007255  aa  777 777 777 777
007256  aa  777 777 777 777
007257  aa  777 777 777 777
007260  aa  777 777 777 777
007261  aa  777 777 777 777
007262  aa  777 777 777 777
007263  aa  777 777 777 777

007264  aa     777777737777

007266  aa     000004000000
007267  aa     000000000000
007270  aa     600000000041
007271  aa     000411000000
007272  aa     600000000041
007273  aa     001163000000

007274  aa     000002000000
007275  aa     000000000000
007276  aa     600000000041
007277  aa     001163000000

007300  aa     000002000000
007301  aa     000000000000
007302  aa     600000000041
007303  aa     001162000000

007304  aa     000004000000
007305  aa     000000000000
007306  aa     600000000041
007307  aa     000132000000
007310  aa     600000000041
007311  aa     001144000000

007312  aa     000002000000
007313  aa     000000000000
007314  aa     600000000041
007315  aa     000354000000

007316  aa     777777000777

007317  aa     677777777777
007320  aa     000006000000
007321  aa     000000000000
007322  ta     000101000000
007323  aa     000000000000
007324  aa     600000000041
007325  aa     001102000000
007326  aa     600000000041
007327  aa     001072000000

007330  aa     000002000000
007331  aa     000000000000
007332  aa     600000000041
007333  aa     001054000000

007334  aa     000004000000
007335  aa     000000000000
007336  aa     600000000041
007337  aa     001055000000
007340  aa     600000000041
007341  aa     001056000000

007342  aa     377777777777

007344  aa     000004000000
007345  aa     000000000000
007346  aa     600000000041
007347  aa     000666000000
007350  aa     600000000041
007351  aa     000770000000

007352  aa     577777777777

007354  aa     000002000000
007355  aa     000000000000
007356  aa     600000000041
007357  aa     000123000000

007360  aa     000004000000
007361  aa     000000000000
007362  aa     600000000041
007363  aa     000123000000
007364  aa     600000000041
007365  aa     000715000000

007366  aa     776777777777

007367  aa     777577777777

007370  aa     777757777777

007371  aa     757777777777

007372  aa     773777777777

007373  aa     767777777777

007374  aa     000004000000
007375  aa     000000000000
007376  aa     600000000041
007377  aa     000121000000
007400  aa     600000000041
007401  aa     000634000000

007402  aa     000002000000
007403  aa     000000000000
007404  aa     600000000041
007405  aa     000631000000

007406  aa     000002000000
007407  aa     000000000000
007410  aa     600000000041
007411  aa     000630000000

007412  aa     000004000000
007413  aa     000000000000
007414  aa     600000000041
007415  aa     000630000000
007416  aa     600000000041
007417  aa     000100000000

007420  aa     000004000000
007421  aa     000000000000
007422  aa     600000000041
007423  aa     000555000000
007424  aa     600000000041
007425  aa     000630000000

007426  aa     776000777777

007430  aa     000006000000
007431  aa     000000000000
007432  aa     600000000041
007433  aa     000135000000
007434  aa     600000000041
007435  aa     000110000000
007436  aa     600000000041
007437  aa     000100000000

007440  aa     777737777777

007441  aa     777677777777

007442  aa     000002000000
007443  aa     000000000000
007444  aa     600000000041
007445  aa     000121000000

007446  aa     000002000000
007447  aa     000000000000
007450  aa     600000000041
007451  aa     000555000000

000000  aa     000000000073

000001  aa     000000000015

000002  aa     000000000002
000003  aa     000000000003
000004  aa     000000000004
000005  aa     000000000011
000006  aa     000000000023
000007  aa     000000000024
000010  aa     000000000025
000011  aa     000000000044
000012  aa     000000000115

000013  aa     000000000016

000014  aa     000000000005
000015  aa     000000000006
000016  aa     000000000007
000017  aa     000000000011
000020  aa     000000000015
000021  aa     000000000016
000022  aa     000000000017
000023  aa     000000000020
000024  aa     000000000021
000025  aa     000000000022

000026  aa     000000000156
000027  aa     000000000205
000030  aa     000000000226
000031  aa     000000000454
000032  aa     000000001130
000033  aa     000000002260
000034  aa     000000003410
000035  aa     000000004540
000036  aa     000000011300
000037  aa     000000016040
000040  aa     000000022600
000041  aa     000000045400
000042  aa     000000117540
000043  aa     000000141520
000044  aa     000000214500

007452  aa  014 000 000 000

000045  aa  014 015 012 000



000046  aa     000000000000
000047  aa     000007502200

000050  aa     000000000071

000051  aa     524000000112

000052  aa     524000000062

000053  aa     524000000103

000054  aa     524000000057

000055  aa     516000000440

000056  aa     406000000021

000057  aa     524000000051

000060  aa     524000000077

000061  aa     404000000006

000062  aa     514000000001

000063  aa     524000000102

000064  aa     524000000134

000065  aa     000000000013

000066  aa     404000000012

000067  aa     406000000010

000070  aa     524000000071

000071  aa     526000000000

000072  aa     524000000014

000073  aa     524000000006

007453  aa     777777777777

000074  aa     606000000022

000075  aa     524000000035

000076  aa     526000000020

000077  aa     526000000001

000100  aa     524000000052

000101  aa     000000000012
000102  aa     000000000006

000103  aa     000000000021

000104  aa     524000000036

000105  aa     524000000050

000106  aa     000000000007

000107  aa     524000000001

000110  aa     524000000124

000111  aa     400000000000

000112  aa     000000000000

000113  aa     000000000004

000114  aa     000000000010

000115  aa     000000000072

000116  aa     516000000044

000117  aa     404000000030

000120  aa     000000000011

000121  aa     404000000021

000122  aa     516000000001

000123  aa     516077777777

000124  aa     404000000010

000125  aa     464000000000

000126  aa     000000000003

000127  aa     514000000044

000130  aa     404000000003

000131  aa     000000000001

000132  aa     404000000043

000134  aa     000000000000
000135  aa     167153120000

000136  aa  136 141 072 040   ^a: 
000137  aa  136 141 000 000   ^a

000140  aa     000000000000
000141  aa     000000000000

000142  aa     077777000043
000143  aa     000001000000

000144  aa  143 154 145 141   clea
000145  aa  156 165 160 000   nup

000146  aa     404100000021
000147  aa     000000000001
000150  aa     000000000003
000151  aa     000000000001

000152  aa  165 156 153 156   unkn
000153  aa  157 167 156 040   own 
000154  aa  146 141 165 154   faul
000155  aa  164 000 000 000   t

000156  aa  144 156 063 065   dn35
000157  aa  065 072 040 115   5: M
000160  aa  145 163 163 141   essa
000161  aa  147 145 040 146   ge f
000162  aa  162 157 155 040   rom 
000163  aa  106 116 120 040   FNP 
000164  aa  136 141 072 040   ^a: 

000165  aa  165 156 162 145   unre
000166  aa  143 157 147 156   cogn
000167  aa  151 172 145 144   ized
000170  aa  040 145 162 162    err
000171  aa  157 162 040 136   or ^
000172  aa  157 040 136 157   o ^o
000173  aa  040 136 157 000    ^o

000174  aa  143 150 141 156   chan
000175  aa  156 145 154 040   nel 
000176  aa  136 157 054 040   ^o, 
000177  aa  146 141 165 154   faul
000200  aa  164 040 163 164   t st
000201  aa  141 164 165 163   atus
000202  aa  040 075 040 136    = ^
000203  aa  066 157 000 000   6o

000204  aa  106 116 120 040   FNP 
000205  aa  151 156 163 164   inst
000206  aa  162 165 143 164   ruct
000207  aa  151 157 156 040   ion 
000210  aa  143 157 165 156   coun
000211  aa  164 145 162 040   ter 
000212  aa  075 040 136 066   = ^6
000213  aa  157 000 000 000   o

000214  aa  144 156 063 065   dn35
000215  aa  065 072 040 114   5: L
000216  aa  103 124 105 040   CTE 
000217  aa  154 157 143 153   lock
000220  aa  040 136 136 075    ^^=
000221  aa  040 160 162 157    pro
000222  aa  143 145 163 163   cess
000223  aa  151 144 000 000   id

000224  aa  144 156 063 065   dn35
000225  aa  065 072 040 151   5: i
000226  aa  156 143 157 156   ncon
000227  aa  163 151 163 164   sist
000230  aa  145 156 164 040   ent 
000231  aa  161 165 145 165   queu
000232  aa  145 040 154 157   e lo
000233  aa  143 153 000 000   ck

000234  aa  144 156 063 065   dn35
000235  aa  065 072 040 106   5: F
000236  aa  116 120 040 136   NP ^
000237  aa  141 040 151 156   a in
000240  aa  166 141 154 151   vali
000241  aa  144 040 151 156   d in
000242  aa  164 145 162 162   terr
000243  aa  165 160 164 040   upt 
000244  aa  154 145 166 145   leve
000245  aa  154 040 136 157   l ^o

000246  aa  144 156 063 065   dn35
000247  aa  065 072 040 157   5: o
000250  aa  165 164 160 165   utpu
000251  aa  164 040 142 165   t bu
000252  aa  146 146 145 162   ffer
000253  aa  040 141 164 040    at 
000254  aa  136 157 040 150   ^o h
000255  aa  141 163 040 172   as z
000256  aa  145 162 157 040   ero 
000257  aa  164 141 154 154   tall
000260  aa  171 000 000 000   y

000261  aa  144 156 063 065   dn35
000262  aa  065 072 040 145   5: e
000263  aa  155 145 162 147   merg
000264  aa  145 156 143 171   ency
000265  aa  040 151 156 164    int
000266  aa  145 162 162 165   erru
000267  aa  160 164 040 146   pt f
000270  aa  162 157 155 040   rom 
000271  aa  106 116 120 040   FNP 
000272  aa  136 141 072 040   ^a: 
000273  aa  136 141 000 000   ^a

000274  aa  144 156 063 065   dn35
000275  aa  065 072 040 141   5: a
000276  aa  164 164 145 155   ttem
000277  aa  160 164 145 144   pted
000300  aa  040 143 162 141    cra
000301  aa  167 154 157 165   wlou
000302  aa  164 040 167 151   t wi
000303  aa  164 150 040 106   th F
000304  aa  116 120 040 161   NP q
000305  aa  165 145 165 145   ueue
000306  aa  040 154 157 143    loc
000307  aa  153 145 144 000   ked

000310  aa  144 156 063 065   dn35
000311  aa  065 072 040 165   5: u
000312  aa  156 141 142 154   nabl
000313  aa  145 040 164 157   e to
000314  aa  040 141 154 154    all
000315  aa  157 143 141 164   ocat
000316  aa  145 040 142 154   e bl
000317  aa  157 143 153 040   ock 
000320  aa  146 157 162 040   for 
000321  aa  144 145 154 141   dela
000322  aa  171 040 161 165   y qu
000323  aa  145 165 145 000   eue

000324  aa  144 156 063 065   dn35
000325  aa  065 072 040 106   5: F
000326  aa  116 120 040 136   NP ^
000327  aa  141 040 144 151   a di
000330  aa  144 040 156 157   d no
000331  aa  164 040 162 145   t re
000332  aa  163 160 157 156   spon
000333  aa  144 040 164 157   d to
000334  aa  040 155 141 151    mai
000335  aa  154 142 157 170   lbox
000336  aa  040 151 156 164    int
000337  aa  145 162 162 165   erru
000340  aa  160 164 000 000   pt

000341  aa  144 156 063 065   dn35
000342  aa  065 072 040 156   5: n
000343  aa  157 040 163 154   o sl
000344  aa  157 164 040 156   ot n
000345  aa  165 155 142 145   umbe
000346  aa  162 040 155 141   r ma
000347  aa  164 143 150 040   tch 
000350  aa  146 157 162 040   for 
000351  aa  163 165 142 040   sub 
000352  aa  155 142 170 040   mbx 
000353  aa  136 157 054 040   ^o, 
000354  aa  106 116 120 040   FNP 
000355  aa  136 141 000 000   ^a

000356  aa  144 156 063 065   dn35
000357  aa  065 072 040 165   5: u
000360  aa  156 162 145 143   nrec
000361  aa  157 147 156 151   ogni
000362  aa  172 145 144 040   zed 
000363  aa  151 157 040 143   io c
000364  aa  157 155 155 141   omma
000365  aa  156 144 040 136   nd ^
000366  aa  157 040 146 162   o fr
000367  aa  157 155 040 106   om F
000370  aa  116 120 040 136   NP ^
000371  aa  141 040 146 157   a fo
000372  aa  162 040 154 151   r li
000373  aa  156 145 040 136   ne ^
000374  aa  157 000 000 000   o

000375  aa  144 156 063 065   dn35
000376  aa  065 072 040 165   5: u
000377  aa  156 162 145 143   nrec
000400  aa  157 147 156 151   ogni
000401  aa  172 145 144 040   zed 
000402  aa  157 160 040 143   op c
000403  aa  157 144 145 040   ode 
000404  aa  136 157 040 167   ^o w
000405  aa  151 164 150 040   ith 
000406  aa  162 143 144 040   rcd 
000407  aa  146 162 157 155   from
000410  aa  040 106 116 120    FNP
000411  aa  040 136 141 040    ^a 
000412  aa  146 157 162 040   for 
000413  aa  144 145 166 170   devx
000414  aa  040 136 157 000    ^o

000415  aa  144 156 063 065   dn35
000416  aa  065 072 040 154   5: l
000417  aa  151 156 145 040   ine 
000420  aa  156 165 155 142   numb
000421  aa  145 162 040 157   er o
000422  aa  146 040 060 040   f 0 
000423  aa  167 151 164 150   with
000424  aa  040 156 157 156    non
000425  aa  055 147 154 157   -glo
000426  aa  142 141 154 040   bal 
000427  aa  157 160 143 157   opco
000430  aa  144 145 040 151   de i
000431  aa  156 040 163 165   n su
000432  aa  142 155 142 170   bmbx
000433  aa  040 136 157 054    ^o,
000434  aa  040 106 116 120    FNP
000435  aa  040 136 141 000    ^a

000436  aa  144 156 063 065   dn35
000437  aa  065 072 040 106   5: F
000440  aa  116 120 040 155   NP m
000441  aa  141 163 153 145   aske
000442  aa  144 040 143 150   d ch
000443  aa  141 156 156 145   anne
000444  aa  154 040 136 141   l ^a
000445  aa  056 150 136 144   .h^d
000446  aa  136 133 060 136   ^[0^
000447  aa  073 136 135 136   ;^]^
000450  aa  144 040 146 157   d fo
000451  aa  162 040 145 170   r ex
000452  aa  143 145 163 163   cess
000453  aa  151 166 145 040   ive 
000454  aa  151 156 164 145   inte
000455  aa  162 162 165 160   rrup
000456  aa  164 163 000 000   ts

000457  aa  144 156 063 065   dn35
000460  aa  065 072 040 136   5: ^
000461  aa  133 105 162 162   [Err
000462  aa  157 162 136 073   or^;
000463  aa  124 151 155 145   Time
000464  aa  157 165 164 136   out^
000465  aa  135 040 163 145   ] se
000466  aa  156 144 151 156   ndin
000467  aa  147 040 155 141   g ma
000470  aa  151 154 142 157   ilbo
000471  aa  170 040 151 156   x in
000472  aa  164 145 162 162   terr
000473  aa  165 160 164 040   upt 
000474  aa  164 157 040 106   to F
000475  aa  116 120 040 136   NP ^
000476  aa  141 054 040 167   a, w
000477  aa  151 154 154 040   ill 
000500  aa  162 145 164 162   retr
000501  aa  171 056 000 000   y.

000502  aa  144 156 063 065   dn35
000503  aa  065 072 040 106   5: F
000504  aa  116 120 040 136   NP ^
000505  aa  141 040 154 145   a le
000506  aa  166 145 154 040   vel 
000507  aa  136 144 040 163   ^d s
000510  aa  164 141 164 165   tatu
000511  aa  163 040 136 167   s ^w
000512  aa  136 133 040 162   ^[ r
000513  aa  165 156 156 151   unni
000514  aa  156 147 136 135   ng^]
000515  aa  136 133 040 142   ^[ b
000516  aa  157 157 164 154   ootl
000517  aa  157 141 144 151   oadi
000520  aa  156 147 136 135   ng^]
000521  aa  136 133 040 164   ^[ t
000522  aa  137 141 156 144   _and
000523  aa  137 144 137 151   _d_i
000524  aa  156 137 160 162   n_pr
000525  aa  157 147 162 145   ogre
000526  aa  163 163 136 135   ss^]

BEGIN PROCEDURE dn355
ENTRY TO dn355                                              STATEMENT 1 ON LINE 14
dn355:
     procedure;

000527  da     000305200000
000530  aa   001520 6270 00   eax7      848
000531  aa  7 00034 3521 20   epp2      pr7|28,*
000532  aa  2 01045 2721 00   tsp2      pr2|549             ext_entry
000533  aa     000000000000
000534  aa     000000000000
                                                            STATEMENT 1 ON LINE 16
          return;

000535  aa  0 00631 7101 00   tra       pr0|409             return_mac
ENTRY TO interrupt                                          STATEMENT 1 ON LINE 61
interrupt:
     entry (x_dno, x_level, x_status);

000536  at     000003000132
000537  tt     000130000127
000540  ta     000536000000
000541  da     000310300000
000542  aa   001520 6270 00   eax7      848
000543  aa  7 00034 3521 20   epp2      pr7|28,*
000544  aa  2 01045 2721 00   tsp2      pr2|549             ext_entry
000545  aa     000006000000
000546  aa     000000000000
                                                            STATEMENT 1 ON LINE 68
          if tc_data$system_shutdown ^= 0
          then return;

000547  aa  6 00044 3701 20   epp4      pr6|36,*
000550  la  4 00010 2361 20   ldq       pr4|8,*             tc_data$system_shutdown
000551  aa  0 00631 6011 00   tnz       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 70
          interrupt_entry = "1"b;

000552  aa   400000 2350 03   lda       131072,du
000553  aa  6 00141 7551 00   sta       pr6|97              interrupt_entry
                                                            STATEMENT 1 ON LINE 72
          call setup;

000554  aa   000710 6700 04   tsp4      456,ic              001464
                                                            STATEMENT 1 ON LINE 73
          level = x_level;

000555  aa  6 00032 3735 20   epp7      pr6|26,*
000556  aa  7 00004 2361 20   ldq       pr7|4,*             x_level
000557  aa  6 00121 7561 00   stq       pr6|81              level
                                                            STATEMENT 1 ON LINE 74
          if datanet_info.trace
          then do;

000560  aa  6 00236 3715 20   epp5      pr6|158,*           infop
000561  aa  5 00005 2351 00   lda       pr5|5               datanet_info.trace
000562  aa   000071 6000 04   tze       57,ic               000653
                                                            STATEMENT 1 ON LINE 76
               if level ^= 3 | ^fnp_info.running
               then syserr_severity = just_tell;

000563  aa   000003 1160 07   cmpq      3,dl
000564  aa   000005 6010 04   tnz       5,ic                000571
000565  aa  6 00240 3535 20   epp3      pr6|160,*           fnpp
000566  aa  3 00030 2351 00   lda       pr3|24              fnp_info.running
000567  aa   100000 3150 03   cana      32768,du
000570  aa   000004 6010 04   tnz       4,ic                000574
000571  aa   000000 2360 07   ldq       0,dl
000572  aa  6 00164 7561 00   stq       pr6|116             syserr_severity
000573  aa   000003 7100 04   tra       3,ic                000576
                                                            STATEMENT 1 ON LINE 78
               else syserr_severity = log;

000574  aa   000004 2360 07   ldq       4,dl
000575  aa  6 00164 7561 00   stq       pr6|116             syserr_severity
                                                            STATEMENT 1 ON LINE 79
               call syserr (syserr_severity,
                    "dn355: FNP ^a level ^d status ^w^[ running^]^[ bootloading^]^[ t_and_d_in_progress^]", fnp_name,
                    level, x_status, fnp_info.running, fnp_info.bootloading, fnp_info.t_and_d_in_progress);

000576  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
000577  aa   777704 00 0124   desc9a    -60,84              000502 = 144156063065
000600  aa  6 00530 00 0124   desc9a    pr6|344,84
000601  aa  6 00164 3521 00   epp2      pr6|116             syserr_severity
000602  aa  6 00560 2521 00   spri2     pr6|368
000603  aa  6 00530 3521 00   epp2      pr6|344
000604  aa  6 00562 2521 00   spri2     pr6|370
000605  aa  6 00137 3521 00   epp2      pr6|95              fnp_name
000606  aa  6 00564 2521 00   spri2     pr6|372
000607  aa  6 00121 3521 00   epp2      pr6|81              level
000610  aa  6 00566 2521 00   spri2     pr6|374
000611  aa  7 00006 3521 20   epp2      pr7|6,*             x_status
000612  aa  6 00570 2521 00   spri2     pr6|376
000613  aa   000002 7270 07   lxl7      2,dl
000614  aa  6 00240 3535 20   epp3      pr6|160,*           fnpp
000615  aa  3 00030 3521 00   epp2      pr3|24              fnp_info.running
000616  aa  2 00000 5035 17   abd       pr2|0,7
000617  aa  6 00572 2521 00   spri2     pr6|378
000620  aa   000001 7260 07   lxl6      1,dl
000621  aa  3 00030 3521 00   epp2      pr3|24              fnp_info.bootloading
000622  aa  2 00000 5035 16   abd       pr2|0,6
000623  aa  6 00574 2521 00   spri2     pr6|380
000624  aa   000010 7250 07   lxl5      8,dl
000625  aa  3 00030 3521 00   epp2      pr3|24              fnp_info.t_and_d_in_progress
000626  aa  2 00000 5035 15   abd       pr2|0,5
000627  aa  6 00576 2521 00   spri2     pr6|382
000630  aa   777302 3520 04   epp2      -318,ic             000132 = 404000000043
000631  aa  6 00600 2521 00   spri2     pr6|384
000632  aa   777256 3520 04   epp2      -338,ic             000110 = 524000000124
000633  aa  6 00602 2521 00   spri2     pr6|386
000634  aa   777253 3520 04   epp2      -341,ic             000107 = 524000000001
000635  aa  6 00604 2521 00   spri2     pr6|388
000636  aa   777263 3520 04   epp2      -333,ic             000121 = 404000000021
000637  aa  6 00606 2521 00   spri2     pr6|390
000640  aa   777267 3520 04   epp2      -329,ic             000127 = 514000000044
000641  aa  6 00610 2521 00   spri2     pr6|392
000642  aa   777260 3520 04   epp2      -336,ic             000122 = 516000000001
000643  aa  6 00612 2521 00   spri2     pr6|394
000644  aa  6 00614 2521 00   spri2     pr6|396
000645  aa  6 00616 2521 00   spri2     pr6|398
000646  aa  6 00556 6211 00   eax1      pr6|366
000647  aa   040000 4310 07   fld       16384,dl
000650  aa  6 00044 3701 20   epp4      pr6|36,*
000651  la  4 00016 3521 20   epp2      pr4|14,*            syserr
000652  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 82
          end;

                                                            STATEMENT 1 ON LINE 83
          if level ^= 3 & level ^= 7
          then do;

000653  aa  6 00121 2361 00   ldq       pr6|81              level
000654  aa   000003 1160 07   cmpq      3,dl
000655  aa   000051 6000 04   tze       41,ic               000726
000656  aa   000007 1160 07   cmpq      7,dl
000657  aa   000047 6000 04   tze       39,ic               000726
                                                            STATEMENT 1 ON LINE 85
               call syserr (beeper, "dn355: FNP ^a invalid interrupt level ^o", fnp_name, level);

000660  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
000661  aa   777354 00 0050   desc9a    -276,40             000234 = 144156063065
000662  aa  6 00530 00 0050   desc9a    pr6|344,40
000663  aa   777243 3520 04   epp2      -349,ic             000126 = 000000000003
000664  aa  6 00560 2521 00   spri2     pr6|368
000665  aa  6 00530 3521 00   epp2      pr6|344
000666  aa  6 00562 2521 00   spri2     pr6|370
000667  aa  6 00137 3521 00   epp2      pr6|95              fnp_name
000670  aa  6 00564 2521 00   spri2     pr6|372
000671  aa  6 00121 3521 00   epp2      pr6|81              level
000672  aa  6 00566 2521 00   spri2     pr6|374
000673  aa   777226 3520 04   epp2      -362,ic             000121 = 404000000021
000674  aa  6 00570 2521 00   spri2     pr6|376
000675  aa  6 00576 2521 00   spri2     pr6|382
000676  aa   777207 3520 04   epp2      -377,ic             000105 = 524000000050
000677  aa  6 00572 2521 00   spri2     pr6|378
000700  aa   777207 3520 04   epp2      -377,ic             000107 = 524000000001
000701  aa  6 00574 2521 00   spri2     pr6|380
000702  aa  6 00556 6211 00   eax1      pr6|366
000703  aa   020000 4310 07   fld       8192,dl
000704  aa  6 00044 3701 20   epp4      pr6|36,*
000705  la  4 00016 3521 20   epp2      pr4|14,*            syserr
000706  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 86
               if fnp_info.bootloading
               then if level = 1                            /* system fault */
                    then call dn355_boot_interrupt$system_fault (dno);

000707  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
000710  aa  7 00030 2351 00   lda       pr7|24              fnp_info.bootloading
000711  aa   200000 3150 03   cana      65536,du
000712  aa   000013 6000 04   tze       11,ic               000725
000713  aa  6 00121 2361 00   ldq       pr6|81              level
000714  aa   000001 1160 07   cmpq      1,dl
000715  aa   000010 6010 04   tnz       8,ic                000725
000716  aa  6 00122 3521 00   epp2      pr6|82              dno
000717  aa  6 00532 2521 00   spri2     pr6|346
000720  aa  6 00530 6211 00   eax1      pr6|344
000721  aa   004000 4310 07   fld       2048,dl
000722  aa  6 00044 3701 20   epp4      pr6|36,*
000723  la  4 00026 3521 20   epp2      pr4|22,*            dn355_boot_interrupt$system_fault
000724  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 89
               return;

000725  aa  0 00631 7101 00   tra       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 90
          end;

                                                            STATEMENT 1 ON LINE 92
          if (^fnp_info.t_and_d_in_progress) & (^fnp_info.running) & (^fnp_info.bootloading)
          then return;

000726  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
000727  aa  7 00030 2351 00   lda       pr7|24              fnp_info.bootloading
000730  aa   301000 3150 03   cana      98816,du
000731  aa  0 00631 6001 00   tze       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 95
          if ^stac (addr (lcte.lock), pds$processid)        /* somebody else has it */
          then do;

000732  aa  6 00254 3715 20   epp5      pr6|172,*           lcte.lock
000733  aa  6 00620 6515 00   spri5     pr6|400
000734  aa  6 00044 3701 20   epp4      pr6|36,*
000735  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
000736  aa  5 00000 3521 00   epp2      pr5|0
000737  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
000740  aa   000066 6010 04   tnz       54,ic               001026
                                                            STATEMENT 1 ON LINE 98
               do while (^stac (addr (fnp_info.queue_lock), pds$processid));

000741  aa   000000 0110 03   nop       0,du
000742  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
000743  aa  7 00043 3735 00   epp7      pr7|35              fnp_info.queue_lock
000744  aa  6 00622 6535 00   spri7     pr6|402
000745  aa  6 00044 3701 20   epp4      pr6|36,*
000746  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
000747  aa  7 00000 3521 00   epp2      pr7|0
000750  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
000751  aa   000002 6010 04   tnz       2,ic                000753
                                                            STATEMENT 1 ON LINE 99
               end;

000752  aa   777770 7100 04   tra       -8,ic               000742
                                                            STATEMENT 1 ON LINE 101
               if level = 7
               then fnp_info.level_7_pending = "1"b;

000753  aa  6 00121 2361 00   ldq       pr6|81              level
000754  aa   000007 1160 07   cmpq      7,dl
000755  aa   000005 6010 04   tnz       5,ic                000762
000756  aa   004000 2350 03   lda       2048,du
000757  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
000760  aa  5 00030 2551 00   orsa      pr5|24              fnp_info.level_7_pending
000761  aa   000004 7100 04   tra       4,ic                000765
                                                            STATEMENT 1 ON LINE 103
               else fnp_info.level_3_pending = "1"b;

000762  aa   010000 2350 03   lda       4096,du
000763  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
000764  aa  5 00030 2551 00   orsa      pr5|24              fnp_info.level_3_pending
                                                            STATEMENT 1 ON LINE 105
               if stac (addr (lcte.lock), pds$processid)    /* in case it got unlocked meanwhile */
               then call process_int_queue ("0"b);

000765  aa  6 00254 3535 20   epp3      pr6|172,*           lcte.lock
000766  aa  6 00624 2535 00   spri3     pr6|404
000767  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
000770  aa  3 00000 3521 00   epp2      pr3|0
000771  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
000772  aa   000006 6000 04   tze       6,ic                001000
000773  aa   000000 2350 07   lda       0,dl
000774  aa  6 00555 7551 00   sta       pr6|365
000775  aa   006451 3520 04   epp2      3369,ic             007446 = 000002000000
000776  aa   000512 6700 04   tsp4      330,ic              001510
000777  aa   000046 7100 04   tra       38,ic               001045
                                                            STATEMENT 1 ON LINE 108
               else if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
               then call syserr (crash_system, "dn355: inconsistent queue lock");

001000  aa   000000 2350 07   lda       0,dl
001001  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
001002  aa  5 00043 3521 00   epp2      pr5|35              fnp_info.queue_lock
001003  la  4 00014 2361 20   ldq       pr4|12,*            pds$processid
001004  aa  0 01434 7001 00   tsx0      pr0|796             stacq_mac
001005  aa   000040 6010 04   tnz       32,ic               001045
001006  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
001007  aa   777216 00 0040   desc9a    -370,32             000224 = 144156063065
001010  aa  6 00530 00 0040   desc9a    pr6|344,32
001011  aa   777120 3520 04   epp2      -432,ic             000131 = 000000000001
001012  aa  6 00560 2521 00   spri2     pr6|368
001013  aa  6 00530 3521 00   epp2      pr6|344
001014  aa  6 00562 2521 00   spri2     pr6|370
001015  aa   777104 3520 04   epp2      -444,ic             000121 = 404000000021
001016  aa  6 00564 2521 00   spri2     pr6|372
001017  aa   777065 3520 04   epp2      -459,ic             000104 = 524000000036
001020  aa  6 00566 2521 00   spri2     pr6|374
001021  aa  6 00556 6211 00   eax1      pr6|366
001022  aa   010000 4310 07   fld       4096,dl
001023  la  4 00016 3521 20   epp2      pr4|14,*            syserr
001024  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 110
          end;

001025  aa   000020 7100 04   tra       16,ic               001045
                                                            STATEMENT 1 ON LINE 112
          else do;

                                                            STATEMENT 1 ON LINE 113
               call process_int (level);

001026  aa   006414 3520 04   epp2      3340,ic             007442 = 000002000000
001027  aa   000760 6700 04   tsp4      496,ic              002007
                                                            STATEMENT 1 ON LINE 115
               do while (^stac (addr (fnp_info.queue_lock), pds$processid));

001030  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001031  aa  7 00043 3735 00   epp7      pr7|35              fnp_info.queue_lock
001032  aa  6 00626 6535 00   spri7     pr6|406
001033  aa  6 00044 3701 20   epp4      pr6|36,*
001034  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
001035  aa  7 00000 3521 00   epp2      pr7|0
001036  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
001037  aa   000002 6010 04   tnz       2,ic                001041
                                                            STATEMENT 1 ON LINE 116
               end;

001040  aa   777770 7100 04   tra       -8,ic               001030
                                                            STATEMENT 1 ON LINE 118
               call process_int_queue ("0"b);

001041  aa   000000 2350 07   lda       0,dl
001042  aa  6 00555 7551 00   sta       pr6|365
001043  aa   006403 3520 04   epp2      3331,ic             007446 = 000002000000
001044  aa   000444 6700 04   tsp4      292,ic              001510
                                                            STATEMENT 1 ON LINE 119
          end;

                                                            STATEMENT 1 ON LINE 121
          return;

001045  aa  0 00631 7101 00   tra       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 123
global_exit:                                                /* if abort out of an internal proc */
          if interrupt_entry
          then do;

001046  aa  6 00141 2351 00   lda       pr6|97              interrupt_entry
001047  aa   000026 6000 04   tze       22,ic               001075
                                                            STATEMENT 1 ON LINE 126
               if stacq (lcte.lock, "0"b, pds$processid)    /* make sure we undo anything we did */
               then if lcte.notify_reqd
                    then do;
001050  aa   000000 2350 07   lda       0,dl
001051  aa  6 00254 3521 20   epp2      pr6|172,*           lcte.lock
001052  aa  6 00044 3701 20   epp4      pr6|36,*
001053  la  4 00014 2361 20   ldq       pr4|12,*            pds$processid
001054  aa  0 01434 7001 00   tsx0      pr0|796             stacq_mac
001055  aa   000015 6000 04   tze       13,ic               001072
001056  aa  6 00254 3735 20   epp7      pr6|172,*           lctep
001057  aa  7 00002 2351 00   lda       pr7|2               lcte.notify_reqd
001060  aa   000100 3150 03   cana      64,du
001061  aa   000011 6000 04   tze       9,ic                001072
                                                            STATEMENT 1 ON LINE 129
                         lcte.notify_reqd = "0"b;

001062  aa   006357 2350 04   lda       3311,ic             007441 = 777677777777
001063  aa  7 00002 3551 00   ansa      pr7|2               lcte.notify_reqd
                                                            STATEMENT 1 ON LINE 130
                         call pxss$notify (tty_ev);

001064  aa   776764 3520 04   epp2      -524,ic             000050 = 000000000071
001065  aa  6 00532 2521 00   spri2     pr6|346
001066  aa  6 00530 6211 00   eax1      pr6|344
001067  aa   004000 4310 07   fld       2048,dl
001070  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
001071  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 131
                    end;

                                                            STATEMENT 1 ON LINE 133
               lcte.locked_for_interrupt = "0"b;

001072  aa   006346 2350 04   lda       3302,ic             007440 = 777737777777
001073  aa  6 00254 3735 20   epp7      pr6|172,*           lctep
001074  aa  7 00002 3551 00   ansa      pr7|2               lcte.locked_for_interrupt
                                                            STATEMENT 1 ON LINE 135
          end;

                                                            STATEMENT 1 ON LINE 136
          return;

001075  aa  0 00631 7101 00   tra       pr0|409             return_mac
ENTRY TO send_wcd                                           STATEMENT 1 ON LINE 139
send_wcd:
     entry (a_fnpp, a_pcbp, opa, chrsa, data);

001076  at     000005000125
001077  tt     000125000124
001100  tt     000124000123
001101  ta     001076000000
001102  da     000316300000
001103  aa   001520 6270 00   eax7      848
001104  aa  7 00034 3521 20   epp2      pr7|28,*
001105  aa  2 01046 2721 00   tsp2      pr2|550             ext_entry_desc
001106  aa     000012000000
001107  aa     000000000000
001110  aa  6 00032 3735 20   epp7      pr6|26,*
001111  aa  7 00006 3715 20   epp5      pr7|6,*
001112  aa  6 00276 6515 00   spri5     pr6|190
001113  aa  7 00010 3535 20   epp3      pr7|8,*
001114  aa  6 00304 2535 00   spri3     pr6|196
001115  aa  7 00012 3515 20   epp1      pr7|10,*
001116  aa  6 00302 2515 00   spri1     pr6|194
001117  aa  6 00042 3715 20   epp5      pr6|34,*
001120  aa  5 00010 3535 20   epp3      pr5|8,*
001121  aa  6 00300 2535 00   spri3     pr6|192
                                                            STATEMENT 1 ON LINE 151
          pcbp = a_pcbp;

001122  aa  6 00032 3735 20   epp7      pr6|26,*
001123  aa  7 00004 3715 20   epp5      pr7|4,*             a_pcbp
001124  aa  5 00000 3715 20   epp5      pr5|0,*             a_pcbp
001125  aa  6 00270 6515 00   spri5     pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 152
          go to send_join;

001126  aa   000027 7100 04   tra       23,ic               001155
ENTRY TO send_global_wcd                                    STATEMENT 1 ON LINE 154
send_global_wcd:
     entry (a_fnpp, opa, chrsa, data);

001127  at     000004000125
001130  tt     000124000124
001131  ta     000123000000
001132  ta     001127000000
001133  da     000325300000
001134  aa   001520 6270 00   eax7      848
001135  aa  7 00034 3521 20   epp2      pr7|28,*
001136  aa  2 01046 2721 00   tsp2      pr2|550             ext_entry_desc
001137  aa     000010000000
001140  aa     000000000000
001141  aa  6 00032 3735 20   epp7      pr6|26,*
001142  aa  7 00004 3715 20   epp5      pr7|4,*
001143  aa  6 00276 6515 00   spri5     pr6|190
001144  aa  7 00006 3535 20   epp3      pr7|6,*
001145  aa  6 00304 2535 00   spri3     pr6|196
001146  aa  7 00010 3515 20   epp1      pr7|8,*
001147  aa  6 00302 2515 00   spri1     pr6|194
001150  aa  6 00042 3715 20   epp5      pr6|34,*
001151  aa  5 00006 3535 20   epp3      pr5|6,*
001152  aa  6 00300 2535 00   spri3     pr6|192
                                                            STATEMENT 1 ON LINE 157
          pcbp = null ();

001153  aa   776767 2370 04   ldaq      -521,ic             000142 = 077777000043 000001000000
001154  aa  6 00270 7571 00   staq      pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 159
send_join:
          interrupt_entry = "0"b;

001155  aa  6 00141 4501 00   stz       pr6|97              interrupt_entry
                                                            STATEMENT 1 ON LINE 161
          fnpp = a_fnpp;

001156  aa  6 00032 3735 20   epp7      pr6|26,*
001157  aa  7 00002 3715 20   epp5      pr7|2,*             a_fnpp
001160  aa  5 00000 3715 20   epp5      pr5|0,*             a_fnpp
001161  aa  6 00240 6515 00   spri5     pr6|160             fnpp
                                                            STATEMENT 1 ON LINE 162
          ttybp = addr (tty_buf$);
001162  aa  6 00044 3701 20   epp4      pr6|36,*
001163  la  4 00056 3535 20   epp3      pr4|46,*            tty_buf$
001164  aa  6 00272 2535 00   spri3     pr6|186             ttybp
                                                            STATEMENT 1 ON LINE 163
          infop = addr (dn355_data$);

001165  la  4 00044 3515 20   epp1      pr4|36,*            dn355_data$
001166  aa  6 00236 2515 00   spri1     pr6|158             infop
                                                            STATEMENT 1 ON LINE 164
          lctep = fnp_info.lcte_ptr;

001167  aa  5 00032 3535 20   epp3      pr5|26,*            fnp_info.lcte_ptr
001170  aa  6 00254 2535 00   spri3     pr6|172             lctep
                                                            STATEMENT 1 ON LINE 165
          operation = opa;

001171  aa  6 00276 2361 20   ldq       pr6|190,*           opa
001172  aa  6 00135 7561 00   stq       pr6|93              operation
                                                            STATEMENT 1 ON LINE 166
          if ^fnp_info.running                              /* can't talk to it if it's not listening */
          then return;

001173  aa  5 00030 2351 00   lda       pr5|24              fnp_info.running
001174  aa   100000 3150 03   cana      32768,du
001175  aa  0 00631 6001 00   tze       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 169
          no_response = "0"b;

001176  aa  6 00140 4501 00   stz       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 170
          dno = fnp_info.fnp_number;

001177  aa  5 00007 2351 00   lda       pr5|7               fnp_info.fnp_number
001200  aa   000011 7350 00   als       9
001201  aa   000077 7730 00   lrl       63
001202  aa  6 00122 7561 00   stq       pr6|82              dno
                                                            STATEMENT 1 ON LINE 171
          mbxp = fnp_info.mbx_pt;

001203  aa  5 00000 3515 20   epp1      pr5|0,*             fnp_info.mbx_pt
001204  aa  6 00244 2515 00   spri1     pr6|164             mbxp
                                                            STATEMENT 1 ON LINE 172
          data_len = min (length (tdata), chrsa);

001205  aa   000440 2360 07   ldq       288,dl
001206  aa  6 00304 1161 20   cmpq      pr6|196,*           chrsa
001207  aa   000002 6040 04   tmi       2,ic                001211
001210  aa  6 00304 2361 20   ldq       pr6|196,*           chrsa
001211  aa  6 00110 7561 00   stq       pr6|72              data_len
                                                            STATEMENT 1 ON LINE 173
          if data_len > 0
          then tdata = substr (data, 1, data_len);

001212  aa  6 00110 2361 00   ldq       pr6|72              data_len
001213  aa   000006 6044 04   tmoz      6,ic                001221
001214  aa  6 00302 3535 20   epp3      pr6|194,*
001215  aa  003 100 060 540   csl       (pr,rl),(pr),fill(0),bool(move)
001216  aa  3 00000 00 0006   descb     pr3|0,ql            data
001217  aa  6 00100 00 0440   descb     pr6|64,288          tdata
001220  aa   000004 7100 04   tra       4,ic                001224
                                                            STATEMENT 1 ON LINE 175
          else tdata = "0"b;

001221  aa  000 100 100 400   mlr       (),(pr),fill(000)
001222  aa   000000 00 0000   desc9a    0,0
001223  aa  6 00100 00 0040   desc9a    pr6|64,32           tdata
                                                            STATEMENT 1 ON LINE 177
          i = index (used_string, "0"b);

001224  aa   000000 2350 07   lda       0,dl
001225  aa   000010 2360 07   ldq       8,dl
001226  aa  1 00005 3521 00   epp2      pr1|5               used_string
001227  aa  0 01234 7001 00   tsx0      pr0|668             index_bs_1_eis
001230  aa  6 00123 7561 00   stq       pr6|83              i
                                                            STATEMENT 1 ON LINE 178
          if i = 0                                          /* no submailbox */
          then do;

001231  aa   000011 6010 04   tnz       9,ic                001242
                                                            STATEMENT 1 ON LINE 180
               call make_q_entry (operation, data_len, tdata);

001232  aa   006176 3520 04   epp2      3198,ic             007430 = 000006000000
001233  aa   004464 6700 04   tsp4      2356,ic             005717
                                                            STATEMENT 1 ON LINE 181
               fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;

001234  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001235  aa  7 00060 2351 00   lda       pr7|48              fnp_info.mbx_unavailable
001236  aa   000044 7330 00   lrs       36
001237  aa   000001 0330 07   adl       1,dl
001240  aa  7 00060 7561 00   stq       pr7|48              fnp_info.mbx_unavailable
                                                            STATEMENT 1 ON LINE 183
          end;

001241  aa   000112 7100 04   tra       74,ic               001353
                                                            STATEMENT 1 ON LINE 185
          else do;

                                                            STATEMENT 1 ON LINE 186
               subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));

001242  aa   000003 7360 00   qls       3
001243  aa  1 00000 3535 06   epp3      pr1|0,ql            datanet_mbx.dn355_sub_mbxes
001244  aa  6 00242 2535 00   spri3     pr6|162             subp
                                                            STATEMENT 1 ON LINE 188
               if pcbp ^= null ()
               then do;

001245  aa  6 00270 2371 00   ldaq      pr6|184             pcbp
001246  aa   776674 6770 04   eraq      -580,ic             000142 = 077777000043 000001000000
001247  aa  0 00460 3771 00   anaq      pr0|304             = 077777000077 777777077077
001250  aa   000012 6000 04   tze       10,ic               001262
                                                            STATEMENT 1 ON LINE 190
                    string (sub_mbx.line_number) = string (pcb.line_number);

001251  aa  6 00270 2351 20   lda       pr6|184,*
001252  aa   000022 7350 00   als       18
001253  aa  3 00000 6751 00   era       pr3|0
001254  aa   001777 3750 03   ana       1023,du
001255  aa  3 00000 6551 00   ersa      pr3|0
                                                            STATEMENT 1 ON LINE 192
                    devx = pcb.devx;

001256  aa  6 00270 2351 20   lda       pr6|184,*           pcb.devx
001257  aa   000066 7330 00   lrs       54
001260  aa  6 00134 7561 00   stq       pr6|92              devx
                                                            STATEMENT 1 ON LINE 193
               end;

001261  aa   000003 7100 04   tra       3,ic                001264
                                                            STATEMENT 1 ON LINE 195
               else string (sub_mbx.line_number) = "0"b;

001262  aa   006144 2350 04   lda       3172,ic             007426 = 776000777777
001263  aa  3 00000 3551 00   ansa      pr3|0
                                                            STATEMENT 1 ON LINE 197
               sub_mbx.op_code = operation;

001264  aa  6 00135 2361 00   ldq       pr6|93              operation
001265  aa   000055 7370 00   lls       45
001266  aa  3 00001 5511 10   stba      pr3|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 198
               sub_mbx.cmd_data_len = divide (data_len, 6, 17, 0);

001267  aa  6 00110 2361 00   ldq       pr6|72              data_len
001270  aa   000006 5060 07   div       6,dl
001271  aa   000066 7370 00   lls       54
001272  aa  3 00001 5511 20   stba      pr3|1,20            sub_mbx.cmd_data_len
                                                            STATEMENT 1 ON LINE 200
               if operation = accept_direct_output          /* if output op */
               then do;

001273  aa  6 00135 2361 00   ldq       pr6|93              operation
001274  aa   000012 1160 07   cmpq      10,dl
001275  aa   000017 6010 04   tnz       15,ic               001314
                                                            STATEMENT 1 ON LINE 202
                    if ^pcb.flags.dialed                    /* output without a dialup? */
                    then call throw_away_output;

001276  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
001277  aa  5 00004 2351 00   lda       pr5|4               pcb.dialed
001300  aa   200000 3150 03   cana      65536,du
001301  aa   000003 6010 04   tnz       3,ic                001304
001302  aa   005326 6700 04   tsp4      2774,ic             006630
001303  aa   000045 7100 04   tra       37,ic               001350
                                                            STATEMENT 1 ON LINE 205
                    else call process_send_output (i - 1, "0"b);

001304  aa  6 00123 2361 00   ldq       pr6|83              i
001305  aa   000001 1760 07   sbq       1,dl
001306  aa  6 00555 7561 00   stq       pr6|365
001307  aa   000000 2350 07   lda       0,dl
001310  aa  6 00630 7551 00   sta       pr6|408
001311  aa   006107 3520 04   epp2      3143,ic             007420 = 000004000000
001312  aa   002772 6700 04   tsp4      1530,ic             004304
                                                            STATEMENT 1 ON LINE 206
               end;

001313  aa   000035 7100 04   tra       29,ic               001350
                                                            STATEMENT 1 ON LINE 208
               else if operation = set_echnego_break_table
               then do;

001314  aa   000030 1160 07   cmpq      24,dl
001315  aa   000013 6010 04   tnz       11,ic               001330
                                                            STATEMENT 1 ON LINE 210
                    if pcb.flags.dialed
                    then call send_echo_table (i - 1, tdata);

001316  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
001317  aa  5 00004 2351 00   lda       pr5|4               pcb.dialed
001320  aa   200000 3150 03   cana      65536,du
001321  aa   000027 6000 04   tze       23,ic               001350
001322  aa  6 00123 2361 00   ldq       pr6|83              i
001323  aa   000001 1760 07   sbq       1,dl
001324  aa  6 00630 7561 00   stq       pr6|408
001325  aa   006065 3520 04   epp2      3125,ic             007412 = 000004000000
001326  aa   003361 6700 04   tsp4      1777,ic             004707
                                                            STATEMENT 1 ON LINE 212
               end;

001327  aa   000021 7100 04   tra       17,ic               001350
                                                            STATEMENT 1 ON LINE 214
               else do;

                                                            STATEMENT 1 ON LINE 215
                    sub_mbx.io_cmd = wcd;

001330  aa   000003 2350 07   lda       3,dl
001331  aa  3 00001 5511 04   stba      pr3|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 216
                    smbx_cmd_data_long = substr (tdata, 1, data_len);

001332  aa  6 00110 7271 00   lxl7      pr6|72              data_len
001333  aa  003 100 060 540   csl       (pr,rl),(pr),fill(0),bool(move)
001334  aa  6 00100 00 0017   descb     pr6|64,x7           tdata
001335  aa  3 00002 00 0330   descb     pr3|2,216           smbx_cmd_data_long
                                                            STATEMENT 1 ON LINE 218
                    call send_mbx (i - 1);

001336  aa  6 00123 2361 00   ldq       pr6|83              i
001337  aa   000001 1760 07   sbq       1,dl
001340  aa  6 00630 7561 00   stq       pr6|408
001341  aa   006045 3520 04   epp2      3109,ic             007406 = 000002000000
001342  aa   004713 6700 04   tsp4      2507,ic             006255
                                                            STATEMENT 1 ON LINE 219
                    fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;

001343  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001344  aa  7 00054 2351 00   lda       pr7|44              fnp_info.output_control_transactions
001345  aa   000044 7330 00   lrs       36
001346  aa   000001 0330 07   adl       1,dl
001347  aa  7 00054 7561 00   stq       pr7|44              fnp_info.output_control_transactions
                                                            STATEMENT 1 ON LINE 220
               end;

                                                            STATEMENT 1 ON LINE 223
               if no_response
               then call report_fnp_no_response;
001350  aa  6 00140 2351 00   lda       pr6|96              no_response
001351  aa   000002 6000 04   tze       2,ic                001353
001352  aa   005320 6700 04   tsp4      2768,ic             006672
                                                            STATEMENT 1 ON LINE 225
          end;

                                                            STATEMENT 1 ON LINE 228
          return;

001353  aa  0 00631 7101 00   tra       pr0|409             return_mac
ENTRY TO process_interrupt_queue                            STATEMENT 1 ON LINE 230
process_interrupt_queue:
     entry (x_dno);

001354  at     000001000132
001355  ta     001354000000
001356  da     000336300000
001357  aa   001520 6270 00   eax7      848
001360  aa  7 00034 3521 20   epp2      pr7|28,*
001361  aa  2 01045 2721 00   tsp2      pr2|549             ext_entry
001362  aa     000002000000
001363  aa     000000000000
                                                            STATEMENT 1 ON LINE 233
          interrupt_entry = "0"b;

001364  aa  6 00141 4501 00   stz       pr6|97              interrupt_entry
                                                            STATEMENT 1 ON LINE 234
          call setup;

001365  aa   000077 6700 04   tsp4      63,ic               001464
                                                            STATEMENT 1 ON LINE 235
          on cleanup call check_lock;

001366  aa   000007 7260 07   lxl6      7,dl
001367  aa   776555 3520 04   epp2      -659,ic             000144 = 143154145141
001370  aa  0 00717 7001 00   tsx0      pr0|463             enable_op
001371  aa   000004 7100 04   tra       4,ic                001375
001372  aa     000230000000
001373  aa   000011 7100 04   tra       9,ic                001404
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 235
          on cleanup call check_lock;

001374  da     000344200000
001375  aa   000140 6270 00   eax7      96
001376  aa  7 00034 3521 20   epp2      pr7|28,*
001377  aa  2 01047 2721 00   tsp2      pr2|551             int_entry
001400  aa     000000000000
001401  aa     000000000000
001402  aa   005402 6700 04   tsp4      2818,ic             007004
001403  aa  0 00631 7101 00   tra       pr0|409             return_mac
  END CONDITION cleanup.1
                                                            STATEMENT 1 ON LINE 236
          masked = "1"b;

001404  aa   400000 2350 03   lda       131072,du
001405  aa  6 00160 7551 00   sta       pr6|112             masked
                                                            STATEMENT 1 ON LINE 237
          call pmut$wire_and_mask (wire_arg, wire_ptr);
001406  aa  6 00154 3521 00   epp2      pr6|108             wire_arg
001407  aa  6 00532 2521 00   spri2     pr6|346
001410  aa  6 00156 3521 00   epp2      pr6|110             wire_ptr
001411  aa  6 00534 2521 00   spri2     pr6|348
001412  aa  6 00530 6211 00   eax1      pr6|344
001413  aa   010000 4310 07   fld       4096,dl
001414  aa  6 00044 3701 20   epp4      pr6|36,*
001415  la  4 00036 3521 20   epp2      pr4|30,*            pmut$wire_and_mask
001416  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 239
          do while (^stac (addr (fnp_info.queue_lock), pds$processid));

001417  aa   000000 0110 03   nop       0,du
001420  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001421  aa  7 00043 3735 00   epp7      pr7|35              fnp_info.queue_lock
001422  aa  6 00632 6535 00   spri7     pr6|410
001423  aa  6 00044 3701 20   epp4      pr6|36,*
001424  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
001425  aa  7 00000 3521 00   epp2      pr7|0
001426  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
001427  aa   000002 6010 04   tnz       2,ic                001431
                                                            STATEMENT 1 ON LINE 240
          end;

001430  aa   777770 7100 04   tra       -8,ic               001420
                                                            STATEMENT 1 ON LINE 241
          queue_locked = "1"b;

001431  aa   400000 2350 03   lda       131072,du
001432  aa  6 00161 7551 00   sta       pr6|113             queue_locked
                                                            STATEMENT 1 ON LINE 243
          call process_int_queue ("1"b);

001433  aa  6 00631 7551 00   sta       pr6|409
001434  aa   005746 3520 04   epp2      3046,ic             007402 = 000002000000
001435  aa   000053 6700 04   tsp4      43,ic               001510
                                                            STATEMENT 1 ON LINE 244
          return;

001436  aa  0 00631 7101 00   tra       pr0|409             return_mac
ENTRY TO hangup_fnp_lines                                   STATEMENT 1 ON LINE 1319
hangup_fnp_lines:
     entry (a_fnp_no);

001437  at     000001000121
001440  ta     001437000000
001441  da     000354300000
001442  aa   001520 6270 00   eax7      848
001443  aa  7 00034 3521 20   epp2      pr7|28,*
001444  aa  2 01045 2721 00   tsp2      pr2|549             ext_entry
001445  aa     000002000000
001446  aa     000000000000
                                                            STATEMENT 1 ON LINE 1324
          ttybp = addr (tty_buf$);

001447  aa  6 00044 3701 20   epp4      pr6|36,*
001450  la  4 00056 3735 20   epp7      pr4|46,*            tty_buf$
001451  aa  6 00272 6535 00   spri7     pr6|186             ttybp
                                                            STATEMENT 1 ON LINE 1325
          infop = addr (dn355_data$);

001452  la  4 00044 3715 20   epp5      pr4|36,*            dn355_data$
001453  aa  6 00236 6515 00   spri5     pr6|158             infop
                                                            STATEMENT 1 ON LINE 1326
          call hangup_fnp (a_fnp_no);

001454  aa  6 00032 3535 20   epp3      pr6|26,*
001455  aa  3 00002 3521 20   epp2      pr3|2,*             a_fnp_no
001456  aa  6 00532 2521 00   spri2     pr6|346
001457  aa  6 00530 3521 00   epp2      pr6|344
001460  aa   004000 4310 07   fld       2048,dl
001461  aa  2 00000 7571 00   staq      pr2|0
001462  aa   005030 6700 04   tsp4      2584,ic             006512
                                                            STATEMENT 1 ON LINE 1327
          return;

001463  aa  0 00631 7101 00   tra       pr0|409             return_mac
                                                            STATEMENT 1 ON LINE 1851
     end dn355;

BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 246
setup:
     proc;

001464  aa  6 00306 6501 00   spri4     pr6|198
                                                            STATEMENT 1 ON LINE 249
          ttybp = addr (tty_buf$);

001465  aa  6 00044 3701 20   epp4      pr6|36,*
001466  la  4 00056 3735 20   epp7      pr4|46,*            tty_buf$
001467  aa  6 00272 6535 00   spri7     pr6|186             ttybp
                                                            STATEMENT 1 ON LINE 250
          dno = x_dno;

001470  aa  6 00032 3715 20   epp5      pr6|26,*
001471  aa  5 00002 2361 20   ldq       pr5|2,*             x_dno
001472  aa  6 00122 7561 00   stq       pr6|82              dno
                                                            STATEMENT 1 ON LINE 251
          infop = addr (dn355_data$);

001473  la  4 00044 3535 20   epp3      pr4|36,*            dn355_data$
001474  aa  6 00236 2535 00   spri3     pr6|158             infop
                                                            STATEMENT 1 ON LINE 253
          fnpp = addr (datanet_info.per_datanet (dno));

001475  aa   000072 4020 07   mpy       58,dl
001476  aa  3 77730 3515 06   epp1      pr3|-40,ql          datanet_info.per_datanet
001477  aa  6 00240 2515 00   spri1     pr6|160             fnpp
                                                            STATEMENT 1 ON LINE 254
          fnp_name = fnp_info.fnp_tag;

001500  aa  1 00007 2351 00   lda       pr1|7               fnp_info.fnp_tag
001501  aa  0 00022 3771 00   anaq      pr0|18              = 777000000000 000000000000
001502  aa  6 00137 7551 00   sta       pr6|95              fnp_name
                                                            STATEMENT 1 ON LINE 255
          mbxp = fnp_info.mbx_pt;

001503  aa  1 00000 3735 20   epp7      pr1|0,*             fnp_info.mbx_pt
001504  aa  6 00244 6535 00   spri7     pr6|164             mbxp
                                                            STATEMENT 1 ON LINE 256
          lctep = fnp_info.lcte_ptr;

001505  aa  1 00032 3535 20   epp3      pr1|26,*            fnp_info.lcte_ptr
001506  aa  6 00254 2535 00   spri3     pr6|172             lctep
                                                            STATEMENT 1 ON LINE 258
          return;

001507  aa  6 00306 6101 00   rtcd      pr6|198
                                                            STATEMENT 1 ON LINE 259
     end setup;

  END PROCEDURE setup
BEGIN PROCEDURE process_int_queue
ENTRY TO process_int_queue                                  STATEMENT 1 ON LINE 261
process_int_queue:
     proc (caller_masked);

001510  aa  6 00314 6501 00   spri4     pr6|204
001511  aa  6 00316 2521 00   spri2     pr6|206
                                                            STATEMENT 1 ON LINE 268
          do while (dequeue (level));

001512  aa   005662 3520 04   epp2      2994,ic             007374 = 000004000000
001513  aa   000234 6700 04   tsp4      156,ic              001747
001514  aa  6 00634 2351 00   lda       pr6|412
001515  aa   400000 3150 03   cana      131072,du
001516  aa   000114 6000 04   tze       76,ic               001632
                                                            STATEMENT 1 ON LINE 269
               fnp_info.processed_from_q = fnp_info.processed_from_q + 1;

001517  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001520  aa  7 00047 2351 00   lda       pr7|39              fnp_info.processed_from_q
001521  aa   000044 7330 00   lrs       36
001522  aa   000001 0330 07   adl       1,dl
001523  aa  7 00047 7561 00   stq       pr7|39              fnp_info.processed_from_q
                                                            STATEMENT 1 ON LINE 271
               if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
               then call syserr (crash_system, "dn355: inconsistent queue lock");

001524  aa   000000 2350 07   lda       0,dl
001525  aa  7 00043 3521 00   epp2      pr7|35              fnp_info.queue_lock
001526  aa  6 00044 3701 20   epp4      pr6|36,*
001527  la  4 00014 2361 20   ldq       pr4|12,*            pds$processid
001530  aa  0 01434 7001 00   tsx0      pr0|796             stacq_mac
001531  aa   000020 6010 04   tnz       16,ic               001551
001532  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
001533  aa   776472 00 0040   desc9a    -710,32             000224 = 144156063065
001534  aa  6 00636 00 0040   desc9a    pr6|414,32
001535  aa   776374 3520 04   epp2      -772,ic             000131 = 000000000001
001536  aa  6 00650 2521 00   spri2     pr6|424
001537  aa  6 00636 3521 00   epp2      pr6|414
001540  aa  6 00652 2521 00   spri2     pr6|426
001541  aa   776360 3520 04   epp2      -784,ic             000121 = 404000000021
001542  aa  6 00654 2521 00   spri2     pr6|428
001543  aa   776341 3520 04   epp2      -799,ic             000104 = 524000000036
001544  aa  6 00656 2521 00   spri2     pr6|430
001545  aa  6 00646 6211 00   eax1      pr6|422
001546  aa   010000 4310 07   fld       4096,dl
001547  la  4 00016 3521 20   epp2      pr4|14,*            syserr
001550  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 274
               queue_locked = "0"b;

001551  aa  6 00161 4501 00   stz       pr6|113             queue_locked
                                                            STATEMENT 1 ON LINE 275
               if caller_masked
               then call pmut$unwire_unmask (wire_arg, wire_ptr);

001552  aa  6 00316 3735 20   epp7      pr6|206,*
001553  aa  7 00002 3715 20   epp5      pr7|2,*
001554  aa  000 000 066 500   cmpb      (pr),(),fill(0)
001555  aa  5 00000 00 0001   descb     pr5|0,1             caller_masked
001556  aa   000000 00 0000   descb     0,0
001557  aa   000012 6000 04   tze       10,ic               001571
001560  aa  6 00154 3521 00   epp2      pr6|108             wire_arg
001561  aa  6 00640 2521 00   spri2     pr6|416
001562  aa  6 00156 3521 00   epp2      pr6|110             wire_ptr
001563  aa  6 00642 2521 00   spri2     pr6|418
001564  aa  6 00636 6211 00   eax1      pr6|414
001565  aa   010000 4310 07   fld       4096,dl
001566  aa  6 00044 3701 20   epp4      pr6|36,*
001567  la  4 00040 3521 20   epp2      pr4|32,*            pmut$unwire_unmask
001570  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 277
               masked = "0"b;

001571  aa  6 00160 4501 00   stz       pr6|112             masked
                                                            STATEMENT 1 ON LINE 279
               call process_int (level);

001572  aa   005650 3520 04   epp2      2984,ic             007442 = 000002000000
001573  aa   000214 6700 04   tsp4      140,ic              002007
                                                            STATEMENT 1 ON LINE 281
               if caller_masked
               then do;

001574  aa  6 00316 3735 20   epp7      pr6|206,*
001575  aa  7 00002 3715 20   epp5      pr7|2,*
001576  aa  000 000 066 500   cmpb      (pr),(),fill(0)
001577  aa  5 00000 00 0001   descb     pr5|0,1             caller_masked
001600  aa   000000 00 0000   descb     0,0
001601  aa   000014 6000 04   tze       12,ic               001615
                                                            STATEMENT 1 ON LINE 283
                    masked = "1"b;

001602  aa   400000 2350 03   lda       131072,du
001603  aa  6 00160 7551 00   sta       pr6|112             masked
                                                            STATEMENT 1 ON LINE 284
                    call pmut$wire_and_mask (wire_arg, wire_ptr);

001604  aa  6 00154 3521 00   epp2      pr6|108             wire_arg
001605  aa  6 00640 2521 00   spri2     pr6|416
001606  aa  6 00156 3521 00   epp2      pr6|110             wire_ptr
001607  aa  6 00642 2521 00   spri2     pr6|418
001610  aa  6 00636 6211 00   eax1      pr6|414
001611  aa   010000 4310 07   fld       4096,dl
001612  aa  6 00044 3701 20   epp4      pr6|36,*
001613  la  4 00036 3521 20   epp2      pr4|30,*            pmut$wire_and_mask
001614  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 285
               end;

                                                            STATEMENT 1 ON LINE 287
               do while (^stac (addr (fnp_info.queue_lock), pds$processid));

001615  aa   000000 0110 03   nop       0,du
001616  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001617  aa  7 00043 3735 00   epp7      pr7|35              fnp_info.queue_lock
001620  aa  6 00660 6535 00   spri7     pr6|432
001621  aa  6 00044 3701 20   epp4      pr6|36,*
001622  la  4 00014 2351 20   lda       pr4|12,*            pds$processid
001623  aa  7 00000 3521 00   epp2      pr7|0
001624  aa  0 00663 7001 00   tsx0      pr0|435             stac_mac
001625  aa   000002 6010 04   tnz       2,ic                001627
                                                            STATEMENT 1 ON LINE 288
               end;

001626  aa   777770 7100 04   tra       -8,ic               001616
                                                            STATEMENT 1 ON LINE 289
               queue_locked = "1"b;

001627  aa   400000 2350 03   lda       131072,du
001630  aa  6 00161 7551 00   sta       pr6|113             queue_locked
                                                            STATEMENT 1 ON LINE 290
          end;

001631  aa   777661 7100 04   tra       -79,ic              001512
                                                            STATEMENT 1 ON LINE 292
          lcte.locked_for_interrupt = "0"b;

001632  aa   005606 2350 04   lda       2950,ic             007440 = 777737777777
001633  aa  6 00254 3735 20   epp7      pr6|172,*           lctep
001634  aa  7 00002 3551 00   ansa      pr7|2               lcte.locked_for_interrupt
                                                            STATEMENT 1 ON LINE 293
          if ^stacq (lcte.lock, "0"b, pds$processid)
          then call syserr (crash_system, "dn355: LCTE lock ^^= processid");

001635  aa   000000 2350 07   lda       0,dl
001636  aa  7 00000 3521 00   epp2      pr7|0               lcte.lock
001637  aa  6 00044 3701 20   epp4      pr6|36,*
001640  la  4 00014 2361 20   ldq       pr4|12,*            pds$processid
001641  aa  0 01434 7001 00   tsx0      pr0|796             stacq_mac
001642  aa   000020 6010 04   tnz       16,ic               001662
001643  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
001644  aa   776351 00 0040   desc9a    -791,32             000214 = 144156063065
001645  aa  6 00636 00 0040   desc9a    pr6|414,32
001646  aa   776263 3520 04   epp2      -845,ic             000131 = 000000000001
001647  aa  6 00650 2521 00   spri2     pr6|424
001650  aa  6 00636 3521 00   epp2      pr6|414
001651  aa  6 00652 2521 00   spri2     pr6|426
001652  aa   776247 3520 04   epp2      -857,ic             000121 = 404000000021
001653  aa  6 00654 2521 00   spri2     pr6|428
001654  aa   776230 3520 04   epp2      -872,ic             000104 = 524000000036
001655  aa  6 00656 2521 00   spri2     pr6|430
001656  aa  6 00646 6211 00   eax1      pr6|422
001657  aa   010000 4310 07   fld       4096,dl
001660  la  4 00016 3521 20   epp2      pr4|14,*            syserr
001661  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 296
          if ^stacq (fnp_info.queue_lock, "0"b, pds$processid)
          then call syserr (crash_system, "dn355: inconsistent queue lock");

001662  aa   000000 2350 07   lda       0,dl
001663  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001664  aa  7 00043 3521 00   epp2      pr7|35              fnp_info.queue_lock
001665  aa  6 00044 3701 20   epp4      pr6|36,*
001666  la  4 00014 2361 20   ldq       pr4|12,*            pds$processid
001667  aa  0 01434 7001 00   tsx0      pr0|796             stacq_mac
001670  aa   000020 6010 04   tnz       16,ic               001710
001671  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
001672  aa   776333 00 0040   desc9a    -805,32             000224 = 144156063065
001673  aa  6 00636 00 0040   desc9a    pr6|414,32
001674  aa   776235 3520 04   epp2      -867,ic             000131 = 000000000001
001675  aa  6 00650 2521 00   spri2     pr6|424
001676  aa  6 00636 3521 00   epp2      pr6|414
001677  aa  6 00652 2521 00   spri2     pr6|426
001700  aa   776221 3520 04   epp2      -879,ic             000121 = 404000000021
001701  aa  6 00654 2521 00   spri2     pr6|428
001702  aa   776202 3520 04   epp2      -894,ic             000104 = 524000000036
001703  aa  6 00656 2521 00   spri2     pr6|430
001704  aa  6 00646 6211 00   eax1      pr6|422
001705  aa   010000 4310 07   fld       4096,dl
001706  la  4 00016 3521 20   epp2      pr4|14,*            syserr
001707  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 299
          queue_locked = "0"b;

001710  aa  6 00161 4501 00   stz       pr6|113             queue_locked
                                                            STATEMENT 1 ON LINE 300
          if caller_masked
          then call pmut$unwire_unmask (wire_arg, wire_ptr);

001711  aa  6 00316 3735 20   epp7      pr6|206,*
001712  aa  7 00002 3715 20   epp5      pr7|2,*
001713  aa  000 000 066 500   cmpb      (pr),(),fill(0)
001714  aa  5 00000 00 0001   descb     pr5|0,1             caller_masked
001715  aa   000000 00 0000   descb     0,0
001716  aa   000012 6000 04   tze       10,ic               001730
001717  aa  6 00154 3521 00   epp2      pr6|108             wire_arg
001720  aa  6 00640 2521 00   spri2     pr6|416
001721  aa  6 00156 3521 00   epp2      pr6|110             wire_ptr
001722  aa  6 00642 2521 00   spri2     pr6|418
001723  aa  6 00636 6211 00   eax1      pr6|414
001724  aa   010000 4310 07   fld       4096,dl
001725  aa  6 00044 3701 20   epp4      pr6|36,*
001726  la  4 00040 3521 20   epp2      pr4|32,*            pmut$unwire_unmask
001727  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 302
          masked = "0"b;

001730  aa  6 00160 4501 00   stz       pr6|112             masked
                                                            STATEMENT 1 ON LINE 304
          if lcte.notify_reqd
          then do;

001731  aa  6 00254 3735 20   epp7      pr6|172,*           lctep
001732  aa  7 00002 2351 00   lda       pr7|2               lcte.notify_reqd
001733  aa   000100 3150 03   cana      64,du
001734  aa   000012 6000 04   tze       10,ic               001746
                                                            STATEMENT 1 ON LINE 306
               lcte.notify_reqd = "0"b;

001735  aa   005504 2350 04   lda       2884,ic             007441 = 777677777777
001736  aa  7 00002 3551 00   ansa      pr7|2               lcte.notify_reqd
                                                            STATEMENT 1 ON LINE 307
               call pxss$notify (tty_ev);

001737  aa   776111 3520 04   epp2      -951,ic             000050 = 000000000071
001740  aa  6 00640 2521 00   spri2     pr6|416
001741  aa  6 00636 6211 00   eax1      pr6|414
001742  aa   004000 4310 07   fld       2048,dl
001743  aa  6 00044 3701 20   epp4      pr6|36,*
001744  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
001745  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 308
          end;

                                                            STATEMENT 1 ON LINE 310
          return;

001746  aa  6 00314 6101 00   rtcd      pr6|204
                                                            STATEMENT 1 ON LINE 334
     end /* process_int_queue */;

BEGIN PROCEDURE dequeue
ENTRY TO dequeue                                            STATEMENT 1 ON LINE 312
dequeue:
          proc (a_level) returns (bit (1));

001747  aa  6 00322 6501 00   spri4     pr6|210
001750  aa  6 00324 2521 00   spri2     pr6|212
                                                            STATEMENT 1 ON LINE 317
               if fnp_info.level_3_pending
               then do;

001751  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
001752  aa  7 00030 2351 00   lda       pr7|24              fnp_info.level_3_pending
001753  aa   010000 3150 03   cana      4096,du
001754  aa   000012 6000 04   tze       10,ic               001766
                                                            STATEMENT 1 ON LINE 319
                    fnp_info.level_3_pending = "0"b;

001755  aa   005416 2350 04   lda       2830,ic             007373 = 767777777777
001756  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.level_3_pending
                                                            STATEMENT 1 ON LINE 320
                    a_level = 3;

001757  aa   000003 2360 07   ldq       3,dl
001760  aa  2 00002 7561 20   stq       pr2|2,*             a_level
                                                            STATEMENT 1 ON LINE 321
                    return ("1"b);

001761  aa  2 00004 3715 20   epp5      pr2|4,*
001762  aa  403 100 060 400   csl       (),(pr),fill(1),bool(move)
001763  aa   000000 00 0000   descb     0,0
001764  aa  5 00000 00 0001   descb     pr5|0,1
001765  aa  6 00322 6101 00   rtcd      pr6|210
                                                            STATEMENT 1 ON LINE 322
               end;

                                                            STATEMENT 1 ON LINE 324
               else if fnp_info.level_7_pending
               then do;

001766  aa  7 00030 2351 00   lda       pr7|24              fnp_info.level_7_pending
001767  aa   004000 3150 03   cana      2048,du
001770  aa   000012 6000 04   tze       10,ic               002002
                                                            STATEMENT 1 ON LINE 326
                    fnp_info.level_7_pending = "0"b;

001771  aa   005401 2350 04   lda       2817,ic             007372 = 773777777777
001772  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.level_7_pending
                                                            STATEMENT 1 ON LINE 327
                    a_level = 7;

001773  aa   000007 2360 07   ldq       7,dl
001774  aa  2 00002 7561 20   stq       pr2|2,*             a_level
                                                            STATEMENT 1 ON LINE 328
                    return ("1"b);

001775  aa  2 00004 3715 20   epp5      pr2|4,*
001776  aa  403 100 060 400   csl       (),(pr),fill(1),bool(move)
001777  aa   000000 00 0000   descb     0,0
002000  aa  5 00000 00 0001   descb     pr5|0,1
002001  aa  6 00322 6101 00   rtcd      pr6|210
                                                            STATEMENT 1 ON LINE 329
               end;

                                                            STATEMENT 1 ON LINE 331
               else return ("0"b);

002002  aa  2 00004 3715 20   epp5      pr2|4,*
002003  aa  003 100 060 400   csl       (),(pr),fill(0),bool(move)
002004  aa   000000 00 0000   descb     0,0
002005  aa  5 00000 00 0001   descb     pr5|0,1
002006  aa  6 00322 6101 00   rtcd      pr6|210
                                                            STATEMENT 1 ON LINE 333
          end /* dequeue */;

  END PROCEDURE dequeue
  END PROCEDURE process_int_queue
BEGIN PROCEDURE process_int
ENTRY TO process_int                                        STATEMENT 1 ON LINE 336
process_int:
     proc (a_level);

002007  aa  6 00330 6501 00   spri4     pr6|216
002010  aa  6 00332 2521 00   spri2     pr6|218
                                                            STATEMENT 1 ON LINE 343
          level = a_level;

002011  aa  2 00002 2361 20   ldq       pr2|2,*             a_level
002012  aa  6 00121 7561 00   stq       pr6|81              level
                                                            STATEMENT 1 ON LINE 345
          lcte.locked_for_interrupt = "1"b;

002013  aa   000040 2350 03   lda       32,du
002014  aa  6 00254 3735 20   epp7      pr6|172,*           lctep
002015  aa  7 00002 2551 00   orsa      pr7|2               lcte.locked_for_interrupt
                                                            STATEMENT 1 ON LINE 346
          if level = 7
          then do;

002016  aa   000007 1160 07   cmpq      7,dl
002017  aa   000345 6010 04   tnz       229,ic              002364
                                                            STATEMENT 1 ON LINE 349
               if fnp_info.t_and_d_in_progress
               then do;

002020  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
002021  aa  5 00030 2351 00   lda       pr5|24              fnp_info.t_and_d_in_progress
002022  aa   001000 3150 03   cana      512,du
002023  aa   000066 6000 04   tze       54,ic               002111
                                                            STATEMENT 1 ON LINE 351
                    if fnp_info.t_and_d_lev_7_occurred
                    then return;

002024  aa  5 00030 2351 00   lda       pr5|24              fnp_info.t_and_d_lev_7_occurred
002025  aa   000200 3150 03   cana      128,du
002026  aa   000002 6000 04   tze       2,ic                002030
002027  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 353
                    fnp_info.t_and_d_lev_7_occurred = "1"b;

002030  aa   000200 2350 03   lda       128,du
002031  aa  5 00030 2551 00   orsa      pr5|24              fnp_info.t_and_d_lev_7_occurred
                                                            STATEMENT 1 ON LINE 354
t_and_d_join:
                    if fnp_info.t_and_d_notify_requested
                    then do;

002032  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
002033  aa  7 00030 2351 00   lda       pr7|24              fnp_info.t_and_d_notify_requested
002034  aa   000100 3150 03   cana      64,du
002035  aa   000013 6000 04   tze       11,ic               002050
                                                            STATEMENT 1 ON LINE 357
                         call pxss$notify (tty_ev);

002036  aa   776012 3520 04   epp2      -1014,ic            000050 = 000000000071
002037  aa  6 00664 2521 00   spri2     pr6|436
002040  aa  6 00662 6211 00   eax1      pr6|434
002041  aa   004000 4310 07   fld       2048,dl
002042  aa  6 00044 3701 20   epp4      pr6|36,*
002043  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
002044  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 358
                         fnp_info.t_and_d_notify_requested = "0"b;

002045  aa   005374 2350 04   lda       2812,ic             007441 = 777677777777
002046  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
002047  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.t_and_d_notify_requested
                                                            STATEMENT 1 ON LINE 359
                    end;

                                                            STATEMENT 1 ON LINE 360
                    unspec (auto_net_event_message) = "0"b;

002050  aa   776070 2370 04   ldaq      -968,ic             000140 = 000000000000 000000000000
002051  aa  6 00166 7571 00   staq      pr6|118
                                                            STATEMENT 1 ON LINE 361
                    auto_net_event_message.version = NET_EVENT_MESSAGE_VERSION_1;

002052  aa   400000 2350 03   lda       131072,du
002053  aa  6 00166 6751 00   era       pr6|118             auto_net_event_message.version
002054  aa  0 00004 3751 00   ana       pr0|4               = 600000000000
002055  aa  6 00166 6551 00   ersa      pr6|118             auto_net_event_message.version
                                                            STATEMENT 1 ON LINE 362
                    auto_net_event_message.network_type = MCS_NETWORK_TYPE;

002056  aa   000000 2350 03   lda       0,du
002057  aa  6 00166 6751 00   era       pr6|118             auto_net_event_message.network_type
002060  aa   007400 3750 07   ana       3840,dl
002061  aa  6 00166 6551 00   ersa      pr6|118             auto_net_event_message.network_type
                                                            STATEMENT 1 ON LINE 363
                    auto_net_event_message.handle = dno;

002062  aa  6 00122 2361 00   ldq       pr6|82              dno
002063  aa  6 00167 7561 00   stq       pr6|119             auto_net_event_message.handle
                                                            STATEMENT 1 ON LINE 364
                    auto_net_event_message.type = level;

002064  aa  6 00121 2361 00   ldq       pr6|81              level
002065  aa  6 00166 6761 00   erq       pr6|118             auto_net_event_message.type
002066  aa   000377 3760 07   anq       255,dl
002067  aa  6 00166 6561 00   ersq      pr6|118             auto_net_event_message.type
                                                            STATEMENT 1 ON LINE 365
                    unspec (net_event_message_arg) = unspec (auto_net_event_message);

002070  aa  6 00166 2371 00   ldaq      pr6|118
002071  aa  6 00264 7571 00   staq      pr6|180
                                                            STATEMENT 1 ON LINE 366
                    call pxss$unique_ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan,
                         net_event_message_arg, 0);

002072  aa  6 00666 4501 00   stz       pr6|438
002073  aa  7 00040 3521 00   epp2      pr7|32              fnp_info.boot_process_id
002074  aa  6 00672 2521 00   spri2     pr6|442
002075  aa  7 00036 3521 00   epp2      pr7|30              fnp_info.boot_ev_chan
002076  aa  6 00674 2521 00   spri2     pr6|444
002077  aa  6 00264 3521 00   epp2      pr6|180             net_event_message_arg
002100  aa  6 00676 2521 00   spri2     pr6|446
002101  aa  6 00666 3521 00   epp2      pr6|438
002102  aa  6 00700 2521 00   spri2     pr6|448
002103  aa  6 00670 6211 00   eax1      pr6|440
002104  aa   020000 4310 07   fld       8192,dl
002105  aa  6 00044 3701 20   epp4      pr6|36,*
002106  la  4 00032 3521 20   epp2      pr4|26,*            pxss$unique_ring_0_wakeup
002107  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 368
                    return;

002110  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 369
               end;

                                                            STATEMENT 1 ON LINE 373
               fault_type = datanet_mbx.crash_data.fault_code;
002111  aa  6 00244 3535 20   epp3      pr6|164,*           mbxp
002112  aa  3 00006 2351 00   lda       pr3|6               datanet_mbx.fault_code
002113  aa   000066 7730 00   lrl       54
002114  aa  6 00177 7561 00   stq       pr6|127             fault_type
                                                            STATEMENT 1 ON LINE 374
               if fault_type > hbound (dn355_messages$fault_names, 1) | fault_type < 0
               then fault_name = "unknown fault";

002115  aa   000012 1160 07   cmpq      10,dl
002116  aa   000003 6054 04   tpnz      3,ic                002121
002117  aa  6 00177 2361 00   ldq       pr6|127             fault_type
002120  aa   000005 6050 04   tpl       5,ic                002125
002121  aa  040 100 100 404   mlr       (ic),(pr),fill(040)
002122  aa   776031 00 0015   desc9a    -999,13             000152 = 165156153156
002123  aa  6 00200 00 0020   desc9a    pr6|128,16          fault_name
002124  aa   000013 7100 04   tra       11,ic               002137
                                                            STATEMENT 1 ON LINE 376
               else fault_name = dn355_messages$fault_names (fault_type);

002125  aa   000002 7360 00   qls       2
002126  aa   000000 6270 06   eax7      0,ql
002127  aa  6 00044 3701 20   epp4      pr6|36,*
002130  la  4 00046 3515 77   epp1      pr4|38,*7           dn355_messages$fault_names
002131  aa  1 00000 2351 00   lda       pr1|0               dn355_messages$fault_names
002132  aa  1 00001 2361 00   ldq       pr1|1               dn355_messages$fault_names
002133  aa  6 00200 7571 00   staq      pr6|128             fault_name
002134  aa  1 00002 2351 00   lda       pr1|2               dn355_messages$fault_names
002135  aa  1 00003 2361 00   ldq       pr1|3               dn355_messages$fault_names
002136  aa  6 00202 7571 00   staq      pr6|130             fault_name
                                                            STATEMENT 1 ON LINE 378
               call syserr (beeper, "dn355: emergency interrupt from FNP ^a: ^a", fnp_info.fnp_tag, fault_name);

002137  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
002140  aa   776122 00 0054   desc9a    -942,44             000261 = 144156063065
002141  aa  6 00702 00 0054   desc9a    pr6|450,44
002142  aa   775764 3520 04   epp2      -1036,ic            000126 = 000000000003
002143  aa  6 00720 2521 00   spri2     pr6|464
002144  aa  6 00702 3521 00   epp2      pr6|450
002145  aa  6 00722 2521 00   spri2     pr6|466
002146  aa  5 00007 3521 00   epp2      pr5|7               fnp_info.fnp_tag
002147  aa  6 00724 2521 00   spri2     pr6|468
002150  aa  6 00200 3521 00   epp2      pr6|128             fault_name
002151  aa  6 00726 2521 00   spri2     pr6|470
002152  aa   775747 3520 04   epp2      -1049,ic            000121 = 404000000021
002153  aa  6 00730 2521 00   spri2     pr6|472
002154  aa   775724 3520 04   epp2      -1068,ic            000100 = 524000000052
002155  aa  6 00732 2521 00   spri2     pr6|474
002156  aa   775721 3520 04   epp2      -1071,ic            000077 = 526000000001
002157  aa  6 00734 2521 00   spri2     pr6|476
002160  aa   775716 3520 04   epp2      -1074,ic            000076 = 526000000020
002161  aa  6 00736 2521 00   spri2     pr6|478
002162  aa  6 00716 6211 00   eax1      pr6|462
002163  aa   020000 4310 07   fld       8192,dl
002164  aa  6 00044 3701 20   epp4      pr6|36,*
002165  la  4 00016 3521 20   epp2      pr4|14,*            syserr
002166  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 380
               if datanet_mbx.crash_data.ic ^= 0
               then call syserr (just_tell, "FNP instruction counter = ^6o", datanet_mbx.crash_data.ic);
002167  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002170  aa  7 00006 2361 00   ldq       pr7|6               datanet_mbx.ic
002171  aa  0 00374 3771 00   anaq      pr0|252             = 000000000000 000000777777
002172  aa   000027 6000 04   tze       23,ic               002221
002173  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
002174  aa   776011 00 0040   desc9a    -1015,32            000204 = 106116120040
002175  aa  6 00670 00 0040   desc9a    pr6|440,32
002176  aa   775714 3520 04   epp2      -1076,ic            000112 = 000000000000
002177  aa  6 00720 2521 00   spri2     pr6|464
002200  aa  6 00670 3521 00   epp2      pr6|440
002201  aa  6 00722 2521 00   spri2     pr6|466
002202  aa   000022 7270 07   lxl7      18,dl
002203  aa  7 00006 3521 00   epp2      pr7|6               datanet_mbx.ic
002204  aa  2 00000 5035 17   abd       pr2|0,7
002205  aa  6 00724 2521 00   spri2     pr6|468
002206  aa   775713 3520 04   epp2      -1077,ic            000121 = 404000000021
002207  aa  6 00726 2521 00   spri2     pr6|470
002210  aa   775665 3520 04   epp2      -1099,ic            000075 = 524000000035
002211  aa  6 00730 2521 00   spri2     pr6|472
002212  aa   775662 3520 04   epp2      -1102,ic            000074 = 606000000022
002213  aa  6 00732 2521 00   spri2     pr6|474
002214  aa  6 00716 6211 00   eax1      pr6|462
002215  aa   014000 4310 07   fld       6144,dl
002216  aa  6 00044 3701 20   epp4      pr6|36,*
002217  la  4 00016 3521 20   epp2      pr4|14,*            syserr
002220  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 383
               if fault_type = iom_channel_fault
               then call syserr (just_tell, "channel ^o, fault status = ^6o", datanet_mbx.crash_data.fault_word,
                         datanet_mbx.crash_data.iom_fault_status);

002221  aa  6 00177 2361 00   ldq       pr6|127             fault_type
002222  aa   000011 1160 07   cmpq      9,dl
002223  aa   000034 6010 04   tnz       28,ic               002257
002224  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
002225  aa   775750 00 0040   desc9a    -1048,32            000174 = 143150141156
002226  aa  6 00670 00 0040   desc9a    pr6|440,32
002227  aa   775663 3520 04   epp2      -1101,ic            000112 = 000000000000
002230  aa  6 00720 2521 00   spri2     pr6|464
002231  aa  6 00670 3521 00   epp2      pr6|440
002232  aa  6 00722 2521 00   spri2     pr6|466
002233  aa   000022 7270 07   lxl7      18,dl
002234  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002235  aa  7 00007 3521 00   epp2      pr7|7               datanet_mbx.fault_word
002236  aa  2 00000 5035 17   abd       pr2|0,7
002237  aa  6 00724 2521 00   spri2     pr6|468
002240  aa  7 00007 3521 00   epp2      pr7|7               datanet_mbx.iom_fault_status
002241  aa  6 00726 2521 00   spri2     pr6|470
002242  aa   775657 3520 04   epp2      -1105,ic            000121 = 404000000021
002243  aa  6 00730 2521 00   spri2     pr6|472
002244  aa   775640 3520 04   epp2      -1120,ic            000104 = 524000000036
002245  aa  6 00732 2521 00   spri2     pr6|474
002246  aa   775626 3520 04   epp2      -1130,ic            000074 = 606000000022
002247  aa  6 00734 2521 00   spri2     pr6|476
002250  aa  6 00736 2521 00   spri2     pr6|478
002251  aa  6 00716 6211 00   eax1      pr6|462
002252  aa   020000 4310 07   fld       8192,dl
002253  aa  6 00044 3701 20   epp4      pr6|36,*
002254  la  4 00016 3521 20   epp2      pr4|14,*            syserr
002255  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
002256  aa   000104 7100 04   tra       68,ic               002362
                                                            STATEMENT 1 ON LINE 387
               else if fault_type = illegal_opcode
               then if dn355_word.opcode = die_code         /* did 355 crash deliberately? */
                    then do;

002257  aa   000003 1160 07   cmpq      3,dl
002260  aa   000102 6010 04   tnz       66,ic               002362
002261  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002262  aa  7 00007 2351 00   lda       pr7|7               dn355_word.opcode
002263  aa   000026 7350 00   als       22
002264  aa   000103 7330 00   lrs       67
002265  aa   000011 1160 07   cmpq      9,dl
002266  aa   000074 6010 04   tnz       60,ic               002362
                                                            STATEMENT 1 ON LINE 390
                         modulep = addr (dn355_messages$per_module);

002267  aa  6 00044 3701 20   epp4      pr6|36,*
002270  la  4 00050 3715 20   epp5      pr4|40,*            dn355_messages$per_module
002271  aa  6 00246 6515 00   spri5     pr6|166             modulep
                                                            STATEMENT 1 ON LINE 391
                         module_num = fixed (dn355_word.modnum, 4);

002272  aa  7 00007 2351 00   lda       pr7|7               dn355_word.modnum
002273  aa   000022 7350 00   als       18
002274  aa   000104 7730 00   lrl       68
002275  aa  6 00204 7561 00   stq       pr6|132             module_num
                                                            STATEMENT 1 ON LINE 392
                         if module_num > 0 & module_num <= hbound (dn355_modules.list_offset, 1)
                              & dn355_word.crash_code > 0 & dn355_word.crash_code <= hbound (modulep -> message_offset, 1)
                         then do;

002276  aa  7 00007 2351 00   lda       pr7|7               dn355_word.crash_code
002277  aa   000033 7350 00   als       27
002300  aa   000077 7330 00   lrs       63
002301  aa  6 00715 7561 00   stq       pr6|461             dn355_word.crash_code
002302  aa  6 00204 2361 00   ldq       pr6|132             module_num
002303  aa   000057 6044 04   tmoz      47,ic               002362
002304  aa   000011 1160 07   cmpq      9,dl
002305  aa   000055 6054 04   tpnz      45,ic               002362
002306  aa  6 00715 2361 00   ldq       pr6|461             dn355_word.crash_code
002307  aa   000053 6044 04   tmoz      43,ic               002362
002310  aa   000026 1160 07   cmpq      22,dl
002311  aa   000051 6054 04   tpnz      41,ic               002362
                                                            STATEMENT 1 ON LINE 395
                              reasonp = ptr (modulep, dn355_modules.list_offset (module_num));

002312  aa  6 00204 2361 00   ldq       pr6|132             module_num
002313  aa   000002 7360 00   qls       2
002314  aa   000000 6260 06   eax6      0,ql
002315  aa  5 77777 2361 06   ldq       pr5|-1,ql           dn355_modules.list_offset
002316  aa  5 00000 3521 00   epp2      pr5|0
002317  aa   000000 3120 06   eawp2     0,ql
002320  aa  6 00250 2521 00   spri2     pr6|168             reasonp
                                                            STATEMENT 1 ON LINE 396
                              reasonp = ptr (reasonp, reasonp -> message_offset (dn355_word.crash_code));

002321  aa  6 00715 7271 00   lxl7      pr6|461             dn355_word.crash_code
002322  aa  2 77777 2361 17   ldq       pr2|-1,7            message_offset
002323  aa   000000 3120 06   eawp2     0,ql
002324  aa  6 00250 2521 00   spri2     pr6|168             reasonp
                                                            STATEMENT 1 ON LINE 398
                              call syserr (just_tell, "^a: ^a", dn355_modules.name (module_num), dn355_reason.msg);

002325  aa  2 00000 2351 00   lda       pr2|0               dn355_reason.length
002326  aa   000077 7330 00   lrs       63
002327  aa  6 00667 7561 00   stq       pr6|439
002330  aa   526000 2760 03   orq       175104,du
002331  aa  6 00715 7561 00   stq       pr6|461
002332  aa   775604 2370 04   ldaq      -1148,ic            000136 = 136141072040 136141000000
002333  aa  6 00740 7571 00   staq      pr6|480
002334  aa   775556 3520 04   epp2      -1170,ic            000112 = 000000000000
002335  aa  6 00720 2521 00   spri2     pr6|464
002336  aa  6 00740 3521 00   epp2      pr6|480
002337  aa  6 00722 2521 00   spri2     pr6|466
002340  aa  5 77774 3521 16   epp2      pr5|-4,6            dn355_modules.name
002341  aa  6 00724 2521 00   spri2     pr6|468
002342  aa   000001 7250 07   lxl5      1,dl
002343  aa  6 00250 3521 20   epp2      pr6|168,*           dn355_reason.msg
002344  aa  2 00000 5005 15   a9bd      pr2|0,5
002345  aa  6 00726 2521 00   spri2     pr6|470
002346  aa   775553 3520 04   epp2      -1173,ic            000121 = 404000000021
002347  aa  6 00730 2521 00   spri2     pr6|472
002350  aa   775523 3520 04   epp2      -1197,ic            000073 = 524000000006
002351  aa  6 00732 2521 00   spri2     pr6|474
002352  aa   775520 3520 04   epp2      -1200,ic            000072 = 524000000014
002353  aa  6 00734 2521 00   spri2     pr6|476
002354  aa  6 00715 3521 00   epp2      pr6|461
002355  aa  6 00736 2521 00   spri2     pr6|478
002356  aa  6 00716 6211 00   eax1      pr6|462
002357  aa   020000 4310 07   fld       8192,dl
002360  la  4 00016 3521 20   epp2      pr4|14,*            syserr
002361  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 399
                         end;

                                                            STATEMENT 1 ON LINE 400
                    end;

                                                            STATEMENT 1 ON LINE 402
               call report_fnp_crash;

002362  aa   004340 6700 04   tsp4      2272,ic             006722
                                                            STATEMENT 1 ON LINE 403
               return;

002363  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 404
          end;

                                                            STATEMENT 1 ON LINE 408
          if fnp_info.bootloading                           /* if this is bootload status */
          then do;

002364  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
002365  aa  5 00030 2351 00   lda       pr5|24              fnp_info.bootloading
002366  aa   200000 3150 03   cana      65536,du
002367  aa   000011 6000 04   tze       9,ic                002400
                                                            STATEMENT 1 ON LINE 410
               call dn355_boot_interrupt (dno);
002370  aa  6 00122 3521 00   epp2      pr6|82              dno
002371  aa  6 00664 2521 00   spri2     pr6|436
002372  aa  6 00662 6211 00   eax1      pr6|434
002373  aa   004000 4310 07   fld       2048,dl
002374  aa  6 00044 3701 20   epp4      pr6|36,*
002375  la  4 00024 3521 20   epp2      pr4|20,*            dn355_boot_interrupt
002376  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 411
               return;

002377  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 412
          end;

                                                            STATEMENT 1 ON LINE 414
          if fnp_info.t_and_d_in_progress
          then do;

002400  aa  5 00030 2351 00   lda       pr5|24              fnp_info.t_and_d_in_progress
002401  aa   001000 3150 03   cana      512,du
002402  aa   000010 6000 04   tze       8,ic                002412
                                                            STATEMENT 1 ON LINE 416
               if fnp_info.t_and_d_lev_3_occurred
               then return;

002403  aa  5 00030 2351 00   lda       pr5|24              fnp_info.t_and_d_lev_3_occurred
002404  aa   000400 3150 03   cana      256,du
002405  aa   000002 6000 04   tze       2,ic                002407
002406  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 418
               fnp_info.t_and_d_lev_3_occurred = "1"b;

002407  aa   000400 2350 03   lda       256,du
002410  aa  5 00030 2551 00   orsa      pr5|24              fnp_info.t_and_d_lev_3_occurred
                                                            STATEMENT 1 ON LINE 419
               go to t_and_d_join;

002411  aa   777421 7100 04   tra       -239,ic             002032
                                                            STATEMENT 1 ON LINE 420
          end;

                                                            STATEMENT 1 ON LINE 422
          if ^fnp_info.running                              /* if this interrupt is premature, ignore it */
          then return;

002412  aa  5 00030 2351 00   lda       pr5|24              fnp_info.running
002413  aa   100000 3150 03   cana      32768,du
002414  aa   000002 6010 04   tnz       2,ic                002416
002415  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 425
          no_response = "0"b;

002416  aa  6 00140 4501 00   stz       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 427
          if fnp_info.count > 0                             /* had we had to wait for a free mbx? */
          then call process_q;

002417  aa  5 00024 2361 00   ldq       pr5|20              fnp_info.count
002420  aa   000002 6044 04   tmoz      2,ic                002422
002421  aa   001447 6700 04   tsp4      807,ic              004070
                                                            STATEMENT 1 ON LINE 432
          timw = ldac (addr (datanet_mbx.term_inpt_mpx_wd));

002422  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002423  aa  7 00002 3735 00   epp7      pr7|2               datanet_mbx.term_inpt_mpx_wd
002424  aa  6 00740 6535 00   spri7     pr6|480
002425  aa  6 00740 3521 00   epp2      pr6|480
002426  aa  6 00672 2521 00   spri2     pr6|442
002427  aa  6 00120 3521 00   epp2      pr6|80              timw
002430  aa  6 00674 2521 00   spri2     pr6|444
002431  aa  6 00670 6211 00   eax1      pr6|440
002432  aa   010000 4310 07   fld       4096,dl
002433  aa  6 00044 3701 20   epp4      pr6|36,*
002434  la  4 00020 3521 20   epp2      pr4|16,*            ldac
002435  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 434
          do i = 0 to 7;

002436  aa  6 00123 4501 00   stz       pr6|83              i
002437  aa   000000 0110 03   nop       0,du
002440  aa  6 00123 2361 00   ldq       pr6|83              i
002441  aa   000007 1160 07   cmpq      7,dl
002442  aa   000255 6054 04   tpnz      173,ic              002717
                                                            STATEMENT 1 ON LINE 436
               if timwb (i) & ^no_response
               then do;

002443  aa  000 000 066 506   cmpb      (pr,ql),(),fill(0)
002444  aa  6 00120 00 0001   descb     pr6|80,1            timwb
002445  aa   000000 00 0000   descb     0,0
002446  aa   000247 6000 04   tze       167,ic              002715
002447  aa  6 00140 2351 00   lda       pr6|96              no_response
002450  aa   000245 6010 04   tnz       165,ic              002715
                                                            STATEMENT 1 ON LINE 439
                    subp = addr (datanet_mbx.dn355_sub_mbxes (i));

002451  aa   000003 7360 00   qls       3
002452  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002453  aa  7 00010 3735 06   epp7      pr7|8,ql            datanet_mbx.dn355_sub_mbxes
002454  aa  6 00242 6535 00   spri7     pr6|162             subp
                                                            STATEMENT 1 ON LINE 441
                    datanet_mbx.mbx_used_flags.used (i) = "0"b;

002455  aa  6 00123 7271 00   lxl7      pr6|83              i
002456  aa  6 00244 3715 20   epp5      pr6|164,*           mbxp
002457  aa  003 117 060 400   csl       (),(pr,x7),fill(0),bool(move)
002460  aa   000000 00 0000   descb     0,0
002461  aa  5 00005 00 0001   descb     pr5|5,1             datanet_mbx.used
                                                            STATEMENT 1 ON LINE 443
                    datanet_mbx.num_in_use = datanet_mbx.num_in_use - 1;

002462  aa   000001 3360 07   lcq       1,dl
002463  aa  5 00004 0561 00   asq       pr5|4               datanet_mbx.num_in_use
                                                            STATEMENT 1 ON LINE 444
                    fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;

002464  aa  6 00240 3535 20   epp3      pr6|160,*           fnpp
002465  aa  3 00055 2351 00   lda       pr3|45              fnp_info.cumulative_mbx_in_use
002466  aa   000044 7330 00   lrs       36
002467  aa  5 00004 0331 00   adl       pr5|4               datanet_mbx.num_in_use
002470  aa  3 00055 7561 00   stq       pr3|45              fnp_info.cumulative_mbx_in_use
                                                            STATEMENT 1 ON LINE 445
                    fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;

002471  aa  3 00057 2351 00   lda       pr3|47              fnp_info.mbx_in_use_updated
002472  aa   000044 7330 00   lrs       36
002473  aa   000001 0330 07   adl       1,dl
002474  aa  3 00057 7561 00   stq       pr3|47              fnp_info.mbx_in_use_updated
                                                            STATEMENT 1 ON LINE 447
                    if sub_mbx.io_cmd = wcd
                    then do;

002475  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.io_cmd
002476  aa   000033 7350 00   als       27
002477  aa   000077 7330 00   lrs       63
002500  aa   000003 1160 07   cmpq      3,dl
002501  aa   000070 6010 04   tnz       56,ic               002571
                                                            STATEMENT 1 ON LINE 449
                         if sub_mbx.op_code = dump_mem | sub_mbx.op_code = patch_mem
                         then do;

002502  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.op_code
002503  aa   000022 7350 00   als       18
002504  aa   000077 7330 00   lrs       63
002505  aa  6 00715 7561 00   stq       pr6|461             sub_mbx.op_code
002506  aa   000023 1160 07   cmpq      19,dl
002507  aa   000003 6000 04   tze       3,ic                002512
002510  aa   000024 1160 07   cmpq      20,dl
002511  aa   000013 6010 04   tnz       11,ic               002524
                                                            STATEMENT 1 ON LINE 451
                              fnp_info.dump_patch_in_progress = "0"b;

002512  aa   004657 2350 04   lda       2479,ic             007371 = 757777777777
002513  aa  3 00030 3551 00   ansa      pr3|24              fnp_info.dump_patch_in_progress
                                                            STATEMENT 1 ON LINE 452
                              call pxss$notify (FNP_DUMP_PATCH_EVENT);

002514  aa   775401 3520 04   epp2      -1279,ic            000115 = 000000000072
002515  aa  6 00664 2521 00   spri2     pr6|436
002516  aa  6 00662 6211 00   eax1      pr6|434
002517  aa   004000 4310 07   fld       2048,dl
002520  aa  6 00044 3701 20   epp4      pr6|36,*
002521  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
002522  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 453
                         end;

002523  aa   000172 7100 04   tra       122,ic              002715
                                                            STATEMENT 1 ON LINE 455
                         else if sub_mbx.op_code = report_meters
                         then do;

002524  aa   000044 1160 07   cmpq      36,dl
002525  aa   000170 6010 04   tnz       120,ic              002715
                                                            STATEMENT 1 ON LINE 457
                              call get_line_number;

002526  aa   003315 6700 04   tsp4      1741,ic             006043
                                                            STATEMENT 1 ON LINE 458
                              if devx = -1
                              then if fnp_info.get_meters_waiting
                                                            /* fnp_multiplexer is waiting for global meters */
                                   then do;

002527  aa  6 00134 2361 00   ldq       pr6|92              devx
002530  aa   004723 1160 04   cmpq      2515,ic             007453 = 777777777777
002531  aa   000017 6010 04   tnz       15,ic               002550
002532  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
002533  aa  7 00030 2351 00   lda       pr7|24              fnp_info.get_meters_waiting
002534  aa   000020 3150 03   cana      16,du
002535  aa   000160 6000 04   tze       112,ic              002715
                                                            STATEMENT 1 ON LINE 462
                                        fnp_info.get_meters_waiting = "0"b;

002536  aa   004632 2350 04   lda       2458,ic             007370 = 777757777777
002537  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.get_meters_waiting
                                                            STATEMENT 1 ON LINE 463
                                        call pxss$notify (FNP_METER_EVENT);

002540  aa   775240 3520 04   epp2      -1376,ic            000000 = 000000000073
002541  aa  6 00664 2521 00   spri2     pr6|436
002542  aa  6 00662 6211 00   eax1      pr6|434
002543  aa   004000 4310 07   fld       2048,dl
002544  aa  6 00044 3701 20   epp4      pr6|36,*
002545  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
002546  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 464
                                   end;

                                                            STATEMENT 1 ON LINE 465
                                   else ;

002547  aa   000146 7100 04   tra       102,ic              002715
                                                            STATEMENT 1 ON LINE 467
                              else if pcb.get_meters_waiting/* waiting for channel's meters */
                              then do;

002550  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
002551  aa  7 00004 2351 00   lda       pr7|4               pcb.get_meters_waiting
002552  aa   000200 3150 03   cana      128,du
002553  aa   000013 6000 04   tze       11,ic               002566
                                                            STATEMENT 1 ON LINE 469
                                   pcb.get_meters_waiting = "0"b;

002554  aa   004613 2350 04   lda       2443,ic             007367 = 777577777777
002555  aa  7 00004 3551 00   ansa      pr7|4               pcb.get_meters_waiting
                                                            STATEMENT 1 ON LINE 470
                                   call pxss$notify (FNP_METER_EVENT);

002556  aa   775222 3520 04   epp2      -1390,ic            000000 = 000000000073
002557  aa  6 00664 2521 00   spri2     pr6|436
002560  aa  6 00662 6211 00   eax1      pr6|434
002561  aa   004000 4310 07   fld       2048,dl
002562  aa  6 00044 3701 20   epp4      pr6|36,*
002563  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
002564  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 471
                              end;
002565  aa   000130 7100 04   tra       88,ic               002715
                                                            STATEMENT 1 ON LINE 473
                              else pcb.copied_meters_ready = "1"b;

002566  aa   000400 2350 03   lda       256,du
002567  aa  7 00004 2551 00   orsa      pr7|4               pcb.copied_meters_ready
                                                            STATEMENT 1 ON LINE 475
                         end;

                                                            STATEMENT 1 ON LINE 476
                    end;

002570  aa   000125 7100 04   tra       85,ic               002715
                                                            STATEMENT 1 ON LINE 478
                    else do;

                                                            STATEMENT 1 ON LINE 479
                         call get_line_number;

002571  aa   003252 6700 04   tsp4      1706,ic             006043
                                                            STATEMENT 1 ON LINE 480
                         if sub_mbx.io_cmd = wtx
                         then do;

002572  aa  6 00242 3735 20   epp7      pr6|162,*           subp
002573  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.io_cmd
002574  aa   000033 7350 00   als       27
002575  aa   000077 7330 00   lrs       63
002576  aa   000004 1160 07   cmpq      4,dl
002577  aa   000051 6010 04   tnz       41,ic               002650
                                                            STATEMENT 1 ON LINE 483
                              pcb.output_mbx_pending = "0"b;

002600  aa   004566 2350 04   lda       2422,ic             007366 = 776777777777
002601  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
002602  aa  5 00004 3551 00   ansa      pr5|4               pcb.output_mbx_pending
                                                            STATEMENT 1 ON LINE 484
                              dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (i));

002603  aa  6 00123 2361 00   ldq       pr6|83              i
002604  aa   000004 7360 00   qls       4
002605  aa  6 00240 3535 20   epp3      pr6|160,*           fnpp
002606  aa  3 00004 3535 66   epp3      pr3|4,*ql           dcw_list_array
002607  aa  6 00112 2535 00   spri3     pr6|74              dcwlptr
                                                            STATEMENT 1 ON LINE 485
                              chain_head_ptr = ptr (ttybp, bin (dcw_list (1).dcw_ptr, 18) - (tty_buf.absorig + dataoff));

002610  aa  6 00272 3515 20   epp1      pr6|186,*           ttybp
002611  aa  1 00001 2361 00   ldq       pr1|1               tty_buf.absorig
002612  aa   000001 0760 07   adq       1,dl
002613  aa  6 00715 7561 00   stq       pr6|461
002614  aa  3 00000 2351 00   lda       pr3|0               dcw_list.dcw_ptr
002615  aa   000066 7730 00   lrl       54
002616  aa  6 00715 1761 00   sbq       pr6|461
002617  aa  1 00000 3521 00   epp2      pr1|0
002620  aa   000000 3120 06   eawp2     0,ql
002621  aa  6 00146 2521 00   spri2     pr6|102             chain_head_ptr
                                                            STATEMENT 1 ON LINE 486
                              call tty_space_man$free_chain ((pcb.devx), OUTPUT, chain_head_ptr);
002622  aa  5 00000 2351 00   lda       pr5|0               pcb.devx
002623  aa   000066 7330 00   lrs       54
002624  aa  6 00715 7561 00   stq       pr6|461
002625  aa  6 00715 3521 00   epp2      pr6|461
002626  aa  6 00672 2521 00   spri2     pr6|442
002627  aa   775262 3520 04   epp2      -1358,ic            000111 = 400000000000
002630  aa  6 00674 2521 00   spri2     pr6|444
002631  aa  6 00146 3521 00   epp2      pr6|102             chain_head_ptr
002632  aa  6 00676 2521 00   spri2     pr6|446
002633  aa  6 00670 6211 00   eax1      pr6|440
002634  aa   014000 4310 07   fld       6144,dl
002635  aa  6 00044 3701 20   epp4      pr6|36,*
002636  la  4 00066 3521 20   epp2      pr4|54,*            tty_space_man$free_chain
002637  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 489
                              if sub_mbx.command_data (1) ^= "0"b
                                                            /* immediate send-output */
                              then call process_send_output (i, "1"b);

002640  aa  6 00242 3735 20   epp7      pr6|162,*           subp
002641  aa  7 00002 2351 00   lda       pr7|2               sub_mbx.command_data
002642  aa   000053 6000 04   tze       43,ic               002715
002643  aa   400000 2350 03   lda       131072,du
002644  aa  6 00715 7551 00   sta       pr6|461
002645  aa   004513 3520 04   epp2      2379,ic             007360 = 000004000000
002646  aa   001436 6700 04   tsp4      798,ic              004304
                                                            STATEMENT 1 ON LINE 493
                         end;

002647  aa   000046 7100 04   tra       38,ic               002715
                                                            STATEMENT 1 ON LINE 497
                         else do;

                                                            STATEMENT 1 ON LINE 498
                              call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o",
                                   sub_mbx.io_cmd, fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));

002650  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
002651  aa   775506 00 0074   desc9a    -1210,60            000356 = 144156063065
002652  aa  6 00716 00 0074   desc9a    pr6|462,60
002653  aa  7 00000 2351 00   lda       pr7|0
002654  aa   000010 7350 00   als       8
002655  aa   000076 7730 00   lrl       62
002656  aa  6 00715 7561 00   stq       pr6|461
002657  aa   775247 3520 04   epp2      -1369,ic            000126 = 000000000003
002660  aa  6 00744 2521 00   spri2     pr6|484
002661  aa  6 00716 3521 00   epp2      pr6|462
002662  aa  6 00746 2521 00   spri2     pr6|486
002663  aa   000033 7270 07   lxl7      27,dl
002664  aa  7 00001 3521 00   epp2      pr7|1               sub_mbx.io_cmd
002665  aa  2 00000 5035 17   abd       pr2|0,7
002666  aa  6 00750 2521 00   spri2     pr6|488
002667  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
002670  aa  5 00007 3521 00   epp2      pr5|7               fnp_info.fnp_tag
002671  aa  6 00752 2521 00   spri2     pr6|490
002672  aa  6 00715 3521 00   epp2      pr6|461
002673  aa  6 00754 2521 00   spri2     pr6|492
002674  aa   775225 3520 04   epp2      -1387,ic            000121 = 404000000021
002675  aa  6 00756 2521 00   spri2     pr6|494
002676  aa   775172 3520 04   epp2      -1414,ic            000070 = 524000000071
002677  aa  6 00760 2521 00   spri2     pr6|496
002700  aa   775167 3520 04   epp2      -1417,ic            000067 = 406000000010
002701  aa  6 00762 2521 00   spri2     pr6|498
002702  aa   775175 3520 04   epp2      -1411,ic            000077 = 526000000001
002703  aa  6 00764 2521 00   spri2     pr6|500
002704  aa   775162 3520 04   epp2      -1422,ic            000066 = 404000000012
002705  aa  6 00766 2521 00   spri2     pr6|502
002706  aa  6 00742 6211 00   eax1      pr6|482
002707  aa   024000 4310 07   fld       10240,dl
002710  aa  6 00044 3701 20   epp4      pr6|36,*
002711  la  4 00016 3521 20   epp2      pr4|14,*            syserr
002712  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 501
                              call report_fnp_crash;

002713  aa   004007 6700 04   tsp4      2055,ic             006722
                                                            STATEMENT 1 ON LINE 502
                              return;

002714  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 503
                         end;

                                                            STATEMENT 1 ON LINE 504
                    end;

                                                            STATEMENT 1 ON LINE 505
               end;

                                                            STATEMENT 1 ON LINE 506
          end;

002715  aa  6 00123 0541 00   aos       pr6|83              i
002716  aa   777522 7100 04   tra       -174,ic             002440
                                                            STATEMENT 1 ON LINE 508
          do i = 8 to 11;

002717  aa   000010 2360 07   ldq       8,dl
002720  aa  6 00123 7561 00   stq       pr6|83              i
002721  aa   000000 0110 03   nop       0,du
002722  aa  6 00123 2361 00   ldq       pr6|83              i
002723  aa   000013 1160 07   cmpq      11,dl
002724  aa   001132 6054 04   tpnz      602,ic              004056
                                                            STATEMENT 1 ON LINE 509
               if timwb (i) & ^no_response
               then do;

002725  aa  000 000 066 506   cmpb      (pr,ql),(),fill(0)
002726  aa  6 00120 00 0001   descb     pr6|80,1            timwb
002727  aa   000000 00 0000   descb     0,0
002730  aa   001124 6000 04   tze       596,ic              004054
002731  aa  6 00140 2351 00   lda       pr6|96              no_response
002732  aa   001122 6010 04   tnz       594,ic              004054
                                                            STATEMENT 1 ON LINE 511
                    subp = addr (datanet_mbx.fnp_sub_mbxes (i - 8));

002733  aa   000034 4020 07   mpy       28,dl
002734  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
002735  aa  7 77550 3735 06   epp7      pr7|-152,ql         datanet_mbx.fnp_sub_mbxes
002736  aa  6 00242 6535 00   spri7     pr6|162             subp
                                                            STATEMENT 1 ON LINE 512
                    call get_line_number;

002737  aa   003104 6700 04   tsp4      1604,ic             006043
                                                            STATEMENT 1 ON LINE 514
                    if sub_mbx.io_cmd = rcd
                    then do;

002740  aa  6 00242 3735 20   epp7      pr6|162,*           subp
002741  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.io_cmd
002742  aa   000033 7350 00   als       27
002743  aa   000077 7330 00   lrs       63
002744  aa  6 00715 7561 00   stq       pr6|461             sub_mbx.io_cmd
002745  aa   000001 1160 07   cmpq      1,dl
002746  aa   001035 6010 04   tnz       541,ic              004003
                                                            STATEMENT 1 ON LINE 517
                         if (sub_mbx.op_code = accept_direct_input) | (sub_mbx.op_code = send_output)
                              | (sub_mbx.op_code = input_in_mailbox)
                         then do;

002747  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.op_code
002750  aa   000022 7350 00   als       18
002751  aa   000077 7330 00   lrs       63
002752  aa  6 00667 7561 00   stq       pr6|439             sub_mbx.op_code
002753  aa   000102 1160 07   cmpq      66,dl
002754  aa  0 00512 7001 00   tsx0      pr0|330             r_e_as
002755  aa   000112 1160 07   cmpq      74,dl
002756  aa  6 00666 7551 00   sta       pr6|438
002757  aa  0 00512 7001 00   tsx0      pr0|330             r_e_as
002760  aa  6 00770 7551 00   sta       pr6|504
002761  aa   000005 6010 04   tnz       5,ic                002766
002762  aa   000105 1160 07   cmpq      69,dl
002763  aa   000003 6000 04   tze       3,ic                002766
002764  aa  6 00666 2351 00   lda       pr6|438
002765  aa   000024 6000 04   tze       20,ic               003011
                                                            STATEMENT 1 ON LINE 520
                              fnp_info.bleft_355 = fnp_sub_mbx.n_free_buffers - 4;

002766  aa  7 00000 2351 00   lda       pr7|0               fnp_sub_mbx.n_free_buffers
002767  aa   000022 7350 00   als       18
002770  aa   000066 7330 00   lrs       54
002771  aa   000004 1760 07   sbq       4,dl
002772  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
002773  aa  5 00027 7561 00   stq       pr5|23              fnp_info.bleft_355
                                                            STATEMENT 1 ON LINE 523
                              if fnp_info.bleft_355 < 0
                              then                          /* if above was too much correction */
                                   fnp_info.bleft_355 = 0;

002774  aa   000002 6050 04   tpl       2,ic                002776
002775  aa  5 00027 4501 00   stz       pr5|23              fnp_info.bleft_355
                                                            STATEMENT 1 ON LINE 528
                              if fnp_info.free_size > 16000000000
                              then do;

002776  aa  5 00061 2351 00   lda       pr5|49              fnp_info.free_size
002777  aa   000044 7330 00   lrs       36
003000  aa   775134 1170 04   cmpaq     -1444,ic            000134 = 000000000000 167153120000
003001  aa   000003 6044 04   tmoz      3,ic                003004
                                                            STATEMENT 1 ON LINE 530
                                   fnp_info.free_size = 0;

003002  aa  5 00061 4501 00   stz       pr5|49              fnp_info.free_size
                                                            STATEMENT 1 ON LINE 531
                                   fnp_info.free_count = 0;

003003  aa  5 00062 4501 00   stz       pr5|50              fnp_info.free_count
                                                            STATEMENT 1 ON LINE 532
                              end;

                                                            STATEMENT 1 ON LINE 534
                              fnp_info.free_size = fnp_info.free_size + fnp_info.bleft_355;

003004  aa  5 00061 2351 00   lda       pr5|49              fnp_info.free_size
003005  aa   000044 7330 00   lrs       36
003006  aa  5 00027 0331 00   adl       pr5|23              fnp_info.bleft_355
003007  aa  5 00061 7561 00   stq       pr5|49              fnp_info.free_size
                                                            STATEMENT 1 ON LINE 535
                              fnp_info.free_count = fnp_info.free_count + 1;

003010  aa  5 00062 0541 00   aos       pr5|50              fnp_info.free_count
                                                            STATEMENT 1 ON LINE 536
                         end;

                                                            STATEMENT 1 ON LINE 538
                         if sub_mbx.op_code = accept_direct_input | sub_mbx.op_code = input_in_mailbox
                         then fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;

003011  aa  6 00770 2351 00   lda       pr6|504
003012  aa   000003 6010 04   tnz       3,ic                003015
003013  aa  6 00666 2351 00   lda       pr6|438
003014  aa   000007 6000 04   tze       7,ic                003023
003015  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
003016  aa  5 00051 2351 00   lda       pr5|41              fnp_info.input_data_transactions
003017  aa   000044 7330 00   lrs       36
003020  aa   000001 0330 07   adl       1,dl
003021  aa  5 00051 7561 00   stq       pr5|41              fnp_info.input_data_transactions
003022  aa   000006 7100 04   tra       6,ic                003030
                                                            STATEMENT 1 ON LINE 540
                         else fnp_info.input_control_transactions = fnp_info.input_control_transactions + 1;

003023  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
003024  aa  5 00053 2351 00   lda       pr5|43              fnp_info.input_control_transactions
003025  aa   000044 7330 00   lrs       36
003026  aa   000001 0330 07   adl       1,dl
003027  aa  5 00053 7561 00   stq       pr5|43              fnp_info.input_control_transactions
                                                            STATEMENT 1 ON LINE 542
                         if sub_mbx.op_code = accept_new_terminal
                         then do;

003030  aa  6 00667 2361 00   ldq       pr6|439             sub_mbx.op_code
003031  aa   000100 1160 07   cmpq      64,dl
003032  aa   000165 6010 04   tnz       117,ic              003217
                                                            STATEMENT 1 ON LINE 546
                              pcb.line_type, dialup_info.line_type = bin (sub_mbx.command_data (1), 17);

003033  aa  7 00002 2351 00   lda       pr7|2               sub_mbx.command_data
003034  aa   000044 7730 00   lrl       36
003035  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003036  aa  3 00002 5521 14   stbq      pr3|2,14            pcb.line_type
003037  aa   000077 7370 00   lls       63
003040  aa  6 00260 5511 40   stba      pr6|176,40          dialup_info.line_type
                                                            STATEMENT 1 ON LINE 547
                              if sub_mbx.command_data (2)
                              then pcb.baud_rate = baud_table (bin (sub_mbx.command_data (2), 17));

003041  aa  7 00003 2351 00   lda       pr7|3               sub_mbx.command_data
003042  aa   000005 6000 04   tze       5,ic                003047
003043  aa   000044 7730 00   lrl       36
003044  ta   000025 2360 06   ldq       21,ql
003045  aa   000066 7370 00   lls       54
003046  aa  3 00002 5511 60   stba      pr3|2,60            pcb.baud_rate
                                                            STATEMENT 1 ON LINE 550
                              do j = 1 to n_sync_line_types while (sync_line_type (j) ^= pcb.line_type);

003047  aa   000012 2360 07   ldq       10,dl
003050  aa  6 00336 7561 00   stq       pr6|222
003051  aa   000001 2360 07   ldq       1,dl
003052  aa  6 00132 7561 00   stq       pr6|90              j
003053  aa   000000 0110 03   nop       0,du
003054  aa  6 00132 2361 00   ldq       pr6|90              j
003055  aa  6 00336 1161 00   cmpq      pr6|222
003056  aa   000012 6054 04   tpnz      10,ic               003070
003057  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
003060  aa  7 00002 2351 00   lda       pr7|2               pcb.line_type
003061  aa   000022 7350 00   als       18
003062  aa   000066 7330 00   lrs       54
003063  aa  6 00132 7271 00   lxl7      pr6|90              j
003064  ta   000013 1160 17   cmpq      11,7
003065  aa   000003 6000 04   tze       3,ic                003070
                                                            STATEMENT 1 ON LINE 551
                              end;

003066  aa  6 00132 0541 00   aos       pr6|90              j
003067  aa   777765 7100 04   tra       -11,ic              003054
                                                            STATEMENT 1 ON LINE 552
                              pcb.sync_line = (j <= n_sync_line_types);

003070  aa  6 00132 2361 00   ldq       pr6|90              j
003071  aa   000012 1160 07   cmpq      10,dl
003072  aa  0 00520 7001 00   tsx0      pr0|336             r_le_a
003073  aa   000004 7710 00   arl       4
003074  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
003075  aa  7 00004 6751 00   era       pr7|4               pcb.sync_line
003076  aa   020000 3750 03   ana       8192,du
003077  aa  7 00004 6551 00   ersa      pr7|4               pcb.sync_line
                                                            STATEMENT 1 ON LINE 554
                              if ^pcb.sync_line             /* asynchronous */
                              then bits_per_char = 10;

003100  aa  7 00004 2351 00   lda       pr7|4               pcb.sync_line
003101  aa   020000 3150 03   cana      8192,du
003102  aa   000004 6010 04   tnz       4,ic                003106
003103  aa   000012 2360 07   ldq       10,dl
003104  aa  6 00152 7561 00   stq       pr6|106             bits_per_char
003105  aa   000003 7100 04   tra       3,ic                003110
                                                            STATEMENT 1 ON LINE 556
                              else bits_per_char = 8;

003106  aa   000010 2360 07   ldq       8,dl
003107  aa  6 00152 7561 00   stq       pr6|106             bits_per_char
                                                            STATEMENT 1 ON LINE 558
                              max_buf_chars =
                                   divide (divide (pcb.baud_rate, bits_per_char, 17, 0), buf_per_second, 17, 0);

003110  aa  7 00002 2351 00   lda       pr7|2               pcb.baud_rate
003111  aa   000066 7330 00   lrs       54
003112  aa  6 00152 5061 00   div       pr6|106             bits_per_char
003113  aa   000012 5060 07   div       10,dl
003114  aa  6 00153 7561 00   stq       pr6|107             max_buf_chars
                                                            STATEMENT 1 ON LINE 560
                              pcb.max_buf_size = min (16 * divide (max_buf_chars + 67, 64, 17, 0), 128);

003115  aa   000103 0760 07   adq       67,dl
003116  aa   000100 5060 07   div       64,dl
003117  aa   000004 7360 00   qls       4
003120  aa   000200 1160 07   cmpq      128,dl
003121  aa   000002 6040 04   tmi       2,ic                003123
003122  aa   000200 2360 07   ldq       128,dl
003123  aa   000066 7370 00   lls       54
003124  aa  7 00003 5511 60   stba      pr7|3,60            pcb.max_buf_size
                                                            STATEMENT 1 ON LINE 562
                              if pcb.line_type = LINE_COLTS
                              then pcb.max_buf_size = 128;

003125  aa  7 00002 2351 00   lda       pr7|2               pcb.line_type
003126  aa   000022 7350 00   als       18
003127  aa   000066 7330 00   lrs       54
003130  aa   000023 1160 07   cmpq      19,dl
003131  aa   000003 6010 04   tnz       3,ic                003134
003132  aa   000200 2350 03   lda       128,du
003133  aa  7 00003 5511 60   stba      pr7|3,60            pcb.max_buf_size
                                                            STATEMENT 1 ON LINE 565
                              dialup_info.baud_rate = pcb.baud_rate;

003134  aa  7 00002 2351 00   lda       pr7|2               pcb.baud_rate
003135  aa   000022 7710 00   arl       18
003136  aa  6 00260 5511 14   stba      pr6|176,14          dialup_info.baud_rate
                                                            STATEMENT 1 ON LINE 566
                              dialup_info.max_buf_size = pcb.max_buf_size;

003137  aa  7 00003 2351 00   lda       pr7|3               pcb.max_buf_size
003140  aa   000011 7350 00   als       9
003141  aa  6 00261 5511 40   stba      pr6|177,40          dialup_info.max_buf_size
                                                            STATEMENT 1 ON LINE 567
                              dialup_info.buffer_pad = 0;

003142  aa   000000 2350 03   lda       0,du
003143  aa  6 00260 5511 20   stba      pr6|176,20          dialup_info.buffer_pad
                                                            STATEMENT 1 ON LINE 568
                              dialup_info.receive_mode_device = (dialup_info.line_type = LINE_ETX);

003144  aa  6 00260 2351 00   lda       pr6|176             dialup_info.line_type
003145  aa   000077 7730 00   lrl       63
003146  aa   000010 1160 07   cmpq      8,dl
003147  aa  0 00512 7001 00   tsx0      pr0|330             r_e_as
003150  aa   000011 7710 00   arl       9
003151  aa  6 00261 6751 00   era       pr6|177             dialup_info.receive_mode_device
003152  aa   000400 3750 03   ana       256,du
003153  aa  6 00261 6551 00   ersa      pr6|177             dialup_info.receive_mode_device
                                                            STATEMENT 1 ON LINE 569
                              dialup_info.pad = "0"b;

003154  aa   777400 2350 03   lda       261888,du
003155  aa  6 00261 3551 00   ansa      pr6|177             dialup_info.pad
                                                            STATEMENT 1 ON LINE 570
                              pcb.dialed = "1"b;

003156  aa   200000 2350 03   lda       65536,du
003157  aa  7 00004 2551 00   orsa      pr7|4               pcb.dialed
                                                            STATEMENT 1 ON LINE 572
                              sub_mbx.op_code = terminal_accepted;

003160  aa   000000 2350 03   lda       0,du
003161  aa  6 00242 3715 20   epp5      pr6|162,*           subp
003162  aa  5 00001 5511 10   stba      pr5|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 574
                              sub_mbx.cmd_data_len = 3;

003163  aa   000003 2350 03   lda       3,du
003164  aa  5 00001 5511 20   stba      pr5|1,20            sub_mbx.cmd_data_len
                                                            STATEMENT 1 ON LINE 575
                              if ^pcb.high_speed            /* less than 1200 baud */
                              then addr (sub_mbx.command_data) -> unal_number = 2;

003165  aa  7 00004 2351 00   lda       pr7|4               pcb.high_speed
003166  aa   040000 3150 03   cana      16384,du
003167  aa   000004 6010 04   tnz       4,ic                003173
003170  aa   000002 2350 03   lda       2,du
003171  aa  5 00002 5511 60   stba      pr5|2,60            unal_number
003172  aa   000003 7100 04   tra       3,ic                003175
                                                            STATEMENT 1 ON LINE 578
                              else addr (sub_mbx.command_data) -> unal_number = 4;

003173  aa   000004 2350 03   lda       4,du
003174  aa  5 00002 5511 60   stba      pr5|2,60            unal_number
                                                            STATEMENT 1 ON LINE 580
                              sub_mbx.io_cmd = wcd;

003175  aa   000003 2350 07   lda       3,dl
003176  aa  5 00001 5511 04   stba      pr5|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 581
                              call return_mbx (i);

003177  aa   004155 3520 04   epp2      2157,ic             007354 = 000002000000
003200  aa   003052 6700 04   tsp4      1578,ic             006252
                                                            STATEMENT 1 ON LINE 582
                              interrupt_info = unspec (dialup_info);

003201  aa  6 00260 2371 00   ldaq      pr6|176
003202  aa  6 00256 7571 00   staq      pr6|174             interrupt_info
                                                            STATEMENT 1 ON LINE 583
                              call channel_manager$interrupt (devx, DIALUP, interrupt_info);

003203  aa  6 00134 3521 00   epp2      pr6|92              devx
003204  aa  6 00672 2521 00   spri2     pr6|442
003205  aa   774724 3520 04   epp2      -1580,ic            000131 = 000000000001
003206  aa  6 00674 2521 00   spri2     pr6|444
003207  aa  6 00256 3521 00   epp2      pr6|174             interrupt_info
003210  aa  6 00676 2521 00   spri2     pr6|446
003211  aa  6 00670 6211 00   eax1      pr6|440
003212  aa   014000 4310 07   fld       6144,dl
003213  aa  6 00044 3701 20   epp4      pr6|36,*
003214  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003215  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 585
                         end;

003216  aa   000636 7100 04   tra       414,ic              004054
                                                            STATEMENT 1 ON LINE 588
                         else if sub_mbx.op_code = disconnected_line
                         then do;

003217  aa   000101 1160 07   cmpq      65,dl
003220  aa   000025 6010 04   tnz       21,ic               003245
                                                            STATEMENT 1 ON LINE 590
                              pcb.dialed = "0"b;

003221  aa   004131 2350 04   lda       2137,ic             007352 = 577777777777
003222  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003223  aa  3 00004 3551 00   ansa      pr3|4               pcb.dialed
                                                            STATEMENT 1 ON LINE 591
                              call throw_away_output;

003224  aa   003404 6700 04   tsp4      1796,ic             006630
                                                            STATEMENT 1 ON LINE 592
                              call channel_manager$interrupt (devx, HANGUP, ""b);

003225  aa   774713 2370 04   ldaq      -1589,ic            000140 = 000000000000 000000000000
003226  aa  6 00740 7571 00   staq      pr6|480
003227  aa  6 00134 3521 00   epp2      pr6|92              devx
003230  aa  6 00672 2521 00   spri2     pr6|442
003231  aa   774551 3520 04   epp2      -1687,ic            000002 = 000000000002
003232  aa  6 00674 2521 00   spri2     pr6|444
003233  aa  6 00740 3521 00   epp2      pr6|480
003234  aa  6 00676 2521 00   spri2     pr6|446
003235  aa  6 00670 6211 00   eax1      pr6|440
003236  aa   014000 4310 07   fld       6144,dl
003237  aa  6 00044 3701 20   epp4      pr6|36,*
003240  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003241  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 593
                              call free_mbx (i);

003242  aa   004112 3520 04   epp2      2122,ic             007354 = 000002000000
003243  aa   003017 6700 04   tsp4      1551,ic             006262
                                                            STATEMENT 1 ON LINE 595
                         end;

003244  aa   000610 7100 04   tra       392,ic              004054
                                                            STATEMENT 1 ON LINE 597
                         else if sub_mbx.op_code = wru_timeout
                         then do;

003245  aa   000114 1160 07   cmpq      76,dl
003246  aa   000025 6010 04   tnz       21,ic               003273
                                                            STATEMENT 1 ON LINE 599
                              if pcb.dialed
                              then call channel_manager$interrupt (devx, WRU_TIMEOUT, ""b);
003247  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003250  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
003251  aa   200000 3150 03   cana      65536,du
003252  aa   000016 6000 04   tze       14,ic               003270
003253  aa   774665 2370 04   ldaq      -1611,ic            000140 = 000000000000 000000000000
003254  aa  6 00740 7571 00   staq      pr6|480
003255  aa  6 00134 3521 00   epp2      pr6|92              devx
003256  aa  6 00672 2521 00   spri2     pr6|442
003257  aa   774606 3520 04   epp2      -1658,ic            000065 = 000000000013
003260  aa  6 00674 2521 00   spri2     pr6|444
003261  aa  6 00740 3521 00   epp2      pr6|480
003262  aa  6 00676 2521 00   spri2     pr6|446
003263  aa  6 00670 6211 00   eax1      pr6|440
003264  aa   014000 4310 07   fld       6144,dl
003265  aa  6 00044 3701 20   epp4      pr6|36,*
003266  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003267  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 601
                              call free_mbx (i);

003270  aa   004064 3520 04   epp2      2100,ic             007354 = 000002000000
003271  aa   002771 6700 04   tsp4      1529,ic             006262
                                                            STATEMENT 1 ON LINE 602
                         end;

003272  aa   000562 7100 04   tra       370,ic              004054
                                                            STATEMENT 1 ON LINE 604
                         else if sub_mbx.op_code = break_condition
                         then do;

003273  aa   000113 1160 07   cmpq      75,dl
003274  aa   000031 6010 04   tnz       25,ic               003325
                                                            STATEMENT 1 ON LINE 607
                              if pcb.dialed
                              then do;

003275  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003276  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
003277  aa   200000 3150 03   cana      65536,du
003300  aa   000022 6000 04   tze       18,ic               003322
                                                            STATEMENT 1 ON LINE 609
                                   if pcb.hndlquit
                                   then call throw_away_output;

003301  aa  3 00004 2351 00   lda       pr3|4               pcb.hndlquit
003302  aa   004000 3150 03   cana      2048,du
003303  aa   000002 6000 04   tze       2,ic                003305
003304  aa   003324 6700 04   tsp4      1748,ic             006630
                                                            STATEMENT 1 ON LINE 611
                                   call channel_manager$interrupt (devx, QUIT, ""b);

003305  aa   774633 2370 04   ldaq      -1637,ic            000140 = 000000000000 000000000000
003306  aa  6 00740 7571 00   staq      pr6|480
003307  aa  6 00134 3521 00   epp2      pr6|92              devx
003310  aa  6 00672 2521 00   spri2     pr6|442
003311  aa   774603 3520 04   epp2      -1661,ic            000114 = 000000000010
003312  aa  6 00674 2521 00   spri2     pr6|444
003313  aa  6 00740 3521 00   epp2      pr6|480
003314  aa  6 00676 2521 00   spri2     pr6|446
003315  aa  6 00670 6211 00   eax1      pr6|440
003316  aa   014000 4310 07   fld       6144,dl
003317  aa  6 00044 3701 20   epp4      pr6|36,*
003320  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003321  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 612
                              end;

                                                            STATEMENT 1 ON LINE 613
                              call free_mbx (i);

003322  aa   004032 3520 04   epp2      2074,ic             007354 = 000002000000
003323  aa   002737 6700 04   tsp4      1503,ic             006262
                                                            STATEMENT 1 ON LINE 614
                         end;

003324  aa   000530 7100 04   tra       344,ic              004054
                                                            STATEMENT 1 ON LINE 617
                         else if sub_mbx.op_code = send_output
                         then do;

003325  aa   000105 1160 07   cmpq      69,dl
003326  aa   000016 6010 04   tnz       14,ic               003344
                                                            STATEMENT 1 ON LINE 620
                              call free_mbx (i);

003327  aa   004025 3520 04   epp2      2069,ic             007354 = 000002000000
003330  aa   002732 6700 04   tsp4      1498,ic             006262
                                                            STATEMENT 1 ON LINE 621
                              if pcb.dialed
                              then call process_send_output (-1, "1"b);

003331  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
003332  aa  7 00004 2351 00   lda       pr7|4               pcb.dialed
003333  aa   200000 3150 03   cana      65536,du
003334  aa   000520 6000 04   tze       336,ic              004054
003335  aa   000001 3360 07   lcq       1,dl
003336  aa  6 00666 7561 00   stq       pr6|438
003337  aa   400000 2350 03   lda       131072,du
003340  aa  6 00770 7551 00   sta       pr6|504
003341  aa   004003 3520 04   epp2      2051,ic             007344 = 000004000000
003342  aa   000742 6700 04   tsp4      482,ic              004304
                                                            STATEMENT 1 ON LINE 624
                         end;

003343  aa   000511 7100 04   tra       329,ic              004054
                                                            STATEMENT 1 ON LINE 627
                         else if sub_mbx.op_code = accept_direct_input
                         then do;

003344  aa   000112 1160 07   cmpq      74,dl
003345  aa   000016 6010 04   tnz       14,ic               003363
                                                            STATEMENT 1 ON LINE 630
                              if pcb.dialed
                              then call process_accept_input;

003346  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003347  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
003350  aa   200000 3150 03   cana      65536,du
003351  aa   000003 6000 04   tze       3,ic                003354
003352  aa   001411 6700 04   tsp4      777,ic              004763
003353  aa   000501 7100 04   tra       321,ic              004054
                                                            STATEMENT 1 ON LINE 633
                              else do;

                                                            STATEMENT 1 ON LINE 634
                                   sub_mbx.io_cmd = wcd;

003354  aa   000003 2350 07   lda       3,dl
003355  aa  7 00001 5511 04   stba      pr7|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 635
                                   sub_mbx.op_code = disconnect_this_line;

003356  aa   001000 2350 07   lda       512,dl
003357  aa  7 00001 5511 10   stba      pr7|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 636
                                   call return_mbx (i);

003360  aa   003774 3520 04   epp2      2044,ic             007354 = 000002000000
003361  aa   002671 6700 04   tsp4      1465,ic             006252
                                                            STATEMENT 1 ON LINE 637
                              end;

                                                            STATEMENT 1 ON LINE 638
                         end;

003362  aa   000472 7100 04   tra       314,ic              004054
                                                            STATEMENT 1 ON LINE 640
                         else if sub_mbx.op_code = error_message
                         then do;

003363  aa   000115 1160 07   cmpq      77,dl
003364  aa   000111 6010 04   tnz       73,ic               003475
                                                            STATEMENT 1 ON LINE 642
                              offset = bin (error_msg.data (1), 18);

003365  aa  7 00002 2351 00   lda       pr7|2               error_msg.data
003366  aa   000066 7730 00   lrl       54
003367  aa  6 00163 7561 00   stq       pr6|115             offset
                                                            STATEMENT 1 ON LINE 644
                              if offset > 0 & offset <= hbound (dn355_messages$error_messages, 1)
                              then do;

003370  aa  6 00163 2361 00   ldq       pr6|115             offset
003371  aa   000021 6044 04   tmoz      17,ic               003412
003372  aa   000012 1160 07   cmpq      10,dl
003373  aa   000017 6054 04   tpnz      15,ic               003412
                                                            STATEMENT 1 ON LINE 646
                                   offset = dn355_messages$error_messages (offset);

003374  aa  6 00044 3701 20   epp4      pr6|36,*
003375  la  4 00052 3535 20   epp3      pr4|42,*
003376  aa  3 77777 2361 06   ldq       pr3|-1,ql           dn355_messages$error_messages
003377  aa  6 00163 7561 00   stq       pr6|115             offset
                                                            STATEMENT 1 ON LINE 648
                                   reasonp = addr (dn355_messages$error_messages);

003400  la  4 00052 3515 20   epp1      pr4|42,*            dn355_messages$error_messages
003401  aa  6 00250 2515 00   spri1     pr6|168             reasonp
                                                            STATEMENT 1 ON LINE 650
                                   reasonp = ptr (reasonp, offset);
003402  aa   000000 3114 06   eawp1     0,ql
003403  aa  6 00250 2515 00   spri1     pr6|168             reasonp
                                                            STATEMENT 1 ON LINE 652
                                   reason_msg = dn355_reason.msg;

003404  aa  1 00000 2351 00   lda       pr1|0               dn355_reason.length
003405  aa   000077 7330 00   lrs       63
003406  aa  040 100 100 540   mlr       (pr,rl),(pr),fill(040)
003407  aa  1 00000 20 0006   desc9a    pr1|0(1),ql         dn355_reason.msg
003410  aa  6 00210 00 0100   desc9a    pr6|136,64          reason_msg
                                                            STATEMENT 1 ON LINE 653
                              end;

003411  aa   000004 7100 04   tra       4,ic                003415
                                                            STATEMENT 1 ON LINE 655
                              else reason_msg = "unrecognized error ^o ^o ^o";

003412  aa  040 100 100 404   mlr       (ic),(pr),fill(040)
003413  aa   774553 00 0033   desc9a    -1685,27            000165 = 165156162145
003414  aa  6 00210 00 0100   desc9a    pr6|136,64          reason_msg
                                                            STATEMENT 1 ON LINE 657
                              do ix = 1 to 3;

003415  aa   000001 2360 07   ldq       1,dl
003416  aa  6 00124 7561 00   stq       pr6|84              ix
003417  aa   000000 0110 03   nop       0,du
003420  aa  6 00124 2361 00   ldq       pr6|84              ix
003421  aa   000003 1160 07   cmpq      3,dl
003422  aa   000014 6054 04   tpnz      12,ic               003436
                                                            STATEMENT 1 ON LINE 658
                                   full_words (ix) = bin (error_msg.data (ix + 1), 18);

003423  aa   000022 4020 07   mpy       18,dl
003424  aa  6 00242 3735 20   epp7      pr6|162,*           subp
003425  aa  003 100 060 506   csl       (pr,ql),(pr),fill(0),bool(move)
003426  aa  7 00002 00 0022   descb     pr7|2,18            error_msg.data
003427  aa  6 00056 00 0044   descb     pr6|46,36
003430  aa  6 00056 2351 00   lda       pr6|46
003431  aa   000066 7730 00   lrl       54
003432  aa  6 00124 7271 00   lxl7      pr6|84              ix
003433  aa  6 00204 7561 17   stq       pr6|132,7           full_words
                                                            STATEMENT 1 ON LINE 659
                              end;

003434  aa  6 00124 0541 00   aos       pr6|84              ix
003435  aa   777763 7100 04   tra       -13,ic              003420
                                                            STATEMENT 1 ON LINE 660
                              call syserr (just_tell, "dn355: Message from FNP ^a: " || reason_msg, fnp_info.fnp_tag,
                                   full_words);

003436  aa  040 100 100 404   mlr       (ic),(pr),fill(040)
003437  aa   774520 00 0034   desc9a    -1712,28            000156 = 144156063065
003440  aa  6 00772 00 0034   desc9a    pr6|506,28
003441  aa  040 100 100 500   mlr       (pr),(pr),fill(040)
003442  aa  6 00210 00 0100   desc9a    pr6|136,64          reason_msg
003443  aa  6 01001 00 0100   desc9a    pr6|513,64
003444  aa   774446 3520 04   epp2      -1754,ic            000112 = 000000000000
003445  aa  6 00720 2521 00   spri2     pr6|464
003446  aa  6 00772 3521 00   epp2      pr6|506
003447  aa  6 00722 2521 00   spri2     pr6|466
003450  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
003451  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
003452  aa  6 00724 2521 00   spri2     pr6|468
003453  aa  6 00205 3521 00   epp2      pr6|133             full_words
003454  aa  6 00726 2521 00   spri2     pr6|470
003455  aa   774444 3520 04   epp2      -1756,ic            000121 = 404000000021
003456  aa  6 00730 2521 00   spri2     pr6|472
003457  aa   774405 3520 04   epp2      -1787,ic            000064 = 524000000134
003460  aa  6 00732 2521 00   spri2     pr6|474
003461  aa   774416 3520 04   epp2      -1778,ic            000077 = 526000000001
003462  aa  6 00734 2521 00   spri2     pr6|476
003463  aa   774463 3520 04   epp2      -1741,ic            000146 = 404100000021
003464  aa  6 00736 2521 00   spri2     pr6|478
003465  aa  6 00716 6211 00   eax1      pr6|462
003466  aa   020000 4310 07   fld       8192,dl
003467  aa  6 00044 3701 20   epp4      pr6|36,*
003470  la  4 00016 3521 20   epp2      pr4|14,*            syserr
003471  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 662
                              call free_mbx (i);

003472  aa   003662 3520 04   epp2      1970,ic             007354 = 000002000000
003473  aa   002567 6700 04   tsp4      1399,ic             006262
                                                            STATEMENT 1 ON LINE 663
                         end;

003474  aa   000360 7100 04   tra       240,ic              004054
                                                            STATEMENT 1 ON LINE 665
                         else if sub_mbx.op_code = input_in_mailbox
                         then do;

003475  aa   000102 1160 07   cmpq      66,dl
003476  aa   000016 6010 04   tnz       14,ic               003514
                                                            STATEMENT 1 ON LINE 667
                              if pcb.dialed
                              then call process_input_in_mbx;

003477  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003500  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
003501  aa   200000 3150 03   cana      65536,du
003502  aa   000003 6000 04   tze       3,ic                003505
003503  aa   001635 6700 04   tsp4      925,ic              005340
003504  aa   000350 7100 04   tra       232,ic              004054
                                                            STATEMENT 1 ON LINE 669
                              else do;

                                                            STATEMENT 1 ON LINE 670
                                   sub_mbx.io_cmd = wcd;

003505  aa   000003 2350 07   lda       3,dl
003506  aa  7 00001 5511 04   stba      pr7|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 671
                                   sub_mbx.op_code = disconnect_this_line;

003507  aa   001000 2350 07   lda       512,dl
003510  aa  7 00001 5511 10   stba      pr7|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 672
                                   call return_mbx (i);
003511  aa   003643 3520 04   epp2      1955,ic             007354 = 000002000000
003512  aa   002540 6700 04   tsp4      1376,ic             006252
                                                            STATEMENT 1 ON LINE 673
                              end;

                                                            STATEMENT 1 ON LINE 674
                         end;

003513  aa   000341 7100 04   tra       225,ic              004054
                                                            STATEMENT 1 ON LINE 676
                         else if sub_mbx.op_code >= first_acu_op_code & sub_mbx.op_code <= last_acu_op_code
                         then do;

003514  aa   000120 1160 07   cmpq      80,dl
003515  aa   000027 6040 04   tmi       23,ic               003544
003516  aa   000123 1160 07   cmpq      83,dl
003517  aa   000025 6054 04   tpnz      21,ic               003544
                                                            STATEMENT 1 ON LINE 678
                              interrupt_info = bit (bin (sub_mbx.op_code, 9));

003520  aa  6 00667 2351 00   lda       pr6|439             sub_mbx.op_code
003521  aa   000002 6050 04   tpl       2,ic                003523
003522  aa   000000 5310 00   neg       0
003523  aa   000033 7350 00   als       27
003524  aa  0 00022 3771 00   anaq      pr0|18              = 777000000000 000000000000
003525  aa  6 00256 7571 00   staq      pr6|174             interrupt_info
                                                            STATEMENT 1 ON LINE 679
                              call channel_manager$interrupt (devx, DIAL_STATUS, interrupt_info);

003526  aa  6 00134 3521 00   epp2      pr6|92              devx
003527  aa  6 00672 2521 00   spri2     pr6|442
003530  aa   774351 3520 04   epp2      -1815,ic            000101 = 000000000012
003531  aa  6 00674 2521 00   spri2     pr6|444
003532  aa  6 00256 3521 00   epp2      pr6|174             interrupt_info
003533  aa  6 00676 2521 00   spri2     pr6|446
003534  aa  6 00670 6211 00   eax1      pr6|440
003535  aa   014000 4310 07   fld       6144,dl
003536  aa  6 00044 3701 20   epp4      pr6|36,*
003537  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003540  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 680
                              call free_mbx (i);

003541  aa   003613 3520 04   epp2      1931,ic             007354 = 000002000000
003542  aa   002520 6700 04   tsp4      1360,ic             006262
                                                            STATEMENT 1 ON LINE 681
                         end;

003543  aa   000311 7100 04   tra       201,ic              004054
                                                            STATEMENT 1 ON LINE 683
                         else if sub_mbx.op_code = line_status
                         then do;

003544  aa   000124 1160 07   cmpq      84,dl
003545  aa   000022 6010 04   tnz       18,ic               003567
                                                            STATEMENT 1 ON LINE 685
                              interrupt_info = substr (unspec (sub_mbx.command_data), 1, 72);

003546  aa  7 00002 2351 00   lda       pr7|2
003547  aa  7 00003 2361 00   ldq       pr7|3
003550  aa  6 00256 7571 00   staq      pr6|174             interrupt_info
                                                            STATEMENT 1 ON LINE 686
                              call channel_manager$interrupt (devx, LINE_STATUS, interrupt_info);

003551  aa  6 00134 3521 00   epp2      pr6|92              devx
003552  aa  6 00672 2521 00   spri2     pr6|442
003553  aa   774345 3520 04   epp2      -1819,ic            000120 = 000000000011
003554  aa  6 00674 2521 00   spri2     pr6|444
003555  aa  6 00256 3521 00   epp2      pr6|174             interrupt_info
003556  aa  6 00676 2521 00   spri2     pr6|446
003557  aa  6 00670 6211 00   eax1      pr6|440
003560  aa   014000 4310 07   fld       6144,dl
003561  aa  6 00044 3701 20   epp4      pr6|36,*
003562  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003563  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 687
                              call free_mbx (i);

003564  aa   003570 3520 04   epp2      1912,ic             007354 = 000002000000
003565  aa   002475 6700 04   tsp4      1341,ic             006262
                                                            STATEMENT 1 ON LINE 688
                         end;

003566  aa   000266 7100 04   tra       182,ic              004054
                                                            STATEMENT 1 ON LINE 690
                         else if sub_mbx.op_code = ack_echnego_init
                         then do;

003567  aa   000106 1160 07   cmpq      70,dl
003570  aa   000021 6010 04   tnz       17,ic               003611
                                                            STATEMENT 1 ON LINE 692
                              call free_mbx (i);

003571  aa   003563 3520 04   epp2      1907,ic             007354 = 000002000000
003572  aa   002470 6700 04   tsp4      1336,ic             006262
                                                            STATEMENT 1 ON LINE 693
                              call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_INIT, "0"b);

003573  aa   774345 2370 04   ldaq      -1819,ic            000140 = 000000000000 000000000000
003574  aa  6 00740 7571 00   staq      pr6|480
003575  aa  6 00134 3521 00   epp2      pr6|92              devx
003576  aa  6 00672 2521 00   spri2     pr6|442
003577  aa   774202 3520 04   epp2      -1918,ic            000001 = 000000000015
003600  aa  6 00674 2521 00   spri2     pr6|444
003601  aa  6 00740 3521 00   epp2      pr6|480
003602  aa  6 00676 2521 00   spri2     pr6|446
003603  aa  6 00670 6211 00   eax1      pr6|440
003604  aa   014000 4310 07   fld       6144,dl
003605  aa  6 00044 3701 20   epp4      pr6|36,*
003606  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003607  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 694
                         end;

003610  aa   000244 7100 04   tra       164,ic              004054
                                                            STATEMENT 1 ON LINE 696
                         else if sub_mbx.op_code = ack_echnego_stop
                         then do;

003611  aa   000107 1160 07   cmpq      71,dl
003612  aa   000021 6010 04   tnz       17,ic               003633
                                                            STATEMENT 1 ON LINE 698
                              call free_mbx (i);

003613  aa   003541 3520 04   epp2      1889,ic             007354 = 000002000000
003614  aa   002446 6700 04   tsp4      1318,ic             006262
                                                            STATEMENT 1 ON LINE 699
                              call channel_manager$interrupt (devx, ACKNOWLEDGE_ECHNEGO_STOP, "0"b);

003615  aa   774323 2370 04   ldaq      -1837,ic            000140 = 000000000000 000000000000
003616  aa  6 00740 7571 00   staq      pr6|480
003617  aa  6 00134 3521 00   epp2      pr6|92              devx
003620  aa  6 00672 2521 00   spri2     pr6|442
003621  aa   774172 3520 04   epp2      -1926,ic            000013 = 000000000016
003622  aa  6 00674 2521 00   spri2     pr6|444
003623  aa  6 00740 3521 00   epp2      pr6|480
003624  aa  6 00676 2521 00   spri2     pr6|446
003625  aa  6 00670 6211 00   eax1      pr6|440
003626  aa   014000 4310 07   fld       6144,dl
003627  aa  6 00044 3701 20   epp4      pr6|36,*
003630  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003631  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 700
                         end;

003632  aa   000222 7100 04   tra       146,ic              004054
                                                            STATEMENT 1 ON LINE 702
                         else if sub_mbx.op_code = line_masked
                         then do;

003633  aa   000103 1160 07   cmpq      67,dl
003634  aa   000107 6010 04   tnz       71,ic               003743
                                                            STATEMENT 1 ON LINE 704
                              pcb.dialed, pcb.listen = "0"b;

003635  aa   003515 2350 04   lda       1869,ic             007352 = 577777777777
003636  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
003637  aa  3 00004 3551 00   ansa      pr3|4               pcb.dialed
003640  aa   003502 2350 04   lda       1858,ic             007342 = 377777777777
003641  aa  3 00004 3551 00   ansa      pr3|4               pcb.listen
                                                            STATEMENT 1 ON LINE 705
                              call throw_away_output;

003642  aa   002766 6700 04   tsp4      1526,ic             006630
                                                            STATEMENT 1 ON LINE 706
                              call syserr (just_tell,
                                   "dn355: FNP masked channel ^a.h^d^[0^;^]^d for excessive interrupts", fnp_info.fnp_tag,
                                   binary (sub_mbx.line_number.la_no, 3), (binary (sub_mbx.line_number.slot_no, 6) < 10),
                                   binary (sub_mbx.line_number.slot_no, 6));

003643  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
003644  aa   774573 00 0104   desc9a    -1669,68            000436 = 144156063065
003645  aa  6 00716 00 0104   desc9a    pr6|462,68
003646  aa  6 00242 2351 20   lda       pr6|162,*           sub_mbx.la_no
003647  aa   000011 7350 00   als       9
003650  aa   000105 7730 00   lrl       69
003651  aa  6 00667 7561 00   stq       pr6|439
003652  aa  6 00242 2351 20   lda       pr6|162,*           sub_mbx.slot_no
003653  aa   000014 7350 00   als       12
003654  aa  0 00014 3771 00   anaq      pr0|12              = 770000000000 000000000000
003655  aa  6 00771 7551 00   sta       pr6|505             sub_mbx.slot_no
003656  aa   000102 7730 00   lrl       66
003657  aa   000012 1160 07   cmpq      10,dl
003660  aa  0 00474 7001 00   tsx0      pr0|316             r_l_a
003661  aa  6 00770 7551 00   sta       pr6|504
003662  aa  6 00771 2351 00   lda       pr6|505             sub_mbx.slot_no
003663  aa   000102 7730 00   lrl       66
003664  aa  6 00666 7561 00   stq       pr6|438
003665  aa   774225 3520 04   epp2      -1899,ic            000112 = 000000000000
003666  aa  6 01024 2521 00   spri2     pr6|532
003667  aa  6 00716 3521 00   epp2      pr6|462
003670  aa  6 01026 2521 00   spri2     pr6|534
003671  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
003672  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
003673  aa  6 01030 2521 00   spri2     pr6|536
003674  aa  6 00667 3521 00   epp2      pr6|439
003675  aa  6 01032 2521 00   spri2     pr6|538
003676  aa  6 00770 3521 00   epp2      pr6|504
003677  aa  6 01034 2521 00   spri2     pr6|540
003700  aa  6 00666 3521 00   epp2      pr6|438
003701  aa  6 01036 2521 00   spri2     pr6|542
003702  aa   774217 3520 04   epp2      -1905,ic            000121 = 404000000021
003703  aa  6 01040 2521 00   spri2     pr6|544
003704  aa   774157 3520 04   epp2      -1937,ic            000063 = 524000000102
003705  aa  6 01042 2521 00   spri2     pr6|546
003706  aa   774171 3520 04   epp2      -1927,ic            000077 = 526000000001
003707  aa  6 01044 2521 00   spri2     pr6|548
003710  aa   774220 3520 04   epp2      -1904,ic            000130 = 404000000003
003711  aa  6 01046 2521 00   spri2     pr6|550
003712  aa   774150 3520 04   epp2      -1944,ic            000062 = 514000000001
003713  aa  6 01050 2521 00   spri2     pr6|552
003714  aa   774145 3520 04   epp2      -1947,ic            000061 = 404000000006
003715  aa  6 01052 2521 00   spri2     pr6|554
003716  aa  6 01022 6211 00   eax1      pr6|530
003717  aa   030000 4310 07   fld       12288,dl
003720  aa  6 00044 3701 20   epp4      pr6|36,*
003721  la  4 00016 3521 20   epp2      pr4|14,*            syserr
003722  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 710
                              call channel_manager$interrupt (devx, MASKED, ""b);

003723  aa   774215 2370 04   ldaq      -1907,ic            000140 = 000000000000 000000000000
003724  aa  6 00740 7571 00   staq      pr6|480
003725  aa  6 00134 3521 00   epp2      pr6|92              devx
003726  aa  6 00672 2521 00   spri2     pr6|442
003727  aa   774154 3520 04   epp2      -1940,ic            000103 = 000000000021
003730  aa  6 00674 2521 00   spri2     pr6|444
003731  aa  6 00740 3521 00   epp2      pr6|480
003732  aa  6 00676 2521 00   spri2     pr6|446
003733  aa  6 00670 6211 00   eax1      pr6|440
003734  aa   014000 4310 07   fld       6144,dl
003735  aa  6 00044 3701 20   epp4      pr6|36,*
003736  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
003737  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 711
                              call free_mbx (i);

003740  aa   003414 3520 04   epp2      1804,ic             007354 = 000002000000
003741  aa   002321 6700 04   tsp4      1233,ic             006262
                                                            STATEMENT 1 ON LINE 713
                         end;

003742  aa   000112 7100 04   tra       74,ic               004054
                                                            STATEMENT 1 ON LINE 715
                         else do;

                                                            STATEMENT 1 ON LINE 716
                              call syserr (beeper, "dn355: unrecognized op code ^o with rcd from FNP ^a for devx ^o",
                                   sub_mbx.op_code, fnp_info.fnp_tag, devx);

003743  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
003744  aa   774432 00 0100   desc9a    -1766,64            000375 = 144156063065
003745  aa  6 00716 00 0100   desc9a    pr6|462,64
003746  aa   774160 3520 04   epp2      -1936,ic            000126 = 000000000003
003747  aa  6 00744 2521 00   spri2     pr6|484
003750  aa  6 00716 3521 00   epp2      pr6|462
003751  aa  6 00746 2521 00   spri2     pr6|486
003752  aa   000022 7270 07   lxl7      18,dl
003753  aa  7 00001 3521 00   epp2      pr7|1               sub_mbx.op_code
003754  aa  2 00000 5035 17   abd       pr2|0,7
003755  aa  6 00750 2521 00   spri2     pr6|488
003756  aa  5 00007 3521 00   epp2      pr5|7               fnp_info.fnp_tag
003757  aa  6 00752 2521 00   spri2     pr6|490
003760  aa  6 00134 3521 00   epp2      pr6|92              devx
003761  aa  6 00754 2521 00   spri2     pr6|492
003762  aa   774137 3520 04   epp2      -1953,ic            000121 = 404000000021
003763  aa  6 00756 2521 00   spri2     pr6|494
003764  aa  6 00766 2521 00   spri2     pr6|502
003765  aa   774073 3520 04   epp2      -1989,ic            000060 = 524000000077
003766  aa  6 00760 2521 00   spri2     pr6|496
003767  aa   774100 3520 04   epp2      -1984,ic            000067 = 406000000010
003770  aa  6 00762 2521 00   spri2     pr6|498
003771  aa   774106 3520 04   epp2      -1978,ic            000077 = 526000000001
003772  aa  6 00764 2521 00   spri2     pr6|500
003773  aa  6 00742 6211 00   eax1      pr6|482
003774  aa   024000 4310 07   fld       10240,dl
003775  aa  6 00044 3701 20   epp4      pr6|36,*
003776  la  4 00016 3521 20   epp2      pr4|14,*            syserr
003777  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 719
                              call report_fnp_crash;

004000  aa   002722 6700 04   tsp4      1490,ic             006722
                                                            STATEMENT 1 ON LINE 720
                              return;

004001  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 721
                         end;

                                                            STATEMENT 1 ON LINE 722
                    end;

004002  aa   000052 7100 04   tra       42,ic               004054
                                                            STATEMENT 1 ON LINE 726
                    else if sub_mbx.io_cmd = rtx
                    then call process_rtx;

004003  aa   000002 1160 07   cmpq      2,dl
004004  aa   000003 6010 04   tnz       3,ic                004007
004005  aa   001177 6700 04   tsp4      639,ic              005204
004006  aa   000046 7100 04   tra       38,ic               004054
                                                            STATEMENT 1 ON LINE 729
                    else do;

                                                            STATEMENT 1 ON LINE 730
                         call syserr (beeper, "dn355: unrecognized io command ^o from FNP ^a for line ^o", sub_mbx.io_cmd,
                              fnp_info.fnp_tag, bin (string (sub_mbx.line_number), 10));

004007  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
004010  aa   774347 00 0074   desc9a    -1817,60            000356 = 144156063065
004011  aa  6 00716 00 0074   desc9a    pr6|462,60
004012  aa  7 00000 2351 00   lda       pr7|0
004013  aa   000010 7350 00   als       8
004014  aa   000076 7730 00   lrl       62
004015  aa  6 00715 7561 00   stq       pr6|461
004016  aa   774110 3520 04   epp2      -1976,ic            000126 = 000000000003
004017  aa  6 00744 2521 00   spri2     pr6|484
004020  aa  6 00716 3521 00   epp2      pr6|462
004021  aa  6 00746 2521 00   spri2     pr6|486
004022  aa   000033 7270 07   lxl7      27,dl
004023  aa  7 00001 3521 00   epp2      pr7|1               sub_mbx.io_cmd
004024  aa  2 00000 5035 17   abd       pr2|0,7
004025  aa  6 00750 2521 00   spri2     pr6|488
004026  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
004027  aa  5 00007 3521 00   epp2      pr5|7               fnp_info.fnp_tag
004030  aa  6 00752 2521 00   spri2     pr6|490
004031  aa  6 00715 3521 00   epp2      pr6|461
004032  aa  6 00754 2521 00   spri2     pr6|492
004033  aa   774066 3520 04   epp2      -1994,ic            000121 = 404000000021
004034  aa  6 00756 2521 00   spri2     pr6|494
004035  aa   774033 3520 04   epp2      -2021,ic            000070 = 524000000071
004036  aa  6 00760 2521 00   spri2     pr6|496
004037  aa   774030 3520 04   epp2      -2024,ic            000067 = 406000000010
004040  aa  6 00762 2521 00   spri2     pr6|498
004041  aa   774036 3520 04   epp2      -2018,ic            000077 = 526000000001
004042  aa  6 00764 2521 00   spri2     pr6|500
004043  aa   774023 3520 04   epp2      -2029,ic            000066 = 404000000012
004044  aa  6 00766 2521 00   spri2     pr6|502
004045  aa  6 00742 6211 00   eax1      pr6|482
004046  aa   024000 4310 07   fld       10240,dl
004047  aa  6 00044 3701 20   epp4      pr6|36,*
004050  la  4 00016 3521 20   epp2      pr4|14,*            syserr
004051  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 733
                         call report_fnp_crash;

004052  aa   002650 6700 04   tsp4      1448,ic             006722
                                                            STATEMENT 1 ON LINE 734
                         return;

004053  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 735
                    end;

                                                            STATEMENT 1 ON LINE 736
               end;

                                                            STATEMENT 1 ON LINE 737
          end;
004054  aa  6 00123 0541 00   aos       pr6|83              i
004055  aa   776645 7100 04   tra       -603,ic             002722
                                                            STATEMENT 1 ON LINE 740
          if ^no_response                                   /* assuming we believe FNP is still there */
          then if fnp_info.count > 0
               then call process_q;

004056  aa  6 00140 2351 00   lda       pr6|96              no_response
004057  aa   000005 6010 04   tnz       5,ic                004064
004060  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004061  aa  7 00024 2361 00   ldq       pr7|20              fnp_info.count
004062  aa   000002 6044 04   tmoz      2,ic                004064
004063  aa   000005 6700 04   tsp4      5,ic                004070
                                                            STATEMENT 1 ON LINE 745
          if no_response                                    /* if someone discovered that the FNP was gone */
          then call report_fnp_no_response;

004064  aa  6 00140 2351 00   lda       pr6|96              no_response
004065  aa   000002 6000 04   tze       2,ic                004067
004066  aa   002604 6700 04   tsp4      1412,ic             006672
                                                            STATEMENT 1 ON LINE 748
          return;

004067  aa  6 00330 6101 00   rtcd      pr6|216
                                                            STATEMENT 1 ON LINE 749
     end /* process_int */;

  END PROCEDURE process_int
BEGIN PROCEDURE process_q
ENTRY TO process_q                                          STATEMENT 1 ON LINE 751
process_q:
     proc;

004070  aa  6 00340 6501 00   spri4     pr6|224
                                                            STATEMENT 1 ON LINE 758
          q_first = fnp_info.cur_ptr;

004071  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004072  aa  7 00025 2361 00   ldq       pr7|21              fnp_info.cur_ptr
004073  aa  6 00125 7561 00   stq       pr6|85              q_first
                                                            STATEMENT 1 ON LINE 759
          q_count = fnp_info.count;

004074  aa  7 00024 2361 00   ldq       pr7|20              fnp_info.count
004075  aa  6 00126 7561 00   stq       pr6|86              q_count
                                                            STATEMENT 1 ON LINE 760
          i = 1;

004076  aa   000001 2360 07   ldq       1,dl
004077  aa  6 00123 7561 00   stq       pr6|83              i
                                                            STATEMENT 1 ON LINE 762
          do while (q_count > 0 & i > 0);

004100  aa  6 00126 2361 00   ldq       pr6|86              q_count
004101  aa   000173 6044 04   tmoz      123,ic              004274
004102  aa  6 00123 2361 00   ldq       pr6|83              i
004103  aa   000171 6044 04   tmoz      121,ic              004274
                                                            STATEMENT 1 ON LINE 763
               i = index (used_string, "0"b);
004104  aa   000000 2350 07   lda       0,dl
004105  aa   000010 2360 07   ldq       8,dl
004106  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
004107  aa  7 00005 3521 00   epp2      pr7|5               used_string
004110  aa  0 01234 7001 00   tsx0      pr0|668             index_bs_1_eis
004111  aa  6 00123 7561 00   stq       pr6|83              i
                                                            STATEMENT 1 ON LINE 764
               if i > 0                                     /* now we can have one */
               then do;

004112  aa   000154 6044 04   tmoz      108,ic              004266
                                                            STATEMENT 1 ON LINE 766
                    subp = addr (datanet_mbx.dn355_sub_mbxes (i - 1));

004113  aa   000003 7360 00   qls       3
004114  aa  7 00000 3715 06   epp5      pr7|0,ql            datanet_mbx.dn355_sub_mbxes
004115  aa  6 00242 6515 00   spri5     pr6|162             subp
                                                            STATEMENT 1 ON LINE 767
                    qptr = ptr (ttybp, q_first);

004116  aa  6 00125 2361 00   ldq       pr6|85              q_first
004117  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
004120  aa   000000 3120 06   eawp2     0,ql
004121  aa  6 00116 2521 00   spri2     pr6|78              qptr
                                                            STATEMENT 1 ON LINE 768
                    if q_entry.pcb_offset ^= "0"b           /* for a specific channel */
                    then do;

004122  aa  2 00000 2351 00   lda       pr2|0               q_entry.pcb_offset
004123  aa   000022 7350 00   als       18
004124  aa  6 01054 7551 00   sta       pr6|556             q_entry.pcb_offset
004125  aa   000015 6000 04   tze       13,ic               004142
                                                            STATEMENT 1 ON LINE 770
                         pcbp = ptr (ttybp, q_entry.pcb_offset);

004126  aa  6 00272 3515 20   epp1      pr6|186,*           ttybp
004127  aa   000000 3114 01   eawp1     0,au
004130  aa  6 00270 2515 00   spri1     pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 771
                         string (sub_mbx.line_number) = string (pcb.line_number);

004131  aa  1 00000 2351 00   lda       pr1|0
004132  aa   000022 7350 00   als       18
004133  aa  5 00000 6751 00   era       pr5|0
004134  aa   001777 3750 03   ana       1023,du
004135  aa  5 00000 6551 00   ersa      pr5|0
                                                            STATEMENT 1 ON LINE 772
                         devx = pcb.devx;

004136  aa  1 00000 2351 00   lda       pr1|0               pcb.devx
004137  aa   000066 7330 00   lrs       54
004140  aa  6 00134 7561 00   stq       pr6|92              devx
                                                            STATEMENT 1 ON LINE 773
                    end;

004141  aa   000003 7100 04   tra       3,ic                004144
                                                            STATEMENT 1 ON LINE 774
                    else string (sub_mbx.line_number) = ""b;
004142  aa   003264 2350 04   lda       1716,ic             007426 = 776000777777
004143  aa  5 00000 3551 00   ansa      pr5|0
                                                            STATEMENT 1 ON LINE 776
                    if q_entry.opcode = accept_direct_output
                    then if pcb.dialed
                         then call process_send_output (i - 1, "0"b);

004144  aa  2 00000 2351 00   lda       pr2|0               q_entry.opcode
004145  aa   000077 7330 00   lrs       63
004146  aa  6 01054 7561 00   stq       pr6|556             q_entry.opcode
004147  aa   000012 1160 07   cmpq      10,dl
004150  aa   000015 6010 04   tnz       13,ic               004165
004151  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
004152  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
004153  aa   200000 3150 03   cana      65536,du
004154  aa   000067 6000 04   tze       55,ic               004243
004155  aa  6 00123 2361 00   ldq       pr6|83              i
004156  aa   000001 1760 07   sbq       1,dl
004157  aa  6 01055 7561 00   stq       pr6|557
004160  aa   000000 2350 07   lda       0,dl
004161  aa  6 01056 7551 00   sta       pr6|558
004162  aa   003152 3520 04   epp2      1642,ic             007334 = 000004000000
004163  aa   000121 6700 04   tsp4      81,ic               004304
                                                            STATEMENT 1 ON LINE 779
                         else ;

004164  aa   000057 7100 04   tra       47,ic               004243
                                                            STATEMENT 1 ON LINE 781
                    else if q_entry.opcode = set_echnego_break_table
                    then if pcb.dialed
                         then call send_echo_table (i - 1, q_entry.cmd_data);

004165  aa   000030 1160 07   cmpq      24,dl
004166  aa   000022 6010 04   tnz       18,ic               004210
004167  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
004170  aa  3 00004 2351 00   lda       pr3|4               pcb.dialed
004171  aa   200000 3150 03   cana      65536,du
004172  aa   000051 6000 04   tze       41,ic               004243
004173  aa  6 00123 2361 00   ldq       pr6|83              i
004174  aa   000001 1760 07   sbq       1,dl
004175  aa  6 01054 7561 00   stq       pr6|556
004176  aa  6 01054 3521 00   epp2      pr6|556
004177  aa  6 01062 2521 00   spri2     pr6|562
004200  aa  6 00116 3515 20   epp1      pr6|78,*            qptr
004201  aa  1 00001 3521 00   epp2      pr1|1               q_entry.cmd_data
004202  aa  6 01064 2521 00   spri2     pr6|564
004203  aa  6 01060 3521 00   epp2      pr6|560
004204  aa   010000 4310 07   fld       4096,dl
004205  aa  2 00000 7571 00   staq      pr2|0
004206  aa   000501 6700 04   tsp4      321,ic              004707
                                                            STATEMENT 1 ON LINE 784
                         else ;

004207  aa   000034 7100 04   tra       28,ic               004243
                                                            STATEMENT 1 ON LINE 786
                    else do;

                                                            STATEMENT 1 ON LINE 787
                         sub_mbx.io_cmd = wcd;
004210  aa   000003 2350 07   lda       3,dl
004211  aa  5 00001 5511 04   stba      pr5|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 788
                         sub_mbx.op_code = q_entry.opcode;

004212  aa  2 00000 2351 00   lda       pr2|0               q_entry.opcode
004213  aa   000022 7710 00   arl       18
004214  aa  5 00001 5511 10   stba      pr5|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 789
                         sub_mbx.cmd_data_len = divide (q_entry.cmd_count, 6, 8, 0);

004215  aa  2 00000 2351 00   lda       pr2|0               q_entry.cmd_count
004216  aa   000011 7350 00   als       9
004217  aa   000077 7330 00   lrs       63
004220  aa   000006 5060 07   div       6,dl
004221  aa   000066 7370 00   lls       54
004222  aa  5 00001 5511 20   stba      pr5|1,20            sub_mbx.cmd_data_len
                                                            STATEMENT 1 ON LINE 790
                         smbx_cmd_data_long = substr (q_entry.cmd_data, 1, q_entry.cmd_count);

004223  aa  2 00000 2351 00   lda       pr2|0               q_entry.cmd_count
004224  aa   000011 7350 00   als       9
004225  aa   000077 7330 00   lrs       63
004226  aa  003 100 060 540   csl       (pr,rl),(pr),fill(0),bool(move)
004227  aa  2 00001 00 0006   descb     pr2|1,ql            q_entry.cmd_data
004230  aa  5 00002 00 0330   descb     pr5|2,216           smbx_cmd_data_long
                                                            STATEMENT 1 ON LINE 791
                         call send_mbx (i - 1);

004231  aa  6 00123 2361 00   ldq       pr6|83              i
004232  aa   000001 1760 07   sbq       1,dl
004233  aa  6 01054 7561 00   stq       pr6|556
004234  aa   003074 3520 04   epp2      1596,ic             007330 = 000002000000
004235  aa   002020 6700 04   tsp4      1040,ic             006255
                                                            STATEMENT 1 ON LINE 792
                         fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;

004236  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004237  aa  7 00054 2351 00   lda       pr7|44              fnp_info.output_control_transactions
004240  aa   000044 7330 00   lrs       36
004241  aa   000001 0330 07   adl       1,dl
004242  aa  7 00054 7561 00   stq       pr7|44              fnp_info.output_control_transactions
                                                            STATEMENT 1 ON LINE 793
                    end;

                                                            STATEMENT 1 ON LINE 795
                    if no_response                          /* give up in this case */
                    then go to update_q_ptrs;

004243  aa  6 00140 2351 00   lda       pr6|96              no_response
004244  aa   000030 6010 04   tnz       24,ic               004274
                                                            STATEMENT 1 ON LINE 798
                    q_first = q_entry.next;

004245  aa  6 00116 3735 20   epp7      pr6|78,*            qptr
004246  aa  7 00011 2361 00   ldq       pr7|9               q_entry.next
004247  aa  6 00125 7561 00   stq       pr6|85              q_first
                                                            STATEMENT 1 ON LINE 799
                    q_count = q_count - 1;
004250  aa   000001 3360 07   lcq       1,dl
004251  aa  6 00126 0561 00   asq       pr6|86              q_count
                                                            STATEMENT 1 ON LINE 800
                    call tty_space_man$free_space (size (q_entry), qptr);

004252  aa   000012 2360 07   ldq       10,dl
004253  aa  6 01054 7561 00   stq       pr6|556
004254  aa  6 01054 3521 00   epp2      pr6|556
004255  aa  6 01062 2521 00   spri2     pr6|562
004256  aa  6 00116 3521 00   epp2      pr6|78              qptr
004257  aa  6 01064 2521 00   spri2     pr6|564
004260  aa  6 01060 6211 00   eax1      pr6|560
004261  aa   010000 4310 07   fld       4096,dl
004262  aa  6 00044 3701 20   epp4      pr6|36,*
004263  la  4 00062 3521 20   epp2      pr4|50,*            tty_space_man$free_space
004264  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 801
               end;

004265  aa   777613 7100 04   tra       -117,ic             004100
                                                            STATEMENT 1 ON LINE 803
               else fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;

004266  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
004267  aa  5 00060 2351 00   lda       pr5|48              fnp_info.mbx_unavailable
004270  aa   000044 7330 00   lrs       36
004271  aa   000001 0330 07   adl       1,dl
004272  aa  5 00060 7561 00   stq       pr5|48              fnp_info.mbx_unavailable
                                                            STATEMENT 1 ON LINE 804
          end;

004273  aa   777605 7100 04   tra       -123,ic             004100
                                                            STATEMENT 1 ON LINE 806
update_q_ptrs:
          fnp_info.cur_ptr = q_first;

004274  aa  6 00125 2361 00   ldq       pr6|85              q_first
004275  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004276  aa  7 00025 7561 00   stq       pr7|21              fnp_info.cur_ptr
                                                            STATEMENT 1 ON LINE 808
          fnp_info.count = q_count;

004277  aa  6 00126 2361 00   ldq       pr6|86              q_count
004300  aa  7 00024 7561 00   stq       pr7|20              fnp_info.count
                                                            STATEMENT 1 ON LINE 809
          if q_count = 0
          then fnp_info.last_ptr = 0;

004301  aa   000002 6010 04   tnz       2,ic                004303
004302  aa  7 00026 4501 00   stz       pr7|22              fnp_info.last_ptr
                                                            STATEMENT 1 ON LINE 812
          return;

004303  aa  6 00340 6101 00   rtcd      pr6|224
                                                            STATEMENT 1 ON LINE 813
     end /* process_q */;

  END PROCEDURE process_q
BEGIN PROCEDURE process_send_output
ENTRY TO process_send_output                                STATEMENT 1 ON LINE 817
process_send_output:
     proc (a_mbx_num, interrupt_entry);

004304  aa  6 00346 6501 00   spri4     pr6|230
004305  aa  6 00350 2521 00   spri2     pr6|232
                                                            STATEMENT 1 ON LINE 824
          mbx_num = a_mbx_num;

004306  aa  2 00002 2361 20   ldq       pr2|2,*             a_mbx_num
004307  aa  6 00354 7561 00   stq       pr6|236             mbx_num
                                                            STATEMENT 1 ON LINE 825
          if pcb.end_frame | pcb.output_mbx_pending         /* if we're waiting for form-feed  or we got delayed */
          then do;

004310  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
004311  aa  7 00004 2351 00   lda       pr7|4               pcb.output_mbx_pending
004312  aa   011000 3150 03   cana      4608,du
004313  aa   000004 6000 04   tze       4,ic                004317
                                                            STATEMENT 1 ON LINE 827
               pcb.flags.send_output = "1"b;

004314  aa   100000 2350 03   lda       32768,du
004315  aa  7 00004 2551 00   orsa      pr7|4               pcb.send_output
                                                            STATEMENT 1 ON LINE 828
               return;

004316  aa  6 00346 6101 00   rtcd      pr6|230
                                                            STATEMENT 1 ON LINE 829
          end;

                                                            STATEMENT 1 ON LINE 831
          if pcb.write_first = 0
          then do;

004317  aa  7 00001 2351 00   lda       pr7|1               pcb.write_first
004320  aa   000066 7330 00   lrs       54
004321  aa   000021 6010 04   tnz       17,ic               004342
                                                            STATEMENT 1 ON LINE 833
               pcb.flags.send_output = "1"b;

004322  aa   100000 2350 03   lda       32768,du
004323  aa  7 00004 2551 00   orsa      pr7|4               pcb.send_output
                                                            STATEMENT 1 ON LINE 834
               call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);

004324  aa   773614 2370 04   ldaq      -2164,ic            000140 = 000000000000 000000000000
004325  aa  6 01070 7571 00   staq      pr6|568
004326  aa  6 00134 3521 00   epp2      pr6|92              devx
004327  aa  6 01074 2521 00   spri2     pr6|572
004330  aa   773563 3520 04   epp2      -2189,ic            000113 = 000000000004
004331  aa  6 01076 2521 00   spri2     pr6|574
004332  aa  6 01070 3521 00   epp2      pr6|568
004333  aa  6 01100 2521 00   spri2     pr6|576
004334  aa  6 01072 6211 00   eax1      pr6|570
004335  aa   014000 4310 07   fld       6144,dl
004336  aa  6 00044 3701 20   epp4      pr6|36,*
004337  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
004340  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 835
          end;
004341  aa   000345 7100 04   tra       229,ic              004706
                                                            STATEMENT 1 ON LINE 837
          else do;

                                                            STATEMENT 1 ON LINE 838
               if mbx_num = -1                              /* caller didn't supply one */
               then do;

004342  aa  6 00354 2361 00   ldq       pr6|236             mbx_num
004343  aa   003110 1160 04   cmpq      1608,ic             007453 = 777777777777
004344  aa   000036 6010 04   tnz       30,ic               004402
                                                            STATEMENT 1 ON LINE 840
                    mbx_num = index (used_string, "0"b) - 1;

004345  aa   000000 2350 07   lda       0,dl
004346  aa   000010 2360 07   ldq       8,dl
004347  aa  6 00244 3715 20   epp5      pr6|164,*           mbxp
004350  aa  5 00005 3521 00   epp2      pr5|5               used_string
004351  aa  0 01234 7001 00   tsx0      pr0|668             index_bs_1_eis
004352  aa   000001 1760 07   sbq       1,dl
004353  aa  6 00354 7561 00   stq       pr6|236             mbx_num
                                                            STATEMENT 1 ON LINE 842
                    if mbx_num = -1                         /* still? we didn't get one */
                    then do;

004354  aa   003077 1160 04   cmpq      1599,ic             007453 = 777777777777
004355  aa   000015 6010 04   tnz       13,ic               004372
                                                            STATEMENT 1 ON LINE 844
                         call make_q_entry (accept_direct_output, 0, ""b);

004356  aa  6 01102 4501 00   stz       pr6|578
004357  aa  000 100 100 400   mlr       (),(pr),fill(000)
004360  aa   000000 00 0000   desc9a    0,0
004361  aa  6 01072 00 0040   desc9a    pr6|570,32
004362  aa   002736 3520 04   epp2      1502,ic             007320 = 000006000000
004363  aa   001334 6700 04   tsp4      732,ic              005717
                                                            STATEMENT 1 ON LINE 845
                         fnp_info.mbx_unavailable = fnp_info.mbx_unavailable + 1;

004364  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004365  aa  7 00060 2351 00   lda       pr7|48              fnp_info.mbx_unavailable
004366  aa   000044 7330 00   lrs       36
004367  aa   000001 0330 07   adl       1,dl
004370  aa  7 00060 7561 00   stq       pr7|48              fnp_info.mbx_unavailable
                                                            STATEMENT 1 ON LINE 846
                         return;

004371  aa  6 00346 6101 00   rtcd      pr6|230
                                                            STATEMENT 1 ON LINE 847
                    end;

                                                            STATEMENT 1 ON LINE 848
                    else do;

                                                            STATEMENT 1 ON LINE 849
                         subp = addr (datanet_mbx.dn355_sub_mbxes (mbx_num));

004372  aa   000003 7360 00   qls       3
004373  aa  5 00010 3535 06   epp3      pr5|8,ql            datanet_mbx.dn355_sub_mbxes
004374  aa  6 00242 2535 00   spri3     pr6|162             subp
                                                            STATEMENT 1 ON LINE 850
                         string (sub_mbx.line_number) = string (pcb.line_number);

004375  aa  7 00000 2351 00   lda       pr7|0
004376  aa   000022 7350 00   als       18
004377  aa  3 00000 6751 00   era       pr3|0
004400  aa   001777 3750 03   ana       1023,du
004401  aa  3 00000 6551 00   ersa      pr3|0
                                                            STATEMENT 1 ON LINE 851
                    end;

                                                            STATEMENT 1 ON LINE 852
               end;

                                                            STATEMENT 1 ON LINE 855
               pcb.flags.send_output = "0"b;

004402  aa   002715 2350 04   lda       1485,ic             007317 = 677777777777
004403  aa  7 00004 3551 00   ansa      pr7|4               pcb.send_output
                                                            STATEMENT 1 ON LINE 856
               dcwlptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));

004404  aa  6 00354 2361 00   ldq       pr6|236             mbx_num
004405  aa   000004 7360 00   qls       4
004406  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
004407  aa  5 00004 3715 66   epp5      pr5|4,*ql           dcw_list_array
004410  aa  6 00112 6515 00   spri5     pr6|74              dcwlptr
                                                            STATEMENT 1 ON LINE 858
               sub_mbx.data_addr = bit (bin (bin (rel (dcwlptr), 18) + tty_buf.absorig, 18), 18);

004411  aa  5 00000 6351 00   eaa       pr5|0               dcwlptr
004412  aa   000066 7730 00   lrl       54
004413  aa  6 00272 3535 20   epp3      pr6|186,*           ttybp
004414  aa  3 00001 0761 00   adq       pr3|1               tty_buf.absorig
004415  aa   000003 6050 04   tpl       3,ic                004420
004416  aa  0 00110 6761 00   erq       pr0|72              = 777777777777
004417  aa   000001 0760 07   adq       1,dl
004420  aa   000066 7370 00   lls       54
004421  aa  6 00242 3515 20   epp1      pr6|162,*           subp
004422  aa  1 00005 5511 60   stba      pr1|5,60            sub_mbx.data_addr
                                                            STATEMENT 1 ON LINE 859
               output_limit =
                    max (
                    min (divide ((fnp_info.bleft_355 - tc_data$fnp_buffer_threshold) * 60, output_bpart, 17, 0),
                    max_chain_len * 4 * (pcb.max_buf_size - 1)), 1);

004423  aa  7 00003 2351 00   lda       pr7|3               pcb.max_buf_size
004424  aa   000066 7330 00   lrs       54
004425  aa   000001 1760 07   sbq       1,dl
004426  aa  6 01102 7561 00   stq       pr6|578
004427  aa   000100 2360 07   ldq       64,dl
004430  aa  6 01102 4021 00   mpy       pr6|578
004431  aa  6 01070 7571 00   staq      pr6|568
004432  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
004433  aa  5 00027 2361 00   ldq       pr5|23              fnp_info.bleft_355
004434  aa  6 00044 3701 20   epp4      pr6|36,*
004435  la  4 00012 1761 20   sbq       pr4|10,*            tc_data$fnp_buffer_threshold
004436  aa   000074 4020 07   mpy       60,dl
004437  aa   000004 5060 07   div       4,dl
004440  aa   000044 7770 00   llr       36
004441  aa   000044 7330 00   lrs       36
004442  aa  6 01070 1171 00   cmpaq     pr6|568
004443  aa   000002 6040 04   tmi       2,ic                004445
004444  aa  6 01070 2371 00   ldaq      pr6|568
004445  aa  6 01070 7571 00   staq      pr6|568
004446  aa   000001 2350 07   lda       1,dl
004447  aa   000044 7330 00   lrs       36
004450  aa  6 01070 1171 00   cmpaq     pr6|568
004451  aa   000002 6050 04   tpl       2,ic                004453
004452  aa  6 01070 2371 00   ldaq      pr6|568
004453  aa  6 00150 7561 00   stq       pr6|104             output_limit
                                                            STATEMENT 1 ON LINE 864
               output_chars = 0;

004454  aa  6 00151 4501 00   stz       pr6|105             output_chars
                                                            STATEMENT 1 ON LINE 865
               continue = "1"b;

004455  aa   400000 2350 03   lda       131072,du
004456  aa  6 00162 7551 00   sta       pr6|114             continue
                                                            STATEMENT 1 ON LINE 866
               do j = 1 to max_chain_len while (pcb.write_first ^= 0 & output_chars < output_limit & continue);

004457  aa   000020 2360 07   ldq       16,dl
004460  aa  6 00355 7561 00   stq       pr6|237
004461  aa   000001 2360 07   ldq       1,dl
004462  aa  6 00132 7561 00   stq       pr6|90              j
004463  aa   000000 0110 03   nop       0,du
004464  aa  6 00132 2361 00   ldq       pr6|90              j
004465  aa  6 00355 1161 00   cmpq      pr6|237
004466  aa   000117 6054 04   tpnz      79,ic               004605
004467  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
004470  aa  7 00001 2351 00   lda       pr7|1               pcb.write_first
004471  aa   000066 7330 00   lrs       54
004472  aa   000113 6000 04   tze       75,ic               004605
004473  aa  6 01102 7561 00   stq       pr6|578             pcb.write_first
004474  aa  6 00151 2361 00   ldq       pr6|105             output_chars
004475  aa  6 00150 1161 00   cmpq      pr6|104             output_limit
004476  aa   000107 6050 04   tpl       71,ic               004605
004477  aa  6 00162 2351 00   lda       pr6|114             continue
004500  aa   000105 6000 04   tze       69,ic               004605
                                                            STATEMENT 1 ON LINE 868
                    dcw_list (j).dcw_ptr = bit (bin (pcb.write_first + dataoff + tty_buf.absorig, 18), 18);

004501  aa  6 01102 2361 00   ldq       pr6|578             pcb.write_first
004502  aa   000001 0760 07   adq       1,dl
004503  aa  6 00272 3715 20   epp5      pr6|186,*           ttybp
004504  aa  5 00001 0761 00   adq       pr5|1               tty_buf.absorig
004505  aa   000003 6050 04   tpl       3,ic                004510
004506  aa  0 00110 6761 00   erq       pr0|72              = 777777777777
004507  aa   000001 0760 07   adq       1,dl
004510  aa   000066 7370 00   lls       54
004511  aa  6 00132 7271 00   lxl7      pr6|90              j
004512  aa  6 00112 3535 20   epp3      pr6|74,*            dcwlptr
004513  aa  3 77777 3515 17   epp1      pr3|-1,7            dcw_list.dcw_ptr
004514  aa  1 00000 5511 60   stba      pr1|0,60            dcw_list.dcw_ptr
                                                            STATEMENT 1 ON LINE 870
                    blockp = ptr (ttybp, pcb.write_first);
004515  aa  6 01102 2361 00   ldq       pr6|578             pcb.write_first
004516  aa  5 00000 3521 00   epp2      pr5|0
004517  aa   000000 3120 06   eawp2     0,ql
004520  aa  6 00274 2521 00   spri2     pr6|188             blockp
                                                            STATEMENT 1 ON LINE 871
                    if buffer.tally = 0                     /* we don't want this in a dcw */
                    then call syserr (crash_system, "dn355: output buffer at ^o has zero tally", pcb.write_first);

004521  aa  2 00000 2361 00   ldq       pr2|0               buffer.tally
004522  aa  0 00416 3771 00   anaq      pr0|270             = 000000000000 000000000777
004523  aa   000025 6010 04   tnz       21,ic               004550
004524  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
004525  aa   773522 00 0054   desc9a    -2222,44            000246 = 144156063065
004526  aa  6 01104 00 0054   desc9a    pr6|580,44
004527  aa   773402 3520 04   epp2      -2302,ic            000131 = 000000000001
004530  aa  6 01122 2521 00   spri2     pr6|594
004531  aa  6 01104 3521 00   epp2      pr6|580
004532  aa  6 01124 2521 00   spri2     pr6|596
004533  aa  7 00001 3521 00   epp2      pr7|1               pcb.write_first
004534  aa  6 01126 2521 00   spri2     pr6|598
004535  aa   773364 3520 04   epp2      -2316,ic            000121 = 404000000021
004536  aa  6 01130 2521 00   spri2     pr6|600
004537  aa   773320 3520 04   epp2      -2352,ic            000057 = 524000000051
004540  aa  6 01132 2521 00   spri2     pr6|602
004541  aa   773315 3520 04   epp2      -2355,ic            000056 = 406000000021
004542  aa  6 01134 2521 00   spri2     pr6|604
004543  aa  6 01120 6211 00   eax1      pr6|592
004544  aa   014000 4310 07   fld       6144,dl
004545  aa  6 00044 3701 20   epp4      pr6|36,*
004546  la  4 00016 3521 20   epp2      pr4|14,*            syserr
004547  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 874
                    dcw_list (j).dcw_tally = bit (buffer.tally, 9);

004550  aa  6 00274 2361 20   ldq       pr6|188,*           buffer.tally
004551  aa  0 00416 3771 00   anaq      pr0|270             = 000000000000 000000000777
004552  aa  6 01117 7561 00   stq       pr6|591             buffer.tally
004553  aa   000077 7370 00   lls       63
004554  aa   000033 7730 00   lrl       27
004555  aa  6 00132 7271 00   lxl7      pr6|90              j
004556  aa  6 00112 3735 20   epp7      pr6|74,*            dcwlptr
004557  aa  7 77777 3715 17   epp5      pr7|-1,7            dcw_list.dcw_tally
004560  aa  5 00000 5511 04   stba      pr5|0,04            dcw_list.dcw_tally
                                                            STATEMENT 1 ON LINE 876
                    dcw_list (j).pad = "0"b;

004561  aa   002535 2350 04   lda       1373,ic             007316 = 777777000777
004562  aa  7 77777 3551 17   ansa      pr7|-1,7            dcw_list.pad
                                                            STATEMENT 1 ON LINE 877
                    pcb.write_first = buffer.next;

004563  aa  6 00274 2351 20   lda       pr6|188,*           buffer.next
004564  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
004565  aa  5 00001 5511 60   stba      pr5|1,60            pcb.write_first
                                                            STATEMENT 1 ON LINE 878
                    pcb.write_cnt = pcb.write_cnt - buffer.tally;

004566  aa  5 00003 2351 00   lda       pr5|3               pcb.write_cnt
004567  aa   000022 7350 00   als       18
004570  aa   000066 7330 00   lrs       54
004571  aa  6 01117 1761 00   sbq       pr6|591             buffer.tally
004572  aa  5 00003 5521 14   stbq      pr5|3,14            pcb.write_cnt
                                                            STATEMENT 1 ON LINE 880
                    output_chars = output_chars + buffer.tally;

004573  aa  6 01117 2361 00   ldq       pr6|591             buffer.tally
004574  aa  6 00151 0561 00   asq       pr6|105             output_chars
                                                            STATEMENT 1 ON LINE 882
                    if buffer.flags.end_of_page             /* if this buffer fills a page/screen */
                    then do;

004575  aa  6 00274 2351 20   lda       pr6|188,*           buffer.end_of_page
004576  aa   400000 3150 07   cana      131072,dl
004577  aa   000004 6000 04   tze       4,ic                004603
                                                            STATEMENT 1 ON LINE 884
                         pcb.flags.end_frame = "1"b;

004600  aa   010000 2350 03   lda       4096,du
004601  aa  5 00004 2551 00   orsa      pr5|4               pcb.end_frame
                                                            STATEMENT 1 ON LINE 885
                         continue = "0"b;

004602  aa  6 00162 4501 00   stz       pr6|114             continue
                                                            STATEMENT 1 ON LINE 886
                    end;

                                                            STATEMENT 1 ON LINE 887
               end;

004603  aa  6 00132 0541 00   aos       pr6|90              j
004604  aa   777660 7100 04   tra       -80,ic              004464
                                                            STATEMENT 1 ON LINE 889
               chain_len = max (j - 1, 1);

004605  aa  6 00132 2361 00   ldq       pr6|90              j
004606  aa   000001 1760 07   sbq       1,dl
004607  aa   000001 1160 07   cmpq      1,dl
004610  aa   000002 6050 04   tpl       2,ic                004612
004611  aa   000001 2360 07   ldq       1,dl
004612  aa  6 00133 7561 00   stq       pr6|91              chain_len
                                                            STATEMENT 1 ON LINE 891
               sub_mbx.word_cnt = chain_len;

004613  aa  6 00242 3735 20   epp7      pr6|162,*           subp
004614  aa  7 00005 5521 14   stbq      pr7|5,14            sub_mbx.word_cnt
                                                            STATEMENT 1 ON LINE 892
               sub_mbx.op_code = accept_direct_output;

004615  aa   012000 2350 07   lda       5120,dl
004616  aa  7 00001 5511 10   stba      pr7|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 893
               sub_mbx.command_data (1) = "0"b;

004617  aa  7 00002 4501 00   stz       pr7|2               sub_mbx.command_data
                                                            STATEMENT 1 ON LINE 894
               sub_mbx.io_cmd = wtx;

004620  aa   000004 2350 07   lda       4,dl
004621  aa  7 00001 5511 04   stba      pr7|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 895
               pcb.output_mbx_pending = "1"b;

004622  aa   001000 2350 03   lda       512,du
004623  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
004624  aa  5 00004 2551 00   orsa      pr5|4               pcb.output_mbx_pending
                                                            STATEMENT 1 ON LINE 896
               buffer.next = 0;

004625  aa   000000 2350 07   lda       0,dl
004626  aa  6 00274 3535 20   epp3      pr6|188,*           buffer.next
004627  aa  3 00000 5511 60   stba      pr3|0,60            buffer.next
                                                            STATEMENT 1 ON LINE 897
               call send_mbx (mbx_num);

004630  aa   002462 3520 04   epp2      1330,ic             007312 = 000002000000
004631  aa   001424 6700 04   tsp4      788,ic              006255
                                                            STATEMENT 1 ON LINE 898
               fnp_info.output_data_transactions = fnp_info.output_data_transactions + 1;

004632  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004633  aa  7 00052 2351 00   lda       pr7|42              fnp_info.output_data_transactions
004634  aa   000044 7330 00   lrs       36
004635  aa   000001 0330 07   adl       1,dl
004636  aa  7 00052 7561 00   stq       pr7|42              fnp_info.output_data_transactions
                                                            STATEMENT 1 ON LINE 899
               lcte.meters.out_bytes = lcte.meters.out_bytes + output_chars;

004637  aa  6 00254 3715 20   epp5      pr6|172,*           lctep
004640  aa  5 00007 2351 00   lda       pr5|7               lcte.out_bytes
004641  aa   000044 7330 00   lrs       36
004642  aa  6 00151 0331 00   adl       pr6|105             output_chars
004643  aa  5 00007 7561 00   stq       pr5|7               lcte.out_bytes
                                                            STATEMENT 1 ON LINE 902
               if /* tree */ pcb.write_first = 0
               then do;

004644  aa  6 00270 3535 20   epp3      pr6|184,*           pcbp
004645  aa  3 00001 2351 00   lda       pr3|1               pcb.write_first
004646  aa   000066 7330 00   lrs       54
004647  aa   000025 6010 04   tnz       21,ic               004674
                                                            STATEMENT 1 ON LINE 904
                    pcb.write_last = 0;

004650  aa   000000 2350 03   lda       0,du
004651  aa  3 00001 5511 14   stba      pr3|1,14            pcb.write_last
                                                            STATEMENT 1 ON LINE 905
                    if interrupt_entry
                    then call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);

004652  aa  6 00350 3515 20   epp1      pr6|232,*
004653  aa  1 00004 2351 20   lda       pr1|4,*             interrupt_entry
004654  aa   400000 3150 03   cana      131072,du
004655  aa   000031 6000 04   tze       25,ic               004706
004656  aa   773262 2370 04   ldaq      -2382,ic            000140 = 000000000000 000000000000
004657  aa  6 01070 7571 00   staq      pr6|568
004660  aa  6 00134 3521 00   epp2      pr6|92              devx
004661  aa  6 01074 2521 00   spri2     pr6|572
004662  aa   773231 3520 04   epp2      -2407,ic            000113 = 000000000004
004663  aa  6 01076 2521 00   spri2     pr6|574
004664  aa  6 01070 3521 00   epp2      pr6|568
004665  aa  6 01100 2521 00   spri2     pr6|576
004666  aa  6 01072 6211 00   eax1      pr6|570
004667  aa   014000 4310 07   fld       6144,dl
004670  aa  6 00044 3701 20   epp4      pr6|36,*
004671  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
004672  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 908
               end;

004673  aa   000013 7100 04   tra       11,ic               004706
                                                            STATEMENT 1 ON LINE 909
               else if chain_len < max_chain_len & ^pcb.flags.end_frame
                                                            /* must have stopped because there wasn't enough space */
                    then fnp_info.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output + 1;

004674  aa  6 00133 2361 00   ldq       pr6|91              chain_len
004675  aa   000020 1160 07   cmpq      16,dl
004676  aa   000010 6050 04   tpl       8,ic                004706
004677  aa  3 00004 2351 00   lda       pr3|4               pcb.end_frame
004700  aa   010000 3150 03   cana      4096,du
004701  aa   000005 6010 04   tnz       5,ic                004706
004702  aa  7 00063 2351 00   lda       pr7|51              fnp_info.fnp_space_restricted_output
004703  aa   000044 7330 00   lrs       36
004704  aa   000001 0330 07   adl       1,dl
004705  aa  7 00063 7561 00   stq       pr7|51              fnp_info.fnp_space_restricted_output
                                                            STATEMENT 1 ON LINE 912
          end;

                                                            STATEMENT 1 ON LINE 914
          return;

004706  aa  6 00346 6101 00   rtcd      pr6|230
                                                            STATEMENT 1 ON LINE 915
     end;

  END PROCEDURE process_send_output
BEGIN PROCEDURE send_echo_table
ENTRY TO send_echo_table                                    STATEMENT 1 ON LINE 924
send_echo_table:
     procedure (mbx_num, table_bits);

004707  aa  6 00356 6501 00   spri4     pr6|238
004710  aa  6 00360 2521 00   spri2     pr6|240
                                                            STATEMENT 1 ON LINE 933
          if ^pcb.dialed
          then return;

004711  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
004712  aa  7 00004 2351 00   lda       pr7|4               pcb.dialed
004713  aa   200000 3150 03   cana      65536,du
004714  aa   000002 6010 04   tnz       2,ic                004716
004715  aa  6 00356 6101 00   rtcd      pr6|238
                                                            STATEMENT 1 ON LINE 935
          table_ptr = addr (fnp_info.dcw_list_array_ptr -> dcw_list_array (mbx_num));

004716  aa  2 00002 2361 20   ldq       pr2|2,*             mbx_num
004717  aa   000004 7360 00   qls       4
004720  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
004721  aa  5 00004 3715 66   epp5      pr5|4,*ql           dcw_list_array
004722  aa  6 00364 6515 00   spri5     pr6|244             table_ptr
                                                            STATEMENT 1 ON LINE 936
          table_ptr -> bits_to_send = table_bits;

004723  aa  2 00004 3535 20   epp3      pr2|4,*
004724  aa  003 100 060 500   csl       (pr),(pr),fill(0),bool(move)
004725  aa  3 00000 00 0440   descb     pr3|0,288           table_bits
004726  aa  5 00000 00 0440   descb     pr5|0,288           bits_to_send
                                                            STATEMENT 1 ON LINE 937
          sub_mbx.op_code = set_echnego_break_table;

004727  aa   030000 2350 07   lda       12288,dl
004730  aa  6 00242 3515 20   epp1      pr6|162,*           subp
004731  aa  1 00001 5511 10   stba      pr1|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 938
          sub_mbx.io_cmd = wcd;

004732  aa   000003 2350 07   lda       3,dl
004733  aa  1 00001 5511 04   stba      pr1|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 939
          sub_mbx.data_addr = bit (bin (bin (rel (table_ptr), 18) + tty_buf.absorig, 18), 18);

004734  aa  5 00000 6351 00   eaa       pr5|0               table_ptr
004735  aa   000066 7730 00   lrl       54
004736  aa  6 00272 3735 20   epp7      pr6|186,*           ttybp
004737  aa  7 00001 0761 00   adq       pr7|1               tty_buf.absorig
004740  aa   000003 6050 04   tpl       3,ic                004743
004741  aa  0 00110 6761 00   erq       pr0|72              = 777777777777
004742  aa   000001 0760 07   adq       1,dl
004743  aa   000066 7370 00   lls       54
004744  aa  1 00005 5511 60   stba      pr1|5,60            sub_mbx.data_addr
                                                            STATEMENT 1 ON LINE 940
          sub_mbx.word_cnt = 8;

004745  aa   000010 2350 07   lda       8,dl
004746  aa  1 00005 5511 14   stba      pr1|5,14            sub_mbx.word_cnt
                                                            STATEMENT 1 ON LINE 942
          call send_mbx (mbx_num);

004747  aa  2 00002 3521 20   epp2      pr2|2,*             mbx_num
004750  aa  6 01140 2521 00   spri2     pr6|608
004751  aa  6 01136 3521 00   epp2      pr6|606
004752  aa   004000 4310 07   fld       2048,dl
004753  aa  2 00000 7571 00   staq      pr2|0
004754  aa   001301 6700 04   tsp4      705,ic              006255
                                                            STATEMENT 1 ON LINE 943
          fnp_info.output_control_transactions = fnp_info.output_control_transactions + 1;

004755  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
004756  aa  7 00054 2351 00   lda       pr7|44              fnp_info.output_control_transactions
004757  aa   000044 7330 00   lrs       36
004760  aa   000001 0330 07   adl       1,dl
004761  aa  7 00054 7561 00   stq       pr7|44              fnp_info.output_control_transactions
                                                            STATEMENT 1 ON LINE 944
          return;

004762  aa  6 00356 6101 00   rtcd      pr6|238
                                                            STATEMENT 1 ON LINE 945
     end send_echo_table;

  END PROCEDURE send_echo_table
BEGIN PROCEDURE process_accept_input
ENTRY TO process_accept_input                               STATEMENT 1 ON LINE 949
process_accept_input:
     proc;

004763  aa  6 00366 6501 00   spri4     pr6|246
                                                            STATEMENT 1 ON LINE 956
          input_count = input_sub_mbx.n_chars;

004764  aa  6 00242 3735 20   epp7      pr6|162,*           subp
004765  aa  7 00001 2351 00   lda       pr7|1               input_sub_mbx.n_chars
004766  aa   000066 7330 00   lrs       54
004767  aa  6 00142 7561 00   stq       pr6|98              input_count
                                                            STATEMENT 1 ON LINE 957
          j = divide (input_count + 3, 4, 17, 0);

004770  aa   000003 0760 07   adq       3,dl
004771  aa   000004 5060 07   div       4,dl
004772  aa  6 00132 7561 00   stq       pr6|90              j
                                                            STATEMENT 1 ON LINE 959
          if enough_input_space (j) & pcb.read_first = 0
          then do;

004773  aa   002311 3520 04   epp2      1225,ic             007304 = 000004000000
004774  aa   000673 6700 04   tsp4      443,ic              005667
004775  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
004776  aa  7 00005 2351 00   lda       pr7|5               pcb.read_first
004777  aa   000066 7730 00   lrl       54
005000  aa  0 00512 7001 00   tsx0      pr0|330             r_e_as
005001  aa  6 01145 7551 00   sta       pr6|613
005002  aa  6 01144 2351 00   lda       pr6|612
005003  aa  0 00002 3771 00   anaq      pr0|2               = 400000000000 000000000000
005004  aa  6 01145 3151 00   cana      pr6|613
005005  aa   000150 6000 04   tze       104,ic              005155
                                                            STATEMENT 1 ON LINE 961
               do k = 1 to input_sub_mbx.n_buffers;

005006  aa  6 00242 3715 20   epp5      pr6|162,*           subp
005007  aa  5 00002 2361 00   ldq       pr5|2               input_sub_mbx.n_buffers
005010  aa  6 00400 7561 00   stq       pr6|256
005011  aa   000001 2360 07   ldq       1,dl
005012  aa  6 00131 7561 00   stq       pr6|89              k
005013  aa   000000 0110 03   nop       0,du
005014  aa  6 00131 2361 00   ldq       pr6|89              k
005015  aa  6 00400 1161 00   cmpq      pr6|256
005016  aa   000123 6054 04   tpnz      83,ic               005141
                                                            STATEMENT 1 ON LINE 962
                    tally = input_sub_mbx.dcw (k).tally;

005017  aa  6 00242 3735 20   epp7      pr6|162,*           subp
005020  aa  7 00002 2361 06   ldq       pr7|2,ql            input_sub_mbx.tally
005021  aa  0 00410 3771 00   anaq      pr0|264             = 000000000000 000000007777
005022  aa  6 00374 7561 00   stq       pr6|252             tally
                                                            STATEMENT 1 ON LINE 963
                    buf_size = 16 * divide (tally + 67, 64, 17, 0);

005023  aa   000103 0760 07   adq       67,dl
005024  aa   000100 5060 07   div       64,dl
005025  aa   000004 7360 00   qls       4
005026  aa  6 00375 7561 00   stq       pr6|253             buf_size
                                                            STATEMENT 1 ON LINE 965
                    call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);

005027  aa  6 00134 3521 00   epp2      pr6|92              devx
005030  aa  6 01150 2521 00   spri2     pr6|616
005031  aa  6 00375 3521 00   epp2      pr6|253             buf_size
005032  aa  6 01152 2521 00   spri2     pr6|618
005033  aa   773013 3520 04   epp2      -2549,ic            000046 = 000000000000
005034  aa  6 01154 2521 00   spri2     pr6|620
005035  aa  6 00274 3521 00   epp2      pr6|188             blockp
005036  aa  6 01156 2521 00   spri2     pr6|622
005037  aa  6 01146 6211 00   eax1      pr6|614
005040  aa   020000 4310 07   fld       8192,dl
005041  aa  6 00044 3701 20   epp4      pr6|36,*
005042  la  4 00064 3521 20   epp2      pr4|52,*            tty_space_man$get_buffer
005043  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 966
                    if blockp = null ()                     /* couldn't get the space */
                    then do;

005044  aa  6 00274 2371 00   ldaq      pr6|188             blockp
005045  aa   773075 6770 04   eraq      -2499,ic            000142 = 077777000043 000001000000
005046  aa  0 00460 3771 00   anaq      pr0|304             = 077777000077 777777077077
005047  aa   000027 6010 04   tnz       23,ic               005076
                                                            STATEMENT 1 ON LINE 968
                         if pcb.read_first ^= 0             /* if we started building a chain */
                         then call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));

005050  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005051  aa  7 00005 2351 00   lda       pr7|5               pcb.read_first
005052  aa   000066 7730 00   lrl       54
005053  aa   000017 6000 04   tze       15,ic               005072
005054  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
005055  aa   000000 3120 06   eawp2     0,ql
005056  aa  6 01160 2521 00   spri2     pr6|624
005057  aa  6 00134 3521 00   epp2      pr6|92              devx
005060  aa  6 01150 2521 00   spri2     pr6|616
005061  aa   772765 3520 04   epp2      -2571,ic            000046 = 000000000000
005062  aa  6 01152 2521 00   spri2     pr6|618
005063  aa  6 01160 3521 00   epp2      pr6|624
005064  aa  6 01154 2521 00   spri2     pr6|620
005065  aa  6 01146 6211 00   eax1      pr6|614
005066  aa   014000 4310 07   fld       6144,dl
005067  aa  6 00044 3701 20   epp4      pr6|36,*
005070  la  4 00066 3521 20   epp2      pr4|54,*            tty_space_man$free_chain
005071  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 970
                         pcb.read_first = 0;

005072  aa   000000 2350 07   lda       0,dl
005073  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005074  aa  7 00005 5511 60   stba      pr7|5,60            pcb.read_first
                                                            STATEMENT 1 ON LINE 971
                         go to reject;

005075  aa   000060 7100 04   tra       48,ic               005155
                                                            STATEMENT 1 ON LINE 972
                    end;

                                                            STATEMENT 1 ON LINE 974
                    if pcb.read_first = 0
                    then pcb.read_first = bin (rel (blockp));

005076  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005077  aa  7 00005 2351 00   lda       pr7|5               pcb.read_first
005100  aa   000066 7730 00   lrl       54
005101  aa   000006 6010 04   tnz       6,ic                005107
005102  aa  6 00274 6351 20   eaa       pr6|188,*           blockp
005103  aa   000066 7730 00   lrl       54
005104  aa   000066 7370 00   lls       54
005105  aa  7 00005 5511 60   stba      pr7|5,60            pcb.read_first
005106  aa   000006 7100 04   tra       6,ic                005114
                                                            STATEMENT 1 ON LINE 976
                    else prev_blockp -> buffer.next = bin (rel (blockp));

005107  aa  6 00274 6351 20   eaa       pr6|188,*           blockp
005110  aa   000066 7730 00   lrl       54
005111  aa   000066 7370 00   lls       54
005112  aa  6 00376 3715 20   epp5      pr6|254,*           buffer.next
005113  aa  5 00000 5511 60   stba      pr5|0,60            buffer.next
                                                            STATEMENT 1 ON LINE 978
                    buffer.tally = tally;

005114  aa  6 00374 2361 00   ldq       pr6|252             tally
005115  aa  6 00274 3715 20   epp5      pr6|188,*           buffer.tally
005116  aa  5 00000 5521 04   stbq      pr5|0,04            buffer.tally
                                                            STATEMENT 1 ON LINE 979
                    input_sub_mbx.dcw (k).abs_addr =
                         bit (bin (tty_buf.absorig + bin (rel (addr (buffer.chars))), 24), 24);

005117  aa  6 00274 3715 20   epp5      pr6|188,*           blockp
005120  aa  5 00001 3715 00   epp5      pr5|1               buffer.chars
005121  aa  5 00000 6351 00   eaa       pr5|0
005122  aa   000066 7730 00   lrl       54
005123  aa  6 00272 3535 20   epp3      pr6|186,*           ttybp
005124  aa  3 00001 0331 00   adl       pr3|1               tty_buf.absorig
005125  aa   000003 6050 04   tpl       3,ic                005130
005126  aa  0 00110 6761 00   erq       pr0|72              = 777777777777
005127  aa   000001 0760 07   adq       1,dl
005130  aa   000060 7370 00   lls       48
005131  aa  6 00131 7271 00   lxl7      pr6|89              k
005132  aa  6 00242 3515 20   epp1      pr6|162,*           subp
005133  aa  1 00002 3735 17   epp7      pr1|2,7             input_sub_mbx.abs_addr
005134  aa  7 00000 7511 74   stca      pr7|0,74            input_sub_mbx.abs_addr
                                                            STATEMENT 1 ON LINE 982
                    prev_blockp = blockp;

005135  aa  6 00274 3735 20   epp7      pr6|188,*           blockp
005136  aa  6 00376 6535 00   spri7     pr6|254             prev_blockp
                                                            STATEMENT 1 ON LINE 983
               end;

005137  aa  6 00131 0541 00   aos       pr6|89              k
005140  aa   777654 7100 04   tra       -84,ic              005014
                                                            STATEMENT 1 ON LINE 985
               pcb.read_last = bin (rel (blockp));

005141  aa  6 00274 6351 20   eaa       pr6|188,*           blockp
005142  aa   000066 7730 00   lrl       54
005143  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005144  aa  7 00005 5521 14   stbq      pr7|5,14            pcb.read_last
                                                            STATEMENT 1 ON LINE 987
               sub_mbx.op_code = input_accepted;

005145  aa   005000 2350 07   lda       2560,dl
005146  aa  6 00242 3715 20   epp5      pr6|162,*           subp
005147  aa  5 00001 5511 10   stba      pr5|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 988
               sub_mbx.io_cmd = rtx;

005150  aa   000002 2350 07   lda       2,dl
005151  aa  5 00001 5511 04   stba      pr5|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 989
               call return_mbx (i);

005152  aa   002202 3520 04   epp2      1154,ic             007354 = 000002000000
005153  aa   001077 6700 04   tsp4      575,ic              006252
                                                            STATEMENT 1 ON LINE 990
          end;

005154  aa   000027 7100 04   tra       23,ic               005203
                                                            STATEMENT 1 ON LINE 992
          else do;

                                                            STATEMENT 1 ON LINE 993
reject:
               sub_mbx.io_cmd = wcd;

005155  aa   000003 2350 07   lda       3,dl
005156  aa  6 00242 3715 20   epp5      pr6|162,*           subp
005157  aa  5 00001 5511 04   stba      pr5|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 995
               sub_mbx.op_code = reject_request_temp;

005160  aa   016000 2350 07   lda       7168,dl
005161  aa  5 00001 5511 10   stba      pr5|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 997
               call return_mbx (i);

005162  aa   002172 3520 04   epp2      1146,ic             007354 = 000002000000
005163  aa   001067 6700 04   tsp4      567,ic              006252
                                                            STATEMENT 1 ON LINE 998
               fnp_info.input_reject_count = fnp_info.input_reject_count + 1;

005164  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
005165  aa  7 00046 0541 00   aos       pr7|38              fnp_info.input_reject_count
                                                            STATEMENT 1 ON LINE 999
               call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);

005166  aa   772752 2370 04   ldaq      -2582,ic            000140 = 000000000000 000000000000
005167  aa  6 01160 7571 00   staq      pr6|624
005170  aa  6 00134 3521 00   epp2      pr6|92              devx
005171  aa  6 01150 2521 00   spri2     pr6|616
005172  aa   772714 3520 04   epp2      -2612,ic            000106 = 000000000007
005173  aa  6 01152 2521 00   spri2     pr6|618
005174  aa  6 01160 3521 00   epp2      pr6|624
005175  aa  6 01154 2521 00   spri2     pr6|620
005176  aa  6 01146 6211 00   eax1      pr6|614
005177  aa   014000 4310 07   fld       6144,dl
005200  aa  6 00044 3701 20   epp4      pr6|36,*
005201  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
005202  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1000
          end;

                                                            STATEMENT 1 ON LINE 1002
     end /* process_accept_input */;

005203  aa  6 00366 6101 00   rtcd      pr6|246
  END PROCEDURE process_accept_input
BEGIN PROCEDURE process_rtx
ENTRY TO process_rtx                                        STATEMENT 1 ON LINE 1005
process_rtx:
     proc;

005204  aa  6 00402 6501 00   spri4     pr6|258
                                                            STATEMENT 1 ON LINE 1014
          fnp_info.input_data_transactions = fnp_info.input_data_transactions + 1;

005205  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
005206  aa  7 00051 2351 00   lda       pr7|41              fnp_info.input_data_transactions
005207  aa   000044 7330 00   lrs       36
005210  aa   000001 0330 07   adl       1,dl
005211  aa  7 00051 7561 00   stq       pr7|41              fnp_info.input_data_transactions
                                                            STATEMENT 1 ON LINE 1015
          real_word_cnt = input_sub_mbx.n_chars;

005212  aa  6 00242 3715 20   epp5      pr6|162,*           subp
005213  aa  5 00001 2351 00   lda       pr5|1               input_sub_mbx.n_chars
005214  aa   000066 7330 00   lrs       54
005215  aa  6 00410 7561 00   stq       pr6|264             real_word_cnt
                                                            STATEMENT 1 ON LINE 1016
          lcte.meters.in_bytes = lcte.meters.in_bytes + real_word_cnt;

005216  aa   000044 7770 00   llr       36
005217  aa   000044 7330 00   lrs       36
005220  aa  6 00254 3535 20   epp3      pr6|172,*           lctep
005221  aa  3 00006 0331 00   adl       pr3|6               lcte.in_bytes
005222  aa  3 00006 7561 00   stq       pr3|6               lcte.in_bytes
                                                            STATEMENT 1 ON LINE 1017
          rtx_info.break_char = substr (input_sub_mbx.command_data, 18, 1);

005223  aa  5 00033 2351 00   lda       pr5|27              input_sub_mbx.command_data
005224  aa   000001 7710 00   arl       1
005225  aa  6 00263 6751 00   era       pr6|179             rtx_info.break_char
005226  aa   400000 3750 07   ana       131072,dl
005227  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.break_char
                                                            STATEMENT 1 ON LINE 1018
          call check_ff ("0"b);

005230  aa   000000 2350 07   lda       0,dl
005231  aa  6 01162 7551 00   sta       pr6|626
005232  aa   002046 3520 04   epp2      1062,ic             007300 = 000002000000
005233  aa   000303 6700 04   tsp4      195,ic              005536
                                                            STATEMENT 1 ON LINE 1019
          input_count = real_word_cnt;

005234  aa  6 00410 2361 00   ldq       pr6|264             real_word_cnt
005235  aa  6 00142 7561 00   stq       pr6|98              input_count
                                                            STATEMENT 1 ON LINE 1020
          if input_count ^= 0                               /* must have been a single FF that we discarded */
          then do;

005236  aa   000051 6000 04   tze       41,ic               005307
                                                            STATEMENT 1 ON LINE 1022
               rtx_info.output_in_fnp = substr (input_sub_mbx.command_data, 17, 1);

005237  aa  6 00242 3735 20   epp7      pr6|162,*           subp
005240  aa  7 00033 2351 00   lda       pr7|27              input_sub_mbx.command_data
005241  aa   000003 7710 00   arl       3
005242  aa  6 00263 6751 00   era       pr6|179             rtx_info.output_in_fnp
005243  aa   200000 3750 07   ana       65536,dl
005244  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.output_in_fnp
                                                            STATEMENT 1 ON LINE 1023
               rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);

005245  aa  6 00270 3715 20   epp5      pr6|184,*           pcbp
005246  aa  5 00001 2351 00   lda       pr5|1               pcb.write_first
005247  aa   000066 7330 00   lrs       54
005250  aa  0 00515 7001 00   tsx0      pr0|333             r_ne_as
005251  aa   000024 7710 00   arl       20
005252  aa  6 00263 6751 00   era       pr6|179             rtx_info.output_in_ring_0
005253  aa   100000 3750 07   ana       32768,dl
005254  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.output_in_ring_0
                                                            STATEMENT 1 ON LINE 1024
               rtx_info.input_count = input_count;

005255  aa  6 00142 2361 00   ldq       pr6|98              input_count
005256  aa   000066 7370 00   lls       54
005257  aa  6 00263 5511 60   stba      pr6|179,60          rtx_info.input_count
                                                            STATEMENT 1 ON LINE 1025
               rtx_info.chain_head = bit (pcb.read_first, 18);

005260  aa  5 00005 2351 00   lda       pr5|5               pcb.read_first
005261  aa   000066 7730 00   lrl       54
005262  aa   000066 7370 00   lls       54
005263  aa  6 00262 5511 60   stba      pr6|178,60          rtx_info.chain_head
                                                            STATEMENT 1 ON LINE 1026
               rtx_info.chain_tail = bit (pcb.read_last, 18);

005264  aa  5 00005 2361 00   ldq       pr5|5               pcb.read_last
005265  aa  0 00374 3771 00   anaq      pr0|252             = 000000000000 000000777777
005266  aa   000066 7370 00   lls       54
005267  aa   000022 7730 00   lrl       18
005270  aa  6 00262 5511 14   stba      pr6|178,14          rtx_info.chain_tail
                                                            STATEMENT 1 ON LINE 1027
               interrupt_info = unspec (rtx_info);

005271  aa  6 00262 2371 00   ldaq      pr6|178
005272  aa  6 00256 7571 00   staq      pr6|174             interrupt_info
                                                            STATEMENT 1 ON LINE 1028
               call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);

005273  aa  6 00134 3521 00   epp2      pr6|92              devx
005274  aa  6 01166 2521 00   spri2     pr6|630
005275  aa   772605 3520 04   epp2      -2683,ic            000102 = 000000000006
005276  aa  6 01170 2521 00   spri2     pr6|632
005277  aa  6 00256 3521 00   epp2      pr6|174             interrupt_info
005300  aa  6 01172 2521 00   spri2     pr6|634
005301  aa  6 01164 6211 00   eax1      pr6|628
005302  aa   014000 4310 07   fld       6144,dl
005303  aa  6 00044 3701 20   epp4      pr6|36,*
005304  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
005305  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1029
          end;

005306  aa   000022 7100 04   tra       18,ic               005330
                                                            STATEMENT 1 ON LINE 1031
          else call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, pcb.read_first));

005307  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005310  aa  7 00005 2351 00   lda       pr7|5               pcb.read_first
005311  aa   000066 7730 00   lrl       54
005312  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
005313  aa   000000 3120 06   eawp2     0,ql
005314  aa  6 01174 2521 00   spri2     pr6|636
005315  aa  6 00134 3521 00   epp2      pr6|92              devx
005316  aa  6 01166 2521 00   spri2     pr6|630
005317  aa   772527 3520 04   epp2      -2729,ic            000046 = 000000000000
005320  aa  6 01170 2521 00   spri2     pr6|632
005321  aa  6 01174 3521 00   epp2      pr6|636
005322  aa  6 01172 2521 00   spri2     pr6|634
005323  aa  6 01164 6211 00   eax1      pr6|628
005324  aa   014000 4310 07   fld       6144,dl
005325  aa  6 00044 3701 20   epp4      pr6|36,*
005326  la  4 00066 3521 20   epp2      pr4|54,*            tty_space_man$free_chain
005327  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1033
          pcb.read_first, pcb.read_last = 0;

005330  aa   000000 2350 07   lda       0,dl
005331  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005332  aa  7 00005 5511 60   stba      pr7|5,60            pcb.read_first
005333  aa   000022 7710 00   arl       18
005334  aa  7 00005 5511 14   stba      pr7|5,14            pcb.read_last
                                                            STATEMENT 1 ON LINE 1035
          call free_mbx (i);

005335  aa   002017 3520 04   epp2      1039,ic             007354 = 000002000000
005336  aa   000724 6700 04   tsp4      468,ic              006262
                                                            STATEMENT 1 ON LINE 1037
          return;

005337  aa  6 00402 6101 00   rtcd      pr6|258
ENTRY TO process_input_in_mbx                               STATEMENT 1 ON LINE 1039
process_input_in_mbx:
     entry;

005340  aa  6 00402 6501 00   spri4     pr6|258
                                                            STATEMENT 1 ON LINE 1044
          numchars = fnp_sub_mbx.n_chars;

005341  aa  6 00242 3735 20   epp7      pr6|162,*           subp
005342  aa  7 00001 2351 00   lda       pr7|1               fnp_sub_mbx.n_chars
005343  aa   000011 7350 00   als       9
005344  aa   000077 7730 00   lrl       63
005345  aa  6 00130 7561 00   stq       pr6|88              numchars
                                                            STATEMENT 1 ON LINE 1045
          rtx_info.break_char = substr (fnp_sub_mbx.command_data, 18, 1);
005346  aa  7 00033 2351 00   lda       pr7|27              fnp_sub_mbx.command_data
005347  aa   000001 7710 00   arl       1
005350  aa  6 00263 6751 00   era       pr6|179             rtx_info.break_char
005351  aa   400000 3750 07   ana       131072,dl
005352  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.break_char
                                                            STATEMENT 1 ON LINE 1046
          call check_ff ("1"b);

005353  aa   400000 2350 03   lda       131072,du
005354  aa  6 01163 7551 00   sta       pr6|627
005355  aa   001717 3520 04   epp2      975,ic              007274 = 000002000000
005356  aa   000160 6700 04   tsp4      112,ic              005536
                                                            STATEMENT 1 ON LINE 1047
          if numchars > 0
          then do;

005357  aa  6 00130 2361 00   ldq       pr6|88              numchars
005360  aa   000153 6044 04   tmoz      107,ic              005533
                                                            STATEMENT 1 ON LINE 1049
               n_words = divide (numchars + 3, 4, 17, 0);

005361  aa   000003 0760 07   adq       3,dl
005362  aa   000004 5060 07   div       4,dl
005363  aa  6 00411 7561 00   stq       pr6|265             n_words
                                                            STATEMENT 1 ON LINE 1050
               if enough_input_space (n_words)
               then do;

005364  aa   001702 3520 04   epp2      962,ic              007266 = 000004000000
005365  aa   000302 6700 04   tsp4      194,ic              005667
005366  aa  6 01163 2351 00   lda       pr6|627
005367  aa   400000 3150 03   cana      131072,du
005370  aa   000116 6000 04   tze       78,ic               005506
                                                            STATEMENT 1 ON LINE 1052
                    buf_size = 16 * (divide (n_words + 17, 16, 17, 0));

005371  aa  6 00411 2361 00   ldq       pr6|265             n_words
005372  aa   000021 0760 07   adq       17,dl
005373  aa   000020 5060 07   div       16,dl
005374  aa   000004 7360 00   qls       4
005375  aa  6 00412 7561 00   stq       pr6|266             buf_size
                                                            STATEMENT 1 ON LINE 1054
                    call tty_space_man$get_buffer (devx, buf_size, INPUT, blockp);

005376  aa  6 00134 3521 00   epp2      pr6|92              devx
005377  aa  6 01200 2521 00   spri2     pr6|640
005400  aa  6 00412 3521 00   epp2      pr6|266             buf_size
005401  aa  6 01202 2521 00   spri2     pr6|642
005402  aa   772444 3520 04   epp2      -2780,ic            000046 = 000000000000
005403  aa  6 01204 2521 00   spri2     pr6|644
005404  aa  6 00274 3521 00   epp2      pr6|188             blockp
005405  aa  6 01206 2521 00   spri2     pr6|646
005406  aa  6 01176 6211 00   eax1      pr6|638
005407  aa   020000 4310 07   fld       8192,dl
005410  aa  6 00044 3701 20   epp4      pr6|36,*
005411  la  4 00064 3521 20   epp2      pr4|52,*            tty_space_man$get_buffer
005412  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1055
                    if blockp = null
                    then go to not_enough_space;

005413  aa  6 00274 2371 00   ldaq      pr6|188             blockp
005414  aa   772526 6770 04   eraq      -2730,ic            000142 = 077777000043 000001000000
005415  aa  0 00460 3771 00   anaq      pr0|304             = 077777000077 777777077077
005416  aa   000070 6000 04   tze       56,ic               005506
                                                            STATEMENT 1 ON LINE 1058
                    source_ptr = addr (fnp_sub_mbx.input_data);

005417  aa  6 00242 3735 20   epp7      pr6|162,*           subp
005420  aa  7 00002 3735 00   epp7      pr7|2               fnp_sub_mbx.input_data
005421  aa  6 00414 6535 00   spri7     pr6|268             source_ptr
                                                            STATEMENT 1 ON LINE 1059
                    target_ptr = addr (buffer.chars);

005422  aa  6 00274 3715 20   epp5      pr6|188,*           blockp
005423  aa  5 00001 3715 00   epp5      pr5|1               buffer.chars
005424  aa  6 00416 6515 00   spri5     pr6|270             target_ptr
                                                            STATEMENT 1 ON LINE 1060
                    target_ptr -> chars = source_ptr -> chars;

005425  aa  6 00130 7271 00   lxl7      pr6|88              numchars
005426  aa  040 140 100 540   mlr       (pr,rl),(pr,rl),fill(040)
005427  aa  7 00000 00 0017   desc9a    pr7|0,x7            chars
005430  aa  5 00000 00 0017   desc9a    pr5|0,x7            chars
                                                            STATEMENT 1 ON LINE 1061
                    buffer.tally = numchars;

005431  aa  6 00130 2361 00   ldq       pr6|88              numchars
005432  aa  6 00274 3535 20   epp3      pr6|188,*           buffer.tally
005433  aa  3 00000 5521 04   stbq      pr3|0,04            buffer.tally
                                                            STATEMENT 1 ON LINE 1062
                    rtx_info.output_in_fnp = substr (fnp_sub_mbx.command_data, 17, 1);

005434  aa  6 00242 3535 20   epp3      pr6|162,*           subp
005435  aa  3 00033 2351 00   lda       pr3|27              fnp_sub_mbx.command_data
005436  aa   000003 7710 00   arl       3
005437  aa  6 00263 6751 00   era       pr6|179             rtx_info.output_in_fnp
005440  aa   200000 3750 07   ana       65536,dl
005441  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.output_in_fnp
                                                            STATEMENT 1 ON LINE 1063
                    rtx_info.output_in_ring_0 = (pcb.write_first ^= 0);

005442  aa  6 00270 3515 20   epp1      pr6|184,*           pcbp
005443  aa  1 00001 2351 00   lda       pr1|1               pcb.write_first
005444  aa   000066 7330 00   lrs       54
005445  aa  0 00515 7001 00   tsx0      pr0|333             r_ne_as
005446  aa   000024 7710 00   arl       20
005447  aa  6 00263 6751 00   era       pr6|179             rtx_info.output_in_ring_0
005450  aa   100000 3750 07   ana       32768,dl
005451  aa  6 00263 6551 00   ersa      pr6|179             rtx_info.output_in_ring_0
                                                            STATEMENT 1 ON LINE 1064
                    rtx_info.input_count = numchars;

005452  aa  6 00130 2361 00   ldq       pr6|88              numchars
005453  aa   000066 7370 00   lls       54
005454  aa  6 00263 5511 60   stba      pr6|179,60          rtx_info.input_count
                                                            STATEMENT 1 ON LINE 1065
                    rtx_info.chain_head, rtx_info.chain_tail = rel (blockp);
005455  aa  6 00274 6351 20   eaa       pr6|188,*           blockp
005456  aa  6 00262 5511 60   stba      pr6|178,60          rtx_info.chain_head
005457  aa   000022 7710 00   arl       18
005460  aa  6 00262 5511 14   stba      pr6|178,14          rtx_info.chain_tail
                                                            STATEMENT 1 ON LINE 1067
                    lcte.meters.in_bytes = lcte.meters.in_bytes + numchars;

005461  aa  6 00254 3715 20   epp5      pr6|172,*           lctep
005462  aa  5 00006 2351 00   lda       pr5|6               lcte.in_bytes
005463  aa   000044 7330 00   lrs       36
005464  aa  6 00130 0331 00   adl       pr6|88              numchars
005465  aa  5 00006 7561 00   stq       pr5|6               lcte.in_bytes
                                                            STATEMENT 1 ON LINE 1068
                    interrupt_info = unspec (rtx_info);

005466  aa  6 00262 2371 00   ldaq      pr6|178
005467  aa  6 00256 7571 00   staq      pr6|174             interrupt_info
                                                            STATEMENT 1 ON LINE 1069
                    call channel_manager$interrupt (devx, ACCEPT_INPUT, interrupt_info);

005470  aa  6 00134 3521 00   epp2      pr6|92              devx
005471  aa  6 01166 2521 00   spri2     pr6|630
005472  aa   772410 3520 04   epp2      -2808,ic            000102 = 000000000006
005473  aa  6 01170 2521 00   spri2     pr6|632
005474  aa  6 00256 3521 00   epp2      pr6|174             interrupt_info
005475  aa  6 01172 2521 00   spri2     pr6|634
005476  aa  6 01164 6211 00   eax1      pr6|628
005477  aa   014000 4310 07   fld       6144,dl
005500  aa  6 00044 3701 20   epp4      pr6|36,*
005501  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
005502  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1070
                    call free_mbx (i);

005503  aa   001651 3520 04   epp2      937,ic              007354 = 000002000000
005504  aa   000556 6700 04   tsp4      366,ic              006262
                                                            STATEMENT 1 ON LINE 1071
               end;

005505  aa   000030 7100 04   tra       24,ic               005535
                                                            STATEMENT 1 ON LINE 1073
               else do;

                                                            STATEMENT 1 ON LINE 1074
not_enough_space:
                    sub_mbx.io_cmd = wcd;

005506  aa   000003 2350 07   lda       3,dl
005507  aa  6 00242 3735 20   epp7      pr6|162,*           subp
005510  aa  7 00001 5511 04   stba      pr7|1,04            sub_mbx.io_cmd
                                                            STATEMENT 1 ON LINE 1076
                    sub_mbx.op_code = reject_request_temp;

005511  aa   016000 2350 07   lda       7168,dl
005512  aa  7 00001 5511 10   stba      pr7|1,10            sub_mbx.op_code
                                                            STATEMENT 1 ON LINE 1077
                    call return_mbx (i);

005513  aa   001641 3520 04   epp2      929,ic              007354 = 000002000000
005514  aa   000536 6700 04   tsp4      350,ic              006252
                                                            STATEMENT 1 ON LINE 1078
                    call channel_manager$interrupt (devx, INPUT_REJECTED, ""b);

005515  aa   772423 2370 04   ldaq      -2797,ic            000140 = 000000000000 000000000000
005516  aa  6 01174 7571 00   staq      pr6|636
005517  aa  6 00134 3521 00   epp2      pr6|92              devx
005520  aa  6 01166 2521 00   spri2     pr6|630
005521  aa   772365 3520 04   epp2      -2827,ic            000106 = 000000000007
005522  aa  6 01170 2521 00   spri2     pr6|632
005523  aa  6 01174 3521 00   epp2      pr6|636
005524  aa  6 01172 2521 00   spri2     pr6|634
005525  aa  6 01164 6211 00   eax1      pr6|628
005526  aa   014000 4310 07   fld       6144,dl
005527  aa  6 00044 3701 20   epp4      pr6|36,*
005530  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
005531  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1079
               end;

                                                            STATEMENT 1 ON LINE 1080
          end;

005532  aa   000003 7100 04   tra       3,ic                005535
                                                            STATEMENT 1 ON LINE 1082
          else call free_mbx (i);

005533  aa   001621 3520 04   epp2      913,ic              007354 = 000002000000
005534  aa   000526 6700 04   tsp4      342,ic              006262
                                                            STATEMENT 1 ON LINE 1083
          return;

005535  aa  6 00402 6101 00   rtcd      pr6|258
                                                            STATEMENT 1 ON LINE 1128
     end /* process_rtx */;

BEGIN PROCEDURE check_ff
ENTRY TO check_ff                                           STATEMENT 1 ON LINE 1085
check_ff:
          proc (in_mbx);

005536  aa  6 00420 6501 00   spri4     pr6|272
005537  aa  6 00422 2521 00   spri2     pr6|274
                                                            STATEMENT 1 ON LINE 1090
               rtx_info.formfeed_present = "0"b;

005540  aa   001524 2350 04   lda       852,ic              007264 = 777777737777
005541  aa  6 00263 3551 00   ansa      pr6|179             rtx_info.formfeed_present
                                                            STATEMENT 1 ON LINE 1091
               if pcb.sync_line                             /* form feeds not interesting in this case */
               then return;

005542  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
005543  aa  7 00004 2351 00   lda       pr7|4               pcb.sync_line
005544  aa   020000 3150 03   cana      8192,du
005545  aa   000002 6000 04   tze       2,ic                005547
005546  aa  6 00420 6101 00   rtcd      pr6|272
                                                            STATEMENT 1 ON LINE 1094
               if in_mbx
               then do;
005547  aa  2 00002 3715 20   epp5      pr2|2,*
005550  aa  003 100 060 500   csl       (pr),(pr),fill(0),bool(move)
005551  aa  5 00000 00 0001   descb     pr5|0,1             in_mbx
005552  aa  6 01210 00 0044   descb     pr6|648,36          in_mbx
005553  aa  6 01210 2351 00   lda       pr6|648             in_mbx
005554  aa   000007 6000 04   tze       7,ic                005563
                                                            STATEMENT 1 ON LINE 1096
                    bufp = addr (fnp_sub_mbx.input_data);

005555  aa  6 00242 3535 20   epp3      pr6|162,*           subp
005556  aa  3 00002 3535 00   epp3      pr3|2               fnp_sub_mbx.input_data
005557  aa  6 00114 2535 00   spri3     pr6|76              bufp
                                                            STATEMENT 1 ON LINE 1097
                    chars_left = numchars;

005560  aa  6 00130 2361 00   ldq       pr6|88              numchars
005561  aa  6 00127 7561 00   stq       pr6|87              chars_left
                                                            STATEMENT 1 ON LINE 1098
               end;

005562  aa   000013 7100 04   tra       11,ic               005575
                                                            STATEMENT 1 ON LINE 1100
               else do;

                                                            STATEMENT 1 ON LINE 1101
                    blockp = ptr (ttybp, pcb.read_last);

005563  aa  7 00005 2361 00   ldq       pr7|5               pcb.read_last
005564  aa  0 00374 3771 00   anaq      pr0|252             = 000000000000 000000777777
005565  aa  6 00272 3515 20   epp1      pr6|186,*           ttybp
005566  aa   000000 3114 06   eawp1     0,ql
005567  aa  6 00274 2515 00   spri1     pr6|188             blockp
                                                            STATEMENT 1 ON LINE 1102
                    chars_left = buffer.tally;

005570  aa  1 00000 2361 00   ldq       pr1|0               buffer.tally
005571  aa  0 00416 3771 00   anaq      pr0|270             = 000000000000 000000000777
005572  aa  6 00127 7561 00   stq       pr6|87              chars_left
                                                            STATEMENT 1 ON LINE 1103
                    bufp = addr (buffer.chars);

005573  aa  1 00001 3535 00   epp3      pr1|1               buffer.chars
005574  aa  6 00114 2535 00   spri3     pr6|76              bufp
                                                            STATEMENT 1 ON LINE 1104
               end;

                                                            STATEMENT 1 ON LINE 1106
               if substr (bufp -> input_chars, chars_left, 1) = form_feed
                                                            /* yup, input ends with FF */
               then rtx_info.formfeed_present = "1"b;

005575  aa  040 004 106 506   cmpc      (pr,ql),(ic),fill(040)
005576  aa  3 77777 60 0001   desc9a    pr3|-1(3),1         input_chars
005577  aa   001655 00 0001   desc9a    941,1               007452 = 014000000000
005600  aa   000003 6010 04   tnz       3,ic                005603
005601  aa   040000 2350 07   lda       16384,dl
005602  aa  6 00263 2551 00   orsa      pr6|179             rtx_info.formfeed_present
                                                            STATEMENT 1 ON LINE 1109
               if pcb.flags.end_frame & rtx_info.break_char /* time to restart suspended output */
               then do;
005603  aa  7 00004 2351 00   lda       pr7|4               pcb.end_frame
005604  aa   010000 3150 03   cana      4096,du
005605  aa   000061 6000 04   tze       49,ic               005666
005606  aa  6 00263 2351 00   lda       pr6|179             rtx_info.break_char
005607  aa   400000 3150 07   cana      131072,dl
005610  aa   000056 6000 04   tze       46,ic               005666
                                                            STATEMENT 1 ON LINE 1111
                    if (chars_left <= 2)
                    then if verify (substr (bufp -> input_chars, 1, chars_left), ff_cr_lf) = 0
                         then do;

005611  aa   000002 1160 07   cmpq      2,dl
005612  aa   000020 6054 04   tpnz      16,ic               005632
005613  aa  000 000 164 540   tct       (pr,rl)
005614  aa  3 00000 00 0006   desc9a    pr3|0,ql            input_chars
005615  aa   001251 0000 04   arg       681,ic              007064 = 777777777777
005616  aa  6 00056 0001 00   arg       pr6|46
005617  aa  6 00056 2361 00   ldq       pr6|46
005620  aa  0 00242 3761 00   anq       pr0|162             = 000777777777
005621  aa   000002 6070 04   ttf       2,ic                005623
005622  aa   000001 3360 07   lcq       1,dl
005623  aa   000001 0760 07   adq       1,dl
005624  aa   000006 6010 04   tnz       6,ic                005632
                                                            STATEMENT 1 ON LINE 1114
                              if in_mbx
                              then numchars = 0;

005625  aa  6 01210 2351 00   lda       pr6|648             in_mbx
005626  aa   000003 6000 04   tze       3,ic                005631
005627  aa  6 00130 4501 00   stz       pr6|88              numchars
005630  aa   000002 7100 04   tra       2,ic                005632
                                                            STATEMENT 1 ON LINE 1116
                              else real_word_cnt = 0;

005631  aa  6 00410 4501 00   stz       pr6|264             real_word_cnt
                                                            STATEMENT 1 ON LINE 1117
                         end;

                                                            STATEMENT 1 ON LINE 1118
                    pcb.flags.end_frame = "0"b;

005632  aa   001541 2350 04   lda       865,ic              007373 = 767777777777
005633  aa  7 00004 3551 00   ansa      pr7|4               pcb.end_frame
                                                            STATEMENT 1 ON LINE 1119
                    if pcb.flags.send_output                /* more output to ship */
                    then if pcb.write_first ^= 0            /* it's waiting in tty_buf */
                         then call make_q_entry (accept_direct_output, 0, ""b);

005634  aa  7 00004 2351 00   lda       pr7|4               pcb.send_output
005635  aa   100000 3150 03   cana      32768,du
005636  aa   000030 6000 04   tze       24,ic               005666
005637  aa  7 00001 2351 00   lda       pr7|1               pcb.write_first
005640  aa   000066 7330 00   lrs       54
005641  aa   000010 6000 04   tze       8,ic                005651
005642  aa  6 01210 4501 00   stz       pr6|648
005643  aa  000 100 100 400   mlr       (),(pr),fill(000)
005644  aa   000000 00 0000   desc9a    0,0
005645  aa  6 01212 00 0040   desc9a    pr6|650,32
005646  aa   001206 3520 04   epp2      646,ic              007054 = 000006000000
005647  aa   000050 6700 04   tsp4      40,ic               005717
005650  aa   000016 7100 04   tra       14,ic               005666
                                                            STATEMENT 1 ON LINE 1123
                         else call channel_manager$interrupt (devx, SEND_OUTPUT, ""b);

005651  aa   772267 2370 04   ldaq      -2889,ic            000140 = 000000000000 000000000000
005652  aa  6 01222 7571 00   staq      pr6|658
005653  aa  6 00134 3521 00   epp2      pr6|92              devx
005654  aa  6 01214 2521 00   spri2     pr6|652
005655  aa   772236 3520 04   epp2      -2914,ic            000113 = 000000000004
005656  aa  6 01216 2521 00   spri2     pr6|654
005657  aa  6 01222 3521 00   epp2      pr6|658
005660  aa  6 01220 2521 00   spri2     pr6|656
005661  aa  6 01212 6211 00   eax1      pr6|650
005662  aa   014000 4310 07   fld       6144,dl
005663  aa  6 00044 3701 20   epp4      pr6|36,*
005664  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
005665  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1124
               end;

                                                            STATEMENT 1 ON LINE 1126
          end /* check_ff */;

005666  aa  6 00420 6101 00   rtcd      pr6|272
  END PROCEDURE check_ff
  END PROCEDURE process_rtx
BEGIN PROCEDURE enough_input_space
ENTRY TO enough_input_space                                 STATEMENT 1 ON LINE 1132
enough_input_space:
     proc (count) returns (bit (1));

005667  aa  6 00426 6501 00   spri4     pr6|278
005670  aa  6 00430 2521 00   spri2     pr6|280
                                                            STATEMENT 1 ON LINE 1137
          lctp = tty_buf.lct_ptr;

005671  aa  6 00272 3735 20   epp7      pr6|186,*           ttybp
005672  aa  7 00006 3735 20   epp7      pr7|6,*             tty_buf.lct_ptr
005673  aa  6 00252 6535 00   spri7     pr6|170             lctp
                                                            STATEMENT 1 ON LINE 1138
          chan_lctep = addr (lct.lcte_array (devx));

005674  aa  6 00134 2361 00   ldq       pr6|92              devx
005675  aa   000005 7360 00   qls       5
005676  aa  7 77760 3715 06   epp5      pr7|-16,ql          lct.lcte_array
005677  aa  6 00144 6515 00   spri5     pr6|100             chan_lctep
                                                            STATEMENT 1 ON LINE 1139
          return (chan_lctep -> lcte.input_words + count <= divide (tty_buf.bleft, input_bpart, 17, 0));

005700  aa  6 00272 3535 20   epp3      pr6|186,*           ttybp
005701  aa  3 00003 2361 00   ldq       pr3|3               tty_buf.bleft
005702  aa   000002 5060 07   div       2,dl
005703  aa  6 01224 7561 00   stq       pr6|660
005704  aa  5 00005 2351 00   lda       pr5|5               lcte.input_words
005705  aa   000066 7330 00   lrs       54
005706  aa  2 00002 0761 20   adq       pr2|2,*             count
005707  aa  6 01224 1161 00   cmpq      pr6|660
005710  aa  0 00520 7001 00   tsx0      pr0|336             r_le_a
005711  aa  6 01224 7551 00   sta       pr6|660
005712  aa  2 00004 3515 20   epp1      pr2|4,*
005713  aa  003 100 060 500   csl       (pr),(pr),fill(0),bool(move)
005714  aa  6 01224 00 0001   descb     pr6|660,1
005715  aa  1 00000 00 0001   descb     pr1|0,1
005716  aa  6 00426 6101 00   rtcd      pr6|278
                                                            STATEMENT 1 ON LINE 1140
     end /* enough_input_space */;

  END PROCEDURE enough_input_space
BEGIN PROCEDURE make_q_entry
ENTRY TO make_q_entry                                       STATEMENT 1 ON LINE 1145
make_q_entry:
     proc (opc, cnt, databits);

005717  aa  6 00434 6501 00   spri4     pr6|284
005720  aa  6 00436 2521 00   spri2     pr6|286
                                                            STATEMENT 1 ON LINE 1151
          call tty_space_man$get_space (size (q_entry), new_qp);

005721  aa   000012 2360 07   ldq       10,dl
005722  aa  6 01225 7561 00   stq       pr6|661
005723  aa  6 01225 3521 00   epp2      pr6|661
005724  aa  6 01230 2521 00   spri2     pr6|664
005725  aa  6 00174 3521 00   epp2      pr6|124             new_qp
005726  aa  6 01232 2521 00   spri2     pr6|666
005727  aa  6 01226 6211 00   eax1      pr6|662
005730  aa   010000 4310 07   fld       4096,dl
005731  aa  6 00044 3701 20   epp4      pr6|36,*
005732  la  4 00060 3521 20   epp2      pr4|48,*            tty_space_man$get_space
005733  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1152
          if new_qp = null
          then do;

005734  aa  6 00174 2371 00   ldaq      pr6|124             new_qp
005735  aa   772205 6770 04   eraq      -2939,ic            000142 = 077777000043 000001000000
005736  aa  0 00460 3771 00   anaq      pr0|304             = 077777000077 777777077077
005737  aa   000022 6010 04   tnz       18,ic               005761
                                                            STATEMENT 1 ON LINE 1154
               call syserr (crash_system, "dn355: unable to allocate block for delay queue");

005740  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
005741  aa   772350 00 0060   desc9a    -2840,48            000310 = 144156063065
005742  aa  6 01234 00 0060   desc9a    pr6|668,48
005743  aa   772166 3520 04   epp2      -2954,ic            000131 = 000000000001
005744  aa  6 01252 2521 00   spri2     pr6|682
005745  aa  6 01234 3521 00   epp2      pr6|668
005746  aa  6 01254 2521 00   spri2     pr6|684
005747  aa   772152 3520 04   epp2      -2966,ic            000121 = 404000000021
005750  aa  6 01256 2521 00   spri2     pr6|686
005751  aa   772103 3520 04   epp2      -3005,ic            000054 = 524000000057
005752  aa  6 01260 2521 00   spri2     pr6|688
005753  aa  6 01250 6211 00   eax1      pr6|680
005754  aa   010000 4310 07   fld       4096,dl
005755  aa  6 00044 3701 20   epp4      pr6|36,*
005756  la  4 00016 3521 20   epp2      pr4|14,*            syserr
005757  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 1155
               return;
005760  aa  6 00434 6101 00   rtcd      pr6|284
                                                            STATEMENT 1 ON LINE 1156
          end;

                                                            STATEMENT 1 ON LINE 1158
          new_qrel = bin (rel (new_qp));

005761  aa  6 00174 6351 20   eaa       pr6|124,*           new_qp
005762  aa   000066 7730 00   lrl       54
005763  aa  6 00176 7561 00   stq       pr6|126             new_qrel
                                                            STATEMENT 1 ON LINE 1159
          if fnp_info.cur_ptr = 0                           /* nothing in the queue yet */
          then fnp_info.cur_ptr = new_qrel;

005764  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
005765  aa  7 00025 2361 00   ldq       pr7|21              fnp_info.cur_ptr
005766  aa   000004 6010 04   tnz       4,ic                005772
005767  aa  6 00176 2361 00   ldq       pr6|126             new_qrel
005770  aa  7 00025 7561 00   stq       pr7|21              fnp_info.cur_ptr
005771  aa   000007 7100 04   tra       7,ic                006000
                                                            STATEMENT 1 ON LINE 1161
          else do;

                                                            STATEMENT 1 ON LINE 1162
               qptr = ptr (ttybp, fnp_info.last_ptr);

005772  aa  7 00026 2361 00   ldq       pr7|22              fnp_info.last_ptr
005773  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
005774  aa   000000 3120 06   eawp2     0,ql
005775  aa  6 00116 2521 00   spri2     pr6|78              qptr
                                                            STATEMENT 1 ON LINE 1163
               q_entry.next = new_qrel;

005776  aa  6 00176 2361 00   ldq       pr6|126             new_qrel
005777  aa  2 00011 7561 00   stq       pr2|9               q_entry.next
                                                            STATEMENT 1 ON LINE 1164
          end;

                                                            STATEMENT 1 ON LINE 1166
          fnp_info.last_ptr = new_qrel;

006000  aa  7 00026 7561 00   stq       pr7|22              fnp_info.last_ptr
                                                            STATEMENT 1 ON LINE 1167
          qptr = new_qp;

006001  aa  6 00174 3715 20   epp5      pr6|124,*           new_qp
006002  aa  6 00116 6515 00   spri5     pr6|78              qptr
                                                            STATEMENT 1 ON LINE 1168
          fnp_info.count = fnp_info.count + 1;

006003  aa  7 00024 0541 00   aos       pr7|20              fnp_info.count
                                                            STATEMENT 1 ON LINE 1169
          fnp_info.q_entries_made = fnp_info.q_entries_made + 1;

006004  aa  7 00045 2351 00   lda       pr7|37              fnp_info.q_entries_made
006005  aa   000044 7330 00   lrs       36
006006  aa   000001 0330 07   adl       1,dl
006007  aa  7 00045 7561 00   stq       pr7|37              fnp_info.q_entries_made
                                                            STATEMENT 1 ON LINE 1171
          q_entry.opcode = opc;
006010  aa  6 00436 3715 20   epp5      pr6|286,*
006011  aa  5 00002 2361 20   ldq       pr5|2,*             opc
006012  aa   000077 7370 00   lls       63
006013  aa  6 00116 3535 20   epp3      pr6|78,*            q_entry.opcode
006014  aa  3 00000 5511 40   stba      pr3|0,40            q_entry.opcode
                                                            STATEMENT 1 ON LINE 1172
          q_entry.cmd_count = cnt;

006015  aa  5 00004 2361 20   ldq       pr5|4,*             cnt
006016  aa   000066 7370 00   lls       54
006017  aa  6 00116 3515 20   epp1      pr6|78,*            q_entry.cmd_count
006020  aa  1 00000 5511 20   stba      pr1|0,20            q_entry.cmd_count
                                                            STATEMENT 1 ON LINE 1173
          if pcbp ^= null ()
          then q_entry.pcb_offset = rel (pcbp);

006021  aa  6 00270 2371 00   ldaq      pr6|184             pcbp
006022  aa   772120 6770 04   eraq      -2992,ic            000142 = 077777000043 000001000000
006023  aa  0 00460 3771 00   anaq      pr0|304             = 077777000077 777777077077
006024  aa   000006 6000 04   tze       6,ic                006032
006025  aa  6 00270 6351 20   eaa       pr6|184,*           pcbp
006026  aa   000022 7710 00   arl       18
006027  aa  6 00116 3515 20   epp1      pr6|78,*            q_entry.pcb_offset
006030  aa  1 00000 5511 14   stba      pr1|0,14            q_entry.pcb_offset
006031  aa   000003 7100 04   tra       3,ic                006034
                                                            STATEMENT 1 ON LINE 1175
          else q_entry.pcb_offset = "0"b;

006032  aa   777777 2350 03   lda       262143,du
006033  aa  6 00116 3551 20   ansa      pr6|78,*            q_entry.pcb_offset
                                                            STATEMENT 1 ON LINE 1176
          q_entry.next = 0;

006034  aa  6 00116 3515 20   epp1      pr6|78,*            qptr
006035  aa  1 00011 4501 00   stz       pr1|9               q_entry.next
                                                            STATEMENT 1 ON LINE 1177
          q_entry.cmd_data = databits;

006036  aa  5 00006 3535 20   epp3      pr5|6,*
006037  aa  003 100 060 500   csl       (pr),(pr),fill(0),bool(move)
006040  aa  3 00000 00 0440   descb     pr3|0,288           databits
006041  aa  1 00001 00 0440   descb     pr1|1,288           q_entry.cmd_data
                                                            STATEMENT 1 ON LINE 1178
          return;

006042  aa  6 00434 6101 00   rtcd      pr6|284
                                                            STATEMENT 1 ON LINE 1179
     end;

  END PROCEDURE make_q_entry
BEGIN PROCEDURE get_line_number
ENTRY TO get_line_number                                    STATEMENT 1 ON LINE 1183
get_line_number:
     proc;

006043  aa  6 00442 6501 00   spri4     pr6|290
                                                            STATEMENT 1 ON LINE 1188
          if string (sub_mbx.line_number) = "0"b
          then do;
006044  aa  6 00242 2351 20   lda       pr6|162,*
006045  aa   000010 7350 00   als       8
006046  aa  0 00024 3771 00   anaq      pr0|20              = 777400000000 000000000000
006047  aa  6 01262 7551 00   sta       pr6|690
006050  aa   000062 6010 04   tnz       50,ic               006132
                                                            STATEMENT 1 ON LINE 1190
               do x = 1 to hbound (global_opcodes, 1) while (sub_mbx.op_code ^= global_opcodes (x));

006051  aa   000001 2360 07   ldq       1,dl
006052  aa  6 00450 7561 00   stq       pr6|296             x
006053  aa   000000 0110 03   nop       0,du
006054  aa  6 00450 2361 00   ldq       pr6|296             x
006055  aa   000011 1160 07   cmpq      9,dl
006056  aa   000012 6054 04   tpnz      10,ic               006070
006057  aa  6 00242 3735 20   epp7      pr6|162,*           subp
006060  aa  7 00001 2351 00   lda       pr7|1               sub_mbx.op_code
006061  aa   000022 7350 00   als       18
006062  aa   000077 7330 00   lrs       63
006063  aa  6 00450 7271 00   lxl7      pr6|296             x
006064  ta   000001 1160 17   cmpq      1,7
006065  aa   000003 6000 04   tze       3,ic                006070
                                                            STATEMENT 1 ON LINE 1191
               end;

006066  aa  6 00450 0541 00   aos       pr6|296             x
006067  aa   777765 7100 04   tra       -11,ic              006054
                                                            STATEMENT 1 ON LINE 1192
               if x > hbound (global_opcodes, 1)
               then do;

006070  aa  6 00450 2361 00   ldq       pr6|296             x
006071  aa   000011 1160 07   cmpq      9,dl
006072  aa   000033 6044 04   tmoz      27,ic               006125
                                                            STATEMENT 1 ON LINE 1194
                    call syserr (beeper, "dn355: line number of 0 with non-global opcode in submbx ^o, FNP ^a", i,
                         fnp_info.fnp_tag);

006073  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
006074  aa   772322 00 0104   desc9a    -2862,68            000415 = 144156063065
006075  aa  6 01264 00 0104   desc9a    pr6|692,68
006076  aa   772030 3520 04   epp2      -3048,ic            000126 = 000000000003
006077  aa  6 01310 2521 00   spri2     pr6|712
006100  aa  6 01264 3521 00   epp2      pr6|692
006101  aa  6 01312 2521 00   spri2     pr6|714
006102  aa  6 00123 3521 00   epp2      pr6|83              i
006103  aa  6 01314 2521 00   spri2     pr6|716
006104  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006105  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
006106  aa  6 01316 2521 00   spri2     pr6|718
006107  aa   772012 3520 04   epp2      -3062,ic            000121 = 404000000021
006110  aa  6 01320 2521 00   spri2     pr6|720
006111  aa  6 01324 2521 00   spri2     pr6|724
006112  aa   771741 3520 04   epp2      -3103,ic            000053 = 524000000103
006113  aa  6 01322 2521 00   spri2     pr6|722
006114  aa   771763 3520 04   epp2      -3085,ic            000077 = 526000000001
006115  aa  6 01326 2521 00   spri2     pr6|726
006116  aa  6 01306 6211 00   eax1      pr6|710
006117  aa   020000 4310 07   fld       8192,dl
006120  aa  6 00044 3701 20   epp4      pr6|36,*
006121  la  4 00016 3521 20   epp2      pr4|14,*            syserr
006122  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 1196
                    call report_fnp_crash;

006123  aa   000577 6700 04   tsp4      383,ic              006722
                                                            STATEMENT 1 ON LINE 1197
                    go to global_exit;

006124  aa   772722 7100 04   tra       -2606,ic            001046
                                                            STATEMENT 1 ON LINE 1198
               end;

                                                            STATEMENT 1 ON LINE 1200
               pcbp = null;

006125  aa   772015 2370 04   ldaq      -3059,ic            000142 = 077777000043 000001000000
006126  aa  6 00270 7571 00   staq      pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 1201
               devx = -1;

006127  aa   000001 3360 07   lcq       1,dl
006130  aa  6 00134 7561 00   stq       pr6|92              devx
                                                            STATEMENT 1 ON LINE 1202
          end;

006131  aa   000120 7100 04   tra       80,ic               006251
                                                            STATEMENT 1 ON LINE 1204
          else do;

                                                            STATEMENT 1 ON LINE 1205
               n_pcbs = fnp_info.no_of_channels;

006132  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006133  aa  7 00006 2361 00   ldq       pr7|6               fnp_info.no_of_channels
006134  aa  6 00266 7561 00   stq       pr6|182             n_pcbs
                                                            STATEMENT 1 ON LINE 1206
               if string (sub_mbx.line_number) = TANDD_LINE_NUMBER
                                                            /* don't decode this, go straight to it */
               then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (fnp_info.tandd_pcbx));

006135  aa   777400 1150 03   cmpa      261888,du
006136  aa   000007 6010 04   tnz       7,ic                006145
006137  aa  7 00064 2361 00   ldq       pr7|52              fnp_info.tandd_pcbx
006140  aa   000003 7360 00   qls       3
006141  aa  7 00002 3715 20   epp5      pr7|2,*             fnp_info.pcb_array_ptr
006142  aa  5 77770 3535 06   epp3      pr5|-8,ql           pcb_array
006143  aa  6 00270 2535 00   spri3     pr6|184             pcbp
006144  aa   000102 7100 04   tra       66,ic               006246
                                                            STATEMENT 1 ON LINE 1209
               else do;

                                                            STATEMENT 1 ON LINE 1210
                    lano = sub_mbx.line_number.la_no;

006145  aa  6 00242 2351 20   lda       pr6|162,*           sub_mbx.la_no
006146  aa   000011 7350 00   als       9
006147  aa  0 00006 3771 00   anaq      pr0|6               = 700000000000 000000000000
006150  aa  6 00136 7551 00   sta       pr6|94              lano
                                                            STATEMENT 1 ON LINE 1211
                    if sub_mbx.is_hsla
                    then j = fnp_info.hsla_idx (fixed (lano));

006151  aa  6 00242 2351 20   lda       pr6|162,*           sub_mbx.is_hsla
006152  aa   001000 3150 03   cana      512,du
006153  aa   000006 6000 04   tze       6,ic                006161
006154  aa  6 00136 2351 00   lda       pr6|94              lano
006155  aa   000105 7730 00   lrl       69
006156  aa  7 00021 2361 06   ldq       pr7|17,ql           fnp_info.hsla_idx
006157  aa  6 00132 7561 00   stq       pr6|90              j
006160  aa   000005 7100 04   tra       5,ic                006165
                                                            STATEMENT 1 ON LINE 1213
                    else j = fnp_info.lsla_idx (fixed (lano));

006161  aa  6 00136 2351 00   lda       pr6|94              lano
006162  aa   000105 7730 00   lrl       69
006163  aa  7 00013 2361 06   ldq       pr7|11,ql           fnp_info.lsla_idx
006164  aa  6 00132 7561 00   stq       pr6|90              j
                                                            STATEMENT 1 ON LINE 1215
                    do j = j to n_pcbs;

006165  aa  6 00266 2361 00   ldq       pr6|182             n_pcbs
006166  aa  6 00451 7561 00   stq       pr6|297
006167  aa  6 00132 2361 00   ldq       pr6|90              j
006170  aa  6 00132 7561 00   stq       pr6|90              j
006171  aa   000000 0110 03   nop       0,du
006172  aa  6 00132 2361 00   ldq       pr6|90              j
006173  aa  6 00451 1161 00   cmpq      pr6|297
006174  aa   000020 6054 04   tpnz      16,ic               006214
                                                            STATEMENT 1 ON LINE 1216
                         pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));

006175  aa   000003 7360 00   qls       3
006176  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006177  aa  7 00002 3715 20   epp5      pr7|2,*             fnp_info.pcb_array_ptr
006200  aa  5 77770 3735 06   epp7      pr5|-8,ql           pcb_array
006201  aa  6 00270 6535 00   spri7     pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 1217
                         if string (pcb.line_number) = string (sub_mbx.line_number)
                         then go to match;

006202  aa  6 00242 2351 20   lda       pr6|162,*
006203  aa   000010 7350 00   als       8
006204  aa  0 00024 3771 00   anaq      pr0|20              = 777400000000 000000000000
006205  aa  6 01262 7551 00   sta       pr6|690
006206  aa  7 00000 2351 00   lda       pr7|0
006207  aa   000032 7350 00   als       26
006210  aa  6 01262 1151 00   cmpa      pr6|690
006211  aa   000035 6000 04   tze       29,ic               006246
                                                            STATEMENT 1 ON LINE 1219
                    end;

006212  aa  6 00132 0541 00   aos       pr6|90              j
006213  aa   777757 7100 04   tra       -17,ic              006172
                                                            STATEMENT 1 ON LINE 1220
                    call syserr (beeper, "dn355: no slot number match for sub mbx ^o, FNP ^a", i, fnp_info.fnp_tag);

006214  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
006215  aa   772125 00 0064   desc9a    -2987,52            000341 = 144156063065
006216  aa  6 01264 00 0064   desc9a    pr6|692,52
006217  aa   771707 3520 04   epp2      -3129,ic            000126 = 000000000003
006220  aa  6 01310 2521 00   spri2     pr6|712
006221  aa  6 01264 3521 00   epp2      pr6|692
006222  aa  6 01312 2521 00   spri2     pr6|714
006223  aa  6 00123 3521 00   epp2      pr6|83              i
006224  aa  6 01314 2521 00   spri2     pr6|716
006225  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006226  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
006227  aa  6 01316 2521 00   spri2     pr6|718
006230  aa   771671 3520 04   epp2      -3143,ic            000121 = 404000000021
006231  aa  6 01320 2521 00   spri2     pr6|720
006232  aa  6 01324 2521 00   spri2     pr6|724
006233  aa   771617 3520 04   epp2      -3185,ic            000052 = 524000000062
006234  aa  6 01322 2521 00   spri2     pr6|722
006235  aa   771642 3520 04   epp2      -3166,ic            000077 = 526000000001
006236  aa  6 01326 2521 00   spri2     pr6|726
006237  aa  6 01306 6211 00   eax1      pr6|710
006240  aa   020000 4310 07   fld       8192,dl
006241  aa  6 00044 3701 20   epp4      pr6|36,*
006242  la  4 00016 3521 20   epp2      pr4|14,*            syserr
006243  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 1222
                    call report_fnp_crash;

006244  aa   000456 6700 04   tsp4      302,ic              006722
                                                            STATEMENT 1 ON LINE 1223
                    go to global_exit;

006245  aa   772601 7100 04   tra       -2687,ic            001046
                                                            STATEMENT 1 ON LINE 1224
               end;

                                                            STATEMENT 1 ON LINE 1226
match:
               devx = pcb.devx;

006246  aa  6 00270 2351 20   lda       pr6|184,*           pcb.devx
006247  aa   000066 7330 00   lrs       54
006250  aa  6 00134 7561 00   stq       pr6|92              devx
                                                            STATEMENT 1 ON LINE 1229
          end;

                                                            STATEMENT 1 ON LINE 1230
          return;

006251  aa  6 00442 6101 00   rtcd      pr6|290
                                                            STATEMENT 1 ON LINE 1232
     end /* get_line_number */;

  END PROCEDURE get_line_number
BEGIN PROCEDURE return_mbx
ENTRY TO return_mbx                                         STATEMENT 1 ON LINE 1236
send_mbx:
return_mbx:
     proc (a_mbx_no);

006252  aa  6 00452 6501 00   spri4     pr6|298
006253  aa  6 00454 2521 00   spri2     pr6|300
006254  aa   000003 7100 04   tra       3,ic                006257
ENTRY TO send_mbx                                           STATEMENT 1 ON LINE 1236
send_mbx:
return_mbx:
     proc (a_mbx_no);

006255  aa  6 00452 6501 00   spri4     pr6|298
006256  aa  6 00454 2521 00   spri2     pr6|300
                                                            STATEMENT 1 ON LINE 1246
          mbx_no = a_mbx_no;

006257  aa  2 00002 2361 20   ldq       pr2|2,*             a_mbx_no
006260  aa  6 00460 7561 00   stq       pr6|304             mbx_no
                                                            STATEMENT 1 ON LINE 1247
          go to test_pcw;

006261  aa   000007 7100 04   tra       7,ic                006270
ENTRY TO free_mbx                                           STATEMENT 1 ON LINE 1249
free_mbx:
     entry (a_mbx_no);

006262  aa  6 00452 6501 00   spri4     pr6|298
006263  aa  6 00454 2521 00   spri2     pr6|300
                                                            STATEMENT 1 ON LINE 1252
          mbx_no = a_mbx_no + 4;

006264  aa  6 00454 3735 20   epp7      pr6|300,*
006265  aa  7 00002 2361 20   ldq       pr7|2,*             a_mbx_no
006266  aa   000004 0760 07   adq       4,dl
006267  aa  6 00460 7561 00   stq       pr6|304             mbx_no
                                                            STATEMENT 1 ON LINE 1254
test_pcw:
          if ^fnp_info.io_manager_assigned
          then do;

006270  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006271  aa  7 00066 2351 00   lda       pr7|54              fnp_info.io_manager_assigned
006272  aa   200000 3150 03   cana      65536,du
006273  aa   000004 6010 04   tnz       4,ic                006277
                                                            STATEMENT 1 ON LINE 1257
               no_response = "1"b;

006274  aa   400000 2350 03   lda       131072,du
006275  aa  6 00140 7551 00   sta       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 1258
               return;

006276  aa  6 00452 6101 00   rtcd      pr6|298
                                                            STATEMENT 1 ON LINE 1259
          end;

                                                            STATEMENT 1 ON LINE 1261
          no_response = "0"b;

006277  aa  6 00140 4501 00   stz       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 1262
          if datanet_mbx.dia_pcw.command ^= "0"b
          then do;

006300  aa  6 00244 2351 20   lda       pr6|164,*           datanet_mbx.command
006301  aa   000077 3150 07   cana      63,dl
006302  aa   000117 6000 04   tze       79,ic               006421
                                                            STATEMENT 1 ON LINE 1264
wait_for_response:
               timeout_time = clock () + TWO_SECONDS;

006303  aa  0 01435 7001 00   tsx0      pr0|797             clock_mac
006304  aa   771542 0770 04   adaq      -3230,ic            000046 = 000000000000 000007502200
006305  aa  6 00462 7571 00   staq      pr6|306             timeout_time
                                                            STATEMENT 1 ON LINE 1266
               do while ((clock () < timeout_time) & (datanet_mbx.dia_pcw.command ^= "0"b));

006306  aa  6 00244 2351 20   lda       pr6|164,*           datanet_mbx.command
006307  aa   000077 3150 07   cana      63,dl
006310  aa  0 00515 7001 00   tsx0      pr0|333             r_ne_as
006311  aa  6 01332 7551 00   sta       pr6|730
006312  aa  0 01435 7001 00   tsx0      pr0|797             clock_mac
006313  aa  6 00462 1171 00   cmpaq     pr6|306             timeout_time
006314  aa  0 00474 7001 00   tsx0      pr0|316             r_l_a
006315  aa  6 01332 3151 00   cana      pr6|730
006316  aa   000002 6000 04   tze       2,ic                006320
                                                            STATEMENT 1 ON LINE 1268
               end;

006317  aa   777767 7100 04   tra       -9,ic               006306
                                                            STATEMENT 1 ON LINE 1269
               if datanet_mbx.dia_pcw.error | datanet_mbx.dia_pcw.command ^= "0"b
               then do;

006320  aa  6 00244 2351 20   lda       pr6|164,*           datanet_mbx.error
006321  aa   000022 7350 00   als       18
006322  aa  0 00002 3771 00   anaq      pr0|2               = 400000000000 000000000000
006323  aa  6 01333 7551 00   sta       pr6|731             datanet_mbx.error
006324  aa   000003 6010 04   tnz       3,ic                006327
006325  aa  6 01332 2351 00   lda       pr6|730
006326  aa   000073 6000 04   tze       59,ic               006421
                                                            STATEMENT 1 ON LINE 1271
                    if ^no_response
                    then do;

006327  aa  6 00140 2351 00   lda       pr6|96              no_response
006330  aa   000161 6010 04   tnz       113,ic              006511
                                                            STATEMENT 1 ON LINE 1273
                         pcw_error = datanet_mbx.dia_pcw.error;

006331  aa  6 01333 2351 00   lda       pr6|731             datanet_mbx.error
006332  aa  6 00461 7551 00   sta       pr6|305             pcw_error
                                                            STATEMENT 1 ON LINE 1274
                         no_response = "1"b;

006333  aa   400000 2350 03   lda       131072,du
006334  aa  6 00140 7551 00   sta       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 1275
                         datanet_mbx.dia_pcw.error = "0"b;

006335  aa   000515 2350 04   lda       333,ic              007052 = 777777377777
006336  aa  6 00244 3551 20   ansa      pr6|164,*           datanet_mbx.error
                                                            STATEMENT 1 ON LINE 1276
                         string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));

006337  aa  6 00244 2351 20   lda       pr6|164,*
006340  aa  6 01333 7551 00   sta       pr6|731
006341  aa  6 01333 3521 00   epp2      pr6|731
006342  aa  6 01336 2521 00   spri2     pr6|734
006343  aa  6 00244 3521 20   epp2      pr6|164,*
006344  aa  6 01340 2521 00   spri2     pr6|736
006345  aa  6 01334 6211 00   eax1      pr6|732
006346  aa   010000 4310 07   fld       4096,dl
006347  aa  6 00044 3701 20   epp4      pr6|36,*
006350  la  4 00022 3521 20   epp2      pr4|18,*            dn355_util$compute_parity
006351  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1278
                         ima.chx = fnp_info.io_manager_chx;

006352  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006353  aa  7 00012 2361 00   ldq       pr7|10              fnp_info.io_manager_chx
006354  aa  6 00464 7561 00   stq       pr6|308             ima.chx
                                                            STATEMENT 1 ON LINE 1279
                         ima.ptp = fnp_info.ptp;

006355  aa  7 00071 7651 00   lprp5     pr7|57              fnp_info.ptp
006356  aa  6 00470 6515 00   spri5     pr6|312             ima.ptp
                                                            STATEMENT 1 ON LINE 1280
                         call io_manager$connect_direct (ima);

006357  aa  6 00464 3521 00   epp2      pr6|308             ima
006360  aa  6 01336 2521 00   spri2     pr6|734
006361  aa  6 01334 6211 00   eax1      pr6|732
006362  aa   004000 4310 07   fld       2048,dl
006363  aa  6 00044 3701 20   epp4      pr6|36,*
006364  la  4 00054 3521 20   epp2      pr4|44,*            io_manager$connect_direct
006365  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1282
                         call syserr (just_tell,
                              "dn355: ^[Error^;Timeout^] sending mailbox interrupt to FNP ^a, will retry.", pcw_error,
                              fnp_info.fnp_tag);

006366  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
006367  aa   772071 00 0114   desc9a    -3015,76            000457 = 144156063065
006370  aa  6 01342 00 0114   desc9a    pr6|738,76
006371  aa   771521 3520 04   epp2      -3247,ic            000112 = 000000000000
006372  aa  6 01370 2521 00   spri2     pr6|760
006373  aa  6 01342 3521 00   epp2      pr6|738
006374  aa  6 01372 2521 00   spri2     pr6|762
006375  aa  6 00461 3521 00   epp2      pr6|305             pcw_error
006376  aa  6 01374 2521 00   spri2     pr6|764
006377  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006400  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
006401  aa  6 01376 2521 00   spri2     pr6|766
006402  aa   771517 3520 04   epp2      -3249,ic            000121 = 404000000021
006403  aa  6 01400 2521 00   spri2     pr6|768
006404  aa   771445 3520 04   epp2      -3291,ic            000051 = 524000000112
006405  aa  6 01402 2521 00   spri2     pr6|770
006406  aa   771514 3520 04   epp2      -3252,ic            000122 = 516000000001
006407  aa  6 01404 2521 00   spri2     pr6|772
006410  aa   771467 3520 04   epp2      -3273,ic            000077 = 526000000001
006411  aa  6 01406 2521 00   spri2     pr6|774
006412  aa  6 01366 6211 00   eax1      pr6|758
006413  aa   020000 4310 07   fld       8192,dl
006414  aa  6 00044 3701 20   epp4      pr6|36,*
006415  la  4 00016 3521 20   epp2      pr4|14,*            syserr
006416  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 1285
                         goto wait_for_response;

006417  aa   777664 7100 04   tra       -76,ic              006303
                                                            STATEMENT 1 ON LINE 1286
                    end;

                                                            STATEMENT 1 ON LINE 1287
               end;

                                                            STATEMENT 1 ON LINE 1289
          end;

006420  aa   000071 7100 04   tra       57,ic               006511
                                                            STATEMENT 1 ON LINE 1290
          else do;

                                                            STATEMENT 1 ON LINE 1291
send_new_connect:
               no_response = "0"b;

006421  aa  6 00140 4501 00   stz       pr6|96              no_response
                                                            STATEMENT 1 ON LINE 1294
               if mbx_no < 8                                /* one of ours */
               then do;

006422  aa  6 00460 2361 00   ldq       pr6|304             mbx_no
006423  aa   000010 1160 07   cmpq      8,dl
006424  aa   000024 6050 04   tpl       20,ic               006450
                                                            STATEMENT 1 ON LINE 1296
                    datanet_mbx.mbx_used_flags.used (mbx_no) = "1"b;

006425  aa  6 00244 3735 20   epp7      pr6|164,*           mbxp
006426  aa  403 106 060 400   csl       (),(pr,ql),fill(1),bool(move)
006427  aa   000000 00 0000   descb     0,0
006430  aa  7 00005 00 0001   descb     pr7|5,1             datanet_mbx.used
                                                            STATEMENT 1 ON LINE 1297
                    datanet_mbx.num_in_use = datanet_mbx.num_in_use + 1;

006431  aa  7 00004 0541 00   aos       pr7|4               datanet_mbx.num_in_use
                                                            STATEMENT 1 ON LINE 1298
                    fnp_info.max_mbx_in_use = max (fnp_info.max_mbx_in_use, datanet_mbx.num_in_use);

006432  aa  6 00240 3715 20   epp5      pr6|160,*           fnpp
006433  aa  5 00056 2361 00   ldq       pr5|46              fnp_info.max_mbx_in_use
006434  aa  7 00004 1161 00   cmpq      pr7|4               datanet_mbx.num_in_use
006435  aa   000002 6050 04   tpl       2,ic                006437
006436  aa  7 00004 2361 00   ldq       pr7|4               datanet_mbx.num_in_use
006437  aa  5 00056 7561 00   stq       pr5|46              fnp_info.max_mbx_in_use
                                                            STATEMENT 1 ON LINE 1299
                    fnp_info.cumulative_mbx_in_use = fnp_info.cumulative_mbx_in_use + datanet_mbx.num_in_use;

006440  aa  5 00055 2351 00   lda       pr5|45              fnp_info.cumulative_mbx_in_use
006441  aa   000044 7330 00   lrs       36
006442  aa  7 00004 0331 00   adl       pr7|4               datanet_mbx.num_in_use
006443  aa  5 00055 7561 00   stq       pr5|45              fnp_info.cumulative_mbx_in_use
                                                            STATEMENT 1 ON LINE 1300
                    fnp_info.mbx_in_use_updated = fnp_info.mbx_in_use_updated + 1;

006444  aa  5 00057 2351 00   lda       pr5|47              fnp_info.mbx_in_use_updated
006445  aa   000044 7330 00   lrs       36
006446  aa   000001 0330 07   adl       1,dl
006447  aa  5 00057 7561 00   stq       pr5|47              fnp_info.mbx_in_use_updated
                                                            STATEMENT 1 ON LINE 1301
               end;

                                                            STATEMENT 1 ON LINE 1302
               string (datanet_mbx.dia_pcw) = initial_pcw;

006450  aa   000071 2350 07   lda       57,dl
006451  aa  6 00244 7551 20   sta       pr6|164,*
                                                            STATEMENT 1 ON LINE 1303
               datanet_mbx.dia_pcw.mbx_no = bit (fixed (mbx_no, 6), 6);

006452  aa  6 00460 2351 00   lda       pr6|304             mbx_no
006453  aa   000002 6050 04   tpl       2,ic                006455
006454  aa   000000 5310 00   neg       0
006455  aa   000036 7350 00   als       30
006456  aa   000030 7710 00   arl       24
006457  aa  6 00244 3735 20   epp7      pr6|164,*           datanet_mbx.mbx_no
006460  aa  7 00000 7511 02   stca      pr7|0,02            datanet_mbx.mbx_no
                                                            STATEMENT 1 ON LINE 1306
               string (datanet_mbx.dia_pcw) = dn355_util$compute_parity (string (datanet_mbx.dia_pcw));

006461  aa  6 00244 2351 20   lda       pr6|164,*
006462  aa  6 01365 7551 00   sta       pr6|757
006463  aa  6 01365 3521 00   epp2      pr6|757
006464  aa  6 01336 2521 00   spri2     pr6|734
006465  aa  6 00244 3521 20   epp2      pr6|164,*
006466  aa  6 01340 2521 00   spri2     pr6|736
006467  aa  6 01334 6211 00   eax1      pr6|732
006470  aa   010000 4310 07   fld       4096,dl
006471  aa  6 00044 3701 20   epp4      pr6|36,*
006472  la  4 00022 3521 20   epp2      pr4|18,*            dn355_util$compute_parity
006473  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1309
               ima.chx = fnp_info.io_manager_chx;

006474  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006475  aa  7 00012 2361 00   ldq       pr7|10              fnp_info.io_manager_chx
006476  aa  6 00464 7561 00   stq       pr6|308             ima.chx
                                                            STATEMENT 1 ON LINE 1310
               ima.ptp = fnp_info.ptp;

006477  aa  7 00071 7651 00   lprp5     pr7|57              fnp_info.ptp
006500  aa  6 00470 6515 00   spri5     pr6|312             ima.ptp
                                                            STATEMENT 1 ON LINE 1311
               call io_manager$connect_direct (ima);

006501  aa  6 00464 3521 00   epp2      pr6|308             ima
006502  aa  6 01336 2521 00   spri2     pr6|734
006503  aa  6 01334 6211 00   eax1      pr6|732
006504  aa   004000 4310 07   fld       2048,dl
006505  aa  6 00044 3701 20   epp4      pr6|36,*
006506  la  4 00054 3521 20   epp2      pr4|44,*            io_manager$connect_direct
006507  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1313
               return;

006510  aa  6 00452 6101 00   rtcd      pr6|298
                                                            STATEMENT 1 ON LINE 1314
          end;

                                                            STATEMENT 1 ON LINE 1315
     end send_mbx;

006511  aa  6 00452 6101 00   rtcd      pr6|298
  END PROCEDURE return_mbx
BEGIN PROCEDURE hangup_fnp
ENTRY TO hangup_fnp                                         STATEMENT 1 ON LINE 1330
hangup_fnp:
     proc (fnp_no);

006512  aa  6 00476 6501 00   spri4     pr6|318
006513  aa  6 00500 2521 00   spri2     pr6|320
                                                            STATEMENT 1 ON LINE 1335
          fnpp = addr (datanet_info.per_datanet (fnp_no));

006514  aa  2 00002 2361 20   ldq       pr2|2,*             fnp_no
006515  aa   000072 4020 07   mpy       58,dl
006516  aa  6 00236 3735 20   epp7      pr6|158,*           infop
006517  aa  7 77730 3735 06   epp7      pr7|-40,ql          datanet_info.per_datanet
006520  aa  6 00240 6535 00   spri7     pr6|160             fnpp
                                                            STATEMENT 1 ON LINE 1336
          n_pcbs = fnp_info.no_of_channels;

006521  aa  7 00006 2361 00   ldq       pr7|6               fnp_info.no_of_channels
006522  aa  6 00266 7561 00   stq       pr6|182             n_pcbs
                                                            STATEMENT 1 ON LINE 1337
          do j = 1 to n_pcbs;

006523  aa  6 00504 7561 00   stq       pr6|324
006524  aa   000001 2360 07   ldq       1,dl
006525  aa  6 00132 7561 00   stq       pr6|90              j
006526  aa  6 00132 2361 00   ldq       pr6|90              j
006527  aa  6 00504 1161 00   cmpq      pr6|324
006530  aa   000034 6054 04   tpnz      28,ic               006564
                                                            STATEMENT 1 ON LINE 1338
               pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));

006531  aa   000003 7360 00   qls       3
006532  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006533  aa  7 00002 3715 20   epp5      pr7|2,*             fnp_info.pcb_array_ptr
006534  aa  5 77770 3735 06   epp7      pr5|-8,ql           pcb_array
006535  aa  6 00270 6535 00   spri7     pr6|184             pcbp
                                                            STATEMENT 1 ON LINE 1339
               if pcb.dialed
               then do;

006536  aa  7 00004 2351 00   lda       pr7|4               pcb.dialed
006537  aa   200000 3150 03   cana      65536,du
006540  aa   000022 6000 04   tze       18,ic               006562
                                                            STATEMENT 1 ON LINE 1341
                    call throw_away_output;

006541  aa   000067 6700 04   tsp4      55,ic               006630
                                                            STATEMENT 1 ON LINE 1342
                    call channel_manager$interrupt ((pcb.devx), CRASH, ""b);

006542  aa  6 00270 2351 20   lda       pr6|184,*           pcb.devx
006543  aa   000066 7330 00   lrs       54
006544  aa  6 01410 7561 00   stq       pr6|776
006545  aa   771373 2370 04   ldaq      -3333,ic            000140 = 000000000000 000000000000
006546  aa  6 01412 7571 00   staq      pr6|778
006547  aa  6 01410 3521 00   epp2      pr6|776
006550  aa  6 01416 2521 00   spri2     pr6|782
006551  aa   771355 3520 04   epp2      -3347,ic            000126 = 000000000003
006552  aa  6 01420 2521 00   spri2     pr6|784
006553  aa  6 01412 3521 00   epp2      pr6|778
006554  aa  6 01422 2521 00   spri2     pr6|786
006555  aa  6 01414 6211 00   eax1      pr6|780
006556  aa   014000 4310 07   fld       6144,dl
006557  aa  6 00044 3701 20   epp4      pr6|36,*
006560  la  4 00042 3521 20   epp2      pr4|34,*            channel_manager$interrupt
006561  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1343
               end;

                                                            STATEMENT 1 ON LINE 1344
          end;

006562  aa  6 00132 0541 00   aos       pr6|90              j
006563  aa   777743 7100 04   tra       -29,ic              006526
                                                            STATEMENT 1 ON LINE 1346
          if fnp_info.count > 0                             /* get rid of any outstanding delay queue entries */
          then do;

006564  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006565  aa  7 00024 2361 00   ldq       pr7|20              fnp_info.count
006566  aa   000041 6044 04   tmoz      33,ic               006627
                                                            STATEMENT 1 ON LINE 1348
               q_count = fnp_info.count;

006567  aa  6 00126 7561 00   stq       pr6|86              q_count
                                                            STATEMENT 1 ON LINE 1349
               q_first = fnp_info.cur_ptr;

006570  aa  7 00025 2361 00   ldq       pr7|21              fnp_info.cur_ptr
006571  aa  6 00125 7561 00   stq       pr6|85              q_first
                                                            STATEMENT 1 ON LINE 1350
               do q_count = q_count to 0 by -1 while (q_first ^= 0);

006572  aa  6 00126 2361 00   ldq       pr6|86              q_count
006573  aa  6 00126 7561 00   stq       pr6|86              q_count
006574  aa  6 00126 2361 00   ldq       pr6|86              q_count
006575  aa   000026 6040 04   tmi       22,ic               006623
006576  aa  6 00125 2361 00   ldq       pr6|85              q_first
006577  aa   000024 6000 04   tze       20,ic               006623
                                                            STATEMENT 1 ON LINE 1351
                    qptr = ptr (ttybp, q_first);

006600  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
006601  aa   000000 3120 06   eawp2     0,ql
006602  aa  6 00116 2521 00   spri2     pr6|78              qptr
                                                            STATEMENT 1 ON LINE 1352
                    q_first = qptr -> q_entry.next;

006603  aa  2 00011 2361 00   ldq       pr2|9               q_entry.next
006604  aa  6 00125 7561 00   stq       pr6|85              q_first
                                                            STATEMENT 1 ON LINE 1353
                    call tty_space_man$free_space (size (q_entry), qptr);

006605  aa   000012 2360 07   ldq       10,dl
006606  aa  6 01410 7561 00   stq       pr6|776
006607  aa  6 01410 3521 00   epp2      pr6|776
006610  aa  6 01416 2521 00   spri2     pr6|782
006611  aa  6 00116 3521 00   epp2      pr6|78              qptr
006612  aa  6 01420 2521 00   spri2     pr6|784
006613  aa  6 01414 6211 00   eax1      pr6|780
006614  aa   010000 4310 07   fld       4096,dl
006615  aa  6 00044 3701 20   epp4      pr6|36,*
006616  la  4 00062 3521 20   epp2      pr4|50,*            tty_space_man$free_space
006617  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1354
               end;

006620  aa   000001 3360 07   lcq       1,dl
006621  aa  6 00126 0561 00   asq       pr6|86              q_count
006622  aa   777752 7100 04   tra       -22,ic              006574
                                                            STATEMENT 1 ON LINE 1356
               fnp_info.count, fnp_info.cur_ptr, fnp_info.last_ptr = 0;

006623  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006624  aa  7 00024 4501 00   stz       pr7|20              fnp_info.count
006625  aa  7 00025 4501 00   stz       pr7|21              fnp_info.cur_ptr
006626  aa  7 00026 4501 00   stz       pr7|22              fnp_info.last_ptr
                                                            STATEMENT 1 ON LINE 1357
          end;

                                                            STATEMENT 1 ON LINE 1359
     end;

006627  aa  6 00476 6101 00   rtcd      pr6|318
  END PROCEDURE hangup_fnp
BEGIN PROCEDURE throw_away_output
ENTRY TO throw_away_output                                  STATEMENT 1 ON LINE 1363
throw_away_output:
     proc;

006630  aa  6 00506 6501 00   spri4     pr6|326
                                                            STATEMENT 1 ON LINE 1368
          if pcb.write_first ^= 0
          then do;

006631  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
006632  aa  7 00001 2351 00   lda       pr7|1               pcb.write_first
006633  aa   000066 7330 00   lrs       54
006634  aa   000033 6000 04   tze       27,ic               006667
                                                            STATEMENT 1 ON LINE 1370
               call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));

006635  aa  7 00000 2351 00   lda       pr7|0               pcb.devx
006636  aa  6 01425 7561 00   stq       pr6|789             pcb.write_first
006637  aa   000066 7330 00   lrs       54
006640  aa  6 01424 7561 00   stq       pr6|788
006641  aa  6 01425 2361 00   ldq       pr6|789             pcb.write_first
006642  aa  6 00272 3521 20   epp2      pr6|186,*           ttybp
006643  aa   000000 3120 06   eawp2     0,ql
006644  aa  6 01426 2521 00   spri2     pr6|790
006645  aa  6 01424 3521 00   epp2      pr6|788
006646  aa  6 01432 2521 00   spri2     pr6|794
006647  aa   771242 3520 04   epp2      -3422,ic            000111 = 400000000000
006650  aa  6 01434 2521 00   spri2     pr6|796
006651  aa  6 01426 3521 00   epp2      pr6|790
006652  aa  6 01436 2521 00   spri2     pr6|798
006653  aa  6 01430 6211 00   eax1      pr6|792
006654  aa   014000 4310 07   fld       6144,dl
006655  aa  6 00044 3701 20   epp4      pr6|36,*
006656  la  4 00066 3521 20   epp2      pr4|54,*            tty_space_man$free_chain
006657  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1371
               pcb.write_first, pcb.write_last, pcb.write_cnt = 0;

006660  aa   000000 2350 07   lda       0,dl
006661  aa  6 00270 3735 20   epp7      pr6|184,*           pcbp
006662  aa  7 00001 5511 60   stba      pr7|1,60            pcb.write_first
006663  aa   000022 7710 00   arl       18
006664  aa  7 00001 5511 14   stba      pr7|1,14            pcb.write_last
006665  aa  0 00264 3771 00   anaq      pr0|180             = 000000777777 777777777777
006666  aa  7 00003 5511 14   stba      pr7|3,14            pcb.write_cnt
                                                            STATEMENT 1 ON LINE 1373
          end;

                                                            STATEMENT 1 ON LINE 1375
          pcb.end_frame = "0"b;

006667  aa   000504 2350 04   lda       324,ic              007373 = 767777777777
006670  aa  7 00004 3551 00   ansa      pr7|4               pcb.end_frame
                                                            STATEMENT 1 ON LINE 1377
          return;

006671  aa  6 00506 6101 00   rtcd      pr6|326
                                                            STATEMENT 1 ON LINE 1378
     end /* throw_away_output */;

  END PROCEDURE throw_away_output
BEGIN PROCEDURE report_fnp_no_response
ENTRY TO report_fnp_no_response                             STATEMENT 1 ON LINE 1382
report_fnp_no_response:
     proc;

006672  aa  6 00514 6501 00   spri4     pr6|332
                                                            STATEMENT 1 ON LINE 1385
          call syserr (beeper, "dn355: FNP ^a did not respond to mailbox interrupt", fnp_info.fnp_tag);

006673  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
006674  aa   771431 00 0064   desc9a    -3303,52            000324 = 144156063065
006675  aa  6 01440 00 0064   desc9a    pr6|800,52
006676  aa   771230 3520 04   epp2      -3432,ic            000126 = 000000000003
006677  aa  6 01460 2521 00   spri2     pr6|816
006700  aa  6 01440 3521 00   epp2      pr6|800
006701  aa  6 01462 2521 00   spri2     pr6|818
006702  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006703  aa  7 00007 3521 00   epp2      pr7|7               fnp_info.fnp_tag
006704  aa  6 01464 2521 00   spri2     pr6|820
006705  aa   771214 3520 04   epp2      -3444,ic            000121 = 404000000021
006706  aa  6 01466 2521 00   spri2     pr6|822
006707  aa   771143 3520 04   epp2      -3485,ic            000052 = 524000000062
006710  aa  6 01470 2521 00   spri2     pr6|824
006711  aa   771166 3520 04   epp2      -3466,ic            000077 = 526000000001
006712  aa  6 01472 2521 00   spri2     pr6|826
006713  aa  6 01456 6211 00   eax1      pr6|814
006714  aa   014000 4310 07   fld       6144,dl
006715  aa  6 00044 3701 20   epp4      pr6|36,*
006716  la  4 00016 3521 20   epp2      pr4|14,*            syserr
006717  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
                                                            STATEMENT 1 ON LINE 1386
          call report_fnp_crash;

006720  aa   000002 6700 04   tsp4      2,ic                006722
                                                            STATEMENT 1 ON LINE 1387
          return;

006721  aa  6 00514 6101 00   rtcd      pr6|332
                                                            STATEMENT 1 ON LINE 1389
     end /* report_fnp_no_response */;

  END PROCEDURE report_fnp_no_response
BEGIN PROCEDURE report_fnp_crash
ENTRY TO report_fnp_crash                                   STATEMENT 1 ON LINE 1394
report_fnp_crash:
     proc;

006722  aa  6 00522 6501 00   spri4     pr6|338
                                                            STATEMENT 1 ON LINE 1397
          fnp_info.running = "0"b;

006723  aa   000374 2350 04   lda       252,ic              007317 = 677777777777
006724  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006725  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.running
                                                            STATEMENT 1 ON LINE 1398
          if fnp_info.dump_patch_in_progress                /* somebody's waiting for this */
          then call pxss$notify (FNP_DUMP_PATCH_EVENT);

006726  aa  7 00030 2351 00   lda       pr7|24              fnp_info.dump_patch_in_progress
006727  aa   020000 3150 03   cana      8192,du
006730  aa   000010 6000 04   tze       8,ic                006740
006731  aa   771164 3520 04   epp2      -3468,ic            000115 = 000000000072
006732  aa  6 01476 2521 00   spri2     pr6|830
006733  aa  6 01474 6211 00   eax1      pr6|828
006734  aa   004000 4310 07   fld       2048,dl
006735  aa  6 00044 3701 20   epp4      pr6|36,*
006736  la  4 00034 3521 20   epp2      pr4|28,*            pxss$notify
006737  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1401
          if ^fnp_info.bootloading                          /* if we weren't still loading it */
          then                                              /* now report hangups for all lines that were dialed to it */
               call hangup_fnp (dno);

006740  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006741  aa  7 00030 2351 00   lda       pr7|24              fnp_info.bootloading
006742  aa   200000 3150 03   cana      65536,du
006743  aa   000004 6010 04   tnz       4,ic                006747
006744  aa   000102 3520 04   epp2      66,ic               007046 = 000002000000
006745  aa   777545 6700 04   tsp4      -155,ic             006512
006746  aa   000003 7100 04   tra       3,ic                006751
                                                            STATEMENT 1 ON LINE 1404
          else fnp_info.bootloading = "0"b;

006747  aa   000403 2350 04   lda       259,ic              007352 = 577777777777
006750  aa  7 00030 3551 00   ansa      pr7|24              fnp_info.bootloading
                                                            STATEMENT 1 ON LINE 1406
          auto_fnp_msg.state = FNP_DOWN;

006751  aa   000002 2350 07   lda       2,dl
006752  aa  6 00170 5511 14   stba      pr6|120,14          auto_fnp_msg.state
                                                            STATEMENT 1 ON LINE 1407
          auto_fnp_msg.fnp_no = dno;

006753  aa  6 00122 2361 00   ldq       pr6|82              dno
006754  aa   000066 7370 00   lls       54
006755  aa  6 00170 5511 60   stba      pr6|120,60          auto_fnp_msg.fnp_no
                                                            STATEMENT 1 ON LINE 1408
          auto_fnp_msg.flags = "0"b;

006756  aa   000364 2350 04   lda       244,ic              007342 = 377777777777
006757  aa  6 00171 3551 00   ansa      pr6|121             auto_fnp_msg.deconfigured
006760  aa   400000 2350 03   lda       131072,du
006761  aa  6 00171 3551 00   ansa      pr6|121             auto_fnp_msg.pad
                                                            STATEMENT 1 ON LINE 1409
          unspec (fnp_event_message) = unspec (auto_fnp_msg);

006762  aa  6 00170 2371 00   ldaq      pr6|120
006763  aa  6 00172 7571 00   staq      pr6|122
                                                            STATEMENT 1 ON LINE 1410
          call pxss$ring_0_wakeup (fnp_info.boot_process_id, fnp_info.boot_ev_chan, fnp_event_message, 0);

006764  aa  6 01500 4501 00   stz       pr6|832
006765  aa  6 00240 3735 20   epp7      pr6|160,*           fnpp
006766  aa  7 00040 3521 00   epp2      pr7|32              fnp_info.boot_process_id
006767  aa  6 01504 2521 00   spri2     pr6|836
006770  aa  7 00036 3521 00   epp2      pr7|30              fnp_info.boot_ev_chan
006771  aa  6 01506 2521 00   spri2     pr6|838
006772  aa  6 00172 3521 00   epp2      pr6|122             fnp_event_message
006773  aa  6 01510 2521 00   spri2     pr6|840
006774  aa  6 01500 3521 00   epp2      pr6|832
006775  aa  6 01512 2521 00   spri2     pr6|842
006776  aa  6 01502 6211 00   eax1      pr6|834
006777  aa   020000 4310 07   fld       8192,dl
007000  aa  6 00044 3701 20   epp4      pr6|36,*
007001  la  4 00030 3521 20   epp2      pr4|24,*            pxss$ring_0_wakeup
007002  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1412
          return;

007003  aa  6 00522 6101 00   rtcd      pr6|338
                                                            STATEMENT 1 ON LINE 1414
     end report_fnp_crash;

  END PROCEDURE report_fnp_crash
BEGIN PROCEDURE check_lock
ENTRY TO check_lock                                         STATEMENT 1 ON LINE 1415
check_lock:
     proc;

007004  aa  6 00100 6501 00   spri4     pr6|64
                                                            STATEMENT 1 ON LINE 1420
          if queue_locked
          then call syserr (crash_system, "dn355: attempted crawlout with FNP queue locked");
007005  aa  6 00040 3735 20   epp7      pr6|32,*
007006  aa  7 00161 2351 00   lda       pr7|113             queue_locked
007007  aa   000022 6000 04   tze       18,ic               007031
007010  aa  000 100 100 404   mlr       (ic),(pr),fill(000)
007011  aa   771264 00 0060   desc9a    -3404,48            000274 = 144156063065
007012  aa  6 00106 00 0060   desc9a    pr6|70,48
007013  aa   771116 3520 04   epp2      -3506,ic            000131 = 000000000001
007014  aa  6 00124 2521 00   spri2     pr6|84
007015  aa  6 00106 3521 00   epp2      pr6|70
007016  aa  6 00126 2521 00   spri2     pr6|86
007017  aa   771102 3520 04   epp2      -3518,ic            000121 = 404000000021
007020  aa  6 00130 2521 00   spri2     pr6|88
007021  aa   771033 3520 04   epp2      -3557,ic            000054 = 524000000057
007022  aa  6 00132 2521 00   spri2     pr6|90
007023  aa  6 00122 6211 00   eax1      pr6|82
007024  aa   010000 4310 07   fld       4096,dl
007025  aa  6 00044 3701 20   epp4      pr6|36,*
007026  la  4 00016 3521 20   epp2      pr4|14,*            syserr
007027  aa  0 00622 7001 00   tsx0      pr0|402             call_ext_out_desc
007030  aa   000014 7100 04   tra       12,ic               007044
                                                            STATEMENT 1 ON LINE 1423
          else if masked
          then call pmut$unwire_unmask (wire_arg, wire_ptr);

007031  aa  7 00160 2351 00   lda       pr7|112             masked
007032  aa   000012 6000 04   tze       10,ic               007044
007033  aa  7 00154 3521 00   epp2      pr7|108             wire_arg
007034  aa  6 00124 2521 00   spri2     pr6|84
007035  aa  7 00156 3521 00   epp2      pr7|110             wire_ptr
007036  aa  6 00126 2521 00   spri2     pr6|86
007037  aa  6 00122 6211 00   eax1      pr6|82
007040  aa   010000 4310 07   fld       4096,dl
007041  aa  6 00044 3701 20   epp4      pr6|36,*
007042  la  4 00040 3521 20   epp2      pr4|32,*            pmut$unwire_unmask
007043  aa  0 00623 7001 00   tsx0      pr0|403             call_ext_out
                                                            STATEMENT 1 ON LINE 1426
          return;

007044  aa  6 00100 6101 00   rtcd      pr6|64
                                                            STATEMENT 1 ON LINE 1427
     end check_lock;

  END PROCEDURE check_lock
  END PROCEDURE dn355
