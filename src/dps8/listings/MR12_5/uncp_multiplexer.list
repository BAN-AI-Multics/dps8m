	COMPILATION LISTING OF SEGMENT uncp_multiplexer
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1122.21_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-06-10,Berno), approve(88-07-13,MCR7928),
       16*     audit(88-06-10,Parisek), install(88-07-19,MR12.2-1061):
       17*     Add support of the uncp multiplexer interface for DSA login protocol.
       18*  2) change(89-02-24,Parisek), approved(89-02-24,MECR0008),
       19*     audit(89-02-28,Farley), install(89-02-28,MR12.3-1016):	
       20*     Reinitialize the uncp_buf data when performing a load on the UNCP FNP.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 /* format: style4,delnl,insnl,^ifthendo */
       24 uncp_multiplexer:
       25      proc;
       26 
       27 /* This is the called multiplexer module for FNP channels. It calls uncp
       28*   *  to pass mailboxes on to the FNP. Important data structures are:
       29*   *	fnp_info (in dn355_data) : info about the FNP as a whole
       30*   *	pcb (physical channel block) : allocated in tty_buf. Contains per-channel info
       31*   *
       32**/
       33 
       34 /* Written 08/15/78 by Robert Coren */
       35 /* Modified 04/11/79 by Robert Coren to handle all modes at once */
       36 /* Modified 06/29/79 by Bernard Greenberg for FNP echo negotiation */
       37 /* Modified 79 Aug 21 by Art Beattie to support 64K DN6670s. */
       38 /* Modified various times in 1980 by Robert Coren to add metering */
       39 /* Modified May 1981 by Robert Coren to keep get_meters order from using user-supplied
       40*   pointer while FNP channel is locked */
       41 /* Modified late summer 1981 by Robert Coren to handle tandd_attach order and COLTS channel */
       42 /* Modified fall 1981 by Robert Coren to assign smaller buffer sizes */
       43 /* Modified November 1981 by Robert Coren to fix bug whereby terminate_multiplexer
       44*   didn't initialize ttybp */
       45 /* Modified June 1982 by Robert Coren to correct precision of FNP addresses. */
       46  
       47 /* THE FOLLOWING HISTORY COMMENTS REFER TO THE CONVERSION TO THE UNCP
       48*   MULTIPLEXER SOFTWARE FOR DSA CONNECTIONS.  fnp_multiplexer.pl1 WAS THE
       49*   TEMPLATE FOR THIS PROGRAM.  */
       50 
       51 /* Reported in February 1982 modifications for the connection of the DN7100
       52*   - Added the orders: load, dump, dial
       53*   - Added the hpriv_control for management of the fnp_info.active_bit
       54*     for dials.
       55*   - Eliminate all the ineffective orders for the DN7100.
       56*
       57*   - Correction of a Multics crash. In the process mode for "breakall"
       58*     it must initialize alter_type. (31 March 1983).
       59*
       60*   Report in this module the improvments for MR10.1 in June 1983
       61*   Installed for MR11 in August 1985.
       62*   Installed for MR12.0 in January 1987.
       63*
       64*   Date of the last modification: 07/01/87.
       65**/
       66 
       67 
       68 /* PARAMETERS */
       69 
       70 dcl  a_devx fixed bin;				/* devx of FNP channel */
       71 dcl  a_init_info_ptr ptr;
       72 dcl  a_fnpp ptr;
       73 dcl  a_subchan fixed bin;
       74 dcl  a_chainp ptr;
       75 dcl  a_mi_flag bit (1) aligned;
       76 dcl  a_code fixed bin (35);
       77 dcl  a_output_ptr ptr;
       78 dcl  a_order char (*);
       79 dcl  a_data_ptr ptr;
       80 dcl  a_mode_list_ptr ptr;
       81 dcl  a_modes char (*);
       82 
       83 
       84 /* AUTOMATIC */
       85 
       86 dcl  code fixed bin (35);				/* standard system error code */
       87 dcl  devx fixed bin;				/* of FNP channel */
       88 dcl  my_chan_name char (1);
       89 dcl  dno fixed bin;					/* FNP number */
       90 dcl  pcb_space fixed bin;
       91 dcl  space_needed fixed bin;
       92 dcl  output_ptr ptr;				/* pointer to caller's output data */
       93 dcl  chanx fixed bin;				/* index of PCB */
       94 dcl  output_length fixed bin;				/* number of output characters */
       95 /*dcl  sourcep ptr;*/
       96 dcl  (i/*, j*/) fixed bin;
       97 dcl  lastp ptr;					/* pointer to last buffer in already-exisitng chain */
       98 
       99 dcl  order char (32);
      100 dcl  data_ptr ptr;					/* pointer to order info structure */
      101 dcl  set_write_status bit (1);
      102 dcl  locked bit (1);
      103 dcl  queue_locked bit (1);
      104 dcl  mylock bit (1);
      105 dcl  opcode fixed bin (8);				/* mailbox opcode */
      106 dcl  alter_type fixed bin (8);			/* alter parameters subop */
      107 dcl  check bit (1);
      108 dcl  mbx_data_len fixed bin;				/* in bits */
      109 dcl  mbx_data bit (4 * 36) based (addr (mbx_data_long));
      110 dcl  mbx_data_long bit (8 * 36);
      111 dcl  alter_data bit (4 * 36) varying;
      112 dcl  dumpin bit (1);
      113 dcl  dumpout bit (1);
      114 dcl  get_meters bit (1);
      115 dcl  temp_saved_meters_ptr ptr;
      116 /*dcl  meter_ptr ptr;*/
      117 /*dcl  lcmp ptr;*/
      118 /*dcl  fnp_meters_ptr ptr;*/
      119 /*dcl  ret_meters_ptr ptr;*/
      120 dcl  local_line_type fixed bin;
      121 /*dcl  phone_no_len fixed bin;*/				/* in bits */
      122 /*dcl  phone_digits (32) bit (6);*/
      123 /*dcl  next_digit fixed bin (6) unsigned;*/			/* value of next dialout digit */
      124 /*dcl  digit_pos fixed bin;*/				/* how far along we are in phone number */
      125 dcl  opend bit (1);					/* whether or not output is pending */
      126 
      127 dcl  modex fixed bin;
      128 dcl  mode_name char (8);
      129 dcl  mode_on bit (1);				/* mode to be turned on or off */
      130 dcl  mode_set (36) bit (1);
      131 dcl  hndlquit_set bit (1);
      132 dcl  base_len fixed bin;
      133 dcl  block_len fixed bin;
      134 /*dcl  chars_per_buf fixed bin;*/
      135 dcl  chars_per_sec fixed bin;
      136 
      137 /*dcl  wire_arg fixed bin (71);
      138*dcl  wire_ptr ptr;*/
      139 dcl  hsla_flag bit (1);
      140 dcl  old_flag bit (1);
      141 dcl  pcb_space_ptr ptr;
      142 dcl  prev_la_no fixed bin;
      143 dcl  la_no fixed bin;
      144 dcl  subchan fixed bin;
      145 dcl  his_fnp_no fixed bin;				/* FNP number in supplied channel name */
      146 dcl  pcbx fixed bin;
      147 /*dcl  found bit (1);*/
      148 /*dcl  past bit (1);*/
      149 /*dcl  n_fnp_words fixed bin;*/
      150 /*dcl  ignore bit (1);*/
      151 dcl  name char (32);
      152 /*dcl  temp_addr fixed bin;*/
      153 /*dcl  fnp_dump_ptr ptr;*/
      154 /*dcl  dump_patch_space fixed bin;*/			/* amount of space required by an fnp_(dump patch) order */
      155 /*dcl  dump_patch_time fixed bin (71);*/			/* clock time when a dump or patch order was initiated */
      156 
      157 
      158 /*dcl  1 dump_fnp_data aligned,*/				/* command data for dump_fnp & patch_fnp */
      159 /*       2 abs_addr fixed bin (24),*/			/* absolute address of ring-zero buffer */
      160 /*       2 fnp_addr fixed bin (18) unsigned unaligned,*/	/* address in FNP */
      161 /*       2 fnp_len fixed bin (18) unsigned unaligned;*/	/* number of 18-bit words */
      162 
      163 /*dcl  1 fnp_break_data aligned,*/			/* command data for fnp_break order */
      164 /*       2 lineno fixed bin (17) unal,*/			/* line number, derived from tty name */
      165 /*       2 fnp_addr fixed bin (18) unsigned unal,
      166*       2 action fixed bin (17) unal,
      167*       2 flags bit (18) unal;*/
      168 
      169 /*dcl  1 echnego_break_table aligned,
      170*       2 words (0:15) unaligned,
      171*         3 bits bit (16) unaligned,
      172*         3 pad bit (2) unaligned;*/
      173 
      174 /* BASED */
      175 
      176 dcl  based_fb_word fixed bin based;
      177 dcl  based_bit2 bit (2) based;
      178 /*dcl  based_bit18 bit (18) based;*/
      179 dcl  based_bit72 bit (72) based;
      180 /*dcl  based_bit108 bit (108) based;*/
      181 /*dcl  fnp_data (n_fnp_words) bit (18) based;*/
      182 
      183 
      184 /*dcl  phone_chars char (32) varying based;*/		/* phone number passed with dial_out order */
      185 
      186 dcl  1 wr_stat aligned based,				/* for write_status */
      187        2 ev_chan fixed bin (71),
      188        2 output_pending bit (1);
      189 
      190 dcl  1 rd_stat aligned based,				/* for read_status */
      191        2 ev_chan fixed bin (71),
      192        2 input_available bit (1);
      193 
      194 /*dcl  1 dump_fnp_info based (data_ptr) aligned,*/		/* structure passed for dump_fnp and patch_fnp */
      195 /*       2 fnp_address fixed bin (24),*/
      196 /*       2 fnp_len fixed bin,*/				/* number of 18=bit words */
      197 /*       2 bufp ptr,*/					/* pointer to caller's buffer */
      198 /*       2 old_value_ptr ptr;*/				/* pointer to previous values (patch only) */
      199 
      200 /*dcl  1 fnp_break_info aligned based (data_ptr),*/		/* structure passed on fnp_break order */
      201 /*       2 chan_name char (6),*/				/* tty name, optional */
      202 /*       2 fnp_addr fixed bin,*/				/* addr in fnp to set break */
      203 /*       2 action fixed bin,*/				/* request type */
      204 /*       2 flags bit (36);*/				/* special action flags */
      205 
      206 /*dcl  1 echo_start_data aligned based (data_ptr),*/		/* Echo starting data */
      207 /*       2 ctr fixed bin (35),*/				/* Synchronization counter */
      208 /*       2 screenleft fixed bin (35);*/			/* Length left on screen */
      209 
      210 /* BUILTINS & CONDITIONS */
      211 
      212 dcl  (addr, addrel, bin, bit, /*clock,*/ divide, lbound, hbound, length, null,
      213      ptr, rel, rtrim, size, /*stac, stacq,*/ string, substr, unspec) builtin;
      214 
      215 dcl  area condition;
      216 
      217 
      218 /* ENTRIES */
      219 
      220 /*dcl  pxss$notify entry (fixed bin);*/
      221 dcl  uncp$send_wcd entry (ptr, ptr, fixed bin (8), fixed bin, bit (*));
      222 dcl  uncp$send_global_wcd entry (ptr, fixed bin (8), fixed bin, bit (*));
      223 dcl  uncp$hangup_fnp_lines entry (fixed bin);
      224 dcl  uncp$process_interrupt_queue entry (fixed bin);
      225 
      226 dcl  uncp$interrupt entry;
      227 dcl  uncp_util$fill_page_table entry (fixed bin, fixed bin (35));
      228 dcl  uncp_util$free_page_table entry (fixed bin);
      229 /*dcl  uncp_util$unwire entry (fixed bin, fixed bin (35));*/
      230 dcl  tty_lock$lock_lcte entry (ptr, fixed bin (35));
      231 dcl  tty_area_manager$allocate entry (fixed bin, ptr);
      232 dcl  tty_area_manager$free entry (fixed bin, ptr);
      233 dcl  lock$lock_fast entry (pointer);
      234 dcl  lock$unlock_fast entry (pointer);
      235 dcl  syserr entry options (variable);
      236 dcl  syserr$error_code entry options (variable);
      237 
      238 dcl  parse_tty_name_ entry (char (*), fixed bin, bit (1), fixed bin, fixed bin);
      239 dcl  parse_fnp_name_ entry (char (*), fixed bin);
      240 /*dcl  pxss$addevent entry (fixed bin);
      241*dcl  pxss$delevent entry (fixed bin);
      242*dcl  pxss$wait entry;*/
      243 dcl  uncp_util$abort entry (fixed bin, fixed bin (35));
      244 dcl  uncp_util$load entry (fixed bin, ptr, fixed bin (35));
      245 dcl  uncp_util$fdump entry (fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
      246 
      247 /* EXTERNAL STATIC */
      248 
      249 dcl  (
      250      error_table_$noalloc,
      251      error_table_$undefined_order_request,
      252      error_table_$bad_mode,
      253      error_table_$bad_channel,
      254 /*     error_table_$buffer_big,
      255*     error_table_$invalid_write,
      256*     error_table_$dev_offset_out_of_bounds,
      257*     error_table_$seglock,*/
      258      error_table_$fnp_down,
      259 /*     error_table_$timeout,*/
      260      error_table_$unimplemented_version,
      261 /*     error_table_$no_channel_meters,
      262*     error_table_$resource_not_free,*/
      263      error_table_$action_not_performed,
      264      error_table_$io_assigned,
      265      error_table_$io_not_assigned,
      266      error_table_$io_not_configured,
      267      error_table_$io_not_available,
      268      error_table_$invalid_state
      269      ) ext static fixed bin (35);
      270 
      271 dcl  pds$processid ext static bit (36) aligned;
      272 /*dcl  pds$process_group_id ext static char (32) aligned;*/
      273 /*dcl  tty_area$ external static fixed bin;*/
      274 
      275 /* INTERNAL STATIC */
      276 
      277 /* The following are declared here because syserr_constants.incl.pl1 cannot
      278*   be used, owing to a naming conflict with mcs_interrupt_info.incl.pl1.
      279**/
      280 
      281 dcl  ANNOUNCE fixed bin internal static options (constant) init (0);
      282 dcl  CRASH_SYSTEM fixed bin internal static options (constant) init (1);
      283 dcl  UNCP_CQ_SIZE fixed bin int static options (constant) init (2000);
      284 /*dcl  DUMP_PATCH_LIMIT fixed bin (35) int static options (constant) init (10000000);*/
      285 						/* i.e., 10 seconds */
      286 dcl  DCW_LIST_SIZE fixed bin int static options (constant) init (16);
      287 dcl  PCB_SIZE_INCR fixed bin int static options (constant) init (8);
      288 dcl  LA_7 fixed bin int static options (constant) init (7);
      289 dcl  TWO_WORD_LTH fixed bin int static options (constant) init (18);
      290 dcl  BASE_LTH fixed bin int static options (constant) init (56);
      291 dcl  CHAR_72 fixed bin int static options (constant) init (72);
      292 
      293 /* The following facts about the the lists of modes below are IMPORTANT.
      294*   *  The modes which have corresponding alter_parameters subtypes are the same as the modes
      295*   *  that are valid for asynchronous lines only, and no data is associated with the
      296*   *  alter_parameters other than on/off, with the following exceptions:
      297*   *	blk_xfer and iflow require additional data (buffer sizes)
      298*   *	hndlquit is valid for any line, but is expressed by alter_parameters
      299*   *
      300*   *  Therefore, hndlquit is handled explicitly, and blk_xfer and iflow must come after those modes having alter_paramters
      301*   *  subop types. Anyone modifying these lists should be aware of this circumstance.
      302**/
      303 
      304 dcl  good_modes (1) char (8) int static options (constant)	/* modes recognized for all lines */
      305 	init ("hndlquit");
      306 
      307 dcl  async_only_modes (15) char (8) int static options (constant)
      308 						/* modes recognized for async lines only */
      309 	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "replay", "polite", "breakall", "prefixnl",
      310 	"no_outp", "8bit", "oddp", "oflow", "iflow", "blk_xfer");
      311 
      312 dcl  IFLOW_INDEX fixed bin internal static options (constant) init (14);
      313 dcl  BLK_XFER_INDEX fixed bin internal static options (constant) init (15);
      314 
      315 dcl  full_dpx_modes (7) char (8) int static options (constant)
      316 						/* modes requiring full duplex line type */
      317 	init ("crecho", "tabecho", "lfecho", "echoplex", "fulldpx", "iflow", "oflow");
      318 
      319 dcl  mode_alter_types (13) fixed bin (8) int static options (constant)
      320 						/* alter_paramters subops corresponding to modes */
      321 	init (8,					/* crecho */
      322 	14,					/* tabecho */
      323 	9,					/* lfecho */
      324 	20,					/* echoplex */
      325 	3,					/* fulldpx */
      326 	23,					/* replay */
      327 	24,					/* polite */
      328 	27,					/* breakall */
      329 	28,					/* prefixnl */
      330 	33,					/* no_outp */
      331 	32,					/* 8bit */
      332 	31,					/* oddp */
      333 	30);					/* oflow */
      334 
      335 /* INCLUDE FILES */
      336 
      337 
  1     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  1     2 
  1     3 /* Date Last Modified and Reason
  1     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  1     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  1     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  1     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  1     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  1     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  1    10*   Modified November 1979 by C. Hornig for MCS tracing.
  1    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  1    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  1    13*   Modified March 1980 by Robert Coren to reorganize metering information
  1    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  1    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  1    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  1    17**/
  1    18 
  1    19 dcl  ttybp ptr,
  1    20      tty_buf$ ext static,				/* tty buffer segment */
  1    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  1    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  1    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  1    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  1    25 
  1    26 
  1    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  1    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  1    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  1    30 
  1    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  1    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  1    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  1    34 
  1    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  1    36     2 slock bit (36),				/* per system lock */
  1    37     2 absorig fixed bin (24),				/* abs address of this seg */
  1    38     2 borig bit (18),				/* index of start of buffer area */
  1    39     2 bleft fixed bin (18),				/* words left in pool */
  1    40     2 free bit (18),				/* pointer to start of free pool */
  1    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  1    42     2 padb1 bit (28) unaligned,
  1    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  1    44 
  1    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  1    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  1    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  1    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  1    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  1    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  1    51     2 minbuf fixed bin (18),				/* min output buffer size */
  1    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  1    53 
  1    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  1    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  1    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  1    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  1    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  1    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  1    60 
  1    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  1    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  1    63     2 bfx fixed bin,				/* used in calls to iobm */
  1    64     2 nquits fixed bin (35),				/* number of quits */
  1    65     2 space_needed_data,
  1    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  1    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  1    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  1    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  1    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  1    71 
  1    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  1    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  1    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  1    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  1    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  1    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  1    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  1    79 
  1    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  1    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  1    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  1    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  1    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  1    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  1    86 
  1    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  1    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  1    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  1    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  1    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  1    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  1    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  1    94 
  1    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  1    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  1    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  1    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  1    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  1   100     2 echo_neg_mux_nonecho fixed bin (35),
  1   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  1   102 
  1   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  1   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  1   105     2 trace unaligned,				/* tracing information */
  1   106       3 flags,
  1   107       4 enable bit,					/* global tracing control */
  1   108       4 default_mode bit,				/* whether to trace channels by default */
  1   109       4 read bit,					/* read */
  1   110       4 write bit,					/* write */
  1   111       4 data bit,					/* buffers on reads and writes */
  1   112       4 control bit,				/* control, priv_control, and hpriv_control */
  1   113       4 modes bit,					/* (get set check)_modes */
  1   114       4 interrupt bit,				/* interrupt, interrupt_later */
  1   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  1   116       4 start bit,					/* start, stop */
  1   117       4 shutdown bit,				/* shutdown */
  1   118       4 space_man bit,				/* tty_space_man$* */
  1   119       4 pad_flags bit (6),
  1   120       3 data_offset bit (18),				/* offset of tracing data */
  1   121 
  1   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  1   123 
  1   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  1   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  1   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  1   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  1   128 
  1   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  1   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  1   131 
  1   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  1   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  1   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  1   135 
  1   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  1   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  1   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  1   139 
  1   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  1   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  1   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  1   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  1   144 
  1   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  1   146 
  1   147     2 pad2 (13) fixed bin (35),
  1   148 
  1   149     2 free_space fixed bin;				/* start of free space region */
  1   150 
  1   151 
  2     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2     2 
  2     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  2     4 
  2     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     6 
  2     7 /* format: style3 */
  2     8 
  2     9 declare	lock_ptr		pointer;
  2    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  2    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    13 	  2 flags		aligned,
  2    14 	    3 notify_sw	bit (1) unaligned,
  2    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    16 
  2    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  1   152 
  1   153 
  1   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      338 
      339 
  3     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  3     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  3     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  3     9*     implementation.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /*
  3    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  3    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  3    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  3    17**/
  3    18 
  3    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  3    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  3    21 
  3    22 
  3    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  3    24     2 next bit (18),				/* foward pointer to next free block */
  3    25     2 size fixed bin;				/* number of words in this block */
  3    26 
  3    27 
  3    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  3    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  3    30     2 flags unaligned,
  3    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  3    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  3    33       3 break bit (1) unaligned,			/* buffer contains break character */
  3    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  3    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  3    36       3 pad bit (1) unaligned,
  3    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  3    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  3    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  3    40 
  3    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  3    42 
  3    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  3    44 
  3    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      340 
      341 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      342 
      343 
  5     1 /*  BEGIN dn355_data.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  5     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  5     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  5     9*     implementation.
  5    10*  2) change(89-03-20,Parisek), approve(89-06-06,MCR8110),
  5    11*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
  5    12*     Add support of protocol mpx.
  5    13*                                                   END HISTORY COMMENTS */
  5    14 
  5    15 
  5    16 /* Date Last Modified and Reason
  5    17*
  5    18*   Created 07/25/74 by R. B. Snyder for new ttydim.
  5    19*   Modified 06/23/77 by J. Stern to add channel_work_reqd and cwork_count
  5    20*   Modified 08/14/78 by Robert Coren to remove devx_tab and invent PCBs
  5    21*   Modified 79 May 14 by Art Beattie to add fnp_mem_size
  5    22*   Modified December 1979 by Robert Coren to add FNP queue lock
  5    23*   Modified January 1980 by Larry Johnson to increase max number of FNPs to 8
  5    24*   Modified 02/12/80 by Robert Coren to add dcw_list_array_ptr
  5    25*   Modified 03/06/80 by Robert Coren to add some metering info
  5    26*   Modified 12/10/80 by Robert Coren to add get_meters_waiting flag
  5    27*   Modified 83-12-16 BIM to use a chanid instead of iom/channel fb's.
  5    28*   Modified 1984-07-26 BIM for paged iom.
  5    29*   Modified in September 1985 for the DN7100 version interim.
  5    30**/
  5    31 
  5    32 /* LOCKING RULES: A fnp is locked by its LCTE unless its LCTE is uninitialized.
  5    33*   In that case, the configuration_lock must be held.
  5    34*   if tty_lock$lock_lcte returns io_no_permission, then the caller must
  5    35*   lock$lock_fast the configuration lock and retry the LCTE lock. If
  5    36*   the lcte is now initialized, too bad. Otherwise, the config lock protects.
  5    37*
  5    38*   Configuration locking is interesting to init_multiplexer and
  5    39*   all of fnp t&d and reconfiguration. The guts of the multiplexer
  5    40*   pay no attention to it. Thus, if the LCTE can be locked, it MUST be
  5    41*   locked before changing the io_manager_assigned flag. */
  5    42 
  5    43 /* format: style4,delnl,insnl,^ifthendo */
  5    44 
  5    45 dcl  max_no_355s fixed bin int static init (8) options (constant);
  5    46 						/* max no of 355s we can handle (arbitrary) */
  5    47 dcl  dn355_data$ external fixed bin;
  5    48 
  5    49 dcl  infop pointer;
  5    50 dcl  fnpp ptr;
  5    51 
  5    52 dcl  1 datanet_info aligned based (infop),
  5    53        2 configuration_lock aligned,
  5    54          3 pid bit (36) aligned,
  5    55          3 event bit (36) aligned,
  5    56          3 flags aligned,
  5    57 	 4 notify_sw bit (1) unaligned,
  5    58 	 4 pad bit (35) aligned,
  5    59        2 no_of_355s fixed bin,			/* no. of FNP's */
  5    60        2 trace bit (1) aligned,			/* watch events on console */
  5    61        2 debug_stop bit (1) aligned,			/* crash on errors */
  5    62        2 uncp_bufp ptr,                                     /* pointer to the circular buffer */
  5    63        2 protocol_datap ptr,				/* pointer to protocol_mpx data */
  5    64        2 pad1 (6) bit (36) aligned,
  5    65        2 per_datanet (max_no_355s) aligned like fnp_info;	/* data per datanet */
  5    66 
  5    67 dcl  1 fnp_info aligned based (fnpp),			/* structure for each FNP */
  5    68        2 mbx_pt pointer,				/* pointer to mailbox NULL if not in config */
  5    69        2 pcb_array_ptr pointer,			/* pointer to array of physical channel blocks */
  5    70        2 dcw_list_array_ptr pointer,			/* pointer to array of space reserved for output DCW lists */
  5    71        2 no_of_channels fixed bin,			/* number of channels on this FNP */
  5    72        2 fnp_id,
  5    73          3 fnp_tag char (1) unaligned,			/* letter identifying FNP */
  5    74          3 fnp_number fixed bin (9) unsigned unaligned,	/* sequence number of FNP */
  5    75          3 padc bit (18) unaligned,
  5    76        2 io_chanid char (8) aligned,
  5    77        2 io_manager_chx fixed bin (35),			/* devx for DIA on iom */
  5    78        2 lsla_idx (0:5) fixed bin aligned,		/* index into PCB array for lsla lines */
  5    79        2 hsla_idx (0:2) fixed bin aligned,		/* index into PCB array for hsla lines */
  5    80        2 count fixed bin,				/* number of items in delay queue */
  5    81        2 cur_ptr fixed bin,				/* offset in tty_buf of next delay queue element */
  5    82        2 last_ptr fixed bin,				/* offset in tty_buf of last delay queue element */
  5    83        2 bleft_355 fixed bin,				/* number of free buffers in this 355 */
  5    84        2 flags,
  5    85          3 work_reqd bit (1) unaligned,			/* mailbox messages queued up */
  5    86          3 bootloading bit (1) unaligned,		/* currently being bootloaded */
  5    87          3 running bit (1) unaligned,			/* this FNP is running */
  5    88          3 wired bit (1) unaligned,			/* bootload buffer is wired */
  5    89          3 dump_patch_in_progress bit (1) unaligned,	/* a dump or patch order is in progress */
  5    90          3 level_3_pending bit (1) unaligned,		/* level 3 interrupt pending */
  5    91          3 level_7_pending bit (1) unaligned,		/* level 7 interrupt pending */
  5    92          3 dump_patch_disabled bit (1) unaligned,		/* dump & patch orders disabled because of timeout */
  5    93          3 t_and_d_in_progress bit (1) unaligned,		/* T & D using FNP */
  5    94          3 t_and_d_lev_3_occurred bit (1) unaligned,	/* A level 3 occurred */
  5    95          3 t_and_d_lev_7_occurred bit (1) unaligned,
  5    96          3 t_and_d_notify_requested bit (1) unaligned,
  5    97          3 t_and_d_assigned bit (1) unaligned,		/* AS has given fnp to process */
  5    98          3 get_meters_waiting bit (1) unaligned,		/* waiting for meter copy to complete */
  5    99          3 padb bit (7) unaligned,
  5   100          3 active_dial unaligned,
  5   101             4 active_bit (15) bit (1) unaligned,		/* ON if the process is active */
  5   102        2 lcte_ptr ptr,				/* pointer to this FNP's LCT entry */
  5   103        2 astep ptr,					/* pointer to aste of wired bootload buffer */
  5   104        2 boot_ev_chan fixed bin (71),			/* event channel over which to signal bootload completion */
  5   105        2 boot_process_id bit (36),			/* process that initiated bootload */
  5   106        2 version char (4),				/* version id of core image */
  5   107        2 fnp_mem_size fixed bin (18) unsigned,		/* memory size of this FNP in 18-bit words */
  5   108        2 queue_lock bit (36) aligned,			/* lock for interrupt queue */
  5   109        2 dump_patch_lock bit (36),			/* lock for fnp_dump or _patch operation */
  5   110        2 q_entries_made fixed bin (35),			/* count of delay queue entries made */
  5   111        2 input_reject_count fixed bin,			/* number of times input rejected */
  5   112        2 processed_from_q fixed bin (35),		/* number of interrupts processed from queue */
  5   113        2 fnp_channel_locked fixed bin (35),		/* number of times dn355 found per-FNP lock locked */
  5   114        2 input_data_transactions fixed bin (35),		/* number of mailbox transactions for input */
  5   115        2 output_data_transactions fixed bin (35),		/* number of mailbox transactions for output */
  5   116        2 input_control_transactions fixed bin (35),	/* number of mailbox transactions for inbound control info */
  5   117        2 output_control_transactions fixed bin (35),	/* number of mailbox transactions for outbound control info */
  5   118        2 cumulative_mbx_in_use fixed bin (35),		/* cumulative count of number of outbound mailboxes in use */
  5   119        2 max_mbx_in_use fixed bin,			/* maximum number of mailboxes in use at any given time */
  5   120        2 mbx_in_use_updated fixed bin (35),		/* number of increments to cumulative_mbx_in_use */
  5   121        2 mbx_unavailable fixed bin (35),		/* number of times had to queue mailbox transaction because none available */
  5   122        2 free_size fixed bin (35),			/* cumulative amount of bleft_355 */
  5   123        2 free_count fixed bin,			/* number of adds to above */
  5   124        2 fnp_space_restricted_output fixed bin (35),	/* number of times available FNP space restricted amount of output sent */
  5   125        2 tandd_pcbx fixed bin,			/* index of PCB for COLTS channel */
  5   126        2 n_pages_wired fixed bin,			/* pages wired for loading */
  5   127        2 config_flags aligned,
  5   128          3 available bit (1) unaligned,			/* reconfig says "yes" */
  5   129          3 io_manager_assigned bit (1) unaligned,		/* We have channel assigned to us */
  5   130          3 pad bit (34) unaligned,
  5   131        2 uncp_pcbx1 fixed bin (17) unaligned,		/* For the DN7100 */
  5   132        2 uncp_pcbx2 fixed bin (17) unaligned,		/* For the DN7100 */  
  5   133        2 ptx fixed bin,				/* page table index, used only at bootload */
  5   134        2 ptp pointer unaligned;			/* page table for this FNP */
  5   135 
  5   136 /**** The following named constants are used to lay out the
  5   137*      iom page tables. Each FNP has to have its own page
  5   138*      table because there is not enough room to have eight different
  5   139*      bootload images of 32 K and > 64 K of tty_buf 
  5   140*
  5   141*      THE MAX TTY BUF LENGTH IS 192 K words. We could have another 16 K
  5   142*      easily, and then after that it would get hard. */ 
  5   143 
  5   144 /**** The layout
  5   145*
  5   146*      Page   I/O address   Memory address     Comments
  5   147*      ----      ------     --------------     --------
  5   148*      0              0       xxxxxx           invalid PTW
  5   149*      1           2000         2000           write-enabled (mailbox)
  5   150*      2           4000         4000           write-enabled (mailbox)
  5   151*      3	        6000         6000           write-enabled (mailbox)
  5   152*      4          10000       as needed        bootload image segment page 0
  5   153*      ....        ....         ....           ....
  5   154*      35        110000       as needed        bootload image segment page 31
  5   155*      36        112000       xxxxxx           invalid PTW
  5   156*      ...         ....         ....           ....
  5   157*      63        160000         ....           invalid PTW
  5   158*      64        200000       as needed        tty_buf page 0
  5   159*      ...         ....         ....           ....
  5   160*      127       260000       as needed        tty_buf page 63
  5   161*      255       ......        .....           tty_buf page 191
  5   162**/
  5   163 
  5   164 /**** We assume that the page table starts at all zeros. */
  5   165 
  5   166 declare  FIRST_BOOTLOAD_PAGEX fixed bin init (4) int static options (constant);
  5   167 declare  FIRST_TTY_BUF_PAGEX fixed bin init (64) int static options (constant);
  5   168 
  5   169 /* End include file dn355_data.incl.pl1 */
      344 
      345 
  6     1 /*	BEGIN INCLUDE FILE ... pcb.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  6     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  6     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  6     9*     implementation.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 
  6    13 /*  Created 08/14/78 by Robert S. Coren */
  6    14 /*  Modified 02/19/80 by Robert S. Coren to add read_first & read_last */
  6    15 /*  Modified 12/10/80 by Robert S. Coren to add metering stuff */
  6    16 /*  Modified May 1981 by Robert S.Coren to add tandd_attached flag */
  6    17 /*  Modified in February 1982 to add: dumpout, turn, enter_receive_pending,
  6    18*             connection_type, send_lf, extra_nl,lfecho flags for DN7100 */
  6    19 
  6    20 /* Describes physical channel blocks for FNP channels */
  6    21 
  6    22 dcl  n_pcbs fixed bin;
  6    23 dcl  pcbp ptr;
  6    24 
  6    25 dcl 1 pcb_array (n_pcbs) based aligned like pcb;
  6    26 
  6    27 dcl 1 pcb aligned based (pcbp),			/* physical channel block declaration */
  6    28     2 channel_desc unaligned,
  6    29       3 devx fixed bin (17),				/* index of LCT entry */
  6    30       3 subchan fixed bin (7) unaligned,		/* logical subchannel/lsla slot # correspondence */
  6    31       3 line_number unal,				/* regular line number */
  6    32         4 is_hsla bit (1) unaligned,			/* on if hsla, off if lsla */
  6    33         4 la_no bit (3) unaligned,			/* line adapter (high or low speed) number */
  6    34         4 slot_no bit (6) unaligned,			/* physical slot or subchannel number */
  6    35     2 write_first fixed bin (17) unaligned,		/* offset of first buffer in output chain */
  6    36     2 write_last fixed bin (17) unaligned,		/* offset of last buffer in output chain */
  6    37     2 baud_rate fixed bin (17) unaligned,		/* baud rate of channel */
  6    38     2 line_type fixed bin (17) unaligned,		/* line type */
  6    39     2 max_buf_size fixed bin (17) unaligned,		/* largest buffer to be allocated for output */
  6    40     2 write_cnt fixed bin (17) unaligned,		/* number of characters in write chain */
  6    41     2 flags unaligned,
  6    42       3 listen bit (1),				/* channel is ready for dialup */
  6    43       3 dialed bit (1),				/* channel is dialed up or connected */
  6    44       3 send_output bit (1),				/* channel is ready for output */
  6    45       3 high_speed bit (1),				/* needs large send_out threshold */
  6    46       3 sync_line bit (1),				/* synchronous channel */
  6    47       3 end_frame bit (1),				/* channel is waiting for formfeed */
  6    48       3 hndlquit bit (1),				/* channel in hndlquit mode */
  6    49       3 breakall_enabled bit (1),			/* breakall mode allowed for this channel */
  6    50       3 output_mbx_pending bit (1),			/* A wtx mbx has been sent, but not relinquished */
  6    51       3 copied_meters_ready bit (1),			/* copy_meters operation has completed */
  6    52       3 get_meters_waiting bit (1),			/* waiting for get_meters operation to complete */
  6    53       3 tandd_attached bit (1),			/* this channel is in use by T & D */
  6    54       3 enter_receive_pending bit (1),			/* enter_receive is waiting for send */
  6    55       3 turn bit (1),				/* Multics owns the turn */
  6    56       3 extra_nl bit (1),				/* add NL at end of buffer  (read) */
  6    57       3 send_lf bit (1),				/* send lf after read  */
  6    58       3 lfecho bit (1),				/* Validate lfecho mode */
  6    59       3 dumpout bit (1),				/* To purge first write after special dial */
  6    60       3 buffer_flag bit (1),                                /* Utilisation of a buffer in place of the circular buffer. */
  6    61       3 connection_type bit (2),			/* For full-duplex */
  6    62       3 padb bit (6),
  6    63       3 uncp_pcbx fixed bin (9) unal uns,		/* To manage the full duplex with the datanet 7100 */
  6    64     2 read_first fixed bin (18) unsigned unaligned,	/* head of read chain (while reading from FNP) */
  6    65     2 read_last fixed bin (18) unsigned unaligned,	/* tail of read chain (likewise) */
  6    66     2 saved_meters_ptr pointer unaligned,		/* pointer to (unwired) copy of meters at last dialup */
  6    67     2 copied_meters_offset fixed bin (18) unsigned;	/* offset in tty_buf of buffer meters copied to */
  6    68 
  6    69 /* END INCLUDE FILE ... pcb.incl.pl1 */
      346 
      347 
  7     1 /*		BEGIN mailbox_ops.incl.pl1
  7     2*
  7     3*   Created 8/15/74 by F. A. Canali
  7     4*   Modified 12/01/75 by J. Goldman for dial out
  7     5*   Modified 8/24/76 by Robert Coren to add dont_accept_calls and blast
  7     6*   Modified 7/28/77 by J. Stern to add set_delay_table
  7     7*   Modified 2/6/78 by Robert Coren to add sync_msg_size
  7     8*   Modified 6/29/79 by B. Greenberg for FNP echo negotiation
  7     9*   Modified Oct. 1979 by Robert Coren to add oflow & iflow modes
  7    10*   Modified 1/21/80 by Robert Coren to add parity controls 
  7    11*   Modified 12/10/80 by Robert Coren to add report_meters
  7    12*   */
  7    13 
  7    14 dcl (						/* declaration of submailbox io commands */
  7    15 
  7    16      rcd init (1),					/* read control data */
  7    17      rtx init (2),					/* read text */
  7    18      wcd init (3),					/* write control data */
  7    19      wtx init (4)					/* write text */
  7    20 
  7    21      ) fixed bin (8) int static options (constant);
  7    22 
  7    23 
  7    24 dcl (						/* declaration of submailbox op codes sent by 6180 to 355 */
  7    25 
  7    26      terminal_accepted init (0),			/* a dialed terminal has been accepted */
  7    27      disconnect_this_line init (1),			/* hang up a line */
  7    28      disconnect_all_lines init (2),			/* hang up all lines */
  7    29      dont_accept_calls init (3),			/* the 6180 is no longer accepting terminals */
  7    30      accept_calls init (4),				/* the 6180 is ready to accept terminals */
  7    31      input_accepted init (5),				/* the 6180 will accept input and has reserved
  7    32*						   space in its circular buffer */
  7    33      set_line_type init (6),				/* set the line type */
  7    34      enter_receive init (7),				/* give the line to the terminal */
  7    35      set_framing_chars init (8),			/* set characters for block transfer */
  7    36      blast init (9),				/* BOS blast message */
  7    37      accept_direct_output init (10),			/* the 6180 has an output request */
  7    38      accept_last_output init (11),			/* same as above but the 355 may
  7    39*						   unlock the keyboard and accept input
  7    40*						   when the output transmission is through */
  7    41      dial init (12),				/* use command data to dial a phone number */
  7    42      reject_request_temp init (14),			/* an input request can not be serviced */
  7    43      terminal_rejected init (16),			/* a dial up has been rejected */
  7    44      disconnect_accepted init (17),			/* the 6180 recognizes a disconnection */
  7    45      init_complete init (18),				/* 6180 system initialization is complete */
  7    46      dump_mem init (19),				/* dump 355 memory */
  7    47      patch_mem init (20),				/* patch 355 memory */
  7    48      fnp_break init (21),				/* to control fnp break points */
  7    49      line_control init (22),				/* line control order to fnp */
  7    50      sync_msg_size init (23),				/* set message size for sync line */
  7    51      set_echnego_break_table init (24),			/* send over echo negotiation break table */
  7    52      start_negotiated_echo init (25),			/* attempt to start FNP echoing for ech. nego. */
  7    53      stop_negotiated_echo init (26),			/* 6180 wants FNP to stop negotiated echo */
  7    54      init_echo_negotiation init (27),			/* synchronize echo negotiation ctrs. */
  7    55      break_acknowledged init (29),			/* the 6180 recognizes a break for a terminal */
  7    56      input_fc_chars init (30),			/* set input flow control chars */
  7    57      output_fc_chars init (31),			/* set output flow control chars */
  7    58      alter_parameters init (34),			/* request to alter 355 parms for a terminal */
  7    59      checksum_error init (35),			/* submailbox has a checksum error */
  7    60      report_meters init (36),				/* get meters from FNP */
  7    61      set_delay_table init (37)			/* tells 355 to set new delay table for channel */
  7    62      ) fixed bin (8) int static options (constant);
  7    63 
  7    64 
  7    65 dcl (						/* submailbox op codes sent from 355 to 6180 */
  7    66 
  7    67      accept_new_terminal init (64),			/* a terminal has dialed up */
  7    68      disconnected_line init (65),			/* a terminal has been hung up */
  7    69      input_in_mailbox init (66),			/* this mailbox contains input */
  7    70      line_masked init (67),				/* channel was masked for excessive interrupts */
  7    71      s6180_params init (68),				/* return bcount */
  7    72      send_output init (69),				/* I am ready to send to a terminal */
  7    73      ack_echnego_init init (70),			/* I have zeroed my ech. nego. ctr. */
  7    74      ack_echnego_stop init (71),			/* I have sent all that I have echoed. */
  7    75      connect_to_slave init (73),			/* a dialup sequence has been completed */
  7    76      accept_direct_input init (74),			/* HEY! here's some input for you */
  7    77      break_condition init (75),			/* a break has been hit for a terminl */
  7    78      wru_timeout init (76),				/* no answerback */
  7    79      error_message init (77),				/* error message from the 355 */
  7    80      first_acu_op_code init (80),
  7    81      acu_no_power init (80),				/* power indicator of auto-call unit is off */
  7    82      acu_line_occupied init (81),			/* auto-call unit's line is being used */
  7    83      acu_dial_failure init (82),			/* dial out failed */
  7    84      acu_no_good init (83),				/* invalid dial out attempt */
  7    85      last_acu_op_code init (83),
  7    86      line_status init (84)				/* line status reported by fnp */
  7    87      ) fixed bin (8) int static options (constant);
  7    88 
  7    89 dcl (						/* declaration of sub operations for alter parameters */
  7    90 
  7    91      Breakchar init (1),				/* specifies break character */
  7    92      Nocontrol init (2),				/* enter/leave nocontrol mode */
  7    93      Fullduplex init (3),				/* perform character echoing */
  7    94      Break init (4),			/* send line break to terminal */
  7    95      Errormsg init (5),				/* indicates error detected by 355 */
  7    96      Meter init (6),				/* read metering info */
  7    97      Sensepos init (7),				/* sense position of carrier */
  7    98      Crecho init (8),				/* enter/leave crecho mode */
  7    99      Lfecho init (9),				/* enter/leave line feed echo mode */
  7   100      Lock init (10),				/* lock keyboard */
  7   101      Msg init (11),					/* precanned msg for dialing terminals */
  7   102      Upstate init (12),				/* are you up? */
  7   103      Dumpoutput init (13),				/* throw away output */
  7   104      Tabecho init (14),				/* echo tabs */
  7   105      Setbusy init (15),				/* force dataset busy */
  7   106      Listen init (16),				/* answer the phone */
  7   107      Hndlquit init (17),				/* send newline on receipt of quit */
  7   108      Chngstring init (18),				/* printer addressing string definition */
  7   109      Wru init (19),					/* read answerback */
  7   110      Echoplex init (20),				/* enter/leave echoplex mode */
  7   111      Xmit_hold init (21),				/* start/stop transmit hold */
  7   112      Dumpinput init (22),				/* throw away input */
  7   113      Replay init (23),				/* replay interrupted input */
  7   114      Polite init (24),				/* write only if at left margin */
  7   115      Block_xfer init (25),				/* block transfer or "frame" mode */
  7   116      Set_buffer_size init (26),			/* set input buffer size */
  7   117      Breakall init (27),				/* break on all characters */
  7   118      Prefixnl init (28),				/* prefix output with newlines if input present */
  7   119      Input_flow_control init (29),			/* iflow mode */
  7   120      Output_flow_control init (30),			/* oflow mode */
  7   121      Odd_parity init (31),				/* generate odd parity */
  7   122      Eight_bit_in init (32),				/* 8bit mode */
  7   123      Eight_bit_out init (33)				/* no_outp mode */
  7   124      ) fixed bin (8) int static options (constant);
  7   125 
  7   126 dcl  global_opcodes (9) fixed bin (8) int static options (constant) init (
  7   127      2,						/* disconnect_all_lines */
  7   128      3,						/* dont_accept_calls */
  7   129      4,						/* accept_calls */
  7   130      9,						/* blast */
  7   131      19,						/* dump_mem */
  7   132      20,						/* patch_mem */
  7   133      21,						/* fnp_break */
  7   134      36,						/* report_meters */
  7   135      77);						/* error_message */
  7   136 
  7   137 /* END of mailbox_ops.incl.pl1 */
      348 
      349 
  8     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  8     2 
  8     3 /* This include file declares all the entries in tty_space_man and defines the constants
  8     4**  to be used for the flags argument
  8     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  8     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  8     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  8     8**/
  8     9 
  8    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  8    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  8    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  8    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  8    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  8    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  8    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  8    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  8    18 dcl  tty_space_man$needs_space entry (fixed bin);
  8    19 
  8    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  8    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  8    22 
  8    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      350 
      351 
  9     1 /* BEGIN INCLUDE FILE ... line_types.incl.pl1  */
  9     2 
  9     3 /* Written  November 10 1975 by Paul Green */
  9     4 /* Modified October 1978 by Larry Johnson to include line_type_names */
  9     5 /* Modified 12/19/78 by J. Stern to add POLLED_VIP line type */
  9     6 /* Modified 9/27/79 by J. Stern to add X25LAP line type */
  9     7 /* Modified Spring 1981 by Charles Hornig to add HDLC line type */
  9     8 /* Modified May 1981 by Robert Coren to add COLTS line type */
  9     9 /* Modified September 1984 by Robert Coren to correctly count VIP as a synchronous line type */
  9    10 
  9    11 
  9    12 /****^  HISTORY COMMENTS:
  9    13*  1) change(86-02-25,Negaret), approve(87-07-13,MCR7679),
  9    14*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    15*     Add a DSA line type.
  9    16*  2) change(87-03-17,Beattie), approve(87-07-13,MCR7656),
  9    17*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    18*     Add HASP_OPR to identify HASP workstation consoles with login service.
  9    19*                                                   END HISTORY COMMENTS */
  9    20 
  9    21 
  9    22 declare   (LINE_MC            initial (-2),
  9    23        	 LINE_TELNET	initial (-1),
  9    24            LINE_UNKNOWN       initial (0),
  9    25 	 LINE_ASCII	initial (1),
  9    26 	 LINE_1050	initial (2),
  9    27 	 LINE_2741	initial (3),
  9    28 	 LINE_ARDS	initial (4),
  9    29 	 LINE_SYNCH	initial (5),
  9    30 	 LINE_G115	initial (6),
  9    31 	 LINE_BSC		initial (7),
  9    32 	 LINE_ETX		initial (8),
  9    33 	 LINE_VIP		initial (9),
  9    34 	 LINE_ASYNC1	initial (10),
  9    35 	 LINE_ASYNC2	initial (11),
  9    36 	 LINE_ASYNC3	initial (12),
  9    37 	 LINE_SYNC1	initial (13),
  9    38 	 LINE_SYNC2	initial (14),
  9    39 	 LINE_SYNC3	initial (15),
  9    40 	 LINE_POLLED_VIP	initial (16),
  9    41 	 LINE_X25LAP	initial (17),
  9    42 	 LINE_HDLC	initial (18),
  9    43 	 LINE_COLTS	initial (19),
  9    44 	 LINE_DSA           initial (20),
  9    45 	 LINE_HASP_OPR	initial (21)
  9    46 	) fixed bin internal static options (constant);
  9    47 
  9    48 dcl  max_line_type fixed bin int static options (constant) init (21);
  9    49 
  9    50 declare  n_sync_line_types fixed bin int static options (constant) init (10);
  9    51 
  9    52 declare  sync_line_type (10) fixed bin int static options (constant) init (5, 6, 7, 9, 13, 14, 15, 16, 17, 18);
  9    53 
  9    54 dcl  line_types (-2:21) char (16) int static options (constant) init (
  9    55      "MC",                                                  /* -2 */
  9    56      "TELNET",					/* -1 */
  9    57      "none",					/* 0 */
  9    58      "ASCII",					/* 1 */
  9    59      "1050",					/* 2 */
  9    60      "2741",					/* 3 */
  9    61      "ARDS",					/* 4 */
  9    62      "Sync",					/* 5 */
  9    63      "G115",					/* 6 */
  9    64      "BSC",					/* 7 */
  9    65      "202ETX",					/* 8 */
  9    66      "VIP",					/* 9 */
  9    67      "ASYNC1",					/* 10 */
  9    68      "ASYNC2",					/* 11 */
  9    69      "ASYNC3",					/* 12 */
  9    70      "SYNC1",					/* 13 */
  9    71      "SYNC2",					/* 14 */
  9    72      "SYNC3",					/* 15 */
  9    73      "POLLED_VIP",					/* 16 */
  9    74      "X25LAP",					/* 17 */
  9    75      "HDLC",					/* 18 */
  9    76      "COLTS",					/* 19 */
  9    77      "DSA",					/* 20 */
  9    78      "HASP_OPR");					/* 21 */
  9    79 
  9    80 /* END INCLUDE FILE ... line_types.incl.pl1  */
      352 
      353 
 10     1 /* BEGIN INCLUDE FILE ... mux_init_info.incl.pl1 */
 10     2 
 10     3 /* Created 8/2/78 by J. Stern */
 10     4 
 10     5 
 10     6 dcl  miip ptr;					/* ptr to mux_init_info structure */
 10     7 dcl  mii_chan_count fixed bin;			/* channel count when allocating mux_init_info */
 10     8 
 10     9 
 10    10 dcl 1 mux_init_info aligned based (miip),		/* multiplexer initialization info */
 10    11       2 no_channels fixed bin,			/* number of multiplexed channels */
 10    12       2 channels (mii_chan_count refer (mux_init_info.no_channels)), /* one entry per channel */
 10    13         3 name char (32) unal,			/* channel name */
 10    14         3 devx fixed bin;				/* device index for channel */
 10    15 
 10    16 
 10    17 /* END INCLUDE FILE ... mux_init_info.incl.pl1 */
      354 
      355 
 11     1 /*  START OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3 /* Written by Charles Hornig, 1st quarter 1981 */
 11     4 /* Canonicalization entry added by Chris Jones, January 1984 */
 11     5 
 11     6 /* chanid = canonicalize_chanid (chanid); */
 11     7 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
 11     8 dcl	io_chnl_util$canonicalize_chanid
 11     9 			   entry (char (8) aligned) returns (char (8) aligned);
 11    10 
 11    11 /* call iom_to_name (iomno, channo, name, code); */
 11    12 dcl	io_chnl_util$iom_to_name
 11    13 			   entry (fixed bin (3), fixed bin (7), char (8) aligned, fixed bin (35));
 11    14 
 11    15 /* call name_to_iom (name, iomno, channo, code); */
 11    16 dcl	io_chnl_util$name_to_iom
 11    17 			   entry (char (8) aligned, fixed bin (3), fixed bin (7), fixed bin (35));
 11    18 
 11    19 /*  END OF:	io_chnl_util_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      356 
 12     1 /* BEGIN INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
 12     2 
 12     3 /* Created 4/9/79 by J. Stern */
 12     4 /* Modified: 10 November 1980 by G. Palter to add can_type */
 12     5 
 12     6 
 12     7 dcl  mclp ptr;
 12     8 dcl  mcl_version_2 fixed bin int static options (constant) init (2);
 12     9 
 12    10 dcl 1 mcl aligned based (mclp),			/* modes change list */
 12    11       2 version fixed bin,				/* version number of this structure (Input) */
 12    12       2 n_entries fixed bin,				/* number of mode change entries (Input) */
 12    13       2 line_len fixed bin,				/* new line length (-1 => no change) (Input) */
 12    14       2 page_len fixed bin,				/* new page length (-1 => no change) (Input) */
 12    15       2 can_type fixed binary,			/* new canonicalization type (-1 => no change) (Input) */
 12    16       2 flags,
 12    17         3 init bit (1) unal,				/* ON if all modes to be reinitialized (Input) */
 12    18         3 ll_error bit (1) unal,			/* ON if line length error detected (Output) */
 12    19         3 pl_error bit (1) unal,			/* ON if page length error detected (Output) */
 12    20         3 can_type_error bit (1) unaligned,		/* ON if can_type error detected (Output) */
 12    21         3 mbz bit (32) unal,
 12    22       2 entries (36) like mcle;			 /* one entry per mode change */
 12    23 
 12    24 dcl  mclep ptr;
 12    25 
 12    26 dcl 1 mcle aligned based (mclep),			/* mode change list entry */
 12    27       2 mode_name char (16) unal,			/* name of mode to change (Input) */
 12    28       2 flags,
 12    29         3 mode_switch bit (1) unal,			/* ON to turn mode on, else OFF (Input) */
 12    30         3 force bit (1) unal,				/* ON to ignore errors for this mode change (Input) */
 12    31         3 mpx_mode bit (1) unal,			/* ON if mode recognized by multiplexer (Output) */
 12    32         3 error bit (1) unal,				/* ON if mode change is in error (Output) */
 12    33         3 mbz bit (32) unal;
 12    34 
 12    35 
 12    36 /* END INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
      357 
 13     1 /* BEGIN INCLUDE FILE ... flow_conrol_info.incl.pl1 */
 13     2 
 13     3 /* This include file defines the structures used for the "input_flow_control_chars"
 13     4*   and "output_flow_control_chars" orders to MCS.
 13     5**/
 13     6 
 13     7 /* Created 08/13/79 by Robert S. Coren */
 13     8 
 13     9 dcl 1 input_flow_control_info aligned based,
 13    10     2 suspend_seq unaligned,
 13    11       3 count fixed bin (9) unsigned,
 13    12       3 chars char (3),
 13    13     2 resume_seq unaligned,
 13    14       3 count fixed bin (9) unsigned,
 13    15       3 chars char (3),
 13    16     2 timeout bit (1);
 13    17 
 13    18 
 13    19 dcl 1 output_flow_control_info aligned based,
 13    20     2 flags unaligned,
 13    21       3 suspend_resume bit (1),
 13    22       3 block_acknowledge bit (1),
 13    23       3 mbz bit (16),
 13    24     2 buffer_size fixed bin (18) unsigned unaligned,
 13    25     2 suspend_or_etb_seq unaligned,
 13    26       3 count fixed bin (9) unsigned,
 13    27       3 chars char (3),
 13    28     2 resume_or_ack_seq unaligned,
 13    29       3 count fixed bin (9) unsigned,
 13    30       3 chars char (3);
 13    31 
 13    32 
 13    33 /* END INCLUDE FILE ... flow_control_info.incl.pl1 */
 13    34 
      358 
 14     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
 14     2 
 14     3 /* Created 8/25/78 by J. Stern */
 14     4 
 14     5 
 14     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
 14     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
 14     8 
 14     9 /* call channel_manager$write (devx, output_ptr, code) */
 14    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
 14    11 
 14    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
 14    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
 14    14 
 14    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
 14    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
 14    17 
 14    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
 14    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
 14    20 
 14    21 /* call channel_manager$get_modes (devx, modes, code) */
 14    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
 14    23 
 14    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
 14    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    26 
 14    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
 14    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
 14    29 
 14    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
 14    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    32 
 14    33 
 14    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      359 
 15     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
 15     2 
 15     3 /* Defines constants and structures  used by MCS interrupt handlers */
 15     4 
 15     5 /* Created 08/21/78 by Robert Coren */
 15     6 /* Echo negotiation types added sometime by Bernie Greenberg */
 15     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
 15     8 /* MASKED type added June 23, 1982, by Robert Coren */
 15     9 
 15    10 dcl  DIALUP fixed bin int static options (constant) init (1);
 15    11 dcl  HANGUP fixed bin int static options (constant) init (2);
 15    12 dcl  CRASH fixed bin int static options (constant) init (3);
 15    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
 15    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
 15    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
 15    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
 15    17 dcl  QUIT fixed bin int static options (constant) init (8);
 15    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
 15    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
 15    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
 15    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
 15    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
 15    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
 15    24 dcl  TIMER fixed bin int static options (constant) init (15);
 15    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
 15    26 dcl  MASKED fixed bin int static options (constant) init (17);
 15    27 
 15    28 dcl  interrupt_info bit (72) aligned;
 15    29 
 15    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
 15    31     2 line_type fixed bin (9) unal uns,
 15    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
 15    33     2 baud_rate fixed bin (18) unal uns,
 15    34     2 max_buf_size fixed bin (9) unal uns,
 15    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
 15    36     2 pad bit (26) unal;
 15    37 
 15    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
 15    39     2 input_chain unaligned,
 15    40       3 chain_head bit (18) unaligned,
 15    41       3 chain_tail bit (18) unaligned,
 15    42     2 input_count fixed bin (18) unal uns,
 15    43     2 flags unaligned,
 15    44       3 break_char bit (1),				/* data contains a break character */
 15    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
 15    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
 15    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
 15    48       3 pad bit (14);
 15    49 
 15    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
 15    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
 15    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
 15    53 
 15    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
      360 
 16     1 
 16     2 /* BEGIN INCLUDE FILE...fnp_meters.incl.pl1 */
 16     3 
 16     4 /* This include file defines structures used to return meters when
 16     5**  a get_meters order is issued for a whole FNP.
 16     6**/
 16     7 
 16     8 /* Written December 1980 by Robert Coren */
 16     9 /* Modified February 1981 by Robert Coren to split off fnp_channel_meters */
 16    10 
 16    11 dcl  fnp_meterp pointer;
 16    12 
 16    13 dcl 1 fnp_global_meters based aligned,			/* FNP-wide meters */
 16    14     2 channels_dialed_cum fixed bin (35),
 16    15     2 channels_dialed_updates fixed bin (35),		/* updates to above */
 16    16     2 space_available_cum fixed bin (35),
 16    17     2 space_available_updates fixed bin (35),		/* updates to above */
 16    18     2 input_mbx_in_use_cum fixed bin (35),
 16    19     2 input_mbx_updates fixed bin (35),			/* updates to above */
 16    20     2 cur_channels_dialed fixed bin (18) unsigned unaligned,
 16    21     2 space_alloc_failures fixed bin (18) unsigned unaligned,
 16    22     2 abnormal_dia_status fixed bin (18) unsigned unaligned,
 16    23     2 buffer_pool fixed bin (18) unsigned unaligned,
 16    24     2 buffer_allocations fixed bin (35),
 16    25     2 buffers_preallocated fixed bin (35),
 16    26     2 used_preallocated_buffer fixed bin (35),
 16    27     2 no_preallocated_available fixed bin (35),
 16    28     2 time_booted fixed bin (71),
 16    29     2 total_idle_count fixed bin (35),
 16    30     2 idle_count_updates fixed bin (35),
 16    31     2 max_idle_count fixed bin (35),
 16    32     2 min_idle_count fixed bin (35),
 16    33     2 memory_parity_errors fixed bin (35);
 16    34 
 16    35 dcl 1 fnp_meters based (fnp_meterp) aligned,		/* structure for returning FNP-wide meters kept by FNP and ring 0 */
 16    36     2 version fixed bin,
 16    37     2 pad fixed bin,
 16    38     2 from_fnp like fnp_global_meters,
 16    39     2 n_channels fixed bin,
 16    40     2 output_mbx_in_use_cum fixed bin (35),
 16    41     2 output_mbx_updates fixed bin (35),
 16    42     2 output_mbx_unavailable fixed bin (35),
 16    43     2 max_output_mbx_in_use fixed bin,
 16    44     2 queue_entries_made fixed bin (35),
 16    45     2 input_rejects fixed bin,
 16    46     2 processed_from_q fixed bin (35),
 16    47     2 fnp_channel_locked fixed bin (35),
 16    48     2 input_data_transactions fixed bin (35),
 16    49     2 output_data_transactions fixed bin (35),
 16    50     2 input_control_transactions fixed bin (35),
 16    51     2 output_control_transactions fixed bin (35),
 16    52     2 fnp_space_restricted_output fixed bin,
 16    53     2 fnp_mem_size fixed bin,
 16    54     2 iom_number fixed bin,
 16    55     2 iom_chan_no fixed bin;
 16    56 
 16    57 dcl  FNP_METERS_VERSION_2 fixed bin int static options (constant) init (2);
 16    58 
 16    59 /* END INCLUDE FILE...fnp_meters.incl.pl1 */
      361 
 17     1 /* BEGIN INCLUDE FILE...fnp_channel_meters.incl.pl1 */
 17     2 
 17     3 /* This include file defines meters returned for subchannels of an FNP. */
 17     4 
 17     5 /* Created February 1981 by Robert Coren from fnp_meters.incl.pl1. */
 17     6 
 17     7 dcl  fnp_chan_meterp pointer;
 17     8 dcl  FNP_CHANNEL_METERS_VERSION_1 fixed bin int static options (constant) init (1);
 17     9 
 17    10 dcl 1 fnp_chan_meter_struc based (fnp_chan_meterp) aligned,
 17    11     2 version fixed bin,
 17    12     2 flags,
 17    13       3 synchronous bit (1) unaligned,
 17    14       3 reserved bit (35) unaligned,
 17    15     2 current_meters like fnp_channel_meters,
 17    16     2 saved_meters like fnp_channel_meters;
 17    17 
 17    18 dcl 1 fnp_channel_meters based aligned,
 17    19     2 header,
 17    20       3 dia_request_q_len fixed bin (35),			/* cumulative */
 17    21       3 dia_rql_updates fixed bin (35),			/* updates to above */
 17    22       3 pending_status fixed bin (35),			/* cumulative */
 17    23       3 pending_status_updates fixed bin (35),		/* updates to above */
 17    24       3 output_overlaps fixed bin (18) unsigned unaligned,	/* output chained to already-existing chain */
 17    25       3 parity_errors fixed bin (18) unsigned unaligned,	/* parity on the channel */
 17    26       3 software_status_overflows fixed bin (18) unsigned unaligned,
 17    27       3 hardware_status_overflows fixed bin (18) unsigned unaligned,
 17    28       3 input_alloc_failures fixed bin (18) unsigned unaligned,
 17    29       3 dia_current_q_len fixed bin (18) unsigned unaligned,	/* current length of dia request queue */
 17    30       3 exhaust fixed bin (35),
 17    31       3 software_xte fixed bin (18) unsigned unaligned,
 17    32       3 pad bit (18) unaligned,
 17    33     2 sync_or_async (17) fixed bin;			/* placeholder for meters for sync or async channels */
 17    34 
 17    35 dcl 1 fnp_sync_meters based aligned,
 17    36     2 header like fnp_channel_meters.header,
 17    37     2 input,
 17    38       3 message_count fixed bin (35),			/* total number of messages */
 17    39       3 cum_length fixed bin (35),			/* total cumulative length in characters */
 17    40       3 min_length fixed bin (18) unsigned unaligned,	/* length of shortest message */
 17    41       3 max_length fixed bin (18) unsigned unaligned,	/* length of longest message */
 17    42     2 output like fnp_sync_meters.input,
 17    43     2 counters (8) fixed bin (35),
 17    44     2 pad (3) fixed bin;
 17    45 
 17    46 dcl 1 fnp_async_meters based aligned,
 17    47     2 header like fnp_channel_meters.header,
 17    48     2 pre_exhaust fixed bin (35),
 17    49     2 echo_buf_overflow fixed bin (35),			/* number of times echo buffer has overflowed */
 17    50     2 bell_quits fixed bin (18) unsigned unaligned,
 17    51     2 padb bit (18) unaligned,
 17    52     2 pad (14) fixed bin;
 17    53 
 17    54 /* END INCLUDE FILE...fnp_channel_meters.incl.pl1 */
      362 
 18     1 /* BEGIN INCLUDE FILE...get_comm_meters_info.incl.pl1 */
 18     2 
 18     3 /* This include file defines the info structure(s) used with the get_meters order to MCM */
 18     4 /* A program that includes this include file must alos include lct.incl.pl1 */
 18     5 
 18     6 /* Written Decemeber 1980 by Robert Coren */
 18     7 
 18     8 dcl 1 get_comm_meters_info aligned based,		/* info_ptr points to this */
 18     9     2 version fixed bin,
 18    10     2 pad fixed bin,
 18    11     2 subchan_ptr pointer,				/* pointer to meters kept by the subchannel */
 18    12     2 logical_chan_ptr pointer,			/* pointer to meters kept by channel_manager */
 18    13     2 parent_ptr pointer,				/* pointer to meters kept by the parent multiplexer */
 18    14     2 subchan_type fixed bin,				/* multiplexer type of subchannel */
 18    15     2 parent_type fixed bin;				/* multiplexer type of parent */
 18    16 
 18    17 dcl 1 logical_chan_meters based aligned,		/* pointed to by get_comm_meters_info.logical_chan_ptr */
 18    18        2 current_meters like lcte.meters,		/* latest values */
 18    19        2 saved_meters like lcte.meters;			/* values as of last copy_meters */
 18    20 
 18    21 dcl  GET_COMM_METERS_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 18    22 
 18    23 /* END INCLUDE FILE...get_comm_meters_info.incl.pl1 */
      363 
 19     1 /* Begin include file io_manager_dcls.incl.pl1 */
 19     2 
 19     3 /* Written by Charles Hornig, late 1980 and early 1981 */
 19     4 /* Modified for MR10 interface, February 1982 */
 19     5 /* Channel reconfiguration entries added by Chris Jones, January 1984 */
 19     6 
 19     7 /* These entries are callable on unwired stacks. */
 19     8 
 19     9 /* call io_manager$assign (Chx, Channel, Handler, Index, Statusp, Code); */
 19    10 dcl  io_manager$assign
 19    11 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 19    12 	fixed bin (35), ptr, fixed bin (35));
 19    13 
 19    14 /* call io_manager$assign_add (Chx, Channel, Handler, Index, Statusp, Code); */
 19    15 dcl  io_manager$assign_add
 19    16 	entry (fixed bin (35), char (8) aligned, entry (fixed bin (35), fixed bin (3), bit (36) aligned),
 19    17 	fixed bin (35), ptr, fixed bin (35));
 19    18 
 19    19 /* call io_manager$unassign (Chx, Code); */
 19    20 dcl  io_manager$unassign entry (fixed bin (35), fixed bin (35));
 19    21 
 19    22 /* call io_manager$unassign_delete (Chx, Code); */
 19    23 dcl  io_manager$unassign_delete entry (fixed bin (35), fixed bin (35));
 19    24 
 19    25 /* call io_manager$connect (Io_manager_arg); */
 19    26 dcl  io_manager$connect entry (1 aligned like io_manager_arg);
 19    27 
 19    28 /* call io_manager$connect_abs (Io_manager_arg); */
 19    29 dcl  io_manager$connect_abs entry (1 aligned like io_manager_arg);
 19    30 
 19    31 /* call io_manager$connect_direct (Io_manager_arg); */
 19    32 dcl  io_manager$connect_direct entry (1 aligned like io_manager_arg);
 19    33 
 19    34 /* call io_manager$get_status (Chx, Io_status_entry_ptr); */
 19    35 dcl  io_manager$get_status entry (fixed bin (35), ptr);
 19    36 
 19    37 /* call io_manager$mask (Chx); */
 19    38 dcl  io_manager$mask entry (fixed bin (35));
 19    39 
 19    40 /* call io_manager$ignore_interrupt (); */
 19    41 dcl  io_manager$ignore_interrupt entry (fixed bin (35), fixed bin (3), bit (36) aligned);
 19    42 
 19    43 /* call io_manager$data_tdcw (Io_manager_arg);
 19    44*   dcl  io_manager$data_tdcw entry (1 aligned like io_manager_arg);
 19    45*
 19    46*   /* call io_manager$workspace_tdcw (Io_manager_arg); */
 19    47 dcl  io_manager$workspace_tdcw entry (1 aligned like io_manager_arg);
 19    48 
 19    49 dcl  io_manager_arg_ptr ptr;
 19    50 dcl  1 io_manager_arg aligned based (io_manager_arg_ptr),
 19    51        2 chx fixed bin (35),				/* channel index from io_manager$assign */
 19    52        2 bound fixed bin (19),			/* workspace size */
 19    53        2 pcw bit (36) aligned,			/* or IDCW */
 19    54        2 listx fixed bin (18),			/* DCW list offset */
 19    55        2 ptp ptr,					/* page table pointer */
 19    56        2 listp ptr,					/* DCW list pointer */
 19    57        2 dcw_pair_ptr ptr;				/* DCW pair pointer */
 19    58 
 19    59 /* End include file io_manager_dcls.incl.pl1 */
      364 
 20     1 /* BEGIN INCLUDE FILE mcs_echo_neg_sys.incl.pl1   Bernard Greenberg 1/20/79 */
 20     2 
 20     3 /* Modified 6/29/79 by BSG for FNP echo negotiation */
 20     4 
 20     5 
 20     6 /****^  HISTORY COMMENTS:
 20     7*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
 20     8*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
 20     9*     To increase size of break table and to add named constants for the size.
 20    10*                                                   END HISTORY COMMENTS */
 20    11 
 20    12 
 20    13 /* This include file defines the wired structure for MCS echo negotiation */
 20    14 
 20    15 dcl echo_datap ptr;					/* Wired echo data ptr */
 20    16 dcl WIRED_ECHO_BREAK_SIZE fixed bin internal static options (constant) init (255);
 20    17 dcl WORDS_IN_ECHO_BREAK_TABLE fixed bin internal static options (constant) init (8);
 20    18 
 20    19 dcl 1 echo_data based (echo_datap) aligned,		/* Wired echo data */
 20    20     2 break (0: 255) bit (1) unaligned,			/* 1 = break on this character */
 20    21     2 synchronized bit (1) unal,			/* Mux echo negotiation is synchronized */
 20    22     2 mux_will_echnego bit (1) unal,			/* Multiplexer accepted start_neg_echnego */
 20    23     2 echo_start_pending_sndopt bit (1) unal,		/* Send start_n_e when SEND_OUTPUT comes */
 20    24     2 awaiting_start_sync bit (1) unal,			/* Awaiting mux reply ACK for start */
 20    25     2 awaiting_stop_sync bit (1) unal,			/* Awaiting mux reply ACK for stop */
 20    26     2 pad bit (27) unaligned,
 20    27     2 sync_ctr fixed bin (35),			/* Protocol ctr for MUX echo neg */
 20    28     2 chars_echoed fixed bin (9) unsigned unaligned,	/* Count of chars echoed */
 20    29     2 horiz_room_left fixed bin (9) unsigned unaligned,	/* Room left on line */
 20    30     2 rubout_trigger_chars (2) unaligned,		/* Characters that cause rubout action */
 20    31       3 char char (1) unaligned,
 20    32     2 rubout_sequence_length fixed bin (4) unsigned unaligned, /* Length of rubout sequence, output */
 20    33     2 rubout_pad_count fixed bin (4) unsigned unaligned,	/* Count of pads needed */
 20    34     2 buffer_rubouts bit (1) unaligned,			/* 1 = put rubouts and rubbed out in buffer */
 20    35     2 rubout_sequence char (12) unaligned;		/* Actual rubout sequence */
 20    36 
 20    37 /* END INCLUDE FILE mcs_echo_neg_sys.incl.pl1 */
      365 
 21     1 /* BEGIN INCLUDE FILE ... uncp_buf.incl.pl1 */
 21     2 
 21     3 
 21     4 /****^  HISTORY COMMENTS:
 21     5*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
 21     6*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
 21     7*     Implement the uncp multiplexer interface for the DSA gateway protocol.
 21     8*                                                   END HISTORY COMMENTS */
 21     9 
 21    10 /* Copied from tty_buf.incl.pl1 June 17, 1981 by Jacke Barre to install
 21    11*   the circular queue in a independent segment (uncp_buf).
 21    12*   In MR9.0 there is no longer a circular queue in tty_buf.
 21    13*   Modified in August 1985 for adaptation to MR11.0.
 21    14**/
 21    15 
 21    16 dcl  uncpbp ptr;
 21    17 
 21    18 
 21    19 dcl 1 uncp_buf aligned based (uncpbp),			/* declaration of uncp buffer area */
 21    20     2 absolute_orig fixed bin (24),			/* abs address of this area */
 21    21     2 cq_hbound fixed bin (18),			/* upper bound for circular_queue array */
 21    22     2 circular_queue_size fixed bin (35),		/* number of words used in circular queue */
 21    23     2 queue_ave_cnt fixed bin (18),			/* divide above by this to get ave queue size */
 21    24     2 queue_full_cnt fixed bin (18),			/* number of times circular queue full */
 21    25     2 cq_next fixed bin (18),				/* next free word in circular queue */
 21    26     2 cq_free fixed bin (18),				/* number of free words in circular queue */
 21    27     2 cq_max_size fixed bin (17),			/* size in words of circular_queue */
 21    28     2 cq_lock bit (36),				/* lock for circular buffer */
 21    29     2 circular_queue (0: 1999) fixed bin (18);		/* circular queue that DN7100 writes into */
 21    30 
 21    31 /* END INCLUDE FILE ... uncp_buf.incl.pl1 */
      366 
      367 
      368 init_multiplexer:
      369      entry (a_devx, a_init_info_ptr, a_fnpp, a_code);
      370 
      371 /* This entry is called to initialize data bases preparatory to loading an FNP
      372*   *  In particular, it initializes the appropriate entry in fnp_info, 
      373*   *  uncp_buf, and allocates and initializes PCBs
      374**/
      375 
      376 
      377 	devx = a_devx;
      378 	miip = a_init_info_ptr;
      379 	mii_chan_count = mux_init_info.no_channels;
      380 	pcb_space_ptr = null ();			/* make cleanup safe */
      381 	infop = addr (dn355_data$);
      382 	ttybp = addr (tty_buf$);
      383 	uncpbp = datanet_info.uncp_bufp;		/* UNCP's circular queue */
      384 	lctp = tty_buf.lct_ptr;
      385 
      386 	lcntp = lct.lcnt_ptr;			/* get channel name */
      387 	if length (rtrim (lcnt.names (devx))) ^= 1
      388 	then go to bad_channel;
      389 	my_chan_name = rtrim (lcnt.names (devx));
      390 	call parse_fnp_name_ (my_chan_name, dno);
      391 	if dno < 0				/* unreasonable name */
      392 	then do;
      393 bad_channel:
      394 	     a_code = error_table_$bad_channel;
      395 	     go to init_exit;
      396 	end;
      397 
      398 	fnpp = addr (datanet_info.per_datanet (dno));
      399 	call TRACE ("init_multiplexer");		/* only error trace if bad devx */
      400 
      401 	if my_chan_name ^= fnp_info.fnp_tag
      402 	then go to bad_channel;
      403 	if ^tty_buf.fnp_config_flags (dno)
      404 	then go to bad_channel;
      405 
      406 	call lock$lock_fast (addr (datanet_info.configuration_lock));
      407 						/* noone else can configure */
      408 	if uncpbp ^= null then do;
      409 	     unspec (uncp_buf) = ""b;			/* start by zeroing out everything */
      410  	     uncp_buf.cq_max_size = UNCP_CQ_SIZE;
      411  	     uncp_buf.cq_free = uncp_buf.cq_max_size;	/* Start of the free space */
      412  	     uncp_buf.cq_hbound = uncp_buf.cq_max_size - 1;
      413  						/* The circular queue is a table (0:cq_max_size - 1) */
      414 	end;
      415 
      416 	fnp_info.lcte_ptr = addr (lct.lcte_array (devx));
      417 
      418 	if fnp_info.t_and_d_in_progress		/* lcte will be invalid, but still */
      419 	then do;
      420 	     code = error_table_$io_not_available;
      421 	     go to init_abort;
      422 	end;
      423 
      424 	call assign_channel (code);			/* under config lock */
      425 	if code ^= 0
      426 	then go to init_abort;			/* it may have been deconfigured while we were farting around */
      427 
      428 	call uncp_util$fill_page_table ((fnp_info.fnp_number), code);
      429 	if code ^= 0
      430 	then go to init_abort;			/* IOI has problems? */
      431 
      432 	do i = lbound (fnp_info.hsla_idx, 1) to hbound (fnp_info.hsla_idx, 1);
      433 						/* initialize line-number indexes for HSLA */
      434 	     fnp_info.hsla_idx (i) = -1;
      435 	end;
      436 	do i = lbound (fnp_info.lsla_idx, 1) to hbound (fnp_info.lsla_idx, 1);
      437 						/* now for LSLAs */
      438 	     fnp_info.lsla_idx (i) = -1;
      439 	end;
      440 
      441 
      442 	pcb_space = size (pcb) * mii_chan_count;	/* get enough space for an array of PCBs */
      443 	space_needed = pcb_space + PCB_SIZE_INCR * DCW_LIST_SIZE;
      444 	call tty_space_man$get_space (space_needed, pcb_space_ptr);
      445 	if pcb_space_ptr = null			/* this would be unfortunate */
      446 	then do;
      447 	     a_code = error_table_$noalloc;
      448 	     go to init_abort;
      449 	end;
      450 	n_pcbs, fnp_info.no_of_channels = mii_chan_count;
      451 	pcb_space_ptr -> pcb_array (*).saved_meters_ptr = null ();
      452 
      453 	fnp_info.pcb_array_ptr = pcb_space_ptr;
      454 	fnp_info.dcw_list_array_ptr = addrel (pcb_space_ptr, pcb_space);
      455 
      456 	string (fnp_info.flags) = "0"b;
      457 	prev_la_no = -1;				/* so test will work right the first time */
      458 	old_flag = "1"b;				/* HSLA channels (if any) are always first */
      459 
      460 /*
      461*   * The following code assigns line numbers and sets the adapter indexes
      462*   * It assumes that channels in mux_init_info are sorted in ascending order
      463**/
      464 
      465 	do pcbx = 1 to n_pcbs;
      466 	     pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
      467 	     unspec (pcb) = "0"b;
      468 	     pcb.saved_meters_ptr = null ();		/* for cleanup dept */
      469 	     pcb.devx = mux_init_info.channels (pcbx).devx;
      470 	     lctep = addr (lct.lcte_array (pcb.devx));
      471 	     lcte.subchannel = pcbx;
      472 	     name = mux_init_info.channels (pcbx).name;
      473 	     call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
      474 	     if his_fnp_no ^= dno
      475 	     then do;
      476 		code = error_table_$bad_channel;
      477 		go to init_abort;
      478 	     end;
      479 	     if la_no = LA_7
      480 	     then fnp_info.tandd_pcbx = pcbx;
      481 	     else if (la_no ^= prev_la_no | hsla_flag ^= old_flag)
      482 						/* first subchannel on this adapter */
      483 	     then do;
      484 		if hsla_flag
      485 		then fnp_info.hsla_idx (la_no) = pcbx;
      486 		else fnp_info.lsla_idx (la_no) = pcbx;
      487 		prev_la_no = la_no;
      488 		old_flag = hsla_flag;
      489 	     end;
      490 
      491 	     pcb.subchan = subchan;
      492 	     pcb.is_hsla = hsla_flag;
      493 	     pcb.la_no = bit (bin (la_no, 3), 3);
      494 	     if hsla_flag
      495 	     then pcb.slot_no = bit (bin (subchan, 6), 6);
      496 
      497 /*	     * lsla slot number has to wait for baud rate supplied at bootload time */
      498 
      499 	     on area
      500 		begin;
      501 		     code = error_table_$noalloc;
      502 		     go to init_abort;
      503 		end;
      504 
      505 	     call tty_area_manager$allocate (size (fnp_channel_meters), temp_saved_meters_ptr);
      506 	     pcb.saved_meters_ptr = temp_saved_meters_ptr;
      507 	end;
      508 
      509 	call lock$unlock_fast (addr (datanet_info.configuration_lock));
      510 
      511 
      512 	a_fnpp = fnpp;				/* pass this back */
      513 	a_code = 0;
      514 init_exit:
      515 	return;
      516 
      517 init_abort:
      518 	call TRACE_ERROR ("init_multiplexer", code);
      519 	call lock$unlock_fast (addr (datanet_info.configuration_lock));
      520 	if pcb_space_ptr ^= null
      521 	then do;
      522 	     do pcbx = 1 to n_pcbs;
      523 		pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));
      524 		if pcb.saved_meters_ptr ^= null ()
      525 		then call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
      526 	     end;
      527 	     call tty_space_man$free_space (space_needed, pcb_space_ptr);
      528 	end;
      529 	a_code = code;
      530 	return;
      531 
      532 terminate_multiplexer:
      533      entry (a_fnpp, a_code);
      534 
      535 /* This entry is called after FNP crash or shutdown in order to free PCBs */
      536 
      537 	fnpp = a_fnpp;
      538 	ttybp = addr (tty_buf$);
      539 	infop = addr (dn355_data$);
      540 	locked = "0"b;
      541 	call TRACE ("terminate_multiplexer");
      542 	call lock;
      543 	if code ^= 0
      544 	then go to terminate_return;
      545 
      546 	if fnp_info.bootloading | fnp_info.wired | fnp_info.running
      547 						/* bad time to terminate */
      548 	then code = error_table_$invalid_state;
      549 
      550 	else do;
      551 	     do i = 1 to fnp_info.no_of_channels;
      552 		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));
      553 		if pcb.write_first ^= 0
      554 		then call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
      555 		if pcb.read_first ^= 0
      556 		then call tty_space_man$free_chain ((pcb.devx), INPUT, ptr (ttybp, pcb.read_first));
      557 		call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));
      558 		if pcb.copied_meters_offset ^= 0	/* free this if it's there */
      559 		then do;
      560 		     call tty_space_man$free_space (size (fnp_channel_meters), ptr (ttybp, pcb.copied_meters_offset));
      561 		     pcb.copied_meters_offset = 0;
      562 		end;
      563 	     end;
      564 
      565 	     string (fnp_info.flags) = "0"b;
      566 	     call tty_space_man$free_space (size (pcb) * fnp_info.no_of_channels + PCB_SIZE_INCR * DCW_LIST_SIZE,
      567 		fnp_info.pcb_array_ptr);
      568 	     fnp_info.pcb_array_ptr = null;
      569 	     code = 0;
      570 	end;
      571 	if fnp_info.io_manager_assigned
      572 	then call unassign_channel (code);		/* not deconfigured on us */
      573 	call uncp_util$free_page_table ((fnp_info.fnp_number));
      574 						/* even if we lost the assignment ... */
      575 
      576 	call unlock;
      577 
      578 terminate_return:
      579 	if code ^= 0
      580 	then call TRACE_ERROR ("terminate_multiplexer", code);
      581 	a_code = code;
      582 	return;
      583 
      584 start:
      585      entry (a_fnpp, a_code);
      586 
      587 /* entry to enable an FNP by sending "accept_calls" order */
      588 
      589 	fnpp = a_fnpp;
      590 	infop = addr (dn355_data$);
      591 	call TRACE ("start");
      592 	chanx = 1;				/* this is irrelevant, but will make setup happy */
      593 	call setup;
      594 	if code = 0
      595 	then do;
      596 
      597 /*	     call dn355$send_global_wcd (fnpp, accept_calls, 18,
      598*   bit (bin (bin (rel (addr (tty_buf.free_space)), 18) + tty_buf.absorig, 18), 18));  */
      599 /*   Le Datanet n aime plus les a-call.
      600*   call uncp$send_global_wcd (fnpp, accept_calls, 0, ""b);
      601**/
      602 	     call unlock;				/* setup locked and masked */
      603 	end;
      604 	if code ^= 0
      605 	then call TRACE_ERROR ("start", code);
      606 	a_code = code;
      607 	return;
      608 
      609 
      610 stop:
      611      entry (a_fnpp, a_code);
      612 
      613 /* entry to disable an FNP from further dialups (by sending dont_accept_calls order) */
      614 
      615 	fnpp = a_fnpp;
      616 	infop = addr (dn355_data$);
      617 	call TRACE ("stop");
      618 	chanx = 1;				/* as for start entry */
      619 	call setup;
      620 	if code = 0
      621 	then call unlock;				/* setup masked and locked */
      622 
      623 	if code ^= 0
      624 	then call TRACE_ERROR ("stop", code);
      625 	a_code = code;
      626 	return;
      627 
      628 
      629 shutdown:
      630      entry (a_fnpp, a_code);
      631 
      632 /* This entry simulates an FNP crash; if the FNP is up, all lines will be hung up */
      633 
      634 	infop = addr (dn355_data$);
      635 	fnpp = a_fnpp;
      636 	if fnpp = null ()
      637 	then do;
      638 	     if datanet_info.trace
      639 	     then call syserr (ANNOUNCE, "uncp_multiplexer$shutdown: Called with null fnp_ptr");
      640 	     go to shutdown_return;
      641 	end;
      642 	call TRACE ("shutdown");
      643 	infop = addr (dn355_data$);
      644 
      645 
      646 /* ****************************************************************************************
      647*
      648*   if fnp_info.bootloading | fnp_info.wired	[* stop any pending load *]
      649*   then call uncp_util$abort ((fnp_info.fnp_number));
      650*   else do;
      651*   ************************************************************************* */
      652 
      653 	fnp_info.bootloading = "0"b;			/* ajouter pour dn 7100 */
      654 	locked = "0"b;
      655 	if fnp_info.running				/* if it's up now */
      656 	then do;
      657 	     call lock;
      658 	     call uncp$hangup_fnp_lines ((fnp_info.fnp_number));
      659 	     fnp_info.running = "0"b;
      660 	     call unlock;
      661 	end;
      662 
      663 /*	end;  dn 7100     */
      664 
      665 shutdown_return:
      666 	a_code = 0;
      667 	return;
      668 
      669 
      670 read:
      671      entry (a_fnpp, a_subchan, a_chainp, a_mi_flag, a_code);
      672 
      673 /* this is a dummy entry, uncp never holds input at interrupt time */
      674 
      675 	a_chainp = null;
      676 	a_mi_flag = "0"b;
      677 	a_code = 0;
      678 	return;
      679 
      680 
      681 write:
      682      entry (a_fnpp, a_subchan, a_output_ptr, a_code);
      683 
      684 	fnpp = a_fnpp;
      685 	chanx = a_subchan;
      686 	output_ptr = a_output_ptr;
      687 
      688 	call setup;
      689 	if code ^= 0
      690 	then do;
      691 	     a_code = code;
      692 	     return;
      693 	end;
      694 
      695 /* figure out length of chain */
      696 
      697 	blockp = output_ptr;
      698 	output_length = buffer.tally;			/* to start with */
      699 
      700 	do while (buffer.next ^= 0);
      701 	     blockp = ptr (ttybp, buffer.next);
      702 	     output_length = output_length + buffer.tally;
      703 	end;
      704 
      705 	if pcb.write_last ^= 0			/* existing write chain */
      706 	then do;
      707 	     lastp = ptr (ttybp, pcb.write_last);
      708 	     lastp -> buffer.next = bin (rel (output_ptr));
      709 	end;
      710 
      711 	else pcb.write_first = bin (rel (output_ptr));
      712 
      713 	pcb.write_last = bin (rel (blockp));		/* in any case */
      714 	pcb.write_cnt = pcb.write_cnt + output_length;
      715 
      716 	if pcb.send_output				/* if the FNP is ready for it */
      717 	then call uncp$send_wcd (fnpp, pcbp, accept_direct_output, 0, ""b);
      718 
      719 	code = 0;
      720 write_exit:
      721 	call unlock;
      722 	if code = 0
      723 	then a_output_ptr = null ();			/* so caller will know we took it all */
      724 	a_code = code;
      725 	return;
      726 
      727 control:
      728      entry (a_fnpp, a_subchan, a_order, a_data_ptr, a_code);
      729 
      730 	fnpp = a_fnpp;
      731 	chanx = a_subchan;
      732 	order = a_order;
      733 	data_ptr = a_data_ptr;
      734 
      735 	dumpin, dumpout, set_write_status, get_meters = "0"b;
      736 						/* initialize local variables */
      737 	opcode, alter_type = -1;
      738 	check = "0"b;
      739 
      740 	if order = "read_status"			/* there's never any at this level */
      741 	then do;
      742 	     data_ptr -> rd_stat.input_available = "0"b;
      743 	     a_code = 0;
      744 	     return;
      745 	end;
      746 
      747 	else if order = "hangup"
      748 	then do;
      749 	     mbx_data_len = 0;
      750 	     mbx_data = ""b;
      751 	     opcode = disconnect_this_line;
      752 	end;
      753 
      754 
      755 /*   supprimer pour le dn7100     *****************************************************************
      756*
      757*
      758*   else if order = "wru"
      759*   then do;
      760*   alter_type = Wru;
      761*   alter_data = ""b;
      762*   end;
      763*
      764*   else if order = "interrupt"
      765*   then do;
      766*   alter_type = Break;
      767*   alter_data = ""b;
      768*   end;
      769*
      770*   else if order = "start_xmit_hd" | order = "stop_xmit_hd"
      771*   then do;
      772*   alter_type = Xmit_hold;
      773*   alter_data = "00000000"b || (order = "start_xmit_hd");
      774*   end;
      775*
      776*   else if order = "set_input_message_size"
      777*   then do;
      778*   mbx_data = bit (bin (data_ptr -> based_fb_word, 18), 18);
      779*   opcode = sync_msg_size;
      780*   end;
      781*
      782*   else if order = "line_control"
      783*   then do;
      784*   mbx_data_len = 72;
      785*   mbx_data = data_ptr -> based_bit72;
      786*   opcode = line_control;
      787*   end;
      788*
      789*   else if order = "set_framing_chars"
      790*   then do;
      791*   mbx_data_len = TWO_WORD_LTH;
      792*   mbx_data = data_ptr -> based_bit18;	** two characters are packed in halfword **
      793*   opcode = set_framing_chars;
      794*   end;
      795*
      796*   else if order = "set_delay"
      797*   then do;
      798*   mbx_data_len = TWELVE_WORD_LTH;
      799*   mbx_data = data_ptr -> based_bit108;	** 6 18-bit values **
      800*   opcode = set_delay_table;
      801*   end;
      802*
      803*   ******************************************************************** */
      804 
      805 
      806 	else if order = "abort"			/* i.e., resetread or resetwrite */
      807 	then do;
      808 	     dumpin = substr (data_ptr -> based_bit2, 2, 1);
      809 						/* we'll simply save this info for later */
      810 	     dumpout = substr (data_ptr -> based_bit2, 1, 1);
      811 	end;
      812 
      813 	else if order = "set_line_type"
      814 	then do;
      815 	     mbx_data_len = TWO_WORD_LTH;
      816 	     local_line_type = data_ptr -> based_fb_word;
      817 	     if local_line_type <= 0 | local_line_type > max_line_type
      818 	     then go to order_error;
      819 	     check = "1"b;				/* we'll have to look at PCB (after locking) */
      820 	     opcode = set_line_type;
      821 	end;
      822 
      823 
      824 /*    ************************************************************************
      825*
      826*
      827*   else if order = "dial_out"
      828*   then do;					** we have to convert digits (in char. form) to 6-bit BCD **
      829*   digit_pos = 0;
      830*   do i = 1 to length (data_ptr -> phone_chars);** should never see "X" in phone number **
      831*   next_digit = index ("0123456789XXX!", substr (data_ptr -> phone_chars, i, 1)) - 1;
      832*   ** a value of 13 tells autocall unit to wait for a **
      833*   ** dial tone before asking for another dialing digit **
      834*   if next_digit >= 0
      835*   then if next_digit < REAL_DIGITS | next_digit = SPECIAL_DIGIT
      836*   then do;			** it's actually a digit **
      837*   digit_pos = digit_pos + 1;
      838*   phone_digits (digit_pos) = bit (next_digit, 6);
      839*   end;
      840*   end;
      841*
      842*   phone_no_len = PHONENO_LTH_X * digit_pos;
      843*   opcode = dial;
      844*   check = "1"b;				** special stuff required here too **
      845*   end;
      846*
      847*
      848*   *********************************************************** */
      849 
      850 
      851 	else if order = "listen"
      852 	then do;
      853 	     alter_type = Listen;
      854 	     alter_data = "000000001"b;
      855 	end;
      856 
      857 	else if order = "write_status"
      858 	then set_write_status = "1"b;
      859 
      860 	else if order = "enter_receive"
      861 	then do;
      862 	     mbx_data_len = 0;
      863 	     mbx_data = ""b;
      864 	     opcode = enter_receive;
      865 	end;
      866 
      867 /* ****      ***************************************************************
      868*
      869*
      870*   else if order = "start_negotiated_echo"
      871*   then do;
      872*   mbx_data_len = 36;
      873*   mbx_data =
      874*   bit (fixed (data_ptr -> echo_start_data.ctr, 18), 18)
      875*   || bit (fixed (data_ptr -> echo_start_data.screenleft, 18), 18);
      876*   opcode = start_negotiated_echo;
      877*   end;
      878*   else if order = "set_echnego_break_table"
      879*   then do;
      880*   mbx_data_len = length (unspec (echnego_break_table));
      881*   unspec (echnego_break_table) = ""b;	** Get pads **
      882*   do i = 0 to 7;
      883*   echnego_break_table.bits (i) = substr (data_ptr -> based_bit128, 1 + 16 * i, 16);
      884*   end;
      885*   mbx_data = unspec (echnego_break_table);
      886*   opcode = set_echnego_break_table;
      887*   end;
      888*   else if order = "init_echo_negotiation"
      889*   then do;
      890*   mbx_data_len = 0;
      891*   mbx_data = ""b;
      892*   opcode = init_echo_negotiation;
      893*   end;
      894*   else if order = "stop_negotiated_echo"
      895*   then do;
      896*   mbx_data_len = 0;
      897*   mbx_data = ""b;
      898*   opcode = stop_negotiated_echo;
      899*   end;
      900*   else if order = "input_flow_control_chars"
      901*   then do;
      902*   mbx_data_len = 36;
      903*   if data_ptr -> input_flow_control_info.resume_seq.count = 0
      904*   ** turning it all off **
      905*   then mbx_data = ""b;
      906*   else do;
      907*   mbx_data =
      908*   unspec (substr (data_ptr -> input_flow_control_info.suspend_seq.chars, 1, 1))
      909*   || unspec (substr (data_ptr -> input_flow_control_info.resume_seq.chars, 1, 1))
      910*   || data_ptr -> input_flow_control_info.timeout;
      911*   if data_ptr -> input_flow_control_info.suspend_seq.count = 0
      912*   then substr (mbx_data, 1, 9) = "0"b;	** don't send suspend char if there isn't one **
      913*   end;
      914*   opcode = input_fc_chars;
      915*   end;
      916*   else if order = "output_flow_control_chars"
      917*   then do;
      918*   mbx_data_len = 36;
      919*   if data_ptr -> output_flow_control_info.suspend_or_etb_seq.count = 0
      920*   ** no chars **
      921*   then mbx_data = "0"b;
      922*   else mbx_data =
      923*   unspec (substr (data_ptr -> output_flow_control_info.suspend_or_etb_seq.chars, 1, 1))
      924*   || unspec (substr (data_ptr -> output_flow_control_info.resume_or_ack_seq.chars, 1, 1))
      925*   || data_ptr -> output_flow_control_info.block_acknowledge;
      926*   opcode = output_fc_chars;
      927*   end;
      928*
      929*   else if order = "copy_meters"
      930*   then do;
      931*   opcode = report_meters;
      932*   check = "1"b;
      933*   end;
      934*
      935*   else if order = "get_meters"
      936*   then do;
      937*   ret_meters_ptr = data_ptr -> get_comm_meters_info.parent_ptr;
      938*   if ret_meters_ptr = null ()
      939*   then return;
      940*   else if ret_meters_ptr -> fnp_chan_meter_struc.version ^= FNP_CHANNEL_METERS_VERSION_1
      941*   then do;
      942*   a_code = error_table_$unimplemented_version;
      943*   return;
      944*   end;
      945*
      946*   else get_meters = "1"b;
      947*   end;
      948*
      949*   else if order = "tandd_attach"
      950*   then do;					** simulate a dialup without bothering the FNP (channel is hung up already) **
      951*   call setup;
      952*   if code ^= 0
      953*   then do;
      954*   a_code = code;
      955*   return;
      956*   end;
      957*
      958*   if pcb.listen | pcb.dialed		** can't have this **
      959*   then do;
      960*   call unlock;
      961*   a_code = error_table_$resource_not_free ;
      962*   return;
      963*   end;
      964*
      965*   pcb.dialed = "1"b;
      966*   pcb.tandd_attached = "1"b;
      967*   unspec (dialup_info) = ""b;
      968*   dialup_info.baud_rate = BAUD_1200;		** just so it's something **
      969*   dialup_info.line_type = LINE_ASCII;	** make everyone's life easier **
      970*   dialup_info.max_buf_size = DIAL_BUF;		** COLTS wants small buffers **
      971*   call channel_manager$interrupt ((pcb.devx), DIALUP, unspec (dialup_info));
      972*   call unlock;
      973*   a_code = 0;
      974*   return;
      975*   end;
      976*
      977*
      978*   **************************************************************** */
      979 
      980 
      981 	else do;
      982 order_error:
      983 	     a_code = error_table_$undefined_order_request;
      984 	     return;
      985 	end;
      986 
      987 	code = 0;
      988 	call setup;
      989 	if code ^= 0
      990 	then do;
      991 	     a_code = code;
      992 	     return;
      993 	end;
      994 
      995 	if opcode = disconnect_this_line		/* hangup */
      996 	then do;
      997 	     pcb.listen, pcb.tandd_attached = "0"b;
      998 	end;
      999 
     1000 
     1001 /* ************************************************************************
     1002*
     1003*   if opcode = start_negotiated_echo & (pcb.write_first ^= 0
     1004*   ** We have queued output **
     1005*   | pcb.output_mbx_pending)
     1006*   then do;					** The FNP has not take the mbx. **
     1007*   ** handler re-do it when he sees this. **
     1008*   call unlock;
     1009*   a_code = error_table_$invalid_write;
     1010*   return;
     1011*   end;
     1012*
     1013*
     1014*   ************************************************************** */
     1015 
     1016 
     1017 	if alter_type ^= -1				/* alter_parameters required */
     1018 	then do;
     1019 	     if alter_type = Listen
     1020 	     then do;				/* need to tell it buffer size */
     1021 
     1022 /*		alter_data = alter_data || fnp_buf_size ();  pour le dn 7100      */
     1023 
     1024 		pcb.listen = "1"b;
     1025 	     end;
     1026 
     1027 	     mbx_data_len = length (alter_data) + 9;	/* 9 bits for subop type */
     1028 	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
     1029 	     opcode = alter_parameters;
     1030 	end;
     1031 
     1032 	if opcode ^= -1				/* we do have to send the FNP something */
     1033 	then do;
     1034 	     if check				/* anything special about it */
     1035 	     then do;
     1036 		if opcode = set_line_type		/* make sure this is OK */
     1037 		then if pcb.listen
     1038 		     then do;			/* it isn't */
     1039 			call unlock;
     1040 			go to order_error;
     1041 		     end;
     1042 
     1043 		     else do;
     1044 			mbx_data = bit (bin (local_line_type, 18), 18);
     1045 			do i = 1 to n_sync_line_types while (local_line_type ^= sync_line_type (i));
     1046 			end;
     1047 
     1048 			pcb.sync_line = (i <= n_sync_line_types);
     1049 			opcode = alter_parameters;
     1050 		     end;
     1051 
     1052 
     1053 /* **************************************************************************
     1054*
     1055*
     1056*   else if opcode = dial		** in this case we have to supply buffer size first **
     1057*   then do;				** because no listen was done **
     1058*   mbx_data_len = 36;
     1059*   alter_data = bit (bin (Set_buffer_size, 9), 9) || "000000001"b;
     1060*   mbx_data = alter_data || fnp_buf_size ();
     1061*   call dn355$send_wcd (fnpp, pcbp, alter_parameters, mbx_data_len, mbx_data);
     1062*
     1063*   mbx_data_len = phone_no_len;
     1064*   mbx_data_long = string (phone_digits);
     1065*   end;
     1066*   else if opcode = report_meters
     1067*   then do;
     1068*   call tty_space_man$get_space (size (fnp_channel_meters), meter_ptr);
     1069*   ** get a buffer for the FNP meters **
     1070*   if meter_ptr = null ()		** couldn't get it **
     1071*   then do;
     1072*   call unlock;
     1073*   a_code = error_table_$noalloc;
     1074*   return;
     1075*   end;
     1076*
     1077*   pcb.copied_meters_offset = bin (rel (meter_ptr), 18);
     1078*   mbx_data = bit (bin (tty_buf.absorig + pcb.copied_meters_offset, 18), 18);
     1079*   mbx_data_len = 18;
     1080*   end;
     1081*
     1082*   ********************************************************************** */
     1083 
     1084 
     1085 	     end;
     1086 	     if opcode ^= alter_parameters
     1087 	     then call uncp$send_wcd (fnpp, pcbp, opcode, mbx_data_len, mbx_data);
     1088 	end;
     1089 
     1090 	else do;
     1091 
     1092 /*	     if dumpin
     1093*   then call uncp$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpinput, 9), 9)); pour le dn 7100  */
     1094 
     1095 	     if dumpout
     1096 	     then do;				/* first get rid of any ring 0 output */
     1097 		if pcb.write_first ^= 0
     1098 		then do;
     1099 		     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));
     1100 		     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;
     1101 		end;
     1102 
     1103 
     1104 /*		call uncp$send_wcd (fnpp, pcbp, alter_parameters, 9, bit (bin (Dumpoutput, 9), 9));   pour le dn 7100     */
     1105 
     1106 
     1107 		if pcb.end_frame
     1108 		then do;
     1109 		     pcb.end_frame = "0"b;
     1110 		     if pcb.send_output
     1111 		     then call channel_manager$interrupt ((pcb.devx), SEND_OUTPUT, ""b);
     1112 		end;
     1113 	     end;
     1114 
     1115 	     if set_write_status
     1116 	     then opend = (pcb.write_first ^= 0);	/* this has to be in automatic, return structure isn't wired */
     1117 
     1118 /* **************************************************************************
     1119*
     1120*   if get_meters
     1121*   then do;
     1122*   call get_fnp_meters ("0"b);
     1123*   call unlock;
     1124*
     1125*   if code = 0
     1126*   then ret_meters_ptr -> fnp_chan_meter_struc.synchronous = pcb.sync_line;
     1127*   if unspec (fnp_meters_ptr -> fnp_channel_meters) = "0"b
     1128*   then code = error_table_$no_channel_meters;
     1129*   else do;
     1130*   ret_meters_ptr -> fnp_chan_meter_struc.current_meters = fnp_meters_ptr -> fnp_channel_meters;
     1131*   ret_meters_ptr -> fnp_chan_meter_struc.saved_meters = pcb.saved_meters_ptr -> fnp_channel_meters;
     1132*
     1133*   call tty_space_man$free_space (size (fnp_channel_meters), fnp_meters_ptr);
     1134*   end;
     1135*   end;
     1136*   ********************************************************************* */
     1137 	end;
     1138 
     1139 	call unlock;
     1140 	if set_write_status
     1141 	then data_ptr -> wr_stat.output_pending = opend;
     1142 	a_code = code;
     1143 
     1144 	return;
     1145 
     1146 check_modes:
     1147      entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);
     1148 
     1149 /* this entry is used to determine if this multiplexer understands or accepts a given set of modes */
     1150 
     1151 	fnpp = a_fnpp;
     1152 	chanx = a_subchan;
     1153 	mclp = a_mode_list_ptr;
     1154 	if mcl.version ^= mcl_version_2
     1155 	then do;
     1156 	     a_code = error_table_$unimplemented_version;
     1157 	     return;
     1158 	end;
     1159 
     1160 	call setup;				/* now we need PCB pointer */
     1161 	if code ^= 0
     1162 	then do;
     1163 	     a_code = code;
     1164 	     return;
     1165 	end;
     1166 
     1167 	do modex = 1 to mcl.n_entries;
     1168 	     mclep = addr (mcl.entries (modex));
     1169 
     1170 	     mode_name = substr (mcle.mode_name, 1, 8);
     1171 	     mode_on = mcle.mode_switch;
     1172 
     1173 	     do i = 1 to hbound (good_modes, 1) while (mode_name ^= good_modes (i));
     1174 	     end;
     1175 
     1176 	     if i <= hbound (good_modes, 1)		/* tree */
     1177 						/* it's one of the ones we always recognize */
     1178 	     then mcle.mpx_mode = "1"b;
     1179 	     else do;
     1180 		do i = 1 to hbound (async_only_modes, 1) while (mode_name ^= async_only_modes (i));
     1181 		end;
     1182 
     1183 		if i > hbound (async_only_modes, 1)	/* we've never heard of this one at all */
     1184 		then mcle.mpx_mode = "0"b;
     1185 		else do;
     1186 		     mcle.mpx_mode = ^pcb.sync_line;	/* this mode is meaningful for asynchronous lines only */
     1187 
     1188 		     do i = 1 to hbound (full_dpx_modes, 1) while (mode_name ^= full_dpx_modes (i));
     1189 		     end;
     1190 
     1191 		     if (mode_name = "no_outp" | mode_name = "8bit" | mode_name = "oddp") & mode_on
     1192 		     then if ^pcb.is_hsla
     1193 			then go to bad_mode;
     1194 
     1195 		     if i <= hbound (full_dpx_modes, 1) /* if this was a mode requiring full duplex capability */
     1196 		     then if mode_on
     1197 			then if pcb.line_type ^= LINE_ASCII & pcb.line_type ^= LINE_ASYNC1
     1198 				& pcb.line_type ^= LINE_ASYNC2 & pcb.line_type ^= LINE_ASYNC3
     1199 			     then do;
     1200 bad_mode:
     1201 				if mcle.force
     1202 				then mcle.mpx_mode = "0"b;
     1203 				else do;
     1204 				     code = error_table_$bad_mode;
     1205 				     mcle.error = "1"b;
     1206 				end;
     1207 			     end;
     1208 
     1209 		end;
     1210 	     end;
     1211 	end;
     1212 
     1213 	call unlock;				/* setup locked */
     1214 	a_code = code;
     1215 	return;
     1216 
     1217 set_modes:
     1218      entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);
     1219 
     1220 /* this entry sets a specified set of mode (probably by calling uncp$send_wcd) */
     1221 
     1222 	fnpp = a_fnpp;
     1223 	chanx = a_subchan;
     1224 	mclp = a_mode_list_ptr;
     1225 	if mcl.version ^= mcl_version_2
     1226 	then do;
     1227 	     a_code = error_table_$unimplemented_version;
     1228 	     return;
     1229 	end;
     1230 
     1231 	call setup;
     1232 	if code ^= 0
     1233 	then do;
     1234 	     a_code = code;
     1235 	     return;
     1236 	end;
     1237 
     1238 	hndlquit_set = "0"b;
     1239 	string (mode_set) = "0"b;			/* nothing set yet */
     1240 
     1241 	do modex = 1 to mcl.n_entries;
     1242 	     mclep = addr (mcl.entries (modex));
     1243 	     if mcle.mpx_mode			/* if this is one we're interested in */
     1244 	     then call process_mode (mcle.mode_name, mcle.mode_switch);
     1245 	end;
     1246 
     1247 	if mcl.init
     1248 	then do;					/* if "init" we must turn off the ones that weren't mentioned */
     1249 	     if ^hndlquit_set
     1250 	     then call process_mode ("hndlquit", "0"b);
     1251 
     1252 	     do modex = 1 to hbound (async_only_modes, 1);
     1253 		if ^mode_set (modex)
     1254 		then call process_mode (async_only_modes (modex), "0"b);
     1255 	     end;
     1256 	end;
     1257 
     1258 	call unlock;
     1259 	a_code = code;
     1260 	return;
     1261 
     1262 
     1263 
     1264 get_modes:
     1265      entry (a_fnpp, a_subchan, a_modes, a_code);
     1266 
     1267 /* this is a dummy, we don't keep records of modes at this level */
     1268 
     1269 	a_modes = "";
     1270 	a_code = 0;
     1271 	return;
     1272 
     1273 priv_control:
     1274      entry (a_fnpp, a_order, a_data_ptr, a_code);
     1275 
     1276 /* entry for privileged global orders */
     1277 
     1278 	fnpp = a_fnpp;
     1279 	order = a_order;
     1280 	data_ptr = a_data_ptr;
     1281 
     1282 
     1283 /*  Supprimer pour DN_7100 *****************************************************
     1284*
     1285*
     1286*   if order = "dump_fnp"
     1287*   then do;
     1288*   call setup_fnp;
     1289*   if code ^= 0
     1290*   then do;
     1291*   a_code = code;
     1292*   return;
     1293*   end;
     1294*
     1295*   locked = "0"b;
     1296*   call send_global (dump_mem);
     1297*   if code ^= 0
     1298*   then go to end_dump_mem;
     1299*
     1300*   ** send_global will wait; come back here after notify **
     1301*
     1302*   n_fnp_words = dump_fnp_info.fnp_len;
     1303*   dump_fnp_info.bufp -> fnp_data = fnp_dump_ptr -> fnp_data;
     1304*
     1305*   end_dump_mem:
     1306*   if code ^= error_table_$timeout			** else we have to abandon the buffer **
     1307*   then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
     1308*   ** this was allocated by setup_fnp **
     1309*   ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1310*   end;
     1311*
     1312*   else if order = "get_meters"
     1313*   then do;
     1314*   fnp_meterp = data_ptr -> get_comm_meters_info.subchan_ptr;
     1315*   if fnp_meterp ^= null
     1316*   then do;
     1317*   if fnp_meters.version ^= FNP_METERS_VERSION_1
     1318*   then code = error_table_$unimplemented_version;
     1319*   else do;
     1320*   ttybp = addr (tty_buf$);		** we'll need this **
     1321*   call lock;
     1322*   call get_fnp_meters ("1"b);
     1323*
     1324*   if code = 0
     1325*   then do;
     1326*   fnp_meters.n_channels = fnp_info.no_of_channels;
     1327*   fnp_meters.output_mbx_in_use_cum = fnp_info.cumulative_mbx_in_use;
     1328*   fnp_meters.output_mbx_updates = fnp_info.mbx_in_use_updated;
     1329*   fnp_meters.output_mbx_unavailable = fnp_info.mbx_unavailable;
     1330*   fnp_meters.max_output_mbx_in_use = fnp_info.max_mbx_in_use;
     1331*   fnp_meters.queue_entries_made = fnp_info.q_entries_made;
     1332*   fnp_meters.input_rejects = fnp_info.input_reject_count;
     1333*   fnp_meters.processed_from_q = fnp_info.processed_from_q;
     1334*   fnp_meters.fnp_channel_locked = fnp_info.fnp_channel_locked;
     1335*   fnp_meters.input_data_transactions = fnp_info.input_data_transactions;
     1336*   fnp_meters.output_data_transactions = fnp_info.output_data_transactions;
     1337*   fnp_meters.input_control_transactions = fnp_info.input_control_transactions;
     1338*   fnp_meters.output_control_transactions = fnp_info.output_control_transactions;
     1339*   fnp_meters.fnp_space_restricted_output = fnp_info.fnp_space_restricted_output;
     1340*   fnp_meters.fnp_mem_size = fnp_info.fnp_mem_size;
     1341*   fnp_meters.iom_number = fnp_info.iom_number;
     1342*   fnp_meters.iom_chan_no = fnp_info.iom_chan_no;
     1343*   end;
     1344*
     1345*   call unlock;
     1346*   if unspec (fnp_meters_ptr -> fnp_global_meters) = "0"b
     1347*   then code = error_table_$no_channel_meters;
     1348*   else data_ptr -> get_comm_meters_info.subchan_ptr -> fnp_meters.from_fnp =
     1349*   fnp_meters_ptr -> fnp_global_meters;
     1350*
     1351*   call tty_space_man$free_space (size (fnp_global_meters), fnp_meters_ptr);
     1352*
     1353*   lctep = fnp_info.lcte_ptr;	** since we don't call channel_manager, **
     1354*   lcmp = data_ptr -> get_comm_meters_info.logical_chan_ptr;
     1355*   ** we have to copy logical channel data ourselves **
     1356*   if lcmp ^= null ()
     1357*   then do;
     1358*   lcmp -> logical_chan_meters.current_meters = lcte.meters;
     1359*   unspec (lcmp -> logical_chan_meters.saved_meters) = "0"b;
     1360*   ** no saved meters for an FNP **
     1361*   end;
     1362*   end;
     1363*   end;
     1364*   end;
     1365*
     1366*   *********************************************************************** */
     1367 
     1368 
     1369 	code = error_table_$undefined_order_request;
     1370 
     1371 	a_code = code;
     1372 	return;
     1373 
     1374 hpriv_control:
     1375      entry (a_fnpp, a_order, a_data_ptr, a_code);
     1376 
     1377 /* entry for highly-privileged global orders */
     1378 
     1379 dcl  1 arg_dump aligned based (data_ptr),
     1380        2 seg_ptr ptr,
     1381        2 uncp_no fixed bin,
     1382        2 uncp_type fixed bin,
     1383        2 uncp_mem_size fixed bin;
     1384 
     1385 	fnpp = a_fnpp;
     1386 
     1387 	order = a_order;
     1388 	data_ptr = a_data_ptr;
     1389 	locked = "0"b;
     1390 	code = 0;
     1391 
     1392 
     1393 	if order = "load"
     1394 	then call uncp_util$load ((fnp_info.fnp_number), data_ptr, code);
     1395 
     1396 	else if order = "dump"
     1397 	then call uncp_util$fdump (arg_dump.uncp_no, arg_dump.uncp_type, arg_dump.uncp_mem_size, arg_dump.seg_ptr, code);
     1398 
     1399 	else if order = "abort"
     1400 	then call uncp_util$abort ((fnp_info.fnp_number), code);
     1401 
     1402 	else if order = "dial"
     1403 	then do;
     1404 	     call lock;
     1405 	     if code ^= 0
     1406 	     then go to hpriv_exit;
     1407 	     mbx_data = data_ptr -> based_bit72;
     1408 	     call uncp$send_global_wcd (fnpp, dial, CHAR_72, mbx_data);
     1409 	     call unlock;
     1410 	     code = 0;
     1411 	end;
     1412 
     1413 
     1414 
     1415 /*      Supprimer pour le DN_7100 *******************************************
     1416*
     1417*   if order = "patch_fnp"
     1418*   then do;
     1419*   call setup_fnp;
     1420*   if code ^= 0
     1421*   then do;
     1422*   a_code = code;
     1423*   return;
     1424*   end;
     1425*   n_fnp_words = dump_fnp_data.fnp_len;
     1426*   sourcep = dump_fnp_info.bufp;
     1427*
     1428*   fnp_dump_ptr -> fnp_data = sourcep -> fnp_data;
     1429*   call syserr (LOG_AND_PRINT, "patching FNP ^a for ^a:", fnp_info.fnp_tag, pds$process_group_id);
     1430*   ** tell operator about it **
     1431*
     1432*   temp_addr = dump_fnp_data.fnp_addr;
     1433*   do i = 1 to dump_fnp_data.fnp_len;
     1434*   call syserr (LOG_AND_PRINT, "^6w from ^6.3b to ^6.3b", temp_addr,
     1435*   dump_fnp_info.old_value_ptr -> fnp_data (i), dump_fnp_info.bufp -> fnp_data (i));
     1436*   temp_addr = temp_addr + 1;
     1437*   end;
     1438*
     1439*   call send_global (patch_mem);		** send it off and wait **
     1440*   if code ^= error_table_$timeout			** else we have to abandon the buffer **
     1441*   then call tty_space_man$free_space (dump_patch_space, fnp_dump_ptr);
     1442*   ** this was allocated by setup_fnp **
     1443*   ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1444*   end;
     1445*
     1446*   else if order = "fnp_break"
     1447*   then do;
     1448*   call setup_fnp;
     1449*   if code ^= 0
     1450*   then do;
     1451*   a_code = code;
     1452*   return;
     1453*   end;
     1454*   fnp_break_data.action = fnp_break_info.action;
     1455*   ** copy info **
     1456*   fnp_break_data.fnp_addr = fnp_break_info.fnp_addr;
     1457*   fnp_break_data.flags = substr (fnp_break_info.flags, 1, 18);
     1458*   name = fnp_break_info.chan_name;
     1459*   if name = ""
     1460*   then fnp_break_data.lineno = -1;		** no line, i.e. any line **
     1461*   else do;
     1462*   call name_to_pcb (name);
     1463*   if code ^= 0
     1464*   then do;
     1465*   a_code = code;
     1466*   return;
     1467*   end;
     1468*   fnp_break_data.lineno = bin (string (pcb.line_number));
     1469*   end;
     1470*
     1471*   mbx_data = addr (fnp_break_data) -> based_bit72;
     1472*   if ^locked
     1473*   then call lock;
     1474*   if code = 0
     1475*   then do;
     1476*   call dn355$send_global_wcd (fnpp, fnp_break, 72, mbx_data);
     1477*   call unlock;
     1478*   end;
     1479*   end;
     1480*
     1481*   else if order = "enable_breakall_mode"
     1482*   then ;
     1483*
     1484*   else if order = "disable_breakall_mode"
     1485*   then ;
     1486*
     1487*   ******************************************************************** */
     1488 
     1489 
     1490 	else code = error_table_$undefined_order_request;
     1491 
     1492 hpriv_exit:
     1493 	a_code = code;
     1494 	return;
     1495 
     1496 fnp_lock:
     1497      entry (a_fnpp, a_code);				/* Non-wired lock entry */
     1498 
     1499 	fnpp = a_fnpp;
     1500 	call lock;
     1501 	a_code = code;
     1502 	return;
     1503 
     1504 fnp_unlock:
     1505      entry (a_fnpp);
     1506 
     1507 	fnpp = a_fnpp;
     1508 	mylock = "0"b;
     1509 	locked = "1"b;
     1510 	call unlock;
     1511 	return;
     1512 
     1513 setup:
     1514      proc;
     1515 
     1516 /* initial setup for per-channel stuff */
     1517 
     1518 
     1519 	code = 0;					/* innocent until proven guilty */
     1520 	ttybp = addr (tty_buf$);
     1521 	infop = addr (dn355_data$);
     1522 	locked, queue_locked = "0"b;
     1523 	call lock;
     1524 	if code ^= 0
     1525 	then return;
     1526 
     1527 	if fnp_info.running
     1528 	then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (chanx));
     1529 	else do;
     1530 	     call unlock;
     1531 	     code = error_table_$fnp_down;
     1532 	     return;
     1533 	end;
     1534 
     1535 	if pcb.copied_meters_ready			/* dn355 left them for us */
     1536 	then if ^lcte.locked_for_interrupt		/* make sure we're on call side */
     1537 	     then call save_copied_meters;
     1538 
     1539 	return;
     1540      end setup;
     1541 
     1542 /*   Supprimer pour l Datanet 7100.   *****************************************
     1543*
     1544*   setup_fnp:
     1545*   proc;
     1546*
     1547*   dcl  (fnp_address, fnp_len) fixed bin;
     1548*
     1549*   [* this procedure is used instead of setup for privileged global orders *]
     1550*
     1551*   if fnpp = null ()
     1552*   then go to setup_fnp_down;
     1553*   code = 0;
     1554*   if fnp_info.mbx_pt = null ()			[* this one isn't configured *]
     1555*   | ^fnp_info.running			[* or it isn't up *]
     1556*   then do;
     1557*   setup_fnp_down:
     1558*   code = error_table_$fnp_down;
     1559*   return;
     1560*   end;
     1561*
     1562*   ttybp = addr (tty_buf$);
     1563*
     1564*   if order = "fnp_break"
     1565*   then return;				[* done if break order *]
     1566*   if fnp_info.dump_patch_disabled
     1567*   then do;
     1568*   code = error_table_$timeout;
     1569*   return;
     1570*   end;
     1571*
     1572*   fnp_address = dump_fnp_info.fnp_address;
     1573*   fnp_len = dump_fnp_info.fnp_len;
     1574*   if order = "dump_fnp"
     1575*   then do;					[* check dump params *]
     1576*   if fnp_len <= 0 | fnp_len > 64
     1577*   then do;
     1578*   bad_fnp_len:
     1579*   code = error_table_$buffer_big;
     1580*   return;
     1581*   end;
     1582*   end;
     1583*   else if order = "patch_fnp"
     1584*   then if fnp_len <= 0 | fnp_len > 32
     1585*   then go to bad_fnp_len;
     1586*
     1587*   if (fnp_address < 0) | ((fnp_address + fnp_len) > fnp_info.fnp_mem_size)
     1588*   then do;
     1589*   code = error_table_$dev_offset_out_of_bounds;
     1590*   return;
     1591*   end;
     1592*
     1593*   if ^stac (addr (fnp_info.dump_patch_lock), pds$processid)
     1594*   [* lock the dump_patch function *]
     1595*   then do;					[* if possible *]
     1596*   code = error_table_$seglock;
     1597*   return;
     1598*   end;
     1599*
     1600*   dump_patch_space = divide (fnp_len + 1, 2, 17, 0);
     1601*   call tty_space_man$get_space (dump_patch_space, fnp_dump_ptr);
     1602*   if fnp_dump_ptr = null			[* couldn't get the space *]
     1603*   then do;
     1604*   code = error_table_$noalloc;
     1605*   ignore = stacq (fnp_info.dump_patch_lock, "0"b, pds$processid);
     1606*   return;
     1607*   end;
     1608*
     1609*   dump_patch_time = clock ();
     1610*   fnp_info.dump_patch_in_progress = "1"b;
     1611*   dump_fnp_data.abs_addr = bin (rel (fnp_dump_ptr)) + tty_buf.absorig;
     1612*   dump_fnp_data.fnp_addr = fnp_address;
     1613*   dump_fnp_data.fnp_len = fnp_len;
     1614*   return;
     1615*
     1616*   end setup_fnp;
     1617*   **************************************************************** */
     1618 
     1619 save_copied_meters:
     1620      proc;
     1621 
     1622 /* internal procedure called  to pick up copied meters left in tty_buf by FNP */
     1623 
     1624 dcl  copied_meters_ptr ptr;
     1625 
     1626 	if pcb.copied_meters_offset ^= 0		/* make sure it's legit */
     1627 	then do;
     1628 	     copied_meters_ptr = ptr (ttybp, pcb.copied_meters_offset);
     1629 
     1630 /* zero out pad fields, which contain random junk (possibly input) from the FNP */
     1631 
     1632 	     if pcb.sync_line
     1633 	     then copied_meters_ptr -> fnp_sync_meters.pad (*) = 0;
     1634 	     else copied_meters_ptr -> fnp_async_meters.pad (*) = 0;
     1635 	     pcb.saved_meters_ptr -> fnp_channel_meters = copied_meters_ptr -> fnp_channel_meters;
     1636 	     call tty_space_man$free_space (size (fnp_channel_meters), copied_meters_ptr);
     1637 						/* through with buffer now */
     1638 	     pcb.copied_meters_offset = 0;
     1639 	     pcb.copied_meters_ready = "0"b;
     1640 	end;
     1641 
     1642 	return;
     1643      end save_copied_meters;
     1644 
     1645 process_mode:
     1646      proc (mode_name, mode_on);
     1647 
     1648 dcl  mode_name char (*);
     1649 dcl  mode_on bit (1);
     1650 dcl  mode_name_index fixed bin;
     1651 
     1652 	alter_data = "00000000"b || mode_on;
     1653 
     1654 	if mode_name = "hndlquit"
     1655 	then do;
     1656 	     alter_type = Hndlquit;
     1657 	     pcb.hndlquit = mode_on;
     1658 	     hndlquit_set = "1"b;
     1659 	end;
     1660 
     1661 	else if mode_name = "breakall"
     1662 	then do;
     1663 	     alter_type = Breakall;
     1664 	     pcb.extra_nl = ^mode_on;
     1665 	end;
     1666 
     1667 	else if ^pcb.sync_line			/* if we haven't already decided what to do */
     1668 	then do;
     1669 	     if mode_name = "blk_xfer" | mode_name = "iflow"
     1670 						/* special stuff here */
     1671 	     then do;
     1672 		if mode_name = "blk_xfer"
     1673 		then do;
     1674 		     mode_name_index = BLK_XFER_INDEX;
     1675 		     alter_type = Block_xfer;
     1676 		end;
     1677 		else do;
     1678 		     mode_name_index = IFLOW_INDEX;
     1679 		     alter_type = Input_flow_control;
     1680 		end;
     1681 
     1682 		if mode_on
     1683 		then do;				/* we have to tell it buffer sizes */
     1684 		     chars_per_sec = divide (pcb.baud_rate, 10, 17, 0);
     1685 		     base_len, block_len = divide (chars_per_sec, buf_per_second, 17, 0);
     1686 						/* and 1/2 second thereafter */
     1687 		end;
     1688 		else do;
     1689 		     base_len = BASE_LTH;
     1690 		     block_len = 0;
     1691 		end;
     1692 
     1693 		alter_data = alter_data || bit (bin (base_len, 18), 18) || bit (bin (block_len, 18), 18);
     1694 		mode_set (mode_name_index) = "1"b;
     1695 	     end;
     1696 
     1697 	     else do;
     1698 		do i = 1 to hbound (mode_alter_types, 1) while (mode_name ^= async_only_modes (i));
     1699 		end;				/* note that blk_xfer is the last async_mode */
     1700 
     1701 		if i > hbound (mode_alter_types, 1)
     1702 		then code = error_table_$bad_mode;
     1703 
     1704 		else do;
     1705 		     alter_type = mode_alter_types (i);
     1706 		     mode_set (i) = "1"b;		/* this one is set now */
     1707 		end;
     1708 	     end;
     1709 	end;
     1710 
     1711 	if code = 0
     1712 	then do;
     1713 	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;
     1714 
     1715 /*   ajouter pour le Datanet 7100       */
     1716 
     1717 	     if alter_type = Lfecho
     1718 	     then pcb.lfecho = mode_on;
     1719 
     1720 	     if alter_type = Fullduplex & mode_on = "0"b
     1721 	     then code = error_table_$action_not_performed;
     1722 
     1723 /*   fin  d insertion        */
     1724 
     1725 /*	     call uncp$send_wcd (fnpp, pcbp, alter_parameters, length (alter_data) + 9, mbx_data);    */
     1726 	end;
     1727 	return;
     1728      end;
     1729 
     1730 /*     Supprimer pour le Datanet 7100   *************************************************
     1731*
     1732*
     1733*   send_global:
     1734*   proc (opcode);
     1735*
     1736*   [* this procedure calls dn355$send_global_wcd for the dump_fnp and patch_fnp orders *]
     1737*
     1738*   dcl  opcode fixed bin (8);
     1739*
     1740*   call pxss$addevent (FNP_DUMP_PATCH_EVENT);	[* so we'll be able to wait *]
     1741*   mbx_data = addr (dump_fnp_data) -> based_bit72;
     1742*   call lock;
     1743*   if code ^= 0
     1744*   then return;
     1745*
     1746*   call uncp$send_global_wcd (fnpp, opcode, 72, mbx_data);
     1747*   call unlock;
     1748*
     1749*   call pxss$wait;				[* mustn't do anything till it's done *]
     1750*
     1751*   do while (fnp_info.dump_patch_in_progress);	[* didn't complete yet *]
     1752*   if ^fnp_info.running			[* FNP crashed out from under us *]
     1753*   then code = error_table_$fnp_down;
     1754*
     1755*   else if clock () - dump_patch_time > DUMP_PATCH_LIMIT
     1756*   [* time's up! *]
     1757*   then do;
     1758*   code = error_table_$timeout;			[* can this operation *]
     1759*   fnp_info.dump_patch_disabled = "1"b;
     1760*   fnp_info.dump_patch_in_progress = "0"b;
     1761*   call syserr (LOG_AND_PRINT, "fnp_multiplexer: ^[dump^;patch^]_fnp order to FNP ^a timed out.",
     1762*   opcode = dump_mem, fnp_info.fnp_tag);
     1763*   end;
     1764*
     1765*   else do;				[* must be someone else's notify *]
     1766*   call pxss$addevent (FNP_DUMP_PATCH_EVENT);
     1767*   if fnp_info.dump_patch_in_progress	[* make sure it still hasn't happened *]
     1768*   then call pxss$wait;
     1769*   else call pxss$delevent (FNP_DUMP_PATCH_EVENT);
     1770*   [* never mind, it's done *]
     1771*   end;
     1772*
     1773*   end;
     1774*
     1775*   return;					[* all right, we're done *]
     1776*
     1777*   end send_global;
     1778*
     1779*
     1780*
     1781*   get_fnp_meters:
     1782*   proc (global);
     1783*
     1784*   [* subroutine to issue request for meters from FNP and wait for them to arrive *]
     1785*
     1786*   dcl  global bit (1) parameter;			[* indicates whether subchannel or whole FNP *]
     1787*   dcl  space_size fixed bin;
     1788*   dcl  fnp_meter_wait_start fixed bin (71);
     1789*
     1790*   if fnp_info.dump_patch_disabled
     1791*   then do;
     1792*   code = error_table_$timeout;			[* don't even try *]
     1793*   return;
     1794*   end;
     1795*
     1796*   if global
     1797*   then space_size = size (fnp_global_meters);
     1798*   else space_size = size (fnp_channel_meters);
     1799*
     1800*   call tty_space_man$get_space (space_size, fnp_meters_ptr);
     1801*   if fnp_meters_ptr = null ()
     1802*   then do;
     1803*   code = error_table_$noalloc;
     1804*   return;
     1805*   end;
     1806*
     1807*   mbx_data = bit (bin (tty_buf.absorig + bin (rel (fnp_meters_ptr)), 18), 18);
     1808*   call pxss$addevent (FNP_METER_EVENT);
     1809*   fnp_meter_wait_start = clock ();
     1810*
     1811*   if global					[* it's for whole FNP *]
     1812*   then do;
     1813*   if fnp_info.get_meters_waiting
     1814*   then do;
     1815*   code = error_table_$seglock;			[* can't have two going at once *]
     1816*   return;
     1817*   end;
     1818*
     1819*   fnp_info.get_meters_waiting = "1"b;
     1820*   call dn355$send_global_wcd (fnpp, report_meters, 18, mbx_data);
     1821*   pcbp = fnpp;				[* to avoid faults in loop test *]
     1822*   end;
     1823*
     1824*   else do;
     1825*   pcb.get_meters_waiting = "1"b;
     1826*   call dn355$send_wcd (fnpp, pcbp, report_meters, 18, mbx_data);
     1827*   end;
     1828*
     1829*   call unlock;				[* while waiting *]
     1830*   call pxss$wait;
     1831*   call lock;				[* while checking *]
     1832*
     1833*   do while ((global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting));
     1834*   if ^fnp_info.running
     1835*   then do;
     1836*   code = error_table_$fnp_down;
     1837*   go to abort_get_meters;
     1838*   end;
     1839*
     1840*   else if clock () - fnp_meter_wait_start > DUMP_PATCH_LIMIT
     1841*   then do;
     1842*   code = error_table_$timeout;
     1843*   fnp_info.dump_patch_disabled = "1"b;
     1844*   call syserr (LOG_AND_PRINT,
     1845*   "fnp_multiplexer: get_meters order for FNP ^a^[^s^;, line ^o,^] timed out.", fnp_info.fnp_tag,
     1846*   global, string (pcb.line_number));
     1847*   abort_get_meters:
     1848*   if global
     1849*   then fnp_info.get_meters_waiting = "0"b;
     1850*   else pcb.get_meters_waiting = "0"b;
     1851*   end;
     1852*
     1853*   else do;
     1854*   call unlock;			[* in case we wait some more *]
     1855*   call pxss$addevent (FNP_METER_EVENT);
     1856*   if (global & fnp_info.get_meters_waiting) | (^global & pcb.get_meters_waiting)
     1857*   [* check if it happened since we checked *]
     1858*   then call pxss$wait;
     1859*   else call pxss$delevent (FNP_METER_EVENT);
     1860*   call lock;
     1861*   end;
     1862*   end;
     1863*
     1864*   return;
     1865*   end get_fnp_meters;
     1866*   ******************************************************************* */
     1867 
     1868 /* Supprimer pour le datanet 7100. ******************************************************************
     1869*
     1870*   name_to_pcb:
     1871*   proc (name);
     1872*
     1873*   dcl  name char (*);
     1874*
     1875*   code = 0;
     1876*   call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);
     1877*   call lock;
     1878*   if code ^= 0
     1879*   then return;
     1880*
     1881*   if his_fnp_no ^= fnp_info.fnp_number
     1882*   then go to bad_device;
     1883*
     1884*   if hsla_flag
     1885*   then pcbx = fnp_info.hsla_idx (la_no);
     1886*   else pcbx = fnp_info.lsla_idx (la_no);
     1887*   if pcbx = -1
     1888*   then go to bad_device;
     1889*
     1890*   found, past = "0"b;
     1891*   do j = pcbx to fnp_info.no_of_channels while (^past & ^found);
     1892*   pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (j));
     1893*   if pcb.la_no ^= bit (bin (la_no, 3), 3)
     1894*   then past = "1"b;
     1895*   else if pcb.slot_no = bit (bin (subchan, 6), 6)
     1896*   then found = "1"b;
     1897*   end;
     1898*
     1899*   if ^found
     1900*   then do;
     1901*   bad_device:
     1902*   call unlock;
     1903*   code = error_table_$bad_channel;
     1904*   return;
     1905*   end;
     1906*
     1907*   return;
     1908*   end name_to_pcb;
     1909*   ************************************************************************ */
     1910 
     1911 lock:
     1912      proc;
     1913 
     1914 /* subroutine to lock the mailbox lock (which incidentally protects PCBs too) */
     1915 
     1916 	if fnpp = null ()
     1917 	then do;
     1918 	     code = error_table_$fnp_down;
     1919 	     return;
     1920 	end;
     1921 
     1922 	code = 0;
     1923 
     1924 	lctep = fnp_info.lcte_ptr;
     1925 
     1926 	if lcte.lock = pds$processid			/* called as result of our own interrupt? */
     1927 	then if lcte.locked_for_interrupt
     1928 	     then mylock = "1"b;			/* remember not to unlock it */
     1929 	     else call syserr (CRASH_SYSTEM, "uncp_multiplexer: mylock error");
     1930 	else do;
     1931 	     mylock = "0"b;
     1932 	     call tty_lock$lock_lcte (lctep, code);
     1933 	     locked = (code = 0);
     1934 	end;
     1935 
     1936 
     1937 	return;
     1938      end lock;
     1939 
     1940 
     1941 
     1942 unlock:
     1943      proc;
     1944 
     1945 /* subroutine to release mailbox lock and process queued interrupts */
     1946 
     1947 	if locked
     1948 	then if ^mylock
     1949 	     then do;
     1950 
     1951 		call uncp$process_interrupt_queue ((fnp_info.fnp_number));
     1952 		locked = "0"b;			/* it unlocks the channel lock when it's done */
     1953 
     1954 	     end;
     1955 	return;
     1956 
     1957      end unlock;
     1958 
     1959 /*   Supprimer pour le Datanet 7100. ***********************************************
     1960*
     1961*   fnp_buf_size:
     1962*   proc returns (bit (18));
     1963*
     1964*   [* internal procedure returns correct buffer size for FNP to use, based on baud rate
     1965*   *  and synchronous/asynchronous
     1966*   *]
     1967*
     1968*   do i = 1 to n_sync_line_types while (pcb.line_type ^= sync_line_type (i));
     1969*   end;
     1970*
     1971*   if i <= n_sync_line_types
     1972*   then do;
     1973*   pcb.sync_line = "1"b;
     1974*   chars_per_buf = divide (divide (pcb.baud_rate, 8, 17, 0), buf_per_second, 17, 0);
     1975*   end;
     1976*
     1977*   else do;
     1978*   pcb.sync_line = "0"b;
     1979*   chars_per_buf = BASE_LTH;			[* always minimum for asynchronous *]
     1980*   end;
     1981*
     1982*   return (bit (bin (chars_per_buf, 18), 18));
     1983*   end fnp_buf_size;
     1984*   ******************************************************************************** */
     1985 
     1986 /**** Wired entrypoints to talk to io_manager for both fnp_multiplexer
     1987*      and the fnp_util TandD code. These should be called under
     1988*      the FNP lcte lock. */
     1989 
     1990 declare  a_fnp_no fixed bin;
     1991 declare  fnp_no fixed bin;
     1992 
     1993 assign:
     1994      entry (a_fnp_no, a_code);
     1995 
     1996 	infop = addr (dn355_data$);
     1997 	call TRACE ("assign");
     1998 	fnp_no = a_fnp_no;
     1999 	fnpp = addr (datanet_info.per_datanet (fnp_no));
     2000 	call assign_channel (code);
     2001 	a_code = code;
     2002 	return;
     2003 
     2004 
     2005 unassign:
     2006      entry (a_fnp_no, a_code);
     2007 
     2008 	fnp_no = a_fnp_no;
     2009 	infop = addr (dn355_data$);
     2010 	call TRACE ("unassign");
     2011 	fnpp = addr (datanet_info.per_datanet (fnp_no));
     2012 
     2013 	call unassign_channel (code);
     2014 	a_code = code;
     2015 	return;
     2016 
     2017 
     2018 assign_channel:
     2019      procedure (code);
     2020 declare  code fixed bin (35);
     2021 
     2022 	code = 0;
     2023 	if ^fnp_info.available
     2024 	then do;
     2025 	     code = error_table_$io_not_configured;	/* "not available" */
     2026 	     go to assign_channel_return;
     2027 	end;
     2028 
     2029 	if fnp_info.io_manager_assigned
     2030 	then do;
     2031 	     code = error_table_$io_assigned;
     2032 	     go to assign_channel_return;
     2033 	end;
     2034 
     2035 	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, uncp$interrupt, (fnp_info.fnp_number),
     2036 	     (null ()), code);
     2037 	fnp_info.io_manager_assigned = (code = 0);
     2038 assign_channel_return:
     2039 	if datanet_info.trace | datanet_info.debug_stop
     2040 	then call syserr (ANNOUNCE, "uncp_multiplexer$assign_channel: Assignment of FNP ^a ^[succeeded^;failed^].",
     2041 		fnp_info.fnp_tag, (code = 0));
     2042 	if code ^= 0
     2043 	then call TRACE_ERROR ("assign_channel", code);
     2044 	return;
     2045      end assign_channel;
     2046 
     2047 unassign_channel:
     2048      procedure (code);
     2049 declare  code fixed bin (35);
     2050 
     2051 
     2052 	if ^fnp_info.io_manager_assigned
     2053 	then do;
     2054 	     code = error_table_$io_not_assigned;
     2055 	     go to unassign_return;
     2056 	end;
     2057 	call io_manager$unassign (fnp_info.io_manager_chx, code);
     2058 	if code = 0
     2059 	then fnp_info.io_manager_assigned = "0"b;
     2060 unassign_return:
     2061 	if datanet_info.trace | datanet_info.debug_stop
     2062 	then call syserr$error_code (ANNOUNCE, code,
     2063 		"uncp_multiplexer$unassign_channel: Unassignment of FNP ^a ^[failed^;succeeded^].", fnp_info.fnp_tag,
     2064 		(code ^= 0));
     2065 	if code ^= 0
     2066 	then call TRACE_ERROR ("unassign_channel", code);
     2067 	return;
     2068      end unassign_channel;
     2069 
     2070 TRACE:
     2071      procedure (Entry);
     2072 
     2073 declare  Entry char (32);
     2074 
     2075 	if datanet_info.trace
     2076 	then call syserr (ANNOUNCE, "uncp_multiplexer$^a: Tracing call.", Entry);
     2077 	return;
     2078 
     2079 
     2080 
     2081 TRACE_ERROR:
     2082      entry (Entry, Code);
     2083 
     2084 declare  Code fixed bin (35);
     2085 
     2086 	if datanet_info.trace | datanet_info.debug_stop
     2087 	then call syserr$error_code (ANNOUNCE, Code, "uncp_multiplexer$^a: Tracing error.", Entry);
     2088 	if datanet_info.debug_stop
     2089 	then call syserr (CRASH_SYSTEM, "uncp_multiplexer: debugging stop (type go to continue).");
     2090 	return;
     2091      end TRACE;
     2092 
     2093 /* Begin message documentation invisible
     2094*
     2095*   This message doc is classed "invisible" so it will not be added to the
     2096*   message documentation distribution for a software release.  The DSA login
     2097*   code will not be shipped.
     2098*
     2099*				
     2100*   Message:
     2101*   patching FNP X for USER:
     2102*   ADDR from XXX to YYY
     2103*
     2104*   S:	$info
     2105*
     2106*   T:	$run
     2107*
     2108*   M:	The memory of FNP X is being patched by the privileged
     2109*   user whose user_id is USER. ADDR is the absolute location in FNP memory that is being
     2110*   patched (in octal); XXX and YYY are the old and new values of the location
     2111*   respectively (also in octal).
     2112*   The second line may be repeated (with different values) if more than one word
     2113*   is being patched.
     2114*
     2115*   A:	This information is for logging purposes.
     2116*
     2117*
     2118*   Message:
     2119*   uncp_multiplexer: mylock error
     2120*
     2121*   S:	$crash
     2122*
     2123*   T:	$run
     2124*
     2125*   M:	An attempt has been made to lock an FNP channel lock to a process
     2126*   that already has it locked.
     2127*
     2128*   A:	$inform
     2129*
     2130*
     2131*   Message:
     2132*   uncp_multiplexer: lock ^= processid
     2133*
     2134*   S:	$crash
     2135*
     2136*   T:	$run
     2137*
     2138*   M:	An attempt has been made to unlock an FNP channel lock when it was
     2139*   locked to some other process.
     2140*
     2141*   A:	$inform
     2142*
     2143*   Message:
     2144*   uncp_multiplexer: attempted crawlout with FNP channel lock set
     2145*
     2146*   S:	$crash
     2147*
     2148*   T:	$run
     2149*
     2150*   M:	An attempt was made to crawl out while an FNP channel
     2151*   lock (a processor lock) was locked.
     2152*
     2153*   A:	$inform
     2154*
     2155*   Message:
     2156*   uncp_multiplexer: NAME order to FNP X timed out.
     2157*
     2158*   S:	$info
     2159*
     2160*   T:	$run
     2161*
     2162*   M:	NAME is "dump_fnp" or "patch_fnp". The named order to FNP X failed to
     2163*   complete within 30 seconds. The buffer space associated with the order has
     2164*   been abandoned, and dump and patch orders to that FNP are disabled until the
     2165*   the FNP is reloaded.
     2166*
     2167*   A:	$inform
     2168*
     2169*   End message documentation invisible */
     2170 
     2171 
     2172 
     2173      end uncp_multiplexer;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1122.2  uncp_multiplexer.pl1              >udd>sm>ds>w>ml>uncp_multiplexer.pl1
338          1    01/06/85  1522.1  tty_buf.incl.pl1                  >ldd>incl>tty_buf.incl.pl1
1-152        2    01/06/85  1522.1  hc_fast_lock.incl.pl1             >ldd>incl>hc_fast_lock.incl.pl1
340          3    07/21/88  2136.0  tty_buffer_block.incl.pl1         >ldd>incl>tty_buffer_block.incl.pl1
342          4    11/08/82  1105.8  lct.incl.pl1                      >ldd>incl>lct.incl.pl1
344          5    10/26/89  2111.9  dn355_data.incl.pl1               >ldd>incl>dn355_data.incl.pl1
346          6    07/21/88  2136.0  pcb.incl.pl1                      >ldd>incl>pcb.incl.pl1
348          7    10/20/82  1038.6  mailbox_ops.incl.pl1              >ldd>incl>mailbox_ops.incl.pl1
350          8    06/18/81  1000.8  tty_space_man_dcls.incl.pl1       >ldd>incl>tty_space_man_dcls.incl.pl1
352          9    08/06/87  1013.4  line_types.incl.pl1               >ldd>incl>line_types.incl.pl1
354         10    02/23/79  1534.9  mux_init_info.incl.pl1            >ldd>incl>mux_init_info.incl.pl1
356         11    07/11/84  1037.3  io_chnl_util_dcls.incl.pl1        >ldd>incl>io_chnl_util_dcls.incl.pl1
357         12    03/19/81  1231.8  mcs_modes_change_list.incl.pl1    >ldd>incl>mcs_modes_change_list.incl.pl1
358         13    11/05/79  1528.9  flow_control_info.incl.pl1        >ldd>incl>flow_control_info.incl.pl1
359         14    05/06/80  1058.2  channel_manager_dcls.incl.pl1     >ldd>incl>channel_manager_dcls.incl.pl1
360         15    10/20/82  1038.6  mcs_interrupt_info.incl.pl1       >ldd>incl>mcs_interrupt_info.incl.pl1
361         16    03/29/82  1106.8  fnp_meters.incl.pl1               >ldd>incl>fnp_meters.incl.pl1
362         17    08/10/81  1943.6  fnp_channel_meters.incl.pl1       >ldd>incl>fnp_channel_meters.incl.pl1
363         18    06/18/81  1000.6  get_comm_meters_info.incl.pl1     >ldd>incl>get_comm_meters_info.incl.pl1
364         19    07/11/84  1037.3  io_manager_dcls.incl.pl1          >ldd>incl>io_manager_dcls.incl.pl1
365         20    07/10/86  2115.0  mcs_echo_neg_sys.incl.pl1         >ldd>incl>mcs_echo_neg_sys.incl.pl1
366         21    07/21/88  2136.0  uncp_buf.incl.pl1                 >ldd>incl>uncp_buf.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000135 constant        fixed bin(17,0)          initial dcl 281 set ref 638* 2038* 2060* 2075* 2086*
BASE_LTH                               constant        fixed bin(17,0)          initial dcl 290 ref 1689
BLK_XFER_INDEX                         constant        fixed bin(17,0)          initial dcl 313 ref 1674
Block_xfer                             constant        fixed bin(8,0)           initial dcl 7-89 ref 1675
Breakall                               constant        fixed bin(8,0)           initial dcl 7-89 ref 1663
CHAR_72                         000106 constant        fixed bin(17,0)          initial dcl 291 set ref 1408*
CRASH_SYSTEM                    000146 constant        fixed bin(17,0)          initial dcl 282 set ref 1929* 2088*
Code                                   parameter       fixed bin(35,0)          dcl 2084 set ref 2081 2086*
DCW_LIST_SIZE                          constant        fixed bin(17,0)          initial dcl 286 ref 443 566
Entry                                  parameter       char(32)                 packed unaligned dcl 2073 set ref 2070 2075* 2081
                                                                                  2086*
Fullduplex                             constant        fixed bin(8,0)           initial dcl 7-89 ref 1720
Hndlquit                               constant        fixed bin(8,0)           initial dcl 7-89 ref 1656
IFLOW_INDEX                            constant        fixed bin(17,0)          initial dcl 312 ref 1678
INPUT                           000135 constant        bit(1)                   initial packed unaligned dcl 8-20 set ref 555*
Input_flow_control                     constant        fixed bin(8,0)           initial dcl 7-89 ref 1679
LA_7                                   constant        fixed bin(17,0)          initial dcl 288 ref 479
LINE_ASCII                             constant        fixed bin(17,0)          initial dcl 9-22 ref 1195
LINE_ASYNC1                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1195
LINE_ASYNC2                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1195
LINE_ASYNC3                            constant        fixed bin(17,0)          initial dcl 9-22 ref 1195
Lfecho                                 constant        fixed bin(8,0)           initial dcl 7-89 ref 1717
Listen                                 constant        fixed bin(8,0)           initial dcl 7-89 ref 853 1019
OUTPUT                          000134 constant        bit(1)                   initial packed unaligned dcl 8-21 set ref 553* 1099*
PCB_SIZE_INCR                          constant        fixed bin(17,0)          initial dcl 287 ref 443 566
SEND_OUTPUT                     000143 constant        fixed bin(17,0)          initial dcl 15-13 set ref 1110*
TWO_WORD_LTH                           constant        fixed bin(17,0)          initial dcl 289 ref 815
UNCP_CQ_SIZE                           constant        fixed bin(17,0)          initial dcl 283 ref 410
a_chainp                               parameter       pointer                  dcl 74 set ref 670 675*
a_code                                 parameter       fixed bin(35,0)          dcl 76 set ref 368 393* 447* 513* 529* 532 581* 584
                                                                                  606* 610 625* 629 665* 670 677* 681 691* 724* 727
                                                                                  743* 982* 991* 1142* 1146 1156* 1163* 1214* 1217
                                                                                  1227* 1234* 1259* 1264 1270* 1273 1371* 1374 1492*
                                                                                  1496 1501* 1993 2001* 2005 2014*
a_data_ptr                             parameter       pointer                  dcl 79 ref 727 733 1273 1280 1374 1388
a_devx                                 parameter       fixed bin(17,0)          dcl 70 ref 368 377
a_fnp_no                               parameter       fixed bin(17,0)          dcl 1990 ref 1993 1998 2005 2008
a_fnpp                                 parameter       pointer                  dcl 72 set ref 368 512* 532 537 584 589 610 615 629
                                                                                  635 670 681 684 727 730 1146 1151 1217 1222 1264
                                                                                  1273 1278 1374 1385 1496 1499 1504 1507
a_init_info_ptr                        parameter       pointer                  dcl 71 ref 368 378
a_mi_flag                              parameter       bit(1)                   dcl 75 set ref 670 676*
a_mode_list_ptr                        parameter       pointer                  dcl 80 ref 1146 1153 1217 1224
a_modes                                parameter       char                     packed unaligned dcl 81 set ref 1264 1269*
a_order                                parameter       char                     packed unaligned dcl 78 ref 727 732 1273 1279 1374
                                                                                  1387
a_output_ptr                           parameter       pointer                  dcl 77 set ref 681 686 722*
a_subchan                              parameter       fixed bin(17,0)          dcl 73 ref 670 681 685 727 731 1146 1152 1217 1223
                                                                                  1264
accept_direct_output            000115 constant        fixed bin(8,0)           initial dcl 7-24 set ref 716*
addr                                                   builtin function         dcl 212 ref 381 382 398 406 406 416 466 470 509 509
                                                                                  519 519 523 538 539 552 590 616 634 643 750 863
                                                                                  1028 1044 1086 1168 1242 1407 1408 1520 1521 1527
                                                                                  1713 1996 1999 2009 2011
addrel                                                 builtin function         dcl 212 ref 454
alter_data                      000150 automatic       varying bit(144)         dcl 111 set ref 854* 1027 1028 1652* 1693* 1693 1713
alter_parameters                       constant        fixed bin(8,0)           initial dcl 7-24 ref 1029 1049 1086
alter_type                      000135 automatic       fixed bin(8,0)           dcl 106 set ref 737* 853* 1017 1019 1028 1656* 1663*
                                                                                  1675* 1679* 1705* 1713 1717 1720
area                            000220 stack reference condition                dcl 215 ref 499
arg_dump                               based           structure                level 1 dcl 1379
async_only_modes                000046 constant        char(8)                  initial array packed unaligned dcl 307 set ref 1180
                                                                                  1180 1183 1252 1253* 1698
available                66            based           bit(1)                   level 3 packed packed unaligned dcl 5-67 ref 2023
base_len                        000173 automatic       fixed bin(17,0)          dcl 132 set ref 1685* 1689* 1693
based_bit2                             based           bit(2)                   packed unaligned dcl 177 ref 808 810
based_bit72                            based           bit(72)                  packed unaligned dcl 179 ref 1407
based_fb_word                          based           fixed bin(17,0)          dcl 176 ref 816
baud_rate                 2            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref
                                                                                  1684
bin                                                    builtin function         dcl 212 ref 493 494 708 711 713 1028 1044 1693 1693
                                                                                  1713
bit                                                    builtin function         dcl 212 ref 493 494 1028 1044 1693 1693 1713
block_len                       000174 automatic       fixed bin(17,0)          dcl 133 set ref 1685* 1690* 1693
blockp                          000230 automatic       pointer                  dcl 3-19 set ref 697* 698 700 701* 701 702 713
bootloading              30(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 546
                                                                                  653*
buf_per_second                         constant        fixed bin(17,0)          initial dcl 1-29 ref 1685
buffer                                 based           structure                level 1 dcl 3-28
channel_desc                           based           structure                level 2 packed packed unaligned dcl 6-27
channel_manager$interrupt       000122 constant        entry                    external dcl 14-25 ref 1110
channels                  1            based           structure                array level 2 dcl 10-10
chanx                           000110 automatic       fixed bin(17,0)          dcl 93 set ref 592* 618* 685* 731* 1152* 1223* 1527
chars_per_sec                   000175 automatic       fixed bin(17,0)          dcl 135 set ref 1684* 1685
check                           000136 automatic       bit(1)                   packed unaligned dcl 107 set ref 738* 819* 1034
code                                   parameter       fixed bin(35,0)          dcl 2020 in procedure "assign_channel" set ref 2018
                                                                                  2022* 2025* 2031* 2035* 2037 2038 2042 2042*
code                                   parameter       fixed bin(35,0)          dcl 2049 in procedure "unassign_channel" set ref
                                                                                  2047 2054* 2057* 2058 2060* 2060 2065 2065*
code                            000100 automatic       fixed bin(35,0)          dcl 86 in procedure "uncp_multiplexer" set ref 420*
                                                                                  424* 425 428* 429 476* 501* 517* 529 543 546* 569*
                                                                                  571* 578 578* 581 594 604 604* 606 620 623 623*
                                                                                  625 689 691 719* 722 724 987* 989 991 1142 1161
                                                                                  1163 1204* 1214 1232 1234 1259 1369* 1371 1390*
                                                                                  1393* 1396* 1399* 1405 1410* 1490* 1492 1501 1519*
                                                                                  1524 1531* 1701* 1711 1720* 1918* 1922* 1932* 1933
                                                                                  2000* 2001 2013* 2014
config_flags             66            based           structure                level 2 dcl 5-67
configuration_lock                     based           structure                level 2 dcl 5-52 set ref 406 406 509 509 519 519
copied_meters_offset      7            based           fixed bin(18,0)          level 2 unsigned dcl 6-27 set ref 558 560 560 561*
                                                                                  1626 1628 1638*
copied_meters_ptr               000322 automatic       pointer                  dcl 1624 set ref 1628* 1632 1634 1635 1636*
copied_meters_ready       4(09)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1535 1639*
cq_free                   6            based           fixed bin(18,0)          level 2 dcl 21-19 set ref 411*
cq_hbound                 1            based           fixed bin(18,0)          level 2 dcl 21-19 set ref 412*
cq_max_size               7            based           fixed bin(17,0)          level 2 dcl 21-19 set ref 410* 411 412
data_ptr                        000126 automatic       pointer                  dcl 100 set ref 733* 742 808 810 816 1140 1280*
                                                                                  1388* 1393* 1396 1396 1396 1396 1407
datanet_info                           based           structure                level 1 dcl 5-52
dcw_list_array_ptr        4            based           pointer                  level 2 dcl 5-67 set ref 454*
debug_stop                6            based           bit(1)                   level 2 dcl 5-52 ref 2038 2060 2086 2088
devx                                   based           fixed bin(17,0)          level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "uncp_multiplexer" set ref
                                                                                  469* 470 553 555 1099 1110
devx                     11            based           fixed bin(17,0)          array level 3 in structure "mux_init_info" dcl 10-10
                                                                                  in procedure "uncp_multiplexer" ref 469
devx                            000101 automatic       fixed bin(17,0)          dcl 87 in procedure "uncp_multiplexer" set ref 377*
                                                                                  387 389 416
dial                            000012 constant        fixed bin(8,0)           initial dcl 7-24 set ref 1408*
disconnect_this_line                   constant        fixed bin(8,0)           initial dcl 7-24 ref 751 995
divide                                                 builtin function         dcl 212 ref 1684 1685
dn355_data$                     000112 external static fixed bin(17,0)          dcl 5-47 set ref 381 539 590 616 634 643 1521 1996
                                                                                  2009
dno                             000103 automatic       fixed bin(17,0)          dcl 89 set ref 390* 391 398 403 474
dumpin                          000155 automatic       bit(1)                   packed unaligned dcl 112 set ref 735* 808*
dumpout                         000156 automatic       bit(1)                   packed unaligned dcl 113 set ref 735* 810* 1095
end_frame                 4(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1107 1109*
enter_receive                          constant        fixed bin(8,0)           initial dcl 7-24 ref 864
entries                   6            based           structure                array level 2 dcl 12-10 set ref 1168 1242
error                     4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1205*
error_table_$action_not_performed
                                000072 external static fixed bin(35,0)          dcl 249 ref 1720
error_table_$bad_channel        000064 external static fixed bin(35,0)          dcl 249 ref 393 476
error_table_$bad_mode           000062 external static fixed bin(35,0)          dcl 249 ref 1204 1701
error_table_$fnp_down           000066 external static fixed bin(35,0)          dcl 249 ref 1531 1918
error_table_$invalid_state      000104 external static fixed bin(35,0)          dcl 249 ref 546
error_table_$io_assigned        000074 external static fixed bin(35,0)          dcl 249 ref 2031
error_table_$io_not_assigned    000076 external static fixed bin(35,0)          dcl 249 ref 2054
error_table_$io_not_available   000102 external static fixed bin(35,0)          dcl 249 ref 420
error_table_$io_not_configured  000100 external static fixed bin(35,0)          dcl 249 ref 2025
error_table_$noalloc            000056 external static fixed bin(35,0)          dcl 249 ref 447 501
error_table_$undefined_order_request
                                000060 external static fixed bin(35,0)          dcl 249 ref 982 1369 1490
error_table_$unimplemented_version
                                000070 external static fixed bin(35,0)          dcl 249 ref 1156 1227
extra_nl                  4(14)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1664*
flags                    30            based           structure                level 2 in structure "fnp_info" dcl 5-67
                                                                                  in procedure "uncp_multiplexer" set ref 456* 565*
flags                     2(09)        based           structure                level 2 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "uncp_multiplexer"
flags                     4            based           structure                level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "uncp_multiplexer"
flags                     4            based           structure                level 2 in structure "mcle" dcl 12-26 in procedure
                                                                                  "uncp_multiplexer"
flags                     5            based           structure                level 2 in structure "mcl" dcl 12-10 in procedure
                                                                                  "uncp_multiplexer"
fnp_async_meters                       based           structure                level 1 dcl 17-46
fnp_channel_meters                     based           structure                level 1 dcl 17-18 set ref 505 505 524 524 557 557
                                                                                  560 560 1635* 1635 1636 1636
fnp_config_flags          5            based           bit(1)                   array level 2 packed packed unaligned dcl 1-35 ref
                                                                                  403
fnp_global_meters                      based           structure                level 1 dcl 16-13
fnp_id                    7            based           structure                level 2 dcl 5-67
fnp_info                               based           structure                level 1 dcl 5-67
fnp_no                          000262 automatic       fixed bin(17,0)          dcl 1991 set ref 1998* 1999 2008* 2011
fnp_number                7(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 5-67
                                                                                  ref 428 573 658 1393 1399 1951 2035
fnp_sync_meters                        based           structure                level 1 dcl 17-35
fnp_tag                   7            based           char(1)                  level 3 packed packed unaligned dcl 5-67 set ref 401
                                                                                  2038* 2060*
fnpp                            000242 automatic       pointer                  dcl 5-50 set ref 398* 401 416 418 428 432 432 434
                                                                                  436 436 438 450 453 454 456 479 484 486 512 537*
                                                                                  546 546 546 551 552 565 566 566 568 571 573 589*
                                                                                  615* 635* 636 653 655 658 659 684* 716* 730* 1086*
                                                                                  1151* 1222* 1278* 1385* 1393 1399 1408* 1499*
                                                                                  1507* 1527 1527 1916 1924 1951 1999* 2011* 2023
                                                                                  2029 2035 2035 2035 2037 2038 2052 2057 2058 2060
force                     4(01)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 ref 1200
full_dpx_modes                  000030 constant        char(8)                  initial array packed unaligned dcl 315 ref 1188 1188
                                                                                  1195
get_meters                      000157 automatic       bit(1)                   packed unaligned dcl 114 set ref 735*
good_modes                      000104 constant        char(8)                  initial array packed unaligned dcl 304 ref 1173 1173
                                                                                  1176
hbound                                                 builtin function         dcl 212 ref 432 436 1173 1176 1180 1183 1188 1195
                                                                                  1252 1698 1701
hc_fast_lock                           based           structure                level 1 dcl 2-10
header                    2            based           structure                level 3 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "uncp_multiplexer"
header                                 based           structure                level 2 in structure "fnp_channel_meters" dcl 17-18
                                                                                  in procedure "uncp_multiplexer"
header                   34            based           structure                level 3 in structure "fnp_chan_meter_struc"
                                                                                  dcl 17-10 in procedure "uncp_multiplexer"
his_fnp_no                      000205 automatic       fixed bin(17,0)          dcl 145 set ref 473* 474
hndlquit                  4(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1657*
hndlquit_set                    000172 automatic       bit(1)                   packed unaligned dcl 131 set ref 1238* 1249 1658*
hsla_flag                       000176 automatic       bit(1)                   packed unaligned dcl 139 set ref 473* 481 484 488
                                                                                  492 494
hsla_idx                 21            based           fixed bin(17,0)          array level 2 dcl 5-67 set ref 432 432 434* 484*
i                               000112 automatic       fixed bin(17,0)          dcl 96 set ref 432* 434* 436* 438* 551* 552* 1045*
                                                                                  1045* 1048 1173* 1173* 1176 1180* 1180* 1183 1188*
                                                                                  1188* 1195 1698* 1698* 1701 1705 1706
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "uncp_multiplexer"
in                       26            based           structure                level 3 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "uncp_multiplexer"
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "uncp_multiplexer"
in                        2            based           structure                level 3 in structure "logical_chan_meters" dcl 18-17
                                                                                  in procedure "uncp_multiplexer"
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "uncp_multiplexer"
infop                           000240 automatic       pointer                  dcl 5-49 set ref 381* 383 398 406 406 509 509 519
                                                                                  519 539* 590* 616* 634* 638 643* 1521* 1996* 1999
                                                                                  2009* 2011 2038 2038 2060 2060 2075 2086 2086 2088
init                      5            based           bit(1)                   level 3 packed packed unaligned dcl 12-10 ref 1247
input                    11            based           structure                level 2 dcl 17-35
input_available           2            based           bit(1)                   level 2 dcl 190 set ref 742*
io_chanid                10            based           char(8)                  level 2 dcl 5-67 set ref 2035*
io_manager$assign               000124 constant        entry                    external dcl 19-10 ref 2035
io_manager$unassign             000126 constant        entry                    external dcl 19-20 ref 2057
io_manager_arg                         based           structure                level 1 dcl 19-50
io_manager_assigned      66(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 571
                                                                                  2029 2037* 2052 2058*
io_manager_chx           12            based           fixed bin(35,0)          level 2 dcl 5-67 set ref 2035* 2057*
is_hsla                   0(26)        based           bit(1)                   level 4 packed packed unaligned dcl 6-27 set ref
                                                                                  492* 1191
la_no                     0(27)        based           bit(3)                   level 4 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "uncp_multiplexer" set ref
                                                                                  493*
la_no                           000203 automatic       fixed bin(17,0)          dcl 143 in procedure "uncp_multiplexer" set ref 473*
                                                                                  479 481 484 486 487 493
lastp                           000114 automatic       pointer                  dcl 97 set ref 707* 708
lbound                                                 builtin function         dcl 212 ref 432 436
lcnt                                   based           structure                level 1 dcl 4-65
lcnt_ptr                  2            based           pointer                  level 2 dcl 4-11 ref 386
lcntp                           000236 automatic       pointer                  dcl 4-63 set ref 386* 387 389
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 1-35 ref 384
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 416 470
lcte_ptr                 32            based           pointer                  level 2 dcl 5-67 set ref 416* 1924
lctep                           000234 automatic       pointer                  dcl 4-8 set ref 470* 471 1535 1924* 1926 1926 1932*
lctp                            000232 automatic       pointer                  dcl 4-7 set ref 384* 386 416 470
length                                                 builtin function         dcl 212 ref 387 1027
lfecho                    4(16)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1717*
line_number               0(26)        based           structure                level 3 packed packed unaligned dcl 6-27
line_type                 2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref
                                                                                  1195 1195 1195 1195
listen                    4            based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  997* 1024* 1036
local_line_type                 000162 automatic       fixed bin(17,0)          dcl 120 set ref 816* 817 817 1044 1045
lock                                   based           bit(36)                  level 2 dcl 4-20 ref 1926
lock$lock_fast                  000034 constant        entry                    external dcl 233 ref 406
lock$unlock_fast                000036 constant        entry                    external dcl 234 ref 509 519
locked                          000131 automatic       bit(1)                   packed unaligned dcl 102 set ref 540* 654* 1389*
                                                                                  1509* 1522* 1933* 1947 1952*
locked_for_interrupt      2(12)        based           bit(1)                   level 3 packed packed unaligned dcl 4-20 ref 1535
                                                                                  1926
lsla_idx                 13            based           fixed bin(17,0)          array level 2 dcl 5-67 set ref 436 436 438* 486*
major_channel_info        3            based           structure                level 2 dcl 4-20
max_line_type                          constant        fixed bin(17,0)          initial dcl 9-48 ref 817
max_no_355s                            internal static fixed bin(17,0)          initial dcl 5-45 ref 5-52
mbx_data                               based           bit(144)                 packed unaligned dcl 109 set ref 750* 863* 1028*
                                                                                  1044* 1086* 1407* 1408* 1713*
mbx_data_len                    000137 automatic       fixed bin(17,0)          dcl 108 set ref 749* 815* 862* 1027* 1086*
mbx_data_long                   000140 automatic       bit(288)                 packed unaligned dcl 110 set ref 750 863 1028 1044
                                                                                  1086 1407 1408 1713
mcl                                    based           structure                level 1 dcl 12-10
mcl_version_2                          constant        fixed bin(17,0)          initial dcl 12-8 ref 1154 1225
mcle                                   based           structure                level 1 dcl 12-26
mclep                           000256 automatic       pointer                  dcl 12-24 set ref 1168* 1170 1171 1176 1183 1186
                                                                                  1200 1200 1205 1242* 1243 1243 1243
mclp                            000254 automatic       pointer                  dcl 12-7 set ref 1153* 1154 1167 1168 1224* 1225
                                                                                  1241 1242 1247
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "uncp_multiplexer"
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "uncp_multiplexer"
mii_chan_count                  000252 automatic       fixed bin(17,0)          dcl 10-7 set ref 379* 442 450
miip                            000250 automatic       pointer                  dcl 10-6 set ref 378* 379 469 472
mode_alter_types                000013 constant        fixed bin(8,0)           initial array dcl 319 ref 1698 1701 1705
mode_name                              parameter       char                     packed unaligned dcl 1648 in procedure
                                                                                  "process_mode" ref 1645 1654 1661 1669 1669 1672
                                                                                  1698
mode_name                       000166 automatic       char(8)                  packed unaligned dcl 128 in procedure
                                                                                  "uncp_multiplexer" set ref 1170* 1173 1180 1188
                                                                                  1191 1191 1191
mode_name                              based           char(16)                 level 2 in structure "mcle" packed packed unaligned
                                                                                  dcl 12-26 in procedure "uncp_multiplexer" set ref
                                                                                  1170 1243*
mode_name_index                 000334 automatic       fixed bin(17,0)          dcl 1650 set ref 1674* 1678* 1694
mode_on                                parameter       bit(1)                   packed unaligned dcl 1649 in procedure
                                                                                  "process_mode" ref 1645 1652 1657 1664 1682 1717
                                                                                  1720
mode_on                         000170 automatic       bit(1)                   packed unaligned dcl 129 in procedure
                                                                                  "uncp_multiplexer" set ref 1171* 1191 1195
mode_set                        000171 automatic       bit(1)                   array packed unaligned dcl 130 set ref 1239* 1253
                                                                                  1694* 1706*
mode_switch               4            based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1171 1243*
modex                           000164 automatic       fixed bin(17,0)          dcl 127 set ref 1167* 1168* 1241* 1242* 1252* 1253
                                                                                  1253*
mpx_mode                  4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 12-26 set ref
                                                                                  1176* 1183* 1186* 1200* 1243
mux_init_info                          based           structure                level 1 dcl 10-10
my_chan_name                    000102 automatic       char(1)                  packed unaligned dcl 88 set ref 389* 390* 401
mylock                          000133 automatic       bit(1)                   packed unaligned dcl 104 set ref 1508* 1926* 1931*
                                                                                  1947
n_entries                 1            based           fixed bin(17,0)          level 2 dcl 12-10 ref 1167 1241
n_pcbs                          000244 automatic       fixed bin(17,0)          dcl 6-22 set ref 450* 451 465 522
n_sync_line_types                      constant        fixed bin(17,0)          initial dcl 9-50 ref 1045 1048
name                            000207 automatic       char(32)                 packed unaligned dcl 151 in procedure
                                                                                  "uncp_multiplexer" set ref 472* 473*
name                      1            based           char(32)                 array level 3 in structure "mux_init_info" packed
                                                                                  packed unaligned dcl 10-10 in procedure
                                                                                  "uncp_multiplexer" ref 472
names                                  based           char(32)                 array level 2 packed packed unaligned dcl 4-65 ref
                                                                                  387 389
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 3-28
                                                                                  set ref 700 701 708*
no_channels                            based           fixed bin(17,0)          level 2 dcl 10-10 ref 379
no_of_channels            6            based           fixed bin(17,0)          level 2 dcl 5-67 set ref 450* 551 566
null                                                   builtin function         dcl 212 ref 380 408 445 451 468 520 524 568 636 675
                                                                                  722 1916 2035
old_flag                        000177 automatic       bit(1)                   packed unaligned dcl 140 set ref 458* 481 488*
opcode                          000134 automatic       fixed bin(8,0)           dcl 105 set ref 737* 751* 820* 864* 995 1029* 1032
                                                                                  1036 1049* 1086 1086*
opend                           000163 automatic       bit(1)                   packed unaligned dcl 125 set ref 1115* 1140
order                           000116 automatic       char(32)                 packed unaligned dcl 99 set ref 732* 740 747 806 813
                                                                                  851 857 860 1279* 1387* 1393 1396 1399 1402
output_length                   000111 automatic       fixed bin(17,0)          dcl 94 set ref 698* 702* 702 714
output_pending            2            based           bit(1)                   level 2 dcl 186 set ref 1140*
output_ptr                      000106 automatic       pointer                  dcl 92 set ref 686* 697 708 711
pad                      14            based           fixed bin(17,0)          array level 2 in structure "fnp_async_meters"
                                                                                  dcl 17-46 in procedure "uncp_multiplexer" set ref
                                                                                  1634*
pad                      27            based           fixed bin(17,0)          array level 2 in structure "fnp_sync_meters"
                                                                                  dcl 17-35 in procedure "uncp_multiplexer" set ref
                                                                                  1632*
parse_fnp_name_                 000046 constant        entry                    external dcl 239 ref 390
parse_tty_name_                 000044 constant        entry                    external dcl 238 ref 473
pcb                                    based           structure                level 1 dcl 6-27 set ref 442 467* 566
pcb_array                              based           structure                array level 1 dcl 6-25 set ref 466 523 552 1527
pcb_array_ptr             2            based           pointer                  level 2 dcl 5-67 set ref 453* 552 566* 568* 1527
pcb_space                       000104 automatic       fixed bin(17,0)          dcl 90 set ref 442* 443 454
pcb_space_ptr                   000200 automatic       pointer                  dcl 141 set ref 380* 444* 445 451 453 454 466 520
                                                                                  523 527*
pcbp                            000246 automatic       pointer                  dcl 6-23 set ref 442 466* 467 468 469 470 491 492
                                                                                  493 494 506 523* 524 524 552* 553 553 553 553 555
                                                                                  555 555 555 557 558 560 560 561 566 705 707 711
                                                                                  713 714 714 716 716* 997 997 1024 1036 1048 1086*
                                                                                  1097 1099 1099 1099 1100 1100 1100 1107 1109 1110
                                                                                  1110 1115 1186 1191 1195 1195 1195 1195 1527* 1535
                                                                                  1626 1628 1632 1635 1638 1639 1657 1664 1667 1684
                                                                                  1717
pcbx                            000206 automatic       fixed bin(17,0)          dcl 146 set ref 465* 466 469 471 472 479 484 486*
                                                                                  522* 523*
pds$processid                   000106 external static bit(36)                  dcl 271 ref 1926
per_datanet              22            based           structure                array level 2 dcl 5-52 set ref 398 1999 2011
prev_la_no                      000202 automatic       fixed bin(17,0)          dcl 142 set ref 457* 481 487*
ptr                                                    builtin function         dcl 212 ref 553 553 555 555 560 560 701 707 1099
                                                                                  1099 1628
queue_locked                    000132 automatic       bit(1)                   packed unaligned dcl 103 set ref 1522*
rd_stat                                based           structure                level 1 dcl 190
read_first                5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-27
                                                                                  set ref 555 555 555
rel                                                    builtin function         dcl 212 ref 708 711 713
rtrim                                                  builtin function         dcl 212 ref 387 389
running                  30(02)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 546
                                                                                  655 659* 1527
saved_meters_ptr          6            based           pointer                  array level 2 in structure "pcb_array" packed packed
                                                                                  unaligned dcl 6-25 in procedure "uncp_multiplexer"
                                                                                  set ref 451*
saved_meters_ptr          6            based           pointer                  level 2 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "uncp_multiplexer" set ref
                                                                                  468* 506* 524 524 557 1635
seg_ptr                                based           pointer                  level 2 dcl 1379 set ref 1396*
send_output               4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref 716
                                                                                  1110
set_line_type                          constant        fixed bin(8,0)           initial dcl 7-24 ref 820 1036
set_write_status                000130 automatic       bit(1)                   packed unaligned dcl 101 set ref 735* 857* 1115 1140
size                                                   builtin function         dcl 212 ref 442 505 505 524 524 557 557 560 560 566
                                                                                  1636 1636
slot_no                   0(30)        based           bit(6)                   level 4 packed packed unaligned dcl 6-27 set ref
                                                                                  494*
space_needed                    000105 automatic       fixed bin(17,0)          dcl 91 set ref 443* 444* 527*
string                                                 builtin function         dcl 212 set ref 456* 565* 1239*
subchan                   0(18)        based           fixed bin(7,0)           level 3 in structure "pcb" packed packed unaligned
                                                                                  dcl 6-27 in procedure "uncp_multiplexer" set ref
                                                                                  491*
subchan                         000204 automatic       fixed bin(17,0)          dcl 144 in procedure "uncp_multiplexer" set ref 473*
                                                                                  491 494
subchannel                3(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-20 set ref
                                                                                  471*
substr                                                 builtin function         dcl 212 ref 808 810 1170
sync_line                 4(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  1048* 1186 1632 1667
sync_line_type                  000000 constant        fixed bin(17,0)          initial array dcl 9-52 ref 1045
syserr                          000040 constant        entry                    external dcl 235 ref 638 1929 2038 2075 2088
syserr$error_code               000042 constant        entry                    external dcl 236 ref 2060 2086
t_and_d_in_progress      30(08)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 418
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 3-28
                                                                                  ref 698 702
tandd_attached            4(11)        based           bit(1)                   level 3 packed packed unaligned dcl 6-27 set ref
                                                                                  997*
tandd_pcbx               64            based           fixed bin(17,0)          level 2 dcl 5-67 set ref 479*
temp_saved_meters_ptr           000160 automatic       pointer                  dcl 115 set ref 505* 506
trace                     5            based           bit(1)                   level 2 dcl 5-52 ref 638 2038 2060 2075 2086
tty_area_manager$allocate       000030 constant        entry                    external dcl 231 ref 505
tty_area_manager$free           000032 constant        entry                    external dcl 232 ref 524 557
tty_buf                                based           structure                level 1 dcl 1-35
tty_buf$                        000110 external static fixed bin(17,0)          dcl 1-19 set ref 382 538 1520
tty_lock$lock_lcte              000026 constant        entry                    external dcl 230 ref 1932
tty_space_man$free_chain        000120 constant        entry                    external dcl 8-16 ref 553 555 1099
tty_space_man$free_space        000116 constant        entry                    external dcl 8-12 ref 527 560 566 1636
tty_space_man$get_space         000114 constant        entry                    external dcl 8-10 ref 444
ttybp                           000226 automatic       pointer                  dcl 1-19 set ref 382* 384 403 538* 553 553 555 555
                                                                                  560 560 701 707 1099 1099 1520* 1628
uncp$hangup_fnp_lines           000014 constant        entry                    external dcl 223 ref 658
uncp$interrupt                  000020 constant        entry                    external dcl 226 ref 2035 2035
uncp$process_interrupt_queue    000016 constant        entry                    external dcl 224 ref 1951
uncp$send_global_wcd            000012 constant        entry                    external dcl 222 ref 1408
uncp$send_wcd                   000010 constant        entry                    external dcl 221 ref 716 1086
uncp_buf                               based           structure                level 1 dcl 21-19 set ref 409*
uncp_bufp                10            based           pointer                  level 2 dcl 5-52 ref 383
uncp_mem_size             4            based           fixed bin(17,0)          level 2 dcl 1379 set ref 1396*
uncp_no                   2            based           fixed bin(17,0)          level 2 dcl 1379 set ref 1396*
uncp_type                 3            based           fixed bin(17,0)          level 2 dcl 1379 set ref 1396*
uncp_util$abort                 000050 constant        entry                    external dcl 243 ref 1399
uncp_util$fdump                 000054 constant        entry                    external dcl 245 ref 1396
uncp_util$fill_page_table       000022 constant        entry                    external dcl 227 ref 428
uncp_util$free_page_table       000024 constant        entry                    external dcl 228 ref 573
uncp_util$load                  000052 constant        entry                    external dcl 244 ref 1393
uncpbp                          000260 automatic       pointer                  dcl 21-16 set ref 383* 408 409 410 411 411 412 412
unspec                                                 builtin function         dcl 212 set ref 409* 467*
version                                based           fixed bin(17,0)          level 2 dcl 12-10 ref 1154 1225
wired                    30(03)        based           bit(1)                   level 3 packed packed unaligned dcl 5-67 set ref 546
wr_stat                                based           structure                level 1 dcl 186
write_cnt                 3(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref
                                                                                  714* 714 1100*
write_first               1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref 553
                                                                                  553 553 711* 1097 1099 1099 1100* 1115
write_last                1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-27 set ref 705
                                                                                  707 713* 1100*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_INPUT                           internal static fixed bin(17,0)          initial dcl 15-15
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 15-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 15-23
Break                                  internal static fixed bin(8,0)           initial dcl 7-89
Breakchar                              internal static fixed bin(8,0)           initial dcl 7-89
CRASH                                  internal static fixed bin(17,0)          initial dcl 15-12
Chngstring                             internal static fixed bin(8,0)           initial dcl 7-89
Crecho                                 internal static fixed bin(8,0)           initial dcl 7-89
DIALUP                                 internal static fixed bin(17,0)          initial dcl 15-10
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 15-19
Dumpinput                              internal static fixed bin(8,0)           initial dcl 7-89
Dumpoutput                             internal static fixed bin(8,0)           initial dcl 7-89
Echoplex                               internal static fixed bin(8,0)           initial dcl 7-89
Eight_bit_in                           internal static fixed bin(8,0)           initial dcl 7-89
Eight_bit_out                          internal static fixed bin(8,0)           initial dcl 7-89
Errormsg                               internal static fixed bin(8,0)           initial dcl 7-89
FIRST_BOOTLOAD_PAGEX                   internal static fixed bin(17,0)          initial dcl 5-166
FIRST_TTY_BUF_PAGEX                    internal static fixed bin(17,0)          initial dcl 5-167
FNP_CHANNEL_METERS_VERSION_1           internal static fixed bin(17,0)          initial dcl 17-8
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 1-31
FNP_METERS_VERSION_2                   internal static fixed bin(17,0)          initial dcl 16-57
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 1-32
GET_COMM_METERS_INFO_VERSION_1         internal static fixed bin(17,0)          initial dcl 18-21
HANGUP                                 internal static fixed bin(17,0)          initial dcl 15-11
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 15-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 15-16
LINE_1050                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_2741                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_ARDS                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_BSC                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_COLTS                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_DSA                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_ETX                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_G115                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_HASP_OPR                          internal static fixed bin(17,0)          initial dcl 9-22
LINE_HDLC                              internal static fixed bin(17,0)          initial dcl 9-22
LINE_MC                                internal static fixed bin(17,0)          initial dcl 9-22
LINE_POLLED_VIP                        internal static fixed bin(17,0)          initial dcl 9-22
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 15-18
LINE_SYNC1                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNC2                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNC3                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_SYNCH                             internal static fixed bin(17,0)          initial dcl 9-22
LINE_TELNET                            internal static fixed bin(17,0)          initial dcl 9-22
LINE_UNKNOWN                           internal static fixed bin(17,0)          initial dcl 9-22
LINE_VIP                               internal static fixed bin(17,0)          initial dcl 9-22
LINE_X25LAP                            internal static fixed bin(17,0)          initial dcl 9-22
Lock                                   internal static fixed bin(8,0)           initial dcl 7-89
MASKED                                 internal static fixed bin(17,0)          initial dcl 15-26
Meter                                  internal static fixed bin(8,0)           initial dcl 7-89
Msg                                    internal static fixed bin(8,0)           initial dcl 7-89
Nocontrol                              internal static fixed bin(8,0)           initial dcl 7-89
Odd_parity                             internal static fixed bin(8,0)           initial dcl 7-89
Output_flow_control                    internal static fixed bin(8,0)           initial dcl 7-89
Polite                                 internal static fixed bin(8,0)           initial dcl 7-89
Prefixnl                               internal static fixed bin(8,0)           initial dcl 7-89
QUIT                                   internal static fixed bin(17,0)          initial dcl 15-17
Replay                                 internal static fixed bin(8,0)           initial dcl 7-89
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 15-21
Sensepos                               internal static fixed bin(8,0)           initial dcl 7-89
Set_buffer_size                        internal static fixed bin(8,0)           initial dcl 7-89
Setbusy                                internal static fixed bin(8,0)           initial dcl 7-89
TIMER                                  internal static fixed bin(17,0)          initial dcl 15-24
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 1-33
Tabecho                                internal static fixed bin(8,0)           initial dcl 7-89
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 15-25
Upstate                                internal static fixed bin(8,0)           initial dcl 7-89
WIRED_ECHO_BREAK_SIZE                  internal static fixed bin(17,0)          initial dcl 20-16
WORDS_IN_ECHO_BREAK_TABLE              internal static fixed bin(17,0)          initial dcl 20-17
WRU_TIMEOUT                            internal static fixed bin(17,0)          initial dcl 15-20
Wru                                    internal static fixed bin(8,0)           initial dcl 7-89
Xmit_hold                              internal static fixed bin(8,0)           initial dcl 7-89
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 1-19
accept_calls                           internal static fixed bin(8,0)           initial dcl 7-24
accept_direct_input                    internal static fixed bin(8,0)           initial dcl 7-65
accept_last_output                     internal static fixed bin(8,0)           initial dcl 7-24
accept_new_terminal                    internal static fixed bin(8,0)           initial dcl 7-65
ack_echnego_init                       internal static fixed bin(8,0)           initial dcl 7-65
ack_echnego_stop                       internal static fixed bin(8,0)           initial dcl 7-65
acu_dial_failure                       internal static fixed bin(8,0)           initial dcl 7-65
acu_line_occupied                      internal static fixed bin(8,0)           initial dcl 7-65
acu_no_good                            internal static fixed bin(8,0)           initial dcl 7-65
acu_no_power                           internal static fixed bin(8,0)           initial dcl 7-65
blast                                  internal static fixed bin(8,0)           initial dcl 7-24
break_acknowledged                     internal static fixed bin(8,0)           initial dcl 7-24
break_condition                        internal static fixed bin(8,0)           initial dcl 7-65
bsizec                                 internal static fixed bin(17,0)          initial dcl 1-28
channel_manager$check_modes     000000 constant        entry                    external dcl 14-19
channel_manager$control         000000 constant        entry                    external dcl 14-13
channel_manager$get_modes       000000 constant        entry                    external dcl 14-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 14-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 14-31
channel_manager$read            000000 constant        entry                    external dcl 14-7
channel_manager$set_modes       000000 constant        entry                    external dcl 14-16
channel_manager$write           000000 constant        entry                    external dcl 14-10
checksum_error                         internal static fixed bin(8,0)           initial dcl 7-24
connect_to_slave                       internal static fixed bin(8,0)           initial dcl 7-65
dialup_info                            automatic       structure                level 1 dcl 15-30
disconnect_accepted                    internal static fixed bin(8,0)           initial dcl 7-24
disconnect_all_lines                   internal static fixed bin(8,0)           initial dcl 7-24
disconnected_line                      internal static fixed bin(8,0)           initial dcl 7-65
dont_accept_calls                      internal static fixed bin(8,0)           initial dcl 7-24
dump_mem                               internal static fixed bin(8,0)           initial dcl 7-24
echo_data                              based           structure                level 1 dcl 20-19
echo_datap                             automatic       pointer                  dcl 20-15
error_message                          internal static fixed bin(8,0)           initial dcl 7-65
first_acu_op_code                      internal static fixed bin(8,0)           initial dcl 7-65
fnp_break                              internal static fixed bin(8,0)           initial dcl 7-24
fnp_chan_meter_struc                   based           structure                level 1 dcl 17-10
fnp_chan_meterp                        automatic       pointer                  dcl 17-7
fnp_meterp                             automatic       pointer                  dcl 16-11
fnp_meters                             based           structure                level 1 dcl 16-35
free_block                             based           structure                level 1 dcl 3-23
free_blockp                            automatic       pointer                  dcl 3-20
get_comm_meters_info                   based           structure                level 1 dcl 18-8
global_opcodes                         internal static fixed bin(8,0)           initial array dcl 7-126
init_complete                          internal static fixed bin(8,0)           initial dcl 7-24
init_echo_negotiation                  internal static fixed bin(8,0)           initial dcl 7-24
input_accepted                         internal static fixed bin(8,0)           initial dcl 7-24
input_bpart                            internal static fixed bin(18,0)          initial dcl 1-19
input_fc_chars                         internal static fixed bin(8,0)           initial dcl 7-24
input_flow_control_info                based           structure                level 1 dcl 13-9
input_in_mailbox                       internal static fixed bin(8,0)           initial dcl 7-65
interrupt_info                         automatic       bit(72)                  dcl 15-28
io_chnl_util$canonicalize_chanid
                                000000 constant        entry                    external dcl 11-8
io_chnl_util$iom_to_name        000000 constant        entry                    external dcl 11-12
io_chnl_util$name_to_iom        000000 constant        entry                    external dcl 11-16
io_manager$assign_add           000000 constant        entry                    external dcl 19-15
io_manager$connect              000000 constant        entry                    external dcl 19-26
io_manager$connect_abs          000000 constant        entry                    external dcl 19-29
io_manager$connect_direct       000000 constant        entry                    external dcl 19-32
io_manager$get_status           000000 constant        entry                    external dcl 19-35
io_manager$ignore_interrupt     000000 constant        entry                    external dcl 19-41
io_manager$mask                 000000 constant        entry                    external dcl 19-38
io_manager$unassign_delete      000000 constant        entry                    external dcl 19-23
io_manager$workspace_tdcw       000000 constant        entry                    external dcl 19-47
io_manager_arg_ptr                     automatic       pointer                  dcl 19-49
last_acu_op_code                       internal static fixed bin(8,0)           initial dcl 7-65
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
line_control                           internal static fixed bin(8,0)           initial dcl 7-24
line_masked                            internal static fixed bin(8,0)           initial dcl 7-65
line_status                            internal static fixed bin(8,0)           initial dcl 7-65
line_types                             internal static char(16)                 initial array packed unaligned dcl 9-54
lock_ptr                               automatic       pointer                  dcl 2-9
logical_chan_meters                    based           structure                level 1 dcl 18-17
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 3-43
output_bpart                           internal static fixed bin(18,0)          initial dcl 1-19
output_fc_chars                        internal static fixed bin(8,0)           initial dcl 7-24
output_flow_control_info               based           structure                level 1 dcl 13-19
patch_mem                              internal static fixed bin(8,0)           initial dcl 7-24
qblock_size                            internal static fixed bin(17,0)          initial dcl 1-27
rcd                                    internal static fixed bin(8,0)           initial dcl 7-14
reject_request_temp                    internal static fixed bin(8,0)           initial dcl 7-24
report_meters                          internal static fixed bin(8,0)           initial dcl 7-24
rtx                                    internal static fixed bin(8,0)           initial dcl 7-14
rtx_info                               automatic       structure                level 1 dcl 15-38
s6180_params                           internal static fixed bin(8,0)           initial dcl 7-65
saved_meters                           based           structure                level 1 dcl 4-68
send_output                            internal static fixed bin(8,0)           initial dcl 7-65
set_delay_table                        internal static fixed bin(8,0)           initial dcl 7-24
set_echnego_break_table                internal static fixed bin(8,0)           initial dcl 7-24
set_framing_chars                      internal static fixed bin(8,0)           initial dcl 7-24
start_negotiated_echo                  internal static fixed bin(8,0)           initial dcl 7-24
stop_negotiated_echo                   internal static fixed bin(8,0)           initial dcl 7-24
sync_msg_size                          internal static fixed bin(8,0)           initial dcl 7-24
terminal_accepted                      internal static fixed bin(8,0)           initial dcl 7-24
terminal_rejected                      internal static fixed bin(8,0)           initial dcl 7-24
timer_info                             automatic       structure                level 1 dcl 15-50
tty_ev                                 internal static fixed bin(17,0)          initial dcl 1-19
tty_space_man$free_buffer       000000 constant        entry                    external dcl 8-14
tty_space_man$get_buffer        000000 constant        entry                    external dcl 8-13
tty_space_man$get_chain         000000 constant        entry                    external dcl 8-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 8-11
tty_space_man$needs_space       000000 constant        entry                    external dcl 8-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 8-17
wcd                                    internal static fixed bin(8,0)           initial dcl 7-14
wru_timeout                            internal static fixed bin(8,0)           initial dcl 7-65
wtx                                    internal static fixed bin(8,0)           initial dcl 7-14

NAMES DECLARED BY EXPLICIT CONTEXT.
TRACE                           005106 constant        entry                    internal dcl 2070 ref 399 541 591 617 642 1997 2010
TRACE_ERROR                     005141 constant        entry                    internal dcl 2081 ref 517 578 604 623 2042 2065
assign                          003754 constant        entry                    external dcl 1993
assign_channel                  004620 constant        entry                    internal dcl 2018 ref 424 2000
assign_channel_return           004706 constant        label                    dcl 2038 ref 2026 2032
bad_channel                     000517 constant        label                    dcl 393 ref 387 401 403
bad_mode                        003170 constant        label                    dcl 1200 ref 1191
check_modes                     002736 constant        entry                    external dcl 1146
control                         002244 constant        entry                    external dcl 727
fnp_lock                        003704 constant        entry                    external dcl 1496
fnp_unlock                      003730 constant        entry                    external dcl 1504
get_modes                       003373 constant        entry                    external dcl 1264
hpriv_control                   003476 constant        entry                    external dcl 1374
hpriv_exit                      003677 constant        label                    dcl 1492 ref 1405
init_abort                      001224 constant        label                    dcl 517 ref 421 425 429 448 477 502
init_exit                       001223 constant        label                    dcl 514 ref 395
init_multiplexer                000414 constant        entry                    external dcl 368
lock                            004511 constant        entry                    internal dcl 1911 ref 542 657 1404 1500 1523
order_error                     002432 constant        label                    dcl 982 ref 817 1040
priv_control                    003430 constant        entry                    external dcl 1273
process_mode                    004176 constant        entry                    internal dcl 1645 ref 1243 1249 1253
read                            002041 constant        entry                    external dcl 670
save_copied_meters              004114 constant        entry                    internal dcl 1619 ref 1535
set_modes                       003214 constant        entry                    external dcl 1217
setup                           004047 constant        entry                    internal dcl 1513 ref 593 619 688 988 1160 1231
shutdown                        001724 constant        entry                    external dcl 629
shutdown_return                 002032 constant        label                    dcl 665 ref 640
start                           001606 constant        entry                    external dcl 584
stop                            001655 constant        entry                    external dcl 610
terminate_multiplexer           001323 constant        entry                    external dcl 532
terminate_return                001572 constant        label                    dcl 578 ref 543
unassign                        004012 constant        entry                    external dcl 2005
unassign_channel                004767 constant        entry                    internal dcl 2047 ref 571 2013
unassign_return                 005021 constant        label                    dcl 2060 ref 2055
uncp_multiplexer                000401 constant        entry                    external dcl 24
unlock                          004575 constant        entry                    internal dcl 1942 ref 576 602 620 660 720 1039 1139
                                                                                  1213 1258 1409 1510 1530
write                           002066 constant        entry                    external dcl 681
write_exit                      002226 constant        label                    dcl 720

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6126        6256    5273        6136
Length      7214    5273       130         721     632           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
uncp_multiplexer                    478 external procedure  is an external procedure.  
on unit on line 499                  64 on unit               
setup                                   internal procedure  shares stack frame of external procedure uncp_multiplexer.  
save_copied_meters                      internal procedure  shares stack frame of external procedure uncp_multiplexer.  
process_mode                            internal procedure  shares stack frame of external procedure uncp_multiplexer.  
lock                                    internal procedure  shares stack frame of external procedure uncp_multiplexer.  
unlock                                  internal procedure  shares stack frame of external procedure uncp_multiplexer.  
assign_channel                          internal procedure  shares stack frame of external procedure uncp_multiplexer.  
unassign_channel                        internal procedure  shares stack frame of external procedure uncp_multiplexer.  
TRACE                                   internal procedure  shares stack frame of external procedure uncp_multiplexer.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
uncp_multiplexer         000100 code                        uncp_multiplexer
                         000101 devx                        uncp_multiplexer
                         000102 my_chan_name                uncp_multiplexer
                         000103 dno                         uncp_multiplexer
                         000104 pcb_space                   uncp_multiplexer
                         000105 space_needed                uncp_multiplexer
                         000106 output_ptr                  uncp_multiplexer
                         000110 chanx                       uncp_multiplexer
                         000111 output_length               uncp_multiplexer
                         000112 i                           uncp_multiplexer
                         000114 lastp                       uncp_multiplexer
                         000116 order                       uncp_multiplexer
                         000126 data_ptr                    uncp_multiplexer
                         000130 set_write_status            uncp_multiplexer
                         000131 locked                      uncp_multiplexer
                         000132 queue_locked                uncp_multiplexer
                         000133 mylock                      uncp_multiplexer
                         000134 opcode                      uncp_multiplexer
                         000135 alter_type                  uncp_multiplexer
                         000136 check                       uncp_multiplexer
                         000137 mbx_data_len                uncp_multiplexer
                         000140 mbx_data_long               uncp_multiplexer
                         000150 alter_data                  uncp_multiplexer
                         000155 dumpin                      uncp_multiplexer
                         000156 dumpout                     uncp_multiplexer
                         000157 get_meters                  uncp_multiplexer
                         000160 temp_saved_meters_ptr       uncp_multiplexer
                         000162 local_line_type             uncp_multiplexer
                         000163 opend                       uncp_multiplexer
                         000164 modex                       uncp_multiplexer
                         000166 mode_name                   uncp_multiplexer
                         000170 mode_on                     uncp_multiplexer
                         000171 mode_set                    uncp_multiplexer
                         000172 hndlquit_set                uncp_multiplexer
                         000173 base_len                    uncp_multiplexer
                         000174 block_len                   uncp_multiplexer
                         000175 chars_per_sec               uncp_multiplexer
                         000176 hsla_flag                   uncp_multiplexer
                         000177 old_flag                    uncp_multiplexer
                         000200 pcb_space_ptr               uncp_multiplexer
                         000202 prev_la_no                  uncp_multiplexer
                         000203 la_no                       uncp_multiplexer
                         000204 subchan                     uncp_multiplexer
                         000205 his_fnp_no                  uncp_multiplexer
                         000206 pcbx                        uncp_multiplexer
                         000207 name                        uncp_multiplexer
                         000226 ttybp                       uncp_multiplexer
                         000230 blockp                      uncp_multiplexer
                         000232 lctp                        uncp_multiplexer
                         000234 lctep                       uncp_multiplexer
                         000236 lcntp                       uncp_multiplexer
                         000240 infop                       uncp_multiplexer
                         000242 fnpp                        uncp_multiplexer
                         000244 n_pcbs                      uncp_multiplexer
                         000246 pcbp                        uncp_multiplexer
                         000250 miip                        uncp_multiplexer
                         000252 mii_chan_count              uncp_multiplexer
                         000254 mclp                        uncp_multiplexer
                         000256 mclep                       uncp_multiplexer
                         000260 uncpbp                      uncp_multiplexer
                         000262 fnp_no                      uncp_multiplexer
                         000322 copied_meters_ptr           save_copied_meters
                         000334 mode_name_index             process_mode

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_le_a              alloc_bit_temp      cat_realloc_bits    call_ext_out_desc
call_ext_out        return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$interrupt     io_manager$assign             io_manager$unassign           lock$lock_fast
lock$unlock_fast              parse_fnp_name_               parse_tty_name_               syserr
syserr$error_code             tty_area_manager$allocate     tty_area_manager$free         tty_lock$lock_lcte
tty_space_man$free_chain      tty_space_man$free_space      tty_space_man$get_space       uncp$hangup_fnp_lines
uncp$interrupt                uncp$process_interrupt_queue  uncp$send_global_wcd          uncp$send_wcd
uncp_util$abort               uncp_util$fdump               uncp_util$fill_page_table     uncp_util$free_page_table
uncp_util$load

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dn355_data$                   error_table_$action_not_performed                           error_table_$bad_channel
error_table_$bad_mode         error_table_$fnp_down         error_table_$invalid_state    error_table_$io_assigned
error_table_$io_not_assigned  error_table_$io_not_available error_table_$io_not_configured
error_table_$noalloc          error_table_$undefined_order_request
error_table_$unimplemented_version                          pds$processid                 tty_buf$


CONSTANTS
005226  aa     077777000043
005227  aa     000001000000

005230  aa     777377777777

005232  aa     000004000000
005233  aa     000004000000
005234  aa     600000000041
005235  aa     000410000000
005236  aa     600000000041
005237  aa     000440000000
005240  ta     000137000000
005241  aa     000000000000
005242  ta     000144000000
005243  aa     000000000000

005244  aa     767777777777

005245  aa     777677777777

005246  aa     377777777777

005247  aa     677777777777

005250  aa     577777777777

005252  aa     000004000000
005253  aa     000000000000
005254  aa     600000000041
005255  aa     000376000000
005256  aa     600000000041
005257  aa     000100000000

005260  aa     007777000001

005262  aa     000002000000
005263  aa     000000000000
005264  aa     600000000041
005265  aa     000100000000

005266  aa     000002000000
005267  aa     000000000000
005270  aa     600000000041
005271  aa     000376000000

000000  aa     000000000005
000001  aa     000000000006
000002  aa     000000000007
000003  aa     000000000011
000004  aa     000000000015
000005  aa     000000000016
000006  aa     000000000017
000007  aa     000000000020
000010  aa     000000000021
000011  aa     000000000022

000012  aa     000000000014

000013  aa     000000000010
000014  aa     000000000016
000015  aa     000000000011
000016  aa     000000000024
000017  aa     000000000003
000020  aa     000000000027
000021  aa     000000000030
000022  aa     000000000033
000023  aa     000000000034
000024  aa     000000000041
000025  aa     000000000040
000026  aa     000000000037
000027  aa     000000000036

000030  aa  143 162 145 143	crec
000031  aa  150 157 040 040	ho  
000032  aa  164 141 142 145	tabe
000033  aa  143 150 157 040	cho 
000034  aa  154 146 145 143	lfec
000035  aa  150 157 040 040	ho  
000036  aa  145 143 150 157	echo
000037  aa  160 154 145 170	plex
000040  aa  146 165 154 154	full
000041  aa  144 160 170 040	dpx 
000042  aa  151 146 154 157	iflo
000043  aa  167 040 040 040	w   
000044  aa  157 146 154 157	oflo
000045  aa  167 040 040 040	w   

000046  aa  143 162 145 143	crec
000047  aa  150 157 040 040	ho  
000050  aa  164 141 142 145	tabe
000051  aa  143 150 157 040	cho 
000052  aa  154 146 145 143	lfec
000053  aa  150 157 040 040	ho  
000054  aa  145 143 150 157	echo
000055  aa  160 154 145 170	plex
000056  aa  146 165 154 154	full
000057  aa  144 160 170 040	dpx 
000060  aa  162 145 160 154	repl
000061  aa  141 171 040 040	ay  
000062  aa  160 157 154 151	poli
000063  aa  164 145 040 040	te  
000064  aa  142 162 145 141	brea
000065  aa  153 141 154 154	kall
000066  aa  160 162 145 146	pref
000067  aa  151 170 156 154	ixnl
000070  aa  156 157 137 157	no_o
000071  aa  165 164 160 040	utp 
000072  aa  070 142 151 164	8bit
000073  aa  040 040 040 040	    
000074  aa  157 144 144 160	oddp
000075  aa  040 040 040 040	    
000076  aa  157 146 154 157	oflo
000077  aa  167 040 040 040	w   
000100  aa  151 146 154 157	iflo
000101  aa  167 040 040 040	w   
000102  aa  142 154 153 137	blk_
000103  aa  170 146 145 162	xfer

000104  aa  150 156 144 154	hndl
000105  aa  161 165 151 164	quit

000106  aa     000000000110

000107  aa     524000000067

000110  aa     524000000043

000111  aa     524000000042

000112  aa     524000000120

000113  aa     524000000114

000114  aa     524000000036

000115  aa     000000000012

000116  aa  144 151 141 154	dial

000117  aa  144 165 155 160	dump

000120  aa  154 157 141 144	load

000121  aa     526000000010

000122  aa     526000000020

000123  aa  157 144 144 160	oddp

000124  aa  070 142 151 164	8bit

000125  aa     516000000220

000126  aa     514000000000

000127  aa     404000000010

000130  aa     524000000063

000131  aa  163 164 157 160	stop

000132  aa     516000000001

000133  aa     526000000040

000134  aa     400000000000

005272  aa     777777777777

000135  aa     000000000000

000136  aa     526000000001

000137  aa     524000000010

000140  aa  141 162 145 141	area

000141  aa     526077777777

000142  aa     404000000043

000143  aa     000000000004

000144  aa     514000000001

000145  aa     464000000000

000146  aa     000000000001

000147  aa     404000000021

000150  aa  151 146 154 157	iflo
000151  aa  167 000 000 000	w

000152  aa  142 154 153 137	blk_
000153  aa  170 146 145 162	xfer

000154  aa  142 162 145 141	brea
000155  aa  153 141 154 154	kall

000156  aa  165 156 141 163	unas
000157  aa  163 151 147 156	sign

000160  aa  141 163 163 151	assi
000161  aa  147 156 000 000	gn

000162  aa  150 156 144 154	hndl
000163  aa  161 165 151 164	quit

000164  aa  156 157 137 157	no_o
000165  aa  165 164 160 000	utp

000166  aa     000000000000
000167  aa     000000000000

000170  aa  154 151 163 164	list
000171  aa  145 156 000 000	en

000172  aa  141 142 157 162	abor
000173  aa  164 000 000 000	t

000174  aa  150 141 156 147	hang
000175  aa  165 160 000 000	up

000176  aa  163 150 165 164	shut
000177  aa  144 157 167 156	down

000200  aa  163 164 141 162	star
000201  aa  164 000 000 000	t

000202  aa     077777000043
000203  aa     000001000000

000204  aa  167 162 151 164	writ
000205  aa  145 137 163 164	e_st
000206  aa  141 164 165 163	atus

000207  aa  162 145 141 144	read
000210  aa  137 163 164 141	_sta
000211  aa  164 165 163 000	tus

000212  aa  165 156 141 163	unas
000213  aa  163 151 147 156	sign
000214  aa  137 143 150 141	_cha
000215  aa  156 156 145 154	nnel

000216  aa  141 163 163 151	assi
000217  aa  147 156 137 143	gn_c
000220  aa  150 141 156 156	hann
000221  aa  145 154 000 000	el

000222  aa  145 156 164 145	ente
000223  aa  162 137 162 145	r_re
000224  aa  143 145 151 166	ceiv
000225  aa  145 000 000 000	e

000226  aa  163 145 164 137	set_
000227  aa  154 151 156 145	line
000230  aa  137 164 171 160	_typ
000231  aa  145 000 000 000	e

000232  aa  151 156 151 164	init
000233  aa  137 155 165 154	_mul
000234  aa  164 151 160 154	tipl
000235  aa  145 170 145 162	exer

000236  aa  164 145 162 155	term
000237  aa  151 156 141 164	inat
000240  aa  145 137 155 165	e_mu
000241  aa  154 164 151 160	ltip
000242  aa  154 145 170 145	lexe
000243  aa  162 000 000 000	r

000244  aa  165 156 143 160	uncp
000245  aa  137 155 165 154	_mul
000246  aa  164 151 160 154	tipl
000247  aa  145 170 145 162	exer
000250  aa  072 040 155 171	: my
000251  aa  154 157 143 153	lock
000252  aa  040 145 162 162	 err
000253  aa  157 162 000 000	or

000254  aa  165 156 143 160	uncp
000255  aa  137 155 165 154	_mul
000256  aa  164 151 160 154	tipl
000257  aa  145 170 145 162	exer
000260  aa  044 136 141 072	$^a:
000261  aa  040 124 162 141	 Tra
000262  aa  143 151 156 147	cing
000263  aa  040 145 162 162	 err
000264  aa  157 162 056 000	or.

000265  aa  165 156 143 160	uncp
000266  aa  137 155 165 154	_mul
000267  aa  164 151 160 154	tipl
000270  aa  145 170 145 162	exer
000271  aa  044 136 141 072	$^a:
000272  aa  040 124 162 141	 Tra
000273  aa  143 151 156 147	cing
000274  aa  040 143 141 154	 cal
000275  aa  154 056 000 000	l.

000276  aa  165 156 143 160	uncp
000277  aa  137 155 165 154	_mul
000300  aa  164 151 160 154	tipl
000301  aa  145 170 145 162	exer
000302  aa  044 163 150 165	$shu
000303  aa  164 144 157 167	tdow
000304  aa  156 072 040 103	n: C
000305  aa  141 154 154 145	alle
000306  aa  144 040 167 151	d wi
000307  aa  164 150 040 156	th n
000310  aa  165 154 154 040	ull 
000311  aa  146 156 160 137	fnp_
000312  aa  160 164 162 000	ptr

000313  aa  165 156 143 160	uncp
000314  aa  137 155 165 154	_mul
000315  aa  164 151 160 154	tipl
000316  aa  145 170 145 162	exer
000317  aa  072 040 144 145	: de
000320  aa  142 165 147 147	bugg
000321  aa  151 156 147 040	ing 
000322  aa  163 164 157 160	stop
000323  aa  040 050 164 171	 (ty
000324  aa  160 145 040 147	pe g
000325  aa  157 040 164 157	o to
000326  aa  040 143 157 156	 con
000327  aa  164 151 156 165	tinu
000330  aa  145 051 056 000	e).

000331  aa  165 156 143 160	uncp
000332  aa  137 155 165 154	_mul
000333  aa  164 151 160 154	tipl
000334  aa  145 170 145 162	exer
000335  aa  044 141 163 163	$ass
000336  aa  151 147 156 137	ign_
000337  aa  143 150 141 156	chan
000340  aa  156 145 154 072	nel:
000341  aa  040 101 163 163	 Ass
000342  aa  151 147 156 155	ignm
000343  aa  145 156 164 040	ent 
000344  aa  157 146 040 106	of F
000345  aa  116 120 040 136	NP ^
000346  aa  141 040 136 133	a ^[
000347  aa  163 165 143 143	succ
000350  aa  145 145 144 145	eede
000351  aa  144 136 073 146	d^;f
000352  aa  141 151 154 145	aile
000353  aa  144 136 135 056	d^].

000354  aa  165 156 143 160	uncp
000355  aa  137 155 165 154	_mul
000356  aa  164 151 160 154	tipl
000357  aa  145 170 145 162	exer
000360  aa  044 165 156 141	$una
000361  aa  163 163 151 147	ssig
000362  aa  156 137 143 150	n_ch
000363  aa  141 156 156 145	anne
000364  aa  154 072 040 125	l: U
000365  aa  156 141 163 163	nass
000366  aa  151 147 156 155	ignm
000367  aa  145 156 164 040	ent 
000370  aa  157 146 040 106	of F
000371  aa  116 120 040 136	NP ^
000372  aa  141 040 136 133	a ^[
000373  aa  146 141 151 154	fail
000374  aa  145 144 136 073	ed^;
000375  aa  163 165 143 143	succ
000376  aa  145 145 144 145	eede
000377  aa  144 136 135 056	d^].

BEGIN PROCEDURE uncp_multiplexer
ENTRY TO uncp_multiplexer                                   STATEMENT 1 ON LINE 24
uncp_multiplexer:
     proc;

000400  da     000457200000
000401  aa   000740 6270 00	eax7 	480
000402  aa  7 00034 3521 20	epp2 	pr7|28,*
000403  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000404  aa     000000000000
000405  aa     000000000000
						STATEMENT 1 ON LINE 368
init_multiplexer:
     entry (a_devx, a_init_info_ptr, a_fnpp, a_code);

000406  aa   000020 7100 04	tra  	16,ic		000426
ENTRY TO init_multiplexer                                   STATEMENT 1 ON LINE 368
init_multiplexer:
     entry (a_devx, a_init_info_ptr, a_fnpp, a_code);

000407  at     000004000147
000410  tt     000145000145
000411  ta     000142000000
000412  ta     000407000000
000413  da     000467300000
000414  aa   000740 6270 00	eax7 	480
000415  aa  7 00034 3521 20	epp2 	pr7|28,*
000416  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000417  aa     000010000000
000420  aa     000000000000
000421  aa  6 00032 3735 20	epp7 	pr6|26,*
000422  aa  7 00006 3715 20	epp5 	pr7|6,*
000423  aa  6 00264 6515 00	spri5	pr6|180
000424  aa  7 00010 3535 20	epp3 	pr7|8,*
000425  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 377
	devx = a_devx;

000426  aa  6 00032 3735 20	epp7 	pr6|26,*
000427  aa  7 00002 2361 20	ldq  	pr7|2,*		a_devx
000430  aa  6 00101 7561 00	stq  	pr6|65		devx
						STATEMENT 1 ON LINE 378
	miip = a_init_info_ptr;

000431  aa  7 00004 3715 20	epp5 	pr7|4,*		a_init_info_ptr
000432  aa  5 00000 3715 20	epp5 	pr5|0,*		a_init_info_ptr
000433  aa  6 00250 6515 00	spri5	pr6|168		miip
						STATEMENT 1 ON LINE 379
	mii_chan_count = mux_init_info.no_channels;

000434  aa  5 00000 2361 00	ldq  	pr5|0		mux_init_info.no_channels
000435  aa  6 00252 7561 00	stq  	pr6|170		mii_chan_count
						STATEMENT 1 ON LINE 380
	pcb_space_ptr = null ();

000436  aa   777544 2370 04	ldaq 	-156,ic		000202 = 077777000043 000001000000
000437  aa  6 00200 7571 00	staq 	pr6|128		pcb_space_ptr
						STATEMENT 1 ON LINE 381
	infop = addr (dn355_data$);

000440  la  4 00112 3535 20	epp3 	pr4|74,*		dn355_data$
000441  aa  6 00240 2535 00	spri3	pr6|160		infop
						STATEMENT 1 ON LINE 382
	ttybp = addr (tty_buf$);

000442  la  4 00110 3515 20	epp1 	pr4|72,*		tty_buf$
000443  aa  6 00226 2515 00	spri1	pr6|150		ttybp
						STATEMENT 1 ON LINE 383
	uncpbp = datanet_info.uncp_bufp;

000444  aa  3 00010 3715 20	epp5 	pr3|8,*		datanet_info.uncp_bufp
000445  aa  6 00260 6515 00	spri5	pr6|176		uncpbp
						STATEMENT 1 ON LINE 384
	lctp = tty_buf.lct_ptr;

000446  aa  1 00006 3535 20	epp3 	pr1|6,*		tty_buf.lct_ptr
000447  aa  6 00232 2535 00	spri3	pr6|154		lctp
						STATEMENT 1 ON LINE 386
	lcntp = lct.lcnt_ptr;

000450  aa  3 00002 3715 20	epp5 	pr3|2,*		lct.lcnt_ptr
000451  aa  6 00236 6515 00	spri5	pr6|158		lcntp
						STATEMENT 1 ON LINE 387
	if length (rtrim (lcnt.names (devx))) ^= 1
	then go to bad_channel;

000452  aa  6 00101 2361 00	ldq  	pr6|65		devx
000453  aa   000003 7360 00	qls  	3
000454  aa  5 77770 3515 06	epp1 	pr5|-8,ql		lcnt.names
000455  aa  6 00374 7561 00	stq  	pr6|252
000456  aa  000 000 165 500	tctr 	(pr)
000457  aa  1 00000 00 0040	desc9a	pr1|0,32		lcnt.names
000460  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000461  aa  6 00056 0001 00	arg  	pr6|46
000462  aa  6 00056 2361 00	ldq  	pr6|46
000463  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000464  aa  6 00375 7561 00	stq  	pr6|253
000465  aa   000040 2360 07	ldq  	32,dl
000466  aa  6 00375 1761 00	sbq  	pr6|253
000467  aa   000001 1160 07	cmpq 	1,dl
000470  aa   000027 6010 04	tnz  	23,ic		000517
						STATEMENT 1 ON LINE 389
	my_chan_name = rtrim (lcnt.names (devx));

000471  aa  6 00375 7561 00	stq  	pr6|253
000472  aa  6 00374 2361 00	ldq  	pr6|252
000473  aa   000002 7360 00	qls  	2
000474  aa  6 00102 4501 00	stz  	pr6|66		my_chan_name
000475  aa  6 00375 2351 00	lda  	pr6|253
000476  aa  040 100 100 546	mlr  	(pr,rl,ql),(pr),fill(040)
000477  aa  5 77770 00 0005	desc9a	pr5|-8,al		lcnt.names
000500  aa  6 00102 00 0001	desc9a	pr6|66,1		my_chan_name
						STATEMENT 1 ON LINE 390
	call parse_fnp_name_ (my_chan_name, dno);

000501  aa  6 00102 3521 00	epp2 	pr6|66		my_chan_name
000502  aa  6 00400 2521 00	spri2	pr6|256
000503  aa  6 00103 3521 00	epp2 	pr6|67		dno
000504  aa  6 00402 2521 00	spri2	pr6|258
000505  aa   777431 3520 04	epp2 	-231,ic		000136 = 526000000001
000506  aa  6 00404 2521 00	spri2	pr6|260
000507  aa   777440 3520 04	epp2 	-224,ic		000147 = 404000000021
000510  aa  6 00406 2521 00	spri2	pr6|262
000511  aa  6 00376 6211 00	eax1 	pr6|254
000512  aa   010000 4310 07	fld  	4096,dl
000513  la  4 00046 3521 20	epp2 	pr4|38,*		parse_fnp_name_
000514  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 391
	if dno < 0				/* unreasonable name */
	then do;

000515  aa  6 00103 2361 00	ldq  	pr6|67		dno
000516  aa   000005 6050 04	tpl  	5,ic		000523
						STATEMENT 1 ON LINE 393
bad_channel:
	     a_code = error_table_$bad_channel;

000517  aa  6 00044 3701 20	epp4 	pr6|36,*
000520  la  4 00064 2361 20	ldq  	pr4|52,*		error_table_$bad_channel
000521  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 395
	     go to init_exit;

000522  aa   000501 7100 04	tra  	321,ic		001223
						STATEMENT 1 ON LINE 396
	end;

						STATEMENT 1 ON LINE 398
	fnpp = addr (datanet_info.per_datanet (dno));

000523  aa   000072 4020 07	mpy  	58,dl
000524  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
000525  aa  7 77730 3735 06	epp7 	pr7|-40,ql	datanet_info.per_datanet
000526  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 399
	call TRACE ("init_multiplexer");

000527  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000530  aa   777503 00 0020	desc9a	-189,16		000232 = 151156151164
000531  aa  6 00376 00 0040	desc9a	pr6|254,32
000532  aa   004534 3520 04	epp2 	2396,ic		005266 = 000002000000
000533  aa   004353 6700 04	tsp4 	2283,ic		005106
						STATEMENT 1 ON LINE 401
	if my_chan_name ^= fnp_info.fnp_tag
	then go to bad_channel;

000534  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
000535  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_tag
000536  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
000537  aa  6 00375 7551 00	sta  	pr6|253		fnp_info.fnp_tag
000540  aa  6 00102 2351 00	lda  	pr6|66		my_chan_name
000541  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
000542  aa  6 00375 1151 00	cmpa 	pr6|253		fnp_info.fnp_tag
000543  aa   777754 6010 04	tnz  	-20,ic		000517
						STATEMENT 1 ON LINE 403
	if ^tty_buf.fnp_config_flags (dno)
	then go to bad_channel;

000544  aa  6 00103 7271 00	lxl7 	pr6|67		dno
000545  aa  6 00226 3715 20	epp5 	pr6|150,*		ttybp
000546  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
000547  aa  5 00004 70 0001	descb	pr5|4(35),1	tty_buf.fnp_config_flags
000550  aa   000000 00 0000	descb	0,0
000551  aa   777746 6000 04	tze  	-26,ic		000517
						STATEMENT 1 ON LINE 406
	call lock$lock_fast (addr (datanet_info.configuration_lock));

000552  aa  6 00240 3535 20	epp3 	pr6|160,*		datanet_info.configuration_lock
000553  aa  6 00410 2535 00	spri3	pr6|264
000554  aa  6 00410 3521 00	epp2 	pr6|264
000555  aa  6 00400 2521 00	spri2	pr6|256
000556  aa  6 00376 6211 00	eax1 	pr6|254
000557  aa   004000 4310 07	fld  	2048,dl
000560  aa  6 00044 3701 20	epp4 	pr6|36,*
000561  la  4 00034 3521 20	epp2 	pr4|28,*		lock$lock_fast
000562  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 408
	if uncpbp ^= null then do;

000563  aa  6 00260 2371 00	ldaq 	pr6|176		uncpbp
000564  aa   777416 6770 04	eraq 	-242,ic		000202 = 077777000043 000001000000
000565  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000566  aa   000013 6000 04	tze  	11,ic		000601
						STATEMENT 1 ON LINE 409
	     unspec (uncp_buf) = ""b;

000567  aa  6 00260 3735 20	epp7 	pr6|176,*		uncpbp
000570  aa   017544 7270 07	lxl7 	8036,dl
000571  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000572  aa   000000 00 0000	desc9a	0,0
000573  aa  7 00000 00 0017	desc9a	pr7|0,x7
						STATEMENT 1 ON LINE 410
 	     uncp_buf.cq_max_size = UNCP_CQ_SIZE;

000574  aa   003720 2360 07	ldq  	2000,dl
000575  aa  7 00007 7561 00	stq  	pr7|7		uncp_buf.cq_max_size
						STATEMENT 1 ON LINE 411
 	     uncp_buf.cq_free = uncp_buf.cq_max_size;

000576  aa  7 00006 7561 00	stq  	pr7|6		uncp_buf.cq_free
						STATEMENT 1 ON LINE 412
 	     uncp_buf.cq_hbound = uncp_buf.cq_max_size - 1;

000577  aa   000001 1760 07	sbq  	1,dl
000600  aa  7 00001 7561 00	stq  	pr7|1		uncp_buf.cq_hbound
						STATEMENT 1 ON LINE 414
	end;

						STATEMENT 1 ON LINE 416
	fnp_info.lcte_ptr = addr (lct.lcte_array (devx));

000601  aa  6 00101 2361 00	ldq  	pr6|65		devx
000602  aa   000005 7360 00	qls  	5
000603  aa  6 00232 3735 20	epp7 	pr6|154,*		lctp
000604  aa  7 77760 3735 06	epp7 	pr7|-16,ql	lct.lcte_array
000605  aa  6 00242 3715 20	epp5 	pr6|162,*		fnpp
000606  aa  5 00032 6535 00	spri7	pr5|26		fnp_info.lcte_ptr
						STATEMENT 1 ON LINE 418
	if fnp_info.t_and_d_in_progress		/* lcte will be invalid, but still */
	then do;

000607  aa  5 00030 2351 00	lda  	pr5|24		fnp_info.t_and_d_in_progress
000610  aa   001000 3150 03	cana 	512,du
000611  aa   000005 6000 04	tze  	5,ic		000616
						STATEMENT 1 ON LINE 420
	     code = error_table_$io_not_available;

000612  aa  6 00044 3701 20	epp4 	pr6|36,*
000613  la  4 00102 2361 20	ldq  	pr4|66,*		error_table_$io_not_available
000614  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 421
	     go to init_abort;

000615  aa   000407 7100 04	tra  	263,ic		001224
						STATEMENT 1 ON LINE 422
	end;

						STATEMENT 1 ON LINE 424
	call assign_channel (code);

000616  aa   004444 3520 04	epp2 	2340,ic		005262 = 000002000000
000617  aa   004001 6700 04	tsp4 	2049,ic		004620
						STATEMENT 1 ON LINE 425
	if code ^= 0
	then go to init_abort;

000620  aa  6 00100 2361 00	ldq  	pr6|64		code
000621  aa   000403 6010 04	tnz  	259,ic		001224
						STATEMENT 1 ON LINE 428
	call uncp_util$fill_page_table ((fnp_info.fnp_number), code);

000622  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
000623  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
000624  aa   000011 7350 00	als  	9
000625  aa   000077 7730 00	lrl  	63
000626  aa  6 00375 7561 00	stq  	pr6|253
000627  aa  6 00375 3521 00	epp2 	pr6|253
000630  aa  6 00400 2521 00	spri2	pr6|256
000631  aa  6 00100 3521 00	epp2 	pr6|64		code
000632  aa  6 00402 2521 00	spri2	pr6|258
000633  aa  6 00376 6211 00	eax1 	pr6|254
000634  aa   010000 4310 07	fld  	4096,dl
000635  aa  6 00044 3701 20	epp4 	pr6|36,*
000636  la  4 00022 3521 20	epp2 	pr4|18,*		uncp_util$fill_page_table
000637  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 429
	if code ^= 0
	then go to init_abort;

000640  aa  6 00100 2361 00	ldq  	pr6|64		code
000641  aa   000363 6010 04	tnz  	243,ic		001224
						STATEMENT 1 ON LINE 432
	do i = lbound (fnp_info.hsla_idx, 1) to hbound (fnp_info.hsla_idx, 1);

000642  aa  6 00112 4501 00	stz  	pr6|74		i
000643  aa   000000 0110 03	nop  	0,du
000644  aa  6 00112 2361 00	ldq  	pr6|74		i
000645  aa   000002 1160 07	cmpq 	2,dl
000646  aa   000007 6054 04	tpnz 	7,ic		000655
						STATEMENT 1 ON LINE 434
	     fnp_info.hsla_idx (i) = -1;

000647  aa   000001 3360 07	lcq  	1,dl
000650  aa  6 00112 7271 00	lxl7 	pr6|74		i
000651  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
000652  aa  7 00021 7561 17	stq  	pr7|17,7		fnp_info.hsla_idx
						STATEMENT 1 ON LINE 435
	end;

000653  aa  6 00112 0541 00	aos  	pr6|74		i
000654  aa   777770 7100 04	tra  	-8,ic		000644
						STATEMENT 1 ON LINE 436
	do i = lbound (fnp_info.lsla_idx, 1) to hbound (fnp_info.lsla_idx, 1);

000655  aa  6 00112 4501 00	stz  	pr6|74		i
000656  aa  6 00112 2361 00	ldq  	pr6|74		i
000657  aa   000005 1160 07	cmpq 	5,dl
000660  aa   000007 6054 04	tpnz 	7,ic		000667
						STATEMENT 1 ON LINE 438
	     fnp_info.lsla_idx (i) = -1;

000661  aa   000001 3360 07	lcq  	1,dl
000662  aa  6 00112 7271 00	lxl7 	pr6|74		i
000663  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
000664  aa  7 00013 7561 17	stq  	pr7|11,7		fnp_info.lsla_idx
						STATEMENT 1 ON LINE 439
	end;

000665  aa  6 00112 0541 00	aos  	pr6|74		i
000666  aa   777770 7100 04	tra  	-8,ic		000656
						STATEMENT 1 ON LINE 442
	pcb_space = size (pcb) * mii_chan_count;

000667  aa   000010 2360 07	ldq  	8,dl
000670  aa  6 00252 4021 00	mpy  	pr6|170		mii_chan_count
000671  aa  6 00104 7561 00	stq  	pr6|68		pcb_space
						STATEMENT 1 ON LINE 443
	space_needed = pcb_space + PCB_SIZE_INCR * DCW_LIST_SIZE;

000672  aa   000200 2350 07	lda  	128,dl
000673  aa   000044 7330 00	lrs  	36
000674  aa  6 00104 0331 00	adl  	pr6|68		pcb_space
000675  aa  6 00105 7561 00	stq  	pr6|69		space_needed
						STATEMENT 1 ON LINE 444
	call tty_space_man$get_space (space_needed, pcb_space_ptr);

000676  aa  6 00105 3521 00	epp2 	pr6|69		space_needed
000677  aa  6 00400 2521 00	spri2	pr6|256
000700  aa  6 00200 3521 00	epp2 	pr6|128		pcb_space_ptr
000701  aa  6 00402 2521 00	spri2	pr6|258
000702  aa  6 00376 6211 00	eax1 	pr6|254
000703  aa   010000 4310 07	fld  	4096,dl
000704  aa  6 00044 3701 20	epp4 	pr6|36,*
000705  la  4 00114 3521 20	epp2 	pr4|76,*		tty_space_man$get_space
000706  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 445
	if pcb_space_ptr = null			/* this would be unfortunate */
	then do;

000707  aa  6 00200 2371 00	ldaq 	pr6|128		pcb_space_ptr
000710  aa   777272 6770 04	eraq 	-326,ic		000202 = 077777000043 000001000000
000711  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000712  aa   000005 6010 04	tnz  	5,ic		000717
						STATEMENT 1 ON LINE 447
	     a_code = error_table_$noalloc;

000713  aa  6 00044 3701 20	epp4 	pr6|36,*
000714  la  4 00056 2361 20	ldq  	pr4|46,*		error_table_$noalloc
000715  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 448
	     go to init_abort;

000716  aa   000306 7100 04	tra  	198,ic		001224
						STATEMENT 1 ON LINE 449
	end;

						STATEMENT 1 ON LINE 450
	n_pcbs, fnp_info.no_of_channels = mii_chan_count;

000717  aa  6 00252 2361 00	ldq  	pr6|170		mii_chan_count
000720  aa  6 00244 7561 00	stq  	pr6|164		n_pcbs
000721  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
000722  aa  7 00006 7561 00	stq  	pr7|6		fnp_info.no_of_channels
						STATEMENT 1 ON LINE 451
	pcb_space_ptr -> pcb_array (*).saved_meters_ptr = null ();

000723  aa   000001 2360 07	ldq  	1,dl
000724  aa  6 00276 7561 00	stq  	pr6|190
000725  aa   000000 0110 03	nop  	0,du
000726  aa  6 00276 2361 00	ldq  	pr6|190
000727  aa   000003 7360 00	qls  	3
000730  aa   000000 6270 06	eax7 	0,ql
000731  aa   004327 2360 04	ldq  	2263,ic		005260 = 007777000001
000732  aa  6 00200 3735 20	epp7 	pr6|128,*		pcb_space_ptr
000733  aa  7 77776 7561 17	stq  	pr7|-2,7		pcb_array.saved_meters_ptr
000734  aa  6 00276 2361 00	ldq  	pr6|190
000735  aa  6 00276 0541 00	aos  	pr6|190
000736  aa  6 00244 1161 00	cmpq 	pr6|164		n_pcbs
000737  aa   777767 6040 04	tmi  	-9,ic		000726
						STATEMENT 1 ON LINE 453
	fnp_info.pcb_array_ptr = pcb_space_ptr;

000740  aa  6 00242 3715 20	epp5 	pr6|162,*		fnpp
000741  aa  5 00002 6535 00	spri7	pr5|2		fnp_info.pcb_array_ptr
						STATEMENT 1 ON LINE 454
	fnp_info.dcw_list_array_ptr = addrel (pcb_space_ptr, pcb_space);

000742  aa  6 00104 2361 00	ldq  	pr6|68		pcb_space
000743  aa  7 00000 3521 06	epp2 	pr7|0,ql
000744  aa   000000 0520 03	adwp2	0,du
000745  aa  5 00004 2521 00	spri2	pr5|4		fnp_info.dcw_list_array_ptr
						STATEMENT 1 ON LINE 456
	string (fnp_info.flags) = "0"b;

000746  aa  5 00030 4501 00	stz  	pr5|24
						STATEMENT 1 ON LINE 457
	prev_la_no = -1;

000747  aa   000001 3360 07	lcq  	1,dl
000750  aa  6 00202 7561 00	stq  	pr6|130		prev_la_no
						STATEMENT 1 ON LINE 458
	old_flag = "1"b;

000751  aa   400000 2350 03	lda  	131072,du
000752  aa  6 00177 7551 00	sta  	pr6|127		old_flag
						STATEMENT 1 ON LINE 465
	do pcbx = 1 to n_pcbs;

000753  aa  6 00244 2361 00	ldq  	pr6|164		n_pcbs
000754  aa  6 00277 7561 00	stq  	pr6|191
000755  aa   000001 2360 07	ldq  	1,dl
000756  aa  6 00206 7561 00	stq  	pr6|134		pcbx
000757  aa   000000 0110 03	nop  	0,du
000760  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
000761  aa  6 00277 1161 00	cmpq 	pr6|191
000762  aa   000225 6054 04	tpnz 	149,ic		001207
						STATEMENT 1 ON LINE 466
	     pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));

000763  aa   000003 7360 00	qls  	3
000764  aa  6 00200 3735 20	epp7 	pr6|128,*		pcb_space_ptr
000765  aa  7 77770 3735 06	epp7 	pr7|-8,ql		pcb_array
000766  aa  6 00246 6535 00	spri7	pr6|166		pcbp
						STATEMENT 1 ON LINE 467
	     unspec (pcb) = "0"b;

000767  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000770  aa   000000 00 0000	desc9a	0,0
000771  aa  7 00000 00 0040	desc9a	pr7|0,32
						STATEMENT 1 ON LINE 468
	     pcb.saved_meters_ptr = null ();

000772  aa   004266 2360 04	ldq  	2230,ic		005260 = 007777000001
000773  aa  7 00006 7561 00	stq  	pr7|6		pcb.saved_meters_ptr
						STATEMENT 1 ON LINE 469
	     pcb.devx = mux_init_info.channels (pcbx).devx;

000774  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
000775  aa   000011 4020 07	mpy  	9,dl
000776  aa   000000 6270 06	eax7 	0,ql
000777  aa  6 00250 2361 66	ldq  	pr6|168,*ql	mux_init_info.devx
001000  aa   000066 7370 00	lls  	54
001001  aa  7 00000 5511 60	stba 	pr7|0,60		pcb.devx
						STATEMENT 1 ON LINE 470
	     lctep = addr (lct.lcte_array (pcb.devx));

001002  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001003  aa   000066 7330 00	lrs  	54
001004  aa   000005 7360 00	qls  	5
001005  aa  6 00232 3715 20	epp5 	pr6|154,*		lctp
001006  aa  5 77760 3715 06	epp5 	pr5|-16,ql	lct.lcte_array
001007  aa  6 00234 6515 00	spri5	pr6|156		lctep
						STATEMENT 1 ON LINE 471
	     lcte.subchannel = pcbx;

001010  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
001011  aa  5 00003 5521 14	stbq 	pr5|3,14		lcte.subchannel
						STATEMENT 1 ON LINE 472
	     name = mux_init_info.channels (pcbx).name;

001012  aa  6 00250 3535 20	epp3 	pr6|168,*		miip
001013  aa  3 77770 3535 17	epp3 	pr3|-8,7		mux_init_info.name
001014  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001015  aa  3 00000 00 0040	desc9a	pr3|0,32		mux_init_info.name
001016  aa  6 00207 00 0040	desc9a	pr6|135,32	name
						STATEMENT 1 ON LINE 473
	     call parse_tty_name_ (name, his_fnp_no, hsla_flag, la_no, subchan);

001017  aa  6 00207 3521 00	epp2 	pr6|135		name
001020  aa  6 00414 2521 00	spri2	pr6|268
001021  aa  6 00205 3521 00	epp2 	pr6|133		his_fnp_no
001022  aa  6 00416 2521 00	spri2	pr6|270
001023  aa  6 00176 3521 00	epp2 	pr6|126		hsla_flag
001024  aa  6 00420 2521 00	spri2	pr6|272
001025  aa  6 00203 3521 00	epp2 	pr6|131		la_no
001026  aa  6 00422 2521 00	spri2	pr6|274
001027  aa  6 00204 3521 00	epp2 	pr6|132		subchan
001030  aa  6 00424 2521 00	spri2	pr6|276
001031  aa   777102 3520 04	epp2 	-446,ic		000133 = 526000000040
001032  aa  6 00426 2521 00	spri2	pr6|278
001033  aa   777114 3520 04	epp2 	-436,ic		000147 = 404000000021
001034  aa  6 00430 2521 00	spri2	pr6|280
001035  aa  6 00434 2521 00	spri2	pr6|284
001036  aa  6 00436 2521 00	spri2	pr6|286
001037  aa   777073 3520 04	epp2 	-453,ic		000132 = 516000000001
001040  aa  6 00432 2521 00	spri2	pr6|282
001041  aa  6 00412 6211 00	eax1 	pr6|266
001042  aa   024000 4310 07	fld  	10240,dl
001043  aa  6 00044 3701 20	epp4 	pr6|36,*
001044  la  4 00044 3521 20	epp2 	pr4|36,*		parse_tty_name_
001045  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 474
	     if his_fnp_no ^= dno
	     then do;

001046  aa  6 00205 2361 00	ldq  	pr6|133		his_fnp_no
001047  aa  6 00103 1161 00	cmpq 	pr6|67		dno
001050  aa   000005 6000 04	tze  	5,ic		001055
						STATEMENT 1 ON LINE 476
		code = error_table_$bad_channel;

001051  aa  6 00044 3701 20	epp4 	pr6|36,*
001052  la  4 00064 2361 20	ldq  	pr4|52,*		error_table_$bad_channel
001053  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 477
		go to init_abort;

001054  aa   000150 7100 04	tra  	104,ic		001224
						STATEMENT 1 ON LINE 478
	     end;

						STATEMENT 1 ON LINE 479
	     if la_no = LA_7
	     then fnp_info.tandd_pcbx = pcbx;

001055  aa  6 00203 2361 00	ldq  	pr6|131		la_no
001056  aa   000007 1160 07	cmpq 	7,dl
001057  aa   000005 6010 04	tnz  	5,ic		001064
001060  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
001061  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001062  aa  7 00064 7561 00	stq  	pr7|52		fnp_info.tandd_pcbx
001063  aa   000027 7100 04	tra  	23,ic		001112
						STATEMENT 1 ON LINE 481
	     else if (la_no ^= prev_la_no | hsla_flag ^= old_flag)
						/* first subchannel on this adapter */
	     then do;

001064  aa  6 00202 1161 00	cmpq 	pr6|130		prev_la_no
001065  aa   000005 6010 04	tnz  	5,ic		001072
001066  aa  6 00176 2351 00	lda  	pr6|126		hsla_flag
001067  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001070  aa  6 00177 1151 00	cmpa 	pr6|127		old_flag
001071  aa   000021 6000 04	tze  	17,ic		001112
						STATEMENT 1 ON LINE 484
		if hsla_flag
		then fnp_info.hsla_idx (la_no) = pcbx;

001072  aa  6 00176 2351 00	lda  	pr6|126		hsla_flag
001073  aa   400000 3150 03	cana 	131072,du
001074  aa   000006 6000 04	tze  	6,ic		001102
001075  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
001076  aa  6 00203 7271 00	lxl7 	pr6|131		la_no
001077  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001100  aa  7 00021 7561 17	stq  	pr7|17,7		fnp_info.hsla_idx
001101  aa   000005 7100 04	tra  	5,ic		001106
						STATEMENT 1 ON LINE 486
		else fnp_info.lsla_idx (la_no) = pcbx;

001102  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
001103  aa  6 00203 7271 00	lxl7 	pr6|131		la_no
001104  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001105  aa  7 00013 7561 17	stq  	pr7|11,7		fnp_info.lsla_idx
						STATEMENT 1 ON LINE 487
		prev_la_no = la_no;

001106  aa  6 00203 2361 00	ldq  	pr6|131		la_no
001107  aa  6 00202 7561 00	stq  	pr6|130		prev_la_no
						STATEMENT 1 ON LINE 488
		old_flag = hsla_flag;

001110  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001111  aa  6 00177 7551 00	sta  	pr6|127		old_flag
						STATEMENT 1 ON LINE 489
	     end;

						STATEMENT 1 ON LINE 491
	     pcb.subchan = subchan;

001112  aa  6 00204 2361 00	ldq  	pr6|132		subchan
001113  aa   000056 7370 00	lls  	46
001114  aa  6 00246 6751 20	era  	pr6|166,*		pcb.subchan
001115  aa   776000 3750 07	ana  	261120,dl
001116  aa  6 00246 6551 20	ersa 	pr6|166,*		pcb.subchan
						STATEMENT 1 ON LINE 492
	     pcb.is_hsla = hsla_flag;

001117  aa  6 00176 2351 00	lda  	pr6|126		hsla_flag
001120  aa   000032 7710 00	arl  	26
001121  aa  6 00246 6751 20	era  	pr6|166,*		pcb.is_hsla
001122  aa   001000 3750 07	ana  	512,dl
001123  aa  6 00246 6551 20	ersa 	pr6|166,*		pcb.is_hsla
						STATEMENT 1 ON LINE 493
	     pcb.la_no = bit (bin (la_no, 3), 3);

001124  aa  6 00203 2351 00	lda  	pr6|131		la_no
001125  aa   000002 6050 04	tpl  	2,ic		001127
001126  aa   000000 5310 00	neg  	0
001127  aa   000041 7350 00	als  	33
001130  aa   000033 7710 00	arl  	27
001131  aa  6 00246 6751 20	era  	pr6|166,*		pcb.la_no
001132  aa   000700 3750 07	ana  	448,dl
001133  aa  6 00246 6551 20	ersa 	pr6|166,*		pcb.la_no
						STATEMENT 1 ON LINE 494
	     if hsla_flag
	     then pcb.slot_no = bit (bin (subchan, 6), 6);

001134  aa  6 00176 2351 00	lda  	pr6|126		hsla_flag
001135  aa   400000 3150 03	cana 	131072,du
001136  aa   000007 6000 04	tze  	7,ic		001145
001137  aa  6 00204 2351 00	lda  	pr6|132		subchan
001140  aa   000002 6050 04	tpl  	2,ic		001142
001141  aa   000000 5310 00	neg  	0
001142  aa  0 00314 3771 00	anaq 	pr0|204		= 000000000077 777777777777
001143  aa  6 00246 3735 20	epp7 	pr6|166,*		pcb.slot_no
001144  aa  7 00000 7511 01	stca 	pr7|0,01		pcb.slot_no
						STATEMENT 1 ON LINE 499
	     on area
		begin;

001145  aa   000004 7260 07	lxl6 	4,dl
001146  aa   776772 3520 04	epp2 	-518,ic		000140 = 141162145141
001147  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
001150  aa   000004 7100 04	tra  	4,ic		001154
001151  aa     000220000000
001152  aa   000015 7100 04	tra  	13,ic		001167
BEGIN CONDITION area.1
ENTRY TO area.1                                             STATEMENT 1 ON LINE 499
	     on area
		begin;

001153  da     000474200000
001154  aa   000100 6270 00	eax7 	64
001155  aa  7 00034 3521 20	epp2 	pr7|28,*
001156  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001157  aa     000000000000
001160  aa     000000000000
						STATEMENT 1 ON LINE 501
		     code = error_table_$noalloc;

001161  la  4 00056 2361 20	ldq  	pr4|46,*		error_table_$noalloc
001162  aa  6 00040 3735 20	epp7 	pr6|32,*
001163  aa  7 00100 7561 00	stq  	pr7|64		code
						STATEMENT 1 ON LINE 502
		     go to init_abort;

001164  aa   000040 3520 04	epp2 	32,ic		001224 = 040100100404
001165  aa   000001 7270 07	lxl7 	1,dl
001166  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 503
		end;

  END CONDITION area.1
						STATEMENT 1 ON LINE 505
	     call tty_area_manager$allocate (size (fnp_channel_meters), temp_saved_meters_ptr);

001167  aa   000032 2360 07	ldq  	26,dl
001170  aa  6 00375 7561 00	stq  	pr6|253
001171  aa  6 00375 3521 00	epp2 	pr6|253
001172  aa  6 00400 2521 00	spri2	pr6|256
001173  aa  6 00160 3521 00	epp2 	pr6|112		temp_saved_meters_ptr
001174  aa  6 00402 2521 00	spri2	pr6|258
001175  aa  6 00376 6211 00	eax1 	pr6|254
001176  aa   010000 4310 07	fld  	4096,dl
001177  aa  6 00044 3701 20	epp4 	pr6|36,*
001200  la  4 00030 3521 20	epp2 	pr4|24,*		tty_area_manager$allocate
001201  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 506
	     pcb.saved_meters_ptr = temp_saved_meters_ptr;

001202  aa  6 00160 3735 20	epp7 	pr6|112,*		temp_saved_meters_ptr
001203  aa  6 00246 3715 20	epp5 	pr6|166,*		pcbp
001204  aa  5 00006 5471 00	sprp7	pr5|6		pcb.saved_meters_ptr
						STATEMENT 1 ON LINE 507
	end;

001205  aa  6 00206 0541 00	aos  	pr6|134		pcbx
001206  aa   777552 7100 04	tra  	-150,ic		000760
						STATEMENT 1 ON LINE 509
	call lock$unlock_fast (addr (datanet_info.configuration_lock));

001207  aa  6 00240 3735 20	epp7 	pr6|160,*		datanet_info.configuration_lock
001210  aa  6 00410 6535 00	spri7	pr6|264
001211  aa  6 00410 3521 00	epp2 	pr6|264
001212  aa  6 00400 2521 00	spri2	pr6|256
001213  aa  6 00376 6211 00	eax1 	pr6|254
001214  aa   004000 4310 07	fld  	2048,dl
001215  aa  6 00044 3701 20	epp4 	pr6|36,*
001216  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_fast
001217  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 512
	a_fnpp = fnpp;

001220  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001221  aa  6 00264 6535 20	spri7	pr6|180,*		a_fnpp
						STATEMENT 1 ON LINE 513
	a_code = 0;

001222  aa  6 00266 4501 20	stz  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 514
init_exit:
	return;

001223  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 517
init_abort:
	call TRACE_ERROR ("init_multiplexer", code);

001224  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001225  aa   777006 00 0020	desc9a	-506,16		000232 = 151156151164
001226  aa  6 00376 00 0040	desc9a	pr6|254,32
001227  aa   004023 3520 04	epp2 	2067,ic		005252 = 000004000000
001230  aa   003711 6700 04	tsp4 	1993,ic		005141
						STATEMENT 1 ON LINE 519
	call lock$unlock_fast (addr (datanet_info.configuration_lock));

001231  aa  6 00240 3735 20	epp7 	pr6|160,*		datanet_info.configuration_lock
001232  aa  6 00410 6535 00	spri7	pr6|264
001233  aa  6 00410 3521 00	epp2 	pr6|264
001234  aa  6 00400 2521 00	spri2	pr6|256
001235  aa  6 00376 6211 00	eax1 	pr6|254
001236  aa   004000 4310 07	fld  	2048,dl
001237  aa  6 00044 3701 20	epp4 	pr6|36,*
001240  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_fast
001241  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 520
	if pcb_space_ptr ^= null
	then do;

001242  aa  6 00200 2371 00	ldaq 	pr6|128		pcb_space_ptr
001243  aa   776737 6770 04	eraq 	-545,ic		000202 = 077777000043 000001000000
001244  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001245  aa   000047 6000 04	tze  	39,ic		001314
						STATEMENT 1 ON LINE 522
	     do pcbx = 1 to n_pcbs;

001246  aa  6 00244 2361 00	ldq  	pr6|164		n_pcbs
001247  aa  6 00300 7561 00	stq  	pr6|192
001250  aa   000001 2360 07	ldq  	1,dl
001251  aa  6 00206 7561 00	stq  	pr6|134		pcbx
001252  aa  6 00206 2361 00	ldq  	pr6|134		pcbx
001253  aa  6 00300 1161 00	cmpq 	pr6|192
001254  aa   000027 6054 04	tpnz 	23,ic		001303
						STATEMENT 1 ON LINE 523
		pcbp = addr (pcb_space_ptr -> pcb_array (pcbx));

001255  aa   000003 7360 00	qls  	3
001256  aa  6 00200 3735 20	epp7 	pr6|128,*		pcb_space_ptr
001257  aa  7 77770 3735 06	epp7 	pr7|-8,ql		pcb_array
001260  aa  6 00246 6535 00	spri7	pr6|166		pcbp
						STATEMENT 1 ON LINE 524
		if pcb.saved_meters_ptr ^= null ()
		then call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));

001261  aa  7 00006 2361 00	ldq  	pr7|6		pcb.saved_meters_ptr
001262  aa   003776 1160 04	cmpq 	2046,ic		005260 = 007777000001
001263  aa   000016 6000 04	tze  	14,ic		001301
001264  aa   000032 2360 07	ldq  	26,dl
001265  aa  6 00375 7561 00	stq  	pr6|253
001266  aa  7 00006 7651 00	lprp5	pr7|6		pcb.saved_meters_ptr
001267  aa  6 00410 6515 00	spri5	pr6|264
001270  aa  6 00375 3521 00	epp2 	pr6|253
001271  aa  6 00400 2521 00	spri2	pr6|256
001272  aa  6 00410 3521 00	epp2 	pr6|264
001273  aa  6 00402 2521 00	spri2	pr6|258
001274  aa  6 00376 6211 00	eax1 	pr6|254
001275  aa   010000 4310 07	fld  	4096,dl
001276  aa  6 00044 3701 20	epp4 	pr6|36,*
001277  la  4 00032 3521 20	epp2 	pr4|26,*		tty_area_manager$free
001300  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 526
	     end;

001301  aa  6 00206 0541 00	aos  	pr6|134		pcbx
001302  aa   777750 7100 04	tra  	-24,ic		001252
						STATEMENT 1 ON LINE 527
	     call tty_space_man$free_space (space_needed, pcb_space_ptr);

001303  aa  6 00105 3521 00	epp2 	pr6|69		space_needed
001304  aa  6 00400 2521 00	spri2	pr6|256
001305  aa  6 00200 3521 00	epp2 	pr6|128		pcb_space_ptr
001306  aa  6 00402 2521 00	spri2	pr6|258
001307  aa  6 00376 6211 00	eax1 	pr6|254
001310  aa   010000 4310 07	fld  	4096,dl
001311  aa  6 00044 3701 20	epp4 	pr6|36,*
001312  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_space
001313  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 528
	end;

						STATEMENT 1 ON LINE 529
	a_code = code;

001314  aa  6 00100 2361 00	ldq  	pr6|64		code
001315  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 530
	return;

001316  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO terminate_multiplexer                              STATEMENT 1 ON LINE 532
terminate_multiplexer:
     entry (a_fnpp, a_code);

001317  at     000002000145
001320  ta     000142000000
001321  ta     001317000000
001322  da     000505300000
001323  aa   000740 6270 00	eax7 	480
001324  aa  7 00034 3521 20	epp2 	pr7|28,*
001325  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001326  aa     000004000000
001327  aa     000000000000
001330  aa  6 00032 3735 20	epp7 	pr6|26,*
001331  aa  7 00002 3715 20	epp5 	pr7|2,*
001332  aa  6 00264 6515 00	spri5	pr6|180
001333  aa  7 00004 3535 20	epp3 	pr7|4,*
001334  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 537
	fnpp = a_fnpp;

001335  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
001336  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
001337  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 538
	ttybp = addr (tty_buf$);

001340  aa  6 00044 3701 20	epp4 	pr6|36,*
001341  la  4 00110 3715 20	epp5 	pr4|72,*		tty_buf$
001342  aa  6 00226 6515 00	spri5	pr6|150		ttybp
						STATEMENT 1 ON LINE 539
	infop = addr (dn355_data$);

001343  la  4 00112 3535 20	epp3 	pr4|74,*		dn355_data$
001344  aa  6 00240 2535 00	spri3	pr6|160		infop
						STATEMENT 1 ON LINE 540
	locked = "0"b;

001345  aa  6 00131 4501 00	stz  	pr6|89		locked
						STATEMENT 1 ON LINE 541
	call TRACE ("terminate_multiplexer");

001346  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001347  aa   776670 00 0025	desc9a	-584,21		000236 = 164145162155
001350  aa  6 00376 00 0040	desc9a	pr6|254,32
001351  aa   003715 3520 04	epp2 	1997,ic		005266 = 000002000000
001352  aa   003534 6700 04	tsp4 	1884,ic		005106
						STATEMENT 1 ON LINE 542
	call lock;

001353  aa   003136 6700 04	tsp4 	1630,ic		004511
						STATEMENT 1 ON LINE 543
	if code ^= 0
	then go to terminate_return;

001354  aa  6 00100 2361 00	ldq  	pr6|64		code
001355  aa   000215 6010 04	tnz  	141,ic		001572
						STATEMENT 1 ON LINE 546
	if fnp_info.bootloading | fnp_info.wired | fnp_info.running
						/* bad time to terminate */
	then code = error_table_$invalid_state;

001356  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001357  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
001360  aa   340000 3150 03	cana 	114688,du
001361  aa   000005 6000 04	tze  	5,ic		001366
001362  aa  6 00044 3701 20	epp4 	pr6|36,*
001363  la  4 00104 2361 20	ldq  	pr4|68,*		error_table_$invalid_state
001364  aa  6 00100 7561 00	stq  	pr6|64		code
001365  aa   000163 7100 04	tra  	115,ic		001550
						STATEMENT 1 ON LINE 550
	else do;

						STATEMENT 1 ON LINE 551
	     do i = 1 to fnp_info.no_of_channels;

001366  aa  7 00006 2361 00	ldq  	pr7|6		fnp_info.no_of_channels
001367  aa  6 00301 7561 00	stq  	pr6|193
001370  aa   000001 2360 07	ldq  	1,dl
001371  aa  6 00112 7561 00	stq  	pr6|74		i
001372  aa  6 00112 2361 00	ldq  	pr6|74		i
001373  aa  6 00301 1161 00	cmpq 	pr6|193
001374  aa   000127 6054 04	tpnz 	87,ic		001523
						STATEMENT 1 ON LINE 552
		pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (i));

001375  aa   000003 7360 00	qls  	3
001376  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001377  aa  7 00002 3715 20	epp5 	pr7|2,*		fnp_info.pcb_array_ptr
001400  aa  5 77770 3735 06	epp7 	pr5|-8,ql		pcb_array
001401  aa  6 00246 6535 00	spri7	pr6|166		pcbp
						STATEMENT 1 ON LINE 553
		if pcb.write_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));

001402  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
001403  aa   000066 7330 00	lrs  	54
001404  aa   000024 6000 04	tze  	20,ic		001430
001405  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001406  aa  6 00440 7561 00	stq  	pr6|288		pcb.write_first
001407  aa   000066 7330 00	lrs  	54
001410  aa  6 00375 7561 00	stq  	pr6|253
001411  aa  6 00440 2361 00	ldq  	pr6|288		pcb.write_first
001412  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
001413  aa   000000 3120 06	eawp2	0,ql
001414  aa  6 00410 2521 00	spri2	pr6|264
001415  aa  6 00375 3521 00	epp2 	pr6|253
001416  aa  6 00400 2521 00	spri2	pr6|256
001417  aa   776515 3520 04	epp2 	-691,ic		000134 = 400000000000
001420  aa  6 00402 2521 00	spri2	pr6|258
001421  aa  6 00410 3521 00	epp2 	pr6|264
001422  aa  6 00404 2521 00	spri2	pr6|260
001423  aa  6 00376 6211 00	eax1 	pr6|254
001424  aa   014000 4310 07	fld  	6144,dl
001425  aa  6 00044 3701 20	epp4 	pr6|36,*
001426  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$free_chain
001427  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 555
		if pcb.read_first ^= 0
		then call tty_space_man$free_chain ((pcb.devx), INPUT, ptr (ttybp, pcb.read_first));

001430  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
001431  aa  7 00005 2351 00	lda  	pr7|5		pcb.read_first
001432  aa   000066 7730 00	lrl  	54
001433  aa   000024 6000 04	tze  	20,ic		001457
001434  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
001435  aa  6 00440 7561 00	stq  	pr6|288		pcb.read_first
001436  aa   000066 7330 00	lrs  	54
001437  aa  6 00375 7561 00	stq  	pr6|253
001440  aa  6 00440 2361 00	ldq  	pr6|288		pcb.read_first
001441  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
001442  aa   000000 3120 06	eawp2	0,ql
001443  aa  6 00410 2521 00	spri2	pr6|264
001444  aa  6 00375 3521 00	epp2 	pr6|253
001445  aa  6 00400 2521 00	spri2	pr6|256
001446  aa   776467 3520 04	epp2 	-713,ic		000135 = 000000000000
001447  aa  6 00402 2521 00	spri2	pr6|258
001450  aa  6 00410 3521 00	epp2 	pr6|264
001451  aa  6 00404 2521 00	spri2	pr6|260
001452  aa  6 00376 6211 00	eax1 	pr6|254
001453  aa   014000 4310 07	fld  	6144,dl
001454  aa  6 00044 3701 20	epp4 	pr6|36,*
001455  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$free_chain
001456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 557
		call tty_area_manager$free (size (fnp_channel_meters), (pcb.saved_meters_ptr));

001457  aa   000032 2360 07	ldq  	26,dl
001460  aa  6 00375 7561 00	stq  	pr6|253
001461  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
001462  aa  7 00006 7671 00	lprp7	pr7|6		pcb.saved_meters_ptr
001463  aa  6 00410 6535 00	spri7	pr6|264
001464  aa  6 00375 3521 00	epp2 	pr6|253
001465  aa  6 00400 2521 00	spri2	pr6|256
001466  aa  6 00410 3521 00	epp2 	pr6|264
001467  aa  6 00402 2521 00	spri2	pr6|258
001470  aa  6 00376 6211 00	eax1 	pr6|254
001471  aa   010000 4310 07	fld  	4096,dl
001472  aa  6 00044 3701 20	epp4 	pr6|36,*
001473  la  4 00032 3521 20	epp2 	pr4|26,*		tty_area_manager$free
001474  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 558
		if pcb.copied_meters_offset ^= 0	/* free this if it's there */
		then do;

001475  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
001476  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
001477  aa   000022 6000 04	tze  	18,ic		001521
						STATEMENT 1 ON LINE 560
		     call tty_space_man$free_space (size (fnp_channel_meters), ptr (ttybp, pcb.copied_meters_offset));

001500  aa   000032 2360 07	ldq  	26,dl
001501  aa  6 00375 7561 00	stq  	pr6|253
001502  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
001503  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
001504  aa   000000 3120 06	eawp2	0,ql
001505  aa  6 00410 2521 00	spri2	pr6|264
001506  aa  6 00375 3521 00	epp2 	pr6|253
001507  aa  6 00400 2521 00	spri2	pr6|256
001510  aa  6 00410 3521 00	epp2 	pr6|264
001511  aa  6 00402 2521 00	spri2	pr6|258
001512  aa  6 00376 6211 00	eax1 	pr6|254
001513  aa   010000 4310 07	fld  	4096,dl
001514  aa  6 00044 3701 20	epp4 	pr6|36,*
001515  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_space
001516  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 561
		     pcb.copied_meters_offset = 0;

001517  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
001520  aa  7 00007 4501 00	stz  	pr7|7		pcb.copied_meters_offset
						STATEMENT 1 ON LINE 562
		end;

						STATEMENT 1 ON LINE 563
	     end;

001521  aa  6 00112 0541 00	aos  	pr6|74		i
001522  aa   777650 7100 04	tra  	-88,ic		001372
						STATEMENT 1 ON LINE 565
	     string (fnp_info.flags) = "0"b;

001523  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001524  aa  7 00030 4501 00	stz  	pr7|24
						STATEMENT 1 ON LINE 566
	     call tty_space_man$free_space (size (pcb) * fnp_info.no_of_channels + PCB_SIZE_INCR * DCW_LIST_SIZE,
		fnp_info.pcb_array_ptr);

001525  aa   000200 2360 07	ldq  	128,dl
001526  aa  6 00440 7561 00	stq  	pr6|288
001527  aa   000010 2360 07	ldq  	8,dl
001530  aa  7 00006 4021 00	mpy  	pr7|6		fnp_info.no_of_channels
001531  aa  6 00440 0331 00	adl  	pr6|288
001532  aa  6 00375 7561 00	stq  	pr6|253
001533  aa  6 00375 3521 00	epp2 	pr6|253
001534  aa  6 00400 2521 00	spri2	pr6|256
001535  aa  7 00002 3521 00	epp2 	pr7|2		fnp_info.pcb_array_ptr
001536  aa  6 00402 2521 00	spri2	pr6|258
001537  aa  6 00376 6211 00	eax1 	pr6|254
001540  aa   010000 4310 07	fld  	4096,dl
001541  aa  6 00044 3701 20	epp4 	pr6|36,*
001542  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_space
001543  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 568
	     fnp_info.pcb_array_ptr = null;

001544  aa   776436 2370 04	ldaq 	-738,ic		000202 = 077777000043 000001000000
001545  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001546  aa  7 00002 7571 00	staq 	pr7|2		fnp_info.pcb_array_ptr
						STATEMENT 1 ON LINE 569
	     code = 0;

001547  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 570
	end;

						STATEMENT 1 ON LINE 571
	if fnp_info.io_manager_assigned
	then call unassign_channel (code);

001550  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
001551  aa   200000 3150 03	cana 	65536,du
001552  aa   000003 6000 04	tze  	3,ic		001555
001553  aa   003507 3520 04	epp2 	1863,ic		005262 = 000002000000
001554  aa   003213 6700 04	tsp4 	1675,ic		004767
						STATEMENT 1 ON LINE 573
	call uncp_util$free_page_table ((fnp_info.fnp_number));

001555  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
001556  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
001557  aa   000011 7350 00	als  	9
001560  aa   000077 7730 00	lrl  	63
001561  aa  6 00375 7561 00	stq  	pr6|253
001562  aa  6 00375 3521 00	epp2 	pr6|253
001563  aa  6 00400 2521 00	spri2	pr6|256
001564  aa  6 00376 6211 00	eax1 	pr6|254
001565  aa   004000 4310 07	fld  	2048,dl
001566  aa  6 00044 3701 20	epp4 	pr6|36,*
001567  la  4 00024 3521 20	epp2 	pr4|20,*		uncp_util$free_page_table
001570  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 576
	call unlock;

001571  aa   003004 6700 04	tsp4 	1540,ic		004575
						STATEMENT 1 ON LINE 578
terminate_return:
	if code ^= 0
	then call TRACE_ERROR ("terminate_multiplexer", code);

001572  aa  6 00100 2361 00	ldq  	pr6|64		code
001573  aa   000006 6000 04	tze  	6,ic		001601
001574  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001575  aa   776442 00 0025	desc9a	-734,21		000236 = 164145162155
001576  aa  6 00376 00 0040	desc9a	pr6|254,32
001577  aa   003453 3520 04	epp2 	1835,ic		005252 = 000004000000
001600  aa   003341 6700 04	tsp4 	1761,ic		005141
						STATEMENT 1 ON LINE 581
	a_code = code;

001601  aa  6 00100 2361 00	ldq  	pr6|64		code
001602  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 582
	return;

001603  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO start                                              STATEMENT 1 ON LINE 584
start:
     entry (a_fnpp, a_code);

001604  ta     001317000000
001605  da     000512300000
001606  aa   000740 6270 00	eax7 	480
001607  aa  7 00034 3521 20	epp2 	pr7|28,*
001610  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001611  aa     000004000000
001612  aa     000000000000
001613  aa  6 00032 3735 20	epp7 	pr6|26,*
001614  aa  7 00002 3715 20	epp5 	pr7|2,*
001615  aa  6 00264 6515 00	spri5	pr6|180
001616  aa  7 00004 3535 20	epp3 	pr7|4,*
001617  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 589
	fnpp = a_fnpp;

001620  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
001621  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
001622  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 590
	infop = addr (dn355_data$);

001623  aa  6 00044 3701 20	epp4 	pr6|36,*
001624  la  4 00112 3715 20	epp5 	pr4|74,*		dn355_data$
001625  aa  6 00240 6515 00	spri5	pr6|160		infop
						STATEMENT 1 ON LINE 591
	call TRACE ("start");

001626  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001627  aa   776352 00 0005	desc9a	-790,5		000200 = 163164141162
001630  aa  6 00376 00 0040	desc9a	pr6|254,32
001631  aa   003435 3520 04	epp2 	1821,ic		005266 = 000002000000
001632  aa   003254 6700 04	tsp4 	1708,ic		005106
						STATEMENT 1 ON LINE 592
	chanx = 1;

001633  aa   000001 2360 07	ldq  	1,dl
001634  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 593
	call setup;

001635  aa   002212 6700 04	tsp4 	1162,ic		004047
						STATEMENT 1 ON LINE 594
	if code = 0
	then do;

001636  aa  6 00100 2361 00	ldq  	pr6|64		code
001637  aa   000002 6010 04	tnz  	2,ic		001641
						STATEMENT 1 ON LINE 602
	     call unlock;

001640  aa   002735 6700 04	tsp4 	1501,ic		004575
						STATEMENT 1 ON LINE 603
	end;

						STATEMENT 1 ON LINE 604
	if code ^= 0
	then call TRACE_ERROR ("start", code);

001641  aa  6 00100 2361 00	ldq  	pr6|64		code
001642  aa   000006 6000 04	tze  	6,ic		001650
001643  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001644  aa   776335 00 0005	desc9a	-803,5		000200 = 163164141162
001645  aa  6 00376 00 0040	desc9a	pr6|254,32
001646  aa   003404 3520 04	epp2 	1796,ic		005252 = 000004000000
001647  aa   003272 6700 04	tsp4 	1722,ic		005141
						STATEMENT 1 ON LINE 606
	a_code = code;

001650  aa  6 00100 2361 00	ldq  	pr6|64		code
001651  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 607
	return;

001652  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO stop                                               STATEMENT 1 ON LINE 610
stop:
     entry (a_fnpp, a_code);

001653  ta     001317000000
001654  da     000517300000
001655  aa   000740 6270 00	eax7 	480
001656  aa  7 00034 3521 20	epp2 	pr7|28,*
001657  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001660  aa     000004000000
001661  aa     000000000000
001662  aa  6 00032 3735 20	epp7 	pr6|26,*
001663  aa  7 00002 3715 20	epp5 	pr7|2,*
001664  aa  6 00264 6515 00	spri5	pr6|180
001665  aa  7 00004 3535 20	epp3 	pr7|4,*
001666  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 615
	fnpp = a_fnpp;

001667  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
001670  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
001671  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 616
	infop = addr (dn355_data$);

001672  aa  6 00044 3701 20	epp4 	pr6|36,*
001673  la  4 00112 3715 20	epp5 	pr4|74,*		dn355_data$
001674  aa  6 00240 6515 00	spri5	pr6|160		infop
						STATEMENT 1 ON LINE 617
	call TRACE ("stop");

001675  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001676  aa   776234 00 0004	desc9a	-868,4		000131 = 163164157160
001677  aa  6 00376 00 0040	desc9a	pr6|254,32
001700  aa   003366 3520 04	epp2 	1782,ic		005266 = 000002000000
001701  aa   003205 6700 04	tsp4 	1669,ic		005106
						STATEMENT 1 ON LINE 618
	chanx = 1;

001702  aa   000001 2360 07	ldq  	1,dl
001703  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 619
	call setup;

001704  aa   002143 6700 04	tsp4 	1123,ic		004047
						STATEMENT 1 ON LINE 620
	if code = 0
	then call unlock;

001705  aa  6 00100 2361 00	ldq  	pr6|64		code
001706  aa   000002 6010 04	tnz  	2,ic		001710
001707  aa   002666 6700 04	tsp4 	1462,ic		004575
						STATEMENT 1 ON LINE 623
	if code ^= 0
	then call TRACE_ERROR ("stop", code);

001710  aa  6 00100 2361 00	ldq  	pr6|64		code
001711  aa   000006 6000 04	tze  	6,ic		001717
001712  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001713  aa   776217 00 0004	desc9a	-881,4		000131 = 163164157160
001714  aa  6 00376 00 0040	desc9a	pr6|254,32
001715  aa   003335 3520 04	epp2 	1757,ic		005252 = 000004000000
001716  aa   003223 6700 04	tsp4 	1683,ic		005141
						STATEMENT 1 ON LINE 625
	a_code = code;

001717  aa  6 00100 2361 00	ldq  	pr6|64		code
001720  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 626
	return;

001721  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO shutdown                                           STATEMENT 1 ON LINE 629
shutdown:
     entry (a_fnpp, a_code);

001722  ta     001317000000
001723  da     000525300000
001724  aa   000740 6270 00	eax7 	480
001725  aa  7 00034 3521 20	epp2 	pr7|28,*
001726  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001727  aa     000004000000
001730  aa     000000000000
001731  aa  6 00032 3735 20	epp7 	pr6|26,*
001732  aa  7 00002 3715 20	epp5 	pr7|2,*
001733  aa  6 00264 6515 00	spri5	pr6|180
001734  aa  7 00004 3535 20	epp3 	pr7|4,*
001735  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 634
	infop = addr (dn355_data$);

001736  aa  6 00044 3701 20	epp4 	pr6|36,*
001737  la  4 00112 3735 20	epp7 	pr4|74,*		dn355_data$
001740  aa  6 00240 6535 00	spri7	pr6|160		infop
						STATEMENT 1 ON LINE 635
	fnpp = a_fnpp;

001741  aa  6 00264 3715 20	epp5 	pr6|180,*		a_fnpp
001742  aa  5 00000 3715 20	epp5 	pr5|0,*		a_fnpp
001743  aa  6 00242 6515 00	spri5	pr6|162		fnpp
						STATEMENT 1 ON LINE 636
	if fnpp = null ()
	then do;

001744  aa  6 00242 2371 00	ldaq 	pr6|162		fnpp
001745  aa   776235 6770 04	eraq 	-867,ic		000202 = 077777000043 000001000000
001746  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001747  aa   000023 6010 04	tnz  	19,ic		001772
						STATEMENT 1 ON LINE 638
	     if datanet_info.trace
	     then call syserr (ANNOUNCE, "uncp_multiplexer$shutdown: Called with null fnp_ptr");

001750  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
001751  aa   000061 6000 04	tze  	49,ic		002032
001752  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001753  aa   776324 00 0064	desc9a	-812,52		000276 = 165156143160
001754  aa  6 00412 00 0064	desc9a	pr6|266,52
001755  aa   776160 3520 04	epp2 	-912,ic		000135 = 000000000000
001756  aa  6 00400 2521 00	spri2	pr6|256
001757  aa  6 00412 3521 00	epp2 	pr6|266
001760  aa  6 00402 2521 00	spri2	pr6|258
001761  aa   776166 3520 04	epp2 	-906,ic		000147 = 404000000021
001762  aa  6 00404 2521 00	spri2	pr6|260
001763  aa   776145 3520 04	epp2 	-923,ic		000130 = 524000000063
001764  aa  6 00406 2521 00	spri2	pr6|262
001765  aa  6 00376 6211 00	eax1 	pr6|254
001766  aa   010000 4310 07	fld  	4096,dl
001767  la  4 00040 3521 20	epp2 	pr4|32,*		syserr
001770  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 640
	     go to shutdown_return;

001771  aa   000041 7100 04	tra  	33,ic		002032
						STATEMENT 1 ON LINE 641
	end;

						STATEMENT 1 ON LINE 642
	call TRACE ("shutdown");

001772  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
001773  aa   776204 00 0010	desc9a	-892,8		000176 = 163150165164
001774  aa  6 00376 00 0040	desc9a	pr6|254,32
001775  aa   003271 3520 04	epp2 	1721,ic		005266 = 000002000000
001776  aa   003110 6700 04	tsp4 	1608,ic		005106
						STATEMENT 1 ON LINE 643
	infop = addr (dn355_data$);

001777  aa  6 00044 3701 20	epp4 	pr6|36,*
002000  la  4 00112 3735 20	epp7 	pr4|74,*		dn355_data$
002001  aa  6 00240 6535 00	spri7	pr6|160		infop
						STATEMENT 1 ON LINE 653
	fnp_info.bootloading = "0"b;

002002  aa   003246 2350 04	lda  	1702,ic		005250 = 577777777777
002003  aa  6 00242 3715 20	epp5 	pr6|162,*		fnpp
002004  aa  5 00030 3551 00	ansa 	pr5|24		fnp_info.bootloading
						STATEMENT 1 ON LINE 654
	locked = "0"b;

002005  aa  6 00131 4501 00	stz  	pr6|89		locked
						STATEMENT 1 ON LINE 655
	if fnp_info.running				/* if it's up now */
	then do;

002006  aa  5 00030 2351 00	lda  	pr5|24		fnp_info.running
002007  aa   100000 3150 03	cana 	32768,du
002010  aa   000022 6000 04	tze  	18,ic		002032
						STATEMENT 1 ON LINE 657
	     call lock;

002011  aa   002500 6700 04	tsp4 	1344,ic		004511
						STATEMENT 1 ON LINE 658
	     call uncp$hangup_fnp_lines ((fnp_info.fnp_number));

002012  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
002013  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
002014  aa   000011 7350 00	als  	9
002015  aa   000077 7730 00	lrl  	63
002016  aa  6 00375 7561 00	stq  	pr6|253
002017  aa  6 00375 3521 00	epp2 	pr6|253
002020  aa  6 00400 2521 00	spri2	pr6|256
002021  aa  6 00376 6211 00	eax1 	pr6|254
002022  aa   004000 4310 07	fld  	2048,dl
002023  aa  6 00044 3701 20	epp4 	pr6|36,*
002024  la  4 00014 3521 20	epp2 	pr4|12,*		uncp$hangup_fnp_lines
002025  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 659
	     fnp_info.running = "0"b;

002026  aa   003221 2350 04	lda  	1681,ic		005247 = 677777777777
002027  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
002030  aa  7 00030 3551 00	ansa 	pr7|24		fnp_info.running
						STATEMENT 1 ON LINE 660
	     call unlock;

002031  aa   002544 6700 04	tsp4 	1380,ic		004575
						STATEMENT 1 ON LINE 661
	end;

						STATEMENT 1 ON LINE 665
shutdown_return:
	a_code = 0;

002032  aa  6 00266 4501 20	stz  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 667
	return;

002033  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read                                               STATEMENT 1 ON LINE 670
read:
     entry (a_fnpp, a_subchan, a_chainp, a_mi_flag, a_code);

002034  at     000005000145
002035  tt     000147000145
002036  tt     000144000142
002037  ta     002034000000
002040  da     000532300000
002041  aa   000740 6270 00	eax7 	480
002042  aa  7 00034 3521 20	epp2 	pr7|28,*
002043  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002044  aa     000012000000
002045  aa     000000000000
002046  aa  6 00032 3735 20	epp7 	pr6|26,*
002047  aa  7 00002 3715 20	epp5 	pr7|2,*
002050  aa  6 00264 6515 00	spri5	pr6|180
002051  aa  7 00012 3535 20	epp3 	pr7|10,*
002052  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 675
	a_chainp = null;

002053  aa   776127 2370 04	ldaq 	-937,ic		000202 = 077777000043 000001000000
002054  aa  6 00032 3735 20	epp7 	pr6|26,*
002055  aa  7 00006 7571 20	staq 	pr7|6,*		a_chainp
						STATEMENT 1 ON LINE 676
	a_mi_flag = "0"b;

002056  aa  7 00010 4501 20	stz  	pr7|8,*		a_mi_flag
						STATEMENT 1 ON LINE 677
	a_code = 0;

002057  aa  6 00266 4501 20	stz  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 678
	return;

002060  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO write                                              STATEMENT 1 ON LINE 681
write:
     entry (a_fnpp, a_subchan, a_output_ptr, a_code);

002061  at     000004000145
002062  tt     000147000145
002063  ta     000142000000
002064  ta     002061000000
002065  da     000537300000
002066  aa   000740 6270 00	eax7 	480
002067  aa  7 00034 3521 20	epp2 	pr7|28,*
002070  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002071  aa     000010000000
002072  aa     000000000000
002073  aa  6 00032 3735 20	epp7 	pr6|26,*
002074  aa  7 00002 3715 20	epp5 	pr7|2,*
002075  aa  6 00264 6515 00	spri5	pr6|180
002076  aa  7 00010 3535 20	epp3 	pr7|8,*
002077  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 684
	fnpp = a_fnpp;

002100  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
002101  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002102  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 685
	chanx = a_subchan;

002103  aa  6 00032 3715 20	epp5 	pr6|26,*
002104  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
002105  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 686
	output_ptr = a_output_ptr;

002106  aa  5 00006 3535 20	epp3 	pr5|6,*		a_output_ptr
002107  aa  3 00000 3535 20	epp3 	pr3|0,*		a_output_ptr
002110  aa  6 00106 2535 00	spri3	pr6|70		output_ptr
						STATEMENT 1 ON LINE 688
	call setup;

002111  aa   001736 6700 04	tsp4 	990,ic		004047
						STATEMENT 1 ON LINE 689
	if code ^= 0
	then do;

002112  aa  6 00100 2361 00	ldq  	pr6|64		code
002113  aa   000003 6000 04	tze  	3,ic		002116
						STATEMENT 1 ON LINE 691
	     a_code = code;

002114  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 692
	     return;

002115  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 693
	end;

						STATEMENT 1 ON LINE 697
	blockp = output_ptr;

002116  aa  6 00106 3735 20	epp7 	pr6|70,*		output_ptr
002117  aa  6 00230 6535 00	spri7	pr6|152		blockp
						STATEMENT 1 ON LINE 698
	output_length = buffer.tally;

002120  aa  6 00230 2361 20	ldq  	pr6|152,*		buffer.tally
002121  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002122  aa  6 00111 7561 00	stq  	pr6|73		output_length
						STATEMENT 1 ON LINE 700
	do while (buffer.next ^= 0);

002123  aa   000000 0110 03	nop  	0,du
002124  aa  6 00230 2351 20	lda  	pr6|152,*		buffer.next
002125  aa   000066 7730 00	lrl  	54
002126  aa  6 00375 7561 00	stq  	pr6|253		buffer.next
002127  aa   000010 6000 04	tze  	8,ic		002137
						STATEMENT 1 ON LINE 701
	     blockp = ptr (ttybp, buffer.next);

002130  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
002131  aa   000000 3120 06	eawp2	0,ql
002132  aa  6 00230 2521 00	spri2	pr6|152		blockp
						STATEMENT 1 ON LINE 702
	     output_length = output_length + buffer.tally;

002133  aa  2 00000 2361 00	ldq  	pr2|0		buffer.tally
002134  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002135  aa  6 00111 0561 00	asq  	pr6|73		output_length
						STATEMENT 1 ON LINE 703
	end;

002136  aa   777766 7100 04	tra  	-10,ic		002124
						STATEMENT 1 ON LINE 705
	if pcb.write_last ^= 0			/* existing write chain */
	then do;

002137  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002140  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_last
002141  aa   000022 7350 00	als  	18
002142  aa   000066 7330 00	lrs  	54
002143  aa  6 00375 7561 00	stq  	pr6|253		pcb.write_last
002144  aa   000011 6000 04	tze  	9,ic		002155
						STATEMENT 1 ON LINE 707
	     lastp = ptr (ttybp, pcb.write_last);

002145  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
002146  aa   000000 3120 06	eawp2	0,ql
002147  aa  6 00114 2521 00	spri2	pr6|76		lastp
						STATEMENT 1 ON LINE 708
	     lastp -> buffer.next = bin (rel (output_ptr));

002150  aa  6 00106 6351 20	eaa  	pr6|70,*		output_ptr
002151  aa   000066 7730 00	lrl  	54
002152  aa   000066 7370 00	lls  	54
002153  aa  2 00000 5511 60	stba 	pr2|0,60		buffer.next
						STATEMENT 1 ON LINE 709
	end;

002154  aa   000005 7100 04	tra  	5,ic		002161
						STATEMENT 1 ON LINE 711
	else pcb.write_first = bin (rel (output_ptr));

002155  aa  6 00106 6351 20	eaa  	pr6|70,*		output_ptr
002156  aa   000066 7730 00	lrl  	54
002157  aa   000066 7370 00	lls  	54
002160  aa  7 00001 5511 60	stba 	pr7|1,60		pcb.write_first
						STATEMENT 1 ON LINE 713
	pcb.write_last = bin (rel (blockp));

002161  aa  6 00230 6351 20	eaa  	pr6|152,*		blockp
002162  aa   000066 7730 00	lrl  	54
002163  aa  7 00001 5521 14	stbq 	pr7|1,14		pcb.write_last
						STATEMENT 1 ON LINE 714
	pcb.write_cnt = pcb.write_cnt + output_length;

002164  aa  7 00003 2351 00	lda  	pr7|3		pcb.write_cnt
002165  aa   000022 7350 00	als  	18
002166  aa   000066 7330 00	lrs  	54
002167  aa  6 00111 0761 00	adq  	pr6|73		output_length
002170  aa  7 00003 5521 14	stbq 	pr7|3,14		pcb.write_cnt
						STATEMENT 1 ON LINE 716
	if pcb.send_output				/* if the FNP is ready for it */
	then call uncp$send_wcd (fnpp, pcbp, accept_direct_output, 0, ""b);

002171  aa  7 00004 2351 00	lda  	pr7|4		pcb.send_output
002172  aa   100000 3150 03	cana 	32768,du
002173  aa   000032 6000 04	tze  	26,ic		002225
002174  aa  6 00375 4501 00	stz  	pr6|253
002175  aa  6 00242 3521 00	epp2 	pr6|162		fnpp
002176  aa  6 00414 2521 00	spri2	pr6|268
002177  aa  6 00246 3521 00	epp2 	pr6|166		pcbp
002200  aa  6 00416 2521 00	spri2	pr6|270
002201  aa   775714 3520 04	epp2 	-1076,ic		000115 = 000000000012
002202  aa  6 00420 2521 00	spri2	pr6|272
002203  aa  6 00375 3521 00	epp2 	pr6|253
002204  aa  6 00422 2521 00	spri2	pr6|274
002205  aa  6 00440 3521 00	epp2 	pr6|288
002206  aa  6 00424 2521 00	spri2	pr6|276
002207  aa   775736 3520 04	epp2 	-1058,ic		000145 = 464000000000
002210  aa  6 00426 2521 00	spri2	pr6|278
002211  aa  6 00430 2521 00	spri2	pr6|280
002212  aa   775715 3520 04	epp2 	-1075,ic		000127 = 404000000010
002213  aa  6 00432 2521 00	spri2	pr6|282
002214  aa   775733 3520 04	epp2 	-1061,ic		000147 = 404000000021
002215  aa  6 00434 2521 00	spri2	pr6|284
002216  aa   775710 3520 04	epp2 	-1080,ic		000126 = 514000000000
002217  aa  6 00436 2521 00	spri2	pr6|286
002220  aa  6 00412 6211 00	eax1 	pr6|266
002221  aa   024000 4310 07	fld  	10240,dl
002222  aa  6 00044 3701 20	epp4 	pr6|36,*
002223  la  4 00010 3521 20	epp2 	pr4|8,*		uncp$send_wcd
002224  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 719
	code = 0;

002225  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 720
write_exit:
	call unlock;

002226  aa   002347 6700 04	tsp4 	1255,ic		004575
						STATEMENT 1 ON LINE 722
	if code = 0
	then a_output_ptr = null ();

002227  aa  6 00100 2361 00	ldq  	pr6|64		code
002230  aa   000004 6010 04	tnz  	4,ic		002234
002231  aa   775751 2370 04	ldaq 	-1047,ic		000202 = 077777000043 000001000000
002232  aa  6 00032 3735 20	epp7 	pr6|26,*
002233  aa  7 00006 7571 20	staq 	pr7|6,*		a_output_ptr
						STATEMENT 1 ON LINE 724
	a_code = code;

002234  aa  6 00100 2361 00	ldq  	pr6|64		code
002235  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 725
	return;

002236  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO control                                            STATEMENT 1 ON LINE 727
control:
     entry (a_fnpp, a_subchan, a_order, a_data_ptr, a_code);

002237  at     000005000145
002240  tt     000147000141
002241  tt     000145000142
002242  ta     002237000000
002243  da     000544300000
002244  aa   000740 6270 00	eax7 	480
002245  aa  7 00034 3521 20	epp2 	pr7|28,*
002246  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002247  aa     000012000000
002250  aa     000000000000
002251  aa  6 00032 3735 20	epp7 	pr6|26,*
002252  aa  7 00002 3715 20	epp5 	pr7|2,*
002253  aa  6 00264 6515 00	spri5	pr6|180
002254  aa  7 00006 3535 20	epp3 	pr7|6,*
002255  aa  6 00272 2535 00	spri3	pr6|186
002256  aa  6 00042 3515 20	epp1 	pr6|34,*
002257  aa  1 00004 3715 20	epp5 	pr1|4,*
002260  aa  6 00270 6515 00	spri5	pr6|184
002261  aa  7 00010 3535 20	epp3 	pr7|8,*
002262  aa  6 00274 2535 00	spri3	pr6|188
002263  aa  7 00012 3515 20	epp1 	pr7|10,*
002264  aa  6 00266 2515 00	spri1	pr6|182
						STATEMENT 1 ON LINE 730
	fnpp = a_fnpp;

002265  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
002266  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002267  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 731
	chanx = a_subchan;

002270  aa  6 00032 3715 20	epp5 	pr6|26,*
002271  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
002272  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 732
	order = a_order;

002273  aa  6 00270 2361 20	ldq  	pr6|184,*
002274  aa   000002 6040 04	tmi  	2,ic		002276
002275  aa   777777 3760 07	anq  	262143,dl
002276  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002277  aa  6 00272 3535 20	epp3 	pr6|186,*
002300  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002301  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_order
002302  aa  6 00116 00 0040	desc9a	pr6|78,32		order
						STATEMENT 1 ON LINE 733
	data_ptr = a_data_ptr;

002303  aa  6 00274 3515 20	epp1 	pr6|188,*		a_data_ptr
002304  aa  1 00000 3515 20	epp1 	pr1|0,*		a_data_ptr
002305  aa  6 00126 2515 00	spri1	pr6|86		data_ptr
						STATEMENT 1 ON LINE 735
	dumpin, dumpout, set_write_status, get_meters = "0"b;

002306  aa  6 00155 4501 00	stz  	pr6|109		dumpin
002307  aa  6 00156 4501 00	stz  	pr6|110		dumpout
002310  aa  6 00130 4501 00	stz  	pr6|88		set_write_status
002311  aa  6 00157 4501 00	stz  	pr6|111		get_meters
						STATEMENT 1 ON LINE 737
	opcode, alter_type = -1;

002312  aa   000001 3360 07	lcq  	1,dl
002313  aa  6 00134 7561 00	stq  	pr6|92		opcode
002314  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 738
	check = "0"b;

002315  aa  6 00136 4501 00	stz  	pr6|94		check
						STATEMENT 1 ON LINE 740
	if order = "read_status"			/* there's never any at this level */
	then do;

002316  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002317  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002320  aa   775671 00 0013	desc9a	-1095,11		000207 = 162145141144
002321  aa   000004 6010 04	tnz  	4,ic		002325
						STATEMENT 1 ON LINE 742
	     data_ptr -> rd_stat.input_available = "0"b;

002322  aa  1 00002 4501 00	stz  	pr1|2		rd_stat.input_available
						STATEMENT 1 ON LINE 743
	     a_code = 0;

002323  aa  6 00266 4501 20	stz  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 744
	     return;

002324  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 745
	end;

						STATEMENT 1 ON LINE 747
	else if order = "hangup"
	then do;

002325  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002326  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002327  aa   775647 00 0006	desc9a	-1113,6		000174 = 150141156147
002330  aa   000010 6010 04	tnz  	8,ic		002340
						STATEMENT 1 ON LINE 749
	     mbx_data_len = 0;

002331  aa  6 00137 4501 00	stz  	pr6|95		mbx_data_len
						STATEMENT 1 ON LINE 750
	     mbx_data = ""b;

002332  aa  000 100 100 400	mlr  	(),(pr),fill(000)
002333  aa   000000 00 0000	desc9a	0,0
002334  aa  6 00140 00 0020	desc9a	pr6|96,16		mbx_data
						STATEMENT 1 ON LINE 751
	     opcode = disconnect_this_line;

002335  aa   000001 2360 07	ldq  	1,dl
002336  aa  6 00134 7561 00	stq  	pr6|92		opcode
						STATEMENT 1 ON LINE 752
	end;

002337  aa   000077 7100 04	tra  	63,ic		002436
						STATEMENT 1 ON LINE 806
	else if order = "abort"			/* i.e., resetread or resetwrite */
	then do;

002340  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002341  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002342  aa   775632 00 0005	desc9a	-1126,5		000172 = 141142157162
002343  aa   000012 6010 04	tnz  	10,ic		002355
						STATEMENT 1 ON LINE 808
	     dumpin = substr (data_ptr -> based_bit2, 2, 1);

002344  aa  6 00155 4501 00	stz  	pr6|109		dumpin
002345  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002346  aa  1 00000 01 0001	descb	pr1|0(1),1	based_bit2
002347  aa  6 00155 00 0001	descb	pr6|109,1		dumpin
						STATEMENT 1 ON LINE 810
	     dumpout = substr (data_ptr -> based_bit2, 1, 1);

002350  aa  6 00156 4501 00	stz  	pr6|110		dumpout
002351  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002352  aa  1 00000 00 0001	descb	pr1|0,1		based_bit2
002353  aa  6 00156 00 0001	descb	pr6|110,1		dumpout
						STATEMENT 1 ON LINE 811
	end;

002354  aa   000062 7100 04	tra  	50,ic		002436
						STATEMENT 1 ON LINE 813
	else if order = "set_line_type"
	then do;

002355  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002356  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002357  aa   775651 00 0015	desc9a	-1111,13		000226 = 163145164137
002360  aa   000015 6010 04	tnz  	13,ic		002375
						STATEMENT 1 ON LINE 815
	     mbx_data_len = TWO_WORD_LTH;

002361  aa   000022 2360 07	ldq  	18,dl
002362  aa  6 00137 7561 00	stq  	pr6|95		mbx_data_len
						STATEMENT 1 ON LINE 816
	     local_line_type = data_ptr -> based_fb_word;

002363  aa  1 00000 2361 00	ldq  	pr1|0		based_fb_word
002364  aa  6 00162 7561 00	stq  	pr6|114		local_line_type
						STATEMENT 1 ON LINE 817
	     if local_line_type <= 0 | local_line_type > max_line_type
	     then go to order_error;

002365  aa   000045 6044 04	tmoz 	37,ic		002432
002366  aa   000025 1160 07	cmpq 	21,dl
002367  aa   000043 6054 04	tpnz 	35,ic		002432
						STATEMENT 1 ON LINE 819
	     check = "1"b;

002370  aa   400000 2350 03	lda  	131072,du
002371  aa  6 00136 7551 00	sta  	pr6|94		check
						STATEMENT 1 ON LINE 820
	     opcode = set_line_type;

002372  aa   000006 2360 07	ldq  	6,dl
002373  aa  6 00134 7561 00	stq  	pr6|92		opcode
						STATEMENT 1 ON LINE 821
	end;

002374  aa   000042 7100 04	tra  	34,ic		002436
						STATEMENT 1 ON LINE 851
	else if order = "listen"
	then do;

002375  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002376  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002377  aa   775573 00 0006	desc9a	-1157,6		000170 = 154151163164
002400  aa   000010 6010 04	tnz  	8,ic		002410
						STATEMENT 1 ON LINE 853
	     alter_type = Listen;

002401  aa   000020 2360 07	ldq  	16,dl
002402  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 854
	     alter_data = "000000001"b;

002403  aa   001000 2350 03	lda  	512,du
002404  aa  6 00151 7551 00	sta  	pr6|105		alter_data
002405  aa   000011 2360 07	ldq  	9,dl
002406  aa  6 00150 7561 00	stq  	pr6|104		alter_data
						STATEMENT 1 ON LINE 855
	end;

002407  aa   000027 7100 04	tra  	23,ic		002436
						STATEMENT 1 ON LINE 857
	else if order = "write_status"
	then set_write_status = "1"b;

002410  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002411  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002412  aa   775574 00 0014	desc9a	-1156,12		000204 = 167162151164
002413  aa   000004 6010 04	tnz  	4,ic		002417
002414  aa   400000 2350 03	lda  	131072,du
002415  aa  6 00130 7551 00	sta  	pr6|88		set_write_status
002416  aa   000020 7100 04	tra  	16,ic		002436
						STATEMENT 1 ON LINE 860
	else if order = "enter_receive"
	then do;

002417  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002420  aa  6 00116 00 0040	desc9a	pr6|78,32		order
002421  aa   775603 00 0015	desc9a	-1149,13		000222 = 145156164145
002422  aa   000010 6010 04	tnz  	8,ic		002432
						STATEMENT 1 ON LINE 862
	     mbx_data_len = 0;

002423  aa  6 00137 4501 00	stz  	pr6|95		mbx_data_len
						STATEMENT 1 ON LINE 863
	     mbx_data = ""b;

002424  aa  000 100 100 400	mlr  	(),(pr),fill(000)
002425  aa   000000 00 0000	desc9a	0,0
002426  aa  6 00140 00 0020	desc9a	pr6|96,16		mbx_data
						STATEMENT 1 ON LINE 864
	     opcode = enter_receive;

002427  aa   000007 2360 07	ldq  	7,dl
002430  aa  6 00134 7561 00	stq  	pr6|92		opcode
						STATEMENT 1 ON LINE 865
	end;

002431  aa   000005 7100 04	tra  	5,ic		002436
						STATEMENT 1 ON LINE 981
	else do;

						STATEMENT 1 ON LINE 982
order_error:
	     a_code = error_table_$undefined_order_request;

002432  aa  6 00044 3701 20	epp4 	pr6|36,*
002433  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$undefined_order_request
002434  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 984
	     return;

002435  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 985
	end;

						STATEMENT 1 ON LINE 987
	code = 0;

002436  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 988
	call setup;

002437  aa   001410 6700 04	tsp4 	776,ic		004047
						STATEMENT 1 ON LINE 989
	if code ^= 0
	then do;

002440  aa  6 00100 2361 00	ldq  	pr6|64		code
002441  aa   000003 6000 04	tze  	3,ic		002444
						STATEMENT 1 ON LINE 991
	     a_code = code;

002442  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 992
	     return;

002443  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 993
	end;

						STATEMENT 1 ON LINE 995
	if opcode = disconnect_this_line		/* hangup */
	then do;

002444  aa  6 00134 2361 00	ldq  	pr6|92		opcode
002445  aa   000001 1160 07	cmpq 	1,dl
002446  aa   000006 6010 04	tnz  	6,ic		002454
						STATEMENT 1 ON LINE 997
	     pcb.listen, pcb.tandd_attached = "0"b;

002447  aa   002577 2350 04	lda  	1407,ic		005246 = 377777777777
002450  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002451  aa  7 00004 3551 00	ansa 	pr7|4		pcb.listen
002452  aa   002573 2350 04	lda  	1403,ic		005245 = 777677777777
002453  aa  7 00004 3551 00	ansa 	pr7|4		pcb.tandd_attached
						STATEMENT 1 ON LINE 998
	end;

						STATEMENT 1 ON LINE 1017
	if alter_type ^= -1				/* alter_parameters required */
	then do;

002454  aa  6 00135 2361 00	ldq  	pr6|93		alter_type
002455  aa   002615 1160 04	cmpq 	1421,ic		005272 = 777777777777
002456  aa   000036 6000 04	tze  	30,ic		002514
						STATEMENT 1 ON LINE 1019
	     if alter_type = Listen
	     then do;

002457  aa   000020 1160 07	cmpq 	16,dl
002460  aa   000004 6010 04	tnz  	4,ic		002464
						STATEMENT 1 ON LINE 1024
		pcb.listen = "1"b;

002461  aa   400000 2350 03	lda  	131072,du
002462  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002463  aa  7 00004 2551 00	orsa 	pr7|4		pcb.listen
						STATEMENT 1 ON LINE 1025
	     end;

						STATEMENT 1 ON LINE 1027
	     mbx_data_len = length (alter_data) + 9;

002464  aa  6 00150 2361 00	ldq  	pr6|104		alter_data
002465  aa   000011 0760 07	adq  	9,dl
002466  aa  6 00137 7561 00	stq  	pr6|95		mbx_data_len
						STATEMENT 1 ON LINE 1028
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;

002467  aa  6 00135 2351 00	lda  	pr6|93		alter_type
002470  aa   000002 6050 04	tpl  	2,ic		002472
002471  aa   000000 5310 00	neg  	0
002472  aa   000033 7350 00	als  	27
002473  aa  6 00440 7551 00	sta  	pr6|288
002474  aa   000011 2360 07	ldq  	9,dl
002475  aa  6 00150 0761 00	adq  	pr6|104		alter_data
002476  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
002477  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002500  aa  6 00440 00 0011	descb	pr6|288,9
002501  aa  2 00000 00 0011	descb	pr2|0,9
002502  aa  6 00150 7271 00	lxl7 	pr6|104		alter_data
002503  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
002504  aa  6 00151 00 0017	descb	pr6|105,x7	alter_data
002505  aa  2 00000 20 0017	descb	pr2|0(9),x7
002506  aa  003 100 060 540	csl  	(pr,rl),(pr),fill(0),bool(move)
002507  aa  2 00000 00 0006	descb	pr2|0,ql
002510  aa  6 00140 00 0220	descb	pr6|96,144	mbx_data
						STATEMENT 1 ON LINE 1029
	     opcode = alter_parameters;

002511  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002512  aa   000042 2360 07	ldq  	34,dl
002513  aa  6 00134 7561 00	stq  	pr6|92		opcode
						STATEMENT 1 ON LINE 1030
	end;

						STATEMENT 1 ON LINE 1032
	if opcode ^= -1				/* we do have to send the FNP something */
	then do;

002514  aa  6 00134 2361 00	ldq  	pr6|92		opcode
002515  aa   002555 1160 04	cmpq 	1389,ic		005272 = 777777777777
002516  aa   000106 6000 04	tze  	70,ic		002624
						STATEMENT 1 ON LINE 1034
	     if check				/* anything special about it */
	     then do;

002517  aa  6 00136 2351 00	lda  	pr6|94		check
002520  aa   000051 6000 04	tze  	41,ic		002571
						STATEMENT 1 ON LINE 1036
		if opcode = set_line_type		/* make sure this is OK */
		then if pcb.listen
		     then do;

002521  aa   000006 1160 07	cmpq 	6,dl
002522  aa   000047 6010 04	tnz  	39,ic		002571
002523  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002524  aa  7 00004 2351 00	lda  	pr7|4		pcb.listen
002525  aa   400000 3150 03	cana 	131072,du
002526  aa   000003 6000 04	tze  	3,ic		002531
						STATEMENT 1 ON LINE 1039
			call unlock;

002527  aa   002046 6700 04	tsp4 	1062,ic		004575
						STATEMENT 1 ON LINE 1040
			go to order_error;

002530  aa   777702 7100 04	tra  	-62,ic		002432
						STATEMENT 1 ON LINE 1041
		     end;

						STATEMENT 1 ON LINE 1043
		     else do;

						STATEMENT 1 ON LINE 1044
			mbx_data = bit (bin (local_line_type, 18), 18);

002531  aa  6 00162 2351 00	lda  	pr6|114		local_line_type
002532  aa   000002 6050 04	tpl  	2,ic		002534
002533  aa   000000 5310 00	neg  	0
002534  aa   000022 7350 00	als  	18
002535  aa  6 00440 7551 00	sta  	pr6|288
002536  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002537  aa  6 00440 00 0022	descb	pr6|288,18
002540  aa  6 00140 00 0220	descb	pr6|96,144	mbx_data
						STATEMENT 1 ON LINE 1045
			do i = 1 to n_sync_line_types while (local_line_type ^= sync_line_type (i));

002541  aa   000012 2360 07	ldq  	10,dl
002542  aa  6 00302 7561 00	stq  	pr6|194
002543  aa   000001 2360 07	ldq  	1,dl
002544  aa  6 00112 7561 00	stq  	pr6|74		i
002545  aa   000000 0110 03	nop  	0,du
002546  aa  6 00112 2361 00	ldq  	pr6|74		i
002547  aa  6 00302 1161 00	cmpq 	pr6|194
002550  aa   000007 6054 04	tpnz 	7,ic		002557
002551  aa  6 00162 2361 00	ldq  	pr6|114		local_line_type
002552  aa  6 00112 7271 00	lxl7 	pr6|74		i
002553  ta   777777 1160 17	cmpq 	-1,7
002554  aa   000003 6000 04	tze  	3,ic		002557
						STATEMENT 1 ON LINE 1046
			end;

002555  aa  6 00112 0541 00	aos  	pr6|74		i
002556  aa   777770 7100 04	tra  	-8,ic		002546
						STATEMENT 1 ON LINE 1048
			pcb.sync_line = (i <= n_sync_line_types);

002557  aa  6 00112 2361 00	ldq  	pr6|74		i
002560  aa   000012 1160 07	cmpq 	10,dl
002561  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
002562  aa   000004 7710 00	arl  	4
002563  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002564  aa  7 00004 6751 00	era  	pr7|4		pcb.sync_line
002565  aa   020000 3750 03	ana  	8192,du
002566  aa  7 00004 6551 00	ersa 	pr7|4		pcb.sync_line
						STATEMENT 1 ON LINE 1049
			opcode = alter_parameters;

002567  aa   000042 2360 07	ldq  	34,dl
002570  aa  6 00134 7561 00	stq  	pr6|92		opcode
						STATEMENT 1 ON LINE 1050
		     end;

						STATEMENT 1 ON LINE 1085
	     end;

						STATEMENT 1 ON LINE 1086
	     if opcode ^= alter_parameters
	     then call uncp$send_wcd (fnpp, pcbp, opcode, mbx_data_len, mbx_data);

002571  aa   000042 1160 07	cmpq 	34,dl
002572  aa   000131 6000 04	tze  	89,ic		002723
002573  aa  6 00242 3521 00	epp2 	pr6|162		fnpp
002574  aa  6 00414 2521 00	spri2	pr6|268
002575  aa  6 00246 3521 00	epp2 	pr6|166		pcbp
002576  aa  6 00416 2521 00	spri2	pr6|270
002577  aa  6 00134 3521 00	epp2 	pr6|92		opcode
002600  aa  6 00420 2521 00	spri2	pr6|272
002601  aa  6 00137 3521 00	epp2 	pr6|95		mbx_data_len
002602  aa  6 00422 2521 00	spri2	pr6|274
002603  aa  6 00140 3521 00	epp2 	pr6|96		mbx_data
002604  aa  6 00424 2521 00	spri2	pr6|276
002605  aa   775340 3520 04	epp2 	-1312,ic		000145 = 464000000000
002606  aa  6 00426 2521 00	spri2	pr6|278
002607  aa  6 00430 2521 00	spri2	pr6|280
002610  aa   775317 3520 04	epp2 	-1329,ic		000127 = 404000000010
002611  aa  6 00432 2521 00	spri2	pr6|282
002612  aa   775335 3520 04	epp2 	-1315,ic		000147 = 404000000021
002613  aa  6 00434 2521 00	spri2	pr6|284
002614  aa   775311 3520 04	epp2 	-1335,ic		000125 = 516000000220
002615  aa  6 00436 2521 00	spri2	pr6|286
002616  aa  6 00412 6211 00	eax1 	pr6|266
002617  aa   024000 4310 07	fld  	10240,dl
002620  aa  6 00044 3701 20	epp4 	pr6|36,*
002621  la  4 00010 3521 20	epp2 	pr4|8,*		uncp$send_wcd
002622  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1088
	end;

002623  aa   000100 7100 04	tra  	64,ic		002723
						STATEMENT 1 ON LINE 1090
	else do;

						STATEMENT 1 ON LINE 1095
	     if dumpout
	     then do;

002624  aa  6 00156 2351 00	lda  	pr6|110		dumpout
002625  aa   000067 6000 04	tze  	55,ic		002714
						STATEMENT 1 ON LINE 1097
		if pcb.write_first ^= 0
		then do;

002626  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002627  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
002630  aa   000066 7330 00	lrs  	54
002631  aa   000033 6000 04	tze  	27,ic		002664
						STATEMENT 1 ON LINE 1099
		     call tty_space_man$free_chain ((pcb.devx), OUTPUT, ptr (ttybp, pcb.write_first));

002632  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
002633  aa  6 00375 7561 00	stq  	pr6|253		pcb.write_first
002634  aa   000066 7330 00	lrs  	54
002635  aa  6 00440 7561 00	stq  	pr6|288
002636  aa  6 00375 2361 00	ldq  	pr6|253		pcb.write_first
002637  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
002640  aa   000000 3120 06	eawp2	0,ql
002641  aa  6 00410 2521 00	spri2	pr6|264
002642  aa  6 00440 3521 00	epp2 	pr6|288
002643  aa  6 00400 2521 00	spri2	pr6|256
002644  aa   775270 3520 04	epp2 	-1352,ic		000134 = 400000000000
002645  aa  6 00402 2521 00	spri2	pr6|258
002646  aa  6 00410 3521 00	epp2 	pr6|264
002647  aa  6 00404 2521 00	spri2	pr6|260
002650  aa  6 00376 6211 00	eax1 	pr6|254
002651  aa   014000 4310 07	fld  	6144,dl
002652  aa  6 00044 3701 20	epp4 	pr6|36,*
002653  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$free_chain
002654  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1100
		     pcb.write_first, pcb.write_last, pcb.write_cnt = 0;

002655  aa   000000 2350 07	lda  	0,dl
002656  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002657  aa  7 00001 5511 60	stba 	pr7|1,60		pcb.write_first
002660  aa   000022 7710 00	arl  	18
002661  aa  7 00001 5511 14	stba 	pr7|1,14		pcb.write_last
002662  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
002663  aa  7 00003 5511 14	stba 	pr7|3,14		pcb.write_cnt
						STATEMENT 1 ON LINE 1101
		end;

						STATEMENT 1 ON LINE 1107
		if pcb.end_frame
		then do;

002664  aa  7 00004 2351 00	lda  	pr7|4		pcb.end_frame
002665  aa   010000 3150 03	cana 	4096,du
002666  aa   000026 6000 04	tze  	22,ic		002714
						STATEMENT 1 ON LINE 1109
		     pcb.end_frame = "0"b;

002667  aa   002355 2350 04	lda  	1261,ic		005244 = 767777777777
002670  aa  7 00004 3551 00	ansa 	pr7|4		pcb.end_frame
						STATEMENT 1 ON LINE 1110
		     if pcb.send_output
		     then call channel_manager$interrupt ((pcb.devx), SEND_OUTPUT, ""b);

002671  aa  7 00004 2351 00	lda  	pr7|4		pcb.send_output
002672  aa   100000 3150 03	cana 	32768,du
002673  aa   000021 6000 04	tze  	17,ic		002714
002674  aa  7 00000 2351 00	lda  	pr7|0		pcb.devx
002675  aa   000066 7330 00	lrs  	54
002676  aa  6 00440 7561 00	stq  	pr6|288
002677  aa   775267 2370 04	ldaq 	-1353,ic		000166 = 000000000000 000000000000
002700  aa  6 00410 7571 00	staq 	pr6|264
002701  aa  6 00440 3521 00	epp2 	pr6|288
002702  aa  6 00400 2521 00	spri2	pr6|256
002703  aa   775240 3520 04	epp2 	-1376,ic		000143 = 000000000004
002704  aa  6 00402 2521 00	spri2	pr6|258
002705  aa  6 00410 3521 00	epp2 	pr6|264
002706  aa  6 00404 2521 00	spri2	pr6|260
002707  aa  6 00376 6211 00	eax1 	pr6|254
002710  aa   014000 4310 07	fld  	6144,dl
002711  aa  6 00044 3701 20	epp4 	pr6|36,*
002712  la  4 00122 3521 20	epp2 	pr4|82,*		channel_manager$interrupt
002713  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1112
		end;

						STATEMENT 1 ON LINE 1113
	     end;

						STATEMENT 1 ON LINE 1115
	     if set_write_status
	     then opend = (pcb.write_first ^= 0);

002714  aa  6 00130 2351 00	lda  	pr6|88		set_write_status
002715  aa   000006 6000 04	tze  	6,ic		002723
002716  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
002717  aa  7 00001 2351 00	lda  	pr7|1		pcb.write_first
002720  aa   000066 7330 00	lrs  	54
002721  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
002722  aa  6 00163 7551 00	sta  	pr6|115		opend
						STATEMENT 1 ON LINE 1137
	end;

						STATEMENT 1 ON LINE 1139
	call unlock;

002723  aa   001652 6700 04	tsp4 	938,ic		004575
						STATEMENT 1 ON LINE 1140
	if set_write_status
	then data_ptr -> wr_stat.output_pending = opend;

002724  aa  6 00130 2351 00	lda  	pr6|88		set_write_status
002725  aa   000004 6000 04	tze  	4,ic		002731
002726  aa  6 00163 2351 00	lda  	pr6|115		opend
002727  aa  6 00126 3735 20	epp7 	pr6|86,*		data_ptr
002730  aa  7 00002 7551 00	sta  	pr7|2		wr_stat.output_pending
						STATEMENT 1 ON LINE 1142
	a_code = code;

002731  aa  6 00100 2361 00	ldq  	pr6|64		code
002732  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1144
	return;

002733  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO check_modes                                        STATEMENT 1 ON LINE 1146
check_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

002734  ta     002061000000
002735  da     000552300000
002736  aa   000740 6270 00	eax7 	480
002737  aa  7 00034 3521 20	epp2 	pr7|28,*
002740  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002741  aa     000010000000
002742  aa     000000000000
002743  aa  6 00032 3735 20	epp7 	pr6|26,*
002744  aa  7 00002 3715 20	epp5 	pr7|2,*
002745  aa  6 00264 6515 00	spri5	pr6|180
002746  aa  7 00010 3535 20	epp3 	pr7|8,*
002747  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 1151
	fnpp = a_fnpp;

002750  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
002751  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
002752  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1152
	chanx = a_subchan;

002753  aa  6 00032 3715 20	epp5 	pr6|26,*
002754  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
002755  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 1153
	mclp = a_mode_list_ptr;

002756  aa  5 00006 3535 20	epp3 	pr5|6,*		a_mode_list_ptr
002757  aa  3 00000 3535 20	epp3 	pr3|0,*		a_mode_list_ptr
002760  aa  6 00254 2535 00	spri3	pr6|172		mclp
						STATEMENT 1 ON LINE 1154
	if mcl.version ^= mcl_version_2
	then do;

002761  aa  3 00000 2361 00	ldq  	pr3|0		mcl.version
002762  aa   000002 1160 07	cmpq 	2,dl
002763  aa   000005 6000 04	tze  	5,ic		002770
						STATEMENT 1 ON LINE 1156
	     a_code = error_table_$unimplemented_version;

002764  aa  6 00044 3701 20	epp4 	pr6|36,*
002765  la  4 00070 2361 20	ldq  	pr4|56,*		error_table_$unimplemented_version
002766  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1157
	     return;

002767  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1158
	end;

						STATEMENT 1 ON LINE 1160
	call setup;

002770  aa   001057 6700 04	tsp4 	559,ic		004047
						STATEMENT 1 ON LINE 1161
	if code ^= 0
	then do;

002771  aa  6 00100 2361 00	ldq  	pr6|64		code
002772  aa   000003 6000 04	tze  	3,ic		002775
						STATEMENT 1 ON LINE 1163
	     a_code = code;

002773  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1164
	     return;

002774  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1165
	end;

						STATEMENT 1 ON LINE 1167
	do modex = 1 to mcl.n_entries;

002775  aa  6 00254 3735 20	epp7 	pr6|172,*		mclp
002776  aa  7 00001 2361 00	ldq  	pr7|1		mcl.n_entries
002777  aa  6 00303 7561 00	stq  	pr6|195
003000  aa   000001 2360 07	ldq  	1,dl
003001  aa  6 00164 7561 00	stq  	pr6|116		modex
003002  aa  6 00164 2361 00	ldq  	pr6|116		modex
003003  aa  6 00303 1161 00	cmpq 	pr6|195
003004  aa   000202 6054 04	tpnz 	130,ic		003206
						STATEMENT 1 ON LINE 1168
	     mclep = addr (mcl.entries (modex));

003005  aa   000005 4020 07	mpy  	5,dl
003006  aa  6 00254 3735 20	epp7 	pr6|172,*		mclp
003007  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
003010  aa  6 00256 6535 00	spri7	pr6|174		mclep
						STATEMENT 1 ON LINE 1170
	     mode_name = substr (mcle.mode_name, 1, 8);

003011  aa  7 00000 2351 00	lda  	pr7|0		mcle.mode_name
003012  aa  7 00001 2361 00	ldq  	pr7|1		mcle.mode_name
003013  aa  6 00166 7571 00	staq 	pr6|118		mode_name
						STATEMENT 1 ON LINE 1171
	     mode_on = mcle.mode_switch;

003014  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
003015  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003016  aa  6 00170 7551 00	sta  	pr6|120		mode_on
						STATEMENT 1 ON LINE 1173
	     do i = 1 to hbound (good_modes, 1) while (mode_name ^= good_modes (i));

003017  aa   000001 2360 07	ldq  	1,dl
003020  aa  6 00112 7561 00	stq  	pr6|74		i
003021  aa   000000 0110 03	nop  	0,du
003022  aa  6 00112 2361 00	ldq  	pr6|74		i
003023  aa   000001 1160 07	cmpq 	1,dl
003024  aa   000012 6054 04	tpnz 	10,ic		003036
003025  aa   000001 7360 00	qls  	1
003026  aa   000000 6270 06	eax7 	0,ql
003027  aa  6 00166 2371 00	ldaq 	pr6|118		mode_name
003030  ta   000102 1150 17	cmpa 	66,7
003031  aa   000002 6010 04	tnz  	2,ic		003033
003032  ta   000103 1160 17	cmpq 	67,7
003033  aa   000003 6000 04	tze  	3,ic		003036
						STATEMENT 1 ON LINE 1174
	     end;

003034  aa  6 00112 0541 00	aos  	pr6|74		i
003035  aa   777765 7100 04	tra  	-11,ic		003022
						STATEMENT 1 ON LINE 1176
	     if i <= hbound (good_modes, 1)		/* tree */
						/* it's one of the ones we always recognize */
	     then mcle.mpx_mode = "1"b;

003036  aa  6 00112 2361 00	ldq  	pr6|74		i
003037  aa   000001 1160 07	cmpq 	1,dl
003040  aa   000005 6054 04	tpnz 	5,ic		003045
003041  aa   100000 2350 03	lda  	32768,du
003042  aa  6 00256 3735 20	epp7 	pr6|174,*		mclep
003043  aa  7 00004 2551 00	orsa 	pr7|4		mcle.mpx_mode
003044  aa   000140 7100 04	tra  	96,ic		003204
						STATEMENT 1 ON LINE 1179
	     else do;

						STATEMENT 1 ON LINE 1180
		do i = 1 to hbound (async_only_modes, 1) while (mode_name ^= async_only_modes (i));

003045  aa   000001 2360 07	ldq  	1,dl
003046  aa  6 00112 7561 00	stq  	pr6|74		i
003047  aa   000000 0110 03	nop  	0,du
003050  aa  6 00112 2361 00	ldq  	pr6|74		i
003051  aa   000017 1160 07	cmpq 	15,dl
003052  aa   000012 6054 04	tpnz 	10,ic		003064
003053  aa   000001 7360 00	qls  	1
003054  aa   000000 6270 06	eax7 	0,ql
003055  aa  6 00166 2371 00	ldaq 	pr6|118		mode_name
003056  ta   000044 1150 17	cmpa 	36,7
003057  aa   000002 6010 04	tnz  	2,ic		003061
003060  ta   000045 1160 17	cmpq 	37,7
003061  aa   000003 6000 04	tze  	3,ic		003064
						STATEMENT 1 ON LINE 1181
		end;

003062  aa  6 00112 0541 00	aos  	pr6|74		i
003063  aa   777765 7100 04	tra  	-11,ic		003050
						STATEMENT 1 ON LINE 1183
		if i > hbound (async_only_modes, 1)	/* we've never heard of this one at all */
		then mcle.mpx_mode = "0"b;

003064  aa  6 00112 2361 00	ldq  	pr6|74		i
003065  aa   000017 1160 07	cmpq 	15,dl
003066  aa   000005 6044 04	tmoz 	5,ic		003073
003067  aa   002160 2350 04	lda  	1136,ic		005247 = 677777777777
003070  aa  6 00256 3735 20	epp7 	pr6|174,*		mclep
003071  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
003072  aa   000112 7100 04	tra  	74,ic		003204
						STATEMENT 1 ON LINE 1185
		else do;

						STATEMENT 1 ON LINE 1186
		     mcle.mpx_mode = ^pcb.sync_line;

003073  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
003074  aa  7 00004 2351 00	lda  	pr7|4		pcb.sync_line
003075  aa   000004 7350 00	als  	4
003076  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003077  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
003100  aa   000002 7710 00	arl  	2
003101  aa  6 00256 3715 20	epp5 	pr6|174,*		mclep
003102  aa  5 00004 6751 00	era  	pr5|4		mcle.mpx_mode
003103  aa   100000 3750 03	ana  	32768,du
003104  aa  5 00004 6551 00	ersa 	pr5|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 1188
		     do i = 1 to hbound (full_dpx_modes, 1) while (mode_name ^= full_dpx_modes (i));

003105  aa   000001 2360 07	ldq  	1,dl
003106  aa  6 00112 7561 00	stq  	pr6|74		i
003107  aa   000000 0110 03	nop  	0,du
003110  aa  6 00112 2361 00	ldq  	pr6|74		i
003111  aa   000007 1160 07	cmpq 	7,dl
003112  aa   000012 6054 04	tpnz 	10,ic		003124
003113  aa   000001 7360 00	qls  	1
003114  aa   000000 6270 06	eax7 	0,ql
003115  aa  6 00166 2371 00	ldaq 	pr6|118		mode_name
003116  ta   000026 1150 17	cmpa 	22,7
003117  aa   000002 6010 04	tnz  	2,ic		003121
003120  ta   000027 1160 17	cmpq 	23,7
003121  aa   000003 6000 04	tze  	3,ic		003124
						STATEMENT 1 ON LINE 1189
		     end;

003122  aa  6 00112 0541 00	aos  	pr6|74		i
003123  aa   777765 7100 04	tra  	-11,ic		003110
						STATEMENT 1 ON LINE 1191
		     if (mode_name = "no_outp" | mode_name = "8bit" | mode_name = "oddp") & mode_on
		     then if ^pcb.is_hsla
			then go to bad_mode;

003124  aa   775040 2370 04	ldaq 	-1504,ic		000164 = 156157137157 165164160000
003125  aa  0 00456 2771 00	oraq 	pr0|302		= 000000000000 000000000040
003126  aa  6 00166 1171 00	cmpaq	pr6|118		mode_name
003127  aa   000013 6000 04	tze  	11,ic		003142
003130  aa   774774 2350 04	lda  	-1540,ic		000124 = 070142151164
003131  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
003132  aa  0 00450 2771 00	oraq 	pr0|296		= 000000000000 040040040040
003133  aa  6 00166 1171 00	cmpaq	pr6|118		mode_name
003134  aa   000006 6000 04	tze  	6,ic		003142
003135  aa   774766 2350 04	lda  	-1546,ic		000123 = 157144144160
003136  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
003137  aa  0 00450 2771 00	oraq 	pr0|296		= 000000000000 040040040040
003140  aa  6 00166 1171 00	cmpaq	pr6|118		mode_name
003141  aa   000006 6010 04	tnz  	6,ic		003147
003142  aa  6 00170 2351 00	lda  	pr6|120		mode_on
003143  aa   000004 6000 04	tze  	4,ic		003147
003144  aa  6 00246 2351 20	lda  	pr6|166,*		pcb.is_hsla
003145  aa   001000 3150 07	cana 	512,dl
003146  aa   000022 6000 04	tze  	18,ic		003170
						STATEMENT 1 ON LINE 1195
		     if i <= hbound (full_dpx_modes, 1) /* if this was a mode requiring full duplex capability */
		     then if mode_on
			then if pcb.line_type ^= LINE_ASCII & pcb.line_type ^= LINE_ASYNC1
				& pcb.line_type ^= LINE_ASYNC2 & pcb.line_type ^= LINE_ASYNC3
			     then do;

003147  aa  6 00112 2361 00	ldq  	pr6|74		i
003150  aa   000007 1160 07	cmpq 	7,dl
003151  aa   000033 6054 04	tpnz 	27,ic		003204
003152  aa  6 00170 2351 00	lda  	pr6|120		mode_on
003153  aa   000031 6000 04	tze  	25,ic		003204
003154  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
003155  aa  7 00002 2351 00	lda  	pr7|2		pcb.line_type
003156  aa   000022 7350 00	als  	18
003157  aa   000066 7330 00	lrs  	54
003160  aa   000001 1160 07	cmpq 	1,dl
003161  aa   000023 6000 04	tze  	19,ic		003204
003162  aa   000012 1160 07	cmpq 	10,dl
003163  aa   000021 6000 04	tze  	17,ic		003204
003164  aa   000013 1160 07	cmpq 	11,dl
003165  aa   000017 6000 04	tze  	15,ic		003204
003166  aa   000014 1160 07	cmpq 	12,dl
003167  aa   000015 6000 04	tze  	13,ic		003204
						STATEMENT 1 ON LINE 1200
bad_mode:
				if mcle.force
				then mcle.mpx_mode = "0"b;

003170  aa  6 00256 3735 20	epp7 	pr6|174,*		mclep
003171  aa  7 00004 2351 00	lda  	pr7|4		mcle.force
003172  aa   200000 3150 03	cana 	65536,du
003173  aa   000004 6000 04	tze  	4,ic		003177
003174  aa   002053 2350 04	lda  	1067,ic		005247 = 677777777777
003175  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
003176  aa   000006 7100 04	tra  	6,ic		003204
						STATEMENT 1 ON LINE 1203
				else do;

						STATEMENT 1 ON LINE 1204
				     code = error_table_$bad_mode;

003177  aa  6 00044 3701 20	epp4 	pr6|36,*
003200  la  4 00062 2361 20	ldq  	pr4|50,*		error_table_$bad_mode
003201  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1205
				     mcle.error = "1"b;

003202  aa   040000 2350 03	lda  	16384,du
003203  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 1206
				end;

						STATEMENT 1 ON LINE 1207
			     end;

						STATEMENT 1 ON LINE 1209
		end;

						STATEMENT 1 ON LINE 1210
	     end;

						STATEMENT 1 ON LINE 1211
	end;

003204  aa  6 00164 0541 00	aos  	pr6|116		modex
003205  aa   777575 7100 04	tra  	-131,ic		003002
						STATEMENT 1 ON LINE 1213
	call unlock;

003206  aa   001367 6700 04	tsp4 	759,ic		004575
						STATEMENT 1 ON LINE 1214
	a_code = code;

003207  aa  6 00100 2361 00	ldq  	pr6|64		code
003210  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1215
	return;

003211  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_modes                                          STATEMENT 1 ON LINE 1217
set_modes:
     entry (a_fnpp, a_subchan, a_mode_list_ptr, a_code);

003212  ta     002061000000
003213  da     000560300000
003214  aa   000740 6270 00	eax7 	480
003215  aa  7 00034 3521 20	epp2 	pr7|28,*
003216  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003217  aa     000010000000
003220  aa     000000000000
003221  aa  6 00032 3735 20	epp7 	pr6|26,*
003222  aa  7 00002 3715 20	epp5 	pr7|2,*
003223  aa  6 00264 6515 00	spri5	pr6|180
003224  aa  7 00010 3535 20	epp3 	pr7|8,*
003225  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 1222
	fnpp = a_fnpp;

003226  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
003227  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
003230  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1223
	chanx = a_subchan;

003231  aa  6 00032 3715 20	epp5 	pr6|26,*
003232  aa  5 00004 2361 20	ldq  	pr5|4,*		a_subchan
003233  aa  6 00110 7561 00	stq  	pr6|72		chanx
						STATEMENT 1 ON LINE 1224
	mclp = a_mode_list_ptr;

003234  aa  5 00006 3535 20	epp3 	pr5|6,*		a_mode_list_ptr
003235  aa  3 00000 3535 20	epp3 	pr3|0,*		a_mode_list_ptr
003236  aa  6 00254 2535 00	spri3	pr6|172		mclp
						STATEMENT 1 ON LINE 1225
	if mcl.version ^= mcl_version_2
	then do;

003237  aa  3 00000 2361 00	ldq  	pr3|0		mcl.version
003240  aa   000002 1160 07	cmpq 	2,dl
003241  aa   000005 6000 04	tze  	5,ic		003246
						STATEMENT 1 ON LINE 1227
	     a_code = error_table_$unimplemented_version;

003242  aa  6 00044 3701 20	epp4 	pr6|36,*
003243  la  4 00070 2361 20	ldq  	pr4|56,*		error_table_$unimplemented_version
003244  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1228
	     return;

003245  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1229
	end;

						STATEMENT 1 ON LINE 1231
	call setup;

003246  aa   000601 6700 04	tsp4 	385,ic		004047
						STATEMENT 1 ON LINE 1232
	if code ^= 0
	then do;

003247  aa  6 00100 2361 00	ldq  	pr6|64		code
003250  aa   000003 6000 04	tze  	3,ic		003253
						STATEMENT 1 ON LINE 1234
	     a_code = code;

003251  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1235
	     return;

003252  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1236
	end;

						STATEMENT 1 ON LINE 1238
	hndlquit_set = "0"b;

003253  aa  6 00172 4501 00	stz  	pr6|122		hndlquit_set
						STATEMENT 1 ON LINE 1239
	string (mode_set) = "0"b;

003254  aa  6 00171 4501 00	stz  	pr6|121
						STATEMENT 1 ON LINE 1241
	do modex = 1 to mcl.n_entries;

003255  aa  6 00254 3735 20	epp7 	pr6|172,*		mclp
003256  aa  7 00001 2361 00	ldq  	pr7|1		mcl.n_entries
003257  aa  6 00304 7561 00	stq  	pr6|196
003260  aa   000001 2360 07	ldq  	1,dl
003261  aa  6 00164 7561 00	stq  	pr6|116		modex
003262  aa  6 00164 2361 00	ldq  	pr6|116		modex
003263  aa  6 00304 1161 00	cmpq 	pr6|196
003264  aa   000026 6054 04	tpnz 	22,ic		003312
						STATEMENT 1 ON LINE 1242
	     mclep = addr (mcl.entries (modex));

003265  aa   000005 4020 07	mpy  	5,dl
003266  aa  6 00254 3735 20	epp7 	pr6|172,*		mclp
003267  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
003270  aa  6 00256 6535 00	spri7	pr6|174		mclep
						STATEMENT 1 ON LINE 1243
	     if mcle.mpx_mode			/* if this is one we're interested in */
	     then call process_mode (mcle.mode_name, mcle.mode_switch);

003271  aa  7 00004 2351 00	lda  	pr7|4		mcle.mpx_mode
003272  aa   100000 3150 03	cana 	32768,du
003273  aa   000015 6000 04	tze  	13,ic		003310
003274  aa  7 00000 3521 00	epp2 	pr7|0		mcle.mode_name
003275  aa  6 00414 2521 00	spri2	pr6|268
003276  aa  7 00004 3521 00	epp2 	pr7|4		mcle.mode_switch
003277  aa  6 00416 2521 00	spri2	pr6|270
003300  aa   774622 3520 04	epp2 	-1646,ic		000122 = 526000000020
003301  aa  6 00420 2521 00	spri2	pr6|272
003302  aa   774630 3520 04	epp2 	-1640,ic		000132 = 516000000001
003303  aa  6 00422 2521 00	spri2	pr6|274
003304  aa  6 00412 3521 00	epp2 	pr6|266
003305  aa   010000 4310 07	fld  	4096,dl
003306  aa  2 00000 7571 00	staq 	pr2|0
003307  aa   000667 6700 04	tsp4 	439,ic		004176
						STATEMENT 1 ON LINE 1245
	end;

003310  aa  6 00164 0541 00	aos  	pr6|116		modex
003311  aa   777751 7100 04	tra  	-23,ic		003262
						STATEMENT 1 ON LINE 1247
	if mcl.init
	then do;

003312  aa  6 00254 3735 20	epp7 	pr6|172,*		mclp
003313  aa  7 00005 2351 00	lda  	pr7|5		mcl.init
003314  aa   400000 3150 03	cana 	131072,du
003315  aa   000045 6000 04	tze  	37,ic		003362
						STATEMENT 1 ON LINE 1249
	     if ^hndlquit_set
	     then call process_mode ("hndlquit", "0"b);

003316  aa  6 00172 2351 00	lda  	pr6|122		hndlquit_set
003317  aa   000010 6010 04	tnz  	8,ic		003327
003320  aa   774642 2370 04	ldaq 	-1630,ic		000162 = 150156144154 161165151164
003321  aa  6 00410 7571 00	staq 	pr6|264
003322  aa   000000 2350 07	lda  	0,dl
003323  aa  6 00440 7551 00	sta  	pr6|288
003324  aa   001706 3520 04	epp2 	966,ic		005232 = 000004000000
003325  aa  2 00000 2351 00	lda  	pr2|0
003326  aa   000650 6700 04	tsp4 	424,ic		004176
						STATEMENT 1 ON LINE 1252
	     do modex = 1 to hbound (async_only_modes, 1);

003327  aa   000001 2360 07	ldq  	1,dl
003330  aa  6 00164 7561 00	stq  	pr6|116		modex
003331  aa   000000 0110 03	nop  	0,du
003332  aa  6 00164 2361 00	ldq  	pr6|116		modex
003333  aa   000017 1160 07	cmpq 	15,dl
003334  aa   000026 6054 04	tpnz 	22,ic		003362
						STATEMENT 1 ON LINE 1253
		if ^mode_set (modex)
		then call process_mode (async_only_modes (modex), "0"b);

003335  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
003336  aa  6 00170 70 0001	descb	pr6|120(35),1	mode_set
003337  aa   000000 00 0000	descb	0,0
003340  aa   000020 6010 04	tnz  	16,ic		003360
003341  aa   000001 7360 00	qls  	1
003342  aa   000000 2350 07	lda  	0,dl
003343  aa  6 00440 7551 00	sta  	pr6|288
003344  ta   000044 3520 06	epp2 	36,ql
003345  aa  6 00414 2521 00	spri2	pr6|268
003346  aa  6 00440 3521 00	epp2 	pr6|288
003347  aa  6 00416 2521 00	spri2	pr6|270
003350  aa   774551 3520 04	epp2 	-1687,ic		000121 = 526000000010
003351  aa  6 00420 2521 00	spri2	pr6|272
003352  aa   774572 3520 04	epp2 	-1670,ic		000144 = 514000000001
003353  aa  6 00422 2521 00	spri2	pr6|274
003354  aa  6 00412 3521 00	epp2 	pr6|266
003355  aa   010000 4310 07	fld  	4096,dl
003356  aa  2 00000 7571 00	staq 	pr2|0
003357  aa   000617 6700 04	tsp4 	399,ic		004176
						STATEMENT 1 ON LINE 1255
	     end;

003360  aa  6 00164 0541 00	aos  	pr6|116		modex
003361  aa   777751 7100 04	tra  	-23,ic		003332
						STATEMENT 1 ON LINE 1256
	end;

						STATEMENT 1 ON LINE 1258
	call unlock;

003362  aa   001213 6700 04	tsp4 	651,ic		004575
						STATEMENT 1 ON LINE 1259
	a_code = code;

003363  aa  6 00100 2361 00	ldq  	pr6|64		code
003364  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1260
	return;

003365  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_modes                                          STATEMENT 1 ON LINE 1264
get_modes:
     entry (a_fnpp, a_subchan, a_modes, a_code);

003366  at     000004000145
003367  tt     000147000141
003370  ta     000142000000
003371  ta     003366000000
003372  da     000566300000
003373  aa   000740 6270 00	eax7 	480
003374  aa  7 00034 3521 20	epp2 	pr7|28,*
003375  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
003376  aa     000010000000
003377  aa     000000000000
003400  aa  6 00042 3735 20	epp7 	pr6|34,*
003401  aa  7 00004 2361 20	ldq  	pr7|4,*
003402  aa   000002 6040 04	tmi  	2,ic		003404
003403  aa   777777 3760 07	anq  	262143,dl
003404  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003405  aa  6 00441 7561 00	stq  	pr6|289
003406  aa  6 00032 3715 20	epp5 	pr6|26,*
003407  aa  5 00002 3535 20	epp3 	pr5|2,*
003410  aa  6 00264 2535 00	spri3	pr6|180
003411  aa  5 00010 3515 20	epp1 	pr5|8,*
003412  aa  6 00266 2515 00	spri1	pr6|182
						STATEMENT 1 ON LINE 1269
	a_modes = "";

003413  aa  6 00032 3735 20	epp7 	pr6|26,*
003414  aa  7 00006 3715 20	epp5 	pr7|6,*
003415  aa  6 00441 2351 00	lda  	pr6|289
003416  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
003417  aa   000000 00 0000	desc9a	0,0
003420  aa  5 00000 00 0005	desc9a	pr5|0,al		a_modes
						STATEMENT 1 ON LINE 1270
	a_code = 0;

003421  aa  6 00266 4501 20	stz  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1271
	return;

003422  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO priv_control                                       STATEMENT 1 ON LINE 1273
priv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

003423  at     000004000145
003424  tt     000141000145
003425  ta     000142000000
003426  ta     003423000000
003427  da     000575300000
003430  aa   000740 6270 00	eax7 	480
003431  aa  7 00034 3521 20	epp2 	pr7|28,*
003432  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
003433  aa     000010000000
003434  aa     000000000000
003435  aa  6 00032 3735 20	epp7 	pr6|26,*
003436  aa  7 00002 3715 20	epp5 	pr7|2,*
003437  aa  6 00264 6515 00	spri5	pr6|180
003440  aa  7 00004 3535 20	epp3 	pr7|4,*
003441  aa  6 00272 2535 00	spri3	pr6|186
003442  aa  6 00042 3515 20	epp1 	pr6|34,*
003443  aa  1 00002 3715 20	epp5 	pr1|2,*
003444  aa  6 00270 6515 00	spri5	pr6|184
003445  aa  7 00006 3535 20	epp3 	pr7|6,*
003446  aa  6 00274 2535 00	spri3	pr6|188
003447  aa  7 00010 3515 20	epp1 	pr7|8,*
003450  aa  6 00266 2515 00	spri1	pr6|182
						STATEMENT 1 ON LINE 1278
	fnpp = a_fnpp;

003451  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
003452  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
003453  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1279
	order = a_order;

003454  aa  6 00270 2361 20	ldq  	pr6|184,*
003455  aa   000002 6040 04	tmi  	2,ic		003457
003456  aa   777777 3760 07	anq  	262143,dl
003457  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003460  aa  6 00272 3715 20	epp5 	pr6|186,*
003461  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
003462  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_order
003463  aa  6 00116 00 0040	desc9a	pr6|78,32		order
						STATEMENT 1 ON LINE 1280
	data_ptr = a_data_ptr;

003464  aa  6 00274 3535 20	epp3 	pr6|188,*		a_data_ptr
003465  aa  3 00000 3535 20	epp3 	pr3|0,*		a_data_ptr
003466  aa  6 00126 2535 00	spri3	pr6|86		data_ptr
						STATEMENT 1 ON LINE 1369
	code = error_table_$undefined_order_request;

003467  aa  6 00044 3701 20	epp4 	pr6|36,*
003470  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$undefined_order_request
003471  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1371
	a_code = code;

003472  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1372
	return;

003473  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO hpriv_control                                      STATEMENT 1 ON LINE 1374
hpriv_control:
     entry (a_fnpp, a_order, a_data_ptr, a_code);

003474  ta     003423000000
003475  da     000604300000
003476  aa   000740 6270 00	eax7 	480
003477  aa  7 00034 3521 20	epp2 	pr7|28,*
003500  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
003501  aa     000010000000
003502  aa     000000000000
003503  aa  6 00032 3735 20	epp7 	pr6|26,*
003504  aa  7 00002 3715 20	epp5 	pr7|2,*
003505  aa  6 00264 6515 00	spri5	pr6|180
003506  aa  7 00004 3535 20	epp3 	pr7|4,*
003507  aa  6 00272 2535 00	spri3	pr6|186
003510  aa  6 00042 3515 20	epp1 	pr6|34,*
003511  aa  1 00002 3715 20	epp5 	pr1|2,*
003512  aa  6 00270 6515 00	spri5	pr6|184
003513  aa  7 00006 3535 20	epp3 	pr7|6,*
003514  aa  6 00274 2535 00	spri3	pr6|188
003515  aa  7 00010 3515 20	epp1 	pr7|8,*
003516  aa  6 00266 2515 00	spri1	pr6|182
						STATEMENT 1 ON LINE 1385
	fnpp = a_fnpp;

003517  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
003520  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
003521  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1387
	order = a_order;

003522  aa  6 00270 2361 20	ldq  	pr6|184,*
003523  aa   000002 6040 04	tmi  	2,ic		003525
003524  aa   777777 3760 07	anq  	262143,dl
003525  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
003526  aa  6 00272 3715 20	epp5 	pr6|186,*
003527  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
003530  aa  5 00000 00 0006	desc9a	pr5|0,ql		a_order
003531  aa  6 00116 00 0040	desc9a	pr6|78,32		order
						STATEMENT 1 ON LINE 1388
	data_ptr = a_data_ptr;

003532  aa  6 00274 3535 20	epp3 	pr6|188,*		a_data_ptr
003533  aa  3 00000 3535 20	epp3 	pr3|0,*		a_data_ptr
003534  aa  6 00126 2535 00	spri3	pr6|86		data_ptr
						STATEMENT 1 ON LINE 1389
	locked = "0"b;

003535  aa  6 00131 4501 00	stz  	pr6|89		locked
						STATEMENT 1 ON LINE 1390
	code = 0;

003536  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1393
	if order = "load"
	then call uncp_util$load ((fnp_info.fnp_number), data_ptr, code);

003537  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003540  aa  6 00116 00 0040	desc9a	pr6|78,32		order
003541  aa   774361 00 0004	desc9a	-1807,4		000120 = 154157141144
003542  aa   000021 6010 04	tnz  	17,ic		003563
003543  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
003544  aa   000011 7350 00	als  	9
003545  aa   000077 7730 00	lrl  	63
003546  aa  6 00440 7561 00	stq  	pr6|288
003547  aa  6 00440 3521 00	epp2 	pr6|288
003550  aa  6 00400 2521 00	spri2	pr6|256
003551  aa  6 00126 3521 00	epp2 	pr6|86		data_ptr
003552  aa  6 00402 2521 00	spri2	pr6|258
003553  aa  6 00100 3521 00	epp2 	pr6|64		code
003554  aa  6 00404 2521 00	spri2	pr6|260
003555  aa  6 00376 6211 00	eax1 	pr6|254
003556  aa   014000 4310 07	fld  	6144,dl
003557  aa  6 00044 3701 20	epp4 	pr6|36,*
003560  la  4 00052 3521 20	epp2 	pr4|42,*		uncp_util$load
003561  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
003562  aa   000115 7100 04	tra  	77,ic		003677
						STATEMENT 1 ON LINE 1396
	else if order = "dump"
	then call uncp_util$fdump (arg_dump.uncp_no, arg_dump.uncp_type, arg_dump.uncp_mem_size, arg_dump.seg_ptr, code);

003563  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003564  aa  6 00116 00 0040	desc9a	pr6|78,32		order
003565  aa   774334 00 0004	desc9a	-1828,4		000117 = 144165155160
003566  aa   000021 6010 04	tnz  	17,ic		003607
003567  aa  3 00002 3521 00	epp2 	pr3|2		arg_dump.uncp_no
003570  aa  6 00414 2521 00	spri2	pr6|268
003571  aa  3 00003 3521 00	epp2 	pr3|3		arg_dump.uncp_type
003572  aa  6 00416 2521 00	spri2	pr6|270
003573  aa  3 00004 3521 00	epp2 	pr3|4		arg_dump.uncp_mem_size
003574  aa  6 00420 2521 00	spri2	pr6|272
003575  aa  3 00000 3521 00	epp2 	pr3|0		arg_dump.seg_ptr
003576  aa  6 00422 2521 00	spri2	pr6|274
003577  aa  6 00100 3521 00	epp2 	pr6|64		code
003600  aa  6 00424 2521 00	spri2	pr6|276
003601  aa  6 00412 6211 00	eax1 	pr6|266
003602  aa   024000 4310 07	fld  	10240,dl
003603  aa  6 00044 3701 20	epp4 	pr6|36,*
003604  la  4 00054 3521 20	epp2 	pr4|44,*		uncp_util$fdump
003605  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
003606  aa   000071 7100 04	tra  	57,ic		003677
						STATEMENT 1 ON LINE 1399
	else if order = "abort"
	then call uncp_util$abort ((fnp_info.fnp_number), code);

003607  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003610  aa  6 00116 00 0040	desc9a	pr6|78,32		order
003611  aa   774363 00 0005	desc9a	-1805,5		000172 = 141142157162
003612  aa   000017 6010 04	tnz  	15,ic		003631
003613  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
003614  aa   000011 7350 00	als  	9
003615  aa   000077 7730 00	lrl  	63
003616  aa  6 00440 7561 00	stq  	pr6|288
003617  aa  6 00440 3521 00	epp2 	pr6|288
003620  aa  6 00400 2521 00	spri2	pr6|256
003621  aa  6 00100 3521 00	epp2 	pr6|64		code
003622  aa  6 00402 2521 00	spri2	pr6|258
003623  aa  6 00376 6211 00	eax1 	pr6|254
003624  aa   010000 4310 07	fld  	4096,dl
003625  aa  6 00044 3701 20	epp4 	pr6|36,*
003626  la  4 00050 3521 20	epp2 	pr4|40,*		uncp_util$abort
003627  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
003630  aa   000047 7100 04	tra  	39,ic		003677
						STATEMENT 1 ON LINE 1402
	else if order = "dial"
	then do;

003631  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003632  aa  6 00116 00 0040	desc9a	pr6|78,32		order
003633  aa   774265 00 0004	desc9a	-1867,4		000116 = 144151141154
003634  aa   000040 6010 04	tnz  	32,ic		003674
						STATEMENT 1 ON LINE 1404
	     call lock;

003635  aa   000654 6700 04	tsp4 	428,ic		004511
						STATEMENT 1 ON LINE 1405
	     if code ^= 0
	     then go to hpriv_exit;

003636  aa  6 00100 2361 00	ldq  	pr6|64		code
003637  aa   000040 6010 04	tnz  	32,ic		003677
						STATEMENT 1 ON LINE 1407
	     mbx_data = data_ptr -> based_bit72;

003640  aa  6 00126 3735 20	epp7 	pr6|86,*		data_ptr
003641  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003642  aa  7 00000 00 0110	descb	pr7|0,72		based_bit72
003643  aa  6 00140 00 0220	descb	pr6|96,144	mbx_data
						STATEMENT 1 ON LINE 1408
	     call uncp$send_global_wcd (fnpp, dial, CHAR_72, mbx_data);

003644  aa  6 00242 3521 00	epp2 	pr6|162		fnpp
003645  aa  6 00414 2521 00	spri2	pr6|268
003646  aa   774144 3520 04	epp2 	-1948,ic		000012 = 000000000014
003647  aa  6 00416 2521 00	spri2	pr6|270
003650  aa   774236 3520 04	epp2 	-1890,ic		000106 = 000000000110
003651  aa  6 00420 2521 00	spri2	pr6|272
003652  aa  6 00140 3521 00	epp2 	pr6|96		mbx_data
003653  aa  6 00422 2521 00	spri2	pr6|274
003654  aa   774271 3520 04	epp2 	-1863,ic		000145 = 464000000000
003655  aa  6 00424 2521 00	spri2	pr6|276
003656  aa   774251 3520 04	epp2 	-1879,ic		000127 = 404000000010
003657  aa  6 00426 2521 00	spri2	pr6|278
003660  aa   774267 3520 04	epp2 	-1865,ic		000147 = 404000000021
003661  aa  6 00430 2521 00	spri2	pr6|280
003662  aa   774243 3520 04	epp2 	-1885,ic		000125 = 516000000220
003663  aa  6 00432 2521 00	spri2	pr6|282
003664  aa  6 00412 6211 00	eax1 	pr6|266
003665  aa   020000 4310 07	fld  	8192,dl
003666  aa  6 00044 3701 20	epp4 	pr6|36,*
003667  la  4 00012 3521 20	epp2 	pr4|10,*		uncp$send_global_wcd
003670  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1409
	     call unlock;

003671  aa   000704 6700 04	tsp4 	452,ic		004575
						STATEMENT 1 ON LINE 1410
	     code = 0;

003672  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1411
	end;

003673  aa   000004 7100 04	tra  	4,ic		003677
						STATEMENT 1 ON LINE 1490
	else code = error_table_$undefined_order_request;

003674  aa  6 00044 3701 20	epp4 	pr6|36,*
003675  la  4 00060 2361 20	ldq  	pr4|48,*		error_table_$undefined_order_request
003676  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1492
hpriv_exit:
	a_code = code;

003677  aa  6 00100 2361 00	ldq  	pr6|64		code
003700  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1494
	return;

003701  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO fnp_lock                                           STATEMENT 1 ON LINE 1496
fnp_lock:
     entry (a_fnpp, a_code);

003702  ta     001317000000
003703  da     000612300000
003704  aa   000740 6270 00	eax7 	480
003705  aa  7 00034 3521 20	epp2 	pr7|28,*
003706  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003707  aa     000004000000
003710  aa     000000000000
003711  aa  6 00032 3735 20	epp7 	pr6|26,*
003712  aa  7 00002 3715 20	epp5 	pr7|2,*
003713  aa  6 00264 6515 00	spri5	pr6|180
003714  aa  7 00004 3535 20	epp3 	pr7|4,*
003715  aa  6 00266 2535 00	spri3	pr6|182
						STATEMENT 1 ON LINE 1499
	fnpp = a_fnpp;

003716  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
003717  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
003720  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1500
	call lock;

003721  aa   000570 6700 04	tsp4 	376,ic		004511
						STATEMENT 1 ON LINE 1501
	a_code = code;

003722  aa  6 00100 2361 00	ldq  	pr6|64		code
003723  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 1502
	return;

003724  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO fnp_unlock                                         STATEMENT 1 ON LINE 1504
fnp_unlock:
     entry (a_fnpp);

003725  at     000001000145
003726  ta     003725000000
003727  da     000620300000
003730  aa   000740 6270 00	eax7 	480
003731  aa  7 00034 3521 20	epp2 	pr7|28,*
003732  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003733  aa     000002000000
003734  aa     000000000000
003735  aa  6 00032 3735 20	epp7 	pr6|26,*
003736  aa  7 00002 3715 20	epp5 	pr7|2,*
003737  aa  6 00264 6515 00	spri5	pr6|180
						STATEMENT 1 ON LINE 1507
	fnpp = a_fnpp;

003740  aa  6 00264 3735 20	epp7 	pr6|180,*		a_fnpp
003741  aa  7 00000 3735 20	epp7 	pr7|0,*		a_fnpp
003742  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 1508
	mylock = "0"b;

003743  aa  6 00133 4501 00	stz  	pr6|91		mylock
						STATEMENT 1 ON LINE 1509
	locked = "1"b;

003744  aa   400000 2350 03	lda  	131072,du
003745  aa  6 00131 7551 00	sta  	pr6|89		locked
						STATEMENT 1 ON LINE 1510
	call unlock;

003746  aa   000627 6700 04	tsp4 	407,ic		004575
						STATEMENT 1 ON LINE 1511
	return;

003747  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO assign                                             STATEMENT 1 ON LINE 1993
assign:
     entry (a_fnp_no, a_code);

003750  at     000002000147
003751  ta     000142000000
003752  ta     003750000000
003753  da     000623300000
003754  aa   000740 6270 00	eax7 	480
003755  aa  7 00034 3521 20	epp2 	pr7|28,*
003756  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003757  aa     000004000000
003760  aa     000000000000
003761  aa  6 00032 3735 20	epp7 	pr6|26,*
003762  aa  7 00004 3715 20	epp5 	pr7|4,*
003763  aa  6 00266 6515 00	spri5	pr6|182
						STATEMENT 1 ON LINE 1996
	infop = addr (dn355_data$);

003764  aa  6 00044 3701 20	epp4 	pr6|36,*
003765  la  4 00112 3735 20	epp7 	pr4|74,*		dn355_data$
003766  aa  6 00240 6535 00	spri7	pr6|160		infop
						STATEMENT 1 ON LINE 1997
	call TRACE ("assign");

003767  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
003770  aa   774171 00 0006	desc9a	-1927,6		000160 = 141163163151
003771  aa  6 00376 00 0040	desc9a	pr6|254,32
003772  aa   001274 3520 04	epp2 	700,ic		005266 = 000002000000
003773  aa   001113 6700 04	tsp4 	587,ic		005106
						STATEMENT 1 ON LINE 1998
	fnp_no = a_fnp_no;

003774  aa  6 00032 3735 20	epp7 	pr6|26,*
003775  aa  7 00002 2361 20	ldq  	pr7|2,*		a_fnp_no
003776  aa  6 00262 7561 00	stq  	pr6|178		fnp_no
						STATEMENT 1 ON LINE 1999
	fnpp = addr (datanet_info.per_datanet (fnp_no));

003777  aa   000072 4020 07	mpy  	58,dl
004000  aa  6 00240 3715 20	epp5 	pr6|160,*		infop
004001  aa  5 77730 3715 06	epp5 	pr5|-40,ql	datanet_info.per_datanet
004002  aa  6 00242 6515 00	spri5	pr6|162		fnpp
						STATEMENT 1 ON LINE 2000
	call assign_channel (code);

004003  aa   001257 3520 04	epp2 	687,ic		005262 = 000002000000
004004  aa   000614 6700 04	tsp4 	396,ic		004620
						STATEMENT 1 ON LINE 2001
	a_code = code;

004005  aa  6 00100 2361 00	ldq  	pr6|64		code
004006  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 2002
	return;

004007  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO unassign                                           STATEMENT 1 ON LINE 2005
unassign:
     entry (a_fnp_no, a_code);

004010  ta     003750000000
004011  da     000626300000
004012  aa   000740 6270 00	eax7 	480
004013  aa  7 00034 3521 20	epp2 	pr7|28,*
004014  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004015  aa     000004000000
004016  aa     000000000000
004017  aa  6 00032 3735 20	epp7 	pr6|26,*
004020  aa  7 00004 3715 20	epp5 	pr7|4,*
004021  aa  6 00266 6515 00	spri5	pr6|182
						STATEMENT 1 ON LINE 2008
	fnp_no = a_fnp_no;

004022  aa  6 00032 3735 20	epp7 	pr6|26,*
004023  aa  7 00002 2361 20	ldq  	pr7|2,*		a_fnp_no
004024  aa  6 00262 7561 00	stq  	pr6|178		fnp_no
						STATEMENT 1 ON LINE 2009
	infop = addr (dn355_data$);

004025  aa  6 00044 3701 20	epp4 	pr6|36,*
004026  la  4 00112 3715 20	epp5 	pr4|74,*		dn355_data$
004027  aa  6 00240 6515 00	spri5	pr6|160		infop
						STATEMENT 1 ON LINE 2010
	call TRACE ("unassign");

004030  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004031  aa   774126 00 0010	desc9a	-1962,8		000156 = 165156141163
004032  aa  6 00376 00 0040	desc9a	pr6|254,32
004033  aa   001233 3520 04	epp2 	667,ic		005266 = 000002000000
004034  aa   001052 6700 04	tsp4 	554,ic		005106
						STATEMENT 1 ON LINE 2011
	fnpp = addr (datanet_info.per_datanet (fnp_no));

004035  aa  6 00262 2361 00	ldq  	pr6|178		fnp_no
004036  aa   000072 4020 07	mpy  	58,dl
004037  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
004040  aa  7 77730 3735 06	epp7 	pr7|-40,ql	datanet_info.per_datanet
004041  aa  6 00242 6535 00	spri7	pr6|162		fnpp
						STATEMENT 1 ON LINE 2013
	call unassign_channel (code);

004042  aa   001220 3520 04	epp2 	656,ic		005262 = 000002000000
004043  aa   000724 6700 04	tsp4 	468,ic		004767
						STATEMENT 1 ON LINE 2014
	a_code = code;

004044  aa  6 00100 2361 00	ldq  	pr6|64		code
004045  aa  6 00266 7561 20	stq  	pr6|182,*		a_code
						STATEMENT 1 ON LINE 2015
	return;

004046  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 2173
     end uncp_multiplexer;

BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 1513
setup:
     proc;

004047  aa  6 00306 6501 00	spri4	pr6|198
						STATEMENT 1 ON LINE 1519
	code = 0;

004050  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1520
	ttybp = addr (tty_buf$);

004051  aa  6 00044 3701 20	epp4 	pr6|36,*
004052  la  4 00110 3735 20	epp7 	pr4|72,*		tty_buf$
004053  aa  6 00226 6535 00	spri7	pr6|150		ttybp
						STATEMENT 1 ON LINE 1521
	infop = addr (dn355_data$);

004054  la  4 00112 3715 20	epp5 	pr4|74,*		dn355_data$
004055  aa  6 00240 6515 00	spri5	pr6|160		infop
						STATEMENT 1 ON LINE 1522
	locked, queue_locked = "0"b;

004056  aa  6 00131 4501 00	stz  	pr6|89		locked
004057  aa  6 00132 4501 00	stz  	pr6|90		queue_locked
						STATEMENT 1 ON LINE 1523
	call lock;

004060  aa   000431 6700 04	tsp4 	281,ic		004511
						STATEMENT 1 ON LINE 1524
	if code ^= 0
	then return;

004061  aa  6 00100 2361 00	ldq  	pr6|64		code
004062  aa   000002 6000 04	tze  	2,ic		004064
004063  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1527
	if fnp_info.running
	then pcbp = addr (fnp_info.pcb_array_ptr -> pcb_array (chanx));

004064  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
004065  aa  7 00030 2351 00	lda  	pr7|24		fnp_info.running
004066  aa   100000 3150 03	cana 	32768,du
004067  aa   000007 6000 04	tze  	7,ic		004076
004070  aa  6 00110 2361 00	ldq  	pr6|72		chanx
004071  aa   000003 7360 00	qls  	3
004072  aa  7 00002 3715 20	epp5 	pr7|2,*		fnp_info.pcb_array_ptr
004073  aa  5 77770 3535 06	epp3 	pr5|-8,ql		pcb_array
004074  aa  6 00246 2535 00	spri3	pr6|166		pcbp
004075  aa   000006 7100 04	tra  	6,ic		004103
						STATEMENT 1 ON LINE 1529
	else do;

						STATEMENT 1 ON LINE 1530
	     call unlock;

004076  aa   000477 6700 04	tsp4 	319,ic		004575
						STATEMENT 1 ON LINE 1531
	     code = error_table_$fnp_down;

004077  aa  6 00044 3701 20	epp4 	pr6|36,*
004100  la  4 00066 2361 20	ldq  	pr4|54,*		error_table_$fnp_down
004101  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1532
	     return;

004102  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1533
	end;

						STATEMENT 1 ON LINE 1535
	if pcb.copied_meters_ready			/* dn355 left them for us */
	then if ^lcte.locked_for_interrupt		/* make sure we're on call side */
	     then call save_copied_meters;

004103  aa  3 00004 2351 00	lda  	pr3|4		pcb.copied_meters_ready
004104  aa   000400 3150 03	cana 	256,du
004105  aa   000006 6000 04	tze  	6,ic		004113
004106  aa  6 00234 3735 20	epp7 	pr6|156,*		lctep
004107  aa  7 00002 2351 00	lda  	pr7|2		lcte.locked_for_interrupt
004110  aa   000040 3150 03	cana 	32,du
004111  aa   000002 6010 04	tnz  	2,ic		004113
004112  aa   000002 6700 04	tsp4 	2,ic		004114
						STATEMENT 1 ON LINE 1539
	return;

004113  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1540
     end setup;

  END PROCEDURE setup
BEGIN PROCEDURE save_copied_meters
ENTRY TO save_copied_meters                                 STATEMENT 1 ON LINE 1619
save_copied_meters:
     proc;

004114  aa  6 00314 6501 00	spri4	pr6|204
						STATEMENT 1 ON LINE 1626
	if pcb.copied_meters_offset ^= 0		/* make sure it's legit */
	then do;

004115  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
004116  aa  7 00007 2361 00	ldq  	pr7|7		pcb.copied_meters_offset
004117  aa   000056 6000 04	tze  	46,ic		004175
						STATEMENT 1 ON LINE 1628
	     copied_meters_ptr = ptr (ttybp, pcb.copied_meters_offset);

004120  aa  6 00226 3521 20	epp2 	pr6|150,*		ttybp
004121  aa   000000 3120 06	eawp2	0,ql
004122  aa  6 00322 2521 00	spri2	pr6|210		copied_meters_ptr
						STATEMENT 1 ON LINE 1632
	     if pcb.sync_line
	     then copied_meters_ptr -> fnp_sync_meters.pad (*) = 0;

004123  aa  7 00004 2351 00	lda  	pr7|4		pcb.sync_line
004124  aa   020000 3150 03	cana 	8192,du
004125  aa   000013 6000 04	tze  	11,ic		004140
004126  aa   000001 2360 07	ldq  	1,dl
004127  aa  6 00324 7561 00	stq  	pr6|212
004130  aa  6 00324 7271 00	lxl7 	pr6|212
004131  aa  6 00322 3735 20	epp7 	pr6|210,*		copied_meters_ptr
004132  aa  7 00026 4501 17	stz  	pr7|22,7		fnp_sync_meters.pad
004133  aa  6 00324 2361 00	ldq  	pr6|212
004134  aa  6 00324 0541 00	aos  	pr6|212
004135  aa   000003 1160 07	cmpq 	3,dl
004136  aa   777772 6040 04	tmi  	-6,ic		004130
004137  aa   000012 7100 04	tra  	10,ic		004151
						STATEMENT 1 ON LINE 1634
	     else copied_meters_ptr -> fnp_async_meters.pad (*) = 0;

004140  aa   000001 2360 07	ldq  	1,dl
004141  aa  6 00324 7561 00	stq  	pr6|212
004142  aa  6 00324 7271 00	lxl7 	pr6|212
004143  aa  6 00322 3735 20	epp7 	pr6|210,*		copied_meters_ptr
004144  aa  7 00013 4501 17	stz  	pr7|11,7		fnp_async_meters.pad
004145  aa  6 00324 2361 00	ldq  	pr6|212
004146  aa  6 00324 0541 00	aos  	pr6|212
004147  aa   000016 1160 07	cmpq 	14,dl
004150  aa   777772 6040 04	tmi  	-6,ic		004142
						STATEMENT 1 ON LINE 1635
	     pcb.saved_meters_ptr -> fnp_channel_meters = copied_meters_ptr -> fnp_channel_meters;

004151  aa  6 00246 3715 20	epp5 	pr6|166,*		pcbp
004152  aa  5 00006 7651 00	lprp5	pr5|6		pcb.saved_meters_ptr
004153  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004154  aa  7 00000 00 0150	desc9a	pr7|0,104		fnp_channel_meters
004155  aa  5 00000 00 0150	desc9a	pr5|0,104		fnp_channel_meters
						STATEMENT 1 ON LINE 1636
	     call tty_space_man$free_space (size (fnp_channel_meters), copied_meters_ptr);

004156  aa   000032 2360 07	ldq  	26,dl
004157  aa  6 00442 7561 00	stq  	pr6|290
004160  aa  6 00442 3521 00	epp2 	pr6|290
004161  aa  6 00446 2521 00	spri2	pr6|294
004162  aa  6 00322 3521 00	epp2 	pr6|210		copied_meters_ptr
004163  aa  6 00450 2521 00	spri2	pr6|296
004164  aa  6 00444 6211 00	eax1 	pr6|292
004165  aa   010000 4310 07	fld  	4096,dl
004166  aa  6 00044 3701 20	epp4 	pr6|36,*
004167  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_space
004170  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1638
	     pcb.copied_meters_offset = 0;

004171  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
004172  aa  7 00007 4501 00	stz  	pr7|7		pcb.copied_meters_offset
						STATEMENT 1 ON LINE 1639
	     pcb.copied_meters_ready = "0"b;

004173  aa   001035 2350 04	lda  	541,ic		005230 = 777377777777
004174  aa  7 00004 3551 00	ansa 	pr7|4		pcb.copied_meters_ready
						STATEMENT 1 ON LINE 1640
	end;

						STATEMENT 1 ON LINE 1642
	return;

004175  aa  6 00314 6101 00	rtcd 	pr6|204
						STATEMENT 1 ON LINE 1643
     end save_copied_meters;

  END PROCEDURE save_copied_meters
BEGIN PROCEDURE process_mode
ENTRY TO process_mode                                       STATEMENT 1 ON LINE 1645
process_mode:
     proc (mode_name, mode_on);

004176  aa  6 00326 6501 00	spri4	pr6|214
004177  aa  6 00330 2521 00	spri2	pr6|216
004200  aa  2 00002 3521 01	epp2 	pr2|2,au
004201  aa  6 00332 2521 00	spri2	pr6|218
004202  aa  2 00000 2361 20	ldq  	pr2|0,*
004203  aa   000002 6040 04	tmi  	2,ic		004205
004204  aa   777777 3760 07	anq  	262143,dl
004205  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
004206  aa  6 00452 7561 00	stq  	pr6|298
						STATEMENT 1 ON LINE 1652
	alter_data = "00000000"b || mode_on;

004207  aa  6 00330 3735 20	epp7 	pr6|216,*
004210  aa  7 00004 3715 20	epp5 	pr7|4,*
004211  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004212  aa  5 00000 00 0001	descb	pr5|0,1		mode_on
004213  aa  6 00453 00 0044	descb	pr6|299,36	mode_on
004214  aa  6 00453 2351 00	lda  	pr6|299		mode_on
004215  aa   000010 7710 00	arl  	8
004216  aa  6 00151 7551 00	sta  	pr6|105		alter_data
004217  aa   000011 2360 07	ldq  	9,dl
004220  aa  6 00150 7561 00	stq  	pr6|104		alter_data
						STATEMENT 1 ON LINE 1654
	if mode_name = "hndlquit"
	then do;

004221  aa  7 00002 3535 20	epp3 	pr7|2,*
004222  aa  6 00452 2351 00	lda  	pr6|298
004223  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004224  aa  3 00000 00 0005	desc9a	pr3|0,al		mode_name
004225  aa   773737 00 0010	desc9a	-2081,8		000162 = 150156144154
004226  aa   000014 6010 04	tnz  	12,ic		004242
						STATEMENT 1 ON LINE 1656
	     alter_type = Hndlquit;

004227  aa   000021 2360 07	ldq  	17,dl
004230  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 1657
	     pcb.hndlquit = mode_on;

004231  aa  6 00453 2351 00	lda  	pr6|299		mode_on
004232  aa   000006 7710 00	arl  	6
004233  aa  6 00246 3515 20	epp1 	pr6|166,*		pcbp
004234  aa  1 00004 6751 00	era  	pr1|4		pcb.hndlquit
004235  aa   004000 3750 03	ana  	2048,du
004236  aa  1 00004 6551 00	ersa 	pr1|4		pcb.hndlquit
						STATEMENT 1 ON LINE 1658
	     hndlquit_set = "1"b;

004237  aa   400000 2350 03	lda  	131072,du
004240  aa  6 00172 7551 00	sta  	pr6|122		hndlquit_set
						STATEMENT 1 ON LINE 1659
	end;

004241  aa   000176 7100 04	tra  	126,ic		004437
						STATEMENT 1 ON LINE 1661
	else if mode_name = "breakall"
	then do;

004242  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004243  aa  3 00000 00 0005	desc9a	pr3|0,al		mode_name
004244  aa   773712 00 0010	desc9a	-2102,8		000154 = 142162145141
004245  aa   000013 6010 04	tnz  	11,ic		004260
						STATEMENT 1 ON LINE 1663
	     alter_type = Breakall;

004246  aa   000033 2360 07	ldq  	27,dl
004247  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 1664
	     pcb.extra_nl = ^mode_on;

004250  aa  6 00453 2351 00	lda  	pr6|299		mode_on
004251  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
004252  aa   000016 7710 00	arl  	14
004253  aa  6 00246 3515 20	epp1 	pr6|166,*		pcbp
004254  aa  1 00004 6751 00	era  	pr1|4		pcb.extra_nl
004255  aa   000010 3750 03	ana  	8,du
004256  aa  1 00004 6551 00	ersa 	pr1|4		pcb.extra_nl
						STATEMENT 1 ON LINE 1665
	end;

004257  aa   000160 7100 04	tra  	112,ic		004437
						STATEMENT 1 ON LINE 1667
	else if ^pcb.sync_line			/* if we haven't already decided what to do */
	then do;

004260  aa  6 00246 3515 20	epp1 	pr6|166,*		pcbp
004261  aa  1 00004 2351 00	lda  	pr1|4		pcb.sync_line
004262  aa   020000 3150 03	cana 	8192,du
004263  aa   000154 6010 04	tnz  	108,ic		004437
						STATEMENT 1 ON LINE 1669
	     if mode_name = "blk_xfer" | mode_name = "iflow"
						/* special stuff here */
	     then do;

004264  aa  6 00452 2361 00	ldq  	pr6|298
004265  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004266  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
004267  aa   773665 00 0010	desc9a	-2123,8		000152 = 142154153137
004270  aa   000005 6000 04	tze  	5,ic		004275
004271  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004272  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
004273  aa   773657 00 0005	desc9a	-2129,5		000150 = 151146154157
004274  aa   000106 6010 04	tnz  	70,ic		004402
						STATEMENT 1 ON LINE 1672
		if mode_name = "blk_xfer"
		then do;

004275  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
004276  aa  3 00000 00 0006	desc9a	pr3|0,ql		mode_name
004277  aa   773655 00 0010	desc9a	-2131,8		000152 = 142154153137
004300  aa   000006 6010 04	tnz  	6,ic		004306
						STATEMENT 1 ON LINE 1674
		     mode_name_index = BLK_XFER_INDEX;

004301  aa   000017 2360 07	ldq  	15,dl
004302  aa  6 00334 7561 00	stq  	pr6|220		mode_name_index
						STATEMENT 1 ON LINE 1675
		     alter_type = Block_xfer;

004303  aa   000031 2360 07	ldq  	25,dl
004304  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 1676
		end;

004305  aa   000005 7100 04	tra  	5,ic		004312
						STATEMENT 1 ON LINE 1677
		else do;

						STATEMENT 1 ON LINE 1678
		     mode_name_index = IFLOW_INDEX;

004306  aa   000016 2360 07	ldq  	14,dl
004307  aa  6 00334 7561 00	stq  	pr6|220		mode_name_index
						STATEMENT 1 ON LINE 1679
		     alter_type = Input_flow_control;

004310  aa   000035 2360 07	ldq  	29,dl
004311  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 1680
		end;

						STATEMENT 1 ON LINE 1682
		if mode_on
		then do;

004312  aa  6 00453 2351 00	lda  	pr6|299		mode_on
004313  aa   000011 6000 04	tze  	9,ic		004324
						STATEMENT 1 ON LINE 1684
		     chars_per_sec = divide (pcb.baud_rate, 10, 17, 0);

004314  aa  1 00002 2351 00	lda  	pr1|2		pcb.baud_rate
004315  aa   000066 7330 00	lrs  	54
004316  aa   000012 5060 07	div  	10,dl
004317  aa  6 00175 7561 00	stq  	pr6|125		chars_per_sec
						STATEMENT 1 ON LINE 1685
		     base_len, block_len = divide (chars_per_sec, buf_per_second, 17, 0);

004320  aa   000012 5060 07	div  	10,dl
004321  aa  6 00173 7561 00	stq  	pr6|123		base_len
004322  aa  6 00174 7561 00	stq  	pr6|124		block_len
						STATEMENT 1 ON LINE 1687
		end;

004323  aa   000004 7100 04	tra  	4,ic		004327
						STATEMENT 1 ON LINE 1688
		else do;

						STATEMENT 1 ON LINE 1689
		     base_len = BASE_LTH;

004324  aa   000070 2360 07	ldq  	56,dl
004325  aa  6 00173 7561 00	stq  	pr6|123		base_len
						STATEMENT 1 ON LINE 1690
		     block_len = 0;

004326  aa  6 00174 4501 00	stz  	pr6|124		block_len
						STATEMENT 1 ON LINE 1691
		end;

						STATEMENT 1 ON LINE 1693
		alter_data = alter_data || bit (bin (base_len, 18), 18) || bit (bin (block_len, 18), 18);

004327  aa  6 00174 2351 00	lda  	pr6|124		block_len
004330  aa   000002 6050 04	tpl  	2,ic		004332
004331  aa   000000 5310 00	neg  	0
004332  aa   000022 7350 00	als  	18
004333  aa  6 00453 7551 00	sta  	pr6|299
004334  aa  6 00173 2351 00	lda  	pr6|123		base_len
004335  aa   000002 6050 04	tpl  	2,ic		004337
004336  aa   000000 5310 00	neg  	0
004337  aa   000022 7350 00	als  	18
004340  aa  6 00454 7551 00	sta  	pr6|300
004341  aa  6 00150 2361 00	ldq  	pr6|104		alter_data
004342  aa   000022 0760 07	adq  	18,dl
004343  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
004344  aa  6 00150 7271 00	lxl7 	pr6|104		alter_data
004345  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
004346  aa  6 00151 00 0017	descb	pr6|105,x7	alter_data
004347  aa  2 00000 00 0017	descb	pr2|0,x7
004350  aa  6 00150 7271 00	lxl7 	pr6|104		alter_data
004351  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
004352  aa  6 00454 00 0022	descb	pr6|300,18
004353  aa  2 00000 00 0022	descb	pr2|0,18
004354  aa  6 00454 7561 00	stq  	pr6|300
004355  aa   000022 0760 07	adq  	18,dl
004356  aa  6 00455 7561 00	stq  	pr6|301
004357  aa  0 00607 7001 00	tsx0 	pr0|391		cat_realloc_bits
004360  aa  6 00454 2351 00	lda  	pr6|300
004361  aa  003 105 060 500	csl  	(pr),(pr,al),fill(0),bool(move)
004362  aa  6 00453 00 0022	descb	pr6|299,18
004363  aa  2 00000 00 0022	descb	pr2|0,18
004364  aa  6 00455 2361 00	ldq  	pr6|301
004365  aa   000220 1160 07	cmpq 	144,dl
004366  aa   000002 6040 04	tmi  	2,ic		004370
004367  aa   000220 2360 07	ldq  	144,dl
004370  aa  6 00150 7561 00	stq  	pr6|104		alter_data
004371  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
004372  aa  2 00000 00 0006	descb	pr2|0,ql
004373  aa  6 00151 00 0006	descb	pr6|105,ql	alter_data
						STATEMENT 1 ON LINE 1694
		mode_set (mode_name_index) = "1"b;

004374  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004375  aa  6 00334 7271 00	lxl7 	pr6|220		mode_name_index
004376  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
004377  aa   000000 00 0000	descb	0,0
004400  aa  6 00170 70 0001	descb	pr6|120(35),1	mode_set
						STATEMENT 1 ON LINE 1695
	     end;

004401  aa   000036 7100 04	tra  	30,ic		004437
						STATEMENT 1 ON LINE 1697
	     else do;

						STATEMENT 1 ON LINE 1698
		do i = 1 to hbound (mode_alter_types, 1) while (mode_name ^= async_only_modes (i));

004402  aa   000001 2360 07	ldq  	1,dl
004403  aa  6 00112 7561 00	stq  	pr6|74		i
004404  aa  6 00112 2361 00	ldq  	pr6|74		i
004405  aa   000015 1160 07	cmpq 	13,dl
004406  aa   000014 6054 04	tpnz 	12,ic		004422
004407  aa   000001 7360 00	qls  	1
004410  aa  6 00330 3735 20	epp7 	pr6|216,*
004411  aa  7 00002 3715 20	epp5 	pr7|2,*
004412  ta   000044 3534 06	epp3 	36,ql
004413  aa  6 00452 2351 00	lda  	pr6|298
004414  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
004415  aa  5 00000 00 0005	desc9a	pr5|0,al		mode_name
004416  aa  3 00000 00 0010	desc9a	pr3|0,8		async_only_modes
004417  aa   000003 6000 04	tze  	3,ic		004422
						STATEMENT 1 ON LINE 1699
		end;

004420  aa  6 00112 0541 00	aos  	pr6|74		i
004421  aa   777763 7100 04	tra  	-13,ic		004404
						STATEMENT 1 ON LINE 1701
		if i > hbound (mode_alter_types, 1)
		then code = error_table_$bad_mode;

004422  aa  6 00112 2361 00	ldq  	pr6|74		i
004423  aa   000015 1160 07	cmpq 	13,dl
004424  aa   000005 6044 04	tmoz 	5,ic		004431
004425  aa  6 00044 3701 20	epp4 	pr6|36,*
004426  la  4 00062 2361 20	ldq  	pr4|50,*		error_table_$bad_mode
004427  aa  6 00100 7561 00	stq  	pr6|64		code
004430  aa   000007 7100 04	tra  	7,ic		004437
						STATEMENT 1 ON LINE 1704
		else do;

						STATEMENT 1 ON LINE 1705
		     alter_type = mode_alter_types (i);

004431  ta   000012 2360 06	ldq  	10,ql
004432  aa  6 00135 7561 00	stq  	pr6|93		alter_type
						STATEMENT 1 ON LINE 1706
		     mode_set (i) = "1"b;

004433  aa  6 00112 7271 00	lxl7 	pr6|74		i
004434  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
004435  aa   000000 00 0000	descb	0,0
004436  aa  6 00170 70 0001	descb	pr6|120(35),1	mode_set
						STATEMENT 1 ON LINE 1707
		end;

						STATEMENT 1 ON LINE 1708
	     end;

						STATEMENT 1 ON LINE 1709
	end;

						STATEMENT 1 ON LINE 1711
	if code = 0
	then do;

004437  aa  6 00100 2361 00	ldq  	pr6|64		code
004440  aa   000050 6010 04	tnz  	40,ic		004510
						STATEMENT 1 ON LINE 1713
	     mbx_data = bit (bin (alter_type, 9), 9) || alter_data;

004441  aa  6 00135 2351 00	lda  	pr6|93		alter_type
004442  aa   000002 6050 04	tpl  	2,ic		004444
004443  aa   000000 5310 00	neg  	0
004444  aa   000033 7350 00	als  	27
004445  aa  6 00455 7551 00	sta  	pr6|301
004446  aa   000011 2360 07	ldq  	9,dl
004447  aa  6 00150 0761 00	adq  	pr6|104		alter_data
004450  aa  0 00552 7001 00	tsx0 	pr0|362		alloc_bit_temp
004451  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004452  aa  6 00455 00 0011	descb	pr6|301,9
004453  aa  2 00000 00 0011	descb	pr2|0,9
004454  aa  6 00150 7271 00	lxl7 	pr6|104		alter_data
004455  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
004456  aa  6 00151 00 0017	descb	pr6|105,x7	alter_data
004457  aa  2 00000 20 0017	descb	pr2|0(9),x7
004460  aa  003 100 060 540	csl  	(pr,rl),(pr),fill(0),bool(move)
004461  aa  2 00000 00 0006	descb	pr2|0,ql
004462  aa  6 00140 00 0220	descb	pr6|96,144	mbx_data
						STATEMENT 1 ON LINE 1717
	     if alter_type = Lfecho
	     then pcb.lfecho = mode_on;

004463  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
004464  aa  6 00135 2361 00	ldq  	pr6|93		alter_type
004465  aa   000011 1160 07	cmpq 	9,dl
004466  aa   000007 6010 04	tnz  	7,ic		004475
004467  aa  6 00246 3735 20	epp7 	pr6|166,*		pcbp
004470  aa  6 00330 3715 20	epp5 	pr6|216,*
004471  aa  5 00004 3535 20	epp3 	pr5|4,*
004472  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004473  aa  3 00000 00 0001	descb	pr3|0,1		mode_on
004474  aa  7 00004 27 0001	descb	pr7|4(16),1	pcb.lfecho
						STATEMENT 1 ON LINE 1720
	     if alter_type = Fullduplex & mode_on = "0"b
	     then code = error_table_$action_not_performed;

004475  aa   000003 1160 07	cmpq 	3,dl
004476  aa   000012 6010 04	tnz  	10,ic		004510
004477  aa  6 00330 3735 20	epp7 	pr6|216,*
004500  aa  7 00004 3715 20	epp5 	pr7|4,*
004501  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
004502  aa  5 00000 00 0001	descb	pr5|0,1		mode_on
004503  aa   000000 00 0000	descb	0,0
004504  aa   000004 6010 04	tnz  	4,ic		004510
004505  aa  6 00044 3701 20	epp4 	pr6|36,*
004506  la  4 00072 2361 20	ldq  	pr4|58,*		error_table_$action_not_performed
004507  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1726
	end;

						STATEMENT 1 ON LINE 1727
	return;

004510  aa  6 00326 6101 00	rtcd 	pr6|214
						STATEMENT 1 ON LINE 1728
     end;

  END PROCEDURE process_mode
BEGIN PROCEDURE lock
ENTRY TO lock                                               STATEMENT 1 ON LINE 1911
lock:
     proc;

004511  aa  6 00336 6501 00	spri4	pr6|222
						STATEMENT 1 ON LINE 1916
	if fnpp = null ()
	then do;

004512  aa  6 00242 2371 00	ldaq 	pr6|162		fnpp
004513  aa   773467 6770 04	eraq 	-2249,ic		000202 = 077777000043 000001000000
004514  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004515  aa   000005 6010 04	tnz  	5,ic		004522
						STATEMENT 1 ON LINE 1918
	     code = error_table_$fnp_down;

004516  aa  6 00044 3701 20	epp4 	pr6|36,*
004517  la  4 00066 2361 20	ldq  	pr4|54,*		error_table_$fnp_down
004520  aa  6 00100 7561 00	stq  	pr6|64		code
						STATEMENT 1 ON LINE 1919
	     return;

004521  aa  6 00336 6101 00	rtcd 	pr6|222
						STATEMENT 1 ON LINE 1920
	end;

						STATEMENT 1 ON LINE 1922
	code = 0;

004522  aa  6 00100 4501 00	stz  	pr6|64		code
						STATEMENT 1 ON LINE 1924
	lctep = fnp_info.lcte_ptr;

004523  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
004524  aa  7 00032 3735 20	epp7 	pr7|26,*		fnp_info.lcte_ptr
004525  aa  6 00234 6535 00	spri7	pr6|156		lctep
						STATEMENT 1 ON LINE 1926
	if lcte.lock = pds$processid			/* called as result of our own interrupt? */
	then if lcte.locked_for_interrupt
	     then mylock = "1"b;

004526  aa  7 00000 2351 00	lda  	pr7|0		lcte.lock
004527  aa  6 00044 3701 20	epp4 	pr6|36,*
004530  la  4 00106 1151 20	cmpa 	pr4|70,*		pds$processid
004531  aa   000027 6010 04	tnz  	23,ic		004560
004532  aa  7 00002 2351 00	lda  	pr7|2		lcte.locked_for_interrupt
004533  aa   000040 3150 03	cana 	32,du
004534  aa   000004 6000 04	tze  	4,ic		004540
004535  aa   400000 2350 03	lda  	131072,du
004536  aa  6 00133 7551 00	sta  	pr6|91		mylock
004537  aa   000035 7100 04	tra  	29,ic		004574
						STATEMENT 1 ON LINE 1929
	     else call syserr (CRASH_SYSTEM, "uncp_multiplexer: mylock error");

004540  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004541  aa   773504 00 0040	desc9a	-2236,32		000244 = 165156143160
004542  aa  6 00456 00 0040	desc9a	pr6|302,32
004543  aa   773403 3520 04	epp2 	-2301,ic		000146 = 000000000001
004544  aa  6 00470 2521 00	spri2	pr6|312
004545  aa  6 00456 3521 00	epp2 	pr6|302
004546  aa  6 00472 2521 00	spri2	pr6|314
004547  aa   773400 3520 04	epp2 	-2304,ic		000147 = 404000000021
004550  aa  6 00474 2521 00	spri2	pr6|316
004551  aa   773343 3520 04	epp2 	-2333,ic		000114 = 524000000036
004552  aa  6 00476 2521 00	spri2	pr6|318
004553  aa  6 00466 6211 00	eax1 	pr6|310
004554  aa   010000 4310 07	fld  	4096,dl
004555  la  4 00040 3521 20	epp2 	pr4|32,*		syserr
004556  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
004557  aa   000015 7100 04	tra  	13,ic		004574
						STATEMENT 1 ON LINE 1930
	else do;

						STATEMENT 1 ON LINE 1931
	     mylock = "0"b;

004560  aa  6 00133 4501 00	stz  	pr6|91		mylock
						STATEMENT 1 ON LINE 1932
	     call tty_lock$lock_lcte (lctep, code);

004561  aa  6 00234 3521 00	epp2 	pr6|156		lctep
004562  aa  6 00460 2521 00	spri2	pr6|304
004563  aa  6 00100 3521 00	epp2 	pr6|64		code
004564  aa  6 00462 2521 00	spri2	pr6|306
004565  aa  6 00456 6211 00	eax1 	pr6|302
004566  aa   010000 4310 07	fld  	4096,dl
004567  la  4 00026 3521 20	epp2 	pr4|22,*		tty_lock$lock_lcte
004570  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1933
	     locked = (code = 0);

004571  aa  6 00100 2361 00	ldq  	pr6|64		code
004572  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004573  aa  6 00131 7551 00	sta  	pr6|89		locked
						STATEMENT 1 ON LINE 1934
	end;

						STATEMENT 1 ON LINE 1937
	return;

004574  aa  6 00336 6101 00	rtcd 	pr6|222
						STATEMENT 1 ON LINE 1938
     end lock;

  END PROCEDURE lock
BEGIN PROCEDURE unlock
ENTRY TO unlock                                             STATEMENT 1 ON LINE 1942
unlock:
     proc;

004575  aa  6 00344 6501 00	spri4	pr6|228
						STATEMENT 1 ON LINE 1947
	if locked
	then if ^mylock
	     then do;

004576  aa  6 00131 2351 00	lda  	pr6|89		locked
004577  aa   000020 6000 04	tze  	16,ic		004617
004600  aa  6 00133 2351 00	lda  	pr6|91		mylock
004601  aa   000016 6010 04	tnz  	14,ic		004617
						STATEMENT 1 ON LINE 1951
		call uncp$process_interrupt_queue ((fnp_info.fnp_number));

004602  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
004603  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
004604  aa   000011 7350 00	als  	9
004605  aa   000077 7730 00	lrl  	63
004606  aa  6 00500 7561 00	stq  	pr6|320
004607  aa  6 00500 3521 00	epp2 	pr6|320
004610  aa  6 00504 2521 00	spri2	pr6|324
004611  aa  6 00502 6211 00	eax1 	pr6|322
004612  aa   004000 4310 07	fld  	2048,dl
004613  aa  6 00044 3701 20	epp4 	pr6|36,*
004614  la  4 00016 3521 20	epp2 	pr4|14,*		uncp$process_interrupt_queue
004615  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1952
		locked = "0"b;

004616  aa  6 00131 4501 00	stz  	pr6|89		locked
						STATEMENT 1 ON LINE 1954
	     end;

						STATEMENT 1 ON LINE 1955
	return;

004617  aa  6 00344 6101 00	rtcd 	pr6|228
						STATEMENT 1 ON LINE 1957
     end unlock;

  END PROCEDURE unlock
BEGIN PROCEDURE assign_channel
ENTRY TO assign_channel                                     STATEMENT 1 ON LINE 2018
assign_channel:
     procedure (code);

004620  aa  6 00352 6501 00	spri4	pr6|234
004621  aa  6 00354 2521 00	spri2	pr6|236
						STATEMENT 1 ON LINE 2022
	code = 0;

004622  aa  2 00002 4501 20	stz  	pr2|2,*		code
						STATEMENT 1 ON LINE 2023
	if ^fnp_info.available
	then do;

004623  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
004624  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.available
004625  aa   400000 3150 03	cana 	131072,du
004626  aa   000005 6010 04	tnz  	5,ic		004633
						STATEMENT 1 ON LINE 2025
	     code = error_table_$io_not_configured;

004627  aa  6 00044 3701 20	epp4 	pr6|36,*
004630  la  4 00100 2361 20	ldq  	pr4|64,*		error_table_$io_not_configured
004631  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 2026
	     go to assign_channel_return;

004632  aa   000054 7100 04	tra  	44,ic		004706
						STATEMENT 1 ON LINE 2027
	end;

						STATEMENT 1 ON LINE 2029
	if fnp_info.io_manager_assigned
	then do;

004633  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
004634  aa   200000 3150 03	cana 	65536,du
004635  aa   000005 6000 04	tze  	5,ic		004642
						STATEMENT 1 ON LINE 2031
	     code = error_table_$io_assigned;

004636  aa  6 00044 3701 20	epp4 	pr6|36,*
004637  la  4 00074 2361 20	ldq  	pr4|60,*		error_table_$io_assigned
004640  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 2032
	     go to assign_channel_return;

004641  aa   000045 7100 04	tra  	37,ic		004706
						STATEMENT 1 ON LINE 2033
	end;

						STATEMENT 1 ON LINE 2035
	call io_manager$assign (fnp_info.io_manager_chx, fnp_info.io_chanid, uncp$interrupt, (fnp_info.fnp_number),
	     (null ()), code);

004642  aa  6 00044 3701 20	epp4 	pr6|36,*
004643  la  4 00020 3521 20	epp2 	pr4|16,*		uncp$interrupt
004644  aa  6 00506 2521 00	spri2	pr6|326		cp.876
004645  aa   000361 2370 04	ldaq 	241,ic		005226 = 077777000043 000001000000
004646  aa  6 00510 7571 00	staq 	pr6|328		cp.876
004647  aa  7 00007 2351 00	lda  	pr7|7		fnp_info.fnp_number
004650  aa   000011 7350 00	als  	9
004651  aa   000077 7730 00	lrl  	63
004652  aa  6 00512 7561 00	stq  	pr6|330
004653  aa   773327 3714 24	epp5 	-2345,ic*
004654  aa  6 00514 6515 00	spri5	pr6|332
004655  aa  7 00012 3521 00	epp2 	pr7|10		fnp_info.io_manager_chx
004656  aa  6 00520 2521 00	spri2	pr6|336
004657  aa  7 00010 3521 00	epp2 	pr7|8		fnp_info.io_chanid
004660  aa  6 00522 2521 00	spri2	pr6|338
004661  aa  6 00506 3521 00	epp2 	pr6|326		cp.876
004662  aa  6 00524 2521 00	spri2	pr6|340
004663  aa  6 00512 3521 00	epp2 	pr6|330
004664  aa  6 00526 2521 00	spri2	pr6|342
004665  aa  6 00514 3521 00	epp2 	pr6|332
004666  aa  6 00530 2521 00	spri2	pr6|344
004667  aa  6 00354 3535 20	epp3 	pr6|236,*
004670  aa  3 00002 3521 20	epp2 	pr3|2,*		code
004671  aa  6 00532 2521 00	spri2	pr6|346
004672  aa  6 00516 6211 00	eax1 	pr6|334
004673  aa   030000 4310 07	fld  	12288,dl
004674  la  4 00124 3521 20	epp2 	pr4|84,*		io_manager$assign
004675  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2037
	fnp_info.io_manager_assigned = (code = 0);

004676  aa  6 00354 3735 20	epp7 	pr6|236,*
004677  aa  7 00002 2361 20	ldq  	pr7|2,*		code
004700  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004701  aa   000001 7710 00	arl  	1
004702  aa  6 00242 3715 20	epp5 	pr6|162,*		fnpp
004703  aa  5 00066 6751 00	era  	pr5|54		fnp_info.io_manager_assigned
004704  aa   200000 3750 03	ana  	65536,du
004705  aa  5 00066 6551 00	ersa 	pr5|54		fnp_info.io_manager_assigned
						STATEMENT 1 ON LINE 2038
assign_channel_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr (ANNOUNCE, "uncp_multiplexer$assign_channel: Assignment of FNP ^a ^[succeeded^;failed^].",
		fnp_info.fnp_tag, (code = 0));

004706  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
004707  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
004710  aa   000003 6010 04	tnz  	3,ic		004713
004711  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
004712  aa   000036 6000 04	tze  	30,ic		004750
004713  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004714  aa   773416 00 0114	desc9a	-2290,76		000331 = 165156143160
004715  aa  6 00534 00 0114	desc9a	pr6|348,76
004716  aa  6 00354 3715 20	epp5 	pr6|236,*
004717  aa  5 00002 2361 20	ldq  	pr5|2,*		code
004720  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
004721  aa  6 00512 7551 00	sta  	pr6|330
004722  aa   773213 3520 04	epp2 	-2421,ic		000135 = 000000000000
004723  aa  6 00562 2521 00	spri2	pr6|370
004724  aa  6 00534 3521 00	epp2 	pr6|348
004725  aa  6 00564 2521 00	spri2	pr6|372
004726  aa  6 00242 3535 20	epp3 	pr6|162,*		fnpp
004727  aa  3 00007 3521 00	epp2 	pr3|7		fnp_info.fnp_tag
004730  aa  6 00566 2521 00	spri2	pr6|374
004731  aa  6 00512 3521 00	epp2 	pr6|330
004732  aa  6 00570 2521 00	spri2	pr6|376
004733  aa   773214 3520 04	epp2 	-2420,ic		000147 = 404000000021
004734  aa  6 00572 2521 00	spri2	pr6|378
004735  aa   773156 3520 04	epp2 	-2450,ic		000113 = 524000000114
004736  aa  6 00574 2521 00	spri2	pr6|380
004737  aa   773177 3520 04	epp2 	-2433,ic		000136 = 526000000001
004740  aa  6 00576 2521 00	spri2	pr6|382
004741  aa   773203 3520 04	epp2 	-2429,ic		000144 = 514000000001
004742  aa  6 00600 2521 00	spri2	pr6|384
004743  aa  6 00560 6211 00	eax1 	pr6|368
004744  aa   020000 4310 07	fld  	8192,dl
004745  aa  6 00044 3701 20	epp4 	pr6|36,*
004746  la  4 00040 3521 20	epp2 	pr4|32,*		syserr
004747  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2042
	if code ^= 0
	then call TRACE_ERROR ("assign_channel", code);

004750  aa  6 00354 3735 20	epp7 	pr6|236,*
004751  aa  7 00002 2361 20	ldq  	pr7|2,*		code
004752  aa   000014 6000 04	tze  	12,ic		004766
004753  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
004754  aa   773243 00 0016	desc9a	-2397,14		000216 = 141163163151
004755  aa  6 00516 00 0040	desc9a	pr6|334,32
004756  aa  6 00516 3521 00	epp2 	pr6|334
004757  aa  6 00562 2521 00	spri2	pr6|370
004760  aa  7 00002 3521 20	epp2 	pr7|2,*		code
004761  aa  6 00564 2521 00	spri2	pr6|372
004762  aa  6 00560 3521 00	epp2 	pr6|368
004763  aa   010000 4310 07	fld  	4096,dl
004764  aa  2 00000 7571 00	staq 	pr2|0
004765  aa   000154 6700 04	tsp4 	108,ic		005141
						STATEMENT 1 ON LINE 2044
	return;

004766  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 2045
     end assign_channel;

  END PROCEDURE assign_channel
BEGIN PROCEDURE unassign_channel
ENTRY TO unassign_channel                                   STATEMENT 1 ON LINE 2047
unassign_channel:
     procedure (code);

004767  aa  6 00360 6501 00	spri4	pr6|240
004770  aa  6 00362 2521 00	spri2	pr6|242
						STATEMENT 1 ON LINE 2052
	if ^fnp_info.io_manager_assigned
	then do;

004771  aa  6 00242 3735 20	epp7 	pr6|162,*		fnpp
004772  aa  7 00066 2351 00	lda  	pr7|54		fnp_info.io_manager_assigned
004773  aa   200000 3150 03	cana 	65536,du
004774  aa   000005 6010 04	tnz  	5,ic		005001
						STATEMENT 1 ON LINE 2054
	     code = error_table_$io_not_assigned;

004775  aa  6 00044 3701 20	epp4 	pr6|36,*
004776  la  4 00076 2361 20	ldq  	pr4|62,*		error_table_$io_not_assigned
004777  aa  2 00002 7561 20	stq  	pr2|2,*		code
						STATEMENT 1 ON LINE 2055
	     go to unassign_return;

005000  aa   000021 7100 04	tra  	17,ic		005021
						STATEMENT 1 ON LINE 2056
	end;

						STATEMENT 1 ON LINE 2057
	call io_manager$unassign (fnp_info.io_manager_chx, code);

005001  aa  7 00012 3521 00	epp2 	pr7|10		fnp_info.io_manager_chx
005002  aa  6 00604 2521 00	spri2	pr6|388
005003  aa  6 00362 3715 20	epp5 	pr6|242,*
005004  aa  5 00002 3521 20	epp2 	pr5|2,*		code
005005  aa  6 00606 2521 00	spri2	pr6|390
005006  aa  6 00602 6211 00	eax1 	pr6|386
005007  aa   010000 4310 07	fld  	4096,dl
005010  aa  6 00044 3701 20	epp4 	pr6|36,*
005011  la  4 00126 3521 20	epp2 	pr4|86,*		io_manager$unassign
005012  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2058
	if code = 0
	then fnp_info.io_manager_assigned = "0"b;

005013  aa  6 00362 3735 20	epp7 	pr6|242,*
005014  aa  7 00002 2361 20	ldq  	pr7|2,*		code
005015  aa   000004 6010 04	tnz  	4,ic		005021
005016  aa   000232 2350 04	lda  	154,ic		005250 = 577777777777
005017  aa  6 00242 3715 20	epp5 	pr6|162,*		fnpp
005020  aa  5 00066 3551 00	ansa 	pr5|54		fnp_info.io_manager_assigned
						STATEMENT 1 ON LINE 2060
unassign_return:
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, code,
		"uncp_multiplexer$unassign_channel: Unassignment of FNP ^a ^[failed^;succeeded^].", fnp_info.fnp_tag,
		(code ^= 0));

005021  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
005022  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
005023  aa   000003 6010 04	tnz  	3,ic		005026
005024  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
005025  aa   000042 6000 04	tze  	34,ic		005067
005026  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005027  aa   773326 00 0120	desc9a	-2346,80		000354 = 165156143160
005030  aa  6 00610 00 0120	desc9a	pr6|392,80
005031  aa  6 00362 3715 20	epp5 	pr6|242,*
005032  aa  5 00002 2361 20	ldq  	pr5|2,*		code
005033  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
005034  aa  6 00634 7551 00	sta  	pr6|412
005035  aa   773100 3520 04	epp2 	-2496,ic		000135 = 000000000000
005036  aa  6 00640 2521 00	spri2	pr6|416
005037  aa  5 00002 3521 20	epp2 	pr5|2,*		code
005040  aa  6 00642 2521 00	spri2	pr6|418
005041  aa  6 00610 3521 00	epp2 	pr6|392
005042  aa  6 00644 2521 00	spri2	pr6|420
005043  aa  6 00242 3535 20	epp3 	pr6|162,*		fnpp
005044  aa  3 00007 3521 00	epp2 	pr3|7		fnp_info.fnp_tag
005045  aa  6 00646 2521 00	spri2	pr6|422
005046  aa  6 00634 3521 00	epp2 	pr6|412
005047  aa  6 00650 2521 00	spri2	pr6|424
005050  aa   773077 3520 04	epp2 	-2497,ic		000147 = 404000000021
005051  aa  6 00652 2521 00	spri2	pr6|426
005052  aa   773070 3520 04	epp2 	-2504,ic		000142 = 404000000043
005053  aa  6 00654 2521 00	spri2	pr6|428
005054  aa   773036 3520 04	epp2 	-2530,ic		000112 = 524000000120
005055  aa  6 00656 2521 00	spri2	pr6|430
005056  aa   773060 3520 04	epp2 	-2512,ic		000136 = 526000000001
005057  aa  6 00660 2521 00	spri2	pr6|432
005060  aa   773064 3520 04	epp2 	-2508,ic		000144 = 514000000001
005061  aa  6 00662 2521 00	spri2	pr6|434
005062  aa  6 00636 6211 00	eax1 	pr6|414
005063  aa   024000 4310 07	fld  	10240,dl
005064  aa  6 00044 3701 20	epp4 	pr6|36,*
005065  la  4 00042 3521 20	epp2 	pr4|34,*		syserr$error_code
005066  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2065
	if code ^= 0
	then call TRACE_ERROR ("unassign_channel", code);

005067  aa  6 00362 3735 20	epp7 	pr6|242,*
005070  aa  7 00002 2361 20	ldq  	pr7|2,*		code
005071  aa   000014 6000 04	tze  	12,ic		005105
005072  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
005073  aa   773120 00 0020	desc9a	-2480,16		000212 = 165156141163
005074  aa  6 00610 00 0040	desc9a	pr6|392,32
005075  aa  6 00610 3521 00	epp2 	pr6|392
005076  aa  6 00640 2521 00	spri2	pr6|416
005077  aa  7 00002 3521 20	epp2 	pr7|2,*		code
005100  aa  6 00642 2521 00	spri2	pr6|418
005101  aa  6 00636 3521 00	epp2 	pr6|414
005102  aa   010000 4310 07	fld  	4096,dl
005103  aa  2 00000 7571 00	staq 	pr2|0
005104  aa   000035 6700 04	tsp4 	29,ic		005141
						STATEMENT 1 ON LINE 2067
	return;

005105  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 2068
     end unassign_channel;

  END PROCEDURE unassign_channel
BEGIN PROCEDURE TRACE
ENTRY TO TRACE                                              STATEMENT 1 ON LINE 2070
TRACE:
     procedure (Entry);

005106  aa  6 00366 6501 00	spri4	pr6|246
005107  aa  6 00370 2521 00	spri2	pr6|248
						STATEMENT 1 ON LINE 2075
	if datanet_info.trace
	then call syserr (ANNOUNCE, "uncp_multiplexer$^a: Tracing call.", Entry);

005110  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
005111  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
005112  aa   000026 6000 04	tze  	22,ic		005140
005113  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005114  aa   773152 00 0044	desc9a	-2454,36		000265 = 165156143160
005115  aa  6 00664 00 0044	desc9a	pr6|436,36
005116  aa   773017 3520 04	epp2 	-2545,ic		000135 = 000000000000
005117  aa  6 00700 2521 00	spri2	pr6|448
005120  aa  6 00664 3521 00	epp2 	pr6|436
005121  aa  6 00702 2521 00	spri2	pr6|450
005122  aa  6 00370 3715 20	epp5 	pr6|248,*
005123  aa  5 00002 3521 20	epp2 	pr5|2,*		Entry
005124  aa  6 00704 2521 00	spri2	pr6|452
005125  aa   773022 3520 04	epp2 	-2542,ic		000147 = 404000000021
005126  aa  6 00706 2521 00	spri2	pr6|454
005127  aa   772762 3520 04	epp2 	-2574,ic		000111 = 524000000042
005130  aa  6 00710 2521 00	spri2	pr6|456
005131  aa   773002 3520 04	epp2 	-2558,ic		000133 = 526000000040
005132  aa  6 00712 2521 00	spri2	pr6|458
005133  aa  6 00676 6211 00	eax1 	pr6|446
005134  aa   014000 4310 07	fld  	6144,dl
005135  aa  6 00044 3701 20	epp4 	pr6|36,*
005136  la  4 00040 3521 20	epp2 	pr4|32,*		syserr
005137  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2077
	return;

005140  aa  6 00366 6101 00	rtcd 	pr6|246
ENTRY TO TRACE_ERROR                                        STATEMENT 1 ON LINE 2081
TRACE_ERROR:
     entry (Entry, Code);

005141  aa  6 00366 6501 00	spri4	pr6|246
005142  aa  6 00370 2521 00	spri2	pr6|248
						STATEMENT 1 ON LINE 2086
	if datanet_info.trace | datanet_info.debug_stop
	then call syserr$error_code (ANNOUNCE, Code, "uncp_multiplexer$^a: Tracing error.", Entry);

005143  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
005144  aa  7 00005 2351 00	lda  	pr7|5		datanet_info.trace
005145  aa   000003 6010 04	tnz  	3,ic		005150
005146  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
005147  aa   000032 6000 04	tze  	26,ic		005201
005150  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005151  aa   773104 00 0044	desc9a	-2492,36		000254 = 165156143160
005152  aa  6 00664 00 0044	desc9a	pr6|436,36
005153  aa   772762 3520 04	epp2 	-2574,ic		000135 = 000000000000
005154  aa  6 00716 2521 00	spri2	pr6|462
005155  aa  6 00370 3715 20	epp5 	pr6|248,*
005156  aa  5 00004 3521 20	epp2 	pr5|4,*		Code
005157  aa  6 00720 2521 00	spri2	pr6|464
005160  aa  6 00664 3521 00	epp2 	pr6|436
005161  aa  6 00722 2521 00	spri2	pr6|466
005162  aa  5 00002 3521 20	epp2 	pr5|2,*		Entry
005163  aa  6 00724 2521 00	spri2	pr6|468
005164  aa   772763 3520 04	epp2 	-2573,ic		000147 = 404000000021
005165  aa  6 00726 2521 00	spri2	pr6|470
005166  aa   772754 3520 04	epp2 	-2580,ic		000142 = 404000000043
005167  aa  6 00730 2521 00	spri2	pr6|472
005170  aa   772720 3520 04	epp2 	-2608,ic		000110 = 524000000043
005171  aa  6 00732 2521 00	spri2	pr6|474
005172  aa   772741 3520 04	epp2 	-2591,ic		000133 = 526000000040
005173  aa  6 00734 2521 00	spri2	pr6|476
005174  aa  6 00714 6211 00	eax1 	pr6|460
005175  aa   020000 4310 07	fld  	8192,dl
005176  aa  6 00044 3701 20	epp4 	pr6|36,*
005177  la  4 00042 3521 20	epp2 	pr4|34,*		syserr$error_code
005200  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2088
	if datanet_info.debug_stop
	then call syserr (CRASH_SYSTEM, "uncp_multiplexer: debugging stop (type go to continue).");

005201  aa  6 00240 3735 20	epp7 	pr6|160,*		infop
005202  aa  7 00006 2351 00	lda  	pr7|6		datanet_info.debug_stop
005203  aa   000021 6000 04	tze  	17,ic		005224
005204  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005205  aa   773107 00 0070	desc9a	-2489,56		000313 = 165156143160
005206  aa  6 00676 00 0070	desc9a	pr6|446,56
005207  aa   772737 3520 04	epp2 	-2593,ic		000146 = 000000000001
005210  aa  6 00716 2521 00	spri2	pr6|462
005211  aa  6 00676 3521 00	epp2 	pr6|446
005212  aa  6 00720 2521 00	spri2	pr6|464
005213  aa   772734 3520 04	epp2 	-2596,ic		000147 = 404000000021
005214  aa  6 00722 2521 00	spri2	pr6|466
005215  aa   772672 3520 04	epp2 	-2630,ic		000107 = 524000000067
005216  aa  6 00724 2521 00	spri2	pr6|468
005217  aa  6 00714 6211 00	eax1 	pr6|460
005220  aa   010000 4310 07	fld  	4096,dl
005221  aa  6 00044 3701 20	epp4 	pr6|36,*
005222  la  4 00040 3521 20	epp2 	pr4|32,*		syserr
005223  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 2090
	return;

005224  aa  6 00366 6101 00	rtcd 	pr6|246
						STATEMENT 1 ON LINE 2091
     end TRACE;

  END PROCEDURE TRACE
  END PROCEDURE uncp_multiplexer


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
