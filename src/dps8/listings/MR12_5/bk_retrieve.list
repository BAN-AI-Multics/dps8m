	COMPILATION LISTING OF SEGMENT bk_retrieve
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-06-29_1717.42_Thu_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 bk_retrieve: proc;					/* extracted from backup_load */
       14 
       15 /* Modified 16 June 1970, R H Campbell. */
       16 /* Modified 21 October 1970, R. J. Feiertag */
       17 /* Modified 10 May 1971, R. A. Tilden */
       18 /* Modified 22 July 1974 RE Mullen */
       19 /* Modified 23 July 1975, R. Bratt to remove knowledge of pre 18-0 backup tape formats */
       20 /* Entry points check_structure and parse structure added 11/9/77 by Steve Herbst */
       21 /* -no_primary added 08/03/79 S. Herbst */
       22 /* Modified to avoid page boundary hardware bug 098; installed on MCR 4311 to fix errmsgs 02/05/80 S. Herbst */
       23 /* Hierarchy level restriction removed for reloading commands 07/18/80 S. Herbst */
       24 /* Changed not to cross-retrieve a segment in place of an existing directory 01/21/82 S. Herbst */
       25 /* Changed to retrieve an entire MSF without ">**" 02/05/82 S. Herbst */
       26 
       27 dcl (i, j, k, l, n, htype) fixed bin,			/* temporary storage */
       28      path_name char (168),				/* Complete path name of entry. */
       29      old_dname char (168) init (""),			/* Previous directory name. */
       30      code fixed bin (35);
       31 
       32 
       33 dcl  line char (300) static,				/* Output line(s) buffer. */
       34      line_pointer ptr static,				/* Pointer to line buffer. */
       35      hp ptr static,
       36      a_hp ptr;
       37 
       38 dcl  nl char (1) static;				/* Newline used in parsing retrieval control */
       39 
       40 dcl  rname char (168) aligned,			/* Retrieval control input name, dirname */
       41      rdname char (168) static aligned,			/* Retrieval control dirname */
       42      rename char (32) aligned static,			/* ..entry name */
       43     (rsize, rbc) fixed bin;				/* size of rname, bit count of file */
       44 
       45 dcl (rptr, reqptr) ptr static;			/* ptr to retrieval control (raw, parsed) */
       46 
       47 dcl (parsed, next, stop, terminate, reported, checked) fixed bin static;
       48 
       49 dcl  label_index fixed bin;
       50 
       51 dcl (rlines, rfin, rcomp,				/* no. requests, no. complete, no. unique */
       52      rcurr, ncurr) fixed bin static,			/* current request, next newname */
       53      grt_count fixed bin;				/* number of >'s in a pathname */
       54 
       55 dcl  1 req based (reqptr) aligned,			/* parsed request array */
       56      2 path_copy char (168),				/* to avoid CMPC failure near page boundary, Bug 098 */
       57      2 opt (1000),					/* options for, status of, a request */
       58      3 (rename,					/* new name was provided */
       59      exact,					/* load only this entity */
       60      synonym,					/* this entry is a synonym for the one specified by renamo */
       61      found,					/* something by this name was found */
       62      finished,					/* request has been satisfied fully */
       63      spare) bit (1) unaligned,
       64      2 srch (1000),					/* data by which to retrieve */
       65      3 (len,					/* significant chars in search name */
       66      grt,						/* number of >'s in search name */
       67      control_index,					/* index of backup_control entry for backup_load_ */
       68      renamo) fixed bin,				/* index of newname or of primary entry if a synonym */
       69      3 name char (168),				/* name to look for */
       70      2 newn (200),					/* name by which to reload */
       71      3 (ndlen, nelen, ngrt) fixed bin,			/* lengths of next fields, number of ">"s in dname */
       72      3 ndname char (168);				/* new pathname */
       73 
       74 dcl (rscan (1000000) char (1), rmove char (1000000)) based, /* overlays for parsing */
       75      rset bit (6) based;				/* overlay for setting field of bits */
       76 
       77 dcl (error_table_$badcall, error_table_$bad_string,
       78      error_table_$smallarg, error_table_$badpath, error_table_$noentry,
       79      error_table_$no_dir, error_table_$no_s_permission,
       80      error_table_$moderr, error_table_$no_info,
       81      error_table_$arg_ignored, error_table_$segknown) external fixed bin (35);
       82 
       83 dcl (addr, baseptr, divide, fixed, index, length, reverse, rtrim, substr, unspec, verify) builtin;
       84 
       85 dcl  backup_map_$fs_error_line entry (fixed bin (35), char (*) aligned, char (*) aligned, char (*) aligned),
       86      backup_map_$on_line entry (ptr, fixed bin),
       87      backup_util$get_real_name entry (ptr, ptr, fixed bin, fixed bin (35)),
       88      expand_pathname_ entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
       89 
       90 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35)),
       91      hcs_$terminate_noname entry (ptr, fixed bin (35)),
       92      hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35)),
       93      hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*), fixed bin, fixed bin (2), ptr, fixed bin (35));
       94 
       95 dcl (com_err_, ioa_, ioa_$rsnnl) ext entry options (variable);
       96 
       97 /*  */
       98 
  1     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  1     6*     install(87-03-30,MR12.1-1018):
  1     7*     added a writing_map switch to indicate when the dump map is being written.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 
  1    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  1    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  1    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  1    14 
  1    15 /* Hierarchy dumper/reloader static data */
  1    16 
  1    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  1    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  1    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  1    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  1    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  1    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  1    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  1    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  1    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  1    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  1    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  1    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  1    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  1    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  1    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  1    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  1    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  1    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  1    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  1    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  1    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  1    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  1    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  1    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  1    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  1    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  1    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  1    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  1    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  1    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  1    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  1    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  1    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  1    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  1    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  1    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  1    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  1    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  1    55*						   requests satisfied (loading) */
  1    56      bk_ss_$operator char(32),			/* operator name */
  1    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  1    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  1    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  1    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  1    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  1    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  1    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  1    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  1    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  1    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  1    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  1    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  1    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  1    70      bk_ss_$rname char(168),				/* retrieval file name */
  1    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  1    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  1    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  1    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  1    75      bk_ss_$segptr pointer,
  1    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  1    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  1    78      bk_ss_$sp pointer,
  1    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  1    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  1    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  1    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  1    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  1    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  1    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  1    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  1    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  1    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  1    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  1    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  1    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  1    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  1    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  1    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  1    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  1    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  1    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  1    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  1    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  1   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  1   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  1   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  1   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  1   104 	external static;
  1   105 
  1   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
       99 
      100 
  2     1 /* BEGIN INCLUDE FILE ... backup_control.incl.pl1 */
  2     2 /* Modified: July 1982 by G. Palter to add features for proper support of AIM in IMFT (version 4) */
  2     3 /* Modified: August 1983 by Robert Coren to add minimum access class enforcement */
  2     4 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  2     5 
  2     6 /* Hierarchy dumper/reloader subroutine control structure */
  2     7 
  2     8 dcl 1 backup_control aligned based (backup_control_ptr),
  2     9     2 header,					/* allows people to use like (!) */
  2    10       3 version character (8) unaligned,
  2    11       3 tape_entry entry (character (*)) variable,	/* returns next tape label */
  2    12       3 data_iocb pointer,				/* -> I/O switch to use for dumping/loading if preattached */
  2    13       3 maximum_access_class bit (72) aligned,		/* maximum access class for anything to be dumped */
  2    14       3 minimum_access_class bit (72) aligned,		/* minimum access class for anything to be dumped */
  2    15       3 maximum_dir_access_class bit (72) aligned,	/* no directory above this access class is dumped */
  2    16       3 user_for_access_check,			/* data required to validate user's access */
  2    17         4 id character (32) unaligned,			/* Person.Project.tag */
  2    18         4 authorization bit (72),			/* the user's process authorization */
  2    19         4 ring fixed binary,				/* the user's ring o execution */
  2    20       3 minimum_ring fixed binary,			/* no ring bracket is set below this value */
  2    21       3 aim_translations,				/* data required to translate AIM attributes on the tape */
  2    22         4 source_attributes_ptr pointer,
  2    23         4 target_attributes_ptr pointer,
  2    24       3 options aligned,
  2    25         4 map_sw  bit(1) unaligned,			/* ON to write map segment */
  2    26         4 debug_sw bit (1) unaligned,			/* ON to check quotas and not trim subtrees */
  2    27         4 no_reload_sw bit (1) unaligned,		/* ON to not load for backup_load_ */
  2    28         4 hold_sw bit (1) unaligned,			/* ON to not demount tape afterwards */
  2    29         4 preattached bit (1) unaligned,		/* ON => perform loading/dumping to supplied I/O switch */
  2    30         4 error_file bit (1) unaligned,			/* ON => generate an error file anyway */
  2    31         4 first bit (1) unaligned,			/* ON => for reload, stop after all requests satisfied */
  2    32         4 caller_handles_conditions bit (1) unaligned,	/* ON => caller of backup_dump_ handles faults */
  2    33         4 allow_dir_overwrite bit (1) unaligned,		/* ON => allow reloaded seg to overwrite a dir */
  2    34         4 enforce_max_access_class bit (1) unaligned,	/* ON => do not dump anything above given access class */
  2    35         4 dont_dump_upgraded_dirs bit (1) unaligned,	/* ON => do not dump directories above given access class */
  2    36         4 check_effective_access bit (1) unaligned,	/* ON => do not dump branches specified user can't touch */
  2    37         4 restore_access_class bit (1) unaligned,		/* ON => restore AIM attributes even in debug mode */
  2    38         4 enforce_minimum_ring bit (1) unaligned,		/* ON => do not give anything ring bracket below minimum */
  2    39         4 translate_access_class bit (1) unaligned,	/* ON => translate access classes read from tape */
  2    40         4 enforce_min_access_class bit (1) unaligned,	/* ON => do not dump anything below given access class */
  2    41         4 upgrade_to_user_auth bit (1) unaligned,		/* ON => set access class of branch being dumped to user's authorization */
  2    42         4 pad bit (19) unaligned,
  2    43       3 request_count fixed binary,			/* # of entries to load or dump */
  2    44     2 requests (backup_control_request_count refer (backup_control.request_count)),
  2    45       3 path character (168) unaligned,			/* pathname of object to be dumped/loaded */
  2    46       3 new_path character (168) unaligned,		/* pathname for object when reloading if not same as above */
  2    47       3 switches aligned,
  2    48         4 no_primary_sw bit (1) unaligned,		/* do not use primary pathname */
  2    49         4 trim_sw bit (1) unaligned,			/* trim target directories */
  2    50         4 pad bit (34) unaligned,
  2    51       3 found bit(1) aligned,				/* ON => found on tape by backup_load_ (output) */
  2    52       3 loaded bit (1) aligned,			/* ON => loaded by backup_load_ (output) */
  2    53       3 status_code fixed binary (35),			/* ON => per-entry status code (output) */
  2    54       3 error_name character (65) unaligned;		/* ON => some information about what happened (output) */
  2    55 
  2    56 dcl  backup_control_ptr pointer;
  2    57 
  2    58 dcl backup_control_request_count fixed binary;		/* for allocations */
  2    59 
  2    60 dcl BACKUP_CONTROL_VERSION_5 character (8) static options (constant) initial ("hbc_0005");
  2    61 
  2    62 /* END INCLUDE FILE ... backup_control.incl.pl1 */
      101 
      102 
  3     1 
  3     2 /* Begin include file ... backup_preamble_header.incl.pl1 */
  3     3 /* Modified 1/29/73 by N. I. Morris */
  3     4 /* Modified 7/15/74 by R. E. Mullen */
  3     5 /* Modified 10/10/74 by A. Kobziar */
  3     6 
  3     7 dcl 1 h based aligned,				/* backup preamble (segment header) */
  3     8 
  3     9     2 dlen fixed binary,
  3    10     2 dname character (168),
  3    11     2 elen fixed binary,
  3    12     2 ename character (32),
  3    13     2 bitcnt fixed binary (24),
  3    14     2 record_type fixed binary,			/* Logical record type. */
  3    15     2 dtd fixed binary (52),				/* Date and time dump occurred. */
  3    16     2 dumper_id character (32),			/* Identification of dumper procedure. */
  3    17 
  3    18     2 bp bit (18),					/* Pointer to branches. */
  3    19     2 bc fixed binary,				/* Branch count. */
  3    20     2 lp bit (18),					/* Pointer to links. */
  3    21     2 lc fixed binary,				/* Link count. */
  3    22     2 aclp bit (18),				/* Pointer to ACL or CACL */
  3    23     2 aclc fixed binary,				/* ACL count. */
  3    24     2 actind bit (18),				/* File activity indicator */
  3    25     2 actime bit (36),				/* File activity time */
  3    26 
  3    27     2 quota fixed binary,				/* Record quota for directory_list record. */
  3    28     2 trp fixed binary (35),				/* Time-record product .. */
  3    29     2 tlu fixed binary (35),				/* Time last updated .. */
  3    30     2 inf_acct fixed binary,				/* Inferior account switch .. */
  3    31     2 term_acct fixed binary (1),			/* Terminal account switch .. */
  3    32     2 pad1 (3),					/* To even out area to 0 mod 8 */
  3    33 
  3    34     2 max_length fixed bin (18),			/* Max. length of segment */
  3    35     2 switches unal,
  3    36       3 safety_sw bit (1) unal,			/* Segment safety switch */
  3    37       3 entrypt_sw bit (1) unal,			/* "1"b -> call limiter enabled */
  3    38       3 security_oosw bit(1) unal,			/* security out-of-service */
  3    39       3 audit_flag bit(1) unal,			/* flag for seg reference auditing */
  3    40       3 multiple_class bit (1) unal,			/* system segment: access class may be higher than parent's */
  3    41       3 pad2 bit(2) unal,				/* =pad2 in dir_entry */
  3    42       3 master_dir bit (1) unal,			/* "1"b => was master dir */
  3    43       3 tpd bit (1) unal,				/* TRUE => never put on paging device */
  3    44       3 sw_pad bit (13) unal,				/* padding in this structure */
  3    45     2 entrypt_bound bit (14) unal,			/* Call limiter. */
  3    46     2 access_class bit(72),				/* access class of entry */
  3    47     2 spad bit(36),					/* last word of dir entry */
  3    48     2 status_version fixed bin,			/* version of status_for_backup struct */
  3    49     2 nss_info_relp bit (18) aligned,			/* NONZERO => NSS INFO */
  3    50     2 dq_info_relp bit (18) aligned,				/* NONZERO => DIRQUOTA INFO */
  3    51 
  3    52     2 inaclp (0:7) bit (18),				/* Pointer to initial ACL for each ring. */
  3    53     2 inaclc (0:7) fixed bin,				/* Initial ACL count for each ring. */
  3    54     2 dir_inaclp (0:7) bit (18),			/* Directory initial ACL pointer for each ring. */
  3    55     2 dir_inaclc (0:7) fixed bin,			/* Directory initial ACL count for each ring. */
  3    56 
  3    57     2 bitcount_author char (32),			/* last modifier of the bit count */
  3    58 
  3    59     2 list_area /* area */ (65408);			/* Area for list_dir and readacl. */
  3    60 
  3    61 dcl  author char (32) aligned based;			/* Author of entry */
  3    62 						/* N. B.  Author is an overlay starting at h.quota */
  3    63 
  3    64 /* End of include file ... backup_preamble_header.incl.pl1 */
  3    65 
      103 
      104 
  4     1 /*  BEGIN:   backup_record_types.incl.pl1		  *  *  *  *  *  */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
  4     6*     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
  4     7*     Converted internal static variables to named constants.  Renamed
  4     8*     record_type array to RECORD_TYPE, to avoid naming conflict with
  4     9*     backup_preamble_header.incl.pl1's h.record_type variable.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Created June 1970, R H Campbell. */
  4    14 /* Modified 1/16/73 by N. I. Morris	*/
  4    15 /* Modified 7/17/75 by R. Bratt */
  4    16 /* Modified 11/04/83 by G. Dixon - better comments */
  4    17 
  4    18 dcl  ndc_segment fixed binary int static options(constant) initial (1);
  4    19 						/* Record of segment with NDC attributes */
  4    20 dcl  ndc_directory fixed binary int static options(constant) initial (2);
  4    21 						/* Record of directory with NDC attributes */
  4    22 dcl  ndc_directory_list fixed binary int static options(constant) initial (3);
  4    23 						/* Record of directory list with initial ACL */
  4    24 dcl  sec_seg fixed binary int static options(constant) initial(19);
  4    25 						/* Seg with security & call_limiter */
  4    26 dcl  sec_dir fixed binary int static options(constant) initial(20);
  4    27 						/* Dir with security & call_limiter */
  4    28 
  4    29 dcl  RECORD_TYPE (0: 20) character (10) aligned		/* Name of the record types. */
  4    30      int static options(constant)
  4    31      initial (*, "NDC seg", "NDC dir", "NDC dirlst", *, *, *, *,
  4    32 	    *, *, *, *, *, *, *, *,
  4    33 	    *, *, *, "SEG", "DIR");
  4    34 
  4    35 /* The following is an excerpt from a backup map showing the relationship
  4    36*   between entries in the backup map and the named constants given above.
  4    37*   I don't know under what conditions the ndc_seg and ndc_dir named constants
  4    38*   are ever used.  (G. Dixon)
  4    39*
  4    40*			        Map Excerpt
  4    41*   		 ---------------------------------------------
  4    42*Named Constant       ENTRY NAME                   BLOCKS REC_TYPE  
  4    43*
  4    44*sec_dir		 >library_dir_dir>system_library_unbundled
  4    45*		  object			     0 directory 
  4    46*			 o
  4    47*sec_dir		  source			     0 directory
  4    48*		           s
  4    49*
  4    50*ndc_directory_list	 >library_dir_dir>system_library_unbundled>object
  4    51*				               0 directory 
  4    52*sec_seg		  bound_gcos_tss_.1.archive	   104 segment   
  4    53*
  4    54*
  4    55*ndc_directory_list   >library_dir_dir>system_library_unbundled>source
  4    56*				               0 directory
  4    57*sec_seg               bound_gcos_tss_.1.s.archive	   134 segment
  4    58*
  4    59*
  4    60*						          */
  4    61 
  4    62 
  4    63 /*  END OF:  backup_record_types.incl.pl1		  *  *  *  *  *  */
      105 
      106 
      107 /*  */
      108 
      109 /* Check whether this tape record is to be reloaded by scanning retrieval request segment. */
      110 
      111 check_retrieval: entry (label_index);
      112 
      113 	if rfin = rcomp then do;			/* If all unique requests are fully satisfied */
      114 	     call ioa_$rsnnl ("^a: all requests satisfied.", line, n, bk_ss_$myname);
      115 	     call backup_map_$on_line (line_pointer, n);	/* inform the world of success */
      116 	     label_index = stop;			/* and terminate retrieval */
      117 	     go to exit;
      118 	end;
      119 
      120 	htype = hp -> h.record_type;
      121 	hp -> h.dlen = length (rtrim (hp -> h.dname));
      122 	path_name = substr (hp -> h.dname, 1, hp -> h.dlen) || ">"; /* prepare full name of tape record */
      123 	n = hp -> h.dlen + 1;			/* set the length */
      124 	if hp -> h.elen ^= 0 then do;			/* if there is an entry name, tack it on */
      125 	     hp -> h.elen = length (rtrim (hp -> h.ename));
      126 	     substr (path_name, n + 1) = substr (hp -> h.ename, 1, hp -> h.elen) || ">";
      127 	     n = n + hp -> h.elen + 1;		/* recompute length */
      128 	end;
      129 	if rcurr ^= 0 then do;			/* if we are currently working on a subtree request */
      130 	     i = rcurr;				/* set i in case of match */
      131 	     req.path_copy = req.srch.name (i);
      132 	     if substr (path_name, 1, req.srch.len (i)) = req.path_copy then
      133 		go to match;			/* first part of pathname matches */
      134 	     if bk_ss_$onlysw & req.opt.found (i) then do; /* no longer matching, and wanted only first */
      135 		req.opt.finished (i) = "1"b;		/* mark previous request completed */
      136 		if req.opt.synonym (i) then req.opt.finished (req.srch.renamo (i)) = "1"b; /* and his twin */
      137 		rfin = rfin + 1;			/* number of fully completed increases */
      138 	     end;
      139 	end;
      140 	do i = 1 to rlines;				/* look for applicable request */
      141 	     if i = rcurr then go to next_test;		/* skip possible request previously checked */
      142 	     if req.opt.finished (i) then go to next_test; /* skip completed request */
      143 	     if req.opt.exact (i) then do;		/* exact means don't load subtree */
      144 		if n = req.srch.len (i) & substr (path_name, 1, n) = req.srch.name (i) then
      145 		     go to match;			/* exactly the item requested */
      146 	     end;
      147 	     else do;
      148 		req.path_copy = req.srch.name (i);
      149 		if substr (path_name, 1, req.srch.len (i)) = req.path_copy then
      150 		     go to match;			/* pathname matches */
      151 	     end;
      152 next_test: end;
      153 	rcurr = 0;				/* not working on anything */
      154 	label_index = next;				/* don't process this tape record */
      155 	go to exit;
      156 
      157 match:	bk_ss_$retrieval_index = i;			/* save; backup_load uses it */
      158 	if bk_ss_$sub_entry then bk_ss_$path_index = req.srch.control_index (i);
      159 	if htype ^= ndc_directory & htype ^= sec_dir then do;
      160 	     req.opt.found (i) = "1"b;		/* indicate something interesting encountered */
      161 	     if req.opt.synonym (i) then req.opt.found (req.srch.renamo (i)) = "1"b; /* on twin too */
      162 	     if bk_ss_$sub_entry then
      163 		bk_ss_$control_ptr -> backup_control.found (bk_ss_$path_index) = "1"b;
      164 	end;
      165 	if bk_ss_$onlysw then do;			/* special processing with -first option */
      166 	     if req.opt.exact (i) then do;		/* if only exact match was wanted, this is it */
      167 		if htype ^= ndc_directory & htype ^= sec_dir then do;
      168 		     req.opt.finished (i) = "1"b;	/* so mark it, and its brother if any */
      169 		     if req.opt.synonym (i) then req.opt.finished (req.srch.renamo (i)) = "1"b;
      170 		     rfin = rfin + 1;		/* count number of requests complete */
      171 		end;
      172 	     end;
      173 	     if rcurr ^= 0 then			/* avoid OOB */
      174 		if req.opt.finished (rcurr) then rcurr = 0; /*  we delayed resetting this so it could be used in loop */
      175 	end;
      176 	if ^req.opt.exact (i) then rcurr = i;		/* indicate we are currently interested in a subtree */
      177 	if req.opt.rename (i) then do;		/* check whether to load it under its own name */
      178 	     bk_ss_$cross_retrievesw = "1"b;
      179 	     ncurr = req.srch.renamo (i);		/* get index of new name */
      180 	     if req.opt.synonym (i) then ncurr = req.srch.renamo (ncurr); /* indirect if necessary */
      181 	     grt_count = req.srch.grt (i);
      182 	     j = 0;				/* count of ">"s in tape dirname */
      183 	     if req.newn.ndlen (ncurr) = 0 then do;	/* check whether replacing only entry name */
      184 		if (htype = ndc_directory_list) then do;
      185 		     do i = 1 to hp -> h.dlen;	/* scan for entry name portion */
      186 			if addr (hp -> h.dname) -> rscan (i) = ">" then do;
      187 			     j = j + 1;		/* count subpath */
      188 			     if j = grt_count then do;  /* found the place */
      189 				hp -> h.dname = substr (hp -> h.dname, 1, i) ||
      190 				     substr (req.newn.ndname (ncurr), 1, req.newn.nelen (ncurr));
      191 				hp -> h.dlen = i + req.newn.nelen (ncurr);
      192 				go to renamed;	/* finished renaming */
      193 			     end;
      194 			end;
      195 		     end;
      196 		     go to renamed;
      197 		end;
      198 		hp -> h.ename = req.newn.ndname (ncurr); /* change name */
      199 		hp -> h.elen = req.newn.nelen (ncurr);	/* and its length */
      200 		go to renamed;			/* go load it */
      201 	     end;
      202 	     if (htype = ndc_directory_list) then do;
      203 		do i = 1 to hp -> h.dlen;		/* scan old dirname */
      204 		     if addr (hp -> h.dname) -> rscan (i) = ">" then do;
      205 			j = j + 1;		/* count partial path */
      206 			if j = grt_count + 1 then do;  /* looking for one > beyond the old path */
      207 partial:			     hp -> h.dname = substr (req.newn.ndname (ncurr), 1, req.newn.ndlen (ncurr))
      208 				|| substr (hp -> h.dname, i, hp -> h.dlen - i + 1);
      209 			     hp -> h.dlen = hp -> h.dlen - i + 1 + req.newn.ndlen (ncurr);
      210 			     go to renamed;		/* partial path substituted */
      211 			end;
      212 		     end;
      213 		end;
      214 dironly:		hp -> h.dlen = req.newn.ndlen (ncurr);	/* complete replacement */
      215 		hp -> h.dname = substr (req.newn.ndname (ncurr), 1, hp -> h.dlen);
      216 		go to renamed;
      217 	     end;
      218 	     do i = 1 to hp -> h.dlen;		/* scan entire tape dirname */
      219 		if addr (hp -> h.dname) -> rscan (i) = ">" then do; /* if it is end of partial path, count it */
      220 		     j = j + 1;			/* increment total */
      221 		     if j = grt_count then do;	/* check whether this is size of dirname */
      222 			k = index (substr (hp -> h.dname, i + 1), ">"); /* look for another one */
      223 			if k = 0 then go to dironly;	/* if not, dirname only needs changing */
      224 			i = i + k;		/* replace this many levels of dirname */
      225 			go to partial;		/* rename front end of path */
      226 		     end;
      227 		end;
      228 	     end;
      229 	     hp -> h.dlen = req.newn.ndlen (ncurr) - req.newn.nelen (ncurr) - 1; /* replace both d- and e- names */
      230 	     hp -> h.dname = substr (req.newn.ndname (ncurr), 1, hp -> h.dlen);
      231 	     hp -> h.elen = req.newn.nelen (ncurr);
      232 	     hp -> h.ename = substr (req.newn.ndname (ncurr), hp -> h.dlen + 2, hp -> h.elen);
      233 renamed:	end;
      234 	else bk_ss_$cross_retrievesw = "0"b;
      235 	label_index = checked;			/* reload (renamed) entity */
      236 	go to exit;
      237 
      238 
      239 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      240 
      241 
      242 flag_msf: entry (A_index);
      243 
      244 dcl A_index fixed bin;
      245 
      246 	rcurr = A_index;				/* doing a subtree (MSF) */
      247 
      248 	req.opt.exact (A_index) = "0"b;		/* retrieve the whole subtree */
      249 	if req.opt.synonym (A_index) then req.opt.exact (req.srch.renamo (A_index)) = "0"b;
      250 						/* get the twin too in case it matters */
      251 	return;
      252 
      253 
      254 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      255 
      256 
      257 /* Entry to parse the retrieval file and convert it into tabular form */
      258 
      259 parse_retrieval_control: entry (rname, rsize, a_hp, label_index);
      260 
      261 	if bk_ss_$sub_entry then do;
      262 	     call backup_map_$fs_error_line (error_table_$badcall, "bk_retrieve$parse_retrieval_control",
      263 		"^/This entry point must be called via backup_load, reload or retrieve", "");
      264 	     label_index = terminate;
      265 	end;
      266 	go to COMMON;
      267 
      268 parse_structure: entry (a_hp, label_index);
      269 
      270 	if ^bk_ss_$sub_entry then do;
      271 	     call backup_map_$fs_error_line (error_table_$badcall, "bk_retrieve$parse_structure",
      272 		"^/This entry point must be called via backup_load_", "");
      273 	     label_index = terminate;
      274 	end;
      275 
      276 COMMON:	hp = a_hp;				/* Copy argument into static and save */
      277 	unspec (nl) = "000001010"b;			/* Newline character */
      278 	rfin, rlines = 0;				/* convert retrieval file to tabular form */
      279 	parsed = 1;				/* set up label index words */
      280 	next = 2;
      281 	stop = 3;
      282 	terminate = 4;
      283 	reported = 5;
      284 	checked = 6;
      285 	if ^bk_ss_$sub_entry then do;
      286 	     line_pointer = addr (line);
      287 
      288 	     call expand_pathname_ (substr (rname, 1, rsize), rdname, rename, code);
      289 	     if code ^= 0 then do;
      290 		call com_err_ (code, bk_ss_$myname, rname);
      291 		go to reported_exit;		/* cannot proceed without legal pathname */
      292 	     end;
      293 
      294 	     call hcs_$initiate_count (rdname, rename, "", rbc, 1, rptr, code);
      295 	     if code ^= 0 & code ^= error_table_$segknown then do;
      296 		call com_err_ (code, bk_ss_$myname, "^a>^a", rdname, rename);
      297 		go to reported_exit;		/* cannot proceed without instructions */
      298 	     end;
      299 	end;
      300 
      301 	call hcs_$make_seg ("", "retrieval_control", "", 01011b, reqptr, code);
      302 	if code ^= 0 & code ^= error_table_$segknown then do;
      303 	     call com_err_ (code, bk_ss_$myname, "retrieval_control");
      304 reported_exit: label_index = reported;			/* cannot proceed without storage */
      305 	     go to exit;
      306 	end;
      307 	call hcs_$truncate_seg (reqptr, 0, 0);		/* be sure it's zeroes */
      308 
      309 	ncurr, rcurr, i = 1;			/* new names, requests, character cursors */
      310 
      311 	if bk_ss_$sub_entry then do;
      312 	     rlines, rcomp = bk_ss_$control_ptr -> backup_control.request_count;
      313 	     if rlines > 500 then go to parsed_enough;
      314 	     do rcurr = 1 to rlines;
      315 		line = bk_ss_$control_ptr -> backup_control.path (rcurr);
      316 		if substr (line, 1, 1) ^= ">" then do;
      317 		     bk_ss_$control_ptr -> backup_control.status_code (rcurr) = error_table_$badpath;
      318 		     label_index = terminate;
      319 		     go to exit;
      320 		end;
      321 		req.srch.control_index (rcurr) = rcurr;  /* one req.srch per backup_control entry so far */
      322 		req.srch.name (rcurr) = line;
      323 		req.srch.len (rcurr) = length (line) + 1 - verify (reverse (line), " ");
      324 		if bk_ss_$control_ptr -> backup_control.new_path (rcurr) ^= "" then do;    /* cross-retrieval */
      325 		     req.opt.rename (rcurr) = "1"b;
      326 		     req.srch.renamo (rcurr) = ncurr;
      327 		     j = 0;			/* count >'s in search name */
      328 		     do k = 1 to req.srch.len (rcurr);
      329 			if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then j = j + 1;
      330 		     end;
      331 		     req.srch.grt (rcurr) = j;
      332 		     line = bk_ss_$control_ptr -> backup_control.new_path (rcurr);
      333 		     n = length (rtrim (line));
      334 		     bk_ss_$no_primary = bk_ss_$control_ptr -> backup_control.no_primary_sw (rcurr);
      335 		     j = 0;
      336 		     call count_grts;
      337 		     ncurr = ncurr + 1;
      338 		     n = req.srch.len (rcurr);
      339 		end;
      340 		else req.opt.rename (rcurr) = "0"b;
      341 		req.opt.exact (rcurr) = "0"b;		/* load everything underneath specified entry */
      342 	     end;
      343 	end;
      344 
      345 	else do;
      346 	     rbc = divide (rbc, 9, 17, 0);		/* compute number of characters to scan */
      347 	     do while (i < rbc);			/* scan the file one line at a time */
      348 		if rlines > 500 then go to parsed_enough; /* maximum requests at one time */
      349 		do j = i by 1 to rbc while (rptr -> rscan (j) ^= nl); /* isolate one request line */
      350 		end;
      351 		n = j - i;			/* length without newline character */
      352 		k = i;				/* save beginning of line index */
      353 		i = j + 1;			/* one past the newline */
      354 		if n = 0 then go to parse_next;	/* ignore blank line */
      355 		line = substr (rptr -> rmove, k, n);	/* extract line to facilitate further scanning */
      356 		if substr (line, 1, 1) ^= ">" then do;	/* at least the lefthand side must be a pathname */
      357 		     call com_err_ (error_table_$badpath, bk_ss_$myname, "search arg of ^a", line);
      358 		     go to bad_p;
      359 		end;
      360 		j = index (line, "=");		/* check for rename option */
      361 		if j = 0 then do;			/* renaming was not specified */
      362 		     req.opt.rename (rcurr) = ""b;	/* turn off the switch */
      363 		     req.srch.name (rcurr) = substr (line, 1, n); /* move in pathname to seek */
      364 		     req.srch.len (rcurr) = n;	/* and its length */
      365 		end;
      366 		else do;				/* renaming was specified */
      367 		     if j = n then do;		/* line ending in "=" is an error */
      368 			call com_err_ (error_table_$bad_string, bk_ss_$myname, "no new name in ^a", line);
      369 			go to bad_p;		/* give up */
      370 		     end;
      371 		     req.opt.rename (rcurr) = "1"b;	/* so indicate */
      372 		     req.srch.name (rcurr) = substr (line, 1, j - 1); /* move search argument */
      373 		     req.srch.len (rcurr) = j - 1;	/* length of sought pathname */
      374 		     req.srch.renamo (rcurr) = ncurr;	/* location of new name */
      375 		     call count_grts;		/* count ">"'s in pathname */
      376 		     ncurr = ncurr + 1;		/* prepare for next renaming */
      377 		     n = j - 1;			/* length ignoring righthand side */
      378 		end;
      379 		call see_stars;			/* look for stars in search name */
      380 		j = 0;				/* count >'s in search name */
      381 		do k = 1 to req.srch.len (rcurr);
      382 		     if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then j = j + 1;
      383 		end;
      384 		req.srch.grt (rcurr) = j;
      385 		rcurr = rcurr + 1;			/* next request */
      386 		rlines = rlines + 1;
      387 parse_next:    end;
      388 	     call hcs_$terminate_noname (rptr, code);	/* ascii version no longer needed */
      389 	     if code ^= 0 then
      390 		call backup_map_$fs_error_line (code, "terminate_noname", rname, "");
      391 	     rcomp = rlines;			/* number of requests to fulfill first option */
      392 	end;
      393 	do i = 1 to rlines;				/* see if abbreviations were typed and get fuller names */
      394 	     if bk_ss_$sub_entry then
      395 		bk_ss_$no_primary = bk_ss_$control_ptr -> backup_control.no_primary_sw (i);
      396 	     if ^bk_ss_$no_primary then do;
      397 		call backup_util$get_real_name
      398 		     (addr (req.srch.name (i)), addr (req.srch.name (rcurr)), req.srch.len (rcurr), code);
      399 		if code > 1 & code ^= error_table_$noentry & code ^= error_table_$no_dir &
      400 		  code ^= error_table_$no_s_permission & code ^= error_table_$moderr &
      401 		  code ^= error_table_$no_info then do;
      402 		     bk_ss_$path_index = i;
      403 		     call backup_map_$fs_error_line (code, (bk_ss_$myname),
      404 			"get_real_name for "||req.srch.name (i), "");
      405 		     go to bad_p;
      406 		end;
      407 		else if code = 1 then do;		/* another name was generated */
      408 		     req.opt (rcurr) = req.opt (i);
      409 		     req.opt.synonym (rcurr) = "1"b;	/* indicate duplicate entry */
      410 		     req.srch.renamo (rcurr) = i;	/* point out original request */
      411 		     req.srch.control_index (rcurr) = req.srch.control_index (i);
      412 						/* index of backup_control entry for backup_load_ */
      413 		     req.srch.grt (rcurr) = req.srch.grt (i);  /* copy the original's > count */
      414 		     req.srch.name (rcurr) = substr (req.srch.name (rcurr), 1, req.srch.len (rcurr)) || ">";
      415 		     req.srch.len (rcurr) = req.srch.len (rcurr) + 1; /* ">" added for comparisons */
      416 		     rcurr = rcurr + 1;
      417 		     rlines = rlines + 1;
      418 		end;
      419 	     end;
      420 	     else code = 0;
      421 	     req.srch.name (i) = substr (req.srch.name (i), 1, req.srch.len (i)) || ">"; /* append ">" for comparisons */
      422 	     req.srch.len (i) = req.srch.len (i) + 1;	/* adjust size */
      423 	end;
      424 	rcurr = 0;				/* indicate no "current" request */
      425 	label_index = parsed;			/* proceed to load the tape */
      426 	go to exit;
      427 
      428 parsed_enough: call ioa_$rsnnl			/* here if too many requests for request table */
      429 	     ("^a: over 500 retrieval requests. Reload ended.", line, n, bk_ss_$myname);
      430 	call backup_map_$on_line (line_pointer, n);	/* print complaint */
      431 bad_p:	call hcs_$terminate_noname (rptr, code);	/* get rid of useless parsed data */
      432 	code = error_table_$arg_ignored;
      433 	rlines = 0;				/* say we don't have any requests */
      434 	label_index = terminate;			/* abort run */
      435 
      436 	return;
      437 
      438 
      439 count_grts: proc;
      440 
      441 	     req.newn.ngrt (ncurr) = 0;		/* prepare to count ">"s */
      442 	     if substr (line, j + 1, 1) = ">" then do;	/* see if dirname or entry name */
      443 		req.newn.ndname (ncurr) = substr (line, j + 1, n - j); /* save new dirname */
      444 		req.newn.ndlen (ncurr) = n - j;	/* ..and its length */
      445 		if ^bk_ss_$no_primary then call backup_util$get_real_name  /* use primary pathname */
      446 		     (addr (req.newn.ndname (ncurr)), addr (req.newn.ndname (ncurr)), req.newn.ndlen (ncurr), code);
      447 		else code = 0;
      448 		do k = 1 to req.newn.ndlen (ncurr);	/* count its ">"s */
      449 		     if addr (req.newn.ndname (ncurr)) -> rscan (k) = ">" then do;
      450 			req.newn.ngrt (ncurr) = req.newn.ngrt (ncurr) + 1;
      451 			l = k;			/* we need to know where the last one was */
      452 		     end;
      453 		end;
      454 		req.newn.nelen (ncurr) = req.newn.ndlen (ncurr) - l; /* split off and save entry name */
      455 	     end;
      456 	     else do;				/* store entry name */
      457 		req.newn.ndlen (ncurr) = 0;		/* no dirname */
      458 		req.newn.ndname (ncurr) = substr (line, j + 1, n - j);
      459 		req.newn.nelen (ncurr) = n - j;
      460 	     end;
      461 
      462 	end count_grts;
      463 
      464 
      465 see_stars: proc;
      466 
      467 	     if substr (req.srch.name (rcurr), n - 2, 3) = ">**" then do; /* hierarchy load is wanted */
      468 		req.opt.exact (rcurr) = ""b;		/* don't want exact match only */
      469 		substr (req.srch.name (rcurr), n - 2, 3) = ""; /* reset global indicator */
      470 		req.srch.len (rcurr) = n - 3;		/* lower length */
      471 		if req.opt.rename (rcurr) then do;	/* special rules for subtree renaming */
      472 		     l = 1;			/* prepare to count ">"s in search name */
      473 		     do k = 2 to req.srch.len (rcurr);	/* to check that request is not to change hierarchy level */
      474 			if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then l = l + 1;
      475 		     end;
      476 		end;
      477 	     end;
      478 	     else req.opt.exact (rcurr) = "1"b;		/* exact match is wanted */
      479 	     req.opt.found (rcurr), req.opt.finished (rcurr), req.opt.synonym (rcurr) = ""b;
      480 
      481 	end see_stars;
      482 
      483 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      484 
      485 
      486 /* Entry to prepare notification of what was accomplished */
      487 
      488 report_retrieval: entry;
      489 
      490 dcl  unsatisfied bit (1) aligned;
      491 
      492 	if rlines = 0 then go to exit;
      493 	if bk_ss_$sub_entry then go to reportend;
      494 	call hcs_$initiate_count (rdname, rename, "", rbc, 1, rptr, code);
      495 	if code ^= 0 & code ^= error_table_$segknown then do; /* cannot report if we can't access request file */
      496 	     call backup_map_$fs_error_line (code, "initiate", rdname, rename);
      497 	     go to reportend;
      498 	end;
      499 	rbc = divide (rbc, 9, 17, 0);			/* who knows if it changed? */
      500 	i, k = 1;					/* ascii index, request index */
      501 	unsatisfied = ""b;				/* Flags first unsatisfied request */
      502 
      503 next_req:	n = index (substr (rptr -> rmove, i, rbc), nl);	/* Look for next new line character */
      504 	if n ^= 0 then				/* Found one */
      505 	     if ^req.opt (k).found then do;		/* Was this request satisfied? */
      506 		if ^unsatisfied then do;		/* Was previous unsatisfied request found? */
      507 		     call ioa_ ("The following requests were not satisfied:"); /* NO! */
      508 		     unsatisfied = "1"b;		/* Mark unsatisfied request encountered */
      509 		end;
      510 
      511 		call ioa_ ("^a^/   Search name: ^a",
      512 		     substr (rptr -> rmove, i, n-1),
      513 		     substr (req.srch (k).name, 1, req.srch (k).len));
      514 	     end;
      515 
      516 	i = i + n;				/* Increment index to continue scan of request file */
      517 	k = k + 1;				/* Increment parsed request index */
      518 
      519 	if i < rbc then go to next_req;		/* Continue if more input */
      520 
      521 	call hcs_$terminate_noname (rptr, code);	/* get rid of ascii requests */
      522 reportend: call hcs_$truncate_seg (reqptr, 0, code);	/* get rid of parsed requests */
      523 exit:	return;
      524      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/00  1717.4  bk_retrieve.pl1                   >udd>sm>ds>w>ml>bk_retrieve.pl1
99           1    04/02/87  2106.7  bk_ss_.incl.pl1                   >ldd>incl>bk_ss_.incl.pl1
101          2    11/21/83  1319.2  backup_control.incl.pl1           >ldd>incl>backup_control.incl.pl1
103          3    04/29/76  1158.2  backup_preamble_header.incl.pl1   >ldd>incl>backup_preamble_header.incl.pl1
105          4    07/16/87  1855.4  backup_record_types.incl.pl1      >ldd>incl>backup_record_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_index                                parameter       fixed bin(17,0)          dcl 244 ref 242 246 248 249 249
a_hp                                   parameter       pointer                  dcl 33 ref 259 268 276
addr                                                   builtin function         dcl 83 ref 186 204 219 286 329 382 397 397 397 397
                                                                                  445 445 445 445 449 474
backup_control                         based           structure                level 1 dcl 2-8
backup_map_$fs_error_line       000260 constant        entry                    external dcl 85 ref 262 271 389 403 496
backup_map_$on_line             000262 constant        entry                    external dcl 85 ref 115 430
backup_util$get_real_name       000264 constant        entry                    external dcl 85 ref 397 445
bk_ss_$control_ptr              000306 external static pointer                  dcl 1-17 ref 162 312 315 317 324 332 334 394
bk_ss_$cross_retrievesw         000310 external static bit(1)                   dcl 1-17 set ref 178* 234*
bk_ss_$myname                   000312 external static char(16)                 packed unaligned dcl 1-17 set ref 114* 290* 296*
                                                                                  303* 357* 368* 403 428*
bk_ss_$no_primary               000314 external static bit(1)                   dcl 1-17 set ref 334* 394* 396 445
bk_ss_$onlysw                   000316 external static bit(1)                   dcl 1-17 ref 134 165
bk_ss_$path_index               000320 external static fixed bin(17,0)          dcl 1-17 set ref 158* 162 402*
bk_ss_$retrieval_index          000322 external static fixed bin(17,0)          dcl 1-17 set ref 157*
bk_ss_$sub_entry                000324 external static bit(1)                   dcl 1-17 ref 158 162 261 270 285 311 394 493
checked                         000225 internal static fixed bin(17,0)          dcl 47 set ref 235 284*
code                            000232 automatic       fixed bin(35,0)          dcl 27 set ref 288* 289 290* 294* 295 295 296* 301*
                                                                                  302 302 303* 388* 389 389* 397* 399 399 399 399
                                                                                  399 399 403* 407 420* 431* 432* 445* 447* 494* 495
                                                                                  495 496* 521* 522*
com_err_                        000300 constant        entry                    external dcl 95 ref 290 296 303 357 368
control_index          2024            based           fixed bin(17,0)          array level 3 dcl 55 set ref 158 321* 411* 411
divide                                                 builtin function         dcl 83 ref 346 499
dlen                                   based           fixed bin(17,0)          level 2 dcl 3-7 set ref 121* 122 123 185 191* 203
                                                                                  207 209* 209 214* 215 218 229* 230 232
dname                     1            based           char(168)                level 2 dcl 3-7 set ref 121 122 186 189* 189 204
                                                                                  207* 207 215* 219 222 230*
elen                     53            based           fixed bin(17,0)          level 2 dcl 3-7 set ref 124 125* 126 127 199* 231*
                                                                                  232
ename                    54            based           char(32)                 level 2 dcl 3-7 set ref 125 126 198* 232*
error_table_$arg_ignored        000254 external static fixed bin(35,0)          dcl 77 ref 432
error_table_$bad_string         000236 external static fixed bin(35,0)          dcl 77 set ref 368*
error_table_$badcall            000234 external static fixed bin(35,0)          dcl 77 set ref 262* 271*
error_table_$badpath            000240 external static fixed bin(35,0)          dcl 77 set ref 317 357*
error_table_$moderr             000250 external static fixed bin(35,0)          dcl 77 ref 399
error_table_$no_dir             000244 external static fixed bin(35,0)          dcl 77 ref 399
error_table_$no_info            000252 external static fixed bin(35,0)          dcl 77 ref 399
error_table_$no_s_permission    000246 external static fixed bin(35,0)          dcl 77 ref 399
error_table_$noentry            000242 external static fixed bin(35,0)          dcl 77 ref 399
error_table_$segknown           000256 external static fixed bin(35,0)          dcl 77 ref 295 302 495
exact                    52(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 55 set ref
                                                                                  143 166 176 248* 249* 341* 468* 478*
expand_pathname_                000266 constant        entry                    external dcl 85 ref 288
finished                 52(04)        based           bit(1)                   array level 3 packed packed unaligned dcl 55 set ref
                                                                                  135* 136* 142 168* 169* 173 479*
found                   165            based           bit(1)                   array level 3 in structure "backup_control" dcl 2-8
                                                                                  in procedure "bk_retrieve" set ref 162*
found                    52(03)        based           bit(1)                   array level 3 in structure "req" packed packed
                                                                                  unaligned dcl 55 in procedure "bk_retrieve" set
                                                                                  ref 134 160* 161* 479* 504
grt                    2023            based           fixed bin(17,0)          array level 3 dcl 55 set ref 181 331* 384* 413* 413
grt_count                       000234 automatic       fixed bin(17,0)          dcl 51 set ref 181* 188 206 221
h                                      based           structure                level 1 dcl 3-7
hcs_$initiate_count             000276 constant        entry                    external dcl 90 ref 294 494
hcs_$make_seg                   000270 constant        entry                    external dcl 90 ref 301
hcs_$terminate_noname           000272 constant        entry                    external dcl 90 ref 388 431 521
hcs_$truncate_seg               000274 constant        entry                    external dcl 90 ref 307 522
header                                 based           structure                level 2 dcl 2-8
hp                              000126 internal static pointer                  dcl 33 set ref 120 121 121 122 122 123 124 125 125
                                                                                  126 126 127 185 186 189 189 191 198 199 203 204
                                                                                  207 207 207 209 209 214 215 215 218 219 222 229
                                                                                  230 230 231 232 232 232 276*
htype                           000105 automatic       fixed bin(17,0)          dcl 27 set ref 120* 159 159 167 167 184 202
i                               000100 automatic       fixed bin(17,0)          dcl 27 set ref 130* 131 132 134 135 136 136 140* 141
                                                                                  142 143 144 144 148 149* 157 158 160 161 161 166
                                                                                  168 169 169 176 176 177 179 180 181 185* 186 189
                                                                                  191* 203* 204 207 207 209* 218* 219 222 224* 224*
                                                                                  309* 347 349 351 352 353* 393* 394 397 397 402 403
                                                                                  408 410 411 413 421 421 421 422 422* 500* 503 511
                                                                                  511 516* 516 519
index                                                  builtin function         dcl 83 ref 222 360 503
ioa_                            000302 constant        entry                    external dcl 95 ref 507 511
ioa_$rsnnl                      000304 constant        entry                    external dcl 95 ref 114 428
j                               000101 automatic       fixed bin(17,0)          dcl 27 set ref 182* 187* 187 188 205* 205 206 220*
                                                                                  220 221 327* 329* 329 331 335* 349* 349* 351 353
                                                                                  360* 361 367 372 373 377 380* 382* 382 384 442 443
                                                                                  443 444 458 458 459
k                               000102 automatic       fixed bin(17,0)          dcl 27 set ref 222* 223 224 328* 329* 352* 355 381*
                                                                                  382* 448* 449 451* 473* 474* 500* 504 511 511 511
                                                                                  511 517* 517
l                               000103 automatic       fixed bin(17,0)          dcl 27 set ref 451* 454 472* 474* 474
label_index                            parameter       fixed bin(17,0)          dcl 49 set ref 111 116* 154* 235* 259 264* 268 273*
                                                                                  304* 318* 425* 434*
len                    2022            based           fixed bin(17,0)          array level 3 dcl 55 set ref 132 144 149 323* 328
                                                                                  338 364* 373* 381 397* 414 415* 415 421 422* 422
                                                                                  470* 473 511 511
length                                                 builtin function         dcl 83 ref 121 125 323 333
line                            000010 internal static char(300)                packed unaligned dcl 33 set ref 114* 286 315* 316
                                                                                  322 323 323 332* 333 355* 356 357* 360 363 368*
                                                                                  372 428* 442 443 458
line_pointer                    000124 internal static pointer                  dcl 33 set ref 115* 286* 430*
n                               000104 automatic       fixed bin(17,0)          dcl 27 set ref 114* 115* 123* 126 127* 127 144 144
                                                                                  333* 338* 351* 354 355 363 364 367 377* 428* 430*
                                                                                  443 444 458 459 467 469 470 503* 504 511 511 516
name                   2026            based           char(168)                array level 3 dcl 55 set ref 131 144 148 322* 329
                                                                                  363* 372* 382 397 397 397 397 403 414* 414 421*
                                                                                  421 467 469* 474 511 511
ncurr                           000232 internal static fixed bin(17,0)          dcl 51 set ref 179* 180* 180 183 189 189 191 198 199
                                                                                  207 207 209 214 215 229 229 230 231 232 309* 326
                                                                                  337* 337 374 376* 376 441 443 444 445 445 445 445
                                                                                  445 448 449 450 450 454 454 457 458 459
ndc_directory                          constant        fixed bin(17,0)          initial dcl 4-20 ref 159 167
ndc_directory_list                     constant        fixed bin(17,0)          initial dcl 4-22 ref 184 202
ndlen                133702            based           fixed bin(17,0)          array level 3 dcl 55 set ref 183 207 209 214 229
                                                                                  444* 445* 448 454 457*
ndname               133705            based           char(168)                array level 3 dcl 55 set ref 189 198 207 215 230 232
                                                                                  443* 445 445 445 445 449 458*
nelen                133703            based           fixed bin(17,0)          array level 3 dcl 55 set ref 189 191 199 229 231
                                                                                  454* 459*
new_path                112            based           char(168)                array level 3 packed packed unaligned dcl 2-8 ref
                                                                                  324 332
newn                 133702            based           structure                array level 2 dcl 55
next                            000221 internal static fixed bin(17,0)          dcl 47 set ref 154 280*
ngrt                 133704            based           fixed bin(17,0)          array level 3 dcl 55 set ref 441* 450* 450
nl                              000130 internal static char(1)                  packed unaligned dcl 38 set ref 277* 349 503
no_primary_sw           164            based           bit(1)                   array level 4 packed packed unaligned dcl 2-8 ref
                                                                                  334 394
old_dname                       000160 automatic       char(168)                initial packed unaligned dcl 27 set ref 27*
opt                      52            based           structure                array level 2 dcl 55 set ref 408* 408
parsed                          000220 internal static fixed bin(17,0)          dcl 47 set ref 279* 425
path                     40            based           char(168)                array level 3 packed packed unaligned dcl 2-8 ref
                                                                                  315
path_copy                              based           char(168)                level 2 dcl 55 set ref 131* 132 148* 149
path_name                       000106 automatic       char(168)                packed unaligned dcl 27 set ref 122* 126* 132 144
                                                                                  149
rbc                             000233 automatic       fixed bin(17,0)          dcl 40 set ref 294* 346* 346 347 349 494* 499* 499
                                                                                  503 519
rcomp                           000230 internal static fixed bin(17,0)          dcl 51 set ref 113 312* 391*
rcurr                           000231 internal static fixed bin(17,0)          dcl 51 set ref 129 130 141 153* 173 173 173* 176*
                                                                                  246* 309* 314* 315 317 321 321 322 323 324 325 326
                                                                                  328 329 331 332 334 338 340 341* 362 363 364 371
                                                                                  372 373 374 381 382 384 385* 385 397 397 397 408
                                                                                  409 410 411 413 414 414 414 415 415 416* 416 424*
                                                                                  467 468 469 470 471 473 474 478 479 479 479
rdname                          000131 internal static char(168)                dcl 40 set ref 288* 294* 296* 494* 496*
record_type              65            based           fixed bin(17,0)          level 2 dcl 3-7 ref 120
rename                   52            based           bit(1)                   array level 3 in structure "req" packed packed
                                                                                  unaligned dcl 55 in procedure "bk_retrieve" set
                                                                                  ref 177 325* 340* 362* 371* 471
rename                          000203 internal static char(32)                 dcl 40 in procedure "bk_retrieve" set ref 288* 294*
                                                                                  296* 494* 496*
renamo                 2025            based           fixed bin(17,0)          array level 3 dcl 55 set ref 136 161 169 179 180 249
                                                                                  326* 374* 410*
reported                        000224 internal static fixed bin(17,0)          dcl 47 set ref 283* 304
req                                    based           structure                level 1 dcl 55
reqptr                          000216 internal static pointer                  dcl 45 set ref 131 131 132 132 134 135 136 136 136
                                                                                  142 143 144 144 148 148 149 149 158 160 161 161
                                                                                  161 166 168 169 169 169 173 176 177 179 180 180
                                                                                  181 183 189 189 191 198 199 207 207 209 214 215
                                                                                  229 229 230 231 232 248 249 249 249 301* 307* 321
                                                                                  322 323 325 326 328 329 331 338 340 341 362 363
                                                                                  364 371 372 373 374 381 382 384 397 397 397 397
                                                                                  397 403 408 408 409 410 411 411 413 413 414 414
                                                                                  414 415 415 421 421 421 422 422 441 443 444 445
                                                                                  445 445 445 445 448 449 450 450 454 454 457 458
                                                                                  459 467 468 469 470 471 473 474 478 479 479 479
                                                                                  504 511 511 511 511 522*
request_count            37            based           fixed bin(17,0)          level 3 dcl 2-8 ref 312
requests                 40            based           structure                array level 2 dcl 2-8
reverse                                                builtin function         dcl 83 ref 323
rfin                            000227 internal static fixed bin(17,0)          dcl 51 set ref 113 137* 137 170* 170 278*
rlines                          000226 internal static fixed bin(17,0)          dcl 51 set ref 140 278* 312* 313 314 348 386* 386
                                                                                  391 393 417* 417 433* 492
rmove                                  based           char(1000000)            packed unaligned dcl 74 ref 355 503 511 511
rname                                  parameter       char(168)                dcl 40 set ref 259 288 288 290* 389*
rptr                            000214 internal static pointer                  dcl 45 set ref 294* 349 355 388* 431* 494* 503 511
                                                                                  511 521*
rscan                                  based           char(1)                  array packed unaligned dcl 74 ref 186 204 219 329
                                                                                  349 382 449 474
rsize                                  parameter       fixed bin(17,0)          dcl 40 ref 259 288 288
rtrim                                                  builtin function         dcl 83 ref 121 125 333
sec_dir                                constant        fixed bin(17,0)          initial dcl 4-26 ref 159 167
srch                   2022            based           structure                array level 2 dcl 55
status_code             167            based           fixed bin(35,0)          array level 3 dcl 2-8 set ref 317*
stop                            000222 internal static fixed bin(17,0)          dcl 47 set ref 116 281*
substr                                                 builtin function         dcl 83 set ref 122 126* 126 132 144 149 189 189 207
                                                                                  207 215 222 230 232 288 288 316 355 356 363 372
                                                                                  414 421 442 443 458 467 469* 503 511 511 511 511
switches                164            based           structure                array level 3 dcl 2-8
synonym                  52(02)        based           bit(1)                   array level 3 packed packed unaligned dcl 55 set ref
                                                                                  136 161 169 180 249 409* 479*
terminate                       000223 internal static fixed bin(17,0)          dcl 47 set ref 264 273 282* 318 434
unsatisfied                     000235 automatic       bit(1)                   dcl 490 set ref 501* 506 508*
unspec                                                 builtin function         dcl 83 set ref 277*
verify                                                 builtin function         dcl 83 ref 323

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BACKUP_CONTROL_VERSION_5               internal static char(8)                  initial packed unaligned dcl 2-60
RECORD_TYPE                            internal static char(10)                 initial array dcl 4-29
author                                 based           char(32)                 dcl 3-61
backup_control_ptr                     automatic       pointer                  dcl 2-56
backup_control_request_count           automatic       fixed bin(17,0)          dcl 2-58
baseptr                                                builtin function         dcl 83
bk_ss_$allow_dir_overwrite             external static bit(1)                   dcl 1-17
bk_ss_$areap                           external static pointer                  dcl 1-17
bk_ss_$brief_mapsw                     external static bit(1)                   dcl 1-17
bk_ss_$caller_handles_conditions       external static bit(1)                   dcl 1-17
bk_ss_$check_effective_access          external static bit(1)                   dcl 1-17
bk_ss_$control_name                    external static char(168)                packed unaligned dcl 1-17
bk_ss_$data_iocb                       external static pointer                  dcl 1-17
bk_ss_$date                            external static fixed bin(52,0)          dcl 1-17
bk_ss_$datesw                          external static bit(1)                   dcl 1-17
bk_ss_$debugsw                         external static bit(1)                   dcl 1-17
bk_ss_$dir_trim                        external static bit(1)                   dcl 1-17
bk_ss_$dont_dump_upgraded_dirs         external static bit(1)                   dcl 1-17
bk_ss_$dprint_destination              external static char(24)                 packed unaligned dcl 1-17
bk_ss_$dprint_destination_setsw        external static bit(1)                   dcl 1-17
bk_ss_$dprint_heading                  external static char(64)                 packed unaligned dcl 1-17
bk_ss_$dprint_heading_setsw            external static bit(1)                   dcl 1-17
bk_ss_$dprint_queue                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$dprint_request_type             external static char(24)                 packed unaligned dcl 1-17
bk_ss_$dprint_request_type_setsw       external static bit(1)                   dcl 1-17
bk_ss_$dprintsw                        external static bit(1)                   dcl 1-17
bk_ss_$dtdsw                           external static bit(1)                   dcl 1-17
bk_ss_$ename                           external static char(32)                 dcl 1-17
bk_ss_$enforce_max_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_min_access_class        external static bit(1)                   dcl 1-17
bk_ss_$enforce_minimum_ring            external static bit(1)                   dcl 1-17
bk_ss_$err_label                       external static label variable           dcl 1-17
bk_ss_$err_onlinesw                    external static bit(1)                   dcl 1-17
bk_ss_$error                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$holdsw                          external static bit(1)                   dcl 1-17
bk_ss_$hp                              external static pointer                  dcl 1-17
bk_ss_$ignore_dates                    external static bit(1)                   dcl 1-17
bk_ss_$mapsw                           external static bit(1)                   dcl 1-17
bk_ss_$maximum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$maximum_dir_access_class        external static bit(72)                  dcl 1-17
bk_ss_$minimum_access_class            external static bit(72)                  dcl 1-17
bk_ss_$minimum_ring                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$namesw                          external static bit(1)                   dcl 1-17
bk_ss_$no_contin                       external static bit(1)                   dcl 1-17
bk_ss_$no_output                       external static bit(1)                   dcl 1-17
bk_ss_$no_reload                       external static bit(1)                   dcl 1-17
bk_ss_$no_setlvid                      external static bit(1)                   dcl 1-17
bk_ss_$ntapes                          external static fixed bin(17,0)          dcl 1-17
bk_ss_$operator                        external static char(32)                 packed unaligned dcl 1-17
bk_ss_$pathsw                          external static bit(1)                   dcl 1-17
bk_ss_$preattached                     external static bit(1)                   dcl 1-17
bk_ss_$pvname                          external static char(32)                 dcl 1-17
bk_ss_$pvsw                            external static bit(1)                   dcl 1-17
bk_ss_$qchecksw                        external static bit(1)                   dcl 1-17
bk_ss_$quotasw                         external static bit(1)                   dcl 1-17
bk_ss_$restart_dumpsw                  external static bit(1)                   dcl 1-17
bk_ss_$restart_path                    external static char(168)                dcl 1-17
bk_ss_$restart_plen                    external static fixed bin(17,0)          dcl 1-17
bk_ss_$restore_access_class            external static bit(1)                   dcl 1-17
bk_ss_$retrievesw                      external static bit(1)                   dcl 1-17
bk_ss_$rlen                            external static fixed bin(17,0)          dcl 1-17
bk_ss_$rname                           external static char(168)                packed unaligned dcl 1-17
bk_ss_$rsize                           external static fixed bin(17,0)          dcl 1-17
bk_ss_$save_path                       external static char(168)                packed unaligned dcl 1-17
bk_ss_$save_plen                       external static fixed bin(17,0)          dcl 1-17
bk_ss_$save_time                       external static fixed bin(52,0)          dcl 1-17
bk_ss_$segptr                          external static pointer                  dcl 1-17
bk_ss_$set_dtd                         external static bit(1)                   dcl 1-17
bk_ss_$set_dtd_explicit                external static bit(1)                   dcl 1-17
bk_ss_$source_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$sp                              external static pointer                  dcl 1-17
bk_ss_$sub_entry_errfile               external static bit(1)                   dcl 1-17
bk_ss_$tapesw                          external static bit(1)                   dcl 1-17
bk_ss_$target_attributes_ptr           external static pointer                  dcl 1-17
bk_ss_$translate_access_class          external static bit(1)                   dcl 1-17
bk_ss_$trimsw                          external static bit(1)                   dcl 1-17
bk_ss_$upgrade_to_user_auth            external static bit(1)                   dcl 1-17
bk_ss_$user_authorization              external static bit(72)                  dcl 1-17
bk_ss_$user_id                         external static char(32)                 packed unaligned dcl 1-17
bk_ss_$user_ring                       external static fixed bin(17,0)          dcl 1-17
bk_ss_$volume_set_name                 external static char(32)                 packed unaligned dcl 1-17
bk_ss_$wakeup_interval                 external static fixed bin(52,0)          dcl 1-17
bk_ss_$wasnt_known                     external static bit(1)                   dcl 1-17
bk_ss_$writing_map                     external static bit(1)                   dcl 1-17
error_table_$smallarg                  external static fixed bin(35,0)          dcl 77
fixed                                                  builtin function         dcl 83
ndc_segment                            internal static fixed bin(17,0)          initial dcl 4-18
rset                                   based           bit(6)                   packed unaligned dcl 74
sec_seg                                internal static fixed bin(17,0)          initial dcl 4-24

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          001372 constant        label                    dcl 276 ref 266
bad_p                           003023 constant        label                    dcl 431 ref 358 369 405
bk_retrieve                     000215 constant        entry                    external dcl 13
check_retrieval                 000227 constant        entry                    external dcl 111
count_grts                      003341 constant        entry                    internal dcl 439 ref 336 375
dironly                         001054 constant        label                    dcl 214 ref 223
exit                            003340 constant        label                    dcl 523 ref 117 155 236 305 319 426 492
flag_msf                        001205 constant        entry                    external dcl 242
match                           000523 constant        label                    dcl 157 ref 132 144 149
next_req                        003164 constant        label                    dcl 503 ref 519
next_test                       000514 constant        label                    dcl 152 ref 141 142
parse_next                      002442 constant        label                    dcl 387 ref 354
parse_retrieval_control         001237 constant        entry                    external dcl 259
parse_structure                 001317 constant        entry                    external dcl 268
parsed_enough                   002763 constant        label                    dcl 428 ref 313 348
partial                         001004 constant        label                    dcl 207 ref 225
renamed                         001175 constant        label                    dcl 233 ref 192 196 200 210 216
report_retrieval                003044 constant        entry                    external dcl 488
reported_exit                   001706 constant        label                    dcl 304 ref 291 297
reportend                       003324 constant        label                    dcl 522 ref 493 497
see_stars                       003476 constant        entry                    internal dcl 465 ref 379

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4176        4524    3607        4206
Length      5162    3607       326         422     366         224

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bk_retrieve                         356 external procedure  is an external procedure.  
count_grts                              internal procedure  shares stack frame of external procedure bk_retrieve.  
see_stars                               internal procedure  shares stack frame of external procedure bk_retrieve.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 line                        bk_retrieve
000124 line_pointer                bk_retrieve
000126 hp                          bk_retrieve
000130 nl                          bk_retrieve
000131 rdname                      bk_retrieve
000203 rename                      bk_retrieve
000214 rptr                        bk_retrieve
000216 reqptr                      bk_retrieve
000220 parsed                      bk_retrieve
000221 next                        bk_retrieve
000222 stop                        bk_retrieve
000223 terminate                   bk_retrieve
000224 reported                    bk_retrieve
000225 checked                     bk_retrieve
000226 rlines                      bk_retrieve
000227 rfin                        bk_retrieve
000230 rcomp                       bk_retrieve
000231 rcurr                       bk_retrieve
000232 ncurr                       bk_retrieve

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bk_retrieve              000100 i                           bk_retrieve
                         000101 j                           bk_retrieve
                         000102 k                           bk_retrieve
                         000103 l                           bk_retrieve
                         000104 n                           bk_retrieve
                         000105 htype                       bk_retrieve
                         000106 path_name                   bk_retrieve
                         000160 old_dname                   bk_retrieve
                         000232 code                        bk_retrieve
                         000233 rbc                         bk_retrieve
                         000234 grt_count                   bk_retrieve
                         000235 unsatisfied                 bk_retrieve

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
backup_map_$fs_error_line     backup_map_$on_line           backup_util$get_real_name     com_err_
expand_pathname_              hcs_$initiate_count           hcs_$make_seg                 hcs_$terminate_noname
hcs_$truncate_seg             ioa_                          ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$control_ptr            bk_ss_$cross_retrievesw       bk_ss_$myname                 bk_ss_$no_primary
bk_ss_$onlysw                 bk_ss_$path_index             bk_ss_$retrieval_index        bk_ss_$sub_entry
error_table_$arg_ignored      error_table_$bad_string       error_table_$badcall          error_table_$badpath
error_table_$moderr           error_table_$no_dir           error_table_$no_info          error_table_$no_s_permission
error_table_$noentry          error_table_$segknown


CONSTANTS
003601  aa     677777777777

003602  aa     757777777777

003603  aa     737777777777

003604  aa     377777777777

003605  aa     577777777777


000000  aa  040 040 040 000	   

000001  aa  076 052 052 000	>**

000002  aa     524000000026

000003  aa     524000000052

000004  aa     524000000010

000005  aa     524000000056

000006  aa     524000000272

000007  aa     524000000020

000010  aa     404000000005

000011  aa     524000000021

000012  aa     524000000005

000013  aa     404000000002

000014  aa     524000000040

000015  aa     524000000062

000016  aa     524000000000

000017  aa     524000000105

000020  aa     524000000043

000021  aa     404000000043

003606  aa  076 000 000 000	>

000022  aa     526000000020

000023  aa     526000000454

000024  aa     524000000033

000025  aa     404000000021

000026  aa     524000000250

000027  aa     464000000000

000030  aa  151 156 151 164	init
000031  aa  151 141 164 145	iate

000032  aa  136 141 076 136	^a>^
000033  aa  141 000 000 000	a

000034  aa  164 145 162 155	term
000035  aa  151 156 141 164	inat
000036  aa  145 137 156 157	e_no
000037  aa  156 141 155 145	name

000040  aa  163 145 141 162	sear
000041  aa  143 150 040 141	ch a
000042  aa  162 147 040 157	rg o
000043  aa  146 040 136 141	f ^a

000044  aa  147 145 164 137	get_
000045  aa  162 145 141 154	real
000046  aa  137 156 141 155	_nam
000047  aa  145 040 146 157	e fo
000050  aa  162 040 000 000	r 

000051  aa  156 157 040 156	no n
000052  aa  145 167 040 156	ew n
000053  aa  141 155 145 040	ame 
000054  aa  151 156 040 136	in ^
000055  aa  141 000 000 000	a

000056  aa  162 145 164 162	retr
000057  aa  151 145 166 141	ieva
000060  aa  154 137 143 157	l_co
000061  aa  156 164 162 157	ntro
000062  aa  154 000 000 000	l

000063  aa  136 141 136 057	^a^/
000064  aa  040 040 040 123	   S
000065  aa  145 141 162 143	earc
000066  aa  150 040 156 141	h na
000067  aa  155 145 072 040	me: 
000070  aa  136 141 000 000	^a

000071  aa  142 153 137 162	bk_r
000072  aa  145 164 162 151	etri
000073  aa  145 166 145 044	eve$
000074  aa  160 141 162 163	pars
000075  aa  145 137 163 164	e_st
000076  aa  162 165 143 164	ruct
000077  aa  165 162 145 000	ure

000100  aa  136 141 072 040	^a: 
000101  aa  141 154 154 040	all 
000102  aa  162 145 161 165	requ
000103  aa  145 163 164 163	ests
000104  aa  040 163 141 164	 sat
000105  aa  151 163 146 151	isfi
000106  aa  145 144 056 000	ed.

000107  aa  142 153 137 162	bk_r
000110  aa  145 164 162 151	etri
000111  aa  145 166 145 044	eve$
000112  aa  160 141 162 163	pars
000113  aa  145 137 162 145	e_re
000114  aa  164 162 151 145	trie
000115  aa  166 141 154 137	val_
000116  aa  143 157 156 164	cont
000117  aa  162 157 154 000	rol

000120  aa  124 150 145 040	The 
000121  aa  146 157 154 154	foll
000122  aa  157 167 151 156	owin
000123  aa  147 040 162 145	g re
000124  aa  161 165 145 163	ques
000125  aa  164 163 040 167	ts w
000126  aa  145 162 145 040	ere 
000127  aa  156 157 164 040	not 
000130  aa  163 141 164 151	sati
000131  aa  163 146 151 145	sfie
000132  aa  144 072 000 000	d:

000133  aa  136 141 072 040	^a: 
000134  aa  157 166 145 162	over
000135  aa  040 065 060 060	 500
000136  aa  040 162 145 164	 ret
000137  aa  162 151 145 166	riev
000140  aa  141 154 040 162	al r
000141  aa  145 161 165 145	eque
000142  aa  163 164 163 056	sts.
000143  aa  040 122 145 154	 Rel
000144  aa  157 141 144 040	oad 
000145  aa  145 156 144 145	ende
000146  aa  144 056 000 000	d.

000147  aa  136 057 124 150	^/Th
000150  aa  151 163 040 145	is e
000151  aa  156 164 162 171	ntry
000152  aa  040 160 157 151	 poi
000153  aa  156 164 040 155	nt m
000154  aa  165 163 164 040	ust 
000155  aa  142 145 040 143	be c
000156  aa  141 154 154 145	alle
000157  aa  144 040 166 151	d vi
000160  aa  141 040 142 141	a ba
000161  aa  143 153 165 160	ckup
000162  aa  137 154 157 141	_loa
000163  aa  144 137 000 000	d_

000164  aa  136 057 124 150	^/Th
000165  aa  151 163 040 145	is e
000166  aa  156 164 162 171	ntry
000167  aa  040 160 157 151	 poi
000170  aa  156 164 040 155	nt m
000171  aa  165 163 164 040	ust 
000172  aa  142 145 040 143	be c
000173  aa  141 154 154 145	alle
000174  aa  144 040 166 151	d vi
000175  aa  141 040 142 141	a ba
000176  aa  143 153 165 160	ckup
000177  aa  137 154 157 141	_loa
000200  aa  144 054 040 162	d, r
000201  aa  145 154 157 141	eloa
000202  aa  144 040 157 162	d or
000203  aa  040 162 145 164	 ret
000204  aa  162 151 145 166	riev
000205  aa  145 000 000 000	e

BEGIN PROCEDURE bk_retrieve
PROLOGUE SEQUENCE
000206  aa  6 00273 4401 00	sxl0 	pr6|187
						STATEMENT 1 ON LINE 27
000207  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000210  aa   000000 00 0000	desc9a	0,0
000211  aa  6 00160 00 0250	desc9a	pr6|112,168	old_dname
000212  aa  6 00273 7201 00	lxl0 	pr6|187
000213  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO bk_retrieve                                        STATEMENT 1 ON LINE 13
bk_retrieve: proc;

000214  da     000315200000
000215  aa   000560 6270 00	eax7 	368
000216  aa  7 00034 3521 20	epp2 	pr7|28,*
000217  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000220  aa     000000000000
000221  aa     000000000000
000222  aa   777764 7000 04	tsx0 	-12,ic		000206
						STATEMENT 1 ON LINE 111
check_retrieval: entry (label_index);

000223  aa   000015 7100 04	tra  	13,ic		000240
ENTRY TO check_retrieval                                    STATEMENT 1 ON LINE 111
check_retrieval: entry (label_index);

000224  at     000001000025
000225  ta     000224000000
000226  da     000324300000
000227  aa   000560 6270 00	eax7 	368
000230  aa  7 00034 3521 20	epp2 	pr7|28,*
000231  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000232  aa     000002000000
000233  aa     000000000000
000234  aa  6 00032 3735 20	epp7 	pr6|26,*
000235  aa  7 00002 3715 20	epp5 	pr7|2,*
000236  aa  6 00240 6515 00	spri5	pr6|160
000237  aa   777747 7000 04	tsx0 	-25,ic		000206
						STATEMENT 1 ON LINE 113
	if rfin = rcomp then do;

000240  aa  6 00044 3701 20	epp4 	pr6|36,*
000241  ia  4 00227 2361 00	ldq  	pr4|151		rfin
000242  ia  4 00230 1161 00	cmpq 	pr4|152		rcomp
000243  aa   000045 6010 04	tnz  	37,ic		000310
						STATEMENT 1 ON LINE 114
	     call ioa_$rsnnl ("^a: all requests satisfied.", line, n, bk_ss_$myname);

000244  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000245  aa   777634 00 0034	desc9a	-100,28		000100 = 136141072040
000246  aa  6 00274 00 0034	desc9a	pr6|188,28
000247  aa  6 00274 3521 00	epp2 	pr6|188
000250  aa  6 00306 2521 00	spri2	pr6|198
000251  ia  4 00010 3521 00	epp2 	pr4|8		line
000252  aa  6 00310 2521 00	spri2	pr6|200
000253  aa  6 00104 3521 00	epp2 	pr6|68		n
000254  aa  6 00312 2521 00	spri2	pr6|202
000255  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
000256  aa  6 00314 2521 00	spri2	pr6|204
000257  aa   777545 3520 04	epp2 	-155,ic		000024 = 524000000033
000260  aa  6 00316 2521 00	spri2	pr6|206
000261  aa   777542 3520 04	epp2 	-158,ic		000023 = 526000000454
000262  aa  6 00320 2521 00	spri2	pr6|208
000263  aa   777542 3520 04	epp2 	-158,ic		000025 = 404000000021
000264  aa  6 00322 2521 00	spri2	pr6|210
000265  aa   777535 3520 04	epp2 	-163,ic		000022 = 526000000020
000266  aa  6 00324 2521 00	spri2	pr6|212
000267  aa  6 00304 6211 00	eax1 	pr6|196
000270  aa   020000 4310 07	fld  	8192,dl
000271  la  4 00304 3521 20	epp2 	pr4|196,*		ioa_$rsnnl
000272  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 115
	     call backup_map_$on_line (line_pointer, n);

000273  aa  6 00044 3701 20	epp4 	pr6|36,*
000274  ia  4 00124 3521 00	epp2 	pr4|84		line_pointer
000275  aa  6 00276 2521 00	spri2	pr6|190
000276  aa  6 00104 3521 00	epp2 	pr6|68		n
000277  aa  6 00300 2521 00	spri2	pr6|192
000300  aa  6 00274 6211 00	eax1 	pr6|188
000301  aa   010000 4310 07	fld  	4096,dl
000302  la  4 00262 3521 20	epp2 	pr4|178,*		backup_map_$on_line
000303  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 116
	     label_index = stop;

000304  aa  6 00044 3701 20	epp4 	pr6|36,*
000305  ia  4 00222 2361 00	ldq  	pr4|146		stop
000306  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 117
	     go to exit;

000307  aa   003031 7100 04	tra  	1561,ic		003340
						STATEMENT 1 ON LINE 118
	end;

						STATEMENT 1 ON LINE 120
	htype = hp -> h.record_type;

000310  ia  4 00126 3735 20	epp7 	pr4|86,*		hp
000311  aa  7 00065 2361 00	ldq  	pr7|53		h.record_type
000312  aa  6 00105 7561 00	stq  	pr6|69		htype
						STATEMENT 1 ON LINE 121
	hp -> h.dlen = length (rtrim (hp -> h.dname));

000313  aa  000 000 165 500	tctr 	(pr)
000314  aa  7 00001 00 0250	desc9a	pr7|1,168		h.dname
000315  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000316  aa  6 00056 0001 00	arg  	pr6|46
000317  aa  6 00056 2361 00	ldq  	pr6|46
000320  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000321  aa  6 00303 7561 00	stq  	pr6|195
000322  aa   000250 2360 07	ldq  	168,dl
000323  aa  6 00303 1761 00	sbq  	pr6|195
000324  aa  7 00000 7561 00	stq  	pr7|0		h.dlen
						STATEMENT 1 ON LINE 122
	path_name = substr (hp -> h.dname, 1, hp -> h.dlen) || ">";

000325  aa   000001 0760 07	adq  	1,dl
000326  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000327  aa  7 00000 7271 00	lxl7 	pr7|0		h.dlen
000330  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000331  aa  7 00001 00 0017	desc9a	pr7|1,x7		h.dname
000332  aa  2 00000 00 0017	desc9a	pr2|0,x7
000333  aa  040 117 100 404	mlr  	(ic),(pr,x7),fill(040)
000334  aa   003253 00 0001	desc9a	1707,1		003606 = 076000000000
000335  aa  2 00000 00 0001	desc9a	pr2|0,1
000336  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000337  aa  2 00000 00 0006	desc9a	pr2|0,ql
000340  aa  6 00106 00 0250	desc9a	pr6|70,168	path_name
						STATEMENT 1 ON LINE 123
	n = hp -> h.dlen + 1;

000341  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000342  aa  7 00000 2361 00	ldq  	pr7|0		h.dlen
000343  aa   000001 0760 07	adq  	1,dl
000344  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 124
	if hp -> h.elen ^= 0 then do;

000345  aa  7 00053 2361 00	ldq  	pr7|43		h.elen
000346  aa   000041 6000 04	tze  	33,ic		000407
						STATEMENT 1 ON LINE 125
	     hp -> h.elen = length (rtrim (hp -> h.ename));

000347  aa  000 000 165 500	tctr 	(pr)
000350  aa  7 00054 00 0040	desc9a	pr7|44,32		h.ename
000351  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000352  aa  6 00056 0001 00	arg  	pr6|46
000353  aa  6 00056 2361 00	ldq  	pr6|46
000354  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000355  aa  6 00303 7561 00	stq  	pr6|195
000356  aa   000040 2360 07	ldq  	32,dl
000357  aa  6 00303 1761 00	sbq  	pr6|195
000360  aa  7 00053 7561 00	stq  	pr7|43		h.elen
						STATEMENT 1 ON LINE 126
	     substr (path_name, n + 1) = substr (hp -> h.ename, 1, hp -> h.elen) || ">";

000361  aa   000250 2360 07	ldq  	168,dl
000362  aa  6 00104 1761 00	sbq  	pr6|68		n
000363  aa   000000 6240 06	eax4 	0,ql
000364  aa  7 00053 2361 00	ldq  	pr7|43		h.elen
000365  aa   000001 0760 07	adq  	1,dl
000366  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000367  aa  7 00053 7261 00	lxl6 	pr7|43		h.elen
000370  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000371  aa  7 00054 00 0016	desc9a	pr7|44,x6		h.ename
000372  aa  2 00000 00 0016	desc9a	pr2|0,x6
000373  aa  040 116 100 404	mlr  	(ic),(pr,x6),fill(040)
000374  aa   003213 00 0001	desc9a	1675,1		003606 = 076000000000
000375  aa  2 00000 00 0001	desc9a	pr2|0,1
000376  aa  6 00104 7251 00	lxl5 	pr6|68		n
000377  aa  040 155 100 540	mlr  	(pr,rl),(pr,rl,x5),fill(040)
000400  aa  2 00000 00 0006	desc9a	pr2|0,ql
000401  aa  6 00106 00 0014	desc9a	pr6|70,x4		path_name
						STATEMENT 1 ON LINE 127
	     n = n + hp -> h.elen + 1;

000402  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000403  aa  6 00104 2361 00	ldq  	pr6|68		n
000404  aa  7 00053 0761 00	adq  	pr7|43		h.elen
000405  aa   000001 0760 07	adq  	1,dl
000406  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 128
	end;

						STATEMENT 1 ON LINE 129
	if rcurr ^= 0 then do;

000407  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
000410  aa   000035 6000 04	tze  	29,ic		000445
						STATEMENT 1 ON LINE 130
	     i = rcurr;

000411  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 131
	     req.path_copy = req.srch.name (i);

000412  aa   000056 4020 07	mpy  	46,dl
000413  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
000414  aa  5 01750 3535 06	epp3 	pr5|1000,ql	req.name
000415  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000416  aa  3 00000 00 0250	desc9a	pr3|0,168		req.name
000417  aa  5 00000 00 0250	desc9a	pr5|0,168		req.path_copy
						STATEMENT 1 ON LINE 132
	     if substr (path_name, 1, req.srch.len (i)) = req.path_copy then
		go to match;

000420  aa  5 01744 7261 06	lxl6 	pr5|996,ql	req.len
000421  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
000422  aa  6 00106 00 0016	desc9a	pr6|70,x6		path_name
000423  aa  5 00000 00 0250	desc9a	pr5|0,168		req.path_copy
000424  aa   000077 6000 04	tze  	63,ic		000523
						STATEMENT 1 ON LINE 134
	     if bk_ss_$onlysw & req.opt.found (i) then do;

000425  aa  6 00303 7561 00	stq  	pr6|195
000426  la  4 00316 2351 20	lda  	pr4|206,*		bk_ss_$onlysw
000427  aa   000016 6000 04	tze  	14,ic		000445
000430  aa  6 00100 7251 00	lxl5 	pr6|64		i
000431  aa  5 00051 2351 15	lda  	pr5|41,5		req.found
000432  aa   040000 3150 03	cana 	16384,du
000433  aa   000012 6000 04	tze  	10,ic		000445
						STATEMENT 1 ON LINE 135
		req.opt.finished (i) = "1"b;

000434  aa   020000 2350 03	lda  	8192,du
000435  aa  5 00051 2551 15	orsa 	pr5|41,5		req.finished
						STATEMENT 1 ON LINE 136
		if req.opt.synonym (i) then req.opt.finished (req.srch.renamo (i)) = "1"b;

000436  aa  5 00051 2351 15	lda  	pr5|41,5		req.synonym
000437  aa   100000 3150 03	cana 	32768,du
000440  aa   000004 6000 04	tze  	4,ic		000444
000441  aa   020000 2350 03	lda  	8192,du
000442  aa  5 01747 7241 06	lxl4 	pr5|999,ql	req.renamo
000443  aa  5 00051 2551 14	orsa 	pr5|41,4		req.finished
						STATEMENT 1 ON LINE 137
		rfin = rfin + 1;

000444  ia  4 00227 0541 00	aos  	pr4|151		rfin
						STATEMENT 1 ON LINE 138
	     end;

						STATEMENT 1 ON LINE 139
	end;

						STATEMENT 1 ON LINE 140
	do i = 1 to rlines;

000445  ia  4 00226 2361 00	ldq  	pr4|150		rlines
000446  aa  6 00242 7561 00	stq  	pr6|162
000447  aa   000001 2360 07	ldq  	1,dl
000450  aa  6 00100 7561 00	stq  	pr6|64		i
000451  aa   000000 0110 03	nop  	0,du
000452  aa  6 00100 2361 00	ldq  	pr6|64		i
000453  aa  6 00242 1161 00	cmpq 	pr6|162
000454  aa   000042 6054 04	tpnz 	34,ic		000516
						STATEMENT 1 ON LINE 141
	     if i = rcurr then go to next_test;

000455  aa  6 00044 3701 20	epp4 	pr6|36,*
000456  ia  4 00231 1161 00	cmpq 	pr4|153		rcurr
000457  aa   000035 6000 04	tze  	29,ic		000514
						STATEMENT 1 ON LINE 142
	     if req.opt.finished (i) then go to next_test;

000460  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
000461  aa  7 00051 2351 06	lda  	pr7|41,ql		req.finished
000462  aa   020000 3150 03	cana 	8192,du
000463  aa   000031 6010 04	tnz  	25,ic		000514
						STATEMENT 1 ON LINE 143
	     if req.opt.exact (i) then do;

000464  aa  7 00051 2351 06	lda  	pr7|41,ql		req.exact
000465  aa   200000 3150 03	cana 	65536,du
000466  aa   000014 6000 04	tze  	12,ic		000502
						STATEMENT 1 ON LINE 144
		if n = req.srch.len (i) & substr (path_name, 1, n) = req.srch.name (i) then
		     go to match;

000467  aa   000056 4020 07	mpy  	46,dl
000470  aa   000000 6270 06	eax7 	0,ql
000471  aa  6 00104 2361 00	ldq  	pr6|68		n
000472  aa  7 01744 1161 17	cmpq 	pr7|996,7		req.len
000473  aa   000021 6010 04	tnz  	17,ic		000514
000474  aa  7 01750 3715 17	epp5 	pr7|1000,7	req.name
000475  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
000476  aa  6 00106 00 0006	desc9a	pr6|70,ql		path_name
000477  aa  5 00000 00 0250	desc9a	pr5|0,168		req.name
000500  aa   000023 6000 04	tze  	19,ic		000523
						STATEMENT 1 ON LINE 146
	     end;

000501  aa   000013 7100 04	tra  	11,ic		000514
						STATEMENT 1 ON LINE 147
	     else do;

						STATEMENT 1 ON LINE 148
		req.path_copy = req.srch.name (i);

000502  aa   000056 4020 07	mpy  	46,dl
000503  aa  7 01750 3715 06	epp5 	pr7|1000,ql	req.name
000504  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000505  aa  5 00000 00 0250	desc9a	pr5|0,168		req.name
000506  aa  7 00000 00 0250	desc9a	pr7|0,168		req.path_copy
						STATEMENT 1 ON LINE 149
		if substr (path_name, 1, req.srch.len (i)) = req.path_copy then
		     go to match;

000507  aa  7 01744 7271 06	lxl7 	pr7|996,ql	req.len
000510  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
000511  aa  6 00106 00 0017	desc9a	pr6|70,x7		path_name
000512  aa  7 00000 00 0250	desc9a	pr7|0,168		req.path_copy
000513  aa   000010 6000 04	tze  	8,ic		000523
						STATEMENT 1 ON LINE 151
	     end;

						STATEMENT 1 ON LINE 152
next_test: end;

000514  aa  6 00100 0541 00	aos  	pr6|64		i
000515  aa   777735 7100 04	tra  	-35,ic		000452
						STATEMENT 1 ON LINE 153
	rcurr = 0;

000516  aa  6 00044 3701 20	epp4 	pr6|36,*
000517  ia  4 00231 4501 00	stz  	pr4|153		rcurr
						STATEMENT 1 ON LINE 154
	label_index = next;

000520  ia  4 00221 2361 00	ldq  	pr4|145		next
000521  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 155
	go to exit;

000522  aa   002616 7100 04	tra  	1422,ic		003340
						STATEMENT 1 ON LINE 157
match:	bk_ss_$retrieval_index = i;

000523  aa  6 00100 2361 00	ldq  	pr6|64		i
000524  la  4 00322 7561 20	stq  	pr4|210,*		bk_ss_$retrieval_index
						STATEMENT 1 ON LINE 158
	if bk_ss_$sub_entry then bk_ss_$path_index = req.srch.control_index (i);

000525  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
000526  aa   000005 6000 04	tze  	5,ic		000533
000527  aa   000056 4020 07	mpy  	46,dl
000530  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
000531  aa  7 01746 2361 06	ldq  	pr7|998,ql	req.control_index
000532  la  4 00320 7561 20	stq  	pr4|208,*		bk_ss_$path_index
						STATEMENT 1 ON LINE 159
	if htype ^= ndc_directory & htype ^= sec_dir then do;

000533  aa  6 00105 2361 00	ldq  	pr6|69		htype
000534  aa   000024 1160 07	cmpq 	20,dl
000535  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
000536  aa  6 00303 7551 00	sta  	pr6|195
000537  aa   000002 1160 07	cmpq 	2,dl
000540  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
000541  aa  6 00303 3751 00	ana  	pr6|195
000542  aa  6 00303 7551 00	sta  	pr6|195
000543  aa   000025 6000 04	tze  	21,ic		000570
						STATEMENT 1 ON LINE 160
	     req.opt.found (i) = "1"b;

000544  aa   040000 2350 03	lda  	16384,du
000545  aa  6 00100 7271 00	lxl7 	pr6|64		i
000546  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
000547  aa  7 00051 2551 17	orsa 	pr7|41,7		req.found
						STATEMENT 1 ON LINE 161
	     if req.opt.synonym (i) then req.opt.found (req.srch.renamo (i)) = "1"b;

000550  aa  7 00051 2351 17	lda  	pr7|41,7		req.synonym
000551  aa   100000 3150 03	cana 	32768,du
000552  aa   000006 6000 04	tze  	6,ic		000560
000553  aa  6 00100 2361 00	ldq  	pr6|64		i
000554  aa   000056 4020 07	mpy  	46,dl
000555  aa   040000 2350 03	lda  	16384,du
000556  aa  7 01747 7261 06	lxl6 	pr7|999,ql	req.renamo
000557  aa  7 00051 2551 16	orsa 	pr7|41,6		req.found
						STATEMENT 1 ON LINE 162
	     if bk_ss_$sub_entry then
		bk_ss_$control_ptr -> backup_control.found (bk_ss_$path_index) = "1"b;

000560  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
000561  aa   000007 6000 04	tze  	7,ic		000570
000562  la  4 00320 2361 20	ldq  	pr4|208,*		bk_ss_$path_index
000563  aa   000151 4020 07	mpy  	105,dl
000564  aa   400000 2350 03	lda  	131072,du
000565  la  4 00306 3715 20	epp5 	pr4|198,*		bk_ss_$control_ptr
000566  aa  5 00000 3715 20	epp5 	pr5|0,*		bk_ss_$control_ptr
000567  aa  5 00014 7551 06	sta  	pr5|12,ql		backup_control.found
						STATEMENT 1 ON LINE 164
	end;

						STATEMENT 1 ON LINE 165
	if bk_ss_$onlysw then do;

000570  la  4 00316 2351 20	lda  	pr4|206,*		bk_ss_$onlysw
000571  aa   000031 6000 04	tze  	25,ic		000622
						STATEMENT 1 ON LINE 166
	     if req.opt.exact (i) then do;

000572  aa  6 00100 7271 00	lxl7 	pr6|64		i
000573  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
000574  aa  7 00051 2351 17	lda  	pr7|41,7		req.exact
000575  aa   200000 3150 03	cana 	65536,du
000576  aa   000016 6000 04	tze  	14,ic		000614
						STATEMENT 1 ON LINE 167
		if htype ^= ndc_directory & htype ^= sec_dir then do;

000577  aa  6 00303 2351 00	lda  	pr6|195
000600  aa   000014 6000 04	tze  	12,ic		000614
						STATEMENT 1 ON LINE 168
		     req.opt.finished (i) = "1"b;

000601  aa   020000 2350 03	lda  	8192,du
000602  aa  7 00051 2551 17	orsa 	pr7|41,7		req.finished
						STATEMENT 1 ON LINE 169
		     if req.opt.synonym (i) then req.opt.finished (req.srch.renamo (i)) = "1"b;

000603  aa  7 00051 2351 17	lda  	pr7|41,7		req.synonym
000604  aa   100000 3150 03	cana 	32768,du
000605  aa   000006 6000 04	tze  	6,ic		000613
000606  aa  6 00100 2361 00	ldq  	pr6|64		i
000607  aa   000056 4020 07	mpy  	46,dl
000610  aa   020000 2350 03	lda  	8192,du
000611  aa  7 01747 7261 06	lxl6 	pr7|999,ql	req.renamo
000612  aa  7 00051 2551 16	orsa 	pr7|41,6		req.finished
						STATEMENT 1 ON LINE 170
		     rfin = rfin + 1;

000613  ia  4 00227 0541 00	aos  	pr4|151		rfin
						STATEMENT 1 ON LINE 171
		end;

						STATEMENT 1 ON LINE 172
	     end;

						STATEMENT 1 ON LINE 173
	     if rcurr ^= 0 then			/* avoid OOB */
		if req.opt.finished (rcurr) then rcurr = 0;

000614  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
000615  aa   000005 6000 04	tze  	5,ic		000622
000616  aa  7 00051 2351 06	lda  	pr7|41,ql		req.finished
000617  aa   020000 3150 03	cana 	8192,du
000620  aa   000002 6000 04	tze  	2,ic		000622
000621  ia  4 00231 4501 00	stz  	pr4|153		rcurr
						STATEMENT 1 ON LINE 175
	end;

						STATEMENT 1 ON LINE 176
	if ^req.opt.exact (i) then rcurr = i;

000622  aa  6 00100 7271 00	lxl7 	pr6|64		i
000623  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
000624  aa  7 00051 2351 17	lda  	pr7|41,7		req.exact
000625  aa   200000 3150 03	cana 	65536,du
000626  aa   000003 6010 04	tnz  	3,ic		000631
000627  aa  6 00100 2361 00	ldq  	pr6|64		i
000630  ia  4 00231 7561 00	stq  	pr4|153		rcurr
						STATEMENT 1 ON LINE 177
	if req.opt.rename (i) then do;

000631  aa  7 00051 2351 17	lda  	pr7|41,7		req.rename
000632  aa   400000 3150 03	cana 	131072,du
000633  aa   000343 6000 04	tze  	227,ic		001176
						STATEMENT 1 ON LINE 178
	     bk_ss_$cross_retrievesw = "1"b;

000634  aa   400000 2350 03	lda  	131072,du
000635  la  4 00310 7551 20	sta  	pr4|200,*		bk_ss_$cross_retrievesw
						STATEMENT 1 ON LINE 179
	     ncurr = req.srch.renamo (i);

000636  aa  6 00100 2361 00	ldq  	pr6|64		i
000637  aa   000056 4020 07	mpy  	46,dl
000640  aa  6 00303 7561 00	stq  	pr6|195
000641  aa  7 01747 2361 06	ldq  	pr7|999,ql	req.renamo
000642  ia  4 00232 7561 00	stq  	pr4|154		ncurr
						STATEMENT 1 ON LINE 180
	     if req.opt.synonym (i) then ncurr = req.srch.renamo (ncurr);

000643  aa  7 00051 2351 17	lda  	pr7|41,7		req.synonym
000644  aa   100000 3150 03	cana 	32768,du
000645  aa   000004 6000 04	tze  	4,ic		000651
000646  aa   000056 4020 07	mpy  	46,dl
000647  aa  7 01747 2361 06	ldq  	pr7|999,ql	req.renamo
000650  ia  4 00232 7561 00	stq  	pr4|154		ncurr
						STATEMENT 1 ON LINE 181
	     grt_count = req.srch.grt (i);

000651  aa  6 00303 7261 00	lxl6 	pr6|195
000652  aa  7 01745 2361 16	ldq  	pr7|997,6		req.grt
000653  aa  6 00234 7561 00	stq  	pr6|156		grt_count
						STATEMENT 1 ON LINE 182
	     j = 0;

000654  aa  6 00101 4501 00	stz  	pr6|65		j
						STATEMENT 1 ON LINE 183
	     if req.newn.ndlen (ncurr) = 0 then do;

000655  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
000656  aa   000055 4020 07	mpy  	45,dl
000657  aa  6 00303 7561 00	stq  	pr6|195
000660  aa   100000 6250 06	eax5 	32768,ql
000661  aa  7 33625 2361 15	ldq  	pr7|14229,5	req.ndlen
000662  aa   000075 6010 04	tnz  	61,ic		000757
						STATEMENT 1 ON LINE 184
		if (htype = ndc_directory_list) then do;

000663  aa  6 00105 2361 00	ldq  	pr6|69		htype
000664  aa   000003 1160 07	cmpq 	3,dl
000665  aa   000062 6010 04	tnz  	50,ic		000747
						STATEMENT 1 ON LINE 185
		     do i = 1 to hp -> h.dlen;

000666  ia  4 00126 2361 20	ldq  	pr4|86,*		h.dlen
000667  aa  6 00243 7561 00	stq  	pr6|163
000670  aa   000001 2360 07	ldq  	1,dl
000671  aa  6 00100 7561 00	stq  	pr6|64		i
000672  aa  6 00100 2361 00	ldq  	pr6|64		i
000673  aa  6 00243 1161 00	cmpq 	pr6|163
000674  aa   000303 6054 04	tpnz 	195,ic		001177
						STATEMENT 1 ON LINE 186
			if addr (hp -> h.dname) -> rscan (i) = ">" then do;

000675  aa  6 00044 3701 20	epp4 	pr6|36,*
000676  ia  4 00126 3735 20	epp7 	pr4|86,*		hp
000677  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
000700  aa  7 00000 60 0001	desc9a	pr7|0(3),1	rscan
000701  aa   002707 00 0001	desc9a	1479,1		003606 = 076000000000
000702  aa   000042 6010 04	tnz  	34,ic		000744
						STATEMENT 1 ON LINE 187
			     j = j + 1;

000703  aa  6 00101 0541 00	aos  	pr6|65		j
						STATEMENT 1 ON LINE 188
			     if j = grt_count then do;

000704  aa  6 00101 2361 00	ldq  	pr6|65		j
000705  aa  6 00234 1161 00	cmpq 	pr6|156		grt_count
000706  aa   000036 6010 04	tnz  	30,ic		000744
						STATEMENT 1 ON LINE 189
				hp -> h.dname = substr (hp -> h.dname, 1, i) ||
				     substr (req.newn.ndname (ncurr), 1, req.newn.nelen (ncurr));

000707  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
000710  aa   000055 4020 07	mpy  	45,dl
000711  aa  6 00326 7561 00	stq  	pr6|214
000712  aa   000002 7360 00	qls  	2
000713  aa  6 00327 7561 00	stq  	pr6|215
000714  aa  6 00100 2361 00	ldq  	pr6|64		i
000715  aa  6 00326 7271 00	lxl7 	pr6|214
000716  aa   100000 6270 17	eax7 	32768,7
000717  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
000720  aa  5 33626 0761 17	adq  	pr5|14230,7	req.nelen
000721  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
000722  aa  6 00100 7261 00	lxl6 	pr6|64		i
000723  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000724  aa  7 00001 00 0016	desc9a	pr7|1,x6		h.dname
000725  aa  2 00000 00 0016	desc9a	pr2|0,x6
000726  aa  6 00327 7251 00	lxl5 	pr6|215
000727  aa   400000 6250 15	eax5 	131072,5
000730  aa  5 33626 7241 17	lxl4 	pr5|14230,7	req.nelen
000731  aa  040 156 100 555	mlr  	(pr,rl,x5),(pr,rl,x6),fill(040)
000732  aa  5 33630 00 0014	desc9a	pr5|14232,x4	req.ndname
000733  aa  2 00000 00 0014	desc9a	pr2|0,x4
000734  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000735  aa  2 00000 00 0006	desc9a	pr2|0,ql
000736  aa  7 00001 00 0250	desc9a	pr7|1,168		h.dname
						STATEMENT 1 ON LINE 191
				hp -> h.dlen = i + req.newn.nelen (ncurr);

000737  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
000740  aa  6 00100 2361 00	ldq  	pr6|64		i
000741  aa  5 33626 0761 17	adq  	pr5|14230,7	req.nelen
000742  aa  7 00000 7561 00	stq  	pr7|0		h.dlen
						STATEMENT 1 ON LINE 192
				go to renamed;

000743  aa   000234 7100 04	tra  	156,ic		001177
						STATEMENT 1 ON LINE 193
			     end;

						STATEMENT 1 ON LINE 194
			end;

						STATEMENT 1 ON LINE 195
		     end;

000744  aa  6 00100 0541 00	aos  	pr6|64		i
000745  aa   777725 7100 04	tra  	-43,ic		000672
						STATEMENT 1 ON LINE 196
		     go to renamed;

000746  aa   000231 7100 04	tra  	153,ic		001177
						STATEMENT 1 ON LINE 197
		end;

						STATEMENT 1 ON LINE 198
		hp -> h.ename = req.newn.ndname (ncurr);

000747  aa  7 33630 3715 15	epp5 	pr7|14232,5	req.ndname
000750  ia  4 00126 3535 20	epp3 	pr4|86,*		hp
000751  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000752  aa  5 00000 00 0040	desc9a	pr5|0,32		req.ndname
000753  aa  3 00054 00 0040	desc9a	pr3|44,32		h.ename
						STATEMENT 1 ON LINE 199
		hp -> h.elen = req.newn.nelen (ncurr);

000754  aa  7 33626 2361 15	ldq  	pr7|14230,5	req.nelen
000755  aa  3 00053 7561 00	stq  	pr3|43		h.elen
						STATEMENT 1 ON LINE 200
		go to renamed;

000756  aa   000221 7100 04	tra  	145,ic		001177
						STATEMENT 1 ON LINE 201
	     end;

						STATEMENT 1 ON LINE 202
	     if (htype = ndc_directory_list) then do;

000757  aa  6 00105 2361 00	ldq  	pr6|69		htype
000760  aa   000003 1160 07	cmpq 	3,dl
000761  aa   000114 6010 04	tnz  	76,ic		001075
						STATEMENT 1 ON LINE 203
		do i = 1 to hp -> h.dlen;

000762  ia  4 00126 2361 20	ldq  	pr4|86,*		h.dlen
000763  aa  6 00244 7561 00	stq  	pr6|164
000764  aa   000001 2360 07	ldq  	1,dl
000765  aa  6 00100 7561 00	stq  	pr6|64		i
000766  aa  6 00100 2361 00	ldq  	pr6|64		i
000767  aa  6 00244 1161 00	cmpq 	pr6|164
000770  aa   000064 6054 04	tpnz 	52,ic		001054
						STATEMENT 1 ON LINE 204
		     if addr (hp -> h.dname) -> rscan (i) = ">" then do;

000771  aa  6 00044 3701 20	epp4 	pr6|36,*
000772  ia  4 00126 3735 20	epp7 	pr4|86,*		hp
000773  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
000774  aa  7 00000 60 0001	desc9a	pr7|0(3),1	rscan
000775  aa   002613 00 0001	desc9a	1419,1		003606 = 076000000000
000776  aa   000054 6010 04	tnz  	44,ic		001052
						STATEMENT 1 ON LINE 205
			j = j + 1;

000777  aa  6 00101 0541 00	aos  	pr6|65		j
						STATEMENT 1 ON LINE 206
			if j = grt_count + 1 then do;

001000  aa  6 00234 2361 00	ldq  	pr6|156		grt_count
001001  aa   000001 0760 07	adq  	1,dl
001002  aa  6 00101 1161 00	cmpq 	pr6|65		j
001003  aa   000047 6010 04	tnz  	39,ic		001052
						STATEMENT 1 ON LINE 207
partial:			     hp -> h.dname = substr (req.newn.ndname (ncurr), 1, req.newn.ndlen (ncurr))
				|| substr (hp -> h.dname, i, hp -> h.dlen - i + 1);

001004  aa  6 00044 3701 20	epp4 	pr6|36,*
001005  ia  4 00126 2361 20	ldq  	pr4|86,*		h.dlen
001006  aa  6 00100 1761 00	sbq  	pr6|64		i
001007  aa   000001 0760 07	adq  	1,dl
001010  aa  6 00303 7561 00	stq  	pr6|195
001011  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
001012  aa   000055 4020 07	mpy  	45,dl
001013  aa  6 00326 7561 00	stq  	pr6|214
001014  aa   000002 7360 00	qls  	2
001015  aa  6 00326 7271 00	lxl7 	pr6|214
001016  aa   100000 6270 17	eax7 	32768,7
001017  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
001020  aa  6 00327 7561 00	stq  	pr6|215
001021  aa  7 33625 2361 17	ldq  	pr7|14229,7	req.ndlen
001022  aa  6 00303 0761 00	adq  	pr6|195
001023  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001024  aa  6 00327 7261 00	lxl6 	pr6|215
001025  aa   400000 6260 16	eax6 	131072,6
001026  aa  7 33625 7251 17	lxl5 	pr7|14229,7	req.ndlen
001027  aa  040 140 100 556	mlr  	(pr,rl,x6),(pr,rl),fill(040)
001030  aa  7 33630 00 0015	desc9a	pr7|14232,x5	req.ndname
001031  aa  2 00000 00 0015	desc9a	pr2|0,x5
001032  aa  6 00100 7241 00	lxl4 	pr6|64		i
001033  ia  4 00126 3715 20	epp5 	pr4|86,*		hp
001034  aa  6 00303 7231 00	lxl3 	pr6|195
001035  aa  040 155 100 554	mlr  	(pr,rl,x4),(pr,rl,x5),fill(040)
001036  aa  5 00000 60 0013	desc9a	pr5|0(3),x3	h.dname
001037  aa  2 00000 00 0013	desc9a	pr2|0,x3
001040  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001041  aa  2 00000 00 0006	desc9a	pr2|0,ql
001042  aa  5 00001 00 0250	desc9a	pr5|1,168		h.dname
						STATEMENT 1 ON LINE 209
			     hp -> h.dlen = hp -> h.dlen - i + 1 + req.newn.ndlen (ncurr);

001043  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001044  aa  5 00000 2361 00	ldq  	pr5|0		h.dlen
001045  aa  6 00100 1761 00	sbq  	pr6|64		i
001046  aa   000001 0760 07	adq  	1,dl
001047  aa  7 33625 0761 17	adq  	pr7|14229,7	req.ndlen
001050  aa  5 00000 7561 00	stq  	pr5|0		h.dlen
						STATEMENT 1 ON LINE 210
			     go to renamed;

001051  aa   000126 7100 04	tra  	86,ic		001177
						STATEMENT 1 ON LINE 211
			end;

						STATEMENT 1 ON LINE 212
		     end;

						STATEMENT 1 ON LINE 213
		end;

001052  aa  6 00100 0541 00	aos  	pr6|64		i
001053  aa   777713 7100 04	tra  	-53,ic		000766
						STATEMENT 1 ON LINE 214
dironly:		hp -> h.dlen = req.newn.ndlen (ncurr);

001054  aa  6 00044 3701 20	epp4 	pr6|36,*
001055  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
001056  aa   000055 4020 07	mpy  	45,dl
001057  aa   100000 6270 06	eax7 	32768,ql
001060  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
001061  aa  6 00326 7561 00	stq  	pr6|214
001062  aa  7 33625 2361 17	ldq  	pr7|14229,7	req.ndlen
001063  ia  4 00126 7561 20	stq  	pr4|86,*		h.dlen
						STATEMENT 1 ON LINE 215
		hp -> h.dname = substr (req.newn.ndname (ncurr), 1, hp -> h.dlen);

001064  aa  6 00326 2361 00	ldq  	pr6|214
001065  aa   000002 7360 00	qls  	2
001066  aa   400000 6260 06	eax6 	131072,ql
001067  ia  4 00126 3715 20	epp5 	pr4|86,*		hp
001070  aa  5 00000 7251 00	lxl5 	pr5|0		h.dlen
001071  aa  040 100 100 556	mlr  	(pr,rl,x6),(pr),fill(040)
001072  aa  7 33630 00 0015	desc9a	pr7|14232,x5	req.ndname
001073  aa  5 00001 00 0250	desc9a	pr5|1,168		h.dname
						STATEMENT 1 ON LINE 216
		go to renamed;

001074  aa   000103 7100 04	tra  	67,ic		001177
						STATEMENT 1 ON LINE 217
	     end;

						STATEMENT 1 ON LINE 218
	     do i = 1 to hp -> h.dlen;

001075  ia  4 00126 2361 20	ldq  	pr4|86,*		h.dlen
001076  aa  6 00245 7561 00	stq  	pr6|165
001077  aa   000001 2360 07	ldq  	1,dl
001100  aa  6 00100 7561 00	stq  	pr6|64		i
001101  aa   000000 0110 03	nop  	0,du
001102  aa  6 00100 2361 00	ldq  	pr6|64		i
001103  aa  6 00245 1161 00	cmpq 	pr6|165
001104  aa   000034 6054 04	tpnz 	28,ic		001140
						STATEMENT 1 ON LINE 219
		if addr (hp -> h.dname) -> rscan (i) = ">" then do;

001105  aa  6 00044 3701 20	epp4 	pr6|36,*
001106  ia  4 00126 3735 20	epp7 	pr4|86,*		hp
001107  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
001110  aa  7 00000 60 0001	desc9a	pr7|0(3),1	rscan
001111  aa   002477 00 0001	desc9a	1343,1		003606 = 076000000000
001112  aa   000024 6010 04	tnz  	20,ic		001136
						STATEMENT 1 ON LINE 220
		     j = j + 1;

001113  aa  6 00101 0541 00	aos  	pr6|65		j
						STATEMENT 1 ON LINE 221
		     if j = grt_count then do;

001114  aa  6 00101 2361 00	ldq  	pr6|65		j
001115  aa  6 00234 1161 00	cmpq 	pr6|156		grt_count
001116  aa   000020 6010 04	tnz  	16,ic		001136
						STATEMENT 1 ON LINE 222
			k = index (substr (hp -> h.dname, i + 1), ">");

001117  aa   000250 2360 07	ldq  	168,dl
001120  aa  6 00100 1761 00	sbq  	pr6|64		i
001121  aa  6 00100 7271 00	lxl7 	pr6|64		i
001122  aa  000 003 124 557	scm  	(pr,rl,x7),(du),mask(000)
001123  aa  7 00001 00 0006	desc9a	pr7|1,ql		h.dname
001124  aa   076000 00 0001	desc9a	31744,1
001125  aa  6 00056 0001 00	arg  	pr6|46
001126  aa  6 00056 2361 00	ldq  	pr6|46
001127  aa   000002 6070 04	ttf  	2,ic		001131
001130  aa   000001 3360 07	lcq  	1,dl
001131  aa   000001 0760 07	adq  	1,dl
001132  aa  6 00102 7561 00	stq  	pr6|66		k
						STATEMENT 1 ON LINE 223
			if k = 0 then go to dironly;

001133  aa   777721 6000 04	tze  	-47,ic		001054
						STATEMENT 1 ON LINE 224
			i = i + k;

001134  aa  6 00100 0561 00	asq  	pr6|64		i
						STATEMENT 1 ON LINE 225
			go to partial;

001135  aa   777647 7100 04	tra  	-89,ic		001004
						STATEMENT 1 ON LINE 226
		     end;

						STATEMENT 1 ON LINE 227
		end;

						STATEMENT 1 ON LINE 228
	     end;

001136  aa  6 00100 0541 00	aos  	pr6|64		i
001137  aa   777743 7100 04	tra  	-29,ic		001102
						STATEMENT 1 ON LINE 229
	     hp -> h.dlen = req.newn.ndlen (ncurr) - req.newn.nelen (ncurr) - 1;

001140  aa  6 00044 3701 20	epp4 	pr6|36,*
001141  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
001142  aa   000055 4020 07	mpy  	45,dl
001143  aa   100000 6270 06	eax7 	32768,ql
001144  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
001145  aa  6 00326 7561 00	stq  	pr6|214
001146  aa  7 33625 2361 17	ldq  	pr7|14229,7	req.ndlen
001147  aa  7 33626 1761 17	sbq  	pr7|14230,7	req.nelen
001150  aa   000001 1760 07	sbq  	1,dl
001151  ia  4 00126 7561 20	stq  	pr4|86,*		h.dlen
						STATEMENT 1 ON LINE 230
	     hp -> h.dname = substr (req.newn.ndname (ncurr), 1, hp -> h.dlen);

001152  aa  6 00326 2361 00	ldq  	pr6|214
001153  aa   000002 7360 00	qls  	2
001154  aa   400000 6260 06	eax6 	131072,ql
001155  ia  4 00126 3715 20	epp5 	pr4|86,*		hp
001156  aa  5 00000 7251 00	lxl5 	pr5|0		h.dlen
001157  aa  040 100 100 556	mlr  	(pr,rl,x6),(pr),fill(040)
001160  aa  7 33630 00 0015	desc9a	pr7|14232,x5	req.ndname
001161  aa  5 00001 00 0250	desc9a	pr5|1,168		h.dname
						STATEMENT 1 ON LINE 231
	     hp -> h.elen = req.newn.nelen (ncurr);

001162  aa  6 00327 7561 00	stq  	pr6|215
001163  aa  7 33626 2361 17	ldq  	pr7|14230,7	req.nelen
001164  aa  5 00053 7561 00	stq  	pr5|43		h.elen
						STATEMENT 1 ON LINE 232
	     hp -> h.ename = substr (req.newn.ndname (ncurr), hp -> h.dlen + 2, hp -> h.elen);

001165  aa  5 00000 2361 00	ldq  	pr5|0		h.dlen
001166  aa   000001 0760 07	adq  	1,dl
001167  aa  6 00327 0761 00	adq  	pr6|215
001170  aa   400000 6240 06	eax4 	131072,ql
001171  aa  5 00053 7231 00	lxl3 	pr5|43		h.elen
001172  aa  040 100 100 554	mlr  	(pr,rl,x4),(pr),fill(040)
001173  aa  7 33630 00 0013	desc9a	pr7|14232,x3	req.ndname
001174  aa  5 00054 00 0040	desc9a	pr5|44,32		h.ename
						STATEMENT 1 ON LINE 233
renamed:	end;

001175  aa   000002 7100 04	tra  	2,ic		001177
						STATEMENT 1 ON LINE 234
	else bk_ss_$cross_retrievesw = "0"b;

001176  la  4 00310 4501 20	stz  	pr4|200,*		bk_ss_$cross_retrievesw
						STATEMENT 1 ON LINE 235
	label_index = checked;

001177  aa  6 00044 3701 20	epp4 	pr6|36,*
001200  ia  4 00225 2361 00	ldq  	pr4|149		checked
001201  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 236
	go to exit;

001202  aa   002136 7100 04	tra  	1118,ic		003340
ENTRY TO flag_msf                                           STATEMENT 1 ON LINE 242
flag_msf: entry (A_index);

001203  ta     000224000000
001204  da     000332300000
001205  aa   000560 6270 00	eax7 	368
001206  aa  7 00034 3521 20	epp2 	pr7|28,*
001207  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001210  aa     000002000000
001211  aa     000000000000
001212  aa   776774 7000 04	tsx0 	-516,ic		000206
						STATEMENT 1 ON LINE 246
	rcurr = A_index;

001213  aa  6 00032 3735 20	epp7 	pr6|26,*
001214  aa  7 00002 2361 20	ldq  	pr7|2,*		A_index
001215  aa  6 00044 3701 20	epp4 	pr6|36,*
001216  ia  4 00231 7561 00	stq  	pr4|153		rcurr
						STATEMENT 1 ON LINE 248
	req.opt.exact (A_index) = "0"b;

001217  aa   002366 2350 04	lda  	1270,ic		003605 = 577777777777
001220  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
001221  aa  5 00051 3551 06	ansa 	pr5|41,ql		req.exact
						STATEMENT 1 ON LINE 249
	if req.opt.synonym (A_index) then req.opt.exact (req.srch.renamo (A_index)) = "0"b;

001222  aa  5 00051 2351 06	lda  	pr5|41,ql		req.synonym
001223  aa   100000 3150 03	cana 	32768,du
001224  aa   000005 6000 04	tze  	5,ic		001231
001225  aa   000056 4020 07	mpy  	46,dl
001226  aa   002357 2350 04	lda  	1263,ic		003605 = 577777777777
001227  aa  5 01747 7271 06	lxl7 	pr5|999,ql	req.renamo
001230  aa  5 00051 3551 17	ansa 	pr5|41,7		req.exact
						STATEMENT 1 ON LINE 251
	return;

001231  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO parse_retrieval_control                            STATEMENT 1 ON LINE 259
parse_retrieval_control: entry (rname, rsize, a_hp, label_index);

001232  at     000004000026
001233  tt     000025000027
001234  ta     000025000000
001235  ta     001232000000
001236  da     000343300000
001237  aa   000560 6270 00	eax7 	368
001240  aa  7 00034 3521 20	epp2 	pr7|28,*
001241  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001242  aa     000010000000
001243  aa     000000000000
001244  aa  6 00032 3735 20	epp7 	pr6|26,*
001245  aa  7 00006 3715 20	epp5 	pr7|6,*
001246  aa  6 00236 6515 00	spri5	pr6|158
001247  aa  7 00010 3535 20	epp3 	pr7|8,*
001250  aa  6 00240 2535 00	spri3	pr6|160
001251  aa   776735 7000 04	tsx0 	-547,ic		000206
						STATEMENT 1 ON LINE 261
	if bk_ss_$sub_entry then do;

001252  aa  6 00044 3701 20	epp4 	pr6|36,*
001253  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
001254  aa   000116 6000 04	tze  	78,ic		001372
						STATEMENT 1 ON LINE 262
	     call backup_map_$fs_error_line (error_table_$badcall, "bk_retrieve$parse_retrieval_control",
		"^/This entry point must be called via backup_load, reload or retrieve", "");

001255  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001256  aa   776632 00 0044	desc9a	-614,36		000107 = 142153137162
001257  aa  6 00304 00 0044	desc9a	pr6|196,36
001260  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001261  aa   776704 00 0110	desc9a	-572,72		000164 = 136057124150
001262  aa  6 00330 00 0110	desc9a	pr6|216,72
001263  la  4 00234 3521 20	epp2 	pr4|156,*		error_table_$badcall
001264  aa  6 00354 2521 00	spri2	pr6|236
001265  aa  6 00304 3521 00	epp2 	pr6|196
001266  aa  6 00356 2521 00	spri2	pr6|238
001267  aa  6 00330 3521 00	epp2 	pr6|216
001270  aa  6 00360 2521 00	spri2	pr6|240
001271  aa  6 00327 3521 00	epp2 	pr6|215
001272  aa  6 00362 2521 00	spri2	pr6|242
001273  aa   776526 3520 04	epp2 	-682,ic		000021 = 404000000043
001274  aa  6 00364 2521 00	spri2	pr6|244
001275  aa   776523 3520 04	epp2 	-685,ic		000020 = 524000000043
001276  aa  6 00366 2521 00	spri2	pr6|246
001277  aa   776520 3520 04	epp2 	-688,ic		000017 = 524000000105
001300  aa  6 00370 2521 00	spri2	pr6|248
001301  aa   776515 3520 04	epp2 	-691,ic		000016 = 524000000000
001302  aa  6 00372 2521 00	spri2	pr6|250
001303  aa  6 00352 6211 00	eax1 	pr6|234
001304  aa   020000 4310 07	fld  	8192,dl
001305  la  4 00260 3521 20	epp2 	pr4|176,*		backup_map_$fs_error_line
001306  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 264
	     label_index = terminate;

001307  aa  6 00044 3701 20	epp4 	pr6|36,*
001310  ia  4 00223 2361 00	ldq  	pr4|147		terminate
001311  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 265
	end;

						STATEMENT 1 ON LINE 266
	go to COMMON;

001312  aa   000060 7100 04	tra  	48,ic		001372
ENTRY TO parse_structure                                    STATEMENT 1 ON LINE 268
parse_structure: entry (a_hp, label_index);

001313  at     000002000027
001314  ta     000025000000
001315  ta     001313000000
001316  da     000352300000
001317  aa   000560 6270 00	eax7 	368
001320  aa  7 00034 3521 20	epp2 	pr7|28,*
001321  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001322  aa     000004000000
001323  aa     000000000000
001324  aa  6 00032 3735 20	epp7 	pr6|26,*
001325  aa  7 00002 3715 20	epp5 	pr7|2,*
001326  aa  6 00236 6515 00	spri5	pr6|158
001327  aa  7 00004 3535 20	epp3 	pr7|4,*
001330  aa  6 00240 2535 00	spri3	pr6|160
001331  aa   776655 7000 04	tsx0 	-595,ic		000206
						STATEMENT 1 ON LINE 270
	if ^bk_ss_$sub_entry then do;

001332  aa  6 00044 3701 20	epp4 	pr6|36,*
001333  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
001334  aa   000036 6010 04	tnz  	30,ic		001372
						STATEMENT 1 ON LINE 271
	     call backup_map_$fs_error_line (error_table_$badcall, "bk_retrieve$parse_structure",
		"^/This entry point must be called via backup_load_", "");

001335  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001336  aa   776534 00 0034	desc9a	-676,28		000071 = 142153137162
001337  aa  6 00274 00 0034	desc9a	pr6|188,28
001340  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001341  aa   776607 00 0064	desc9a	-633,52		000147 = 136057124150
001342  aa  6 00352 00 0064	desc9a	pr6|234,52
001343  la  4 00234 3521 20	epp2 	pr4|156,*		error_table_$badcall
001344  aa  6 00306 2521 00	spri2	pr6|198
001345  aa  6 00274 3521 00	epp2 	pr6|188
001346  aa  6 00310 2521 00	spri2	pr6|200
001347  aa  6 00352 3521 00	epp2 	pr6|234
001350  aa  6 00312 2521 00	spri2	pr6|202
001351  aa  6 00327 3521 00	epp2 	pr6|215
001352  aa  6 00314 2521 00	spri2	pr6|204
001353  aa   776446 3520 04	epp2 	-730,ic		000021 = 404000000043
001354  aa  6 00316 2521 00	spri2	pr6|206
001355  aa   776447 3520 04	epp2 	-729,ic		000024 = 524000000033
001356  aa  6 00320 2521 00	spri2	pr6|208
001357  aa   776436 3520 04	epp2 	-738,ic		000015 = 524000000062
001360  aa  6 00322 2521 00	spri2	pr6|210
001361  aa   776435 3520 04	epp2 	-739,ic		000016 = 524000000000
001362  aa  6 00324 2521 00	spri2	pr6|212
001363  aa  6 00304 6211 00	eax1 	pr6|196
001364  aa   020000 4310 07	fld  	8192,dl
001365  la  4 00260 3521 20	epp2 	pr4|176,*		backup_map_$fs_error_line
001366  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 273
	     label_index = terminate;

001367  aa  6 00044 3701 20	epp4 	pr6|36,*
001370  ia  4 00223 2361 00	ldq  	pr4|147		terminate
001371  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 274
	end;

						STATEMENT 1 ON LINE 276
COMMON:	hp = a_hp;

001372  aa  6 00236 3735 20	epp7 	pr6|158,*		a_hp
001373  aa  7 00000 3735 20	epp7 	pr7|0,*		a_hp
001374  ia  4 00126 6535 00	spri7	pr4|86		hp
						STATEMENT 1 ON LINE 277
	unspec (nl) = "000001010"b;

001375  aa   012000 2350 03	lda  	5120,du
001376  ia  4 00130 5511 40	stba 	pr4|88,40
						STATEMENT 1 ON LINE 278
	rfin, rlines = 0;

001377  ia  4 00227 4501 00	stz  	pr4|151		rfin
001400  ia  4 00226 4501 00	stz  	pr4|150		rlines
						STATEMENT 1 ON LINE 279
	parsed = 1;

001401  aa   000001 2360 07	ldq  	1,dl
001402  ia  4 00220 7561 00	stq  	pr4|144		parsed
						STATEMENT 1 ON LINE 280
	next = 2;

001403  aa   000002 2360 07	ldq  	2,dl
001404  ia  4 00221 7561 00	stq  	pr4|145		next
						STATEMENT 1 ON LINE 281
	stop = 3;

001405  aa   000003 2360 07	ldq  	3,dl
001406  ia  4 00222 7561 00	stq  	pr4|146		stop
						STATEMENT 1 ON LINE 282
	terminate = 4;

001407  aa   000004 2360 07	ldq  	4,dl
001410  ia  4 00223 7561 00	stq  	pr4|147		terminate
						STATEMENT 1 ON LINE 283
	reported = 5;

001411  aa   000005 2360 07	ldq  	5,dl
001412  ia  4 00224 7561 00	stq  	pr4|148		reported
						STATEMENT 1 ON LINE 284
	checked = 6;

001413  aa   000006 2360 07	ldq  	6,dl
001414  ia  4 00225 7561 00	stq  	pr4|149		checked
						STATEMENT 1 ON LINE 285
	if ^bk_ss_$sub_entry then do;

001415  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
001416  aa   000171 6010 04	tnz  	121,ic		001607
						STATEMENT 1 ON LINE 286
	     line_pointer = addr (line);

001417  ia  4 00010 3715 00	epp5 	pr4|8		line
001420  ia  4 00124 6515 00	spri5	pr4|84		line_pointer
						STATEMENT 1 ON LINE 288
	     call expand_pathname_ (substr (rname, 1, rsize), rdname, rename, code);

001421  aa  6 00032 3535 20	epp3 	pr6|26,*
001422  aa  3 00004 2361 20	ldq  	pr3|4,*		rsize
001423  aa   524000 2760 03	orq  	174080,du
001424  aa  6 00327 7561 00	stq  	pr6|215
001425  aa  3 00004 2361 20	ldq  	pr3|4,*		rsize
001426  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
001427  aa  6 00332 2521 00	spri2	pr6|218
001430  aa  3 00002 3515 20	epp1 	pr3|2,*
001431  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001432  aa  1 00000 00 0006	desc9a	pr1|0,ql		rname
001433  aa  2 00000 00 0006	desc9a	pr2|0,ql
001434  ia  4 00131 3521 00	epp2 	pr4|89		rdname
001435  aa  6 00334 2521 00	spri2	pr6|220
001436  ia  4 00203 3521 00	epp2 	pr4|131		rename
001437  aa  6 00336 2521 00	spri2	pr6|222
001440  aa  6 00232 3521 00	epp2 	pr6|154		code
001441  aa  6 00340 2521 00	spri2	pr6|224
001442  aa  6 00327 3521 00	epp2 	pr6|215
001443  aa  6 00342 2521 00	spri2	pr6|226
001444  aa   776362 3520 04	epp2 	-782,ic		000026 = 524000000250
001445  aa  6 00344 2521 00	spri2	pr6|228
001446  aa   776346 3520 04	epp2 	-794,ic		000014 = 524000000040
001447  aa  6 00346 2521 00	spri2	pr6|230
001450  aa   776351 3520 04	epp2 	-791,ic		000021 = 404000000043
001451  aa  6 00350 2521 00	spri2	pr6|232
001452  aa  6 00330 6211 00	eax1 	pr6|216
001453  aa   020000 4310 07	fld  	8192,dl
001454  la  4 00266 3521 20	epp2 	pr4|182,*		expand_pathname_
001455  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 289
	     if code ^= 0 then do;

001456  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
001457  aa  6 00232 2361 00	ldq  	pr6|154		code
001460  aa   000024 6000 04	tze  	20,ic		001504
						STATEMENT 1 ON LINE 290
		call com_err_ (code, bk_ss_$myname, rname);

001461  aa  6 00232 3521 00	epp2 	pr6|154		code
001462  aa  6 00306 2521 00	spri2	pr6|198
001463  aa  6 00044 3701 20	epp4 	pr6|36,*
001464  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
001465  aa  6 00310 2521 00	spri2	pr6|200
001466  aa  6 00032 3735 20	epp7 	pr6|26,*
001467  aa  7 00002 3521 20	epp2 	pr7|2,*		rname
001470  aa  6 00312 2521 00	spri2	pr6|202
001471  aa   776330 3520 04	epp2 	-808,ic		000021 = 404000000043
001472  aa  6 00314 2521 00	spri2	pr6|204
001473  aa   776327 3520 04	epp2 	-809,ic		000022 = 526000000020
001474  aa  6 00316 2521 00	spri2	pr6|206
001475  aa   776331 3520 04	epp2 	-807,ic		000026 = 524000000250
001476  aa  6 00320 2521 00	spri2	pr6|208
001477  aa  6 00304 6211 00	eax1 	pr6|196
001500  aa   014000 4310 07	fld  	6144,dl
001501  la  4 00300 3521 20	epp2 	pr4|192,*		com_err_
001502  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 291
		go to reported_exit;

001503  aa   000203 7100 04	tra  	131,ic		001706
						STATEMENT 1 ON LINE 292
	     end;

						STATEMENT 1 ON LINE 294
	     call hcs_$initiate_count (rdname, rename, "", rbc, 1, rptr, code);

001504  aa   000001 2360 07	ldq  	1,dl
001505  aa  6 00326 7561 00	stq  	pr6|214
001506  aa  6 00044 3701 20	epp4 	pr6|36,*
001507  ia  4 00131 3521 00	epp2 	pr4|89		rdname
001510  aa  6 00400 2521 00	spri2	pr6|256
001511  ia  4 00203 3521 00	epp2 	pr4|131		rename
001512  aa  6 00402 2521 00	spri2	pr6|258
001513  aa  6 00327 3521 00	epp2 	pr6|215
001514  aa  6 00404 2521 00	spri2	pr6|260
001515  aa  6 00233 3521 00	epp2 	pr6|155		rbc
001516  aa  6 00406 2521 00	spri2	pr6|262
001517  aa  6 00326 3521 00	epp2 	pr6|214
001520  aa  6 00410 2521 00	spri2	pr6|264
001521  ia  4 00214 3521 00	epp2 	pr4|140		rptr
001522  aa  6 00412 2521 00	spri2	pr6|266
001523  aa  6 00232 3521 00	epp2 	pr6|154		code
001524  aa  6 00414 2521 00	spri2	pr6|268
001525  aa   776301 3520 04	epp2 	-831,ic		000026 = 524000000250
001526  aa  6 00416 2521 00	spri2	pr6|270
001527  aa   776265 3520 04	epp2 	-843,ic		000014 = 524000000040
001530  aa  6 00420 2521 00	spri2	pr6|272
001531  aa   776265 3520 04	epp2 	-843,ic		000016 = 524000000000
001532  aa  6 00422 2521 00	spri2	pr6|274
001533  aa   776272 3520 04	epp2 	-838,ic		000025 = 404000000021
001534  aa  6 00424 2521 00	spri2	pr6|276
001535  aa   776256 3520 04	epp2 	-850,ic		000013 = 404000000002
001536  aa  6 00426 2521 00	spri2	pr6|278
001537  aa   776270 3520 04	epp2 	-840,ic		000027 = 464000000000
001540  aa  6 00430 2521 00	spri2	pr6|280
001541  aa   776260 3520 04	epp2 	-848,ic		000021 = 404000000043
001542  aa  6 00432 2521 00	spri2	pr6|282
001543  aa  6 00376 6211 00	eax1 	pr6|254
001544  aa   034000 4310 07	fld  	14336,dl
001545  la  4 00276 3521 20	epp2 	pr4|190,*		hcs_$initiate_count
001546  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 295
	     if code ^= 0 & code ^= error_table_$segknown then do;

001547  aa  6 00232 2361 00	ldq  	pr6|154		code
001550  aa   000037 6000 04	tze  	31,ic		001607
001551  aa  6 00044 3701 20	epp4 	pr6|36,*
001552  la  4 00256 1161 20	cmpq 	pr4|174,*		error_table_$segknown
001553  aa   000034 6000 04	tze  	28,ic		001607
						STATEMENT 1 ON LINE 296
		call com_err_ (code, bk_ss_$myname, "^a>^a", rdname, rename);

001554  aa   776256 2370 04	ldaq 	-850,ic		000032 = 136141076136 141000000000
001555  aa  6 00374 7571 00	staq 	pr6|252
001556  aa  6 00232 3521 00	epp2 	pr6|154		code
001557  aa  6 00400 2521 00	spri2	pr6|256
001560  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
001561  aa  6 00402 2521 00	spri2	pr6|258
001562  aa  6 00374 3521 00	epp2 	pr6|252
001563  aa  6 00404 2521 00	spri2	pr6|260
001564  ia  4 00131 3521 00	epp2 	pr4|89		rdname
001565  aa  6 00406 2521 00	spri2	pr6|262
001566  ia  4 00203 3521 00	epp2 	pr4|131		rename
001567  aa  6 00410 2521 00	spri2	pr6|264
001570  aa   776231 3520 04	epp2 	-871,ic		000021 = 404000000043
001571  aa  6 00412 2521 00	spri2	pr6|266
001572  aa   776230 3520 04	epp2 	-872,ic		000022 = 526000000020
001573  aa  6 00414 2521 00	spri2	pr6|268
001574  aa   776216 3520 04	epp2 	-882,ic		000012 = 524000000005
001575  aa  6 00416 2521 00	spri2	pr6|270
001576  aa   776230 3520 04	epp2 	-872,ic		000026 = 524000000250
001577  aa  6 00420 2521 00	spri2	pr6|272
001600  aa   776214 3520 04	epp2 	-884,ic		000014 = 524000000040
001601  aa  6 00422 2521 00	spri2	pr6|274
001602  aa  6 00376 6211 00	eax1 	pr6|254
001603  aa   024000 4310 07	fld  	10240,dl
001604  la  4 00300 3521 20	epp2 	pr4|192,*		com_err_
001605  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 297
		go to reported_exit;

001606  aa   000100 7100 04	tra  	64,ic		001706
						STATEMENT 1 ON LINE 298
	     end;

						STATEMENT 1 ON LINE 299
	end;

						STATEMENT 1 ON LINE 301
	call hcs_$make_seg ("", "retrieval_control", "", 01011b, reqptr, code);

001607  aa   776247 2370 04	ldaq 	-857,ic		000056 = 162145164162 151145166141
001610  aa  6 00274 7571 00	staq 	pr6|188
001611  aa   776247 2370 04	ldaq 	-857,ic		000060 = 154137143157 156164162157
001612  aa  6 00276 7571 00	staq 	pr6|190
001613  aa   154000 2350 03	lda  	55296,du
001614  aa  6 00300 7551 00	sta  	pr6|192
001615  aa   000013 2360 07	ldq  	11,dl
001616  aa  6 00303 7561 00	stq  	pr6|195
001617  aa  6 00326 3521 00	epp2 	pr6|214
001620  aa  6 00400 2521 00	spri2	pr6|256
001621  aa  6 00274 3521 00	epp2 	pr6|188
001622  aa  6 00402 2521 00	spri2	pr6|258
001623  aa  6 00327 3521 00	epp2 	pr6|215
001624  aa  6 00404 2521 00	spri2	pr6|260
001625  aa  6 00303 3521 00	epp2 	pr6|195
001626  aa  6 00406 2521 00	spri2	pr6|262
001627  aa  6 00044 3701 20	epp4 	pr6|36,*
001630  ia  4 00216 3521 00	epp2 	pr4|142		reqptr
001631  aa  6 00410 2521 00	spri2	pr6|264
001632  aa  6 00232 3521 00	epp2 	pr6|154		code
001633  aa  6 00412 2521 00	spri2	pr6|266
001634  aa   776162 3520 04	epp2 	-910,ic		000016 = 524000000000
001635  aa  6 00414 2521 00	spri2	pr6|268
001636  aa  6 00420 2521 00	spri2	pr6|272
001637  aa   776152 3520 04	epp2 	-918,ic		000011 = 524000000021
001640  aa  6 00416 2521 00	spri2	pr6|270
001641  aa   776147 3520 04	epp2 	-921,ic		000010 = 404000000005
001642  aa  6 00422 2521 00	spri2	pr6|274
001643  aa   776164 3520 04	epp2 	-908,ic		000027 = 464000000000
001644  aa  6 00424 2521 00	spri2	pr6|276
001645  aa   776154 3520 04	epp2 	-916,ic		000021 = 404000000043
001646  aa  6 00426 2521 00	spri2	pr6|278
001647  aa  6 00376 6211 00	eax1 	pr6|254
001650  aa   030000 4310 07	fld  	12288,dl
001651  la  4 00270 3521 20	epp2 	pr4|184,*		hcs_$make_seg
001652  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 302
	if code ^= 0 & code ^= error_table_$segknown then do;

001653  aa  6 00232 2361 00	ldq  	pr6|154		code
001654  aa   000036 6000 04	tze  	30,ic		001712
001655  aa  6 00044 3701 20	epp4 	pr6|36,*
001656  la  4 00256 1161 20	cmpq 	pr4|174,*		error_table_$segknown
001657  aa   000033 6000 04	tze  	27,ic		001712
						STATEMENT 1 ON LINE 303
	     call com_err_ (code, bk_ss_$myname, "retrieval_control");

001660  aa   776176 2370 04	ldaq 	-898,ic		000056 = 162145164162 151145166141
001661  aa  6 00274 7571 00	staq 	pr6|188
001662  aa   776176 2370 04	ldaq 	-898,ic		000060 = 154137143157 156164162157
001663  aa  6 00276 7571 00	staq 	pr6|190
001664  aa   154000 2350 03	lda  	55296,du
001665  aa  6 00300 7551 00	sta  	pr6|192
001666  aa  6 00232 3521 00	epp2 	pr6|154		code
001667  aa  6 00354 2521 00	spri2	pr6|236
001670  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
001671  aa  6 00356 2521 00	spri2	pr6|238
001672  aa  6 00274 3521 00	epp2 	pr6|188
001673  aa  6 00360 2521 00	spri2	pr6|240
001674  aa   776125 3520 04	epp2 	-939,ic		000021 = 404000000043
001675  aa  6 00362 2521 00	spri2	pr6|242
001676  aa   776124 3520 04	epp2 	-940,ic		000022 = 526000000020
001677  aa  6 00364 2521 00	spri2	pr6|244
001700  aa   776111 3520 04	epp2 	-951,ic		000011 = 524000000021
001701  aa  6 00366 2521 00	spri2	pr6|246
001702  aa  6 00352 6211 00	eax1 	pr6|234
001703  aa   014000 4310 07	fld  	6144,dl
001704  la  4 00300 3521 20	epp2 	pr4|192,*		com_err_
001705  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 304
reported_exit: label_index = reported;

001706  aa  6 00044 3701 20	epp4 	pr6|36,*
001707  ia  4 00224 2361 00	ldq  	pr4|148		reported
001710  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 305
	     go to exit;

001711  aa   001427 7100 04	tra  	791,ic		003340
						STATEMENT 1 ON LINE 306
	end;

						STATEMENT 1 ON LINE 307
	call hcs_$truncate_seg (reqptr, 0, 0);

001712  aa  6 00303 4501 00	stz  	pr6|195
001713  aa  6 00327 4501 00	stz  	pr6|215
001714  aa  6 00044 3701 20	epp4 	pr6|36,*
001715  ia  4 00216 3521 00	epp2 	pr4|142		reqptr
001716  aa  6 00332 2521 00	spri2	pr6|218
001717  aa  6 00303 3521 00	epp2 	pr6|195
001720  aa  6 00334 2521 00	spri2	pr6|220
001721  aa  6 00327 3521 00	epp2 	pr6|215
001722  aa  6 00336 2521 00	spri2	pr6|222
001723  aa  6 00330 6211 00	eax1 	pr6|216
001724  aa   014000 4310 07	fld  	6144,dl
001725  la  4 00274 3521 20	epp2 	pr4|188,*		hcs_$truncate_seg
001726  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 309
	ncurr, rcurr, i = 1;

001727  aa   000001 2360 07	ldq  	1,dl
001730  aa  6 00044 3701 20	epp4 	pr6|36,*
001731  ia  4 00232 7561 00	stq  	pr4|154		ncurr
001732  ia  4 00231 7561 00	stq  	pr4|153		rcurr
001733  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 311
	if bk_ss_$sub_entry then do;

001734  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
001735  aa   000217 6000 04	tze  	143,ic		002154
						STATEMENT 1 ON LINE 312
	     rlines, rcomp = bk_ss_$control_ptr -> backup_control.request_count;

001736  la  4 00306 3735 20	epp7 	pr4|198,*		bk_ss_$control_ptr
001737  aa  7 00000 3735 20	epp7 	pr7|0,*		bk_ss_$control_ptr
001740  aa  7 00037 2361 00	ldq  	pr7|31		backup_control.request_count
001741  ia  4 00226 7561 00	stq  	pr4|150		rlines
001742  ia  4 00230 7561 00	stq  	pr4|152		rcomp
						STATEMENT 1 ON LINE 313
	     if rlines > 500 then go to parsed_enough;

001743  aa   000764 1160 07	cmpq 	500,dl
001744  aa   001017 6054 04	tpnz 	527,ic		002763
						STATEMENT 1 ON LINE 314
	     do rcurr = 1 to rlines;

001745  aa  6 00246 7561 00	stq  	pr6|166
001746  aa  6 00044 3701 20	epp4 	pr6|36,*
001747  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
001750  aa  6 00246 1161 00	cmpq 	pr6|166
001751  aa   000542 6054 04	tpnz 	354,ic		002513
						STATEMENT 1 ON LINE 315
		line = bk_ss_$control_ptr -> backup_control.path (rcurr);

001752  aa   000151 4020 07	mpy  	105,dl
001753  la  4 00306 3735 20	epp7 	pr4|198,*		bk_ss_$control_ptr
001754  aa  7 00000 3735 20	epp7 	pr7|0,*		bk_ss_$control_ptr
001755  aa  7 77667 3735 06	epp7 	pr7|-73,ql	backup_control.path
001756  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
001757  aa  7 00000 00 0250	desc9a	pr7|0,168		backup_control.path
001760  ia  4 00010 00 0454	desc9a	pr4|8,300		line
						STATEMENT 1 ON LINE 316
		if substr (line, 1, 1) ^= ">" then do;

001761  aa  6 00327 7561 00	stq  	pr6|215
001762  ia  4 00010 2351 00	lda  	pr4|8		line
001763  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001764  aa   076000 1150 03	cmpa 	31744,du
001765  aa   000011 6000 04	tze  	9,ic		001776
						STATEMENT 1 ON LINE 317
		     bk_ss_$control_ptr -> backup_control.status_code (rcurr) = error_table_$badpath;

001766  la  4 00240 2361 20	ldq  	pr4|160,*		error_table_$badpath
001767  aa  6 00327 7271 00	lxl7 	pr6|215
001770  la  4 00306 3715 20	epp5 	pr4|198,*		bk_ss_$control_ptr
001771  aa  5 00000 3715 20	epp5 	pr5|0,*		bk_ss_$control_ptr
001772  aa  5 00016 7561 17	stq  	pr5|14,7		backup_control.status_code
						STATEMENT 1 ON LINE 318
		     label_index = terminate;

001773  ia  4 00223 2361 00	ldq  	pr4|147		terminate
001774  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 319
		     go to exit;

001775  aa   001343 7100 04	tra  	739,ic		003340
						STATEMENT 1 ON LINE 320
		end;

						STATEMENT 1 ON LINE 321
		req.srch.control_index (rcurr) = rcurr;

001776  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
001777  aa   000056 4020 07	mpy  	46,dl
002000  aa   000000 6270 06	eax7 	0,ql
002001  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002002  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
002003  aa  5 01746 7561 17	stq  	pr5|998,7		req.control_index
						STATEMENT 1 ON LINE 322
		req.srch.name (rcurr) = line;

002004  aa  5 01750 3535 17	epp3 	pr5|1000,7	req.name
002005  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002006  ia  4 00010 00 0250	desc9a	pr4|8,168		line
002007  aa  3 00000 00 0250	desc9a	pr3|0,168		req.name
						STATEMENT 1 ON LINE 323
		req.srch.len (rcurr) = length (line) + 1 - verify (reverse (line), " ");

002010  aa  000 000 165 500	tctr 	(pr)
002011  ia  4 00010 00 0454	desc9a	pr4|8,300		line
002012  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
002013  aa  6 00056 0001 00	arg  	pr6|46
002014  aa  6 00056 2361 00	ldq  	pr6|46
002015  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002016  aa   000002 6070 04	ttf  	2,ic		002020
002017  aa   000001 3360 07	lcq  	1,dl
002020  aa   000001 0760 07	adq  	1,dl
002021  aa  6 00303 7561 00	stq  	pr6|195
002022  aa   000455 2360 07	ldq  	301,dl
002023  aa  6 00303 1761 00	sbq  	pr6|195
002024  aa  5 01744 7561 17	stq  	pr5|996,7		req.len
						STATEMENT 1 ON LINE 324
		if bk_ss_$control_ptr -> backup_control.new_path (rcurr) ^= "" then do;

002025  aa  6 00303 7471 00	stx7 	pr6|195
002026  aa  6 00327 7261 00	lxl6 	pr6|215
002027  la  4 00306 3515 20	epp1 	pr4|198,*		bk_ss_$control_ptr
002030  aa  1 00000 3515 20	epp1 	pr1|0,*		bk_ss_$control_ptr
002031  aa  1 77741 3515 16	epp1 	pr1|-31,6		backup_control.new_path
002032  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002033  aa  1 00000 00 0250	desc9a	pr1|0,168		backup_control.new_path
002034  aa   001554 00 0000	desc9a	876,0		003606 = 076000000000
002035  aa   000105 6000 04	tze  	69,ic		002142
						STATEMENT 1 ON LINE 325
		     req.opt.rename (rcurr) = "1"b;

002036  aa   400000 2350 03	lda  	131072,du
002037  ia  4 00231 7251 00	lxl5 	pr4|153		rcurr
002040  aa  5 00051 2551 15	orsa 	pr5|41,5		req.rename
						STATEMENT 1 ON LINE 326
		     req.srch.renamo (rcurr) = ncurr;

002041  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
002042  aa  5 01747 7561 17	stq  	pr5|999,7		req.renamo
						STATEMENT 1 ON LINE 327
		     j = 0;

002043  aa  6 00101 4501 00	stz  	pr6|65		j
						STATEMENT 1 ON LINE 328
		     do k = 1 to req.srch.len (rcurr);

002044  aa  5 01744 2361 17	ldq  	pr5|996,7		req.len
002045  aa  6 00247 7561 00	stq  	pr6|167
002046  aa   000001 2360 07	ldq  	1,dl
002047  aa  6 00102 7561 00	stq  	pr6|66		k
002050  aa  6 00102 2361 00	ldq  	pr6|66		k
002051  aa  6 00247 1161 00	cmpq 	pr6|167
002052  aa   000017 6054 04	tpnz 	15,ic		002071
						STATEMENT 1 ON LINE 329
			if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then j = j + 1;

002053  aa  6 00044 3701 20	epp4 	pr6|36,*
002054  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002055  aa   000056 4020 07	mpy  	46,dl
002056  aa  6 00303 7561 00	stq  	pr6|195
002057  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002060  aa  7 01750 3735 06	epp7 	pr7|1000,ql	req.name
002061  aa  6 00102 7271 00	lxl7 	pr6|66		k
002062  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
002063  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	rscan
002064  aa   001524 00 0001	desc9a	852,1		003606 = 076000000000
002065  aa   000002 6010 04	tnz  	2,ic		002067
002066  aa  6 00101 0541 00	aos  	pr6|65		j
						STATEMENT 1 ON LINE 330
		     end;

002067  aa  6 00102 0541 00	aos  	pr6|66		k
002070  aa   777760 7100 04	tra  	-16,ic		002050
						STATEMENT 1 ON LINE 331
		     req.srch.grt (rcurr) = j;

002071  aa  6 00044 3701 20	epp4 	pr6|36,*
002072  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002073  aa   000056 4020 07	mpy  	46,dl
002074  aa   000000 6270 06	eax7 	0,ql
002075  aa  6 00101 2361 00	ldq  	pr6|65		j
002076  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002077  aa  7 01745 7561 17	stq  	pr7|997,7		req.grt
						STATEMENT 1 ON LINE 332
		     line = bk_ss_$control_ptr -> backup_control.new_path (rcurr);

002100  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002101  aa   000151 4020 07	mpy  	105,dl
002102  la  4 00306 3715 20	epp5 	pr4|198,*		bk_ss_$control_ptr
002103  aa  5 00000 3715 20	epp5 	pr5|0,*		bk_ss_$control_ptr
002104  aa  5 77741 3715 06	epp5 	pr5|-31,ql	backup_control.new_path
002105  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002106  aa  5 00000 00 0250	desc9a	pr5|0,168		backup_control.new_path
002107  ia  4 00010 00 0454	desc9a	pr4|8,300		line
						STATEMENT 1 ON LINE 333
		     n = length (rtrim (line));

002110  aa   000000 6260 06	eax6 	0,ql
002111  aa  000 000 165 500	tctr 	(pr)
002112  ia  4 00010 00 0454	desc9a	pr4|8,300		line
002113  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
002114  aa  6 00056 0001 00	arg  	pr6|46
002115  aa  6 00056 2361 00	ldq  	pr6|46
002116  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
002117  aa  6 00326 7561 00	stq  	pr6|214
002120  aa   000454 2360 07	ldq  	300,dl
002121  aa  6 00326 1761 00	sbq  	pr6|214
002122  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 334
		     bk_ss_$no_primary = bk_ss_$control_ptr -> backup_control.no_primary_sw (rcurr);

002123  la  4 00306 3535 20	epp3 	pr4|198,*		bk_ss_$control_ptr
002124  aa  3 00000 3535 20	epp3 	pr3|0,*		bk_ss_$control_ptr
002125  aa  3 00013 2351 16	lda  	pr3|11,6		backup_control.no_primary_sw
002126  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002127  la  4 00314 7551 20	sta  	pr4|204,*		bk_ss_$no_primary
						STATEMENT 1 ON LINE 335
		     j = 0;

002130  aa  6 00101 4501 00	stz  	pr6|65		j
						STATEMENT 1 ON LINE 336
		     call count_grts;

002131  aa   001210 6700 04	tsp4 	648,ic		003341
						STATEMENT 1 ON LINE 337
		     ncurr = ncurr + 1;

002132  aa  6 00044 3701 20	epp4 	pr6|36,*
002133  ia  4 00232 0541 00	aos  	pr4|154		ncurr
						STATEMENT 1 ON LINE 338
		     n = req.srch.len (rcurr);

002134  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002135  aa   000056 4020 07	mpy  	46,dl
002136  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002137  aa  7 01744 2361 06	ldq  	pr7|996,ql	req.len
002140  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 339
		end;

002141  aa   000004 7100 04	tra  	4,ic		002145
						STATEMENT 1 ON LINE 340
		else req.opt.rename (rcurr) = "0"b;

002142  aa   001442 2350 04	lda  	802,ic		003604 = 377777777777
002143  ia  4 00231 7251 00	lxl5 	pr4|153		rcurr
002144  aa  5 00051 3551 15	ansa 	pr5|41,5		req.rename
						STATEMENT 1 ON LINE 341
		req.opt.exact (rcurr) = "0"b;

002145  aa   001440 2350 04	lda  	800,ic		003605 = 577777777777
002146  ia  4 00231 7271 00	lxl7 	pr4|153		rcurr
002147  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002150  aa  7 00051 3551 17	ansa 	pr7|41,7		req.exact
						STATEMENT 1 ON LINE 342
	     end;

002151  ia  4 00231 0541 00	aos  	pr4|153		rcurr
002152  aa   777574 7100 04	tra  	-132,ic		001746
						STATEMENT 1 ON LINE 343
	end;

002153  aa   000340 7100 04	tra  	224,ic		002513
						STATEMENT 1 ON LINE 345
	else do;

						STATEMENT 1 ON LINE 346
	     rbc = divide (rbc, 9, 17, 0);

002154  aa  6 00233 2361 00	ldq  	pr6|155		rbc
002155  aa   000011 5060 07	div  	9,dl
002156  aa  6 00233 7561 00	stq  	pr6|155		rbc
						STATEMENT 1 ON LINE 347
	     do while (i < rbc);

002157  aa   000000 0110 03	nop  	0,du
002160  aa  6 00100 2361 00	ldq  	pr6|64		i
002161  aa  6 00233 1161 00	cmpq 	pr6|155		rbc
002162  aa   000261 6050 04	tpl  	177,ic		002443
						STATEMENT 1 ON LINE 348
		if rlines > 500 then go to parsed_enough;

002163  aa  6 00044 3701 20	epp4 	pr6|36,*
002164  ia  4 00226 2361 00	ldq  	pr4|150		rlines
002165  aa   000764 1160 07	cmpq 	500,dl
002166  aa   000575 6054 04	tpnz 	381,ic		002763
						STATEMENT 1 ON LINE 349
		do j = i by 1 to rbc while (rptr -> rscan (j) ^= nl);

002167  aa  6 00233 2361 00	ldq  	pr6|155		rbc
002170  aa  6 00250 7561 00	stq  	pr6|168
002171  aa  6 00100 2361 00	ldq  	pr6|64		i
002172  aa  6 00101 7561 00	stq  	pr6|65		j
002173  aa   000000 0110 03	nop  	0,du
002174  aa  6 00101 2361 00	ldq  	pr6|65		j
002175  aa  6 00250 1161 00	cmpq 	pr6|168
002176  aa   000011 6054 04	tpnz 	9,ic		002207
002177  aa  6 00044 3701 20	epp4 	pr6|36,*
002200  ia  4 00214 3735 20	epp7 	pr4|140,*		rptr
002201  aa  040 106 106 500	cmpc 	(pr),(pr,ql),fill(040)
002202  ia  4 00130 00 0001	desc9a	pr4|88,1		nl
002203  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	rscan
002204  aa   000003 6000 04	tze  	3,ic		002207
						STATEMENT 1 ON LINE 350
		end;

002205  aa  6 00101 0541 00	aos  	pr6|65		j
002206  aa   777766 7100 04	tra  	-10,ic		002174
						STATEMENT 1 ON LINE 351
		n = j - i;

002207  aa  6 00100 1761 00	sbq  	pr6|64		i
002210  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 352
		k = i;

002211  aa  6 00100 2361 00	ldq  	pr6|64		i
002212  aa  6 00102 7561 00	stq  	pr6|66		k
						STATEMENT 1 ON LINE 353
		i = j + 1;

002213  aa  6 00101 2361 00	ldq  	pr6|65		j
002214  aa   000001 0760 07	adq  	1,dl
002215  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 354
		if n = 0 then go to parse_next;

002216  aa  6 00104 2361 00	ldq  	pr6|68		n
002217  aa   777741 6000 04	tze  	-31,ic		002160
						STATEMENT 1 ON LINE 355
		line = substr (rptr -> rmove, k, n);

002220  aa  6 00044 3701 20	epp4 	pr6|36,*
002221  aa  6 00102 7271 00	lxl7 	pr6|66		k
002222  ia  4 00214 3735 20	epp7 	pr4|140,*		rptr
002223  aa  040 100 100 557	mlr  	(pr,rl,x7),(pr),fill(040)
002224  aa  7 77777 60 0006	desc9a	pr7|-1(3),ql	rmove
002225  ia  4 00010 00 0454	desc9a	pr4|8,300		line
						STATEMENT 1 ON LINE 356
		if substr (line, 1, 1) ^= ">" then do;

002226  ia  4 00010 2351 00	lda  	pr4|8		line
002227  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
002230  aa   076000 1150 03	cmpa 	31744,du
002231  aa   000032 6000 04	tze  	26,ic		002263
						STATEMENT 1 ON LINE 357
		     call com_err_ (error_table_$badpath, bk_ss_$myname, "search arg of ^a", line);

002232  aa   775606 2370 04	ldaq 	-1146,ic		000040 = 163145141162 143150040141
002233  aa  6 00274 7571 00	staq 	pr6|188
002234  aa   775606 2370 04	ldaq 	-1146,ic		000042 = 162147040157 146040136141
002235  aa  6 00276 7571 00	staq 	pr6|190
002236  la  4 00240 3521 20	epp2 	pr4|160,*		error_table_$badpath
002237  aa  6 00306 2521 00	spri2	pr6|198
002240  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
002241  aa  6 00310 2521 00	spri2	pr6|200
002242  aa  6 00274 3521 00	epp2 	pr6|188
002243  aa  6 00312 2521 00	spri2	pr6|202
002244  ia  4 00010 3521 00	epp2 	pr4|8		line
002245  aa  6 00314 2521 00	spri2	pr6|204
002246  aa   775553 3520 04	epp2 	-1173,ic		000021 = 404000000043
002247  aa  6 00316 2521 00	spri2	pr6|206
002250  aa   775552 3520 04	epp2 	-1174,ic		000022 = 526000000020
002251  aa  6 00320 2521 00	spri2	pr6|208
002252  aa   775535 3520 04	epp2 	-1187,ic		000007 = 524000000020
002253  aa  6 00322 2521 00	spri2	pr6|210
002254  aa   775547 3520 04	epp2 	-1177,ic		000023 = 526000000454
002255  aa  6 00324 2521 00	spri2	pr6|212
002256  aa  6 00304 6211 00	eax1 	pr6|196
002257  aa   020000 4310 07	fld  	8192,dl
002260  la  4 00300 3521 20	epp2 	pr4|192,*		com_err_
002261  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 358
		     go to bad_p;

002262  aa   000541 7100 04	tra  	353,ic		003023
						STATEMENT 1 ON LINE 359
		end;

						STATEMENT 1 ON LINE 360
		j = index (line, "=");

002263  aa  000 003 124 500	scm  	(pr),(du),mask(000)
002264  ia  4 00010 00 0454	desc9a	pr4|8,300		line
002265  aa   075000 00 0001	desc9a	31232,1
002266  aa  6 00056 0001 00	arg  	pr6|46
002267  aa  6 00056 2361 00	ldq  	pr6|46
002270  aa   000002 6070 04	ttf  	2,ic		002272
002271  aa   000001 3360 07	lcq  	1,dl
002272  aa   000001 0760 07	adq  	1,dl
002273  aa  6 00101 7561 00	stq  	pr6|65		j
						STATEMENT 1 ON LINE 361
		if j = 0 then do;

002274  aa   000020 6010 04	tnz  	16,ic		002314
						STATEMENT 1 ON LINE 362
		     req.opt.rename (rcurr) = ""b;

002275  aa   001307 2350 04	lda  	711,ic		003604 = 377777777777
002276  ia  4 00231 7261 00	lxl6 	pr4|153		rcurr
002277  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
002300  aa  5 00051 3551 16	ansa 	pr5|41,6		req.rename
						STATEMENT 1 ON LINE 363
		     req.srch.name (rcurr) = substr (line, 1, n);

002301  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002302  aa   000056 4020 07	mpy  	46,dl
002303  aa  5 01750 3535 06	epp3 	pr5|1000,ql	req.name
002304  aa  6 00104 7251 00	lxl5 	pr6|68		n
002305  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002306  ia  4 00010 00 0015	desc9a	pr4|8,x5		line
002307  aa  3 00000 00 0250	desc9a	pr3|0,168		req.name
						STATEMENT 1 ON LINE 364
		     req.srch.len (rcurr) = n;

002310  aa   000000 6240 06	eax4 	0,ql
002311  aa  6 00104 2361 00	ldq  	pr6|68		n
002312  aa  5 01744 7561 14	stq  	pr5|996,4		req.len
						STATEMENT 1 ON LINE 365
		end;

002313  aa   000063 7100 04	tra  	51,ic		002376
						STATEMENT 1 ON LINE 366
		else do;

						STATEMENT 1 ON LINE 367
		     if j = n then do;

002314  aa  6 00104 1161 00	cmpq 	pr6|68		n
002315  aa   000031 6010 04	tnz  	25,ic		002346
						STATEMENT 1 ON LINE 368
			call com_err_ (error_table_$bad_string, bk_ss_$myname, "no new name in ^a", line);

002316  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002317  aa   775533 00 0024	desc9a	-1189,20		000051 = 156157040156
002320  aa  6 00274 00 0024	desc9a	pr6|188,20
002321  la  4 00236 3521 20	epp2 	pr4|158,*		error_table_$bad_string
002322  aa  6 00354 2521 00	spri2	pr6|236
002323  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
002324  aa  6 00356 2521 00	spri2	pr6|238
002325  aa  6 00274 3521 00	epp2 	pr6|188
002326  aa  6 00360 2521 00	spri2	pr6|240
002327  ia  4 00010 3521 00	epp2 	pr4|8		line
002330  aa  6 00362 2521 00	spri2	pr6|242
002331  aa   775470 3520 04	epp2 	-1224,ic		000021 = 404000000043
002332  aa  6 00364 2521 00	spri2	pr6|244
002333  aa   775467 3520 04	epp2 	-1225,ic		000022 = 526000000020
002334  aa  6 00366 2521 00	spri2	pr6|246
002335  aa   775454 3520 04	epp2 	-1236,ic		000011 = 524000000021
002336  aa  6 00370 2521 00	spri2	pr6|248
002337  aa   775464 3520 04	epp2 	-1228,ic		000023 = 526000000454
002340  aa  6 00372 2521 00	spri2	pr6|250
002341  aa  6 00352 6211 00	eax1 	pr6|234
002342  aa   020000 4310 07	fld  	8192,dl
002343  la  4 00300 3521 20	epp2 	pr4|192,*		com_err_
002344  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 369
			go to bad_p;

002345  aa   000456 7100 04	tra  	302,ic		003023
						STATEMENT 1 ON LINE 370
		     end;

						STATEMENT 1 ON LINE 371
		     req.opt.rename (rcurr) = "1"b;

002346  aa   400000 2350 03	lda  	131072,du
002347  ia  4 00231 7261 00	lxl6 	pr4|153		rcurr
002350  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
002351  aa  5 00051 2551 16	orsa 	pr5|41,6		req.rename
						STATEMENT 1 ON LINE 372
		     req.srch.name (rcurr) = substr (line, 1, j - 1);

002352  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002353  aa   000056 4020 07	mpy  	46,dl
002354  aa   000000 6250 06	eax5 	0,ql
002355  aa  6 00101 2361 00	ldq  	pr6|65		j
002356  aa   000001 1760 07	sbq  	1,dl
002357  aa  5 01750 3535 15	epp3 	pr5|1000,5	req.name
002360  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002361  ia  4 00010 00 0006	desc9a	pr4|8,ql		line
002362  aa  3 00000 00 0250	desc9a	pr3|0,168		req.name
						STATEMENT 1 ON LINE 373
		     req.srch.len (rcurr) = j - 1;

002363  aa  6 00101 2361 00	ldq  	pr6|65		j
002364  aa   000001 1760 07	sbq  	1,dl
002365  aa  5 01744 7561 15	stq  	pr5|996,5		req.len
						STATEMENT 1 ON LINE 374
		     req.srch.renamo (rcurr) = ncurr;

002366  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
002367  aa  5 01747 7561 15	stq  	pr5|999,5		req.renamo
						STATEMENT 1 ON LINE 375
		     call count_grts;

002370  aa   000751 6700 04	tsp4 	489,ic		003341
						STATEMENT 1 ON LINE 376
		     ncurr = ncurr + 1;

002371  aa  6 00044 3701 20	epp4 	pr6|36,*
002372  ia  4 00232 0541 00	aos  	pr4|154		ncurr
						STATEMENT 1 ON LINE 377
		     n = j - 1;

002373  aa  6 00101 2361 00	ldq  	pr6|65		j
002374  aa   000001 1760 07	sbq  	1,dl
002375  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 378
		end;

						STATEMENT 1 ON LINE 379
		call see_stars;

002376  aa   001100 6700 04	tsp4 	576,ic		003476
						STATEMENT 1 ON LINE 380
		j = 0;

002377  aa  6 00101 4501 00	stz  	pr6|65		j
						STATEMENT 1 ON LINE 381
		do k = 1 to req.srch.len (rcurr);

002400  aa  6 00044 3701 20	epp4 	pr6|36,*
002401  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002402  aa   000056 4020 07	mpy  	46,dl
002403  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002404  aa  7 01744 2361 06	ldq  	pr7|996,ql	req.len
002405  aa  6 00251 7561 00	stq  	pr6|169
002406  aa   000001 2360 07	ldq  	1,dl
002407  aa  6 00102 7561 00	stq  	pr6|66		k
002410  aa  6 00102 2361 00	ldq  	pr6|66		k
002411  aa  6 00251 1161 00	cmpq 	pr6|169
002412  aa   000017 6054 04	tpnz 	15,ic		002431
						STATEMENT 1 ON LINE 382
		     if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then j = j + 1;

002413  aa  6 00044 3701 20	epp4 	pr6|36,*
002414  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002415  aa   000056 4020 07	mpy  	46,dl
002416  aa  6 00327 7561 00	stq  	pr6|215
002417  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002420  aa  7 01750 3735 06	epp7 	pr7|1000,ql	req.name
002421  aa  6 00102 7271 00	lxl7 	pr6|66		k
002422  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
002423  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	rscan
002424  aa   001164 00 0001	desc9a	628,1		003606 = 076000000000
002425  aa   000002 6010 04	tnz  	2,ic		002427
002426  aa  6 00101 0541 00	aos  	pr6|65		j
						STATEMENT 1 ON LINE 383
		end;

002427  aa  6 00102 0541 00	aos  	pr6|66		k
002430  aa   777760 7100 04	tra  	-16,ic		002410
						STATEMENT 1 ON LINE 384
		req.srch.grt (rcurr) = j;

002431  aa  6 00044 3701 20	epp4 	pr6|36,*
002432  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002433  aa   000056 4020 07	mpy  	46,dl
002434  aa   000000 6270 06	eax7 	0,ql
002435  aa  6 00101 2361 00	ldq  	pr6|65		j
002436  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002437  aa  7 01745 7561 17	stq  	pr7|997,7		req.grt
						STATEMENT 1 ON LINE 385
		rcurr = rcurr + 1;

002440  ia  4 00231 0541 00	aos  	pr4|153		rcurr
						STATEMENT 1 ON LINE 386
		rlines = rlines + 1;

002441  ia  4 00226 0541 00	aos  	pr4|150		rlines
						STATEMENT 1 ON LINE 387
parse_next:    end;

002442  aa   777516 7100 04	tra  	-178,ic		002160
						STATEMENT 1 ON LINE 388
	     call hcs_$terminate_noname (rptr, code);

002443  aa  6 00044 3701 20	epp4 	pr6|36,*
002444  ia  4 00214 3521 00	epp2 	pr4|140		rptr
002445  aa  6 00276 2521 00	spri2	pr6|190
002446  aa  6 00232 3521 00	epp2 	pr6|154		code
002447  aa  6 00300 2521 00	spri2	pr6|192
002450  aa  6 00274 6211 00	eax1 	pr6|188
002451  aa   010000 4310 07	fld  	4096,dl
002452  la  4 00272 3521 20	epp2 	pr4|186,*		hcs_$terminate_noname
002453  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 389
	     if code ^= 0 then
		call backup_map_$fs_error_line (code, "terminate_noname", rname, "");

002454  aa  6 00232 2361 00	ldq  	pr6|154		code
002455  aa   000033 6000 04	tze  	27,ic		002510
002456  aa   775356 2370 04	ldaq 	-1298,ic		000034 = 164145162155 151156141164
002457  aa  6 00274 7571 00	staq 	pr6|188
002460  aa   775356 2370 04	ldaq 	-1298,ic		000036 = 145137156157 156141155145
002461  aa  6 00276 7571 00	staq 	pr6|190
002462  aa  6 00232 3521 00	epp2 	pr6|154		code
002463  aa  6 00332 2521 00	spri2	pr6|218
002464  aa  6 00274 3521 00	epp2 	pr6|188
002465  aa  6 00334 2521 00	spri2	pr6|220
002466  aa  6 00032 3735 20	epp7 	pr6|26,*
002467  aa  7 00002 3521 20	epp2 	pr7|2,*		rname
002470  aa  6 00336 2521 00	spri2	pr6|222
002471  aa  6 00326 3521 00	epp2 	pr6|214
002472  aa  6 00340 2521 00	spri2	pr6|224
002473  aa   775326 3520 04	epp2 	-1322,ic		000021 = 404000000043
002474  aa  6 00342 2521 00	spri2	pr6|226
002475  aa   775312 3520 04	epp2 	-1334,ic		000007 = 524000000020
002476  aa  6 00344 2521 00	spri2	pr6|228
002477  aa   775327 3520 04	epp2 	-1321,ic		000026 = 524000000250
002500  aa  6 00346 2521 00	spri2	pr6|230
002501  aa   775315 3520 04	epp2 	-1331,ic		000016 = 524000000000
002502  aa  6 00350 2521 00	spri2	pr6|232
002503  aa  6 00330 6211 00	eax1 	pr6|216
002504  aa   020000 4310 07	fld  	8192,dl
002505  aa  6 00044 3701 20	epp4 	pr6|36,*
002506  la  4 00260 3521 20	epp2 	pr4|176,*		backup_map_$fs_error_line
002507  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 391
	     rcomp = rlines;

002510  aa  6 00044 3701 20	epp4 	pr6|36,*
002511  ia  4 00226 2361 00	ldq  	pr4|150		rlines
002512  ia  4 00230 7561 00	stq  	pr4|152		rcomp
						STATEMENT 1 ON LINE 392
	end;

						STATEMENT 1 ON LINE 393
	do i = 1 to rlines;

002513  aa  6 00044 3701 20	epp4 	pr6|36,*
002514  ia  4 00226 2361 00	ldq  	pr4|150		rlines
002515  aa  6 00252 7561 00	stq  	pr6|170
002516  aa   000001 2360 07	ldq  	1,dl
002517  aa  6 00100 7561 00	stq  	pr6|64		i
002520  aa  6 00100 2361 00	ldq  	pr6|64		i
002521  aa  6 00252 1161 00	cmpq 	pr6|170
002522  aa   000234 6054 04	tpnz 	156,ic		002756
						STATEMENT 1 ON LINE 394
	     if bk_ss_$sub_entry then
		bk_ss_$no_primary = bk_ss_$control_ptr -> backup_control.no_primary_sw (i);

002523  aa  6 00044 3701 20	epp4 	pr6|36,*
002524  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
002525  aa   000007 6000 04	tze  	7,ic		002534
002526  aa   000151 4020 07	mpy  	105,dl
002527  la  4 00306 3735 20	epp7 	pr4|198,*		bk_ss_$control_ptr
002530  aa  7 00000 3735 20	epp7 	pr7|0,*		bk_ss_$control_ptr
002531  aa  7 00013 2351 06	lda  	pr7|11,ql		backup_control.no_primary_sw
002532  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002533  la  4 00314 7551 20	sta  	pr4|204,*		bk_ss_$no_primary
						STATEMENT 1 ON LINE 396
	     if ^bk_ss_$no_primary then do;

002534  la  4 00314 2351 20	lda  	pr4|204,*		bk_ss_$no_primary
002535  aa   000167 6010 04	tnz  	119,ic		002724
						STATEMENT 1 ON LINE 397
		call backup_util$get_real_name
		     (addr (req.srch.name (i)), addr (req.srch.name (rcurr)), req.srch.len (rcurr), code);

002536  aa  6 00100 2361 00	ldq  	pr6|64		i
002537  aa   000056 4020 07	mpy  	46,dl
002540  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002541  aa  7 01750 3735 06	epp7 	pr7|1000,ql	req.name
002542  aa  6 00374 6535 00	spri7	pr6|252
002543  aa  6 00326 7561 00	stq  	pr6|214
002544  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
002545  aa   000056 4020 07	mpy  	46,dl
002546  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
002547  aa  5 01750 3715 06	epp5 	pr5|1000,ql	req.name
002550  aa  6 00434 6515 00	spri5	pr6|284
002551  aa  6 00374 3521 00	epp2 	pr6|252
002552  aa  6 00306 2521 00	spri2	pr6|198
002553  aa  6 00434 3521 00	epp2 	pr6|284
002554  aa  6 00310 2521 00	spri2	pr6|200
002555  ia  4 00216 3535 20	epp3 	pr4|142,*		reqptr
002556  aa  3 01744 3521 06	epp2 	pr3|996,ql	req.len
002557  aa  6 00312 2521 00	spri2	pr6|202
002560  aa  6 00232 3521 00	epp2 	pr6|154		code
002561  aa  6 00314 2521 00	spri2	pr6|204
002562  aa  6 00436 7561 00	stq  	pr6|286
002563  aa  6 00304 6211 00	eax1 	pr6|196
002564  aa   020000 4310 07	fld  	8192,dl
002565  la  4 00264 3521 20	epp2 	pr4|180,*		backup_util$get_real_name
002566  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 399
		if code > 1 & code ^= error_table_$noentry & code ^= error_table_$no_dir &
		  code ^= error_table_$no_s_permission & code ^= error_table_$moderr &
		  code ^= error_table_$no_info then do;

002567  aa  6 00232 2361 00	ldq  	pr6|154		code
002570  aa   000001 1160 07	cmpq 	1,dl
002571  aa   000063 6044 04	tmoz 	51,ic		002654
002572  aa  6 00044 3701 20	epp4 	pr6|36,*
002573  la  4 00242 1161 20	cmpq 	pr4|162,*		error_table_$noentry
002574  aa   000060 6000 04	tze  	48,ic		002654
002575  la  4 00244 1161 20	cmpq 	pr4|164,*		error_table_$no_dir
002576  aa   000056 6000 04	tze  	46,ic		002654
002577  la  4 00246 1161 20	cmpq 	pr4|166,*		error_table_$no_s_permission
002600  aa   000054 6000 04	tze  	44,ic		002654
002601  la  4 00250 1161 20	cmpq 	pr4|168,*		error_table_$moderr
002602  aa   000052 6000 04	tze  	42,ic		002654
002603  la  4 00252 1161 20	cmpq 	pr4|170,*		error_table_$no_info
002604  aa   000050 6000 04	tze  	40,ic		002654
						STATEMENT 1 ON LINE 402
		     bk_ss_$path_index = i;

002605  aa  6 00100 2361 00	ldq  	pr6|64		i
002606  la  4 00320 7561 20	stq  	pr4|208,*		bk_ss_$path_index
						STATEMENT 1 ON LINE 403
		     call backup_map_$fs_error_line (code, (bk_ss_$myname),
			"get_real_name for "||req.srch.name (i), "");

002607  la  4 00312 3735 20	epp7 	pr4|202,*		bk_ss_$myname
002610  aa  7 00000 2351 00	lda  	pr7|0		bk_ss_$myname
002611  aa  7 00001 2361 00	ldq  	pr7|1		bk_ss_$myname
002612  aa  6 00274 7571 00	staq 	pr6|188
002613  aa  7 00002 2351 00	lda  	pr7|2		bk_ss_$myname
002614  aa  7 00003 2361 00	ldq  	pr7|3		bk_ss_$myname
002615  aa  6 00276 7571 00	staq 	pr6|190
002616  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
002617  aa   775226 00 0022	desc9a	-1386,18		000044 = 147145164137
002620  aa  6 00440 00 0022	desc9a	pr6|288,18
002621  aa  6 00326 7271 00	lxl7 	pr6|214
002622  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
002623  aa  5 01750 3715 17	epp5 	pr5|1000,7	req.name
002624  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002625  aa  5 00000 00 0250	desc9a	pr5|0,168		req.name
002626  aa  6 00444 40 0250	desc9a	pr6|292(2),168
002627  aa  6 00232 3521 00	epp2 	pr6|154		code
002630  aa  6 00354 2521 00	spri2	pr6|236
002631  aa  6 00274 3521 00	epp2 	pr6|188
002632  aa  6 00356 2521 00	spri2	pr6|238
002633  aa  6 00440 3521 00	epp2 	pr6|288
002634  aa  6 00360 2521 00	spri2	pr6|240
002635  aa  6 00437 3521 00	epp2 	pr6|287
002636  aa  6 00362 2521 00	spri2	pr6|242
002637  aa   775162 3520 04	epp2 	-1422,ic		000021 = 404000000043
002640  aa  6 00364 2521 00	spri2	pr6|244
002641  aa   775146 3520 04	epp2 	-1434,ic		000007 = 524000000020
002642  aa  6 00366 2521 00	spri2	pr6|246
002643  aa   775143 3520 04	epp2 	-1437,ic		000006 = 524000000272
002644  aa  6 00370 2521 00	spri2	pr6|248
002645  aa   775151 3520 04	epp2 	-1431,ic		000016 = 524000000000
002646  aa  6 00372 2521 00	spri2	pr6|250
002647  aa  6 00352 6211 00	eax1 	pr6|234
002650  aa   020000 4310 07	fld  	8192,dl
002651  la  4 00260 3521 20	epp2 	pr4|176,*		backup_map_$fs_error_line
002652  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 405
		     go to bad_p;

002653  aa   000150 7100 04	tra  	104,ic		003023
						STATEMENT 1 ON LINE 406
		end;

						STATEMENT 1 ON LINE 407
		else if code = 1 then do;

002654  aa   000001 1160 07	cmpq 	1,dl
002655  aa   000050 6010 04	tnz  	40,ic		002725
						STATEMENT 1 ON LINE 408
		     req.opt (rcurr) = req.opt (i);

002656  aa  6 00044 3701 20	epp4 	pr6|36,*
002657  ia  4 00231 7271 00	lxl7 	pr4|153		rcurr
002660  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002661  aa  6 00100 7261 00	lxl6 	pr6|64		i
002662  aa  7 00051 2351 16	lda  	pr7|41,6		req.opt
002663  aa  7 00051 7551 17	sta  	pr7|41,7		req.opt
						STATEMENT 1 ON LINE 409
		     req.opt.synonym (rcurr) = "1"b;

002664  aa   100000 2350 03	lda  	32768,du
002665  aa  7 00051 2551 17	orsa 	pr7|41,7		req.synonym
						STATEMENT 1 ON LINE 410
		     req.srch.renamo (rcurr) = i;

002666  aa  6 00100 2361 00	ldq  	pr6|64		i
002667  aa  6 00436 7251 00	lxl5 	pr6|286
002670  aa  7 01747 7561 15	stq  	pr7|999,5		req.renamo
						STATEMENT 1 ON LINE 411
		     req.srch.control_index (rcurr) = req.srch.control_index (i);

002671  aa  6 00326 7241 00	lxl4 	pr6|214
002672  aa  7 01746 2361 14	ldq  	pr7|998,4		req.control_index
002673  aa  7 01746 7561 15	stq  	pr7|998,5		req.control_index
						STATEMENT 1 ON LINE 413
		     req.srch.grt (rcurr) = req.srch.grt (i);

002674  aa  7 01745 2361 14	ldq  	pr7|997,4		req.grt
002675  aa  7 01745 7561 15	stq  	pr7|997,5		req.grt
						STATEMENT 1 ON LINE 414
		     req.srch.name (rcurr) = substr (req.srch.name (rcurr), 1, req.srch.len (rcurr)) || ">";

002676  aa  6 00436 2361 00	ldq  	pr6|286
002677  aa   000002 7360 00	qls  	2
002700  aa   000000 6230 06	eax3 	0,ql
002701  aa  7 01744 2361 15	ldq  	pr7|996,5		req.len
002702  aa   000001 0760 07	adq  	1,dl
002703  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002704  aa  7 01744 7221 15	lxl2 	pr7|996,5		req.len
002705  aa  040 140 100 553	mlr  	(pr,rl,x3),(pr,rl),fill(040)
002706  aa  7 01750 00 0012	desc9a	pr7|1000,x2	req.name
002707  aa  2 00000 00 0012	desc9a	pr2|0,x2
002710  aa  040 112 100 404	mlr  	(ic),(pr,x2),fill(040)
002711  aa   000676 00 0001	desc9a	446,1		003606 = 076000000000
002712  aa  2 00000 00 0001	desc9a	pr2|0,1
002713  aa  7 01750 3715 15	epp5 	pr7|1000,5	req.name
002714  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002715  aa  2 00000 00 0006	desc9a	pr2|0,ql
002716  aa  5 00000 00 0250	desc9a	pr5|0,168		req.name
						STATEMENT 1 ON LINE 415
		     req.srch.len (rcurr) = req.srch.len (rcurr) + 1;

002717  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002720  aa  7 01744 0541 15	aos  	pr7|996,5		req.len
						STATEMENT 1 ON LINE 416
		     rcurr = rcurr + 1;

002721  ia  4 00231 0541 00	aos  	pr4|153		rcurr
						STATEMENT 1 ON LINE 417
		     rlines = rlines + 1;

002722  ia  4 00226 0541 00	aos  	pr4|150		rlines
						STATEMENT 1 ON LINE 418
		end;

						STATEMENT 1 ON LINE 419
	     end;

002723  aa   000002 7100 04	tra  	2,ic		002725
						STATEMENT 1 ON LINE 420
	     else code = 0;

002724  aa  6 00232 4501 00	stz  	pr6|154		code
						STATEMENT 1 ON LINE 421
	     req.srch.name (i) = substr (req.srch.name (i), 1, req.srch.len (i)) || ">";

002725  aa  6 00100 2361 00	ldq  	pr6|64		i
002726  aa   000056 4020 07	mpy  	46,dl
002727  aa   000000 6270 06	eax7 	0,ql
002730  aa   000002 7360 00	qls  	2
002731  aa  6 00044 3701 20	epp4 	pr6|36,*
002732  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
002733  aa   000000 6260 06	eax6 	0,ql
002734  aa  7 01744 2361 17	ldq  	pr7|996,7		req.len
002735  aa   000001 0760 07	adq  	1,dl
002736  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
002737  aa  7 01744 7251 17	lxl5 	pr7|996,7		req.len
002740  aa  040 140 100 556	mlr  	(pr,rl,x6),(pr,rl),fill(040)
002741  aa  7 01750 00 0015	desc9a	pr7|1000,x5	req.name
002742  aa  2 00000 00 0015	desc9a	pr2|0,x5
002743  aa  040 115 100 404	mlr  	(ic),(pr,x5),fill(040)
002744  aa   000643 00 0001	desc9a	419,1		003606 = 076000000000
002745  aa  2 00000 00 0001	desc9a	pr2|0,1
002746  aa  7 01750 3715 17	epp5 	pr7|1000,7	req.name
002747  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002750  aa  2 00000 00 0006	desc9a	pr2|0,ql
002751  aa  5 00000 00 0250	desc9a	pr5|0,168		req.name
						STATEMENT 1 ON LINE 422
	     req.srch.len (i) = req.srch.len (i) + 1;

002752  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
002753  aa  7 01744 0541 17	aos  	pr7|996,7		req.len
						STATEMENT 1 ON LINE 423
	end;

002754  aa  6 00100 0541 00	aos  	pr6|64		i
002755  aa   777543 7100 04	tra  	-157,ic		002520
						STATEMENT 1 ON LINE 424
	rcurr = 0;

002756  aa  6 00044 3701 20	epp4 	pr6|36,*
002757  ia  4 00231 4501 00	stz  	pr4|153		rcurr
						STATEMENT 1 ON LINE 425
	label_index = parsed;

002760  ia  4 00220 2361 00	ldq  	pr4|144		parsed
002761  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 426
	go to exit;

002762  aa   000356 7100 04	tra  	238,ic		003340
						STATEMENT 1 ON LINE 428
parsed_enough: call ioa_$rsnnl			/* here if too many requests for request table */
	     ("^a: over 500 retrieval requests. Reload ended.", line, n, bk_ss_$myname);

002763  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002764  aa   775150 00 0060	desc9a	-1432,48		000133 = 136141072040
002765  aa  6 00330 00 0060	desc9a	pr6|216,48
002766  aa  6 00330 3521 00	epp2 	pr6|216
002767  aa  6 00306 2521 00	spri2	pr6|198
002770  ia  4 00010 3521 00	epp2 	pr4|8		line
002771  aa  6 00310 2521 00	spri2	pr6|200
002772  aa  6 00104 3521 00	epp2 	pr6|68		n
002773  aa  6 00312 2521 00	spri2	pr6|202
002774  la  4 00312 3521 20	epp2 	pr4|202,*		bk_ss_$myname
002775  aa  6 00314 2521 00	spri2	pr6|204
002776  aa   775007 3520 04	epp2 	-1529,ic		000005 = 524000000056
002777  aa  6 00316 2521 00	spri2	pr6|206
003000  aa   775023 3520 04	epp2 	-1517,ic		000023 = 526000000454
003001  aa  6 00320 2521 00	spri2	pr6|208
003002  aa   775023 3520 04	epp2 	-1517,ic		000025 = 404000000021
003003  aa  6 00322 2521 00	spri2	pr6|210
003004  aa   775016 3520 04	epp2 	-1522,ic		000022 = 526000000020
003005  aa  6 00324 2521 00	spri2	pr6|212
003006  aa  6 00304 6211 00	eax1 	pr6|196
003007  aa   020000 4310 07	fld  	8192,dl
003010  la  4 00304 3521 20	epp2 	pr4|196,*		ioa_$rsnnl
003011  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 430
	call backup_map_$on_line (line_pointer, n);

003012  aa  6 00044 3701 20	epp4 	pr6|36,*
003013  ia  4 00124 3521 00	epp2 	pr4|84		line_pointer
003014  aa  6 00276 2521 00	spri2	pr6|190
003015  aa  6 00104 3521 00	epp2 	pr6|68		n
003016  aa  6 00300 2521 00	spri2	pr6|192
003017  aa  6 00274 6211 00	eax1 	pr6|188
003020  aa   010000 4310 07	fld  	4096,dl
003021  la  4 00262 3521 20	epp2 	pr4|178,*		backup_map_$on_line
003022  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 431
bad_p:	call hcs_$terminate_noname (rptr, code);

003023  aa  6 00044 3701 20	epp4 	pr6|36,*
003024  ia  4 00214 3521 00	epp2 	pr4|140		rptr
003025  aa  6 00276 2521 00	spri2	pr6|190
003026  aa  6 00232 3521 00	epp2 	pr6|154		code
003027  aa  6 00300 2521 00	spri2	pr6|192
003030  aa  6 00274 6211 00	eax1 	pr6|188
003031  aa   010000 4310 07	fld  	4096,dl
003032  la  4 00272 3521 20	epp2 	pr4|186,*		hcs_$terminate_noname
003033  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 432
	code = error_table_$arg_ignored;

003034  aa  6 00044 3701 20	epp4 	pr6|36,*
003035  la  4 00254 2361 20	ldq  	pr4|172,*		error_table_$arg_ignored
003036  aa  6 00232 7561 00	stq  	pr6|154		code
						STATEMENT 1 ON LINE 433
	rlines = 0;

003037  ia  4 00226 4501 00	stz  	pr4|150		rlines
						STATEMENT 1 ON LINE 434
	label_index = terminate;

003040  ia  4 00223 2361 00	ldq  	pr4|147		terminate
003041  aa  6 00240 7561 20	stq  	pr6|160,*		label_index
						STATEMENT 1 ON LINE 436
	return;

003042  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO report_retrieval                                   STATEMENT 1 ON LINE 488
report_retrieval: entry;

003043  da     000362200000
003044  aa   000560 6270 00	eax7 	368
003045  aa  7 00034 3521 20	epp2 	pr7|28,*
003046  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
003047  aa     000000000000
003050  aa     000000000000
003051  aa   775135 7000 04	tsx0 	-1443,ic		000206
						STATEMENT 1 ON LINE 492
	if rlines = 0 then go to exit;

003052  aa  6 00044 3701 20	epp4 	pr6|36,*
003053  ia  4 00226 2361 00	ldq  	pr4|150		rlines
003054  aa   000264 6000 04	tze  	180,ic		003340
						STATEMENT 1 ON LINE 493
	if bk_ss_$sub_entry then go to reportend;

003055  la  4 00324 2351 20	lda  	pr4|212,*		bk_ss_$sub_entry
003056  aa   000246 6010 04	tnz  	166,ic		003324
						STATEMENT 1 ON LINE 494
	call hcs_$initiate_count (rdname, rename, "", rbc, 1, rptr, code);

003057  aa   000001 2360 07	ldq  	1,dl
003060  aa  6 00326 7561 00	stq  	pr6|214
003061  ia  4 00131 3521 00	epp2 	pr4|89		rdname
003062  aa  6 00400 2521 00	spri2	pr6|256
003063  ia  4 00203 3521 00	epp2 	pr4|131		rename
003064  aa  6 00402 2521 00	spri2	pr6|258
003065  aa  6 00436 3521 00	epp2 	pr6|286
003066  aa  6 00404 2521 00	spri2	pr6|260
003067  aa  6 00233 3521 00	epp2 	pr6|155		rbc
003070  aa  6 00406 2521 00	spri2	pr6|262
003071  aa  6 00326 3521 00	epp2 	pr6|214
003072  aa  6 00410 2521 00	spri2	pr6|264
003073  ia  4 00214 3521 00	epp2 	pr4|140		rptr
003074  aa  6 00412 2521 00	spri2	pr6|266
003075  aa  6 00232 3521 00	epp2 	pr6|154		code
003076  aa  6 00414 2521 00	spri2	pr6|268
003077  aa   774727 3520 04	epp2 	-1577,ic		000026 = 524000000250
003100  aa  6 00416 2521 00	spri2	pr6|270
003101  aa   774713 3520 04	epp2 	-1589,ic		000014 = 524000000040
003102  aa  6 00420 2521 00	spri2	pr6|272
003103  aa   774713 3520 04	epp2 	-1589,ic		000016 = 524000000000
003104  aa  6 00422 2521 00	spri2	pr6|274
003105  aa   774720 3520 04	epp2 	-1584,ic		000025 = 404000000021
003106  aa  6 00424 2521 00	spri2	pr6|276
003107  aa   774704 3520 04	epp2 	-1596,ic		000013 = 404000000002
003110  aa  6 00426 2521 00	spri2	pr6|278
003111  aa   774716 3520 04	epp2 	-1586,ic		000027 = 464000000000
003112  aa  6 00430 2521 00	spri2	pr6|280
003113  aa   774706 3520 04	epp2 	-1594,ic		000021 = 404000000043
003114  aa  6 00432 2521 00	spri2	pr6|282
003115  aa  6 00376 6211 00	eax1 	pr6|254
003116  aa   034000 4310 07	fld  	14336,dl
003117  la  4 00276 3521 20	epp2 	pr4|190,*		hcs_$initiate_count
003120  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 495
	if code ^= 0 & code ^= error_table_$segknown then do;

003121  aa  6 00232 2361 00	ldq  	pr6|154		code
003122  aa   000033 6000 04	tze  	27,ic		003155
003123  aa  6 00044 3701 20	epp4 	pr6|36,*
003124  la  4 00256 1161 20	cmpq 	pr4|174,*		error_table_$segknown
003125  aa   000030 6000 04	tze  	24,ic		003155
						STATEMENT 1 ON LINE 496
	     call backup_map_$fs_error_line (code, "initiate", rdname, rename);

003126  aa   774702 2370 04	ldaq 	-1598,ic		000030 = 151156151164 151141164145
003127  aa  6 00434 7571 00	staq 	pr6|284
003130  aa  6 00232 3521 00	epp2 	pr6|154		code
003131  aa  6 00354 2521 00	spri2	pr6|236
003132  aa  6 00434 3521 00	epp2 	pr6|284
003133  aa  6 00356 2521 00	spri2	pr6|238
003134  ia  4 00131 3521 00	epp2 	pr4|89		rdname
003135  aa  6 00360 2521 00	spri2	pr6|240
003136  ia  4 00203 3521 00	epp2 	pr4|131		rename
003137  aa  6 00362 2521 00	spri2	pr6|242
003140  aa   774661 3520 04	epp2 	-1615,ic		000021 = 404000000043
003141  aa  6 00364 2521 00	spri2	pr6|244
003142  aa   774642 3520 04	epp2 	-1630,ic		000004 = 524000000010
003143  aa  6 00366 2521 00	spri2	pr6|246
003144  aa   774662 3520 04	epp2 	-1614,ic		000026 = 524000000250
003145  aa  6 00370 2521 00	spri2	pr6|248
003146  aa   774646 3520 04	epp2 	-1626,ic		000014 = 524000000040
003147  aa  6 00372 2521 00	spri2	pr6|250
003150  aa  6 00352 6211 00	eax1 	pr6|234
003151  aa   020000 4310 07	fld  	8192,dl
003152  la  4 00260 3521 20	epp2 	pr4|176,*		backup_map_$fs_error_line
003153  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 497
	     go to reportend;

003154  aa   000150 7100 04	tra  	104,ic		003324
						STATEMENT 1 ON LINE 498
	end;

						STATEMENT 1 ON LINE 499
	rbc = divide (rbc, 9, 17, 0);

003155  aa  6 00233 2361 00	ldq  	pr6|155		rbc
003156  aa   000011 5060 07	div  	9,dl
003157  aa  6 00233 7561 00	stq  	pr6|155		rbc
						STATEMENT 1 ON LINE 500
	i, k = 1;

003160  aa   000001 2360 07	ldq  	1,dl
003161  aa  6 00100 7561 00	stq  	pr6|64		i
003162  aa  6 00102 7561 00	stq  	pr6|66		k
						STATEMENT 1 ON LINE 501
	unsatisfied = ""b;

003163  aa  6 00235 4501 00	stz  	pr6|157		unsatisfied
						STATEMENT 1 ON LINE 503
next_req:	n = index (substr (rptr -> rmove, i, rbc), nl);

003164  aa  6 00044 3701 20	epp4 	pr6|36,*
003165  aa  6 00100 7271 00	lxl7 	pr6|64		i
003166  ia  4 00214 3735 20	epp7 	pr4|140,*		rptr
003167  aa  6 00233 7261 00	lxl6 	pr6|155		rbc
003170  aa  000 100 124 557	scm  	(pr,rl,x7),(pr),mask(000)
003171  aa  7 77777 60 0016	desc9a	pr7|-1(3),x6	rmove
003172  ia  4 00130 00 0001	desc9a	pr4|88,1		nl
003173  aa  6 00056 0001 00	arg  	pr6|46
003174  aa  6 00056 2361 00	ldq  	pr6|46
003175  aa   000002 6070 04	ttf  	2,ic		003177
003176  aa   000001 3360 07	lcq  	1,dl
003177  aa   000001 0760 07	adq  	1,dl
003200  aa  6 00104 7561 00	stq  	pr6|68		n
						STATEMENT 1 ON LINE 504
	if n ^= 0 then				/* Found one */
	     if ^req.opt (k).found then do;

003201  aa   000104 6000 04	tze  	68,ic		003305
003202  aa  6 00102 7251 00	lxl5 	pr6|66		k
003203  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
003204  aa  5 00051 2351 15	lda  	pr5|41,5		req.found
003205  aa   040000 3150 03	cana 	16384,du
003206  aa   000077 6010 04	tnz  	63,ic		003305
						STATEMENT 1 ON LINE 506
		if ^unsatisfied then do;

003207  aa  6 00235 2351 00	lda  	pr6|157		unsatisfied
003210  aa   000016 6010 04	tnz  	14,ic		003226
						STATEMENT 1 ON LINE 507
		     call ioa_ ("The following requests were not satisfied:");

003211  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003212  aa   774707 00 0054	desc9a	-1593,44		000120 = 124150145040
003213  aa  6 00304 00 0054	desc9a	pr6|196,44
003214  aa  6 00304 3521 00	epp2 	pr6|196
003215  aa  6 00276 2521 00	spri2	pr6|190
003216  aa   774565 3520 04	epp2 	-1675,ic		000003 = 524000000052
003217  aa  6 00300 2521 00	spri2	pr6|192
003220  aa  6 00274 6211 00	eax1 	pr6|188
003221  aa   004000 4310 07	fld  	2048,dl
003222  la  4 00302 3521 20	epp2 	pr4|194,*		ioa_
003223  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 508
		     unsatisfied = "1"b;

003224  aa   400000 2350 03	lda  	131072,du
003225  aa  6 00235 7551 00	sta  	pr6|157		unsatisfied
						STATEMENT 1 ON LINE 509
		end;

						STATEMENT 1 ON LINE 511
		call ioa_ ("^a^/   Search name: ^a",
		     substr (rptr -> rmove, i, n-1),
		     substr (req.srch (k).name, 1, req.srch (k).len));

003226  aa  6 00104 2361 00	ldq  	pr6|68		n
003227  aa   000001 1760 07	sbq  	1,dl
003230  aa  6 00436 7561 00	stq  	pr6|286
003231  aa   524000 2760 03	orq  	174080,du
003232  aa  6 00326 7561 00	stq  	pr6|214
003233  aa  6 00102 2361 00	ldq  	pr6|66		k
003234  aa   000056 4020 07	mpy  	46,dl
003235  aa  6 00044 3701 20	epp4 	pr6|36,*
003236  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003237  aa  6 00517 7561 00	stq  	pr6|335
003240  aa  7 01744 2361 06	ldq  	pr7|996,ql	req.len
003241  aa   524000 2760 03	orq  	174080,du
003242  aa  6 00437 7561 00	stq  	pr6|287
003243  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003244  aa   774620 00 0030	desc9a	-1648,24		000063 = 136141136057
003245  aa  6 00274 00 0030	desc9a	pr6|188,24
003246  aa  6 00436 2361 00	ldq  	pr6|286
003247  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
003250  aa  6 00334 2521 00	spri2	pr6|220
003251  aa  6 00100 7271 00	lxl7 	pr6|64		i
003252  ia  4 00214 3715 20	epp5 	pr4|140,*		rptr
003253  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
003254  aa  5 77777 60 0006	desc9a	pr5|-1(3),ql	rmove
003255  aa  2 00000 00 0006	desc9a	pr2|0,ql
003256  aa  6 00517 2361 00	ldq  	pr6|335
003257  aa   000002 7360 00	qls  	2
003260  aa  6 00517 7261 00	lxl6 	pr6|335
003261  aa   000000 6250 06	eax5 	0,ql
003262  aa  7 01744 2361 16	ldq  	pr7|996,6		req.len
003263  aa  0 00551 7001 00	tsx0 	pr0|361		alloc_char_temp
003264  aa  6 00336 2521 00	spri2	pr6|222
003265  aa  040 140 100 555	mlr  	(pr,rl,x5),(pr,rl),fill(040)
003266  aa  7 01750 00 0006	desc9a	pr7|1000,ql	req.name
003267  aa  2 00000 00 0006	desc9a	pr2|0,ql
003270  aa  6 00274 3521 00	epp2 	pr6|188
003271  aa  6 00332 2521 00	spri2	pr6|218
003272  aa   774510 3520 04	epp2 	-1720,ic		000002 = 524000000026
003273  aa  6 00340 2521 00	spri2	pr6|224
003274  aa  6 00326 3521 00	epp2 	pr6|214
003275  aa  6 00342 2521 00	spri2	pr6|226
003276  aa  6 00437 3521 00	epp2 	pr6|287
003277  aa  6 00344 2521 00	spri2	pr6|228
003300  aa  6 00330 6211 00	eax1 	pr6|216
003301  aa   014000 4310 07	fld  	6144,dl
003302  la  4 00302 3521 20	epp2 	pr4|194,*		ioa_
003303  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 514
	     end;

003304  aa  0 01014 7001 00	tsx0 	pr0|524		shorten_stack
						STATEMENT 1 ON LINE 516
	i = i + n;

003305  aa  6 00104 2361 00	ldq  	pr6|68		n
003306  aa  6 00100 0561 00	asq  	pr6|64		i
						STATEMENT 1 ON LINE 517
	k = k + 1;

003307  aa  6 00102 0541 00	aos  	pr6|66		k
						STATEMENT 1 ON LINE 519
	if i < rbc then go to next_req;

003310  aa  6 00100 2361 00	ldq  	pr6|64		i
003311  aa  6 00233 1161 00	cmpq 	pr6|155		rbc
003312  aa   777652 6040 04	tmi  	-86,ic		003164
						STATEMENT 1 ON LINE 521
	call hcs_$terminate_noname (rptr, code);

003313  aa  6 00044 3701 20	epp4 	pr6|36,*
003314  ia  4 00214 3521 00	epp2 	pr4|140		rptr
003315  aa  6 00276 2521 00	spri2	pr6|190
003316  aa  6 00232 3521 00	epp2 	pr6|154		code
003317  aa  6 00300 2521 00	spri2	pr6|192
003320  aa  6 00274 6211 00	eax1 	pr6|188
003321  aa   010000 4310 07	fld  	4096,dl
003322  la  4 00272 3521 20	epp2 	pr4|186,*		hcs_$terminate_noname
003323  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 522
reportend: call hcs_$truncate_seg (reqptr, 0, code);

003324  aa  6 00326 4501 00	stz  	pr6|214
003325  aa  6 00044 3701 20	epp4 	pr6|36,*
003326  ia  4 00216 3521 00	epp2 	pr4|142		reqptr
003327  aa  6 00354 2521 00	spri2	pr6|236
003330  aa  6 00326 3521 00	epp2 	pr6|214
003331  aa  6 00356 2521 00	spri2	pr6|238
003332  aa  6 00232 3521 00	epp2 	pr6|154		code
003333  aa  6 00360 2521 00	spri2	pr6|240
003334  aa  6 00352 6211 00	eax1 	pr6|234
003335  aa   014000 4310 07	fld  	6144,dl
003336  la  4 00274 3521 20	epp2 	pr4|188,*		hcs_$truncate_seg
003337  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 523
exit:	return;

003340  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 524
     end;

BEGIN PROCEDURE count_grts
ENTRY TO count_grts                                         STATEMENT 1 ON LINE 439
count_grts: proc;

003341  aa  6 00254 6501 00	spri4	pr6|172
						STATEMENT 1 ON LINE 441
	     req.newn.ngrt (ncurr) = 0;

003342  aa  6 00044 3701 20	epp4 	pr6|36,*
003343  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
003344  aa   000055 4020 07	mpy  	45,dl
003345  aa   100000 6270 06	eax7 	32768,ql
003346  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003347  aa  7 33627 4501 17	stz  	pr7|14231,7	req.ngrt
						STATEMENT 1 ON LINE 442
	     if substr (line, j + 1, 1) = ">" then do;

003350  aa  6 00521 7561 00	stq  	pr6|337
003351  aa  6 00101 7261 00	lxl6 	pr6|65		j
003352  aa  040 004 106 516	cmpc 	(pr,x6),(ic),fill(040)
003353  ia  4 00010 00 0001	desc9a	pr4|8,1		line
003354  aa   000234 00 0001	desc9a	156,1		003606 = 076000000000
003355  aa   000106 6010 04	tnz  	70,ic		003463
						STATEMENT 1 ON LINE 443
		req.newn.ndname (ncurr) = substr (line, j + 1, n - j);

003356  aa  6 00104 2361 00	ldq  	pr6|68		n
003357  aa  6 00101 1761 00	sbq  	pr6|65		j
003360  aa  7 33630 3715 17	epp5 	pr7|14232,7	req.ndname
003361  aa  040 100 100 556	mlr  	(pr,rl,x6),(pr),fill(040)
003362  ia  4 00010 00 0006	desc9a	pr4|8,ql		line
003363  aa  5 00000 00 0250	desc9a	pr5|0,168		req.ndname
						STATEMENT 1 ON LINE 444
		req.newn.ndlen (ncurr) = n - j;

003364  aa  6 00104 2361 00	ldq  	pr6|68		n
003365  aa  6 00101 1761 00	sbq  	pr6|65		j
003366  aa  7 33625 7561 17	stq  	pr7|14229,7	req.ndlen
						STATEMENT 1 ON LINE 445
		if ^bk_ss_$no_primary then call backup_util$get_real_name  /* use primary pathname */
		     (addr (req.newn.ndname (ncurr)), addr (req.newn.ndname (ncurr)), req.newn.ndlen (ncurr), code);

003367  la  4 00314 2351 20	lda  	pr4|204,*		bk_ss_$no_primary
003370  aa   000022 6010 04	tnz  	18,ic		003412
003371  aa  7 33630 3535 17	epp3 	pr7|14232,7	req.ndname
003372  aa  6 00522 2535 00	spri3	pr6|338
003373  aa  7 33630 3515 17	epp1 	pr7|14232,7	req.ndname
003374  aa  6 00524 2515 00	spri1	pr6|340
003375  aa  6 00522 3521 00	epp2 	pr6|338
003376  aa  6 00530 2521 00	spri2	pr6|344
003377  aa  6 00524 3521 00	epp2 	pr6|340
003400  aa  6 00532 2521 00	spri2	pr6|346
003401  aa  7 33625 3521 17	epp2 	pr7|14229,7	req.ndlen
003402  aa  6 00534 2521 00	spri2	pr6|348
003403  aa  6 00232 3521 00	epp2 	pr6|154		code
003404  aa  6 00536 2521 00	spri2	pr6|350
003405  aa  6 00526 6211 00	eax1 	pr6|342
003406  aa   020000 4310 07	fld  	8192,dl
003407  la  4 00264 3521 20	epp2 	pr4|180,*		backup_util$get_real_name
003410  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
003411  aa   000002 7100 04	tra  	2,ic		003413
						STATEMENT 1 ON LINE 447
		else code = 0;

003412  aa  6 00232 4501 00	stz  	pr6|154		code
						STATEMENT 1 ON LINE 448
		do k = 1 to req.newn.ndlen (ncurr);

003413  aa  6 00044 3701 20	epp4 	pr6|36,*
003414  aa  6 00521 7271 00	lxl7 	pr6|337
003415  aa   100000 6270 17	eax7 	32768,7
003416  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003417  aa  7 33625 2361 17	ldq  	pr7|14229,7	req.ndlen
003420  aa  6 00262 7561 00	stq  	pr6|178
003421  aa   000001 2360 07	ldq  	1,dl
003422  aa  6 00102 7561 00	stq  	pr6|66		k
003423  aa   000000 0110 03	nop  	0,du
003424  aa  6 00102 2361 00	ldq  	pr6|66		k
003425  aa  6 00262 1161 00	cmpq 	pr6|178
003426  aa   000023 6054 04	tpnz 	19,ic		003451
						STATEMENT 1 ON LINE 449
		     if addr (req.newn.ndname (ncurr)) -> rscan (k) = ">" then do;

003427  aa  6 00044 3701 20	epp4 	pr6|36,*
003430  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
003431  aa   000055 4020 07	mpy  	45,dl
003432  aa  6 00540 7561 00	stq  	pr6|352
003433  aa   100000 6270 06	eax7 	32768,ql
003434  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003435  aa  7 33630 3735 17	epp7 	pr7|14232,7	req.ndname
003436  aa  6 00102 7261 00	lxl6 	pr6|66		k
003437  aa  040 004 106 516	cmpc 	(pr,x6),(ic),fill(040)
003440  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	rscan
003441  aa   000147 00 0001	desc9a	103,1		003606 = 076000000000
003442  aa   000005 6010 04	tnz  	5,ic		003447
						STATEMENT 1 ON LINE 450
			req.newn.ngrt (ncurr) = req.newn.ngrt (ncurr) + 1;

003443  ia  4 00216 3715 20	epp5 	pr4|142,*		reqptr
003444  aa  5 33627 0541 17	aos  	pr5|14231,7	req.ngrt
						STATEMENT 1 ON LINE 451
			l = k;

003445  aa  6 00102 2361 00	ldq  	pr6|66		k
003446  aa  6 00103 7561 00	stq  	pr6|67		l
						STATEMENT 1 ON LINE 452
		     end;

						STATEMENT 1 ON LINE 453
		end;

003447  aa  6 00102 0541 00	aos  	pr6|66		k
003450  aa   777754 7100 04	tra  	-20,ic		003424
						STATEMENT 1 ON LINE 454
		req.newn.nelen (ncurr) = req.newn.ndlen (ncurr) - l;

003451  aa  6 00044 3701 20	epp4 	pr6|36,*
003452  ia  4 00232 2361 00	ldq  	pr4|154		ncurr
003453  aa   000055 4020 07	mpy  	45,dl
003454  aa   100000 6270 06	eax7 	32768,ql
003455  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003456  aa  6 00541 7561 00	stq  	pr6|353
003457  aa  7 33625 2361 17	ldq  	pr7|14229,7	req.ndlen
003460  aa  6 00103 1761 00	sbq  	pr6|67		l
003461  aa  7 33626 7561 17	stq  	pr7|14230,7	req.nelen
						STATEMENT 1 ON LINE 455
	     end;

003462  aa   000013 7100 04	tra  	11,ic		003475
						STATEMENT 1 ON LINE 456
	     else do;

						STATEMENT 1 ON LINE 457
		req.newn.ndlen (ncurr) = 0;

003463  aa  7 33625 4501 17	stz  	pr7|14229,7	req.ndlen
						STATEMENT 1 ON LINE 458
		req.newn.ndname (ncurr) = substr (line, j + 1, n - j);

003464  aa  6 00104 2361 00	ldq  	pr6|68		n
003465  aa  6 00101 1761 00	sbq  	pr6|65		j
003466  aa  7 33630 3715 17	epp5 	pr7|14232,7	req.ndname
003467  aa  040 100 100 556	mlr  	(pr,rl,x6),(pr),fill(040)
003470  ia  4 00010 00 0006	desc9a	pr4|8,ql		line
003471  aa  5 00000 00 0250	desc9a	pr5|0,168		req.ndname
						STATEMENT 1 ON LINE 459
		req.newn.nelen (ncurr) = n - j;

003472  aa  6 00104 2361 00	ldq  	pr6|68		n
003473  aa  6 00101 1761 00	sbq  	pr6|65		j
003474  aa  7 33626 7561 17	stq  	pr7|14230,7	req.nelen
						STATEMENT 1 ON LINE 460
	     end;

						STATEMENT 1 ON LINE 462
	end count_grts;

003475  aa  6 00254 6101 00	rtcd 	pr6|172
  END PROCEDURE count_grts
BEGIN PROCEDURE see_stars
ENTRY TO see_stars                                          STATEMENT 1 ON LINE 465
see_stars: proc;

003476  aa  6 00264 6501 00	spri4	pr6|180
						STATEMENT 1 ON LINE 467
	     if substr (req.srch.name (rcurr), n - 2, 3) = ">**" then do;

003477  aa  6 00104 2361 00	ldq  	pr6|68		n
003500  aa   000003 1760 07	sbq  	3,dl
003501  aa  6 00542 7561 00	stq  	pr6|354
003502  aa  6 00044 3701 20	epp4 	pr6|36,*
003503  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
003504  aa   000056 4020 07	mpy  	46,dl
003505  aa  6 00543 7561 00	stq  	pr6|355
003506  aa   000002 7360 00	qls  	2
003507  aa  6 00542 0761 00	adq  	pr6|354
003510  aa  6 00542 7561 00	stq  	pr6|354
003511  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003512  aa  040 004 106 506	cmpc 	(pr,ql),(ic),fill(040)
003513  aa  7 01750 00 0003	desc9a	pr7|1000,3	req.name
003514  aa   774267 00 0003	desc9a	-1865,3		000001 = 076052052000
003515  aa   000047 6010 04	tnz  	39,ic		003564
						STATEMENT 1 ON LINE 468
		req.opt.exact (rcurr) = ""b;

003516  aa   000067 2350 04	lda  	55,ic		003605 = 577777777777
003517  ia  4 00231 7271 00	lxl7 	pr4|153		rcurr
003520  aa  7 00051 3551 17	ansa 	pr7|41,7		req.exact
						STATEMENT 1 ON LINE 469
		substr (req.srch.name (rcurr), n - 2, 3) = "";

003521  aa  040 106 100 400	mlr  	(),(pr,ql),fill(040)
003522  aa   000000 00 0000	desc9a	0,0
003523  aa  7 01750 00 0003	desc9a	pr7|1000,3	req.name
						STATEMENT 1 ON LINE 470
		req.srch.len (rcurr) = n - 3;

003524  aa  6 00104 2361 00	ldq  	pr6|68		n
003525  aa   000003 1760 07	sbq  	3,dl
003526  aa  6 00543 7261 00	lxl6 	pr6|355
003527  aa  7 01744 7561 16	stq  	pr7|996,6		req.len
						STATEMENT 1 ON LINE 471
		if req.opt.rename (rcurr) then do;

003530  aa  7 00051 2351 17	lda  	pr7|41,7		req.rename
003531  aa   400000 3150 03	cana 	131072,du
003532  aa   000035 6000 04	tze  	29,ic		003567
						STATEMENT 1 ON LINE 472
		     l = 1;

003533  aa   000001 2360 07	ldq  	1,dl
003534  aa  6 00103 7561 00	stq  	pr6|67		l
						STATEMENT 1 ON LINE 473
		     do k = 2 to req.srch.len (rcurr);

003535  aa  7 01744 2361 16	ldq  	pr7|996,6		req.len
003536  aa  6 00272 7561 00	stq  	pr6|186
003537  aa   000002 2360 07	ldq  	2,dl
003540  aa  6 00102 7561 00	stq  	pr6|66		k
003541  aa   000000 0110 03	nop  	0,du
003542  aa  6 00102 2361 00	ldq  	pr6|66		k
003543  aa  6 00272 1161 00	cmpq 	pr6|186
003544  aa   000023 6054 04	tpnz 	19,ic		003567
						STATEMENT 1 ON LINE 474
			if addr (req.srch.name (rcurr)) -> rscan (k) = ">" then l = l + 1;

003545  aa  6 00044 3701 20	epp4 	pr6|36,*
003546  ia  4 00231 2361 00	ldq  	pr4|153		rcurr
003547  aa   000056 4020 07	mpy  	46,dl
003550  aa  6 00543 7561 00	stq  	pr6|355
003551  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003552  aa  7 01750 3735 06	epp7 	pr7|1000,ql	req.name
003553  aa  6 00102 7271 00	lxl7 	pr6|66		k
003554  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
003555  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	rscan
003556  aa   000032 00 0001	desc9a	26,1		003606 = 076000000000
003557  aa   000002 6010 04	tnz  	2,ic		003561
003560  aa  6 00103 0541 00	aos  	pr6|67		l
						STATEMENT 1 ON LINE 475
		     end;

003561  aa  6 00102 0541 00	aos  	pr6|66		k
003562  aa   777760 7100 04	tra  	-16,ic		003542
						STATEMENT 1 ON LINE 476
		end;

						STATEMENT 1 ON LINE 477
	     end;

003563  aa   000004 7100 04	tra  	4,ic		003567
						STATEMENT 1 ON LINE 478
	     else req.opt.exact (rcurr) = "1"b;

003564  aa   200000 2350 03	lda  	65536,du
003565  ia  4 00231 7271 00	lxl7 	pr4|153		rcurr
003566  aa  7 00051 2551 17	orsa 	pr7|41,7		req.exact
						STATEMENT 1 ON LINE 479
	     req.opt.found (rcurr), req.opt.finished (rcurr), req.opt.synonym (rcurr) = ""b;

003567  aa   000014 2350 04	lda  	12,ic		003603 = 737777777777
003570  aa  6 00044 3701 20	epp4 	pr6|36,*
003571  ia  4 00231 7271 00	lxl7 	pr4|153		rcurr
003572  ia  4 00216 3735 20	epp7 	pr4|142,*		reqptr
003573  aa  7 00051 3551 17	ansa 	pr7|41,7		req.found
003574  aa   000006 2350 04	lda  	6,ic		003602 = 757777777777
003575  aa  7 00051 3551 17	ansa 	pr7|41,7		req.finished
003576  aa   000003 2350 04	lda  	3,ic		003601 = 677777777777
003577  aa  7 00051 3551 17	ansa 	pr7|41,7		req.synonym
						STATEMENT 1 ON LINE 481
	end see_stars;

003600  aa  6 00264 6101 00	rtcd 	pr6|180
  END PROCEDURE see_stars
  END PROCEDURE bk_retrieve


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
