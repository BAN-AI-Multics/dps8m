	COMPILATION LISTING OF SEGMENT quota
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1043.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 quota: proc;
       15 
       16 /* QUOTA - directory control interface for managing quotas.
       17*
       18*   Quotas live in the VTOC entry; or in the ASTE when the seg is active.
       19*   There are two "quota cells" for each directory: one for pages of segments and one for directory pages.
       20*   Each quota cell contains
       21*   .	quota
       22*   .	used
       23*   .	clock
       24*   .	time-page product
       25*   .	received count (quota + all inferior quotas)
       26*   .	inferior quota count
       27*
       28*   The current program does not handle directory quota at all.
       29*
       30*   Quota cell is protected by the directory lock.
       31*   But used can only be satisfactorily protected by the PTL.
       32*   So quotaw is called to look at or manipulate used, and he must be called
       33*   with the AST locked since his inputs are asteps.
       34*
       35*   vtoc_attributes is used to  read and write quota cells in VTOC.
       36*   It may be called with or without AST locked */
       37 
       38 /* Last change: */
       39 /* Modified May 1985 by EJ Sharpe to use dc_find$mdir_set_quota_uid and to
       40*     enforce AIM restriction on removing quota from upgraded master dirs */
       41 /* Modified January 1985 by Keith Loepere to set tup at append_mdir_set. */
       42 /* Modified November 1984 by Keith Loepere for auditing info. */
       43 /* Modified July 1984 by Keith Loepere to use the new dc_find. */
       44 /* Modified BIM 84-05 for sst reformat. */
       45 /* Modified BIM 83-12-06 to correctly check dir privilege and upgradedness, TR 16411 */
       46 /* Modified BIM 3/82 to only hold read locks when appropriate */
       47 /* Modified 05/05/82 by S. Krupp to change error code invalid_move_quota to
       48*   invalid_move_qmax and return ai_not_restricted in case of no privilege */
       49 /* Modified November 1979 by C. Hornig for privileged quota reading */
       50 /* Modified 19 Feb 79 by D. Spector for 18-bit quota values */
       51 /* Modified June 1, 1976 by R. Bratt to call find_$finished */
       52 /* Modified March 1976 by Larry Johnson for master directory quota */
       53 /* Extensive changes for NSS by TVV 6/75 */
       54 /* Modified by Kobziar 10-21-74 to add qmove_mylock entry */
       55 /* Modified by Kobziar July 74 to call new entry in access_mode and to check authorization */
       56 
       57 /* Parameters */
       58 
       59 dcl  a_code			fixed bin (35) parameter;
       60 dcl  a_dp1			ptr parameter;
       61 dcl  a_ename			char (*) parameter;
       62 dcl  a_ep				ptr parameter;
       63 dcl  a_ignore			fixed bin (17) parameter;
       64 dcl  a_ltrp			fixed bin (71) parameter;
       65 dcl  a_parent			char (*) parameter;
       66 dcl  a_qchange			fixed bin (17) parameter;
       67 dcl  a_quota			fixed bin (18) parameter;
       68 dcl  a_seg_or_dir			bit (1) parameter;
       69 dcl  a_segptr			ptr parameter;
       70 dcl  a_slvid			bit (36) parameter;
       71 dcl  a_taccsw			fixed bin (1) parameter;
       72 dcl  a_trp			fixed bin (35) parameter;
       73 dcl  a_trpc			fixed bin (35) parameter;
       74 dcl  a_tup			bit (36) aligned parameter;
       75 dcl  a_uchange			fixed bin (17) parameter;
       76 dcl  a_uidpath			(0:15) bit (36) aligned parameter;
       77 dcl  a_used			fixed bin (17) parameter;
       78 
       79 /* Variables */
       80 
       81 dcl  CHECK_ONLY			fixed bin (1) init (1) static options (constant);
       82 dcl  LOTS				fixed bin (71) static options (constant) init (11111111111111111111111111111111111b); /* 35 1-bits */
       83 dcl  ROOT_UID			bit (36) static options (constant) init ((36)"1"b);
       84 dcl  SEC_PER_TICK			float bin static options (constant) init (.65536e-1); /* Convert fs time to seconds */
       85 
       86 dcl  called_find			bit (1) aligned init ("0"b);
       87 dcl  check_access			bit (1);
       88 dcl  code				fixed bin (35);
       89 dcl  curtime			bit (36) aligned;
       90 dcl  dep				ptr;
       91 dcl  dir_privilege			bit (1);
       92 dcl  dir_quota_sw			bit (1) init ("0"b);/* TRUE only if doing dir quota */
       93 dcl  dt				fixed bin (35);
       94 dcl  ename			char (32);
       95 dcl  len				fixed bin;
       96 dcl  locked			bit (1) aligned init ("0"b);
       97 dcl  ltrp				fixed bin (71);
       98 dcl  moved_down			fixed bin (35);
       99 dcl  mylock_entry			bit (1) aligned;
      100 dcl  new_entry			bit (1) aligned init ("0"b);
      101 dcl  not_root			bit (1) aligned init ("1"b);
      102 dcl  now_terminal			bit (1);
      103 dcl  parent			char (168);
      104 dcl  parent_astep			ptr;
      105 dcl  parent_dp			ptr;
      106 dcl  parent_pvid			bit (36) aligned;
      107 dcl  1 parent_qcell			like quota_cell aligned;
      108 dcl  parent_uid			bit (36) aligned;
      109 dcl  parent_vtocx			fixed bin;
      110 dcl  pathname			char (168);
      111 dcl  pvid				bit (36) aligned;
      112 dcl  1 qcell			like quota_cell aligned;
      113 dcl  qchange			fixed bin (18);
      114 dcl  qt				fixed bin (18) init (0); /* default assumption is segs (=0) */
      115 dcl  quota			fixed bin (18);
      116 dcl  read_lock			bit (36) aligned init ("0"b);
      117 dcl  segptr			ptr;
      118 dcl  setquota_entry			bit (1) init ("0"b);
      119 dcl  slvid			bit (36);
      120 dcl  sstp				pointer;
      121 dcl  taccsw			bit (1) aligned;
      122 dcl  trp				fixed bin (35);
      123 dcl  tup				bit (36) aligned;
      124 dcl  uchange			fixed bin (18);
      125 dcl  uid				bit (36) aligned;
      126 dcl  uidpath			(0:15) bit (36) aligned;
      127 dcl  unlock_son			bit (1);
      128 dcl  used				fixed bin (18);
      129 dcl  vtocx			fixed bin;
      130 dcl  was_terminal			bit (1);
      131 dcl  write_lock			bit (36) aligned init ("1"b);
      132 
      133 /* External */
      134 
      135 dcl  error_table_$ai_restricted	fixed bin (35) ext;
      136 dcl  error_table_$argerr		fixed bin (35) ext;
      137 dcl  error_table_$bad_ring_brackets	fixed bin (35) ext;
      138 dcl  error_table_$invalid_move_qmax	fixed bin (35) ext;
      139 dcl  error_table_$master_dir		fixed bin (35) ext;
      140 dcl  error_table_$mdc_not_mdir	fixed bin (35) ext;
      141 dcl  error_table_$rqover		fixed bin (35) ext;
      142 dcl  pds$access_authorization		bit (72) aligned ext static;
      143 dcl  sst_seg$			external static;
      144 dcl  sst$root_astep			pointer external static;
      145 
      146 /* Entries */
      147 
      148 dcl  activate			entry (ptr, fixed bin (35)) returns (ptr);
      149 dcl  aim_check_$greater		entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      150 dcl  level$get			entry returns (fixed bin (17));
      151 dcl  lock$dir_unlock		entry (ptr);
      152 dcl  lock$unlock_ast		entry;
      153 dcl  quotaw$cu			entry (ptr, fixed bin (18), bit (1), fixed bin (1), fixed bin (35));
      154 dcl  quotaw$mq			entry (ptr, ptr, fixed bin (18), bit (1), fixed bin (35));
      155 dcl  quotaw$sq			entry (ptr, fixed bin (18), bit (1), fixed bin (1));
      156 dcl  sum$getbranch			entry (ptr, bit (36) aligned, ptr, fixed bin (35));
      157 dcl  sum$dirmod			entry (ptr);
      158 dcl  vtoc_attributes$get_quota	entry (bit (36) aligned, bit (36) aligned, fixed bin (17), ptr, fixed bin (18), fixed bin (35));
      159 dcl  vtoc_attributes$set_quota	entry (bit (36) aligned, bit (36) aligned, fixed bin (17), ptr, fixed bin (18), fixed bin (35));
      160 
      161 /* Misc */
      162 
      163 dcl  (addr, bin, bit, clock, fixed, length, min, null, ptr, rtrim, substr, unspec) builtin;
      164 
      165 
      166 /* ========================================================== */
      167 
      168 /* qlong_reset, reset - entries which modify the trp of the directory only */
      169 /* these are called by accounting to reduce the trp once a month. */
      170 /* qreset is very probably obsolete */
      171 
      172 dqlong_reset: entry (a_parent, a_ltrp, a_code);
      173 
      174 	dir_quota_sw = "1"b;
      175 	qt = 1;
      176 
      177 qlong_reset: entry (a_parent, a_ltrp, a_code);
      178 
      179 	ltrp = a_ltrp;				/* Copy arguments */
      180 	go to reset1;
      181 
      182 qreset: entry (a_parent, a_trpc, a_code);
      183 
      184 	ltrp = a_trpc;				/* .. old style */
      185 reset1:
      186 	parent = a_parent;
      187 
      188 	code = 0;					/* Clear return code */
      189 	call dc_find$dir_write_priv (parent, FS_OBJ_TRP_MOD, dp, code); /* get pointer to directory */
      190 	if code ^= 0 then go to errxit;
      191 	called_find, locked = "1"b;
      192 
      193 	call get_quota_cell;			/* read VTOC */
      194 	qcell.trp = qcell.trp - ltrp;			/* Perform subtraction */
      195 	call vtoc_attributes$set_quota (uid, pvid, vtocx, addr (qcell), qt, code);
      196 	call sum$dirmod (dp);			/* Make sure dir mod noted */
      197 	goto done;
      198 
      199 /* * * * * * * * * * * * * * * * * * * * * * */
      200 
      201 /* qset, qset_mylock, qreload, qrestor - support for entries which set the quota cell */
      202 /* all four are highly-privileged entrypoints */
      203 
      204 dqset: entry (a_parent, a_quota, a_code);
      205 
      206 	dir_quota_sw = "1"b;
      207 	qt = 1;
      208 
      209 qset: entry (a_parent, a_quota, a_code);
      210 
      211 	setquota_entry = "1"b;
      212 	taccsw = "1"b;				/* Default */
      213 	quota = a_quota;				/* Copy arg */
      214 	parent = a_parent;				/* copy into char(168) aligned */
      215 
      216 	code = 0;					/* Clear return code */
      217 	call dc_find$dir_write_priv (parent, FS_OBJ_QUOTA_MOD, dp, code); /* get pointer to directory */
      218 	if code ^= 0 then go to errxit;
      219 	called_find, locked = "1"b;
      220 
      221 	call get_quota_cell;			/* Read VTOCE */
      222 	go to common;
      223 
      224 dqrestor: entry (a_parent, a_quota, a_ltrp, a_tup, a_ignore, a_taccsw, a_code);
      225 
      226 	dir_quota_sw = "1"b;
      227 	qt = 1;
      228 
      229 qrestor: entry (a_parent, a_quota, a_ltrp, a_tup, a_ignore, a_taccsw, a_code);
      230 	ltrp = a_ltrp;				/* Privileged entry for SysAdmin */
      231 	go to qreload_common;			/* .. and daemon */
      232 
      233 qreload: entry (a_parent, a_quota, a_trp, a_tup, a_ignore, a_taccsw, a_code);
      234 
      235 	ltrp = a_trp;
      236 qreload_common:
      237 
      238 	tup = a_tup;				/* Copy args */
      239 	taccsw = bit (a_taccsw, 1);
      240 	quota = a_quota;
      241 	parent = a_parent;				/* copy into char(168) aligned */
      242 
      243 	code = 0;					/* Clear return code */
      244 	call dc_find$dir_write_priv (parent, FS_OBJ_QUOTA_RELOAD, dp, code); /* get pointer to directory */
      245 	if code ^= 0 then go to errxit;
      246 	called_find, locked = "1"b;
      247 
      248 	call get_quota_cell;			/* read in quota info */
      249 	qcell.trp = ltrp;
      250 	qcell.tup = tup;
      251 
      252 common:
      253 	sstp = addr (sst_seg$);			/* Make segment active */
      254 	astep = make_seg_active (dp);
      255 	if aste.tqsw (qt) = taccsw then		/* if no change to terminal status */
      256 	     aste.quota (qt) = quota;			/* just change quota in AST entry */
      257 	else do;					/* for non-term quota, used must be subtracted from parent */
      258 	     call quotaw$sq (astep, quota, dir_quota_sw, fixed (taccsw, 1));
      259 						/* sets quota, adds or subs used from sup accts */
      260 	     if setquota_entry then qcell.tup = bit (bin (clock (), 52), 52); /* on first qset set tup */
      261 	end;
      262 	qcell.received = qcell.received + quota - qcell.quota;
      263 	qcell.quota = quota;			/* set quota in VTOC */
      264 	qcell.terminal_quota_sw = aste.tqsw (qt);
      265 	if not_root then call lock$unlock_ast;
      266 
      267 	call vtoc_attributes$set_quota (uid, pvid, vtocx, addr (qcell), qt, code);
      268 	if not_root then do;			/* Unlock parent dir */
      269 	     parent_dp = ptr (dep, 0);
      270 	     call lock$dir_unlock (parent_dp);		/* unlock sup dir */
      271 	end;
      272 	call sum$dirmod (dp);			/* Make sure dir mod noted */
      273 	goto done;
      274 
      275 /* * * * * * * * * * * * * * * * * * * * * * */
      276 
      277 /* mdir_set: entry to set quota on a master directory */
      278 
      279 mdir_set: entry (a_uidpath, a_quota, a_code);
      280 
      281 	uidpath = a_uidpath;
      282 	quota = a_quota;
      283 
      284 	call dc_find$mdir_set_quota_uid (uidpath, parent, FS_OBJ_MDIR_QUOTA_MOD, ep, dp, code); /* finds directory */
      285 	if code ^= 0 then go to errxit;
      286 	locked, called_find = "1"b;
      287 	parent_dp = ptr (ep, 0);
      288 
      289 	if ^entry.master_dir then do;
      290 	     code = error_table_$mdc_not_mdir;
      291 	     go to unlock2;
      292 	end;
      293 
      294 	if level$get () > fixed (entry.ex_ring_brackets (1), 3) then do;
      295 	     code = error_table_$bad_ring_brackets;
      296 	     go to unlock2;
      297 	end;
      298 
      299 	uid = dir.uid;				/* setup to read vtoce */
      300 	pvid = dir.pvid;
      301 	vtocx = dir.vtocx;
      302 	call vtoc_attributes$get_quota (uid, pvid, vtocx, addr (qcell), 0, code);
      303 	if code ^= 0 then go to unlock2;
      304 
      305 	dir_privilege = addr (pds$access_authorization) -> aim_template.privileges.dir;
      306 	qchange = quota - qcell.quota;
      307 	if qchange < 0 then				/* If reducing quota */
      308 	     if aim_check_$greater (entry.access_class, parent_dp -> dir.access_class) then /* its an upgraded dir */
      309 		if ^dir_privilege then do;		/* If not privileged, forget it. */
      310 						/* Could publish info if he did this */
      311 		     code = error_table_$ai_restricted;
      312 		     go to unlock2;
      313 		end;
      314 		else if qcell.quota + qchange <= 0 then do; /* if would make it zero, forget it too. */
      315 		     code = error_table_$invalid_move_qmax;
      316 		     go to unlock2;
      317 		end;
      318 	call lock$dir_unlock (parent_dp);		/* done with parent */
      319 
      320 	astep = activate (ep, code);
      321 	qcell.used = aste.used (0);			/*  aste is more up to date */
      322 	moved_down = qcell.received - qcell.quota;	/* quota on lower directorys */
      323 	qcell.received = quota;
      324 	qcell.quota = quota - moved_down;
      325 	if qcell.received < qcell.used + moved_down then do; /* not enough */
      326 	     code = error_table_$rqover;
      327 	     call lock$unlock_ast;
      328 	     go to unlock1;
      329 	end;
      330 	aste.quota (0) = quota;
      331 	call lock$unlock_ast;
      332 
      333 	call vtoc_attributes$set_quota (uid, pvid, vtocx, addr (qcell), 0, code);
      334 	call sum$dirmod (dp);
      335 	go to done;
      336 
      337 /* * * * * * * * * * * * * * * * * * * * * * */
      338 
      339 /* append_mdir_set: special entry called by append to set initial master directory quota */
      340 
      341 append_mdir_set: entry (a_ep, a_quota, a_code);
      342 
      343 	ep = a_ep;
      344 	quota = a_quota;
      345 	uid = entry.uid;				/* set up for vtoc_attributes call */
      346 	pvid = entry.pvid;
      347 	vtocx = entry.vtocx;
      348 	unspec (qcell) = "0"b;
      349 	qcell.received, qcell.quota = quota;
      350 	qcell.terminal_quota_sw = "1"b;
      351 	curtime = bit (bin (clock (), 52), 52);
      352 	qcell.tup = curtime;			/* trp clock starts NOW */
      353 
      354 	astep = activate (ep, code);			/* must also update aste */
      355 	aste.quota (0) = quota;
      356 	aste.tqsw (0) = "1"b;
      357 	call lock$unlock_ast;
      358 	call vtoc_attributes$set_quota (uid, pvid, vtocx, addr (qcell), 0, code);
      359 	a_code = code;
      360 	return;
      361 
      362 
      363 
      364 /* * * * * * * * * * * * * * * * * * * * * * */
      365 
      366 /* qread, qget - entries to read the quota information */
      367 
      368 dqread: entry (a_parent, a_quota, a_ltrp, a_tup, a_slvid, a_taccsw, a_used, a_code);
      369 
      370 	dir_quota_sw = "1"b;
      371 	qt = 1;
      372 	check_access = "1"b;
      373 	new_entry = "1"b;
      374 	goto get_common;
      375 
      376 qread: entry (a_parent, a_quota, a_ltrp, a_tup, a_slvid, a_taccsw, a_used, a_code);
      377 	new_entry = "1"b;
      378 	check_access = "1"b;
      379 	goto get_common;
      380 
      381 qget: entry (a_parent, a_quota, a_trp, a_tup, a_slvid, a_taccsw, a_used, a_code);
      382 
      383 	check_access = "1"b;
      384 	goto get_common;
      385 
      386 priv_qread: entry (a_parent, a_quota, a_ltrp, a_tup, a_slvid, a_taccsw, a_used, a_code);
      387 
      388 	new_entry = "1"b;
      389 	check_access = "0"b;
      390 	goto get_common;
      391 
      392 priv_dqread: entry (a_parent, a_quota, a_ltrp, a_tup, a_slvid, a_taccsw, a_used, a_code);
      393 
      394 	new_entry = "1"b;
      395 	dir_quota_sw = "1"b;
      396 	qt = 1;
      397 	check_access = "0"b;
      398 
      399 get_common:
      400 	quota, trp, ltrp, used = 0;			/* zero return variables */
      401 	tup = "0"b;
      402 	taccsw = "0"b;
      403 	parent = a_parent;				/* copy into char(168) aligned */
      404 
      405 	code = 0;					/* Clear return code */
      406 	if check_access then call dc_find$dir_read (parent, dp, code); /* get pointer to directory */
      407 	else call dc_find$dir_read_priv (parent, dp, code);
      408 	if code ^= 0 then go to errxit;
      409 	called_find, locked = "1"b;
      410 
      411 	call get_quota_cell;			/* get quota info */
      412 
      413 	slvid = dir.sons_lvid;			/* Save sons LVID for later */
      414 	sstp = addr (sst_seg$);
      415 	astep = make_seg_active (dp);			/* To check used, must have active acct */
      416 	qcell.used = aste.used (qt);			/* update from ast entry to temp */
      417 	if not_root then do;			/* ok, now unlock */
      418 	     parent_dp = ptr (dep, 0);
      419 	     call lock$unlock_ast;
      420 	     call lock$dir_unlock (parent_dp);		/* unlock parent dir */
      421 	end;
      422 	if qcell.terminal_quota_sw then do;		/* this is a terminal account, do full update */
      423 	     curtime = bit (bin (clock (), 52), 52);	/* get time as bit string - high order bits */
      424 						/* calc and add to the time-page product which is in page-secs */
      425 	     dt = fixed (curtime, 36) - fixed (qcell.tup, 36); /* time since last update */
      426 	     qcell.trp = qcell.trp + fixed ((dt * qcell.used) * SEC_PER_TICK + .5e0, 71);
      427 	     qcell.tup = curtime;			/* .. */
      428 	end;
      429 	quota = qcell.quota;			/* copy info from dir header */
      430 	ltrp = qcell.trp;				/* .. into return args */
      431 	trp = min (ltrp, LOTS);			/* return max value if  overflow 35 bits */
      432 	tup = qcell.tup;
      433 	used = qcell.used;
      434 	taccsw = qcell.terminal_quota_sw;
      435 
      436 unlock:	call dc_find$finished (dp, "1"b);		/* Unlock directory */
      437 	a_quota = quota;				/* .. and give args back to caller */
      438 	if new_entry then a_ltrp = ltrp;
      439 	else a_trp = trp;
      440 	a_tup = tup;
      441 	a_slvid = slvid;
      442 	a_taccsw = fixed (taccsw, 1);
      443 	a_used = used;
      444 	a_code = code;
      445 	return;
      446 
      447 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      448 
      449 /* entry called by append to see if can move quota */
      450 
      451 check: entry (a_ep, a_uchange, a_code);
      452 
      453 	ep = a_ep;				/* dir is not locked */
      454 	unlock_son = "0"b;
      455 	go to join;
      456 
      457 check_file: entry (a_parent, a_ename, a_uchange, a_code);	/* Called by fs_move */
      458 
      459 	parent = a_parent;
      460 	ename = a_ename;
      461 	code = 0;
      462 	unlock_son = "1"b;				/* will lock the dir */
      463 	call dc_find$obj_status_read (parent, ename, DC_FIND_CHASE, ep, code);
      464 	dp = ptr (ep, 0);				/* Get ptr to parent */
      465 	if code ^= 0 then go to errxit;		/* see if find it */
      466 	called_find = "1"b;
      467 	go to join;
      468 
      469 check_seg: entry (a_segptr, a_uchange, a_code);		/* (not used currently) */
      470 
      471 	segptr = a_segptr;
      472 	code = 0;
      473 	unlock_son = "1"b;
      474 	call dc_find$obj_status_read_ptr (segptr, ep, code);
      475 	if code ^= 0 then go to errxit;
      476 	dp = ptr (ep, 0);
      477 
      478 join:
      479 	uchange = a_uchange;			/* What's the change in quota */
      480 	dp = ptr (ep, 0);				/* get pointer to base of directory */
      481 
      482 	sstp = addr (sst_seg$);
      483 	astep = make_seg_active (dp);			/* Force active so look at used */
      484 	call quotaw$cu (astep, uchange, dir_quota_sw, CHECK_ONLY, code); /* checks act acct with ptl set */
      485 	if not_root then do;
      486 	     parent_dp = ptr (dep, 0);
      487 	     call lock$unlock_ast;
      488 	     call lock$dir_unlock (parent_dp);		/* unlock parent dir */
      489 	end;
      490 
      491 unlock3:	if unlock_son then
      492 	     if called_find then call dc_find$finished (dp, "1"b);
      493 	     else call lock$dir_unlock (dp);
      494 	a_code = code;
      495 	return;
      496 
      497 /* * * * * * * * * * * * * * * * * * * * * * */
      498 
      499 /* This entry moves quota between a dir and its parent */
      500 
      501 dqmove: entry (a_parent, a_ename, a_qchange, a_code);
      502 
      503 	dir_quota_sw = "1"b;
      504 	qt = 1;
      505 
      506 qmove: entry (a_parent, a_ename, a_qchange, a_code);
      507 
      508 	code = 0;
      509 	qchange = a_qchange;			/* Copy arg */
      510 	parent = a_parent;				/* copy into char(168) aligned */
      511 	ename = a_ename;				/* copy into char(32) aligned */
      512 	mylock_entry = "0"b;
      513 
      514 	len = length (rtrim (parent));		/* Get dirname into pathname */
      515 	if ename ^= "" then do;
      516 	     if len + length (rtrim (ename)) + 1 > length (pathname) then do; /* too long */
      517 bad_path:		code = error_table_$argerr;
      518 		goto errxit;
      519 	     end;
      520 	     if len = 1 then pathname = substr (parent, 1, 1) || ename; /* dir is then root */
      521 	     else pathname = substr (parent, 1, len) || ">" || ename;
      522 	end;
      523 	else do;
      524 	     if len > length (pathname) then goto bad_path;
      525 	     if len = 1 then goto bad_path;		/* don't bother with a single directory (root) */
      526 	     pathname = parent;
      527 	end;
      528 
      529 	dir_privilege = addr (pds$access_authorization) -> aim_template.privileges.dir;
      530 
      531 /* this is going to be useful later... */
      532 
      533 	call dc_find$dir_move_quota (pathname, ep, dp, code);
      534 	if code ^= 0 then goto errxit;
      535 	called_find, locked = "1"b;
      536 	parent_dp = ptr (ep, 0);			/* Locate parent */
      537 
      538 	if level$get () > fixed (entry.ex_ring_brackets (1), 3) then do;
      539 	     code = error_table_$bad_ring_brackets;	/* ringbrackets must be consistent with validation level */
      540 	     go to unlock2;
      541 	end;
      542 
      543 	uid = dir.uid; pvid = dir.pvid; vtocx = dir.vtocx;/* Copy vars for son */
      544 	call vtoc_attributes$get_quota (uid, pvid, vtocx, /* .. and read VTOC */
      545 	     addr (qcell), qt, code);
      546 	if code ^= 0 then go to unlock2;
      547 	parent_uid = parent_dp -> dir.uid; parent_pvid = parent_dp -> dir.pvid; parent_vtocx = parent_dp -> dir.vtocx;
      548 	call vtoc_attributes$get_quota (parent_uid, parent_pvid, parent_vtocx,
      549 	     addr (parent_qcell), qt, code);
      550 	if code ^= 0 then go to unlock2;
      551 
      552 	if qcell.terminal_quota_sw then		/* if inferior dir has terminal acct */
      553 	     if qcell.received > qcell.quota then	/* and it has inferior quotas */
      554 		if qcell.quota + qchange <= 0 then do;	/* and the.change would make it non-terminal */
      555 		     code = error_table_$invalid_move_qmax; /* don't allow change to be made */
      556 		     go to unlock2;
      557 		end;
      558 
      559 	if qchange < 0 then				/* If moving quota up */
      560 	     if aim_check_$greater (entry.access_class, parent_dp -> dir.access_class) then /* its an upgraded dir */
      561 		if ^dir_privilege then do;		/* If not privileged, forget it. */
      562 						/* Could publish info if he did this */
      563 		     code = error_table_$ai_restricted;
      564 		     go to unlock2;
      565 		end;
      566 		else if qcell.quota + qchange <= 0 then do; /* if would make non-term, forget it too. */
      567 		     code = error_table_$invalid_move_qmax;
      568 		     go to unlock2;
      569 		end;
      570 
      571 	go to skip_del_entry;
      572 
      573 /* This entry is called from inside append, when creating an upgraded directory.
      574*   Parent and new dir are both locked at this point */
      575 
      576 qmove_mylock: entry (a_ep, a_dp1, a_qchange, a_seg_or_dir, a_code);
      577 
      578 	dir_quota_sw = a_seg_or_dir;			/* Copy switch */
      579 	qt = fixed (dir_quota_sw, 1);
      580 	mylock_entry = "1"b;
      581 	ep = a_ep;
      582 	parent_dp = ptr (ep, 0);
      583 	dp = a_dp1;				/* are already locked */
      584 	qchange = a_qchange;
      585 
      586 	uid = dir.uid; pvid = dir.pvid; vtocx = dir.vtocx;/* Copy vars */
      587 	call vtoc_attributes$get_quota (uid, pvid, vtocx,
      588 	     addr (qcell), qt, code);
      589 	if code ^= 0 then go to errxit;
      590 	parent_uid = parent_dp -> dir.uid; parent_pvid = parent_dp -> dir.pvid; parent_vtocx = parent_dp -> dir.vtocx;
      591 	call vtoc_attributes$get_quota (parent_uid, parent_pvid, parent_vtocx,
      592 	     addr (parent_qcell), qt, code);
      593 	if code ^= 0 then go to errxit;
      594 	if qchange = 0 then				/* If quota change arg is zero, */
      595 	     qchange = -qcell.quota;			/* ..take the whole thing */
      596 
      597 skip_del_entry:
      598 	if ^dir_quota_sw & dir.master_dir then do;
      599 	     code = error_table_$master_dir;		/* Apples an oranges */
      600 	     if mylock_entry then go to errxit;
      601 	     go to unlock2;
      602 	end;
      603 	if qchange = 0 then do;			/* If useless call */
      604 	     code = 0;
      605 	     if mylock_entry then go to errxit;
      606 	     go to unlock2;
      607 	end;
      608 
      609 	if ^parent_qcell.terminal_quota_sw then do;	/* None to move */
      610 	     code = error_table_$invalid_move_qmax;
      611 	     if mylock_entry then go to errxit;
      612 	     go to unlock2;
      613 	end;
      614 
      615 /* get pointers to AST entries for both directories */
      616 
      617 	sstp = addr (sst_seg$);			/* Get SST */
      618 	astep = activate (ep, code);			/* Activate son */
      619 
      620 	parent_astep = ptr (sstp, aste.par_astep);	/* this is active because son is active */
      621 
      622 /* update trp for both directories, since we may cause a sudden change to used */
      623 
      624 	qcell.used = aste.used (qt);			/* Copy from AST */
      625 	parent_qcell.used = parent_astep -> aste.used (qt);
      626 	curtime = bit (bin (clock (), 52), 52);		/* same as above */
      627 						/* calc & add the time-page product which is in page-seconds */
      628 	dt = fixed (curtime, 36) - fixed (parent_qcell.tup, 36); /* time since trp was last updated */
      629 	parent_qcell.trp = parent_qcell.trp + fixed ((dt * parent_qcell.used) * SEC_PER_TICK + .5e0, 71);
      630 	parent_qcell.tup = curtime;
      631 	was_terminal = qcell.terminal_quota_sw;		/* indicator if directory currently has terminal quota */
      632 	if was_terminal then do;			/* only update son if it is terminal */
      633 	     dt = fixed (curtime, 36) - fixed (qcell.tup, 36); /* time since trp was last updated */
      634 	     qcell.trp = qcell.trp + fixed ((dt * qcell.used) * SEC_PER_TICK + .5e0, 71);
      635 	     qcell.tup = curtime;
      636 	end;
      637 
      638 	call quotaw$mq (parent_astep, astep, qchange, dir_quota_sw, code);
      639 						/* change quotas and maybe used with ptl locked */
      640 	if code ^= 0 then do;			/* one if the quotas didn't cover the used */
      641 	     call lock$unlock_ast;
      642 	     if mylock_entry then go to errxit;		/* don't unlock */
      643 	     else go to unlock2;
      644 	end;
      645 	qcell.quota = aste.quota (qt);		/* change quotas in the VTOCEs */
      646 	parent_qcell.quota = parent_astep -> aste.quota (qt);
      647 	now_terminal, qcell.terminal_quota_sw = aste.tqsw (qt); /* terminal status of directory may have changed */
      648 
      649 /* clean up trps in case terminal status of directory has changed */
      650 
      651 	if was_terminal ^= now_terminal then do;	/* Did status of inferior change? */
      652 	     if was_terminal then do;
      653 		parent_qcell.trp = parent_qcell.trp + qcell.trp; /* carry total trp up to parent */
      654 	     end;
      655 	     else do;
      656 		qcell.tup = curtime;
      657 	     end;
      658 	     qcell.trp = 0;				/* just so it doesn't get charged twice */
      659 	end;
      660 
      661 	qcell.received = qcell.received + qchange;	/* Adjust total quota at this node */
      662 
      663 	call lock$unlock_ast;			/* Unlock AST */
      664 
      665 	call vtoc_attributes$set_quota (uid, pvid, vtocx, /* Write back */
      666 	     addr (qcell), qt, code);
      667 	call vtoc_attributes$set_quota (parent_uid, parent_pvid, parent_vtocx,
      668 	     addr (parent_qcell), qt, code);
      669 
      670 	if ^mylock_entry then do;			/* usually must unlock */
      671 	     call sum$dirmod (dp);			/* indicate directory and parent modified */
      672 	     if called_find then call dc_find$finished (dp, "1"b);
      673 	     else call lock$dir_unlock (dp);
      674 	     call lock$dir_unlock (parent_dp);
      675 	end;
      676 	a_code = code;
      677 	return;
      678 
      679 /* * * * * * * * * * * * * * * * * * * * * * */
      680 
      681 /* Error handlers */
      682 
      683 unlock2:	if not_root then call lock$dir_unlock (parent_dp);
      684 
      685 done:
      686 unlock1:	if called_find then call dc_find$finished (dp, locked);
      687 	else call lock$dir_unlock (dp);
      688 
      689 errxit:	a_code = code;				/* set return error code */
      690 	return;
      691 
      692 /* * * * * * * * * * * * * * * * * * * * * * */
      693 
      694 /* Internal procedure to get directory's quota cell */
      695 
      696 get_quota_cell: proc;
      697 
      698 	uid = dir.uid; pvid = dir.pvid; vtocx = dir.vtocx;/* Copy vars */
      699 	call vtoc_attributes$get_quota (uid, pvid, vtocx, addr (qcell), qt, code);
      700 	if code ^= 0 then go to unlock1;
      701 
      702      end get_quota_cell;
      703 
      704 /* * * * * * * * * * * * * * * * * * * * * * */
      705 
      706 /* Internal procedure to make segment be active */
      707 
      708 make_seg_active: proc (dpt) returns (ptr);		/* Returns astep */
      709 
      710 dcl  dpt				ptr parameter;	/* .. given entry ptr */
      711 
      712 dcl  ASTep			ptr;
      713 
      714 	if dpt -> dir.uid = ROOT_UID then do;		/* root's active already */
      715 	     not_root = "0"b;
      716 	     return (sst$root_astep);
      717 	end;
      718 	else do;					/* no root */
      719 	     call sum$getbranch (dpt, read_lock, dep, code); /* get branch (lock parent) */
      720 	     if code ^= 0 then return (null);
      721 	     ASTep = activate (dep, code);		/* Activate thing */
      722 	end;
      723 	return (ASTep);
      724 
      725      end make_seg_active;
      726  /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  1     2 
  1     3 /* Created 740723 by PG */
  1     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  1     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  1     6 
  1     7 /* This structure defines the components of both an access
  1     8*   class and an access authorization as interpreted by the
  1     9*   Access Isolation Mechanism. */
  1    10 
  1    11 
  1    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  1    13        2 categories bit (36),				/* access categories */
  1    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  1    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  1    16         (3 ipc,					/* interprocess communication privilege */
  1    17          3 dir,					/* directory privilege */
  1    18          3 seg,					/* segment privilege */
  1    19          3 soos,					/* security out-of-service privilege */
  1    20          3 ring1,					/* ring 1 access privilege */
  1    21          3 rcp,					/* RCP resource access privilege */
  1    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  1    23          3 pad bit (11);
  1    24 
  1    25 
  1    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      726 
      727  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      727 
      728  /* BEGIN include file dc_find_dcls.incl.pl1 */
  3     2 
  3     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  3     4 /* Added a few more, October 1984. */
  3     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  3     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  3     7 
  3     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  3     9 
  3    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  3    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  3    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  3    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  3    14 
  3    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  3    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  3    18 
  3    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  3    20 
  3    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  3    22 
  3    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  3    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  3    25 
  3    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  3    27 
  3    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  3    29 
  3    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  3    32 
  3    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  3    34 
  3    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  3    36 
  3    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  3    38 
  3    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    41 
  3    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    44 
  3    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    47 
  3    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  3    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  3    52 
  3    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  3    58 
  3    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  3    60 
  3    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  3    62 
  3    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  3    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  3    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  3    66 
  3    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  3    68 
  3    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  3    70 
  3    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    72 
  3    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    74 
  3    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  3    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  3    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  3    82 
  3    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  3    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  3    87 
  3    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  3    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  3    90 
  3    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  3    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  3    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  3    94 
  3    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  3    96 
  3    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  3    98 
  3    99 /* END include file dc_find_dcls.incl.pl1 */
      728 
      729  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      729 
      730  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  5     2 /* Modified 8/74 for NSS */
  5     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  5     4 /* Modified 3/82 BIM for change pclock */
  5     5 /* format: style3 */
  5     6 
  5     7 /* Template for the directory header. Length = 64 words. */
  5     8 
  5     9 dcl  dp ptr;
  5    10 
  5    11 dcl 1 dir based (dp) aligned,
  5    12 
  5    13    2 modify bit (36),				/* Process ID of last modifier */
  5    14    2 type bit (18) unaligned,			/* type of object = dir header */
  5    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  5    16     2 dtc (3),					/* date-time checked by salvager array */
  5    17       3 date bit (36),				/* the date */
  5    18       3 error bit (36),				/* what errors were discovered */
  5    19 
  5    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  5    21 
  5    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  5    23 
  5    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  5    25 
  5    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  5    27 
  5    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  5    29     2 version_number fixed bin (17),			/* version number of header */
  5    30 
  5    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  5    32     2 pad2 bit (18),
  5    33 
  5    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  5    35     2 pad3 bit (18),
  5    36 
  5    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  5    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  5    39 
  5    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  5    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  5    42 
  5    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  5    44     2 dir_count fixed bin (17),			/* number of directory branches */
  5    45 
  5    46     2 lcount fixed bin (17),				/* number of links */
  5    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  5    48 
  5    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  5    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  5    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  5    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  5    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  5    54     2 pad4 bit (14),
  5    55 
  5    56     2 iacl_count (0:7),
  5    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  5    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  5    59 
  5    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  5    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  5    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  5    63 
  5    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  5    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  5    66 
  5    67     2 htsize fixed bin (17),				/* size of hash table */
  5    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  5    69 
  5    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  5    71     2 pad6 fixed bin (17),
  5    72 
  5    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  5    74     2 pad7 bit (18)) unaligned,
  5    75 
  5    76     2 dts bit (36),					/* date-time directory last salvaged */
  5    77 
  5    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  5    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  5    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  5    81     2 checksum bit (36),				/* checksummed from uid on */
  5    82     2 owner bit (36);				/* uid of parent dir */
  5    83 
  5    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  5    85 
  5    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      730 
      731  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
  6     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  6     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
  6     8*                                                   END HISTORY COMMENTS */
  6     9 
  6    10 
  6    11 /* The possible events within the file system; access codes and
  6    12*   detailed operation codes.  October 1984, Keith Loepere. */
  6    13 
  6    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  6    15 
  6    16 /* Major file system operations. */
  6    17 
  6    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
  6    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
  6    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
  6    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
  6    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
  6    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
  6    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
  6    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
  6    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
  6    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
  6    28 
  6    29 /* Detailed operations. */
  6    30 
  6    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
  6    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
  6    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
  6    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
  6    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
  6    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
  6    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
  6    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
  6    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
  6    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
  6    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
  6    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
  6    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
  6    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
  6    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
  6    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
  6    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
  6    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
  6    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
  6    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
  6    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
  6    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
  6    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
  6    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
  6    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
  6    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
  6    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
  6    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
  6    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
  6    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
  6    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
  6    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
  6    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
  6    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
  6    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
  6    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
  6    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
  6    68 
  6    69 /* END include file fs_obj_access_codes.incl.pl1 */
      731 
      732  /* BEGIN INCLUDE FILE ... quota_cell.incl.pl1 ... February 1982 */
  7     2 
  7     3 dcl 1 quota_cell based (qcp) aligned,			/* Argument used by vtoc_attributes$(get set)_quota */
  7     4     2 quota fixed bin (35),				/* Record quota */
  7     5     2 used fixed bin (35),				/* Current use */
  7     6     2 received fixed bin (35),			/* Quota moved down */
  7     7     2 tup bit (36),					/* Clock time of update */
  7     8     2 trp fixed bin (71),				/* Time-page-product, in page-seconds */
  7     9     2 pad fixed bin,
  7    10     2 terminal_quota_sw bit (1);			/* TRUE if terminal quota */
  7    11 
  7    12 dcl  qcp ptr;
  7    13 
  7    14 /* END INCLUDE FILE ... quota_cell */
      732 
      733      end quota;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  quota.pl1                         >spec>install>1110>quota.pl1
726          1    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
727          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
728          3    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
729          4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
730          5    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
731          6    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
732          7    05/27/82  1525.9  quota_cell.incl.pl1               >ldd>include>quota_cell.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ASTep                           000406 automatic       pointer                  dcl 712 set ref 721* 723
CHECK_ONLY                      000023 constant        fixed bin(1,0)           initial dcl 81 set ref 484*
DC_FIND_CHASE                   000023 constant        fixed bin(1,0)           initial dcl 3-10 set ref 463*
FS_OBJ_MDIR_QUOTA_MOD           000003 constant        fixed bin(18,0)          initial unsigned dcl 6-57 set ref 284*
FS_OBJ_QUOTA_MOD                000002 constant        fixed bin(18,0)          initial unsigned dcl 6-58 set ref 217*
FS_OBJ_QUOTA_RELOAD             000001 constant        fixed bin(18,0)          initial unsigned dcl 6-59 set ref 244*
FS_OBJ_TRP_MOD                  000000 constant        fixed bin(18,0)          initial unsigned dcl 6-63 set ref 189*
LOTS                            000006 constant        fixed bin(71,0)          initial dcl 82 ref 431
ROOT_UID                        003712 constant        bit(36)                  initial packed unaligned dcl 83 ref 714
SEC_PER_TICK                    000004 constant        float bin(27)            initial dcl 84 ref 426 629 634
a_code                                 parameter       fixed bin(35,0)          dcl 59 set ref 172 177 182 204 209 224 229 233 279
                                                                                  341 359* 368 376 381 386 392 444* 451 457 469 494*
                                                                                  501 506 576 676* 689*
a_dp1                                  parameter       pointer                  dcl 60 ref 576 583
a_ename                                parameter       char                     packed unaligned dcl 61 ref 457 460 501 506 511
a_ep                                   parameter       pointer                  dcl 62 ref 341 343 451 453 576 581
a_ignore                               parameter       fixed bin(17,0)          dcl 63 ref 224 229 233
a_ltrp                                 parameter       fixed bin(71,0)          dcl 64 set ref 172 177 179 224 229 230 368 376 386
                                                                                  392 438*
a_parent                               parameter       char                     packed unaligned dcl 65 ref 172 177 182 185 204 209
                                                                                  214 224 229 233 241 368 376 381 386 392 403 457
                                                                                  459 501 506 510
a_qchange                              parameter       fixed bin(17,0)          dcl 66 ref 501 506 509 576 584
a_quota                                parameter       fixed bin(18,0)          dcl 67 set ref 204 209 213 224 229 233 240 279 282
                                                                                  341 344 368 376 381 386 392 437*
a_seg_or_dir                           parameter       bit(1)                   packed unaligned dcl 68 ref 576 578
a_segptr                               parameter       pointer                  dcl 69 ref 469 471
a_slvid                                parameter       bit(36)                  packed unaligned dcl 70 set ref 368 376 381 386 392
                                                                                  441*
a_taccsw                               parameter       fixed bin(1,0)           dcl 71 set ref 224 229 233 239 368 376 381 386 392
                                                                                  442*
a_trp                                  parameter       fixed bin(35,0)          dcl 72 set ref 233 235 381 439*
a_trpc                                 parameter       fixed bin(35,0)          dcl 73 ref 182 184
a_tup                                  parameter       bit(36)                  dcl 74 set ref 224 229 233 236 368 376 381 386 392
                                                                                  440*
a_uchange                              parameter       fixed bin(17,0)          dcl 75 ref 451 457 469 478
a_uidpath                              parameter       bit(36)                  array dcl 76 ref 279 281
a_used                                 parameter       fixed bin(17,0)          dcl 77 set ref 368 376 381 386 392 443*
access_class             13            based           bit(72)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "quota" set ref 307* 559*
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "quota" set ref 307* 559*
activate                        000034 constant        entry                    external dcl 148 ref 320 354 618 721
addr                                                   builtin function         dcl 163 ref 195 195 252 267 267 302 302 305 333 333
                                                                                  358 358 414 482 529 544 544 548 548 587 587 591
                                                                                  591 617 665 665 667 667 699 699
aim_check_$greater              000036 constant        entry                    external dcl 149 ref 307 559
aim_template                           based           structure                level 1 dcl 1-12
aste                                   based           structure                level 1 dcl 2-11
astep                           000356 automatic       pointer                  dcl 2-9 set ref 254* 255 255 258* 264 320* 321 330
                                                                                  354* 355 356 415* 416 483* 484* 618* 620 624 638*
                                                                                  645 647
bin                                                    builtin function         dcl 163 ref 260 351 423 626
bit                                                    builtin function         dcl 163 ref 239 260 351 423 626
called_find                     000100 automatic       bit(1)                   initial dcl 86 set ref 86* 191* 219* 246* 286* 409*
                                                                                  466* 491 535* 672 685
check_access                    000101 automatic       bit(1)                   packed unaligned dcl 87 set ref 372* 378* 383* 389*
                                                                                  397* 406
clock                                                  builtin function         dcl 163 ref 260 351 423 626
code                            000102 automatic       fixed bin(35,0)          dcl 88 set ref 188* 189* 190 195* 216* 217* 218 243*
                                                                                  244* 245 267* 284* 285 290* 295* 302* 303 311*
                                                                                  315* 320* 326* 333* 354* 358* 359 405* 406* 407*
                                                                                  408 444 461* 463* 465 472* 474* 475 484* 494 508*
                                                                                  517* 533* 534 539* 544* 546 548* 550 555* 563*
                                                                                  567* 587* 589 591* 593 599* 604* 610* 618* 638*
                                                                                  640 665* 667* 676 689 699* 700 719* 720 721*
curtime                         000103 automatic       bit(36)                  dcl 89 set ref 351* 352 423* 425 427 626* 628 630
                                                                                  633 635 656
dc_find$dir_move_quota          000064 constant        entry                    external dcl 3-21 ref 533
dc_find$dir_read                000066 constant        entry                    external dcl 3-23 ref 406
dc_find$dir_read_priv           000070 constant        entry                    external dcl 3-24 ref 407
dc_find$dir_write_priv          000072 constant        entry                    external dcl 3-31 ref 189 217 244
dc_find$finished                000074 constant        entry                    external dcl 3-33 ref 436 491 672 685
dc_find$mdir_set_quota_uid      000076 constant        entry                    external dcl 3-37 ref 284
dc_find$obj_status_read         000100 constant        entry                    external dcl 3-75 ref 463
dc_find$obj_status_read_ptr     000102 constant        entry                    external dcl 3-81 ref 474
dep                             000104 automatic       pointer                  dcl 90 set ref 269 418 486 719* 721*
dir                                    based           structure                level 1 dcl 5-11 in procedure "quota"
dir                       1(19)        based           bit(1)                   level 3 in structure "aim_template" packed packed
                                                                                  unaligned dcl 1-12 in procedure "quota" ref 305
                                                                                  529
dir_privilege                   000106 automatic       bit(1)                   packed unaligned dcl 91 set ref 305* 307 529* 559
dir_quota_sw                    000107 automatic       bit(1)                   initial packed unaligned dcl 92 set ref 92* 174*
                                                                                  206* 226* 258* 370* 395* 484* 503* 578* 579 597
                                                                                  638*
dp                              000362 automatic       pointer                  dcl 5-9 set ref 189* 196* 217* 244* 254* 272* 284*
                                                                                  299 300 301 334* 406* 407* 413 415* 436* 464* 476*
                                                                                  480* 483* 491* 493* 533* 543 543 543 583* 586 586
                                                                                  586 597 671* 672* 673* 685* 687* 698 698 698
dpt                                    parameter       pointer                  dcl 710 set ref 708 714 719*
dt                              000110 automatic       fixed bin(35,0)          dcl 93 set ref 425* 426 628* 629 633* 634
ename                           000111 automatic       char(32)                 packed unaligned dcl 94 set ref 460* 463* 511* 515
                                                                                  516 520 521
entry                                  based           structure                level 1 dcl 4-8
ep                              000360 automatic       pointer                  dcl 4-6 set ref 284* 287 289 294 307 320* 343* 345
                                                                                  346 347 354* 453* 463* 464 474* 476 480 533* 536
                                                                                  538 559 581* 582 618*
error_table_$ai_restricted      000010 external static fixed bin(35,0)          dcl 135 ref 311 563
error_table_$argerr             000012 external static fixed bin(35,0)          dcl 136 ref 517
error_table_$bad_ring_brackets  000014 external static fixed bin(35,0)          dcl 137 ref 295 539
error_table_$invalid_move_qmax  000016 external static fixed bin(35,0)          dcl 138 ref 315 555 567 610
error_table_$master_dir         000020 external static fixed bin(35,0)          dcl 139 ref 599
error_table_$mdc_not_mdir       000022 external static fixed bin(35,0)          dcl 140 ref 290
error_table_$rqover             000024 external static fixed bin(35,0)          dcl 141 ref 326
ex_ring_brackets         35(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 4-8 ref
                                                                                  294 538
fixed                                                  builtin function         dcl 163 ref 258 258 294 425 425 426 442 538 579 628
                                                                                  628 629 633 633 634
len                             000121 automatic       fixed bin(17,0)          dcl 95 set ref 514* 516 520 521 524 525
length                                                 builtin function         dcl 163 ref 514 516 516 524
level$get                       000040 constant        entry                    external dcl 150 ref 294 538
lock$dir_unlock                 000042 constant        entry                    external dcl 151 ref 270 318 420 488 493 673 674 683
                                                                                  687
lock$unlock_ast                 000044 constant        entry                    external dcl 152 ref 265 327 331 357 419 487 641 663
locked                          000122 automatic       bit(1)                   initial dcl 96 set ref 96* 191* 219* 246* 286* 409*
                                                                                  535* 685*
ltrp                            000124 automatic       fixed bin(71,0)          dcl 97 set ref 179* 184* 194 230* 235* 249 399* 430*
                                                                                  431 438
master_dir               32(09)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "quota" ref 289
master_dir               24(19)        based           bit(1)                   level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 5-11 in procedure "quota" ref 597
min                                                    builtin function         dcl 163 ref 431
moved_down                      000126 automatic       fixed bin(35,0)          dcl 98 set ref 322* 324 325
mylock_entry                    000127 automatic       bit(1)                   dcl 99 set ref 512* 580* 600 605 611 642 670
new_entry                       000130 automatic       bit(1)                   initial dcl 100 set ref 100* 373* 377* 388* 394* 438
not_root                        000131 automatic       bit(1)                   initial dcl 101 set ref 101* 265 268 417 485 683
                                                                                  715*
now_terminal                    000132 automatic       bit(1)                   packed unaligned dcl 102 set ref 647* 651
null                                                   builtin function         dcl 163 ref 720
par_astep                 2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 620
parent                          000133 automatic       char(168)                packed unaligned dcl 103 set ref 185* 189* 214* 217*
                                                                                  241* 244* 284* 403* 406* 407* 459* 463* 510* 514
                                                                                  520 521 526
parent_astep                    000206 automatic       pointer                  dcl 104 set ref 620* 625 638* 646
parent_dp                       000210 automatic       pointer                  dcl 105 set ref 269* 270* 287* 307 318* 418* 420*
                                                                                  486* 488* 536* 547 547 547 559 582* 590 590 590
                                                                                  674* 683*
parent_pvid                     000212 automatic       bit(36)                  dcl 106 set ref 547* 548* 590* 591* 667*
parent_qcell                    000214 automatic       structure                level 1 dcl 107 set ref 548 548 591 591 667 667
parent_uid                      000224 automatic       bit(36)                  dcl 108 set ref 547* 548* 590* 591* 667*
parent_vtocx                    000225 automatic       fixed bin(17,0)          dcl 109 set ref 547* 548* 590* 591* 667*
pathname                        000226 automatic       char(168)                packed unaligned dcl 110 set ref 516 520* 521* 524
                                                                                  526* 533*
pds$access_authorization        000026 external static bit(72)                  dcl 142 set ref 305 529
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 1-12
ptr                                                    builtin function         dcl 163 ref 269 287 418 464 476 480 486 536 582 620
pvid                     11            based           bit(36)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "quota" ref 300 543 547 586 590 698
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "quota" ref 346
pvid                            000300 automatic       bit(36)                  dcl 111 in procedure "quota" set ref 195* 267* 300*
                                                                                  302* 333* 346* 358* 543* 544* 586* 587* 665* 698*
                                                                                  699*
qcell                           000302 automatic       structure                level 1 dcl 112 set ref 195 195 267 267 302 302 333
                                                                                  333 348* 358 358 544 544 587 587 665 665 699 699
qchange                         000312 automatic       fixed bin(18,0)          dcl 113 set ref 306* 307 314 509* 552 559 566 584*
                                                                                  594 594* 603 638* 661
qt                              000313 automatic       fixed bin(18,0)          initial dcl 114 set ref 114* 175* 195* 207* 227* 255
                                                                                  255 264 267* 371* 396* 416 504* 544* 548* 579*
                                                                                  587* 591* 624 625 645 646 647 665* 667* 699*
quota                           000302 automatic       fixed bin(35,0)          level 2 in structure "qcell" dcl 112 in procedure
                                                                                  "quota" set ref 262 263* 306 314 322 324* 349* 429
                                                                                  552 552 566 594 645*
quota                           000314 automatic       fixed bin(18,0)          dcl 115 in procedure "quota" set ref 213* 240* 255
                                                                                  258* 262 263 282* 306 323 324 330 344* 349 355
                                                                                  399* 429* 437
quota                           000214 automatic       fixed bin(35,0)          level 2 in structure "parent_qcell" dcl 107
                                                                                  in procedure "quota" set ref 646*
quota                    10            based           fixed bin(18,0)          array level 2 in structure "aste" packed packed
                                                                                  unsigned unaligned dcl 2-11 in procedure "quota"
                                                                                  set ref 255* 330* 355* 645 646
quota_cell                             based           structure                level 1 dcl 7-3
quotaw$cu                       000046 constant        entry                    external dcl 153 ref 484
quotaw$mq                       000050 constant        entry                    external dcl 154 ref 638
quotaw$sq                       000052 constant        entry                    external dcl 155 ref 258
read_lock                       000315 automatic       bit(36)                  initial dcl 116 set ref 116* 719*
received                  2     000302 automatic       fixed bin(35,0)          level 2 dcl 112 set ref 262* 262 322 323* 325 349*
                                                                                  552 661* 661
rtrim                                                  builtin function         dcl 163 ref 514 516
segptr                          000316 automatic       pointer                  dcl 117 set ref 471* 474*
setquota_entry                  000320 automatic       bit(1)                   initial packed unaligned dcl 118 set ref 118* 211*
                                                                                  260
slvid                           000321 automatic       bit(36)                  packed unaligned dcl 119 set ref 413* 441
sons_lvid                12            based           bit(36)                  level 2 dcl 5-11 ref 413
sst$root_astep                  000032 external static pointer                  dcl 144 ref 716
sst_seg$                        000030 external static fixed bin(17,0)          dcl 143 set ref 252 414 482 617
sstp                            000322 automatic       pointer                  dcl 120 set ref 252* 414* 482* 617* 620
substr                                                 builtin function         dcl 163 ref 520 521
sum$dirmod                      000056 constant        entry                    external dcl 157 ref 196 272 334 671
sum$getbranch                   000054 constant        entry                    external dcl 156 ref 719
taccsw                          000324 automatic       bit(1)                   dcl 121 set ref 212* 239* 255 258 258 402* 434* 442
terminal_quota_sw         7     000302 automatic       bit(1)                   level 2 in structure "qcell" dcl 112 in procedure
                                                                                  "quota" set ref 264* 350* 422 434 552 631 647*
terminal_quota_sw         7     000214 automatic       bit(1)                   level 2 in structure "parent_qcell" dcl 107
                                                                                  in procedure "quota" set ref 609
tqsw                      5(24)        based           bit(1)                   array level 2 packed packed unaligned dcl 2-11 set
                                                                                  ref 255 264 356* 647
trp                       4     000214 automatic       fixed bin(71,0)          level 2 in structure "parent_qcell" dcl 107
                                                                                  in procedure "quota" set ref 629* 629 653* 653
trp                       4     000302 automatic       fixed bin(71,0)          level 2 in structure "qcell" dcl 112 in procedure
                                                                                  "quota" set ref 194* 194 249* 426* 426 430 634*
                                                                                  634 653 658*
trp                             000325 automatic       fixed bin(35,0)          dcl 122 in procedure "quota" set ref 399* 431* 439
tup                       3     000302 automatic       bit(36)                  level 2 in structure "qcell" dcl 112 in procedure
                                                                                  "quota" set ref 250* 260* 352* 425 427* 432 633
                                                                                  635* 656*
tup                             000326 automatic       bit(36)                  dcl 123 in procedure "quota" set ref 236* 250 401*
                                                                                  432* 440
tup                       3     000214 automatic       bit(36)                  level 2 in structure "parent_qcell" dcl 107
                                                                                  in procedure "quota" set ref 628 630*
uchange                         000327 automatic       fixed bin(18,0)          dcl 124 set ref 478* 484*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "quota" ref 345
uid                             000330 automatic       bit(36)                  dcl 125 in procedure "quota" set ref 195* 267* 299*
                                                                                  302* 333* 345* 358* 543* 544* 586* 587* 665* 698*
                                                                                  699*
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 5-11 in procedure
                                                                                  "quota" ref 299 543 547 586 590 698 714
uidpath                         000331 automatic       bit(36)                  array dcl 126 set ref 281* 284*
unlock_son                      000351 automatic       bit(1)                   packed unaligned dcl 127 set ref 454* 462* 473* 491
unspec                                                 builtin function         dcl 163 set ref 348*
used                     11            based           fixed bin(18,0)          array level 2 in structure "aste" packed packed
                                                                                  unsigned unaligned dcl 2-11 in procedure "quota"
                                                                                  ref 321 416 624 625
used                      1     000302 automatic       fixed bin(35,0)          level 2 in structure "qcell" dcl 112 in procedure
                                                                                  "quota" set ref 321* 325 416* 426 433 624* 634
used                      1     000214 automatic       fixed bin(35,0)          level 2 in structure "parent_qcell" dcl 107
                                                                                  in procedure "quota" set ref 625* 629
used                            000352 automatic       fixed bin(18,0)          dcl 128 in procedure "quota" set ref 399* 433* 443
vtoc_attributes$get_quota       000060 constant        entry                    external dcl 158 ref 302 544 548 587 591 699
vtoc_attributes$set_quota       000062 constant        entry                    external dcl 159 ref 195 267 333 358 665 667
vtocx                           000353 automatic       fixed bin(17,0)          dcl 129 in procedure "quota" set ref 195* 267* 301*
                                                                                  302* 333* 347* 358* 543* 544* 586* 587* 665* 698*
                                                                                  699*
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 5-11 in procedure "quota" ref 301 543 547 586
                                                                                  590 698
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 4-8 in procedure "quota" ref 347
was_terminal                    000354 automatic       bit(1)                   packed unaligned dcl 130 set ref 631* 632 651 652
write_lock                      000355 automatic       bit(36)                  initial dcl 131 set ref 131*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 3-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 3-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 3-13
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 6-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 6-36
FS_OBJ_AUDIT_FLAG_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 6-67
FS_OBJ_AUTHOR_MOD                      internal static fixed bin(18,0)          initial unsigned dcl 6-46
FS_OBJ_BACKUP_TIMES_MOD                internal static fixed bin(18,0)          initial unsigned dcl 6-48
FS_OBJ_BC_AUTHOR_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 6-47
FS_OBJ_BC_MOD                          internal static fixed bin(18,0)          initial unsigned dcl 6-32
FS_OBJ_CONNECT                         internal static fixed bin(18,0)          initial unsigned dcl 6-31
FS_OBJ_COPY_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 6-38
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 6-55
FS_OBJ_CREATE_BRANCH                   internal static fixed bin(18,0)          initial unsigned dcl 6-66
FS_OBJ_DAMAGED_SW_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 6-39
FS_OBJ_DATES_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 6-49
FS_OBJ_DIR_SALVAGE                     internal static fixed bin(18,0)          initial unsigned dcl 6-56
FS_OBJ_DNZP_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 6-40
FS_OBJ_DT_DUMPED_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 6-50
FS_OBJ_ENTRY_BOUND_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 6-41
FS_OBJ_FOR_RELOADER_MOD                internal static fixed bin(18,0)          initial unsigned dcl 6-51
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 6-65
FS_OBJ_MAX_LEN_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 6-42
FS_OBJ_MOVE_QUOTA                      internal static fixed bin(18,0)          initial unsigned dcl 6-54
FS_OBJ_RECLASSIFY                      internal static fixed bin(18,0)          initial unsigned dcl 6-60
FS_OBJ_RECLASSIFY_NODE                 internal static fixed bin(18,0)          initial unsigned dcl 6-61
FS_OBJ_RENAME                          internal static fixed bin(18,0)          initial unsigned dcl 6-37
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 6-35
FS_OBJ_SAFETY_SW_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 6-43
FS_OBJ_SEG_MOVE                        internal static fixed bin(18,0)          initial unsigned dcl 6-62
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 6-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 6-53
FS_OBJ_SYNC_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 6-44
FS_OBJ_TRUNCATE                        internal static fixed bin(18,0)          initial unsigned dcl 6-33
FS_OBJ_VOLUME_RETRIEVE                 internal static fixed bin(18,0)          initial unsigned dcl 6-64
FS_OBJ_VOL_DUMP_SW_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 6-45
access_operations_$fs_obj_access_mod   external static bit(36)                  dcl 6-27
access_operations_$fs_obj_attr_mod     external static bit(36)                  dcl 6-25
access_operations_$fs_obj_contents_mod external static bit(36)                  dcl 6-23
access_operations_$fs_obj_contents_read
                                       external static bit(36)                  dcl 6-22
access_operations_$fs_obj_create       external static bit(36)                  dcl 6-18
access_operations_$fs_obj_delete       external static bit(36)                  dcl 6-19
access_operations_$fs_obj_initiate     external static bit(36)                  dcl 6-20
access_operations_$fs_obj_prop_read    external static bit(36)                  dcl 6-24
access_operations_$fs_obj_status_mod   external static bit(36)                  dcl 6-26
access_operations_$fs_obj_terminate    external static bit(36)                  dcl 6-21
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
dc_find$dir_for_append          000000 constant        entry                    external dcl 3-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 3-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 3-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 3-19
dc_find$dir_reclassify          000000 constant        entry                    external dcl 3-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 3-28
dc_find$dir_write               000000 constant        entry                    external dcl 3-30
dc_find$link_target             000000 constant        entry                    external dcl 3-35
dc_find$obj_access_write        000000 constant        entry                    external dcl 3-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 3-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 3-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 3-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 3-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 3-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 3-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 3-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 3-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 3-51
dc_find$obj_delete              000000 constant        entry                    external dcl 3-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 3-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 3-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 3-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 3-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 3-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 3-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 3-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 3-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 3-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 3-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 3-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 3-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 3-73
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 3-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 3-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 3-79
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 3-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 3-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 3-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 3-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 3-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 3-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 3-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 3-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 3-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 3-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 3-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 3-95
dc_find$seg_fault               000000 constant        entry                    external dcl 3-97
qcp                                    automatic       pointer                  dcl 7-12
seg_aste                               based           structure                level 1 dcl 2-96
version_number_2                       internal static fixed bin(17,0)          initial dcl 5-84

NAMES DECLARED BY EXPLICIT CONTEXT.
append_mdir_set                 001275 constant        entry                    external dcl 341
bad_path                        002472 constant        label                    dcl 517 ref 524 525
check                           002052 constant        entry                    external dcl 451
check_file                      002100 constant        entry                    external dcl 457
check_seg                       002174 constant        entry                    external dcl 469
common                          000554 constant        label                    dcl 252 ref 222
done                            003540 constant        label                    dcl 685 ref 197 273 335
dqlong_reset                    000066 constant        entry                    external dcl 172
dqmove                          002341 constant        entry                    external dcl 501
dqread                          001425 constant        entry                    external dcl 368
dqrestor                        000400 constant        entry                    external dcl 224
dqset                           000265 constant        entry                    external dcl 204
errxit                          003563 constant        label                    dcl 689 ref 190 218 245 285 408 465 475 518 534 589
                                                                                  593 600 605 611 642
get_common                      001617 constant        label                    dcl 399 ref 374 379 384 390
get_quota_cell                  003566 constant        entry                    internal dcl 696 ref 193 221 248 411
join                            002235 constant        label                    dcl 478 ref 455 467
make_seg_active                 003625 constant        entry                    internal dcl 708 ref 254 415 483
mdir_set                        000730 constant        entry                    external dcl 279
priv_dqread                     001567 constant        entry                    external dcl 392
priv_qread                      001540 constant        entry                    external dcl 386
qget                            001514 constant        entry                    external dcl 381
qlong_reset                     000116 constant        entry                    external dcl 177
qmove                           002374 constant        entry                    external dcl 506
qmove_mylock                    003003 constant        entry                    external dcl 576
qread                           001460 constant        entry                    external dcl 376
qreload                         000462 constant        entry                    external dcl 233
qreload_common                  000505 constant        label                    dcl 236 ref 231
qreset                          000146 constant        entry                    external dcl 182
qrestor                         000430 constant        entry                    external dcl 229
qset                            000313 constant        entry                    external dcl 209
quota                           000053 constant        entry                    external dcl 14
reset1                          000171 constant        label                    dcl 185 ref 180
skip_del_entry                  003135 constant        label                    dcl 597 ref 571
unlock                          002003 constant        label                    dcl 436
unlock1                         003540 constant        label                    dcl 685 ref 328 700
unlock2                         003527 constant        label                    dcl 683 ref 291 296 303 312 316 540 546 550 556 564
                                                                                  568 601 606 612 643
unlock3                         002305 constant        label                    dcl 491

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4444        4550    3714        4454
Length      5216    3714       104         431     527           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
quota                               324 external procedure  is an external procedure.  
get_quota_cell                          internal procedure  shares stack frame of external procedure quota.  
make_seg_active                         internal procedure  shares stack frame of external procedure quota.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
quota                    000100 called_find                 quota
                         000101 check_access                quota
                         000102 code                        quota
                         000103 curtime                     quota
                         000104 dep                         quota
                         000106 dir_privilege               quota
                         000107 dir_quota_sw                quota
                         000110 dt                          quota
                         000111 ename                       quota
                         000121 len                         quota
                         000122 locked                      quota
                         000124 ltrp                        quota
                         000126 moved_down                  quota
                         000127 mylock_entry                quota
                         000130 new_entry                   quota
                         000131 not_root                    quota
                         000132 now_terminal                quota
                         000133 parent                      quota
                         000206 parent_astep                quota
                         000210 parent_dp                   quota
                         000212 parent_pvid                 quota
                         000214 parent_qcell                quota
                         000224 parent_uid                  quota
                         000225 parent_vtocx                quota
                         000226 pathname                    quota
                         000300 pvid                        quota
                         000302 qcell                       quota
                         000312 qchange                     quota
                         000313 qt                          quota
                         000314 quota                       quota
                         000315 read_lock                   quota
                         000316 segptr                      quota
                         000320 setquota_entry              quota
                         000321 slvid                       quota
                         000322 sstp                        quota
                         000324 taccsw                      quota
                         000325 trp                         quota
                         000326 tup                         quota
                         000327 uchange                     quota
                         000330 uid                         quota
                         000331 uidpath                     quota
                         000351 unlock_son                  quota
                         000352 used                        quota
                         000353 vtocx                       quota
                         000354 was_terminal                quota
                         000355 write_lock                  quota
                         000356 astep                       quota
                         000360 ep                          quota
                         000362 dp                          quota
                         000406 ASTep                       make_seg_active

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out        return_mac          fl2_to_fx2          shorten_stack
ext_entry           ext_entry_desc      clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
activate                      aim_check_$greater            dc_find$dir_move_quota        dc_find$dir_read
dc_find$dir_read_priv         dc_find$dir_write_priv        dc_find$finished              dc_find$mdir_set_quota_uid
dc_find$obj_status_read       dc_find$obj_status_read_ptr   level$get                     lock$dir_unlock
lock$unlock_ast               quotaw$cu                     quotaw$mq                     quotaw$sq
sum$dirmod                    sum$getbranch                 vtoc_attributes$get_quota     vtoc_attributes$set_quota

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$argerr           error_table_$bad_ring_brackets
error_table_$invalid_move_qmax                              error_table_$master_dir       error_table_$mdc_not_mdir
error_table_$rqover           pds$access_authorization      sst$root_astep                sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     86 000035        92 000036        96 000037       100 000040       101 000041       114 000043       116 000044
    118 000045       131 000046        14 000052       172 000061       174 000107       175 000111       177 000113
    179 000137       180 000141       182 000142       184 000165       185 000171       188 000177       189 000200
    190 000215       191 000217       193 000222       194 000223       195 000226       196 000251       197 000260
    204 000261       206 000304       207 000306       209 000310       211 000332       212 000334       213 000335
    214 000340       216 000345       217 000346       218 000363       219 000365       221 000370       222 000371
    224 000372       226 000421       227 000423       229 000425       230 000451       231 000453       233 000454
    235 000501       236 000505       239 000510       240 000515       241 000517       243 000524       244 000525
    245 000542       246 000544       248 000547       249 000550       250 000552       252 000554       254 000557
    255 000561       258 000601       260 000621       262 000630       263 000637       264 000641       265 000647
    267 000656       268 000701       269 000703       270 000705       272 000714       273 000723       279 000724
    281 000741       282 000746       284 000750       285 000771       286 000773       287 000776       289 001000
    290 001004       291 001007       294 001010       295 001025       296 001030       299 001031       300 001034
    301 001036       302 001041       303 001065       305 001067       306 001075       307 001103       311 001125
    312 001130       314 001131       315 001135       316 001140       318 001141       320 001150       321 001163
    322 001167       323 001175       324 001177       325 001205       326 001215       327 001220       328 001224
    330 001225       331 001230       333 001235       334 001261       335 001270       341 001271       343 001306
    344 001312       345 001314       346 001316       347 001320       348 001323       349 001326       350 001331
    351 001333       352 001340       354 001341       355 001354       356 001360       357 001362       358 001367
    359 001413       360 001415       368 001416       370 001446       371 001450       372 001452       373 001454
    374 001455       376 001456       377 001501       378 001503       379 001504       381 001505       383 001533
    384 001535       386 001536       388 001561       389 001563       390 001564       392 001565       394 001610
    395 001612       396 001614       397 001616       399 001617       401 001624       402 001625       403 001626
    405 001634       406 001635       407 001653       408 001666       409 001670       411 001673       413 001674
    414 001677       415 001702       416 001704       417 001715       418 001717       419 001721       420 001726
    422 001735       423 001737       425 001744       426 001753       427 001763       429 001765       430 001767
    431 001771       432 001775       433 001777       434 002001       436 002003       437 002016       438 002021
    439 002026       440 002030       441 002032       442 002036       443 002041       444 002043       445 002045
    451 002046       453 002065       454 002071       455 002072       457 002073       459 002126       460 002134
    461 002141       462 002142       463 002144       464 002163       465 002165       466 002167       467 002171
    469 002172       471 002207       472 002213       473 002214       474 002216       475 002231       476 002233
    478 002235       480 002237       482 002241       483 002244       484 002246       485 002265       486 002267
    487 002271       488 002276       491 002305       493 002325       494 002334       495 002336       501 002337
    503 002365       504 002367       506 002371       508 002420       509 002421       510 002424       511 002431
    512 002436       514 002437       515 002451       516 002455       517 002472       518 002475       520 002476
    521 002515       522 002543       524 002545       525 002547       526 002551       529 002554       533 002562
    534 002576       535 002600       536 002603       538 002605       539 002622       540 002625       543 002626
    543 002631       543 002633       544 002636       546 002661       547 002663       547 002666       547 002670
    548 002673       550 002716       552 002720       555 002731       556 002734       559 002735       563 002761
    564 002764       566 002765       567 002771       568 002774       571 002775       576 002776       578 003014
    579 003021       580 003024       581 003026       582 003031       583 003033       584 003036       586 003040
    586 003042       586 003044       587 003047       589 003072       590 003074       590 003077       590 003101
    591 003104       593 003127       594 003131       597 003135       599 003144       600 003147       601 003151
    603 003152       604 003154       605 003155       606 003157       609 003160       610 003162       611 003165
    612 003167       617 003170       618 003173       620 003205       624 003213       625 003224       626 003232
    628 003237       629 003247       630 003257       631 003261       632 003263       633 003265       634 003272
    635 003302       638 003304       640 003323       641 003325       642 003332       643 003334       645 003335
    646 003345       647 003354       651 003364       652 003366       653 003370       654 003373       656 003374
    658 003376       661 003400       663 003404       665 003411       667 003434       670 003457       671 003461
    672 003470       673 003506       674 003515       676 003524       677 003526       683 003527       685 003540
    687 003554       689 003563       690 003565       696 003566       698 003567       698 003572       698 003574
    699 003577       700 003622       702 003624       708 003625       714 003627       715 003634       716 003635
    719 003642       720 003657       721 003665       723 003700


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
