	COMPILATION LISTING OF SEGMENT pc_deposit
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1009.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /* format: style3 */
       11 pc_deposit:
       12      proc (Pvtx, Devadd, Vtocx, Pageno);
       13 
       14 /*  Routine to deposit an address or a list of addresses to the Volume
       15*    Map. It is called from ALM Page Control when the address or addresses
       16*    cannot be deposited into the record stock. This can happen only if
       17*    the record stock is full. Asynchronous record stock management
       18*    will deposit excess addresses to the Volume Map as we update each
       19*    Volume Map page.
       20*
       21*    This routine is also called during a volume scavenge, when addresses
       22*    are to be deposited to the volume being scavenged. Asynchronous
       23*    scavenger action is done here (that is, the scavenger data block
       24*    for this volume is updated - addresses being deposited are checked
       25*    for conflicts and their states are updated). 
       26*
       27*    Written March 1982 by J. Bongiovanni
       28*    Modified July 1982 by J. Bongiovanni for the scavenger
       29**/
       30 
       31 
       32 /****^  HISTORY COMMENTS:
       33*  1) change(86-06-10,Hartogs), approve(86-06-10,MCR7383),
       34*     audit(86-06-11,Coppola), install(86-07-17,MR12.0-1097):
       35*     Calls to syserr modified to report on subvolumes.
       36*                                                   END HISTORY COMMENTS */
       37 
       38 
       39 /*  Parameter  */
       40 
       41 dcl	Pvtx		fixed bin parameter;	/* PVTE index */
       42 dcl	Devadd		bit (36) aligned parameter;	/* Single address to deposit */
       43 dcl	Vtocx		fixed bin;		/* VTOCE index (used by scavenger) */
       44 dcl	Pageno		fixed bin;		/* Page number within segment (used by scavenger) */
       45 dcl	List_ptr		ptr parameter;		/* Pointer to list of addresses */
       46 dcl	First		fixed bin;		/* First element to deposit in array */
       47 dcl	Last		fixed bin;		/* Last element to deposit in array */
       48 dcl	Pageno_list_ptr	ptr;			/* Pointer to list of page numbers */
       49 
       50 /*  Automatic  */
       51 
       52 dcl	check_scavenger	bit (1) aligned;
       53 dcl	conflict		bit (1) aligned;
       54 dcl	grabbed_vpage	fixed bin;
       55 dcl	listx		fixed bin;
       56 dcl	listx1		fixed bin;
       57 dcl	p99		pic "99";
       58 dcl	pageno		fixed bin;
       59 dcl	pages		fixed bin;
       60 dcl	pf_begin		fixed bin (35);
       61 dcl	pf_end		fixed bin (35);
       62 dcl	Single_addressp	ptr;
       63 dcl	this_vpage	fixed bin;
       64 dcl	vcpu_begin	fixed bin (71);
       65 dcl	vcpu_end		fixed bin (71);
       66 dcl	volmap_locked	bit (1);
       67 dcl	vpage_found	bit (1);
       68 dcl	vpage_list	(256) fixed bin;
       69 dcl	vpage_no		fixed bin;
       70 dcl	vpage_ptr		ptr;
       71 dcl	vtoc_index	fixed bin;
       72 
       73 /*  Static  */
       74 
       75 dcl	NULL_SDW		fixed bin (71) int static options (constant) init (0);
       76 dcl	RECORDS_PER_WORD	fixed bin int static options (constant) init (32);
       77 
       78 /*  Based  */
       79 
       80 dcl	1 List		(Last) aligned like Single_address based (List_ptr);
       81 dcl	Pageno_list	(Last) fixed bin based (Pageno_list_ptr);
       82 dcl	1 Single_address	aligned based (Single_addressp),
       83 	  2 Null_flag	bit (1) unaligned,
       84 	  2 Address	fixed bin (17) unsigned unaligned,
       85 	  2 Pad		bit (18) unaligned;
       86 
       87 /*  External  */
       88 
       89 dcl	volmap_abs_seg$	external;
       90 
       91 /*  Entry  */
       92 
       93 dcl	page$grab_volmap_page_unwired
       94 			entry (ptr, fixed bin, ptr);
       95 dcl	page$lock_volmap	entry (ptr);
       96 dcl	page$unlock_volmap	entry (ptr);
       97 dcl	page$write_volmap_page_unwired
       98 			entry (ptr, fixed bin);
       99 dcl	pmut$swap_sdw	entry (ptr, ptr);
      100 dcl	syserr		entry options (variable);
      101 dcl	usage_values	entry (fixed bin (35), fixed bin (71));
      102 
      103 /*  Condition  */
      104 
      105 dcl	cleanup		condition;
      106 dcl	page_fault_error	condition;
      107 
      108 /*  Builtin  */
      109 
      110 dcl	addr		builtin;
      111 dcl	convert		builtin;
      112 dcl	divide		builtin;
      113 dcl	mod		builtin;
      114 dcl	null		builtin;
      115 dcl	ptr		builtin;
      116 dcl	stacq		builtin;
      117 dcl	unspec		builtin;
      118 
      119 /*  Deposit a single record address into the Volume Map  */
      120 
      121 	call usage_values (pf_begin, vcpu_begin);
      122 	pages = 1;
      123 
      124 	pvtep = addr (addr (pvt$array) -> pvt_array (Pvtx));
      125 	record_stockp = pvte.volmap_stock_ptr;
      126 	Single_addressp = addr (Devadd);
      127 	volmap_locked = "0"b;
      128 	grabbed_vpage = -1;
      129 
      130 	call CHECK_FOR_SCAVENGE;
      131 
      132 	vtoc_index = Vtocx;
      133 	pageno = Pageno;
      134 
      135 	call FIND_VOLMAP_PAGE (Single_addressp, vpage_no, pageno, conflict);
      136 	if conflict
      137 	then goto RETURN;
      138 
      139 	on cleanup call UNLOCK_RESET;
      140 
      141 	call LOCK_SETUP;
      142 
      143 	on page_fault_error
      144 	     begin;
      145 		call IO_ERROR;
      146 		goto RETURN;
      147 	     end;
      148 
      149 	call page$grab_volmap_page_unwired (pvtep, vpage_no - 1, vpage_ptr);
      150 	grabbed_vpage = vpage_no - 1;
      151 
      152 	call DEPOSIT_TO_PAGE ((Single_address.Address), vpage_no, vpage_ptr);
      153 
      154 	call page$write_volmap_page_unwired (pvtep, vpage_no - 1);
      155 	grabbed_vpage = -1;
      156 
      157 RETURN:
      158 	revert page_fault_error;
      159 
      160 	call UNLOCK_RESET;
      161 
      162 	call METER;
      163 
      164 	return;
      165 
      166 /*  Deposit a list of addresses into the Volume Map. Go through the list
      167*    some number of times. For each candidate found, compute the Volume
      168*    Map page number, grab the page, and deposit all addresses in the list
      169*    which belong to that page.
      170**/
      171 
      172 pc_deposit$deposit_list:
      173      entry (Pvtx, List_ptr, First, Last, Vtocx, Pageno_list_ptr);
      174 
      175 	call usage_values (pf_begin, vcpu_begin);
      176 	pages = Last - First + 1;
      177 
      178 	pvtep = addr (addr (pvt$array) -> pvt_array (Pvtx));
      179 	record_stockp = pvte.volmap_stock_ptr;
      180 	volmap_locked = "0"b;
      181 	grabbed_vpage = -1;
      182 
      183 	call CHECK_FOR_SCAVENGE;
      184 
      185 	vtoc_index = Vtocx;
      186 
      187 	do listx = First to Last;
      188 	     if Pageno_list_ptr = null ()
      189 	     then pageno = -1;
      190 	     else pageno = Pageno_list (listx);
      191 	     call FIND_VOLMAP_PAGE (addr (List (listx)), vpage_list (listx), pageno, conflict);
      192 	     if conflict
      193 	     then vpage_list (listx) = -1;
      194 	end;
      195 
      196 	on cleanup call UNLOCK_RESET;
      197 
      198 	call LOCK_SETUP;
      199 
      200 	on page_fault_error
      201 	     begin;
      202 dcl	pagex		fixed bin;
      203 
      204 		if grabbed_vpage >= 0
      205 		then do;
      206 			do pagex = First to Last;
      207 			     if vpage_list (pagex) = grabbed_vpage + 1
      208 			     then vpage_list (pagex) = -1;
      209 			end;
      210 			call IO_ERROR;
      211 		     end;
      212 		goto VPAGE_RETRY;
      213 	     end;
      214 
      215 VPAGE_RETRY:
      216 	vpage_found = "0"b;
      217 	do listx = First to Last;
      218 	     if vpage_list (listx) > 0
      219 	     then do;
      220 		     vpage_found = "1"b;
      221 		     this_vpage = vpage_list (listx);
      222 		     call page$grab_volmap_page_unwired (pvtep, this_vpage - 1, vpage_ptr);
      223 		     grabbed_vpage = this_vpage - 1;
      224 		     do listx1 = listx to Last;
      225 			if vpage_list (listx1) = this_vpage
      226 			then do;
      227 				call DEPOSIT_TO_PAGE ((List (listx1).Address), this_vpage, vpage_ptr);
      228 				vpage_list (listx1) = -1;
      229 			     end;
      230 		     end;
      231 		     call page$write_volmap_page_unwired (pvtep, grabbed_vpage);
      232 		     grabbed_vpage = -1;
      233 		end;
      234 	end;
      235 
      236 	if vpage_found
      237 	then goto VPAGE_RETRY;
      238 
      239 	revert page_fault_error;
      240 
      241 	call UNLOCK_RESET;
      242 
      243 	call METER;
      244 
      245 	return;
      246 
      247 /* Internal Procedure to find the Volume Map page associated with a given
      248*   address */
      249 
      250 FIND_VOLMAP_PAGE:
      251      proc (Devaddp, Volmap_pageno, Page_no, Conflict);
      252 
      253 dcl	Devaddp		ptr parameter;
      254 dcl	Volmap_pageno	fixed bin parameter;
      255 dcl	Page_no		fixed bin parameter;
      256 dcl	Conflict		bit (1) aligned parameter;
      257 
      258 dcl	vpagex		fixed bin;
      259 dcl	vpage_found	bit (1);
      260 dcl	address		fixed bin;
      261 
      262 dcl	1 Devaddr		aligned like Single_address based (Devaddp);
      263 
      264 	vpage_found = "0"b;
      265 	address = Devaddr.Address;
      266 	Conflict = "0"b;
      267 
      268 	if address < pvte.baseadd | address >= pvte.baseadd + pvte.totrec
      269 	then call syserr (CRASH, "pc_deposit: Address ^o out of paging region on ^a_^a^[^a^;^s^].", address, pvte.devname,
      270 		convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      271 
      272 	do vpagex = record_stock.n_volmap_pages to 1 by -1 while (^vpage_found);
      273 	     if address >= record_stock.volmap_page (vpagex).baseadd
      274 	     then do;
      275 		     vpage_found = "1"b;
      276 		     Volmap_pageno = vpagex;
      277 		end;
      278 	end;
      279 
      280 	if ^vpage_found
      281 	then call syserr (CRASH, "pc_deposit: Invalid address ^o on ^a_^a^[^a^;^s^].", address, pvte.devname,
      282 		convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      283 
      284 	if check_scavenger
      285 	then Conflict = CHECK_ADDRESS_FOR_SCAVENGER (address, Page_no);
      286 
      287 	return;
      288 
      289 
      290      end FIND_VOLMAP_PAGE;
      291 
      292 /* Internal Procedure to deposit a single record address to the Volume Map */
      293 
      294 DEPOSIT_TO_PAGE:
      295      proc (Record_address, Vpage_no, Vpage_ptr);
      296 
      297 dcl	Record_address	fixed bin;
      298 dcl	Vpage_no		fixed bin;
      299 dcl	Vpage_ptr		ptr;
      300 
      301 dcl	bit_no		fixed bin;
      302 dcl	word_no		fixed bin;
      303 
      304 dcl	1 Vm_page		aligned based (Vpage_ptr),
      305 	  2 Word		(0:1023) aligned,
      306 	    3 Pad1	bit (1) unaligned,
      307 	    3 Bit		(0:31) bit (1) unaligned,
      308 	    3 Pad2	bit (3) unaligned;
      309 
      310 	word_no = divide (Record_address - record_stock.volmap_page (Vpage_no).baseadd, RECORDS_PER_WORD, 17);
      311 	if word_no < 0 | word_no > 1023 | (Vpage_no = 1 & word_no < 64)
      312 	then call syserr (CRASH, "pc_deposit: Invalid address ^o on ^a_^a^[^a^;^s^].", Record_address, pvte.devname,
      313 		convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      314 
      315 	bit_no = mod (Record_address - record_stock.volmap_page (Vpage_no).baseadd, RECORDS_PER_WORD);
      316 
      317 	if Vm_page.Word (word_no).Bit (bit_no)
      318 	then do;
      319 		call syserr (ANNOUNCE, "pc_deposit: Deposit in-use address ^o on ^a_^a^[^a^;^s^].", Record_address,
      320 		     pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      321 		pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      322 						/* Add to inconsistency count */
      323 	     end;
      324 	else do;
      325 		Vm_page.Word (word_no).Bit (bit_no) = "1"b;
      326 		pvte.nleft = pvte.nleft + 1;
      327 		record_stock.volmap_page (Vpage_no).n_free = record_stock.volmap_page (Vpage_no).n_free + 1;
      328 	     end;
      329 
      330 	return;
      331 
      332      end DEPOSIT_TO_PAGE;
      333 
      334 /*  Internal Procedure to handle I/O Error on the Volume Map  */
      335 
      336 IO_ERROR:
      337      proc;
      338 
      339 	pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      340 	if grabbed_vpage >= 0
      341 	then if record_stock.volmap_page (grabbed_vpage + 1).n_free > 0
      342 	     then do;
      343 		     record_stock.volmap_page (grabbed_vpage + 1).n_free = 0;
      344 		     call syserr (BEEP,
      345 			"pc_deposit: Unrecoverable I/O error on Volmap page ^d of ^a_^a^[^a^;^s^]. Addresses lost.",
      346 			grabbed_vpage, pvte.devname, convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name);
      347 		end;
      348 
      349      end IO_ERROR;
      350 
      351 /*  Internal procedure to see whether there's a scavenge goin' on for this
      352*    physical volume and set a flag accordingly.
      353**/
      354 
      355 CHECK_FOR_SCAVENGE:
      356      proc;
      357 
      358 	check_scavenger = "0"b;
      359 
      360 	scavenger_blockp = null ();
      361 	scavenger_datap = addr (scavenger_data$);
      362 
      363 	if pvte.scavenger_block_rel ^= ""b
      364 	then if pvte.scav_check_address
      365 	     then do;
      366 		     check_scavenger = "1"b;
      367 		     scavenger_blockp = ptr (scavenger_datap, pvte.scavenger_block_rel);
      368 		end;
      369 
      370      end CHECK_FOR_SCAVENGE;
      371 
      372 /*  Internal Procedure to check an address against the scavenger block for
      373*    this physical volume. The state is updated and conflicts marked
      374*    appropriately. Indication of conflict is returned to the caller,
      375*    so that the address is not deposited.
      376**/
      377 
      378 CHECK_ADDRESS_FOR_SCAVENGER:
      379      proc (Record_address, Page_no) returns (bit (1) aligned);
      380 
      381 dcl	Record_address	fixed bin parameter;
      382 dcl	Page_no		fixed bin parameter;
      383 
      384 dcl	1 A_record_block	aligned like record_block;
      385 dcl	Ap		ptr;
      386 dcl	conflict		bit (1) aligned;
      387 dcl	locked		bit (1) aligned;
      388 dcl	1 Q_record_block	aligned like record_block;
      389 dcl	Qp		ptr;
      390 dcl	Wp		ptr;
      391 
      392 dcl	A		bit (36) aligned based (Ap);
      393 dcl	Q		bit (36) aligned based (Qp);
      394 dcl	W		bit (36) aligned based (Wp);
      395 
      396 
      397 	record_blockp = addr (scavenger_block.records (Record_address - pvte.baseadd + 1));
      398 
      399 	locked = "0"b;
      400 	Ap = addr (A_record_block);
      401 	Qp = addr (Q_record_block);
      402 	Wp = record_blockp;
      403 	do while (^locked);
      404 	     unspec (Q_record_block) = unspec (record_block);
      405 	     unspec (A_record_block) = unspec (Q_record_block);
      406 	     if ^A_record_block.lock
      407 	     then do;
      408 		     A_record_block.lock = "1"b;
      409 		     locked = stacq (W, A, Q);
      410 		end;
      411 	end;
      412 
      413 	if record_block.state = STATE_UNSEEN
      414 	then record_block.state = STATE_FREE;
      415 	else if record_block.state = STATE_FREE
      416 	then record_block.state = STATE_CONFLICT;
      417 	else if record_block.state = STATE_IN_USE
      418 	then do;
      419 		if Page_no >= 0 & vtoc_index >= 0 & record_block.vtocx = vtoc_index & record_block.pageno = Page_no
      420 		then do;
      421 			record_block.vtocx = 0;
      422 			record_block.pageno = 0;
      423 			record_block.state = STATE_FREE;
      424 		     end;
      425 		else record_block.state = STATE_CONFLICT;
      426 	     end;
      427 
      428 	if record_block.state = STATE_CONFLICT
      429 	then conflict = "1"b;
      430 	else conflict = "0"b;
      431 
      432 	record_block.lock = "0"b;
      433 
      434 	return (conflict);
      435 
      436 
      437      end CHECK_ADDRESS_FOR_SCAVENGER;
      438 
      439 
      440 
      441 /*  Internal Procedure to lock the Volume Map lock, setup volmap_abs_seg  */
      442 
      443 LOCK_SETUP:
      444      proc;
      445 
      446 	call page$lock_volmap (pvtep);
      447 	volmap_locked = "1"b;
      448 	call pmut$swap_sdw (addr (volmap_abs_seg$), addr (pvte.volmap_seg_sdw));
      449 
      450      end LOCK_SETUP;
      451 
      452 /*  Internal Procedure to Cleanup  */
      453 
      454 UNLOCK_RESET:
      455      proc;
      456 
      457 	if grabbed_vpage ^= -1
      458 	then call page$write_volmap_page_unwired (pvtep, grabbed_vpage);
      459 	grabbed_vpage = -1;
      460 
      461 	call pmut$swap_sdw (addr (volmap_abs_seg$), addr (NULL_SDW));
      462 
      463 	if volmap_locked
      464 	then call page$unlock_volmap (pvtep);
      465 	volmap_locked = "0"b;
      466 
      467      end UNLOCK_RESET;
      468 
      469 /*  Internal Subroutine to meter CPU time, number of calls, and number of pages
      470*    whose addresses were deposited  */
      471 
      472 METER:
      473      proc;
      474 
      475 	stock_segp = addr (stock_seg$);
      476 	stock_seg.meters.pc_deposit_calls = stock_seg.meters.pc_deposit_calls + 1;
      477 	stock_seg.meters.pc_deposit_pages = stock_seg.meters.pc_deposit_pages + pages;
      478 	call usage_values (pf_end, vcpu_end);
      479 	stock_seg.meters.pc_deposit_time = stock_seg.meters.pc_deposit_time + vcpu_end - vcpu_begin;
      480 
      481      end METER;
      482 
      483 
  1     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  1     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1     8*     Add the support for subvolumes
  1     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  1    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  1    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  1    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  1    14*     Added inconsistent_dbm bit for determining the status of volume
  1    15*     dumper bit maps.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18      dcl	   pvt$array	      aligned external;
  1    19      dcl	   pvt$max_n_entries      fixed bin external;
  1    20 
  1    21      dcl	   pvt_arrayp	      ptr;
  1    22      dcl	   pvtep		      ptr;
  1    23 
  1    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  1    25 
  1    26      dcl	   1 pvte		      based (pvtep) aligned,
  1    27 
  1    28 	     2 pvid	      bit (36),		/* physical volume ID */
  1    29 
  1    30 	     2 lvid	      bit (36),		/* logical volume ID */
  1    31 
  1    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  1    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  1    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  1    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  1    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  1    37 	     2 pad3	      bit (2) unaligned,
  1    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  1    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  1    40 
  1    41 
  1    42 
  1    43 	     2 devname	      char (4),		/* device name */
  1    44 
  1    45 	     (2 device_type	      fixed bin (8),	/* device type */
  1    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  1    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  1    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  1    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  1    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  1    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  1    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  1    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  1    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  1    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  1    56 	     2 scav_check_address
  1    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  1    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  1    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  1    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  1    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  1    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  1    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  1    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  1    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  1    66 
  1    67 
  1    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  1    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  1    70 
  1    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  1    72 
  1    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  1    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  1    75 
  1    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  1    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  1    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  1    79 	     2 records_per_cyl    fixed bin,
  1    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  1    81 	     2 sv_name            char (2) aligned,
  1    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  1    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  1    84 
  1    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  1    86 	     2 pad2	      bit (18) unaligned,
  1    87 
  1    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  1    89 
  1    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  1    91 
  1    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  1    93 
  1    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  1    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  1    96 
  1    97 
  1    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  1    99 
  1   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  1   101 
  1   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  1   103 
  1   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  1   105 
  1   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  1   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  1   108 
  1   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  1   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  1   111 
  1   112 
  1   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  1   114 	   VOLMAP_ASYNC_READ      init (1),
  1   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  1   116 
  1   117 
  1   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      484 
      485 
  2     1 /*  START OF:	scavenger_data.incl.pl1   November 1982       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* format: style3 */
  2     4 dcl	scavenger_data$	external;
  2     5 
  2     6 dcl	scavenger_datap	ptr;
  2     7 dcl	sc_metersp	ptr;
  2     8 dcl	sc_process_tablep	ptr;
  2     9 dcl	scavenger_blockp	ptr;
  2    10 dcl	record_blockp	ptr;
  2    11 dcl	scavenger_optionsp	ptr;
  2    12 
  2    13 dcl	sc_n_processes	fixed bin;
  2    14 dcl	scavenger_n_records fixed bin;
  2    15 dcl	scavenger_n_ovfl	fixed bin;
  2    16 
  2    17 
  2    18 dcl	1 scavenger_data	aligned based (scavenger_datap),
  2    19 	  2 lock		aligned,			/* Lock on scavenger_data */
  2    20 	    3 lock_word	bit (36) aligned,
  2    21 	    3 wait_event	bit (36) aligned,
  2    22 	    3 notify_sw	bit (1) aligned,
  2    23 	  2 process_table_ptr
  2    24 			ptr,			/* Pointer to scavenger process table */
  2    25 	  2 error_severity	fixed bin,		/* Severity of unexpected error condition */
  2    26 	  2 meters	aligned like sc_meters,
  2    27 	  2 free		bit (1) aligned;		/* Available region */
  2    28 
  2    29 
  2    30 dcl	1 sc_meters	aligned based (sc_metersp),	/* Meters */
  2    31 	  2 n_scavenge	fixed bin (35),		/* Number of volume scavenges */
  2    32 	  2 pf		fixed bin (35),		/* Total page faults */
  2    33 	  2 vcpu		fixed bin (71),		/* Total virtual CPU time */
  2    34 	  2 clock_time	fixed bin (71),		/* Total clock time */
  2    35 	  2 n_vtoces	fixed bin (35),		/* Number VTOCEs examined */
  2    36 	  2 n_vtoces_damaged
  2    37 			fixed bin (35),		/* Number VTOCEs damaged by scavenge */
  2    38 	  2 n_vtoces_per_proc
  2    39 			fixed bin (35),		/* Number per-process VTOCEs freed */
  2    40 	  2 n_vtoces_per_boot
  2    41 			fixed bin (35),		/* Number per-bootload VTOCEs freed */
  2    42 	  2 n_vtoces_freed	fixed bin (35),		/* Total number VTOCEs freed */
  2    43 	  2 n_vtoces_fmd	fixed bin (35),		/* Number VTOCEs with fm_damaged reset */
  2    44 	  2 n_records	fixed bin (35),		/* Number non-null filemap entries examined */
  2    45 	  2 n_conflicts	fixed bin (35),		/* Number potential conflicts detected */
  2    46 	  2 n_fmd_conflicts fixed bin (35),		/* Number potential conflicts due to fm_damaged */
  2    47 	  2 n_real_conflicts
  2    48 			fixed bin (35),		/* Number real conflicts */
  2    49 	  2 n_lost_records	fixed bin (35);		/* Number lost records freed */
  2    50 
  2    51 
  2    52 dcl	1 sc_process_table	aligned based (sc_process_tablep),
  2    53 	  2 max_n_processes fixed bin,		/* Number of table entries */
  2    54 	  2 n_processes	fixed bin,		/* Number active entries */
  2    55 	  2 process	(sc_n_processes refer (sc_process_table.max_n_processes)) aligned,
  2    56 	    3 processid	bit (36) aligned,		/* Owner. 0=>empty */
  2    57 	    3 pvtep	ptr unal,			/* PVTE of volume being scavenged */
  2    58 	    3 blockp	ptr unal,			/* Block w/i scavenger_data */
  2    59 	    3 first_block_page
  2    60 			fixed bin,		/* Index of first page of block */
  2    61 	    3 n_block_pages fixed bin;		/* Number of pages in block */
  2    62 
  2    63 
  2    64 dcl	1 scavenger_block	aligned based (scavenger_blockp),
  2    65 	  2 n_records	fixed bin,		/* Number of record addresses */
  2    66 	  2 n_ovfl	fixed bin,		/* Number of overflow blocks */
  2    67 	  2 ovfl_free_ix	fixed bin,		/* Index of first free overflow block */
  2    68 	  2 records	(scavenger_n_records refer (scavenger_block.n_records)) aligned like record_block,
  2    69 	  2 overflow	(scavenger_n_ovfl refer (scavenger_block.n_ovfl)) aligned like record_block;
  2    70 
  2    71 
  2    72 dcl	1 record_block	aligned based (record_blockp),/* One per record address */
  2    73 	  2 vtocx		fixed bin (15) uns unal,	/* Owning VTOCE index */
  2    74 	  2 pageno	fixed bin (8) uns unal,	/* Owning page number */
  2    75 	  2 state		fixed bin (2) uns unal,	/* State */
  2    76 	  2 lock		bit (1) unal,		/* Lock bit on this block */
  2    77 	  2 ovflx		fixed bin (10) uns unal;	/* Index of first overflow block on chain */
  2    78 
  2    79 dcl	1 scavenger_data_pages
  2    80 			aligned based (scavenger_datap),
  2    81 	  2 page		(0:255) aligned,
  2    82 	    3 word	(1024) bit (36) aligned;
  2    83 
  2    84 dcl	1 scavenger_options aligned based (scavenger_optionsp),
  2    85 	  2 print_meters	bit (1) unaligned,		/* ON => meter each scavenge into the log */
  2    86 	  2 debug		bit (1) unaligned,		/* ON => do special debugging things */
  2    87 	  2 dump		bit (1) unaligned,		/* ON => dump bad VTOCEs into syserr log */
  2    88 	  2 trap		bit (1) unaligned,		/* ON => trap to BOS for debug */
  2    89 	  2 no_optimize	bit (1) unaligned,		/* ON => no VTOCE read-ahead */
  2    90 	  2 fault_under_ast bit (1) unaligned,		/* ON => fault under AST lock, benign */
  2    91 	  2 fault_under_volmap bit (1) unaligned,	/* ON => fault under volmap lock, benign */
  2    92 	  2 fault_under_pt bit (1) unaligned;		/* ON => fault inder PTL, NOT BENIGN */
  2    93 
  2    94 dcl	(
  2    95 	STATE_UNSEEN	init (0),
  2    96 	STATE_FREE	init (1),
  2    97 	STATE_IN_USE	init (2),
  2    98 	STATE_CONFLICT	init (3)
  2    99 	)		fixed bin int static options (constant);
  2   100 
  2   101 
  2   102 
  2   103 
  2   104 /*  END OF:	scavenger_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      486 
      487 
  3     1 /*  START OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3      dcl	   stock_segp	      ptr;
  3     4      dcl	   record_stockp	      ptr;
  3     5      dcl	   vtoce_stockp	      ptr;
  3     6      dcl	   stock_seg$	      ext;
  3     7 
  3     8      dcl	   n_in_record_stock      fixed bin;
  3     9      dcl	   n_volmap_pages	      fixed bin;
  3    10      dcl	   n_in_vtoce_stock	      fixed bin;
  3    11 
  3    12 
  3    13      dcl	   1 stock_seg	      aligned based (stock_segp),
  3    14 
  3    15 	     2 meters	      aligned like rsmeters,
  3    16 
  3    17 	     2 record_stock_entries fixed bin,		/* Number of entries in a record stock */
  3    18 	     2 vtoce_stock_entries fixed bin,		/* Number of entries in a VTOCE stock */
  3    19 	     2 record_stock_size  fixed bin,		/* Size of a record stock in words */
  3    20 	     2 vtoce_stock_size   fixed bin,		/* Size of a VTOCE stock in words */
  3    21 	     2 n_stock_entries    fixed bin,		/* Number of stocks of each type */
  3    22 	     2 record_stock_arrayp ptr,		/* Record stock region */
  3    23 	     2 vtoce_stock_arrayp ptr;		/* VTOCE stock region */
  3    24 
  3    25 
  3    26      dcl	   1 record_stock	      aligned based (record_stockp),
  3    27 
  3    28 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  3    29 
  3    30 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number of addresses in stock */
  3    31 	     2 n_volmap_pages     fixed bin (18) uns unal,/* Number of pages in Volume Map */
  3    32 
  3    33 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number addresses currently free */
  3    34 	     2 n_os_in_stock      fixed bin (18) uns unal,/* Number addresses currently out-of-service */
  3    35 
  3    36 	     2 low_threshold      fixed bin (18) uns unal,/* Low threshold for withdrawing from volmap */
  3    37 	     2 high_threshold     fixed bin (18) uns unal,/* High threshold for depositing to volmap */
  3    38 
  3    39 	     2 target	      fixed bin (18) uns unal,/* Target for stock */
  3    40 	     2 stock_offset	      bit (18) unal,	/* Offset of stock in this structure */
  3    41 
  3    42 	     2 n_words_in_stock   fixed bin (18) uns unal,/* Number of words = Number of entries / 2 */
  3    43 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  3    44 
  3    45 	     2 old_volmap_page    (3) aligned,		/* N_OLD_VOLMAP_PAGES (cif) */
  3    46 	       3 last	      fixed bin (18) uns unal,/* Roving pointer */
  3    47 	       3 pad	      bit (18) unal,
  3    48 
  3    49 	     2 volmap_page	      (n_volmap_pages refer (record_stock.n_volmap_pages)) aligned,
  3    50 	       3 n_free	      fixed bin (18) uns unal,/* Number free records in this volmap page */
  3    51 	       3 baseadd	      fixed bin (17) unal,	/* First record address described by this page */
  3    52 
  3    53 	     2 stock	      (n_in_record_stock refer (record_stock.n_in_stock)) bit (18) unal; /* Stock array of addresses */
  3    54 						/* bit 0 ON => out-of-service */
  3    55 
  3    56 
  3    57      dcl	   1 vtoce_stock	      aligned based (vtoce_stockp),
  3    58 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  3    59 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number indices in stock */
  3    60 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number indices currently free */
  3    61 	     2 target	      fixed bin (18) uns unal,/* Target when withdrawing/depositing */
  3    62 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  3    63 	     2 stock	      (n_in_vtoce_stock refer (vtoce_stock.n_in_stock)) fixed bin (17) unal; /* Stock array of VTOCE indices */
  3    64 
  3    65 
  3    66      dcl	   1 rsmeters	      aligned based,
  3    67 
  3    68 	     2 async_read_calls   fixed bin (35),	/* Number of asynchronous read attempts */
  3    69 	     2 async_page_reads   fixed bin (35),	/* Number of times page read was required */
  3    70 	     2 async_post_io_calls fixed bin (35),	/* Number of times read or write posted */
  3    71 	     2 deposit_calls      fixed bin (35),	/* Number of times deposit called */
  3    72 	     2 async_post_io_time fixed bin (71),	/* CPU time posting I/Os (interrupt side) */
  3    73 	     2 deposit_time	      fixed bin (71),	/* CPU time in deposit (call side) */
  3    74 	     2 low_thresh_detected fixed bin (35),	/* Number of times stock below low threshold */
  3    75 	     2 high_thresh_detected fixed bin (35),	/* Number of times stock above high threshold */
  3    76 	     2 low_thresh_fails   fixed bin (35),	/* Number of times no records in volmap */
  3    77 	     2 withdraw_stock_steps fixed bin (35),	/* Number steps thru stock in withdraw */
  3    78 	     2 withdraw_stock_losses fixed bin (35),	/* Number lockless losses */
  3    79 	     2 n_withdraw_attempt fixed bin (35),	/* Number attempts to withdraw a page */
  3    80 	     2 n_withdraw_range   fixed bin (35),	/* Number attempts to withdraw within range */
  3    81 	     2 n_pages_withdraw_stock fixed bin (35),	/* Number pages withdrawn from stock */
  3    82 	     2 n_pages_withdraw_async fixed bin (35),	/* Number pages withdrawn from volmap */
  3    83 	     2 n_v_withdraw_attempts fixed bin (35),	/* Number attempts to withdraw from volmap */
  3    84 	     2 withdraw_volmap_steps fixed bin (35),	/* Number steps thru volmap in withdraw */
  3    85 	     2 deposit_stock_steps fixed bin (35),	/* Number steps thru stock in deposit */
  3    86 	     2 deposit_stock_losses fixed bin (35),	/* Number lockless losses */
  3    87 	     2 n_deposit_attempt  fixed bin (35),	/* Number attempts to deposit a page */
  3    88 	     2 n_pages_deposit_stock fixed bin (35),	/* Number pages deposited to stock */
  3    89 	     2 n_pages_deposit_volmap fixed bin (35),	/* Number pages deposited to volmap */
  3    90 	     2 n_v_deposit_attempts fixed bin (35),	/* Number attempts to deposit to volmap */
  3    91 	     2 reset_os_calls     fixed bin (35),	/* Number calls to reset_os */
  3    92 	     2 reset_os_losses    fixed bin (35),	/* Number lockless losses */
  3    93 	     2 withdraw_calls     fixed bin (35),	/* Number calls to withdraw */
  3    94 	     2 withdraw_time      fixed bin (71),	/* CPU time in withdraw (page-fault) */
  3    95 	     2 pc_deposit_time    fixed bin (71),	/* CPU time in pc_deposit */
  3    96 	     2 pc_deposit_calls   fixed bin (35),	/* Number calls to pc_deposit */
  3    97 	     2 pc_deposit_pages   fixed bin (35),	/* Number pages deposited by pc_deposit */
  3    98 	     2 get_free_vtoce_calls fixed bin (35),	/* Number calls to get_free_vtoce */
  3    99 	     2 return_free_vtoce_call fixed bin (35),	/* Number calls to return_free_vtoce */
  3   100 	     2 deposit_vstock_calls fixed bin (35),	/* Number attempts to deposit to vtoce stock */
  3   101 	     2 deposit_vstock_fails fixed bin (35),	/* Number times deposit failed */
  3   102 	     2 withdraw_vstock_calls fixed bin (35),	/* Number attempts to withdraw from vtoce stock */
  3   103 	     2 withdraw_vstock_fails fixed bin (35),	/* Number times withdraw failed */
  3   104 	     2 deposit_vtoc_map fixed bin (35),		/* Number times vtoce deposited to map */
  3   105 	     2 withdraw_check_scav fixed bin (35),	/* Number times withdraw checked an address for scavenge */
  3   106 	     2 withdraw_conflict fixed bin (35),	/* Number times conflict found */
  3   107 	     2 pad (11)	      fixed bin (35);
  3   108 	
  3   109 
  3   110      dcl	   N_OLD_VOLMAP_PAGES     fixed bin init (3) int static options (constant);
  3   111      dcl	   DEFAULT_N_IN_RECORD_STOCK fixed bin init (104) int static options (constant);
  3   112      dcl	   DEFAULT_N_IN_VTOCE_STOCK fixed bin init (10) int static options (constant);
  3   113 
  3   114 
  3   115 /*  END OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      488 
      489 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      490 
      491 
      492 /* BEGIN MESSAGE DOCUMENTATION
      493*
      494*   Message:
      495*   pc_deposit: Address XXXXXX out of paging region on dskX_NN{s}.
      496*
      497*   S:     $crash
      498*
      499*   T:	$run
      500*
      501*   M:	An attempt was made to return disk address XXXXXX on device dskX_NN{s}
      502*   to the free pool. The address is not in the paging region.
      503*
      504*   A:	$recover
      505*   It may be necessary to run the physical volume salvager on the device.
      506*
      507*   Message:
      508*   pc_deposit: Invalid address XXXXXX on dskX_NN{s}.
      509*
      510*   S:     $crash
      511*
      512*   T:	$run
      513*
      514*   M:	In attempting to deposit address XXXXXX on device dskX_NN{s}, an invalid
      515*   volume map offset was computed. 
      516*
      517*   A:	$recover
      518*   It may be necessary to run the physical volume salvager on the device.
      519*
      520*   Message:
      521*   pc_deposit: Deposit in-use address XXXXXX on dskX_NN{s}.
      522*
      523*   S:     $beep
      524*
      525*   T:	$run
      526*
      527*   M:	An attempt was made to return address XXXXXX on device dskX_NN{s} to
      528*   the free record pool, but the address was already marked as free. This 
      529*   indicates damage to control structures on the device. This damage can
      530*   be corrected by a physical volume salvage.
      531*
      532*   A:     $inform
      533*
      534*   Message:
      535*   pc_deposit: Unrecoverable I/O error on Volmap page M of dskX_NN{s}. Addresses lost.
      536*
      537*   S:     $beep
      538*
      539*   T:	$run
      540*
      541*   M:	There was an unrecoverable I/O error on a page of the Volume Map,
      542*   which describes free records of the volume. All free records described
      543*   by that page have been lost.
      544*
      545*   A:     It may be possible to recover the lost addresses by a volume
      546*   salvage. If there is a hard device error, the volume salvage will
      547*   fail. In this case, it will be necessary to recover the volume onto
      548*   a good pack.
      549*
      550*   END MESSAGE DOCUMENTATION */
      551 
      552      end pc_deposit;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.3  pc_deposit.pl1                    >spec>install>1111>pc_deposit.pl1
484          1    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
486          2    02/27/84  1141.4  scavenger_data.incl.pl1           >ldd>include>scavenger_data.incl.pl1
488          3    10/25/82  1015.6  stock_seg.incl.pl1                >ldd>include>stock_seg.incl.pl1
490          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                                      based           bit(36)                  dcl 392 ref 409
ANNOUNCE                        000000 constant        fixed bin(17,0)          initial dcl 4-7 set ref 319*
A_record_block                  000626 automatic       structure                level 1 dcl 384 set ref 400 405*
Address                   0(01)        based           fixed bin(17,0)          array level 2 in structure "List" packed packed
                                                                                  unsigned unaligned dcl 80 in procedure
                                                                                  "pc_deposit" set ref 227
Address                   0(01)        based           fixed bin(17,0)          level 2 in structure "Single_address" packed packed
                                                                                  unsigned unaligned dcl 82 in procedure
                                                                                  "pc_deposit" ref 152
Address                   0(01)        based           fixed bin(17,0)          level 2 in structure "Devaddr" packed packed
                                                                                  unsigned unaligned dcl 262 in procedure
                                                                                  "FIND_VOLMAP_PAGE" ref 265
Ap                              000630 automatic       pointer                  dcl 385 set ref 400* 409
BEEP                            000012 constant        fixed bin(17,0)          initial dcl 4-7 set ref 344*
Bit                       0(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 304 set
                                                                                  ref 317 325*
CRASH                           000015 constant        fixed bin(17,0)          initial dcl 4-7 set ref 268* 280* 311*
Conflict                               parameter       bit(1)                   dcl 256 set ref 250 266* 284*
Devadd                                 parameter       bit(36)                  dcl 42 set ref 11 126
Devaddp                                parameter       pointer                  dcl 253 ref 250 265
Devaddr                                based           structure                level 1 dcl 262
First                                  parameter       fixed bin(17,0)          dcl 46 ref 172 176 187 206 217
Last                                   parameter       fixed bin(17,0)          dcl 47 ref 172 176 187 206 217 224
List                                   based           structure                array level 1 dcl 80 set ref 191 191
List_ptr                               parameter       pointer                  dcl 45 ref 172 191 191 227
NULL_SDW                        000000 constant        fixed bin(71,0)          initial dcl 75 set ref 461 461
Page_no                                parameter       fixed bin(17,0)          dcl 255 in procedure "FIND_VOLMAP_PAGE" set ref 250
                                                                                  284*
Page_no                                parameter       fixed bin(17,0)          dcl 382 in procedure "CHECK_ADDRESS_FOR_SCAVENGER"
                                                                                  ref 378 419 419
Pageno                                 parameter       fixed bin(17,0)          dcl 44 ref 11 133
Pageno_list                            based           fixed bin(17,0)          array dcl 81 ref 190
Pageno_list_ptr                        parameter       pointer                  dcl 48 ref 172 188 190
Pvtx                                   parameter       fixed bin(17,0)          dcl 41 ref 11 124 172 178
Q                                      based           bit(36)                  dcl 393 ref 409
Q_record_block                  000634 automatic       structure                level 1 dcl 388 set ref 401 404* 405
Qp                              000636 automatic       pointer                  dcl 389 set ref 401* 409
RECORDS_PER_WORD                002104 constant        fixed bin(17,0)          initial dcl 76 ref 310 315
Record_address                         parameter       fixed bin(17,0)          dcl 381 in procedure "CHECK_ADDRESS_FOR_SCAVENGER"
                                                                                  ref 378 397
Record_address                         parameter       fixed bin(17,0)          dcl 297 in procedure "DEPOSIT_TO_PAGE" set ref 294
                                                                                  310 311* 315 319*
STATE_CONFLICT                         constant        fixed bin(17,0)          initial dcl 2-94 ref 415 425 428
STATE_FREE                             constant        fixed bin(17,0)          initial dcl 2-94 ref 413 415 423
STATE_IN_USE                           constant        fixed bin(17,0)          initial dcl 2-94 ref 417
STATE_UNSEEN                           constant        fixed bin(17,0)          initial dcl 2-94 ref 413
Single_address                         based           structure                level 1 dcl 82
Single_addressp                 000112 automatic       pointer                  dcl 62 set ref 126* 135* 152
Vm_page                                based           structure                level 1 dcl 304
Volmap_pageno                          parameter       fixed bin(17,0)          dcl 254 set ref 250 276*
Vpage_no                               parameter       fixed bin(17,0)          dcl 298 ref 294 310 311 315 327 327
Vpage_ptr                              parameter       pointer                  dcl 299 ref 294 317 325
Vtocx                                  parameter       fixed bin(17,0)          dcl 43 ref 11 132 172 185
W                                      based           bit(36)                  dcl 394 ref 409
Word                                   based           structure                array level 2 dcl 304
Wp                              000640 automatic       pointer                  dcl 390 set ref 402* 409
addr                                                   builtin function         dcl 110 ref 124 124 126 178 178 191 191 361 397 400
                                                                                  401 448 448 448 448 461 461 461 461 475
address                         000600 automatic       fixed bin(17,0)          dcl 260 set ref 265* 268 268 268* 273 280* 284*
baseadd                  20            based           fixed bin(18,0)          level 2 in structure "pvte" packed packed unsigned
                                                                                  unaligned dcl 1-26 in procedure "pc_deposit" ref
                                                                                  268 268 397
baseadd                  11(18)        based           fixed bin(17,0)          array level 3 in structure "record_stock" packed
                                                                                  packed unaligned dcl 3-26 in procedure
                                                                                  "pc_deposit" ref 273 310 315
bit_no                          000610 automatic       fixed bin(17,0)          dcl 301 set ref 315* 317 325
check_scavenger                 000100 automatic       bit(1)                   dcl 52 set ref 284 358* 366*
cleanup                         000532 stack reference condition                dcl 105 ref 139 196
conflict                        000101 automatic       bit(1)                   dcl 53 in procedure "pc_deposit" set ref 135* 136
                                                                                  191* 192
conflict                        000632 automatic       bit(1)                   dcl 386 in procedure "CHECK_ADDRESS_FOR_SCAVENGER"
                                                                                  set ref 428* 430* 434
convert                                                builtin function         dcl 111 ref 268 268 280 280 311 311 319 319 344 344
devname                   3            based           char(4)                  level 2 dcl 1-26 set ref 268* 280* 311* 319* 344*
divide                                                 builtin function         dcl 112 ref 310
grabbed_vpage                   000102 automatic       fixed bin(17,0)          dcl 54 set ref 128* 150* 155* 181* 204 207 223* 231*
                                                                                  232* 340 340 343 344* 457 457* 459*
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  268* 280* 311* 319* 344*
listx                           000103 automatic       fixed bin(17,0)          dcl 55 set ref 187* 190 191 191 191 192* 217* 218
                                                                                  221 224*
listx1                          000104 automatic       fixed bin(17,0)          dcl 56 set ref 224* 225 227 228*
lock                      0(25)        based           bit(1)                   level 2 in structure "record_block" packed packed
                                                                                  unaligned dcl 2-72 in procedure "pc_deposit" set
                                                                                  ref 432*
lock                      0(25) 000626 automatic       bit(1)                   level 2 in structure "A_record_block" packed packed
                                                                                  unaligned dcl 384 in procedure
                                                                                  "CHECK_ADDRESS_FOR_SCAVENGER" set ref 406 408*
locked                          000633 automatic       bit(1)                   dcl 387 set ref 399* 403 409*
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1-26 ref 268 268
                                                                                  280 280 311 311 319 319 344 344
meters                                 based           structure                level 2 dcl 3-13
mod                                                    builtin function         dcl 113 ref 315
n_free                   11            based           fixed bin(18,0)          array level 3 packed packed unsigned unaligned
                                                                                  dcl 3-26 set ref 327* 327 340 343*
n_volmap_pages            1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 3-26
                                                                                  ref 272
nleft                     7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  326* 326
null                                                   builtin function         dcl 114 ref 188 360
p99                                    automatic       picture(2)               packed unaligned dcl 57 ref 268 268 280 280 311 311
                                                                                  319 319 344 344
page$grab_volmap_page_unwired   000012 constant        entry                    external dcl 93 ref 149 222
page$lock_volmap                000014 constant        entry                    external dcl 95 ref 446
page$unlock_volmap              000016 constant        entry                    external dcl 96 ref 463
page$write_volmap_page_unwired  000020 constant        entry                    external dcl 97 ref 154 231 457
page_fault_error                000540 stack reference condition                dcl 106 ref 143 157 200 239
pageno                          000105 automatic       fixed bin(17,0)          dcl 58 in procedure "pc_deposit" set ref 133* 135*
                                                                                  188* 190* 191*
pageno                    0(15)        based           fixed bin(8,0)           level 2 in structure "record_block" packed packed
                                                                                  unsigned unaligned dcl 2-72 in procedure
                                                                                  "pc_deposit" set ref 419 422*
pages                           000106 automatic       fixed bin(17,0)          dcl 59 set ref 122* 176* 477
pagex                           000100 automatic       fixed bin(17,0)          dcl 202 set ref 206* 207 207*
pc_deposit_calls         40            based           fixed bin(35,0)          level 3 dcl 3-13 set ref 476* 476
pc_deposit_pages         41            based           fixed bin(35,0)          level 3 dcl 3-13 set ref 477* 477
pc_deposit_time          36            based           fixed bin(71,0)          level 3 dcl 3-13 set ref 479* 479
pf_begin                        000107 automatic       fixed bin(35,0)          dcl 60 set ref 121* 175*
pf_end                          000110 automatic       fixed bin(35,0)          dcl 61 set ref 478*
pmut$swap_sdw                   000022 constant        entry                    external dcl 99 ref 448 461
ptr                                                    builtin function         dcl 115 ref 367
pvt$array                       000030 external static fixed bin(17,0)          dcl 1-18 set ref 124 178
pvt_array                              based           structure                array level 1 dcl 1-24 set ref 124 178
pvte                                   based           structure                level 1 dcl 1-26
pvtep                           000546 automatic       pointer                  dcl 1-22 set ref 124* 125 149* 154* 178* 179 222*
                                                                                  231* 268 268 268 268 268 268 268 268 280 280 280
                                                                                  280 280 311 311 311 311 311 319 319 319 319 319
                                                                                  321 321 326 326 339 339 344 344 344 344 344 363
                                                                                  363 367 397 446* 448 448 457* 463*
record_block                           based           structure                level 1 dcl 2-72 set ref 404
record_blockp                   000554 automatic       pointer                  dcl 2-10 set ref 397* 402 404 413 413 415 415 417
                                                                                  419 419 421 422 423 425 428 432
record_stock                           based           structure                level 1 dcl 3-26
record_stockp                   000560 automatic       pointer                  dcl 3-4 set ref 125* 179* 272 273 310 315 327 327
                                                                                  340 343
records                   3            based           structure                array level 2 dcl 2-64 set ref 397
rsmeters                               based           structure                level 1 dcl 3-66
sc_meters                              based           structure                level 1 dcl 2-30
scav_check_address        4(27)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 ref 363
scavenger_block                        based           structure                level 1 dcl 2-64
scavenger_block_rel      33(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-26 ref 363 367
scavenger_blockp                000552 automatic       pointer                  dcl 2-9 set ref 360* 367* 397
scavenger_data$                 000032 external static fixed bin(17,0)          dcl 2-4 set ref 361
scavenger_datap                 000550 automatic       pointer                  dcl 2-6 set ref 361* 367
stacq                                                  builtin function         dcl 116 ref 409
state                     0(23)        based           fixed bin(2,0)           level 2 packed packed unsigned unaligned dcl 2-72
                                                                                  set ref 413 413* 415 415* 417 423* 425* 428
stock_seg                              based           structure                level 1 dcl 3-13
stock_seg$                      000034 external static fixed bin(17,0)          dcl 3-6 set ref 475
stock_segp                      000556 automatic       pointer                  dcl 3-3 set ref 475* 476 476 477 477 479 479
sv_name                  15            based           char(2)                  level 2 dcl 1-26 set ref 268* 280* 311* 319* 344*
syserr                          000024 constant        entry                    external dcl 100 ref 268 280 311 319 344
this_vpage                      000114 automatic       fixed bin(17,0)          dcl 63 set ref 221* 222 223 225 227*
totrec                    7(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-26 ref 268
unspec                                                 builtin function         dcl 117 set ref 404* 404 405* 405
usage_values                    000026 constant        entry                    external dcl 101 ref 121 175 478
vcpu_begin                      000116 automatic       fixed bin(71,0)          dcl 64 set ref 121* 175* 479
vcpu_end                        000120 automatic       fixed bin(71,0)          dcl 65 set ref 478* 479
vol_trouble_count        33            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  321* 321 339* 339
volmap_abs_seg$                 000010 external static fixed bin(17,0)          dcl 89 set ref 448 448 461 461
volmap_locked                   000122 automatic       bit(1)                   packed unaligned dcl 66 set ref 127* 180* 447* 463
                                                                                  465*
volmap_page              11            based           structure                array level 2 dcl 3-26
volmap_seg_sdw           22            based           fixed bin(71,0)          level 2 dcl 1-26 set ref 448 448
volmap_stock_ptr         30            based           pointer                  level 2 packed packed unaligned dcl 1-26 ref 125 179
vpage_found                     000577 automatic       bit(1)                   packed unaligned dcl 259 in procedure
                                                                                  "FIND_VOLMAP_PAGE" set ref 264* 272 275* 280
vpage_found                     000123 automatic       bit(1)                   packed unaligned dcl 67 in procedure "pc_deposit"
                                                                                  set ref 215* 220* 236
vpage_list                      000124 automatic       fixed bin(17,0)          array dcl 68 set ref 191* 192* 207 207* 218 221 225
                                                                                  228*
vpage_no                        000524 automatic       fixed bin(17,0)          dcl 69 set ref 135* 149 150 152* 154
vpage_ptr                       000526 automatic       pointer                  dcl 70 set ref 149* 152* 222* 227*
vpagex                          000576 automatic       fixed bin(17,0)          dcl 258 set ref 272* 273 276*
vtoc_index                      000530 automatic       fixed bin(17,0)          dcl 71 set ref 132* 185* 419 419
vtocx                                  based           fixed bin(15,0)          level 2 packed packed unsigned unaligned dcl 2-72
                                                                                  set ref 419 421*
word_no                         000611 automatic       fixed bin(17,0)          dcl 302 set ref 310* 311 311 311 317 325

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_N_IN_RECORD_STOCK              internal static fixed bin(17,0)          initial dcl 3-111
DEFAULT_N_IN_VTOCE_STOCK               internal static fixed bin(17,0)          initial dcl 3-112
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
N_OLD_VOLMAP_PAGES                     internal static fixed bin(17,0)          initial dcl 3-110
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 1-113
n_in_record_stock                      automatic       fixed bin(17,0)          dcl 3-8
n_in_vtoce_stock                       automatic       fixed bin(17,0)          dcl 3-10
n_volmap_pages                         automatic       fixed bin(17,0)          dcl 3-9
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 1-19
pvt_arrayp                             automatic       pointer                  dcl 1-21
sc_metersp                             automatic       pointer                  dcl 2-7
sc_n_processes                         automatic       fixed bin(17,0)          dcl 2-13
sc_process_table                       based           structure                level 1 dcl 2-52
sc_process_tablep                      automatic       pointer                  dcl 2-8
scavenger_data                         based           structure                level 1 dcl 2-18
scavenger_data_pages                   based           structure                level 1 dcl 2-79
scavenger_n_ovfl                       automatic       fixed bin(17,0)          dcl 2-15
scavenger_n_records                    automatic       fixed bin(17,0)          dcl 2-14
scavenger_options                      based           structure                level 1 dcl 2-84
scavenger_optionsp                     automatic       pointer                  dcl 2-11
vtoce_stock                            based           structure                level 1 dcl 3-57
vtoce_stockp                           automatic       pointer                  dcl 3-5

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_ADDRESS_FOR_SCAVENGER     001542 constant        entry                    internal dcl 378 ref 284
CHECK_FOR_SCAVENGE              001514 constant        entry                    internal dcl 355 ref 130 183
DEPOSIT_TO_PAGE                 001140 constant        entry                    internal dcl 294 ref 152 227
FIND_VOLMAP_PAGE                000703 constant        entry                    internal dcl 250 ref 135 191
IO_ERROR                        001406 constant        entry                    internal dcl 336 ref 145 210
LOCK_SETUP                      001705 constant        entry                    internal dcl 443 ref 141 198
METER                           002015 constant        entry                    internal dcl 472 ref 162 243
RETURN                          000327 constant        label                    dcl 157 set ref 136 146
UNLOCK_RESET                    001737 constant        entry                    internal dcl 454 ref 139 160 196 241
VPAGE_RETRY                     000563 constant        label                    dcl 215 ref 212 236
pc_deposit                      000140 constant        entry                    external dcl 11
pc_deposit$deposit_list         000344 constant        entry                    external dcl 172

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2344        2402    2106        2354
Length      2670    2106        36         252     236           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pc_deposit                          610 external procedure  is an external procedure.  
on unit on line 139                  64 on unit               
on unit on line 143                  64 on unit               
on unit on line 196                  64 on unit               
on unit on line 200                  66 on unit               
FIND_VOLMAP_PAGE                        internal procedure  shares stack frame of external procedure pc_deposit.  
DEPOSIT_TO_PAGE                         internal procedure  shares stack frame of external procedure pc_deposit.  
IO_ERROR                            120 internal procedure  is called by several nonquick procedures.  
CHECK_FOR_SCAVENGE                      internal procedure  shares stack frame of external procedure pc_deposit.  
CHECK_ADDRESS_FOR_SCAVENGER             internal procedure  shares stack frame of external procedure pc_deposit.  
LOCK_SETUP                              internal procedure  shares stack frame of external procedure pc_deposit.  
UNLOCK_RESET                         74 internal procedure  is called by several nonquick procedures.  
METER                                   internal procedure  shares stack frame of external procedure pc_deposit.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
on unit on line 200      000100 pagex                       on unit on line 200
pc_deposit               000100 check_scavenger             pc_deposit
                         000101 conflict                    pc_deposit
                         000102 grabbed_vpage               pc_deposit
                         000103 listx                       pc_deposit
                         000104 listx1                      pc_deposit
                         000105 pageno                      pc_deposit
                         000106 pages                       pc_deposit
                         000107 pf_begin                    pc_deposit
                         000110 pf_end                      pc_deposit
                         000112 Single_addressp             pc_deposit
                         000114 this_vpage                  pc_deposit
                         000116 vcpu_begin                  pc_deposit
                         000120 vcpu_end                    pc_deposit
                         000122 volmap_locked               pc_deposit
                         000123 vpage_found                 pc_deposit
                         000124 vpage_list                  pc_deposit
                         000524 vpage_no                    pc_deposit
                         000526 vpage_ptr                   pc_deposit
                         000530 vtoc_index                  pc_deposit
                         000546 pvtep                       pc_deposit
                         000550 scavenger_datap             pc_deposit
                         000552 scavenger_blockp            pc_deposit
                         000554 record_blockp               pc_deposit
                         000556 stock_segp                  pc_deposit
                         000560 record_stockp               pc_deposit
                         000576 vpagex                      FIND_VOLMAP_PAGE
                         000577 vpage_found                 FIND_VOLMAP_PAGE
                         000600 address                     FIND_VOLMAP_PAGE
                         000610 bit_no                      DEPOSIT_TO_PAGE
                         000611 word_no                     DEPOSIT_TO_PAGE
                         000626 A_record_block              CHECK_ADDRESS_FOR_SCAVENGER
                         000630 Ap                          CHECK_ADDRESS_FOR_SCAVENGER
                         000632 conflict                    CHECK_ADDRESS_FOR_SCAVENGER
                         000633 locked                      CHECK_ADDRESS_FOR_SCAVENGER
                         000634 Q_record_block              CHECK_ADDRESS_FOR_SCAVENGER
                         000636 Qp                          CHECK_ADDRESS_FOR_SCAVENGER
                         000640 Wp                          CHECK_ADDRESS_FOR_SCAVENGER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
mdfx1               enable_op           ext_entry           int_entry           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
page$grab_volmap_page_unwired page$lock_volmap              page$unlock_volmap
page$write_volmap_page_unwired                              pmut$swap_sdw                 syserr
usage_values

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pvt$array                     scavenger_data$               stock_seg$                    volmap_abs_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000133       121 000150       122 000160       124 000162       125 000171       126 000173       127 000175
    128 000176       130 000200       132 000201       133 000203       135 000206       136 000210       139 000213
    141 000235       143 000236       145 000252       146 000257       149 000262       150 000300       152 000303
    154 000311       155 000325       157 000327       160 000330       162 000334       164 000335       172 000336
    175 000354       176 000365       178 000372       179 000400       180 000402       181 000403       183 000405
    185 000406       187 000410       188 000421       190 000431       191 000436       192 000457       194 000465
    196 000467       198 000511       200 000512       204 000526       206 000531       207 000541       209 000551
    210 000553       212 000560       215 000563       217 000564       218 000575       220 000577       221 000601
    222 000602       223 000617       224 000622       225 000633       227 000636       228 000650       230 000653
    231 000655       232 000666       234 000670       236 000672       239 000674       241 000675       243 000701
    245 000702       250 000703       264 000705       265 000706       266 000713       268 000714       272 001010
    273 001021       275 001027       276 001031       278 001034       280 001037       284 001122       287 001137
    294 001140       310 001142       311 001154       315 001247       317 001263       319 001275       321 001356
    323 001364       325 001365       326 001370       327 001376       330 001404       336 001405       339 001413
    340 001422       343 001430       344 001434       349 001513       355 001514       358 001515       360 001516
    361 001520       363 001523       366 001533       367 001535       370 001541       378 001542       397 001544
    399 001555       400 001556       401 001560       402 001562       403 001563       404 001566       405 001570
    406 001571       408 001574       409 001576       411 001603       413 001604       415 001616       417 001625
    419 001627       421 001645       422 001651       423 001655       424 001661       425 001662       428 001666
    430 001676       432 001677       434 001701       443 001705       446 001706       447 001715       448 001717
    450 001735       454 001736       457 001744       459 001760       461 001763       463 002000       465 002012
    467 002014       472 002015       475 002016       476 002021       477 002025       478 002031       479 002041
    481 002046


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
