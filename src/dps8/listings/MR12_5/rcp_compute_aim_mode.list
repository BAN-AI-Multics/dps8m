	COMPILATION LISTING OF SEGMENT rcp_compute_aim_mode
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0951.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(87-07-06,Rauschelbach), approve(87-08-07,MCR7748),
       12*     audit(87-11-11,Farley), install(87-11-30,MR12.2-1004):
       13*     Changed to return error_table_$ai_restricted when access is denied for
       14*     all cases, not just one. Removed signal to vfile_error condition as it
       15*     was erroneously left from debugging.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 
       19 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       20 rcp_compute_aim_mode:
       21      procedure (a_req_info_ptr, a_res_info_ptr, a_aim_mode, a_error_code);
       22 
       23 /*            This internal subroutine implements mandatory access
       24*   *	    control (AIM) for RCP.
       25*   *            Created 841112 by Maria M. Pozzo
       26*   *
       27**/
       28 
       29 /*                 ARGUMENT DATA                             */
       30 
       31 dcl	a_req_info_ptr	   ptr;			/* (I) Points to requestor info */
       32 dcl	a_res_info_ptr	   ptr;			/* (I) Points to resoruce info */
       33 dcl	a_aim_mode	   bit (3);		/* (O) Raw AIM mode */
       34 dcl	a_error_code	   fixed bin (35);		/* (O) Error code */
       35 
       36 /*                 AUTOMATIC DATA                            */
       37 
       38 dcl	aim_mode		   bit (3);		/* Local AIM mode */
       39 dcl	temp_range	   (2) bit (72) aligned;
       40 dcl	based_bits	   bit (bl * 9) aligned based (bp);
       41 dcl	bl		   fixed bin (21);
       42 dcl	error_code	   fixed bin (35);		/* Local error code */
       43 dcl	bp		   ptr;
       44 dcl	(addr, null, unspec)   builtin;
       45 
       46 /*                 EXTERNAL ENTRIES                          */
       47 
       48 dcl	aim_check_$range_in_range
       49 			   entry ((2) bit (72) aligned, (2) bit (72) aligned) returns (bit (1) aligned);
       50 dcl	aim_check_$greater_or_equal
       51 			   entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       52 dcl	aim_check_$equal	   entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       53 dcl	hcs_$get_authorization entry (bit (72) aligned, bit (72) aligned);
       54 dcl	read_allowed_	   entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       55 dcl	write_allowed_	   entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
       56 
       57 dcl	error_table_$ai_invalid_range
       58 			   ext fixed bin (35) static;
       59 dcl	error_table_$ai_out_range
       60 			   ext fixed bin (35) static;
       61 dcl	error_table_$ai_restricted
       62 			   ext fixed bin (35) static;
       63 dcl	error_table_$action_not_performed
       64 			   ext fixed bin (35) static;
       65 
       66 /* Copy arguments */
       67 
       68 	requestor_info_ptr = a_req_info_ptr;
       69 	resource_info_ptr = a_res_info_ptr;
       70 	record_ptr = resource_info.registry_record_ptr;
       71 	user_auth = requestor_info.current_authorization;
       72 
       73 /* Initialize local variables */
       74 
       75 	aim_mode = REW_ACCESS;			/* Assume REW initially */
       76 	error_code, bl = 0;
       77 	bp = null ();
       78 
       79 /* If the resource is free, get the potential aim range found in the */
       80 /* registry record; otherwise get the real aim range found in the */
       81 /* registry record. */
       82 
       83 	if registry_record.free then
       84 	     call chase (registry_record.potential_aim_range_desc, bp, bl, error_code);
       85 	else call chase (registry_record.aim_range_desc, bp, bl, error_code);
       86 	if error_code ^= 0 then
       87 	     goto MAIN_RETURN;
       88 	if bl > 0 then addr (temp_range) -> based_bits = based_bits;
       89 	else unspec (temp_range) = ""b;		/* no range, set to lowest possible */
       90 
       91 /* If the low end of the AIM range is higher than us, then R access (and */
       92 /* thus all access) is denied since we can't read up */
       93 
       94 	if ^read_allowed_ (user_auth, temp_range (1)) then do;
       95 	     aim_mode = N_ACCESS;
       96 	     error_code = error_table_$ai_restricted;
       97 	     goto MAIN_RETURN;
       98 	end;
       99 
      100 /* If the current authorization is not at the low end of the AIM range */
      101 /* then E access is denied since allowing it anywhere else in the range */
      102 /* could be a potential covert channel.  E access allows writing of */
      103 /* protected attributes. */
      104 
      105 	if ^aim_check_$equal (user_auth, temp_range (1)) then
      106 	     aim_mode = aim_mode & RW_ACCESS;
      107 
      108 /* If the high end of the AIM range is lower or disjoint then W access */
      109 /* is denied since we can't write down.  We can still have R access and */
      110 /* that is preserved, however, we must also deny E access since that */
      111 /* allows writing of protected attributes and we have just been denied */
      112 /* write access. */
      113 
      114 	if ^write_allowed_ (user_auth, temp_range (2)) then
      115 	     aim_mode = aim_mode & R_ACCESS;
      116 
      117 MAIN_RETURN:
      118 	if error_code ^= 0 then
      119 	     aim_mode = N_ACCESS;
      120 	a_aim_mode = aim_mode;
      121 	a_error_code = error_code;
      122 	return;
      123 
      124 
      125 /* --------------------------------------------- */
      126 permissible_aim:
      127      entry (max_range, aim_range, code);
      128 
      129 /* This entry takes a pair of AIM access classes and determines
      130*   whether the user should be allowed to place these
      131*   AIM range on some RCP resource. */
      132 
      133 dcl	(aim_range, max_range) (2) bit (72) aligned parameter;
      134 dcl	user_auth		   bit (72) aligned;
      135 dcl	code		   fixed bin (35);
      136 dcl	rcp_priv		   bit (1) aligned;
      137 
      138 
      139 	call hcs_$get_authorization (user_auth, (""b));
      140 	rcp_priv = addr (user_auth) -> aim_template.privileges.rcp;
      141 
      142 /* First and simplest check-- the high bounds must be >= the low bounds. */
      143 
      144 	if ^aim_check_$greater_or_equal (max_range (2), max_range (1)) then do;
      145 	     code = error_table_$ai_invalid_range;
      146 	     goto permissible_aim_return;
      147 	end;
      148 
      149 	if ^aim_check_$greater_or_equal (aim_range (2), aim_range (1)) then do;
      150 	     code = error_table_$ai_invalid_range;
      151 	     goto permissible_aim_return;
      152 	end;
      153 
      154 /* Now check that the desired range "fits within" the max bounds. */
      155 
      156 	if (^aim_check_$range_in_range (aim_range, max_range)) then do;
      157 	     code = error_table_$ai_out_range;
      158 	     goto permissible_aim_return;
      159 	end;
      160 
      161 /* Now we know that the ranges are self-consistent. */
      162 
      163 	code = 0;
      164 
      165 /* Now check to see whether this user has the ability to set these ranges. */
      166 
      167 	if rcp_priv then
      168 	     goto permissible_aim_return;
      169 
      170 /* Make sure a user at a high authorization is not making a resource "suddenly
      171*   appear" to someone at a lower authorization. */
      172 
      173 	if ^write_allowed_ (user_auth, aim_range (1)) then do;
      174 	     code = error_table_$ai_restricted;
      175 	     goto permissible_aim_return;
      176 	end;
      177 
      178 /* We don't check upper bound.  Like creating directories, you can register a
      179*   resource with an upper bound higher than you-- just don't expect to do
      180*   anything else with it afterwards! */
      181 
      182 permissible_aim_return:
      183 	return;
      184 
      185 /* ------------------------ */
      186 chase:
      187      proc (descriptor, bp, bl, a_error_code);
      188 
      189 dcl	(
      190 	descriptor	   fixed bin (35),
      191 	a_error_code	   fixed bin (35),
      192 	bp		   pointer,
      193 	bl		   fixed bin (21)
      194 	)		   parameter;
      195 
      196 dcl	1 rs		   like rs_info aligned automatic;
      197 dcl	local_code	   fixed bin (35);
      198 
      199 	a_error_code = 0;
      200 	if descriptor = 0 then do;
      201 	     bp = addr (bp);			/* gotta point somewhere */
      202 	     bl = 0;
      203 	     return;
      204 	end;
      205 
      206 	unspec (rs) = ""b;
      207 	rs.version = rs_info_version_2;
      208 	rs.locate_sw = "1"b;
      209 	rs.descriptor = descriptor;
      210 	local_code = 0;
      211 
      212 	call iox_$control (resource_info.registry_switch_ptr, "record_status", addr (rs), local_code);
      213 	if local_code ^= 0 then do;
      214 	     a_error_code = error_table_$action_not_performed;
      215 	     return;
      216 	end;
      217 	bl = rs.record_length;
      218 	bp = rs.record_ptr;
      219 	return;
      220      end chase;					/* ------------------------------- */
      221 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      222 
      223 
  2     1 /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  2     2 
  2     3 /* Created 740723 by PG */
  2     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  2     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  2     6 
  2     7 /* This structure defines the components of both an access
  2     8*   class and an access authorization as interpreted by the
  2     9*   Access Isolation Mechanism. */
  2    10 
  2    11 
  2    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  2    13        2 categories bit (36),				/* access categories */
  2    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  2    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  2    16         (3 ipc,					/* interprocess communication privilege */
  2    17          3 dir,					/* directory privilege */
  2    18          3 seg,					/* segment privilege */
  2    19          3 soos,					/* security out-of-service privilege */
  2    20          3 ring1,					/* ring 1 access privilege */
  2    21          3 rcp,					/* RCP resource access privilege */
  2    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  2    23          3 pad bit (11);
  2    24 
  2    25 
  2    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      224 
      225 
  3     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  3     2 
  3     3 /* Written 05/04/78 by C. D. Tavares */
  3     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  3     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  3     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  3     7 
  3     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  3     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  3    10      iox_$close entry (pointer, fixed bin (35)),
  3    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  3    12      iox_$delete_record entry (pointer, fixed bin (35)),
  3    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  3    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  3    15      iox_$err_not_attached entry options (variable),
  3    16      iox_$err_not_closed entry options (variable),
  3    17      iox_$err_no_operation entry options (variable),
  3    18      iox_$err_not_open entry options (variable),
  3    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  3    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  3    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  3    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  3    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  3    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  3    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  3    28      iox_$propagate entry (pointer),
  3    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  3    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  3    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  3    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  3    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  3    40 
  3    41 dcl (iox_$user_output,
  3    42      iox_$user_input,
  3    43      iox_$user_io,
  3    44      iox_$error_output) external static pointer;
  3    45 
  3    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      226 
      227 
  4     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  4     2 /*       Begin include file rcp_requestor_info.incl.pl1
  4     3* *       
  4     4* *       This include file gives information about the subject,
  4     5* *       or requestor of the RCP operation.  In one case, absentee
  4     6* *       requests, the user is the Initializer, so this piece of
  4     7* *       information tells us about the real requestor of the RCP
  4     8* *       operation.
  4     9**/
  4    10 
  4    11 dcl requestor_info_ptr ptr;
  4    12 
  4    13 dcl 1 requestor_info aligned based (requestor_info_ptr),
  4    14     2 user_id char (32),
  4    15     2 current_authorization bit (72) aligned,
  4    16     2 validation_level fixed bin (3);
  4    17 
  4    18 /*  end include file .. rcp_requestor_info.incl.pl1 */
      228 
      229 
  5     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  5     2 /*       Begin include file rcp_resource_info.incl.pl1
  5     3*   *
  5     4*   *       This include file gives information about the object,
  5     5*   *       or resource for the RCP operation.  If RM is enabled this
  5     6*   *       information will provide the registry name and switch pointer
  5     7*   *       for the registry so additional resource information can be
  5     8*   *       determined.  If RM is disabled, this information will include
  5     9*   *       the resource name and/or type.
  5    10**/
  5    11 
  5    12 dcl	resource_info_ptr	   ptr;
  5    13 
  5    14 dcl	1 resource_info	   based (resource_info_ptr),
  5    15 	  2 registry_dir	   aligned char (64),	/*  Could be a different if it is reconstruct operation */
  5    16 	  2 registry_switch_ptr
  5    17 			   ptr,			/*  Switch to the registry */
  5    18 	  2 registry_record_ptr
  5    19 			   ptr,			/*  Pointer to the registry record */
  5    20 	  2 resource_type	   char (32),		/*  Resource type */
  5    21 	  2 resource_name	   char (32);		/*  Resource name */
  5    22 
  5    23 /*  end include file .. rcp_resource_info.incl.pl1 */
      230 
      231 
  6     1 /* --------------- BEGIN include file rcp_registry.incl.pl1 --------------- */
  6     2 
  6     3 /* Written 05/04/78 by C. D. Tavares */
  6     4 
  6     5 dcl 1 registry_record aligned based (record_ptr),
  6     6     2 dynamic_info aligned,
  6     7       3 attributes (2) bit (72) aligned,
  6     8       3 (location_desc,
  6     9          comment_desc,
  6    10          pad (2)) fixed bin (35) aligned,
  6    11     2 acquisition_info aligned,
  6    12       3 (owner_desc,
  6    13          acs_path_desc,
  6    14          aim_range_desc) fixed bin (35) aligned,
  6    15       3 flags unaligned,
  6    16         4 (usage_lock,
  6    17 	 release_lock,
  6    18 	 awaiting_clear,
  6    19 	 user_alloc,
  6    20 	 system,
  6    21 	 free) bit (1) unaligned,
  6    22         4 pad bit (12) unaligned,
  6    23       3 reserver_chain bit (18) unaligned,
  6    24       3 pad (2) fixed bin (35) aligned,
  6    25     2 registration_info aligned,
  6    26       3 uid bit (36) aligned,
  6    27       3 (potential_attributes_desc,
  6    28          potential_aim_range_desc,
  6    29          charge_type_desc,
  6    30          pad (2)) fixed bin (35) aligned,
  6    31       3 name unaligned,
  6    32         4 n fixed bin (8) unaligned,
  6    33         4 string char (rr_strl refer (registry_record.name.n)) unaligned;
  6    34 
  6    35 dcl 1 registry_header aligned based (header_ptr),
  6    36     2 rtde_size fixed bin (18),
  6    37     2 rtde_copy (RTDE_SIZE refer (registry_header.rtde_size)) bit (36) aligned,
  6    38     2 other aligned,
  6    39       3 last_transaction_time fixed bin (71),
  6    40       3 pad (18) bit (36) aligned;
  6    41 
  6    42 dcl RTDE_SIZE fixed bin (18);
  6    43 
  7     1 /* --------------- BEGIN include file rtdt.incl.pl1 --------------- */
  7     2 
  7     3 dcl 1 rtdt aligned based (rtdtp),			/* resource type description table */
  8     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  8     2 
  8     3 /* the "author" items must always be the first ones in the table. The
  8     4*   module which moves the converted table to the System Control process
  8     5*   fills in these data items and assumes them to be at the head of the segment
  8     6*   regardless of the specific table's actual declaration. The variables
  8     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  8     8*    respectively. For tables installed in multiple processes, these
  8     9*    are to be used to lock out multiple installations. */
  8    10 
  8    11 /*  Lock should be used as a modification lock. Since, in general,
  8    12*    entries may not be moved in system tables, even by installations,
  8    13*    it is sufficient for only installers and programs that change threads
  8    14*    to set or respect the lock. Simply updating data in an entry
  8    15*    requires no such protection.
  8    16*
  8    17*    Last_install_time is used by readers of system tables to detect
  8    18*    installations or other serious modifications. By checking it before
  8    19*    and after copying a block of data, they can be protected against
  8    20*    modifications.
  8    21*
  8    22*    Modules that set the lock should save proc_group_id, and then
  8    23*    put their group id there for the time they hold the lock.
  8    24*    if they do not actually install the, they should restore the group id.
  8    25**/
  8    26 
  8    27     2 author aligned,				/* validation data about table's author */
  8    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  8    29       3 lock bit (36),				/* installation lock */
  8    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  8    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  8    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  8    33       3 pad bit (33) unaligned,
  8    34       3 last_install_time fixed bin (71),
  8    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  8    36       3 w_dir char (64),				/* author's working directory */
  8    37 
  8    38 /* END INCLUDE FILE author.incl.pl1 */
  7     4 
  7     5     2 version fixed bin,				/* version number */
  7     6     2 installed_under_resource_mgt bit (1) aligned,	/* resource mgt. was ON when this was installed */
  7     7     2 charge_type_table_ptr offset,			/* points to charge_type_table */
  7     8     2 first_resource offset,				/* chain for RTDE's */
  7     9     2 rtdt_area area (RTDT_area_len);			/* all following items allocated here */
  7    10 
  7    11 dcl 1 charge_type_table aligned based (cttp),		/* describes charges for resource types */
  7    12     2 n_charge_types fixed bin,			/* number of distinct charge types */
  7    13     2 charge_types (N_CHARGE_TYPES refer (charge_type_table.n_charge_types)) aligned char (32),
  7    14     2 flagword fixed bin (35) aligned;			/* this word simply help us set bitcount properly */
  7    15 
  7    16 dcl 1 rtde aligned based (rtdep),			/* describes one resource type */
  7    17     2 fixed_info aligned,
  7    18       3 next_resource offset,				/* chains to next type, or nullo */
  7    19       3 name char (32),				/* name of resource type, e.g. "tape_drive" */
  7    20       3 syn_to char (32),				/* if is_synonym this is master syn */
  7    21       3 precanon_proc char (64),			/* name of routine to standardize resource name */
  7    22       3 pad_1 (16) fixed bin (35),
  7    23       3 flags unaligned,
  7    24         4 (valid,					/* resource type hasn't been deleted */
  7    25      is_volume,					/* specifies volume or device type */
  7    26      manual_clear,					/* volumes of this type to be "degaussed" between owners */
  7    27      addition_pending,				/* bookkeeping bit for upd_rtdt_ */
  7    28      deletion_pending,
  7    29      is_synonym) bit (1) unaligned,			/* ditto */
  7    30         4 pad bit (12) unaligned,
  7    31       3 (process_limit,				/* how many can you assign at one time */
  7    32      default_time,					/* implicit reservations are for how many minutes */
  7    33      max_time,					/* how long can you reserve it for */
  7    34      advance_notice_time,				/* warn operator to prepare mount ahead of time */
  7    35      pad2,
  7    36      n_exclusion_specs,				/* number of distinct "name=" fields in attributes */
  7    37      n_mates,					/* number of mating devs/vols for this vol/dev */
  7    38      n_subtypes,					/* number of registration subtypes */
  7    39      n_defined_attributes) fixed bin (17) unaligned,	/* number of defined attributes */
  7    40       3 pad_2 (8) fixed bin (35),
  7    41       3 attributes_valid bit (72) aligned,		/* "1"b if corresp. attribute undeleted */
  7    42       3 attributes_to_match bit (72) aligned,		/* potential mate must possess these attributes */
  7    43       3 attribute_names (72) char (12) aligned,		/* all possible attributes for this resource */
  7    44       3 exclusion_specs (36) bit (72) aligned,		/* each masks all attrributes of the form "key=val" */
  7    45       3 pad_3 (32) fixed bin (35),
  7    46       3 registration_defaults aligned,			/* applied at reg. time if none given */
  7    47         4 default_flags aligned,
  7    48 	5 (potential_attributes_given,		/* "1"b = there are default potential_attributes */
  7    49      attributes_given,				/* and similarly, etc. */
  7    50      aim_range_given,
  7    51      charge_type_given) bit (1) unaligned,
  7    52 	5 pad bit (31) unaligned,
  7    53         4 potential_attributes bit (72) aligned,		/* for registration, if given */
  7    54         4 attributes bit (72) aligned,			/* for registration and also for runtime "I-don't-care" */
  7    55         4 aim_range (2) bit (72) aligned,		/* and similarly, etc. */
  7    56         4 charge_type fixed bin,
  7    57         4 pad_4 (8) fixed bin (35) aligned,
  7    58     2 mates (N_MATES refer (rtde.n_mates)) char (32) aligned,
  7    59 						/* the volume type that mounts on this device, or vice versa */
  7    60     2 subtypes (N_SUBTYPES refer (rtde.n_subtypes)) aligned, /* named registration default groups */
  7    61       3 subtype_name char (32),			/* name of the group */
  7    62       3 subtype_defaults like rtde.registration_defaults aligned;
  7    63 
  7    64 dcl  RTDT_version_3 fixed bin static options (constant) initial (3),
  7    65      RTDT_version_2 fixed bin static options (constant) initial (2),
  7    66 						/* same format, but without precanon_proc */
  7    67     (N_MATES, N_SUBTYPES, N_CHARGE_TYPES) fixed bin,
  7    68      RTDT_area_len fixed bin (18);
  7    69 
  7    70 dcl (rtdep, rtdtp, cttp) pointer;
  7    71 
  7    72 /* ---------------- END include file rtdt.incl.pl1 ---------------- */
  6    44 
  6    45 
  6    46 dcl (record_ptr, header_ptr) pointer,
  6    47      rr_strl fixed bin;
  6    48 
  6    49 /* ---------------- END include file rcp_registry.incl.pl1 ---------------- */
      232 
      233 
  9     1 /* include file for info structure used with record_status control order
  9     2*   created by M. Asherman 1/6/76 */
  9     3 /* modified 6/15/77 to support stationary type records */
  9     4 
  9     5      dcl	   rs_info_ptr	      ptr;
  9     6      dcl	   1 rs_info	      based (rs_info_ptr) aligned,
  9     7 	     2 version	      fixed,		/* must be set to 1 or 2 (Input) */
  9     8 	     2 flags	      aligned,
  9     9 	       3 lock_sw	      bit (1) unal,		/* Input -- if ="1"b  try to lock record */
  9    10 	       3 unlock_sw	      bit (1) unal,		/* Input -- if ="1"b try to unlock record */
  9    11 	       3 create_sw	      bit (1) unal,		/* Input--if set creat new record */
  9    12 	       3 locate_sw	      bit (1) unal,		/* Input--if set causes current rec to be
  9    13*						   located outside the index by descrip, or created without key */
  9    14 	       3 inc_ref_count    bit (1) unal,		/* Input--bump reference count of record, if stationary */
  9    15 	       3 dec_ref_count    bit (1) unal,		/* Input--decrement ref count if this flag set and record stationary */
  9    16 	       3 locate_pos_sw    bit (1) unal,		/* Input--if set the record_length is taken
  9    17*						   as an input argument specifying the absolute logical record positioni	  to which both the current and next positions will be set */
  9    18 	       3 mbz1	      bit (29) unal,	/* must be set to "0"b, reserved for future use */
  9    19 	     2 record_length      fixed (21),		/* length in bytes, Input if create_sw set */
  9    20 	     2 max_rec_len	      fixed (21),		/* max length of contained record
  9    21*						   Input if create_sw is set--overrides min_block_size in effect */
  9    22 	     2 record_ptr	      ptr,		/* points to first byte of record--will be word aligned */
  9    23 	     2 descriptor	      fixed (35),		/* Input if locate_sw set and create_sw="0"b */
  9    24 	     2 ref_count	      fixed (34),		/* Output--should match number of keys on this record-- = -1 if non-stationary record */
  9    25 	     2 time_last_modified fixed (71),		/* Output */
  9    26 	     2 modifier	      fixed (35),		/* Output--also Input when locking */
  9    27 	     2 block_ptr	      ptr unal,		/* Output */
  9    28 	     2 last_image_modifier
  9    29 			      fixed (35),
  9    30 	     2 mbz2	      fixed;
  9    31 
  9    32      dcl	   1 rs_desc	      based (addr (rs_info.descriptor)),
  9    33 						/* record block descriptor structure */
  9    34 	     2 comp_num	      fixed (17) unal,	/* msf component number */
  9    35 	     2 offset	      bit (18) unal;	/* word offset of record block */
  9    36 
  9    37      dcl	   1 seq_desc	      based (addr (rs_info.descriptor)),
  9    38 						/* for sequential files */
  9    39 	     2 bitno	      bit (6) unal,
  9    40 	     2 comp_num	      fixed (11) unal,	/* msf component number */
  9    41 	     2 wordno	      bit (18) unal;	/* word offset */
  9    42 
  9    43      dcl	   rs_info_version_1      static internal fixed init (1);
  9    44      dcl	   rs_info_version_2      static internal fixed init (2);
  9    45 
      234 
      235      end rcp_compute_aim_mode;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0805.5  rcp_compute_aim_mode.pl1          >spec>install>1111>rcp_compute_aim_mode.pl1
222          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
224          2    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
226          3    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
228          4    03/15/85  0953.1  rcp_requestor_info.incl.pl1       >ldd>include>rcp_requestor_info.incl.pl1
230          5    03/15/85  0953.1  rcp_resource_info.incl.pl1        >ldd>include>rcp_resource_info.incl.pl1
232          6    11/20/79  2015.5  rcp_registry.incl.pl1             >ldd>include>rcp_registry.incl.pl1
6-44         7    11/20/79  2015.6  rtdt.incl.pl1                     >ldd>include>rtdt.incl.pl1
7-4          8    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
234          9    07/19/79  1547.0  rs_info.incl.pl1                  >ldd>include>rs_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
N_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 95 117
REW_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 1-11 ref 75
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 1-11 ref 105
R_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 114
a_aim_mode                             parameter       bit(3)                   packed unaligned dcl 33 set ref 20 120*
a_error_code                           parameter       fixed bin(35,0)          dcl 189 in procedure "chase" set ref 186 199* 214*
a_error_code                           parameter       fixed bin(35,0)          dcl 34 in procedure "rcp_compute_aim_mode" set ref
                                                                                  20 121*
a_req_info_ptr                         parameter       pointer                  dcl 31 ref 20 68
a_res_info_ptr                         parameter       pointer                  dcl 32 ref 20 69
acquisition_info         10            based           structure                level 2 dcl 6-5
addr                                                   builtin function         dcl 44 ref 88 140 201 212 212
aim_check_$equal                000014 constant        entry                    external dcl 52 ref 105
aim_check_$greater_or_equal     000012 constant        entry                    external dcl 50 ref 144 149
aim_check_$range_in_range       000010 constant        entry                    external dcl 48 ref 156
aim_mode                        000100 automatic       bit(3)                   packed unaligned dcl 38 set ref 75* 95* 105* 105
                                                                                  114* 114 117* 120
aim_range                              parameter       bit(72)                  array dcl 133 set ref 126 149* 149* 156* 173*
aim_range_desc           12            based           fixed bin(35,0)          level 3 dcl 6-5 set ref 85*
aim_template                           based           structure                level 1 dcl 2-12
based_bits                             based           bit                      dcl 40 set ref 88* 88
bl                              000105 automatic       fixed bin(21,0)          dcl 41 in procedure "rcp_compute_aim_mode" set ref
                                                                                  76* 83* 85* 88 88 88
bl                                     parameter       fixed bin(21,0)          dcl 189 in procedure "chase" set ref 186 202* 217*
bp                                     parameter       pointer                  dcl 189 in procedure "chase" set ref 186 201* 201
                                                                                  218*
bp                              000110 automatic       pointer                  dcl 43 in procedure "rcp_compute_aim_mode" set ref
                                                                                  77* 83* 85* 88
code                                   parameter       fixed bin(35,0)          dcl 135 set ref 126 145* 150* 157* 163* 174*
current_authorization
                         10            based           bit(72)                  level 2 dcl 4-13 ref 71
descriptor                6     000132 automatic       fixed bin(35,0)          level 2 in structure "rs" dcl 196 in procedure
                                                                                  "chase" set ref 209*
descriptor                             parameter       fixed bin(35,0)          dcl 189 in procedure "chase" ref 186 200 209
error_code                      000106 automatic       fixed bin(35,0)          dcl 42 set ref 76* 83* 85* 86 96* 117 121
error_table_$action_not_performed
                                000032 external static fixed bin(35,0)          dcl 63 ref 214
error_table_$ai_invalid_range   000024 external static fixed bin(35,0)          dcl 57 ref 145 150
error_table_$ai_out_range       000026 external static fixed bin(35,0)          dcl 59 ref 157
error_table_$ai_restricted      000030 external static fixed bin(35,0)          dcl 61 ref 96 174
fixed_info                             based           structure                level 2 dcl 7-16
flags                     1     000132 automatic       structure                level 2 in structure "rs" dcl 196 in procedure
                                                                                  "chase"
flags                    13            based           structure                level 3 in structure "registry_record" packed packed
                                                                                  unaligned dcl 6-5 in procedure
                                                                                  "rcp_compute_aim_mode"
free                     13(05)        based           bit(1)                   level 4 packed packed unaligned dcl 6-5 ref 83
hcs_$get_authorization          000016 constant        entry                    external dcl 53 ref 139
iox_$control                    000034 constant        entry                    external dcl 3-8 ref 212
local_code                      000150 automatic       fixed bin(35,0)          dcl 197 set ref 210* 212* 213
locate_sw                 1(03) 000132 automatic       bit(1)                   level 3 packed packed unaligned dcl 196 set ref 208*
max_range                              parameter       bit(72)                  array dcl 133 set ref 126 144* 144* 156*
null                                                   builtin function         dcl 44 ref 77
potential_aim_range_desc
                         20            based           fixed bin(35,0)          level 3 dcl 6-5 set ref 83*
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 2-12
rcp                       1(23)        based           bit(1)                   level 3 packed packed unaligned dcl 2-12 ref 140
rcp_priv                        000114 automatic       bit(1)                   dcl 136 set ref 140* 167
read_allowed_                   000020 constant        entry                    external dcl 54 ref 94
record_length             2     000132 automatic       fixed bin(21,0)          level 2 dcl 196 set ref 217
record_ptr                4     000132 automatic       pointer                  level 2 in structure "rs" dcl 196 in procedure
                                                                                  "chase" set ref 218
record_ptr                      000122 automatic       pointer                  dcl 6-46 in procedure "rcp_compute_aim_mode" set ref
                                                                                  70* 83 83 85
registration_defaults
                        602            based           structure                level 3 dcl 7-16
registration_info        16            based           structure                level 2 dcl 6-5
registry_record                        based           structure                level 1 dcl 6-5
registry_record_ptr      22            based           pointer                  level 2 dcl 5-14 ref 70
registry_switch_ptr      20            based           pointer                  level 2 dcl 5-14 set ref 212*
requestor_info                         based           structure                level 1 dcl 4-13
requestor_info_ptr              000116 automatic       pointer                  dcl 4-11 set ref 68* 71
resource_info                          based           structure                level 1 unaligned dcl 5-14
resource_info_ptr               000120 automatic       pointer                  dcl 5-12 set ref 69* 70 212
rs                              000132 automatic       structure                level 1 dcl 196 set ref 206* 212 212
rs_info                                based           structure                level 1 dcl 9-6
rs_info_version_2                      constant        fixed bin(17,0)          initial dcl 9-44 ref 207
rtde                                   based           structure                level 1 dcl 7-16
temp_range                      000101 automatic       bit(72)                  array dcl 39 set ref 88 89* 94* 105* 114*
unspec                                                 builtin function         dcl 44 set ref 89* 206*
user_auth                       000112 automatic       bit(72)                  dcl 134 set ref 71* 94* 105* 114* 139* 140 173*
version                         000132 automatic       fixed bin(17,0)          level 2 dcl 196 set ref 207*
write_allowed_                  000022 constant        entry                    external dcl 55 ref 114 173

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_CHARGE_TYPES                         automatic       fixed bin(17,0)          dcl 7-64
N_MATES                                automatic       fixed bin(17,0)          dcl 7-64
N_SUBTYPES                             automatic       fixed bin(17,0)          dcl 7-64
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RTDE_SIZE                              automatic       fixed bin(18,0)          dcl 6-42
RTDT_area_len                          automatic       fixed bin(18,0)          dcl 7-64
RTDT_version_2                         internal static fixed bin(17,0)          initial dcl 7-64
RTDT_version_3                         internal static fixed bin(17,0)          initial dcl 7-64
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
charge_type_table                      based           structure                level 1 dcl 7-11
cttp                                   automatic       pointer                  dcl 7-70
header_ptr                             automatic       pointer                  dcl 6-46
iox_$attach_loud                000000 constant        entry                    external dcl 3-8
iox_$attach_name                000000 constant        entry                    external dcl 3-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 3-8
iox_$close                      000000 constant        entry                    external dcl 3-8
iox_$close_file                 000000 constant        entry                    external dcl 3-8
iox_$delete_record              000000 constant        entry                    external dcl 3-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 3-8
iox_$detach                     000000 constant        entry                    external dcl 3-8
iox_$detach_iocb                000000 constant        entry                    external dcl 3-8
iox_$err_no_operation           000000 constant        entry                    external dcl 3-8
iox_$err_not_attached           000000 constant        entry                    external dcl 3-8
iox_$err_not_closed             000000 constant        entry                    external dcl 3-8
iox_$err_not_open               000000 constant        entry                    external dcl 3-8
iox_$error_output                      external static pointer                  dcl 3-41
iox_$find_iocb                  000000 constant        entry                    external dcl 3-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 3-8
iox_$get_chars                  000000 constant        entry                    external dcl 3-8
iox_$get_line                   000000 constant        entry                    external dcl 3-8
iox_$look_iocb                  000000 constant        entry                    external dcl 3-8
iox_$modes                      000000 constant        entry                    external dcl 3-8
iox_$move_attach                000000 constant        entry                    external dcl 3-8
iox_$open                       000000 constant        entry                    external dcl 3-8
iox_$open_file                  000000 constant        entry                    external dcl 3-8
iox_$position                   000000 constant        entry                    external dcl 3-8
iox_$propagate                  000000 constant        entry                    external dcl 3-8
iox_$put_chars                  000000 constant        entry                    external dcl 3-8
iox_$read_key                   000000 constant        entry                    external dcl 3-8
iox_$read_length                000000 constant        entry                    external dcl 3-8
iox_$read_record                000000 constant        entry                    external dcl 3-8
iox_$rewrite_record             000000 constant        entry                    external dcl 3-8
iox_$seek_key                   000000 constant        entry                    external dcl 3-8
iox_$user_input                        external static pointer                  dcl 3-41
iox_$user_io                           external static pointer                  dcl 3-41
iox_$user_output                       external static pointer                  dcl 3-41
iox_$write_record               000000 constant        entry                    external dcl 3-8
registry_header                        based           structure                level 1 dcl 6-35
rr_strl                                automatic       fixed bin(17,0)          dcl 6-46
rs_desc                                based           structure                level 1 packed packed unaligned dcl 9-32
rs_info_ptr                            automatic       pointer                  dcl 9-5
rs_info_version_1                      internal static fixed bin(17,0)          initial dcl 9-43
rtdep                                  automatic       pointer                  dcl 7-70
rtdt                                   based           structure                level 1 dcl 7-3
rtdtp                                  automatic       pointer                  dcl 7-70
seq_desc                               based           structure                level 1 packed packed unaligned dcl 9-37

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000212 constant        label                    dcl 117 ref 86 97
chase                           000402 constant        entry                    internal dcl 186 ref 83 85
permissible_aim                 000230 constant        entry                    external dcl 126
permissible_aim_return          000401 constant        label                    dcl 182 ref 146 151 158 167 175
rcp_compute_aim_mode            000027 constant        entry                    external dcl 20

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       664         722     475         674
Length      1276     475        36         340     167           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_compute_aim_mode                144 external procedure  is an external procedure.  
chase                                   internal procedure  shares stack frame of external procedure rcp_compute_aim_mode.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_compute_aim_mode     000100 aim_mode                    rcp_compute_aim_mode
                         000101 temp_range                  rcp_compute_aim_mode
                         000105 bl                          rcp_compute_aim_mode
                         000106 error_code                  rcp_compute_aim_mode
                         000110 bp                          rcp_compute_aim_mode
                         000112 user_auth                   rcp_compute_aim_mode
                         000114 rcp_priv                    rcp_compute_aim_mode
                         000116 requestor_info_ptr          rcp_compute_aim_mode
                         000120 resource_info_ptr           rcp_compute_aim_mode
                         000122 record_ptr                  rcp_compute_aim_mode
                         000132 rs                          chase
                         000150 local_code                  chase

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$equal              aim_check_$greater_or_equal   aim_check_$range_in_range     hcs_$get_authorization
iox_$control                  read_allowed_                 write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$ai_invalid_range error_table_$ai_out_range
error_table_$ai_restricted




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000022        68 000034        69 000040        70 000043        71 000045        75 000050        76 000052
     77 000054        83 000056        85 000076        86 000112        88 000114        89 000124        94 000127
     95 000145        96 000146        97 000151       105 000152       114 000172       117 000212       120 000215
    121 000222       122 000223       126 000224       139 000235       140 000250       144 000254       145 000274
    146 000300       149 000301       150 000321       151 000325       156 000326       157 000345       158 000351
    163 000352       167 000354       173 000356       174 000374       175 000400       182 000401       186 000402
    199 000404       200 000405       201 000407       202 000411       203 000412       206 000413       207 000416
    208 000420       209 000422       210 000424       212 000425       213 000460       214 000462       215 000466
    217 000467       218 000472       219 000474


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
