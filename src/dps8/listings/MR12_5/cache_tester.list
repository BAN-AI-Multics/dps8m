	COMPILATION LISTING OF SEGMENT cache_tester
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1001.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       19*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       20*     Correct error message documentation.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* format: style4 */
       25 cache_tester: procedure (mcp);
       26 
       27 /* cache_tester - module to test cpu cache memory.
       28*   This module is called from hardware_fault after a cache_store or cache_dir parity has been detected.
       29*   A  test  of  cache  memory  will be performed before cache is turned back on. If errors are found in
       30*   cache that part of cache memory (csh1 or csh2) is left in disabled state. A  diagnostic  message  is
       31*   output  determining  the cache board and chip in error. If a cache parity cannot be generated with a
       32*   data pattern test of cache, the data structure pds$cpar_info is looked at to determine  if  the  fim
       33*   captured  the active data from memory and cache when the cache parity occurred. If this is true and
       34*   if the contents of pds$cpar_mem_data and pds$cpar_err_data only differ by one bit, this  information
       35*   is  used  to  output  a  diagnostic  which gives the bad board and chip and states that error is non
       36*   repeatable.
       37*
       38*   Originally coded by J. A. Bush 1/15/80
       39*   Modified 8/80 by J. A. Bush for the DPS8/70M CPU (8k cache)
       40*   Modified September 1981 by J. Bongiovanni for set_procs_required
       41*   Modified March 1982 by C. Hornig for new pc_abs.
       42*   Modified 03/10/83 by GA Texada to announce transient parity error.
       43*   Modified 03/25/83 by J. A. Bush for 16/32K cache
       44*   Modified and reorganized Jul 1984 by R. A. Fawcett to:
       45*     - Prevent OOSB in cache_priv.
       46*     - Report the first three errors accumulated by cache_priv.
       47*     - Always display the fim diagnose data if valid.
       48*     - Report parity only problems.
       49*     - Always report the state of cache on or off
       50*     - Set the cache correctly before returning by calling pmut.
       51**/
       52 
       53 /* external entries */
       54 
       55 dcl  pc_abs$remove_core_mod entry (fixed bin (16), fixed bin (16), fixed bin (26), fixed bin (35));
       56 dcl  cache_priv$csh1 entry (ptr, fixed bin, ptr, fixed bin (35));
       57 dcl  cache_priv$csh2 entry (ptr, fixed bin, ptr, fixed bin (35));
       58 dcl  syserr entry options (variable);
       59 dcl  syserr$error_code entry options (variable);
       60 dcl  privileged_mode_ut$swap_sdw entry (ptr, ptr);
       61 dcl  privileged_mode_ut$clear_cache entry;
       62 dcl  set_procs_required entry (bit (8) aligned, fixed bin (35));
       63 dcl  freecore entry (fixed bin);
       64 dcl  sdw_util_$construct entry (ptr, ptr);
       65 dcl  max_buf fixed bin;
       66 						/* External static */
       67 
       68 dcl  fim_abs_seg$ ext;
       69 dcl  pds$cpar_err_data bit (72) aligned ext;
       70 dcl  pds$cpar_mem_data bit (72) aligned ext;
       71 dcl  pds$cpar_info bit (36) aligned ext;
       72 dcl  prds$cache_luf_reg bit (36) aligned ext;
       73 
       74 /* builtins */
       75 
       76 dcl  (addr, addrel, binary, bool, divide, mod, string, substr) builtin;
       77 
       78 /* Automatic */
       79 
       80 dcl  (i, j, fwp, lwp, buf_size, fim_err_bit, buf_wds, pclv, clv, ccol, cache_size, cache_size_index) fixed bin;
       81 dcl  absaddr fixed bin (26);
       82 dcl  code fixed bin (35);
       83 dcl  (cache_error, test_called, fim_static_agree, diagnostic_displayed, fim_mult, csh1_off, csh2_off, csh_mem) bit (1) aligned;
       84 dcl  fimxord bit (72) aligned;
       85 dcl  (segptr, cptr, cpip) ptr;
       86 dcl  cpu fixed bin (3);
       87 dcl  cpu_tag char (1);
       88 dcl  cpu_mask bit (8) aligned;
       89 
       90 
       91 /* structures and based variables */
       92 
       93 dcl  1 cfim_info aligned based (cptr),			/* cache parity info from fim */
       94        (2 diagnose bit (1),				/* = "1"b if diagnostic info available */
       95        2 pad1 bit (7),
       96        2 csh1 bit (1),				/* state of "csh1" programable switch at TOF */
       97        2 csh2 bit (1),				/* state of "csh2" programable switch at TOF */
       98        2 level fixed bin (2) unsigned,			/* cache level  that has parity */
       99        2 absaddr bit (24)) unaligned;			/* abs address in mem of cache parity */
      100 
      101 dcl  1 cpriv_info aligned based (cpip),			/* structure returned from cache_priv */
      102        2 err_data (3),				/* 3 possible error disagnostics */
      103          3 cache_data bit (72),			/* data in error from cache */
      104          3 ex_or_data bit (72),			/* exclusive or of cache and mem data */
      105          3 fault_reg bit (72),			/* storage for fault reg at time of error */
      106 
      107          3 cache_addr bit (36),			/* cache address in error */
      108          3 ind_reg bit (36);				/* storage for indicator reg */
      109 
      110 
      111 dcl  tsdw fixed bin (71);
      112 dcl  1 sdwi aligned like sdw_info;
      113 dcl  c_data (0:buf_wds - 1) bit (36) based (segptr) aligned;
      114 
      115 /* constants */
      116 
      117 dcl  CPU_TAGS char (8) int static options (constant) init ("ABCDEFGH");
      118 dcl  csize (0:5) fixed bin static options (constant) init (0, 2, 8, 8, 16, 32);
      119 dcl  lv_ex (0:5) fixed bin static options (constant) init (0, 26, 24, 24, 23, 22);
      120 dcl  fim_col_ex (0:5) fixed bin static options (constant) init (0, 15, 13, 13, 12, 11);
      121 dcl  l68_cpar_chip char (12) static options (constant) init ("FEDCBAPQRSTU");
      122 dcl  cpar_wwb char (6) static options (constant) init ("345678");
      123 dcl  dps8_chip (0:11, 0:3) char (3) int static options (constant) init (
      124 	"36X", "45X", "55X", "65X",			/* Bit 0, levels 0 - 3 */
      125 	"33W", "42W", "51W", "60W",			/* Bit 1, levels 0 - 3 */
      126 	"36V", "45V", "55V", "65V",			/* Bit 2, levels 0 - 3 */
      127 	"31U", "40U", "49U", "56U",			/* Bit 3, levels 0 - 3 */
      128 	"36T", "45T", "55T", "65T",			/* Bit 4, levels 0 - 3 */
      129 	"36S", "45S", "55S", "65S",			/* Bit 5, levels 0 - 3 */
      130 	"32F", "41F", "50F", "59F",			/* Bit 36, levels 0 - 3 */
      131 	"32E", "41E", "50E", "59E",			/* Bit 37, levels 0 - 3 */
      132 	"32D", "41D", "50D", "59D",			/* Bit 38, levels 0 - 3 */
      133 	"32C", "41C", "50C", "59C",			/* Bit 39, levels 0 - 3 */
      134 	"32B", "41B", "50B", "59B",			/* Bit 40, levels 0 - 3 */
      135 	"32A", "41A", "50A", "59A");			/* Bit 41, levels 0 - 3 */
      136 dcl  vs_sc_chip (0:11, 0:3) char (3) int static options (constant) init (
      137 	"35S", "56Q", "39J", "55C",			/* Bit 0, levels 0 - 3 */
      138 	"55S", "16N", "59J", "35C",			/* Bit 1, levels 0 - 3 */
      139 	"36Q", "40P", "29G", "15C",			/* Bit 2, levels 0 - 3 */
      140 	"45S", "66Q", "49J", "45C",			/* Bit 3, levels 0 - 3 */
      141 	"65S", "26N", "19G", "25C",			/* Bit 4, levels 0 - 3 */
      142 	"46Q", "50L", "39G", "13A",			/* Bit 5, levels 0 - 3 */
      143 	"43W", "10L", "62E", "23A",			/* Bit 36, levels 0 - 3 */
      144 	"53U", "30L", "42E", "43A",			/* Bit 37, levels 0 - 3 */
      145 	"73U", "19J", "22E", "63A",			/* Bit 38, levels 0 - 3 */
      146 	"43U", "20L", "52E", "33A",			/* Bit 39, levels 0 - 3 */
      147 	"63U", "40L", "32E", "53A",			/* Bit 40, levels 0 - 3 */
      148 	"83U", "29J", "12E", "73A");			/* Bit 41, levels 0 - 3 */
      149 dcl  d_pattern (4) bit (36) static options (constant) init ("777777777777"b3, "0"b, "252525252525"b3, "525252525252"b3);
      150 
      151 	scup = addr (mc.scu);			/* get our cpu number from SCU data */
      152 	cpu = binary (scu.cpu_no, 3);
      153 	cpu_tag = substr (CPU_TAGS, cpu + 1, 1);	/* save cpu tag for messages */
      154 	cpu_mask = "0"b;
      155 	substr (cpu_mask, cpu + 1, 1) = "1"b;		/* set the bitstring for set_procs_required */
      156 	cache_size_index = scs$processor_data (cpu).cache_size; /* get cache index */
      157 	cache_size = csize (cache_size_index);		/*  set cache size in 1024 word blocks */
      158 	buf_size = divide (cache_size, 2, 17, 0);	/* only testing half of cache at a time */
      159 	buf_wds = buf_size * 1024;			/* set up number of words */
      160 	cptr = addr (pds$cpar_info);			/* get ptr to cfim_info */
      161 	fim_static_agree, diagnostic_displayed = "0"b;	/* initialize display flags */
      162 	csh1_off, csh2_off = "0"b;			/* initialize cache disable flags */
      163 	test_called, cache_error = "0"b;		/* initialize test_flags */
      164 	call display_fimerror;			/* print the reason we were called */
      165 
      166 
      167 /* first a contiguous wired buffer that is modulo our cache size */
      168 	max_buf = 2 * buf_size;
      169 	call pc_abs$remove_core_mod ((max_buf), (cache_size), absaddr, code);
      170 	if code ^= 0 then do;			/* couln't get wired buffer */
      171 	     call syserr (ANNOUNCE, "cache_tester: Unable to allocate wired buffer");
      172 	     call enable_cache;			/* go reenable cache mode reg */
      173 	     return;
      174 	end;
      175 
      176 /* now set up sdw for fim_abs_seg and swap it for original */
      177 
      178 	segptr = addr (fim_abs_seg$);			/* get ptr to fim_abs_seg */
      179 
      180 	unspec (sdwi) = ""b;
      181 	sdwi.access.read, sdwi.access.write = "1"b;
      182 	sdwi.flags.cache = "1"b;
      183 	sdwi.address = absaddr;
      184 	sdwi.size = 1024 * max_buf;
      185 	call sdw_util_$construct (addr (tsdw), addr (sdwi));
      186 	call privileged_mode_ut$swap_sdw (segptr, addr (tsdw));
      187 						/* swap the sdw */
      188 
      189 /* set ptr to our wired down info structure */
      190 
      191 	cpip = addrel (segptr, buf_wds);		/* info struct at end of buffer */
      192 	unspec (cpriv_info) = ""b;			/* clear it out -- cache_priv uses sxl stores */
      193 
      194 /* now set up each of 4 data patterns in our wired buffer until we get a cache error */
      195 
      196 
      197 	call set_procs_required (cpu_mask, code);	/* run on CPU in error */
      198 	if code ^= 0 then do;
      199 	     call syserr$error_code (ANNOUNCE, code, "cache_tester: Unable to set CPU required to ^a cache is off",
      200 		substr (CPU_TAGS, cpu + 1, 1));
      201 	     goto return_buffer;
      202 	end;
      203 
      204 	cache_error = "0"b;				/* reset terminate condition */
      205 	do i = 1 to 4 while (^cache_error);
      206 	     do j = 0 to buf_wds - 1;			/* fill up cache buffer */
      207 		c_data (j) = d_pattern (i);
      208 	     end;
      209 	     call test_cache;
      210 	end;
      211 	if ^cache_error then do;
      212 						/* if there has not been an error try relative address pattern */
      213 	     do i = 0 to buf_wds - 1;
      214 		c_data (i) = unspec (i);
      215 	     end;
      216 	     call test_cache;
      217 	end;
      218 	call enable_cache;				/* go reenable cache mode reg */
      219 
      220 
      221 /* now reset sdw for fim_abs_seg and free up wired cache buffer core */
      222 
      223 return_buffer:
      224 	tsdw = 0;
      225 	call privileged_mode_ut$swap_sdw (segptr, addr (tsdw));
      226 						/* swap the sdw */
      227 	fwp = divide (absaddr, 1024, 17, 0);		/* get mod 1024 core slot */
      228 	lwp = fwp + max_buf - 1;			/* get last page address */
      229 	do i = fwp to lwp;				/* go through each core map entry */
      230 	     call freecore (i);			/* and give page back to paging pool */
      231 	end;
      232 
      233 	return;
      234 
      235 
      236 /* display_fimerror - internal procedure to display cache error data captured in fim */
      237 
      238 display_fimerror: proc;
      239 
      240 	if cfim_info.diagnose then do;		/* if a valid data capture exits */
      241 	     fimxord = bool (pds$cpar_err_data, pds$cpar_mem_data, "0110"b); /* XOR data captured */
      242 	     call find_err_bit (fimxord, fim_err_bit, fim_mult); /* get bit in error */
      243 	     if fim_err_bit = -1 then fim_static_agree = "1"b; /* couldn't find an error parity only ?? 			*/
      244 
      245 	     call syserr (ANNOUNCE, "cache_tester: cache parity error detected on CPU ^a",
      246 		cpu_tag);
      247 	     
      248 	     if fim_err_bit = -1 then
      249 		call syserr (ANNOUNCE, "The cache data is equal to the memory data. Possible parity generation problem for level ^d",cfim_info.level);
      250 	     else if ^fim_mult then			/* if not multiple bit failure */
      251 		call get_bcx ((cfim_info.level), fim_err_bit);
      252 						/* go display board and chip */
      253 	     else do;				/* multiple bit failure go display multtiple  message */
      254 		ccol = bin (substr (cfim_info.absaddr, fim_col_ex (cache_size_index)));
      255 		ccol = divide (ccol, 4, 17, 0);
      256 		call mult_mess ((cfim_info.level), ccol, pds$cpar_err_data, pds$cpar_mem_data);
      257 						/* display multiple bit message */
      258 	     end;
      259 	end;
      260 	else fim_static_agree = "1"b;			/* not valid data captured, set flag */
      261      end display_fimerror;
      262 
      263 /* enable_cache - internal procedure to set up cache mode reg constant in prds */
      264 
      265 enable_cache: proc;
      266 
      267 dcl  1 c_mode_reg aligned,				/* program settable bits in cache_mode reg */
      268        (2 pad1 bit (18),
      269        2 csh1 bit (1),				/* lower half of cache mem enabled */
      270        2 csh2 bit (1),				/* upper half of cache mem enabled */
      271        2 opnd_on bit (1),				/* operands enabled in cache */
      272        2 inst_on bit (1),				/* instructions enabled in cache */
      273        2 csh_dump bit (1),				/* on if dumping cache */
      274        2 pad2 bit (11),
      275        2 luf_timer bit (2)) unaligned;			/* lockup fault timer */
      276 dcl  other_state bit (1);
      277 	string (c_mode_reg) = "0"b;			/* initialize template first */
      278 	c_mode_reg.opnd_on = "1"b;			/* set operand encachability enable */
      279 	c_mode_reg.inst_on = "1"b;			/* set instruction encachability enable */
      280 	c_mode_reg.luf_timer = "11"b;			/* set LUF timer to max value */
      281 	if ^csh1_off & cfim_info.csh1 then		/* if csh1 is not to be turned off */
      282 	     c_mode_reg.csh1 = "1"b;			/* enable it */
      283 	if ^csh2_off & cfim_info.csh2 then		/* if csh2 is not to be turned off */
      284 	     c_mode_reg.csh2 = "1"b;			/* enable it */
      285 	cpu_mask = "0"b;
      286 	substr (cpu_mask, cpu + 1, 1) = "1"b;
      287 	call set_procs_required (cpu_mask, code);	/* Make sure we run on the right CPU */
      288 	if code ^= 0 then do;
      289 	     call syserr$error_code (BEEP, code, "cache_tester: Unable to run on CPU ^a to ^[disable^;enable^] cache (cache is off)",
      290 		cpu_tag, (^(c_mode_reg.csh1 | c_mode_reg.csh2) | csh1_off | csh2_off));
      291 	     return;
      292 	end;
      293 
      294 	prds$cache_luf_reg = prds$cache_luf_reg | string (c_mode_reg);
      295 						/* set in value */
      296 	call set_procs_required ("0"b, code);		/* reset proc required */
      297 	pds$cpar_info = "0"b;			/* zero out info from fim */
      298 	if ^cache_error then
      299 	     call syserr (BEEP,
      300 		"cache_tester: ^[Error not reproducible in^;Could not test^] cache memory for CPU ^a^/^-^4xCache will remain as Lower ^[on^;off^] Upper ^[on^;off^]",
      301 		test_called, cpu_tag, c_mode_reg.csh1, c_mode_reg.csh2);
      302 
      303 	else if ^c_mode_reg.csh1 & ^c_mode_reg.csh2 then	/* if no cache enabled */
      304 	     call syserr (BEEP, "cache_tester: Entire cache memory for CPU ^a has been disabled", cpu_tag);
      305 	else if csh1_off | csh2_off then do;		/* if either half to be turned off */
      306 	     if csh1_off then do;
      307 		csh_mem = "1"b;			/* turn csh1 off */
      308 		other_state = c_mode_reg.csh2;
      309 	     end;
      310 	     else do;
      311 		csh_mem = "0"b;
      312 		other_state = c_mode_reg.csh1;
      313 	     end;
      314 	     call syserr (BEEP, "cache_tester: ^[Lower^;Upper^] cache memory (csh^[1^;2^]) for CPU ^a has been turned off^/^-^4x^[Upper^;Lower^] cache was ^[on^;off^] and has not been changed",
      315 		csh_mem, csh_mem, cpu_tag, csh_mem, other_state);
      316 	end;
      317 	call privileged_mode_ut$clear_cache;		/* set the cache correctly */
      318      end enable_cache;
      319 
      320 /* find_err_bit - internal procedure to find single bit in error given exclusive or input data */
      321 
      322 find_err_bit: proc (xord, err_bit, multiple);
      323 
      324 dcl  xord bit (72) aligned;				/* exclusive or input data */
      325 dcl  (err_bit, i, j) fixed bin;
      326 dcl  multiple bit (1) aligned;
      327 
      328 	multiple = "0"b;				/* initialize multiple failure flag */
      329 	j = 0;					/* initialize error bit count	*/
      330 	do i = 0 to 71;				/* go through each bit */
      331 	     if i = 0 | i = 36 then			/* if first bit of each word */
      332 		if substr (xord, i + 1, 36) = "0"b then do; /* skip entire word if 0 */
      333 		     i = i + 35;
      334 		     go to nxt_i;
      335 		end;
      336 	     if substr (xord, i + 1, 1) ^= "0"b then do;	/* found bit in error */
      337 		err_bit = i;			/* copy bit number */
      338 		j = j + 1;			/* increment error counter */
      339 	     end;
      340 nxt_i:
      341 	end;
      342 	if j > 1 then				/* if multiple bit failure, */
      343 	     multiple = "1"b;			/* set multiple flag */
      344 	else if j = 0 then err_bit = -1;		/* tell caller we couldn't find a bit in error	*/
      345 
      346      end find_err_bit;
      347 
      348 
      349 /* get_bcx - internal procedure to display board and chip diagnostic */
      350 
      351 get_bcx: proc (level, err_bit);
      352 
      353 dcl  (level, err_bit, bdx, cpx, i) fixed bin;
      354 dcl  odd_wd bit (1) aligned;
      355 
      356 	odd_wd = "0"b;
      357 	if err_bit > 35 then do;			/* if bit in second word of pair  */
      358 	     odd_wd = "1"b;				/* set indicator and subtract off */
      359 	     i = err_bit - 36;			/*  36 bits to get relative bit # */
      360 	end;
      361 	else i = err_bit;
      362 	bdx = divide (i, 6, 17, 0);			/* determine board index */
      363 	cpx = mod (i, 6);				/* and chip index */
      364 	if odd_wd then				/* if this was the odd word... */
      365 	     cpx = cpx + 6;				/* set index for second 6 chars */
      366 
      367 /* now display board and chip in error */
      368 
      369 	if cache_size_index = 1 then			/* if 2k cache ... */
      370 	     call syserr (ANNOUNCE, "^-at:^3xboard AB1^a, chip ^o^a", substr (cpar_wwb, bdx + 1, 1), level,
      371 		substr (l68_cpar_chip, cpx + 1, 1));
      372 	else if cache_size_index = 2 then		/* if old style DPS8.. */
      373 	     call syserr (ANNOUNCE, "^-at:^3xboard CD^d, chip ^a",
      374 		bdx + 1, dps8_chip (cpx, level));
      375 	else call syserr (ANNOUNCE, "^-at:^3xboard CD^d, chip ^a", /* VS&SC cache */
      376 		bdx + 1, vs_sc_chip (cpx, level));
      377 
      378      end get_bcx;
      379 
      380 
      381 /* mult_mess - internal procedure to display cache parity multiple bit failures */
      382 
      383 mult_mess: proc (lv, col, dwas, dsb);
      384 
      385 dcl  (lv, col) fixed bin;
      386 dcl  (dwas, dsb) bit (72) aligned;
      387 
      388 	call syserr (ANNOUNCE, "^2-multiple bit failures at level ^o, column ^d^/^2-^a^-^24.3b^/^2-^a^-^24.3b", lv, col,
      389 	     "data in cache:", dwas, "data in memory:", dsb);
      390 
      391      end mult_mess;
      392 
      393 
      394 /* static_err - internal procedure to display errors from static test */
      395 
      396 static_err: proc (err_cnt);
      397 
      398 dcl  (dpx, i, j) fixed bin;
      399 dcl  err_cnt fixed bin (35);
      400 dcl  bit_no (3) fixed bin;
      401 dcl  mult bit (1) aligned;
      402 
      403 	bit_no = 0;				/* initialize bit number error array */
      404 
      405 /* display header message first */
      406 	if ^diagnostic_displayed then do;
      407 	     diagnostic_displayed = "1"b;
      408 	     call syserr (ANNOUNCE, "cache_tester: repeatable cache parity error(s) detected on CPU ^a",
      409 		cpu_tag);
      410 	end;
      411 	
      412 
      413 	do i = 1 to err_cnt while (i <= 3);		/* display up to 3 board and chip messages */
      414 	     call find_err_bit (err_data (i).ex_or_data, j, mult);
      415 
      416 	     clv = bin (substr (cpriv_info (i).cache_addr, lv_ex (cache_size_index), 2));
      417 	     ccol = bin (substr (cpriv_info (i).cache_addr, lv_ex (cache_size_index) + 2));
      418 	     ccol = divide (ccol, 4, 17, 0);
      419 	     if j = -1 then do;
      420 						/* parity error only */
      421 		     call syserr (ANNOUNCE, "The cache data is equal to the memory data. Possible parity generation problem for level ^d", clv);
      422 
      423 	     end;
      424 	     else if ^mult then do;			/* if not multiple bit failure */
      425 		bit_no (i) = j;			/* save error bit number */
      426 		if i > 1 then			/* if more than 1 error */
      427 		     if j = bit_no (i - 1) & clv = pclv then
      428 			go to duplicate;		/* do not print out duplicate errors */
      429 
      430 		call get_bcx (clv, j);		/* display diagnostic */
      431 		if ^fim_static_agree then		/* if we havn't found match yet */
      432 		     if ^fim_mult then		/* and data  captured in fim not multple bit failure */
      433 			if j = fim_err_bit & clv = cfim_info.level then
      434 			     fim_static_agree = "1"b; /* set flag so we don't do this test again */
      435 	     end;
      436 	     else do;
      437 		dpx = fixed (err_data(i).cache_addr,17);
      438 		if dpx >= buf_wds then
      439 		     dpx = dpx - buf_wds;
      440 		call mult_mess (clv, ccol,		/* multiple bit failure */
      441 		     err_data (i).cache_data, c_data (dpx) || c_data (dpx + 1));
      442 	     end;
      443 duplicate:
      444 	     pclv = clv;				/* copy current level for duplicate comparisons */
      445 
      446 	end;
      447 
      448      end static_err;
      449 
      450 
      451 /* test_cache - this will cause cache to be tested if that half was on */
      452 
      453 test_cache:
      454      proc;
      455 	if cfim_info.csh1 then do;			/* if lower cache was on... */
      456 	     test_called = "1"b;
      457 	     call cache_priv$csh1 (segptr, buf_wds, cpip, code); /* go test lower half of cache */
      458 
      459 	     if code ^= 0 then do;			/* if cache errors encountered */
      460 		cache_error = "1"b;			/* set terminate condition */
      461 		call static_err (code);		/* go display errors */
      462 		csh1_off = "1"b;			/* set flag to disable csh1 */
      463 	     end;
      464 	end;
      465 	if cfim_info.csh2 then do;			/* if upper cache was on ... */
      466 	     test_called = "1"b;
      467 	     call cache_priv$csh2 (segptr, buf_wds, cpip, code);
      468 						/* go test upper half of cache */
      469 	     if code ^= 0 then do;			/* if cache errors encountered */
      470 		cache_error = "1"b;			/* set terminate condition */
      471 		call static_err (code);		/* go display errors */
      472 		csh2_off = "1"b;			/* set flag to disable csh2 */
      473 	     end;
      474 	end;
      475      end test_cache;
      476 
      477 
      478 /* BEGIN MESSAGE DOCUMENTATION
      479*
      480*   Message:
      481*   cache_tester: Unable to allocate wired buffer.
      482*
      483*   S: $info
      484*
      485*   T: $run
      486*
      487*   M: Attempted to allocate wired contiguous buffer for cache testing and
      488*   pc_contig could not find enough pages available.
      489*
      490*   A: If cache error information was captured in the fim this information is
      491*   displayed. Cache memory is turned back on.
      492*
      493*   Message:
      494*   cache_tester: Unable to set CPU required to <TAG> cache is off ERRORMESSAGE.
      495*
      496*   S: $info
      497*
      498*   T: $run
      499*
      500*   M: Attempted to run on CPU <TAG> for cache testing and could not set CPU
      501*   required to that CPU.
      502*
      503*   A: Cache memory is turned back on.
      504*
      505*   Message:
      506*   cache_tester: Unable to run on CPU <TAG> to EEDD cache ERRORMESSAGE.
      507*
      508*   S: $beep
      509*
      510*   T: $run
      511*
      512*   M: The attempt to run on CPU <TAG> to either enable (EEDD - enable) or disable
      513*   (EEDD = disable) cache memory failed.
      514*
      515*   A: CPU <TAG> should be taken offline if the attempt was to disable cache
      516*   memory.
      517*
      518*   Message:
      519*   cache_tester: No errors found in cache memory for CPU <TAG>, cache will remain on.
      520*
      521*   S: $info
      522*
      523*   T: $run
      524*
      525*   M: The static test of cache memory for CPU <TAG> found no errors and no cache
      526*   error information was captured by the fim.
      527*
      528*   A: cache is turned back on
      529*
      530*   Message:
      531*   cache_tester: repeatable cache parity error(s) detected on CPU <TAG> at:
      532*board XXXX, chip YY.
      533*
      534*   S: $info
      535*
      536*   T: $run
      537*
      538*   M: The static test of cache memory for CPU <TAG> indicated a single bit error
      539*   between the contents of cache and the contents of the wired test buffer. The
      540*   single bit failure is further broken down to the failing wire wrapped board
      541*   (board XXXX) and integrated circuit chip (chip YY) that failed. Since it
      542*   happened during the static test of cache, it is assumed to be a solid failure
      543*   and that segment of cache memory (csh1 or csh2) is turned off. There could be up
      544*   to 3 board and chip callouts since diagnostic data for the first 3 cache errors
      545*   is captured. These additional board and chip callouts will only be displayed if
      546*   the single bit failure was a different bit or different
      547*   cache level than the board and chip diagnostic already displayed.
      548*
      549*   A: Contact Field Engineering personnel.
      550*
      551*   Message:
      552*   cache_tester: repeatable cache parity error detected on CPU <TAG>
      553*cache data is equal to the memory data. 
      554*parity generation problem for level <L>.
      555*
      556*   S: $info
      557*
      558*   T: $run
      559*
      560*   M: The static test of cache memory for CPU <TAG>  detected a cache failure, but the
      561*   data and its corresponding memory data are equal.
      562*
      563*   A: Contact field Engineering.
      564*
      565*   Message:
      566*   cache_tester: repeatable cache parity error(s) detected on CPU <TAG>
      567*bit failures at level W, column XXX
      568*in cache:	YYYYYYYYYYYYYYYYYYYYYYYY
      569*in memory:	ZZZZZZZZZZZZZZZZZZZZZZZZ.
      570*
      571*   S: $info
      572*
      573*   T: $run
      574*
      575*   M: The static test of cache memory for CPU <TAG> indicated a multiple bit error
      576*   between the contents of cache and the contents of the wired test buffer. The
      577*   multiple bit failure is further broken down to the failing cache level (W) (0 -
      578*   3) and column (XXX) address. The data read from cache (YYY...Y) and the expected
      579*   data (ZZZ...Z) is displayed as an aid for the field engineer. Since the failure
      580*   happened during the static test of cache, it is assumed to be a solid failure
      581*   and that segment of cache memory (csh1 or csh2) is turned off. There could be up
      582*   to 3 multiple messages or some combination of multiple bit error messages and
      583*   board and chip callouts, since diagnostic data for the first 3 cache errors is
      584*   captured.
      585*
      586*   A: Contact Field Engineering personnel.
      587*
      588*   Message:
      589*   cache_tester: cache parity error detected on CPU <TAG>
      590*at:   board XXXX, chip YY.
      591*
      592*   S: $info
      593*
      594*   T: $run
      595*
      596*   M: This message is the result of a single bit cache failure detected and cache
      597*   data and its corresponding memory data captured by the fim. This message will
      598*   be displayed if the diagnostic error data from the fim is valid. The board and
      599*   chip callout are as explained above.
      600*
      601*   A: Contact field Engineering.
      602*
      603*
      604*   Message:
      605*   cache_tester: cache parity error detected on CPU <TAG>
      606*cache data is equal to the memory data. 
      607*parity generation problem for level <L>.
      608*
      609*   S: $info
      610*
      611*   T: $run
      612*
      613*   M: This message is the result of a cache failure detected and cache
      614*   data and its corresponding memory data captured by the fim. This message will
      615*   be displayed if the diagnostic error data from the fim is valid.
      616*
      617*   A: Contact field Engineering.
      618*
      619*   Message:
      620*   cache_tester:  cache parity error detected on CPU <TAG>
      621*bit failures at level W, column XXX
      622*in cache:	YYYYYYYYYYYYYYYYYYYYYYYY
      623*in memory:	ZZZZZZZZZZZZZZZZZZZZZZZZ.
      624*
      625*   S: $info
      626*
      627*   T: $run
      628*
      629*   M: This message is the result of a multiple bit cache failure detected and cache
      630*   data and its corresponding memory data captured by the fim. It should be noted
      631*   that when a cache parity error is detected by the fim, there is a window of
      632*   time before the address in cache and in main store can be determined. Although
      633*   the cache error data is frozen (cache is turned off unconditionaly when the
      634*   parity retry of the fim is called), the corresponding address in main store
      635*   might have been changed through paging migration from other processors. This
      636*   message then might not be a multiple error but rather the result of this window
      637*   condition. If this message was the only diagnostic displayed (i.e. the static
      638*   test found no errors), the cache will be turned back on. The values of W, XXX,
      639*   YYY...Y, and ZZZ...Z are as explained above.
      640*
      641*   A: Contact Field Engineering
      642*
      643*   Message:
      644*   cache_tester: Entire cache memory for CPU <TAG> has been disabled.
      645*
      646*   S: $beep
      647*
      648*   T: $run
      649*
      650*   M: The static test of cache memory for CPU <TAG> detected repeatable errors in
      651*   both halfs of cache. or one half of cache had previously been disabled and the
      652*   static test of the other half detected repeatable errors.
      653*
      654*   A: Contact field Engineering
      655*
      656*   Message:
      657*   cache_tester: LLUU cache memory (csh<n>) for CPU <TAG> has been turned off
      658*OTHER was AA and has not been changed.
      659*
      660*   S: $beep
      661*
      662*   T: $run
      663*
      664*   M: Either the lower half (LLUU = Lower, <n> = 1) or the upper half (LLUU =
      665*   Upper, <n> = 2) of cache memory for CPU <TAG> has been turned off as the result of
      666*   the static cache test finding a repeatable cache failure. The OTHER (Upper or 
      667*   Lower) was in state AA. If AA is off this half of cache was not tested. If AA
      668*   is on this half of cache had no errors.
      669*
      670*   A: Contact Field Engineering
      671*
      672*
      673*   END MESSAGE DOCUMENTATION */
      674 
  1     1 /*  */
  1     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  1     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  1     4 /* Modified 07/07/76 by Morris for fault register data */
  1     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  1     6 /* Modified '82 to make values constant */
  1     7 
  1     8 /* words 0-15 pointer registers */
  1     9 
  1    10 dcl  mcp ptr;
  1    11 
  1    12 dcl 1 mc based (mcp) aligned,
  1    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  1    14    (2 regs,					/* registers */
  1    15       3 x (0:7) bit (18),				/* index registers */
  1    16       3 a bit (36),					/* accumulator */
  1    17       3 q bit (36),					/* q-register */
  1    18       3 e bit (8),					/* exponent */
  1    19       3 pad1 bit (28),
  1    20       3 t bit (27),					/* timer register */
  1    21       3 pad2 bit (6),
  1    22       3 ralr bit (3),				/* ring alarm register */
  1    23 
  1    24     2 scu (0:7) bit (36),
  1    25 
  1    26     2 mask bit (72),				/* mem controller mask at time of fault */
  1    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  1    28     2 errcode fixed bin (35),				/* fault handler's error code */
  1    29     2 fim_temp,
  1    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  1    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  1    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  1    33     2 fault_reg bit (36),				/* fault register */
  1    34     2 pad2 bit (1),
  1    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  1    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  1    37     2 fault_time bit (54),				/* time of fault */
  1    38 
  1    39     2 eis_info (0:7) bit (36)) unaligned;
  1    40 
  1    41 
  1    42 dcl (apx fixed bin init (0),
  1    43      abx fixed bin init (1),
  1    44      bpx fixed bin init (2),
  1    45      bbx fixed bin init (3),
  1    46      lpx fixed bin init (4),
  1    47      lbx fixed bin init (5),
  1    48      spx fixed bin init (6),
  1    49      sbx fixed bin init (7)) internal static options (constant);
  1    50 
  1    51 
  1    52 
  1    53 
  1    54 dcl  scup ptr;
  1    55 
  1    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  1    57 
  1    58 
  1    59 /*	WORD (0)		*/
  1    60 
  1    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  1    62       3 prr bit (3),				/* procedure ring register */
  1    63       3 psr bit (15),				/* procedure segment register */
  1    64       3 p bit (1),					/* procedure privileged bit */
  1    65 
  1    66     2 apu,					/* APPENDING UNIT STATUS */
  1    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  1    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  1    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  1    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  1    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  1    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  1    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  1    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  1    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  1    76       3 ptw bit (1),				/* Fetch of PTW */
  1    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  1    78       3 fap bit (1),				/* Fetch of final address paged */
  1    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  1    80       3 fabs bit (1),				/* Fetch of final address absolute */
  1    81 
  1    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  1    83 
  1    84 
  1    85 /*	WORD (1)		*/
  1    86 
  1    87     2 fd,						/* FAULT  DATA */
  1    88       3 iro bit (1),				/* illegal ring order */
  1    89       3 oeb bit (1),				/* out of execute bracket */
  1    90       3 e_off bit (1),				/* no execute */
  1    91       3 orb bit (1),				/* out of read bracket */
  1    92       3 r_off bit (1),				/* no read */
  1    93       3 owb bit (1),				/* out of write bracket */
  1    94       3 w_off bit (1),				/* no write */
  1    95       3 no_ga bit (1),				/* not a gate */
  1    96       3 ocb bit (1),				/* out of call bracket */
  1    97       3 ocall bit (1),				/* outward call */
  1    98       3 boc bit (1),				/* bad outward call */
  1    99       3 inret bit (1),				/* inward return */
  1   100       3 crt bit (1),				/* cross ring transfer */
  1   101       3 ralr bit (1),				/* ring alarm register */
  1   102       3 am_er bit (1),				/* associative memory fault */
  1   103       3 oosb bit (1),				/* out of segment bounds */
  1   104       3 paru bit (1),				/* processor parity upper */
  1   105       3 parl bit (1),				/* processor parity lower */
  1   106       3 onc_1 bit (1),				/* op not complete type 1 */
  1   107       3 onc_2 bit (1),				/* op not complete type 2 */
  1   108 
  1   109     2 port_stat,					/* PORT  STATUS */
  1   110       3 ial bit (4),				/* illegal action lines */
  1   111       3 iac bit (3),				/* illegal action channel */
  1   112       3 con_chan bit (3),				/* connect channel */
  1   113 
  1   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  1   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  1   116 
  1   117 
  1   118 /*	WORD (2)		*/
  1   119 
  1   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  1   121       3 trr bit (3),				/* temporary ring register */
  1   122       3 tsr bit (15),				/* temporary segment register */
  1   123 
  1   124     2 pad2 bit (9),
  1   125 
  1   126     2 cpu_no bit (3),				/* CPU number */
  1   127 
  1   128     2 delta bit (6),				/* tally modification DELTA */
  1   129 
  1   130 
  1   131 /*	WORD (3)		*/
  1   132 
  1   133     2 word3 bit (18),
  1   134 
  1   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  1   136       3 tsna,					/* Word 1 status */
  1   137         4 prn bit (3),				/* Word 1  PR  number */
  1   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  1   139       3 tsnb,					/* Word 2  status */
  1   140         4 prn bit (3),				/* Word 2  PR  number */
  1   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  1   142       3 tsnc,					/* Word 3  status */
  1   143         4 prn bit (3),				/* Word 3  PR  number */
  1   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  1   145 
  1   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  1   147 
  1   148 
  1   149 /* 	WORD (4)		*/
  1   150 
  1   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  1   152 
  1   153     2 ir,						/* INDICATOR  REGISTERS */
  1   154       3 zero bit (1),				/* zero indicator */
  1   155       3 neg bit (1),				/* negative indicator */
  1   156       3 carry bit (1),				/* carryry indicator */
  1   157       3 ovfl bit (1),				/* overflow indicator */
  1   158       3 eovf bit (1),				/* eponent overflow */
  1   159       3 eufl bit (1),				/* exponent underflow */
  1   160       3 oflm bit (1),				/* overflow mask */
  1   161       3 tro bit (1),				/* tally runout */
  1   162       3 par bit (1),				/* parity error */
  1   163       3 parm bit (1),				/* parity mask */
  1   164       3 bm bit (1),					/* ^bar mode */
  1   165       3 tru bit (1),				/* truncation mode */
  1   166       3 mif bit (1),				/* multi-word instruction mode */
  1   167       3 abs bit (1),				/* absolute mode */
  1   168       3 hex bit (1),				/* hexadecimal exponent mode */
  1   169       3 pad bit (3),
  1   170 
  1   171 
  1   172 /*	WORD (5)		*/
  1   173 
  1   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  1   175 
  1   176     2 cu,						/* CONTROL UNIT STATUS */
  1   177       3 rf bit (1),					/* on first cycle of repeat instr */
  1   178       3 rpt bit (1),				/* repeat instruction */
  1   179       3 rd bit (1),					/* repeat double instruction */
  1   180       3 rl bit (1),					/* repeat link instruciton */
  1   181       3 pot bit (1),				/* IT  modification */
  1   182       3 pon bit (1),				/* return type instruction */
  1   183       3 xde bit (1),				/* XDE from Even location */
  1   184       3 xdo bit (1),				/* XDE from Odd  location */
  1   185       3 poa bit (1),				/* operation preparation */
  1   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  1   187       3 its bit (1),				/* ITS modification */
  1   188       3 if bit (1),					/* fault occured during instruction fetch */
  1   189 
  1   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  1   191 
  1   192 
  1   193 /*	WORDS (6,7)	*/
  1   194 
  1   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  1   196 
  1   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  1   198 
  1   199 
  1   200 
  1   201 
  1   202 
  1   203 
  1   204 /*	ALTERNATE   SCU  DECLARATION		*/
  1   205 
  1   206 
  1   207 dcl 1 scux based (scup) aligned,
  1   208 
  1   209    (2 pad0 bit (36),
  1   210 
  1   211     2 fd,						/* GROUP II  FAULT DATA */
  1   212       3 isn bit (1),				/* illegal segment number */
  1   213       3 ioc bit (1),				/* illegal op  code  */
  1   214       3 ia_am bit (1),				/* illegal address - modifier */
  1   215       3 isp bit (1),				/* illegal slave  procedure */
  1   216       3 ipr bit (1),				/* illegal procedure */
  1   217       3 nea bit (1),				/* non existent address */
  1   218       3 oobb bit (1),				/* out of bounds */
  1   219       3 pad bit (29),
  1   220 
  1   221     2 pad2 bit (36),
  1   222 
  1   223     2 pad3a bit (18),
  1   224 
  1   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  1   226       3 prn bit (3),				/* PR  number */
  1   227       3 prv bit (1),				/* PR  valid bit */
  1   228 
  1   229     2 pad3b bit (6)) unaligned,
  1   230 
  1   231     2 pad45 (0:1) bit (36),
  1   232 
  1   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  1   234 
  1   235 
  1   236 
  1   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      675 
      676 
  2     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  2     2 /* format: style4 */
  2     3 
  2     4 /* Information about system controllers */
  2     5 
  2     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  2     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  2     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  2     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  2    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  2    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  2    12          3 mbz bit (3) unaligned,
  2    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  2    14        2 info aligned,
  2    15          3 online bit (1) unaligned,			/* ON if controller is online */
  2    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  2    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  2    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  2    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  2    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  2    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  2    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  2    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  2    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  2    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  2    26          3 type bit (4) unaligned,			/* Model number for this controller */
  2    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  2    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  2    29          3 mbz bit (13) unaligned,
  2    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  2    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  2    32 
  2    33 /* Information about CPUs */
  2    34 
  2    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  2    36        (
  2    37        2 online bit (1),				/* "1"b if CPU is online */
  2    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  2    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  2    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  2    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  2    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  2    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  2    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  2    45        2 mbz1 bit (6),
  2    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  2    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  2    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  2    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  2    50        2 mbz2 bit (12),
  2    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  2    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  2    53        2 controller_port fixed bin (3) unsigned
  2    54        ) unaligned;					/* Port on controller */
  2    55 
  2    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  2    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  2    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  2    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  2    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  2    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  2    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  2    63        2 pad bit (12) unaligned;
  2    64 
  2    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  2    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  2    67        2 cow,
  2    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    69          3 mbz1 bit (13) unaligned,
  2    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    71          3 mbz2 bit (2) unaligned,
  2    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  2    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  2    74          3 mbz3 bit (3) unaligned,
  2    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    76 
  2    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  2    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  2    79        2 pad bit (12) unal,
  2    80        2 tag bit (6) unal;				/* Better be zero. */
  2    81 
  2    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  2    83        2 pad bit (36) aligned,
  2    84        2 cow,					/* Connect operand word, in odd location. */
  2    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    86          3 mbz1 bit (13) unaligned,
  2    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    88          3 mbz2 bit (9) unaligned,
  2    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    90 
  2    91 /* MASKS and PATTERNS */
  2    92 
  2    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  2    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  2    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  2    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  2    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  2    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  2    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  2   100 
  2   101 /* CAM and CACHE clear info */
  2   102 
  2   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  2   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  2   105 
  2   106 /* MASKING INSTRUCTIONS & POINTERS */
  2   107 
  2   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  2   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  2   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  2   111 
  2   112 /* MISCELLANEOUS */
  2   113 
  2   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  2   115        (
  2   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  2   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  2   118        2 pad1 bit (4),
  2   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  2   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  2   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  2   122        2 mask_cpu fixed bin (5)
  2   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  2   124 
  2   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  2   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  2   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  2   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  2   129 
  2   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  2   131 
  2   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  2   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  2   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  2   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  2   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  2   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  2   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  2   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  2   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  2   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  2   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  2   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  2   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  2   145 
  2   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  2   147 
  2   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  2   149 
  2   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  2   151 
  2   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  2   153 
  2   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  2   155 						/* Which ports have expanders */
  2   156 
  2   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  2   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  2   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  2   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  2   161 
  2   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  2   163 
  2   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  2   165 						/* Controller size on config card */
  2   166 
  2   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  2   168 
  2   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  2   170 						/* PTWs for SCAS pages */
  2   171 
  2   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  2   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  2   174 
  2   175 
  2   176 dcl  (
  2   177      IOM_PORT init (1),
  2   178      CPU_PORT init (2),
  2   179      BULK_PORT init (3)
  2   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  2   181 
  2   182 
  2   183 /* END INCLUDE FILE scs.incl.pl1 */
      677 
      678 
  3     1 /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  3     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  3     3 
  3     4 dcl  sdw_info_ptr pointer;
  3     5 
  3     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  3     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  3     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  3     9 
  3    10     2 access unaligned,				/* REWP */
  3    11       3 read bit (1) unaligned,
  3    12       3 execute bit (1) unaligned,
  3    13       3 write bit (1) unaligned,
  3    14       3 privileged bit (1) unaligned,
  3    15 
  3    16     2 pad1 bit (32) unaligned,
  3    17 
  3    18     2 rings unaligned,				/* Ring brackets */
  3    19       3 r1 bit (3) unaligned,
  3    20       3 r2 bit (3) unaligned,
  3    21       3 r3 bit (3) unaligned,
  3    22 
  3    23     2 pad2 bit (27) unaligned,
  3    24 
  3    25     2 flags aligned,
  3    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  3    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  3    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  3    29       3 pad3 bit (33) unaligned,
  3    30 
  3    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  3    32 
  3    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
      679 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      680 
      681 
      682      end cache_tester;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0830.0  cache_tester.pl1                  >special_ldd>install>MR12.3-1114>cache_tester.pl1
675          1    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
677          2    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
679          3    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
680          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000121 constant        fixed bin(17,0)          initial dcl 4-7 set ref 171* 199* 245* 248* 369*
                                                                                  372* 375* 388* 408* 421*
BEEP                            000177 constant        fixed bin(17,0)          initial dcl 4-7 set ref 289* 298* 303* 314*
CPU_TAGS                        000144 constant        char(8)                  initial packed unaligned dcl 117 ref 153 199 199
absaddr                   0(12)        based           bit(24)                  level 2 in structure "cfim_info" packed packed
                                                                                  unaligned dcl 93 in procedure "cache_tester" ref
                                                                                  254
absaddr                         000115 automatic       fixed bin(26,0)          dcl 81 in procedure "cache_tester" set ref 169* 183
                                                                                  227
access                    2     000146 automatic       structure                level 2 packed packed unaligned dcl 112
addr                                                   builtin function         dcl 76 ref 151 160 178 185 185 185 185 186 186 225
                                                                                  225
addrel                                                 builtin function         dcl 76 ref 191
address                         000146 automatic       fixed bin(26,0)          level 2 dcl 112 set ref 183*
bdx                             000216 automatic       fixed bin(17,0)          dcl 353 set ref 362* 369 369 372 375
binary                                                 builtin function         dcl 76 ref 152
bit_no                          000241 automatic       fixed bin(17,0)          array dcl 400 set ref 403* 425* 426
bool                                                   builtin function         dcl 76 ref 241
buf_size                        000105 automatic       fixed bin(17,0)          dcl 80 set ref 158* 159 168
buf_wds                         000107 automatic       fixed bin(17,0)          dcl 80 set ref 159* 191 206 213 438 438 457* 467*
c_data                                 based           bit(36)                  array dcl 113 set ref 207* 214* 440 440
c_mode_reg                      000176 automatic       structure                level 1 dcl 267 set ref 277* 294
cache                     4(02) 000146 automatic       bit(1)                   level 3 packed packed unaligned dcl 112 set ref 182*
cache_addr                6            based           bit(36)                  array level 3 dcl 101 set ref 416 417 437
cache_data                             based           bit(72)                  array level 3 dcl 101 set ref 440*
cache_error                     000117 automatic       bit(1)                   dcl 83 set ref 163* 204* 205 211 298 460* 470*
cache_priv$csh1                 000012 constant        entry                    external dcl 56 ref 457
cache_priv$csh2                 000014 constant        entry                    external dcl 57 ref 467
cache_size                0(15) 000046 external static fixed bin(3,0)           array level 2 in structure "scs$processor_data"
                                                                                  packed packed unsigned unaligned dcl 2-35
                                                                                  in procedure "cache_tester" ref 156
cache_size                      000113 automatic       fixed bin(17,0)          dcl 80 in procedure "cache_tester" set ref 157* 158
                                                                                  169
cache_size_index                000114 automatic       fixed bin(17,0)          dcl 80 set ref 156* 157 254 369 372 416 417
ccol                            000112 automatic       fixed bin(17,0)          dcl 80 set ref 254* 255* 255 256* 417* 418* 418 440*
cfim_info                              based           structure                level 1 dcl 93
clv                             000111 automatic       fixed bin(17,0)          dcl 80 set ref 416* 421* 426 430* 431 440* 443
code                            000116 automatic       fixed bin(35,0)          dcl 82 set ref 169* 170 197* 198 199* 287* 288 289*
                                                                                  296* 457* 459 461* 467* 469 471*
col                                    parameter       fixed bin(17,0)          dcl 385 set ref 383 388*
cpar_wwb                        000114 constant        char(6)                  initial packed unaligned dcl 122 ref 369 369
cpip                            000136 automatic       pointer                  dcl 85 set ref 191* 192 414 416 417 437 440 457*
                                                                                  467*
cpriv_info                             based           structure                level 1 dcl 101 set ref 192*
cptr                            000134 automatic       pointer                  dcl 85 set ref 160* 240 248 250 254 256 281 283 431
                                                                                  455 465
cpu                             000140 automatic       fixed bin(3,0)           dcl 86 set ref 152* 153 155 156 199 199 286
cpu_mask                        000142 automatic       bit(8)                   dcl 88 set ref 154* 155* 197* 285* 286* 287*
cpu_no                    2(27)        based           bit(3)                   level 2 packed packed unaligned dcl 1-56 ref 152
cpu_tag                         000141 automatic       char(1)                  packed unaligned dcl 87 set ref 153* 245* 289* 298*
                                                                                  303* 314* 408*
cpx                             000217 automatic       fixed bin(17,0)          dcl 353 set ref 363* 364* 364 369 369 372 375
csh1                      0(18) 000176 automatic       bit(1)                   level 2 in structure "c_mode_reg" packed packed
                                                                                  unaligned dcl 267 in procedure "enable_cache" set
                                                                                  ref 281* 289 298* 303 312
csh1                      0(08)        based           bit(1)                   level 2 in structure "cfim_info" packed packed
                                                                                  unaligned dcl 93 in procedure "cache_tester" ref
                                                                                  281 455
csh1_off                        000124 automatic       bit(1)                   dcl 83 set ref 162* 281 289 305 306 462*
csh2                      0(19) 000176 automatic       bit(1)                   level 2 in structure "c_mode_reg" packed packed
                                                                                  unaligned dcl 267 in procedure "enable_cache" set
                                                                                  ref 283* 289 298* 303 308
csh2                      0(09)        based           bit(1)                   level 2 in structure "cfim_info" packed packed
                                                                                  unaligned dcl 93 in procedure "cache_tester" ref
                                                                                  283 465
csh2_off                        000125 automatic       bit(1)                   dcl 83 set ref 162* 283 289 305 472*
csh_mem                         000126 automatic       bit(1)                   dcl 83 set ref 307* 311* 314* 314* 314*
csize                           000135 constant        fixed bin(17,0)          initial array dcl 118 ref 157
d_pattern                       000000 constant        bit(36)                  initial array packed unaligned dcl 149 ref 207
diagnose                               based           bit(1)                   level 2 packed packed unaligned dcl 93 ref 240
diagnostic_displayed            000122 automatic       bit(1)                   dcl 83 set ref 161* 406 407*
divide                                                 builtin function         dcl 76 ref 158 227 255 362 418
dps8_chip                       000050 constant        char(3)                  initial array packed unaligned dcl 123 set ref 372*
dpx                             000236 automatic       fixed bin(17,0)          dcl 398 set ref 437* 438 438* 438 440 440
dsb                                    parameter       bit(72)                  dcl 386 set ref 383 388*
dwas                                   parameter       bit(72)                  dcl 386 set ref 383 388*
err_bit                                parameter       fixed bin(17,0)          dcl 353 in procedure "get_bcx" ref 351 357 359 361
err_bit                                parameter       fixed bin(17,0)          dcl 325 in procedure "find_err_bit" set ref 322 337*
                                                                                  344*
err_cnt                                parameter       fixed bin(35,0)          dcl 399 ref 396 413
err_data                               based           structure                array level 2 dcl 101
ex_or_data                2            based           bit(72)                  array level 3 dcl 101 set ref 414*
fim_abs_seg$                    000034 external static fixed bin(17,0)          dcl 68 set ref 178
fim_col_ex                      000121 constant        fixed bin(17,0)          initial array dcl 120 ref 254
fim_err_bit                     000106 automatic       fixed bin(17,0)          dcl 80 set ref 242* 243 248 250* 431
fim_mult                        000123 automatic       bit(1)                   dcl 83 set ref 242* 250 431
fim_static_agree                000121 automatic       bit(1)                   dcl 83 set ref 161* 243* 260* 431 431*
fimxord                         000130 automatic       bit(72)                  dcl 84 set ref 241* 242*
flags                     4     000146 automatic       structure                level 2 dcl 112
freecore                        000030 constant        entry                    external dcl 63 ref 230
fwp                             000103 automatic       fixed bin(17,0)          dcl 80 set ref 227* 228 229
i                               000101 automatic       fixed bin(17,0)          dcl 80 in procedure "cache_tester" set ref 205* 207*
                                                                                  213* 214 214* 229* 230*
i                               000206 automatic       fixed bin(17,0)          dcl 325 in procedure "find_err_bit" set ref 330* 331
                                                                                  331 331 333* 333 336 337*
i                               000220 automatic       fixed bin(17,0)          dcl 353 in procedure "get_bcx" set ref 359* 361* 362
                                                                                  363
i                               000237 automatic       fixed bin(17,0)          dcl 398 in procedure "static_err" set ref 413* 413*
                                                                                  414 416 417 425 426 426 437 440*
inst_on                   0(21) 000176 automatic       bit(1)                   level 2 packed packed unaligned dcl 267 set ref 279*
j                               000207 automatic       fixed bin(17,0)          dcl 325 in procedure "find_err_bit" set ref 329*
                                                                                  338* 338 342 344
j                               000102 automatic       fixed bin(17,0)          dcl 80 in procedure "cache_tester" set ref 206* 207*
j                               000240 automatic       fixed bin(17,0)          dcl 398 in procedure "static_err" set ref 414* 419
                                                                                  425 426 430* 431
l68_cpar_chip                   000116 constant        char(12)                 initial packed unaligned dcl 121 ref 369 369
level                                  parameter       fixed bin(17,0)          dcl 353 in procedure "get_bcx" set ref 351 369* 372
                                                                                  375
level                     0(10)        based           fixed bin(2,0)           level 2 in structure "cfim_info" packed packed
                                                                                  unsigned unaligned dcl 93 in procedure
                                                                                  "cache_tester" set ref 248* 250 256 431
luf_timer                 0(34) 000176 automatic       bit(2)                   level 2 packed packed unaligned dcl 267 set ref 280*
lv                                     parameter       fixed bin(17,0)          dcl 385 set ref 383 388*
lv_ex                           000127 constant        fixed bin(17,0)          initial array dcl 119 ref 416 417
lwp                             000104 automatic       fixed bin(17,0)          dcl 80 set ref 228* 229
max_buf                         000100 automatic       fixed bin(17,0)          dcl 65 set ref 168* 169 184 228
mc                                     based           structure                level 1 dcl 1-12
mcp                                    parameter       pointer                  dcl 1-10 ref 25 151
mod                                                    builtin function         dcl 76 ref 363
mult                            000244 automatic       bit(1)                   dcl 401 set ref 414* 424
multiple                               parameter       bit(1)                   dcl 326 set ref 322 328* 342*
odd_wd                          000221 automatic       bit(1)                   dcl 354 set ref 356* 358* 364
opnd_on                   0(20) 000176 automatic       bit(1)                   level 2 packed packed unaligned dcl 267 set ref 278*
other_state                     000177 automatic       bit(1)                   packed unaligned dcl 276 set ref 308* 312* 314*
pc_abs$remove_core_mod          000010 constant        entry                    external dcl 55 ref 169
pclv                            000110 automatic       fixed bin(17,0)          dcl 80 set ref 426 443*
pds$cpar_err_data               000036 external static bit(72)                  dcl 69 set ref 241 256*
pds$cpar_info                   000042 external static bit(36)                  dcl 71 set ref 160 297*
pds$cpar_mem_data               000040 external static bit(72)                  dcl 70 set ref 241 256*
prds$cache_luf_reg              000044 external static bit(36)                  dcl 72 set ref 294* 294
privileged_mode_ut$clear_cache  000024 constant        entry                    external dcl 61 ref 317
privileged_mode_ut$swap_sdw     000022 constant        entry                    external dcl 60 ref 186 225
read                      2     000146 automatic       bit(1)                   level 3 packed packed unaligned dcl 112 set ref 181*
scs$processor_data              000046 external static structure                array level 1 dcl 2-35
scu                                    based           structure                level 1 dcl 1-56 in procedure "cache_tester"
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 1-12 in procedure "cache_tester" set
                                                                                  ref 151
scup                            000154 automatic       pointer                  dcl 1-54 set ref 151* 152
sdw_info                               based           structure                level 1 dcl 3-6
sdw_util_$construct             000032 constant        entry                    external dcl 64 ref 185
sdwi                            000146 automatic       structure                level 1 dcl 112 set ref 180* 185 185
segptr                          000132 automatic       pointer                  dcl 85 set ref 178* 186* 191 207 214 225* 440 440
                                                                                  457* 467*
set_procs_required              000026 constant        entry                    external dcl 62 ref 197 287 296
size                      1     000146 automatic       fixed bin(19,0)          level 2 dcl 112 set ref 184*
string                                                 builtin function         dcl 76 set ref 277* 294
substr                                                 builtin function         dcl 76 set ref 153 155* 199 199 254 286* 331 336 369
                                                                                  369 369 369 416 417
syserr                          000016 constant        entry                    external dcl 58 ref 171 245 248 298 303 314 369 372
                                                                                  375 388 408 421
syserr$error_code               000020 constant        entry                    external dcl 59 ref 199 289
test_called                     000120 automatic       bit(1)                   dcl 83 set ref 163* 298* 456* 466*
tsdw                            000144 automatic       fixed bin(71,0)          dcl 111 set ref 185 185 186 186 223* 225 225
vs_sc_chip                      000004 constant        char(3)                  initial array packed unaligned dcl 136 set ref 375*
write                     2(02) 000146 automatic       bit(1)                   level 3 packed packed unaligned dcl 112 set ref 181*
xord                                   parameter       bit(72)                  dcl 324 ref 322 331 336

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 2-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
CRASH                                  internal static fixed bin(17,0)          initial dcl 4-7
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
abx                                    internal static fixed bin(17,0)          initial dcl 1-42
apx                                    internal static fixed bin(17,0)          initial dcl 1-42
bbx                                    internal static fixed bin(17,0)          initial dcl 1-42
bpx                                    internal static fixed bin(17,0)          initial dcl 1-42
lbx                                    internal static fixed bin(17,0)          initial dcl 1-42
lpx                                    internal static fixed bin(17,0)          initial dcl 1-42
sbx                                    internal static fixed bin(17,0)          initial dcl 1-42
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 2-137
scs$bos_restart_flags                  external static bit(8)                   dcl 2-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 2-103
scs$cam_wait                           external static bit(8)                   dcl 2-104
scs$cfg_data                           external static fixed bin(71,0)          array dcl 2-150
scs$cfg_data_save                      external static fixed bin(71,0)          dcl 2-152
scs$connect_lock                       external static bit(36)                  dcl 2-132
scs$controller_config_size             external static fixed bin(14,0)          array dcl 2-164
scs$controller_data                    external static structure                array level 1 dcl 2-6
scs$cow                                external static structure                array level 1 dcl 2-65
scs$cow_ptrs                           external static structure                array level 1 dcl 2-77
scs$cpu_test_mask                      external static bit(72)                  dcl 2-96
scs$cpu_test_pattern                   external static bit(36)                  dcl 2-99
scs$cycle_priority_template            external static bit(7)                   dcl 2-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 2-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 2-140
scs$faults_initialized                 external static bit(1)                   dcl 2-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 2-130
scs$interrupt_controller               external static fixed bin(3,0)           dcl 2-141
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 2-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 2-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 2-97
scs$open_level                         external static bit(72)                  dcl 2-94
scs$port_addressing_word               external static bit(3)                   array dcl 2-148
scs$port_data                          external static structure                array level 1 dcl 2-56
scs$processor                          external static bit(8)                   dcl 2-143
scs$processor_data_switch_value        external static bit(36)                  dcl 2-162
scs$processor_start_int_no             external static fixed bin(5,0)           dcl 2-142
scs$processor_start_mask               external static bit(72)                  dcl 2-95
scs$processor_start_pattern            external static bit(36)                  dcl 2-98
scs$processor_start_wait               external static bit(8)                   dcl 2-144
scs$processor_switch_compare           external static bit(36)                  array dcl 2-159
scs$processor_switch_data              external static bit(36)                  array dcl 2-157
scs$processor_switch_mask              external static bit(36)                  array dcl 2-160
scs$processor_switch_template          external static bit(36)                  array dcl 2-158
scs$processor_test_data                external static structure                level 1 dcl 2-114
scs$read_mask                          external static bit(36)                  array dcl 2-109
scs$reconfig_general_cow               external static structure                level 1 dcl 2-82
scs$reconfig_lock                      external static bit(36)                  dcl 2-133
scs$reconfig_locker_id                 external static char(32)                 dcl 2-167
scs$scas_page_table                    external static bit(36)                  array dcl 2-169
scs$set_cycle_switches                 external static bit(1)                   dcl 2-173
scs$set_mask                           external static bit(36)                  array dcl 2-108
scs$sys_level                          external static bit(72)                  dcl 2-93
scs$sys_trouble_pending                external static bit(1)                   dcl 2-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 2-146
scs$trouble_flags                      external static bit(8)                   dcl 2-134
scux                                   based           structure                level 1 dcl 1-207
sdw_info_ptr                           automatic       pointer                  dcl 3-4
spx                                    internal static fixed bin(17,0)          initial dcl 1-42

NAMES DECLARED BY EXPLICIT CONTEXT.
cache_tester                    000562 constant        entry                    external dcl 25
display_fimerror                001147 constant        entry                    internal dcl 238 ref 164
duplicate                       002501 constant        label                    dcl 443 ref 426
enable_cache                    001326 constant        entry                    internal dcl 265 ref 172 218
find_err_bit                    001657 constant        entry                    internal dcl 322 ref 242 414
get_bcx                         001733 constant        entry                    internal dcl 351 ref 250 430
mult_mess                       002144 constant        entry                    internal dcl 383 ref 256 440
nxt_i                           001714 constant        label                    dcl 340 ref 334
return_buffer                   001103 constant        label                    dcl 223 ref 201
static_err                      002225 constant        entry                    internal dcl 396 ref 461 471
test_cache                      002506 constant        entry                    internal dcl 453 ref 209 216

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 254 416 417
fixed                                                  builtin function         ref 437
unspec                                                 builtin function         set ref 180 192* 214

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3040        3110    2626        3050
Length      3402    2626        50         256     212           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cache_tester                        608 external procedure  is an external procedure.  
display_fimerror                        internal procedure  shares stack frame of external procedure cache_tester.  
enable_cache                            internal procedure  shares stack frame of external procedure cache_tester.  
find_err_bit                            internal procedure  shares stack frame of external procedure cache_tester.  
get_bcx                                 internal procedure  shares stack frame of external procedure cache_tester.  
mult_mess                               internal procedure  shares stack frame of external procedure cache_tester.  
static_err                              internal procedure  shares stack frame of external procedure cache_tester.  
test_cache                              internal procedure  shares stack frame of external procedure cache_tester.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cache_tester             000100 max_buf                     cache_tester
                         000101 i                           cache_tester
                         000102 j                           cache_tester
                         000103 fwp                         cache_tester
                         000104 lwp                         cache_tester
                         000105 buf_size                    cache_tester
                         000106 fim_err_bit                 cache_tester
                         000107 buf_wds                     cache_tester
                         000110 pclv                        cache_tester
                         000111 clv                         cache_tester
                         000112 ccol                        cache_tester
                         000113 cache_size                  cache_tester
                         000114 cache_size_index            cache_tester
                         000115 absaddr                     cache_tester
                         000116 code                        cache_tester
                         000117 cache_error                 cache_tester
                         000120 test_called                 cache_tester
                         000121 fim_static_agree            cache_tester
                         000122 diagnostic_displayed        cache_tester
                         000123 fim_mult                    cache_tester
                         000124 csh1_off                    cache_tester
                         000125 csh2_off                    cache_tester
                         000126 csh_mem                     cache_tester
                         000130 fimxord                     cache_tester
                         000132 segptr                      cache_tester
                         000134 cptr                        cache_tester
                         000136 cpip                        cache_tester
                         000140 cpu                         cache_tester
                         000141 cpu_tag                     cache_tester
                         000142 cpu_mask                    cache_tester
                         000144 tsdw                        cache_tester
                         000146 sdwi                        cache_tester
                         000154 scup                        cache_tester
                         000176 c_mode_reg                  enable_cache
                         000177 other_state                 enable_cache
                         000206 i                           find_err_bit
                         000207 j                           find_err_bit
                         000216 bdx                         get_bcx
                         000217 cpx                         get_bcx
                         000220 i                           get_bcx
                         000221 odd_wd                      get_bcx
                         000236 dpx                         static_err
                         000237 i                           static_err
                         000240 j                           static_err
                         000241 bit_no                      static_err
                         000244 mult                        static_err

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          longbs_to_fx2       mdfx1               ext_entry
set_bits_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cache_priv$csh1               cache_priv$csh2               freecore                      pc_abs$remove_core_mod
privileged_mode_ut$clear_cache                              privileged_mode_ut$swap_sdw   sdw_util_$construct
set_procs_required            syserr                        syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
fim_abs_seg$                  pds$cpar_err_data             pds$cpar_info                 pds$cpar_mem_data
prds$cache_luf_reg            scs$processor_data




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000557       151 000567       152 000574       153 000600       154 000604       155 000605       156 000610
    157 000614       158 000616       159 000620       160 000622       161 000624       162 000626       163 000630
    164 000632       168 000633       169 000636       170 000656       171 000660       172 000700       173 000701
    178 000702       180 000705       181 000710       182 000714       183 000716       184 000720       185 000723
    186 000737       191 000752       192 000756       197 000761       198 000772       199 000774       201 001031
    204 001032       205 001033       206 001043       207 001053       208 001056       209 001060       210 001061
    211 001063       213 001065       214 001075       215 001077       216 001101       218 001102       223 001103
    225 001105       227 001120       228 001123       229 001126       230 001135       231 001144       233 001146
    238 001147       240 001150       241 001153       242 001163       243 001165       245 001172       248 001216
    250 001250       254 001262       255 001277       256 001301       259 001322       260 001323       261 001325
    265 001326       277 001327       278 001330       279 001332       280 001334       281 001336       283 001345
    285 001354       286 001355       287 001361       288 001372       289 001374       291 001444       294 001445
    296 001450       297 001462       298 001464       303 001531       305 001571       306 001575       307 001577
    308 001601       309 001603       311 001604       312 001605       314 001611       317 001651       318 001656
    322 001657       328 001661       329 001662       330 001663       331 001667       333 001701       334 001703
    336 001704       337 001712       338 001713       340 001714       342 001716       344 001725       346 001732
    351 001733       356 001735       357 001736       358 001741       359 001743       360 001745       361 001746
    362 001747       363 001751       364 001755       369 001761       372 002032       375 002100       378 002143
    383 002144       388 002146       391 002224       396 002225       403 002227       406 002240       407 002242
    408 002244       413 002270       414 002303       416 002317       417 002340       418 002357       419 002361
    421 002364       423 002407       424 002410       425 002413       426 002415       430 002426       431 002430
    435 002447       437 002450       438 002454       440 002460       443 002501       446 002503       448 002505
    453 002506       455 002507       456 002512       457 002514       459 002531       460 002533       461 002535
    462 002537       465 002541       466 002544       467 002546       469 002563       470 002565       471 002567
    472 002571       475 002573


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
