	COMPILATION LISTING OF SEGMENT make_sdw
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1021.4 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 make_sdw: proc (a_segno, a_tsdw, a_astep, a_ptp);
       11 
       12 /*	Last Modified: (Date and Reason)
       13*   09/22/71 by Richard H. Gumpertz to change null devadds to include rel(ptp) for page
       14*   08/--/71 by David R. Vinograd for page multi-level
       15*   02/12/74 by Bernard S. Greenberg for 6180 cache
       16*   04/09/74 by Bernard S. Greenberg for TBLS card
       17*   07/17/74 by Mike Grady to move code to temp wire pages and
       18*     look for pds and pl1_operators_
       19*   02/10/75 by Andre Bensoussan for the new storage system.
       20*   07/09/75 by Greenberg, incorporating 1/6/75 change by Mabee
       21*     making SDW parameters 'like', instead of fixed (71).
       22*   12/08/75 by Greenberg for pre-withdraw against HC partition
       23*   07/20/78 by Greenberg for multi-vol HC part.
       24*   01/31/79 by D. Spector to allocate deciduous segments on root phys vol
       25*   03/22/81, W. Olin Sibert, for ADP PTWs and SDWs
       26*   04/16/81, WOS, to make parameters fixed bin (71) again, use sdw_util_
       27*   02/28/82, J. Bongiovanni, to eliminate use of FSDCT, add entries
       28*             thread_hcp, reset_hcp
       29*   08/11/82, J. Bongiovanni, to eliminate RLV parasites.
       30*   10/18/82, BIM, $no_pages, entry for establishing segs on partitions
       31*   04/06/83, KPL, bug fix to $no_pages to fill in length fields in aste
       32*   12/13/83, KPL, for adding breakpoint page to executable segments.
       33*   07/12/84, KPL, for setting sentinel in breakpoint page.
       34*   */
       35 
       36 	dcl     a_segno		 fixed bin (18) parameter;
       37 	dcl     a_tsdw		 fixed bin (71) parameter;
       38 	dcl     a_ptp		 pointer parameter;
       39 	dcl     a_astep		 pointer parameter;
       40 	dcl     a_pvtx		 fixed bin parameter;
       41 
       42 	dcl     (error_table_no, pdsno, dsegno, pl1_ops_no, pl1_ops_pages, no_pages_wired) fixed bin;
       43 	dcl     (ptsi, loopcnt)	 fixed bin;
       44 	dcl     pvtx		 fixed bin;
       45 	dcl     temp_sdw		 fixed bin (71);
       46 	dcl     save_pts		 fixed bin;
       47 	dcl     dummy		 fixed bin;
       48 	dcl     asp		 ptr;
       49 	dcl     pts		 fixed bin (9);
       50 	dcl     (i, j)		 fixed bin;
       51 	dcl     unthreaded		 bit (1) aligned;	/* Switch is on if unthreaded entry */
       52 	dcl     no_pages		 bit (1) aligned;
       53 
       54 	dcl     1 sdwi		 aligned like sdw_info automatic;
       55 
       56 	dcl     seg		 (0:262143) fixed bin based aligned;
       57 	dcl     bfword		 (0:1) fixed bin based;
       58 
       59 	dcl     hcp_thread		 fixed bin int static init (0);
       60 	dcl     hcp_first		 fixed bin int static init (0);
       61 
       62 	dcl     abs_seg$		 external static;
       63 	dcl     breakpoint_page$	 external static;
       64 	dcl     dseg$		 external static;
       65 	dcl     name_table$		 external static;
       66 	dcl     pds$		 external static;
       67 	dcl     slt$		 external static;
       68 
       69 	dcl     pl1_operators_$end_pl1_operators fixed bin external static;
       70 	dcl     error_table_$	 external static;
       71 	dcl     sys_info$system_type	 fixed bin external static;
       72 
       73 	dcl     absadr		 entry (ptr, fixed bin (35)) returns (fixed bin (26));
       74 	dcl     config_$find	 entry (char (4) aligned, ptr);
       75 	dcl     get_ptrs_$given_astep	 ext entry (ptr) returns (fixed bin (71));
       76 	dcl     pmut$swap_sdw	 entry (ptr, ptr);
       77 	dcl     ptw_util_$make_core    entry (pointer, fixed bin (26));
       78 	dcl     ptw_util_$make_null	 entry (pointer, bit (22) aligned);
       79 	dcl     ptw_util_$set_wired	 entry (pointer);
       80 	dcl     sdw_util_$construct	 entry (pointer, pointer);
       81 	dcl     sdw_util_$dissect	 entry (pointer, pointer);
       82 	dcl     syserr		 ext entry options (variable);
       83 	dcl     thread$cin		 ext entry (ptr, bit (18));
       84 	dcl     thread$out		 ext entry (ptr, bit (18));
       85 
       86 	dcl     (addr, addrel, baseno, bin, bit, divide, fixed, hbound, max, null, ptr, rel, string, substr) builtin;
       87 
       88 /*  */
       89 
       90 	unthreaded = "0"b;				/* This is not the unthreaded entry */
       91 	no_pages = "0"b;
       92 	goto MAKE_SDW_COMMON;
       93 
       94 
       95 unthreaded: entry (a_segno, a_tsdw, a_astep, a_ptp);	/* Entry for unthreaded AST entry */
       96 
       97 	unthreaded = "1"b;
       98 	no_pages = "0"b;
       99 	goto MAKE_SDW_COMMON;
      100 
      101 no_pages: entry (a_segno, a_tsdw, a_astep, a_ptp);
      102 	no_pages = "1"b;
      103 	unthreaded = "0"b;				/* thread in ! */
      104 
      105 MAKE_SDW_COMMON:
      106 
      107 	sstp = addr (sst_seg$);
      108 	pvt_arrayp = addr (pvt$array);
      109 	sltp = addr (slt$);
      110 	sltep = addr (slt.seg (a_segno));		/* Set pointer to slt entry. */
      111 	asp = addr (abs_seg$);			/* Used to withdraw seg */
      112 
      113 	pdsno = fixed (baseno (addr (pds$)), 17);
      114 	dsegno = fixed (baseno (addr (dseg$)), 17);
      115 	pl1_ops_no = fixed (baseno (addr (pl1_operators_$end_pl1_operators)), 17);
      116 	pl1_ops_pages = divide (fixed (rel (addr (pl1_operators_$end_pl1_operators)), 18) + 1023, 1024, 17, 0);
      117 	error_table_no = fixed (baseno (addr (error_table_$)), 17);
      118 
      119 	namep = ptr (addr (name_table$), slte.names_ptr); /* get ptr to name */
      120 	do i = 1 to hbound (table_corresp, 1);		/* scan variable size table names */
      121 	     if table_corresp (i).slt_name = namep -> segnam.name (1)
      122 	     then do tbcp = null repeat (tbcp);		/* scan config deck for size spec */
      123 		     call config_$find (tbl_card_name, tbcp); /* get a card */
      124 		     if tbcp = null then go to no_card; /* no more in deck */
      125 		     do j = 1 to hbound (tbls_card.tbl_spec, 1); /* scan this card */
      126 			if tbls_card.tbl_name (j) = table_corresp (i).card_name then do;
      127 				pts, save_pts = tbls_card.cur_length (j); /* get length from card */
      128 				slte_uns.max_length =
      129 				     max (pts, slte_uns.max_length);
      130 				slte_uns.cur_length = pts; /* set from card */
      131 				go to got_pts;
      132 			     end;
      133 		     end;
      134 		end;
      135 	end;
      136 
      137 no_card:	pts = max (slte_uns.max_length, slte_uns.cur_length); /* get page table size */
      138 	if (pts = 0 | (slte.abs_seg & ^ no_pages)) & ^unthreaded then do; /* No aste for abs segs unless user insists */
      139 						/* If void seg, don't create unless forced */
      140 						/* Avoid routine creation of abs segs */
      141 		a_astep, a_ptp = null ();		/* Don't try using it */
      142 		a_tsdw = 0;			/* Quick segfault */
      143 		return;
      144 	     end;
      145 
      146 	if ^ slte.breakpointable & ^ no_pages & substr (slte_uns.access, 2, 1) then do;/* execute => breakpointable */
      147 	     slte_uns.breakpointable = "1"b;
      148 	     slte_uns.max_length = slte_uns.max_length + 1;
      149 	     slte_uns.cur_length = slte_uns.cur_length + 1;
      150 	     pts = pts + 1;
      151 	end;
      152 	save_pts = pts;
      153 
      154 got_pts:	do i = 3 to 0 by -1 while (sst.pts (i) >= pts);	/* find correct page table pool */
      155 	end;
      156 
      157 	ptsi = i + 1;
      158 	loopcnt = 0;				/* zero counter */
      159 	pts = sst.pts (ptsi);			/* specify page table size */
      160 
      161 	do astep = ptr (sstp, sst.ausedp (ptsi)) /* look for an ASTE for the segment */
      162 	     repeat ptr (sstp, aste.fp) /* skip to next ASTE for free one */
      163 	     while (aste.usedf & /* until it's free or */
      164 	     loopcnt <= fixed (sst.no_aste (ptsi), 17));	/* there are no more ASTE's */
      165 	     loopcnt = loopcnt + 1;			/* how many times through the loop */
      166 	end;
      167 
      168 	if loopcnt > fixed (sst.no_aste (ptsi), 18) then /* too many times; pool is empty */
      169 	     call syserr (1, "make_sdw: aste pool ^d too small", ptsi);
      170 
      171 	call thread$out (astep, sst.ausedp (ptsi));	/* thread the entry out of the used list */
      172 	do i = 0 to sst.astsize - 2;			/* zero the AST entry */
      173 	     astep -> bfword (i) = 0;
      174 	end;
      175 
      176 /*  */
      177 
      178 	aste.usedf = "1"b;				/* mark it as being used */
      179 	a_ptp = addrel (astep, sst.astsize);		/* get a pointer to the page table */
      180 
      181 	if slte.wired then do;			/* if this a temp wired seg */
      182 		if a_segno = pdsno then no_pages_wired = 1; /* wire first page of pds */
      183 		else if a_segno = dsegno then no_pages_wired = 1; /* wire first page of dseg */
      184 		else if a_segno = pl1_ops_no then no_pages_wired = pl1_ops_pages; /* wire just the first few pages */
      185 		else if a_segno = error_table_no then no_pages_wired = 1;
      186 		else no_pages_wired = save_pts;	/* otherwise wire all pages */
      187 		sst.wired = sst.wired + no_pages_wired;
      188 	     end;
      189 	else no_pages_wired = 0;
      190 
      191 	do i = 0 to pts - 1;			/* initialize the page table array for the entry */
      192 	     call ptw_util_$make_null (addrel (a_ptp, i), make_sdw_null_addr);
      193 	     if i < no_pages_wired then call ptw_util_$set_wired (addrel (a_ptp, i));
      194 	end;
      195 
      196 	if slte_uns.breakpointable then
      197 	     if no_pages_wired > 0 then do;		/* wired seg - use breakpoint_page */
      198 	          call ptw_util_$make_core (addrel (a_ptp, save_pts - 1), absadr (addr (breakpoint_page$), (0)));
      199 		call ptw_util_$set_wired (addrel (a_ptp, save_pts - 1));
      200 		if no_pages_wired = save_pts then sst.wired = sst.wired - 1;  /* wired was one too high from counting all pages as new wired pages */
      201 	     end;
      202 
      203 	if ^unthreaded				/* If threaded.. */
      204 	then if slte.temp_seg then call thread$cin (astep, sst.atempp);
      205 	     else if slte.branch_required then call thread$cin (astep, sst.ausedp (ptsi));
      206 	     else if slte.init_seg then call thread$cin (astep, sst.ainitp);
      207 	     else if slte.wired then do;		/* if this is wired then */
      208 		     unthreaded = "1"b;		/* don't thread it */
      209 		     aste.hc = "1"b;		/* and mark as hardcore */
      210 		end;
      211 	     else aste.hc = "1"b;
      212 
      213 	a_tsdw = get_ptrs_$given_astep (astep);		/* Get initial SDW, */
      214 	call sdw_util_$dissect (addr (a_tsdw), addr (sdwi)); /* and find out what's in it now */
      215 	sdwi.size = save_pts * 1024;			/* Set the size as appropriate for a paged segment */
      216 	string (sdwi.access) = slte.access;		/* Access from SLT entry */
      217 	if sys_info$system_type = L68_SYSTEM then /* And cache, if appropriate */
      218 	     sdwi.cache = slte.cache;
      219 	call sdw_util_$construct (addr (a_tsdw), addr (sdwi)); /* and put it all back together again */
      220 
      221 	aste.nqsw = "1"b;				/* turn on no quota switch */
      222 	aste.dnzp = "1"b;				/* never null hardcore pages */
      223 	aste.ddnp = "1"b;				/* Never report prewithdrawns to free */
      224 	aste.strp = bit (a_segno, 18);		/* store segment number in AST */
      225 	aste.ehs = "1"b;				/* Turn entry hold switch on if appropriate */
      226 	aste.hc_sdw = "1"b;				/* sdw for a hardcore seg so no trailer */
      227 	aste.vtocx = -1;				/* VTOCE-less segment */
      228 
      229 	a_astep = astep;
      230 
      231 /* If disk abs seg, don't attempt to prewithdraw pages. */
      232 
      233 	if no_pages then aste.csl, aste.records = bit (bin (slte_uns.cur_length, 9), 9);  /* so status_, et al, know about it */
      234 
      235 	if slte.abs_seg | no_pages then return;		/* If abs_seg forced, don't prewithdraw */
      236 						/* or if pages are to be supplied by the caller */
      237 
      238 /* Allocate a volume with a hardcore partition for the segment. */
      239 
      240 	if hcp_thread = 0 then do;			/* This gets interesting. */
      241 		if sst.root_pvtx = 0 then do;		/* PVT created before init-pvt */
      242 			aste.pvtx = -1;		/* Cause a fault if used. */
      243 			return;
      244 		     end;
      245 		call syserr (1, "make_sdw: no hardcore partitions available.");
      246 	     end;
      247 
      248 /* Allocate deciduous segments on root phys vol */
      249 	if slte.branch_required then do;
      250 		pvtx = sst.root_pvtx;
      251 		pvtep = addr (pvt_array (pvtx));
      252 		goto got_pvtx;
      253 	     end;
      254 
      255 	do pvtx = hcp_thread repeat pvte.brother_pvtx;
      256 	     pvtep = addr (pvt_array (pvtx));
      257 	     if pvte.nleft >= save_pts then go to got_pvtx;
      258 	     if pvte.brother_pvtx = hcp_thread then call syserr
      259 		     (1, "make_sdw: out of hardcore partition for ^a.", namep -> segnam.name (1));
      260 	end;
      261 got_pvtx:
      262 	hcp_thread = pvte.brother_pvtx;		/* Keep chain rotating */
      263 	aste.pvtx = pvtx;				/* This is where seg will go. */
      264 	aste.hc_part = "1"b;			/* Uses a hardcore partition */
      265 
      266 /* Touch all the pages, causing withdrawing nulled addresses against hc partition */
      267 
      268 	call pmut$swap_sdw (asp, addr (a_tsdw));
      269 	do i = 0 to save_pts - 1;			/* real cur length */
      270 	     dummy = asp -> seg (i * 1024);		/* touch for nulled withdraw */
      271 	end;
      272 
      273 	if slte.breakpointable then do;		/* set sentinel in bkpt_page (keeps page from being nulled) */
      274 	     sdwi.access.write = "1"b;
      275 	     call sdw_util_$construct (addr (temp_sdw), addr (sdwi)); /* force access */
      276 	     call pmut$swap_sdw (asp, addr (temp_sdw));
      277 	     addrel (asp, (save_pts - 1) * 1024) -> bkpt_page.sentinel = BKPT_page_sentinel;
      278 	end;
      279 
      280 	temp_sdw = 0;
      281 	call pmut$swap_sdw (asp, addr (temp_sdw));	/* clear slot */
      282 
      283 	return;
      284 
      285 
      286 /* Entries to manage allocation from the Hardcore Partition
      287*
      288*   thread_hcp adds a PVTE index to the thread
      289*
      290*   reset_hcp terminates allocation from the Hardcore Partition
      291**/
      292 
      293 thread_hcp:
      294      entry (a_pvtx);
      295 
      296 	pvt_arrayp = addr (pvt$array);
      297 	if hcp_thread = 0				/* This is the first pvtx */
      298 	then hcp_thread, hcp_first = a_pvtx;
      299 	else do;
      300 		pvt_array (hcp_thread).brother_pvtx = a_pvtx;
      301 		hcp_thread = a_pvtx;
      302 	     end;
      303 
      304 	pvt_array (a_pvtx).brother_pvtx = hcp_first;
      305 
      306 	return;
      307 
      308 
      309 reset_hcp:
      310      entry;
      311 
      312 	hcp_thread, hcp_first = 0;
      313 	return;
      314 
      315 
      316  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      316 
      317  /* BEGIN include file bce_breakpoint_page.incl.pl1 */
  2     2 
  2     3 /* Description of hardcore breakpoint information saved in breakpoint_page.
  2     4*Keith Loepere, December 1983. */
  2     5 /* Sentinel added, July 1984 by Keith Loepere. */
  2     6 
  2     7 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  2     8 
  2     9 dcl  1 bkpt_page		        aligned based (bkpt_page_ptr),
  2    10        2 header		        aligned,
  2    11          3 mc_		        aligned like mc,
  2    12          3 mode_reg		        bit (36) aligned,
  2    13          3 cache_mode_reg	        bit (36) aligned,
  2    14          3 dbr		        bit (72) aligned,
  2    15          3 bar		        bit (36) aligned,
  2    16          3 sentinel		        char (4) unal,
  2    17          3 pad		        (10) bit (36),
  2    18        2 bkpts		        (120) aligned like breakpoint;
  2    19 dcl  bkpt_page_ptr		        ptr;
  2    20 
  2    21 dcl  1 breakpoint		        aligned based (breakpoint_ptr),
  2    22        2 breakpoint_drl	        bit (36),		/* drl -1 => breakpoint */
  2    23        2 instructions	        (4) bit (36),
  2    24        2 tra_back_offset	        fixed bin (18) unal uns,
  2    25        2 tra_back		        bit (18) unal,	/* tra back to original code */
  2    26        2 original_instr_ptr	        ptr unal,		/* ptr to where original instruction was */
  2    27        2 original_instr	        bit (36);		/* real instruction moved */
  2    28 dcl  breakpoint_ptr		        ptr;
  2    29 
  2    30 dcl  BKPT_page_sentinel	        char (4) static options (constant) init ("bkpt");
  2    31 
  2    32 /* END include file bce_breakpoint_page.incl.pl1 */
      317 
      318  /*  */
  3     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  3     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  3     4 /* Modified 07/07/76 by Morris for fault register data */
  3     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  3     6 /* Modified '82 to make values constant */
  3     7 
  3     8 /* words 0-15 pointer registers */
  3     9 
  3    10 dcl  mcp ptr;
  3    11 
  3    12 dcl 1 mc based (mcp) aligned,
  3    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  3    14    (2 regs,					/* registers */
  3    15       3 x (0:7) bit (18),				/* index registers */
  3    16       3 a bit (36),					/* accumulator */
  3    17       3 q bit (36),					/* q-register */
  3    18       3 e bit (8),					/* exponent */
  3    19       3 pad1 bit (28),
  3    20       3 t bit (27),					/* timer register */
  3    21       3 pad2 bit (6),
  3    22       3 ralr bit (3),				/* ring alarm register */
  3    23 
  3    24     2 scu (0:7) bit (36),
  3    25 
  3    26     2 mask bit (72),				/* mem controller mask at time of fault */
  3    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  3    28     2 errcode fixed bin (35),				/* fault handler's error code */
  3    29     2 fim_temp,
  3    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  3    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  3    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  3    33     2 fault_reg bit (36),				/* fault register */
  3    34     2 pad2 bit (1),
  3    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  3    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  3    37     2 fault_time bit (54),				/* time of fault */
  3    38 
  3    39     2 eis_info (0:7) bit (36)) unaligned;
  3    40 
  3    41 
  3    42 dcl (apx fixed bin init (0),
  3    43      abx fixed bin init (1),
  3    44      bpx fixed bin init (2),
  3    45      bbx fixed bin init (3),
  3    46      lpx fixed bin init (4),
  3    47      lbx fixed bin init (5),
  3    48      spx fixed bin init (6),
  3    49      sbx fixed bin init (7)) internal static options (constant);
  3    50 
  3    51 
  3    52 
  3    53 
  3    54 dcl  scup ptr;
  3    55 
  3    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  3    57 
  3    58 
  3    59 /*	WORD (0)		*/
  3    60 
  3    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  3    62       3 prr bit (3),				/* procedure ring register */
  3    63       3 psr bit (15),				/* procedure segment register */
  3    64       3 p bit (1),					/* procedure privileged bit */
  3    65 
  3    66     2 apu,					/* APPENDING UNIT STATUS */
  3    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  3    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  3    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  3    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  3    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  3    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  3    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  3    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  3    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  3    76       3 ptw bit (1),				/* Fetch of PTW */
  3    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  3    78       3 fap bit (1),				/* Fetch of final address paged */
  3    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  3    80       3 fabs bit (1),				/* Fetch of final address absolute */
  3    81 
  3    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  3    83 
  3    84 
  3    85 /*	WORD (1)		*/
  3    86 
  3    87     2 fd,						/* FAULT  DATA */
  3    88       3 iro bit (1),				/* illegal ring order */
  3    89       3 oeb bit (1),				/* out of execute bracket */
  3    90       3 e_off bit (1),				/* no execute */
  3    91       3 orb bit (1),				/* out of read bracket */
  3    92       3 r_off bit (1),				/* no read */
  3    93       3 owb bit (1),				/* out of write bracket */
  3    94       3 w_off bit (1),				/* no write */
  3    95       3 no_ga bit (1),				/* not a gate */
  3    96       3 ocb bit (1),				/* out of call bracket */
  3    97       3 ocall bit (1),				/* outward call */
  3    98       3 boc bit (1),				/* bad outward call */
  3    99       3 inret bit (1),				/* inward return */
  3   100       3 crt bit (1),				/* cross ring transfer */
  3   101       3 ralr bit (1),				/* ring alarm register */
  3   102       3 am_er bit (1),				/* associative memory fault */
  3   103       3 oosb bit (1),				/* out of segment bounds */
  3   104       3 paru bit (1),				/* processor parity upper */
  3   105       3 parl bit (1),				/* processor parity lower */
  3   106       3 onc_1 bit (1),				/* op not complete type 1 */
  3   107       3 onc_2 bit (1),				/* op not complete type 2 */
  3   108 
  3   109     2 port_stat,					/* PORT  STATUS */
  3   110       3 ial bit (4),				/* illegal action lines */
  3   111       3 iac bit (3),				/* illegal action channel */
  3   112       3 con_chan bit (3),				/* connect channel */
  3   113 
  3   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  3   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  3   116 
  3   117 
  3   118 /*	WORD (2)		*/
  3   119 
  3   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  3   121       3 trr bit (3),				/* temporary ring register */
  3   122       3 tsr bit (15),				/* temporary segment register */
  3   123 
  3   124     2 pad2 bit (9),
  3   125 
  3   126     2 cpu_no bit (3),				/* CPU number */
  3   127 
  3   128     2 delta bit (6),				/* tally modification DELTA */
  3   129 
  3   130 
  3   131 /*	WORD (3)		*/
  3   132 
  3   133     2 word3 bit (18),
  3   134 
  3   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  3   136       3 tsna,					/* Word 1 status */
  3   137         4 prn bit (3),				/* Word 1  PR  number */
  3   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  3   139       3 tsnb,					/* Word 2  status */
  3   140         4 prn bit (3),				/* Word 2  PR  number */
  3   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  3   142       3 tsnc,					/* Word 3  status */
  3   143         4 prn bit (3),				/* Word 3  PR  number */
  3   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  3   145 
  3   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  3   147 
  3   148 
  3   149 /* 	WORD (4)		*/
  3   150 
  3   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  3   152 
  3   153     2 ir,						/* INDICATOR  REGISTERS */
  3   154       3 zero bit (1),				/* zero indicator */
  3   155       3 neg bit (1),				/* negative indicator */
  3   156       3 carry bit (1),				/* carryry indicator */
  3   157       3 ovfl bit (1),				/* overflow indicator */
  3   158       3 eovf bit (1),				/* eponent overflow */
  3   159       3 eufl bit (1),				/* exponent underflow */
  3   160       3 oflm bit (1),				/* overflow mask */
  3   161       3 tro bit (1),				/* tally runout */
  3   162       3 par bit (1),				/* parity error */
  3   163       3 parm bit (1),				/* parity mask */
  3   164       3 bm bit (1),					/* ^bar mode */
  3   165       3 tru bit (1),				/* truncation mode */
  3   166       3 mif bit (1),				/* multi-word instruction mode */
  3   167       3 abs bit (1),				/* absolute mode */
  3   168       3 hex bit (1),				/* hexadecimal exponent mode */
  3   169       3 pad bit (3),
  3   170 
  3   171 
  3   172 /*	WORD (5)		*/
  3   173 
  3   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  3   175 
  3   176     2 cu,						/* CONTROL UNIT STATUS */
  3   177       3 rf bit (1),					/* on first cycle of repeat instr */
  3   178       3 rpt bit (1),				/* repeat instruction */
  3   179       3 rd bit (1),					/* repeat double instruction */
  3   180       3 rl bit (1),					/* repeat link instruciton */
  3   181       3 pot bit (1),				/* IT  modification */
  3   182       3 pon bit (1),				/* return type instruction */
  3   183       3 xde bit (1),				/* XDE from Even location */
  3   184       3 xdo bit (1),				/* XDE from Odd  location */
  3   185       3 poa bit (1),				/* operation preparation */
  3   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  3   187       3 its bit (1),				/* ITS modification */
  3   188       3 if bit (1),					/* fault occured during instruction fetch */
  3   189 
  3   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  3   191 
  3   192 
  3   193 /*	WORDS (6,7)	*/
  3   194 
  3   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  3   196 
  3   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  3   198 
  3   199 
  3   200 
  3   201 
  3   202 
  3   203 
  3   204 /*	ALTERNATE   SCU  DECLARATION		*/
  3   205 
  3   206 
  3   207 dcl 1 scux based (scup) aligned,
  3   208 
  3   209    (2 pad0 bit (36),
  3   210 
  3   211     2 fd,						/* GROUP II  FAULT DATA */
  3   212       3 isn bit (1),				/* illegal segment number */
  3   213       3 ioc bit (1),				/* illegal op  code  */
  3   214       3 ia_am bit (1),				/* illegal address - modifier */
  3   215       3 isp bit (1),				/* illegal slave  procedure */
  3   216       3 ipr bit (1),				/* illegal procedure */
  3   217       3 nea bit (1),				/* non existent address */
  3   218       3 oobb bit (1),				/* out of bounds */
  3   219       3 pad bit (29),
  3   220 
  3   221     2 pad2 bit (36),
  3   222 
  3   223     2 pad3a bit (18),
  3   224 
  3   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  3   226       3 prn bit (3),				/* PR  number */
  3   227       3 prv bit (1),				/* PR  valid bit */
  3   228 
  3   229     2 pad3b bit (6)) unaligned,
  3   230 
  3   231     2 pad45 (0:1) bit (36),
  3   232 
  3   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  3   234 
  3   235 
  3   236 
  3   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      318 
      319  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  4     2 /* Added segmove values, Benson Margulies, 84-01 */
  4     3 
  4     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  4     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  4     6      get_aste_null_addr init			("3770110"b3),
  4     7      make_sdw_null_addr init			("3770120"b3),
  4     8      put_aste_null_addr init			("3770130"b3),
  4     9      page_bad_pd_null_addr init		("3770150"b3),
  4    10      list_deposit_null_addr init		("3770160"b3),
  4    11      get_file_map_null_addr init		("3770170"b3),
  4    12      fill_page_table_null_addr init		("3770200"b3),
  4    13      init_sst_null_addr init			("3770210"b3),
  4    14      get_file_map_vt_null_addr init		("3770220"b3),
  4    15      unprotected_null_addr init		("3770230"b3),
  4    16      page_bad_null_addr init			("3770240"b3),
  4    17      page_problem_null_addr init		("3770250"b3),
  4    18      page_parity_null_addr init		("3770260"b3),
  4    19      page_devparity_null_addr init		("3770270"b3),
  4    20      segmove_old_addr_null_addr init              ("3770300"b3),
  4    21      segmove_new_addr_null_addr init		("3770310"b3),
  4    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  4    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  4    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  4    25 
  4    26 dcl (create_vtoce_null_addr init		("777777"b3),
  4    27      update_vtoce_null_addr init		("777776"b3),
  4    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  4    29      truncate_vtoce_null_addr init		("777002"b3),
  4    30      pv_salv_null_addr init			("777004"b3),
  4    31      pv_scav_null_addr init			("777006"b3),
  4    32      volume_reloader_null_addr init		("777774"b3),
  4    33      volume_retriever_null_addr init		("777773"b3),
  4    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  4    35 
  4    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
      319 
      320  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  5     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  5     8*     Add the support for subvolumes
  5     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  5    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  5    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  5    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5    14*     Added inconsistent_dbm bit for determining the status of volume
  5    15*     dumper bit maps.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18      dcl	   pvt$array	      aligned external;
  5    19      dcl	   pvt$max_n_entries      fixed bin external;
  5    20 
  5    21      dcl	   pvt_arrayp	      ptr;
  5    22      dcl	   pvtep		      ptr;
  5    23 
  5    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  5    25 
  5    26      dcl	   1 pvte		      based (pvtep) aligned,
  5    27 
  5    28 	     2 pvid	      bit (36),		/* physical volume ID */
  5    29 
  5    30 	     2 lvid	      bit (36),		/* logical volume ID */
  5    31 
  5    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  5    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  5    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  5    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  5    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  5    37 	     2 pad3	      bit (2) unaligned,
  5    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  5    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  5    40 
  5    41 
  5    42 
  5    43 	     2 devname	      char (4),		/* device name */
  5    44 
  5    45 	     (2 device_type	      fixed bin (8),	/* device type */
  5    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  5    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  5    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  5    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  5    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  5    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  5    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  5    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  5    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  5    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  5    56 	     2 scav_check_address
  5    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  5    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  5    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  5    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  5    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  5    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  5    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  5    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  5    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  5    66 
  5    67 
  5    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  5    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  5    70 
  5    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  5    72 
  5    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  5    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  5    75 
  5    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  5    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  5    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  5    79 	     2 records_per_cyl    fixed bin,
  5    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  5    81 	     2 sv_name            char (2) aligned,
  5    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  5    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  5    84 
  5    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  5    86 	     2 pad2	      bit (18) unaligned,
  5    87 
  5    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  5    89 
  5    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  5    91 
  5    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  5    93 
  5    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  5    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  5    96 
  5    97 
  5    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  5    99 
  5   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  5   101 
  5   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  5   103 
  5   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  5   105 
  5   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  5   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  5   108 
  5   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  5   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  5   111 
  5   112 
  5   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  5   114 	   VOLMAP_ASYNC_READ      init (1),
  5   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  5   116 
  5   117 
  5   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      320 
      321  /* BEGIN INCLUDE FILE ... sdw_info.incl.pl1 ... 12/16/80, for ADP conversion */
  6     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  6     3 
  6     4 dcl  sdw_info_ptr pointer;
  6     5 
  6     6 dcl 1 sdw_info aligned based (sdw_info_ptr),		/* Structure describing SDW contents */
  6     7     2 address fixed bin (26), 			/* Address of seg base or of page table */
  6     8     2 size fixed bin (19),				/* Max length of segment (NOT offset of last word) */
  6     9 
  6    10     2 access unaligned,				/* REWP */
  6    11       3 read bit (1) unaligned,
  6    12       3 execute bit (1) unaligned,
  6    13       3 write bit (1) unaligned,
  6    14       3 privileged bit (1) unaligned,
  6    15 
  6    16     2 pad1 bit (32) unaligned,
  6    17 
  6    18     2 rings unaligned,				/* Ring brackets */
  6    19       3 r1 bit (3) unaligned,
  6    20       3 r2 bit (3) unaligned,
  6    21       3 r3 bit (3) unaligned,
  6    22 
  6    23     2 pad2 bit (27) unaligned,
  6    24 
  6    25     2 flags aligned,
  6    26       3 paged bit (1) unaligned,			/* "1"b => Segment is paged */
  6    27       3 faulted bit (1) unaligned,			/* "1"b => SDW has fault set */
  6    28       3 cache bit (1) unaligned,			/* "1"b => Segment is encacheable */
  6    29       3 pad3 bit (33) unaligned,
  6    30 
  6    31     2 gate_entry_bound fixed bin (14);			/* Number of entrypoints in gate, or zero */
  6    32 
  6    33 /* END INCLUDE FILE ... sdw_info.incl.pl1 */
      321 
      322  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  7     2 
  7     3 /* Declarations for Segment Loading Table header and array.
  7     4*
  7     5*   Used by Initialization and MST Checker subroutines */
  7     6 
  7     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  7     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  7     9     namep ptr,					/* pointer to segment name list block */
  7    10     pathp ptr,					/* pointer to segment's directory path name */
  7    11     aclp ptr;					/* pointer to acl structure */
  7    12 
  7    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  7    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  7    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  7    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  7    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  7    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  7    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  7    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  7    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  7    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  7    23 
  7    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  7    25 
  7    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  7    27 	2 pad bit (18) unal,
  7    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  7    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  7    30 
  7    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  7    32 	2 count fixed bin (17),			/* number of segment names in this block */
  7    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  7    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  7    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  7    36 	  3 pad bit (5) unal,
  7    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  7    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  7    39 
  7    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  7    41 	2 size fixed bin (17),			/* length of pathname */
  7    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  7    43 	2 acls fixed bin;				/* ACL list starts here */
  7    44 
  7    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  7    46 	2 count fixed bin,				/* number of entries in acl list */
  7    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  7    48 	  3 userid char (32),			/* user specification */
  7    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  7    50 	  3 pad bit (36) aligned,
  7    51 	  3 code fixed bin;
  7    52 
  7    53 
  7    54 /* END INCLUDE FILE slt.incl.pl1 */
      322 
      323  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  8     2 /* Declaration for Segment Loading Table Entry structure.
  8     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  8     4 /* modified 5/4/76 by Noel I. Morris	*/
  8     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  8     6 /* format: style3 */
  8     7 
  8     8 dcl	sltep		ptr;
  8     9 
  8    10 dcl	1 slte_uns	based (sltep) aligned,
  8    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  8    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  8    13 /**** End of word 1 */
  8    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  8    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  8    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  8    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  8    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  8    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  8    20 	  2 pad1		bit (3),			/* unused */
  8    21 	  2 wired		bit (1),			/* segment is wired if ON */
  8    22 	  2 paged		bit (1),			/* segment is paged if ON */
  8    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  8    24 	  2 pad3		bit (2),
  8    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  8    26 /**** End of 1st half of word 2 */
  8    27 	  2 pad4		bit (3),
  8    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  8    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  8    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  8    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  8    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  8    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  8    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  8    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  8    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  8    37 /***** End of word 2 */
  8    38 	  2 pad5		bit (6),
  8    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  8    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  8    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  8    42 /***** End of word 3 */
  8    43 	  2 pad7		bit (3),
  8    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  8    45 	  2 bit_count	fixed bin (24) uns
  8    46 	  )		unaligned;		/* bitcount of segment */
  8    47 
  8    48 dcl	1 slte		based (sltep) aligned,
  8    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  8    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  8    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  8    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  8    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  8    54 	  2 firmware_seg    bit (1),
  8    55 	  2 layout_seg      bit (1),
  8    56 	  2 breakpointable  bit (1),
  8    57 	  2 pad2		bit (3),
  8    58 	  2 wired		bit (1),			/* segment is wired if ON */
  8    59 	  2 paged		bit (1),			/* segment is paged if ON */
  8    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  8    61 	  2 pad3		bit (2),
  8    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  8    63 	  2 pad4		bit (3),
  8    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  8    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  8    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  8    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  8    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  8    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  8    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  8    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  8    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  8    73 	  2 pad5		bit (6),
  8    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  8    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  8    76 	  2 segno		bit (18),			/* text/link segment number */
  8    77 	  2 pad6		bit (3),
  8    78 	  2 max_length	bit (9),			/* maximum length for segment */
  8    79 	  2 bit_count	bit (24)
  8    80 	  )		unaligned;		/* bitcount of segment */
  8    81 
  8    82 /* END INCLUDE FILE slte.incl.pl1 */
      323 
      324  /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  9     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  9     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  9     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  9     5 
  9     6 dcl  sst_seg$ external;
  9     7 dcl  sstp ptr;
  9     8 
  9     9 dcl 1 sst based (sstp) aligned,
  9    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  9    11 
  9    12 /* SST HEADER */
  9    13 
  9    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  9    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  9    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  9    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  9    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  9    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  9    20 
  9    21     2 ptl bit (36),					/* global page table loop lock */
  9    22     2 astl bit (36),				/* global ast allocation block lock */
  9    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  9    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  9    25     2 nused fixed bin,				/* number of pages on used list */
  9    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  9    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  9    28 
  9    29     2 astap ptr,					/* aste array pointer */
  9    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  9    31     2 astsize fixed bin,				/* size of an AST entry */
  9    32     2 cmesize fixed bin,				/* size of a CME entry */
  9    33     2 root_astep ptr,				/* pointer to the root AST entry */
  9    34 
  9    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  9    36     2 level (0:3),					/* per-list information about ASTE's */
  9    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  9    38 
  9    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  9    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  9    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  9    42     2 strsize fixed bin,				/* Trailer size in words. */
  9    43 
  9    44 /* CORE MAP HEADER */
  9    45 
  9    46     2 cmp ptr,					/* pointer to start of core map */
  9    47     2 usedp bit (18),				/* pointer to first used core block */
  9    48     2 wtct fixed bin,				/* count of pages being written */
  9    49 
  9    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  9    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  9    52 						/* MISC */
  9    53 
  9    54     2 double_write fixed bin,				/* trigger for store through scheme */
  9    55 						/* 0 = no double writes,
  9    56*						   1 = all non-pd pages get written,
  9    57*						   2 = all directories get written */
  9    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  9    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  9    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  9    61 
  9    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  9    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  9    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  9    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  9    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  9    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  9    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  9    69 
  9    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  9    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  9    72 
  9    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  9    74 
  9    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  9    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  9    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  9    78 
  9    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  9    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  9    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  9    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  9    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  9    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  9    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  9    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  9    87 
  9    88 
  9    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  9    90 
  9    91     2 steps fixed bin,				/* number of steps taken around used list */
  9    92     2 needc fixed bin,				/* number of times core page needed */
  9    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  9    94     2 ctwait fixed bin,				/* number of times write counter was full */
  9    95     2 wired fixed bin,				/* number of pages wired by pc */
  9    96     2 laps fixed bin,				/* number of times around used list */
  9    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  9    98     2 skipu fixed bin,				/* because of being used */
  9    99 
  9   100     2 skipm fixed bin,				/* because of being modified */
  9   101     2 skipos fixed bin,				/* because out of service */
  9   102     2 aused fixed bin,				/* number of AST entries on used list */
  9   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  9   104     2 deact_count fixed bin,				/* count of deactivations */
  9   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  9   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  9   107 
  9   108     2 reads (8) fixed bin,				/* number of reads for each did */
  9   109     2 writes (8) fixed bin,				/* number of writes for each did */
  9   110 
  9   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  9   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  9   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  9   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  9   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  9   116     2 total_sf fixed bin,				/* total number of seg_faults */
  9   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  9   118     2 post_list_size fixed bin,
  9   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  9   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  9   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  9   122     2 pre_page_list_size fixed bin,
  9   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  9   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  9   125 
  9   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  9   127 
  9   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  9   129 
  9   130 /* MAIN MEMORY USAGE INFORMATION */
  9   131 
  9   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  9   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  9   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  9   135     2 recopies fixed bin,				/* number of times recopied because modified */
  9   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  9   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  9   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  9   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  9   140 
  9   141 /*  AST METERS  */
  9   142 
  9   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  9   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  9   145 
  9   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  9   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  9   148     2 asearches fixed bin,				/* count of full searches made */
  9   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  9   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  9   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  9   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  9   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  9   154 
  9   155     2 alaps fixed bin,				/* lap counter for AST list */
  9   156     2 updates fixed bin,				/* calls to updateb */
  9   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  9   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  9   159     2 total_bf fixed bin,				/* count of bound faults */
  9   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  9   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  9   162 
  9   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  9   164 
  9   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  9   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  9   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  9   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  9   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  9   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  9   171 
  9   172 /* PRE-PAGE METERS */
  9   173 
  9   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  9   175 
  9   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  9   177 
  9   178 
  9   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  9   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  9   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  9   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  9   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  9   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  9   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  9   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  9   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  9   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  9   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  9   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  9   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  9   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  9   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  9   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  9   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  9   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  9   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  9   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  9   199     2 activations fixed bin,				/* total count of activations */
  9   200     2 dir_activations fixed bin,			/* count of directory activations */
  9   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  9   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  9   203     2 evict_recover_data,				/* see evict_page.alm */
  9   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  9   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  9   206 
  9   207 /* Data for metering force_write facility 08/19/78 */
  9   208 
  9   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  9   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  9   211     2 fw_none fixed bin,				/* Force write wrote none */
  9   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  9   213 
  9   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  9   215     2 pf_unlock_ptl_meterings fixed bin,
  9   216 
  9   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  9   218     2 backup_activations fixed bin (35),		/* activations for backup */
  9   219     2 metering_flags aligned,				/* small chunks of misc. information */
  9   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  9   221       3 pad bit (35) unal,
  9   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  9   223 
  9   224 /* METERS FOR STACK TRUNCATION */
  9   225 
  9   226     2 (stk_truncate_should_didnt,			/* counts */
  9   227        stk_truncate_should_did,
  9   228        stk_truncate_shouldnt_didnt,
  9   229        stk_truncate_shouldnt_did) fixed bin (35),
  9   230     2 stk_pages_truncated fixed bin (35),
  9   231     2 stk_pages_truncated_in_core fixed bin (35),
  9   232 
  9   233 /* SUPPORT FOR PC SEGMOVES */
  9   234 
  9   235     2 segmove_lock aligned,
  9   236       3 pid bit (36) aligned,
  9   237       3 event bit (36) aligned,
  9   238       3 notify bit (1) aligned,
  9   239     2 segmove_io_limit fixed bin, /* max read aheads */
  9   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  9   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  9   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  9   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  9   244 
  9   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  9   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  9   247     2 segmove_vtocx fixed bin,			/* ditto */
  9   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  9   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  9   250 
  9   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  9   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  9   253     2 trace_sw aligned,				/* tracing control flags */
  9   254       3 pad_trace bit (32) unaligned,
  9   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  9   256       3 tty_trace bit (1) unaligned,
  9   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  9   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  9   259     2 new_pages fixed bin,				/* newly created pages */
  9   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  9   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  9   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  9   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  9   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  9   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  9   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  9   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  9   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  9   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  9   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  9   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  9   272 
  9   273 /* END INCLUDE FILE sst.incl.pl1 */
      324 
      325  /* BEGIN INCLUDE FILE ... system_types.incl.pl1 ... 03/23/81 ... W. Olin Sibert */
 10     2 
 10     3 dcl  L68_SYSTEM	fixed bin (17) internal static options (constant) init (1);
 10     4 dcl  ADP_SYSTEM	fixed bin (17) internal static options (constant) init (2);
 10     5 
 10     6 dcl  SYSTEM_TYPE_NAME (2) char (8) internal static options (constant) init
 10     7     ("Level68", "ADP");
 10     8 
 10     9 /* END INCLUDE FILE ... system_types.incl.pl1 */
      325 
      326  /* Begin Include File   variable_tables.incl.pl1 */
 11     2 
 11     3 /* This include file defines the system tables and data areas
 11     4*   whose size may be specified by the  TBLS config card. */
 11     5 
 11     6 dcl  tbcp pointer, tbl_card_name char (4) aligned static init ("tbls");
 11     7 
 11     8 dcl 1 tbls_card based (tbcp),
 11     9     2 name char (4),
 11    10     2 tbl_spec (7),					/* array of pairs */
 11    11       3 tbl_name char (4),				/* short name for table */
 11    12       3 cur_length fixed bin;				/* length in pages */
 11    13 
 11    14 dcl 1 table_corresp (5) static,			/* correspondence between slt and card names */
 11    15     2 slt_name char (32) init ("str_seg", "ioat", "kst_seg", "prds", "scavenger_data"),
 11    16     2 card_name char (4) init ("str", "ioat", "kst", "prds", "scav");
 11    17 
 11    18 /* End include file  variable_tables.incl.pl1 */
      326 
      327 
      328 /*  */
      329 
      330 /* BEGIN MESSAGE DOCUMENTATION
      331*
      332*   Message:
      333*   make_sdw: XXXk ast pool to small.
      334*
      335*   S: $crash
      336*
      337*   T: $init
      338*
      339*   M: There were not enough AST entries of size XXX k to allocate
      340*   the permanent AST entries of the supervisor.
      341*
      342*   A: Increase the number of AST entries of that size, as specified on
      343*   the SST CONFIG card, substantially, and reboot.
      344*
      345*   Message:
      346*   make_sdw: no hardcore partitions available.
      347*
      348*   S: $crash
      349*
      350*   T: $init
      351*
      352*   M: No hardcore partitions were defined on any of the packs on the drives
      353*   specified by the ROOT CONFIG card. At least the RPV must have a hardcore
      354*   partition.  Supervisor segments cannot be created.
      355*
      356*   A: If this is a cold boot, which is most likely, the RPV was
      357*   initialized without a hardcore partition.  It must be reinitialized.
      358*   Check the PART HC CONFIG card, one of which must describe the RPV
      359*   during a cold boot, and reboot.  If this is not a cold boot, the RPV
      360*   has been damaged, and volume recovery must be undertaken.
      361*
      362*   Message:
      363*   make_sdw: out of hardcore partition for SEGNAME.
      364*
      365*   S: $crash
      366*
      367*   T: $init
      368*
      369*   M: In attempting to allocate space for hardcore segment SEGNAME, no
      370*   more room could be found in any of the defined hardcore partitions.
      371*
      372*   A: If this is a cold boot, redefine the hardcore partition of the RPV
      373*   to be larger.  At least 1000 (decimal) records is recommended.  Change
      374*   the PART HC CONFIG card describing the RPV to indicate this, and
      375*   reboot.  If this is not a cold boot, this situation is highly unlikely
      376*   and indicates damage to one or more RLV volume labels.  Volume
      377*   recovery for part or all of the RLV should be undertaken.
      378*
      379*   END MESSAGE DOCUMENTATION */
      380 
      381      end make_sdw;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.1  make_sdw.pl1                      >spec>install>1110>make_sdw.pl1
316          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
317          2    11/18/84  1346.2  bce_breakpoint_page.incl.pl1      >ldd>include>bce_breakpoint_page.incl.pl1
318          3    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
319          4    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
320          5    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
321          6    03/27/82  0430.3  sdw_info.incl.pl1                 >ldd>include>sdw_info.incl.pl1
322          7    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
323          8    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
324          9    01/30/85  1523.9  sst.incl.pl1                      >ldd>include>sst.incl.pl1
325         10    06/19/81  2115.0  system_types.incl.pl1             >ldd>include>system_types.incl.pl1
326         11    10/25/82  1015.6  variable_tables.incl.pl1          >ldd>include>variable_tables.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BKPT_page_sentinel              000056 constant        char(4)                  initial packed unaligned dcl 2-30 ref 277
L68_SYSTEM                             constant        fixed bin(17,0)          initial dcl 10-3 ref 217
a_astep                                parameter       pointer                  dcl 39 set ref 10 95 101 141* 229*
a_ptp                                  parameter       pointer                  dcl 38 set ref 10 95 101 141* 179* 192 192 193 193
                                                                                  198 198 199 199
a_pvtx                                 parameter       fixed bin(17,0)          dcl 40 ref 293 297 300 301 304
a_segno                                parameter       fixed bin(18,0)          dcl 36 ref 10 95 101 110 182 183 184 185 224
a_tsdw                                 parameter       fixed bin(71,0)          dcl 37 set ref 10 95 101 142* 213* 214 214 219 219
                                                                                  268 268
abs_seg                   1(05)        based           bit(1)                   level 2 packed packed unaligned dcl 8-48 ref 138 235
abs_seg$                        000014 external static fixed bin(17,0)          dcl 62 set ref 111
absadr                          000036 constant        entry                    external dcl 73 ref 198 198
access                    1            based           bit(4)                   level 2 in structure "slte_uns" packed packed
                                                                                  unaligned dcl 8-10 in procedure "make_sdw" ref 146
access                    2     000125 automatic       structure                level 2 in structure "sdwi" packed packed unaligned
                                                                                  dcl 54 in procedure "make_sdw" set ref 216*
access                    1            based           bit(4)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 8-48 in procedure "make_sdw" ref 216
addr                                                   builtin function         dcl 86 ref 105 108 109 110 111 113 114 115 116 117
                                                                                  119 198 198 198 198 214 214 214 214 219 219 219
                                                                                  219 251 256 268 268 275 275 275 275 276 276 281
                                                                                  281 296
addrel                                                 builtin function         dcl 86 ref 179 192 192 193 193 198 198 199 199 277
ainitp                   52            based           bit(18)                  level 2 packed packed unaligned dcl 9-9 set ref 206*
asp                             000116 automatic       pointer                  dcl 48 set ref 111* 268* 270 276* 277 281*
aste                                   based           structure                level 1 dcl 1-11
astep                           000134 automatic       pointer                  dcl 1-9 set ref 161* 161* 166 171* 173 178 179 203*
                                                                                  205* 206* 209 211 213* 221 222 223 224 225 226 227
                                                                                  229 233 233 242 263 264
astsize                  33            based           fixed bin(17,0)          level 2 dcl 9-9 ref 172 179
atempp                   50            based           bit(18)                  level 2 packed packed unaligned dcl 9-9 set ref 203*
ausedp                   44            based           bit(18)                  array level 3 packed packed unaligned dcl 9-9 set
                                                                                  ref 161 171* 205*
baseno                                                 builtin function         dcl 86 ref 113 114 115 117
bfword                                 based           fixed bin(17,0)          array dcl 57 set ref 173*
bin                                                    builtin function         dcl 86 ref 233
bit                                                    builtin function         dcl 86 ref 224 233
bkpt_page                              based           structure                level 1 dcl 2-9
branch_required           1(21)        based           bit(1)                   level 2 packed packed unaligned dcl 8-48 ref 205 249
breakpoint                             based           structure                level 1 dcl 2-21
breakpoint_page$                000016 external static fixed bin(17,0)          dcl 63 set ref 198 198 198 198
breakpointable            1(08)        based           bit(1)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 8-48 in procedure "make_sdw" ref 146 273
breakpointable            1(08)        based           bit(1)                   level 2 in structure "slte_uns" packed packed
                                                                                  unaligned dcl 8-10 in procedure "make_sdw" set ref
                                                                                  147* 196
brother_pvtx              2(09)        based           fixed bin(8,0)           array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 5-24 in procedure "make_sdw" set ref
                                                                                  300* 304*
brother_pvtx              2(09)        based           fixed bin(8,0)           level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 5-26 in procedure "make_sdw" ref 258 260 261
cache                     1(04)        based           bit(1)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 8-48 in procedure "make_sdw" ref 217
cache                     4(02) 000125 automatic       bit(1)                   level 3 in structure "sdwi" packed packed unaligned
                                                                                  dcl 54 in procedure "make_sdw" set ref 217*
card_name                10     000000 constant        char(4)                  initial array level 2 packed packed unaligned
                                                                                  dcl 11-14 ref 126
config_$find                    000040 constant        entry                    external dcl 74 ref 123
csl                      12            based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  233*
cur_length                2            based           fixed bin(17,0)          array level 3 in structure "tbls_card" dcl 11-8
                                                                                  in procedure "make_sdw" ref 127
cur_length                2            based           fixed bin(9,0)           level 2 in structure "slte_uns" packed packed
                                                                                  unsigned unaligned dcl 8-10 in procedure
                                                                                  "make_sdw" set ref 130* 137 149* 149 233
ddnp                     12(15)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  223*
divide                                                 builtin function         dcl 86 ref 116
dnzp                     12(13)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  222*
dseg$                           000020 external static fixed bin(17,0)          dcl 64 set ref 114
dsegno                          000102 automatic       fixed bin(17,0)          dcl 42 set ref 114* 183
dummy                           000115 automatic       fixed bin(17,0)          dcl 47 set ref 270*
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  225*
error_table_$                   000032 external static fixed bin(17,0)          dcl 70 set ref 117
error_table_no                  000100 automatic       fixed bin(17,0)          dcl 42 set ref 117* 185
fixed                                                  builtin function         dcl 86 ref 113 114 115 116 117 161 168
flags                     4     000125 automatic       structure                level 2 dcl 54
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 166
get_ptrs_$given_astep           000042 constant        entry                    external dcl 75 ref 213
hbound                                                 builtin function         dcl 86 ref 120 125
hc                        5(04)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  209* 211*
hc_part                   5(11)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  264*
hc_sdw                    5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  226*
hcp_first                       000011 internal static fixed bin(17,0)          initial dcl 60 set ref 297* 304 312*
hcp_thread                      000010 internal static fixed bin(17,0)          initial dcl 59 set ref 240 255 258 261* 297 297* 300
                                                                                  301* 312*
header                                 based           structure                level 2 dcl 2-9
i                               000121 automatic       fixed bin(17,0)          dcl 50 set ref 120* 121 126* 154* 154* 157 172* 173*
                                                                                  191* 192 192 193 193 193* 269* 270*
init_seg                  1(22)        based           bit(1)                   level 2 packed packed unaligned dcl 8-48 ref 206
j                               000122 automatic       fixed bin(17,0)          dcl 50 set ref 125* 126 127*
level                    44            based           structure                array level 2 dcl 9-9
loopcnt                         000107 automatic       fixed bin(17,0)          dcl 43 set ref 158* 161 165* 165 168
make_sdw_null_addr              000055 constant        bit(22)                  initial dcl 4-4 set ref 192*
max                                                    builtin function         dcl 86 ref 128 137
max_length                3(03)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 8-10
                                                                                  set ref 128* 128 137 148* 148
mc                                     based           structure                level 1 dcl 3-12
name                      2            based           char(32)                 array level 3 packed packed unaligned dcl 7-31 set
                                                                                  ref 121 258*
name_table$                     000022 external static fixed bin(17,0)          dcl 65 set ref 119
namep                           000144 automatic       pointer                  dcl 7-7 set ref 119* 121 258
names                     1            based           structure                array level 2 dcl 7-31
names_ptr                              based           bit(18)                  level 2 packed packed unaligned dcl 8-48 ref 119
nleft                     7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-26 ref 257
no_aste                  44(18)        based           bit(18)                  array level 3 packed packed unaligned dcl 9-9 ref
                                                                                  161 168
no_pages                        000124 automatic       bit(1)                   dcl 52 set ref 91* 98* 102* 138 146 233 235
no_pages_wired                  000105 automatic       fixed bin(17,0)          dcl 42 set ref 182* 183* 184* 185* 186* 187 189* 193
                                                                                  196 200
nqsw                      5(20)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  221*
null                                                   builtin function         dcl 86 ref 121 124 141
pds$                            000024 external static fixed bin(17,0)          dcl 66 set ref 113
pdsno                           000101 automatic       fixed bin(17,0)          dcl 42 set ref 113* 182
pl1_operators_$end_pl1_operators
                                000030 external static fixed bin(17,0)          dcl 69 set ref 115 116
pl1_ops_no                      000103 automatic       fixed bin(17,0)          dcl 42 set ref 115* 184
pl1_ops_pages                   000104 automatic       fixed bin(17,0)          dcl 42 set ref 116* 184
pmut$swap_sdw                   000044 constant        entry                    external dcl 76 ref 268 276 281
ptr                                                    builtin function         dcl 86 ref 119 161 166
pts                      40            based           fixed bin(17,0)          array level 2 in structure "sst" dcl 9-9
                                                                                  in procedure "make_sdw" ref 154 159
pts                             000120 automatic       fixed bin(9,0)           dcl 49 in procedure "make_sdw" set ref 127* 128 130
                                                                                  137* 138 150* 150 152 154 159* 191
ptsi                            000106 automatic       fixed bin(17,0)          dcl 43 set ref 157* 159 161 161 168 168* 171 205
ptw_util_$make_core             000046 constant        entry                    external dcl 77 ref 198
ptw_util_$make_null             000050 constant        entry                    external dcl 78 ref 192
ptw_util_$set_wired             000052 constant        entry                    external dcl 79 ref 193 199
pvt$array                       000066 external static fixed bin(17,0)          dcl 5-18 set ref 108 296
pvt_array                              based           structure                array level 1 dcl 5-24 set ref 251 256
pvt_arrayp                      000136 automatic       pointer                  dcl 5-21 set ref 108* 251 256 296* 300 304
pvte                                   based           structure                level 1 dcl 5-26
pvtep                           000140 automatic       pointer                  dcl 5-22 set ref 251* 256* 257 258 260 261
pvtx                            000110 automatic       fixed bin(17,0)          dcl 44 in procedure "make_sdw" set ref 250* 251 255*
                                                                                  256* 263
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "make_sdw" set ref 242* 263*
records                  12(18)        based           bit(9)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  233*
rel                                                    builtin function         dcl 86 ref 116
root_pvtx                64            based           fixed bin(17,0)          level 2 dcl 9-9 ref 241 250
save_pts                        000114 automatic       fixed bin(17,0)          dcl 46 set ref 127* 152* 186 198 198 199 199 200 215
                                                                                  257 269 277
sdw_info                               based           structure                level 1 dcl 6-6
sdw_util_$construct             000054 constant        entry                    external dcl 80 ref 219 275
sdw_util_$dissect               000056 constant        entry                    external dcl 81 ref 214
sdwi                            000125 automatic       structure                level 1 dcl 54 set ref 214 214 219 219 275 275
seg                      10            based           structure                array level 2 in structure "slt" dcl 7-13
                                                                                  in procedure "make_sdw" set ref 110
seg                                    based           fixed bin(17,0)          array dcl 56 in procedure "make_sdw" ref 270
segnam                                 based           structure                level 1 dcl 7-31
sentinel                 65            based           char(4)                  level 3 packed packed unaligned dcl 2-9 set ref 277*
size                      1     000125 automatic       fixed bin(19,0)          level 2 dcl 54 set ref 215*
slt                                    based           structure                level 1 dcl 7-13
slt$                            000026 external static fixed bin(17,0)          dcl 67 set ref 109
slt_name                        000000 constant        char(32)                 initial array level 2 packed packed unaligned
                                                                                  dcl 11-14 ref 121
slte                                   based           structure                level 1 dcl 8-48
slte_uns                               based           structure                level 1 dcl 8-10
sltep                           000146 automatic       pointer                  dcl 8-8 set ref 110* 119 128 128 130 137 137 138 146
                                                                                  146 147 148 148 149 149 181 196 203 205 206 207
                                                                                  216 217 233 235 249 273
sltp                            000142 automatic       pointer                  dcl 7-7 set ref 109* 110
sst                                    based           structure                level 1 dcl 9-9
sst_seg$                        000070 external static fixed bin(17,0)          dcl 9-6 set ref 105
sstp                            000150 automatic       pointer                  dcl 9-7 set ref 105* 154 159 161 161 161 166 168 171
                                                                                  172 179 187 187 200 200 203 205 206 241 250
string                                                 builtin function         dcl 86 set ref 216*
strp                      2            based           bit(18)                  level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  224*
substr                                                 builtin function         dcl 86 ref 146
sys_info$system_type            000034 external static fixed bin(17,0)          dcl 71 ref 217
syserr                          000060 constant        entry                    external dcl 82 ref 168 245 258
table_corresp                   000000 constant        structure                array level 1 packed packed unaligned dcl 11-14 ref
                                                                                  120
tbcp                            000152 automatic       pointer                  dcl 11-6 set ref 121* 123* 124 125 126 127* 134*
tbl_card_name                   000012 internal static char(4)                  initial dcl 11-6 set ref 123*
tbl_name                  1            based           char(4)                  array level 3 packed packed unaligned dcl 11-8 ref
                                                                                  126
tbl_spec                  1            based           structure                array level 2 unaligned dcl 11-8 ref 125
tbls_card                              based           structure                level 1 unaligned dcl 11-8
temp_sdw                        000112 automatic       fixed bin(71,0)          dcl 45 set ref 275 275 276 276 280* 281 281
temp_seg                  1(23)        based           bit(1)                   level 2 packed packed unaligned dcl 8-48 ref 203
thread$cin                      000062 constant        entry                    external dcl 83 ref 203 205 206
thread$out                      000064 constant        entry                    external dcl 84 ref 171
unthreaded                      000123 automatic       bit(1)                   dcl 51 set ref 90* 97* 103* 138 203 208*
usedf                     5            based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref 161
                                                                                  178*
vtocx                     4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  227*
wired                     1(12)        based           bit(1)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 8-48 in procedure "make_sdw" ref 181 207
wired                   120            based           fixed bin(17,0)          level 2 in structure "sst" dcl 9-9 in procedure
                                                                                  "make_sdw" set ref 187* 187 200* 200
write                     2(02) 000125 automatic       bit(1)                   level 3 packed packed unaligned dcl 54 set ref 274*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADP_SYSTEM                             internal static fixed bin(17,0)          initial dcl 10-4
SYSTEM_TYPE_NAME                       internal static char(8)                  initial array packed unaligned dcl 10-6
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 5-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 5-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 5-113
abx                                    internal static fixed bin(17,0)          initial dcl 3-42
aclp                                   automatic       pointer                  dcl 7-7
acls                                   based           structure                level 1 dcl 7-45
append_null_addr                       internal static bit(22)                  initial dcl 4-4
apx                                    internal static fixed bin(17,0)          initial dcl 3-42
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
bbx                                    internal static fixed bin(17,0)          initial dcl 3-42
bkpt_page_ptr                          automatic       pointer                  dcl 2-19
bpx                                    internal static fixed bin(17,0)          initial dcl 3-42
breakpoint_ptr                         automatic       pointer                  dcl 2-28
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 4-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 4-26
fill_page_table_null_addr              internal static bit(22)                  initial dcl 4-4
get_aste_null_addr                     internal static bit(22)                  initial dcl 4-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 4-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 4-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 4-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 4-4
lbx                                    internal static fixed bin(17,0)          initial dcl 3-42
list_deposit_null_addr                 internal static bit(22)                  initial dcl 4-4
lpx                                    internal static fixed bin(17,0)          initial dcl 3-42
mcp                                    automatic       pointer                  dcl 3-10
name_seg                               based           structure                level 1 dcl 7-26
names_ptr                              automatic       pointer                  dcl 7-7
page_bad_null_addr                     internal static bit(22)                  initial dcl 4-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 4-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 4-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 4-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 4-4
path                                   based           structure                level 1 dcl 7-40
pathp                                  automatic       pointer                  dcl 7-7
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 4-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 4-4
put_aste_null_addr                     internal static bit(22)                  initial dcl 4-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 4-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 4-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 5-19
salv_truncate_null_addr                internal static bit(18)                  initial dcl 4-26
sbx                                    internal static fixed bin(17,0)          initial dcl 3-42
scu                                    based           structure                level 1 dcl 3-56
scup                                   automatic       pointer                  dcl 3-54
scux                                   based           structure                level 1 dcl 3-207
sdw_info_ptr                           automatic       pointer                  dcl 6-4
seg_aste                               based           structure                level 1 dcl 1-96
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 4-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 4-4
spx                                    internal static fixed bin(17,0)          initial dcl 3-42
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 4-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 4-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 4-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 4-26
volume_reloader_null_addr              internal static bit(18)                  initial dcl 4-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 4-26

NAMES DECLARED BY EXPLICIT CONTEXT.
MAKE_SDW_COMMON                 000174 constant        label                    dcl 105 ref 92 99
got_pts                         000453 constant        label                    dcl 154 ref 131
got_pvtx                        001373 constant        label                    dcl 261 ref 252 257
make_sdw                        000137 constant        entry                    external dcl 10
no_card                         000364 constant        label                    dcl 137 ref 124
no_pages                        000164 constant        entry                    external dcl 101
reset_hcp                       001565 constant        entry                    external dcl 309
thread_hcp                      001524 constant        entry                    external dcl 293
unthreaded                      000151 constant        entry                    external dcl 95

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2100        2172    1576        2110
Length      2620    1576        72         412     301           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
make_sdw                            178 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 hcp_thread                  make_sdw
000011 hcp_first                   make_sdw
000012 tbl_card_name               make_sdw

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
make_sdw                 000100 error_table_no              make_sdw
                         000101 pdsno                       make_sdw
                         000102 dsegno                      make_sdw
                         000103 pl1_ops_no                  make_sdw
                         000104 pl1_ops_pages               make_sdw
                         000105 no_pages_wired              make_sdw
                         000106 ptsi                        make_sdw
                         000107 loopcnt                     make_sdw
                         000110 pvtx                        make_sdw
                         000112 temp_sdw                    make_sdw
                         000114 save_pts                    make_sdw
                         000115 dummy                       make_sdw
                         000116 asp                         make_sdw
                         000120 pts                         make_sdw
                         000121 i                           make_sdw
                         000122 j                           make_sdw
                         000123 unthreaded                  make_sdw
                         000124 no_pages                    make_sdw
                         000125 sdwi                        make_sdw
                         000134 astep                       make_sdw
                         000136 pvt_arrayp                  make_sdw
                         000140 pvtep                       make_sdw
                         000142 sltp                        make_sdw
                         000144 namep                       make_sdw
                         000146 sltep                       make_sdw
                         000150 sstp                        make_sdw
                         000152 tbcp                        make_sdw

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absadr                        config_$find                  get_ptrs_$given_astep         pmut$swap_sdw
ptw_util_$make_core           ptw_util_$make_null           ptw_util_$set_wired           sdw_util_$construct
sdw_util_$dissect             syserr                        thread$cin                    thread$out

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
abs_seg$                      breakpoint_page$              dseg$                         error_table_$
name_table$                   pds$                          pl1_operators_$end_pl1_operators
pvt$array                     slt$                          sst_seg$                      sys_info$system_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000132        90 000144        91 000145        92 000146        95 000147        97 000156        98 000160
     99 000161       101 000162       102 000171       103 000173       105 000174       108 000177       109 000201
    110 000203       111 000210       113 000212       114 000217       115 000224       116 000231       117 000236
    119 000243       120 000251       121 000263       123 000276       124 000307       125 000313       126 000321
    127 000333       128 000336       130 000351       131 000354       133 000355       134 000357       135 000362
    137 000364       138 000400       141 000414       142 000420       143 000422       146 000423       147 000433
    148 000435       149 000443       150 000450       152 000451       154 000453       155 000464       157 000467
    158 000472       159 000473       161 000476       165 000521       166 000522       168 000530       171 000562
    172 000575       173 000605       174 000606       178 000610       179 000613       181 000621       182 000625
    183 000633       184 000640       185 000645       186 000652       187 000654       188 000655       189 000656
    191 000657       192 000667       193 000705       194 000724       196 000726       198 000734       199 000773
    200 001010       203 001016       205 001037       206 001056       207 001074       208 001077       209 001101
    210 001104       211 001105       213 001110       214 001122       215 001140       216 001143       217 001150
    219 001161       221 001176       222 001201       223 001203       224 001205       225 001213       226 001215
    227 001217       229 001221       233 001222       235 001236       240 001244       241 001247       242 001252
    243 001254       245 001255       249 001276       250 001302       251 001305       252 001311       255 001312
    256 001316       257 001323       258 001327       260 001365       261 001373       263 001401       264 001405
    268 001407       269 001422       270 001431       271 001434       273 001436       274 001442       275 001444
    276 001461       277 001474       280 001503       281 001505       283 001520       293 001521       296 001531
    297 001534       300 001543       301 001552       304 001554       306 001563       309 001564       312 001572
    313 001575


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
