	COMPILATION LISTING OF SEGMENT ncp_tbop_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1320.8 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ncp_tbop_:
       12           procedure ();
       13 
       14 /*             "ncp_tbop_" -- this procedure interprets the microfunction table */
       15 /*        whenever necessary.                                                   */
       16 
       17           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
       18 
       19      declare
       20           procpx pointer
       21                parameter;
       22 
       23           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
       24 
       25      declare
       26          (oper_loc fixed binary (18),                       /* location of operator (for tracing)             */
       27           host_code fixed binary (32),
       28           num_bytes fixed binary (24),
       29           icode fixed binary (35),
       30           procid bit (36) aligned,
       31           cv_bin_output character (12),
       32           host_ptr pointer,
       33           (gpr, hpr, mpr, npr, procp, rpr, sep, spr) pointer,
       34           return_label local label)
       35                automatic;
       36 
       37           /* * * * * TEXT SECTION REFERENCES  * * * * * * */
       38 
       39           /* * * * * BASED & TEMPLATE DECLARATIONS * * * */
       40 
       41      declare
       42           1 host_array (1) aligned based like host,
       43           1 rfc_array (1) aligned based like rcvd_rfc,
       44           1 socket_array (1) aligned based like socket;
       45 
       46 dcl (i, j, k) fixed bin (18),                               /* iterative temporaries */
       47      event_msg fixed bin (71),                              /* For use by the "signal" microfunction */
       48      lockp ptr,                                             /* pointer to socket table entry lock word */
       49      rw fixed bin (1),                                      /* read_write temporary switch */
       50 success bit(1) aligned,
       51      tpr ptr;                                               /* temporary pointer */
       52 
       53 
       54 dcl  control_message bit (1024);                            /* space for a control message to be constructed */
       55 
       56 dcl  msg_chr8 char (8) aligned based;                       /* For inserting a charstring message into event_msg */
       57 dcl  boffer (0: 1000) bit (1) unaligned based;              /* For adding a bit offset to a pointer */
       58 
       59 dcl  com8 (0: 100) bit (8) unaligned based;
       60 dcl based_lock bit (36) aligned based;
       61 
       62           /* * * * * EXTERNAL STATIC DECLARATIONS  * * * * * * */
       63 
       64      declare
       65          (ncp_params_$interrupt_signal character (4) aligned,
       66           ncp_tables_$tracing_info bit (36) aligned)
       67                external static;
       68 
       69      declare
       70          (ncp_tables_$host_tbl,
       71           ncp_tables_$meter_cells,
       72           ncp_tables_$ncp_data,
       73           ncp_tables_$rfc_tbl,
       74           ncp_tables_$socket_tbl)
       75                external static;
       76 
       77      declare
       78          (error_table_$bad_index,
       79           error_table_$bad_processid,
       80           error_table_$imp_rfnm_pending,
       81           error_table_$net_invalid_state,
       82           error_table_$net_bad_gender,
       83           error_table_$net_fhost_inactive,
       84           error_table_$net_socket_not_found,
       85           error_table_$notalloc)
       86                fixed binary (35) external static;
       87 
       88           /* * * * * ENTRY & PROCEDURE DECLARATIONS  * * * * * * */
       89 
       90      declare
       91           cv_bin_$dec constant entry (fixed bin (35)) returns (character (12)),
       92           imp_order$imp_update_write_allocation constant entry (fixed bin (17), fixed bin (16), fixed bin (32)),
       93           imp_read_order constant entry (fixed bin (17), fixed bin (12), ptr, bit (18), fixed bin (35)),
       94           imp_write_order constant entry (fixed bin (17), fixed bin (12), ptr, bit (18), fixed bin (35)),
       95           ncp_access_$assign_link constant entry (ptr, fixed bin (35)),
       96           ncp_access_$change_socket_state constant entry (ptr, fixed bin (6), fixed bin (35)),
       97           ncp_access_$deactivate_socket constant entry (ptr, fixed bin (35)),
       98           ncp_access_$signal_process constant entry (ptr, fixed bin (1), fixed bin (35)),
       99           ncp_access_$unassign_link constant entry (ptr, fixed bin (35)),
      100           ncp_connection_$allocate_read constant entry (ptr, fixed bin (35)),
      101           ncp_error_ constant entry (fixed bin (35), char (*)),
      102           ncp_lock_$lock_unlock constant entry (ptr, fixed bin (35)),
      103           ncp_lock_$unlock_all constant entry (fixed bin (35)),
      104           ncp_trace_ constant entry options (variable),
      105           ncp_util_$find_host_entry constant entry (fixed bin (32), bit (1), ptr, fixed bin (35)),
      106           ncp_util_$find_socket_from_index constant entry (bit (36), bit (1), ptr, fixed bin (35)),
      107           ncp_util_$find_socket_from_link_number constant entry (fixed bin (32), fixed bin (8), bit (1), ptr, fixed bin (35)),
      108           ncp_util_$find_socket_from_socket_number constant entry (fixed bin (32), fixed bin (32), bit (1), ptr, fixed bin (35)),
      109           ncp_util_$send_control_message constant entry (ptr, ptr, fixed bin (24), fixed bin (35)),
      110           pxss$ips_wakeup_int constant entry (bit (36) aligned, char (4) aligned),
      111           pxss$wakeup_int constant entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      112 
      113      declare
      114           (addr, binary, bit, divide, min, null, pointer, rel, stacq, string, substr, unspec)
      115                builtin;
      116 
      117           /* * * * * INCLUDE FILES * * * * * * * * * * * * */
      118 
      119           
  1     2 /* BEGIN INCLUDE FILE imp_orders.incl.pl1                                       */
  1     3 
  1     4 /*             This include file declares the special order codes accepted by   */
  1     5 /*        the IMP DIM.                                                          */
  1     6 
  1     7 /*        Originally created by D. M. Wells, September, 1977.                   */
  1     8 
  1     9      declare
  1    10          (IMP_ORDER_abort_transfer                initial (1),        /* flush buffered data                  */
  1    11           IMP_ORDER_multiple_message_mode         initial (2),        /* pack messages together if possible   */
  1    12           IMP_ORDER_single_message_mode           initial (3),        /* don't pack messages together         */
  1    13           IMP_ORDER_get_status                    initial (4),        /* return status of link and host       */
  1    14           IMP_ORDER_no_ncp                        initial (5),        /* the NCP isn't using this link        */
  1    15           IMP_ORDER_imp_ascii                     initial (6),        /* messages for IMP's  TTY              */
  1    16           IMP_ORDER_control_link                  initial (7),        /* this is NCP's control link           */
  1    17           IMP_ORDER_clear_host_state              initial (8),        /* clear stae of foreign host and IMP   */
  1    18           IMP_ORDER_block_link                    initial (9),        /* stop transferring data on link       */
  1    19           IMP_ORDER_unblock_link                  initial (10),       /* start transferring data on link      */
  1    20           IMP_ORDER_imp_octal                     initial (11),       /* message is for IMP's TTY (octal)     */
  1    21           IMP_ORDER_normal_leader                 initial (12),       /* messages for foreign host again      */
  1    22           IMP_ORDER_pgqlrr                        initial (13),       /* put on global queue when get RFNM    */
  1    23           IMP_ORDER_clear_pgqlrr                  initial (14),       /* clear flag to pgqlrr                 */
  1    24           IMP_ORDER_set_byte_size                 initial (15),       /* setthe link's bytesize               */
  1    25           IMP_ORDER_get_byte_size                 initial (16),       /* get the link's bytesize              */
  1    26           IMP_ORDER_get_allocation_status         initial (17))       /* get status and include allocations   */
  1    27                fixed binary (12) internal static options (constant);
  1    28 
  1    29 /* END INCLUDE FILE imp_orders.incl.pl1                                         */
  1    30 
      119 
      120           
  2     2 /*        BEGIN include file "ncp_connection_dcls.incl.pl1" --                  */
  2     3 
  2     4 /*             This include file contains declarations for the structures       */
  2     5 /*        maintained by the NCP which contain information about Host-Host       */
  2     6 /*        connections.  Currently, this is the information about sockets,       */
  2     7 /*        hosts, and requests-for-connection.                                   */
  2     8 
  2     9 /*        Originally created by D. M. Wells, Summer, 1975.                      */
  2    10 /*	Modified by B. Greenberg, Spring '78 for new leader support */
  2    11 /*	        Modified by C. Hornig, July 1979 for new host number format */
  2    12 
  2    13      declare
  2    14           1 socket aligned based,                           /* information we keep on a per-socket basis      */
  2    15              2 event_channel fixed binary (71),             /* event channel of using process                 */
  2    16              2 overseer_event_channel fixed binary (71),    /* event chanel of overseer process               */
  2    17              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  2    18              2 process_id bit (36) aligned,                 /* process id of using process                    */
  2    19              2 overseer_process_id bit (36) aligned,        /* process id of overseer process                 */
  2    20              2 bit_allocation fixed binary (32),            /* bit allocation outstanding on attached link    */
  2    21              2 msg_allocation fixed binary (16),            /* message allocation outstanding on link         */
  2    22 
  2    23              2 local_socket unaligned like socket.foreign_socket,     /* identification of local socket       */
  2    24              2 foreign_socket unaligned,                    /* identification of foreign socket               */
  2    25 	      3 host,				/* id of this host				*/
  2    26 	        4 net bit (8),			/* network id				*/
  2    27 	        4 host bit (8),			/* port on imp				*/
  2    28 	        4 imp bit (16),			/* imp id					*/
  2    29                 3 socket_num bit (32),                      /* actual socket number                           */
  2    30                 3 pad bit (8),
  2    31 
  2    32              2 rfc_queue fixed binary (17) unaligned,       /* RFC table index of next block for this         */
  2    33                                                             /* socket, 0 if queue is empty                    */
  2    34              2 link_number fixed binary (17) unaligned,     /* number of link assigned for connection         */
  2    35 
  2    36              2 host_entry_index fixed binary (17) unaligned,          /* index in host table of foreign       */
  2    37                                                                       /* host involved in connection          */
  2    38              2 impdim_index fixed binary (17) unaligned,    /* index by which IMPDIM knows about connection   */
  2    39              2 state bit (6) unaligned,                     /* finite-state-machine information               */
  2    40              2 byte_size bit (8) unaligned,                 /* byte-size of connections                       */
  2    41              2 send_gender bit (1) unaligned,               /* on iff this is a transmit socket               */
  2    42              2 allow_interrupts bit (1) unaligned,          /* on iff INS and INR should be signalled to user */
  2    43              2 deactivate bit (1) unaligned,                /* on iff this socket should be deactivated when  */
  2    44                                                             /* matching network messages are finally received */
  2    45              2 allow_rfc_queuing bit (1) unaligned,         /* on iff we should allow multiple outstanding    */
  2    46                                                             /* RFC's for this socket                          */
  2    47              2 extra_bits bit (12) unaligned,
  2    48 
  2    49              2 overseer_validation_level bit (3) unaligned,           /* ring of highest overseer control     */
  2    50              2 validation_level bit (3) unaligned,                    /* ring of highest operator control     */
  2    51 
  2    52              2 overseer_lock_id bit (36) aligned,           /* lock id of the overseer process                */
  2    53              2 umodes bit (36) aligned,                     /* 36 bits that the users can play with           */
  2    54              2 time_state_changed fixed binary (71),        /* time that the socket state last changed        */
  2    55              2 signal_event_channel fixed binary (71),      /* chanel to signal over when get INS or INR      */
  2    56              2 socket_index bit (36) aligned,               /* the handle we gave user for future reference   */
  2    57              2 history aligned,                             /* state of socket over recent past history       */
  2    58                 3 num_state_changes fixed binary (11) unaligned,      /* small field, so only keep mod        */
  2    59                 3 prev_state (0 : 3) fixed binary (5) unaligned;      /* past N states, kept in rotation      */
  2    60 
  2    61      declare
  2    62           1 host aligned based,                             /* information we retain about a foreign host     */
  2    63              2 lock bit (36) aligned,                       /* lock to prevent simultaneous updating          */
  2    64              2 rcv_link_index fixed binary (17) unaligned,  /* impdim index of read link for control msgs     */
  2    65              2 xmit_link_index fixed binary (17) unaligned, /* impdim index of write link for control msgs    */
  2    66              2 read_links_assigned bit (32) unaligned,      /* a bit is on iff we have assigned that link     */
  2    67              2 read_link_padd bit (4) unaligned,
  2    68 	   2 xhost_number_pad bit (9) unaligned,
  2    69              2 host_state bit (6) unaligned,                /* stae of communications with this host          */
  2    70              2 previous_host_state bit (6) unaligned,       /* last state of this host                        */
  2    71              2 state_pad bit (15) unaligned,
  2    72              2 time_state_changed fixed binary (71),        /* time when host state last changed              */
  2    73              2 read_links_used bit (32) unaligned,          /* bit is on if link has been used "recently"     */
  2    74              2 read_link_used_pad bit (4) unaligned,
  2    75              2 num_connections fixed binary (17) unaligned, /* times we attached links for this host          */
  2    76              2 hash_index fixed binary (17) unaligned,      /* table index of this host entry                 */
  2    77 	   2 host_number fixed bin (32) aligned,	/* host number of this host			*/
  2    78 	   2 host_number_pad fixed bin (35);
  2    79 
  2    80      declare
  2    81           1 rcvd_rfc aligned based,                         /* info about a rcvd Request for Connection       */
  2    82              2 foreign_socket unaligned like socket.foreign_socket,   /* foreign socket in RFC msg            */
  2    83              2 foreign_hosts_choice fixed binary (17) unaligned,      /* link or size that other host chose   */
  2    84              2 next_entry fixed binary (17) unaligned,                /* next RFC entry in queue for socket   */
  2    85              2 padding (1) fixed binary (35);
  2    86 
  2    87      declare
  2    88 	1 host_address based aligned,			/* Form of a host address			*/
  2    89 	   2 net bit (8) unaligned,			/* Netwwork ID				*/
  2    90 	   2 host bit (8) unaligned,			/* Host Port				*/
  2    91 	   2 imp bit (16) unaligned;			/* IMP ID					*/
  2    92 				/* Duplicated because of PL/I multi-like restriction */
  2    93 
  2    94 /*        END of include file ncp_connection_dcls.incl.pl1                      */
  2    95 
      120 
      121           
  3     2 /*             "ncp_constants_dcls.incl.pl1" -- include file to       */
  3     3 /*        declare some constants used throughout the Multics Network  */
  3     4 /*        Control Program (NCP).                                      */
  3     5 
  3     6 /*        Originally created by D. M. Wells, 1975, May 19.            */
  3     7 
  3     8      declare
  3     9          (NCP_DOWN            initial (0),                  /* the NCP has been shutdown normally             */
  3    10           NCP_UP_IMP_DOWN     initial (1),                  /* the NCP is up, but the IMP is unreachable      */
  3    11           NCP_UP              initial (2),                  /* the NCP is up and running normally             */
  3    12           NCP_CRASHED         initial (-1))                 /* the NCP has crashed itself                     */
  3    13                fixed binary (3) internal static options (constant);
  3    14 
  3    15      declare
  3    16          (READ_GENDER         initial ("0"b),               /* Read sockets are even numbers                  */
  3    17           WRITE_GENDER        initial ("1"b))               /* Write sockets ar odd numbers                   */
  3    18                bit (1) internal static options (constant);
  3    19 
  3    20      declare
  3    21          (HOST_OFF            initial (0),                  /* this host is not enabled for communications    */
  3    22           HOST_UP             initial (1),                  /* Host is up and everything ok                   */
  3    23           HOST_RST            initial (2),                  /* a Host-Host RST command has been sent          */
  3    24           HOST_DOWN           initial (3),                  /* Foreign host is down                           */
  3    25           HOST_ON             initial (4))                  /* Foreign host is enabled, but not RST yet       */
  3    26                fixed binary (6) internal static options (constant);
  3    27 
  3    28      declare
  3    29          (SOCK_UNASSIGNED     initial (0),                  /* This socket entry is not in use currently      */
  3    30           SOCK_ASSIGNED       initial (1),                  /* Socket has been assigned and is quiescent      */
  3    31           SOCK_LISTENING      initial (2),                  /* Socket is listening for incoming-RFCs          */
  3    32           SOCK_RFC_RCVD       initial (3),                  /* Socket has received RFC from foreign socket    */
  3    33           SOCK_RFC_ABORTED    initial (4),                  /* CLS  received for unacknowledged RFC           */
  3    34           SOCK_RFC_SENT       initial (5),                  /* RFC sent to foreign socket, but no reply       */
  3    35           SOCK_CONNECTED      initial (6),                  /* Socket is connected to foreign socket          */
  3    36           SOCK_CLS_WAIT       initial (7),                  /* CLS issued, waiting for reply CLS              */
  3    37                                                             /* State 8 is not currently defined               */
  3    38           SOCK_DATA_WAIT      initial (9),                  /* User requested close, but data still here      */
  3    39           SOCK_RFNM_WAIT      initial (10),                 /* User requested close, but waiting on last RFNM */
  3    40           SOCK_CLS_READ       initial (11),                 /* CLS received, but data still in buffers        */
  3    41                                                             /* State 12 is not currently defined              */
  3    42           SOCK_BROKEN         initial (13),                 /* Socket has been involved in some NCP anomaly   */
  3    43           SOCK_RESET          initial (14))                 /* Socket was connected to host that was reset    */
  3    44                fixed binary (6) internal static options (constant);
  3    45 
  3    46      declare
  3    47          (SOCK_INDX_MASK      initial ("000000777777"b3),   /* mask to get out actual array index             */
  3    48           SOCK_UNIQUE_MASK    initial ("377777000000"b3))   /* mask to get out incrementing part of indx      */
  3    49                bit (36) internal static options (constant);
  3    50 
  3    51      declare
  3    52          (ANY_TRACING         initial ("400000000000"b3),             /* if any tracing is occurring          */
  3    53           PRINTER_TRACING     initial ("200000000000"b3),             /* if tracing to the ptr is happening   */
  3    54           SYSERR_LOG_TRACING  initial ("100000000000"b3),             /* if tracing to syserr log mechanism   */
  3    55 
  3    56           TRACE_CTL_MSGS      initial ("004000000000"b3),             /* if host-host ctl msgs should be trcd */
  3    57           TRACE_PROCESS_INFO  initial ("002000000000"b3),             /* if process control should be trcd    */
  3    58           TRACE_DATA_FLOW     initial ("001000000000"b3),             /* if flow of user data to be traced    */
  3    59 
  3    60           TRACE_NCP_RING      initial ("000400000000"b3),             /* if ncp_ring_ should be traced        */
  3    61           TRACE_NCP_ACCESS    initial ("000200000000"b3),             /* if ncp_access_ should be traced      */
  3    62           TRACE_NCP_DAEMON    initial ("000100000000"b3),             /* if ncp_daemon_ should be traced      */
  3    63           TRACE_NCP_CONTROL   initial ("000040000000"b3),             /* if ncp_control_ should be traced     */
  3    64           TRACE_NCP_TBOP      initial ("000020000000"b3),             /* if ncp_tbop_ should be traced        */
  3    65           TRACE_NCP_IO        initial ("000010000000"b3))             /* if ncp_io_ should be traced          */
  3    66                bit (36) aligned internal static options (constant);
  3    67 
  3    68 /*        end of include file "ncp_constants_dcls.incl.pl1            */
  3    69 
      121 
      122           
  4     2 /*        BEGIN include file ncp_data_dcls.incl.pl1 --                          */
  4     3 
  4     4 /*             This include file contains declarations of structures kept       */
  4     5 /*        in the NCP data base which aren't associated directly with            */
  4     6 /*        Network connections or process control.                               */
  4     7 
  4     8 /*        Originally created by D. M. Wells, Jan., 1976 by altering a           */
  4     9 /*                  previously existing include file.                           */
  4    10      declare
  4    11           1 ncp_dt aligned based,                           /* Information about global state of NCP          */
  4    12              2 ncp_ev_chan fixed binary (71),               /* event channel id of NCP Daemon process         */
  4    13              2 ncp_procid bit (36),                         /* process id of NCP Daemon process               */
  4    14              2 ncp_up fixed binary (2),                     /* -1 crashed, 0 uninit, 1 imp down, 2 up         */
  4    15              2 htbl_size fixed binary (17),                 /* max size of host table in entries              */
  4    16              2 rtbl_size fixed binary (17),                 /* max size of RFC table in entries               */
  4    17              2 stbl_size fixed binary (17),                 /* max size of socket table in entries            */
  4    18              2 size_pad fixed binary (17),
  4    19 
  4    20              2 htbl_gent fixed binary (17),                 /* max host entry used                            */
  4    21              2 rtbl_gent fixed binary (17),                 /* max RFC entry used                             */
  4    22              2 stbl_gent fixed binary (17),                 /* max socket entry used                          */
  4    23              2 gent_pad fixed binary (17),
  4    24 
  4    25              2 htbl_lock bit (36) aligned,                  /* lock for host table                            */
  4    26              2 rtbl_lock bit (36) aligned,                  /* lock for RFC table                             */
  4    27              2 stbl_lock bit (36) aligned,                  /* lock for socket table                          */
  4    28              2 lock_pad bit (36) aligned,
  4    29 
  4    30              2 state_change_reason character (32) unaligned,          /* reason for last state change         */
  4    31 
  4    32              2 ncp_devx fixed binary (12),                  /* IOAM devx of NCP pseudo-device                 */
  4    33              2 ncp_state_changes fixed binary (17),         /* number of times NCP has changed state          */
  4    34              2 spacen1 (14) fixed fixed binary (35),
  4    35 
  4    36              2 host_id fixed binary (32),                   /* network identifier of this Multics System      */
  4    37              2 crash_on_ncp_error bit (1) aligned,          /* on if should crash to trap ncp error */
  4    38              2 imp_state char (8) aligned,
  4    39              2 time_imp_state_changed fixed binary (71),
  4    40              2 time_ncp_state_changed fixed binary (71),
  4    41 
  4    42              2 imp_special_message bit (32),
  4    43              2 imp_state_change_count fixed binary (17),
  4    44              2 spacen3 (3) fixed binary (17),
  4    45              2 ptbl_size fixed binary (17),                 /* number of entries in process table             */
  4    46              2 ptbl_gent fixed binary (17),                 /* index of highest slot in use                   */
  4    47              2 ptbl_lock bit (36) aligned,                  /* lock word for "proc_tb"                        */
  4    48 
  4    49              2 access_dirname character (168) unaligned,              /* dir of access defining segment       */
  4    50              2 access_ename character (32) unaligned;                 /* entry of access defining segment     */
  4    51 
  4    52      declare
  4    53           1 meter_dt aligned based,                         /* various meters kept by the NCP                 */
  4    54              2 prev_user_call_time fixed binary (71),
  4    55              2 prev_daemon_call_time fixed binary (71),
  4    56              2 accu_time_in_ncp fixed binary (71),
  4    57              2 accu_time_since_user_call fixed binary (71),
  4    58 
  4    59              2 nprocs_in_ncp fixed binary (17),
  4    60              2 nprocs_inconsistent bit (1),
  4    61              2 ndaemon_calls fixed binary (17),
  4    62              2 ncalls (5) fixed binary (17),
  4    63 
  4    64              2 net_error_count fixed binary (17),
  4    65              2 ncp_wakeup_count (7) fixed binary (17),
  4    66 
  4    67              2 call_count (0: 31) fixed binary (17),
  4    68 
  4    69              2 ctl_mess_count (0: 15) fixed binary (17),
  4    70 
  4    71              2 tbop_mf_count (48) fixed binary (17),
  4    72 
  4    73              2 eco_time fixed binary (71),
  4    74              2 erp_time fixed binary (71),
  4    75              2 eco_host fixed binary (16),
  4    76              2 erp_host fixed binary (16),
  4    77              2 num_activations fixed binary (30),           /* number of socket activations performed         */
  4    78              2 num_processes fixed binary (30);             /* number of processes using the NCP              */
  4    79 
  4    80 /*        END include file ncp_data_dcls.incl.pl1 --                            */
  4    81 
      122 
      123           
  5     2 /*        BEGIN include file ncp_process_dcls.incl.pl1 --                       */
  5     3 
  5     4 /*             This include file contains declarations of per-process data.     */
  5     5 
  5     6 /*        Originally created by D. M. Wells, Jan, 1976 from a previously        */
  5     7 /*                  existing include file.                                      */
  5     8 
  5     9      declare
  5    10           1 gdt aligned based,                              /* this holds data to/from outside world          */
  5    11              2 init_sw fixed binary (30),                   /* set to 620998 iff initialized properly.        */
  5    12                                                             /* This particular value has  no significance     */
  5    13              2 error_code fixed binary (35),                /* a code returned by internal modules            */
  5    14              2 request_code fixed binary (12),              /* type of request to be performed (input)        */
  5    15              2 ncp_idx bit (36) unaligned,                  /* handle of socket to be manipulated (input)     */
  5    16              2 state fixed binary (6),                      /* state of the socket (output)                   */
  5    17              2 privilege_code fixed binary (2),             /* = 0 unpriv, = 1 priv, = 2 daemon               */
  5    18              2 nbytes fixed binary (24),                    /* number of bytes of data presented (input)      */
  5    19              2 nelemt fixed binary (24),                    /* number of bytes transmitted (output)           */
  5    20 
  5    21              2 areap pointer,                               /* pointer to a supplied area (input)             */
  5    22              2 fsoc bit (64) unaligned,                     /* foreign socket associated with this request    */
  5    23              2 fsoc_pad bit (8) unaligned,
  5    24              2 abort_location label,                        /* label to goto on procedure abort               */
  5    25 
  5    26              2 host_tbl_index fixed binary (17),            /* host_tbl index of foreign host                 */
  5    27              2 proc_id_arg bit (36),                        /* process id argument                            */
  5    28              2 entry_time fixed binary (71),                /* time NCP was entered by this call              */
  5    29              2 entry_type fixed binary (17),                /* 1, 2 daemon; 3 userid; 4 process_rq;           */
  5    30                                                             /* 5 global_chnchn; 6 socket_state; 7 micro       */
  5    31              2 nprocs_sw fixed binary (30),                 /* = 459248 if nprocs cell was properly set       */
  5    32              2 event_chn fixed binary (71),                 /* event_channel argument                         */
  5    33 
  5    34              2 proc_tbp pointer,                            /* pointer to this process's static info block    */
  5    35              2 global_queue aligned,                        /* impdim global queue info struct                */
  5    36                 3 gq_type fixed binary (17),                /* imp_global_state substructure begins here      */
  5    37                 3 gq_imp_state character (8) unaligned,     /* state of our IMP (up, down?)                   */
  5    38                 3 gq_message bit (32) aligned,              /* special message sent by IMP                    */
  5    39 
  5    40                 3 gq_imp_index fixed binary (17),           /* imp_dim index of this link                     */
  5    41                 3 gq_host_id fixed binary (32),             /* host identifier of a foreign host              */
  5    42                 3 gq_link fixed binary (8),                 /* link number of this link                       */
  5    43                 3 gq_status aligned,                        /* of this link returned by imp_global_state      */
  5    44                    4 sba (0 : 17) bit (1) unaligned,        /* status bits from imp dim                       */
  5    45 
  5    46              2 spaceg2 (14) fixed binary (17);
  5    47 
  5    48      declare
  5    49           1 pdt aligned based,                              /* information about each process using NCP       */
  5    50              2 gdtp pointer,                                /* points to this call's global_data base         */
  5    51              2 returnp label,                               /* return label for non-local error goto          */
  5    52 
  5    53              2 multuid character (32) unaligned,            /* process group id                               */
  5    54 
  5    55              2 netuid bit (24),                             /* Network id of this process                     */
  5    56              2 lockid bit (36),                             /* lock id of process,  = ""b iff unassigned      */
  5    57              2 processid bit (36),                          /* process id of this process                     */
  5    58              2 error_recur fixed binary (17),               /* number of ncp error recursions                 */
  5    59              2 global_ev_chn fixed binary (71),             /* this process gets changes of NCP state         */
  5    60              2 num_activations fixed binary (17),
  5    61              2 proc_devx fixed binary (12),
  5    62              2 spacep2 (2) fixed binary (17);
  5    63 
  5    64      declare
  5    65           1 error_snapshot aligned based,                   /* snapshot of process info for an NCP error      */
  5    66              2 ewho character (32) unaligned,               /* process group id of detecting process          */
  5    67              2 econdition character (32) unaligned,         /* condition signalled                            */
  5    68 
  5    69              2 etime fixed binary (71),                     /* time of error                                  */
  5    70              2 error_number fixed binary (17),
  5    71              2 spacee1 (5) fixed binary (17),
  5    72 
  5    73              2 mc_cond (32) bit (36) aligned,               /* machine conditions                             */
  5    74              2 if_data (8) fixed binary (17),               /* space for software supplied data               */
  5    75              2 proc_slot aligned like pdt,                  /* copy of proc_tbl entry for this process        */
  5    76              2 gdt_data aligned like gdt,                   /* copy of ncp_global_data at time of error       */
  5    77              2 associated_data (24) bit (36) aligned;       /* add'l info -- usually copy of socket entry     */
  5    78 
  5    79 /*        END include file ncp_process_dcls.incl.pl1 --                         */
  5    80 
      123 
      124 
      125 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      126 
      127 /* MICROFUNCTION PROCESSING DECLARATIONS */
      128 
      129 
      130 
      131 
      132 dcl  curp ptr;                                              /* pointer to current operation block */
      133 
      134 dcl 1 ctlb aligned based (curp),                            /* operation block format */
      135     2 next bit (18) unaligned,                              /* address of next operation block */
      136     2 op bit (18) unaligned,                                /* microfunction code */
      137     2 (a, b, c, d) bit (18) unaligned;                      /* arguments */
      138 
      139 dcl 1 ctlb1 aligned based (curp),                           /* operation block format for "ctl_message" microfunction */
      140     2 next1 bit (18) unaligned,
      141     2 op1 bit (18) unaligned,
      142     2 arg (4) bit (18) unaligned;                           /* argumentsto be referenced in array */
      143 
      144 dcl  ncp_tbl_$com_state_tbl (24, 14) bit (18) unaligned external;
      145 dcl  ncp_tbl_$ctl_tbl (0: 15) bit (18) unaligned external;
      146 dcl  ncp_tbl_$base fixed bin external;                      /* used to find the base of the table */
      147 
      148 dcl  bytet bit (8),                                         /* temporary byte cell */
      149      ccode fixed bin (18),                                  /* command code - helps determine
      150*                                                               which operation sequence will be processed */
      151      com_len fixed bin,                                     /* byte length of this control command */
      152      cpr ptr,                                               /* copy of argument "com_pr".
      153*                                                               Pointer to base of input control message */
      154      fsocr bit (64),                                        /* working cell and internal copy
      155*                                                               of "fsoc" argument to be returned */
      156      fsoct bit (64),                                        /*  working foreign socket cell */
      157      fsoct1 bit (64),                                       /* working foreign socket cell */
      158      host_tb_index fixed bin,                               /* index of host in host table */
      159      linkt fixed bin (18),                                  /* working link number cell */
      160      lsoct bit (64),                                        /* working local socket cell */
      161      ncp_err_code char (8),                         /* an input argument to the ncp_error procedure */
      162      pcode fixed bin (18),                                  /* privilege code: 0 - no privileges, 1 - special privileges */
      163      queue_level fixed bin,                                 /* no. rfc's queued for this socket */
      164      bspace fixed bin (32),                                 /* amount of space allocated or deallocated to a socket */
      165      mspace fixed bin (16),                                 /* number of message transmissions allocated
      166*                                                               or deallocated to a socket */
      167      status bit (18);                                       /* link status returned by calls to imp_dim_ */
      168 
      169 /* The following are "pointers" into the linked list of a socket's RFC blocks, being a RFC table index to
      170*   an RFC block.  Special values: -1 = points to before the beginning of a list.
      171*   0 = points beyond the end of a list */
      172 
      173 dcl  qn fixed bin,                                          /* points to the "current" RFC block */
      174      pqn fixed bin,                                         /* points to the block previous to the current block */
      175      ppqn fixed bin (18);                                   /* points to the block previous to the previous block (except in backup operations) */
      176 
      177 
      178 /* BASED DECLARATIONS FOR CONTROL MESSAGE FORMATS */
      179 
      180 dcl 1 sccom based (cpr) unaligned,                          /* RTS, STR, CLS */
      181     2 com bit (8),
      182     2 rsoc bit (32),
      183     2 ssoc bit (32),
      184     2 link bit (8);                                         /* link for RTS, byte size for STR */
      185 
      186 dcl 1 lkcom based (cpr) unaligned,                          /* GVB, INR, INS */
      187     2 com bit (8),
      188     2 link bit (8),
      189     2 mfrac bit (8),                                        /* GVB only */
      190     2 bfrac bit (8);                                        /* GVB only */
      191 
      192 dcl 1 spcom based (cpr) unaligned,                          /* ALL, RET */
      193     2 com bit (8),
      194     2 link bit (8),
      195     2 mspace bit (16),
      196     2 bspace bit (32);
      197 
      198 dcl 1 ercom based (cpr) unaligned,                          /* ECO, ERP, ERR */
      199     2 com bit (8),
      200     2 code bit (8),
      201     2 txt bit (80);                                         /* ERR only */
      202 
      203 dcl  bit80 bit (80) based;                                  /* template for referencing entire ctl message */
      204 
      205 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      206 
      207                                         /*      This entry is used to process user calls.  The argument       */
      208                                         /* stating the type of request and all other arguments are found in   */
      209                                         /* the structure global_data (referenced by "gdt").  The defined      */
      210                                         /* requests and the arguments each takes are listed as follows:       */
      211 /*
      212*
      213*   gdt.request_code =
      214*
      215*   1 - abort        IN: gdt.ncp_idx; OUT: gdt.state, gdt.error_code.
      216*   2 - connect      IN: gdt.ncp_idx, gdt.fsoc; OUT: gdt.state, gdt.error_code.
      217*   3 - listen       IN: gdt.priv_code, gdt.ncp_idx; OUT: gdt.state, gdt.error_code.
      218*   4 - reject       same
      219*   5 - accept       same
      220*   6 - close        same
      221*   7 - force_deac   same
      222*   8 - sendquit     same
      223*   9 - quitenable   same
      224*   10 - quitinhibit same
      225*   11 - setbytesize IN: gdt.priv_code, gdt.ncp_idx, gdt.areap; OUT: gdt.state, gdt.error_code.
      226*   12 - getbytesize same
      227*   13 - read        IN: gdt.ncp_idx, gdt.areap, gdt.nbytes; OUT: gdt.nelemt, gdt.state, gdt.error_code.
      228*   14 - state       IN: gdt.ncp_idx. OUT: gdt.fsoc, gdt.state, gdt.error_code.
      229*   15 - write       IN: gdt.ncp_idx, gdt.areap, gdt.nbytes; OUT: gdt.nelemt, gdt.state, gdt.error_code.
      230*   16 - deactivate  IN: gdt.ncp_idx; OUT: gdt.error_code.
      231*   (17 - write_force)
      232*   18 - buf         IN: gdt.gs_host, gdt.gs_linkn, gdt.gs_r_w; OUT: gdt.error_code.
      233*   19 - no oper.    OUT: gdt.error_code.
      234*   (20 - activate)
      235*   (21 - priv_activate)
      236*   (22 - passoff)
      237*   (23 - host_on)
      238*   (24 - host_off)
      239*   (25 - proc_host_down)
      240*   (26 - send_rst)
      241*   (27 - proc_rst)
      242*   (28 - proc_rrp)
      243*   (29 - send_eco)
      244*   30 - get_umodes  IN: gdt.priv_code, gdt.ncp_idx, gdt.areap; OUT: gdt.state, gdt.error_code.
      245*   31 - set_umodes  same
      246*   (32 - set_global_evchn)
      247*   (33 - pin_state)
      248*   (34 - socket_state)
      249*   (35 - get_userid)
      250*   (36 - set_userid)
      251*
      252*   */
      253 
      254 process_call:
      255           entry (procpx);
      256 
      257           procp = procpx;
      258           gpr = procp -> pdt.gdtp;
      259           pcode = gpr -> gdt.privilege_code;
      260           ccode = gpr -> gdt.request_code;
      261           fsoct, fsocr = ""b;
      262           gpr -> gdt.state = 0;
      263 
      264           npr = addr (ncp_tables_$ncp_data);
      265           spr = addr (ncp_tables_$socket_tbl);
      266           hpr = addr (ncp_tables_$host_tbl);
      267           rpr = addr (ncp_tables_$rfc_tbl);
      268           mpr = addr (ncp_tables_$meter_cells);
      269 
      270           procid = procp -> pdt.processid;
      271 
      272           if ncp_tables_$tracing_info ^= ""b
      273           then call ncp_trace_ (TRACE_NCP_TBOP, "tbop_$process_call:  ^w -- ^d", procid, gpr -> gdt.request_code);
      274 
      275           if (gpr -> gdt.request_code > 32) & (gpr -> gdt.request_code < 35) then do;
      276                call ncp_util_$find_socket_from_socket_number (binary (substr (gpr -> gdt.fsoc, 1, 32)), binary (substr (gpr -> gdt.fsoc, 33, 32)), bit (pcode > 0, 1), sep, icode);
      277                if icode = 0
      278                then do;
      279                     gpr -> gdt.ncp_idx = sep -> socket.socket_index;
      280                     ccode = 14;
      281                     goto socket_is_locked;
      282                     end;
      283                gpr -> gdt.ncp_idx = ""b;
      284                gpr -> gdt.error_code = error_table_$net_socket_not_found;
      285                goto return_to_user;
      286           end;
      287 
      288           if gpr -> gdt.request_code = 19 then goto return_zero_error;
      289 
      290           if gpr -> gdt.request_code = 18 then do;
      291                call ncp_util_$find_socket_from_link_number (gpr -> gdt.gq_host_id, gpr -> gdt.gq_link, "1"b, sep, icode);
      292                if icode = 0
      293                then do;
      294                     gpr -> gdt.ncp_idx = sep -> socket.socket_index;
      295                     ccode = 24;                        /* change to value table processor expects */
      296                     goto socket_is_locked;
      297                     end;
      298                call ncp_error_ (icode, "TBOP_buf_socket");            /* we didnt find this socket   */
      299                return;
      300                end;
      301 
      302           call ncp_util_$find_socket_from_index (gpr -> gdt.ncp_idx, bit (pcode > 0, 1), sep, icode);
      303           if icode ^= 0
      304           then do;
      305                gpr -> gdt.error_code = error_table_$bad_index;   /* invalid index */
      306                goto return_to_user;
      307                end;
      308 
      309 socket_is_locked:
      310           lockp = addr (sep -> socket.lock);
      311           return_label = return_to_user;
      312 
      313           host_tb_index = sep -> socket.host_entry_index;      /* get table index of foreign host */
      314 pcom_state_tbl_init:
      315           gpr -> gdt.error_code = 0;
      316           lsoct = string (sep -> socket.local_socket);
      317           fsoct, fsocr = string (sep -> socket.foreign_socket);
      318           gpr -> gdt.state = binary (sep -> socket.state, 6);
      319           queue_level = 0;
      320           qn, pqn, ppqn = -1;
      321 
      322           curp = pointer (addr (ncp_tbl_$base), ncp_tbl_$com_state_tbl (ccode, gpr -> gdt.state));
      323           goto start_operation;
      324 
      325 return_to_user:
      326           call ncp_lock_$unlock_all (icode);          /* unlock locks still left set */
      327           gpr -> gdt.fsoc = fsoct;
      328           if gpr -> gdt.error_code = error_table_$imp_rfnm_pending
      329           then gpr -> gdt.error_code = 0;
      330           return;
      331 
      332 return_zero_error:
      333           gpr -> gdt.error_code = 0;
      334 return_error:
      335           return;
      336 
      337 
      338           /* * * * * * * * * * * * * * * * * * * * * * * * */
      339 
      340 process_ctl_mess:
      341           entry (procpx);
      342 
      343           procp = procpx;
      344           gpr = procp -> pdt.gdtp;
      345           procid = procp -> pdt.processid;
      346           pcode = 3;
      347           return_label = return_error;
      348 
      349           npr = addr (ncp_tables_$ncp_data);
      350           spr = addr (ncp_tables_$socket_tbl);
      351           hpr = addr (ncp_tables_$host_tbl);
      352           rpr = addr (ncp_tables_$rfc_tbl);
      353           mpr = addr (ncp_tables_$meter_cells);
      354 
      355           if ncp_tables_$tracing_info ^= ""b
      356           then call ncp_trace_ (TRACE_NCP_TBOP, "ncp_tbop_$process_ctl_mess:  host ^d, len ^d", gpr -> gdt.gq_host_id, gpr -> gdt.nbytes);
      357 
      358           gpr -> gdt.nelemt = 0;
      359           com_len = 0;
      360           mpr -> meter_dt.ncp_wakeup_count (5) = mpr -> meter_dt.ncp_wakeup_count (5) + 1;
      361 
      362           host_code = gpr -> gdt.gq_host_id;         /* code of host which sent message */
      363           host_tb_index = gpr -> gdt.host_tbl_index;
      364           if hpr -> host_array (host_tb_index).host_number ^= host_code then do;
      365                call ncp_error_ (error_table_$net_fhost_inactive, "TBOP_msg_from_inactive_host");
      366                return;
      367                end;
      368 
      369           if hpr -> host_array (host_tb_index).host_state = bit (binary (HOST_OFF, 6))
      370           then do;                      /* we have turned this host off */
      371                gpr -> gdt.error_code = error_table_$net_fhost_inactive;
      372                goto return_error;
      373           end;
      374                                                             /* otherwise this host is valid and is enabled */
      375 
      376           cpr = gpr -> gdt.areap;
      377 
      378           ccode = binary (cpr -> sccom.com, 8);
      379           ccode = min (ccode, 15);
      380 
      381           curp = pointer (addr (ncp_tbl_$base), ncp_tbl_$ctl_tbl (ccode));
      382           goto start_operation;
      383 
      384 /* */
      385 /* CODE TO MANAGE THE MICROFUNCTION PROCESSOR FOLLOWS */
      386 
      387 next:
      388           curp = pointer (curp, curp -> ctlb.next);         /* Gets the next operation block in the sequence */
      389 
      390 start_operation:
      391           j = binary (curp -> ctlb.op, 18);
      392 
      393           if ncp_tables_$tracing_info ^= ""b
      394           then do;
      395                oper_loc = binary (rel (curp), 18) - binary (rel (addr (ncp_tbl_$base)), 18);
      396                call ncp_trace_ (TRACE_NCP_TBOP, "OPER ^2d @ ^6o  ^w  ^w", j, oper_loc, procid, gpr -> gdt.ncp_idx);
      397                end;
      398 
      399           mpr -> meter_dt.tbop_mf_count (j) = mpr -> meter_dt.tbop_mf_count (j) + 1;
      400           goto operation (j);                               /* Enters the new microfunction processor */
      401 
      402 transfer_arg_a:
      403           curp = pointer (curp, curp -> ctlb.a);          /* set up for transfer to first argument */
      404           goto start_operation;                             /* effect transfer */
      405 
      406 transfer_arg_b:
      407           curp = pointer (curp, curp -> ctlb.b);          /* set up for transfer to second argument */
      408           goto start_operation;
      409 
      410 transfer_arg_c:
      411           curp = pointer (curp, curp -> ctlb.c);          /* set up for transfer to second argument */
      412           goto start_operation;
      413 
      414 
      415 
      416 /*  CODE BLOCKS TO IMPLEMENT THE MICROFUNCTIONS FOLLOW */
      417 
      418 
      419 /* allocate_write <microlabel>; */
      420 /* assumes the process_com and find_entry variable sets */
      421 /* Increase the output allocation for this socket by the amount specified in an ALL control message */
      422 /* Transfers to <microlabel> after processing if the writing process needs no wakeup */
      423 
      424 operation (3):
      425 
      426           call imp_order$imp_update_write_allocation ((sep -> socket.impdim_index),
      427                     binary (spcom.mspace, 16),
      428                     binary (spcom.bspace, 32));
      429           goto next;
      430 
      431 
      432 /* byte_length <n>; */
      433 /* sets the "txlen" cell and the ncp_tbop_$process_com argument "com_len" to <n> */
      434 
      435 operation (5):
      436           com_len = binary (curp -> ctlb.a, 18);
      437           goto next;
      438 
      439 
      440 /* find_entry_link_transfer <read_write> <com_code>; */
      441 /* Assumes the process_com variable set */
      442 /* Finds the socket table entry  for this read/write link (depending on the
      443*   <read_write> pseudo-argument).  Initializes the find_entry
      444*   variable set and enters the com_state table in the <com_code> by socket-state
      445*   position.  Continues to the next operation block if the socket table entry is not found. */
      446 
      447 operation (15):
      448           linkt = binary (cpr -> lkcom.link, 8);                        /* get link number related to this message */
      449           rw = binary (curp -> ctlb.a, 18);                              /* get r_w pseudo-argument */
      450           ccode = binary (curp -> ctlb.b, 18);                           /* get command code pseudo-argument */
      451 
      452           call ncp_util_$find_socket_from_link_number (host_code, (linkt), bit (binary (rw, 1)), sep, icode);
      453           if icode ^= 0
      454           then goto next;               /* dould not find link                  */
      455 
      456           lockp = addr (sep -> socket.lock);
      457           gpr -> gdt.ncp_idx = sep -> socket.socket_index;
      458           goto pcom_state_tbl_init;
      459 
      460 /* local_read_socket <microlabel>; */
      461 /* assumes user call or process_com and find_entry variable sets */
      462 /* Transfers to <microlabel> if the local socket is a "read" socket */
      463 
      464 operation (24):
      465           if sep -> socket.send_gender = READ_GENDER
      466           then goto transfer_arg_a;            /* this is a read socket */
      467           goto next;
      468 
      469 
      470 /* return_; */
      471 /* Leaves the state processor */
      472 
      473 operation (29):
      474           goto return_label;
      475 
      476 
      477 /* signal <wakeup_code>; */
      478 /* assumes the process_com and find_entry variable sets */
      479 /* Sends a wakeup event to the process owning this socket.  If <wakeup_code> = 0 the user process is
      480*   awoken.  If <wakeup_code> = 1 both the user and overseer processes are awoken. */
      481 
      482 operation (35):
      483           call ncp_access_$signal_process (sep, binary (ctlb.a, 1), (0));
      484 
      485           goto next;
      486 
      487 
      488 /* unlock_return; */
      489 /* assumes the user call or process_com and find_entry variable sets */
      490 /* Unlocks the socket table entry and leaves the state processor */
      491 
      492 operation (40):
      493 unlock_return1:
      494           call ncp_lock_$lock_unlock (lockp, icode);
      495           goto return_label;
      496 
      497 
      498 /* THE FOLLOWING MICROFUNCTIONS ARE IN THE SECOND FREQUENCY-OF-INVOCATION GROUP */
      499 
      500 /* assign_link <rw> <microlabel>; */
      501 /* assumes the user call or process_com and find_entry variable sets */
      502 /* If <rw> = 0, assigns a read link from the foreign host not currently in use to this socket, and places it in
      503*   "linkt".  Calls imp_dim_ to attach the "read" or "write" link specified by "linkt" and the host id
      504*   (contained in "fsoct"), and inserts "linkt" into "sep -> socket.link_number".
      505*   Transfers to <microlabel> if unable to assign or attach the link. */
      506 
      507 operation (4):
      508           if sep -> socket.send_gender = WRITE_GENDER
      509           then do;                                          /* this is a write link, other guy chooses link   */
      510                sep -> socket.link_number = linkt;
      511                end;
      512 
      513           call ncp_access_$assign_link (sep, gpr -> gdt.error_code);
      514           if gpr -> gdt.error_code ^= 0
      515           then do;
      516                if (gpr -> gdt.error_code = error_table_$net_fhost_inactive) | (gpr -> gdt.error_code = error_table_$notalloc)
      517                then goto transfer_arg_b;
      518 
      519                call ncp_error_ (gpr -> gdt.error_code, "TBOP_assign_link_error");
      520                return;
      521                end;
      522 
      523           linkt = sep -> socket.link_number;
      524 
      525           goto next;
      526 
      527 
      528 
      529 /* ctl_mess <fragment_code_0> <fragment_code_1> <fragment_code_2> <fragment_code_3>; */
      530 /* assumes the user call or process com variable set */
      531 /* Sends to the foreign NCP in this connection a control message specified by the fragment codes */
      532 
      533 operation (8):
      534           substr (control_message, 1, 8) = bit (binary (ctlb.a, 8)); /* first arg is always opcode */
      535 
      536           i = 2;                                         /* used as argument count */
      537           j = 9;                                            /* used as bit index */
      538 
      539 cm_get_arg:
      540           k = binary (ctlb1.arg (i), 17) - 64;                         /* get arg code */
      541           if k < 0 then goto cm_put_out;                    /* not valid - indicates control message is complete */
      542           goto cm_op (k);                                   /* transfer indirect to processor for this fragment */
      543 
      544 cm_get_nxt:
      545           i = i + 1;                                      /* increment pseudo-argument counter */
      546           if i <= 4 then goto cm_get_arg;                   /* there are more args to process */
      547 
      548 cm_put_out:
      549           if (host_tb_index <= 0) | (host_tb_index > npr -> ncp_dt.htbl_gent)
      550           then do;
      551                call ncp_error_ (0, "TBOP_bad_host_index");
      552                return;
      553                end;
      554 
      555           host_ptr = addr (hpr -> host_array (host_tb_index));
      556           if host_ptr -> host.host_state = bit (binary (HOST_OFF, 6))
      557           then do;
      558                call ncp_error_ (error_table_$net_fhost_inactive, "TBOP_sending_ctl_msg");
      559                return;
      560                end;
      561 
      562           num_bytes = divide (j, 8, 17, 0);                         /* i now is the byte length of the full message */
      563           call ncp_util_$send_control_message (addr (hpr -> host_array (host_tb_index)), addr (control_message), num_bytes, icode);
      564           if icode = 0 then goto next;                      /* IMP DIM took the message, all o.k. */
      565           gpr -> gdt.error_code = icode;                           /* record some kind of error */
      566           call ncp_error_ (icode, "TBOP_unable_to_send_ctl_msg");
      567           return;
      568 
      569 cm_op (0):
      570           substr (control_message, j, 32) = substr (fsoct, 33, 32); /* insert foreign socket id */
      571           j = j + 32;                                       /* increment bit counter */
      572           goto cm_get_nxt;
      573 
      574 cm_op (1):
      575           substr (control_message, j, 32) = substr (lsoct, 33, 32); /* insert local socket id */
      576           j = j + 32;
      577           goto cm_get_nxt;
      578 
      579 cm_op (2):
      580           substr (control_message, j, 8) = bit (binary (sep -> socket.link_number, 8)); /* insert link number */
      581           j = j + 8;
      582           goto cm_get_nxt;
      583 
      584 cm_op (3):
      585           substr (control_message, j, 32) = bit (binary (bspace, 32)); /* insert bit space cell */
      586           j = j + 32;
      587           goto cm_get_nxt;
      588 
      589 cm_op (4):
      590           substr (control_message, j, 16) = bit (binary (mspace, 16)); /* insert message space cell */
      591           j = j + 16;
      592           goto cm_get_nxt;
      593 
      594 cm_op (5):
      595           i = i + 1;                                        /* increment to get code fragment */
      596           substr (control_message, j, 8) = bit (binary (ctlb1.arg (i), 8)); /* insert code field */
      597           j = j + 8;
      598           goto cm_get_nxt;
      599 
      600 cm_op (6):
      601           substr (control_message, j, 80) = ""b;
      602           substr (control_message, j, com_len) = cpr -> bit80; /* insert into text part of ERR message */
      603           j = j + 80;
      604           goto cm_get_nxt;
      605 
      606 cm_op (7):
      607           substr (control_message, j, 8) = cpr -> ercom.code;
      608           j = j + 8;
      609           goto cm_get_nxt;
      610 
      611 cm_op (8):
      612           substr (control_message, j, 32) = substr (fsoct1, 33, 32); /* insert foreign socket id */
      613           j = j + 32;                                       /* increment bit counter */
      614           goto cm_get_nxt;
      615 
      616 cm_op (9):
      617           substr (control_message, j, 8) = sep -> socket.byte_size;
      618           j = j + 8;
      619           goto cm_get_nxt;
      620 
      621 
      622 
      623 /* deac_sw <microlabel>; */
      624 /* assumes the user_call or process_com and find_entry variable groups */
      625 /* Transfers to <microlabel> if the "socket.deactivate" is "on". */
      626 
      627 operation (9):
      628           if sep -> socket.deactivate then goto transfer_arg_a;         /* transfer to <microlabel> */
      629           goto next;
      630 
      631 
      632 /* find_entry_sock_transfer <com_code>; */
      633 /* assumes the process_com variable set */
      634 /* Performs similarly to find_entry_link_transfer, except it searches for the socket table
      635*   entry according to the local socket identifier in the cell "lsoc".  Continues to the
      636*   next operation block if the socket entry is not found. */
      637 
      638 operation (16):
      639           ccode = binary (curp -> ctlb.a, 18);                           /* get command code pseudo-argument */
      640 
      641           call ncp_util_$find_socket_from_socket_number (binary (substr (lsoct, 1, 32)), binary (substr (lsoct, 33, 32)), "1"b, sep, icode);
      642           if icode ^= 0
      643           then goto next;                         /* could not find socket      */
      644 
      645           lockp = addr (sep -> socket.lock);
      646           gpr -> gdt.ncp_idx = sep -> socket.socket_index;
      647           goto pcom_state_tbl_init;
      648 
      649 
      650 /* fsoc_unequal <microlabel>; */
      651 /* assumes the process_com and find_entry variable sets */
      652 /* If the temporary cells "fsoct" and "fsoct1" are unequal then transfer to <microlabel>.
      653*   Otherwise continue. */
      654 
      655 operation (17):
      656           if fsoct ^= fsoct1 then goto transfer_arg_a;      /* transfer to <microlabel> */
      657           goto next;
      658 
      659 
      660 /* get_nxt_rfc <microlabel>; */
      661 /* assumes the  user call or process_com and find_entry variable sets */
      662 /* Advances to the next RFC block in the list by setting "pqn" and "qn" block indicies if "looked_sw" is "on".
      663*   If this is the end of the list, it transfers to <microlabel>.  Otherwise, it pulls data from the new
      664*   block into the cells "fsoct" and "linkt". */
      665 
      666 operation (18):
      667           ppqn = pqn;                                       /* update pp cell */
      668           pqn = qn;                                         /* same */
      669           if pqn = -1
      670           then qn = sep -> socket.rfc_queue;                 /* get first cell if at front */
      671           else if pqn = 0
      672                then do;                          /* we are at the end, this is an error */
      673                     call ncp_error_ (0, "TBOP_no_next_RFC");
      674                     return;
      675                     end;
      676                else qn = rpr -> rfc_array (pqn).next_entry;                    /* get index of next cell */
      677 
      678           queue_level = queue_level + 1;                    /* one more level down */
      679           if queue_level > 10 then do;                      /* we are beyond reasonable limit - error */
      680                call ncp_error_ (0, "TBOP_too_many_RFCs");
      681                return;
      682           end;
      683 
      684           if qn = 0 then goto transfer_arg_a;               /* this is the end of the list, transfer */
      685 
      686           fsoct = string (rpr -> rfc_array (qn).foreign_socket);                        /* get items from RFC block */
      687           linkt = rpr -> rfc_array (qn).foreign_hosts_choice;
      688           goto next;
      689 
      690 
      691 /* get_sockets <RSC> <errorlabel>; */
      692 /* assumes the process_com variable set */
      693 /* <RSC> = 1 for an RTS, 2 for an STR, 3 for a CLS */
      694 /* Transfers to <errorlabel> if the socket polarity is bad.
      695*   Examines the received control message in RTS, STR, or CLS format and sets "fsoct1" and "lsoct".
      696*   If an RTS, sets "linkt" from RTS link cell; if an STR, sets "bytet" from STR bytesize cell. */
      697 
      698 operation (19):
      699           if substr (sccom.ssoc, 32, 1) = substr (sccom.rsoc, 32, 1) then goto transfer_arg_b;
      700           j = binary (curp -> ctlb.a, 18);                               /* set j to <RSC> */
      701           if binary (substr (sccom.ssoc, 32, 1), 1) = j-1
      702           then goto transfer_arg_b;
      703 
      704           if j ^= 3
      705           then do;
      706                if sccom.link = ""b
      707                then goto transfer_arg_b;
      708                end;
      709 
      710           fsoct1 = bit (binary (hpr -> host_array (host_tb_index).host_number, 32), 32) || sccom.rsoc; /* get foreign socket id */
      711           lsoct = bit (binary (npr -> ncp_dt.host_id, 32), 32) || sccom.ssoc;        /* get local socket id */
      712           if j /* <RSC> */ > 2
      713           then goto next;              /* this is a CLS */
      714           else if j = 2
      715                then do;
      716                     bytet = sccom.link;
      717                     linkt = 0;
      718                     end;
      719                else do;
      720                     linkt = binary (sccom.link, 8);
      721                     bytet = ""b;
      722                     end;
      723           goto next;
      724 
      725 
      726 /* insert_socket_id <arg_sw> <hostlabel> <gendlabel>; */
      727 /* assumes the user call variable set */
      728 /* If <arg_sw> = 0 sets the cell "fsoct" from the input argument "fsoc".  Transfers to <gendlabel> if this local socket
      729*   and "fsoct" are of the same gender.  Checks the supplied host id with
      730*   the host table and transfers to <hostlabel> if the host id is not found in it.  Sets the socket entry's
      731*   "fsoc" cell from "fsoct" and sets "host_tb_index" and "socket.host_entry_index" from the host table entry's index */
      732 
      733 operation (22):
      734           if ctlb.a = ""b then fsoct = gpr -> gdt.fsoc;
      735           if substr (fsoct, 64, 1) = substr (sep -> socket.local_socket.socket_num, 32, 1) then goto transfer_arg_c;
      736 
      737           host_code = binary (substr (fsoct, 1, 32), 32);
      738 
      739           call ncp_util_$find_host_entry (host_code, "0"b, host_ptr, icode);
      740           if icode ^= 0
      741           then goto transfer_arg_b;
      742 
      743           host_tb_index = host_ptr -> host.hash_index;
      744 
      745           sep -> socket.host_entry_index = host_tb_index;
      746           string (sep -> socket.foreign_socket) = fsoct;
      747           goto next;
      748 
      749 
      750 /* state_ul_return <state>; */
      751 /* assumes the user call or process_com and find_entry variable sets */
      752 /* In addition to actions of "state" microfunction above, this unlocks the socket table entry
      753*   and leaves the state processor */
      754 
      755 operation (38):
      756           i = 2;                                            /* tells common code this is "state_ul_return" */
      757 
      758 state_common:
      759           j = binary (curp -> ctlb.a, 18);
      760 
      761           call ncp_access_$change_socket_state (sep, binary (j, 6), (0));
      762           if i ^= 1
      763           then gpr -> gdt.state = binary (sep -> socket.state);                     /* "state_ns" */
      764           if i = 2 then goto unlock_return1;                /* "state_ul_return" */
      765           goto next;                                        /* "state_" and "state_ns" */
      766 
      767 
      768 
      769 /* unassign_link <spec>; */
      770 /* assumes the user call or process_com and find_entry variable sets */
      771 /* Calls the imp_dim to detach the link associated with this socket connection.  ("socket.impdim_index" contains
      772*   the imp_dim index.)  <spec> is not referenced. */
      773 
      774 operation (39):
      775           call ncp_access_$unassign_link (sep, gpr -> gdt.error_code);
      776           if gpr -> gdt.error_code ^= 0
      777           then call ncp_error_ (gpr -> gdt.error_code, "TBOP_unassigning_link");
      778 
      779           goto next;
      780 
      781 
      782 
      783 
      784 
      785 
      786 /* THE FOLLOWING MICROFUNCTIONS ARE IN THE THIRD FREQUENCY-OF-INVOCATION GROUP */
      787 
      788 /* add_to_queue <clslabel>; */
      789 /* assumes process_com, find_entry, and get_sockets variable sets */
      790 /* Adds an RFC block to the end of the queue for this entry, using "fsoct1" as the foreign socket id. */
      791 
      792 operation (1):
      793           if sep -> socket.send_gender = WRITE_GENDER then if linkt = 0
      794           then goto transfer_arg_a; /* this is a foreign error */
      795           i = 1;                                            /* set up for full iteration thru rfc_array */
      796 
      797 atq_restart:
      798           do i = i to npr -> ncp_dt.rtbl_gent;                  /* search for empty block in already allocated table space */
      799                if stacq (addr (rpr -> rfc_array (i).foreign_hosts_choice) -> based_lock, "1"b, (36)"0"b)
      800                then goto atq_got_block;
      801                end;
      802 
      803                                                             /* lock rfc table here */
      804           if npr -> ncp_dt.rtbl_gent = npr -> ncp_dt.rtbl_size then do;   /* The table is expanded to its full size now */
      805                goto transfer_arg_a;                         /* transfer to <clslabel> */
      806           end;
      807           npr -> ncp_dt.rtbl_gent = npr -> ncp_dt.rtbl_gent + 1;          /* expand by 1 */
      808           i = npr -> ncp_dt.rtbl_gent;
      809                                                             /* unlock rfc tbl here */
      810           goto atq_restart;
      811 
      812 atq_got_block:
      813           string (rpr -> rfc_array (i).foreign_socket) = fsoct1;                   /* set in foreign socket id */
      814           if sep -> socket.send_gender = WRITE_GENDER
      815           then rpr -> rfc_array (i).foreign_hosts_choice = linkt;
      816           else rpr -> rfc_array (i).foreign_hosts_choice = -1;           /* no link specified, this -1 keeps this entry allocated */
      817 
      818 atq_put_in_soct:
      819           if qn = 0 then do;                         /* we're at the end of the rfc chain */
      820                if pqn = -1
      821                then sep -> socket.rfc_queue = i;             /* attach to socket tbl queue cell */
      822                else rpr -> rfc_array (pqn).next_entry = i;                /* attach to end of rfc queue chain */
      823           end;
      824           else do;                                          /* go to next level down */
      825                ppqn = pqn;
      826                pqn = qn;
      827                if pqn = -1
      828                then qn = sep -> socket.rfc_queue;
      829                else qn = rpr -> rfc_array (pqn).next_entry;
      830                goto atq_put_in_soct;
      831           end;
      832           goto next;
      833 
      834 
      835 /* allocate_read; */
      836 /* assumes user call or process_com and find_entry variable sets */
      837 /* allocates more space to this "read" socket and sets the "space" cell to the amount of additional space allocated */
      838 
      839 operation (2):
      840           call ncp_connection_$allocate_read (sep, gpr -> gdt.error_code);
      841           if gpr -> gdt.error_code ^= 0
      842           then do;
      843                call ncp_error_ (gpr -> gdt.error_code, "TBOP_allocating_for_read");
      844                return;
      845                end;
      846 
      847           goto next;
      848 
      849 
      850 /* check_for_rfnm <microlabel>; */
      851 /* assumes the user call or process_com and find_entry variable sets */
      852 /* Transfers control to the operation block sequence <microlabel> if the IMP DIM buffers for this
      853*   link are empty and (if this is a write link) the RFNM from the latest message has returned */
      854 
      855 operation (7):
      856           if sep -> socket.send_gender = WRITE_GENDER
      857           then call imp_write_order ((sep -> socket.impdim_index), IMP_ORDER_get_status, null (), status, icode);
      858           else call imp_read_order ((sep -> socket.impdim_index), IMP_ORDER_get_status, null (), status, icode);
      859           if ^substr (status, 12, 1) then if ^substr (status, 17, 1) then goto transfer_arg_a; /* goto <microlabel> */
      860           goto next;
      861 
      862 
      863 /* delete_rfc; */
      864 /* assumes the user call or process_com and find_entry variable sets. "qn" is the index of the RFC block
      865*   to be removed, and "pqn" is the index of the previous block. */
      866 /* Deletes an RFC block from this socket's queue. */
      867 
      868 operation (12):
      869           i = rpr -> rfc_array (qn).next_entry;                           /* index contained in block to be deleted */
      870           string (rpr -> rfc_array (qn).foreign_socket) = ""b;
      871           rpr -> rfc_array (qn).next_entry = 0;
      872           tpr = addr(rpr -> rfc_array (qn).foreign_hosts_choice);
      873           success = stacq (tpr -> based_lock, (36)"0"b, tpr -> based_lock);
      874 
      875           qn = pqn;                                         /* back up */
      876           if pqn = -1 then do;                              /* back to begining of list */
      877                sep -> socket.rfc_queue = i;                              /* make front the remainder of the list */
      878                goto next;
      879           end;
      880           else rpr -> rfc_array (pqn).next_entry = i;                     /* insert in previous block */
      881 
      882           pqn = ppqn;
      883           ppqn = 262143;                                 /* set to large invalid number */
      884           queue_level = queue_level - 1;
      885           goto next;
      886 
      887 
      888 /* err_code <code>; */
      889 /* Sets the err_codet cell to <code> */
      890 
      891 operation (13):
      892           i = binary (curp -> ctlb.a, 18);
      893           if i = 1 then gpr -> gdt.error_code = error_table_$net_invalid_state;
      894 /*          else if i = 2 then gpr -> gdt.error_code = error_table_$net_socket_closed;  */
      895           else if i = 3 then gpr -> gdt.error_code = error_table_$net_fhost_inactive;
      896           else if i = 4 then gpr -> gdt.error_code = error_table_$net_bad_gender;
      897           else if i = 5 then gpr -> gdt.error_code = error_table_$notalloc;
      898           else do;                                          /* error index not known */
      899                call ncp_error_ (0, "TBOP_unknown_error_code_index");
      900                return;
      901           end;
      902           goto next;
      903 
      904 
      905 /* go_to <microlabel>; */
      906 /* Transfers to <microlabel> */
      907 
      908 operation (20):
      909           goto transfer_arg_a;                              /* transfer to <microlabel> */
      910 
      911 
      912 /* imp_abort; */
      913 /* assumes the user call or process_com and find_entry variable sets */
      914 /* Calls imp_dim_ to reset the internal buffers for the link associated with this socket */
      915 
      916 operation (21):
      917           i = sep -> socket.impdim_index;
      918           if sep -> socket.send_gender = WRITE_GENDER
      919           then call imp_write_order ((i), IMP_ORDER_abort_transfer, null, status, gpr -> gdt.error_code);
      920          /*        else call imp_read_order ((i), IMP_ORDER_abort_transfer, null, status, gpr -> gdt.error_code); EWM -10/10/72 */
      921           goto next;
      922 
      923 
      924 /* set_fsocr; */
      925 /* assumes the user call variable set */
      926 /* Sets the fsoc argument return cell "fsocr" in a user call from the cell "fsoct" */
      927 
      928 operation (34):
      929           fsocr = fsoct;
      930           goto next;
      931 
      932 
      933 
      934 
      935 /* THE FOLLOWING MICROFUNCTIONS ARE IN THE FOURTH (LAST) FREQUENCY-OF-INVOCATION GROUP */
      936 
      937 /* check_bytesize <unequallabel>; */
      938 /* assumes the process_com and find_entry variable sets plus "bytet" */
      939 /* Transfers to <unequallabel> if "bytet" ^= socket.byte_size */
      940 
      941 operation (6):
      942           if bytet ^= sep -> socket.byte_size then goto transfer_arg_a;
      943           goto next;
      944 
      945 
      946 /* deactivate; */
      947 /* assumes the user_call or process_com and find_entry variable groups */
      948 /* deactivates this socket table entry.  Only the overseer process can deactivate a socket. */
      949 
      950 operation (10):
      951           if pcode = 0 then if procid ^= sep -> socket.overseer_process_id then do;
      952                gpr -> gdt.error_code = error_table_$bad_processid; /* bad process id */
      953                goto next;
      954           end;
      955           call ncp_access_$deactivate_socket (sep, icode);
      956           gpr-> gdt.error_code = icode;
      957           goto next;                                        /* the now empty slot is still locked */
      958 
      959 
      960 /* deallocate_write; */
      961 /* assumes the process_com and find_entry variable sets */
      962 /* Decrease the output allocation for this socket by the amount specified in a GVB control message */
      963 
      964 operation (11):
      965           i = binary (lkcom.bfrac, 8);                                  /* get fraction of bit allocation to send back */
      966           if i > 127
      967           then bspace = sep -> socket.bit_allocation;             /* we are to return all */
      968           else bspace = divide (sep -> socket.bit_allocation * i, 128, 35, 0); /* get fraction to return */
      969           sep -> socket.bit_allocation = sep -> socket.bit_allocation - bspace;               /* this is new allocation */
      970 
      971           i = binary (lkcom.mfrac, 8);                                  /* repeat for message allocation */
      972           if i > 127
      973           then mspace = sep -> socket.msg_allocation;
      974           else mspace = divide (sep -> socket.msg_allocation * i, 128, 35, 0);
      975           sep -> socket.msg_allocation = sep -> socket.msg_allocation - mspace;
      976           goto next;
      977 
      978 
      979 /* interrupt; */
      980 /* assumes user call or process_com and find entry variable sets */
      981 /* Signals an interrupt for this process if the entry's "int_ok" switch is on */
      982 
      983 operation (23):
      984           if sep -> socket.signal_event_channel ^= 0
      985           then do;
      986                addr (event_msg) -> msg_chr8 = "NCP ";
      987                substr (unspec (event_msg), 37, 36) = gpr -> gdt.ncp_idx;
      988                call pxss$wakeup_int (sep -> socket.process_id, sep -> socket.signal_event_channel, event_msg, icode);
      989                end;
      990 
      991           if sep -> socket.allow_interrupts
      992           then call pxss$ips_wakeup_int (sep -> socket.process_id, ncp_params_$interrupt_signal);
      993           goto next;
      994 
      995 
      996 /* ncp_error <error_code>; */
      997 /* Records an ncp_error */
      998 
      999 operation (25):
     1000           cv_bin_output = cv_bin_$dec (binary (curp -> ctlb.a, 18));
     1001 
     1002           ncp_err_code = "NBtbl_" || substr (cv_bin_output, 11, 2);
     1003           call ncp_error_ (0, ncp_err_code);
     1004           return;
     1005 
     1006 
     1007 
     1008 /* set_deac_sw; */
     1009 /* assumes the user call variable set */
     1010 /* Sets the "socket.deactivate" on for this socket */
     1011 
     1012 operation (31):
     1013           sep -> socket.deactivate = "1"b;
     1014           sep -> socket.allow_interrupts = "0"b;
     1015           sep -> socket.event_channel = 0;
     1016           sep -> socket.overseer_event_channel = 0;
     1017           goto next;
     1018 
     1019 
     1020 /* set_empty_wakeup; */
     1021 /* assumes the user call or process_com and find_entry variable sets */
     1022 /* Tells the imp_dim to wakeup the NCP process when the buffers for this write link become
     1023*   empty and when the last RFNM has returned */
     1024 
     1025 operation (32):
     1026           call imp_write_order ((sep -> socket.impdim_index), IMP_ORDER_pgqlrr, null (), status, icode);
     1027           goto next;
     1028 
     1029 
     1030 /* state_ns <state>; */
     1031 /* assumes user call variable sets */
     1032 /* Sets the state cell of the socket table entry to <state> (does nothing to "statet") */
     1033 
     1034 operation (37):
     1035           i = 1;                                            /* tells main code this is "state_ns" */
     1036           goto state_common;                                /* by "state_ul_return" */
     1037 
     1038 
     1039 /* Obsolete micro-operations -- catch any use of these */
     1040 operation (14):
     1041 operation (26):
     1042 operation (27):
     1043 operation (28):
     1044 operation (30):
     1045 operation (33):
     1046 operation (36):
     1047 operation (41):
     1048           call ncp_error_ (0, "TBOP_obsolete_function");
     1049           return;
     1050 
     1051 end;      /* end ncp_tbop_                                 */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1129.5  ncp_tbop_.pl1                     >dumps>old_dumps>hardcore>ncp_tbop_.pl1
119          1    10/07/77  1700.0  imp_orders.incl.pl1               >ldd>include>imp_orders.incl.pl1
120          2    09/05/79  2206.3  ncp_connection_dcls.incl.pl1      >ldd>include>ncp_connection_dcls.incl.pl1
121          3    10/07/77  1700.0  ncp_constants_dcls.incl.pl1       >ldd>include>ncp_constants_dcls.incl.pl1
122          4    07/24/78  1704.7  ncp_data_dcls.incl.pl1            >ldd>include>ncp_data_dcls.incl.pl1
123          5    07/24/78  1704.7  ncp_process_dcls.incl.pl1         >ldd>include>ncp_process_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HOST_OFF                               constant        fixed bin(6,0)           initial dcl 3-20 ref 369 556
IMP_ORDER_abort_transfer        000112 constant        fixed bin(12,0)          initial dcl 1-9 set ref 918*
IMP_ORDER_get_status            000111 constant        fixed bin(12,0)          initial dcl 1-9 set ref 855* 858*
IMP_ORDER_pgqlrr                000064 constant        fixed bin(12,0)          initial dcl 1-9 set ref 1025*
READ_GENDER                            constant        bit(1)                   initial unaligned dcl 3-15 ref 464
TRACE_NCP_TBOP                  000063 constant        bit(36)                  initial dcl 3-51 set ref 272* 355* 396*
WRITE_GENDER                           constant        bit(1)                   initial unaligned dcl 3-15 ref 507 792 814 855 918
a                         1            based           bit(18)                  level 2 packed unaligned dcl 134 ref 402 435 449 482
                                                                                  482 533 638 700 733 758 891 999 999
addr                                                   builtin function         dcl 113 ref 264 265 266 267 268 309 322 349 350 351
                                                                                  352 353 381 395 456 555 563 563 563 563 645 799
                                                                                  872 986
allow_interrupts         17(15)        based           bit(1)                   level 2 packed unaligned dcl 2-13 set ref 991 1014*
areap                    10            based           pointer                  level 2 dcl 5-9 ref 376
arg                       1            based           bit(18)                  array level 2 packed unaligned dcl 139 ref 539 596
b                         1(18)        based           bit(18)                  level 2 packed unaligned dcl 134 ref 406 450
based_lock                             based           bit(36)                  dcl 60 ref 799 873 873
bfrac                     0(24)        based           bit(8)                   level 2 packed unaligned dcl 186 ref 964
binary                                                 builtin function         dcl 113 ref 276 276 276 276 318 369 378 390 395 395
                                                                                  424 424 424 424 435 447 449 450 452 452 482 482
                                                                                  533 539 556 579 584 589 596 638 641 641 641 641
                                                                                  700 701 710 711 720 737 758 761 761 762 891 964
                                                                                  971 999 999
bit                                                    builtin function         dcl 113 ref 276 276 302 302 369 452 452 533 556 579
                                                                                  584 589 596 710 711
bit80                                  based           bit(80)                  unaligned dcl 203 ref 602
bit_allocation            7            based           fixed bin(32,0)          level 2 dcl 2-13 set ref 966 968 969* 969
bspace                    0(32)        based           bit(32)                  level 2 in structure "spcom" packed unaligned
                                                                                  dcl 192 in procedure "ncp_tbop_" ref 424 424
bspace                          000236 automatic       fixed bin(32,0)          dcl 148 in procedure "ncp_tbop_" set ref 584 966*
                                                                                  968* 969
byte_size                17(06)        based           bit(8)                   level 2 packed unaligned dcl 2-13 ref 616 941
bytet                           000212 automatic       bit(8)                   unaligned dcl 148 set ref 716* 721* 941
c                         2            based           bit(18)                  level 2 packed unaligned dcl 134 ref 410
ccode                           000213 automatic       fixed bin(18,0)          dcl 148 set ref 260* 280* 295* 322 378* 379* 379 381
                                                                                  450* 638*
code                      0(08)        based           bit(8)                   level 2 packed unaligned dcl 198 ref 606
com                                    based           bit(8)                   level 2 packed unaligned dcl 180 ref 378
com_len                         000214 automatic       fixed bin(17,0)          dcl 148 set ref 359* 435* 602
control_message                 000152 automatic       bit(1024)                unaligned dcl 54 set ref 533* 563 563 569* 574* 579*
                                                                                  584* 589* 596* 600* 602* 606* 611* 616*
cpr                             000216 automatic       pointer                  dcl 148 set ref 376* 378 424 424 424 424 447 602 606
                                                                                  698 698 701 706 710 711 716 720 964 971
ctlb                                   based           structure                level 1 dcl 134
ctlb1                                  based           structure                level 1 dcl 139
curp                            000210 automatic       pointer                  dcl 132 set ref 322* 381* 387* 387 387 390 395 402*
                                                                                  402 402 406* 406 406 410* 410 410 435 449 450 482
                                                                                  482 533 539 596 638 700 733 758 891 999 999
cv_bin_$dec                     000046 constant        entry                    external dcl 90 ref 999
cv_bin_output                   000105 automatic       char(12)                 unaligned dcl 25 set ref 999* 1002
deactivate               17(16)        based           bit(1)                   level 2 packed unaligned dcl 2-13 set ref 627 1012*
divide                                                 builtin function         dcl 113 ref 562 968 974
ercom                                  based           structure                level 1 packed unaligned dcl 198
error_code                1            based           fixed bin(35,0)          level 2 dcl 5-9 set ref 284* 305* 314* 328 328* 332*
                                                                                  371* 513* 514 516 516 519* 565* 774* 776 776* 839*
                                                                                  841 843* 893* 895* 896* 897* 918* 952* 956*
error_table_$bad_index          000026 external static fixed bin(35,0)          dcl 77 ref 305
error_table_$bad_processid      000030 external static fixed bin(35,0)          dcl 77 ref 952
error_table_$imp_rfnm_pending   000032 external static fixed bin(35,0)          dcl 77 ref 328
error_table_$net_bad_gender     000036 external static fixed bin(35,0)          dcl 77 ref 896
error_table_$net_fhost_inactive 000040 external static fixed bin(35,0)          dcl 77 set ref 365* 371 516 558* 895
error_table_$net_invalid_state  000034 external static fixed bin(35,0)          dcl 77 ref 893
error_table_$net_socket_not_found
                                000042 external static fixed bin(35,0)          dcl 77 ref 284
error_table_$notalloc           000044 external static fixed bin(35,0)          dcl 77 ref 516 897
event_channel                          based           fixed bin(71,0)          level 2 dcl 2-13 set ref 1015*
event_msg                       000142 automatic       fixed bin(71,0)          dcl 46 set ref 986 987 988*
foreign_hosts_choice      2            based           fixed bin(17,0)          array level 2 packed unaligned dcl 41 set ref 687
                                                                                  799 814* 816* 872
foreign_socket           13            based           structure                level 2 in structure "socket" packed unaligned
                                                                                  dcl 2-13 in procedure "ncp_tbop_" set ref 317 746*
foreign_socket           13            based           structure                array level 2 in structure "socket_array" packed
                                                                                  unaligned dcl 41 in procedure "ncp_tbop_"
foreign_socket                         based           structure                array level 2 in structure "rfc_array" packed
                                                                                  unaligned dcl 41 in procedure "ncp_tbop_" set ref
                                                                                  686 812* 870*
fsoc                     12            based           bit(64)                  level 2 packed unaligned dcl 5-9 set ref 276 276 276
                                                                                  276 327* 733
fsocr                           000220 automatic       bit(64)                  unaligned dcl 148 set ref 261* 317* 928*
fsoct                           000222 automatic       bit(64)                  unaligned dcl 148 set ref 261* 317* 327 569 655 686*
                                                                                  733* 735 737 746 928
fsoct1                          000224 automatic       bit(64)                  unaligned dcl 148 set ref 611 655 710* 812
gdt                                    based           structure                level 1 dcl 5-9
gdtp                                   based           pointer                  level 2 dcl 5-48 ref 258 344
global_queue             32            based           structure                level 2 dcl 5-9
gpr                             000112 automatic       pointer                  dcl 25 set ref 258* 259 260 262 272 275 275 276 276
                                                                                  276 276 279 283 284 288 290 291 291 294 302 305
                                                                                  314 318 322 327 328 328 332 344* 355 355 358 362
                                                                                  363 371 376 396 457 513 514 516 516 519 565 646
                                                                                  733 762 774 776 776 839 841 843 893 895 896 897
                                                                                  918 952 956 987
gq_host_id               37            based           fixed bin(32,0)          level 3 dcl 5-9 set ref 291* 355* 362
gq_link                  40            based           fixed bin(8,0)           level 3 dcl 5-9 set ref 291*
hash_index                7(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-61 ref 743
host                                   based           structure                level 1 dcl 2-61
host_array                             based           structure                array level 1 dcl 41 set ref 555 563 563
host_code                       000101 automatic       fixed bin(32,0)          dcl 25 set ref 362* 364 452* 737* 739*
host_entry_index         16            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 set ref 313 745*
host_id                  50            based           fixed bin(32,0)          level 2 dcl 4-10 ref 711
host_number              10            based           fixed bin(32,0)          array level 2 dcl 41 set ref 364 710
host_ptr                        000110 automatic       pointer                  dcl 25 set ref 555* 556 739* 743
host_state                3(09)        based           bit(6)                   level 2 in structure "host" packed unaligned
                                                                                  dcl 2-61 in procedure "ncp_tbop_" ref 556
host_state                3(09)        based           bit(6)                   array level 2 in structure "host_array" packed
                                                                                  unaligned dcl 41 in procedure "ncp_tbop_" set ref
                                                                                  369
host_tb_index                   000226 automatic       fixed bin(17,0)          dcl 148 set ref 313* 363* 364 369 548 548 555 563
                                                                                  563 710 743* 745
host_tbl_index           20            based           fixed bin(17,0)          level 2 dcl 5-9 ref 363
hpr                             000114 automatic       pointer                  dcl 25 set ref 266* 351* 364 369 555 563 563 710
htbl_gent                10            based           fixed bin(17,0)          level 2 dcl 4-10 ref 548
i                               000136 automatic       fixed bin(18,0)          dcl 46 set ref 536* 539 544* 544 546 594* 594 596
                                                                                  755* 762 764 795* 797* 797* 799* 808* 812 814 816
                                                                                  820 822 868* 877 880 891* 893 895 896 897 916* 918
                                                                                  964* 966 968 971* 972 974 1034*
icode                           000103 automatic       fixed bin(35,0)          dcl 25 set ref 276* 277 291* 292 298* 302* 303 325*
                                                                                  452* 453 492* 563* 564 565 566* 641* 642 739* 740
                                                                                  855* 858* 955* 956 988* 1025*
imp_order$imp_update_write_allocation
                                000050 constant        entry                    external dcl 90 ref 424
imp_read_order                  000052 constant        entry                    external dcl 90 ref 858
imp_write_order                 000054 constant        entry                    external dcl 90 ref 855 918 1025
impdim_index             16(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 ref 424 855 858
                                                                                  916 1025
j                               000137 automatic       fixed bin(18,0)          dcl 46 set ref 390* 396* 399 399 400 537* 562 569
                                                                                  571* 571 574 576* 576 579 581* 581 584 586* 586
                                                                                  589 591* 591 596 597* 597 600 602 603* 603 606
                                                                                  608* 608 611 613* 613 616 618* 618 700* 701 704
                                                                                  712 714 758* 761 761
k                               000140 automatic       fixed bin(18,0)          dcl 46 set ref 539* 541 542
link                      0(08)        based           bit(8)                   level 2 in structure "lkcom" packed unaligned
                                                                                  dcl 186 in procedure "ncp_tbop_" ref 447
link                      2            based           bit(8)                   level 2 in structure "sccom" packed unaligned
                                                                                  dcl 180 in procedure "ncp_tbop_" ref 706 716 720
link_number              15(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 set ref 510* 523
                                                                                  579
linkt                           000227 automatic       fixed bin(18,0)          dcl 148 set ref 447* 452 510 523* 687* 717* 720* 792
                                                                                  814
lkcom                                  based           structure                level 1 packed unaligned dcl 186
local_socket             11            based           structure                level 2 packed unaligned dcl 2-13 ref 316
lock                      4            based           bit(36)                  level 2 dcl 2-13 set ref 309 456 645
lockp                           000144 automatic       pointer                  dcl 46 set ref 309* 456* 492* 645*
lsoct                           000230 automatic       bit(64)                  unaligned dcl 148 set ref 316* 574 641 641 641 641
                                                                                  711*
meter_dt                               based           structure                level 1 dcl 4-52
mfrac                     0(16)        based           bit(8)                   level 2 packed unaligned dcl 186 ref 971
min                                                    builtin function         dcl 113 ref 379
mpr                             000116 automatic       pointer                  dcl 25 set ref 268* 353* 360 360 399 399
msg_allocation           10            based           fixed bin(16,0)          level 2 dcl 2-13 set ref 972 974 975* 975
msg_chr8                               based           char(8)                  dcl 56 set ref 986*
mspace                          000237 automatic       fixed bin(16,0)          dcl 148 in procedure "ncp_tbop_" set ref 589 972*
                                                                                  974* 975
mspace                    0(16)        based           bit(16)                  level 2 in structure "spcom" packed unaligned
                                                                                  dcl 192 in procedure "ncp_tbop_" ref 424 424
nbytes                    6            based           fixed bin(24,0)          level 2 dcl 5-9 set ref 355*
ncp_access_$assign_link         000056 constant        entry                    external dcl 90 ref 513
ncp_access_$change_socket_state 000060 constant        entry                    external dcl 90 ref 761
ncp_access_$deactivate_socket   000062 constant        entry                    external dcl 90 ref 955
ncp_access_$signal_process      000064 constant        entry                    external dcl 90 ref 482
ncp_access_$unassign_link       000066 constant        entry                    external dcl 90 ref 774
ncp_connection_$allocate_read   000070 constant        entry                    external dcl 90 ref 839
ncp_dt                                 based           structure                level 1 dcl 4-10
ncp_err_code                    000232 automatic       char(8)                  unaligned dcl 148 set ref 1002* 1003*
ncp_error_                      000072 constant        entry                    external dcl 90 ref 298 365 519 551 558 566 673 680
                                                                                  776 843 899 1003 1040
ncp_idx                   3            based           bit(36)                  level 2 packed unaligned dcl 5-9 set ref 279* 283*
                                                                                  294* 302* 396* 457* 646* 987
ncp_lock_$lock_unlock           000074 constant        entry                    external dcl 90 ref 492
ncp_lock_$unlock_all            000076 constant        entry                    external dcl 90 ref 325
ncp_params_$interrupt_signal    000010 external static char(4)                  dcl 64 set ref 991*
ncp_tables_$host_tbl            000014 external static fixed bin(17,0)          dcl 69 set ref 266 351
ncp_tables_$meter_cells         000016 external static fixed bin(17,0)          dcl 69 set ref 268 353
ncp_tables_$ncp_data            000020 external static fixed bin(17,0)          dcl 69 set ref 264 349
ncp_tables_$rfc_tbl             000022 external static fixed bin(17,0)          dcl 69 set ref 267 352
ncp_tables_$socket_tbl          000024 external static fixed bin(17,0)          dcl 69 set ref 265 350
ncp_tables_$tracing_info        000012 external static bit(36)                  dcl 64 ref 272 355 393
ncp_tbl_$base                   000124 external static fixed bin(17,0)          dcl 146 set ref 322 381 395
ncp_tbl_$com_state_tbl          000120 external static bit(18)                  array unaligned dcl 144 ref 322
ncp_tbl_$ctl_tbl                000122 external static bit(18)                  array unaligned dcl 145 ref 381
ncp_trace_                      000100 constant        entry                    external dcl 90 ref 272 355 396
ncp_util_$find_host_entry       000102 constant        entry                    external dcl 90 ref 739
ncp_util_$find_socket_from_index
                                000104 constant        entry                    external dcl 90 ref 302
ncp_util_$find_socket_from_link_number
                                000106 constant        entry                    external dcl 90 ref 291 452
ncp_util_$find_socket_from_socket_number
                                000110 constant        entry                    external dcl 90 ref 276 641
ncp_util_$send_control_message  000112 constant        entry                    external dcl 90 ref 563
ncp_wakeup_count         21            based           fixed bin(17,0)          array level 2 dcl 4-52 set ref 360* 360
nelemt                    7            based           fixed bin(24,0)          level 2 dcl 5-9 set ref 358*
next                                   based           bit(18)                  level 2 packed unaligned dcl 134 ref 387
next_entry                2(18)        based           fixed bin(17,0)          array level 2 packed unaligned dcl 41 set ref 676
                                                                                  822* 829 868 871* 880*
npr                             000120 automatic       pointer                  dcl 25 set ref 264* 349* 548 711 797 804 804 807 807
                                                                                  808
null                                                   builtin function         dcl 113 ref 855 855 858 858 918 918 1025 1025
num_bytes                       000102 automatic       fixed bin(24,0)          dcl 25 set ref 562* 563*
op                        0(18)        based           bit(18)                  level 2 packed unaligned dcl 134 ref 390
oper_loc                        000100 automatic       fixed bin(18,0)          dcl 25 set ref 395* 396*
overseer_event_channel
                          2            based           fixed bin(71,0)          level 2 dcl 2-13 set ref 1016*
overseer_process_id       6            based           bit(36)                  level 2 dcl 2-13 ref 950
pcode                           000234 automatic       fixed bin(18,0)          dcl 148 set ref 259* 276 276 302 302 346* 950
pdt                                    based           structure                level 1 dcl 5-48
pointer                                                builtin function         dcl 113 ref 322 381 387 402 406 410
ppqn                            000243 automatic       fixed bin(18,0)          dcl 173 set ref 320* 666* 825* 882 883*
pqn                             000242 automatic       fixed bin(17,0)          dcl 173 set ref 320* 666 668* 669 671 676 820 822
                                                                                  825 826* 827 829 875 876 880 882*
privilege_code            5            based           fixed bin(2,0)           level 2 dcl 5-9 ref 259
process_id                5            based           bit(36)                  level 2 dcl 2-13 set ref 988* 991*
processid                20            based           bit(36)                  level 2 dcl 5-48 ref 270 345
procid                          000104 automatic       bit(36)                  dcl 25 set ref 270* 272* 345* 396* 950
procp                           000122 automatic       pointer                  dcl 25 set ref 257* 258 270 343* 344 345
procpx                                 parameter       pointer                  dcl 19 ref 254 257 340 343
pxss$ips_wakeup_int             000114 constant        entry                    external dcl 90 ref 991
pxss$wakeup_int                 000116 constant        entry                    external dcl 90 ref 988
qn                              000241 automatic       fixed bin(17,0)          dcl 173 set ref 320* 668 669* 676* 684 686 687 818
                                                                                  826 827* 829* 868 870 871 872 875*
queue_level                     000235 automatic       fixed bin(17,0)          dcl 148 set ref 319* 678* 678 679 884* 884
rcvd_rfc                               based           structure                level 1 dcl 2-80
rel                                                    builtin function         dcl 113 ref 395 395
request_code              2            based           fixed bin(12,0)          level 2 dcl 5-9 set ref 260 272* 275 275 288 290
return_label                    000132 automatic       label variable           local dcl 25 set ref 311* 347* 473 495
rfc_array                              based           structure                array level 1 dcl 41
rfc_queue                15            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-13 set ref 669 820*
                                                                                  827 877*
rpr                             000124 automatic       pointer                  dcl 25 set ref 267* 352* 676 686 687 799 812 814 816
                                                                                  822 829 868 870 871 872 880
rsoc                      0(08)        based           bit(32)                  level 2 packed unaligned dcl 180 ref 698 710
rtbl_gent                11            based           fixed bin(17,0)          level 2 dcl 4-10 set ref 797 804 807* 807 808
rtbl_size                 5            based           fixed bin(17,0)          level 2 dcl 4-10 ref 804
rw                              000146 automatic       fixed bin(1,0)           dcl 46 set ref 449* 452 452
sccom                                  based           structure                level 1 packed unaligned dcl 180
send_gender              17(14)        based           bit(1)                   level 2 packed unaligned dcl 2-13 ref 464 507 792
                                                                                  814 855 918
sep                             000126 automatic       pointer                  dcl 25 set ref 276* 279 291* 294 302* 309 313 316
                                                                                  317 318 424 452* 456 457 464 482* 507 510 513* 523
                                                                                  579 616 627 641* 645 646 669 735 745 746 761* 762
                                                                                  774* 792 814 820 827 839* 855 855 858 877 916 918
                                                                                  941 950 955* 966 968 969 969 972 974 975 975 983
                                                                                  988 988 991 991 1012 1014 1015 1016 1025
signal_event_channel     24            based           fixed bin(71,0)          level 2 dcl 2-13 set ref 983 988*
socket                                 based           structure                level 1 dcl 2-13
socket_index             26            based           bit(36)                  level 2 dcl 2-13 ref 279 294 457 646
socket_num               11(32)        based           bit(32)                  level 3 packed unaligned dcl 2-13 ref 735
spcom                                  based           structure                level 1 packed unaligned dcl 192
spr                             000130 automatic       pointer                  dcl 25 set ref 265* 350*
ssoc                      1(04)        based           bit(32)                  level 2 packed unaligned dcl 180 ref 698 701 711
stacq                                                  builtin function         dcl 113 ref 799 873
state                    17            based           bit(6)                   level 2 in structure "socket" packed unaligned
                                                                                  dcl 2-13 in procedure "ncp_tbop_" ref 318 762
state                     4            based           fixed bin(6,0)           level 2 in structure "gdt" dcl 5-9 in procedure
                                                                                  "ncp_tbop_" set ref 262* 318* 322 762*
status                          000240 automatic       bit(18)                  unaligned dcl 148 set ref 855* 858* 859 859 918*
                                                                                  1025*
string                                                 builtin function         dcl 113 set ref 316 317 686 746* 812* 870*
substr                                                 builtin function         dcl 113 set ref 276 276 276 276 533* 569* 569 574*
                                                                                  574 579* 584* 589* 596* 600* 602* 606* 611* 611
                                                                                  616* 641 641 641 641 698 698 701 735 735 737 859
                                                                                  859 987* 1002
success                         000147 automatic       bit(1)                   dcl 46 set ref 873*
tbop_mf_count           110            based           fixed bin(17,0)          array level 2 dcl 4-52 set ref 399* 399
tpr                             000150 automatic       pointer                  dcl 46 set ref 872* 873 873
unspec                                                 builtin function         dcl 113 ref 987

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_TRACING                            internal static bit(36)                  initial dcl 3-51
HOST_DOWN                              internal static fixed bin(6,0)           initial dcl 3-20
HOST_ON                                internal static fixed bin(6,0)           initial dcl 3-20
HOST_RST                               internal static fixed bin(6,0)           initial dcl 3-20
HOST_UP                                internal static fixed bin(6,0)           initial dcl 3-20
IMP_ORDER_block_link                   internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_clear_host_state             internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_clear_pgqlrr                 internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_control_link                 internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_get_allocation_status        internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_get_byte_size                internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_imp_ascii                    internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_imp_octal                    internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_multiple_message_mode        internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_no_ncp                       internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_normal_leader                internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_set_byte_size                internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_single_message_mode          internal static fixed bin(12,0)          initial dcl 1-9
IMP_ORDER_unblock_link                 internal static fixed bin(12,0)          initial dcl 1-9
NCP_CRASHED                            internal static fixed bin(3,0)           initial dcl 3-8
NCP_DOWN                               internal static fixed bin(3,0)           initial dcl 3-8
NCP_UP                                 internal static fixed bin(3,0)           initial dcl 3-8
NCP_UP_IMP_DOWN                        internal static fixed bin(3,0)           initial dcl 3-8
PRINTER_TRACING                        internal static bit(36)                  initial dcl 3-51
SOCK_ASSIGNED                          internal static fixed bin(6,0)           initial dcl 3-28
SOCK_BROKEN                            internal static fixed bin(6,0)           initial dcl 3-28
SOCK_CLS_READ                          internal static fixed bin(6,0)           initial dcl 3-28
SOCK_CLS_WAIT                          internal static fixed bin(6,0)           initial dcl 3-28
SOCK_CONNECTED                         internal static fixed bin(6,0)           initial dcl 3-28
SOCK_DATA_WAIT                         internal static fixed bin(6,0)           initial dcl 3-28
SOCK_INDX_MASK                         internal static bit(36)                  initial unaligned dcl 3-46
SOCK_LISTENING                         internal static fixed bin(6,0)           initial dcl 3-28
SOCK_RESET                             internal static fixed bin(6,0)           initial dcl 3-28
SOCK_RFC_ABORTED                       internal static fixed bin(6,0)           initial dcl 3-28
SOCK_RFC_RCVD                          internal static fixed bin(6,0)           initial dcl 3-28
SOCK_RFC_SENT                          internal static fixed bin(6,0)           initial dcl 3-28
SOCK_RFNM_WAIT                         internal static fixed bin(6,0)           initial dcl 3-28
SOCK_UNASSIGNED                        internal static fixed bin(6,0)           initial dcl 3-28
SOCK_UNIQUE_MASK                       internal static bit(36)                  initial unaligned dcl 3-46
SYSERR_LOG_TRACING                     internal static bit(36)                  initial dcl 3-51
TRACE_CTL_MSGS                         internal static bit(36)                  initial dcl 3-51
TRACE_DATA_FLOW                        internal static bit(36)                  initial dcl 3-51
TRACE_NCP_ACCESS                       internal static bit(36)                  initial dcl 3-51
TRACE_NCP_CONTROL                      internal static bit(36)                  initial dcl 3-51
TRACE_NCP_DAEMON                       internal static bit(36)                  initial dcl 3-51
TRACE_NCP_IO                           internal static bit(36)                  initial dcl 3-51
TRACE_NCP_RING                         internal static bit(36)                  initial dcl 3-51
TRACE_PROCESS_INFO                     internal static bit(36)                  initial dcl 3-51
boffer                                 based           bit(1)                   array unaligned dcl 57
com8                                   based           bit(8)                   array unaligned dcl 59
error_snapshot                         based           structure                level 1 dcl 5-64
host_address                           based           structure                level 1 dcl 2-87
socket_array                           based           structure                array level 1 dcl 41

NAMES DECLARED BY EXPLICIT CONTEXT.
atq_got_block                   002552 constant        label                    dcl 812 ref 799
atq_put_in_soct                 002574 constant        label                    dcl 818 ref 830
atq_restart                     002516 constant        label                    dcl 797 ref 810
cm_get_arg                      001455 constant        label                    dcl 539 ref 546
cm_get_nxt                      001471 constant        label                    dcl 544 ref 572 577 582 587 592 598 604 609 614 619
cm_op                           000051 constant        label                    array(0:9) dcl 569 ref 542
cm_put_out                      001475 constant        label                    dcl 548 ref 541
ncp_tbop_                       000263 constant        entry                    external dcl 11
next                            001064 constant        label                    dcl 387 ref 429 437 453 467 485 525 564 629 642 657
                                                                                  688 712 723 747 765 779 832 847 860 878 885 902
                                                                                  921 930 943 953 957 976 993 1017 1027
operation                       000000 constant        label                    array(41) dcl 424 ref 400
pcom_state_tbl_init             000565 constant        label                    dcl 314 ref 458 647
process_call                    000274 constant        entry                    external dcl 254
process_ctl_mess                000666 constant        entry                    external dcl 340
return_error                    000663 constant        label                    dcl 334 ref 347 372
return_to_user                  000636 constant        label                    dcl 325 ref 285 306 311
return_zero_error               000662 constant        label                    dcl 332 ref 288
socket_is_locked                000553 constant        label                    dcl 309 ref 281 296
start_operation                 001071 constant        label                    dcl 390 ref 323 382 404 408 412
state_common                    002411 constant        label                    dcl 758 ref 1036
transfer_arg_a                  001152 constant        label                    dcl 402 ref 464 627 655 684 792 805 859 908 941
transfer_arg_b                  001160 constant        label                    dcl 406 ref 516 698 701 706 740
transfer_arg_c                  001166 constant        label                    dcl 410 ref 735
unlock_return1                  001344 constant        label                    dcl 492 ref 764

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4220        4346    3471        4230
Length      4736    3471       126         353     527           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ncp_tbop_                           244 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ncp_tbop_                000100 oper_loc                    ncp_tbop_
                         000101 host_code                   ncp_tbop_
                         000102 num_bytes                   ncp_tbop_
                         000103 icode                       ncp_tbop_
                         000104 procid                      ncp_tbop_
                         000105 cv_bin_output               ncp_tbop_
                         000110 host_ptr                    ncp_tbop_
                         000112 gpr                         ncp_tbop_
                         000114 hpr                         ncp_tbop_
                         000116 mpr                         ncp_tbop_
                         000120 npr                         ncp_tbop_
                         000122 procp                       ncp_tbop_
                         000124 rpr                         ncp_tbop_
                         000126 sep                         ncp_tbop_
                         000130 spr                         ncp_tbop_
                         000132 return_label                ncp_tbop_
                         000136 i                           ncp_tbop_
                         000137 j                           ncp_tbop_
                         000140 k                           ncp_tbop_
                         000142 event_msg                   ncp_tbop_
                         000144 lockp                       ncp_tbop_
                         000146 rw                          ncp_tbop_
                         000147 success                     ncp_tbop_
                         000150 tpr                         ncp_tbop_
                         000152 control_message             ncp_tbop_
                         000210 curp                        ncp_tbop_
                         000212 bytet                       ncp_tbop_
                         000213 ccode                       ncp_tbop_
                         000214 com_len                     ncp_tbop_
                         000216 cpr                         ncp_tbop_
                         000220 fsocr                       ncp_tbop_
                         000222 fsoct                       ncp_tbop_
                         000224 fsoct1                      ncp_tbop_
                         000226 host_tb_index               ncp_tbop_
                         000227 linkt                       ncp_tbop_
                         000230 lsoct                       ncp_tbop_
                         000232 ncp_err_code                ncp_tbop_
                         000234 pcode                       ncp_tbop_
                         000235 queue_level                 ncp_tbop_
                         000236 bspace                      ncp_tbop_
                         000237 mspace                      ncp_tbop_
                         000240 status                      ncp_tbop_
                         000241 qn                          ncp_tbop_
                         000242 pqn                         ncp_tbop_
                         000243 ppqn                        ncp_tbop_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        return              ext_entry           divide_fx3
stacq

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_bin_$dec                   imp_order$imp_update_write_allocation                       imp_read_order
imp_write_order               ncp_access_$assign_link       ncp_access_$change_socket_state
ncp_access_$deactivate_socket ncp_access_$signal_process    ncp_access_$unassign_link     ncp_connection_$allocate_read
ncp_error_                    ncp_lock_$lock_unlock         ncp_lock_$unlock_all          ncp_trace_
ncp_util_$find_host_entry     ncp_util_$find_socket_from_index
ncp_util_$find_socket_from_link_number                      ncp_util_$find_socket_from_socket_number
ncp_util_$send_control_message                              pxss$ips_wakeup_int           pxss$wakeup_int

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_index        error_table_$bad_processid    error_table_$imp_rfnm_pending error_table_$net_bad_gender
error_table_$net_fhost_inactive                             error_table_$net_invalid_state
error_table_$net_socket_not_found                           error_table_$notalloc         ncp_params_$interrupt_signal
ncp_tables_$host_tbl          ncp_tables_$meter_cells       ncp_tables_$ncp_data          ncp_tables_$rfc_tbl
ncp_tables_$socket_tbl        ncp_tables_$tracing_info      ncp_tbl_$base                 ncp_tbl_$com_state_tbl
ncp_tbl_$ctl_tbl


CONSTANTS
003466  aa     777773777777

000063  aa     000020000000

000064  aa     000000000015

000065  aa     526000000010

003467  aa     000000000200

000066  aa     524000000030

000067  aa     524000000025

000070  aa     524000000022

000071  aa     524000000020

000072  aa     524000000024

000073  aa     524000000023

000074  aa     516000000044

000075  aa     404000000022

000076  aa     524000000026

000077  aa     524000000033

000100  aa     404000000030

000101  aa     404000000040

000102  aa     524000000054

003470  aa     777777777777

000103  aa     524000000017

000104  aa     404000000043

000105  aa     404000000014

000106  aa     524000000035

000107  aa     514000000044

000110  aa     526000000014

000111  aa     000000000004

000112  aa     000000000001

000113  aa     464000000000

000114  aa  116 102 164 142	NBtb
000115  aa  154 137 000 000	l_

000116  aa  116 103 120 040	NCP 
000117  aa  040 040 040 040	    

000120  aa     077777000043
000121  aa     000001000000

000122  aa     000000000000
000123  aa     000000000000

000124  aa  124 102 117 120	TBOP
000125  aa  137 156 157 137	_no_
000126  aa  156 145 170 164	next
000127  aa  137 122 106 103	_RFC

000130  aa  124 102 117 120	TBOP
000131  aa  137 142 165 146	_buf
000132  aa  137 163 157 143	_soc
000133  aa  153 145 164 000	ket

000134  aa  124 102 117 120	TBOP
000135  aa  137 164 157 157	_too
000136  aa  137 155 141 156	_man
000137  aa  171 137 122 106	y_RF
000140  aa  103 163 000 000	Cs

000141  aa  124 102 117 120	TBOP
000142  aa  137 163 145 156	_sen
000143  aa  144 151 156 147	ding
000144  aa  137 143 164 154	_ctl
000145  aa  137 155 163 147	_msg

000146  aa  124 102 117 120	TBOP
000147  aa  137 142 141 144	_bad
000150  aa  137 150 157 163	_hos
000151  aa  164 137 151 156	t_in
000152  aa  144 145 170 000	dex

000153  aa  124 102 117 120	TBOP
000154  aa  137 157 142 163	_obs
000155  aa  157 154 145 164	olet
000156  aa  145 137 146 165	e_fu
000157  aa  156 143 164 151	ncti
000160  aa  157 156 000 000	on

000161  aa  124 102 117 120	TBOP
000162  aa  137 141 154 154	_all
000163  aa  157 143 141 164	ocat
000164  aa  151 156 147 137	ing_
000165  aa  146 157 162 137	for_
000166  aa  162 145 141 144	read

000167  aa  124 102 117 120	TBOP
000170  aa  137 165 156 141	_una
000171  aa  163 163 151 147	ssig
000172  aa  156 151 156 147	ning
000173  aa  137 154 151 156	_lin
000174  aa  153 000 000 000	k

000175  aa  124 102 117 120	TBOP
000176  aa  137 141 163 163	_ass
000177  aa  151 147 156 137	ign_
000200  aa  154 151 156 153	link
000201  aa  137 145 162 162	_err
000202  aa  157 162 000 000	or

000203  aa  117 120 105 122	OPER
000204  aa  040 136 062 144	 ^2d
000205  aa  040 100 040 136	 @ ^
000206  aa  066 157 040 040	6o  
000207  aa  136 167 040 040	^w  
000210  aa  136 167 000 000	^w

000211  aa  124 102 117 120	TBOP
000212  aa  137 165 156 141	_una
000213  aa  142 154 145 137	ble_
000214  aa  164 157 137 163	to_s
000215  aa  145 156 144 137	end_
000216  aa  143 164 154 137	ctl_
000217  aa  155 163 147 000	msg

000220  aa  124 102 117 120	TBOP
000221  aa  137 155 163 147	_msg
000222  aa  137 146 162 157	_fro
000223  aa  155 137 151 156	m_in
000224  aa  141 143 164 151	acti
000225  aa  166 145 137 150	ve_h
000226  aa  157 163 164 000	ost

000227  aa  124 102 117 120	TBOP
000230  aa  137 165 156 153	_unk
000231  aa  156 157 167 156	nown
000232  aa  137 145 162 162	_err
000233  aa  157 162 137 143	or_c
000234  aa  157 144 145 137	ode_
000235  aa  151 156 144 145	inde
000236  aa  170 000 000 000	x

000237  aa  164 142 157 160	tbop
000240  aa  137 044 160 162	_$pr
000241  aa  157 143 145 163	oces
000242  aa  163 137 143 141	s_ca
000243  aa  154 154 072 040	ll: 
000244  aa  040 136 167 040	 ^w 
000245  aa  055 055 040 136	-- ^
000246  aa  144 000 000 000	d

000247  aa  156 143 160 137	ncp_
000250  aa  164 142 157 160	tbop
000251  aa  137 044 160 162	_$pr
000252  aa  157 143 145 163	oces
000253  aa  163 137 143 164	s_ct
000254  aa  154 137 155 145	l_me
000255  aa  163 163 072 040	ss: 
000256  aa  040 150 157 163	 hos
000257  aa  164 040 136 144	t ^d
000260  aa  054 040 154 145	, le
000261  aa  156 040 136 144	n ^d

LABEL ARRAYS
000000  aa   002504 7100 04	tra  	1348,ic		002504
000001  aa   002637 7100 04	tra  	1439,ic		002640
000002  aa   001172 7100 04	tra  	634,ic		001174
000003  aa   001353 7100 04	tra  	747,ic		001356
000004  aa   001226 7100 04	tra  	662,ic		001232
000005  aa   003162 7100 04	tra  	1650,ic		003167
000006  aa   002671 7100 04	tra  	1465,ic		002677
000007  aa   001427 7100 04	tra  	791,ic		001436
000010  aa   002010 7100 04	tra  	1032,ic		002020
000011  aa   003165 7100 04	tra  	1653,ic		003176
000012  aa   003214 7100 04	tra  	1676,ic		003226
000013  aa   002754 7100 04	tra  	1516,ic		002767
000014  aa   003025 7100 04	tra  	1557,ic		003041
000015  aa   003427 7100 04	tra  	1815,ic		003444
000016  aa   001221 7100 04	tra  	657,ic		001237
000017  aa   002006 7100 04	tra  	1030,ic		002025
000020  aa   002053 7100 04	tra  	1067,ic		002073
000021  aa   002056 7100 04	tra  	1070,ic		002077
000022  aa   002171 7100 04	tra  	1145,ic		002213
000023  aa   003101 7100 04	tra  	1601,ic		003124
000024  aa   003101 7100 04	tra  	1601,ic		003125
000025  aa   002277 7100 04	tra  	1215,ic		002324
000026  aa   003246 7100 04	tra  	1702,ic		003274
000027  aa   001266 7100 04	tra  	694,ic		001315
000030  aa   003307 7100 04	tra  	1735,ic		003337
000031  aa   003413 7100 04	tra  	1803,ic		003444
000032  aa   003412 7100 04	tra  	1802,ic		003444
000033  aa   003411 7100 04	tra  	1801,ic		003444
000034  aa   001266 7100 04	tra  	694,ic		001322
000035  aa   003407 7100 04	tra  	1799,ic		003444
000036  aa   003343 7100 04	tra  	1763,ic		003401
000037  aa   003353 7100 04	tra  	1771,ic		003412
000040  aa   003404 7100 04	tra  	1796,ic		003444
000041  aa   003123 7100 04	tra  	1619,ic		003164
000042  aa   001261 7100 04	tra  	689,ic		001323
000043  aa   003401 7100 04	tra  	1793,ic		003444
000044  aa   003375 7100 04	tra  	1789,ic		003441
000045  aa   002342 7100 04	tra  	1250,ic		002407
000046  aa   002400 7100 04	tra  	1280,ic		002446
000047  aa   001275 7100 04	tra  	701,ic		001344
000050  aa   003374 7100 04	tra  	1788,ic		003444

000051  aa   001571 7100 04	tra  	889,ic		001642
000052  aa   001577 7100 04	tra  	895,ic		001651
000053  aa   001605 7100 04	tra  	901,ic		001660
000054  aa   001624 7100 04	tra  	916,ic		001700
000055  aa   001637 7100 04	tra  	927,ic		001714
000056  aa   001652 7100 04	tra  	938,ic		001730
000057  aa   001676 7100 04	tra  	958,ic		001755
000060  aa   001711 7100 04	tra  	969,ic		001771
000061  aa   001720 7100 04	tra  	976,ic		002001
000062  aa   001726 7100 04	tra  	982,ic		002010

BEGIN PROCEDURE ncp_tbop_
ENTRY TO ncp_tbop_                                          STATEMENT 1 ON LINE 11
ncp_tbop_:
          procedure ();

000262  da     000504200000
000263  aa   000400 6270 00	eax7 	256
000264  aa  7 00034 3521 20	epp2 	pr7|28,*
000265  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000266  aa     000000000000
000267  aa     000000000000
						STATEMENT 1 ON LINE 254
process_call:
          entry (procpx);

000270  aa   000011 7100 04	tra  	9,ic		000301
ENTRY TO process_call                                       STATEMENT 1 ON LINE 254
process_call:
          entry (procpx);

000271  at     000001000113
000272  ta     000271000000
000273  da     000513300000
000274  aa   000400 6270 00	eax7 	256
000275  aa  7 00034 3521 20	epp2 	pr7|28,*
000276  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000277  aa     000002000000
000300  aa     000000000000
						STATEMENT 1 ON LINE 257
          procp = procpx;

000301  aa  6 00032 3735 20	epp7 	pr6|26,*
000302  aa  7 00002 3715 20	epp5 	pr7|2,*		procpx
000303  aa  5 00000 3715 20	epp5 	pr5|0,*		procpx
000304  aa  6 00122 6515 00	spri5	pr6|82		procp
						STATEMENT 1 ON LINE 258
          gpr = procp -> pdt.gdtp;

000305  aa  5 00000 3535 20	epp3 	pr5|0,*		pdt.gdtp
000306  aa  6 00112 2535 00	spri3	pr6|74		gpr
						STATEMENT 1 ON LINE 259
          pcode = gpr -> gdt.privilege_code;

000307  aa  3 00005 2361 00	ldq  	pr3|5		gdt.privilege_code
000310  aa  6 00234 7561 00	stq  	pr6|156		pcode
						STATEMENT 1 ON LINE 260
          ccode = gpr -> gdt.request_code;

000311  aa  3 00002 2361 00	ldq  	pr3|2		gdt.request_code
000312  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 261
          fsoct, fsocr = ""b;

000313  aa   777607 2370 04	ldaq 	-121,ic		000122 = 000000000000 000000000000
000314  aa  6 00222 7571 00	staq 	pr6|146		fsoct
000315  aa  6 00220 7571 00	staq 	pr6|144		fsocr
						STATEMENT 1 ON LINE 262
          gpr -> gdt.state = 0;

000316  aa  3 00004 4501 00	stz  	pr3|4		gdt.state
						STATEMENT 1 ON LINE 264
          npr = addr (ncp_tables_$ncp_data);

000317  la  4 00020 3515 20	epp1 	pr4|16,*		ncp_tables_$ncp_data
000320  aa  6 00120 2515 00	spri1	pr6|80		npr
						STATEMENT 1 ON LINE 265
          spr = addr (ncp_tables_$socket_tbl);

000321  la  4 00024 3715 20	epp5 	pr4|20,*		ncp_tables_$socket_tbl
000322  aa  6 00130 6515 00	spri5	pr6|88		spr
						STATEMENT 1 ON LINE 266
          hpr = addr (ncp_tables_$host_tbl);

000323  la  4 00014 3535 20	epp3 	pr4|12,*		ncp_tables_$host_tbl
000324  aa  6 00114 2535 00	spri3	pr6|76		hpr
						STATEMENT 1 ON LINE 267
          rpr = addr (ncp_tables_$rfc_tbl);

000325  la  4 00022 3515 20	epp1 	pr4|18,*		ncp_tables_$rfc_tbl
000326  aa  6 00124 2515 00	spri1	pr6|84		rpr
						STATEMENT 1 ON LINE 268
          mpr = addr (ncp_tables_$meter_cells);

000327  la  4 00016 3715 20	epp5 	pr4|14,*		ncp_tables_$meter_cells
000330  aa  6 00116 6515 00	spri5	pr6|78		mpr
						STATEMENT 1 ON LINE 270
          procid = procp -> pdt.processid;

000331  aa  6 00122 3535 20	epp3 	pr6|82,*		procp
000332  aa  3 00020 2351 00	lda  	pr3|16		pdt.processid
000333  aa  6 00104 7551 00	sta  	pr6|68		procid
						STATEMENT 1 ON LINE 272
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_NCP_TBOP, "tbop_$process_call:  ^w -- ^d", procid, gpr -> gdt.request_code);

000334  la  4 00012 2351 20	lda  	pr4|10,*		ncp_tables_$tracing_info
000335  aa   000030 6000 04	tze  	24,ic		000365
000336  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000337  aa   777701 00 0040	desc9a	-63,32		000237 = 164142157160
000340  aa  6 00246 00 0040	desc9a	pr6|166,32
000341  aa   777522 3520 04	epp2 	-174,ic		000063 = 000020000000
000342  aa  6 00260 2521 00	spri2	pr6|176
000343  aa  6 00246 3521 00	epp2 	pr6|166
000344  aa  6 00262 2521 00	spri2	pr6|178
000345  aa  6 00104 3521 00	epp2 	pr6|68		procid
000346  aa  6 00264 2521 00	spri2	pr6|180
000347  aa  6 00112 3515 20	epp1 	pr6|74,*		gpr
000350  aa  1 00002 3521 00	epp2 	pr1|2		gdt.request_code
000351  aa  6 00266 2521 00	spri2	pr6|182
000352  aa   777535 3520 04	epp2 	-163,ic		000107 = 514000000044
000353  aa  6 00270 2521 00	spri2	pr6|184
000354  aa  6 00274 2521 00	spri2	pr6|188
000355  aa   777531 3520 04	epp2 	-167,ic		000106 = 524000000035
000356  aa  6 00272 2521 00	spri2	pr6|186
000357  aa   777526 3520 04	epp2 	-170,ic		000105 = 404000000014
000360  aa  6 00276 2521 00	spri2	pr6|190
000361  aa  6 00256 6211 00	eax1 	pr6|174
000362  aa   020000 4310 07	fld  	8192,dl
000363  la  4 00100 3521 20	epp2 	pr4|64,*		ncp_trace_
000364  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 275
          if (gpr -> gdt.request_code > 32) & (gpr -> gdt.request_code < 35) then do;

000365  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000366  aa  7 00002 2361 00	ldq  	pr7|2		gdt.request_code
000367  aa   000040 1160 07	cmpq 	32,dl
000370  aa   000054 6044 04	tmoz 	44,ic		000444
000371  aa   000043 1160 07	cmpq 	35,dl
000372  aa   000052 6050 04	tpl  	42,ic		000444
						STATEMENT 1 ON LINE 276
               call ncp_util_$find_socket_from_socket_number (binary (substr (gpr -> gdt.fsoc, 1, 32)), binary (substr (gpr -> gdt.fsoc, 33, 32)), bit (pcode > 0, 1), sep, icode);

000373  aa  7 00012 2351 00	lda  	pr7|10		gdt.fsoc
000374  aa   000050 7730 00	lrl  	40
000375  aa  6 00245 7561 00	stq  	pr6|165
000376  aa  7 00012 2351 00	lda  	pr7|10		gdt.fsoc
000377  aa  7 00013 2361 00	ldq  	pr7|11		gdt.fsoc
000400  aa   000040 7370 00	lls  	32
000401  aa   000050 7730 00	lrl  	40
000402  aa  6 00300 7561 00	stq  	pr6|192
000403  aa  6 00234 2361 00	ldq  	pr6|156		pcode
000404  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
000405  aa  6 00301 7551 00	sta  	pr6|193
000406  aa  6 00245 3521 00	epp2 	pr6|165
000407  aa  6 00260 2521 00	spri2	pr6|176
000410  aa  6 00300 3521 00	epp2 	pr6|192
000411  aa  6 00262 2521 00	spri2	pr6|178
000412  aa  6 00301 3521 00	epp2 	pr6|193
000413  aa  6 00264 2521 00	spri2	pr6|180
000414  aa  6 00126 3521 00	epp2 	pr6|86		sep
000415  aa  6 00266 2521 00	spri2	pr6|182
000416  aa  6 00103 3521 00	epp2 	pr6|67		icode
000417  aa  6 00270 2521 00	spri2	pr6|184
000420  aa  6 00256 6211 00	eax1 	pr6|174
000421  aa   024000 4310 07	fld  	10240,dl
000422  aa  6 00044 3701 20	epp4 	pr6|36,*
000423  la  4 00110 3521 20	epp2 	pr4|72,*		ncp_util_$find_socket_from_socket_number
000424  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 277
               if icode = 0
               then do;

000425  aa  6 00103 2361 00	ldq  	pr6|67		icode
000426  aa   000010 6010 04	tnz  	8,ic		000436
						STATEMENT 1 ON LINE 279
                    gpr -> gdt.ncp_idx = sep -> socket.socket_index;

000427  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
000430  aa  7 00026 2351 00	lda  	pr7|22		socket.socket_index
000431  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
000432  aa  5 00003 7551 00	sta  	pr5|3		gdt.ncp_idx
						STATEMENT 1 ON LINE 280
                    ccode = 14;

000433  aa   000016 2360 07	ldq  	14,dl
000434  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 281
                    goto socket_is_locked;

000435  aa   000116 7100 04	tra  	78,ic		000553
						STATEMENT 1 ON LINE 282
                    end;

						STATEMENT 1 ON LINE 283
               gpr -> gdt.ncp_idx = ""b;

000436  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000437  aa  7 00003 4501 00	stz  	pr7|3		gdt.ncp_idx
						STATEMENT 1 ON LINE 284
               gpr -> gdt.error_code = error_table_$net_socket_not_found;

000440  aa  6 00044 3701 20	epp4 	pr6|36,*
000441  la  4 00042 2361 20	ldq  	pr4|34,*		error_table_$net_socket_not_found
000442  aa  7 00001 7561 00	stq  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 285
               goto return_to_user;

000443  aa   000173 7100 04	tra  	123,ic		000636
						STATEMENT 1 ON LINE 286
          end;

						STATEMENT 1 ON LINE 288
          if gpr -> gdt.request_code = 19 then goto return_zero_error;

000444  aa   000023 1160 07	cmpq 	19,dl
000445  aa   000215 6000 04	tze  	141,ic		000662
						STATEMENT 1 ON LINE 290
          if gpr -> gdt.request_code = 18 then do;

000446  aa   000022 1160 07	cmpq 	18,dl
000447  aa   000055 6010 04	tnz  	45,ic		000524
						STATEMENT 1 ON LINE 291
               call ncp_util_$find_socket_from_link_number (gpr -> gdt.gq_host_id, gpr -> gdt.gq_link, "1"b, sep, icode);

000450  aa   400000 2350 03	lda  	131072,du
000451  aa  6 00301 7551 00	sta  	pr6|193
000452  aa  7 00037 3521 00	epp2 	pr7|31		gdt.gq_host_id
000453  aa  6 00260 2521 00	spri2	pr6|176
000454  aa  7 00040 3521 00	epp2 	pr7|32		gdt.gq_link
000455  aa  6 00262 2521 00	spri2	pr6|178
000456  aa  6 00301 3521 00	epp2 	pr6|193
000457  aa  6 00264 2521 00	spri2	pr6|180
000460  aa  6 00126 3521 00	epp2 	pr6|86		sep
000461  aa  6 00266 2521 00	spri2	pr6|182
000462  aa  6 00103 3521 00	epp2 	pr6|67		icode
000463  aa  6 00270 2521 00	spri2	pr6|184
000464  aa  6 00256 6211 00	eax1 	pr6|174
000465  aa   024000 4310 07	fld  	10240,dl
000466  aa  6 00044 3701 20	epp4 	pr6|36,*
000467  la  4 00106 3521 20	epp2 	pr4|70,*		ncp_util_$find_socket_from_link_number
000470  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 292
               if icode = 0
               then do;

000471  aa  6 00103 2361 00	ldq  	pr6|67		icode
000472  aa   000010 6010 04	tnz  	8,ic		000502
						STATEMENT 1 ON LINE 294
                    gpr -> gdt.ncp_idx = sep -> socket.socket_index;

000473  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
000474  aa  7 00026 2351 00	lda  	pr7|22		socket.socket_index
000475  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
000476  aa  5 00003 7551 00	sta  	pr5|3		gdt.ncp_idx
						STATEMENT 1 ON LINE 295
                    ccode = 24;

000477  aa   000030 2360 07	ldq  	24,dl
000500  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 296
                    goto socket_is_locked;

000501  aa   000052 7100 04	tra  	42,ic		000553
						STATEMENT 1 ON LINE 297
                    end;

						STATEMENT 1 ON LINE 298
               call ncp_error_ (icode, "TBOP_buf_socket");

000502  aa   777426 2370 04	ldaq 	-234,ic		000130 = 124102117120 137142165146
000503  aa  6 00246 7571 00	staq 	pr6|166
000504  aa   777426 2370 04	ldaq 	-234,ic		000132 = 137163157143 153145164000
000505  aa  6 00250 7571 00	staq 	pr6|168
000506  aa  6 00103 3521 00	epp2 	pr6|67		icode
000507  aa  6 00260 2521 00	spri2	pr6|176
000510  aa  6 00246 3521 00	epp2 	pr6|166
000511  aa  6 00262 2521 00	spri2	pr6|178
000512  aa   777372 3520 04	epp2 	-262,ic		000104 = 404000000043
000513  aa  6 00264 2521 00	spri2	pr6|180
000514  aa   777367 3520 04	epp2 	-265,ic		000103 = 524000000017
000515  aa  6 00266 2521 00	spri2	pr6|182
000516  aa  6 00256 6211 00	eax1 	pr6|174
000517  aa   010000 4310 07	fld  	4096,dl
000520  aa  6 00044 3701 20	epp4 	pr6|36,*
000521  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
000522  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 299
               return;

000523  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 300
               end;

						STATEMENT 1 ON LINE 302
          call ncp_util_$find_socket_from_index (gpr -> gdt.ncp_idx, bit (pcode > 0, 1), sep, icode);

000524  aa  6 00234 2361 00	ldq  	pr6|156		pcode
000525  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
000526  aa  6 00301 7551 00	sta  	pr6|193
000527  aa  7 00003 3521 00	epp2 	pr7|3		gdt.ncp_idx
000530  aa  6 00260 2521 00	spri2	pr6|176
000531  aa  6 00301 3521 00	epp2 	pr6|193
000532  aa  6 00262 2521 00	spri2	pr6|178
000533  aa  6 00126 3521 00	epp2 	pr6|86		sep
000534  aa  6 00264 2521 00	spri2	pr6|180
000535  aa  6 00103 3521 00	epp2 	pr6|67		icode
000536  aa  6 00266 2521 00	spri2	pr6|182
000537  aa  6 00256 6211 00	eax1 	pr6|174
000540  aa   020000 4310 07	fld  	8192,dl
000541  aa  6 00044 3701 20	epp4 	pr6|36,*
000542  la  4 00104 3521 20	epp2 	pr4|68,*		ncp_util_$find_socket_from_index
000543  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 303
          if icode ^= 0
          then do;

000544  aa  6 00103 2361 00	ldq  	pr6|67		icode
000545  aa   000006 6000 04	tze  	6,ic		000553
						STATEMENT 1 ON LINE 305
               gpr -> gdt.error_code = error_table_$bad_index;

000546  aa  6 00044 3701 20	epp4 	pr6|36,*
000547  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$bad_index
000550  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000551  aa  7 00001 7561 00	stq  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 306
               goto return_to_user;

000552  aa   000064 7100 04	tra  	52,ic		000636
						STATEMENT 1 ON LINE 307
               end;

						STATEMENT 1 ON LINE 309
socket_is_locked:
          lockp = addr (sep -> socket.lock);

000553  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
000554  aa  7 00004 3735 00	epp7 	pr7|4		socket.lock
000555  aa  6 00144 6535 00	spri7	pr6|100		lockp
						STATEMENT 1 ON LINE 311
          return_label = return_to_user;

000556  aa   000060 3520 04	epp2 	48,ic		000636 = 600103352100
000557  aa  6 00132 2521 00	spri2	pr6|90		return_label
000560  aa  6 00134 6521 00	spri6	pr6|92		return_label
						STATEMENT 1 ON LINE 313
          host_tb_index = sep -> socket.host_entry_index;

000561  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
000562  aa  5 00016 2351 00	lda  	pr5|14		socket.host_entry_index
000563  aa   000066 7330 00	lrs  	54
000564  aa  6 00226 7561 00	stq  	pr6|150		host_tb_index
						STATEMENT 1 ON LINE 314
pcom_state_tbl_init:
          gpr -> gdt.error_code = 0;

000565  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000566  aa  7 00001 4501 00	stz  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 316
          lsoct = string (sep -> socket.local_socket);

000567  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
000570  aa  5 00011 2351 00	lda  	pr5|9
000571  aa  5 00012 2361 00	ldq  	pr5|10
000572  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
000573  aa  6 00230 7571 00	staq 	pr6|152		lsoct
						STATEMENT 1 ON LINE 317
          fsoct, fsocr = string (sep -> socket.foreign_socket);

000574  aa  5 00013 2351 00	lda  	pr5|11
000575  aa  5 00014 2361 00	ldq  	pr5|12
000576  aa  6 00302 7571 00	staq 	pr6|194
000577  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
000600  aa  6 00222 7571 00	staq 	pr6|146		fsoct
000601  aa  6 00302 2371 00	ldaq 	pr6|194
000602  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
000603  aa  6 00220 7571 00	staq 	pr6|144		fsocr
						STATEMENT 1 ON LINE 318
          gpr -> gdt.state = binary (sep -> socket.state, 6);

000604  aa  5 00017 2351 00	lda  	pr5|15		socket.state
000605  aa   000102 7730 00	lrl  	66
000606  aa  7 00004 7561 00	stq  	pr7|4		gdt.state
						STATEMENT 1 ON LINE 319
          queue_level = 0;

000607  aa  6 00235 4501 00	stz  	pr6|157		queue_level
						STATEMENT 1 ON LINE 320
          qn, pqn, ppqn = -1;

000610  aa   000001 3360 07	lcq  	1,dl
000611  aa  6 00241 7561 00	stq  	pr6|161		qn
000612  aa  6 00242 7561 00	stq  	pr6|162		pqn
000613  aa   000001 3360 07	lcq  	1,dl
000614  aa  6 00243 7561 00	stq  	pr6|163		ppqn
						STATEMENT 1 ON LINE 322
          curp = pointer (addr (ncp_tbl_$base), ncp_tbl_$com_state_tbl (ccode, gpr -> gdt.state));

000615  aa  6 00213 2361 00	ldq  	pr6|139		ccode
000616  aa   000374 4020 07	mpy  	252,dl
000617  aa  6 00301 7561 00	stq  	pr6|193
000620  aa  7 00004 2361 00	ldq  	pr7|4		gdt.state
000621  aa   000022 4020 07	mpy  	18,dl
000622  aa  6 00301 0761 00	adq  	pr6|193
000623  aa  6 00044 3701 20	epp4 	pr6|36,*
000624  la  4 00124 3535 20	epp3 	pr4|84,*		ncp_tbl_$base
000625  la  4 00120 3515 20	epp1 	pr4|80,*
000626  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000627  aa  1 77770 40 0022	descb	pr1|-8(18),18	ncp_tbl_$com_state_tbl
000630  aa  6 00056 00 0044	descb	pr6|46,36
000631  aa  6 00056 2351 00	lda  	pr6|46
000632  aa  3 00000 3521 00	epp2 	pr3|0
000633  aa   000000 3120 01	eawp2	0,au
000634  aa  6 00210 2521 00	spri2	pr6|136		curp
						STATEMENT 1 ON LINE 323
          goto start_operation;

000635  aa   000234 7100 04	tra  	156,ic		001071
						STATEMENT 1 ON LINE 325
return_to_user:
          call ncp_lock_$unlock_all (icode);

000636  aa  6 00103 3521 00	epp2 	pr6|67		icode
000637  aa  6 00250 2521 00	spri2	pr6|168
000640  aa  6 00246 6211 00	eax1 	pr6|166
000641  aa   004000 4310 07	fld  	2048,dl
000642  aa  6 00044 3701 20	epp4 	pr6|36,*
000643  la  4 00076 3521 20	epp2 	pr4|62,*		ncp_lock_$unlock_all
000644  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 327
          gpr -> gdt.fsoc = fsoct;

000645  aa  6 00222 2371 00	ldaq 	pr6|146		fsoct
000646  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000647  aa  7 00012 6751 00	era  	pr7|10		gdt.fsoc
000650  aa  7 00013 6761 00	erq  	pr7|11		gdt.fsoc
000651  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
000652  aa  7 00012 6551 00	ersa 	pr7|10		gdt.fsoc
000653  aa  7 00013 6561 00	ersq 	pr7|11		gdt.fsoc
						STATEMENT 1 ON LINE 328
          if gpr -> gdt.error_code = error_table_$imp_rfnm_pending
          then gpr -> gdt.error_code = 0;

000654  aa  7 00001 2361 00	ldq  	pr7|1		gdt.error_code
000655  aa  6 00044 3701 20	epp4 	pr6|36,*
000656  la  4 00032 1161 20	cmpq 	pr4|26,*		error_table_$imp_rfnm_pending
000657  aa   000002 6010 04	tnz  	2,ic		000661
000660  aa  7 00001 4501 00	stz  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 330
          return;

000661  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 332
return_zero_error:
          gpr -> gdt.error_code = 0;

000662  aa  7 00001 4501 00	stz  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 334
return_error:
          return;

000663  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO process_ctl_mess                                   STATEMENT 1 ON LINE 340
process_ctl_mess:
          entry (procpx);

000664  ta     000271000000
000665  da     000523300000
000666  aa   000400 6270 00	eax7 	256
000667  aa  7 00034 3521 20	epp2 	pr7|28,*
000670  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000671  aa     000002000000
000672  aa     000000000000
						STATEMENT 1 ON LINE 343
          procp = procpx;

000673  aa  6 00032 3735 20	epp7 	pr6|26,*
000674  aa  7 00002 3715 20	epp5 	pr7|2,*		procpx
000675  aa  5 00000 3715 20	epp5 	pr5|0,*		procpx
000676  aa  6 00122 6515 00	spri5	pr6|82		procp
						STATEMENT 1 ON LINE 344
          gpr = procp -> pdt.gdtp;

000677  aa  5 00000 3535 20	epp3 	pr5|0,*		pdt.gdtp
000700  aa  6 00112 2535 00	spri3	pr6|74		gpr
						STATEMENT 1 ON LINE 345
          procid = procp -> pdt.processid;

000701  aa  5 00020 2351 00	lda  	pr5|16		pdt.processid
000702  aa  6 00104 7551 00	sta  	pr6|68		procid
						STATEMENT 1 ON LINE 346
          pcode = 3;

000703  aa   000003 2360 07	ldq  	3,dl
000704  aa  6 00234 7561 00	stq  	pr6|156		pcode
						STATEMENT 1 ON LINE 347
          return_label = return_error;

000705  aa   777756 3520 04	epp2 	-18,ic		000663 = 000631710100
000706  aa  6 00132 2521 00	spri2	pr6|90		return_label
000707  aa  6 00134 6521 00	spri6	pr6|92		return_label
						STATEMENT 1 ON LINE 349
          npr = addr (ncp_tables_$ncp_data);

000710  aa  6 00044 3701 20	epp4 	pr6|36,*
000711  la  4 00020 3515 20	epp1 	pr4|16,*		ncp_tables_$ncp_data
000712  aa  6 00120 2515 00	spri1	pr6|80		npr
						STATEMENT 1 ON LINE 350
          spr = addr (ncp_tables_$socket_tbl);

000713  la  4 00024 3535 20	epp3 	pr4|20,*		ncp_tables_$socket_tbl
000714  aa  6 00130 2535 00	spri3	pr6|88		spr
						STATEMENT 1 ON LINE 351
          hpr = addr (ncp_tables_$host_tbl);

000715  la  4 00014 3715 20	epp5 	pr4|12,*		ncp_tables_$host_tbl
000716  aa  6 00114 6515 00	spri5	pr6|76		hpr
						STATEMENT 1 ON LINE 352
          rpr = addr (ncp_tables_$rfc_tbl);

000717  la  4 00022 3515 20	epp1 	pr4|18,*		ncp_tables_$rfc_tbl
000720  aa  6 00124 2515 00	spri1	pr6|84		rpr
						STATEMENT 1 ON LINE 353
          mpr = addr (ncp_tables_$meter_cells);

000721  la  4 00016 3535 20	epp3 	pr4|14,*		ncp_tables_$meter_cells
000722  aa  6 00116 2535 00	spri3	pr6|78		mpr
						STATEMENT 1 ON LINE 355
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_NCP_TBOP, "ncp_tbop_$process_ctl_mess:  host ^d, len ^d", gpr -> gdt.gq_host_id, gpr -> gdt.nbytes);

000723  la  4 00012 2351 20	lda  	pr4|10,*		ncp_tables_$tracing_info
000724  aa   000031 6000 04	tze  	25,ic		000755
000725  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000726  aa   777322 00 0054	desc9a	-302,44		000247 = 156143160137
000727  aa  6 00256 00 0054	desc9a	pr6|174,44
000730  aa   777133 3520 04	epp2 	-421,ic		000063 = 000020000000
000731  aa  6 00306 2521 00	spri2	pr6|198
000732  aa  6 00256 3521 00	epp2 	pr6|174
000733  aa  6 00310 2521 00	spri2	pr6|200
000734  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
000735  aa  5 00037 3521 00	epp2 	pr5|31		gdt.gq_host_id
000736  aa  6 00312 2521 00	spri2	pr6|202
000737  aa  5 00006 3521 00	epp2 	pr5|6		gdt.nbytes
000740  aa  6 00314 2521 00	spri2	pr6|204
000741  aa   777146 3520 04	epp2 	-410,ic		000107 = 514000000044
000742  aa  6 00316 2521 00	spri2	pr6|206
000743  aa   777137 3520 04	epp2 	-417,ic		000102 = 524000000054
000744  aa  6 00320 2521 00	spri2	pr6|208
000745  aa   777134 3520 04	epp2 	-420,ic		000101 = 404000000040
000746  aa  6 00322 2521 00	spri2	pr6|210
000747  aa   777131 3520 04	epp2 	-423,ic		000100 = 404000000030
000750  aa  6 00324 2521 00	spri2	pr6|212
000751  aa  6 00304 6211 00	eax1 	pr6|196
000752  aa   020000 4310 07	fld  	8192,dl
000753  la  4 00100 3521 20	epp2 	pr4|64,*		ncp_trace_
000754  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 358
          gpr -> gdt.nelemt = 0;

000755  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
000756  aa  7 00007 4501 00	stz  	pr7|7		gdt.nelemt
						STATEMENT 1 ON LINE 359
          com_len = 0;

000757  aa  6 00214 4501 00	stz  	pr6|140		com_len
						STATEMENT 1 ON LINE 360
          mpr -> meter_dt.ncp_wakeup_count (5) = mpr -> meter_dt.ncp_wakeup_count (5) + 1;

000760  aa  6 00116 3715 20	epp5 	pr6|78,*		mpr
000761  aa  5 00025 0541 00	aos  	pr5|21		meter_dt.ncp_wakeup_count
						STATEMENT 1 ON LINE 362
          host_code = gpr -> gdt.gq_host_id;

000762  aa  7 00037 2361 00	ldq  	pr7|31		gdt.gq_host_id
000763  aa  6 00101 7561 00	stq  	pr6|65		host_code
						STATEMENT 1 ON LINE 363
          host_tb_index = gpr -> gdt.host_tbl_index;

000764  aa  7 00020 2361 00	ldq  	pr7|16		gdt.host_tbl_index
000765  aa  6 00226 7561 00	stq  	pr6|150		host_tb_index
						STATEMENT 1 ON LINE 364
          if hpr -> host_array (host_tb_index).host_number ^= host_code then do;

000766  aa   000012 4020 07	mpy  	10,dl
000767  aa  6 00114 3535 20	epp3 	pr6|76,*		hpr
000770  aa  6 00301 7561 00	stq  	pr6|193
000771  aa  3 77776 2361 06	ldq  	pr3|-2,ql		host_array.host_number
000772  aa  6 00101 1161 00	cmpq 	pr6|65		host_code
000773  aa   000022 6000 04	tze  	18,ic		001015
						STATEMENT 1 ON LINE 365
               call ncp_error_ (error_table_$net_fhost_inactive, "TBOP_msg_from_inactive_host");

000774  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000775  aa   777224 00 0034	desc9a	-364,28		000220 = 124102117120
000776  aa  6 00246 00 0034	desc9a	pr6|166,28
000777  aa  6 00044 3701 20	epp4 	pr6|36,*
001000  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$net_fhost_inactive
001001  aa  6 00306 2521 00	spri2	pr6|198
001002  aa  6 00246 3521 00	epp2 	pr6|166
001003  aa  6 00310 2521 00	spri2	pr6|200
001004  aa   777100 3520 04	epp2 	-448,ic		000104 = 404000000043
001005  aa  6 00312 2521 00	spri2	pr6|202
001006  aa   777071 3520 04	epp2 	-455,ic		000077 = 524000000033
001007  aa  6 00314 2521 00	spri2	pr6|204
001010  aa  6 00304 6211 00	eax1 	pr6|196
001011  aa   010000 4310 07	fld  	4096,dl
001012  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
001013  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 366
               return;

001014  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 367
               end;

						STATEMENT 1 ON LINE 369
          if hpr -> host_array (host_tb_index).host_state = bit (binary (HOST_OFF, 6))
          then do;

001015  aa   000000 2350 07	lda  	0,dl
001016  aa   000002 6050 04	tpl  	2,ic		001020
001017  aa   000000 5310 00	neg  	0
001020  aa   000036 7350 00	als  	30
001021  aa  6 00300 7551 00	sta  	pr6|192
001022  aa  6 00301 7271 00	lxl7 	pr6|193
001023  aa  3 77771 2351 17	lda  	pr3|-7,7		host_array.host_state
001024  aa   000011 7350 00	als  	9
001025  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
001026  aa  6 00300 1151 00	cmpa 	pr6|192
001027  aa   000005 6010 04	tnz  	5,ic		001034
						STATEMENT 1 ON LINE 371
               gpr -> gdt.error_code = error_table_$net_fhost_inactive;

001030  aa  6 00044 3701 20	epp4 	pr6|36,*
001031  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$net_fhost_inactive
001032  aa  7 00001 7561 00	stq  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 372
               goto return_error;

001033  aa   777630 7100 04	tra  	-104,ic		000663
						STATEMENT 1 ON LINE 373
          end;

						STATEMENT 1 ON LINE 376
          cpr = gpr -> gdt.areap;

001034  aa  7 00010 3515 20	epp1 	pr7|8,*		gdt.areap
001035  aa  6 00216 2515 00	spri1	pr6|142		cpr
						STATEMENT 1 ON LINE 378
          ccode = binary (cpr -> sccom.com, 8);

001036  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001037  aa  1 00000 00 0010	descb	pr1|0,8		sccom.com
001040  aa  6 00056 00 0044	descb	pr6|46,36
001041  aa  6 00056 2351 00	lda  	pr6|46
001042  aa   000100 7730 00	lrl  	64
001043  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 379
          ccode = min (ccode, 15);

001044  aa   000017 1160 07	cmpq 	15,dl
001045  aa   000002 6040 04	tmi  	2,ic		001047
001046  aa   000017 2360 07	ldq  	15,dl
001047  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 381
          curp = pointer (addr (ncp_tbl_$base), ncp_tbl_$ctl_tbl (ccode));

001050  aa   000022 4020 07	mpy  	18,dl
001051  aa  6 00044 3701 20	epp4 	pr6|36,*
001052  la  4 00124 3715 20	epp5 	pr4|84,*		ncp_tbl_$base
001053  la  4 00122 3535 20	epp3 	pr4|82,*
001054  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001055  aa  3 00000 00 0022	descb	pr3|0,18		ncp_tbl_$ctl_tbl
001056  aa  6 00056 00 0044	descb	pr6|46,36
001057  aa  6 00056 2351 00	lda  	pr6|46
001060  aa  5 00000 3521 00	epp2 	pr5|0
001061  aa   000000 3120 01	eawp2	0,au
001062  aa  6 00210 2521 00	spri2	pr6|136		curp
						STATEMENT 1 ON LINE 382
          goto start_operation;

001063  aa   000006 7100 04	tra  	6,ic		001071
						STATEMENT 1 ON LINE 387
next:
          curp = pointer (curp, curp -> ctlb.next);

001064  aa  6 00210 2351 20	lda  	pr6|136,*		ctlb.next
001065  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001066  aa  6 00210 3521 20	epp2 	pr6|136,*		curp
001067  aa   000000 3120 01	eawp2	0,au
001070  aa  6 00210 2521 00	spri2	pr6|136		curp
						STATEMENT 1 ON LINE 390
start_operation:
          j = binary (curp -> ctlb.op, 18);

001071  aa  6 00210 2361 20	ldq  	pr6|136,*		ctlb.op
001072  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001073  aa  6 00137 7561 00	stq  	pr6|95		j
						STATEMENT 1 ON LINE 393
          if ncp_tables_$tracing_info ^= ""b
          then do;

001074  aa  6 00044 3701 20	epp4 	pr6|36,*
001075  la  4 00012 2351 20	lda  	pr4|10,*		ncp_tables_$tracing_info
001076  aa   000050 6000 04	tze  	40,ic		001146
						STATEMENT 1 ON LINE 395
               oper_loc = binary (rel (curp), 18) - binary (rel (addr (ncp_tbl_$base)), 18);

001077  la  4 00124 3735 20	epp7 	pr4|84,*		ncp_tbl_$base
001100  aa  7 00000 6351 00	eaa  	pr7|0
001101  aa   000066 7730 00	lrl  	54
001102  aa  6 00300 7561 00	stq  	pr6|192
001103  aa  6 00210 6351 20	eaa  	pr6|136,*		curp
001104  aa   000066 7730 00	lrl  	54
001105  aa  6 00300 1761 00	sbq  	pr6|192
001106  aa  6 00100 7561 00	stq  	pr6|64		oper_loc
						STATEMENT 1 ON LINE 396
               call ncp_trace_ (TRACE_NCP_TBOP, "OPER ^2d @ ^6o  ^w  ^w", j, oper_loc, procid, gpr -> gdt.ncp_idx);

001107  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001110  aa   777074 00 0030	desc9a	-452,24		000203 = 117120105122
001111  aa  6 00246 00 0030	desc9a	pr6|166,24
001112  aa   776751 3520 04	epp2 	-535,ic		000063 = 000020000000
001113  aa  6 00330 2521 00	spri2	pr6|216
001114  aa  6 00246 3521 00	epp2 	pr6|166
001115  aa  6 00332 2521 00	spri2	pr6|218
001116  aa  6 00137 3521 00	epp2 	pr6|95		j
001117  aa  6 00334 2521 00	spri2	pr6|220
001120  aa  6 00100 3521 00	epp2 	pr6|64		oper_loc
001121  aa  6 00336 2521 00	spri2	pr6|222
001122  aa  6 00104 3521 00	epp2 	pr6|68		procid
001123  aa  6 00340 2521 00	spri2	pr6|224
001124  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
001125  aa  5 00003 3521 00	epp2 	pr5|3		gdt.ncp_idx
001126  aa  6 00342 2521 00	spri2	pr6|226
001127  aa   776760 3520 04	epp2 	-528,ic		000107 = 514000000044
001130  aa  6 00344 2521 00	spri2	pr6|228
001131  aa  6 00354 2521 00	spri2	pr6|236
001132  aa   776744 3520 04	epp2 	-540,ic		000076 = 524000000026
001133  aa  6 00346 2521 00	spri2	pr6|230
001134  aa   776741 3520 04	epp2 	-543,ic		000075 = 404000000022
001135  aa  6 00350 2521 00	spri2	pr6|232
001136  aa  6 00352 2521 00	spri2	pr6|234
001137  aa   776735 3520 04	epp2 	-547,ic		000074 = 516000000044
001140  aa  6 00356 2521 00	spri2	pr6|238
001141  aa  6 00326 6211 00	eax1 	pr6|214
001142  aa   030000 4310 07	fld  	12288,dl
001143  la  4 00100 3521 20	epp2 	pr4|64,*		ncp_trace_
001144  aa  6 00302 6535 00	spri7	pr6|194
001145  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 397
               end;

						STATEMENT 1 ON LINE 399
          mpr -> meter_dt.tbop_mf_count (j) = mpr -> meter_dt.tbop_mf_count (j) + 1;

001146  aa  6 00137 7271 00	lxl7 	pr6|95		j
001147  aa  6 00116 3735 20	epp7 	pr6|78,*		mpr
001150  aa  7 00107 0541 17	aos  	pr7|71,7		meter_dt.tbop_mf_count
						STATEMENT 1 ON LINE 400
          goto operation (j);

001151  ta   777777 7100 17	tra  	-1,7
						STATEMENT 1 ON LINE 402
transfer_arg_a:
          curp = pointer (curp, curp -> ctlb.a);

001152  aa  6 00210 3735 20	epp7 	pr6|136,*		curp
001153  aa  7 00001 2351 00	lda  	pr7|1		ctlb.a
001154  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001155  aa   000000 3334 01	eawp7	0,au
001156  aa  6 00210 6535 00	spri7	pr6|136		curp
						STATEMENT 1 ON LINE 404
          goto start_operation;

001157  aa   777712 7100 04	tra  	-54,ic		001071
						STATEMENT 1 ON LINE 406
transfer_arg_b:
          curp = pointer (curp, curp -> ctlb.b);

001160  aa  6 00210 3735 20	epp7 	pr6|136,*		curp
001161  aa  7 00001 2351 00	lda  	pr7|1		ctlb.b
001162  aa   000022 7350 00	als  	18
001163  aa   000000 3334 01	eawp7	0,au
001164  aa  6 00210 6535 00	spri7	pr6|136		curp
						STATEMENT 1 ON LINE 408
          goto start_operation;

001165  aa   777704 7100 04	tra  	-60,ic		001071
						STATEMENT 1 ON LINE 410
transfer_arg_c:
          curp = pointer (curp, curp -> ctlb.c);

001166  aa  6 00210 3735 20	epp7 	pr6|136,*		curp
001167  aa  7 00002 2351 00	lda  	pr7|2		ctlb.c
001170  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001171  aa   000000 3334 01	eawp7	0,au
001172  aa  6 00210 6535 00	spri7	pr6|136		curp
						STATEMENT 1 ON LINE 412
          goto start_operation;

001173  aa   777676 7100 04	tra  	-66,ic		001071
						STATEMENT 1 ON LINE 424
operation (3):

          call imp_order$imp_update_write_allocation ((sep -> socket.impdim_index),
                    binary (spcom.mspace, 16),
                    binary (spcom.bspace, 32));

001174  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
001175  aa  5 00016 2351 00	lda  	pr5|14		socket.impdim_index
001176  aa   000022 7350 00	als  	18
001177  aa   000066 7330 00	lrs  	54
001200  aa  6 00300 7561 00	stq  	pr6|192
001201  aa  6 00216 3535 20	epp3 	pr6|142,*		cpr
001202  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001203  aa  3 00000 27 0020	descb	pr3|0(16),16	spcom.mspace
001204  aa  6 00056 00 0044	descb	pr6|46,36
001205  aa  6 00056 2351 00	lda  	pr6|46
001206  aa   000070 7730 00	lrl  	56
001207  aa  6 00301 7561 00	stq  	pr6|193
001210  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001211  aa  3 00000 65 0040	descb	pr3|0(32),32	spcom.bspace
001212  aa  6 00056 00 0044	descb	pr6|46,36
001213  aa  6 00056 2351 00	lda  	pr6|46
001214  aa   000050 7730 00	lrl  	40
001215  aa  6 00245 7561 00	stq  	pr6|165
001216  aa  6 00300 3521 00	epp2 	pr6|192
001217  aa  6 00250 2521 00	spri2	pr6|168
001220  aa  6 00301 3521 00	epp2 	pr6|193
001221  aa  6 00252 2521 00	spri2	pr6|170
001222  aa  6 00245 3521 00	epp2 	pr6|165
001223  aa  6 00254 2521 00	spri2	pr6|172
001224  aa  6 00246 6211 00	eax1 	pr6|166
001225  aa   014000 4310 07	fld  	6144,dl
001226  aa  6 00044 3701 20	epp4 	pr6|36,*
001227  la  4 00050 3521 20	epp2 	pr4|40,*		imp_order$imp_update_write_allocation
001230  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 429
          goto next;

001231  aa   777633 7100 04	tra  	-101,ic		001064
						STATEMENT 1 ON LINE 435
operation (5):
          com_len = binary (curp -> ctlb.a, 18);

001232  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
001233  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
001234  aa   000066 7730 00	lrl  	54
001235  aa  6 00214 7561 00	stq  	pr6|140		com_len
						STATEMENT 1 ON LINE 437
          goto next;

001236  aa   777626 7100 04	tra  	-106,ic		001064
						STATEMENT 1 ON LINE 447
operation (15):
          linkt = binary (cpr -> lkcom.link, 8);

001237  aa  6 00216 3715 20	epp5 	pr6|142,*		cpr
001240  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001241  aa  5 00000 10 0010	descb	pr5|0(8),8	lkcom.link
001242  aa  6 00056 00 0044	descb	pr6|46,36
001243  aa  6 00056 2351 00	lda  	pr6|46
001244  aa   000100 7730 00	lrl  	64
001245  aa  6 00227 7561 00	stq  	pr6|151		linkt
						STATEMENT 1 ON LINE 449
          rw = binary (curp -> ctlb.a, 18);

001246  aa  6 00210 3535 20	epp3 	pr6|136,*		curp
001247  aa  3 00001 2351 00	lda  	pr3|1		ctlb.a
001250  aa   000066 7730 00	lrl  	54
001251  aa  6 00146 7561 00	stq  	pr6|102		rw
						STATEMENT 1 ON LINE 450
          ccode = binary (curp -> ctlb.b, 18);

001252  aa  3 00001 2361 00	ldq  	pr3|1		ctlb.b
001253  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
001254  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 452
          call ncp_util_$find_socket_from_link_number (host_code, (linkt), bit (binary (rw, 1)), sep, icode);

001255  aa  6 00227 2361 00	ldq  	pr6|151		linkt
001256  aa  6 00245 7561 00	stq  	pr6|165
001257  aa  6 00146 2351 00	lda  	pr6|102		rw
001260  aa   000002 6050 04	tpl  	2,ic		001262
001261  aa   000000 5310 00	neg  	0
001262  aa   000043 7350 00	als  	35
001263  aa  6 00301 7551 00	sta  	pr6|193
001264  aa  6 00101 3521 00	epp2 	pr6|65		host_code
001265  aa  6 00260 2521 00	spri2	pr6|176
001266  aa  6 00245 3521 00	epp2 	pr6|165
001267  aa  6 00262 2521 00	spri2	pr6|178
001270  aa  6 00301 3521 00	epp2 	pr6|193
001271  aa  6 00264 2521 00	spri2	pr6|180
001272  aa  6 00126 3521 00	epp2 	pr6|86		sep
001273  aa  6 00266 2521 00	spri2	pr6|182
001274  aa  6 00103 3521 00	epp2 	pr6|67		icode
001275  aa  6 00270 2521 00	spri2	pr6|184
001276  aa  6 00256 6211 00	eax1 	pr6|174
001277  aa   024000 4310 07	fld  	10240,dl
001300  aa  6 00044 3701 20	epp4 	pr6|36,*
001301  la  4 00106 3521 20	epp2 	pr4|70,*		ncp_util_$find_socket_from_link_number
001302  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 453
          if icode ^= 0
          then goto next;

001303  aa  6 00103 2361 00	ldq  	pr6|67		icode
001304  aa   777560 6010 04	tnz  	-144,ic		001064
						STATEMENT 1 ON LINE 456
          lockp = addr (sep -> socket.lock);

001305  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
001306  aa  7 00004 3735 00	epp7 	pr7|4		socket.lock
001307  aa  6 00144 6535 00	spri7	pr6|100		lockp
						STATEMENT 1 ON LINE 457
          gpr -> gdt.ncp_idx = sep -> socket.socket_index;

001310  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
001311  aa  5 00026 2351 00	lda  	pr5|22		socket.socket_index
001312  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
001313  aa  3 00003 7551 00	sta  	pr3|3		gdt.ncp_idx
						STATEMENT 1 ON LINE 458
          goto pcom_state_tbl_init;

001314  aa   777251 7100 04	tra  	-343,ic		000565
						STATEMENT 1 ON LINE 464
operation (24):
          if sep -> socket.send_gender = READ_GENDER
          then goto transfer_arg_a;

001315  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
001316  aa  5 00017 2351 00	lda  	pr5|15		socket.send_gender
001317  aa   000010 3150 03	cana 	8,du
001320  aa   777632 6000 04	tze  	-102,ic		001152
						STATEMENT 1 ON LINE 467
          goto next;

001321  aa   777543 7100 04	tra  	-157,ic		001064
						STATEMENT 1 ON LINE 473
operation (29):
          goto return_label;

001322  aa  6 00132 7101 20	tra  	pr6|90,*		return_label
						STATEMENT 1 ON LINE 482
operation (35):
          call ncp_access_$signal_process (sep, binary (ctlb.a, 1), (0));

001323  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
001324  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
001325  aa   000066 7730 00	lrl  	54
001326  aa  6 00301 7561 00	stq  	pr6|193
001327  aa  6 00245 4501 00	stz  	pr6|165
001330  aa  6 00126 3521 00	epp2 	pr6|86		sep
001331  aa  6 00250 2521 00	spri2	pr6|168
001332  aa  6 00301 3521 00	epp2 	pr6|193
001333  aa  6 00252 2521 00	spri2	pr6|170
001334  aa  6 00245 3521 00	epp2 	pr6|165
001335  aa  6 00254 2521 00	spri2	pr6|172
001336  aa  6 00246 6211 00	eax1 	pr6|166
001337  aa   014000 4310 07	fld  	6144,dl
001340  aa  6 00044 3701 20	epp4 	pr6|36,*
001341  la  4 00064 3521 20	epp2 	pr4|52,*		ncp_access_$signal_process
001342  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 485
          goto next;

001343  aa   777521 7100 04	tra  	-175,ic		001064
						STATEMENT 1 ON LINE 492
operation (40):
unlock_return1:
          call ncp_lock_$lock_unlock (lockp, icode);

001344  aa  6 00144 3521 00	epp2 	pr6|100		lockp
001345  aa  6 00250 2521 00	spri2	pr6|168
001346  aa  6 00103 3521 00	epp2 	pr6|67		icode
001347  aa  6 00252 2521 00	spri2	pr6|170
001350  aa  6 00246 6211 00	eax1 	pr6|166
001351  aa   010000 4310 07	fld  	4096,dl
001352  aa  6 00044 3701 20	epp4 	pr6|36,*
001353  la  4 00074 3521 20	epp2 	pr4|60,*		ncp_lock_$lock_unlock
001354  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 495
          goto return_label;

001355  aa  6 00132 7101 20	tra  	pr6|90,*		return_label
						STATEMENT 1 ON LINE 507
operation (4):
          if sep -> socket.send_gender = WRITE_GENDER
          then do;

001356  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
001357  aa  7 00017 2351 00	lda  	pr7|15		socket.send_gender
001360  aa   000016 7350 00	als  	14
001361  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001362  aa   400000 1150 03	cmpa 	131072,du
001363  aa   000003 6010 04	tnz  	3,ic		001366
						STATEMENT 1 ON LINE 510
               sep -> socket.link_number = linkt;

001364  aa  6 00227 2361 00	ldq  	pr6|151		linkt
001365  aa  7 00015 5521 14	stbq 	pr7|13,14		socket.link_number
						STATEMENT 1 ON LINE 511
               end;

						STATEMENT 1 ON LINE 513
          call ncp_access_$assign_link (sep, gpr -> gdt.error_code);

001366  aa  6 00126 3521 00	epp2 	pr6|86		sep
001367  aa  6 00250 2521 00	spri2	pr6|168
001370  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
001371  aa  5 00001 3521 00	epp2 	pr5|1		gdt.error_code
001372  aa  6 00252 2521 00	spri2	pr6|170
001373  aa  6 00246 6211 00	eax1 	pr6|166
001374  aa   010000 4310 07	fld  	4096,dl
001375  aa  6 00044 3701 20	epp4 	pr6|36,*
001376  la  4 00056 3521 20	epp2 	pr4|46,*		ncp_access_$assign_link
001377  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 514
          if gpr -> gdt.error_code ^= 0
          then do;

001400  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
001401  aa  7 00001 2361 00	ldq  	pr7|1		gdt.error_code
001402  aa   000026 6000 04	tze  	22,ic		001430
						STATEMENT 1 ON LINE 516
               if (gpr -> gdt.error_code = error_table_$net_fhost_inactive) | (gpr -> gdt.error_code = error_table_$notalloc)
               then goto transfer_arg_b;

001403  aa  6 00044 3701 20	epp4 	pr6|36,*
001404  la  4 00040 1161 20	cmpq 	pr4|32,*		error_table_$net_fhost_inactive
001405  aa   777553 6000 04	tze  	-149,ic		001160
001406  la  4 00044 1161 20	cmpq 	pr4|36,*		error_table_$notalloc
001407  aa   777551 6000 04	tze  	-151,ic		001160
						STATEMENT 1 ON LINE 519
               call ncp_error_ (gpr -> gdt.error_code, "TBOP_assign_link_error");

001410  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001411  aa   776565 00 0030	desc9a	-651,24		000175 = 124102117120
001412  aa  6 00246 00 0030	desc9a	pr6|166,24
001413  aa  7 00001 3521 00	epp2 	pr7|1		gdt.error_code
001414  aa  6 00306 2521 00	spri2	pr6|198
001415  aa  6 00246 3521 00	epp2 	pr6|166
001416  aa  6 00310 2521 00	spri2	pr6|200
001417  aa   776465 3520 04	epp2 	-715,ic		000104 = 404000000043
001420  aa  6 00312 2521 00	spri2	pr6|202
001421  aa   776455 3520 04	epp2 	-723,ic		000076 = 524000000026
001422  aa  6 00314 2521 00	spri2	pr6|204
001423  aa  6 00304 6211 00	eax1 	pr6|196
001424  aa   010000 4310 07	fld  	4096,dl
001425  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
001426  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 520
               return;

001427  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 521
               end;

						STATEMENT 1 ON LINE 523
          linkt = sep -> socket.link_number;

001430  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
001431  aa  5 00015 2351 00	lda  	pr5|13		socket.link_number
001432  aa   000022 7350 00	als  	18
001433  aa   000066 7330 00	lrs  	54
001434  aa  6 00227 7561 00	stq  	pr6|151		linkt
						STATEMENT 1 ON LINE 525
          goto next;

001435  aa   777427 7100 04	tra  	-233,ic		001064
						STATEMENT 1 ON LINE 533
operation (8):
          substr (control_message, 1, 8) = bit (binary (ctlb.a, 8));

001436  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
001437  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
001440  aa   000066 7730 00	lrl  	54
001441  aa  0 00000 1161 00	cmpq 	pr0|0		= 000000000000
001442  aa   000003 6050 04	tpl  	3,ic		001445
001443  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
001444  aa   000001 0760 07	adq  	1,dl
001445  aa   000100 7370 00	lls  	64
001446  aa  6 00152 6751 00	era  	pr6|106		control_message
001447  aa  0 00020 3751 00	ana  	pr0|16		= 776000000000
001450  aa  6 00152 6551 00	ersa 	pr6|106		control_message
						STATEMENT 1 ON LINE 536
          i = 2;

001451  aa   000002 2360 07	ldq  	2,dl
001452  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 537
          j = 9;

001453  aa   000011 2360 07	ldq  	9,dl
001454  aa  6 00137 7561 00	stq  	pr6|95		j
						STATEMENT 1 ON LINE 539
cm_get_arg:
          k = binary (ctlb1.arg (i), 17) - 64;

001455  aa  6 00136 2361 00	ldq  	pr6|94		i
001456  aa   000022 4020 07	mpy  	18,dl
001457  aa  6 00210 3735 20	epp7 	pr6|136,*		curp
001460  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001461  aa  7 00000 40 0022	descb	pr7|0(18),18	ctlb1.arg
001462  aa  6 00056 00 0044	descb	pr6|46,36
001463  aa  6 00056 2351 00	lda  	pr6|46
001464  aa   000066 7730 00	lrl  	54
001465  aa   000100 1760 07	sbq  	64,dl
001466  aa  6 00140 7561 00	stq  	pr6|96		k
						STATEMENT 1 ON LINE 541
          if k < 0 then goto cm_put_out;

001467  aa   000006 6040 04	tmi  	6,ic		001475
						STATEMENT 1 ON LINE 542
          goto cm_op (k);

001470  ta   000051 7100 06	tra  	41,ql
						STATEMENT 1 ON LINE 544
cm_get_nxt:
          i = i + 1;

001471  aa  6 00136 0541 00	aos  	pr6|94		i
						STATEMENT 1 ON LINE 546
          if i <= 4 then goto cm_get_arg;

001472  aa  6 00136 2361 00	ldq  	pr6|94		i
001473  aa   000004 1160 07	cmpq 	4,dl
001474  aa   777761 6044 04	tmoz 	-15,ic		001455
						STATEMENT 1 ON LINE 548
cm_put_out:
          if (host_tb_index <= 0) | (host_tb_index > npr -> ncp_dt.htbl_gent)
          then do;

001475  aa  6 00226 2361 00	ldq  	pr6|150		host_tb_index
001476  aa   000004 6044 04	tmoz 	4,ic		001502
001477  aa  6 00120 3735 20	epp7 	pr6|80,*		npr
001500  aa  7 00010 1161 00	cmpq 	pr7|8		ncp_dt.htbl_gent
001501  aa   000026 6044 04	tmoz 	22,ic		001527
						STATEMENT 1 ON LINE 551
               call ncp_error_ (0, "TBOP_bad_host_index");

001502  aa  6 00245 4501 00	stz  	pr6|165
001503  aa   776443 2370 04	ldaq 	-733,ic		000146 = 124102117120 137142141144
001504  aa  6 00246 7571 00	staq 	pr6|166
001505  aa   776443 2370 04	ldaq 	-733,ic		000150 = 137150157163 164137151156
001506  aa  6 00250 7571 00	staq 	pr6|168
001507  aa   776443 2350 04	lda  	-733,ic		000152 = 144145170000
001510  aa  6 00252 7551 00	sta  	pr6|170
001511  aa  6 00245 3521 00	epp2 	pr6|165
001512  aa  6 00260 2521 00	spri2	pr6|176
001513  aa  6 00246 3521 00	epp2 	pr6|166
001514  aa  6 00262 2521 00	spri2	pr6|178
001515  aa   776367 3520 04	epp2 	-777,ic		000104 = 404000000043
001516  aa  6 00264 2521 00	spri2	pr6|180
001517  aa   776354 3520 04	epp2 	-788,ic		000073 = 524000000023
001520  aa  6 00266 2521 00	spri2	pr6|182
001521  aa  6 00256 6211 00	eax1 	pr6|174
001522  aa   010000 4310 07	fld  	4096,dl
001523  aa  6 00044 3701 20	epp4 	pr6|36,*
001524  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
001525  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 552
               return;

001526  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 553
               end;

						STATEMENT 1 ON LINE 555
          host_ptr = addr (hpr -> host_array (host_tb_index));

001527  aa   000012 4020 07	mpy  	10,dl
001530  aa  6 00114 3715 20	epp5 	pr6|76,*		hpr
001531  aa  5 77766 3715 06	epp5 	pr5|-10,ql	host_array
001532  aa  6 00110 6515 00	spri5	pr6|72		host_ptr
						STATEMENT 1 ON LINE 556
          if host_ptr -> host.host_state = bit (binary (HOST_OFF, 6))
          then do;

001533  aa   000000 2350 07	lda  	0,dl
001534  aa   000002 6050 04	tpl  	2,ic		001536
001535  aa   000000 5310 00	neg  	0
001536  aa   000036 7350 00	als  	30
001537  aa  6 00245 7551 00	sta  	pr6|165
001540  aa  5 00003 2351 00	lda  	pr5|3		host.host_state
001541  aa   000011 7350 00	als  	9
001542  aa  6 00301 7561 00	stq  	pr6|193
001543  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
001544  aa  6 00245 1151 00	cmpa 	pr6|165
001545  aa   000022 6010 04	tnz  	18,ic		001567
						STATEMENT 1 ON LINE 558
               call ncp_error_ (error_table_$net_fhost_inactive, "TBOP_sending_ctl_msg");

001546  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001547  aa   776373 00 0024	desc9a	-773,20		000141 = 124102117120
001550  aa  6 00246 00 0024	desc9a	pr6|166,20
001551  aa  6 00044 3701 20	epp4 	pr6|36,*
001552  la  4 00040 3521 20	epp2 	pr4|32,*		error_table_$net_fhost_inactive
001553  aa  6 00306 2521 00	spri2	pr6|198
001554  aa  6 00246 3521 00	epp2 	pr6|166
001555  aa  6 00310 2521 00	spri2	pr6|200
001556  aa   776326 3520 04	epp2 	-810,ic		000104 = 404000000043
001557  aa  6 00312 2521 00	spri2	pr6|202
001560  aa   776312 3520 04	epp2 	-822,ic		000072 = 524000000024
001561  aa  6 00314 2521 00	spri2	pr6|204
001562  aa  6 00304 6211 00	eax1 	pr6|196
001563  aa   010000 4310 07	fld  	4096,dl
001564  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
001565  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 559
               return;

001566  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 560
               end;

						STATEMENT 1 ON LINE 562
          num_bytes = divide (j, 8, 17, 0);

001567  aa  6 00137 2361 00	ldq  	pr6|95		j
001570  aa   000010 5060 07	div  	8,dl
001571  aa  6 00102 7561 00	stq  	pr6|66		num_bytes
						STATEMENT 1 ON LINE 563
          call ncp_util_$send_control_message (addr (hpr -> host_array (host_tb_index)), addr (control_message), num_bytes, icode);

001572  aa  6 00301 7271 00	lxl7 	pr6|193
001573  aa  6 00114 3535 20	epp3 	pr6|76,*		hpr
001574  aa  3 77766 3535 17	epp3 	pr3|-10,7		host_array
001575  aa  6 00360 2535 00	spri3	pr6|240
001576  aa  6 00152 3515 00	epp1 	pr6|106		control_message
001577  aa  6 00362 2515 00	spri1	pr6|242
001600  aa  6 00360 3521 00	epp2 	pr6|240
001601  aa  6 00260 2521 00	spri2	pr6|176
001602  aa  6 00362 3521 00	epp2 	pr6|242
001603  aa  6 00262 2521 00	spri2	pr6|178
001604  aa  6 00102 3521 00	epp2 	pr6|66		num_bytes
001605  aa  6 00264 2521 00	spri2	pr6|180
001606  aa  6 00103 3521 00	epp2 	pr6|67		icode
001607  aa  6 00266 2521 00	spri2	pr6|182
001610  aa  6 00256 6211 00	eax1 	pr6|174
001611  aa   020000 4310 07	fld  	8192,dl
001612  aa  6 00044 3701 20	epp4 	pr6|36,*
001613  la  4 00112 3521 20	epp2 	pr4|74,*		ncp_util_$send_control_message
001614  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 564
          if icode = 0 then goto next;

001615  aa  6 00103 2361 00	ldq  	pr6|67		icode
001616  aa   777246 6000 04	tze  	-346,ic		001064
						STATEMENT 1 ON LINE 565
          gpr -> gdt.error_code = icode;

001617  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
001620  aa  7 00001 7561 00	stq  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 566
          call ncp_error_ (icode, "TBOP_unable_to_send_ctl_msg");

001621  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001622  aa   776370 00 0034	desc9a	-776,28		000211 = 124102117120
001623  aa  6 00246 00 0034	desc9a	pr6|166,28
001624  aa  6 00103 3521 00	epp2 	pr6|67		icode
001625  aa  6 00306 2521 00	spri2	pr6|198
001626  aa  6 00246 3521 00	epp2 	pr6|166
001627  aa  6 00310 2521 00	spri2	pr6|200
001630  aa   776254 3520 04	epp2 	-852,ic		000104 = 404000000043
001631  aa  6 00312 2521 00	spri2	pr6|202
001632  aa   776245 3520 04	epp2 	-859,ic		000077 = 524000000033
001633  aa  6 00314 2521 00	spri2	pr6|204
001634  aa  6 00304 6211 00	eax1 	pr6|196
001635  aa   010000 4310 07	fld  	4096,dl
001636  aa  6 00044 3701 20	epp4 	pr6|36,*
001637  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
001640  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 567
          return;

001641  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 569
cm_op (0):
          substr (control_message, j, 32) = substr (fsoct, 33, 32);

001642  aa  6 00137 7271 00	lxl7 	pr6|95		j
001643  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001644  aa  6 00222 65 0040	descb	pr6|146(32),32	fsoct
001645  aa  6 00151 70 0040	descb	pr6|105(35),32	control_message
						STATEMENT 1 ON LINE 571
          j = j + 32;

001646  aa   000040 2360 07	ldq  	32,dl
001647  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 572
          goto cm_get_nxt;

001650  aa   777621 7100 04	tra  	-111,ic		001471
						STATEMENT 1 ON LINE 574
cm_op (1):
          substr (control_message, j, 32) = substr (lsoct, 33, 32);

001651  aa  6 00137 7271 00	lxl7 	pr6|95		j
001652  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001653  aa  6 00230 65 0040	descb	pr6|152(32),32	lsoct
001654  aa  6 00151 70 0040	descb	pr6|105(35),32	control_message
						STATEMENT 1 ON LINE 576
          j = j + 32;

001655  aa   000040 2360 07	ldq  	32,dl
001656  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 577
          goto cm_get_nxt;

001657  aa   777612 7100 04	tra  	-118,ic		001471
						STATEMENT 1 ON LINE 579
cm_op (2):
          substr (control_message, j, 8) = bit (binary (sep -> socket.link_number, 8));

001660  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
001661  aa  5 00015 2351 00	lda  	pr5|13		socket.link_number
001662  aa   000022 7350 00	als  	18
001663  aa   000066 7330 00	lrs  	54
001664  aa   000003 6050 04	tpl  	3,ic		001667
001665  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
001666  aa   000001 0760 07	adq  	1,dl
001667  aa   000100 7370 00	lls  	64
001670  aa  6 00056 7551 00	sta  	pr6|46
001671  aa  6 00137 7271 00	lxl7 	pr6|95		j
001672  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001673  aa  6 00056 00 0010	descb	pr6|46,8
001674  aa  6 00151 70 0010	descb	pr6|105(35),8	control_message
						STATEMENT 1 ON LINE 581
          j = j + 8;

001675  aa   000010 2360 07	ldq  	8,dl
001676  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 582
          goto cm_get_nxt;

001677  aa   777572 7100 04	tra  	-134,ic		001471
						STATEMENT 1 ON LINE 584
cm_op (3):
          substr (control_message, j, 32) = bit (binary (bspace, 32));

001700  aa  6 00236 2351 00	lda  	pr6|158		bspace
001701  aa   000002 6050 04	tpl  	2,ic		001703
001702  aa   000000 5310 00	neg  	0
001703  aa   000004 7350 00	als  	4
001704  aa  6 00056 7551 00	sta  	pr6|46
001705  aa  6 00137 7271 00	lxl7 	pr6|95		j
001706  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001707  aa  6 00056 00 0040	descb	pr6|46,32
001710  aa  6 00151 70 0040	descb	pr6|105(35),32	control_message
						STATEMENT 1 ON LINE 586
          j = j + 32;

001711  aa   000040 2360 07	ldq  	32,dl
001712  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 587
          goto cm_get_nxt;

001713  aa   777556 7100 04	tra  	-146,ic		001471
						STATEMENT 1 ON LINE 589
cm_op (4):
          substr (control_message, j, 16) = bit (binary (mspace, 16));

001714  aa  6 00237 2351 00	lda  	pr6|159		mspace
001715  aa   000002 6050 04	tpl  	2,ic		001717
001716  aa   000000 5310 00	neg  	0
001717  aa   000024 7350 00	als  	20
001720  aa  6 00056 7551 00	sta  	pr6|46
001721  aa  6 00137 7271 00	lxl7 	pr6|95		j
001722  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001723  aa  6 00056 00 0020	descb	pr6|46,16
001724  aa  6 00151 70 0020	descb	pr6|105(35),16	control_message
						STATEMENT 1 ON LINE 591
          j = j + 16;

001725  aa   000020 2360 07	ldq  	16,dl
001726  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 592
          goto cm_get_nxt;

001727  aa   777542 7100 04	tra  	-158,ic		001471
						STATEMENT 1 ON LINE 594
cm_op (5):
          i = i + 1;

001730  aa  6 00136 0541 00	aos  	pr6|94		i
						STATEMENT 1 ON LINE 596
          substr (control_message, j, 8) = bit (binary (ctlb1.arg (i), 8));

001731  aa  6 00136 2361 00	ldq  	pr6|94		i
001732  aa   000022 4020 07	mpy  	18,dl
001733  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001734  aa  7 00000 40 0022	descb	pr7|0(18),18	ctlb1.arg
001735  aa  6 00056 00 0044	descb	pr6|46,36
001736  aa  6 00056 2351 00	lda  	pr6|46
001737  aa   000066 7730 00	lrl  	54
001740  aa  0 00000 1161 00	cmpq 	pr0|0		= 000000000000
001741  aa   000003 6050 04	tpl  	3,ic		001744
001742  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
001743  aa   000001 0760 07	adq  	1,dl
001744  aa   000100 7370 00	lls  	64
001745  aa  6 00056 7551 00	sta  	pr6|46
001746  aa  6 00137 7271 00	lxl7 	pr6|95		j
001747  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001750  aa  6 00056 00 0010	descb	pr6|46,8
001751  aa  6 00151 70 0010	descb	pr6|105(35),8	control_message
						STATEMENT 1 ON LINE 597
          j = j + 8;

001752  aa   000010 2360 07	ldq  	8,dl
001753  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 598
          goto cm_get_nxt;

001754  aa   777515 7100 04	tra  	-179,ic		001471
						STATEMENT 1 ON LINE 600
cm_op (6):
          substr (control_message, j, 80) = ""b;

001755  aa  6 00137 7271 00	lxl7 	pr6|95		j
001756  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
001757  aa   000000 00 0000	descb	0,0
001760  aa  6 00151 70 0120	descb	pr6|105(35),80	control_message
						STATEMENT 1 ON LINE 602
          substr (control_message, j, com_len) = cpr -> bit80;

001761  aa  6 00216 3715 20	epp5 	pr6|142,*		cpr
001762  aa  6 00214 7261 00	lxl6 	pr6|140		com_len
001763  aa  003 157 060 500	csl  	(pr),(pr,rl,x7),fill(0),bool(move)
001764  aa  5 00000 00 0120	descb	pr5|0,80		bit80
001765  aa  6 00151 70 0016	descb	pr6|105(35),x6	control_message
						STATEMENT 1 ON LINE 603
          j = j + 80;

001766  aa   000120 2360 07	ldq  	80,dl
001767  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 604
          goto cm_get_nxt;

001770  aa   777501 7100 04	tra  	-191,ic		001471
						STATEMENT 1 ON LINE 606
cm_op (7):
          substr (control_message, j, 8) = cpr -> ercom.code;

001771  aa  6 00137 7271 00	lxl7 	pr6|95		j
001772  aa  6 00216 3715 20	epp5 	pr6|142,*		cpr
001773  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
001774  aa  5 00000 10 0010	descb	pr5|0(8),8	ercom.code
001775  aa  6 00151 70 0010	descb	pr6|105(35),8	control_message
						STATEMENT 1 ON LINE 608
          j = j + 8;

001776  aa   000010 2360 07	ldq  	8,dl
001777  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 609
          goto cm_get_nxt;

002000  aa   777471 7100 04	tra  	-199,ic		001471
						STATEMENT 1 ON LINE 611
cm_op (8):
          substr (control_message, j, 32) = substr (fsoct1, 33, 32);

002001  aa  6 00137 7271 00	lxl7 	pr6|95		j
002002  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
002003  aa  6 00224 65 0040	descb	pr6|148(32),32	fsoct1
002004  aa  6 00151 70 0040	descb	pr6|105(35),32	control_message
						STATEMENT 1 ON LINE 613
          j = j + 32;

002005  aa   000040 2360 07	ldq  	32,dl
002006  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 614
          goto cm_get_nxt;

002007  aa   777462 7100 04	tra  	-206,ic		001471
						STATEMENT 1 ON LINE 616
cm_op (9):
          substr (control_message, j, 8) = sep -> socket.byte_size;

002010  aa  6 00137 7271 00	lxl7 	pr6|95		j
002011  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002012  aa  003 117 060 500	csl  	(pr),(pr,x7),fill(0),bool(move)
002013  aa  5 00017 06 0010	descb	pr5|15(6),8	socket.byte_size
002014  aa  6 00151 70 0010	descb	pr6|105(35),8	control_message
						STATEMENT 1 ON LINE 618
          j = j + 8;

002015  aa   000010 2360 07	ldq  	8,dl
002016  aa  6 00137 0561 00	asq  	pr6|95		j
						STATEMENT 1 ON LINE 619
          goto cm_get_nxt;

002017  aa   777452 7100 04	tra  	-214,ic		001471
						STATEMENT 1 ON LINE 627
operation (9):
          if sep -> socket.deactivate then goto transfer_arg_a;

002020  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002021  aa  5 00017 2351 00	lda  	pr5|15		socket.deactivate
002022  aa   000002 3150 03	cana 	2,du
002023  aa   777127 6010 04	tnz  	-425,ic		001152
						STATEMENT 1 ON LINE 629
          goto next;

002024  aa   777040 7100 04	tra  	-480,ic		001064
						STATEMENT 1 ON LINE 638
operation (16):
          ccode = binary (curp -> ctlb.a, 18);

002025  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
002026  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
002027  aa   000066 7730 00	lrl  	54
002030  aa  6 00213 7561 00	stq  	pr6|139		ccode
						STATEMENT 1 ON LINE 641
          call ncp_util_$find_socket_from_socket_number (binary (substr (lsoct, 1, 32)), binary (substr (lsoct, 33, 32)), "1"b, sep, icode);

002031  aa  6 00230 2351 00	lda  	pr6|152		lsoct
002032  aa   000050 7730 00	lrl  	40
002033  aa  6 00301 7561 00	stq  	pr6|193
002034  aa  6 00230 2371 00	ldaq 	pr6|152		lsoct
002035  aa   000040 7370 00	lls  	32
002036  aa   000050 7730 00	lrl  	40
002037  aa  6 00245 7561 00	stq  	pr6|165
002040  aa   400000 2350 03	lda  	131072,du
002041  aa  6 00300 7551 00	sta  	pr6|192
002042  aa  6 00301 3521 00	epp2 	pr6|193
002043  aa  6 00260 2521 00	spri2	pr6|176
002044  aa  6 00245 3521 00	epp2 	pr6|165
002045  aa  6 00262 2521 00	spri2	pr6|178
002046  aa  6 00300 3521 00	epp2 	pr6|192
002047  aa  6 00264 2521 00	spri2	pr6|180
002050  aa  6 00126 3521 00	epp2 	pr6|86		sep
002051  aa  6 00266 2521 00	spri2	pr6|182
002052  aa  6 00103 3521 00	epp2 	pr6|67		icode
002053  aa  6 00270 2521 00	spri2	pr6|184
002054  aa  6 00256 6211 00	eax1 	pr6|174
002055  aa   024000 4310 07	fld  	10240,dl
002056  aa  6 00044 3701 20	epp4 	pr6|36,*
002057  la  4 00110 3521 20	epp2 	pr4|72,*		ncp_util_$find_socket_from_socket_number
002060  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 642
          if icode ^= 0
          then goto next;

002061  aa  6 00103 2361 00	ldq  	pr6|67		icode
002062  aa   777002 6010 04	tnz  	-510,ic		001064
						STATEMENT 1 ON LINE 645
          lockp = addr (sep -> socket.lock);

002063  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
002064  aa  7 00004 3735 00	epp7 	pr7|4		socket.lock
002065  aa  6 00144 6535 00	spri7	pr6|100		lockp
						STATEMENT 1 ON LINE 646
          gpr -> gdt.ncp_idx = sep -> socket.socket_index;

002066  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002067  aa  5 00026 2351 00	lda  	pr5|22		socket.socket_index
002070  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
002071  aa  3 00003 7551 00	sta  	pr3|3		gdt.ncp_idx
						STATEMENT 1 ON LINE 647
          goto pcom_state_tbl_init;

002072  aa   776473 7100 04	tra  	-709,ic		000565
						STATEMENT 1 ON LINE 655
operation (17):
          if fsoct ^= fsoct1 then goto transfer_arg_a;

002073  aa  6 00222 2371 00	ldaq 	pr6|146		fsoct
002074  aa  6 00224 1171 00	cmpaq	pr6|148		fsoct1
002075  aa   777055 6010 04	tnz  	-467,ic		001152
						STATEMENT 1 ON LINE 657
          goto next;

002076  aa   776766 7100 04	tra  	-522,ic		001064
						STATEMENT 1 ON LINE 666
operation (18):
          ppqn = pqn;

002077  aa  6 00242 2361 00	ldq  	pr6|162		pqn
002100  aa  6 00243 7561 00	stq  	pr6|163		ppqn
						STATEMENT 1 ON LINE 668
          pqn = qn;

002101  aa  6 00241 2361 00	ldq  	pr6|161		qn
002102  aa  6 00242 7561 00	stq  	pr6|162		pqn
						STATEMENT 1 ON LINE 669
          if pqn = -1
          then qn = sep -> socket.rfc_queue;

002103  aa   001365 1160 04	cmpq 	757,ic		003470 = 777777777777
002104  aa   000006 6010 04	tnz  	6,ic		002112
002105  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002106  aa  5 00015 2351 00	lda  	pr5|13		socket.rfc_queue
002107  aa   000066 7330 00	lrs  	54
002110  aa  6 00241 7561 00	stq  	pr6|161		qn
002111  aa   000034 7100 04	tra  	28,ic		002145
						STATEMENT 1 ON LINE 671
          else if pqn = 0
               then do;

002112  aa  6 00242 2361 00	ldq  	pr6|162		pqn
002113  aa   000024 6010 04	tnz  	20,ic		002137
						STATEMENT 1 ON LINE 673
                    call ncp_error_ (0, "TBOP_no_next_RFC");

002114  aa  6 00300 4501 00	stz  	pr6|192
002115  aa   776007 2370 04	ldaq 	-1017,ic		000124 = 124102117120 137156157137
002116  aa  6 00246 7571 00	staq 	pr6|166
002117  aa   776007 2370 04	ldaq 	-1017,ic		000126 = 156145170164 137122106103
002120  aa  6 00250 7571 00	staq 	pr6|168
002121  aa  6 00300 3521 00	epp2 	pr6|192
002122  aa  6 00306 2521 00	spri2	pr6|198
002123  aa  6 00246 3521 00	epp2 	pr6|166
002124  aa  6 00310 2521 00	spri2	pr6|200
002125  aa   775757 3520 04	epp2 	-1041,ic		000104 = 404000000043
002126  aa  6 00312 2521 00	spri2	pr6|202
002127  aa   775742 3520 04	epp2 	-1054,ic		000071 = 524000000020
002130  aa  6 00314 2521 00	spri2	pr6|204
002131  aa  6 00304 6211 00	eax1 	pr6|196
002132  aa   010000 4310 07	fld  	4096,dl
002133  aa  6 00044 3701 20	epp4 	pr6|36,*
002134  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
002135  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 674
                    return;

002136  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 675
                    end;

						STATEMENT 1 ON LINE 676
               else qn = rpr -> rfc_array (pqn).next_entry;

002137  aa   000002 7360 00	qls  	2
002140  aa  6 00124 3715 20	epp5 	pr6|84,*		rpr
002141  aa  5 77776 2351 06	lda  	pr5|-2,ql		rfc_array.next_entry
002142  aa   000022 7350 00	als  	18
002143  aa   000066 7330 00	lrs  	54
002144  aa  6 00241 7561 00	stq  	pr6|161		qn
						STATEMENT 1 ON LINE 678
          queue_level = queue_level + 1;

002145  aa  6 00235 0541 00	aos  	pr6|157		queue_level
						STATEMENT 1 ON LINE 679
          if queue_level > 10 then do;

002146  aa  6 00235 2361 00	ldq  	pr6|157		queue_level
002147  aa   000012 1160 07	cmpq 	10,dl
002150  aa   000026 6044 04	tmoz 	22,ic		002176
						STATEMENT 1 ON LINE 680
               call ncp_error_ (0, "TBOP_too_many_RFCs");

002151  aa  6 00300 4501 00	stz  	pr6|192
002152  aa   775762 2370 04	ldaq 	-1038,ic		000134 = 124102117120 137164157157
002153  aa  6 00246 7571 00	staq 	pr6|166
002154  aa   775762 2370 04	ldaq 	-1038,ic		000136 = 137155141156 171137122106
002155  aa  6 00250 7571 00	staq 	pr6|168
002156  aa   103163 2350 03	lda  	34419,du
002157  aa  6 00252 7551 00	sta  	pr6|170
002160  aa  6 00300 3521 00	epp2 	pr6|192
002161  aa  6 00260 2521 00	spri2	pr6|176
002162  aa  6 00246 3521 00	epp2 	pr6|166
002163  aa  6 00262 2521 00	spri2	pr6|178
002164  aa   775720 3520 04	epp2 	-1072,ic		000104 = 404000000043
002165  aa  6 00264 2521 00	spri2	pr6|180
002166  aa   775702 3520 04	epp2 	-1086,ic		000070 = 524000000022
002167  aa  6 00266 2521 00	spri2	pr6|182
002170  aa  6 00256 6211 00	eax1 	pr6|174
002171  aa   010000 4310 07	fld  	4096,dl
002172  aa  6 00044 3701 20	epp4 	pr6|36,*
002173  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
002174  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 681
               return;

002175  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 682
          end;

						STATEMENT 1 ON LINE 684
          if qn = 0 then goto transfer_arg_a;

002176  aa  6 00241 2361 00	ldq  	pr6|161		qn
002177  aa   776753 6000 04	tze  	-533,ic		001152
						STATEMENT 1 ON LINE 686
          fsoct = string (rpr -> rfc_array (qn).foreign_socket);

002200  aa   000002 7360 00	qls  	2
002201  aa  6 00124 3715 20	epp5 	pr6|84,*		rpr
002202  aa   000000 6260 06	eax6 	0,ql
002203  aa  5 77774 2351 06	lda  	pr5|-4,ql
002204  aa  5 77775 2361 06	ldq  	pr5|-3,ql
002205  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
002206  aa  6 00222 7571 00	staq 	pr6|146		fsoct
						STATEMENT 1 ON LINE 687
          linkt = rpr -> rfc_array (qn).foreign_hosts_choice;

002207  aa  5 77776 2351 16	lda  	pr5|-2,6		rfc_array.foreign_hosts_choice
002210  aa   000066 7330 00	lrs  	54
002211  aa  6 00227 7561 00	stq  	pr6|151		linkt
						STATEMENT 1 ON LINE 688
          goto next;

002212  aa   776652 7100 04	tra  	-598,ic		001064
						STATEMENT 1 ON LINE 698
operation (19):
          if substr (sccom.ssoc, 32, 1) = substr (sccom.rsoc, 32, 1) then goto transfer_arg_b;

002213  aa  6 00216 3715 20	epp5 	pr6|142,*		cpr
002214  aa  000 100 066 500	cmpb 	(pr),(pr),fill(0)
002215  aa  5 00001 70 0001	descb	pr5|1(35),1	sccom.ssoc
002216  aa  5 00001 03 0001	descb	pr5|1(3),1	sccom.rsoc
002217  aa   776741 6000 04	tze  	-543,ic		001160
						STATEMENT 1 ON LINE 700
          j = binary (curp -> ctlb.a, 18);

002220  aa  6 00210 3535 20	epp3 	pr6|136,*		curp
002221  aa  3 00001 2351 00	lda  	pr3|1		ctlb.a
002222  aa   000066 7730 00	lrl  	54
002223  aa  6 00137 7561 00	stq  	pr6|95		j
						STATEMENT 1 ON LINE 701
          if binary (substr (sccom.ssoc, 32, 1), 1) = j-1
          then goto transfer_arg_b;

002224  aa   000001 1760 07	sbq  	1,dl
002225  aa  6 00300 7561 00	stq  	pr6|192
002226  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002227  aa  5 00001 70 0001	descb	pr5|1(35),1	sccom.ssoc
002230  aa  6 00056 00 0044	descb	pr6|46,36
002231  aa  6 00056 2351 00	lda  	pr6|46
002232  aa   000107 7730 00	lrl  	71
002233  aa  6 00300 1161 00	cmpq 	pr6|192
002234  aa   776724 6000 04	tze  	-556,ic		001160
						STATEMENT 1 ON LINE 704
          if j ^= 3
          then do;

002235  aa  6 00137 2361 00	ldq  	pr6|95		j
002236  aa   000003 1160 07	cmpq 	3,dl
002237  aa   000005 6000 04	tze  	5,ic		002244
						STATEMENT 1 ON LINE 706
               if sccom.link = ""b
               then goto transfer_arg_b;

002240  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
002241  aa  5 00002 00 0010	descb	pr5|2,8		sccom.link
002242  aa   000000 00 0000	descb	0,0
002243  aa   776715 6000 04	tze  	-563,ic		001160
						STATEMENT 1 ON LINE 708
               end;

						STATEMENT 1 ON LINE 710
          fsoct1 = bit (binary (hpr -> host_array (host_tb_index).host_number, 32), 32) || sccom.rsoc;

002244  aa  6 00226 2361 00	ldq  	pr6|150		host_tb_index
002245  aa   000012 4020 07	mpy  	10,dl
002246  aa  6 00114 3515 20	epp1 	pr6|76,*		hpr
002247  aa  1 77776 2351 06	lda  	pr1|-2,ql		host_array.host_number
002250  aa   000002 6050 04	tpl  	2,ic		002252
002251  aa   000000 5310 00	neg  	0
002252  aa   000004 7350 00	als  	4
002253  aa  6 00300 7551 00	sta  	pr6|192
002254  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002255  aa  5 00000 10 0040	descb	pr5|0(8),32	sccom.rsoc
002256  aa  6 00056 00 0044	descb	pr6|46,36
002257  aa  6 00056 2351 00	lda  	pr6|46
002260  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
002261  aa   000040 7730 00	lrl  	32
002262  aa  6 00300 2751 00	ora  	pr6|192
002263  aa  6 00224 7571 00	staq 	pr6|148		fsoct1
						STATEMENT 1 ON LINE 711
          lsoct = bit (binary (npr -> ncp_dt.host_id, 32), 32) || sccom.ssoc;

002264  aa  6 00120 3735 20	epp7 	pr6|80,*		npr
002265  aa  7 00050 2351 00	lda  	pr7|40		ncp_dt.host_id
002266  aa   000002 6050 04	tpl  	2,ic		002270
002267  aa   000000 5310 00	neg  	0
002270  aa   000004 7350 00	als  	4
002271  aa  6 00300 7551 00	sta  	pr6|192
002272  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002273  aa  5 00001 04 0040	descb	pr5|1(4),32	sccom.ssoc
002274  aa  6 00056 00 0044	descb	pr6|46,36
002275  aa  6 00056 2351 00	lda  	pr6|46
002276  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
002277  aa   000040 7730 00	lrl  	32
002300  aa  6 00300 2751 00	ora  	pr6|192
002301  aa  6 00230 7571 00	staq 	pr6|152		lsoct
						STATEMENT 1 ON LINE 712
          if j /* <RSC> */ > 2
          then goto next;

002302  aa  6 00137 2361 00	ldq  	pr6|95		j
002303  aa   000002 1160 07	cmpq 	2,dl
002304  aa   776560 6054 04	tpnz 	-656,ic		001064
						STATEMENT 1 ON LINE 714
          else if j = 2
               then do;

002305  aa   000007 6010 04	tnz  	7,ic		002314
						STATEMENT 1 ON LINE 716
                    bytet = sccom.link;

002306  aa  6 00212 4501 00	stz  	pr6|138		bytet
002307  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002310  aa  5 00002 00 0010	descb	pr5|2,8		sccom.link
002311  aa  6 00212 00 0010	descb	pr6|138,8		bytet
						STATEMENT 1 ON LINE 717
                    linkt = 0;

002312  aa  6 00227 4501 00	stz  	pr6|151		linkt
						STATEMENT 1 ON LINE 718
                    end;

002313  aa   776551 7100 04	tra  	-663,ic		001064
						STATEMENT 1 ON LINE 719
               else do;

						STATEMENT 1 ON LINE 720
                    linkt = binary (sccom.link, 8);

002314  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
002315  aa  5 00002 00 0010	descb	pr5|2,8		sccom.link
002316  aa  6 00056 00 0044	descb	pr6|46,36
002317  aa  6 00056 2351 00	lda  	pr6|46
002320  aa   000100 7730 00	lrl  	64
002321  aa  6 00227 7561 00	stq  	pr6|151		linkt
						STATEMENT 1 ON LINE 721
                    bytet = ""b;

002322  aa  6 00212 4501 00	stz  	pr6|138		bytet
						STATEMENT 1 ON LINE 722
                    end;

						STATEMENT 1 ON LINE 723
          goto next;

002323  aa   776541 7100 04	tra  	-671,ic		001064
						STATEMENT 1 ON LINE 733
operation (22):
          if ctlb.a = ""b then fsoct = gpr -> gdt.fsoc;

002324  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
002325  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
002326  aa   777777 3150 03	cana 	262143,du
002327  aa   000006 6010 04	tnz  	6,ic		002335
002330  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
002331  aa  3 00012 2351 00	lda  	pr3|10		gdt.fsoc
002332  aa  3 00013 2361 00	ldq  	pr3|11		gdt.fsoc
002333  aa  0 00200 3771 00	anaq 	pr0|128		= 777777777777 777777777400
002334  aa  6 00222 7571 00	staq 	pr6|146		fsoct
						STATEMENT 1 ON LINE 735
          if substr (fsoct, 64, 1) = substr (sep -> socket.local_socket.socket_num, 32, 1) then goto transfer_arg_c;

002335  aa  6 00126 3535 20	epp3 	pr6|86,*		sep
002336  aa  3 00012 2351 00	lda  	pr3|10		socket.socket_num
002337  aa   000033 7350 00	als  	27
002340  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002341  aa  6 00300 7551 00	sta  	pr6|192		socket.socket_num
002342  aa  6 00223 2351 00	lda  	pr6|147		fsoct
002343  aa   000033 7350 00	als  	27
002344  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002345  aa  6 00300 1151 00	cmpa 	pr6|192		socket.socket_num
002346  aa   776620 6000 04	tze  	-624,ic		001166
						STATEMENT 1 ON LINE 737
          host_code = binary (substr (fsoct, 1, 32), 32);

002347  aa  6 00222 2351 00	lda  	pr6|146		fsoct
002350  aa   000050 7730 00	lrl  	40
002351  aa  6 00101 7561 00	stq  	pr6|65		host_code
						STATEMENT 1 ON LINE 739
          call ncp_util_$find_host_entry (host_code, "0"b, host_ptr, icode);

002352  aa   000000 2350 07	lda  	0,dl
002353  aa  6 00300 7551 00	sta  	pr6|192
002354  aa  6 00101 3521 00	epp2 	pr6|65		host_code
002355  aa  6 00306 2521 00	spri2	pr6|198
002356  aa  6 00300 3521 00	epp2 	pr6|192
002357  aa  6 00310 2521 00	spri2	pr6|200
002360  aa  6 00110 3521 00	epp2 	pr6|72		host_ptr
002361  aa  6 00312 2521 00	spri2	pr6|202
002362  aa  6 00103 3521 00	epp2 	pr6|67		icode
002363  aa  6 00314 2521 00	spri2	pr6|204
002364  aa  6 00304 6211 00	eax1 	pr6|196
002365  aa   020000 4310 07	fld  	8192,dl
002366  aa  6 00044 3701 20	epp4 	pr6|36,*
002367  la  4 00102 3521 20	epp2 	pr4|66,*		ncp_util_$find_host_entry
002370  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 740
          if icode ^= 0
          then goto transfer_arg_b;

002371  aa  6 00103 2361 00	ldq  	pr6|67		icode
002372  aa   776566 6010 04	tnz  	-650,ic		001160
						STATEMENT 1 ON LINE 743
          host_tb_index = host_ptr -> host.hash_index;

002373  aa  6 00110 3735 20	epp7 	pr6|72,*		host_ptr
002374  aa  7 00007 2351 00	lda  	pr7|7		host.hash_index
002375  aa   000022 7350 00	als  	18
002376  aa   000066 7330 00	lrs  	54
002377  aa  6 00226 7561 00	stq  	pr6|150		host_tb_index
						STATEMENT 1 ON LINE 745
          sep -> socket.host_entry_index = host_tb_index;

002400  aa   000066 7370 00	lls  	54
002401  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002402  aa  5 00016 5511 60	stba 	pr5|14,60		socket.host_entry_index
						STATEMENT 1 ON LINE 746
          string (sep -> socket.foreign_socket) = fsoct;

002403  aa  6 00222 2371 00	ldaq 	pr6|146		fsoct
002404  aa  5 00013 7551 00	sta  	pr5|11
002405  aa  5 00014 7561 00	stq  	pr5|12
						STATEMENT 1 ON LINE 747
          goto next;

002406  aa   776456 7100 04	tra  	-722,ic		001064
						STATEMENT 1 ON LINE 755
operation (38):
          i = 2;

002407  aa   000002 2360 07	ldq  	2,dl
002410  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 758
state_common:
          j = binary (curp -> ctlb.a, 18);

002411  aa  6 00210 3735 20	epp7 	pr6|136,*		curp
002412  aa  7 00001 2351 00	lda  	pr7|1		ctlb.a
002413  aa   000066 7730 00	lrl  	54
002414  aa  6 00137 7561 00	stq  	pr6|95		j
						STATEMENT 1 ON LINE 761
          call ncp_access_$change_socket_state (sep, binary (j, 6), (0));

002415  aa  6 00300 7561 00	stq  	pr6|192
002416  aa  6 00245 4501 00	stz  	pr6|165
002417  aa  6 00126 3521 00	epp2 	pr6|86		sep
002420  aa  6 00250 2521 00	spri2	pr6|168
002421  aa  6 00300 3521 00	epp2 	pr6|192
002422  aa  6 00252 2521 00	spri2	pr6|170
002423  aa  6 00245 3521 00	epp2 	pr6|165
002424  aa  6 00254 2521 00	spri2	pr6|172
002425  aa  6 00246 6211 00	eax1 	pr6|166
002426  aa   014000 4310 07	fld  	6144,dl
002427  aa  6 00044 3701 20	epp4 	pr6|36,*
002430  la  4 00060 3521 20	epp2 	pr4|48,*		ncp_access_$change_socket_state
002431  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 762
          if i ^= 1
          then gpr -> gdt.state = binary (sep -> socket.state);

002432  aa  6 00136 2361 00	ldq  	pr6|94		i
002433  aa   000001 1160 07	cmpq 	1,dl
002434  aa   000006 6000 04	tze  	6,ic		002442
002435  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
002436  aa  7 00017 2351 00	lda  	pr7|15		socket.state
002437  aa   000102 7730 00	lrl  	66
002440  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
002441  aa  5 00004 7561 00	stq  	pr5|4		gdt.state
						STATEMENT 1 ON LINE 764
          if i = 2 then goto unlock_return1;

002442  aa  6 00136 2361 00	ldq  	pr6|94		i
002443  aa   000002 1160 07	cmpq 	2,dl
002444  aa   776700 6000 04	tze  	-576,ic		001344
						STATEMENT 1 ON LINE 765
          goto next;

002445  aa   776417 7100 04	tra  	-753,ic		001064
						STATEMENT 1 ON LINE 774
operation (39):
          call ncp_access_$unassign_link (sep, gpr -> gdt.error_code);

002446  aa  6 00126 3521 00	epp2 	pr6|86		sep
002447  aa  6 00250 2521 00	spri2	pr6|168
002450  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
002451  aa  5 00001 3521 00	epp2 	pr5|1		gdt.error_code
002452  aa  6 00252 2521 00	spri2	pr6|170
002453  aa  6 00246 6211 00	eax1 	pr6|166
002454  aa   010000 4310 07	fld  	4096,dl
002455  aa  6 00044 3701 20	epp4 	pr6|36,*
002456  la  4 00066 3521 20	epp2 	pr4|54,*		ncp_access_$unassign_link
002457  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 776
          if gpr -> gdt.error_code ^= 0
          then call ncp_error_ (gpr -> gdt.error_code, "TBOP_unassigning_link");

002460  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
002461  aa  7 00001 2361 00	ldq  	pr7|1		gdt.error_code
002462  aa   776402 6000 04	tze  	-766,ic		001064
002463  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002464  aa   775504 00 0030	desc9a	-1212,24		000167 = 124102117120
002465  aa  6 00246 00 0030	desc9a	pr6|166,24
002466  aa  7 00001 3521 00	epp2 	pr7|1		gdt.error_code
002467  aa  6 00260 2521 00	spri2	pr6|176
002470  aa  6 00246 3521 00	epp2 	pr6|166
002471  aa  6 00262 2521 00	spri2	pr6|178
002472  aa   775412 3520 04	epp2 	-1270,ic		000104 = 404000000043
002473  aa  6 00264 2521 00	spri2	pr6|180
002474  aa   775373 3520 04	epp2 	-1285,ic		000067 = 524000000025
002475  aa  6 00266 2521 00	spri2	pr6|182
002476  aa  6 00256 6211 00	eax1 	pr6|174
002477  aa   010000 4310 07	fld  	4096,dl
002500  aa  6 00044 3701 20	epp4 	pr6|36,*
002501  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
002502  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 779
          goto next;

002503  aa   776361 7100 04	tra  	-783,ic		001064
						STATEMENT 1 ON LINE 792
operation (1):
          if sep -> socket.send_gender = WRITE_GENDER then if linkt = 0
          then goto transfer_arg_a;

002504  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002505  aa  5 00017 2351 00	lda  	pr5|15		socket.send_gender
002506  aa   000016 7350 00	als  	14
002507  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002510  aa   400000 1150 03	cmpa 	131072,du
002511  aa   000003 6010 04	tnz  	3,ic		002514
002512  aa  6 00227 2361 00	ldq  	pr6|151		linkt
002513  aa   776437 6000 04	tze  	-737,ic		001152
						STATEMENT 1 ON LINE 795
          i = 1;

002514  aa   000001 2360 07	ldq  	1,dl
002515  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 797
atq_restart:
          do i = i to npr -> ncp_dt.rtbl_gent;

002516  aa  6 00120 3735 20	epp7 	pr6|80,*		npr
002517  aa  7 00011 2361 00	ldq  	pr7|9		ncp_dt.rtbl_gent
002520  aa  6 00244 7561 00	stq  	pr6|164
002521  aa  6 00136 2361 00	ldq  	pr6|94		i
002522  aa  6 00136 7561 00	stq  	pr6|94		i
002523  aa   000000 0110 03	nop  	0,du
002524  aa  6 00136 2361 00	ldq  	pr6|94		i
002525  aa  6 00244 1161 00	cmpq 	pr6|164
002526  aa   000013 6054 04	tpnz 	11,ic		002541
						STATEMENT 1 ON LINE 799
               if stacq (addr (rpr -> rfc_array (i).foreign_hosts_choice) -> based_lock, "1"b, (36)"0"b)
               then goto atq_got_block;

002527  aa   000002 7360 00	qls  	2
002530  aa   400000 2350 03	lda  	131072,du
002531  aa  6 00124 3735 20	epp7 	pr6|84,*		rpr
002532  aa  7 77776 3521 06	epp2 	pr7|-2,ql		based_lock
002533  aa  6 00245 7561 00	stq  	pr6|165
002534  aa   000000 2360 07	ldq  	0,dl
002535  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
002536  aa   000014 6010 04	tnz  	12,ic		002552
						STATEMENT 1 ON LINE 801
               end;

002537  aa  6 00136 0541 00	aos  	pr6|94		i
002540  aa   777764 7100 04	tra  	-12,ic		002524
						STATEMENT 1 ON LINE 804
          if npr -> ncp_dt.rtbl_gent = npr -> ncp_dt.rtbl_size then do;

002541  aa  6 00120 3735 20	epp7 	pr6|80,*		npr
002542  aa  7 00011 2361 00	ldq  	pr7|9		ncp_dt.rtbl_gent
002543  aa  7 00005 1161 00	cmpq 	pr7|5		ncp_dt.rtbl_size
002544  aa   000002 6010 04	tnz  	2,ic		002546
						STATEMENT 1 ON LINE 805
               goto transfer_arg_a;

002545  aa   776405 7100 04	tra  	-763,ic		001152
						STATEMENT 1 ON LINE 806
          end;

						STATEMENT 1 ON LINE 807
          npr -> ncp_dt.rtbl_gent = npr -> ncp_dt.rtbl_gent + 1;

002546  aa  7 00011 0541 00	aos  	pr7|9		ncp_dt.rtbl_gent
						STATEMENT 1 ON LINE 808
          i = npr -> ncp_dt.rtbl_gent;

002547  aa  7 00011 2361 00	ldq  	pr7|9		ncp_dt.rtbl_gent
002550  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 810
          goto atq_restart;

002551  aa   777745 7100 04	tra  	-27,ic		002516
						STATEMENT 1 ON LINE 812
atq_got_block:
          string (rpr -> rfc_array (i).foreign_socket) = fsoct1;

002552  aa  6 00224 2371 00	ldaq 	pr6|148		fsoct1
002553  aa  6 00245 7271 00	lxl7 	pr6|165
002554  aa  7 77774 7551 17	sta  	pr7|-4,7
002555  aa  7 77775 7561 17	stq  	pr7|-3,7
						STATEMENT 1 ON LINE 814
          if sep -> socket.send_gender = WRITE_GENDER
          then rpr -> rfc_array (i).foreign_hosts_choice = linkt;

002556  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002557  aa  5 00017 2351 00	lda  	pr5|15		socket.send_gender
002560  aa   000016 7350 00	als  	14
002561  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002562  aa   400000 1150 03	cmpa 	131072,du
002563  aa   000006 6010 04	tnz  	6,ic		002571
002564  aa  6 00227 2361 00	ldq  	pr6|151		linkt
002565  aa   000066 7370 00	lls  	54
002566  aa  7 77776 3535 17	epp3 	pr7|-2,7		rfc_array.foreign_hosts_choice
002567  aa  3 00000 5511 60	stba 	pr3|0,60		rfc_array.foreign_hosts_choice
002570  aa   000004 7100 04	tra  	4,ic		002574
						STATEMENT 1 ON LINE 816
          else rpr -> rfc_array (i).foreign_hosts_choice = -1;

002571  aa   777777 2350 03	lda  	262143,du
002572  aa  7 77776 3535 17	epp3 	pr7|-2,7		rfc_array.foreign_hosts_choice
002573  aa  3 00000 5511 60	stba 	pr3|0,60		rfc_array.foreign_hosts_choice
						STATEMENT 1 ON LINE 818
atq_put_in_soct:
          if qn = 0 then do;

002574  aa  6 00241 2361 00	ldq  	pr6|161		qn
002575  aa   000020 6010 04	tnz  	16,ic		002615
						STATEMENT 1 ON LINE 820
               if pqn = -1
               then sep -> socket.rfc_queue = i;

002576  aa  6 00242 2361 00	ldq  	pr6|162		pqn
002577  aa   000671 1160 04	cmpq 	441,ic		003470 = 777777777777
002600  aa   000006 6010 04	tnz  	6,ic		002606
002601  aa  6 00136 2361 00	ldq  	pr6|94		i
002602  aa   000066 7370 00	lls  	54
002603  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
002604  aa  7 00015 5511 60	stba 	pr7|13,60		socket.rfc_queue
002605  aa   776257 7100 04	tra  	-849,ic		001064
						STATEMENT 1 ON LINE 822
               else rpr -> rfc_array (pqn).next_entry = i;

002606  aa   000002 7360 00	qls  	2
002607  aa   000000 6270 06	eax7 	0,ql
002610  aa  6 00136 2361 00	ldq  	pr6|94		i
002611  aa  6 00124 3735 20	epp7 	pr6|84,*		rpr
002612  aa  7 77776 3715 17	epp5 	pr7|-2,7		rfc_array.next_entry
002613  aa  5 00000 5521 14	stbq 	pr5|0,14		rfc_array.next_entry
						STATEMENT 1 ON LINE 823
          end;

002614  aa   776250 7100 04	tra  	-856,ic		001064
						STATEMENT 1 ON LINE 824
          else do;

						STATEMENT 1 ON LINE 825
               ppqn = pqn;

002615  aa  6 00242 2361 00	ldq  	pr6|162		pqn
002616  aa  6 00243 7561 00	stq  	pr6|163		ppqn
						STATEMENT 1 ON LINE 826
               pqn = qn;

002617  aa  6 00241 2361 00	ldq  	pr6|161		qn
002620  aa  6 00242 7561 00	stq  	pr6|162		pqn
						STATEMENT 1 ON LINE 827
               if pqn = -1
               then qn = sep -> socket.rfc_queue;

002621  aa   000647 1160 04	cmpq 	423,ic		003470 = 777777777777
002622  aa   000006 6010 04	tnz  	6,ic		002630
002623  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
002624  aa  7 00015 2351 00	lda  	pr7|13		socket.rfc_queue
002625  aa   000066 7330 00	lrs  	54
002626  aa  6 00241 7561 00	stq  	pr6|161		qn
002627  aa   777745 7100 04	tra  	-27,ic		002574
						STATEMENT 1 ON LINE 829
               else qn = rpr -> rfc_array (pqn).next_entry;

002630  aa   000002 7360 00	qls  	2
002631  aa  6 00124 3735 20	epp7 	pr6|84,*		rpr
002632  aa  7 77776 2351 06	lda  	pr7|-2,ql		rfc_array.next_entry
002633  aa   000022 7350 00	als  	18
002634  aa   000066 7330 00	lrs  	54
002635  aa  6 00241 7561 00	stq  	pr6|161		qn
						STATEMENT 1 ON LINE 830
               goto atq_put_in_soct;

002636  aa   777736 7100 04	tra  	-34,ic		002574
						STATEMENT 1 ON LINE 831
          end;

						STATEMENT 1 ON LINE 832
          goto next;

002637  aa   776225 7100 04	tra  	-875,ic		001064
						STATEMENT 1 ON LINE 839
operation (2):
          call ncp_connection_$allocate_read (sep, gpr -> gdt.error_code);

002640  aa  6 00126 3521 00	epp2 	pr6|86		sep
002641  aa  6 00250 2521 00	spri2	pr6|168
002642  aa  6 00112 3715 20	epp5 	pr6|74,*		gpr
002643  aa  5 00001 3521 00	epp2 	pr5|1		gdt.error_code
002644  aa  6 00252 2521 00	spri2	pr6|170
002645  aa  6 00246 6211 00	eax1 	pr6|166
002646  aa   010000 4310 07	fld  	4096,dl
002647  aa  6 00044 3701 20	epp4 	pr6|36,*
002650  la  4 00070 3521 20	epp2 	pr4|56,*		ncp_connection_$allocate_read
002651  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 841
          if gpr -> gdt.error_code ^= 0
          then do;

002652  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
002653  aa  7 00001 2361 00	ldq  	pr7|1		gdt.error_code
002654  aa   776210 6000 04	tze  	-888,ic		001064
						STATEMENT 1 ON LINE 843
               call ncp_error_ (gpr -> gdt.error_code, "TBOP_allocating_for_read");

002655  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002656  aa   775304 00 0030	desc9a	-1340,24		000161 = 124102117120
002657  aa  6 00246 00 0030	desc9a	pr6|166,24
002660  aa  7 00001 3521 00	epp2 	pr7|1		gdt.error_code
002661  aa  6 00306 2521 00	spri2	pr6|198
002662  aa  6 00246 3521 00	epp2 	pr6|166
002663  aa  6 00310 2521 00	spri2	pr6|200
002664  aa   775220 3520 04	epp2 	-1392,ic		000104 = 404000000043
002665  aa  6 00312 2521 00	spri2	pr6|202
002666  aa   775200 3520 04	epp2 	-1408,ic		000066 = 524000000030
002667  aa  6 00314 2521 00	spri2	pr6|204
002670  aa  6 00304 6211 00	eax1 	pr6|196
002671  aa   010000 4310 07	fld  	4096,dl
002672  aa  6 00044 3701 20	epp4 	pr6|36,*
002673  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
002674  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 844
               return;

002675  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 845
               end;

						STATEMENT 1 ON LINE 847
          goto next;

002676  aa   776166 7100 04	tra  	-906,ic		001064
						STATEMENT 1 ON LINE 855
operation (7):
          if sep -> socket.send_gender = WRITE_GENDER
          then call imp_write_order ((sep -> socket.impdim_index), IMP_ORDER_get_status, null (), status, icode);

002677  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
002700  aa  5 00017 2351 00	lda  	pr5|15		socket.send_gender
002701  aa   000016 7350 00	als  	14
002702  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002703  aa   400000 1150 03	cmpa 	131072,du
002704  aa   000027 6010 04	tnz  	23,ic		002733
002705  aa  5 00016 2351 00	lda  	pr5|14		socket.impdim_index
002706  aa   000022 7350 00	als  	18
002707  aa   000066 7330 00	lrs  	54
002710  aa  6 00300 7561 00	stq  	pr6|192
002711  aa   775207 3534 24	epp3 	-1401,ic*
002712  aa  6 00362 2535 00	spri3	pr6|242
002713  aa  6 00300 3521 00	epp2 	pr6|192
002714  aa  6 00260 2521 00	spri2	pr6|176
002715  aa   775174 3520 04	epp2 	-1412,ic		000111 = 000000000004
002716  aa  6 00262 2521 00	spri2	pr6|178
002717  aa  6 00362 3521 00	epp2 	pr6|242
002720  aa  6 00264 2521 00	spri2	pr6|180
002721  aa  6 00240 3521 00	epp2 	pr6|160		status
002722  aa  6 00266 2521 00	spri2	pr6|182
002723  aa  6 00103 3521 00	epp2 	pr6|67		icode
002724  aa  6 00270 2521 00	spri2	pr6|184
002725  aa  6 00256 6211 00	eax1 	pr6|174
002726  aa   024000 4310 07	fld  	10240,dl
002727  aa  6 00044 3701 20	epp4 	pr6|36,*
002730  la  4 00054 3521 20	epp2 	pr4|44,*		imp_write_order
002731  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002732  aa   000026 7100 04	tra  	22,ic		002760
						STATEMENT 1 ON LINE 858
          else call imp_read_order ((sep -> socket.impdim_index), IMP_ORDER_get_status, null (), status, icode);

002733  aa  5 00016 2351 00	lda  	pr5|14		socket.impdim_index
002734  aa   000022 7350 00	als  	18
002735  aa   000066 7330 00	lrs  	54
002736  aa  6 00300 7561 00	stq  	pr6|192
002737  aa   775161 3534 24	epp3 	-1423,ic*
002740  aa  6 00362 2535 00	spri3	pr6|242
002741  aa  6 00300 3521 00	epp2 	pr6|192
002742  aa  6 00306 2521 00	spri2	pr6|198
002743  aa   775146 3520 04	epp2 	-1434,ic		000111 = 000000000004
002744  aa  6 00310 2521 00	spri2	pr6|200
002745  aa  6 00362 3521 00	epp2 	pr6|242
002746  aa  6 00312 2521 00	spri2	pr6|202
002747  aa  6 00240 3521 00	epp2 	pr6|160		status
002750  aa  6 00314 2521 00	spri2	pr6|204
002751  aa  6 00103 3521 00	epp2 	pr6|67		icode
002752  aa  6 00316 2521 00	spri2	pr6|206
002753  aa  6 00304 6211 00	eax1 	pr6|196
002754  aa   024000 4310 07	fld  	10240,dl
002755  aa  6 00044 3701 20	epp4 	pr6|36,*
002756  la  4 00052 3521 20	epp2 	pr4|42,*		imp_read_order
002757  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 859
          if ^substr (status, 12, 1) then if ^substr (status, 17, 1) then goto transfer_arg_a;

002760  aa  6 00240 2351 00	lda  	pr6|160		status
002761  aa   000100 3150 03	cana 	64,du
002762  aa   776102 6010 04	tnz  	-958,ic		001064
002763  aa  6 00240 2351 00	lda  	pr6|160		status
002764  aa   000002 3150 03	cana 	2,du
002765  aa   776165 6000 04	tze  	-907,ic		001152
						STATEMENT 1 ON LINE 860
          goto next;

002766  aa   776076 7100 04	tra  	-962,ic		001064
						STATEMENT 1 ON LINE 868
operation (12):
          i = rpr -> rfc_array (qn).next_entry;

002767  aa  6 00241 2361 00	ldq  	pr6|161		qn
002770  aa   000002 7360 00	qls  	2
002771  aa  6 00124 3715 20	epp5 	pr6|84,*		rpr
002772  aa  5 77776 2351 06	lda  	pr5|-2,ql		rfc_array.next_entry
002773  aa   000022 7350 00	als  	18
002774  aa   000000 6260 06	eax6 	0,ql
002775  aa   000066 7330 00	lrs  	54
002776  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 870
          string (rpr -> rfc_array (qn).foreign_socket) = ""b;

002777  aa   775123 2370 04	ldaq 	-1453,ic		000122 = 000000000000 000000000000
003000  aa  5 77774 7551 16	sta  	pr5|-4,6
003001  aa  5 77775 7561 16	stq  	pr5|-3,6
						STATEMENT 1 ON LINE 871
          rpr -> rfc_array (qn).next_entry = 0;

003002  aa   000000 2350 03	lda  	0,du
003003  aa  5 77776 3535 16	epp3 	pr5|-2,6		rfc_array.next_entry
003004  aa  3 00000 5511 14	stba 	pr3|0,14		rfc_array.next_entry
						STATEMENT 1 ON LINE 872
          tpr = addr(rpr -> rfc_array (qn).foreign_hosts_choice);

003005  aa  5 77776 3535 16	epp3 	pr5|-2,6		rfc_array.foreign_hosts_choice
003006  aa  6 00150 2535 00	spri3	pr6|104		tpr
						STATEMENT 1 ON LINE 873
          success = stacq (tpr -> based_lock, (36)"0"b, tpr -> based_lock);

003007  aa   000000 2350 07	lda  	0,dl
003010  aa  3 00000 3521 00	epp2 	pr3|0		based_lock
003011  aa  2 00000 2361 00	ldq  	pr2|0		based_lock
003012  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
003013  aa  6 00147 7551 00	sta  	pr6|103		success
						STATEMENT 1 ON LINE 875
          qn = pqn;

003014  aa  6 00242 2361 00	ldq  	pr6|162		pqn
003015  aa  6 00241 7561 00	stq  	pr6|161		qn
						STATEMENT 1 ON LINE 876
          if pqn = -1 then do;

003016  aa   000452 1160 04	cmpq 	298,ic		003470 = 777777777777
003017  aa   000006 6010 04	tnz  	6,ic		003025
						STATEMENT 1 ON LINE 877
               sep -> socket.rfc_queue = i;

003020  aa  6 00136 2361 00	ldq  	pr6|94		i
003021  aa   000066 7370 00	lls  	54
003022  aa  6 00126 3515 20	epp1 	pr6|86,*		sep
003023  aa  1 00015 5511 60	stba 	pr1|13,60		socket.rfc_queue
						STATEMENT 1 ON LINE 878
               goto next;

003024  aa   776040 7100 04	tra  	-992,ic		001064
						STATEMENT 1 ON LINE 879
          end;

						STATEMENT 1 ON LINE 880
          else rpr -> rfc_array (pqn).next_entry = i;

003025  aa   000002 7360 00	qls  	2
003026  aa   000000 6250 06	eax5 	0,ql
003027  aa  6 00136 2361 00	ldq  	pr6|94		i
003030  aa  5 77776 3515 15	epp1 	pr5|-2,5		rfc_array.next_entry
003031  aa  1 00000 5521 14	stbq 	pr1|0,14		rfc_array.next_entry
						STATEMENT 1 ON LINE 882
          pqn = ppqn;

003032  aa  6 00243 2361 00	ldq  	pr6|163		ppqn
003033  aa  6 00242 7561 00	stq  	pr6|162		pqn
						STATEMENT 1 ON LINE 883
          ppqn = 262143;

003034  aa   777777 2360 07	ldq  	262143,dl
003035  aa  6 00243 7561 00	stq  	pr6|163		ppqn
						STATEMENT 1 ON LINE 884
          queue_level = queue_level - 1;

003036  aa   000001 3360 07	lcq  	1,dl
003037  aa  6 00235 0561 00	asq  	pr6|157		queue_level
						STATEMENT 1 ON LINE 885
          goto next;

003040  aa   776024 7100 04	tra  	-1004,ic		001064
						STATEMENT 1 ON LINE 891
operation (13):
          i = binary (curp -> ctlb.a, 18);

003041  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
003042  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
003043  aa   000066 7730 00	lrl  	54
003044  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 893
          if i = 1 then gpr -> gdt.error_code = error_table_$net_invalid_state;

003045  aa   000001 1160 07	cmpq 	1,dl
003046  aa   000006 6010 04	tnz  	6,ic		003054
003047  aa  6 00044 3701 20	epp4 	pr6|36,*
003050  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$net_invalid_state
003051  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003052  aa  3 00001 7561 00	stq  	pr3|1		gdt.error_code
003053  aa   776011 7100 04	tra  	-1015,ic		001064
						STATEMENT 1 ON LINE 895
          else if i = 3 then gpr -> gdt.error_code = error_table_$net_fhost_inactive;

003054  aa   000003 1160 07	cmpq 	3,dl
003055  aa   000006 6010 04	tnz  	6,ic		003063
003056  aa  6 00044 3701 20	epp4 	pr6|36,*
003057  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$net_fhost_inactive
003060  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003061  aa  3 00001 7561 00	stq  	pr3|1		gdt.error_code
003062  aa   776002 7100 04	tra  	-1022,ic		001064
						STATEMENT 1 ON LINE 896
          else if i = 4 then gpr -> gdt.error_code = error_table_$net_bad_gender;

003063  aa   000004 1160 07	cmpq 	4,dl
003064  aa   000006 6010 04	tnz  	6,ic		003072
003065  aa  6 00044 3701 20	epp4 	pr6|36,*
003066  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$net_bad_gender
003067  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003070  aa  3 00001 7561 00	stq  	pr3|1		gdt.error_code
003071  aa   775773 7100 04	tra  	-1029,ic		001064
						STATEMENT 1 ON LINE 897
          else if i = 5 then gpr -> gdt.error_code = error_table_$notalloc;

003072  aa   000005 1160 07	cmpq 	5,dl
003073  aa   000006 6010 04	tnz  	6,ic		003101
003074  aa  6 00044 3701 20	epp4 	pr6|36,*
003075  la  4 00044 2361 20	ldq  	pr4|36,*		error_table_$notalloc
003076  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003077  aa  3 00001 7561 00	stq  	pr3|1		gdt.error_code
003100  aa   775764 7100 04	tra  	-1036,ic		001064
						STATEMENT 1 ON LINE 898
          else do;

						STATEMENT 1 ON LINE 899
               call ncp_error_ (0, "TBOP_unknown_error_code_index");

003101  aa  6 00300 4501 00	stz  	pr6|192
003102  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003103  aa   775125 00 0040	desc9a	-1451,32		000227 = 124102117120
003104  aa  6 00246 00 0040	desc9a	pr6|166,32
003105  aa  6 00300 3521 00	epp2 	pr6|192
003106  aa  6 00260 2521 00	spri2	pr6|176
003107  aa  6 00246 3521 00	epp2 	pr6|166
003110  aa  6 00262 2521 00	spri2	pr6|178
003111  aa   774773 3520 04	epp2 	-1541,ic		000104 = 404000000043
003112  aa  6 00264 2521 00	spri2	pr6|180
003113  aa   774773 3520 04	epp2 	-1541,ic		000106 = 524000000035
003114  aa  6 00266 2521 00	spri2	pr6|182
003115  aa  6 00256 6211 00	eax1 	pr6|174
003116  aa   010000 4310 07	fld  	4096,dl
003117  aa  6 00044 3701 20	epp4 	pr6|36,*
003120  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
003121  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 900
               return;

003122  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 901
          end;

						STATEMENT 1 ON LINE 902
          goto next;

003123  aa   775741 7100 04	tra  	-1055,ic		001064
						STATEMENT 1 ON LINE 908
operation (20):
          goto transfer_arg_a;

003124  aa   776026 7100 04	tra  	-1002,ic		001152
						STATEMENT 1 ON LINE 916
operation (21):
          i = sep -> socket.impdim_index;

003125  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003126  aa  5 00016 2351 00	lda  	pr5|14		socket.impdim_index
003127  aa   000022 7350 00	als  	18
003130  aa   000066 7330 00	lrs  	54
003131  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 918
          if sep -> socket.send_gender = WRITE_GENDER
          then call imp_write_order ((i), IMP_ORDER_abort_transfer, null, status, gpr -> gdt.error_code);

003132  aa  5 00017 2351 00	lda  	pr5|15		socket.send_gender
003133  aa   000016 7350 00	als  	14
003134  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003135  aa   400000 1150 03	cmpa 	131072,du
003136  aa   775726 6010 04	tnz  	-1066,ic		001064
003137  aa  6 00136 2361 00	ldq  	pr6|94		i
003140  aa  6 00300 7561 00	stq  	pr6|192
003141  aa   774757 3534 24	epp3 	-1553,ic*
003142  aa  6 00362 2535 00	spri3	pr6|242
003143  aa  6 00300 3521 00	epp2 	pr6|192
003144  aa  6 00306 2521 00	spri2	pr6|198
003145  aa   774745 3520 04	epp2 	-1563,ic		000112 = 000000000001
003146  aa  6 00310 2521 00	spri2	pr6|200
003147  aa  6 00362 3521 00	epp2 	pr6|242
003150  aa  6 00312 2521 00	spri2	pr6|202
003151  aa  6 00240 3521 00	epp2 	pr6|160		status
003152  aa  6 00314 2521 00	spri2	pr6|204
003153  aa  6 00112 3515 20	epp1 	pr6|74,*		gpr
003154  aa  1 00001 3521 00	epp2 	pr1|1		gdt.error_code
003155  aa  6 00316 2521 00	spri2	pr6|206
003156  aa  6 00304 6211 00	eax1 	pr6|196
003157  aa   024000 4310 07	fld  	10240,dl
003160  aa  6 00044 3701 20	epp4 	pr6|36,*
003161  la  4 00054 3521 20	epp2 	pr4|44,*		imp_write_order
003162  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 921
          goto next;

003163  aa   775701 7100 04	tra  	-1087,ic		001064
						STATEMENT 1 ON LINE 928
operation (34):
          fsocr = fsoct;

003164  aa  6 00222 2371 00	ldaq 	pr6|146		fsoct
003165  aa  6 00220 7571 00	staq 	pr6|144		fsocr
						STATEMENT 1 ON LINE 930
          goto next;

003166  aa   775676 7100 04	tra  	-1090,ic		001064
						STATEMENT 1 ON LINE 941
operation (6):
          if bytet ^= sep -> socket.byte_size then goto transfer_arg_a;

003167  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003170  aa  5 00017 2351 00	lda  	pr5|15		socket.byte_size
003171  aa   000006 7350 00	als  	6
003172  aa  0 00020 3771 00	anaq 	pr0|16		= 776000000000 000000000000
003173  aa  6 00212 1151 00	cmpa 	pr6|138		bytet
003174  aa   775756 6010 04	tnz  	-1042,ic		001152
						STATEMENT 1 ON LINE 943
          goto next;

003175  aa   775667 7100 04	tra  	-1097,ic		001064
						STATEMENT 1 ON LINE 950
operation (10):
          if pcode = 0 then if procid ^= sep -> socket.overseer_process_id then do;

003176  aa  6 00234 2361 00	ldq  	pr6|156		pcode
003177  aa   000012 6010 04	tnz  	10,ic		003211
003200  aa  6 00104 2351 00	lda  	pr6|68		procid
003201  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003202  aa  5 00006 1151 00	cmpa 	pr5|6		socket.overseer_process_id
003203  aa   000006 6000 04	tze  	6,ic		003211
						STATEMENT 1 ON LINE 952
               gpr -> gdt.error_code = error_table_$bad_processid;

003204  aa  6 00044 3701 20	epp4 	pr6|36,*
003205  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$bad_processid
003206  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003207  aa  3 00001 7561 00	stq  	pr3|1		gdt.error_code
						STATEMENT 1 ON LINE 953
               goto next;

003210  aa   775654 7100 04	tra  	-1108,ic		001064
						STATEMENT 1 ON LINE 954
          end;

						STATEMENT 1 ON LINE 955
          call ncp_access_$deactivate_socket (sep, icode);

003211  aa  6 00126 3521 00	epp2 	pr6|86		sep
003212  aa  6 00250 2521 00	spri2	pr6|168
003213  aa  6 00103 3521 00	epp2 	pr6|67		icode
003214  aa  6 00252 2521 00	spri2	pr6|170
003215  aa  6 00246 6211 00	eax1 	pr6|166
003216  aa   010000 4310 07	fld  	4096,dl
003217  aa  6 00044 3701 20	epp4 	pr6|36,*
003220  la  4 00062 3521 20	epp2 	pr4|50,*		ncp_access_$deactivate_socket
003221  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 956
          gpr-> gdt.error_code = icode;

003222  aa  6 00103 2361 00	ldq  	pr6|67		icode
003223  aa  6 00112 3735 20	epp7 	pr6|74,*		gpr
003224  aa  7 00001 7561 00	stq  	pr7|1		gdt.error_code
						STATEMENT 1 ON LINE 957
          goto next;

003225  aa   775637 7100 04	tra  	-1121,ic		001064
						STATEMENT 1 ON LINE 964
operation (11):
          i = binary (lkcom.bfrac, 8);

003226  aa  6 00216 3715 20	epp5 	pr6|142,*		cpr
003227  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003230  aa  5 00000 46 0010	descb	pr5|0(24),8	lkcom.bfrac
003231  aa  6 00056 00 0044	descb	pr6|46,36
003232  aa  6 00056 2351 00	lda  	pr6|46
003233  aa   000100 7730 00	lrl  	64
003234  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 966
          if i > 127
          then bspace = sep -> socket.bit_allocation;

003235  aa   000177 1160 07	cmpq 	127,dl
003236  aa   000005 6044 04	tmoz 	5,ic		003243
003237  aa  6 00126 3535 20	epp3 	pr6|86,*		sep
003240  aa  3 00007 2361 00	ldq  	pr3|7		socket.bit_allocation
003241  aa  6 00236 7561 00	stq  	pr6|158		bspace
003242  aa   000007 7100 04	tra  	7,ic		003251
						STATEMENT 1 ON LINE 968
          else bspace = divide (sep -> socket.bit_allocation * i, 128, 35, 0);

003243  aa  6 00126 3535 20	epp3 	pr6|86,*		sep
003244  aa  3 00007 4021 00	mpy  	pr3|7		socket.bit_allocation
003245  aa   000222 3520 04	epp2 	146,ic		003467 = 000000000200
003246  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
003247  aa     000000000000
003250  aa  6 00236 7561 00	stq  	pr6|158		bspace
						STATEMENT 1 ON LINE 969
          sep -> socket.bit_allocation = sep -> socket.bit_allocation - bspace;

003251  aa  6 00236 3361 00	lcq  	pr6|158		bspace
003252  aa  3 00007 0561 00	asq  	pr3|7		socket.bit_allocation
						STATEMENT 1 ON LINE 971
          i = binary (lkcom.mfrac, 8);

003253  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
003254  aa  5 00000 27 0010	descb	pr5|0(16),8	lkcom.mfrac
003255  aa  6 00056 00 0044	descb	pr6|46,36
003256  aa  6 00056 2351 00	lda  	pr6|46
003257  aa   000100 7730 00	lrl  	64
003260  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 972
          if i > 127
          then mspace = sep -> socket.msg_allocation;

003261  aa   000177 1160 07	cmpq 	127,dl
003262  aa   000004 6044 04	tmoz 	4,ic		003266
003263  aa  3 00010 2361 00	ldq  	pr3|8		socket.msg_allocation
003264  aa  6 00237 7561 00	stq  	pr6|159		mspace
003265  aa   000004 7100 04	tra  	4,ic		003271
						STATEMENT 1 ON LINE 974
          else mspace = divide (sep -> socket.msg_allocation * i, 128, 35, 0);

003266  aa  3 00010 4021 00	mpy  	pr3|8		socket.msg_allocation
003267  aa   000200 5060 07	div  	128,dl
003270  aa  6 00237 7561 00	stq  	pr6|159		mspace
						STATEMENT 1 ON LINE 975
          sep -> socket.msg_allocation = sep -> socket.msg_allocation - mspace;

003271  aa  6 00237 3361 00	lcq  	pr6|159		mspace
003272  aa  3 00010 0561 00	asq  	pr3|8		socket.msg_allocation
						STATEMENT 1 ON LINE 976
          goto next;

003273  aa   775571 7100 04	tra  	-1159,ic		001064
						STATEMENT 1 ON LINE 983
operation (23):
          if sep -> socket.signal_event_channel ^= 0
          then do;

003274  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003275  aa  5 00024 2371 00	ldaq 	pr5|20		socket.signal_event_channel
003276  aa   000023 6000 04	tze  	19,ic		003321
						STATEMENT 1 ON LINE 986
               addr (event_msg) -> msg_chr8 = "NCP ";

003277  aa   774617 2370 04	ldaq 	-1649,ic		000116 = 116103120040 040040040040
003300  aa  6 00142 7571 00	staq 	pr6|98		msg_chr8
						STATEMENT 1 ON LINE 987
               substr (unspec (event_msg), 37, 36) = gpr -> gdt.ncp_idx;

003301  aa  6 00112 3535 20	epp3 	pr6|74,*		gpr
003302  aa  3 00003 2351 00	lda  	pr3|3		gdt.ncp_idx
003303  aa  6 00143 7551 00	sta  	pr6|99
						STATEMENT 1 ON LINE 988
               call pxss$wakeup_int (sep -> socket.process_id, sep -> socket.signal_event_channel, event_msg, icode);

003304  aa  5 00005 3521 00	epp2 	pr5|5		socket.process_id
003305  aa  6 00260 2521 00	spri2	pr6|176
003306  aa  5 00024 3521 00	epp2 	pr5|20		socket.signal_event_channel
003307  aa  6 00262 2521 00	spri2	pr6|178
003310  aa  6 00142 3521 00	epp2 	pr6|98		event_msg
003311  aa  6 00264 2521 00	spri2	pr6|180
003312  aa  6 00103 3521 00	epp2 	pr6|67		icode
003313  aa  6 00266 2521 00	spri2	pr6|182
003314  aa  6 00256 6211 00	eax1 	pr6|174
003315  aa   020000 4310 07	fld  	8192,dl
003316  aa  6 00044 3701 20	epp4 	pr6|36,*
003317  la  4 00116 3521 20	epp2 	pr4|78,*		pxss$wakeup_int
003320  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 989
               end;

						STATEMENT 1 ON LINE 991
          if sep -> socket.allow_interrupts
          then call pxss$ips_wakeup_int (sep -> socket.process_id, ncp_params_$interrupt_signal);

003321  aa  6 00126 3735 20	epp7 	pr6|86,*		sep
003322  aa  7 00017 2351 00	lda  	pr7|15		socket.allow_interrupts
003323  aa   000004 3150 03	cana 	4,du
003324  aa   775540 6000 04	tze  	-1184,ic		001064
003325  aa  7 00005 3521 00	epp2 	pr7|5		socket.process_id
003326  aa  6 00250 2521 00	spri2	pr6|168
003327  aa  6 00044 3701 20	epp4 	pr6|36,*
003330  la  4 00010 3521 20	epp2 	pr4|8,*		ncp_params_$interrupt_signal
003331  aa  6 00252 2521 00	spri2	pr6|170
003332  aa  6 00246 6211 00	eax1 	pr6|166
003333  aa   010000 4310 07	fld  	4096,dl
003334  la  4 00114 3521 20	epp2 	pr4|76,*		pxss$ips_wakeup_int
003335  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 993
          goto next;

003336  aa   775526 7100 04	tra  	-1194,ic		001064
						STATEMENT 1 ON LINE 999
operation (25):
          cv_bin_output = cv_bin_$dec (binary (curp -> ctlb.a, 18));

003337  aa  6 00210 3715 20	epp5 	pr6|136,*		curp
003340  aa  5 00001 2351 00	lda  	pr5|1		ctlb.a
003341  aa   000066 7730 00	lrl  	54
003342  aa  6 00300 7561 00	stq  	pr6|192
003343  aa  6 00300 3521 00	epp2 	pr6|192
003344  aa  6 00250 2521 00	spri2	pr6|168
003345  aa  6 00105 3521 00	epp2 	pr6|69		cv_bin_output
003346  aa  6 00252 2521 00	spri2	pr6|170
003347  aa  6 00246 6211 00	eax1 	pr6|166
003350  aa   010000 4310 07	fld  	4096,dl
003351  aa  6 00044 3701 20	epp4 	pr6|36,*
003352  la  4 00046 3521 20	epp2 	pr4|38,*		cv_bin_$dec
003353  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1002
          ncp_err_code = "NBtbl_" || substr (cv_bin_output, 11, 2);

003354  aa  6 00107 2351 00	lda  	pr6|71		cv_bin_output
003355  aa   000022 7350 00	als  	18
003356  aa  0 00110 3771 00	anaq 	pr0|72		= 777777777777 000000000000
003357  aa   000066 7730 00	lrl  	54
003360  aa   774534 2770 04	oraq 	-1700,ic		000114 = 116102164142 154137000000
003361  aa  6 00232 7571 00	staq 	pr6|154		ncp_err_code
						STATEMENT 1 ON LINE 1003
          call ncp_error_ (0, ncp_err_code);

003362  aa  6 00300 4501 00	stz  	pr6|192
003363  aa  6 00300 3521 00	epp2 	pr6|192
003364  aa  6 00306 2521 00	spri2	pr6|198
003365  aa  6 00232 3521 00	epp2 	pr6|154		ncp_err_code
003366  aa  6 00310 2521 00	spri2	pr6|200
003367  aa   774515 3520 04	epp2 	-1715,ic		000104 = 404000000043
003370  aa  6 00312 2521 00	spri2	pr6|202
003371  aa   774474 3520 04	epp2 	-1732,ic		000065 = 526000000010
003372  aa  6 00314 2521 00	spri2	pr6|204
003373  aa  6 00304 6211 00	eax1 	pr6|196
003374  aa   010000 4310 07	fld  	4096,dl
003375  aa  6 00044 3701 20	epp4 	pr6|36,*
003376  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
003377  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1004
          return;

003400  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 1012
operation (31):
          sep -> socket.deactivate = "1"b;

003401  aa   000002 2350 03	lda  	2,du
003402  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003403  aa  5 00017 2551 00	orsa 	pr5|15		socket.deactivate
						STATEMENT 1 ON LINE 1014
          sep -> socket.allow_interrupts = "0"b;

003404  aa   000062 2350 04	lda  	50,ic		003466 = 777773777777
003405  aa  5 00017 3551 00	ansa 	pr5|15		socket.allow_interrupts
						STATEMENT 1 ON LINE 1015
          sep -> socket.event_channel = 0;

003406  aa   774514 2370 04	ldaq 	-1716,ic		000122 = 000000000000 000000000000
003407  aa  5 00000 7571 00	staq 	pr5|0		socket.event_channel
						STATEMENT 1 ON LINE 1016
          sep -> socket.overseer_event_channel = 0;

003410  aa  5 00002 7571 00	staq 	pr5|2		socket.overseer_event_channel
						STATEMENT 1 ON LINE 1017
          goto next;

003411  aa   775453 7100 04	tra  	-1237,ic		001064
						STATEMENT 1 ON LINE 1025
operation (32):
          call imp_write_order ((sep -> socket.impdim_index), IMP_ORDER_pgqlrr, null (), status, icode);

003412  aa  6 00126 3715 20	epp5 	pr6|86,*		sep
003413  aa  5 00016 2351 00	lda  	pr5|14		socket.impdim_index
003414  aa   000022 7350 00	als  	18
003415  aa   000066 7330 00	lrs  	54
003416  aa  6 00300 7561 00	stq  	pr6|192
003417  aa   774501 3534 24	epp3 	-1727,ic*
003420  aa  6 00362 2535 00	spri3	pr6|242
003421  aa  6 00300 3521 00	epp2 	pr6|192
003422  aa  6 00260 2521 00	spri2	pr6|176
003423  aa   774441 3520 04	epp2 	-1759,ic		000064 = 000000000015
003424  aa  6 00262 2521 00	spri2	pr6|178
003425  aa  6 00362 3521 00	epp2 	pr6|242
003426  aa  6 00264 2521 00	spri2	pr6|180
003427  aa  6 00240 3521 00	epp2 	pr6|160		status
003430  aa  6 00266 2521 00	spri2	pr6|182
003431  aa  6 00103 3521 00	epp2 	pr6|67		icode
003432  aa  6 00270 2521 00	spri2	pr6|184
003433  aa  6 00256 6211 00	eax1 	pr6|174
003434  aa   024000 4310 07	fld  	10240,dl
003435  aa  6 00044 3701 20	epp4 	pr6|36,*
003436  la  4 00054 3521 20	epp2 	pr4|44,*		imp_write_order
003437  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1027
          goto next;

003440  aa   775424 7100 04	tra  	-1260,ic		001064
						STATEMENT 1 ON LINE 1034
operation (37):
          i = 1;

003441  aa   000001 2360 07	ldq  	1,dl
003442  aa  6 00136 7561 00	stq  	pr6|94		i
						STATEMENT 1 ON LINE 1036
          goto state_common;

003443  aa   776746 7100 04	tra  	-538,ic		002411
						STATEMENT 1 ON LINE 1040
operation (14):
operation (26):
operation (27):
operation (28):
operation (30):
operation (33):
operation (36):
operation (41):
          call ncp_error_ (0, "TBOP_obsolete_function");

003444  aa  6 00300 4501 00	stz  	pr6|192
003445  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003446  aa   774506 00 0030	desc9a	-1722,24		000153 = 124102117120
003447  aa  6 00246 00 0030	desc9a	pr6|166,24
003450  aa  6 00300 3521 00	epp2 	pr6|192
003451  aa  6 00306 2521 00	spri2	pr6|198
003452  aa  6 00246 3521 00	epp2 	pr6|166
003453  aa  6 00310 2521 00	spri2	pr6|200
003454  aa   774430 3520 04	epp2 	-1768,ic		000104 = 404000000043
003455  aa  6 00312 2521 00	spri2	pr6|202
003456  aa   774420 3520 04	epp2 	-1776,ic		000076 = 524000000026
003457  aa  6 00314 2521 00	spri2	pr6|204
003460  aa  6 00304 6211 00	eax1 	pr6|196
003461  aa   010000 4310 07	fld  	4096,dl
003462  aa  6 00044 3701 20	epp4 	pr6|36,*
003463  la  4 00072 3521 20	epp2 	pr4|58,*		ncp_error_
003464  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1049
          return;

003465  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 1051
end;

  END PROCEDURE ncp_tbop_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
