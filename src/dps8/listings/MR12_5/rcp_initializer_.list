	COMPILATION LISTING OF SEGMENT rcp_initializer_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 06/04/84  1657.1 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       12 rcp_initializer_:
       13      procedure (arg_message);
       14 
       15 /*	This program is an internal interface of RCP.
       16*   *	Created on 11/27/74 by Bill Silver
       17*   *
       18*   *	This program performs the RCP functions that will eventually be
       19*   *	performed by the initializer process.  These functions are:
       20*   *	     1.	Assign a device and/or volume.
       21*   *	     2.	Update the error count for the specified device.
       22*   *	     3.	Unassign a device and/or volume.
       23*   *	     4.	Forcedly unassign a device.
       24*   *	     5.	Unassign all resources of specified process.
       25*   *	     6.   Delete a device.
       26*   *	     7.	Add a device.
       27**/
       28 /*	rcp_initializer_$ss_io_interchange added for "static" "AC/DC" disks,
       29*   *	Bernard Greenberg 3/9/77
       30*   *	RCP accounting by BSG, agent for T. Casey, 8/2/77.
       31*   *	RCP accounting bug fix by T. Casey, 10/19/77.
       32*   *	Preloaded volumes by Michael R. Jordan, 04/28/78.
       33*   *	Emergency bugfix for preloaded volumes by Michael R. Jordan, 08/17/78.
       34*   *	Bug fixes for preloading a volume on an assigned device; accounting for reserved devices; and deleting
       35*   *	  reserved, unassigned devices by Michael R. Jordan, 12/09/78.
       36*   *	Add accounting for reservation by R.J.C. Kissel, 1/79
       37*   *	Support for MSS0500 subsystem by Michael R. Jordan, 01/29/79.
       38*   *	MR7.0R changes to access checking by Michael R. Jordan, 3/79
       39*   *	Tape survey when adding drive by C. Hornig, September 1982.
       40*   *      Modified 12/8/83 by B. Braun to correct all device requests being denined (phx12105).
       41*   *	Modified 1/84 by Chris Jones to tell IOI what we've done about adding or deleting a device.
       42*   *	Modified 840521 for console addition / deletion... -E. A. Ranzenbach
       43**/
       44 
       45 /*		ARGUMENT  DATA		*/
       46 
       47 
       48 dcl	arg_message	   fixed bin (71);		/* (I) Simulates an IPC event message. */
       49 
       50 dcl	a_add_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b = add to RCP */
       51 dcl	a_del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */
       52 dcl	a_device_name	   char (*);		/* For $ss_io_interchange, drive name */
       53 dcl	a_ecode		   fixed bin (35);		/* For $ss_io_interchange, error code. */
       54 
       55 
       56 /*		AUTOMATIC  DATA		*/
       57 
       58 
       59 dcl	access		   bit (3) aligned;		/* User's access to resource. */
       60 dcl	access_needed	   bit (3);		/* Access required to resource. */
       61 dcl	accessible_flag	   bit (1);		/* ON => process has access to a segment. */
       62 dcl	add_sw		   bit (1);		/* For $ss_io_interchange, "1"b => add to RCP. */
       63 dcl	available_flag	   bit (1);		/* ON => device is available. */
       64 dcl	available_list	   (16) ptr;		/* List of appropriate, accessible, and available devices. */
       65 dcl	del_sw		   bit (1) aligned;		/* For $ss_io_interchange, "1"b to 'add' in deleted state */
       66 dcl	dev_rcse_off	   bit (18);		/* Offset of RCS device entry. */
       67 dcl	device_name	   char (32);		/* Device name. */
       68 dcl	device_off	   bit (18);		/* Offset of RCPD device entry. */
       69 dcl	dtypex		   fixed bin;		/* Device type index. */
       70 dcl	ecode		   fixed bin (35);		/* error_table_ code. */
       71 dcl	i		   fixed bin;		/* Work variable. */
       72 dcl	j		   fixed bin;
       73 dcl	match_flag	   bit (1);		/* ON => device matches. */
       74 dcl	message		   fixed bin (71);		/* Simulated IPC event message. */
       75 dcl	num_accessible	   fixed bin;		/* Number of devices accessible to process. */
       76 dcl	num_appropriate	   fixed bin;		/* Number of appropriate devices. */
       77 dcl	num_assigned	   fixed bin;		/* Number of devices assigned to a process. */
       78 dcl	num_avail_nres	   fixed bin;		/* Number of non reservable devices available. */
       79 dcl	num_available	   fixed bin;		/* Number of devices available for assignment. */
       80 dcl	num_free_res	   fixed bin;		/* Number of reservable devices currently free. */
       81 dcl	num_reserved	   fixed bin;		/* Number of devices reserved to system processes. */
       82 dcl	num_resvd		   fixed bin;		/* Number of device reserved for this process. */
       83 dcl	process_id	   bit (36);		/* Process ID. */
       84 dcl	save_device_ptr	   ptr;			/* Used to save pointer to assigned device. */
       85 dcl	system_flag	   bit (1);		/* ON => process is a system process. */
       86 dcl	time_assigned	   fixed bin (71);		/* Used to compute metering data. */
       87 dcl	vol_rcse_off	   bit (18);		/* Offset of RCS volume entry. */
       88 dcl	volume_flag	   bit (1);		/* ON => we have assigned a volume. */
       89 dcl	volume_name	   char (32);		/* Volume name. */
       90 dcl	volume_off	   bit (18);		/* Offset of RCPD volume entry. */
       91 
       92 
       93 /*		CONSTANTS			*/
       94 
       95 
       96 dcl	NULL		   bit (3) static internal options (constant) init ("000"b);
       97 dcl	R		   bit (3) static internal options (constant) init ("100"b);
       98 dcl	REW		   bit (3) static internal options (constant) init ("111"b);
       99 dcl	RW		   bit (3) static internal options (constant) init ("101"b);
      100 
      101 
      102 /*		CONDITIONS		*/
      103 
      104 
      105 dcl	cleanup		   condition;		/* Used to establish a cleanup handler. */
      106 
      107 
      108 /*		BUILTIN FUNCTIONS		*/
      109 
      110 
      111 dcl	addr		   builtin;
      112 dcl	clock		   builtin;
      113 dcl	divide		   builtin;
      114 dcl	hbound		   builtin;
      115 dcl	ptr		   builtin;
      116 dcl	rel		   builtin;
      117 dcl	string		   builtin;
      118 dcl	unspec		   builtin;
      119 
      120 
      121 /*		ERROR CODES		*/
      122 
      123 
      124 dcl	error_table_$device_limit_exceeded
      125 			   fixed bin (35) ext;
      126 dcl	error_table_$insufficient_access
      127 			   fixed bin (35) ext;
      128 dcl	error_table_$invalid_state
      129 			   fixed bin (35) ext;
      130 dcl	error_table_$io_still_assnd
      131 			   fixed bin (35) ext;
      132 dcl	error_table_$notalloc  fixed bin (35) ext;
      133 dcl	error_table_$resource_bad_access
      134 			   fixed bin (35) ext;
      135 dcl	error_table_$resource_unavailable
      136 			   fixed bin (35) ext;
      137 dcl	error_table_$resource_unknown
      138 			   fixed bin (35) ext;
      139 
      140 
      141 /*		EXTERNAL ENTRIES CALLED	*/
      142 
      143 
      144 dcl	admin_gate_$ioi_add_device
      145 			   entry (char (*), fixed bin (35));
      146 dcl	admin_gate_$ioi_delete_device
      147 			   entry (char (*), fixed bin (35));
      148 dcl	admin_gate_$syserr	   entry options (variable);
      149 dcl	admin_gate_$syserr_error_code
      150 			   entry options (variable);
      151 dcl	get_process_id_	   entry returns (bit (36));
      152 dcl	hcs_$wakeup	   entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      153 dcl	hphcs_$ocdcm_reconfigure
      154 			   entry (char (4), fixed bin (17), fixed bin (35));
      155 dcl	rcp_check_access_	   entry (char (32), char (32), char (32), fixed bin, bit (3) aligned, fixed bin (35));
      156 dcl	rcp_lock_$lock	   entry (ptr, fixed bin (35));
      157 dcl	rcp_lock_$unlock	   entry (ptr);
      158 dcl	rcp_match_$match	   entry (ptr, ptr) returns (bit (1));
      159 dcl	rcp_match_$select	   entry (ptr, fixed bin, char (*) aligned, ptr);
      160 dcl	rcp_match_user_name_   entry (char (32) aligned, char (32) aligned) returns (bit (1));
      161 dcl	rcp_pointers_$com_seg  entry returns (ptr);
      162 dcl	rcp_pointers_$data	   entry returns (ptr);
      163 dcl	rcp_tape_survey_	   entry (char (*), fixed bin, bit (1) aligned, (4) fixed bin (35), fixed bin (35));
      164 dcl	rcp_unload_$unload_device
      165 			   entry (ptr, bit (1));
      166 dcl	get_authorization_	   entry () returns (bit (72) aligned);
      167 dcl	rcp_get_scratch_volume_
      168 			   entry (ptr, char (*), bit (3) aligned, fixed bin (35));
      169 dcl	rcp_cancel_resource_   entry (char (*), char (*), fixed bin (35));
      170 
      171 /*	There is only one entry point to this procedure.  We will determine what
      172*   *	function to perform by using the action index found in the event message.
      173*   *	We will lock RCPD during the time we are working with it.
      174**/
      175 	message = arg_message;			/* Get info from message. */
      176 	message_ptr = addr (message);			/* Get pointer to message data. */
      177 	rcpd_ptr = rcp_pointers_$data ();		/* Set up pointers. */
      178 	rcs_ptr = rcp_pointers_$com_seg ();
      179 	ecode = 0;
      180 
      181 	on cleanup
      182 	     begin;				/* If trouble unlock rcp_data. */
      183 		call UNLOCK;
      184 	     end;
      185 
      186 	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
      187 	if ecode ^= 0 then
      188 	     return;
      189 
      190 	goto ACTION (offset_message.actionx);		/* Go perform requested action. */
      191 
      192 ACTION (1):					/* Assign. */
      193 	call ASSIGN;
      194 	call UNLOCK;
      195 	return;
      196 
      197 ACTION (2):					/* Error count. */
      198 	call ERROR_COUNT;
      199 	call UNLOCK;
      200 	return;
      201 
      202 ACTION (3):					/* Unassign. */
      203 	call UNASSIGN;
      204 	call UNLOCK;
      205 	return;
      206 
      207 ACTION (4):					/* Force unassign. */
      208 	call FORCE_UNASSIGN;
      209 	call UNLOCK;
      210 	return;
      211 
      212 ACTION (5):					/* Unassign process. */
      213 	call PROC_UNASSIGN;
      214 	call UNLOCK;
      215 	return;
      216 
      217 ACTION (6):					/* Delete a device. */
      218 	call DELETE_DEVICE;
      219 	call UNLOCK;
      220 	return;
      221 
      222 ACTION (7):					/* Add a device. */
      223 	call ADD_DEVICE;
      224 	call UNLOCK;
      225 	return;
      226 
      227 ACTION (8):					/* Account attach */
      228 	call ACCOUNT_ATTACH;
      229 	call UNLOCK;
      230 	return;
      231 
      232 UNLOCK:
      233      procedure;					/* Unlock RCPD. */
      234 	call rcp_lock_$unlock (addr (rcpd.lock_info));
      235      end UNLOCK;
      236 
      237 ASSIGN:
      238      procedure;
      239 
      240 /*	This procedure is called to perform an assignment of a device and/or volume.
      241*   *	The offsets in the event message are used to determine what is to be assigned.
      242*   *	These offsets reference RCS entries.  We will communicate the results of the
      243*   *	assignment(s) by filling in these entries.
      244**/
      245 	vol_rcse_off = offset_message.volume_off;	/* Get RCS entry offsets. */
      246 	dev_rcse_off = offset_message.device_off;
      247 
      248 	volume_flag = "0"b;				/* Assume no volume assigned. */
      249 
      250 	if vol_rcse_off ^= "0"b			/* Do we have to assign a volume? */
      251 	then do;					/* Yes. */
      252 	     call ASSIGN_VOLUME;			/* Assign one volume to this process. */
      253 	     rcse.ecode = ecode;			/* Tell results of volume assignment. */
      254 	     if ecode ^= 0				/* Any problems with volume? */
      255 	     then return;				/* Yes, abort all assignments. */
      256 	end;
      257 
      258 	if dev_rcse_off ^= "0"b			/* Do we have a device to assign? */
      259 	then do;					/* Yes. */
      260 	     call ASSIGN_DEVICE;			/* Assign an appropriate device. */
      261 	     rcse.ecode = ecode;			/* Tell results of device assignment. */
      262 	end;
      263 
      264 	if ^volume_flag				/* Device assignment done.  Was there a volume? */
      265 	then return;				/* No, nothing else to do. */
      266 
      267 	if ecode ^= 0				/* Was there an error assigning device? */
      268 	then do;					/* Yes. */
      269 	     call UNASSIGN_VOLUME ();
      270 	     return;
      271 	end;
      272 
      273 	if dev_rcse_off = "0"b			/* Was a device just assigned? */
      274 	then do;					/* No, put volume on previously assigned device. */
      275 	     rcse_ptr = ptr (rcs_ptr, vol_rcse_off);	/* Attachment RCS entry. */
      276 	     rcse_ptr = ptr (rcs_ptr, rcse.rcse_off);	/* Assignment RCS entry. */
      277 	     device_ptr = ptr (rcpd_ptr, rcse.device_off);
      278 	     dtypex = device.dtypex;			/* Get device type of this device. */
      279 	     dtype_ptr = addr (rcpd.dtype (dtypex));
      280 	end;
      281 
      282 	if device.volume_name = volume_name		/* Is volume already on this device? */
      283 	then do;					/* Yes, nothing more to do. */
      284 	     rcse.volume_name = volume_name;		/* ASSIGNment RCSE */
      285 	     return;
      286 	end;
      287 
      288 	if volume_name = "scratch"			/* Is this a scratch volume. */
      289 	then do;					/* Yes, special case. */
      290 	     device.volume_name = " ";		/* Scratch volumes not remembered. */
      291 	     return;
      292 	end;
      293 
      294 /*	The assigned volume is being put on a new device.  We must search through
      295*   *	all of the devices of this type to see if it is currently on any other
      296*   *	device.  If it is we will remove it from that device.
      297**/
      298 	save_device_ptr = device_ptr;			/* Save pointer to assigned device. */
      299 	device_off = dtype.first_off;			/* Get first device of this type. */
      300 	do while (device_off ^= "0"b);		/* Test all devices of this type. */
      301 	     device_ptr = ptr (rcpd_ptr, device_off);
      302 	     if device.volume_name = volume_name then do; /* We found the volume on another device. */
      303 		call rcp_unload_$unload_device (device_ptr, "0"b);
      304 						/* unload the volume */
      305 		device.volume_name = "";		/* Forget this occurance. */
      306 		goto REMEMBER_DEVICE;		/* No need to test any more devices. */
      307 	     end;
      308 	     device_off = device.next_off;		/* Test next device. */
      309 	end;
      310 
      311 REMEMBER_DEVICE:					/* Put volume on assigned device. */
      312 	save_device_ptr -> device.volume_name = volume_name;
      313 
      314      end ASSIGN;
      315 
      316 /*	This procedure is called to assign a volume.  The assignment of a volume
      317*   *	is independent of the assignment of a device.  A list of the currently
      318*   *	assigned volumes is kept in RCPD.
      319**/
      320 
      321 
      322 ASSIGN_VOLUME:
      323      procedure;
      324 
      325 
      326 	rcse_ptr = ptr (rcs_ptr, vol_rcse_off);		/* Get pointer to RCS entry that => volume. */
      327 	access = "000"b;
      328 	if rcse.volume_name ^= "scratch" then
      329 	     volume_name = rcse.volume_name;
      330 	else do;
      331 	     call rcp_get_scratch_volume_ (rcse_ptr, volume_name, access, ecode);
      332 	     if ecode ^= 0 then
      333 		return;
      334 	     rcse.volume_name = volume_name;
      335 	end;
      336 	volume_off = "0"b;				/* Initialize volume offset. */
      337 
      338 	do i = 1 to rcpd.last_volume;			/* Search through list of volumes. */
      339 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
      340 	     if volume.volume_name = volume_name then do;
      341 		if (volume.state = 0) | ((volume.state = 4) & (volume.process_id = rcse.process_id)) then
      342 		     volume_off = rel (volume_ptr);
      343 		else if volume_name ^= "" then do;
      344 		     ecode = error_table_$resource_unavailable;
      345 		     return;
      346 		end;
      347 	     end;
      348 	     else if (volume.state = 0) & (volume.volume_name = "") then
      349 						/* If this is a free entry in the table ... */
      350 		if volume_off = "0"b then		/* ... and we don't have a slot to use yet ... */
      351 		     volume_off = rel (volume_ptr);	/* ... then remember this one for later. */
      352 	end;
      353 
      354 	if volume_off = "0"b			/* Volume not found, room for another? */
      355 	then if rcpd.last_volume >= rcpd.tot_volumes then do;
      356 						/* No room. */
      357 		ecode = error_table_$notalloc;
      358 		return;
      359 	     end;
      360 	     else do;				/* Get a new entry. */
      361 		rcpd.last_volume = rcpd.last_volume + 1;
      362 		volume_off = rel (addr (rcpd.volume (rcpd.last_volume)));
      363 	     end;
      364 
      365 /*	Now we must make sure we have access to the volume requested.
      366**/
      367 
      368 	if access = "000"b				/* Don't know yet. */
      369 	then do;
      370 	     call rcp_check_access_ (VOLUME_TYPE (rcse.dtypex), (rcse.volume_name), (rcse.group_id), rcse.caller_level,
      371 		access, ecode);
      372 	     if ecode ^= 0 then do;			/* An error has occured. */
      373 		if ecode = error_table_$resource_unknown/* Unregistered volume. */
      374 		     & rcpd.modes.auto_registration	/* And auto registration is on. */
      375 		then do;				/* We will continue for now. */
      376 		     rcse.flags.must_auto_register = "1"b;
      377 						/* Ask the operator later. */
      378 		     access = REW;
      379 		     ecode = 0;
      380 		end;
      381 		else return;
      382 	     end;
      383 	end;
      384 
      385 	if rcse.flags.writing then
      386 	     access_needed = RW;
      387 	else access_needed = R;
      388 
      389 	if (access & access_needed) ^= access_needed	/* Must have access_needed access to volume. */
      390 	then do;
      391 	     if access = NULL			/* No access to the resource. */
      392 	     then ecode = error_table_$resource_bad_access;
      393 						/* Process lacks access to volume. */
      394 	     else ecode = error_table_$insufficient_access;
      395 	     return;
      396 	end;
      397 
      398 /*	Assign volume by filling in the free volume entry that we have found.
      399**/
      400 	volume_ptr = ptr (rcpd_ptr, volume_off);	/* Get pointer to assigned volume entry. */
      401 	volume.process_id = rcse.process_id;		/* Assign volume entry to process. */
      402 	volume.vtypex = rcse.dtypex;
      403 	volume.unassign_state = volume.state;
      404 	volume.state = 1;				/* Make it assigned. */
      405 	volume.state_time = clock ();
      406 	volume.volume_name = volume_name;
      407 	volume.group_id = rcse.group_id;
      408 	if volume.unassign_state = 0 then do;		/* if this was free ... */
      409 	     volume.reserved_by = "";			/* no reservation */
      410 	     volume.reservation_id = 0;
      411 	end;
      412 	volume.current_authorization = get_authorization_ ();
      413 						/* Save this guy's authorization. */
      414 
      415 	volume_name = rcse.volume_name;		/* Leave the real volume name here. */
      416 	volume_flag = "1"b;				/* ON => a volume has been assigned. */
      417 	rcse.state = 2;				/* State => volume now assigned. */
      418 	rcse.volume_off = volume_off;			/* Save offset of volume entry. */
      419 
      420      end ASSIGN_VOLUME;
      421 
      422 ASSIGN_DEVICE:
      423      procedure;
      424 
      425 dcl	ignored_code	   fixed bin (35);
      426 
      427 /*	This procedure is called to assign a device.  The following tests
      428*   *	are made before assigning a device:
      429*   *	     1.	There must be an appropriate device.
      430*   *	     2.	The requesting process must have access to the device.
      431*   *	     3.  	There must be an appropriate and accessible device that is available.
      432*   *	     4.	The device limits must not be exceeded.
      433*   *	     5.	If the assignment is based on a volume then we will try to
      434*   *		find a device that has the specified volume already mounted.
      435*   *	     6.	Otherwise we take the device that has been unassigned the longest.
      436**/
      437 	rcse_ptr = ptr (rcs_ptr, dev_rcse_off);		/* Get pointer to RCS entry for device. */
      438 	dtypex = rcse.dtypex;			/* Get device type index. */
      439 	dtype_ptr = addr (rcpd.dtype (dtypex));		/* Get pointer to device type entry. */
      440 	system_flag = rcse.flags.system;		/* Get system flag. */
      441 	if rcse.group_id = "Initializer.SysDaemon.z" & rcse.caller_level = 1 then
      442 	     system_flag = "1"b;
      443 
      444 	num_assigned,				/* Initialize counters. */
      445 	     num_free_res, num_reserved, num_resvd = 0;
      446 	num_appropriate, num_accessible, num_available = 0;
      447 
      448 	device_off = dtype.first_off;			/* Start with first type of device. */
      449 	do while (device_off ^= "0"b);		/* Test all devices of this type. */
      450 	     device_ptr = ptr (rcpd_ptr, device_off);	/* Get pointer to RCPD device entry. */
      451 	     call TEST_DEVICE;			/* Test device to see if it can be assigned. */
      452 	     device_off = device.next_off;		/* Get offset of next device of this type. */
      453 	end;
      454 
      455 	if num_appropriate = 0			/* Did we find any appropriate device? */
      456 	then do;					/* No. */
      457 	     ecode = error_table_$resource_unknown;
      458 	     return;
      459 	end;
      460 
      461 	if num_accessible = 0			/* Did we find any accessible device? */
      462 	then do;					/* No. */
      463 	     ecode = error_table_$resource_bad_access;
      464 	     return;
      465 	end;
      466 
      467 	if num_available = 0			/* Did we find any available device? */
      468 	then do;					/* No. */
      469 	     ecode = error_table_$resource_unavailable;
      470 	     return;
      471 	end;
      472 
      473 	call CHECK_LIMITS;				/* Check device limits. */
      474 	if ecode ^= 0 then
      475 	     return;				/* Find the best device that matched. */
      476 	if num_resvd > 0 then do;
      477 	     j = 0;
      478 	     do i = 1 to num_available;
      479 		if available_list (i) -> device.state = 4 then do;
      480 		     j = j + 1;
      481 		     available_list (j) = available_list (i);
      482 		end;
      483 	     end;
      484 	     num_available = j;
      485 	end;
      486 
      487 	call rcp_match_$select (addr (available_list), num_available, rcse.volume_name, device_ptr);
      488 	device_off = rel (device_ptr);		/* Save offset of device entry. */
      489 
      490 	rcse.flags.volume = "0"b;
      491 	if device.volume_name ^= " " then do;		/* then let him know it. */
      492 	     if rcpd.modes.resource_mgmt_enabled then do;
      493 		call rcp_check_access_ (VOLUME_TYPE (device.dtypex), (device.volume_name), (rcse.group_id),
      494 		     rcse.caller_level, access, ecode);
      495 		if (ecode = 0) & (access ^= NULL) then do;
      496 		     rcse.flags.volume = "1"b;
      497 		     rcse.volume_name = device.volume_name;
      498 		end;
      499 		else ecode = 0;			/* No error for not having access -- or whatever else. */
      500 	     end;
      501 	     else if rcp_match_user_name_ (rcse.group_id, device.group_id) then do;
      502 		rcse.flags.volume = "1"b;
      503 		rcse.volume_name = device.volume_name;
      504 	     end;
      505 	end;
      506 
      507 	rcse.flags.preload_allowed = ^rcpd.modes.unload_on_detach;
      508 	rcse.flags.not_removable_media = device.flags.not_removable_media;
      509 
      510 	device.process_id = rcse.process_id;		/* Save info about assignment. */
      511 	device.group_id = rcse.group_id;
      512 	if device.flags.reservable			/* Can device be reserved? */
      513 	then device.flags.reserved = system_flag;
      514 	else device.flags.reserved = "0"b;
      515 	if device.state = 2				/* Are we assigning a deleted device? */
      516 	then do;					/* Yes. */
      517 	     call admin_gate_$ioi_add_device ((device.device_name), ignored_code);
      518 	     device.flags.delete,			/* Remember to delete when unassigned. */
      519 		device.flags.priv = "1"b;		/* Special assignment for privileged attachment. */
      520 	end;
      521 	device.state_time = clock ();			/* Note when assigned. */
      522 	device.unassign_state = device.state;
      523 	device.current_authorization = get_authorization_ ();
      524 						/* Save this guy's authorization. */
      525 	device.state = 1;				/* Device is now assigned. */
      526 
      527 	if device.unassign_state ^= 4 then		/* Accounting for reserved devices is done at reservation time. */
      528 	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_assign);
      529 
      530 	rcse.state = 2;				/* Tell requesting process assignment complete. */
      531 	rcse.device_off = device_off;			/* Save offset of rcp_data entry. */
      532 	rcse.device_name = device.device_name;		/* Return info about assigned device. */
      533 	rcse.model = device.model;
      534 	do i = 1 to device.num_qualifiers;
      535 	     rcse.qualifiers (i) = device.qualifiers (i);
      536 	end;
      537 	rcse.flags.system = system_flag;		/* Note whether assigned as a system process. */
      538 
      539 /*	Note this assignment in the syserr log.
      540**/
      541 	call admin_gate_$syserr (LOG, "RCP: Assigned ^a to ^a", device.device_name, device.group_id);
      542 
      543      end ASSIGN_DEVICE;
      544 
      545 TEST_DEVICE:
      546      procedure;
      547 
      548 /*	This procedure is called to test a device.  We will see if it is
      549*   *	appropriate, accessible, and available.  If it is all three we
      550*   *	will add it to a list of such devices.
      551**/
      552 	goto DEVICE_STATE (device.state);		/* Process according to state of device. */
      553 
      554 DEVICE_STATE (3):					/* SHARED by STORAGE SYSTEM */
      555 	return;					/* Forget it. */
      556 
      557 DEVICE_STATE (2):					/* DELETED. */
      558 	if rcse.flags.priv				/* Is assignment for a privileged attachment? */
      559 	then goto DEVICE_STATE (0);			/* Yes, consider device to be free for now. */
      560 	else return;				/* No, don't even test. */
      561 
      562 DEVICE_STATE (1):					/* ASSIGNED. */
      563 	if device.process_id = rcse.process_id		/* Assigned to requesting process? */
      564 	then num_assigned = num_assigned + 1;		/* Yes, count number assigned to this process. */
      565 	if device.flags.reserved			/* Is device reserved to a system process? */
      566 	then num_reserved = num_reserved + 1;		/* Yes, count these too. */
      567 	available_flag = "0"b;			/* This device is not available. */
      568 	goto AAA_TEST;				/* Go complete test. */
      569 
      570 DEVICE_STATE (4):					/* RESERVED */
      571 	if device.process_id = rcse.process_id then
      572 	     available_flag = "1"b;
      573 	else available_flag = "0"b;
      574 	goto AAA_TEST;
      575 
      576 DEVICE_STATE (0):					/* FREE. */
      577 	if device.flags.reservable			/* Can this device be reserved? */
      578 	then num_free_res = num_free_res + 1;		/* Yes, count free reservable devices. */
      579 	available_flag = "1"b;			/* This device is available. */
      580 
      581 AAA_TEST:						/* Make Appropriate, Accessible, Available test. */
      582 	match_flag = rcp_match_$match (rcse_ptr, device_ptr);
      583 	if match_flag				/* Did it match, i.e., is it appropriate? */
      584 	then num_appropriate = num_appropriate + 1;
      585 	else return;				/* No this device is not apporpriate. */
      586 	call rcp_check_access_ (DEVICE_TYPE (device.dtypex), (device.device_name), (rcse.group_id), rcse.caller_level,
      587 	     access, ecode);
      588 	if ecode = 0 then
      589 	     accessible_flag = ((access & RW) = RW);
      590 	else do;
      591 	     accessible_flag = "0"b;
      592 	     ecode = 0;
      593 	end;
      594 	if accessible_flag				/* Does this process have "RW" access to this device? */
      595 	then num_accessible = num_accessible + 1;
      596 	else return;				/* No, insufficient access to this device. */
      597 	if available_flag				/* Is this device available? */
      598 	then num_available = num_available + 1;
      599 	else return;				/* No, device already assigned. */
      600 	available_list (num_available) = device_ptr;	/* Put this device in the available list. */
      601 	if device.state = 4 then			/* a reserved device */
      602 	     num_resvd = num_resvd + 1;
      603 
      604      end TEST_DEVICE;
      605 
      606 CHECK_LIMITS:
      607      procedure;
      608 
      609 /*	This procedure is called to check the limits imposed upon non
      610*   *	system processes.  These limits are:
      611*   *	     1.	Only a certain number of devices of any one type may be assigned
      612*   *		to a process at at one time.
      613*   *	     2.	A certain number of reservable devices of this type
      614*   *		must be free or in use by system processes.
      615**/
      616 	if system_flag				/* Is this a system process? */
      617 	then return;				/* Yes, no need to test limits. */
      618 
      619 	if num_resvd ^= 0 then
      620 	     return;				/* can always use reserved device */
      621 
      622 	if num_assigned >= dtype.max_concurrent		/* Maximum already assigned to this process? */
      623 	then do;					/* Yes. */
      624 	     ecode = error_table_$device_limit_exceeded;
      625 	     return;
      626 	end;
      627 
      628 	if num_reserved >= dtype.num_reserved		/* Already using the quota of system drives? */
      629 	then return;				/* Yes, don't bother the user */
      630 
      631 	if num_free_res > (dtype.num_reserved - num_reserved) then
      632 	     return;				/* There are enough free reservable devices. */
      633 
      634 	num_avail_nres = 0;				/* Count number that will be available. *. */
      635 	do i = 1 to num_available;			/* Remove reservable devices from selection list. */
      636 	     device_ptr = available_list (i);
      637 	     if ^device.flags.reservable		/* If non reservable keep in list. */
      638 	     then do;
      639 		available_list (num_avail_nres) = device_ptr;
      640 		num_avail_nres = num_avail_nres + 1;
      641 	     end;
      642 	end;
      643 	num_available = num_avail_nres;		/* Now only non reservable devices are available. */
      644 	if num_available = 0			/* Are there any available devices left? */
      645 	then do;					/* No, only reservable devices were available. */
      646 	     ecode = error_table_$resource_unavailable;
      647 	     return;
      648 	end;
      649 
      650      end CHECK_LIMITS;
      651 
      652 ERROR_COUNT:
      653      procedure;
      654 
      655 /*	This procedure is called to update the error count for a device.
      656**/
      657 	device_ptr = ptr (rcpd_ptr, offset_message.device_off);
      658 
      659 	if device.state ^= 1			/* Is device assigned? */
      660 	then return;				/* No, ignore this call. */
      661 
      662 	if device.process_id ^= get_process_id_ () then
      663 	     return;				/* Not assigned to this process. */
      664 
      665 	device.error_count = device.error_count + offset_message.error_count;
      666 
      667      end ERROR_COUNT;
      668 
      669 UNASSIGN:
      670      procedure;
      671 
      672 /*	This procedure is called to unassign a device and/or volume.
      673*   *	The volume and device offsets in the event message reference
      674*   *	RCPD volume and device entries.  The resources associated with
      675*   *	these entries will be unassigned.  Before unassigning any
      676*   *	resource we will verify that it is actually assigned to the
      677*   *	requesting process.  We will note this unassignment in the syserr log.
      678**/
      679 	volume_off = offset_message.volume_off;
      680 	device_off = offset_message.device_off;
      681 
      682 	process_id = get_process_id_ ();		/* Get process ID of calling process. */
      683 
      684 	if volume_off ^= "0"b			/* Is there a volume to unassign? */
      685 	then do;					/* Yes. */
      686 	     volume_ptr = ptr (rcpd_ptr, volume_off);
      687 	     if volume.process_id = process_id then	/* Volume is assigned to this process. */
      688 		call UNASSIGN_VOLUME ();
      689 	end;
      690 
      691 	if device_off = "0"b			/* Is there a device to unassign? */
      692 	then return;				/* No. */
      693 
      694 	device_ptr = ptr (rcpd_ptr, device_off);	/* Yes, get a pointer to its device entry. */
      695 	if device.process_id = process_id		/* Is it actually assigned to this process? */
      696 	then do;					/* Yes, unassign it. */
      697 	     device.error_count = device.error_count + offset_message.error_count;
      698 	     call UNASSIGN_DEVICE;
      699 	     call admin_gate_$syserr (LOG, "RCP: Unassigned ^a from ^a", device.device_name, device.group_id);
      700 	end;
      701 
      702      end UNASSIGN;
      703 
      704 FORCE_UNASSIGN:
      705      procedure;
      706 
      707 /*	This procedure is called to force the unassignment of a device.
      708*   *	The device does not have to be assigned by the requesting process.
      709*   *	If there is a volume mounted on this device we will unassign it.
      710**/
      711 	device_name = name_message.device_name;		/* Get device name from message. */
      712 
      713 	call FIND_DEVICE;				/* Search through all devices for this one. */
      714 	if device_off = "0"b			/* Did we find it? */
      715 	then return;				/* No. */
      716 
      717 	if device.state = 1				/* Is device assigned? */
      718 	then do;					/* Yes. */
      719 	     call UNASSIGN_DEVICE;			/* Just forcedly unassign it. */
      720 	     call admin_gate_$syserr (ANNOUNCE, "RCP: Force Unassigned ^a from ^a", device_name, device.group_id);
      721 	end;
      722 
      723 	if device.volume_name = " "			/* Is there a volume on this device? */
      724 	then return;				/* No, we are all done. */
      725 
      726 	do i = 1 to rcpd.last_volume;			/* Yes, find this volume. */
      727 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to next volume entry. */
      728 	     if volume.volume_name = device.volume_name then do;
      729 						/* We found this volume. */
      730 		call UNASSIGN_VOLUME ();
      731 		return;
      732 	     end;
      733 	end;
      734 
      735      end FORCE_UNASSIGN;
      736 
      737 PROC_UNASSIGN:
      738      procedure;
      739 
      740 /*	This procedure is called to forcedly unassign all devices and volumes
      741*   *	currently assigned to the process whose process ID is specified in
      742*   *	the event message.
      743**/
      744 	process_id = id_message.process_id;		/* Message specifies process to work on. */
      745 
      746 	do i = 1 to rcpd.last_volume;			/* Look at all volume entries. */
      747 	     volume_ptr = addr (rcpd.volume (i));	/* Get pointer to volume entry. */
      748 	     if volume.process_id = process_id		/* Does volume belong to this process? */
      749 	     then do;				/* Yes, unassign it. */
      750 		volume.unassign_state = 0;
      751 		call UNASSIGN_VOLUME ();
      752 	     end;
      753 	end;
      754 
      755 	do i = 1 to rcpd.tot_devices;			/* Look at all devices. */
      756 	     device_ptr = addr (rcpd.device (i));
      757 	     if device.process_id = process_id		/* Does device belong to this process? */
      758 	     then do;				/* Yes, forcedly unassign. */
      759 		device.unassign_state = 0;
      760 		call UNASSIGN_DEVICE;
      761 		call admin_gate_$syserr (LOG, "RCP: Force Unassigned ^a from ^a", device.device_name, device.group_id)
      762 		     ;
      763 	     end;
      764 	end;
      765 
      766      end PROC_UNASSIGN;
      767 
      768 DELETE_DEVICE:
      769      procedure;
      770 
      771 /*	This procedure is called to put a device in the deleted state.
      772*   *	This means that the device cannot be assigned to any process.
      773*   *	If the device is currently assigned will will not delete it now.
      774*   *	We will remember to delete it when it is unassigned.
      775**/
      776 	device_name = name_message.device_name;		/* Get name of device to delete. */
      777 
      778 	call FIND_DEVICE;				/* Find the device with this name. */
      779 	if device_off = "0"b			/* Did we find it? */
      780 	then return;
      781 
      782 	if device.state = 3 then
      783 	     return;				/* Should not be here, but check for ss drives */
      784 	if device.state = 1 | device.state = 4		/* Is device still assigned? */
      785 	then do;					/* Yes, we won't delete it now. */
      786 	     device.flags.delete = "1"b;		/* Remember to delete it when unassigned. */
      787 	     return;
      788 	end;
      789 
      790 	call admin_gate_$ioi_delete_device (device_name, ecode);
      791 	if ecode ^= 0 then do;
      792 	     call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error deleting ^a.", device_name);
      793 	     return;
      794 	end;
      795 
      796 	if device.volume_name ^= "" & device.dtypex = 1 then
      797 	     call rcp_unload_$unload_device (device_ptr, "1"b);
      798 						/* unload volume and forget it was here */
      799 
      800 	device.volume_name = " ";			/* Forget any volume on the deleted device. */
      801 	device.process_id = "0"b;			/* Make sure it doesn't belong to any process. */
      802 	device.state = 2;				/* Just change its state. */
      803 	device.state_time = clock ();			/* And remember when. */
      804 
      805 	if device.dtypex = 3 then do;			/* must inform console DIM of deletion... */
      806 	     call hphcs_$ocdcm_reconfigure ((device_name), MAKE_UNAVAILABLE, ecode);
      807 	     if ecode ^= 0 then do;
      808 		call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Unable to delete console ^a.",
      809 		     device_name);
      810 		return;
      811 	     end;
      812 	end;
      813 
      814 	call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device_name);
      815 
      816      end DELETE_DEVICE;
      817 
      818 
      819 
      820 
      821 
      822 ADD_DEVICE:
      823      procedure;
      824 
      825 /*	This procedure is called to take a device out of the deleted state.
      826*   *	This will only be done if the device is already in the deleted state.
      827**/
      828 
      829 dcl	operational	   bit (1) aligned;
      830 dcl	1 tape_name	   unaligned,
      831 	  2 subsystem	   char (4),
      832 	  2 bar		   char (1),
      833 	  2 drive		   pic "99";
      834 
      835 	device_name = name_message.device_name;		/* Get name of device to add. */
      836 
      837 	call FIND_DEVICE;				/* Find the device with this name. */
      838 	if device_off = "0"b			/* Did we find it? */
      839 	then return;
      840 
      841 	device.flags.delete = "0"b;			/* Make sure no delete is pending. */
      842 
      843 	if device.state ^= 2			/* Is device in the deleted state? */
      844 	then return;				/* No, leave it alone. */
      845 
      846 	if (device.dtypex = TAPE_DRIVE_DTYPEX) & (device.qualifiers (1) = 0) then do;
      847 						/* this is a tape drive deleted during initialization */
      848 	     string (tape_name) = device_name;
      849 	     call rcp_tape_survey_ (tape_name.subsystem, (tape_name.drive), operational, device.qualifiers, ecode);
      850 	     if ^operational then do;
      851 		if ecode = 0 then
      852 		     call admin_gate_$syserr (ANNOUNCE, "RCP: ^a is not operational and will not be added.",
      853 			device_name);
      854 		else call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error surveying ^a.",
      855 			device_name);
      856 		return;
      857 	     end;
      858 	end;
      859 
      860 	call admin_gate_$ioi_add_device (device_name, ecode);
      861 	if ecode ^= 0 then do;
      862 	     call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error adding ^a.", device_name);
      863 	     return;
      864 	end;
      865 
      866 	device.state = 0;				/* Put it into the free state. */
      867 	device.unassign_state = 0;			/* And keep it there. */
      868 	device.state_time = clock ();			/* Save time device added. */
      869 
      870 	if device.dtypex = 3 then do;			/* must inform console DIM of deletion... */
      871 	     call hphcs_$ocdcm_reconfigure ((device_name), MAKE_IO_DEVICE, ecode);
      872 	     if ecode ^= 0 then do;
      873 		call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Unable to add console ^a",
      874 		     device_name);
      875 		return;
      876 	     end;
      877 	end;
      878 
      879 	call admin_gate_$syserr (ANNOUNCE, "RCP: Added device ^a", device_name);
      880 
      881      end ADD_DEVICE;
      882 
      883 ACCOUNT_ATTACH:
      884      procedure;
      885 
      886 /*	This procedure is called when an attachment is completed.  The rcp_initializer_
      887*   *	wakes the accounting process with a datum about the attachment. */
      888 
      889 	device_off = offset_message.device_off;
      890 
      891 	device_ptr = ptr (rcpd_ptr, device_off);
      892 
      893 	call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_attach);
      894 
      895      end ACCOUNT_ATTACH;
      896 
      897 UNASSIGN_DEVICE:
      898      procedure;
      899 
      900 dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
      901 
      902 /*	This procedure is called to put a device in the free state.
      903*   *	It will also compute the metering statistics kept for each device.
      904*   *	If the device was supposed to be deleted but was not because it was still
      905*   *	assigned we will delete it now.
      906**/
      907 	time_assigned = device.state_time;		/* Save time assigned. */
      908 
      909 	if device.flags.delete /* Are we waiting to delete this device? */ & device.unassign_state = 0
      910 						/* And is it about to be freed? */
      911 	then do;					/* Yes, delete it now. */
      912 	     call admin_gate_$ioi_delete_device (device_name, ignored_code);
      913 
      914 	     if device.volume_name ^= "" & device.dtypex <= 2 then do;
      915 						/* Must unload this loaded device. */
      916 		device.state = device.unassign_state;
      917 		call rcp_unload_$unload_device (device_ptr, "1"b);
      918 						/* unload volume and forget it was here */
      919 	     end;
      920 	     device.state = 2;			/* Now it is deleted. */
      921 	     device.volume_name = " ";
      922 	     if ^device.flags.priv			/* If not assigned while deleted say it is deleted now. */
      923 	     then call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device.device_name);
      924 	     device.flags.delete,			/* Turn off these flags. */
      925 		device.flags.priv = "0"b;
      926 	end;
      927 	else device.state = device.unassign_state;	/* No, unassign the device. */
      928 	device.unassign_state = 0;
      929 
      930 	if device.state ^= 4 then do;			/* Accounting for reserved devices is done at cancel time. */
      931 	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_unassign);
      932 						/* go send wakeup before clearing process_id */
      933 	     device.process_id = "0"b;		/* No longer assigned to this process. */
      934 	     device.reservation_id = 0;
      935 	     device.reserved_by = "";
      936 	     call rcp_cancel_resource_ (DEVICE_TYPE (device.dtypex), (device.device_name), ignored_code);
      937 	end;
      938 	device.state_time = clock ();			/* Time device made free. */
      939 
      940 	device.num_assigns = device.num_assigns + 1;
      941 	device.flags.mounting = "0"b;			/* Turn off mount timer for this device. */
      942 	device.flags.attached = "0"b;
      943 
      944 	time_assigned = device.state_time - time_assigned;
      945 	device.tot_assign_time = device.tot_assign_time + time_assigned;
      946 	time_assigned = divide (time_assigned, 1000000, 71, 0);
      947 	dtype_ptr = addr (rcpd.dtype (device.dtypex));
      948 
      949 	do i = 1 to hbound (dtype.histo_times, 1);	/* Find histogram slot. */
      950 	     if time_assigned < dtype.histo_times (i) then do;
      951 						/* We found the right slot. */
      952 		device.histogram (i) = device.histogram (i) + 1;
      953 		return;
      954 	     end;
      955 	end;					/* Falling through loop => use last slot. */
      956 	device.histogram (hbound (device.histogram, 1)) = device.histogram (hbound (device.histogram, 1)) + 1;
      957 
      958      end UNASSIGN_DEVICE;
      959 
      960 UNASSIGN_VOLUME:
      961      proc ();
      962 
      963 dcl	ignored_code	   fixed bin (35);		/* Ignored error code. */
      964 
      965 /*
      966*   This procedure is called to put a volume in the free or reserved
      967*   state.  The choice is made based on the volume's state at the time of
      968*   the last assignment.
      969**/
      970 
      971 	volume.state_time = clock ();			/* record the time */
      972 	volume.state = volume.unassign_state;		/* and return the volume to the proper state */
      973 	volume.unassign_state = 0;			/* reset the unassign state */
      974 	if volume.state = 0 then do;			/* if we are freeing it ... */
      975 	     volume.process_id = "0"b;		/* no process owns it now */
      976 	     volume.reserved_by = "";
      977 	     volume.reservation_id = 0;
      978 	     call rcp_cancel_resource_ (VOLUME_TYPE (volume.vtypex), (volume.volume_name), ignored_code);
      979 						/* Tell Resource Management that this volume has been turned loose. */
      980 	     if rcpd.unload_on_detach then do;		/* all done */
      981 		volume.volume_name = "";		/* no need to remember the volume_name */
      982 		volume.group_id = "";
      983 	     end;
      984 	end;
      985 	return;
      986 
      987      end UNASSIGN_VOLUME;
      988 
      989 FIND_DEVICE:
      990      procedure;
      991 
      992 /*	This procedure is called to find the device entry of the device with
      993*   *	the specified name.  We will search by device type since tapes and
      994*   *	disks are the most active types.
      995**/
      996 	do i = 1 to rcpd.tot_dtypes;			/* Look at each device type. */
      997 	     dtype_ptr = addr (rcpd.dtype (i));		/* Get pointer to device type entry. */
      998 	     device_off = dtype.first_off;		/* Start with first device type. */
      999 	     do while (device_off ^= "0"b);		/* Look at each device of this type. */
     1000 		device_ptr = ptr (rcpd_ptr, device_off);
     1001 		if device.device_name = device_name then
     1002 		     return;			/* This is the device.  Look no further. */
     1003 		device_off = device.next_off;
     1004 	     end;
     1005 	end;
     1006 
     1007 	device_off = "0"b;				/* Let caller know we didn't find device. */
     1008 
     1009      end FIND_DEVICE;
     1010 
     1011 ACCOUNT_WAKEUP:
     1012      procedure (a_devptr, a_action);
     1013 
     1014 /*	This procedure is called to format an accounting message, and send it to the
     1015*   *	accounting process.  If the accounting event channel has not been set up, no message is sent.
     1016**/
     1017 
     1018 
     1019 dcl	a_devptr		   ptr;			/* Pointer to rcp_data entry */
     1020 dcl	a_action		   fixed bin;		/* Accounting action */
     1021 
     1022 dcl	wakeup_buf	   fixed bin (71);
     1023 dcl	1 auto_rcpamsg	   like rcp_account_msg aligned;
     1024 
     1025 	unspec (auto_rcpamsg) = "0"b;
     1026 
     1027 	auto_rcpamsg.device_user_procid = a_devptr -> device.process_id;
     1028 	auto_rcpamsg.rcp_data_relp = rel (a_devptr);
     1029 	auto_rcpamsg.devtype = a_devptr -> device.dtypex;
     1030 	auto_rcpamsg.action = a_action;
     1031 
     1032 	unspec (wakeup_buf) = unspec (auto_rcpamsg);
     1033 	if rcpd.accounting_chan ^= 0 then
     1034 	     call hcs_$wakeup (rcpd.accounting_pid, rcpd.accounting_chan, wakeup_buf, (0));
     1035 
     1036      end ACCOUNT_WAKEUP;
     1037 
     1038 ss_io_interchange:
     1039      entry (a_device_name, a_add_sw, a_del_sw, a_ecode);
     1040 
     1041 /*	Entry to add and delete disk drives on demand, called from mdx in
     1042*   *	the initializer's process, in ring 1. a_add_sw is "1"b if drive is
     1043*   *	being given back to RCP.
     1044**/
     1045 
     1046 	device_name = a_device_name;
     1047 	add_sw = a_add_sw;
     1048 	del_sw = a_del_sw;
     1049 	ecode = 0;
     1050 
     1051 	on cleanup call UNLOCK;
     1052 
     1053 	rcpd_ptr = rcp_pointers_$data ();
     1054 	rcs_ptr = rcp_pointers_$com_seg ();
     1055 	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);
     1056 	if ecode ^= 0 then do;
     1057 	     a_ecode = ecode;
     1058 	     return;
     1059 	end;
     1060 
     1061 	call FIND_DEVICE;				/* Attempt to find the device */
     1062 
     1063 	if device_off = "000000"b3 then
     1064 	     ecode = error_table_$resource_unknown;
     1065 	else if dtype.device_type ^= DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
     1066 	     ecode = error_table_$invalid_state;
     1067 
     1068 	if ecode = 0 then
     1069 	     if add_sw then
     1070 		if device.state = 3 then
     1071 		     if del_sw then
     1072 			device.state = 2;		/* deleted */
     1073 		     else device.state = 0;		/* free */
     1074 		else ecode = error_table_$invalid_state;
     1075 	     else if device.state = 1 then
     1076 		ecode = error_table_$io_still_assnd;
     1077 	     else device.state = 3;
     1078 
     1079 	if ecode = 0 then do;
     1080 	     device.state_time = clock ();
     1081 	     device.volume_name = " ";
     1082 	     device.process_id = "000000000000"b3;
     1083 	     call admin_gate_$syserr (ANNOUNCE, "RCP: ^[Acquired ^a from^;Consigned ^a to^] storage system.", add_sw,
     1084 		device_name);
     1085 	end;
     1086 
     1087 	a_ecode = ecode;
     1088 	call UNLOCK;
     1089 	return;
     1090 
  1     1 /*  START OF:	opc_reconfig_options.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     4 	/*										*/
  1     5 	/* Purpose:									*/
  1     6 	/*										*/
  1     7 	/* This include file contains the possible operator console reconfiguration options. These are 	*/
  1     8 	/* passed to hphcs_$ocdcm_reconfigure to effect explicit console reconfiguration.		*/
  1     9 	/*										*/
  1    10 	/* Initial Coding:		06/18/83							*/
  1    11 	/*										*/
  1    12 	/* Author:		E. A. Ranzenbach	(Ranzenbach.Multics@M)			*/
  1    13 	/* Location:		System-M.							*/
  1    14 	/* Release:		MR10.2							*/
  1    15 	/*										*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    17 	/*										*/
  1    18 	/* Modifications:									*/
  1    19 	/*										*/
  1    20 	/* Date    Author			Reason						*/
  1    21 	/*										*/
  1    22 	/* 840420  E. A. Ranzenbach		Added MAKE_UNAVAILABLE option.			*/
  1    23 	/*										*/
  1    24 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    25 
  1    26 /* format: off */
  1    27 
  1    28      dcl	(
  1    29 	NOP			init	(0),			/* just to make sure...		*/
  1    30 	ENABLE_CONSOLE_SERVICE	init	(1),			/* allow syserr and normal I/O...	*/
  1    31 	SUSPEND_CONSOLE_SERVICE	init	(2),			/* the opposite of ENABLE...		*/
  1    32 	MAKE_BOOTLOAD_CONSOLE	init	(3),			/* make the bootload console...	*/
  1    33 	MAKE_ALTERNATE_CONSOLE	init	(4),			/* add console to alternate list...	*/
  1    34 	MAKE_IO_DEVICE		init	(5),			/* release the console to IOI...	*/
  1    35 	MAKE_INOP_DEVICE		init	(6),			/* release the console to IOI...	*/
  1    36 	RESET_CONSOLE		init	(7),			/* reset the bootload console...	*/
  1    37 	CRASH_ON_CRF		init	(8),			/* CRASH on console recovery failure... */
  1    38 	RUN_ON_CRF		init	(9),			/* RUN on console recovery failure... 	*/
  1    39 	MAKE_UNAVAILABLE		init	(10)			/* put console into the OFF state...	*/
  1    40 	)
  1    41 				fixed bin	(17)
  1    42 				internal static	options (constant);
  1    43 
  1    44 /*  END OF:	opc_reconfig_options.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1091 
  2     1 /*	Begin  include file ... rcp_data.incl.pl1
  2     2*   *
  2     3*   *	Created on 09/06/74 by Bill Silver.
  2     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  2     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  2     6*   *	It contains information about all of the devices and volumes managed by RCP.
  2     7*   *	This include file references rcp_com_seg.incl.pl1.
  2     8*
  2     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  2    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  2    11*   *	Modified on 12/09/78 to add removable media bit.
  2    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  2    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  2    14**/
  2    15 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  2    16 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  2    17 dcl  device_ptr ptr;				/* Points to a device entry. */
  2    18 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  2    19 
  2    20 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  2    21     2 lock_info like lock_info,			/* Data used to lock this segment. */
  2    22     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  2    23     2 modes like rcp_init_flags unaligned,
  2    24     2 tot_dtypes fixed bin,				/* Number of known device types. */
  2    25     2 tot_devices fixed bin,				/* Total number of devices configured. */
  2    26     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  2    27     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  2    28     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  2    29     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  2    30     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  2    31     2 accounting_pid bit (36),			/* ID of accounting process */
  2    32     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  2    33     2 pad (7) fixed bin,
  2    34     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  2    35      like dtype,					/* See structure below. */
  2    36     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  2    37      like device,					/* See structure below. */
  2    38     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  2    39      like volume,					/* See structure below. */
  2    40     2 end bit (36) aligned;				/* End of rcp_data. */
  2    41 
  2    42 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  2    43     2 device_type char (32),				/* Name of this device type. */
  2    44     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  2    45     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  2    46     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  2    47     2 first_off bit (18),				/* Offset of first device entry. */
  2    48     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  2    49 
  2    50 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  2    51     2 device_name char (8),				/* Name of device associated with this entry. */
  2    52     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  2    53     2 dtypex fixed bin,				/* Device type index. */
  2    54     2 model fixed bin,				/* Device model number. */
  2    55     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  2    56     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  2    57     2 state_time fixed bin (71),			/* Time device put into current state. */
  2    58     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  2    59*						   3 => storage system, 4 => reserved */
  2    60 
  2    61 /*	*	*	*	*	** Following fields are unique to device entry. */
  2    62 
  2    63     2 unassign_state fixed bin,			/* State to return when unassigning. */
  2    64     2 acs_name char (12),				/* Entry name of ACS for this device. */
  2    65     2 next_off bit (18),				/* Offset of next entry for this device type. */
  2    66     2 iom_num fixed bin,				/* IOM number for this device. */
  2    67     2 chan_num fixed bin,				/* Channel number for this device. */
  2    68     2 num_channels fixed bin,				/* Num channels that may address device. */
  2    69     2 flags,					/* Special info flags. */
  2    70      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  2    71       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  2    72       3 reservable bit (1),				/* ON => may be reserved for system process. */
  2    73       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  2    74       3 mounting bit (1),				/* ON => mount pending. */
  2    75       3 writing bit (1),				/* ON => mounting for writing. */
  2    76       3 attached bit (1) unal,			/* ON => device is attached. */
  2    77       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  2    78       3 unused bit (28)) unal,
  2    79     2 process_id bit (36),				/* ID of assigned process. */
  2    80     2 group_id char (32),				/* Process group ID. */
  2    81     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  2    82     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  2    83     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  2    84     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  2    85     2 reservation_id fixed bin (71),
  2    86     2 reserved_by char (32),				/* Who made this reservation. */
  2    87     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  2    88 
  2    89 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  2    90     2 process_id bit (36),				/* "0"b => unassigned. */
  2    91     2 volume_name char (32),				/* Volume name. */
  2    92     2 vtypex fixed bin,				/* Volume type index. */
  2    93     2 group_id char (32),				/* This is used for the reserved_for field. */
  2    94     2 reserved_by char (32),
  2    95     2 reservation_id fixed bin (71),
  2    96     2 state_time fixed bin (71),			/* Same as for a device. */
  2    97     2 state fixed bin,				/* Same as for a device. */
  2    98     2 unassign_state fixed bin,			/* State to return when unassigning. */
  2    99     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  2   100 
  3     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  3     2 
  3     3 /* Created on 04/24/78 by Michael R. Jordan */
  3     4 /* Modified 04/10/79 by C. D. Tavares */
  3     5 
  3     6 dcl  rifp ptr;
  3     7 
  3     8 dcl 1 rcp_init_flags based (rifp),
  3     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  3    10     2 pad1 bit (2) unaligned,				/* obsolete */
  3    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  3    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  3    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  3    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  3    15 
  3    16 dcl (No_authentication initial (0),
  3    17      Nominal_authentication initial (1),
  3    18      Automatic_authentication initial (2),
  3    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  3    20 
  3    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  3    22     ("none", "nominal", "automatic", "manual");
  3    23 
  3    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  2   101 
  2   102 
  2   103 /*	End of include file ... rcp_data.incl.pl1	*/
     1092 
  4     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  4     2*   *
  4     3*   *	Created on 11/20/74 by Bill Silver.
  4     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  4     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  4     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  4     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  4     8*   *	This include file defines the Resource Control Package communication segment.
  4     9*   *	This segment is used to communicate requests between the various internal
  4    10*   *	parts of RCP.
  4    11**/
  4    12 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  4    13 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  4    14 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  4    15 
  4    16 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  4    17    (2 id_count fixed bin (17),			/* Unique count index. */
  4    18     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  4    19 
  4    20 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  4    21     2 lock_info like lock_info,			/* Data used to lock this segment. */
  4    22     2 ws_maxs (7) fixed bin (19),			/* Max IOI workspace size in words. */
  4    23     2 ws_pmaxs (7) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  4    24     2 to_maxs (7) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  4    25     2 sys_directory char (32),			/* Directory  used to define a system process. */
  4    26     2 sys_acs char (32),				/* Entry name used to define a system process. */
  4    27     2 acs_directory char (32),			/* Directory containing device ACSs. */
  4    28     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  4    29     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  4    30     2 num_entries fixed bin,				/* Total number of entries. */
  4    31     2 first_free_off bit (18),			/* Offset of first free entry. */
  4    32     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  4    33      like rcse,					/* See structure below. */
  4    34     2 end bit (36);					/* End of rcp_com_seg. */
  4    35 
  4    36 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  4    37     2 lock bit (36),				/* The lock itself. */
  4    38     2 num_locks fixed bin (35),			/* Number of times locked. */
  4    39     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  4    40     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  4    41     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  4    42     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  4    43     2 starting_time fixed bin (71);			/* Time metering started. */
  4    44 
  4    45 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  4    46     2 device_name char (8),				/* Name of device associated with this entry. */
  4    47     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  4    48     2 dtypex fixed bin,				/* Device type index. */
  4    49     2 model fixed bin,				/* Device model number. */
  4    50     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  4    51     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  4    52     2 state_time fixed bin (71),			/* Time device put into current state. */
  4    53     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  4    54 						/* 3 - attaching  4 - attached   5 - completed. */
  4    55 
  4    56 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  4    57     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  4    58     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  4    59     2 user_off bit (18),				/* Offset of next entry in user list. */
  4    60     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  4    61     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  4    62     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  4    63     2 caller_level fixed bin,				/* Caller's validation level. */
  4    64     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  4    65     2 flags,					/* Special info flags. */
  4    66      (3 device bit (1),				/* ON => assigning a specific device. */
  4    67       3 priv bit (1),				/* ON => attached with IOI privilege. */
  4    68       3 system bit (1),				/* ON => assigned to a system process. */
  4    69       3 t_and_d bit (1),				/* ON => T&D attachment. */
  4    70       3 volume bit (1),				/* ON => volume associated with this device. */
  4    71       3 writing bit (1),				/* ON => writing on volume. */
  4    72       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  4    73       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  4    74       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  4    75       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  4    76       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  4    77       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  4    78       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  4    79       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  4    80       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  4    81       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  4    82       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  4    83       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  4    84       3 unused bit (9),
  4    85       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  4    86       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  4    87     2 rcp_id bit (36),				/* ID of this entry. */
  4    88     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  4    89     2 process_id bit (36),				/* ID of calling process. */
  4    90     2 group_id char (32),				/* Group ID of calling process. */
  4    91     2 ecode fixed bin (35),				/* Assignment error code. */
  4    92     2 version_num fixed bin,				/* Device info version number. */
  4    93     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  4    94     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  4    95     2 ioi_index fixed bin,				/* IOI device index. */
  4    96     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  4    97     2 caller_comment char (64);			/* Caller's comment. */
  4    98 
  4    99 /*	End of include file ... rcp_com_seg.incl.pl1	*/
     1093 
  5     1 /* BEGIN INCLUDE FILE rcp_account_msg.incl.pl1    B. Greenberg 8/1/77 */
  5     2 
  5     3 dcl 1 rcp_account_msg based aligned,			/* Message format */
  5     4     2 device_user_procid bit (36),			/* id of process using the device */
  5     5 
  5     6     2 rcp_data_relp bit (18) unal,			/* Ptr to rcp_data entry for device */
  5     7     2 devtype fixed bin (8) unal,			/* rcp device type involved */
  5     8     2 pad bit (6) unal,
  5     9     2 action fixed bin (2) unal;			/* see below... */
  5    10 
  5    11 dcl (
  5    12      RCP_ACCTMSG_assign init (0),
  5    13      RCP_ACCTMSG_unassign init (1),
  5    14      RCP_ACCTMSG_attach init (2)
  5    15      ) options (constant) fixed bin (17) static;
  5    16 
  5    17 /* END INCLUDE FILE rcp_account_msg.incl.pl1 */
     1094 
  6     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  6     2*   *
  6     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  6     4*   *
  6     5*   *	This include file defines the official RCP resource types.
  6     6*   *	The array of names is indexed by the corresponding device type.
  6     7*   *
  6     8**/
  6     9 
  6    10 
  6    11 dcl  DEVICE_TYPE (7) char (32)
  6    12      internal static options (constant)
  6    13      init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special");
  6    14 
  6    15 dcl  NUM_QUALIFIERS (7) fixed bin			/* Number of qualifiers for each device type. */
  6    16      internal static init (3, 0, 0, 2, 0, 0, 0);
  6    17 
  6    18 dcl  VOLUME_TYPE (7) char (32)
  6    19      internal static options (constant)
  6    20      init ("tape_vol", "disk_vol", "", "", "", "", "");
  6    21 
  6    22 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  6    23 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  6    24 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  6    25 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  6    26 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  6    27 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  6    28 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  6    29 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  6    30 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  6    31 
  6    32 
  6    33 /*	End include file ... rcp_resource_types.incl.pl1 */
     1095 
  7     1 /*	Begin  include file ... rcp_message.incl.pl1
  7     2*   *
  7     3*   *	Created on 12/03/74 by Bill Silver.
  7     4*   *	This include file defines the various forms of the event message
  7     5*   *	sent to rcp_initializer_.
  7     6*   *
  7     7*   *	Accounting changes 8/2/77 by B. Greenberg.
  7     8**/
  7     9 
  7    10 dcl  message_ptr ptr;				/* Pointer to event message. */
  7    11 
  7    12 dcl (assign_actionx init (1),
  7    13      error_actionx init (2),
  7    14      unassign_actionx init (3),
  7    15      force_actionx init (4),
  7    16      proc_actionx init (5),
  7    17      delete_actionx init (6),
  7    18      add_actionx init (7),
  7    19      attach_acct_actionx init (8)) fixed bin internal static options (constant);
  7    20 
  7    21 dcl 1 offset_message based (message_ptr) aligned,		/* Info contained in IPC message. */
  7    22    (2 actionx fixed bin (8),				/* Action that must be performed. */
  7    23     2 pad bit (9),
  7    24     2 error_count fixed bin (17),			/* Number of errors during attachment. */
  7    25     2 volume_off bit (18),				/* Offset of RCS or RCPD volume entry. */
  7    26     2 device_off bit (18)) unal;			/* Offset of RCS or RCPD device entry. */
  7    27 
  7    28 dcl 1 name_message based (message_ptr) aligned,		/* Info contained in IPC message. */
  7    29    (2 actionx fixed bin (8),				/* Action index. */
  7    30     2 device_name char (7)) unal;			/* Device name. */
  7    31 
  7    32 dcl 1 id_message based (message_ptr) aligned,		/* Info contained in IPC message. */
  7    33    (2 actionx fixed bin (8),				/* Action index. */
  7    34     2 pad bit (27)) unal,
  7    35     2 process_id bit (36);				/* Action on behalf of this process. */
  7    36 
  7    37 /*	End of include file ... rcp_message.incl.pl1	*/
     1096 
  8     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  8     2 
  8     3 dcl (CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  8     4      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  8     5      BEEP 		init (3), 		/* Beep and print the message on the console. */
  8     6      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  8     7      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  8     8      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  8     9 
  8    10      AIM_MESSAGE		init (20) 		/* Added to normal severities to indicate an AIM message */
  8    11 	) fixed bin internal static options (constant);
  8    12 
  8    13 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     1097 
     1098 
     1099 /* BEGIN MESSAGE DOCUMENTATION
     1100*
     1101*   Message:
     1102*   RCP: Acquired DEVICE from storage system.
     1103*
     1104*   S:	$info
     1105*
     1106*   T:	$response
     1107*
     1108*   M:	The operator has used the set_drive_usage command to make
     1109*   DRIVE an IO drive.
     1110*
     1111*   A:	$ignore
     1112*
     1113*
     1114*   Message:
     1115*   RCP: Added device DEVICE
     1116*
     1117*   S:	$info
     1118*
     1119*   T:	$response
     1120*
     1121*   M:	The operator has added a user I/O disk drive with adddev.
     1122*
     1123*   A:	$ignore
     1124*
     1125*
     1126*   Message:
     1127*   RCP: Assigned DEVICE to PERSON.PROJ.T
     1128*
     1129*   S:	$log
     1130*
     1131*   T:	$run
     1132*
     1133*   M:	DEVICE has been assigned to a user process.
     1134*
     1135*   A:	$ignore
     1136*
     1137*
     1138*   Message:
     1139*   RCP: Consigned DEVICE to storage system.
     1140*
     1141*   S:	$info
     1142*
     1143*   T:	$response
     1144*
     1145*   M:	The operator has used the set_drive_usage command to make DRIVE a storage system drive.
     1146*
     1147*   A:	$ignore
     1148*
     1149*
     1150*   Message:
     1151*   RCP: Deleted device DEVICE
     1152*
     1153*   S:	$info
     1154*
     1155*   T:	$response
     1156*
     1157*   M:	The operator has deleted user I/O disk DRIVE with deldev.
     1158*
     1159*   A:	$ignore
     1160*
     1161*
     1162*   Message:
     1163*   RCP: Force Unassigned DEVICE from PERSON.PROJ.T
     1164*
     1165*   S:	$info
     1166*
     1167*   T:	$run
     1168*
     1169*   M:	The user process PERSON.PROJ.T has terminated,
     1170*   and its resources have been freed.
     1171*   Or, the operator may have forced the unassignment of DRIVE.
     1172*
     1173*   A:	$ignore
     1174*
     1175*
     1176*   Message:
     1177*   RCP: Unassigned DEVICE from PERSON.PROJ.T
     1178*
     1179*   S:	$log
     1180*
     1181*   T:	$run
     1182*
     1183*   M:	PERSON.PROJ.T has released DRIVE normally.
     1184*
     1185*   A:	$ignore
     1186*
     1187*
     1188*   Message:
     1189*   RCP: DEVICE is not operational and has not been added.
     1190*
     1191*   S:	$info
     1192*
     1193*   T:	$response
     1194*
     1195*   M:	An attempt was made to add a non-operational device with adddev.
     1196*
     1197*   A:	Ready the device and add it again.
     1198*
     1199*
     1200*   Message:
     1201*   rcp_initializer_: Error surveying DEVICE. MESSAGE
     1202*
     1203*   S:	$info
     1204*
     1205*   T:	$response
     1206*
     1207*   M:	An error occurred while surveying the device.
     1208*
     1209*   A:	$notify
     1210*
     1211*
     1212*   END MESSAGE DOCUMENTATION */
     1213 
     1214      end rcp_initializer_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/04/84  1657.1  rcp_initializer_.pl1              >special_ldd>temp>bce>40-00>rcp_initializer_.pl1
1091         1    06/01/84  1101.6  opc_reconfig_options.incl.pl1     >special_ldd>temp>bce>40-00>opc_reconfig_options.incl.pl1
1092         2    11/21/79  1458.3  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
2-101        3    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
1093         4    11/21/79  1458.3  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
1094         5    11/09/77  0713.6  rcp_account_msg.incl.pl1          >ldd>include>rcp_account_msg.incl.pl1
1095         6    11/21/79  1509.5  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
1096         7    11/09/77  0713.6  rcp_message.incl.pl1              >ldd>include>rcp_message.incl.pl1
1097         8    03/27/82  0430.3  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000216 constant        fixed bin(17,0)          initial dcl 8-3 set ref 720* 792* 808* 814* 851*
                                                                                  854* 862* 873* 879* 922* 1083*
DEVICE_TYPE                     000105 constant        char(32)                 initial array unaligned dcl 6-11 set ref 586* 936*
                                                                                  1065
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-23 ref 1065
LOG                             000225 constant        fixed bin(17,0)          initial dcl 8-3 set ref 541* 699* 761*
MAKE_IO_DEVICE                  000217 constant        fixed bin(17,0)          initial dcl 1-28 set ref 871*
MAKE_UNAVAILABLE                000220 constant        fixed bin(17,0)          initial dcl 1-28 set ref 806*
NULL                                   constant        bit(3)                   initial unaligned dcl 96 ref 391 495
R                                      constant        bit(3)                   initial unaligned dcl 97 ref 387
RCP_ACCTMSG_assign                     constant        fixed bin(17,0)          initial dcl 5-11 set ref 527*
RCP_ACCTMSG_attach                     constant        fixed bin(17,0)          initial dcl 5-11 set ref 893*
RCP_ACCTMSG_unassign                   constant        fixed bin(17,0)          initial dcl 5-11 set ref 931*
REW                                    constant        bit(3)                   initial unaligned dcl 98 ref 378
RW                                     constant        bit(3)                   initial unaligned dcl 99 ref 385 588 588
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 6-22 ref 846
VOLUME_TYPE                     000015 constant        char(32)                 initial array unaligned dcl 6-18 set ref 370* 493*
                                                                                  978*
a_action                               parameter       fixed bin(17,0)          dcl 1020 ref 1011 1030
a_add_sw                               parameter       bit(1)                   dcl 50 ref 1038 1047
a_del_sw                               parameter       bit(1)                   dcl 51 ref 1038 1048
a_device_name                          parameter       char                     unaligned dcl 52 ref 1038 1046
a_devptr                               parameter       pointer                  dcl 1019 ref 1011 1027 1028 1029
a_ecode                                parameter       fixed bin(35,0)          dcl 53 set ref 1038 1057* 1087*
access                          000100 automatic       bit(3)                   dcl 59 set ref 327* 331* 368 370* 378* 389 391 493*
                                                                                  495 586* 588
access_needed                   000101 automatic       bit(3)                   unaligned dcl 60 set ref 385* 387* 389 389
accessible_flag                 000102 automatic       bit(1)                   unaligned dcl 61 set ref 588* 591* 594
accounting_chan          26            based           fixed bin(71,0)          level 2 dcl 2-20 set ref 1033 1033*
accounting_pid           30            based           bit(36)                  level 2 dcl 2-20 set ref 1033*
action                    1(33) 000440 automatic       fixed bin(2,0)           level 2 packed unaligned dcl 1023 set ref 1030*
actionx                                based           fixed bin(8,0)           level 2 packed unaligned dcl 7-21 ref 190
add_sw                          000103 automatic       bit(1)                   unaligned dcl 62 set ref 1047* 1068 1083*
addr                                                   builtin function         dcl 111 ref 176 186 186 234 234 279 339 362 439 487
                                                                                  487 727 747 756 947 997 1055 1055
admin_gate_$ioi_add_device      000030 constant        entry                    external dcl 144 ref 517 860
admin_gate_$ioi_delete_device   000032 constant        entry                    external dcl 146 ref 790 912
admin_gate_$syserr              000034 constant        entry                    external dcl 148 ref 541 699 720 761 814 851 879 922
                                                                                  1083
admin_gate_$syserr_error_code   000036 constant        entry                    external dcl 149 ref 792 808 854 862 873
arg_message                            parameter       fixed bin(71,0)          dcl 48 ref 12 175
attached                 35(06)        based           bit(1)                   level 3 packed unaligned dcl 2-50 set ref 942*
auto_rcpamsg                    000440 automatic       structure                level 1 dcl 1023 set ref 1025* 1032
auto_registration        14(05)        based           bit(1)                   level 3 packed unaligned dcl 2-20 ref 373
available_flag                  000104 automatic       bit(1)                   unaligned dcl 63 set ref 567* 570* 573* 579* 597
available_list                  000106 automatic       pointer                  array dcl 64 set ref 479 481* 481 487 487 600* 636
                                                                                  639*
caller_level             33            based           fixed bin(17,0)          level 2 dcl 4-45 set ref 370* 441 493* 586*
cleanup                         000224 stack reference condition                dcl 105 ref 181 1051
clock                                                  builtin function         dcl 112 ref 405 521 803 868 938 971 1080
current_authorization
                         72            based           bit(72)                  level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 523*
current_authorization
                         40            based           bit(72)                  level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 412*
del_sw                          000146 automatic       bit(1)                   dcl 65 set ref 1048* 1068
delete                   35            based           bit(1)                   level 3 packed unaligned dcl 2-50 set ref 518* 786*
                                                                                  841* 909 924*
dev_rcse_off                    000147 automatic       bit(18)                  unaligned dcl 66 set ref 246* 258 273 437
device                                 based           structure                level 1 dcl 2-50 in procedure "rcp_initializer_"
device                                 based           structure                array level 2 in structure "rcpd" dcl 2-20
                                                                                  in procedure "rcp_initializer_" set ref 756
device_name               0(09)        based           char(7)                  level 2 in structure "name_message" packed unaligned
                                                                                  dcl 7-28 in procedure "rcp_initializer_" ref 711
                                                                                  776 835
device_name                            based           char(8)                  level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 532*
device_name                     000150 automatic       char(32)                 unaligned dcl 67 in procedure "rcp_initializer_" set
                                                                                  ref 711* 720* 776* 790* 792* 806 808* 814* 835*
                                                                                  848 851* 854* 860* 862* 871 873* 879* 912* 1001
                                                                                  1046* 1083*
device_name                            based           char(8)                  level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 517 532 541* 586 699*
                                                                                  761* 922* 936 1001
device_off                1(18)        based           bit(18)                  level 2 in structure "offset_message" packed
                                                                                  unaligned dcl 7-21 in procedure "rcp_initializer_"
                                                                                  ref 246 657 680 889
device_off                      000160 automatic       bit(18)                  unaligned dcl 68 in procedure "rcp_initializer_" set
                                                                                  ref 299* 300 301 308* 448* 449 450 452* 488* 531
                                                                                  680* 691 694 714 779 838 889* 891 998* 999 1000
                                                                                  1003* 1007* 1063
device_off               30            based           bit(18)                  level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 277 531*
device_ptr                      000236 automatic       pointer                  dcl 2-17 set ref 277* 278 282 290 298 301* 302 303*
                                                                                  305 308 450* 452 487* 488 491 493 493 497 501 503
                                                                                  508 510 511 512 512 514 515 517 518 518 521 522
                                                                                  522 523 525 527 527* 532 533 534 535 541 541 552
                                                                                  562 565 570 576 581* 586 586 600 601 636* 637 639
                                                                                  657* 659 662 665 665 694* 695 697 697 699 699 717
                                                                                  720 723 728 756* 757 759 761 761 782 784 784 786
                                                                                  796 796 796* 800 801 802 803 805 841 843 846 846
                                                                                  849 866 867 868 870 891* 893* 907 909 909 914 914
                                                                                  916 916 917* 920 921 922 922 924 924 927 927 928
                                                                                  930 931* 933 934 935 936 936 938 940 940 941 942
                                                                                  944 945 945 947 952 952 956 956 956 956 1000* 1001
                                                                                  1003 1068 1068 1073 1075 1077 1080 1081 1082
device_type                            based           char(32)                 level 2 dcl 2-42 ref 1065
device_user_procid              000440 automatic       bit(36)                  level 2 dcl 1023 set ref 1027*
devtype                   1(18) 000440 automatic       fixed bin(8,0)           level 2 packed unaligned dcl 1023 set ref 1029*
divide                                                 builtin function         dcl 113 ref 946
drive                     1(09) 000370 automatic       picture(2)               level 2 packed unaligned dcl 830 set ref 849
dtype                    43            based           structure                array level 2 in structure "rcpd" dcl 2-20
                                                                                  in procedure "rcp_initializer_" set ref 279 439
                                                                                  947 997
dtype                                  based           structure                level 1 dcl 2-42 in procedure "rcp_initializer_"
dtype_ptr                       000234 automatic       pointer                  dcl 2-16 set ref 279* 299 439* 448 622 628 631 947*
                                                                                  949 950 997* 998 1065
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" ref 370 402 438
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" ref 278 493 586 796 805 846 870
                                                                                  914 936 947 1029
dtypex                          000161 automatic       fixed bin(17,0)          dcl 69 in procedure "rcp_initializer_" set ref 278*
                                                                                  279 438* 439
ecode                    53            based           fixed bin(35,0)          level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 253* 261*
ecode                           000162 automatic       fixed bin(35,0)          dcl 70 in procedure "rcp_initializer_" set ref 179*
                                                                                  186* 187 253 254 261 267 331* 332 344* 357* 370*
                                                                                  372 373 379* 391* 394* 457* 463* 469* 474 493* 495
                                                                                  499* 586* 588 592* 624* 646* 790* 791 792* 806*
                                                                                  807 808* 849* 851 854* 860* 861 862* 871* 872 873*
                                                                                  1049* 1055* 1056 1057 1063* 1065* 1068 1074* 1075*
                                                                                  1079 1087
error_count              47            based           fixed bin(35,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 665* 665 697* 697
error_count               0(18)        based           fixed bin(17,0)          level 2 in structure "offset_message" packed
                                                                                  unaligned dcl 7-21 in procedure "rcp_initializer_"
                                                                                  ref 665 697
error_table_$device_limit_exceeded
                                000010 external static fixed bin(35,0)          dcl 124 ref 624
error_table_$insufficient_access
                                000012 external static fixed bin(35,0)          dcl 126 ref 394
error_table_$invalid_state      000014 external static fixed bin(35,0)          dcl 128 ref 1065 1074
error_table_$io_still_assnd     000016 external static fixed bin(35,0)          dcl 130 ref 1075
error_table_$notalloc           000020 external static fixed bin(35,0)          dcl 132 ref 357
error_table_$resource_bad_access
                                000022 external static fixed bin(35,0)          dcl 133 ref 391 463
error_table_$resource_unavailable
                                000024 external static fixed bin(35,0)          dcl 135 ref 344 469 646
error_table_$resource_unknown   000026 external static fixed bin(35,0)          dcl 137 ref 373 457 1063
first_off                13            based           bit(18)                  level 2 dcl 2-42 ref 299 448 998
flags                    35            based           structure                level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_"
flags                    35            based           structure                level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_"
get_authorization_              000072 constant        entry                    external dcl 166 ref 412 523
get_process_id_                 000040 constant        entry                    external dcl 151 ref 662 682
group_id                 43            based           char(32)                 level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 370 407 441 493 501*
                                                                                  511 586
group_id                 37            based           char(32)                 level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 501* 511* 541* 699*
                                                                                  720* 761*
group_id                 12            based           char(32)                 level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 407* 982*
hbound                                                 builtin function         dcl 114 ref 949 956 956
hcs_$wakeup                     000042 constant        entry                    external dcl 152 ref 1033
histo_times              14            based           fixed bin(17,0)          array level 2 dcl 2-42 ref 949 950
histogram                54            based           fixed bin(17,0)          array level 2 dcl 2-50 set ref 952* 952 956* 956 956
                                                                                  956
hphcs_$ocdcm_reconfigure        000044 constant        entry                    external dcl 153 ref 806 871
i                               000163 automatic       fixed bin(17,0)          dcl 71 set ref 338* 339* 478* 479 481* 534* 535 535*
                                                                                  635* 636* 726* 727* 746* 747* 755* 756* 949* 950
                                                                                  952 952* 996* 997*
id_message                             based           structure                level 1 dcl 7-32
ignored_code                    000406 automatic       fixed bin(35,0)          dcl 900 in procedure "UNASSIGN_DEVICE" set ref 912*
                                                                                  936*
ignored_code                    000274 automatic       fixed bin(35,0)          dcl 425 in procedure "ASSIGN_DEVICE" set ref 517*
ignored_code                    000416 automatic       fixed bin(35,0)          dcl 963 in procedure "UNASSIGN_VOLUME" set ref 978*
j                               000164 automatic       fixed bin(17,0)          dcl 72 set ref 477* 480* 480 481 484
last_volume              20            based           fixed bin(17,0)          level 2 dcl 2-20 set ref 338 354 361* 361 362 726
                                                                                  746
lock_info                              based           structure                level 1 dcl 4-36 in procedure "rcp_initializer_"
lock_info                              based           structure                level 2 in structure "rcpd" dcl 2-20 in procedure
                                                                                  "rcp_initializer_" set ref 186 186 234 234 1055
                                                                                  1055
match_flag                      000165 automatic       bit(1)                   unaligned dcl 73 set ref 581* 583
max_concurrent           10            based           fixed bin(17,0)          level 2 dcl 2-42 ref 622
message                         000166 automatic       fixed bin(71,0)          dcl 74 set ref 175* 176
message_ptr                     000246 automatic       pointer                  dcl 7-10 set ref 176* 190 245 246 657 665 679 680
                                                                                  697 711 744 776 835 889
model                    13            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 533*
model                    13            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" ref 533
modes                    14(01)        based           structure                level 2 packed unaligned dcl 2-20
mounting                 35(04)        based           bit(1)                   level 3 packed unaligned dcl 2-50 set ref 941*
must_auto_register       35(17)        based           bit(1)                   level 3 packed unaligned dcl 4-45 set ref 376*
name_message                           based           structure                level 1 dcl 7-28
next_off                 31            based           bit(18)                  level 2 dcl 2-50 ref 308 452 1003
not_removable_media      35(11)        based           bit(1)                   level 3 in structure "rcse" packed unaligned
                                                                                  dcl 4-45 in procedure "rcp_initializer_" set ref
                                                                                  508*
not_removable_media      35(07)        based           bit(1)                   level 3 in structure "device" packed unaligned
                                                                                  dcl 2-50 in procedure "rcp_initializer_" ref 508
num_accessible                  000170 automatic       fixed bin(17,0)          dcl 75 set ref 446* 461 594* 594
num_appropriate                 000171 automatic       fixed bin(17,0)          dcl 76 set ref 446* 455 583* 583
num_assigned                    000172 automatic       fixed bin(17,0)          dcl 77 set ref 444* 562* 562 622
num_assigns              50            based           fixed bin(35,0)          level 2 dcl 2-50 set ref 940* 940
num_avail_nres                  000173 automatic       fixed bin(17,0)          dcl 78 set ref 634* 639 640* 640 643
num_available                   000174 automatic       fixed bin(17,0)          dcl 79 set ref 446* 467 478 484* 487* 597* 597 600
                                                                                  635 643* 644
num_free_res                    000175 automatic       fixed bin(17,0)          dcl 80 set ref 444* 576* 576 631
num_qualifiers           14            based           fixed bin(17,0)          level 2 dcl 2-50 ref 534
num_reserved                    000176 automatic       fixed bin(17,0)          dcl 81 in procedure "rcp_initializer_" set ref 444*
                                                                                  565* 565 628 631
num_reserved             11            based           fixed bin(17,0)          level 2 in structure "dtype" dcl 2-42 in procedure
                                                                                  "rcp_initializer_" ref 628 631
num_resvd                       000177 automatic       fixed bin(17,0)          dcl 82 set ref 444* 476 601* 601 619
offset_message                         based           structure                level 1 dcl 7-21
operational                     000366 automatic       bit(1)                   dcl 829 set ref 849* 850
preload_allowed          35(09)        based           bit(1)                   level 3 packed unaligned dcl 4-45 set ref 507*
priv                     35(01)        based           bit(1)                   level 3 in structure "device" packed unaligned
                                                                                  dcl 2-50 in procedure "rcp_initializer_" set ref
                                                                                  518* 922 924*
priv                     35(01)        based           bit(1)                   level 3 in structure "rcse" packed unaligned
                                                                                  dcl 4-45 in procedure "rcp_initializer_" ref 557
process_id                             based           bit(36)                  level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 341 401* 687 748 975*
process_id                1            based           bit(36)                  level 2 in structure "id_message" dcl 7-32
                                                                                  in procedure "rcp_initializer_" ref 744
process_id               36            based           bit(36)                  level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 510* 562 570 662 695
                                                                                  757 801* 933* 1027 1082*
process_id                      000200 automatic       bit(36)                  unaligned dcl 83 in procedure "rcp_initializer_" set
                                                                                  ref 682* 687 695 744* 748 757
process_id               42            based           bit(36)                  level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" ref 341 401 510 562 570
ptr                                                    builtin function         dcl 115 ref 275 276 277 301 326 400 437 450 657 686
                                                                                  694 891 1000
qualifiers               15            based           fixed bin(35,0)          array level 2 in structure "device" dcl 2-50
                                                                                  in procedure "rcp_initializer_" set ref 535 846
                                                                                  849*
qualifiers               15            based           fixed bin(35,0)          array level 2 in structure "rcse" dcl 4-45
                                                                                  in procedure "rcp_initializer_" set ref 535*
rcp_account_msg                        based           structure                level 1 dcl 5-3
rcp_cancel_resource_            000076 constant        entry                    external dcl 169 ref 936 978
rcp_check_access_               000046 constant        entry                    external dcl 155 ref 370 493 586
rcp_data_relp             1     000440 automatic       bit(18)                  level 2 packed unaligned dcl 1023 set ref 1028*
rcp_get_scratch_volume_         000074 constant        entry                    external dcl 167 ref 331
rcp_init_flags                         based           structure                level 1 packed unaligned dcl 3-8
rcp_lock_$lock                  000050 constant        entry                    external dcl 156 ref 186 1055
rcp_lock_$unlock                000052 constant        entry                    external dcl 157 ref 234
rcp_match_$match                000054 constant        entry                    external dcl 158 ref 581
rcp_match_$select               000056 constant        entry                    external dcl 159 ref 487
rcp_match_user_name_            000060 constant        entry                    external dcl 160 ref 501
rcp_pointers_$com_seg           000062 constant        entry                    external dcl 161 ref 178 1054
rcp_pointers_$data              000064 constant        entry                    external dcl 162 ref 177 1053
rcp_tape_survey_                000066 constant        entry                    external dcl 163 ref 849
rcp_unload_$unload_device       000070 constant        entry                    external dcl 164 ref 303 796 917
rcpd                                   based           structure                level 1 dcl 2-20
rcpd_ptr                        000232 automatic       pointer                  dcl 2-15 set ref 177* 186 186 234 234 277 279 301
                                                                                  338 339 354 354 361 361 362 362 373 400 439 450
                                                                                  492 507 657 686 694 726 727 746 747 755 756 891
                                                                                  947 980 996 997 1000 1033 1033 1033 1053* 1055
                                                                                  1055
rcs_ptr                         000242 automatic       pointer                  dcl 4-13 set ref 178* 275 276 326 437 1054*
rcse                                   based           structure                level 1 dcl 4-45
rcse_off                 32            based           bit(18)                  level 2 dcl 4-45 ref 276
rcse_ptr                        000244 automatic       pointer                  dcl 4-14 set ref 253 261 275* 276* 276 277 284 326*
                                                                                  328 328 331* 334 341 370 370 370 370 376 385 401
                                                                                  402 407 415 417 418 437* 438 440 441 441 487 490
                                                                                  493 493 496 497 501 502 503 507 508 510 511 530
                                                                                  531 532 533 535 537 557 562 570 581* 586 586
rel                                                    builtin function         dcl 116 ref 341 348 362 488 1028
reservable               35(02)        based           bit(1)                   level 3 packed unaligned dcl 2-50 ref 512 576 637
reservation_id           32            based           fixed bin(71,0)          level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 410* 977*
reservation_id           60            based           fixed bin(71,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 934*
reserved                 35(03)        based           bit(1)                   level 3 packed unaligned dcl 2-50 set ref 512* 514*
                                                                                  565
reserved_by              22            based           char(32)                 level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 409* 976*
reserved_by              62            based           char(32)                 level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 935*
resource_mgmt_enabled
                         14(04)        based           bit(1)                   level 3 packed unaligned dcl 2-20 ref 492
save_device_ptr                 000202 automatic       pointer                  dcl 84 set ref 298* 311
state                    24            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 479 515 522 525* 552
                                                                                  601 659 717 782 784 784 802* 843 866* 916* 920*
                                                                                  927* 930 1068 1068* 1073* 1075 1077*
state                    36            based           fixed bin(17,0)          level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 341 341 348 403 404*
                                                                                  972* 974
state                    24            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 417* 530*
state_time               34            based           fixed bin(71,0)          level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 405* 971*
state_time               22            based           fixed bin(71,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 521* 803* 868* 907 938*
                                                                                  944 1080*
string                                                 builtin function         dcl 117 set ref 848*
subsystem                       000370 automatic       char(4)                  level 2 packed unaligned dcl 830 set ref 849*
system                   35(02)        based           bit(1)                   level 3 packed unaligned dcl 4-45 set ref 440 537*
system_flag                     000204 automatic       bit(1)                   unaligned dcl 85 set ref 440* 441* 512 537 616
tape_name                       000370 automatic       structure                level 1 packed unaligned dcl 830 set ref 848*
time_assigned                   000206 automatic       fixed bin(71,0)          dcl 86 set ref 907* 944* 944 945 946* 946 950
tot_assign_time          52            based           fixed bin(71,0)          level 2 dcl 2-50 set ref 945* 945
tot_devices              16            based           fixed bin(17,0)          level 2 dcl 2-20 ref 339 362 727 747 755
tot_dtypes               15            based           fixed bin(17,0)          level 2 dcl 2-20 ref 339 362 727 747 756 996
tot_volumes              17            based           fixed bin(17,0)          level 2 dcl 2-20 ref 354
unassign_state           25            based           fixed bin(17,0)          level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 522* 527 759* 867* 909
                                                                                  916 927 928*
unassign_state           37            based           fixed bin(17,0)          level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 403* 408 750* 972 973*
unload_on_detach         14(01)        based           bit(1)                   level 3 packed unaligned dcl 2-20 ref 507 980
unspec                                                 builtin function         dcl 118 set ref 1025* 1032* 1032
vol_rcse_off                    000210 automatic       bit(18)                  unaligned dcl 87 set ref 245* 250 275 326
volume                                 based           structure                array level 2 in structure "rcpd" dcl 2-20
                                                                                  in procedure "rcp_initializer_" set ref 339 362
                                                                                  727 747
volume                   35(04)        based           bit(1)                   level 3 in structure "rcse" packed unaligned
                                                                                  dcl 4-45 in procedure "rcp_initializer_" set ref
                                                                                  490* 496* 502*
volume                                 based           structure                level 1 dcl 2-89 in procedure "rcp_initializer_"
volume_flag                     000211 automatic       bit(1)                   unaligned dcl 88 set ref 248* 264 416*
volume_name               2            based           char(32)                 level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 284* 328 328 334* 370
                                                                                  415 487* 497* 503*
volume_name                     000212 automatic       char(32)                 unaligned dcl 89 in procedure "rcp_initializer_" set
                                                                                  ref 282 284 288 302 311 328* 331* 334 340 343 406
                                                                                  415*
volume_name               1            based           char(32)                 level 2 in structure "volume" dcl 2-89 in procedure
                                                                                  "rcp_initializer_" set ref 340 348 406* 728 978
                                                                                  981*
volume_name               2            based           char(32)                 level 2 in structure "device" dcl 2-50 in procedure
                                                                                  "rcp_initializer_" set ref 282 290* 302 305* 311*
                                                                                  491 493 497 503 723 728 796 800* 914 921* 1081*
volume_off                1            based           bit(18)                  level 2 in structure "offset_message" packed
                                                                                  unaligned dcl 7-21 in procedure "rcp_initializer_"
                                                                                  ref 245 679
volume_off                      000222 automatic       bit(18)                  unaligned dcl 90 in procedure "rcp_initializer_" set
                                                                                  ref 336* 341* 348 348* 354 362* 400 418 679* 684
                                                                                  686
volume_off               31            based           bit(18)                  level 2 in structure "rcse" dcl 4-45 in procedure
                                                                                  "rcp_initializer_" set ref 418*
volume_ptr                      000240 automatic       pointer                  dcl 2-18 set ref 339* 340 341 341 341 341 348 348
                                                                                  348 400* 401 402 403 403 404 405 406 407 408 409
                                                                                  410 412 686* 687 727* 728 747* 748 750 971 972 972
                                                                                  973 974 975 976 977 978 978 981 982
vtypex                   11            based           fixed bin(17,0)          level 2 dcl 2-89 set ref 402* 978
wakeup_buf                      000436 automatic       fixed bin(71,0)          dcl 1022 set ref 1032* 1033*
writing                  35(05)        based           bit(1)                   level 3 packed unaligned dcl 4-45 ref 385

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AIM_MESSAGE                            internal static fixed bin(17,0)          initial dcl 8-3
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 3-16
BEEP                                   internal static fixed bin(17,0)          initial dcl 8-3
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-24
CRASH                                  internal static fixed bin(17,0)          initial dcl 8-3
CRASH_ON_CRF                           internal static fixed bin(17,0)          initial dcl 1-28
DISK_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-30
ENABLE_CONSOLE_SERVICE                 internal static fixed bin(17,0)          initial dcl 1-28
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 8-3
MAKE_ALTERNATE_CONSOLE                 internal static fixed bin(17,0)          initial dcl 1-28
MAKE_BOOTLOAD_CONSOLE                  internal static fixed bin(17,0)          initial dcl 1-28
MAKE_INOP_DEVICE                       internal static fixed bin(17,0)          initial dcl 1-28
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 3-16
NOP                                    internal static fixed bin(17,0)          initial dcl 1-28
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 6-15
No_authentication                      internal static fixed bin(17,0)          initial dcl 3-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 3-16
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-25
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 6-26
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 6-27
RESET_CONSOLE                          internal static fixed bin(17,0)          initial dcl 1-28
RUN_ON_CRF                             internal static fixed bin(17,0)          initial dcl 1-28
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 6-28
SUSPEND_CONSOLE_SERVICE                internal static fixed bin(17,0)          initial dcl 1-28
TAPE_VOL_VTYPEX                        internal static fixed bin(17,0)          initial dcl 6-29
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 8-3
add_actionx                            internal static fixed bin(17,0)          initial dcl 7-12
assign_actionx                         internal static fixed bin(17,0)          initial dcl 7-12
attach_acct_actionx                    internal static fixed bin(17,0)          initial dcl 7-12
authentication_level_names             internal static char(12)                 initial array unaligned dcl 3-21
based_rcp_id                           based           structure                level 1 dcl 4-16
delete_actionx                         internal static fixed bin(17,0)          initial dcl 7-12
error_actionx                          internal static fixed bin(17,0)          initial dcl 7-12
force_actionx                          internal static fixed bin(17,0)          initial dcl 7-12
lock_info_ptr                          automatic       pointer                  dcl 4-12
proc_actionx                           internal static fixed bin(17,0)          initial dcl 7-12
rcs                                    based           structure                level 1 dcl 4-20
rifp                                   automatic       pointer                  dcl 3-6
unassign_actionx                       internal static fixed bin(17,0)          initial dcl 7-12

NAMES DECLARED BY EXPLICIT CONTEXT.
AAA_TEST                        002412 constant        label                    dcl 581 ref 568 574
ACCOUNT_ATTACH                  004013 constant        entry                    internal dcl 883 ref 227
ACCOUNT_WAKEUP                  004411 constant        entry                    internal dcl 1011 ref 527 893 931
ACTION                          000000 constant        label                    array(8) dcl 192 ref 190
ADD_DEVICE                      003454 constant        entry                    internal dcl 822 ref 222
ASSIGN                          001075 constant        entry                    internal dcl 237 ref 192
ASSIGN_DEVICE                   001643 constant        entry                    internal dcl 422 ref 260
ASSIGN_VOLUME                   001247 constant        entry                    internal dcl 322 ref 252
CHECK_LIMITS                    002525 constant        entry                    internal dcl 606 ref 473
DELETE_DEVICE                   003222 constant        entry                    internal dcl 768 ref 217
DEVICE_STATE                    000010 constant        label                    array(0:4) dcl 554 ref 552 557
ERROR_COUNT                     002611 constant        entry                    internal dcl 652 ref 197
FIND_DEVICE                     004350 constant        entry                    internal dcl 989 ref 713 778 837 1061
FORCE_UNASSIGN                  002753 constant        entry                    internal dcl 704 ref 207
PROC_UNASSIGN                   003072 constant        entry                    internal dcl 737 ref 212
REMEMBER_DEVICE                 001242 constant        label                    dcl 311 ref 306
TEST_DEVICE                     002346 constant        entry                    internal dcl 545 ref 451
UNASSIGN                        002650 constant        entry                    internal dcl 669 ref 202
UNASSIGN_DEVICE                 004026 constant        entry                    internal dcl 897 ref 698 719 760
UNASSIGN_VOLUME                 004267 constant        entry                    internal dcl 960 ref 269 687 730 751
UNLOCK                          001056 constant        entry                    internal dcl 232 ref 183 194 199 204 209 214 219 224
                                                                                  229 1051 1088
rcp_initializer_                000436 constant        entry                    external dcl 12
ss_io_interchange               000615 constant        entry                    external dcl 1038

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5132        5232    4514        5142
Length      5672    4514       100         423     415           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_initializer_                    704 external procedure  is an external procedure.  
on unit on line 181                  64 on unit               
UNLOCK                               70 internal procedure  is called by several nonquick procedures.  
ASSIGN                                  internal procedure  shares stack frame of external procedure rcp_initializer_.  
ASSIGN_VOLUME                           internal procedure  shares stack frame of external procedure rcp_initializer_.  
ASSIGN_DEVICE                           internal procedure  shares stack frame of external procedure rcp_initializer_.  
TEST_DEVICE                             internal procedure  shares stack frame of external procedure rcp_initializer_.  
CHECK_LIMITS                            internal procedure  shares stack frame of external procedure rcp_initializer_.  
ERROR_COUNT                             internal procedure  shares stack frame of external procedure rcp_initializer_.  
UNASSIGN                                internal procedure  shares stack frame of external procedure rcp_initializer_.  
FORCE_UNASSIGN                          internal procedure  shares stack frame of external procedure rcp_initializer_.  
PROC_UNASSIGN                           internal procedure  shares stack frame of external procedure rcp_initializer_.  
DELETE_DEVICE                           internal procedure  shares stack frame of external procedure rcp_initializer_.  
ADD_DEVICE                              internal procedure  shares stack frame of external procedure rcp_initializer_.  
ACCOUNT_ATTACH                          internal procedure  shares stack frame of external procedure rcp_initializer_.  
UNASSIGN_DEVICE                         internal procedure  shares stack frame of external procedure rcp_initializer_.  
UNASSIGN_VOLUME                         internal procedure  shares stack frame of external procedure rcp_initializer_.  
FIND_DEVICE                             internal procedure  shares stack frame of external procedure rcp_initializer_.  
ACCOUNT_WAKEUP                          internal procedure  shares stack frame of external procedure rcp_initializer_.  
on unit on line 1051                 64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_initializer_         000100 access                      rcp_initializer_
                         000101 access_needed               rcp_initializer_
                         000102 accessible_flag             rcp_initializer_
                         000103 add_sw                      rcp_initializer_
                         000104 available_flag              rcp_initializer_
                         000106 available_list              rcp_initializer_
                         000146 del_sw                      rcp_initializer_
                         000147 dev_rcse_off                rcp_initializer_
                         000150 device_name                 rcp_initializer_
                         000160 device_off                  rcp_initializer_
                         000161 dtypex                      rcp_initializer_
                         000162 ecode                       rcp_initializer_
                         000163 i                           rcp_initializer_
                         000164 j                           rcp_initializer_
                         000165 match_flag                  rcp_initializer_
                         000166 message                     rcp_initializer_
                         000170 num_accessible              rcp_initializer_
                         000171 num_appropriate             rcp_initializer_
                         000172 num_assigned                rcp_initializer_
                         000173 num_avail_nres              rcp_initializer_
                         000174 num_available               rcp_initializer_
                         000175 num_free_res                rcp_initializer_
                         000176 num_reserved                rcp_initializer_
                         000177 num_resvd                   rcp_initializer_
                         000200 process_id                  rcp_initializer_
                         000202 save_device_ptr             rcp_initializer_
                         000204 system_flag                 rcp_initializer_
                         000206 time_assigned               rcp_initializer_
                         000210 vol_rcse_off                rcp_initializer_
                         000211 volume_flag                 rcp_initializer_
                         000212 volume_name                 rcp_initializer_
                         000222 volume_off                  rcp_initializer_
                         000232 rcpd_ptr                    rcp_initializer_
                         000234 dtype_ptr                   rcp_initializer_
                         000236 device_ptr                  rcp_initializer_
                         000240 volume_ptr                  rcp_initializer_
                         000242 rcs_ptr                     rcp_initializer_
                         000244 rcse_ptr                    rcp_initializer_
                         000246 message_ptr                 rcp_initializer_
                         000274 ignored_code                ASSIGN_DEVICE
                         000366 operational                 ADD_DEVICE
                         000370 tape_name                   ADD_DEVICE
                         000406 ignored_code                UNASSIGN_DEVICE
                         000416 ignored_code                UNASSIGN_VOLUME
                         000436 wakeup_buf                  ACCOUNT_WAKEUP
                         000440 auto_rcpamsg                ACCOUNT_WAKEUP

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
enable              ext_entry           ext_entry_desc      int_entry           unpack_pic          divide_fx3
clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$ioi_add_device    admin_gate_$ioi_delete_device admin_gate_$syserr            admin_gate_$syserr_error_code
get_authorization_            get_process_id_               hcs_$wakeup                   hphcs_$ocdcm_reconfigure
rcp_cancel_resource_          rcp_check_access_             rcp_get_scratch_volume_       rcp_lock_$lock
rcp_lock_$unlock              rcp_match_$match              rcp_match_$select             rcp_match_user_name_
rcp_pointers_$com_seg         rcp_pointers_$data            rcp_tape_survey_              rcp_unload_$unload_device

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$device_limit_exceeded                          error_table_$insufficient_access
error_table_$invalid_state    error_table_$io_still_assnd   error_table_$notalloc
error_table_$resource_bad_access                            error_table_$resource_unavailable
error_table_$resource_unknown


CONSTANTS
004456  aa     773777777777

004460  aa     000004000000
004461  aa     000000000000
004462  aa     600000000041
004463  aa     000236000000
004464  ta     000232000000
004465  aa     000000000000

004466  aa     577777777777

004470  aa     000004000000
004471  aa     000000000000
004472  aa     600000000041
004473  aa     000236000000
004474  ta     000230000000
004475  aa     000000000000

004476  aa     377777777777

004500  aa     000004000000
004501  aa     000000000000
004502  aa     600000000041
004503  aa     000236000000
004504  ta     000216000000
004505  aa     000000000000

004506  aa     737777777777

004507  aa     757777777777

000015  aa  164 141 160 145	tape
000016  aa  137 166 157 154	_vol
000017  aa  040 040 040 040	    
000020  aa  040 040 040 040	    
000021  aa  040 040 040 040	    
000022  aa  040 040 040 040	    
000023  aa  040 040 040 040	    
000024  aa  040 040 040 040	    
000025  aa  144 151 163 153	disk
000026  aa  137 166 157 154	_vol
000027  aa  040 040 040 040	    
000030  aa  040 040 040 040	    
000031  aa  040 040 040 040	    
000032  aa  040 040 040 040	    
000033  aa  040 040 040 040	    
000034  aa  040 040 040 040	    
000035  aa  040 040 040 040	    
000036  aa  040 040 040 040	    
000037  aa  040 040 040 040	    
000040  aa  040 040 040 040	    
000041  aa  040 040 040 040	    
000042  aa  040 040 040 040	    
000043  aa  040 040 040 040	    
000044  aa  040 040 040 040	    
000045  aa  040 040 040 040	    
000046  aa  040 040 040 040	    
000047  aa  040 040 040 040	    
000050  aa  040 040 040 040	    
000051  aa  040 040 040 040	    
000052  aa  040 040 040 040	    
000053  aa  040 040 040 040	    
000054  aa  040 040 040 040	    
000055  aa  040 040 040 040	    
000056  aa  040 040 040 040	    
000057  aa  040 040 040 040	    
000060  aa  040 040 040 040	    
000061  aa  040 040 040 040	    
000062  aa  040 040 040 040	    
000063  aa  040 040 040 040	    
000064  aa  040 040 040 040	    
000065  aa  040 040 040 040	    
000066  aa  040 040 040 040	    
000067  aa  040 040 040 040	    
000070  aa  040 040 040 040	    
000071  aa  040 040 040 040	    
000072  aa  040 040 040 040	    
000073  aa  040 040 040 040	    
000074  aa  040 040 040 040	    
000075  aa  040 040 040 040	    
000076  aa  040 040 040 040	    
000077  aa  040 040 040 040	    
000100  aa  040 040 040 040	    
000101  aa  040 040 040 040	    
000102  aa  040 040 040 040	    
000103  aa  040 040 040 040	    
000104  aa  040 040 040 040	    

000105  aa  164 141 160 145	tape
000106  aa  137 144 162 151	_dri
000107  aa  166 145 040 040	ve  
000110  aa  040 040 040 040	    
000111  aa  040 040 040 040	    
000112  aa  040 040 040 040	    
000113  aa  040 040 040 040	    
000114  aa  040 040 040 040	    
000115  aa  144 151 163 153	disk
000116  aa  137 144 162 151	_dri
000117  aa  166 145 040 040	ve  
000120  aa  040 040 040 040	    
000121  aa  040 040 040 040	    
000122  aa  040 040 040 040	    
000123  aa  040 040 040 040	    
000124  aa  040 040 040 040	    
000125  aa  143 157 156 163	cons
000126  aa  157 154 145 040	ole 
000127  aa  040 040 040 040	    
000130  aa  040 040 040 040	    
000131  aa  040 040 040 040	    
000132  aa  040 040 040 040	    
000133  aa  040 040 040 040	    
000134  aa  040 040 040 040	    
000135  aa  160 162 151 156	prin
000136  aa  164 145 162 040	ter 
000137  aa  040 040 040 040	    
000140  aa  040 040 040 040	    
000141  aa  040 040 040 040	    
000142  aa  040 040 040 040	    
000143  aa  040 040 040 040	    
000144  aa  040 040 040 040	    
000145  aa  160 165 156 143	punc
000146  aa  150 040 040 040	h   
000147  aa  040 040 040 040	    
000150  aa  040 040 040 040	    
000151  aa  040 040 040 040	    
000152  aa  040 040 040 040	    
000153  aa  040 040 040 040	    
000154  aa  040 040 040 040	    
000155  aa  162 145 141 144	read
000156  aa  145 162 040 040	er  
000157  aa  040 040 040 040	    
000160  aa  040 040 040 040	    
000161  aa  040 040 040 040	    
000162  aa  040 040 040 040	    
000163  aa  040 040 040 040	    
000164  aa  040 040 040 040	    
000165  aa  163 160 145 143	spec
000166  aa  151 141 154 040	ial 
000167  aa  040 040 040 040	    
000170  aa  040 040 040 040	    
000171  aa  040 040 040 040	    
000172  aa  040 040 040 040	    
000173  aa  040 040 040 040	    
000174  aa  040 040 040 040	    


000175  aa     000003641100

000176  aa     524000000024

000177  aa     524000000052

000200  aa     524000000042

000201  aa     524000000045

000202  aa     524000000061

000203  aa     526000000004

000204  aa     524000000056

000205  aa     524000000044

000206  aa     524000000032

000207  aa     524000000026

000210  aa     524000000010

000211  aa     524000000040

000212  aa     514000000003

000213  aa     526000000040

000214  aa     524000000072

000215  aa     404000000021

004510  aa  040 000 000 000	 

000216  aa     000000000000

000217  aa     000000000005

000220  aa     000000000012

000221  aa     514000000110

000222  aa     464000000000

000223  aa     516000000001

000224  aa     516000000044

000225  aa     000000000004

000226  aa     404000000043

000227  aa     526077777777

000230  aa     000000000002

000231  aa     514000000001

000232  aa     000000000001

000233  aa     410000000107

000234  aa     000000000000
000235  aa     000000000000

000236  aa  163 143 162 141	scra
000237  aa  164 143 150 000	tch

000240  aa  143 154 145 141	clea
000241  aa  156 165 160 000	nup

004511  aa     031002000002
004512  aa     002000000040
004513  aa     071071000000

000242  aa     404100000043
000243  aa     000000000001
000244  aa     000000000004
000245  aa     000000000001

000246  aa  122 103 120 072	RCP:
000247  aa  040 101 144 144	 Add
000250  aa  145 144 040 144	ed d
000251  aa  145 166 151 143	evic
000252  aa  145 040 136 141	e ^a

000253  aa  122 103 120 072	RCP:
000254  aa  040 104 145 154	 Del
000255  aa  145 164 145 144	eted
000256  aa  040 144 145 166	 dev
000257  aa  151 143 145 040	ice 
000260  aa  136 141 000 000	^a

000261  aa  122 103 120 072	RCP:
000262  aa  040 101 163 163	 Ass
000263  aa  151 147 156 145	igne
000264  aa  144 040 136 141	d ^a
000265  aa  040 164 157 040	 to 
000266  aa  136 141 000 000	^a

000267  aa  111 156 151 164	Init
000270  aa  151 141 154 151	iali
000271  aa  172 145 162 056	zer.
000272  aa  123 171 163 104	SysD
000273  aa  141 145 155 157	aemo
000274  aa  156 056 172 000	n.z

000275  aa  122 103 120 072	RCP:
000276  aa  040 125 156 141	 Una
000277  aa  163 163 151 147	ssig
000300  aa  156 145 144 040	ned 
000301  aa  136 141 040 146	^a f
000302  aa  162 157 155 040	rom 
000303  aa  136 141 000 000	^a

000304  aa  122 103 120 072	RCP:
000305  aa  040 106 157 162	 For
000306  aa  143 145 040 125	ce U
000307  aa  156 141 163 163	nass
000310  aa  151 147 156 145	igne
000311  aa  144 040 136 141	d ^a
000312  aa  040 146 162 157	 fro
000313  aa  155 040 136 141	m ^a

000314  aa  162 143 160 137	rcp_
000315  aa  151 156 151 164	init
000316  aa  151 141 154 151	iali
000317  aa  172 145 162 137	zer_
000320  aa  072 040 105 162	: Er
000321  aa  162 157 162 040	ror 
000322  aa  141 144 144 151	addi
000323  aa  156 147 040 136	ng ^
000324  aa  141 056 000 000	a.

000325  aa  162 143 160 137	rcp_
000326  aa  151 156 151 164	init
000327  aa  151 141 154 151	iali
000330  aa  172 145 162 137	zer_
000331  aa  072 040 105 162	: Er
000332  aa  162 157 162 040	ror 
000333  aa  144 145 154 145	dele
000334  aa  164 151 156 147	ting
000335  aa  040 136 141 056	 ^a.

000336  aa  162 143 160 137	rcp_
000337  aa  151 156 151 164	init
000340  aa  151 141 154 151	iali
000341  aa  172 145 162 137	zer_
000342  aa  072 040 105 162	: Er
000343  aa  162 157 162 040	ror 
000344  aa  163 165 162 166	surv
000345  aa  145 171 151 156	eyin
000346  aa  147 040 136 141	g ^a
000347  aa  056 000 000 000	.

000350  aa  162 143 160 137	rcp_
000351  aa  151 156 151 164	init
000352  aa  151 141 154 151	iali
000353  aa  172 145 162 137	zer_
000354  aa  072 040 125 156	: Un
000355  aa  141 142 154 145	able
000356  aa  040 164 157 040	 to 
000357  aa  141 144 144 040	add 
000360  aa  143 157 156 163	cons
000361  aa  157 154 145 040	ole 
000362  aa  136 141 000 000	^a

000363  aa  162 143 160 137	rcp_
000364  aa  151 156 151 164	init
000365  aa  151 141 154 151	iali
000366  aa  172 145 162 137	zer_
000367  aa  072 040 125 156	: Un
000370  aa  141 142 154 145	able
000371  aa  040 164 157 040	 to 
000372  aa  144 145 154 145	dele
000373  aa  164 145 040 143	te c
000374  aa  157 156 163 157	onso
000375  aa  154 145 040 136	le ^
000376  aa  141 056 000 000	a.

000377  aa  122 103 120 072	RCP:
000400  aa  040 136 141 040	 ^a 
000401  aa  151 163 040 156	is n
000402  aa  157 164 040 157	ot o
000403  aa  160 145 162 141	pera
000404  aa  164 151 157 156	tion
000405  aa  141 154 040 141	al a
000406  aa  156 144 040 167	nd w
000407  aa  151 154 154 040	ill 
000410  aa  156 157 164 040	not 
000411  aa  142 145 040 141	be a
000412  aa  144 144 145 144	dded
000413  aa  056 000 000 000	.

000414  aa  122 103 120 072	RCP:
000415  aa  040 136 133 101	 ^[A
000416  aa  143 161 165 151	cqui
000417  aa  162 145 144 040	red 
000420  aa  136 141 040 146	^a f
000421  aa  162 157 155 136	rom^
000422  aa  073 103 157 156	;Con
000423  aa  163 151 147 156	sign
000424  aa  145 144 040 136	ed ^
000425  aa  141 040 164 157	a to
000426  aa  136 135 040 163	^] s
000427  aa  164 157 162 141	tora
000430  aa  147 145 040 163	ge s
000431  aa  171 163 164 145	yste
000432  aa  155 056 000 000	m.

LABEL ARRAYS
000000  aa   000530 7100 04	tra  	344,ic		000530
000001  aa   000535 7100 04	tra  	349,ic		000536
000002  aa   000542 7100 04	tra  	354,ic		000544
000003  aa   000547 7100 04	tra  	359,ic		000552
000004  aa   000554 7100 04	tra  	364,ic		000560
000005  aa   000561 7100 04	tra  	369,ic		000566
000006  aa   000566 7100 04	tra  	374,ic		000574
000007  aa   000573 7100 04	tra  	379,ic		000602

000010  aa   002374 7100 04	tra  	1276,ic		002404
000011  aa   002347 7100 04	tra  	1255,ic		002360
000012  aa   002341 7100 04	tra  	1249,ic		002353
000013  aa   002337 7100 04	tra  	1247,ic		002352
000014  aa   002357 7100 04	tra  	1263,ic		002373

BEGIN PROCEDURE rcp_initializer_
ENTRY TO rcp_initializer_                                   STATEMENT 1 ON LINE 12
rcp_initializer_:
     procedure (arg_message);

000433  at     000001000233
000434  ta     000433000000
000435  da     000360300000
000436  aa   001300 6270 00	eax7 	704
000437  aa  7 00034 3521 20	epp2 	pr7|28,*
000440  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000441  aa     000002000000
000442  aa     000000000000
						STATEMENT 1 ON LINE 175
	message = arg_message;

000443  aa  6 00032 3735 20	epp7 	pr6|26,*
000444  aa  7 00002 2371 20	ldaq 	pr7|2,*		arg_message
000445  aa  6 00166 7571 00	staq 	pr6|118		message
						STATEMENT 1 ON LINE 176
	message_ptr = addr (message);

000446  aa  6 00166 3715 00	epp5 	pr6|118		message
000447  aa  6 00246 6515 00	spri5	pr6|166		message_ptr
						STATEMENT 1 ON LINE 177
	rcpd_ptr = rcp_pointers_$data ();

000450  aa  6 00232 3521 00	epp2 	pr6|154		rcpd_ptr
000451  aa  6 00444 2521 00	spri2	pr6|292
000452  aa  6 00442 6211 00	eax1 	pr6|290
000453  aa   004000 4310 07	fld  	2048,dl
000454  la  4 00064 3521 20	epp2 	pr4|52,*		rcp_pointers_$data
000455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 178
	rcs_ptr = rcp_pointers_$com_seg ();

000456  aa  6 00242 3521 00	epp2 	pr6|162		rcs_ptr
000457  aa  6 00444 2521 00	spri2	pr6|292
000460  aa  6 00442 6211 00	eax1 	pr6|290
000461  aa   004000 4310 07	fld  	2048,dl
000462  aa  6 00044 3701 20	epp4 	pr6|36,*
000463  la  4 00062 3521 20	epp2 	pr4|50,*		rcp_pointers_$com_seg
000464  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 179
	ecode = 0;

000465  aa  6 00162 4501 00	stz  	pr6|114		ecode
						STATEMENT 1 ON LINE 181
	on cleanup
	     begin;

000466  aa   000007 7260 07	lxl6 	7,dl
000467  aa   777551 3520 04	epp2 	-151,ic		000240 = 143154145141
000470  aa  0 00717 7001 00	tsx0 	pr0|463		enable
000471  aa   000004 7100 04	tra  	4,ic		000475
000472  aa     000224000000
000473  aa   000015 7100 04	tra  	13,ic		000510
BEGIN CONDITION cleanup.1
ENTRY TO cleanup.1                                          STATEMENT 1 ON LINE 181
	on cleanup
	     begin;

000474  da     000366200000
000475  aa   000100 6270 00	eax7 	64
000476  aa  7 00034 3521 20	epp2 	pr7|28,*
000477  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000500  aa     000000000000
000501  aa     000000000000
						STATEMENT 1 ON LINE 183
		call UNLOCK;

000502  aa   000001 7270 07	lxl7 	1,dl
000503  aa  6 00056 6211 00	eax1 	pr6|46
000504  aa   000000 4310 07	fld  	0,dl
000505  aa   000351 3520 04	epp2 	233,ic		001056 = 000120627000
000506  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 184
	     end;

000507  aa  0 00631 7101 00	tra  	pr0|409		return
  END CONDITION cleanup.1
						STATEMENT 1 ON LINE 186
	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);

000510  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd.lock_info
000511  aa  6 00446 6535 00	spri7	pr6|294
000512  aa  6 00446 3521 00	epp2 	pr6|294
000513  aa  6 00452 2521 00	spri2	pr6|298
000514  aa  6 00162 3521 00	epp2 	pr6|114		ecode
000515  aa  6 00454 2521 00	spri2	pr6|300
000516  aa  6 00450 6211 00	eax1 	pr6|296
000517  aa   010000 4310 07	fld  	4096,dl
000520  aa  6 00044 3701 20	epp4 	pr6|36,*
000521  la  4 00050 3521 20	epp2 	pr4|40,*		rcp_lock_$lock
000522  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 187
	if ecode ^= 0 then
	     return;

000523  aa  6 00162 2361 00	ldq  	pr6|114		ecode
000524  aa  0 00631 6011 00	tnz  	pr0|409		return
						STATEMENT 1 ON LINE 190
	goto ACTION (offset_message.actionx);

000525  aa  6 00246 2351 20	lda  	pr6|166,*		offset_message.actionx
000526  aa   000077 7330 00	lrs  	63
000527  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 192
ACTION (1):					/* Assign. */
	call ASSIGN;

000530  aa   000345 6700 04	tsp4 	229,ic		001075
						STATEMENT 1 ON LINE 194
	call UNLOCK;

000531  aa  6 00056 6211 00	eax1 	pr6|46
000532  aa   000000 4310 07	fld  	0,dl
000533  aa   000323 3520 04	epp2 	211,ic		001056 = 000120627000
000534  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 195
	return;

000535  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 197
ACTION (2):					/* Error count. */
	call ERROR_COUNT;

000536  aa   002053 6700 04	tsp4 	1067,ic		002611
						STATEMENT 1 ON LINE 199
	call UNLOCK;

000537  aa  6 00056 6211 00	eax1 	pr6|46
000540  aa   000000 4310 07	fld  	0,dl
000541  aa   000315 3520 04	epp2 	205,ic		001056 = 000120627000
000542  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 200
	return;

000543  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 202
ACTION (3):					/* Unassign. */
	call UNASSIGN;

000544  aa   002104 6700 04	tsp4 	1092,ic		002650
						STATEMENT 1 ON LINE 204
	call UNLOCK;

000545  aa  6 00056 6211 00	eax1 	pr6|46
000546  aa   000000 4310 07	fld  	0,dl
000547  aa   000307 3520 04	epp2 	199,ic		001056 = 000120627000
000550  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 205
	return;

000551  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 207
ACTION (4):					/* Force unassign. */
	call FORCE_UNASSIGN;

000552  aa   002201 6700 04	tsp4 	1153,ic		002753
						STATEMENT 1 ON LINE 209
	call UNLOCK;

000553  aa  6 00056 6211 00	eax1 	pr6|46
000554  aa   000000 4310 07	fld  	0,dl
000555  aa   000301 3520 04	epp2 	193,ic		001056 = 000120627000
000556  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 210
	return;

000557  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 212
ACTION (5):					/* Unassign process. */
	call PROC_UNASSIGN;

000560  aa   002312 6700 04	tsp4 	1226,ic		003072
						STATEMENT 1 ON LINE 214
	call UNLOCK;

000561  aa  6 00056 6211 00	eax1 	pr6|46
000562  aa   000000 4310 07	fld  	0,dl
000563  aa   000273 3520 04	epp2 	187,ic		001056 = 000120627000
000564  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 215
	return;

000565  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 217
ACTION (6):					/* Delete a device. */
	call DELETE_DEVICE;

000566  aa   002434 6700 04	tsp4 	1308,ic		003222
						STATEMENT 1 ON LINE 219
	call UNLOCK;

000567  aa  6 00056 6211 00	eax1 	pr6|46
000570  aa   000000 4310 07	fld  	0,dl
000571  aa   000265 3520 04	epp2 	181,ic		001056 = 000120627000
000572  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 220
	return;

000573  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 222
ACTION (7):					/* Add a device. */
	call ADD_DEVICE;

000574  aa   002660 6700 04	tsp4 	1456,ic		003454
						STATEMENT 1 ON LINE 224
	call UNLOCK;

000575  aa  6 00056 6211 00	eax1 	pr6|46
000576  aa   000000 4310 07	fld  	0,dl
000577  aa   000257 3520 04	epp2 	175,ic		001056 = 000120627000
000600  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 225
	return;

000601  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 227
ACTION (8):					/* Account attach */
	call ACCOUNT_ATTACH;

000602  aa   003211 6700 04	tsp4 	1673,ic		004013
						STATEMENT 1 ON LINE 229
	call UNLOCK;

000603  aa  6 00056 6211 00	eax1 	pr6|46
000604  aa   000000 4310 07	fld  	0,dl
000605  aa   000251 3520 04	epp2 	169,ic		001056 = 000120627000
000606  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 230
	return;

000607  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO ss_io_interchange                                  STATEMENT 1 ON LINE 1038
ss_io_interchange:
     entry (a_device_name, a_add_sw, a_del_sw, a_ecode);

000610  at     000004000227
000611  tt     000231000231
000612  ta     000226000000
000613  ta     000610000000
000614  da     000376300000
000615  aa   001300 6270 00	eax7 	704
000616  aa  7 00034 3521 20	epp2 	pr7|28,*
000617  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000620  aa     000010000000
000621  aa     000000000000
000622  aa  6 00042 3735 20	epp7 	pr6|34,*
000623  aa  7 00000 2361 20	ldq  	pr7|0,*
000624  aa   000002 6040 04	tmi  	2,ic		000626
000625  aa   777777 3760 07	anq  	262143,dl
000626  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000627  aa  6 00457 7561 00	stq  	pr6|303
						STATEMENT 1 ON LINE 1046
	device_name = a_device_name;

000630  aa  6 00032 3735 20	epp7 	pr6|26,*
000631  aa  7 00002 3715 20	epp5 	pr7|2,*
000632  aa  6 00457 2351 00	lda  	pr6|303
000633  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000634  aa  5 00000 00 0005	desc9a	pr5|0,al		a_device_name
000635  aa  6 00150 00 0040	desc9a	pr6|104,32	device_name
						STATEMENT 1 ON LINE 1047
	add_sw = a_add_sw;

000636  aa  7 00004 2351 20	lda  	pr7|4,*		a_add_sw
000637  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000640  aa  6 00103 7551 00	sta  	pr6|67		add_sw
						STATEMENT 1 ON LINE 1048
	del_sw = a_del_sw;

000641  aa  7 00006 2351 20	lda  	pr7|6,*		a_del_sw
000642  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000643  aa  6 00146 7551 00	sta  	pr6|102		del_sw
						STATEMENT 1 ON LINE 1049
	ecode = 0;

000644  aa  6 00162 4501 00	stz  	pr6|114		ecode
						STATEMENT 1 ON LINE 1051
	on cleanup call UNLOCK;

000645  aa   000007 7260 07	lxl6 	7,dl
000646  aa   777372 3520 04	epp2 	-262,ic		000240 = 143154145141
000647  aa  0 00717 7001 00	tsx0 	pr0|463		enable
000650  aa   000004 7100 04	tra  	4,ic		000654
000651  aa     000224000000
000652  aa   000015 7100 04	tra  	13,ic		000667
BEGIN CONDITION cleanup.2
ENTRY TO cleanup.2                                          STATEMENT 1 ON LINE 1051
	on cleanup call UNLOCK;

000653  da     000404200000
000654  aa   000100 6270 00	eax7 	64
000655  aa  7 00034 3521 20	epp2 	pr7|28,*
000656  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000657  aa     000000000000
000660  aa     000000000000
000661  aa   000001 7270 07	lxl7 	1,dl
000662  aa  6 00056 6211 00	eax1 	pr6|46
000663  aa   000000 4310 07	fld  	0,dl
000664  aa   000172 3520 04	epp2 	122,ic		001056 = 000120627000
000665  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
000666  aa  0 00631 7101 00	tra  	pr0|409		return
  END CONDITION cleanup.2
						STATEMENT 1 ON LINE 1053
	rcpd_ptr = rcp_pointers_$data ();

000667  aa  6 00232 3521 00	epp2 	pr6|154		rcpd_ptr
000670  aa  6 00444 2521 00	spri2	pr6|292
000671  aa  6 00442 6211 00	eax1 	pr6|290
000672  aa   004000 4310 07	fld  	2048,dl
000673  aa  6 00044 3701 20	epp4 	pr6|36,*
000674  la  4 00064 3521 20	epp2 	pr4|52,*		rcp_pointers_$data
000675  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1054
	rcs_ptr = rcp_pointers_$com_seg ();

000676  aa  6 00242 3521 00	epp2 	pr6|162		rcs_ptr
000677  aa  6 00444 2521 00	spri2	pr6|292
000700  aa  6 00442 6211 00	eax1 	pr6|290
000701  aa   004000 4310 07	fld  	2048,dl
000702  aa  6 00044 3701 20	epp4 	pr6|36,*
000703  la  4 00062 3521 20	epp2 	pr4|50,*		rcp_pointers_$com_seg
000704  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1055
	call rcp_lock_$lock (addr (rcpd.lock_info), ecode);

000705  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd.lock_info
000706  aa  6 00446 6535 00	spri7	pr6|294
000707  aa  6 00446 3521 00	epp2 	pr6|294
000710  aa  6 00452 2521 00	spri2	pr6|298
000711  aa  6 00162 3521 00	epp2 	pr6|114		ecode
000712  aa  6 00454 2521 00	spri2	pr6|300
000713  aa  6 00450 6211 00	eax1 	pr6|296
000714  aa   010000 4310 07	fld  	4096,dl
000715  aa  6 00044 3701 20	epp4 	pr6|36,*
000716  la  4 00050 3521 20	epp2 	pr4|40,*		rcp_lock_$lock
000717  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1056
	if ecode ^= 0 then do;

000720  aa  6 00162 2361 00	ldq  	pr6|114		ecode
000721  aa   000004 6000 04	tze  	4,ic		000725
						STATEMENT 1 ON LINE 1057
	     a_ecode = ecode;

000722  aa  6 00032 3735 20	epp7 	pr6|26,*
000723  aa  7 00010 7561 20	stq  	pr7|8,*		a_ecode
						STATEMENT 1 ON LINE 1058
	     return;

000724  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 1059
	end;

						STATEMENT 1 ON LINE 1061
	call FIND_DEVICE;

000725  aa   003423 6700 04	tsp4 	1811,ic		004350
						STATEMENT 1 ON LINE 1063
	if device_off = "000000"b3 then
	     ecode = error_table_$resource_unknown;

000726  aa  6 00160 2351 00	lda  	pr6|112		device_off
000727  aa   000005 6010 04	tnz  	5,ic		000734
000730  aa  6 00044 3701 20	epp4 	pr6|36,*
000731  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$resource_unknown
000732  aa  6 00162 7561 00	stq  	pr6|114		ecode
000733  aa   000013 7100 04	tra  	11,ic		000746
						STATEMENT 1 ON LINE 1065
	else if dtype.device_type ^= DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
	     ecode = error_table_$invalid_state;

000734  aa   000020 2360 07	ldq  	16,dl
000735  aa  6 00234 3735 20	epp7 	pr6|156,*		dtype_ptr
000736  ta   000075 3714 06	epp5 	61,ql
000737  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
000740  aa  7 00000 00 0040	desc9a	pr7|0,32		dtype.device_type
000741  aa  5 00000 00 0040	desc9a	pr5|0,32		DEVICE_TYPE
000742  aa   000004 6000 04	tze  	4,ic		000746
000743  aa  6 00044 3701 20	epp4 	pr6|36,*
000744  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$invalid_state
000745  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 1068
	if ecode = 0 then
	     if add_sw then
		if device.state = 3 then
		     if del_sw then
			device.state = 2;

000746  aa  6 00162 2361 00	ldq  	pr6|114		ecode
000747  aa   000035 6010 04	tnz  	29,ic		001004
000750  aa  6 00103 2351 00	lda  	pr6|67		add_sw
000751  aa   400000 3150 03	cana 	131072,du
000752  aa   000020 6000 04	tze  	16,ic		000772
000753  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
000754  aa  7 00024 2361 00	ldq  	pr7|20		device.state
000755  aa   000003 1160 07	cmpq 	3,dl
000756  aa   000010 6010 04	tnz  	8,ic		000766
000757  aa  6 00146 2351 00	lda  	pr6|102		del_sw
000760  aa   000004 6000 04	tze  	4,ic		000764
000761  aa   000002 2360 07	ldq  	2,dl
000762  aa  7 00024 7561 00	stq  	pr7|20		device.state
000763  aa   000021 7100 04	tra  	17,ic		001004
						STATEMENT 1 ON LINE 1073
		     else device.state = 0;

000764  aa  7 00024 4501 00	stz  	pr7|20		device.state
000765  aa   000017 7100 04	tra  	15,ic		001004
						STATEMENT 1 ON LINE 1074
		else ecode = error_table_$invalid_state;

000766  aa  6 00044 3701 20	epp4 	pr6|36,*
000767  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$invalid_state
000770  aa  6 00162 7561 00	stq  	pr6|114		ecode
000771  aa   000013 7100 04	tra  	11,ic		001004
						STATEMENT 1 ON LINE 1075
	     else if device.state = 1 then
		ecode = error_table_$io_still_assnd;

000772  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
000773  aa  7 00024 2361 00	ldq  	pr7|20		device.state
000774  aa   000001 1160 07	cmpq 	1,dl
000775  aa   000005 6010 04	tnz  	5,ic		001002
000776  aa  6 00044 3701 20	epp4 	pr6|36,*
000777  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$io_still_assnd
001000  aa  6 00162 7561 00	stq  	pr6|114		ecode
001001  aa   000003 7100 04	tra  	3,ic		001004
						STATEMENT 1 ON LINE 1077
	     else device.state = 3;

001002  aa   000003 2360 07	ldq  	3,dl
001003  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 1079
	if ecode = 0 then do;

001004  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001005  aa   000040 6010 04	tnz  	32,ic		001045
						STATEMENT 1 ON LINE 1080
	     device.state_time = clock ();

001006  aa  0 01435 7001 00	tsx0 	pr0|797		clock
001007  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
001010  aa  7 00022 7571 00	staq 	pr7|18		device.state_time
						STATEMENT 1 ON LINE 1081
	     device.volume_name = " ";

001011  aa  040 100 100 400	mlr  	(),(pr),fill(040)
001012  aa   000000 00 0000	desc9a	0,0
001013  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 1082
	     device.process_id = "000000000000"b3;

001014  aa  7 00036 4501 00	stz  	pr7|30		device.process_id
						STATEMENT 1 ON LINE 1083
	     call admin_gate_$syserr (ANNOUNCE, "RCP: ^[Acquired ^a from^;Consigned ^a to^] storage system.", add_sw,
		device_name);

001015  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001016  aa   777377 00 0074	desc9a	-257,60		000414 = 122103120072
001017  aa  6 00460 00 0074	desc9a	pr6|304,60
001020  aa   777176 3520 04	epp2 	-386,ic		000216 = 000000000000
001021  aa  6 00502 2521 00	spri2	pr6|322
001022  aa  6 00460 3521 00	epp2 	pr6|304
001023  aa  6 00504 2521 00	spri2	pr6|324
001024  aa  6 00103 3521 00	epp2 	pr6|67		add_sw
001025  aa  6 00506 2521 00	spri2	pr6|326
001026  aa  6 00150 3521 00	epp2 	pr6|104		device_name
001027  aa  6 00510 2521 00	spri2	pr6|328
001030  aa   777165 3520 04	epp2 	-395,ic		000215 = 404000000021
001031  aa  6 00512 2521 00	spri2	pr6|330
001032  aa   777162 3520 04	epp2 	-398,ic		000214 = 524000000072
001033  aa  6 00514 2521 00	spri2	pr6|332
001034  aa   777167 3520 04	epp2 	-393,ic		000223 = 516000000001
001035  aa  6 00516 2521 00	spri2	pr6|334
001036  aa   777155 3520 04	epp2 	-403,ic		000213 = 526000000040
001037  aa  6 00520 2521 00	spri2	pr6|336
001040  aa  6 00500 6211 00	eax1 	pr6|320
001041  aa   020000 4310 07	fld  	8192,dl
001042  aa  6 00044 3701 20	epp4 	pr6|36,*
001043  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
001044  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1085
	end;

						STATEMENT 1 ON LINE 1087
	a_ecode = ecode;

001045  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001046  aa  6 00032 3735 20	epp7 	pr6|26,*
001047  aa  7 00010 7561 20	stq  	pr7|8,*		a_ecode
						STATEMENT 1 ON LINE 1088
	call UNLOCK;

001050  aa  6 00056 6211 00	eax1 	pr6|46
001051  aa   000000 4310 07	fld  	0,dl
001052  aa   000004 3520 04	epp2 	4,ic		001056 = 000120627000
001053  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 1089
	return;

001054  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 1214
     end rcp_initializer_;

BEGIN PROCEDURE UNLOCK
ENTRY TO UNLOCK                                             STATEMENT 1 ON LINE 232
UNLOCK:
     procedure;

001055  da     000411200000
001056  aa   000120 6270 00	eax7 	80
001057  aa  7 00034 3521 20	epp2 	pr7|28,*
001060  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001061  aa     000000000000
001062  aa     000000000000
						STATEMENT 1 ON LINE 234
	call rcp_lock_$unlock (addr (rcpd.lock_info));

001063  aa  6 00040 3735 20	epp7 	pr6|32,*
001064  aa  7 00232 3735 20	epp7 	pr7|154,*		rcpd.lock_info
001065  aa  6 00100 6535 00	spri7	pr6|64
001066  aa  6 00100 3521 00	epp2 	pr6|64
001067  aa  6 00104 2521 00	spri2	pr6|68
001070  aa  6 00102 6211 00	eax1 	pr6|66
001071  aa   004000 4310 07	fld  	2048,dl
001072  la  4 00052 3521 20	epp2 	pr4|42,*		rcp_lock_$unlock
001073  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 235
     end UNLOCK;

001074  aa  0 00631 7101 00	tra  	pr0|409		return
  END PROCEDURE UNLOCK
BEGIN PROCEDURE ASSIGN
ENTRY TO ASSIGN                                             STATEMENT 1 ON LINE 237
ASSIGN:
     procedure;

001075  aa  6 00250 6501 00	spri4	pr6|168
						STATEMENT 1 ON LINE 245
	vol_rcse_off = offset_message.volume_off;

001076  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
001077  aa  7 00001 2351 00	lda  	pr7|1		offset_message.volume_off
001100  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001101  aa  6 00210 7551 00	sta  	pr6|136		vol_rcse_off
						STATEMENT 1 ON LINE 246
	dev_rcse_off = offset_message.device_off;

001102  aa  7 00001 2351 00	lda  	pr7|1		offset_message.device_off
001103  aa   000022 7350 00	als  	18
001104  aa  6 00147 7551 00	sta  	pr6|103		dev_rcse_off
						STATEMENT 1 ON LINE 248
	volume_flag = "0"b;

001105  aa  6 00211 4501 00	stz  	pr6|137		volume_flag
						STATEMENT 1 ON LINE 250
	if vol_rcse_off ^= "0"b			/* Do we have to assign a volume? */
	then do;

001106  aa  6 00210 2351 00	lda  	pr6|136		vol_rcse_off
001107  aa   000010 6000 04	tze  	8,ic		001117
						STATEMENT 1 ON LINE 252
	     call ASSIGN_VOLUME;

001110  aa   000137 6700 04	tsp4 	95,ic		001247
						STATEMENT 1 ON LINE 253
	     rcse.ecode = ecode;

001111  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001112  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001113  aa  7 00053 7561 00	stq  	pr7|43		rcse.ecode
						STATEMENT 1 ON LINE 254
	     if ecode ^= 0				/* Any problems with volume? */
	     then return;

001114  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001115  aa   000002 6000 04	tze  	2,ic		001117
001116  aa  6 00250 6101 00	rtcd 	pr6|168
						STATEMENT 1 ON LINE 256
	end;

						STATEMENT 1 ON LINE 258
	if dev_rcse_off ^= "0"b			/* Do we have a device to assign? */
	then do;

001117  aa  6 00147 2351 00	lda  	pr6|103		dev_rcse_off
001120  aa   000005 6000 04	tze  	5,ic		001125
						STATEMENT 1 ON LINE 260
	     call ASSIGN_DEVICE;

001121  aa   000522 6700 04	tsp4 	338,ic		001643
						STATEMENT 1 ON LINE 261
	     rcse.ecode = ecode;

001122  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001123  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001124  aa  7 00053 7561 00	stq  	pr7|43		rcse.ecode
						STATEMENT 1 ON LINE 262
	end;

						STATEMENT 1 ON LINE 264
	if ^volume_flag				/* Device assignment done.  Was there a volume? */
	then return;

001125  aa  6 00211 2351 00	lda  	pr6|137		volume_flag
001126  aa   000002 6010 04	tnz  	2,ic		001130
001127  aa  6 00250 6101 00	rtcd 	pr6|168
						STATEMENT 1 ON LINE 267
	if ecode ^= 0				/* Was there an error assigning device? */
	then do;

001130  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001131  aa   000003 6000 04	tze  	3,ic		001134
						STATEMENT 1 ON LINE 269
	     call UNASSIGN_VOLUME ();

001132  aa   003135 6700 04	tsp4 	1629,ic		004267
						STATEMENT 1 ON LINE 270
	     return;

001133  aa  6 00250 6101 00	rtcd 	pr6|168
						STATEMENT 1 ON LINE 271
	end;

						STATEMENT 1 ON LINE 273
	if dev_rcse_off = "0"b			/* Was a device just assigned? */
	then do;

001134  aa  6 00147 2351 00	lda  	pr6|103		dev_rcse_off
001135  aa   000023 6010 04	tnz  	19,ic		001160
						STATEMENT 1 ON LINE 275
	     rcse_ptr = ptr (rcs_ptr, vol_rcse_off);

001136  aa  6 00210 2351 00	lda  	pr6|136		vol_rcse_off
001137  aa  6 00242 3521 20	epp2 	pr6|162,*		rcs_ptr
001140  aa   000000 3120 01	eawp2	0,au
001141  aa  6 00244 2521 00	spri2	pr6|164		rcse_ptr
						STATEMENT 1 ON LINE 276
	     rcse_ptr = ptr (rcs_ptr, rcse.rcse_off);

001142  aa  2 00032 2351 00	lda  	pr2|26		rcse.rcse_off
001143  aa  6 00242 3515 20	epp1 	pr6|162,*		rcs_ptr
001144  aa   000000 3114 01	eawp1	0,au
001145  aa  6 00244 2515 00	spri1	pr6|164		rcse_ptr
						STATEMENT 1 ON LINE 277
	     device_ptr = ptr (rcpd_ptr, rcse.device_off);

001146  aa  1 00030 2351 00	lda  	pr1|24		rcse.device_off
001147  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
001150  aa   000000 3120 01	eawp2	0,au
001151  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 278
	     dtypex = device.dtypex;

001152  aa  2 00012 2361 00	ldq  	pr2|10		device.dtypex
001153  aa  6 00161 7561 00	stq  	pr6|113		dtypex
						STATEMENT 1 ON LINE 279
	     dtype_ptr = addr (rcpd.dtype (dtypex));

001154  aa   000017 4020 07	mpy  	15,dl
001155  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001156  aa  7 00024 3735 06	epp7 	pr7|20,ql		rcpd.dtype
001157  aa  6 00234 6535 00	spri7	pr6|156		dtype_ptr
						STATEMENT 1 ON LINE 280
	end;

						STATEMENT 1 ON LINE 282
	if device.volume_name = volume_name		/* Is volume already on this device? */
	then do;

001160  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
001161  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
001162  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
001163  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001164  aa   000006 6010 04	tnz  	6,ic		001172
						STATEMENT 1 ON LINE 284
	     rcse.volume_name = volume_name;

001165  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
001166  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001167  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001170  aa  5 00002 00 0040	desc9a	pr5|2,32		rcse.volume_name
						STATEMENT 1 ON LINE 285
	     return;

001171  aa  6 00250 6101 00	rtcd 	pr6|168
						STATEMENT 1 ON LINE 286
	end;

						STATEMENT 1 ON LINE 288
	if volume_name = "scratch"			/* Is this a scratch volume. */
	then do;

001172  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001173  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001174  aa   777044 00 0007	desc9a	-476,7		000236 = 163143162141
001175  aa   000005 6010 04	tnz  	5,ic		001202
						STATEMENT 1 ON LINE 290
	     device.volume_name = " ";

001176  aa  040 100 100 400	mlr  	(),(pr),fill(040)
001177  aa   000000 00 0000	desc9a	0,0
001200  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 291
	     return;

001201  aa  6 00250 6101 00	rtcd 	pr6|168
						STATEMENT 1 ON LINE 292
	end;

						STATEMENT 1 ON LINE 298
	save_device_ptr = device_ptr;

001202  aa  6 00202 6535 00	spri7	pr6|130		save_device_ptr
						STATEMENT 1 ON LINE 299
	device_off = dtype.first_off;

001203  aa  6 00234 3715 20	epp5 	pr6|156,*		dtype_ptr
001204  aa  5 00013 2351 00	lda  	pr5|11		dtype.first_off
001205  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 300
	do while (device_off ^= "0"b);

001206  aa  6 00160 2351 00	lda  	pr6|112		device_off
001207  aa   000033 6000 04	tze  	27,ic		001242
						STATEMENT 1 ON LINE 301
	     device_ptr = ptr (rcpd_ptr, device_off);

001210  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
001211  aa   000000 3120 01	eawp2	0,au
001212  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 302
	     if device.volume_name = volume_name then do;

001213  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
001214  aa  2 00002 00 0040	desc9a	pr2|2,32		device.volume_name
001215  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001216  aa   000021 6010 04	tnz  	17,ic		001237
						STATEMENT 1 ON LINE 303
		call rcp_unload_$unload_device (device_ptr, "0"b);

001217  aa   000000 2350 07	lda  	0,dl
001220  aa  6 00522 7551 00	sta  	pr6|338
001221  aa  6 00236 3521 00	epp2 	pr6|158		device_ptr
001222  aa  6 00526 2521 00	spri2	pr6|342
001223  aa  6 00522 3521 00	epp2 	pr6|338
001224  aa  6 00530 2521 00	spri2	pr6|344
001225  aa  6 00524 6211 00	eax1 	pr6|340
001226  aa   010000 4310 07	fld  	4096,dl
001227  aa  6 00044 3701 20	epp4 	pr6|36,*
001230  la  4 00070 3521 20	epp2 	pr4|56,*		rcp_unload_$unload_device
001231  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 305
		device.volume_name = "";

001232  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
001233  aa  040 100 100 400	mlr  	(),(pr),fill(040)
001234  aa   000000 00 0000	desc9a	0,0
001235  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 306
		goto REMEMBER_DEVICE;

001236  aa   000004 7100 04	tra  	4,ic		001242
						STATEMENT 1 ON LINE 307
	     end;

						STATEMENT 1 ON LINE 308
	     device_off = device.next_off;

001237  aa  2 00031 2351 00	lda  	pr2|25		device.next_off
001240  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 309
	end;

001241  aa   777745 7100 04	tra  	-27,ic		001206
						STATEMENT 1 ON LINE 311
REMEMBER_DEVICE:					/* Put volume on assigned device. */
	save_device_ptr -> device.volume_name = volume_name;

001242  aa  6 00202 3735 20	epp7 	pr6|130,*		save_device_ptr
001243  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001244  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001245  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 314
     end ASSIGN;

001246  aa  6 00250 6101 00	rtcd 	pr6|168
  END PROCEDURE ASSIGN
BEGIN PROCEDURE ASSIGN_VOLUME
ENTRY TO ASSIGN_VOLUME                                      STATEMENT 1 ON LINE 322
ASSIGN_VOLUME:
     procedure;

001247  aa  6 00256 6501 00	spri4	pr6|174
						STATEMENT 1 ON LINE 326
	rcse_ptr = ptr (rcs_ptr, vol_rcse_off);

001250  aa  6 00210 2351 00	lda  	pr6|136		vol_rcse_off
001251  aa  6 00242 3521 20	epp2 	pr6|162,*		rcs_ptr
001252  aa   000000 3120 01	eawp2	0,au
001253  aa  6 00244 2521 00	spri2	pr6|164		rcse_ptr
						STATEMENT 1 ON LINE 327
	access = "000"b;

001254  aa  6 00100 4501 00	stz  	pr6|64		access
						STATEMENT 1 ON LINE 328
	if rcse.volume_name ^= "scratch" then
	     volume_name = rcse.volume_name;

001255  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001256  aa  2 00002 00 0040	desc9a	pr2|2,32		rcse.volume_name
001257  aa   776761 00 0007	desc9a	-527,7		000236 = 163143162141
001260  aa   000005 6000 04	tze  	5,ic		001265
001261  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001262  aa  2 00002 00 0040	desc9a	pr2|2,32		rcse.volume_name
001263  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001264  aa   000035 7100 04	tra  	29,ic		001321
						STATEMENT 1 ON LINE 330
	else do;

						STATEMENT 1 ON LINE 331
	     call rcp_get_scratch_volume_ (rcse_ptr, volume_name, access, ecode);

001265  aa  6 00244 3521 00	epp2 	pr6|164		rcse_ptr
001266  aa  6 00534 2521 00	spri2	pr6|348
001267  aa  6 00212 3521 00	epp2 	pr6|138		volume_name
001270  aa  6 00536 2521 00	spri2	pr6|350
001271  aa  6 00100 3521 00	epp2 	pr6|64		access
001272  aa  6 00540 2521 00	spri2	pr6|352
001273  aa  6 00162 3521 00	epp2 	pr6|114		ecode
001274  aa  6 00542 2521 00	spri2	pr6|354
001275  aa   776725 3520 04	epp2 	-555,ic		000222 = 464000000000
001276  aa  6 00544 2521 00	spri2	pr6|356
001277  aa   776714 3520 04	epp2 	-564,ic		000213 = 526000000040
001300  aa  6 00546 2521 00	spri2	pr6|358
001301  aa   776711 3520 04	epp2 	-567,ic		000212 = 514000000003
001302  aa  6 00550 2521 00	spri2	pr6|360
001303  aa   776723 3520 04	epp2 	-557,ic		000226 = 404000000043
001304  aa  6 00552 2521 00	spri2	pr6|362
001305  aa  6 00532 6211 00	eax1 	pr6|346
001306  aa   020000 4310 07	fld  	8192,dl
001307  aa  6 00044 3701 20	epp4 	pr6|36,*
001310  la  4 00074 3521 20	epp2 	pr4|60,*		rcp_get_scratch_volume_
001311  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 332
	     if ecode ^= 0 then
		return;

001312  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001313  aa   000002 6000 04	tze  	2,ic		001315
001314  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 334
	     rcse.volume_name = volume_name;

001315  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001316  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001317  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001320  aa  7 00002 00 0040	desc9a	pr7|2,32		rcse.volume_name
						STATEMENT 1 ON LINE 335
	end;

						STATEMENT 1 ON LINE 336
	volume_off = "0"b;

001321  aa  6 00222 4501 00	stz  	pr6|146		volume_off
						STATEMENT 1 ON LINE 338
	do i = 1 to rcpd.last_volume;

001322  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001323  aa  7 00020 2361 00	ldq  	pr7|16		rcpd.last_volume
001324  aa  6 00264 7561 00	stq  	pr6|180
001325  aa   000001 2360 07	ldq  	1,dl
001326  aa  6 00163 7561 00	stq  	pr6|115		i
001327  aa   000000 0110 03	nop  	0,du
001330  aa  6 00163 2361 00	ldq  	pr6|115		i
001331  aa  6 00264 1161 00	cmpq 	pr6|180
001332  aa   000066 6054 04	tpnz 	54,ic		001420
						STATEMENT 1 ON LINE 339
	     volume_ptr = addr (rcpd.volume (i));

001333  aa   000042 4020 07	mpy  	34,dl
001334  aa  6 00554 7561 00	stq  	pr6|364
001335  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001336  aa  7 00016 2361 00	ldq  	pr7|14		rcpd.tot_devices
001337  aa   000074 4020 07	mpy  	60,dl
001340  aa  6 00555 7561 00	stq  	pr6|365
001341  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
001342  aa   000017 4020 07	mpy  	15,dl
001343  aa   000043 0760 07	adq  	35,dl
001344  aa   000001 0760 07	adq  	1,dl
001345  aa   777776 3760 07	anq  	262142,dl
001346  aa  6 00555 0761 00	adq  	pr6|365
001347  aa   000001 0760 07	adq  	1,dl
001350  aa   777776 3760 07	anq  	262142,dl
001351  aa  6 00554 0761 00	adq  	pr6|364
001352  aa  7 77736 3715 06	epp5 	pr7|-34,ql	rcpd.volume
001353  aa  6 00240 6515 00	spri5	pr6|160		volume_ptr
						STATEMENT 1 ON LINE 340
	     if volume.volume_name = volume_name then do;

001354  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
001355  aa  5 00001 00 0040	desc9a	pr5|1,32		volume.volume_name
001356  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001357  aa   000025 6010 04	tnz  	21,ic		001404
						STATEMENT 1 ON LINE 341
		if (volume.state = 0) | ((volume.state = 4) & (volume.process_id = rcse.process_id)) then
		     volume_off = rel (volume_ptr);

001360  aa  5 00036 2361 00	ldq  	pr5|30		volume.state
001361  aa   000007 6000 04	tze  	7,ic		001370
001362  aa   000004 1160 07	cmpq 	4,dl
001363  aa   000010 6010 04	tnz  	8,ic		001373
001364  aa  5 00000 2351 00	lda  	pr5|0		volume.process_id
001365  aa  6 00244 3535 20	epp3 	pr6|164,*		rcse_ptr
001366  aa  3 00042 1151 00	cmpa 	pr3|34		rcse.process_id
001367  aa   000004 6010 04	tnz  	4,ic		001373
001370  aa  5 00000 6351 00	eaa  	pr5|0		volume_ptr
001371  aa  6 00222 7551 00	sta  	pr6|146		volume_off
001372  aa   000024 7100 04	tra  	20,ic		001416
						STATEMENT 1 ON LINE 343
		else if volume_name ^= "" then do;

001373  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001374  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001375  aa   003115 00 0000	desc9a	1613,0		004510 = 040000000000
001376  aa   000020 6000 04	tze  	16,ic		001416
						STATEMENT 1 ON LINE 344
		     ecode = error_table_$resource_unavailable;

001377  aa  6 00044 3701 20	epp4 	pr6|36,*
001400  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$resource_unavailable
001401  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 345
		     return;

001402  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 346
		end;

						STATEMENT 1 ON LINE 347
	     end;

001403  aa   000013 7100 04	tra  	11,ic		001416
						STATEMENT 1 ON LINE 348
	     else if (volume.state = 0) & (volume.volume_name = "") then
						/* If this is a free entry in the table ... */
		if volume_off = "0"b then		/* ... and we don't have a slot to use yet ... */
		     volume_off = rel (volume_ptr);

001404  aa  5 00036 2361 00	ldq  	pr5|30		volume.state
001405  aa   000011 6010 04	tnz  	9,ic		001416
001406  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001407  aa  5 00001 00 0040	desc9a	pr5|1,32		volume.volume_name
001410  aa   003102 00 0000	desc9a	1602,0		004510 = 040000000000
001411  aa   000005 6010 04	tnz  	5,ic		001416
001412  aa  6 00222 2351 00	lda  	pr6|146		volume_off
001413  aa   000003 6010 04	tnz  	3,ic		001416
001414  aa  5 00000 6351 00	eaa  	pr5|0		volume_ptr
001415  aa  6 00222 7551 00	sta  	pr6|146		volume_off
						STATEMENT 1 ON LINE 352
	end;

001416  aa  6 00163 0541 00	aos  	pr6|115		i
001417  aa   777711 7100 04	tra  	-55,ic		001330
						STATEMENT 1 ON LINE 354
	if volume_off = "0"b			/* Volume not found, room for another? */
	then if rcpd.last_volume >= rcpd.tot_volumes then do;

001420  aa  6 00222 2351 00	lda  	pr6|146		volume_off
001421  aa   000034 6010 04	tnz  	28,ic		001455
001422  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001423  aa  7 00020 2361 00	ldq  	pr7|16		rcpd.last_volume
001424  aa  7 00017 1161 00	cmpq 	pr7|15		rcpd.tot_volumes
001425  aa   000005 6040 04	tmi  	5,ic		001432
						STATEMENT 1 ON LINE 357
		ecode = error_table_$notalloc;

001426  aa  6 00044 3701 20	epp4 	pr6|36,*
001427  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$notalloc
001430  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 358
		return;

001431  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 359
	     end;

						STATEMENT 1 ON LINE 360
	     else do;

						STATEMENT 1 ON LINE 361
		rcpd.last_volume = rcpd.last_volume + 1;

001432  aa  7 00020 0541 00	aos  	pr7|16		rcpd.last_volume
						STATEMENT 1 ON LINE 362
		volume_off = rel (addr (rcpd.volume (rcpd.last_volume)));

001433  aa  7 00020 2361 00	ldq  	pr7|16		rcpd.last_volume
001434  aa   000042 4020 07	mpy  	34,dl
001435  aa  6 00554 7561 00	stq  	pr6|364
001436  aa  7 00016 2361 00	ldq  	pr7|14		rcpd.tot_devices
001437  aa   000074 4020 07	mpy  	60,dl
001440  aa  6 00555 7561 00	stq  	pr6|365
001441  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
001442  aa   000017 4020 07	mpy  	15,dl
001443  aa   000043 0760 07	adq  	35,dl
001444  aa   000001 0760 07	adq  	1,dl
001445  aa   777776 3760 07	anq  	262142,dl
001446  aa  6 00555 0761 00	adq  	pr6|365
001447  aa   000001 0760 07	adq  	1,dl
001450  aa   777776 3760 07	anq  	262142,dl
001451  aa  6 00554 0761 00	adq  	pr6|364
001452  aa  7 77736 3715 06	epp5 	pr7|-34,ql	rcpd.volume
001453  aa  5 00000 6351 00	eaa  	pr5|0
001454  aa  6 00222 7551 00	sta  	pr6|146		volume_off
						STATEMENT 1 ON LINE 363
	     end;

001455  aa  6 00556 6515 00	spri5	pr6|366
						STATEMENT 1 ON LINE 368
	if access = "000"b				/* Don't know yet. */
	then do;

001456  aa  6 00100 2351 00	lda  	pr6|64		access
001457  aa   700000 3150 03	cana 	229376,du
001460  aa   000054 6010 04	tnz  	44,ic		001534
						STATEMENT 1 ON LINE 370
	     call rcp_check_access_ (VOLUME_TYPE (rcse.dtypex), (rcse.volume_name), (rcse.group_id), rcse.caller_level,
		access, ecode);

001461  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001462  aa  7 00012 2361 00	ldq  	pr7|10		rcse.dtypex
001463  aa   000003 7360 00	qls  	3
001464  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001465  aa  7 00002 00 0040	desc9a	pr7|2,32		rcse.volume_name
001466  aa  6 00532 00 0040	desc9a	pr6|346,32
001467  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001470  aa  7 00043 00 0040	desc9a	pr7|35,32		rcse.group_id
001471  aa  6 00560 00 0040	desc9a	pr6|368,32
001472  ta   000005 3520 06	epp2 	5,ql
001473  aa  6 00572 2521 00	spri2	pr6|378
001474  aa  6 00532 3521 00	epp2 	pr6|346
001475  aa  6 00574 2521 00	spri2	pr6|380
001476  aa  6 00560 3521 00	epp2 	pr6|368
001477  aa  6 00576 2521 00	spri2	pr6|382
001500  aa  7 00033 3521 00	epp2 	pr7|27		rcse.caller_level
001501  aa  6 00600 2521 00	spri2	pr6|384
001502  aa  6 00100 3521 00	epp2 	pr6|64		access
001503  aa  6 00602 2521 00	spri2	pr6|386
001504  aa  6 00162 3521 00	epp2 	pr6|114		ecode
001505  aa  6 00604 2521 00	spri2	pr6|388
001506  aa  6 00570 6211 00	eax1 	pr6|376
001507  aa   030000 4310 07	fld  	12288,dl
001510  aa  6 00044 3701 20	epp4 	pr6|36,*
001511  la  4 00046 3521 20	epp2 	pr4|38,*		rcp_check_access_
001512  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 372
	     if ecode ^= 0 then do;

001513  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001514  aa   000020 6000 04	tze  	16,ic		001534
						STATEMENT 1 ON LINE 373
		if ecode = error_table_$resource_unknown/* Unregistered volume. */
		     & rcpd.modes.auto_registration	/* And auto registration is on. */
		then do;

001515  aa  6 00044 3701 20	epp4 	pr6|36,*
001516  la  4 00026 1161 20	cmpq 	pr4|22,*		error_table_$resource_unknown
001517  aa   000014 6010 04	tnz  	12,ic		001533
001520  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001521  aa  7 00014 2351 00	lda  	pr7|12		rcpd.auto_registration
001522  aa   010000 3150 03	cana 	4096,du
001523  aa   000010 6000 04	tze  	8,ic		001533
						STATEMENT 1 ON LINE 376
		     rcse.flags.must_auto_register = "1"b;

001524  aa   000001 2350 03	lda  	1,du
001525  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
001526  aa  5 00035 2551 00	orsa 	pr5|29		rcse.must_auto_register
						STATEMENT 1 ON LINE 378
		     access = REW;

001527  aa   700000 2350 03	lda  	229376,du
001530  aa  6 00100 7551 00	sta  	pr6|64		access
						STATEMENT 1 ON LINE 379
		     ecode = 0;

001531  aa  6 00162 4501 00	stz  	pr6|114		ecode
						STATEMENT 1 ON LINE 380
		end;

001532  aa   000002 7100 04	tra  	2,ic		001534
						STATEMENT 1 ON LINE 381
		else return;

001533  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 382
	     end;

						STATEMENT 1 ON LINE 383
	end;

						STATEMENT 1 ON LINE 385
	if rcse.flags.writing then
	     access_needed = RW;

001534  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001535  aa  7 00035 2351 00	lda  	pr7|29		rcse.writing
001536  aa   010000 3150 03	cana 	4096,du
001537  aa   000004 6000 04	tze  	4,ic		001543
001540  aa   500000 2350 03	lda  	163840,du
001541  aa  6 00101 7551 00	sta  	pr6|65		access_needed
001542  aa   000003 7100 04	tra  	3,ic		001545
						STATEMENT 1 ON LINE 387
	else access_needed = R;

001543  aa   400000 2350 03	lda  	131072,du
001544  aa  6 00101 7551 00	sta  	pr6|65		access_needed
						STATEMENT 1 ON LINE 389
	if (access & access_needed) ^= access_needed	/* Must have access_needed access to volume. */
	then do;

001545  aa  6 00100 2351 00	lda  	pr6|64		access
001546  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
001547  aa  6 00101 3751 00	ana  	pr6|65		access_needed
001550  aa  6 00101 1151 00	cmpa 	pr6|65		access_needed
001551  aa   000014 6000 04	tze  	12,ic		001565
						STATEMENT 1 ON LINE 391
	     if access = NULL			/* No access to the resource. */
	     then ecode = error_table_$resource_bad_access;

001552  aa  6 00100 2351 00	lda  	pr6|64		access
001553  aa   700000 3150 03	cana 	229376,du
001554  aa   000005 6010 04	tnz  	5,ic		001561
001555  aa  6 00044 3701 20	epp4 	pr6|36,*
001556  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$resource_bad_access
001557  aa  6 00162 7561 00	stq  	pr6|114		ecode
001560  aa   000004 7100 04	tra  	4,ic		001564
						STATEMENT 1 ON LINE 394
	     else ecode = error_table_$insufficient_access;

001561  aa  6 00044 3701 20	epp4 	pr6|36,*
001562  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$insufficient_access
001563  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 395
	     return;

001564  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 396
	end;

						STATEMENT 1 ON LINE 400
	volume_ptr = ptr (rcpd_ptr, volume_off);

001565  aa  6 00222 2351 00	lda  	pr6|146		volume_off
001566  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
001567  aa   000000 3120 01	eawp2	0,au
001570  aa  6 00240 2521 00	spri2	pr6|160		volume_ptr
						STATEMENT 1 ON LINE 401
	volume.process_id = rcse.process_id;

001571  aa  7 00042 2351 00	lda  	pr7|34		rcse.process_id
001572  aa  2 00000 7551 00	sta  	pr2|0		volume.process_id
						STATEMENT 1 ON LINE 402
	volume.vtypex = rcse.dtypex;

001573  aa  7 00012 2361 00	ldq  	pr7|10		rcse.dtypex
001574  aa  2 00011 7561 00	stq  	pr2|9		volume.vtypex
						STATEMENT 1 ON LINE 403
	volume.unassign_state = volume.state;

001575  aa  2 00036 2361 00	ldq  	pr2|30		volume.state
001576  aa  2 00037 7561 00	stq  	pr2|31		volume.unassign_state
						STATEMENT 1 ON LINE 404
	volume.state = 1;

001577  aa   000001 2360 07	ldq  	1,dl
001600  aa  2 00036 7561 00	stq  	pr2|30		volume.state
						STATEMENT 1 ON LINE 405
	volume.state_time = clock ();

001601  aa  0 01435 7001 00	tsx0 	pr0|797		clock
001602  aa  2 00034 7571 00	staq 	pr2|28		volume.state_time
						STATEMENT 1 ON LINE 406
	volume.volume_name = volume_name;

001603  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001604  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
001605  aa  2 00001 00 0040	desc9a	pr2|1,32		volume.volume_name
						STATEMENT 1 ON LINE 407
	volume.group_id = rcse.group_id;

001606  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001607  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001610  aa  7 00043 00 0040	desc9a	pr7|35,32		rcse.group_id
001611  aa  2 00012 00 0040	desc9a	pr2|10,32		volume.group_id
						STATEMENT 1 ON LINE 408
	if volume.unassign_state = 0 then do;

001612  aa  2 00037 2361 00	ldq  	pr2|31		volume.unassign_state
001613  aa   000006 6010 04	tnz  	6,ic		001621
						STATEMENT 1 ON LINE 409
	     volume.reserved_by = "";

001614  aa  040 100 100 400	mlr  	(),(pr),fill(040)
001615  aa   000000 00 0000	desc9a	0,0
001616  aa  2 00022 00 0040	desc9a	pr2|18,32		volume.reserved_by
						STATEMENT 1 ON LINE 410
	     volume.reservation_id = 0;

001617  aa   776415 2370 04	ldaq 	-755,ic		000234 = 000000000000 000000000000
001620  aa  2 00032 7571 00	staq 	pr2|26		volume.reservation_id
						STATEMENT 1 ON LINE 411
	end;

						STATEMENT 1 ON LINE 412
	volume.current_authorization = get_authorization_ ();

001621  aa  2 00040 3521 00	epp2 	pr2|32		volume.current_authorization
001622  aa  6 00562 2521 00	spri2	pr6|370
001623  aa  6 00560 6211 00	eax1 	pr6|368
001624  aa   004000 4310 07	fld  	2048,dl
001625  aa  6 00044 3701 20	epp4 	pr6|36,*
001626  la  4 00072 3521 20	epp2 	pr4|58,*		get_authorization_
001627  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 415
	volume_name = rcse.volume_name;

001630  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
001631  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
001632  aa  7 00002 00 0040	desc9a	pr7|2,32		rcse.volume_name
001633  aa  6 00212 00 0040	desc9a	pr6|138,32	volume_name
						STATEMENT 1 ON LINE 416
	volume_flag = "1"b;

001634  aa   400000 2350 03	lda  	131072,du
001635  aa  6 00211 7551 00	sta  	pr6|137		volume_flag
						STATEMENT 1 ON LINE 417
	rcse.state = 2;

001636  aa   000002 2360 07	ldq  	2,dl
001637  aa  7 00024 7561 00	stq  	pr7|20		rcse.state
						STATEMENT 1 ON LINE 418
	rcse.volume_off = volume_off;

001640  aa  6 00222 2351 00	lda  	pr6|146		volume_off
001641  aa  7 00031 7551 00	sta  	pr7|25		rcse.volume_off
						STATEMENT 1 ON LINE 420
     end ASSIGN_VOLUME;

001642  aa  6 00256 6101 00	rtcd 	pr6|174
  END PROCEDURE ASSIGN_VOLUME
BEGIN PROCEDURE ASSIGN_DEVICE
ENTRY TO ASSIGN_DEVICE                                      STATEMENT 1 ON LINE 422
ASSIGN_DEVICE:
     procedure;

001643  aa  6 00266 6501 00	spri4	pr6|182
						STATEMENT 1 ON LINE 437
	rcse_ptr = ptr (rcs_ptr, dev_rcse_off);

001644  aa  6 00147 2351 00	lda  	pr6|103		dev_rcse_off
001645  aa  6 00242 3521 20	epp2 	pr6|162,*		rcs_ptr
001646  aa   000000 3120 01	eawp2	0,au
001647  aa  6 00244 2521 00	spri2	pr6|164		rcse_ptr
						STATEMENT 1 ON LINE 438
	dtypex = rcse.dtypex;

001650  aa  2 00012 2361 00	ldq  	pr2|10		rcse.dtypex
001651  aa  6 00161 7561 00	stq  	pr6|113		dtypex
						STATEMENT 1 ON LINE 439
	dtype_ptr = addr (rcpd.dtype (dtypex));

001652  aa   000017 4020 07	mpy  	15,dl
001653  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
001654  aa  7 00024 3735 06	epp7 	pr7|20,ql		rcpd.dtype
001655  aa  6 00234 6535 00	spri7	pr6|156		dtype_ptr
						STATEMENT 1 ON LINE 440
	system_flag = rcse.flags.system;

001656  aa  2 00035 2351 00	lda  	pr2|29		rcse.system
001657  aa   000002 7350 00	als  	2
001660  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001661  aa  6 00204 7551 00	sta  	pr6|132		system_flag
						STATEMENT 1 ON LINE 441
	if rcse.group_id = "Initializer.SysDaemon.z" & rcse.caller_level = 1 then
	     system_flag = "1"b;

001662  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001663  aa  2 00043 00 0040	desc9a	pr2|35,32		rcse.group_id
001664  aa   776405 00 0027	desc9a	-763,23		000267 = 111156151164
001665  aa   000006 6010 04	tnz  	6,ic		001673
001666  aa  2 00033 2361 00	ldq  	pr2|27		rcse.caller_level
001667  aa   000001 1160 07	cmpq 	1,dl
001670  aa   000003 6010 04	tnz  	3,ic		001673
001671  aa   400000 2350 03	lda  	131072,du
001672  aa  6 00204 7551 00	sta  	pr6|132		system_flag
						STATEMENT 1 ON LINE 444
	num_assigned,				/* Initialize counters. */
	     num_free_res, num_reserved, num_resvd = 0;

001673  aa  6 00172 4501 00	stz  	pr6|122		num_assigned
001674  aa  6 00175 4501 00	stz  	pr6|125		num_free_res
001675  aa  6 00176 4501 00	stz  	pr6|126		num_reserved
001676  aa  6 00177 4501 00	stz  	pr6|127		num_resvd
						STATEMENT 1 ON LINE 446
	num_appropriate, num_accessible, num_available = 0;

001677  aa  6 00171 4501 00	stz  	pr6|121		num_appropriate
001700  aa  6 00170 4501 00	stz  	pr6|120		num_accessible
001701  aa  6 00174 4501 00	stz  	pr6|124		num_available
						STATEMENT 1 ON LINE 448
	device_off = dtype.first_off;

001702  aa  7 00013 2351 00	lda  	pr7|11		dtype.first_off
001703  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 449
	do while (device_off ^= "0"b);

001704  aa  6 00160 2351 00	lda  	pr6|112		device_off
001705  aa   000011 6000 04	tze  	9,ic		001716
						STATEMENT 1 ON LINE 450
	     device_ptr = ptr (rcpd_ptr, device_off);

001706  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
001707  aa   000000 3120 01	eawp2	0,au
001710  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 451
	     call TEST_DEVICE;

001711  aa   000435 6700 04	tsp4 	285,ic		002346
						STATEMENT 1 ON LINE 452
	     device_off = device.next_off;

001712  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
001713  aa  7 00031 2351 00	lda  	pr7|25		device.next_off
001714  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 453
	end;

001715  aa   777767 7100 04	tra  	-9,ic		001704
						STATEMENT 1 ON LINE 455
	if num_appropriate = 0			/* Did we find any appropriate device? */
	then do;

001716  aa  6 00171 2361 00	ldq  	pr6|121		num_appropriate
001717  aa   000005 6010 04	tnz  	5,ic		001724
						STATEMENT 1 ON LINE 457
	     ecode = error_table_$resource_unknown;

001720  aa  6 00044 3701 20	epp4 	pr6|36,*
001721  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$resource_unknown
001722  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 458
	     return;

001723  aa  6 00266 6101 00	rtcd 	pr6|182
						STATEMENT 1 ON LINE 459
	end;

						STATEMENT 1 ON LINE 461
	if num_accessible = 0			/* Did we find any accessible device? */
	then do;

001724  aa  6 00170 2361 00	ldq  	pr6|120		num_accessible
001725  aa   000005 6010 04	tnz  	5,ic		001732
						STATEMENT 1 ON LINE 463
	     ecode = error_table_$resource_bad_access;

001726  aa  6 00044 3701 20	epp4 	pr6|36,*
001727  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$resource_bad_access
001730  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 464
	     return;

001731  aa  6 00266 6101 00	rtcd 	pr6|182
						STATEMENT 1 ON LINE 465
	end;

						STATEMENT 1 ON LINE 467
	if num_available = 0			/* Did we find any available device? */
	then do;

001732  aa  6 00174 2361 00	ldq  	pr6|124		num_available
001733  aa   000005 6010 04	tnz  	5,ic		001740
						STATEMENT 1 ON LINE 469
	     ecode = error_table_$resource_unavailable;

001734  aa  6 00044 3701 20	epp4 	pr6|36,*
001735  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$resource_unavailable
001736  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 470
	     return;

001737  aa  6 00266 6101 00	rtcd 	pr6|182
						STATEMENT 1 ON LINE 471
	end;

						STATEMENT 1 ON LINE 473
	call CHECK_LIMITS;

001740  aa   000565 6700 04	tsp4 	373,ic		002525
						STATEMENT 1 ON LINE 474
	if ecode ^= 0 then
	     return;

001741  aa  6 00162 2361 00	ldq  	pr6|114		ecode
001742  aa   000002 6000 04	tze  	2,ic		001744
001743  aa  6 00266 6101 00	rtcd 	pr6|182
						STATEMENT 1 ON LINE 476
	if num_resvd > 0 then do;

001744  aa  6 00177 2361 00	ldq  	pr6|127		num_resvd
001745  aa   000030 6044 04	tmoz 	24,ic		001775
						STATEMENT 1 ON LINE 477
	     j = 0;

001746  aa  6 00164 4501 00	stz  	pr6|116		j
						STATEMENT 1 ON LINE 478
	     do i = 1 to num_available;

001747  aa  6 00174 2361 00	ldq  	pr6|124		num_available
001750  aa  6 00275 7561 00	stq  	pr6|189
001751  aa   000001 2360 07	ldq  	1,dl
001752  aa  6 00163 7561 00	stq  	pr6|115		i
001753  aa   000000 0110 03	nop  	0,du
001754  aa  6 00163 2361 00	ldq  	pr6|115		i
001755  aa  6 00275 1161 00	cmpq 	pr6|189
001756  aa   000015 6054 04	tpnz 	13,ic		001773
						STATEMENT 1 ON LINE 479
		if available_list (i) -> device.state = 4 then do;

001757  aa   000001 7360 00	qls  	1
001760  aa  6 00104 3735 26	epp7 	pr6|68,ql*	available_list
001761  aa  6 00606 7561 00	stq  	pr6|390
001762  aa  7 00024 2361 00	ldq  	pr7|20		device.state
001763  aa   000004 1160 07	cmpq 	4,dl
001764  aa   000005 6010 04	tnz  	5,ic		001771
						STATEMENT 1 ON LINE 480
		     j = j + 1;

001765  aa  6 00164 0541 00	aos  	pr6|116		j
						STATEMENT 1 ON LINE 481
		     available_list (j) = available_list (i);

001766  aa  6 00164 2361 00	ldq  	pr6|116		j
001767  aa   000001 7360 00	qls  	1
001770  aa  6 00104 6535 06	spri7	pr6|68,ql		available_list
						STATEMENT 1 ON LINE 482
		end;

						STATEMENT 1 ON LINE 483
	     end;

001771  aa  6 00163 0541 00	aos  	pr6|115		i
001772  aa   777762 7100 04	tra  	-14,ic		001754
						STATEMENT 1 ON LINE 484
	     num_available = j;

001773  aa  6 00164 2361 00	ldq  	pr6|116		j
001774  aa  6 00174 7561 00	stq  	pr6|124		num_available
						STATEMENT 1 ON LINE 485
	end;

						STATEMENT 1 ON LINE 487
	call rcp_match_$select (addr (available_list), num_available, rcse.volume_name, device_ptr);

001775  aa  6 00106 3735 00	epp7 	pr6|70		available_list
001776  aa  6 00610 6535 00	spri7	pr6|392
001777  aa  6 00610 3521 00	epp2 	pr6|392
002000  aa  6 00614 2521 00	spri2	pr6|396
002001  aa  6 00174 3521 00	epp2 	pr6|124		num_available
002002  aa  6 00616 2521 00	spri2	pr6|398
002003  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002004  aa  5 00002 3521 00	epp2 	pr5|2		rcse.volume_name
002005  aa  6 00620 2521 00	spri2	pr6|400
002006  aa  6 00236 3521 00	epp2 	pr6|158		device_ptr
002007  aa  6 00622 2521 00	spri2	pr6|402
002010  aa   776212 3520 04	epp2 	-886,ic		000222 = 464000000000
002011  aa  6 00624 2521 00	spri2	pr6|404
002012  aa  6 00632 2521 00	spri2	pr6|410
002013  aa   776202 3520 04	epp2 	-894,ic		000215 = 404000000021
002014  aa  6 00626 2521 00	spri2	pr6|406
002015  aa   776174 3520 04	epp2 	-900,ic		000211 = 524000000040
002016  aa  6 00630 2521 00	spri2	pr6|408
002017  aa  6 00612 6211 00	eax1 	pr6|394
002020  aa   020000 4310 07	fld  	8192,dl
002021  aa  6 00044 3701 20	epp4 	pr6|36,*
002022  la  4 00056 3521 20	epp2 	pr4|46,*		rcp_match_$select
002023  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 488
	device_off = rel (device_ptr);

002024  aa  6 00236 6351 20	eaa  	pr6|158,*		device_ptr
002025  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 490
	rcse.flags.volume = "0"b;

002026  aa   002461 2350 04	lda  	1329,ic		004507 = 757777777777
002027  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
002030  aa  7 00035 3551 00	ansa 	pr7|29		rcse.volume
						STATEMENT 1 ON LINE 491
	if device.volume_name ^= " " then do;

002031  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
002032  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002033  aa  5 00002 00 0040	desc9a	pr5|2,32		device.volume_name
002034  aa   002456 00 0001	desc9a	1326,1		004510 = 040000000000
002035  aa   000102 6000 04	tze  	66,ic		002137
						STATEMENT 1 ON LINE 492
	     if rcpd.modes.resource_mgmt_enabled then do;

002036  aa  6 00232 3535 20	epp3 	pr6|154,*		rcpd_ptr
002037  aa  3 00014 2351 00	lda  	pr3|12		rcpd.resource_mgmt_enabled
002040  aa   020000 3150 03	cana 	8192,du
002041  aa   000051 6000 04	tze  	41,ic		002112
						STATEMENT 1 ON LINE 493
		call rcp_check_access_ (VOLUME_TYPE (device.dtypex), (device.volume_name), (rcse.group_id),
		     rcse.caller_level, access, ecode);

002042  aa  5 00012 2361 00	ldq  	pr5|10		device.dtypex
002043  aa   000003 7360 00	qls  	3
002044  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002045  aa  5 00002 00 0040	desc9a	pr5|2,32		device.volume_name
002046  aa  6 00612 00 0040	desc9a	pr6|394,32
002047  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002050  aa  7 00043 00 0040	desc9a	pr7|35,32		rcse.group_id
002051  aa  6 00634 00 0040	desc9a	pr6|412,32
002052  ta   000005 3520 06	epp2 	5,ql
002053  aa  6 00646 2521 00	spri2	pr6|422
002054  aa  6 00612 3521 00	epp2 	pr6|394
002055  aa  6 00650 2521 00	spri2	pr6|424
002056  aa  6 00634 3521 00	epp2 	pr6|412
002057  aa  6 00652 2521 00	spri2	pr6|426
002060  aa  7 00033 3521 00	epp2 	pr7|27		rcse.caller_level
002061  aa  6 00654 2521 00	spri2	pr6|428
002062  aa  6 00100 3521 00	epp2 	pr6|64		access
002063  aa  6 00656 2521 00	spri2	pr6|430
002064  aa  6 00162 3521 00	epp2 	pr6|114		ecode
002065  aa  6 00660 2521 00	spri2	pr6|432
002066  aa  6 00644 6211 00	eax1 	pr6|420
002067  aa   030000 4310 07	fld  	12288,dl
002070  aa  6 00044 3701 20	epp4 	pr6|36,*
002071  la  4 00046 3521 20	epp2 	pr4|38,*		rcp_check_access_
002072  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 495
		if (ecode = 0) & (access ^= NULL) then do;

002073  aa  6 00162 2361 00	ldq  	pr6|114		ecode
002074  aa   000014 6010 04	tnz  	12,ic		002110
002075  aa  6 00100 2351 00	lda  	pr6|64		access
002076  aa   700000 3150 03	cana 	229376,du
002077  aa   000011 6000 04	tze  	9,ic		002110
						STATEMENT 1 ON LINE 496
		     rcse.flags.volume = "1"b;

002100  aa   020000 2350 03	lda  	8192,du
002101  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
002102  aa  7 00035 2551 00	orsa 	pr7|29		rcse.volume
						STATEMENT 1 ON LINE 497
		     rcse.volume_name = device.volume_name;

002103  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
002104  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002105  aa  5 00002 00 0040	desc9a	pr5|2,32		device.volume_name
002106  aa  7 00002 00 0040	desc9a	pr7|2,32		rcse.volume_name
						STATEMENT 1 ON LINE 498
		end;

002107  aa   000030 7100 04	tra  	24,ic		002137
						STATEMENT 1 ON LINE 499
		else ecode = 0;

002110  aa  6 00162 4501 00	stz  	pr6|114		ecode
						STATEMENT 1 ON LINE 500
	     end;

002111  aa   000026 7100 04	tra  	22,ic		002137
						STATEMENT 1 ON LINE 501
	     else if rcp_match_user_name_ (rcse.group_id, device.group_id) then do;

002112  aa  7 00043 3521 00	epp2 	pr7|35		rcse.group_id
002113  aa  6 00636 2521 00	spri2	pr6|414
002114  aa  5 00037 3521 00	epp2 	pr5|31		device.group_id
002115  aa  6 00640 2521 00	spri2	pr6|416
002116  aa  6 00607 3521 00	epp2 	pr6|391
002117  aa  6 00642 2521 00	spri2	pr6|418
002120  aa  6 00634 6211 00	eax1 	pr6|412
002121  aa   014000 4310 07	fld  	6144,dl
002122  aa  6 00044 3701 20	epp4 	pr6|36,*
002123  la  4 00060 3521 20	epp2 	pr4|48,*		rcp_match_user_name_
002124  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002125  aa  6 00607 2351 00	lda  	pr6|391
002126  aa   400000 3150 03	cana 	131072,du
002127  aa   000010 6000 04	tze  	8,ic		002137
						STATEMENT 1 ON LINE 502
		rcse.flags.volume = "1"b;

002130  aa   020000 2350 03	lda  	8192,du
002131  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
002132  aa  7 00035 2551 00	orsa 	pr7|29		rcse.volume
						STATEMENT 1 ON LINE 503
		rcse.volume_name = device.volume_name;

002133  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
002134  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002135  aa  5 00002 00 0040	desc9a	pr5|2,32		device.volume_name
002136  aa  7 00002 00 0040	desc9a	pr7|2,32		rcse.volume_name
						STATEMENT 1 ON LINE 504
	     end;

						STATEMENT 1 ON LINE 505
	end;

						STATEMENT 1 ON LINE 507
	rcse.flags.preload_allowed = ^rcpd.modes.unload_on_detach;

002137  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
002140  aa  7 00014 2351 00	lda  	pr7|12		rcpd.unload_on_detach
002141  aa   000001 7350 00	als  	1
002142  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002143  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002144  aa   000011 7710 00	arl  	9
002145  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002146  aa  5 00035 6751 00	era  	pr5|29		rcse.preload_allowed
002147  aa   000400 3750 03	ana  	256,du
002150  aa  5 00035 6551 00	ersa 	pr5|29		rcse.preload_allowed
						STATEMENT 1 ON LINE 508
	rcse.flags.not_removable_media = device.flags.not_removable_media;

002151  aa  6 00236 3535 20	epp3 	pr6|158,*		device_ptr
002152  aa  3 00035 2351 00	lda  	pr3|29		device.not_removable_media
002153  aa   000004 7710 00	arl  	4
002154  aa  5 00035 6751 00	era  	pr5|29		rcse.not_removable_media
002155  aa   000100 3750 03	ana  	64,du
002156  aa  5 00035 6551 00	ersa 	pr5|29		rcse.not_removable_media
						STATEMENT 1 ON LINE 510
	device.process_id = rcse.process_id;

002157  aa  5 00042 2351 00	lda  	pr5|34		rcse.process_id
002160  aa  3 00036 7551 00	sta  	pr3|30		device.process_id
						STATEMENT 1 ON LINE 511
	device.group_id = rcse.group_id;

002161  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002162  aa  5 00043 00 0040	desc9a	pr5|35,32		rcse.group_id
002163  aa  3 00037 00 0040	desc9a	pr3|31,32		device.group_id
						STATEMENT 1 ON LINE 512
	if device.flags.reservable			/* Can device be reserved? */
	then device.flags.reserved = system_flag;

002164  aa  3 00035 2351 00	lda  	pr3|29		device.reservable
002165  aa   100000 3150 03	cana 	32768,du
002166  aa   000007 6000 04	tze  	7,ic		002175
002167  aa  6 00204 2351 00	lda  	pr6|132		system_flag
002170  aa   000003 7710 00	arl  	3
002171  aa  3 00035 6751 00	era  	pr3|29		device.reserved
002172  aa   040000 3750 03	ana  	16384,du
002173  aa  3 00035 6551 00	ersa 	pr3|29		device.reserved
002174  aa   000003 7100 04	tra  	3,ic		002177
						STATEMENT 1 ON LINE 514
	else device.flags.reserved = "0"b;

002175  aa   002311 2350 04	lda  	1225,ic		004506 = 737777777777
002176  aa  3 00035 3551 00	ansa 	pr3|29		device.reserved
						STATEMENT 1 ON LINE 515
	if device.state = 2				/* Are we assigning a deleted device? */
	then do;

002177  aa  3 00024 2361 00	ldq  	pr3|20		device.state
002200  aa   000002 1160 07	cmpq 	2,dl
002201  aa   000026 6010 04	tnz  	22,ic		002227
						STATEMENT 1 ON LINE 517
	     call admin_gate_$ioi_add_device ((device.device_name), ignored_code);

002202  aa  3 00000 2351 00	lda  	pr3|0		device.device_name
002203  aa  3 00001 2361 00	ldq  	pr3|1		device.device_name
002204  aa  6 00610 7571 00	staq 	pr6|392
002205  aa  6 00610 3521 00	epp2 	pr6|392
002206  aa  6 00646 2521 00	spri2	pr6|422
002207  aa  6 00274 3521 00	epp2 	pr6|188		ignored_code
002210  aa  6 00650 2521 00	spri2	pr6|424
002211  aa   775777 3520 04	epp2 	-1025,ic		000210 = 524000000010
002212  aa  6 00652 2521 00	spri2	pr6|426
002213  aa   776013 3520 04	epp2 	-1013,ic		000226 = 404000000043
002214  aa  6 00654 2521 00	spri2	pr6|428
002215  aa  6 00644 6211 00	eax1 	pr6|420
002216  aa   010000 4310 07	fld  	4096,dl
002217  aa  6 00044 3701 20	epp4 	pr6|36,*
002220  la  4 00030 3521 20	epp2 	pr4|24,*		admin_gate_$ioi_add_device
002221  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 518
	     device.flags.delete,			/* Remember to delete when unassigned. */
		device.flags.priv = "1"b;

002222  aa   400000 2350 03	lda  	131072,du
002223  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002224  aa  7 00035 2551 00	orsa 	pr7|29		device.delete
002225  aa   200000 2350 03	lda  	65536,du
002226  aa  7 00035 2551 00	orsa 	pr7|29		device.priv
						STATEMENT 1 ON LINE 520
	end;

						STATEMENT 1 ON LINE 521
	device.state_time = clock ();

002227  aa  0 01435 7001 00	tsx0 	pr0|797		clock
002230  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002231  aa  7 00022 7571 00	staq 	pr7|18		device.state_time
						STATEMENT 1 ON LINE 522
	device.unassign_state = device.state;

002232  aa  7 00024 2361 00	ldq  	pr7|20		device.state
002233  aa  7 00025 7561 00	stq  	pr7|21		device.unassign_state
						STATEMENT 1 ON LINE 523
	device.current_authorization = get_authorization_ ();

002234  aa  7 00072 3521 00	epp2 	pr7|58		device.current_authorization
002235  aa  6 00636 2521 00	spri2	pr6|414
002236  aa  6 00634 6211 00	eax1 	pr6|412
002237  aa   004000 4310 07	fld  	2048,dl
002240  aa  6 00044 3701 20	epp4 	pr6|36,*
002241  la  4 00072 3521 20	epp2 	pr4|58,*		get_authorization_
002242  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 525
	device.state = 1;

002243  aa   000001 2360 07	ldq  	1,dl
002244  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002245  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 527
	if device.unassign_state ^= 4 then		/* Accounting for reserved devices is done at reservation time. */
	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_assign);

002246  aa  7 00025 2361 00	ldq  	pr7|21		device.unassign_state
002247  aa   000004 1160 07	cmpq 	4,dl
002250  aa   000003 6000 04	tze  	3,ic		002253
002251  aa   002227 3520 04	epp2 	1175,ic		004500 = 000004000000
002252  aa   002137 6700 04	tsp4 	1119,ic		004411
						STATEMENT 1 ON LINE 530
	rcse.state = 2;

002253  aa   000002 2360 07	ldq  	2,dl
002254  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
002255  aa  7 00024 7561 00	stq  	pr7|20		rcse.state
						STATEMENT 1 ON LINE 531
	rcse.device_off = device_off;

002256  aa  6 00160 2351 00	lda  	pr6|112		device_off
002257  aa  7 00030 7551 00	sta  	pr7|24		rcse.device_off
						STATEMENT 1 ON LINE 532
	rcse.device_name = device.device_name;

002260  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
002261  aa  5 00000 2351 00	lda  	pr5|0		device.device_name
002262  aa  5 00001 2361 00	ldq  	pr5|1		device.device_name
002263  aa  7 00000 7551 00	sta  	pr7|0		rcse.device_name
002264  aa  7 00001 7561 00	stq  	pr7|1		rcse.device_name
						STATEMENT 1 ON LINE 533
	rcse.model = device.model;

002265  aa  5 00013 2361 00	ldq  	pr5|11		device.model
002266  aa  7 00013 7561 00	stq  	pr7|11		rcse.model
						STATEMENT 1 ON LINE 534
	do i = 1 to device.num_qualifiers;

002267  aa  5 00014 2361 00	ldq  	pr5|12		device.num_qualifiers
002270  aa  6 00276 7561 00	stq  	pr6|190
002271  aa   000001 2360 07	ldq  	1,dl
002272  aa  6 00163 7561 00	stq  	pr6|115		i
002273  aa   000000 0110 03	nop  	0,du
002274  aa  6 00163 2361 00	ldq  	pr6|115		i
002275  aa  6 00276 1161 00	cmpq 	pr6|190
002276  aa   000010 6054 04	tpnz 	8,ic		002306
						STATEMENT 1 ON LINE 535
	     rcse.qualifiers (i) = device.qualifiers (i);

002277  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002300  aa  7 00014 2361 06	ldq  	pr7|12,ql		device.qualifiers
002301  aa  6 00163 7271 00	lxl7 	pr6|115		i
002302  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002303  aa  5 00014 7561 17	stq  	pr5|12,7		rcse.qualifiers
						STATEMENT 1 ON LINE 536
	end;

002304  aa  6 00163 0541 00	aos  	pr6|115		i
002305  aa   777767 7100 04	tra  	-9,ic		002274
						STATEMENT 1 ON LINE 537
	rcse.flags.system = system_flag;

002306  aa  6 00204 2351 00	lda  	pr6|132		system_flag
002307  aa   000002 7710 00	arl  	2
002310  aa  6 00244 3735 20	epp7 	pr6|164,*		rcse_ptr
002311  aa  7 00035 6751 00	era  	pr7|29		rcse.system
002312  aa   100000 3750 03	ana  	32768,du
002313  aa  7 00035 6551 00	ersa 	pr7|29		rcse.system
						STATEMENT 1 ON LINE 541
	call admin_gate_$syserr (LOG, "RCP: Assigned ^a to ^a", device.device_name, device.group_id);

002314  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002315  aa   775745 00 0030	desc9a	-1051,24		000261 = 122103120072
002316  aa  6 00634 00 0030	desc9a	pr6|412,24
002317  aa   775706 3520 04	epp2 	-1082,ic		000225 = 000000000004
002320  aa  6 00614 2521 00	spri2	pr6|396
002321  aa  6 00634 3521 00	epp2 	pr6|412
002322  aa  6 00616 2521 00	spri2	pr6|398
002323  aa  6 00236 3521 20	epp2 	pr6|158,*		device.device_name
002324  aa  6 00620 2521 00	spri2	pr6|400
002325  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
002326  aa  5 00037 3521 00	epp2 	pr5|31		device.group_id
002327  aa  6 00622 2521 00	spri2	pr6|402
002330  aa   775665 3520 04	epp2 	-1099,ic		000215 = 404000000021
002331  aa  6 00624 2521 00	spri2	pr6|404
002332  aa   775655 3520 04	epp2 	-1107,ic		000207 = 524000000026
002333  aa  6 00626 2521 00	spri2	pr6|406
002334  aa   775654 3520 04	epp2 	-1108,ic		000210 = 524000000010
002335  aa  6 00630 2521 00	spri2	pr6|408
002336  aa   775653 3520 04	epp2 	-1109,ic		000211 = 524000000040
002337  aa  6 00632 2521 00	spri2	pr6|410
002340  aa  6 00612 6211 00	eax1 	pr6|394
002341  aa   020000 4310 07	fld  	8192,dl
002342  aa  6 00044 3701 20	epp4 	pr6|36,*
002343  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
002344  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 543
     end ASSIGN_DEVICE;

002345  aa  6 00266 6101 00	rtcd 	pr6|182
  END PROCEDURE ASSIGN_DEVICE
BEGIN PROCEDURE TEST_DEVICE
ENTRY TO TEST_DEVICE                                        STATEMENT 1 ON LINE 545
TEST_DEVICE:
     procedure;

002346  aa  6 00300 6501 00	spri4	pr6|192
						STATEMENT 1 ON LINE 552
	goto DEVICE_STATE (device.state);

002347  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002350  aa  7 00024 7271 00	lxl7 	pr7|20		device.state
002351  ta   000010 7100 17	tra  	8,7
						STATEMENT 1 ON LINE 554
DEVICE_STATE (3):					/* SHARED by STORAGE SYSTEM */
	return;

002352  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 557
DEVICE_STATE (2):					/* DELETED. */
	if rcse.flags.priv				/* Is assignment for a privileged attachment? */
	then goto DEVICE_STATE (0);

002353  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002354  aa  5 00035 2351 00	lda  	pr5|29		rcse.priv
002355  aa   200000 3150 03	cana 	65536,du
002356  aa   775432 6010 04	tnz  	-1254,ic		000010
						STATEMENT 1 ON LINE 560
	else return;

002357  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 562
DEVICE_STATE (1):					/* ASSIGNED. */
	if device.process_id = rcse.process_id		/* Assigned to requesting process? */
	then num_assigned = num_assigned + 1;

002360  aa  7 00036 2351 00	lda  	pr7|30		device.process_id
002361  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002362  aa  5 00042 1151 00	cmpa 	pr5|34		rcse.process_id
002363  aa   000002 6010 04	tnz  	2,ic		002365
002364  aa  6 00172 0541 00	aos  	pr6|122		num_assigned
						STATEMENT 1 ON LINE 565
	if device.flags.reserved			/* Is device reserved to a system process? */
	then num_reserved = num_reserved + 1;

002365  aa  7 00035 2351 00	lda  	pr7|29		device.reserved
002366  aa   040000 3150 03	cana 	16384,du
002367  aa   000002 6000 04	tze  	2,ic		002371
002370  aa  6 00176 0541 00	aos  	pr6|126		num_reserved
						STATEMENT 1 ON LINE 567
	available_flag = "0"b;

002371  aa  6 00104 4501 00	stz  	pr6|68		available_flag
						STATEMENT 1 ON LINE 568
	goto AAA_TEST;

002372  aa   000020 7100 04	tra  	16,ic		002412
						STATEMENT 1 ON LINE 570
DEVICE_STATE (4):					/* RESERVED */
	if device.process_id = rcse.process_id then
	     available_flag = "1"b;

002373  aa  7 00036 2351 00	lda  	pr7|30		device.process_id
002374  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002375  aa  5 00042 1151 00	cmpa 	pr5|34		rcse.process_id
002376  aa   000004 6010 04	tnz  	4,ic		002402
002377  aa   400000 2350 03	lda  	131072,du
002400  aa  6 00104 7551 00	sta  	pr6|68		available_flag
002401  aa   000011 7100 04	tra  	9,ic		002412
						STATEMENT 1 ON LINE 573
	else available_flag = "0"b;

002402  aa  6 00104 4501 00	stz  	pr6|68		available_flag
						STATEMENT 1 ON LINE 574
	goto AAA_TEST;

002403  aa   000007 7100 04	tra  	7,ic		002412
						STATEMENT 1 ON LINE 576
DEVICE_STATE (0):					/* FREE. */
	if device.flags.reservable			/* Can this device be reserved? */
	then num_free_res = num_free_res + 1;

002404  aa  7 00035 2351 00	lda  	pr7|29		device.reservable
002405  aa   100000 3150 03	cana 	32768,du
002406  aa   000002 6000 04	tze  	2,ic		002410
002407  aa  6 00175 0541 00	aos  	pr6|125		num_free_res
						STATEMENT 1 ON LINE 579
	available_flag = "1"b;

002410  aa   400000 2350 03	lda  	131072,du
002411  aa  6 00104 7551 00	sta  	pr6|68		available_flag
						STATEMENT 1 ON LINE 581
AAA_TEST:						/* Make Appropriate, Accessible, Available test. */
	match_flag = rcp_match_$match (rcse_ptr, device_ptr);

002412  aa  6 00244 3521 00	epp2 	pr6|164		rcse_ptr
002413  aa  6 00664 2521 00	spri2	pr6|436
002414  aa  6 00236 3521 00	epp2 	pr6|158		device_ptr
002415  aa  6 00666 2521 00	spri2	pr6|438
002416  aa  6 00165 3521 00	epp2 	pr6|117		match_flag
002417  aa  6 00670 2521 00	spri2	pr6|440
002420  aa  6 00662 6211 00	eax1 	pr6|434
002421  aa   014000 4310 07	fld  	6144,dl
002422  aa  6 00044 3701 20	epp4 	pr6|36,*
002423  la  4 00054 3521 20	epp2 	pr4|44,*		rcp_match_$match
002424  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 583
	if match_flag				/* Did it match, i.e., is it appropriate? */
	then num_appropriate = num_appropriate + 1;

002425  aa  6 00165 2351 00	lda  	pr6|117		match_flag
002426  aa   400000 3150 03	cana 	131072,du
002427  aa   000003 6000 04	tze  	3,ic		002432
002430  aa  6 00171 0541 00	aos  	pr6|121		num_appropriate
002431  aa   000002 7100 04	tra  	2,ic		002433
						STATEMENT 1 ON LINE 585
	else return;

002432  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 586
	call rcp_check_access_ (DEVICE_TYPE (device.dtypex), (device.device_name), (rcse.group_id), rcse.caller_level,
	     access, ecode);

002433  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002434  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
002435  aa   000003 7360 00	qls  	3
002436  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002437  aa  7 00000 00 0010	desc9a	pr7|0,8		device.device_name
002440  aa  6 00662 00 0040	desc9a	pr6|434,32
002441  aa  6 00244 3715 20	epp5 	pr6|164,*		rcse_ptr
002442  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002443  aa  5 00043 00 0040	desc9a	pr5|35,32		rcse.group_id
002444  aa  6 00672 00 0040	desc9a	pr6|442,32
002445  ta   000075 3520 06	epp2 	61,ql
002446  aa  6 00704 2521 00	spri2	pr6|452
002447  aa  6 00662 3521 00	epp2 	pr6|434
002450  aa  6 00706 2521 00	spri2	pr6|454
002451  aa  6 00672 3521 00	epp2 	pr6|442
002452  aa  6 00710 2521 00	spri2	pr6|456
002453  aa  5 00033 3521 00	epp2 	pr5|27		rcse.caller_level
002454  aa  6 00712 2521 00	spri2	pr6|458
002455  aa  6 00100 3521 00	epp2 	pr6|64		access
002456  aa  6 00714 2521 00	spri2	pr6|460
002457  aa  6 00162 3521 00	epp2 	pr6|114		ecode
002460  aa  6 00716 2521 00	spri2	pr6|462
002461  aa  6 00702 6211 00	eax1 	pr6|450
002462  aa   030000 4310 07	fld  	12288,dl
002463  aa  6 00044 3701 20	epp4 	pr6|36,*
002464  la  4 00046 3521 20	epp2 	pr4|38,*		rcp_check_access_
002465  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 588
	if ecode = 0 then
	     accessible_flag = ((access & RW) = RW);

002466  aa  6 00162 2361 00	ldq  	pr6|114		ecode
002467  aa   000010 6010 04	tnz  	8,ic		002477
002470  aa  6 00100 2351 00	lda  	pr6|64		access
002471  aa  0 00006 3771 00	anaq 	pr0|6		= 700000000000 000000000000
002472  aa   500000 3750 03	ana  	163840,du
002473  aa   500000 1150 03	cmpa 	163840,du
002474  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
002475  aa  6 00102 7551 00	sta  	pr6|66		accessible_flag
002476  aa   000003 7100 04	tra  	3,ic		002501
						STATEMENT 1 ON LINE 590
	else do;

						STATEMENT 1 ON LINE 591
	     accessible_flag = "0"b;

002477  aa  6 00102 4501 00	stz  	pr6|66		accessible_flag
						STATEMENT 1 ON LINE 592
	     ecode = 0;

002500  aa  6 00162 4501 00	stz  	pr6|114		ecode
						STATEMENT 1 ON LINE 593
	end;

						STATEMENT 1 ON LINE 594
	if accessible_flag				/* Does this process have "RW" access to this device? */
	then num_accessible = num_accessible + 1;

002501  aa  6 00102 2351 00	lda  	pr6|66		accessible_flag
002502  aa   000003 6000 04	tze  	3,ic		002505
002503  aa  6 00170 0541 00	aos  	pr6|120		num_accessible
002504  aa   000002 7100 04	tra  	2,ic		002506
						STATEMENT 1 ON LINE 596
	else return;

002505  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 597
	if available_flag				/* Is this device available? */
	then num_available = num_available + 1;

002506  aa  6 00104 2351 00	lda  	pr6|68		available_flag
002507  aa   000003 6000 04	tze  	3,ic		002512
002510  aa  6 00174 0541 00	aos  	pr6|124		num_available
002511  aa   000002 7100 04	tra  	2,ic		002513
						STATEMENT 1 ON LINE 599
	else return;

002512  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 600
	available_list (num_available) = device_ptr;

002513  aa  6 00174 2361 00	ldq  	pr6|124		num_available
002514  aa   000001 7360 00	qls  	1
002515  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002516  aa  6 00104 6535 06	spri7	pr6|68,ql		available_list
						STATEMENT 1 ON LINE 601
	if device.state = 4 then			/* a reserved device */
	     num_resvd = num_resvd + 1;

002517  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002520  aa  7 00024 2361 00	ldq  	pr7|20		device.state
002521  aa   000004 1160 07	cmpq 	4,dl
002522  aa   000002 6010 04	tnz  	2,ic		002524
002523  aa  6 00177 0541 00	aos  	pr6|127		num_resvd
						STATEMENT 1 ON LINE 604
     end TEST_DEVICE;

002524  aa  6 00300 6101 00	rtcd 	pr6|192
  END PROCEDURE TEST_DEVICE
BEGIN PROCEDURE CHECK_LIMITS
ENTRY TO CHECK_LIMITS                                       STATEMENT 1 ON LINE 606
CHECK_LIMITS:
     procedure;

002525  aa  6 00306 6501 00	spri4	pr6|198
						STATEMENT 1 ON LINE 616
	if system_flag				/* Is this a system process? */
	then return;

002526  aa  6 00204 2351 00	lda  	pr6|132		system_flag
002527  aa   000002 6000 04	tze  	2,ic		002531
002530  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 619
	if num_resvd ^= 0 then
	     return;

002531  aa  6 00177 2361 00	ldq  	pr6|127		num_resvd
002532  aa   000002 6000 04	tze  	2,ic		002534
002533  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 622
	if num_assigned >= dtype.max_concurrent		/* Maximum already assigned to this process? */
	then do;

002534  aa  6 00172 2361 00	ldq  	pr6|122		num_assigned
002535  aa  6 00234 3735 20	epp7 	pr6|156,*		dtype_ptr
002536  aa  7 00010 1161 00	cmpq 	pr7|8		dtype.max_concurrent
002537  aa   000005 6040 04	tmi  	5,ic		002544
						STATEMENT 1 ON LINE 624
	     ecode = error_table_$device_limit_exceeded;

002540  aa  6 00044 3701 20	epp4 	pr6|36,*
002541  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$device_limit_exceeded
002542  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 625
	     return;

002543  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 626
	end;

						STATEMENT 1 ON LINE 628
	if num_reserved >= dtype.num_reserved		/* Already using the quota of system drives? */
	then return;

002544  aa  6 00176 2361 00	ldq  	pr6|126		num_reserved
002545  aa  7 00011 1161 00	cmpq 	pr7|9		dtype.num_reserved
002546  aa   000002 6040 04	tmi  	2,ic		002550
002547  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 631
	if num_free_res > (dtype.num_reserved - num_reserved) then
	     return;

002550  aa  7 00011 2361 00	ldq  	pr7|9		dtype.num_reserved
002551  aa  6 00176 1761 00	sbq  	pr6|126		num_reserved
002552  aa  6 00175 1161 00	cmpq 	pr6|125		num_free_res
002553  aa   000002 6050 04	tpl  	2,ic		002555
002554  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 634
	num_avail_nres = 0;

002555  aa  6 00173 4501 00	stz  	pr6|123		num_avail_nres
						STATEMENT 1 ON LINE 635
	do i = 1 to num_available;

002556  aa  6 00174 2361 00	ldq  	pr6|124		num_available
002557  aa  6 00314 7561 00	stq  	pr6|204
002560  aa   000001 2360 07	ldq  	1,dl
002561  aa  6 00163 7561 00	stq  	pr6|115		i
002562  aa  6 00163 2361 00	ldq  	pr6|115		i
002563  aa  6 00314 1161 00	cmpq 	pr6|204
002564  aa   000015 6054 04	tpnz 	13,ic		002601
						STATEMENT 1 ON LINE 636
	     device_ptr = available_list (i);

002565  aa   000001 7360 00	qls  	1
002566  aa  6 00104 3735 26	epp7 	pr6|68,ql*	available_list
002567  aa  6 00236 6535 00	spri7	pr6|158		device_ptr
						STATEMENT 1 ON LINE 637
	     if ^device.flags.reservable		/* If non reservable keep in list. */
	     then do;

002570  aa  7 00035 2351 00	lda  	pr7|29		device.reservable
002571  aa   100000 3150 03	cana 	32768,du
002572  aa   000005 6010 04	tnz  	5,ic		002577
						STATEMENT 1 ON LINE 639
		available_list (num_avail_nres) = device_ptr;

002573  aa  6 00173 2361 00	ldq  	pr6|123		num_avail_nres
002574  aa   000001 7360 00	qls  	1
002575  aa  6 00104 6535 06	spri7	pr6|68,ql		available_list
						STATEMENT 1 ON LINE 640
		num_avail_nres = num_avail_nres + 1;

002576  aa  6 00173 0541 00	aos  	pr6|123		num_avail_nres
						STATEMENT 1 ON LINE 641
	     end;

						STATEMENT 1 ON LINE 642
	end;

002577  aa  6 00163 0541 00	aos  	pr6|115		i
002600  aa   777762 7100 04	tra  	-14,ic		002562
						STATEMENT 1 ON LINE 643
	num_available = num_avail_nres;

002601  aa  6 00173 2361 00	ldq  	pr6|123		num_avail_nres
002602  aa  6 00174 7561 00	stq  	pr6|124		num_available
						STATEMENT 1 ON LINE 644
	if num_available = 0			/* Are there any available devices left? */
	then do;

002603  aa   000005 6010 04	tnz  	5,ic		002610
						STATEMENT 1 ON LINE 646
	     ecode = error_table_$resource_unavailable;

002604  aa  6 00044 3701 20	epp4 	pr6|36,*
002605  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$resource_unavailable
002606  aa  6 00162 7561 00	stq  	pr6|114		ecode
						STATEMENT 1 ON LINE 647
	     return;

002607  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 648
	end;

						STATEMENT 1 ON LINE 650
     end CHECK_LIMITS;

002610  aa  6 00306 6101 00	rtcd 	pr6|198
  END PROCEDURE CHECK_LIMITS
BEGIN PROCEDURE ERROR_COUNT
ENTRY TO ERROR_COUNT                                        STATEMENT 1 ON LINE 652
ERROR_COUNT:
     procedure;

002611  aa  6 00316 6501 00	spri4	pr6|206
						STATEMENT 1 ON LINE 657
	device_ptr = ptr (rcpd_ptr, offset_message.device_off);

002612  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
002613  aa  7 00001 2351 00	lda  	pr7|1		offset_message.device_off
002614  aa   000022 7350 00	als  	18
002615  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
002616  aa   000000 3120 01	eawp2	0,au
002617  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 659
	if device.state ^= 1			/* Is device assigned? */
	then return;

002620  aa  2 00024 2361 00	ldq  	pr2|20		device.state
002621  aa   000001 1160 07	cmpq 	1,dl
002622  aa   000002 6000 04	tze  	2,ic		002624
002623  aa  6 00316 6101 00	rtcd 	pr6|206
						STATEMENT 1 ON LINE 662
	if device.process_id ^= get_process_id_ () then
	     return;

002624  aa  6 00720 3521 00	epp2 	pr6|464
002625  aa  6 00724 2521 00	spri2	pr6|468
002626  aa  6 00722 6211 00	eax1 	pr6|466
002627  aa   004000 4310 07	fld  	2048,dl
002630  aa  6 00044 3701 20	epp4 	pr6|36,*
002631  la  4 00040 3521 20	epp2 	pr4|32,*		get_process_id_
002632  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002633  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002634  aa  7 00036 2351 00	lda  	pr7|30		device.process_id
002635  aa  6 00720 1151 00	cmpa 	pr6|464
002636  aa   000002 6000 04	tze  	2,ic		002640
002637  aa  6 00316 6101 00	rtcd 	pr6|206
						STATEMENT 1 ON LINE 665
	device.error_count = device.error_count + offset_message.error_count;

002640  aa  6 00246 2351 20	lda  	pr6|166,*		offset_message.error_count
002641  aa   000022 7350 00	als  	18
002642  aa   000066 7330 00	lrs  	54
002643  aa   000044 7770 00	llr  	36
002644  aa   000044 7330 00	lrs  	36
002645  aa  7 00047 0331 00	adl  	pr7|39		device.error_count
002646  aa  7 00047 7561 00	stq  	pr7|39		device.error_count
						STATEMENT 1 ON LINE 667
     end ERROR_COUNT;

002647  aa  6 00316 6101 00	rtcd 	pr6|206
  END PROCEDURE ERROR_COUNT
BEGIN PROCEDURE UNASSIGN
ENTRY TO UNASSIGN                                           STATEMENT 1 ON LINE 669
UNASSIGN:
     procedure;

002650  aa  6 00324 6501 00	spri4	pr6|212
						STATEMENT 1 ON LINE 679
	volume_off = offset_message.volume_off;

002651  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
002652  aa  7 00001 2351 00	lda  	pr7|1		offset_message.volume_off
002653  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
002654  aa  6 00222 7551 00	sta  	pr6|146		volume_off
						STATEMENT 1 ON LINE 680
	device_off = offset_message.device_off;

002655  aa  7 00001 2351 00	lda  	pr7|1		offset_message.device_off
002656  aa   000022 7350 00	als  	18
002657  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 682
	process_id = get_process_id_ ();

002660  aa  6 00200 3521 00	epp2 	pr6|128		process_id
002661  aa  6 00730 2521 00	spri2	pr6|472
002662  aa  6 00726 6211 00	eax1 	pr6|470
002663  aa   004000 4310 07	fld  	2048,dl
002664  aa  6 00044 3701 20	epp4 	pr6|36,*
002665  la  4 00040 3521 20	epp2 	pr4|32,*		get_process_id_
002666  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 684
	if volume_off ^= "0"b			/* Is there a volume to unassign? */
	then do;

002667  aa  6 00222 2351 00	lda  	pr6|146		volume_off
002670  aa   000010 6000 04	tze  	8,ic		002700
						STATEMENT 1 ON LINE 686
	     volume_ptr = ptr (rcpd_ptr, volume_off);

002671  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
002672  aa   000000 3120 01	eawp2	0,au
002673  aa  6 00240 2521 00	spri2	pr6|160		volume_ptr
						STATEMENT 1 ON LINE 687
	     if volume.process_id = process_id then	/* Volume is assigned to this process. */
		call UNASSIGN_VOLUME ();

002674  aa  2 00000 2351 00	lda  	pr2|0		volume.process_id
002675  aa  6 00200 1151 00	cmpa 	pr6|128		process_id
002676  aa   000002 6010 04	tnz  	2,ic		002700
002677  aa   001370 6700 04	tsp4 	760,ic		004267
						STATEMENT 1 ON LINE 689
	end;

						STATEMENT 1 ON LINE 691
	if device_off = "0"b			/* Is there a device to unassign? */
	then return;

002700  aa  6 00160 2351 00	lda  	pr6|112		device_off
002701  aa   000002 6010 04	tnz  	2,ic		002703
002702  aa  6 00324 6101 00	rtcd 	pr6|212
						STATEMENT 1 ON LINE 694
	device_ptr = ptr (rcpd_ptr, device_off);

002703  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
002704  aa   000000 3120 01	eawp2	0,au
002705  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 695
	if device.process_id = process_id		/* Is it actually assigned to this process? */
	then do;

002706  aa  2 00036 2351 00	lda  	pr2|30		device.process_id
002707  aa  6 00200 1151 00	cmpa 	pr6|128		process_id
002710  aa   000042 6010 04	tnz  	34,ic		002752
						STATEMENT 1 ON LINE 697
	     device.error_count = device.error_count + offset_message.error_count;

002711  aa  6 00246 2351 20	lda  	pr6|166,*		offset_message.error_count
002712  aa   000022 7350 00	als  	18
002713  aa   000066 7330 00	lrs  	54
002714  aa   000044 7770 00	llr  	36
002715  aa   000044 7330 00	lrs  	36
002716  aa  2 00047 0331 00	adl  	pr2|39		device.error_count
002717  aa  2 00047 7561 00	stq  	pr2|39		device.error_count
						STATEMENT 1 ON LINE 698
	     call UNASSIGN_DEVICE;

002720  aa   001106 6700 04	tsp4 	582,ic		004026
						STATEMENT 1 ON LINE 699
	     call admin_gate_$syserr (LOG, "RCP: Unassigned ^a from ^a", device.device_name, device.group_id);

002721  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002722  aa   775354 00 0034	desc9a	-1300,28		000275 = 122103120072
002723  aa  6 00732 00 0034	desc9a	pr6|474,28
002724  aa   775301 3520 04	epp2 	-1343,ic		000225 = 000000000004
002725  aa  6 00744 2521 00	spri2	pr6|484
002726  aa  6 00732 3521 00	epp2 	pr6|474
002727  aa  6 00746 2521 00	spri2	pr6|486
002730  aa  6 00236 3521 20	epp2 	pr6|158,*		device.device_name
002731  aa  6 00750 2521 00	spri2	pr6|488
002732  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002733  aa  7 00037 3521 00	epp2 	pr7|31		device.group_id
002734  aa  6 00752 2521 00	spri2	pr6|490
002735  aa   775260 3520 04	epp2 	-1360,ic		000215 = 404000000021
002736  aa  6 00754 2521 00	spri2	pr6|492
002737  aa   775247 3520 04	epp2 	-1369,ic		000206 = 524000000032
002740  aa  6 00756 2521 00	spri2	pr6|494
002741  aa   775247 3520 04	epp2 	-1369,ic		000210 = 524000000010
002742  aa  6 00760 2521 00	spri2	pr6|496
002743  aa   775246 3520 04	epp2 	-1370,ic		000211 = 524000000040
002744  aa  6 00762 2521 00	spri2	pr6|498
002745  aa  6 00742 6211 00	eax1 	pr6|482
002746  aa   020000 4310 07	fld  	8192,dl
002747  aa  6 00044 3701 20	epp4 	pr6|36,*
002750  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
002751  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 700
	end;

						STATEMENT 1 ON LINE 702
     end UNASSIGN;

002752  aa  6 00324 6101 00	rtcd 	pr6|212
  END PROCEDURE UNASSIGN
BEGIN PROCEDURE FORCE_UNASSIGN
ENTRY TO FORCE_UNASSIGN                                     STATEMENT 1 ON LINE 704
FORCE_UNASSIGN:
     procedure;

002753  aa  6 00332 6501 00	spri4	pr6|218
						STATEMENT 1 ON LINE 711
	device_name = name_message.device_name;

002754  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
002755  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002756  aa  7 00000 20 0007	desc9a	pr7|0(1),7	name_message.device_name
002757  aa  6 00150 00 0040	desc9a	pr6|104,32	device_name
						STATEMENT 1 ON LINE 713
	call FIND_DEVICE;

002760  aa   001370 6700 04	tsp4 	760,ic		004350
						STATEMENT 1 ON LINE 714
	if device_off = "0"b			/* Did we find it? */
	then return;

002761  aa  6 00160 2351 00	lda  	pr6|112		device_off
002762  aa   000002 6010 04	tnz  	2,ic		002764
002763  aa  6 00332 6101 00	rtcd 	pr6|218
						STATEMENT 1 ON LINE 717
	if device.state = 1				/* Is device assigned? */
	then do;

002764  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
002765  aa  7 00024 2361 00	ldq  	pr7|20		device.state
002766  aa   000001 1160 07	cmpq 	1,dl
002767  aa   000032 6010 04	tnz  	26,ic		003021
						STATEMENT 1 ON LINE 719
	     call UNASSIGN_DEVICE;

002770  aa   001036 6700 04	tsp4 	542,ic		004026
						STATEMENT 1 ON LINE 720
	     call admin_gate_$syserr (ANNOUNCE, "RCP: Force Unassigned ^a from ^a", device_name, device.group_id);

002771  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002772  aa   775313 00 0040	desc9a	-1333,32		000304 = 122103120072
002773  aa  6 00764 00 0040	desc9a	pr6|500,32
002774  aa   775222 3520 04	epp2 	-1390,ic		000216 = 000000000000
002775  aa  6 00776 2521 00	spri2	pr6|510
002776  aa  6 00764 3521 00	epp2 	pr6|500
002777  aa  6 01000 2521 00	spri2	pr6|512
003000  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003001  aa  6 01002 2521 00	spri2	pr6|514
003002  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003003  aa  7 00037 3521 00	epp2 	pr7|31		device.group_id
003004  aa  6 01004 2521 00	spri2	pr6|516
003005  aa   775210 3520 04	epp2 	-1400,ic		000215 = 404000000021
003006  aa  6 01006 2521 00	spri2	pr6|518
003007  aa   775202 3520 04	epp2 	-1406,ic		000211 = 524000000040
003010  aa  6 01010 2521 00	spri2	pr6|520
003011  aa  6 01014 2521 00	spri2	pr6|524
003012  aa   775201 3520 04	epp2 	-1407,ic		000213 = 526000000040
003013  aa  6 01012 2521 00	spri2	pr6|522
003014  aa  6 00774 6211 00	eax1 	pr6|508
003015  aa   020000 4310 07	fld  	8192,dl
003016  aa  6 00044 3701 20	epp4 	pr6|36,*
003017  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
003020  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 721
	end;

						STATEMENT 1 ON LINE 723
	if device.volume_name = " "			/* Is there a volume on this device? */
	then return;

003021  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003022  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003023  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
003024  aa   001466 00 0001	desc9a	822,1		004510 = 040000000000
003025  aa   000002 6010 04	tnz  	2,ic		003027
003026  aa  6 00332 6101 00	rtcd 	pr6|218
						STATEMENT 1 ON LINE 726
	do i = 1 to rcpd.last_volume;

003027  aa  6 00232 3715 20	epp5 	pr6|154,*		rcpd_ptr
003030  aa  5 00020 2361 00	ldq  	pr5|16		rcpd.last_volume
003031  aa  6 00340 7561 00	stq  	pr6|224
003032  aa   000001 2360 07	ldq  	1,dl
003033  aa  6 00163 7561 00	stq  	pr6|115		i
003034  aa  6 00163 2361 00	ldq  	pr6|115		i
003035  aa  6 00340 1161 00	cmpq 	pr6|224
003036  aa   000033 6054 04	tpnz 	27,ic		003071
						STATEMENT 1 ON LINE 727
	     volume_ptr = addr (rcpd.volume (i));

003037  aa   000042 4020 07	mpy  	34,dl
003040  aa  6 01016 7561 00	stq  	pr6|526
003041  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
003042  aa  7 00016 2361 00	ldq  	pr7|14		rcpd.tot_devices
003043  aa   000074 4020 07	mpy  	60,dl
003044  aa  6 01017 7561 00	stq  	pr6|527
003045  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
003046  aa   000017 4020 07	mpy  	15,dl
003047  aa   000043 0760 07	adq  	35,dl
003050  aa   000001 0760 07	adq  	1,dl
003051  aa   777776 3760 07	anq  	262142,dl
003052  aa  6 01017 0761 00	adq  	pr6|527
003053  aa   000001 0760 07	adq  	1,dl
003054  aa   777776 3760 07	anq  	262142,dl
003055  aa  6 01016 0761 00	adq  	pr6|526
003056  aa  7 77736 3715 06	epp5 	pr7|-34,ql	rcpd.volume
003057  aa  6 00240 6515 00	spri5	pr6|160		volume_ptr
						STATEMENT 1 ON LINE 728
	     if volume.volume_name = device.volume_name then do;

003060  aa  6 00236 3535 20	epp3 	pr6|158,*		device_ptr
003061  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003062  aa  5 00001 00 0040	desc9a	pr5|1,32		volume.volume_name
003063  aa  3 00002 00 0040	desc9a	pr3|2,32		device.volume_name
003064  aa   000003 6010 04	tnz  	3,ic		003067
						STATEMENT 1 ON LINE 730
		call UNASSIGN_VOLUME ();

003065  aa   001202 6700 04	tsp4 	642,ic		004267
						STATEMENT 1 ON LINE 731
		return;

003066  aa  6 00332 6101 00	rtcd 	pr6|218
						STATEMENT 1 ON LINE 732
	     end;

						STATEMENT 1 ON LINE 733
	end;

003067  aa  6 00163 0541 00	aos  	pr6|115		i
003070  aa   777744 7100 04	tra  	-28,ic		003034
						STATEMENT 1 ON LINE 735
     end FORCE_UNASSIGN;

003071  aa  6 00332 6101 00	rtcd 	pr6|218
  END PROCEDURE FORCE_UNASSIGN
BEGIN PROCEDURE PROC_UNASSIGN
ENTRY TO PROC_UNASSIGN                                      STATEMENT 1 ON LINE 737
PROC_UNASSIGN:
     procedure;

003072  aa  6 00342 6501 00	spri4	pr6|226
						STATEMENT 1 ON LINE 744
	process_id = id_message.process_id;

003073  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
003074  aa  7 00001 2351 00	lda  	pr7|1		id_message.process_id
003075  aa  6 00200 7551 00	sta  	pr6|128		process_id
						STATEMENT 1 ON LINE 746
	do i = 1 to rcpd.last_volume;

003076  aa  6 00232 3715 20	epp5 	pr6|154,*		rcpd_ptr
003077  aa  5 00020 2361 00	ldq  	pr5|16		rcpd.last_volume
003100  aa  6 00350 7561 00	stq  	pr6|232
003101  aa   000001 2360 07	ldq  	1,dl
003102  aa  6 00163 7561 00	stq  	pr6|115		i
003103  aa   000000 0110 03	nop  	0,du
003104  aa  6 00163 2361 00	ldq  	pr6|115		i
003105  aa  6 00350 1161 00	cmpq 	pr6|232
003106  aa   000031 6054 04	tpnz 	25,ic		003137
						STATEMENT 1 ON LINE 747
	     volume_ptr = addr (rcpd.volume (i));

003107  aa   000042 4020 07	mpy  	34,dl
003110  aa  6 01020 7561 00	stq  	pr6|528
003111  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
003112  aa  7 00016 2361 00	ldq  	pr7|14		rcpd.tot_devices
003113  aa   000074 4020 07	mpy  	60,dl
003114  aa  6 01021 7561 00	stq  	pr6|529
003115  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
003116  aa   000017 4020 07	mpy  	15,dl
003117  aa   000043 0760 07	adq  	35,dl
003120  aa   000001 0760 07	adq  	1,dl
003121  aa   777776 3760 07	anq  	262142,dl
003122  aa  6 01021 0761 00	adq  	pr6|529
003123  aa   000001 0760 07	adq  	1,dl
003124  aa   777776 3760 07	anq  	262142,dl
003125  aa  6 01020 0761 00	adq  	pr6|528
003126  aa  7 77736 3715 06	epp5 	pr7|-34,ql	rcpd.volume
003127  aa  6 00240 6515 00	spri5	pr6|160		volume_ptr
						STATEMENT 1 ON LINE 748
	     if volume.process_id = process_id		/* Does volume belong to this process? */
	     then do;

003130  aa  5 00000 2351 00	lda  	pr5|0		volume.process_id
003131  aa  6 00200 1151 00	cmpa 	pr6|128		process_id
003132  aa   000003 6010 04	tnz  	3,ic		003135
						STATEMENT 1 ON LINE 750
		volume.unassign_state = 0;

003133  aa  5 00037 4501 00	stz  	pr5|31		volume.unassign_state
						STATEMENT 1 ON LINE 751
		call UNASSIGN_VOLUME ();

003134  aa   001133 6700 04	tsp4 	603,ic		004267
						STATEMENT 1 ON LINE 752
	     end;

						STATEMENT 1 ON LINE 753
	end;

003135  aa  6 00163 0541 00	aos  	pr6|115		i
003136  aa   777746 7100 04	tra  	-26,ic		003104
						STATEMENT 1 ON LINE 755
	do i = 1 to rcpd.tot_devices;

003137  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
003140  aa  7 00016 2361 00	ldq  	pr7|14		rcpd.tot_devices
003141  aa  6 00351 7561 00	stq  	pr6|233
003142  aa   000001 2360 07	ldq  	1,dl
003143  aa  6 00163 7561 00	stq  	pr6|115		i
003144  aa  6 00163 2361 00	ldq  	pr6|115		i
003145  aa  6 00351 1161 00	cmpq 	pr6|233
003146  aa   000053 6054 04	tpnz 	43,ic		003221
						STATEMENT 1 ON LINE 756
	     device_ptr = addr (rcpd.device (i));

003147  aa   000074 4020 07	mpy  	60,dl
003150  aa  6 01020 7561 00	stq  	pr6|528
003151  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
003152  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
003153  aa   000017 4020 07	mpy  	15,dl
003154  aa   000043 0760 07	adq  	35,dl
003155  aa   000001 0760 07	adq  	1,dl
003156  aa   777776 3760 07	anq  	262142,dl
003157  aa  6 01020 0761 00	adq  	pr6|528
003160  aa  7 77704 3715 06	epp5 	pr7|-60,ql	rcpd.device
003161  aa  6 00236 6515 00	spri5	pr6|158		device_ptr
						STATEMENT 1 ON LINE 757
	     if device.process_id = process_id		/* Does device belong to this process? */
	     then do;

003162  aa  5 00036 2351 00	lda  	pr5|30		device.process_id
003163  aa  6 00200 1151 00	cmpa 	pr6|128		process_id
003164  aa   000033 6010 04	tnz  	27,ic		003217
						STATEMENT 1 ON LINE 759
		device.unassign_state = 0;

003165  aa  5 00025 4501 00	stz  	pr5|21		device.unassign_state
						STATEMENT 1 ON LINE 760
		call UNASSIGN_DEVICE;

003166  aa   000640 6700 04	tsp4 	416,ic		004026
						STATEMENT 1 ON LINE 761
		call admin_gate_$syserr (LOG, "RCP: Force Unassigned ^a from ^a", device.device_name, device.group_id)
		     ;

003167  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003170  aa   775115 00 0040	desc9a	-1459,32		000304 = 122103120072
003171  aa  6 01022 00 0040	desc9a	pr6|530,32
003172  aa   775033 3520 04	epp2 	-1509,ic		000225 = 000000000004
003173  aa  6 01034 2521 00	spri2	pr6|540
003174  aa  6 01022 3521 00	epp2 	pr6|530
003175  aa  6 01036 2521 00	spri2	pr6|542
003176  aa  6 00236 3521 20	epp2 	pr6|158,*		device.device_name
003177  aa  6 01040 2521 00	spri2	pr6|544
003200  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003201  aa  7 00037 3521 00	epp2 	pr7|31		device.group_id
003202  aa  6 01042 2521 00	spri2	pr6|546
003203  aa   775012 3520 04	epp2 	-1526,ic		000215 = 404000000021
003204  aa  6 01044 2521 00	spri2	pr6|548
003205  aa   775004 3520 04	epp2 	-1532,ic		000211 = 524000000040
003206  aa  6 01046 2521 00	spri2	pr6|550
003207  aa  6 01052 2521 00	spri2	pr6|554
003210  aa   775000 3520 04	epp2 	-1536,ic		000210 = 524000000010
003211  aa  6 01050 2521 00	spri2	pr6|552
003212  aa  6 01032 6211 00	eax1 	pr6|538
003213  aa   020000 4310 07	fld  	8192,dl
003214  aa  6 00044 3701 20	epp4 	pr6|36,*
003215  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
003216  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 763
	     end;

						STATEMENT 1 ON LINE 764
	end;

003217  aa  6 00163 0541 00	aos  	pr6|115		i
003220  aa   777724 7100 04	tra  	-44,ic		003144
						STATEMENT 1 ON LINE 766
     end PROC_UNASSIGN;

003221  aa  6 00342 6101 00	rtcd 	pr6|226
  END PROCEDURE PROC_UNASSIGN
BEGIN PROCEDURE DELETE_DEVICE
ENTRY TO DELETE_DEVICE                                      STATEMENT 1 ON LINE 768
DELETE_DEVICE:
     procedure;

003222  aa  6 00352 6501 00	spri4	pr6|234
						STATEMENT 1 ON LINE 776
	device_name = name_message.device_name;

003223  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
003224  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
003225  aa  7 00000 20 0007	desc9a	pr7|0(1),7	name_message.device_name
003226  aa  6 00150 00 0040	desc9a	pr6|104,32	device_name
						STATEMENT 1 ON LINE 778
	call FIND_DEVICE;

003227  aa   001121 6700 04	tsp4 	593,ic		004350
						STATEMENT 1 ON LINE 779
	if device_off = "0"b			/* Did we find it? */
	then return;

003230  aa  6 00160 2351 00	lda  	pr6|112		device_off
003231  aa   000002 6010 04	tnz  	2,ic		003233
003232  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 782
	if device.state = 3 then
	     return;

003233  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003234  aa  7 00024 2361 00	ldq  	pr7|20		device.state
003235  aa   000003 1160 07	cmpq 	3,dl
003236  aa   000002 6010 04	tnz  	2,ic		003240
003237  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 784
	if device.state = 1 | device.state = 4		/* Is device still assigned? */
	then do;

003240  aa   000001 1160 07	cmpq 	1,dl
003241  aa   000003 6000 04	tze  	3,ic		003244
003242  aa   000004 1160 07	cmpq 	4,dl
003243  aa   000004 6010 04	tnz  	4,ic		003247
						STATEMENT 1 ON LINE 786
	     device.flags.delete = "1"b;

003244  aa   400000 2350 03	lda  	131072,du
003245  aa  7 00035 2551 00	orsa 	pr7|29		device.delete
						STATEMENT 1 ON LINE 787
	     return;

003246  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 788
	end;

						STATEMENT 1 ON LINE 790
	call admin_gate_$ioi_delete_device (device_name, ecode);

003247  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003250  aa  6 01056 2521 00	spri2	pr6|558
003251  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003252  aa  6 01060 2521 00	spri2	pr6|560
003253  aa   774740 3520 04	epp2 	-1568,ic		000213 = 526000000040
003254  aa  6 01062 2521 00	spri2	pr6|562
003255  aa   774751 3520 04	epp2 	-1559,ic		000226 = 404000000043
003256  aa  6 01064 2521 00	spri2	pr6|564
003257  aa  6 01054 6211 00	eax1 	pr6|556
003260  aa   010000 4310 07	fld  	4096,dl
003261  aa  6 00044 3701 20	epp4 	pr6|36,*
003262  la  4 00032 3521 20	epp2 	pr4|26,*		admin_gate_$ioi_delete_device
003263  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 791
	if ecode ^= 0 then do;

003264  aa  6 00162 2361 00	ldq  	pr6|114		ecode
003265  aa   000032 6000 04	tze  	26,ic		003317
						STATEMENT 1 ON LINE 792
	     call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error deleting ^a.", device_name);

003266  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003267  aa   775037 00 0044	desc9a	-1505,36		000325 = 162143160137
003270  aa  6 01054 00 0044	desc9a	pr6|556,36
003271  aa   774725 3520 04	epp2 	-1579,ic		000216 = 000000000000
003272  aa  6 01070 2521 00	spri2	pr6|568
003273  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003274  aa  6 01072 2521 00	spri2	pr6|570
003275  aa  6 01054 3521 00	epp2 	pr6|556
003276  aa  6 01074 2521 00	spri2	pr6|572
003277  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003300  aa  6 01076 2521 00	spri2	pr6|574
003301  aa   774714 3520 04	epp2 	-1588,ic		000215 = 404000000021
003302  aa  6 01100 2521 00	spri2	pr6|576
003303  aa   774723 3520 04	epp2 	-1581,ic		000226 = 404000000043
003304  aa  6 01102 2521 00	spri2	pr6|578
003305  aa   774700 3520 04	epp2 	-1600,ic		000205 = 524000000044
003306  aa  6 01104 2521 00	spri2	pr6|580
003307  aa   774704 3520 04	epp2 	-1596,ic		000213 = 526000000040
003310  aa  6 01106 2521 00	spri2	pr6|582
003311  aa  6 01066 6211 00	eax1 	pr6|566
003312  aa   020000 4310 07	fld  	8192,dl
003313  aa  6 00044 3701 20	epp4 	pr6|36,*
003314  la  4 00036 3521 20	epp2 	pr4|30,*		admin_gate_$syserr_error_code
003315  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 793
	     return;

003316  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 794
	end;

						STATEMENT 1 ON LINE 796
	if device.volume_name ^= "" & device.dtypex = 1 then
	     call rcp_unload_$unload_device (device_ptr, "1"b);

003317  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003320  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
003321  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
003322  aa   001170 00 0000	desc9a	632,0		004510 = 040000000000
003323  aa   000017 6000 04	tze  	15,ic		003342
003324  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
003325  aa   000001 1160 07	cmpq 	1,dl
003326  aa   000014 6010 04	tnz  	12,ic		003342
003327  aa   400000 2350 03	lda  	131072,du
003330  aa  6 01110 7551 00	sta  	pr6|584
003331  aa  6 00236 3521 00	epp2 	pr6|158		device_ptr
003332  aa  6 01056 2521 00	spri2	pr6|558
003333  aa  6 01110 3521 00	epp2 	pr6|584
003334  aa  6 01060 2521 00	spri2	pr6|560
003335  aa  6 01054 6211 00	eax1 	pr6|556
003336  aa   010000 4310 07	fld  	4096,dl
003337  aa  6 00044 3701 20	epp4 	pr6|36,*
003340  la  4 00070 3521 20	epp2 	pr4|56,*		rcp_unload_$unload_device
003341  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 800
	device.volume_name = " ";

003342  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003343  aa  040 100 100 400	mlr  	(),(pr),fill(040)
003344  aa   000000 00 0000	desc9a	0,0
003345  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 801
	device.process_id = "0"b;

003346  aa  7 00036 4501 00	stz  	pr7|30		device.process_id
						STATEMENT 1 ON LINE 802
	device.state = 2;

003347  aa   000002 2360 07	ldq  	2,dl
003350  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 803
	device.state_time = clock ();

003351  aa  0 01435 7001 00	tsx0 	pr0|797		clock
003352  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003353  aa  7 00022 7571 00	staq 	pr7|18		device.state_time
						STATEMENT 1 ON LINE 805
	if device.dtypex = 3 then do;

003354  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
003355  aa   000003 1160 07	cmpq 	3,dl
003356  aa   000051 6010 04	tnz  	41,ic		003427
						STATEMENT 1 ON LINE 806
	     call hphcs_$ocdcm_reconfigure ((device_name), MAKE_UNAVAILABLE, ecode);

003357  aa  6 00150 2351 00	lda  	pr6|104		device_name
003360  aa  6 01110 7551 00	sta  	pr6|584
003361  aa  6 01110 3521 00	epp2 	pr6|584
003362  aa  6 01056 2521 00	spri2	pr6|558
003363  aa   774635 3520 04	epp2 	-1635,ic		000220 = 000000000012
003364  aa  6 01060 2521 00	spri2	pr6|560
003365  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003366  aa  6 01062 2521 00	spri2	pr6|562
003367  aa  6 01054 6211 00	eax1 	pr6|556
003370  aa   014000 4310 07	fld  	6144,dl
003371  aa  6 00044 3701 20	epp4 	pr6|36,*
003372  la  4 00044 3521 20	epp2 	pr4|36,*		hphcs_$ocdcm_reconfigure
003373  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 807
	     if ecode ^= 0 then do;

003374  aa  6 00162 2361 00	ldq  	pr6|114		ecode
003375  aa   000032 6000 04	tze  	26,ic		003427
						STATEMENT 1 ON LINE 808
		call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Unable to delete console ^a.",
		     device_name);

003376  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003377  aa   774765 00 0060	desc9a	-1547,48		000363 = 162143160137
003400  aa  6 01066 00 0060	desc9a	pr6|566,48
003401  aa   774615 3520 04	epp2 	-1651,ic		000216 = 000000000000
003402  aa  6 01114 2521 00	spri2	pr6|588
003403  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003404  aa  6 01116 2521 00	spri2	pr6|590
003405  aa  6 01066 3521 00	epp2 	pr6|566
003406  aa  6 01120 2521 00	spri2	pr6|592
003407  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003410  aa  6 01122 2521 00	spri2	pr6|594
003411  aa   774604 3520 04	epp2 	-1660,ic		000215 = 404000000021
003412  aa  6 01124 2521 00	spri2	pr6|596
003413  aa   774613 3520 04	epp2 	-1653,ic		000226 = 404000000043
003414  aa  6 01126 2521 00	spri2	pr6|598
003415  aa   774567 3520 04	epp2 	-1673,ic		000204 = 524000000056
003416  aa  6 01130 2521 00	spri2	pr6|600
003417  aa   774574 3520 04	epp2 	-1668,ic		000213 = 526000000040
003420  aa  6 01132 2521 00	spri2	pr6|602
003421  aa  6 01112 6211 00	eax1 	pr6|586
003422  aa   020000 4310 07	fld  	8192,dl
003423  aa  6 00044 3701 20	epp4 	pr6|36,*
003424  la  4 00036 3521 20	epp2 	pr4|30,*		admin_gate_$syserr_error_code
003425  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 810
		return;

003426  aa  6 00352 6101 00	rtcd 	pr6|234
						STATEMENT 1 ON LINE 811
	     end;

						STATEMENT 1 ON LINE 812
	end;

						STATEMENT 1 ON LINE 814
	call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device_name);

003427  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003430  aa   774624 00 0030	desc9a	-1644,24		000253 = 122103120072
003431  aa  6 01054 00 0030	desc9a	pr6|556,24
003432  aa   774564 3520 04	epp2 	-1676,ic		000216 = 000000000000
003433  aa  6 01114 2521 00	spri2	pr6|588
003434  aa  6 01054 3521 00	epp2 	pr6|556
003435  aa  6 01116 2521 00	spri2	pr6|590
003436  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003437  aa  6 01120 2521 00	spri2	pr6|592
003440  aa   774555 3520 04	epp2 	-1683,ic		000215 = 404000000021
003441  aa  6 01122 2521 00	spri2	pr6|594
003442  aa   774545 3520 04	epp2 	-1691,ic		000207 = 524000000026
003443  aa  6 01124 2521 00	spri2	pr6|596
003444  aa   774547 3520 04	epp2 	-1689,ic		000213 = 526000000040
003445  aa  6 01126 2521 00	spri2	pr6|598
003446  aa  6 01112 6211 00	eax1 	pr6|586
003447  aa   014000 4310 07	fld  	6144,dl
003450  aa  6 00044 3701 20	epp4 	pr6|36,*
003451  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
003452  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 816
     end DELETE_DEVICE;

003453  aa  6 00352 6101 00	rtcd 	pr6|234
  END PROCEDURE DELETE_DEVICE
BEGIN PROCEDURE ADD_DEVICE
ENTRY TO ADD_DEVICE                                         STATEMENT 1 ON LINE 822
ADD_DEVICE:
     procedure;

003454  aa  6 00360 6501 00	spri4	pr6|240
						STATEMENT 1 ON LINE 835
	device_name = name_message.device_name;

003455  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
003456  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
003457  aa  7 00000 20 0007	desc9a	pr7|0(1),7	name_message.device_name
003460  aa  6 00150 00 0040	desc9a	pr6|104,32	device_name
						STATEMENT 1 ON LINE 837
	call FIND_DEVICE;

003461  aa   000667 6700 04	tsp4 	439,ic		004350
						STATEMENT 1 ON LINE 838
	if device_off = "0"b			/* Did we find it? */
	then return;

003462  aa  6 00160 2351 00	lda  	pr6|112		device_off
003463  aa   000002 6010 04	tnz  	2,ic		003465
003464  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 841
	device.flags.delete = "0"b;

003465  aa   001011 2350 04	lda  	521,ic		004476 = 377777777777
003466  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003467  aa  7 00035 3551 00	ansa 	pr7|29		device.delete
						STATEMENT 1 ON LINE 843
	if device.state ^= 2			/* Is device in the deleted state? */
	then return;

003470  aa  7 00024 2361 00	ldq  	pr7|20		device.state
003471  aa   000002 1160 07	cmpq 	2,dl
003472  aa   000002 6000 04	tze  	2,ic		003474
003473  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 846
	if (device.dtypex = TAPE_DRIVE_DTYPEX) & (device.qualifiers (1) = 0) then do;

003474  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
003475  aa   000001 1160 07	cmpq 	1,dl
003476  aa   000134 6010 04	tnz  	92,ic		003632
003477  aa  7 00015 2361 00	ldq  	pr7|13		device.qualifiers
003500  aa   000132 6010 04	tnz  	90,ic		003632
						STATEMENT 1 ON LINE 848
	     string (tape_name) = device_name;

003501  aa  6 00150 2371 00	ldaq 	pr6|104		device_name
003502  aa  6 00370 7551 00	sta  	pr6|248
003503  aa  6 00371 5521 70	stbq 	pr6|249,70
						STATEMENT 1 ON LINE 849
	     call rcp_tape_survey_ (tape_name.subsystem, (tape_name.drive), operational, device.qualifiers, ecode);

003504  aa  6 01135 3515 00	epp1 	pr6|605
003505  aa   001004 3534 04	epp3 	516,ic		004511 = 031002000002
003506  aa   000001 7270 07	lxl7 	1,dl
003507  aa  6 00371 3715 00	epp5 	pr6|249		tape_name.drive
003510  aa  5 00000 5005 17	a9bd 	pr5|0,7
003511  aa  0 01260 7001 00	tsx0 	pr0|688		unpack_pic
003512  aa  000 100 305 500	dtb  	(pr),(pr)
003513  aa  6 01135 01 0003	desc9ls	pr6|605,3,0
003514  aa  6 01134 00 0004	desc9a	pr6|604,4
003515  aa  6 00370 3521 00	epp2 	pr6|248		tape_name.subsystem
003516  aa  6 01140 2521 00	spri2	pr6|608
003517  aa  6 01134 3521 00	epp2 	pr6|604
003520  aa  6 01142 2521 00	spri2	pr6|610
003521  aa  6 00366 3521 00	epp2 	pr6|246		operational
003522  aa  6 01144 2521 00	spri2	pr6|612
003523  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003524  aa  7 00015 3521 00	epp2 	pr7|13		device.qualifiers
003525  aa  6 01146 2521 00	spri2	pr6|614
003526  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003527  aa  6 01150 2521 00	spri2	pr6|616
003530  aa   774453 3520 04	epp2 	-1749,ic		000203 = 526000000004
003531  aa  6 01152 2521 00	spri2	pr6|618
003532  aa   774463 3520 04	epp2 	-1741,ic		000215 = 404000000021
003533  aa  6 01154 2521 00	spri2	pr6|620
003534  aa   774475 3520 04	epp2 	-1731,ic		000231 = 514000000001
003535  aa  6 01156 2521 00	spri2	pr6|622
003536  aa   774504 3520 04	epp2 	-1724,ic		000242 = 404100000043
003537  aa  6 01160 2521 00	spri2	pr6|624
003540  aa   774466 3520 04	epp2 	-1738,ic		000226 = 404000000043
003541  aa  6 01162 2521 00	spri2	pr6|626
003542  aa  6 01136 6211 00	eax1 	pr6|606
003543  aa   024000 4310 07	fld  	10240,dl
003544  aa  6 00044 3701 20	epp4 	pr6|36,*
003545  la  4 00066 3521 20	epp2 	pr4|54,*		rcp_tape_survey_
003546  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 850
	     if ^operational then do;

003547  aa  6 00366 2351 00	lda  	pr6|246		operational
003550  aa   400000 3150 03	cana 	131072,du
003551  aa   000061 6010 04	tnz  	49,ic		003632
						STATEMENT 1 ON LINE 851
		if ecode = 0 then
		     call admin_gate_$syserr (ANNOUNCE, "RCP: ^a is not operational and will not be added.",
			device_name);

003552  aa  6 00162 2361 00	ldq  	pr6|114		ecode
003553  aa   000026 6010 04	tnz  	22,ic		003601
003554  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003555  aa   774623 00 0064	desc9a	-1645,52		000377 = 122103120072
003556  aa  6 01136 00 0064	desc9a	pr6|606,52
003557  aa   774437 3520 04	epp2 	-1761,ic		000216 = 000000000000
003560  aa  6 01166 2521 00	spri2	pr6|630
003561  aa  6 01136 3521 00	epp2 	pr6|606
003562  aa  6 01170 2521 00	spri2	pr6|632
003563  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003564  aa  6 01172 2521 00	spri2	pr6|634
003565  aa   774430 3520 04	epp2 	-1768,ic		000215 = 404000000021
003566  aa  6 01174 2521 00	spri2	pr6|636
003567  aa   774413 3520 04	epp2 	-1781,ic		000202 = 524000000061
003570  aa  6 01176 2521 00	spri2	pr6|638
003571  aa   774422 3520 04	epp2 	-1774,ic		000213 = 526000000040
003572  aa  6 01200 2521 00	spri2	pr6|640
003573  aa  6 01164 6211 00	eax1 	pr6|628
003574  aa   014000 4310 07	fld  	6144,dl
003575  aa  6 00044 3701 20	epp4 	pr6|36,*
003576  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
003577  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
003600  aa   000031 7100 04	tra  	25,ic		003631
						STATEMENT 1 ON LINE 854
		else call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error surveying ^a.",
			device_name);

003601  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003602  aa   774535 00 0050	desc9a	-1699,40		000336 = 162143160137
003603  aa  6 01164 00 0050	desc9a	pr6|628,40
003604  aa   774412 3520 04	epp2 	-1782,ic		000216 = 000000000000
003605  aa  6 01140 2521 00	spri2	pr6|608
003606  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003607  aa  6 01142 2521 00	spri2	pr6|610
003610  aa  6 01164 3521 00	epp2 	pr6|628
003611  aa  6 01144 2521 00	spri2	pr6|612
003612  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003613  aa  6 01146 2521 00	spri2	pr6|614
003614  aa   774401 3520 04	epp2 	-1791,ic		000215 = 404000000021
003615  aa  6 01150 2521 00	spri2	pr6|616
003616  aa   774410 3520 04	epp2 	-1784,ic		000226 = 404000000043
003617  aa  6 01152 2521 00	spri2	pr6|618
003620  aa   774361 3520 04	epp2 	-1807,ic		000201 = 524000000045
003621  aa  6 01154 2521 00	spri2	pr6|620
003622  aa   774371 3520 04	epp2 	-1799,ic		000213 = 526000000040
003623  aa  6 01156 2521 00	spri2	pr6|622
003624  aa  6 01136 6211 00	eax1 	pr6|606
003625  aa   020000 4310 07	fld  	8192,dl
003626  aa  6 00044 3701 20	epp4 	pr6|36,*
003627  la  4 00036 3521 20	epp2 	pr4|30,*		admin_gate_$syserr_error_code
003630  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 856
		return;

003631  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 857
	     end;

						STATEMENT 1 ON LINE 858
	end;

						STATEMENT 1 ON LINE 860
	call admin_gate_$ioi_add_device (device_name, ecode);

003632  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003633  aa  6 01166 2521 00	spri2	pr6|630
003634  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003635  aa  6 01170 2521 00	spri2	pr6|632
003636  aa   774355 3520 04	epp2 	-1811,ic		000213 = 526000000040
003637  aa  6 01172 2521 00	spri2	pr6|634
003640  aa   774366 3520 04	epp2 	-1802,ic		000226 = 404000000043
003641  aa  6 01174 2521 00	spri2	pr6|636
003642  aa  6 01164 6211 00	eax1 	pr6|628
003643  aa   010000 4310 07	fld  	4096,dl
003644  aa  6 00044 3701 20	epp4 	pr6|36,*
003645  la  4 00030 3521 20	epp2 	pr4|24,*		admin_gate_$ioi_add_device
003646  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 861
	if ecode ^= 0 then do;

003647  aa  6 00162 2361 00	ldq  	pr6|114		ecode
003650  aa   000032 6000 04	tze  	26,ic		003702
						STATEMENT 1 ON LINE 862
	     call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Error adding ^a.", device_name);

003651  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003652  aa   774443 00 0044	desc9a	-1757,36		000314 = 162143160137
003653  aa  6 01164 00 0044	desc9a	pr6|628,36
003654  aa   774342 3520 04	epp2 	-1822,ic		000216 = 000000000000
003655  aa  6 01140 2521 00	spri2	pr6|608
003656  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003657  aa  6 01142 2521 00	spri2	pr6|610
003660  aa  6 01164 3521 00	epp2 	pr6|628
003661  aa  6 01144 2521 00	spri2	pr6|612
003662  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003663  aa  6 01146 2521 00	spri2	pr6|614
003664  aa   774331 3520 04	epp2 	-1831,ic		000215 = 404000000021
003665  aa  6 01150 2521 00	spri2	pr6|616
003666  aa   774340 3520 04	epp2 	-1824,ic		000226 = 404000000043
003667  aa  6 01152 2521 00	spri2	pr6|618
003670  aa   774310 3520 04	epp2 	-1848,ic		000200 = 524000000042
003671  aa  6 01154 2521 00	spri2	pr6|620
003672  aa   774321 3520 04	epp2 	-1839,ic		000213 = 526000000040
003673  aa  6 01156 2521 00	spri2	pr6|622
003674  aa  6 01136 6211 00	eax1 	pr6|606
003675  aa   020000 4310 07	fld  	8192,dl
003676  aa  6 00044 3701 20	epp4 	pr6|36,*
003677  la  4 00036 3521 20	epp2 	pr4|30,*		admin_gate_$syserr_error_code
003700  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 863
	     return;

003701  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 864
	end;

						STATEMENT 1 ON LINE 866
	device.state = 0;

003702  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003703  aa  7 00024 4501 00	stz  	pr7|20		device.state
						STATEMENT 1 ON LINE 867
	device.unassign_state = 0;

003704  aa  7 00025 4501 00	stz  	pr7|21		device.unassign_state
						STATEMENT 1 ON LINE 868
	device.state_time = clock ();

003705  aa  0 01435 7001 00	tsx0 	pr0|797		clock
003706  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
003707  aa  7 00022 7571 00	staq 	pr7|18		device.state_time
						STATEMENT 1 ON LINE 870
	if device.dtypex = 3 then do;

003710  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
003711  aa   000003 1160 07	cmpq 	3,dl
003712  aa   000051 6010 04	tnz  	41,ic		003763
						STATEMENT 1 ON LINE 871
	     call hphcs_$ocdcm_reconfigure ((device_name), MAKE_IO_DEVICE, ecode);

003713  aa  6 00150 2351 00	lda  	pr6|104		device_name
003714  aa  6 01134 7551 00	sta  	pr6|604
003715  aa  6 01134 3521 00	epp2 	pr6|604
003716  aa  6 01166 2521 00	spri2	pr6|630
003717  aa   774300 3520 04	epp2 	-1856,ic		000217 = 000000000005
003720  aa  6 01170 2521 00	spri2	pr6|632
003721  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003722  aa  6 01172 2521 00	spri2	pr6|634
003723  aa  6 01164 6211 00	eax1 	pr6|628
003724  aa   014000 4310 07	fld  	6144,dl
003725  aa  6 00044 3701 20	epp4 	pr6|36,*
003726  la  4 00044 3521 20	epp2 	pr4|36,*		hphcs_$ocdcm_reconfigure
003727  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 872
	     if ecode ^= 0 then do;

003730  aa  6 00162 2361 00	ldq  	pr6|114		ecode
003731  aa   000032 6000 04	tze  	26,ic		003763
						STATEMENT 1 ON LINE 873
		call admin_gate_$syserr_error_code (ANNOUNCE, ecode, "rcp_initializer_: Unable to add console ^a",
		     device_name);

003732  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003733  aa   774416 00 0054	desc9a	-1778,44		000350 = 162143160137
003734  aa  6 01164 00 0054	desc9a	pr6|628,44
003735  aa   774261 3520 04	epp2 	-1871,ic		000216 = 000000000000
003736  aa  6 01140 2521 00	spri2	pr6|608
003737  aa  6 00162 3521 00	epp2 	pr6|114		ecode
003740  aa  6 01142 2521 00	spri2	pr6|610
003741  aa  6 01164 3521 00	epp2 	pr6|628
003742  aa  6 01144 2521 00	spri2	pr6|612
003743  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003744  aa  6 01146 2521 00	spri2	pr6|614
003745  aa   774250 3520 04	epp2 	-1880,ic		000215 = 404000000021
003746  aa  6 01150 2521 00	spri2	pr6|616
003747  aa   774257 3520 04	epp2 	-1873,ic		000226 = 404000000043
003750  aa  6 01152 2521 00	spri2	pr6|618
003751  aa   774226 3520 04	epp2 	-1898,ic		000177 = 524000000052
003752  aa  6 01154 2521 00	spri2	pr6|620
003753  aa   774240 3520 04	epp2 	-1888,ic		000213 = 526000000040
003754  aa  6 01156 2521 00	spri2	pr6|622
003755  aa  6 01136 6211 00	eax1 	pr6|606
003756  aa   020000 4310 07	fld  	8192,dl
003757  aa  6 00044 3701 20	epp4 	pr6|36,*
003760  la  4 00036 3521 20	epp2 	pr4|30,*		admin_gate_$syserr_error_code
003761  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 875
		return;

003762  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 876
	     end;

						STATEMENT 1 ON LINE 877
	end;

						STATEMENT 1 ON LINE 879
	call admin_gate_$syserr (ANNOUNCE, "RCP: Added device ^a", device_name);

003763  aa   774263 2370 04	ldaq 	-1869,ic		000246 = 122103120072 040101144144
003764  aa  6 01164 7571 00	staq 	pr6|628
003765  aa   774263 2370 04	ldaq 	-1869,ic		000250 = 145144040144 145166151143
003766  aa  6 01166 7571 00	staq 	pr6|630
003767  aa   774263 2350 04	lda  	-1869,ic		000252 = 145040136141
003770  aa  6 01170 7551 00	sta  	pr6|632
003771  aa   774225 3520 04	epp2 	-1899,ic		000216 = 000000000000
003772  aa  6 01140 2521 00	spri2	pr6|608
003773  aa  6 01164 3521 00	epp2 	pr6|628
003774  aa  6 01142 2521 00	spri2	pr6|610
003775  aa  6 00150 3521 00	epp2 	pr6|104		device_name
003776  aa  6 01144 2521 00	spri2	pr6|612
003777  aa   774216 3520 04	epp2 	-1906,ic		000215 = 404000000021
004000  aa  6 01146 2521 00	spri2	pr6|614
004001  aa   774175 3520 04	epp2 	-1923,ic		000176 = 524000000024
004002  aa  6 01150 2521 00	spri2	pr6|616
004003  aa   774210 3520 04	epp2 	-1912,ic		000213 = 526000000040
004004  aa  6 01152 2521 00	spri2	pr6|618
004005  aa  6 01136 6211 00	eax1 	pr6|606
004006  aa   014000 4310 07	fld  	6144,dl
004007  aa  6 00044 3701 20	epp4 	pr6|36,*
004010  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
004011  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 881
     end ADD_DEVICE;

004012  aa  6 00360 6101 00	rtcd 	pr6|240
  END PROCEDURE ADD_DEVICE
BEGIN PROCEDURE ACCOUNT_ATTACH
ENTRY TO ACCOUNT_ATTACH                                     STATEMENT 1 ON LINE 883
ACCOUNT_ATTACH:
     procedure;

004013  aa  6 00372 6501 00	spri4	pr6|250
						STATEMENT 1 ON LINE 889
	device_off = offset_message.device_off;

004014  aa  6 00246 3735 20	epp7 	pr6|166,*		message_ptr
004015  aa  7 00001 2351 00	lda  	pr7|1		offset_message.device_off
004016  aa   000022 7350 00	als  	18
004017  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 891
	device_ptr = ptr (rcpd_ptr, device_off);

004020  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
004021  aa   000000 3120 01	eawp2	0,au
004022  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 893
	call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_attach);

004023  aa   000445 3520 04	epp2 	293,ic		004470 = 000004000000
004024  aa   000365 6700 04	tsp4 	245,ic		004411
						STATEMENT 1 ON LINE 895
     end ACCOUNT_ATTACH;

004025  aa  6 00372 6101 00	rtcd 	pr6|250
  END PROCEDURE ACCOUNT_ATTACH
BEGIN PROCEDURE UNASSIGN_DEVICE
ENTRY TO UNASSIGN_DEVICE                                    STATEMENT 1 ON LINE 897
UNASSIGN_DEVICE:
     procedure;

004026  aa  6 00400 6501 00	spri4	pr6|256
						STATEMENT 1 ON LINE 907
	time_assigned = device.state_time;

004027  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004030  aa  7 00022 2371 00	ldaq 	pr7|18		device.state_time
004031  aa  6 00206 7571 00	staq 	pr6|134		time_assigned
						STATEMENT 1 ON LINE 909
	if device.flags.delete /* Are we waiting to delete this device? */ & device.unassign_state = 0
						/* And is it about to be freed? */
	then do;

004032  aa  7 00035 2351 00	lda  	pr7|29		device.delete
004033  aa   400000 3150 03	cana 	131072,du
004034  aa   000110 6000 04	tze  	72,ic		004144
004035  aa  7 00025 2361 00	ldq  	pr7|21		device.unassign_state
004036  aa   000106 6010 04	tnz  	70,ic		004144
						STATEMENT 1 ON LINE 912
	     call admin_gate_$ioi_delete_device (device_name, ignored_code);

004037  aa  6 00150 3521 00	epp2 	pr6|104		device_name
004040  aa  6 01204 2521 00	spri2	pr6|644
004041  aa  6 00406 3521 00	epp2 	pr6|262		ignored_code
004042  aa  6 01206 2521 00	spri2	pr6|646
004043  aa   774150 3520 04	epp2 	-1944,ic		000213 = 526000000040
004044  aa  6 01210 2521 00	spri2	pr6|648
004045  aa   774161 3520 04	epp2 	-1935,ic		000226 = 404000000043
004046  aa  6 01212 2521 00	spri2	pr6|650
004047  aa  6 01202 6211 00	eax1 	pr6|642
004050  aa   010000 4310 07	fld  	4096,dl
004051  aa  6 00044 3701 20	epp4 	pr6|36,*
004052  la  4 00032 3521 20	epp2 	pr4|26,*		admin_gate_$ioi_delete_device
004053  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 914
	     if device.volume_name ^= "" & device.dtypex <= 2 then do;

004054  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004055  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
004056  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
004057  aa   000433 00 0000	desc9a	283,0		004510 = 040000000000
004060  aa   000021 6000 04	tze  	17,ic		004101
004061  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
004062  aa   000002 1160 07	cmpq 	2,dl
004063  aa   000016 6054 04	tpnz 	14,ic		004101
						STATEMENT 1 ON LINE 916
		device.state = device.unassign_state;

004064  aa  7 00025 2361 00	ldq  	pr7|21		device.unassign_state
004065  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 917
		call rcp_unload_$unload_device (device_ptr, "1"b);

004066  aa   400000 2350 03	lda  	131072,du
004067  aa  6 01214 7551 00	sta  	pr6|652
004070  aa  6 00236 3521 00	epp2 	pr6|158		device_ptr
004071  aa  6 01204 2521 00	spri2	pr6|644
004072  aa  6 01214 3521 00	epp2 	pr6|652
004073  aa  6 01206 2521 00	spri2	pr6|646
004074  aa  6 01202 6211 00	eax1 	pr6|642
004075  aa   010000 4310 07	fld  	4096,dl
004076  aa  6 00044 3701 20	epp4 	pr6|36,*
004077  la  4 00070 3521 20	epp2 	pr4|56,*		rcp_unload_$unload_device
004100  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 919
	     end;

						STATEMENT 1 ON LINE 920
	     device.state = 2;

004101  aa   000002 2360 07	ldq  	2,dl
004102  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004103  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 921
	     device.volume_name = " ";

004104  aa  040 100 100 400	mlr  	(),(pr),fill(040)
004105  aa   000000 00 0000	desc9a	0,0
004106  aa  7 00002 00 0040	desc9a	pr7|2,32		device.volume_name
						STATEMENT 1 ON LINE 922
	     if ^device.flags.priv			/* If not assigned while deleted say it is deleted now. */
	     then call admin_gate_$syserr (ANNOUNCE, "RCP: Deleted device ^a", device.device_name);

004107  aa  7 00035 2351 00	lda  	pr7|29		device.priv
004110  aa   200000 3150 03	cana 	65536,du
004111  aa   000025 6010 04	tnz  	21,ic		004136
004112  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004113  aa   774141 00 0030	desc9a	-1951,24		000253 = 122103120072
004114  aa  6 01202 00 0030	desc9a	pr6|642,24
004115  aa   774101 3520 04	epp2 	-1983,ic		000216 = 000000000000
004116  aa  6 01220 2521 00	spri2	pr6|656
004117  aa  6 01202 3521 00	epp2 	pr6|642
004120  aa  6 01222 2521 00	spri2	pr6|658
004121  aa  7 00000 3521 00	epp2 	pr7|0		device.device_name
004122  aa  6 01224 2521 00	spri2	pr6|660
004123  aa   774072 3520 04	epp2 	-1990,ic		000215 = 404000000021
004124  aa  6 01226 2521 00	spri2	pr6|662
004125  aa   774062 3520 04	epp2 	-1998,ic		000207 = 524000000026
004126  aa  6 01230 2521 00	spri2	pr6|664
004127  aa   774061 3520 04	epp2 	-1999,ic		000210 = 524000000010
004130  aa  6 01232 2521 00	spri2	pr6|666
004131  aa  6 01216 6211 00	eax1 	pr6|654
004132  aa   014000 4310 07	fld  	6144,dl
004133  aa  6 00044 3701 20	epp4 	pr6|36,*
004134  la  4 00034 3521 20	epp2 	pr4|28,*		admin_gate_$syserr
004135  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 924
	     device.flags.delete,			/* Turn off these flags. */
		device.flags.priv = "0"b;

004136  aa   000340 2350 04	lda  	224,ic		004476 = 377777777777
004137  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004140  aa  7 00035 3551 00	ansa 	pr7|29		device.delete
004141  aa   000325 2350 04	lda  	213,ic		004466 = 577777777777
004142  aa  7 00035 3551 00	ansa 	pr7|29		device.priv
						STATEMENT 1 ON LINE 926
	end;

004143  aa   000003 7100 04	tra  	3,ic		004146
						STATEMENT 1 ON LINE 927
	else device.state = device.unassign_state;

004144  aa  7 00025 2361 00	ldq  	pr7|21		device.unassign_state
004145  aa  7 00024 7561 00	stq  	pr7|20		device.state
						STATEMENT 1 ON LINE 928
	device.unassign_state = 0;

004146  aa  7 00025 4501 00	stz  	pr7|21		device.unassign_state
						STATEMENT 1 ON LINE 930
	if device.state ^= 4 then do;

004147  aa  7 00024 2361 00	ldq  	pr7|20		device.state
004150  aa   000004 1160 07	cmpq 	4,dl
004151  aa   000041 6000 04	tze  	33,ic		004212
						STATEMENT 1 ON LINE 931
	     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_unassign);

004152  aa   000306 3520 04	epp2 	198,ic		004460 = 000004000000
004153  aa   000236 6700 04	tsp4 	158,ic		004411
						STATEMENT 1 ON LINE 933
	     device.process_id = "0"b;

004154  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004155  aa  7 00036 4501 00	stz  	pr7|30		device.process_id
						STATEMENT 1 ON LINE 934
	     device.reservation_id = 0;

004156  aa   774056 2370 04	ldaq 	-2002,ic		000234 = 000000000000 000000000000
004157  aa  7 00060 7571 00	staq 	pr7|48		device.reservation_id
						STATEMENT 1 ON LINE 935
	     device.reserved_by = "";

004160  aa  040 100 100 400	mlr  	(),(pr),fill(040)
004161  aa   000000 00 0000	desc9a	0,0
004162  aa  7 00062 00 0040	desc9a	pr7|50,32		device.reserved_by
						STATEMENT 1 ON LINE 936
	     call rcp_cancel_resource_ (DEVICE_TYPE (device.dtypex), (device.device_name), ignored_code);

004163  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
004164  aa   000003 7360 00	qls  	3
004165  aa   000000 6270 06	eax7 	0,ql
004166  aa  7 00000 2351 00	lda  	pr7|0		device.device_name
004167  aa  7 00001 2361 00	ldq  	pr7|1		device.device_name
004170  aa  6 01234 7571 00	staq 	pr6|668
004171  ta   000075 3520 17	epp2 	61,7
004172  aa  6 01220 2521 00	spri2	pr6|656
004173  aa  6 01234 3521 00	epp2 	pr6|668
004174  aa  6 01222 2521 00	spri2	pr6|658
004175  aa  6 00406 3521 00	epp2 	pr6|262		ignored_code
004176  aa  6 01224 2521 00	spri2	pr6|660
004177  aa   774014 3520 04	epp2 	-2036,ic		000213 = 526000000040
004200  aa  6 01226 2521 00	spri2	pr6|662
004201  aa   774007 3520 04	epp2 	-2041,ic		000210 = 524000000010
004202  aa  6 01230 2521 00	spri2	pr6|664
004203  aa   774023 3520 04	epp2 	-2029,ic		000226 = 404000000043
004204  aa  6 01232 2521 00	spri2	pr6|666
004205  aa  6 01216 6211 00	eax1 	pr6|654
004206  aa   014000 4310 07	fld  	6144,dl
004207  aa  6 00044 3701 20	epp4 	pr6|36,*
004210  la  4 00076 3521 20	epp2 	pr4|62,*		rcp_cancel_resource_
004211  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 937
	end;

						STATEMENT 1 ON LINE 938
	device.state_time = clock ();

004212  aa  0 01435 7001 00	tsx0 	pr0|797		clock
004213  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004214  aa  7 00022 7571 00	staq 	pr7|18		device.state_time
						STATEMENT 1 ON LINE 940
	device.num_assigns = device.num_assigns + 1;

004215  aa  7 00050 2351 00	lda  	pr7|40		device.num_assigns
004216  aa   000044 7330 00	lrs  	36
004217  aa   000001 0330 07	adl  	1,dl
004220  aa  7 00050 7561 00	stq  	pr7|40		device.num_assigns
						STATEMENT 1 ON LINE 941
	device.flags.mounting = "0"b;

004221  aa   000266 2350 04	lda  	182,ic		004507 = 757777777777
004222  aa  7 00035 3551 00	ansa 	pr7|29		device.mounting
						STATEMENT 1 ON LINE 942
	device.flags.attached = "0"b;

004223  aa   000233 2350 04	lda  	155,ic		004456 = 773777777777
004224  aa  7 00035 3551 00	ansa 	pr7|29		device.attached
						STATEMENT 1 ON LINE 944
	time_assigned = device.state_time - time_assigned;

004225  aa  7 00022 2371 00	ldaq 	pr7|18		device.state_time
004226  aa  6 00206 1771 00	sbaq 	pr6|134		time_assigned
004227  aa  6 00206 7571 00	staq 	pr6|134		time_assigned
						STATEMENT 1 ON LINE 945
	device.tot_assign_time = device.tot_assign_time + time_assigned;

004230  aa  7 00052 0771 00	adaq 	pr7|42		device.tot_assign_time
004231  aa  7 00052 7571 00	staq 	pr7|42		device.tot_assign_time
						STATEMENT 1 ON LINE 946
	time_assigned = divide (time_assigned, 1000000, 71, 0);

004232  aa  6 00206 2371 00	ldaq 	pr6|134		time_assigned
004233  aa   773742 3520 04	epp2 	-2078,ic		000175 = 000003641100
004234  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
004235  aa     000000000000
004236  aa  6 00206 7571 00	staq 	pr6|134		time_assigned
						STATEMENT 1 ON LINE 947
	dtype_ptr = addr (rcpd.dtype (device.dtypex));

004237  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
004240  aa   000017 4020 07	mpy  	15,dl
004241  aa  6 00232 3715 20	epp5 	pr6|154,*		rcpd_ptr
004242  aa  5 00024 3715 06	epp5 	pr5|20,ql		rcpd.dtype
004243  aa  6 00234 6515 00	spri5	pr6|156		dtype_ptr
						STATEMENT 1 ON LINE 949
	do i = 1 to hbound (dtype.histo_times, 1);

004244  aa   000001 2360 07	ldq  	1,dl
004245  aa  6 00163 7561 00	stq  	pr6|115		i
004246  aa  6 00163 2361 00	ldq  	pr6|115		i
004247  aa   000003 1160 07	cmpq 	3,dl
004250  aa   000014 6054 04	tpnz 	12,ic		004264
						STATEMENT 1 ON LINE 950
	     if time_assigned < dtype.histo_times (i) then do;

004251  aa  6 00234 3735 20	epp7 	pr6|156,*		dtype_ptr
004252  aa  7 00013 2351 06	lda  	pr7|11,ql		dtype.histo_times
004253  aa   000044 7330 00	lrs  	36
004254  aa  6 00206 1171 00	cmpaq	pr6|134		time_assigned
004255  aa   000005 6044 04	tmoz 	5,ic		004262
						STATEMENT 1 ON LINE 952
		device.histogram (i) = device.histogram (i) + 1;

004256  aa  6 00163 7271 00	lxl7 	pr6|115		i
004257  aa  6 00236 3715 20	epp5 	pr6|158,*		device_ptr
004260  aa  5 00053 0541 17	aos  	pr5|43,7		device.histogram
						STATEMENT 1 ON LINE 953
		return;

004261  aa  6 00400 6101 00	rtcd 	pr6|256
						STATEMENT 1 ON LINE 954
	     end;

						STATEMENT 1 ON LINE 955
	end;

004262  aa  6 00163 0541 00	aos  	pr6|115		i
004263  aa   777763 7100 04	tra  	-13,ic		004246
						STATEMENT 1 ON LINE 956
	device.histogram (hbound (device.histogram, 1)) = device.histogram (hbound (device.histogram, 1)) + 1;

004264  aa  6 00236 3735 20	epp7 	pr6|158,*		device_ptr
004265  aa  7 00057 0541 00	aos  	pr7|47		device.histogram
						STATEMENT 1 ON LINE 958
     end UNASSIGN_DEVICE;

004266  aa  6 00400 6101 00	rtcd 	pr6|256
  END PROCEDURE UNASSIGN_DEVICE
BEGIN PROCEDURE UNASSIGN_VOLUME
ENTRY TO UNASSIGN_VOLUME                                    STATEMENT 1 ON LINE 960
UNASSIGN_VOLUME:
     proc ();

004267  aa  6 00410 6501 00	spri4	pr6|264
						STATEMENT 1 ON LINE 971
	volume.state_time = clock ();

004270  aa  0 01435 7001 00	tsx0 	pr0|797		clock
004271  aa  6 00240 3735 20	epp7 	pr6|160,*		volume_ptr
004272  aa  7 00034 7571 00	staq 	pr7|28		volume.state_time
						STATEMENT 1 ON LINE 972
	volume.state = volume.unassign_state;

004273  aa  7 00037 2361 00	ldq  	pr7|31		volume.unassign_state
004274  aa  7 00036 7561 00	stq  	pr7|30		volume.state
						STATEMENT 1 ON LINE 973
	volume.unassign_state = 0;

004275  aa  7 00037 4501 00	stz  	pr7|31		volume.unassign_state
						STATEMENT 1 ON LINE 974
	if volume.state = 0 then do;

004276  aa  7 00036 2361 00	ldq  	pr7|30		volume.state
004277  aa   000050 6010 04	tnz  	40,ic		004347
						STATEMENT 1 ON LINE 975
	     volume.process_id = "0"b;

004300  aa  7 00000 4501 00	stz  	pr7|0		volume.process_id
						STATEMENT 1 ON LINE 976
	     volume.reserved_by = "";

004301  aa  040 100 100 400	mlr  	(),(pr),fill(040)
004302  aa   000000 00 0000	desc9a	0,0
004303  aa  7 00022 00 0040	desc9a	pr7|18,32		volume.reserved_by
						STATEMENT 1 ON LINE 977
	     volume.reservation_id = 0;

004304  aa   773730 2370 04	ldaq 	-2088,ic		000234 = 000000000000 000000000000
004305  aa  7 00032 7571 00	staq 	pr7|26		volume.reservation_id
						STATEMENT 1 ON LINE 978
	     call rcp_cancel_resource_ (VOLUME_TYPE (volume.vtypex), (volume.volume_name), ignored_code);

004306  aa  7 00011 2361 00	ldq  	pr7|9		volume.vtypex
004307  aa   000003 7360 00	qls  	3
004310  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
004311  aa  7 00001 00 0040	desc9a	pr7|1,32		volume.volume_name
004312  aa  6 01236 00 0040	desc9a	pr6|670,32
004313  ta   000005 3520 06	epp2 	5,ql
004314  aa  6 01250 2521 00	spri2	pr6|680
004315  aa  6 01236 3521 00	epp2 	pr6|670
004316  aa  6 01252 2521 00	spri2	pr6|682
004317  aa  6 00416 3521 00	epp2 	pr6|270		ignored_code
004320  aa  6 01254 2521 00	spri2	pr6|684
004321  aa   773672 3520 04	epp2 	-2118,ic		000213 = 526000000040
004322  aa  6 01256 2521 00	spri2	pr6|686
004323  aa   773666 3520 04	epp2 	-2122,ic		000211 = 524000000040
004324  aa  6 01260 2521 00	spri2	pr6|688
004325  aa   773701 3520 04	epp2 	-2111,ic		000226 = 404000000043
004326  aa  6 01262 2521 00	spri2	pr6|690
004327  aa  6 01246 6211 00	eax1 	pr6|678
004330  aa   014000 4310 07	fld  	6144,dl
004331  aa  6 00044 3701 20	epp4 	pr6|36,*
004332  la  4 00076 3521 20	epp2 	pr4|62,*		rcp_cancel_resource_
004333  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 980
	     if rcpd.unload_on_detach then do;

004334  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
004335  aa  7 00014 2351 00	lda  	pr7|12		rcpd.unload_on_detach
004336  aa   200000 3150 03	cana 	65536,du
004337  aa   000010 6000 04	tze  	8,ic		004347
						STATEMENT 1 ON LINE 981
		volume.volume_name = "";

004340  aa  6 00240 3715 20	epp5 	pr6|160,*		volume_ptr
004341  aa  040 100 100 400	mlr  	(),(pr),fill(040)
004342  aa   000000 00 0000	desc9a	0,0
004343  aa  5 00001 00 0040	desc9a	pr5|1,32		volume.volume_name
						STATEMENT 1 ON LINE 982
		volume.group_id = "";

004344  aa  040 100 100 400	mlr  	(),(pr),fill(040)
004345  aa   000000 00 0000	desc9a	0,0
004346  aa  5 00012 00 0040	desc9a	pr5|10,32		volume.group_id
						STATEMENT 1 ON LINE 983
	     end;

						STATEMENT 1 ON LINE 984
	end;

						STATEMENT 1 ON LINE 985
	return;

004347  aa  6 00410 6101 00	rtcd 	pr6|264
						STATEMENT 1 ON LINE 987
     end UNASSIGN_VOLUME;

  END PROCEDURE UNASSIGN_VOLUME
BEGIN PROCEDURE FIND_DEVICE
ENTRY TO FIND_DEVICE                                        STATEMENT 1 ON LINE 989
FIND_DEVICE:
     procedure;

004350  aa  6 00420 6501 00	spri4	pr6|272
						STATEMENT 1 ON LINE 996
	do i = 1 to rcpd.tot_dtypes;

004351  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
004352  aa  7 00015 2361 00	ldq  	pr7|13		rcpd.tot_dtypes
004353  aa  6 00426 7561 00	stq  	pr6|278
004354  aa   000001 2360 07	ldq  	1,dl
004355  aa  6 00163 7561 00	stq  	pr6|115		i
004356  aa  6 00163 2361 00	ldq  	pr6|115		i
004357  aa  6 00426 1161 00	cmpq 	pr6|278
004360  aa   000027 6054 04	tpnz 	23,ic		004407
						STATEMENT 1 ON LINE 997
	     dtype_ptr = addr (rcpd.dtype (i));

004361  aa   000017 4020 07	mpy  	15,dl
004362  aa  6 00232 3735 20	epp7 	pr6|154,*		rcpd_ptr
004363  aa  7 00024 3735 06	epp7 	pr7|20,ql		rcpd.dtype
004364  aa  6 00234 6535 00	spri7	pr6|156		dtype_ptr
						STATEMENT 1 ON LINE 998
	     device_off = dtype.first_off;

004365  aa  7 00013 2351 00	lda  	pr7|11		dtype.first_off
004366  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 999
	     do while (device_off ^= "0"b);

004367  aa   000000 0110 03	nop  	0,du
004370  aa  6 00160 2351 00	lda  	pr6|112		device_off
004371  aa   000014 6000 04	tze  	12,ic		004405
						STATEMENT 1 ON LINE 1000
		device_ptr = ptr (rcpd_ptr, device_off);

004372  aa  6 00232 3521 20	epp2 	pr6|154,*		rcpd_ptr
004373  aa   000000 3120 01	eawp2	0,au
004374  aa  6 00236 2521 00	spri2	pr6|158		device_ptr
						STATEMENT 1 ON LINE 1001
		if device.device_name = device_name then
		     return;

004375  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
004376  aa  2 00000 00 0010	desc9a	pr2|0,8		device.device_name
004377  aa  6 00150 00 0040	desc9a	pr6|104,32	device_name
004400  aa   000002 6010 04	tnz  	2,ic		004402
004401  aa  6 00420 6101 00	rtcd 	pr6|272
						STATEMENT 1 ON LINE 1003
		device_off = device.next_off;

004402  aa  2 00031 2351 00	lda  	pr2|25		device.next_off
004403  aa  6 00160 7551 00	sta  	pr6|112		device_off
						STATEMENT 1 ON LINE 1004
	     end;

004404  aa   777764 7100 04	tra  	-12,ic		004370
						STATEMENT 1 ON LINE 1005
	end;

004405  aa  6 00163 0541 00	aos  	pr6|115		i
004406  aa   777750 7100 04	tra  	-24,ic		004356
						STATEMENT 1 ON LINE 1007
	device_off = "0"b;

004407  aa  6 00160 4501 00	stz  	pr6|112		device_off
						STATEMENT 1 ON LINE 1009
     end FIND_DEVICE;

004410  aa  6 00420 6101 00	rtcd 	pr6|272
  END PROCEDURE FIND_DEVICE
BEGIN PROCEDURE ACCOUNT_WAKEUP
ENTRY TO ACCOUNT_WAKEUP                                     STATEMENT 1 ON LINE 1011
ACCOUNT_WAKEUP:
     procedure (a_devptr, a_action);

004411  aa  6 00430 6501 00	spri4	pr6|280
004412  aa  6 00432 2521 00	spri2	pr6|282
						STATEMENT 1 ON LINE 1025
	unspec (auto_rcpamsg) = "0"b;

004413  aa   773621 2370 04	ldaq 	-2159,ic		000234 = 000000000000 000000000000
004414  aa  6 00440 7571 00	staq 	pr6|288
						STATEMENT 1 ON LINE 1027
	auto_rcpamsg.device_user_procid = a_devptr -> device.process_id;

004415  aa  2 00002 3735 20	epp7 	pr2|2,*		a_devptr
004416  aa  7 00000 3735 20	epp7 	pr7|0,*		a_devptr
004417  aa  7 00036 2351 00	lda  	pr7|30		device.process_id
004420  aa  6 00440 7551 00	sta  	pr6|288		auto_rcpamsg.device_user_procid
						STATEMENT 1 ON LINE 1028
	auto_rcpamsg.rcp_data_relp = rel (a_devptr);

004421  aa  7 00000 6351 00	eaa  	pr7|0		a_devptr
004422  aa  6 00441 5511 60	stba 	pr6|289,60	auto_rcpamsg.rcp_data_relp
						STATEMENT 1 ON LINE 1029
	auto_rcpamsg.devtype = a_devptr -> device.dtypex;

004423  aa  7 00012 2361 00	ldq  	pr7|10		device.dtypex
004424  aa   000055 7370 00	lls  	45
004425  aa  6 00441 5511 10	stba 	pr6|289,10	auto_rcpamsg.devtype
						STATEMENT 1 ON LINE 1030
	auto_rcpamsg.action = a_action;

004426  aa  2 00004 2361 20	ldq  	pr2|4,*		a_action
004427  aa  6 00441 6761 00	erq  	pr6|289		auto_rcpamsg.action
004430  aa   000007 3760 07	anq  	7,dl
004431  aa  6 00441 6561 00	ersq 	pr6|289		auto_rcpamsg.action
						STATEMENT 1 ON LINE 1032
	unspec (wakeup_buf) = unspec (auto_rcpamsg);

004432  aa  6 00440 2371 00	ldaq 	pr6|288
004433  aa  6 00436 7571 00	staq 	pr6|286
						STATEMENT 1 ON LINE 1033
	if rcpd.accounting_chan ^= 0 then
	     call hcs_$wakeup (rcpd.accounting_pid, rcpd.accounting_chan, wakeup_buf, (0));

004434  aa  6 00232 3715 20	epp5 	pr6|154,*		rcpd_ptr
004435  aa  5 00026 2371 00	ldaq 	pr5|22		rcpd.accounting_chan
004436  aa   000017 6000 04	tze  	15,ic		004455
004437  aa  6 01264 4501 00	stz  	pr6|692
004440  aa  5 00030 3521 00	epp2 	pr5|24		rcpd.accounting_pid
004441  aa  6 01270 2521 00	spri2	pr6|696
004442  aa  5 00026 3521 00	epp2 	pr5|22		rcpd.accounting_chan
004443  aa  6 01272 2521 00	spri2	pr6|698
004444  aa  6 00436 3521 00	epp2 	pr6|286		wakeup_buf
004445  aa  6 01274 2521 00	spri2	pr6|700
004446  aa  6 01264 3521 00	epp2 	pr6|692
004447  aa  6 01276 2521 00	spri2	pr6|702
004450  aa  6 01266 6211 00	eax1 	pr6|694
004451  aa   020000 4310 07	fld  	8192,dl
004452  aa  6 00044 3701 20	epp4 	pr6|36,*
004453  la  4 00042 3521 20	epp2 	pr4|34,*		hcs_$wakeup
004454  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1036
     end ACCOUNT_WAKEUP;

004455  aa  6 00430 6101 00	rtcd 	pr6|280
  END PROCEDURE ACCOUNT_WAKEUP
  END PROCEDURE rcp_initializer_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
