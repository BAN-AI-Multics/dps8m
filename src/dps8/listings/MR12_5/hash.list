	COMPILATION LISTING OF SEGMENT hash
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1009.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 hash: proc;
       14 
       15 /* Modified 07/77 by THVV for bad_dir_ check */
       16 /* Mod by S. E. Barr 4/77 to add a count to hash chain loop to prevent looping indefinitely */
       17 /* Mod by S.E. Barr 9/76 to use hash threads and variable hash table sizes */
       18 /* Mod by B. Greenberg 4/28/75 to remove in-directory hashing meters, for NSS */
       19 /* Modified by E. Stone 8/73 to convert to version 2 and to meter unsuccessful searches as well as successful ones */
       20 /*
       21*   NAME:	hash
       22*
       23*   This does all the necessary manipulations on the directory hash table.
       24*
       25*   ENTRY:	hash$in
       26*
       27*   This entry is called to add an entry to the directory hash table.
       28*   It assumes that the name has already been allocated in the directory.
       29*
       30*   USAGE:	call hash$in (dp, arg_name_entry_ptr, code);
       31*
       32*   1) dp (ptr)				directory pointer (Input)
       33*   2) arg_name_entry_ptr (ptr)		pointer to the name entry to be hashed (Input)
       34*   3) code (fixed bin)			error code (Output)
       35*
       36*   ENTRY:	hash$out
       37*
       38*   This entry is called to remove an entry from the directory hash table.
       39*
       40*   USAGE:	call hash$out (dp, arg_name_ptr, arg_name_entry_ptr, code);
       41*
       42*   1) as above
       43*   2) arg_name_ptr (ptr)			pointer to name to be hashed (Input)
       44*   3) arg_name_entry_ptr (ptr)		pointer to the name entry which was hashed (Output)
       45*   4) as above
       46*
       47*   ENTRY:	hash$search
       48*
       49*   This entry is called to search the directory hash table for a given name.
       50*
       51*   USAGE:	call hash$search (dp, arg_name_ptr, arg_entry_ptr, code);
       52*
       53*   1) as above
       54*   2) arg_name_ptr (ptr)			pointer to name to be hashed (Input)
       55*   3) arg_entry_ptr (ptr)			pointer to entry to which the name belongs (Output)
       56*   4) as above
       57*
       58*   */
       59 
       60 
       61 /* arguments */
       62 
       63 dcl  arg_name_ptr ptr;				/* pointer to character string with name */
       64 dcl  arg_name_entry_ptr ptr;				/* pointer to name structure */
       65 dcl  arg_entry_ptr ptr;				/* pointer to entry */
       66 dcl  code fixed bin (35);				/* standard Multics error code */
       67 
       68 /* automatic */
       69 
       70 dcl  name_ptr ptr;					/* ptr to charcter string with name */
       71 dcl  p ptr;					/* ptr to name structure */
       72 dcl  cur_index fixed bin;				/* hash index for this name */
       73 dcl  cur_offset bit (18) unal;			/* offset of current  entry name structure */
       74 dcl  prev_offset bit (18) unal;			/* offset of previous entry name structure */
       75 dcl  found bit (1) unal;				/* ON if name is in hash table */
       76 dcl  names_seen fixed bin;				/* names_seen of names on hash chain */
       77 
       78 
       79 dcl  name char (32) based (name_ptr);
       80 
       81 dcl (error_table_$argerr, error_table_$noentry,
       82      error_table_$hashtbl_error) ext fixed bin (35);
       83 dcl  active_hardcore_data$num_hash_table_sizes ext fixed bin;
       84 dcl  active_hardcore_data$hash_table_sizes (1) ext fixed bin;
       85 dcl  fs_alloc$free entry (ptr, fixed bin, ptr);
       86 dcl  allocate_dir_ht_ entry (ptr, fixed bin, fixed bin (35));
       87 dcl  hash_index_ entry (ptr, fixed bin, fixed bin, fixed bin) returns (fixed bin);
       88 dcl (addr, index, null, ptr, rel, unspec) builtin;
       89 dcl  bad_dir_ condition;
       90 
       91 
  1     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  1     2 /* Modified 8/74 for NSS */
  1     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  1     4 /* Modified 3/82 BIM for change pclock */
  1     5 /* format: style3 */
  1     6 
  1     7 /* Template for the directory header. Length = 64 words. */
  1     8 
  1     9 dcl  dp ptr;
  1    10 
  1    11 dcl 1 dir based (dp) aligned,
  1    12 
  1    13    2 modify bit (36),				/* Process ID of last modifier */
  1    14    2 type bit (18) unaligned,			/* type of object = dir header */
  1    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  1    16     2 dtc (3),					/* date-time checked by salvager array */
  1    17       3 date bit (36),				/* the date */
  1    18       3 error bit (36),				/* what errors were discovered */
  1    19 
  1    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  1    21 
  1    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  1    23 
  1    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  1    25 
  1    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  1    27 
  1    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  1    29     2 version_number fixed bin (17),			/* version number of header */
  1    30 
  1    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  1    32     2 pad2 bit (18),
  1    33 
  1    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  1    35     2 pad3 bit (18),
  1    36 
  1    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  1    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  1    39 
  1    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  1    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  1    42 
  1    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  1    44     2 dir_count fixed bin (17),			/* number of directory branches */
  1    45 
  1    46     2 lcount fixed bin (17),				/* number of links */
  1    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  1    48 
  1    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  1    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  1    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  1    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  1    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  1    54     2 pad4 bit (14),
  1    55 
  1    56     2 iacl_count (0:7),
  1    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  1    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  1    59 
  1    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  1    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  1    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  1    63 
  1    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  1    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  1    66 
  1    67     2 htsize fixed bin (17),				/* size of hash table */
  1    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  1    69 
  1    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  1    71     2 pad6 fixed bin (17),
  1    72 
  1    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  1    74     2 pad7 bit (18)) unaligned,
  1    75 
  1    76     2 dts bit (36),					/* date-time directory last salvaged */
  1    77 
  1    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  1    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  1    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  1    81     2 checksum bit (36),				/* checksummed from uid on */
  1    82     2 owner bit (36);				/* uid of parent dir */
  1    83 
  1    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  1    85 
  1    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
       92 
  2     1 /*     BEGIN INCLUDE FILE ... dir_ht.incl.pl1 */
  2     2 
  2     3 
  2     4 dcl htp ptr;
  2     5 
  2     6 dcl 1 hash_table based (htp) aligned,			/* htp = ptr(dp,active_hardcore_data$htrp) */
  2     7     2 modify bit (36) unal,
  2     8     2 type bit (18) unal,				/* type = dir hash table */
  2     9     2 size fixed bin (17) unal,			/* size of current dir hash table entry */
  2    10     2 name_rp (0:1) bit(18) unal,			/* rel ptr of name entry  */
  2    11     2 checksum bit (36) unal,
  2    12     2 owner bit (36) unal;
  2    13 						/* otherwise rel ptr to name */
  2    14 
  2    15 /*     END INCLUDE FILE ... dir_ht.incl.pl1 */
       93 
       94 /*  */
  3     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
       95 
  4     1 /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  4     2 
  4     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  4     4 
  4     5 
  4     6 dcl 1 link based (ep) aligned,
  4     7 
  4     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  4    10 
  4    11     2 type bit (18),				/* type = dir link */
  4    12     2 size fixed bin (17),				/* size of link in words */
  4    13 
  4    14     2 uid bit (36),					/* unique id of entry */
  4    15 
  4    16     2 dtem bit (36),				/* date-time entry modified */
  4    17 
  4    18     2 bs bit (1),					/* entry switch = 1 if entry */
  4    19     2 pad0 bit (17),
  4    20     2 nnames fixed bin (17),				/* number of names for this entry */
  4    21 
  4    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    24 
  4    25     2 author,					/* user who created entry */
  4    26       3 pers_rp bit (18),				/* name of user who created entry */
  4    27       3 proj_rp bit (18),				/* project of user who created entry */
  4    28 
  4    29       3 tag char (1),				/* tag of user who created entry */
  4    30       3 pad1 char (3),
  4    31 
  4    32     2 primary_name bit (504),				/* first name on name list */
  4    33 
  4    34     2 dtd bit (36),					/* date time dumped */
  4    35 
  4    36     2 pad2 bit (36),
  4    37 
  4    38 
  4    39 /* the declarations below are only applicable to links */
  4    40 
  4    41     2 pad3 bit (18),
  4    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  4    43 
  4    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  4    45 
  4    46     2 checksum bit (36),				/* checksum from uid */
  4    47 
  4    48     2 owner bit (36);				/* uid of containing directory */
  4    49 
  4    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
       96 
  5     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
       97 
  6     1 /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  6     2 
  6     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  6     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  6     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  6     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  6     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  6     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  6     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  6    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  6    11 
  6    12 dcl  access_name_type fixed bin static options (constant) init (1);
  6    13 dcl  acle_type fixed bin static options (constant) init (2);
  6    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  6    15 dcl  dir_type fixed bin static options (constant) init (4);
  6    16 dcl  link_type fixed bin static options (constant) init (5);
  6    17 dcl  name_type fixed bin static options (constant) init (6);
  6    18 dcl  seg_type fixed bin static options (constant) init (7);
  6    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  6    20 
  6    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
       98 
       99 
      100 /* This entry adds a name to the directory hash table.  If the hash location is full, the new name is threaded onto
      101*   the front of the list for this hash index.  If the name is already in the list, nothing is done and a 0 code
      102*   is returned.
      103**/
      104 
      105 in:	entry (dp, arg_name_entry_ptr, code);
      106 
      107 	if dir.rehashing then signal bad_dir_;
      108 
      109 	if dir.htused >= dir.htsize then do;
      110 	     call get_larger_hash_table;
      111 	     if code ^= 0 then return;
      112 	end;
      113 	call add_name (arg_name_entry_ptr);
      114 
      115 	return;
      116 
      117 /* This entry removes a name from the directory hash table.
      118**/
      119 out:	entry (dp, arg_name_ptr, arg_name_entry_ptr, code);
      120 
      121 	if dir.rehashing then signal bad_dir_;
      122 
      123 	name_ptr = arg_name_ptr;
      124 	call hash_entry;
      125 
      126 	if found then do;
      127 	     arg_name_entry_ptr = p;
      128 	     if prev_offset
      129 	     then ptr (dp, prev_offset) -> names.hash_thread = p -> names.hash_thread;
      130 	     else hash_table.name_rp (cur_index) = p -> names.hash_thread;
      131 	     dir.htused = dir.htused - 1;
      132 	end;
      133 	else if code = 0 then code = error_table_$noentry;
      134 
      135 	return;
      136 
      137 /* This entry is given a pointer to the name of an entry and returns a pointer to that entry.
      138**/
      139 search:	entry (dp, arg_name_ptr, arg_entry_ptr, code);
      140 
      141 	if dir.rehashing then signal bad_dir_;
      142 
      143 	name_ptr = arg_name_ptr;
      144 	call hash_entry;
      145 
      146 	if found then arg_entry_ptr = ptr (dp, p -> names.entry_rp);
      147 	else do;
      148 	     if code = 0 then code = error_table_$noentry;
      149 	     arg_entry_ptr = null;
      150 	end;
      151 
      152 	return;
      153 
      154 /* The hash table values are relative pointers to name entries.  If more than one entry hashes to the same location,
      155*   the entries are chained together using the names.hash_thread location. A value of "0"b indicates an empty
      156*   hash table location or an end of a hash chain.
      157**/
      158 
      159 hash_entry: proc;
      160 
      161 dcl  xp ptr;
      162 
      163 	     found = "0"b;
      164 	     code = 0;
      165 
      166 	     htp = ptr (dp, dir.hash_table_rp);
      167 	     cur_index = hash_index_ (name_ptr, 32, 0, (dir.htsize));
      168 	     prev_offset = "0"b;
      169 
      170 	     names_seen = 0;
      171 	     do cur_offset = hash_table.name_rp (cur_index)
      172 		     repeat p -> names.hash_thread
      173 		     while (cur_offset);
      174 		names_seen = names_seen + 1;
      175 		if names_seen > dir.htused then signal bad_dir_;
      176 
      177 		p = ptr (dp, cur_offset);
      178 		if p -> names.type ^= NAME_TYPE then signal bad_dir_;
      179 		xp = ptr (dp, p -> names.entry_rp);
      180 		if p -> names.owner ^= xp -> entry.uid then signal bad_dir_;
      181 		if name = p -> names.name then do;
      182 		     if cur_index = p -> names.ht_index then found = "1"b;
      183 		     else signal bad_dir_;
      184 		     return;
      185 		end;
      186 		prev_offset = cur_offset;
      187 	     end;
      188 
      189 	     return;
      190 
      191 	end hash_entry;
      192 
      193 /*  */
      194 /* This procedure adds one name to the hash table.  It is not considered an error if the name is already in the table.
      195*   The new name entry is put at the head of the chain of names that hash to the current slot.
      196**/
      197 add_name:	proc (nep);
      198 
      199 dcl  nep ptr;					/* pointer to names structure */
      200 
      201 	     name_ptr = addr (nep -> names.name);
      202 	     call check_name;
      203 	     if code ^= 0 then return;
      204 	     call hash_entry;
      205 	     if code = 0 & ^found then do;
      206 		nep -> names.hash_thread = hash_table.name_rp (cur_index);
      207 		hash_table.name_rp (cur_index) = rel (nep);
      208 
      209 		nep -> names.ht_index = cur_index;
      210 		dir.htused = dir.htused + 1;
      211 	     end;
      212 
      213 	     return;
      214 
      215 	end add_name;
      216 
      217 
      218 
      219 /* Entry name to be hashed may consist of any ascii character except ">" and must have at least one non-blank character */
      220 
      221 check_name: proc;
      222 
      223 dcl 1 check_for_ascii aligned static options (constant),	/* Overlay for entry name to check if name consists */
      224     2 part1 bit (9 * 16) init ((16)"110000000"b),		/* of ascii characters */
      225     2 part2 bit (9 * 16) init ((16)"110000000"b);		/* String must be so declared due to limits of compiler */
      226 
      227 	     code = 0;
      228 	     if (unspec (name) & unspec (check_for_ascii)) = "0"b
      229 	     then if name ^= ""
      230 		then if index (name, ">") = 0 then return;
      231 
      232 	     code = error_table_$argerr;
      233 
      234 	     return;
      235 
      236 	end check_name;
      237 
      238 
      239 /* This procedure allocates a new hash table with the next size.  It follows the entry chain and rehashes
      240*   all names.  If any errors occur, the on line salvager is called.
      241**/
      242 get_larger_hash_table: proc;
      243 
      244 dcl (nentries, nnames, nentries_expected) fixed bin;
      245 dcl  nep ptr;					/* ptr to names structure */
      246 dcl  save_htp ptr;					/* ptr to old hash table block */
      247 
      248 /*  */
      249 /* Find next hash table and allocate the new hash table.  If the new one can't be allocated, use old one. */
      250 
      251 	     code = 0;
      252 	     if dir.htsize >= active_hardcore_data$hash_table_sizes (active_hardcore_data$num_hash_table_sizes) then return;
      253 
      254 	     save_htp = ptr (dp, dir.hash_table_rp);
      255 	     call allocate_dir_ht_ (dp, dir.htused+1, code);
      256 	     if code ^= 0 then do;
      257 		code = 0;
      258 		return;
      259 	     end;
      260 	     dir.rehashing = "1"b;			/* set inconsistent bit in case of crash while rehashing */
      261 	     call fs_alloc$free (ptr (dp, dir.arearp), (save_htp -> hash_table.size), save_htp);
      262 	     htp = ptr (dp, dir.hash_table_rp);
      263 
      264 /* Follow the entry chain and rehash all names on each entry */
      265 
      266 	     dir.htused = 0;
      267 	     nentries = 0;
      268 	     nentries_expected = dir.seg_count + dir.dir_count + dir.lcount;
      269 	     do ep = ptr (dp, dir.entryfrp)
      270 		     repeat ptr (dp, ep -> entry.efrp)
      271 		     while (rel (ep));
      272 
      273 		nentries = nentries + 1;
      274 		if nentries > nentries_expected
      275 		then signal bad_dir_;
      276 		if entry.bs then
      277 		     if entry.owner ^= dir.uid
      278 		     | (entry.type ^= SEG_TYPE & entry.type ^= DIR_TYPE) then signal bad_dir_;
      279 		     else;
      280 		else if link.type ^= LINK_TYPE | link.owner ^= dir.uid then signal bad_dir_;
      281 		nnames = 0;
      282 		do nep = ptr (dp, entry.name_frp) repeat ptr (dp, nep -> names.fp) while (rel (nep));
      283 		     nnames = nnames + 1;
      284 		     if nnames > entry.nnames
      285 		     | nep -> names.type ^= NAME_TYPE
      286 		     | nep -> names.owner ^= entry.uid
      287 		     | nep -> names.entry_rp ^= rel (ep)
      288 		     then signal bad_dir_;
      289 		     call add_name (nep);
      290 		     if code ^= 0 then signal bad_dir_;
      291 		end;
      292 	     end;
      293 	     dir.rehashing = "0"b;
      294 
      295 	     return;
      296 	end get_larger_hash_table;
      297 
      298      end hash;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.4  hash.pl1                          >special_ldd>install>MR12.3-1114>hash.pl1
92           1    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
93           2    11/02/76  1414.6  dir_ht.incl.pl1                   >ldd>include>dir_ht.incl.pl1
95           3    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
96           4    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
97           5    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
98           6    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 6-6 ref 276
LINK_TYPE                              constant        bit(18)                  initial packed unaligned dcl 6-7 ref 280
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 6-8 ref 178 284
SEG_TYPE                               constant        bit(18)                  initial packed unaligned dcl 6-9 ref 276
active_hardcore_data$hash_table_sizes
                                000016 external static fixed bin(17,0)          array dcl 84 ref 252
active_hardcore_data$num_hash_table_sizes
                                000014 external static fixed bin(17,0)          dcl 83 ref 252
addr                                                   builtin function         dcl 88 ref 201
allocate_dir_ht_                000022 constant        entry                    external dcl 86 ref 255
arearp                   24            based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 261 261
arg_entry_ptr                          parameter       pointer                  dcl 65 set ref 139 146* 149*
arg_name_entry_ptr                     parameter       pointer                  dcl 64 set ref 105 113* 119 127*
arg_name_ptr                           parameter       pointer                  dcl 63 ref 119 123 139 143
bad_dir_                        000112 stack reference condition                dcl 89 ref 107 121 141 175 178 180 183 274 276 280
                                                                                  284 290
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 3-8 ref 276
check_for_ascii                 000000 constant        structure                level 1 dcl 223 ref 228
code                                   parameter       fixed bin(35,0)          dcl 66 set ref 105 111 119 133 133* 139 148 148*
                                                                                  164* 203 205 227* 232* 251* 255* 256 257* 290
cur_index                       000104 automatic       fixed bin(17,0)          dcl 72 set ref 130 167* 171 182 206 207 209
cur_offset                      000105 automatic       bit(18)                  packed unaligned dcl 73 set ref 171* 171* 177 186*
dir                                    based           structure                level 1 dcl 1-11
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 ref 268
dp                                     parameter       pointer                  dcl 1-9 set ref 105 107 109 109 119 121 128 131 131
                                                                                  139 141 146 166 166 167 175 177 179 210 210 252
                                                                                  254 254 255* 255 260 261 261 261 261 262 262 266
                                                                                  268 268 268 269 269 276 280 282 291 292 293
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 3-8 ref 292
entry                                  based           structure                level 1 dcl 3-8
entry_rp                  2            based           bit(18)                  level 2 packed packed unaligned dcl 5-7 ref 146 179
                                                                                  284
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 269
ep                              000122 automatic       pointer                  dcl 3-6 set ref 269* 269* 276 276 276 276 280 280
                                                                                  282 284 284 284* 292
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 81 ref 232
error_table_$noentry            000012 external static fixed bin(35,0)          dcl 81 ref 133 148
found                           000107 automatic       bit(1)                   packed unaligned dcl 75 set ref 126 146 163* 182*
                                                                                  205
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 5-7 ref 291
fs_alloc$free                   000020 constant        entry                    external dcl 85 ref 261
hash_index_                     000024 constant        entry                    external dcl 87 ref 167
hash_table                             based           structure                level 1 dcl 2-6
hash_table_rp            55(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-11 ref 166 254
                                                                                  262
hash_thread               3            based           bit(18)                  level 2 packed packed unaligned dcl 5-7 set ref 128*
                                                                                  128 130 187 206*
ht_index                  2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-7 set ref 182
                                                                                  209*
htp                             000120 automatic       pointer                  dcl 2-4 set ref 130 166* 171 206 207 262*
htsize                   55            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 ref 109 167
                                                                                  252
htused                   56            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 set ref 109
                                                                                  131* 131 175 210* 210 255 266*
index                                                  builtin function         dcl 88 ref 228
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 ref 268
link                                   based           structure                level 1 dcl 4-6
name                      4            based           char(32)                 level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "hash" set ref 181 201
name                                   based           char(32)                 packed unaligned dcl 79 in procedure "hash" ref 181
                                                                                  228 228 228
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 3-8 ref 282
name_ptr                        000100 automatic       pointer                  dcl 70 set ref 123* 143* 167* 181 201* 228 228 228
name_rp                   2            based           bit(18)                  array level 2 packed packed unaligned dcl 2-6 set
                                                                                  ref 130* 171 206 207*
names                                  based           structure                level 1 dcl 5-7
names_seen                      000110 automatic       fixed bin(17,0)          dcl 76 set ref 170* 174* 174 175
nentries                        000170 automatic       fixed bin(17,0)          dcl 244 set ref 267* 273* 273 274
nentries_expected               000172 automatic       fixed bin(17,0)          dcl 244 set ref 268* 274
nep                                    parameter       pointer                  dcl 199 in procedure "add_name" ref 197 201 206 207
                                                                                  209
nep                             000174 automatic       pointer                  dcl 245 in procedure "get_larger_hash_table" set ref
                                                                                  282* 282* 284 284 284 289* 291
nnames                          000171 automatic       fixed bin(17,0)          dcl 244 in procedure "get_larger_hash_table" set ref
                                                                                  281* 283* 283 284
nnames                    4(18)        based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "hash" ref 284
null                                                   builtin function         dcl 88 ref 149
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "hash" ref 276
owner                                  based           bit(36)                  level 2 in structure "link" dcl 4-6 in procedure
                                                                                  "hash" ref 280
owner                    15            based           bit(36)                  level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "hash" ref 180 284
p                               000102 automatic       pointer                  dcl 71 set ref 127 128 130 146 177* 178 179 180 181
                                                                                  182 187
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-6 ref 280
prev_offset                     000106 automatic       bit(18)                  packed unaligned dcl 74 set ref 128 128 168* 186*
ptr                                                    builtin function         dcl 88 ref 128 146 166 177 179 254 261 261 262 269
                                                                                  282 291 292
rehashing                24(21)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref 107
                                                                                  121 141 260* 293*
rel                                                    builtin function         dcl 88 ref 207 269 282 284
save_htp                        000176 automatic       pointer                  dcl 246 set ref 254* 261 261*
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 1-11 ref 268
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-6 ref 261
type                      1            based           bit(18)                  level 2 in structure "names" packed packed unaligned
                                                                                  dcl 5-7 in procedure "hash" ref 178 284
type                      1            based           bit(18)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 4-6 in procedure "hash" ref 280
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "hash" ref 276 276
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "hash" ref 180 284
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 1-11 in procedure
                                                                                  "hash" ref 276 280
unspec                                                 builtin function         dcl 88 ref 228 228
xp                              000136 automatic       pointer                  dcl 161 set ref 179* 180

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 6-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 6-4
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 6-5
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 6-10
access_name_type                       internal static fixed bin(17,0)          initial dcl 6-12
acle_type                              internal static fixed bin(17,0)          initial dcl 6-13
dir_header_type                        internal static fixed bin(17,0)          initial dcl 6-14
dir_type                               internal static fixed bin(17,0)          initial dcl 6-15
error_table_$hashtbl_error             external static fixed bin(35,0)          dcl 81
hash_table_type                        internal static fixed bin(17,0)          initial dcl 6-19
link_type                              internal static fixed bin(17,0)          initial dcl 6-16
name_type                              internal static fixed bin(17,0)          initial dcl 6-17
np                                     automatic       pointer                  dcl 5-5
seg_type                               internal static fixed bin(17,0)          initial dcl 6-18
version_number_2                       internal static fixed bin(17,0)          initial dcl 1-84

NAMES DECLARED BY EXPLICIT CONTEXT.
add_name                        000427 constant        entry                    internal dcl 197 ref 113 289
check_name                      000477 constant        entry                    internal dcl 221 ref 202
get_larger_hash_table           000530 constant        entry                    internal dcl 242 ref 110
hash                            000021 constant        entry                    external dcl 13
hash_entry                      000255 constant        entry                    internal dcl 159 ref 124 144 204
in                              000033 constant        entry                    external dcl 105
out                             000107 constant        entry                    external dcl 119
search                          000203 constant        entry                    external dcl 139

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1204        1232    1050        1214
Length      1520    1050        26         252     133           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hash                                170 external procedure  is an external procedure.  
hash_entry                              internal procedure  shares stack frame of external procedure hash.  
add_name                                internal procedure  shares stack frame of external procedure hash.  
check_name                              internal procedure  shares stack frame of external procedure hash.  
get_larger_hash_table                   internal procedure  shares stack frame of external procedure hash.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hash                     000100 name_ptr                    hash
                         000102 p                           hash
                         000104 cur_index                   hash
                         000105 cur_offset                  hash
                         000106 prev_offset                 hash
                         000107 found                       hash
                         000110 names_seen                  hash
                         000120 htp                         hash
                         000122 ep                          hash
                         000136 xp                          hash_entry
                         000170 nentries                    get_larger_hash_table
                         000171 nnames                      get_larger_hash_table
                         000172 nentries_expected           get_larger_hash_table
                         000174 nep                         get_larger_hash_table
                         000176 save_htp                    get_larger_hash_table

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          signal_op           ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
allocate_dir_ht_              fs_alloc$free                 hash_index_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_hardcore_data$hash_table_sizes                       active_hardcore_data$num_hash_table_sizes
error_table_$argerr           error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000020       105 000026       107 000045       109 000056       110 000070       111 000071       113 000073
    115 000101       119 000102       121 000121       123 000132       124 000136       126 000137       127 000141
    128 000143       130 000154       131 000162       132 000172       133 000173       135 000200       139 000201
    141 000213       143 000224       144 000230       146 000231       148 000244       149 000251       152 000254
    159 000255       163 000256       164 000257       166 000260       167 000270       168 000315       170 000316
    171 000317       174 000330       175 000331       177 000343       178 000351       179 000360       180 000370
    181 000376       182 000404       183 000414       184 000417       186 000420       187 000422       189 000426
    197 000427       201 000431       202 000435       203 000436       204 000441       205 000442       206 000446
    207 000457       209 000464       210 000466       213 000476       221 000477       227 000500       228 000501
    232 000524       234 000527       242 000530       251 000531       252 000532       254 000545       255 000552
    256 000570       257 000572       258 000573       260 000574       261 000601       262 000625       266 000635
    267 000637       268 000640       269 000654       273 000662       274 000663       276 000671       279 000716
    280 000717       281 000742       282 000743       283 000756       284 000757       289 001006       290 001010
    291 001015       292 001025       293 001035       295 001042


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
