	COMPILATION LISTING OF SEGMENT tape_ioi_utils
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1006.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* Various internal interfaces of the tape_ioi_ software */
       10 /* Written May 1982 by Chris Jones */
       11 /* Modified 12/2/82 by Chris Jones to break out bad density from other MPC device attention errors. */
       12 /* Modified 12/17/82 by Chris Jones to put more things into the "SI" and "DN" categories. */
       13 /* Modified 1/5/83 by Chris Jones to look harder for valid status. */
       14 /* Modified 2/4/83 by Chris Jones to break out blank tape on read from EOT */
       15 /* Modified St. Valentine's day, 1983 by Chris Jones to look more carefully for status. */
       16 /* Modified 8 March 1983 by Chris Jones to fix bug in last_status_entry_offset. */
       17 
       18 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
       19 tape_ioi_utils:
       20      proc;
       21 
       22 /* Parameters */
       23 
       24 dcl	p_buffer_data_ptr	   ptr parameter;		/* (I) pointer to the data area of a buffer */
       25 dcl	p_status_ptr	   ptr parameter;		/* (I) pointer to a ioi status structure */
       26 dcl	p_tioi_id		   bit (36) aligned;	/* (I) tape_ioi_ activation ID */
       27 dcl	p_wksp		   ptr parameter;		/* (I/O) pointer to the tape_ioi_ workspace */
       28 
       29 /* Automatic variables */
       30 
       31 dcl	buffer_data_ptr	   ptr;
       32 dcl	buffer_idx	   fixed bin;
       33 dcl	buffer_ptr	   ptr;
       34 dcl	done		   bit (1) aligned;
       35 dcl	status_entry_idx	   fixed bin (9) unsigned;
       36 dcl	test_read		   fixed bin (35);
       37 
       38 /* Based variables */
       39 
       40 dcl	based_integer	   fixed bin (35) based;
       41 dcl	1 based_tioi_id	   aligned based,
       42 	  2 segno		   bit (18) unal,
       43 	  2 actid		   fixed bin (18) unsigned unal;
       44 
       45 /* Builtins and Conditions */
       46 
       47 dcl	(addr, addrel, baseptr, mod, null, ptr, size, unspec)
       48 			   builtin;
       49 
       50 dcl	any_other		   condition;
       51 
       52 /* Entry to return a pointer to the buffer header of a buffer given its data pointer */
       53 
       54 get_buffer_ptr:
       55      entry (p_wksp, p_buffer_data_ptr) returns (ptr);
       56 
       57 	wksp = p_wksp;
       58 	buffer_data_ptr = p_buffer_data_ptr;
       59 	if tai.buffer_count = 0 then
       60 	     return (null ());			/* can't be for real */
       61 	else do;
       62 	     buffer_ptr = ptr (wksp, tai.buffer_list_offset);
       63 	     do buffer_idx = 1 to tai.buffer_count while (ptr (wksp, buffer_ptr -> tbi.data_offset) ^= buffer_data_ptr);
       64 		buffer_ptr = ptr (wksp, buffer_ptr -> tbi.next_buf_offset);
       65 	     end;
       66 	     if ptr (wksp, buffer_ptr -> tbi.data_offset) = buffer_data_ptr then
       67 		return (buffer_ptr);
       68 	     else return (null ());
       69 	end;
       70 
       71 /* entry to return a pointer to the workspace given a tape_ioi_ activation ID */
       72 get_workspace_ptr:
       73      entry (p_tioi_id, p_wksp);
       74 
       75 	on any_other
       76 	     begin;
       77 		goto CANT_RETURN_PTR;
       78 	     end;
       79 
       80 	wksp = baseptr (addr (p_tioi_id) -> based_tioi_id.segno);
       81 	if p_tioi_id ^= unspec (tai.tioi_id) then
       82 	     goto CANT_RETURN_PTR;
       83 
       84 /* Make sure we can read the last word of the buffer, and write any word.  The any_other handler will trap errors. */
       85 
       86 	test_read = ptr (wksp, tai.workspace_len) -> based_integer;
       87 	p_wksp = wksp;
       88 	return;
       89 
       90 CANT_RETURN_PTR:
       91 	p_wksp = null ();
       92 	return;
       93 
       94 /* entry which tells whether or not I/O is in progress on the device */
       95 
       96 
       97 io_in_progress:
       98      entry (p_wksp) returns (bit (1) aligned);
       99 
      100 	wksp = p_wksp;
      101 	return (tai.read_queued | tai.write_queued | tai.order_queued);
      102 
      103 /* entry which returns a two character status class based on the given status */
      104 /* These status classes are described in MTB-383, Appendix D */
      105 
      106 get_status_class:
      107      entry (p_status_ptr) returns (char (2));
      108 
      109 	isp = p_status_ptr;
      110 	io_status_word_ptr = addr (istat.iom_stat);
      111 
      112 /* Now just brute force the status lookup. */
      113 /* This code works for type 500, 501, 601, 610, and 650 (DIPPER) tape controllers.  Much of the weird
      114*   masking is to maintain compatibility between the various controllers. */
      115 
      116 	if io_status_word.power then			/* power off */
      117 	     return ("UE");
      118 	else if istat.level = 1 then			/* system fault */
      119 	     return ("UE");
      120 	else if io_status_word.central_stat ^= "0"b3 then do;
      121 	     if io_status_word.central_stat = "7"b3 then	/* parity error, data from channel */
      122 		return ("DA");
      123 	     else return ("UE");
      124 	end;
      125 	else if io_status_word.channel_stat ^= "0"b3 then do;
      126 	     if io_status_word.channel_stat = "7"b3 then
      127 		return ("IP");			/* parity error, data to channel */
      128 	     else if io_status_word.channel_stat = "3"b3 then
      129 		return ("BL");			/* incorrect DCW on list service */
      130 	     else return ("UE");
      131 	end;
      132 	else if io_status_word.major = "0000"b then do;	/* peripheral subsystem ready */
      133 	     if (io_status_word.sub & "111010"b) = "000010"b then
      134 		return ("AB");			/* at beginning */
      135 	     else if (io_status_word.sub & "111011"b) = "001000"b then
      136 		return ("CA");			/* ASCII alert */
      137 	     else return ("OK");
      138 	end;
      139 	else if io_status_word.major = "0001"b then do;	/* device busy */
      140 	     if (io_status_word.sub & "000101"b) ^= "000000"b then
      141 						/* rewinding or loading */
      142 		return ("SI");			/* wait for special interrupt */
      143 	     else return ("UE");			/* unrecoverable error */
      144 	end;
      145 	else if io_status_word.major = "0010"b then	/* device attention */
      146 	     return ("UE");
      147 	else if io_status_word.major = "0011"b then do;	/* device data alert */
      148 	     if io_status_word.sub = "000010"b then	/* blank tape on read */
      149 		return ("BT");			/* blank tape */
      150 	     else if io_status_word.sub = "100000"b then	/* EOT */
      151 		return ("ET");			/* end of tape */
      152 	     else if (io_status_word.sub & "100000"b) = "100000"b then
      153 						/* if EOT is set */
      154 		return ("DE");			/* data alert, at end */
      155 	     else return ("DA");			/* data alert */
      156 	end;
      157 	else if io_status_word.major = "0100"b then	/* EOF */
      158 	     return ("EF");
      159 	else if io_status_word.major = "0101"b then do;	/* command reject */
      160 	     if io_status_word.sub = "001000"b then	/* at BOT */
      161 		return ("AB");
      162 	     else if io_status_word.sub = "000000"b then	/* invalid density */
      163 		return ("DN");
      164 	     else return ("UE");
      165 	end;
      166 	else if io_status_word.major = "1010"b then do;	/* MPC device attention */
      167 	     if io_status_word.sub = "010000"b | (io_status_word.sub & "111100"b) = "001100"b then
      168 		return ("DA");
      169 	     else if io_status_word.sub = "001000"b then	/* incompatible mode */
      170 		return ("DN");
      171 	     else return ("UE");
      172 	end;
      173 	else if io_status_word.major = "1011"b then do;	/* MPC device data alert */
      174 	     if io_status_word.sub = "001000"b |	/* ID burst write error */
      175 		io_status_word.sub = "010011"b |	/* NRZI CCC error */
      176 		io_status_word.sub = "001001"b |	/* preamble error */
      177 		io_status_word.sub = "010010"b |	/* postamble error */
      178 		io_status_word.sub = "010000"b |	/* multi-track error */
      179 		io_status_word.sub = "100000"b then	/* marginal condition */
      180 		return ("DA");
      181 	     else if io_status_word.sub = "010100"b then	/* code alert */
      182 		return ("CA");
      183 	     else return ("UE");
      184 	end;
      185 	else if io_status_word.major = "1101"b then do;	/* MPC command reject */
      186 	     if io_status_word.sub = "000011"b then	/* Illegal suspended L.C. number */
      187 		return ("SI");
      188 	     else return ("UE");
      189 	end;
      190 	else return ("UE");				/* should never happen, but... */
      191 
      192 /* entry to return a pointer to the next status entry if it is valid */
      193 
      194 get_status:
      195      entry (p_wksp) returns (ptr);
      196 
      197 	wksp = p_wksp;
      198 	status_entry_idx = tai.status_entry_idx;	/* save where we started */
      199 	done = "0"b;
      200 	do while (^done);				/* until we've had enough */
      201 	     isp = ptr (wksp, tai.status_queue_offset + tai.status_entry_idx * size (istat));
      202 						/* point to next status entry */
      203 	     if istat.completion.st then do;		/* found one, get set to look again */
      204 		if istat.level = IO_SPECIAL_INTERRUPT_LEVEL then
      205 		     istat.completion.st = "0"b;	/* should never happen... */
      206 		else done = "1"b;
      207 	     end;
      208 	     if ^done then
      209 		tai.status_entry_idx = mod (tai.status_entry_idx + 1, tai.status_entry_count);
      210 	     if ^done & tai.status_entry_idx = status_entry_idx then
      211 		return (null ());			/* we've checked them all */
      212 	end;
      213 
      214 /* Since a status may have landed behind us after we had already checked, scan forward again to find the first */
      215 
      216 	tai.status_entry_idx = status_entry_idx;
      217 	do isp = ptr (wksp, tai.status_queue_offset + size (istat) * tai.status_entry_idx)
      218 	     repeat ptr (wksp, tai.status_queue_offset + size (istat) * tai.status_entry_idx)
      219 	     while (^istat.completion.st);
      220 	     tai.status_entry_idx = mod (tai.status_entry_idx + 1, tai.status_entry_count);
      221 	end;
      222 	tai.status_entry_idx = mod (tai.status_entry_idx + 1, tai.status_entry_count);
      223 	istat.completion.st = "0"b;			/* so we don't hit this again */
      224 	return (isp);
      225 
      226 /* Entry to return the offset of the last status entry. */
      227 
      228 last_status_entry_offset:
      229      entry (p_wksp) returns (fixed bin (18) unsigned);
      230 
      231 	wksp = p_wksp;
      232 	return (tai.status_queue_offset + size (istat) * mod (tai.status_entry_idx - 1, tai.status_entry_count));
      233 
  1     1 /*  START OF:	tape_ioi_workspace.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(87-07-06,Hartogs), approve(87-07-06,MCR7726),
  1     7*     audit(87-08-27,GWMay), install(87-08-27,MR12.1-1094):
  1     8*     A) Added variable at_bot to structure tai.
  1     9*     B) Added density_command to tai structure for use by error_retry.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 /*
  1    14*   *	     This include file describes the workspace maintained by tape_ioi_.
  1    15*   *	No programs other than tape_ioi_ programs should need to use this include file.
  1    16*   *
  1    17*   *	This workspace is the ioi_ workspace.
  1    18**/
  1    19 /* Written 8/78 by R.J.C. Kissel. */
  1    20 /* Modified April-May 1982 by Chris Jones for installation. */
  1    21 /* Modified 2/4/83 by Chris Jones to add last_terminate_time */
  1    22 
  1    23 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  1    24 
  1    25 dcl	wksp		   ptr;
  1    26 
  1    27 dcl	1 tai		   based (wksp) aligned,	/* Activation info and order buffer. */
  1    28 	  2 ioi_index	   fixed bin,		/* For communication with ioi. */
  1    29 	  2 tioi_id	   unal,			/* 36 bit activation identifier. */
  1    30 	    3 segno	   bit (18),		/* Segment number of the workspace. */
  1    31 	    3 actid	   fixed bin (18) unsigned,	/* Per process, per activation number. */
  1    32 	  2 event_id	   fixed bin (71),		/* All ipc done on this channel. */
  1    33 	  2 max_timeout	   fixed bin (71),		/* maximum timeout value */
  1    34 	  2 cur_timeout	   fixed bin (71),		/* current timeout value */
  1    35 	  2 last_terminate_time
  1    36 			   fixed bin (71),		/* when the last terminate interrupt was received */
  1    37 	  (
  1    38 	  2 workspace_max	   fixed bin (18) unsigned,	/* max_len-1 to fit in 18 bits. */
  1    39 	  2 workspace_len	   fixed bin (18) unsigned,	/* len-1 to fit in 18 bits. */
  1    40 	  2 buffer_list_offset fixed bin (18) unsigned,	/* to list of all buffers */
  1    41 	  2 free_list_offset   fixed bin (18) unsigned,	/* to list of free buffers */
  1    42 	  2 queue_list_offset  fixed bin (18) unsigned,	/* to list of buffers which are queued */
  1    43 	  2 susp_list_offset   fixed bin (18) unsigned,	/* to list of suspended buffers */
  1    44 	  2 retry_count	   fixed bin (9) unsigned,	/* number of times we've retried this operation */
  1    45 	  2 buffer_count	   fixed bin (9) unsigned,	/* Number of I/O buffers allocated. */
  1    46 	  2 status_entry_count fixed bin (9) unsigned,	/* Number of status queue entries. */
  1    47 	  2 status_entry_idx   fixed bin (9) unsigned,	/* index of next status entry to be used */
  1    48 	  2 status_queue_offset
  1    49 			   fixed bin (18) unsigned,	/* Status queue offset. */
  1    50 	  2 pad1               bit (12),
  1    51 	  2 density_command    bit (6),                   /* density of data on storage */
  1    52 	  2 workarea_len	   fixed bin (18) unsigned,	/* len-1 to fit in 18 bits. */
  1    53 	  2 workarea_offset	   fixed bin (18) unsigned	/* Workarea offset. */
  1    54 	  )		   unal,
  1    55 	  2 modes		   unal,			/* tape_ioi_ modes settings. */
  1    56 	    3 data_code	   bit (6),		/* Encoded representation of data mode. */
  1    57 	    3 cif_code	   bit (6),		/* CIF field for channel instructions. */
  1    58 	    3 align	   bit (1),		/* "0"b--left aligned, "1"b--right aligned. */
  1    59 	    3 length	   bit (1),		/* "0"b--normal, "1"b--special. */
  1    60 	    3 recovery	   bit (1),		/* "0"b--no error recovery, "1"b--error recovery. */
  1    61 	    3 wait	   bit (1),		/* "0"b--simplex, "1"b--multiplex. */
  1    62 	    3 req_len	   bit (1),		/* "0"b--don't need to know record length, "1"b--do need it */
  1    63 	  2 flags		   unal,			/* Used internally by tape_ioi_. */
  1    64 	    3 order_queued	   bit (1),		/* "0"b--no order queued, "1"b--order queued. */
  1    65 	    3 read_queued	   bit (1),		/* "0"b--no read queued, "1"b--read queued. */
  1    66 	    3 write_queued	   bit (1),		/* "0"b--no write queued, "1"b--write queued. */
  1    67 	    3 order_done	   bit (1),		/* "1"b--the queue_order entry finished the order */
  1    68 	    3 workarea_last	   bit (1),		/* "1"b--user workarea at end of workspace */
  1    69 	    3 special_status_expected
  1    70 			   bit (1),		/* set if we're waiting for a special interrupt */
  1    71 	    3 retry_in_progress
  1    72 			   bit (1),
  1    73 	    3 suspect_short_record bit (1),		/* "1"b--got invalid DCW on list service last */
  1    74 	    3 at_bot	   bit (1),		/* "1"b-- tape is positioned to BOT. */
  1    75 	  2 pad2		   bit (1) unal,
  1    76 	  2 order_idx	   fixed bin (9) unsigned unaligned,
  1    77 						/* encoding of last order queued */
  1    78 	  2 counts	   aligned,		/* error and operation counts */
  1    79 	    3 total_reads	   fixed bin (35),
  1    80 	    3 read_errors	   fixed bin (35),
  1    81 	    3 total_writes	   fixed bin (35),
  1    82 	    3 write_errors	   fixed bin (35),
  1    83 	    3 total_orders	   fixed bin (35),
  1    84 	    3 order_errors	   fixed bin (35),
  1    85 	    3 times_status_lost
  1    86 			   fixed bin (35),
  1    87 	    3 extra_statuses   fixed bin (35),
  1    88 	    3 times_tape_stopped
  1    89 			   fixed bin (35),
  1    90 	    3 recovery_succeeded
  1    91 			   (7) fixed bin (35),	/* meters which kind of recovery worked */
  1    92 	  2 order_count_requested
  1    93 			   fixed bin (18) unsigned unaligned,
  1    94 	  2 order_count_done   fixed bin (18) unsigned unaligned,
  1    95 	  2 saved_special_status
  1    96 			   bit (36),
  1    97 	  2 order_data_ptr	   ptr,
  1    98 	  2 order_idcw	   bit (36) aligned,
  1    99 	  2 order_dcw	   bit (36) aligned,
  1   100 	  2 order_data	   (1:8) bit (36) aligned;
  1   101 /**** The buffers go here, followed by the status queue entries.  There are min (1, tai.nbufs) status queue entries. */
  1   102 /**** It is considered a good idea to have the length of the previous structure b an even number of words long.  This
  1   103*      is accomplished by the aligned pointer "order_data_ptr" being followed by an even number of words. */
  1   104 
  1   105 /* Tape buffer overlay.  Each tape buffer consists of a variable length header followed by the data area.
  1   106*   Whenever a buffer pointer is returned to a caller of tape_ioi_, it points to the data area. */
  1   107 
  1   108 dcl	1 tbi		   based aligned,		/* I/O buffer overlay. */
  1   109 	( 2 data_offset	   fixed bin (18) unsigned,	/* to the data portion of the buffer */
  1   110 	  2 next_buf_offset	   fixed bin (18) unsigned,	/* to the next buffer in list of all buffers */
  1   111 	  2 next_state_offset  fixed bin (18) unsigned,	/* to the next buffer in the same state */
  1   112 	  2 state		   fixed bin (9) unsigned,	/* buffer state */
  1   113 	  2 ndcws		   fixed bin (9) unsigned	/* number of DCWs necessary to fill buffer */
  1   114 	  )		   unal,
  1   115 	  2 modes		   unal like tai.modes,	/* mode settings when buffer was queued */
  1   116 	  2 reserved	   bit (1) unal,		/* "1"b=>won't be used for reads unless explicitly asked */
  1   117 	  2 buffer_len	   fixed bin (21),		/* length of buffer in 9-bit bytes */
  1   118 	  2 data_len	   fixed bin (21),		/* length of data in buffer in 9-bit bytes */
  1   119 	  2 bit_len	   fixed bin (24),		/* length of data in buffer in bits */
  1   120 	  2 idcw_word	   bit (36),		/* holds IDCW */
  1   121 	  2 dcw_words	   (1 refer (tbi.ndcws)) bit (36),
  1   122 						/* data DCWs */
  1   123 	  2 tdcw_word	   bit (36);		/* transfer to the next buffer */
  1   124 						/* This header is followed by the actual buffer area. */
  1   125 
  1   126 /*
  1   127*   *	N__o_t_e_s
  1   128*   *
  1   129*   *	     Both structures are carefully packed into words, so care should be
  1   130*   *	taken when modifying them.
  1   131*   *
  1   132*   *	     The workspace_max, workspace_len, and workarea_len must be at least one long.
  1   133*   *	This allows us to store the value-1 and thus fit into 18 bits.
  1   134*   *
  1   135*   *	     None of the offsets (first_buf_off, statq_off, etc.) can be zero since the first
  1   136*   *	word in the workspace contains the ioi_index.  This allows a zero offset
  1   137*   *	to be used as a null offset indication.
  1   138*   *
  1   139*   *	     The data_code, cif_code, and tbi.state are encoded as follows:
  1   140*   *
  1   141*   *	data mode |                                                     buffer |
  1   142*   *	setting   | data_code     cif_code |    Meaning		    state  | Meaning
  1   143*   *	__________|__________     _________|_______________________     _______|________
  1   144*   *	  bin     |   05            20     | no retry, high                1   | ready
  1   145*   *	  bcd     |   04            21     | no retry, low                 2   | busy
  1   146*   *	  tap9    |   03            22     | no retry, high, deskew        3   | suspended
  1   147*   *	  asc     |   27            23     | no retry, low, deskew
  1   148*   *	  ebc     |   24            30     | retry, high
  1   149*   *	  a/e     |   25            31     | retry, low
  1   150*   *			        32     | retry, high, deskew
  1   151*   *			        33     | retry, low, deskew
  1   152*   *
  1   153*   *
  1   154*   *	     Before data_code can be used for the command field in the IDCW the fourth
  1   155*   *	bit (from the right) must be set to "0"b for read commands and to "1"b for write commands.
  1   156*   *
  1   157*   *	     The general layout of the workspace maintained by tape_ioi_ is as follows:
  1   158*   *
  1   159*   *			_________________________
  1   160*   *			|                       |
  1   161*   *			|  General Information  |
  1   162*   *			|       (see tai)       |
  1   163*   *			|_______________________|
  1   164*   *			|______O____r__d__e__r_I_D_C_W________|
  1   165*   *			|______O____r__d__e__r_D_C_W_________|
  1   166*   *			|                       |
  1   167*   *			|   Order data buffer   |
  1   168*   *			|       (8 words)       |
  1   169*   *			|_______________________|
  1   170*   *			|                       |
  1   171*   *			|   Optional workarea   |
  1   172*   *			|      (unlimited)      |
  1   173*   *			|_______________________|
  1   174*   *			|________I__O___I_D_C_W_________|
  1   175*   *			|                       |
  1   176*   *			|      IO DCW list      |
  1   177*   *			|_______________________|
  1   178*   *			|________I__O___T_D_C_W_________|
  1   179*   *			|                       |
  1   180*   *			|       IO buffer       |
  1   181*   *			|   (user specified)    |
  1   182*   *			|_______________________|
  1   183*   *			            .
  1   184*   *			            .
  1   185*   *			            .
  1   186*   *			_________________________
  1   187*   *			|________I__O___I_D_C_W_________|
  1   188*   *			|                       |
  1   189*   *			|      IO DCW list      |
  1   190*   *			|_______________________|
  1   191*   *			|__________z_e_r_o_s_________|
  1   192*   *			|                       |
  1   193*   *			|       IO buffer       |
  1   194*   *			|    (user specified)   |
  1   195*   *			|_______________________|
  1   196*   *			|                       |
  1   197*   *			|     Status queue      |
  1   198*   *			| (at least one entry)  |
  1   199*   *			|_______________________|
  1   200*   *			|                       |
  1   201*   *			|   Optional workarea   |
  1   202*   *			|       (limited)       |
  1   203*   *			|_______________________|
  1   204**/
  1   205 
  1   206 /*  END OF:	tape_ioi_workspace.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      234 
      235 
  2     1 
  2     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  2     3 /* Last modified 3/24/75 by Noel I. Morris */
  2     4 
  2     5 dcl  isp ptr;					/* pointer to status structure */
  2     6 
  2     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  2     8     2 completion,					/* completion flags */
  2     9      (3 st bit (1),					/* "1"b if status returned */
  2    10       3 er bit (1),					/* "1"b if status indicates error condition */
  2    11       3 run bit (1),				/* "1"b if channel still running */
  2    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  2    13     2 level fixed bin (3),				/* IOM interrupt level */
  2    14     2 offset fixed bin (18),				/* DCW list offset */
  2    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  2    16     2 iom_stat bit (72),				/* IOM status */
  2    17     2 lpw bit (72);					/* LPW residue */
  2    18 
  2    19 dcl  imp ptr;					/* pointer to message structure */
  2    20 
  2    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  2    22    (2 completion like istat.completion,			/* completion flags */
  2    23     2 pad bit (11),
  2    24     2 level bit (3),				/* interrupt level */
  2    25     2 offset bit (18),				/* DCW list offset */
  2    26     2 status bit (36)) unal;				/* first 36 bits of status */
  2    27 
  2    28 /* End of include file ...... ioi_stat.incl.pl1 */
  2    29 
      236 
      237 
  3     1 /* Begin include file io_status_word.incl.pl1 */
  3     2 /* Made from iom_stat.incl.pl1 by C. Hornig */
  3     3 
  3     4 dcl  io_status_word_ptr ptr;
  3     5 dcl  1 io_status_word based (io_status_word_ptr) aligned,	/* I/O status information */
  3     6        (
  3     7        2 t bit (1),					/* set to "1"b by IOM */
  3     8        2 power bit (1),				/* non-zero if peripheral absent or power off */
  3     9        2 major bit (4),				/* major status */
  3    10        2 sub bit (6),				/* substatus */
  3    11        2 eo bit (1),				/* even/odd bit */
  3    12        2 marker bit (1),				/* non-zero if marker status */
  3    13        2 soft bit (2),				/* software status */
  3    14        2 initiate bit (1),				/* initiate bit */
  3    15        2 abort bit (1),				/* software abort bit */
  3    16        2 channel_stat bit (3),			/* IOM channel status */
  3    17        2 central_stat bit (3),			/* IOM central status */
  3    18        2 mbz bit (6),
  3    19        2 rcount bit (6)
  3    20        ) unaligned;					/* record count residue */
  3    21 
  3    22 /* End include file io_status_word.incl.pl1 */
      238 
      239 
  4     1 /*  START OF:	interrupt_levels.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /* Written 14 June 1982 by Chris Jones */
  4     4 
  4     5 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  4     6 dcl	IO_SYSTEM_FAULT_INTERRUPT_LEVEL
  4     7 			   fixed bin internal static options (constant) init (1);
  4     8 dcl	IO_TERMINATE_INTERRUPT_LEVEL
  4     9 			   fixed bin internal static options (constant) init (3);
  4    10 dcl	IO_MARKER_INTERRUPT_LEVEL
  4    11 			   fixed bin internal static options (constant) init (5);
  4    12 dcl	IO_SPECIAL_INTERRUPT_LEVEL
  4    13 			   fixed bin internal static options (constant) init (7);
  4    14 
  4    15 /*  END OF:	interrupt_levels.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      240 
      241 
      242      end tape_ioi_utils;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0812.0  tape_ioi_utils.pl1                >spec>install>1112>tape_ioi_utils.pl1
234          1    08/27/87  1445.9  tape_ioi_workspace.incl.pl1       >ldd>include>tape_ioi_workspace.incl.pl1
236          2    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
238          3    03/27/82  0430.3  io_status_word.incl.pl1           >ldd>include>io_status_word.incl.pl1
240          4    12/01/82  1039.8  interrupt_levels.incl.pl1         >ldd>include>interrupt_levels.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
IO_SPECIAL_INTERRUPT_LEVEL             constant        fixed bin(17,0)          initial dcl 4-12 ref 204
addr                                                   builtin function         dcl 47 ref 80 110
any_other                       000112 stack reference condition                dcl 50 ref 75
based_integer                          based           fixed bin(35,0)          dcl 40 ref 86
based_tioi_id                          based           structure                level 1 dcl 41
baseptr                                                builtin function         dcl 47 ref 80
buffer_count             15(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 1-27
                                                                                  ref 59 63
buffer_data_ptr                 000100 automatic       pointer                  dcl 31 set ref 58* 63 66
buffer_idx                      000102 automatic       fixed bin(17,0)          dcl 32 set ref 63*
buffer_list_offset       13            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-27
                                                                                  ref 62
buffer_ptr                      000104 automatic       pointer                  dcl 33 set ref 62* 63 64* 64 66 66
central_stat              0(21)        based           bit(3)                   level 2 packed packed unaligned dcl 3-5 ref 120 121
channel_stat              0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 3-5 ref 125 126
                                                                                  128
completion                             based           structure                level 2 dcl 2-7
data_offset                            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-108
                                                                                  ref 63 66
done                            000106 automatic       bit(1)                   dcl 34 set ref 199* 200 206* 208 210
flags                    20(17)        based           structure                level 2 packed packed unaligned dcl 1-27
io_status_word                         based           structure                level 1 dcl 3-5
io_status_word_ptr              000124 automatic       pointer                  dcl 3-4 set ref 110* 116 120 121 125 126 128 132 133
                                                                                  135 139 140 145 147 148 150 152 157 159 160 162
                                                                                  166 167 167 169 173 174 174 174 174 174 174 181
                                                                                  185 186
iom_stat                  4            based           bit(72)                  level 2 dcl 2-7 set ref 110
isp                             000122 automatic       pointer                  dcl 2-5 set ref 109* 110 118 201* 201 203 204 204
                                                                                  217* 217 217* 221 223 224 232
istat                                  based           structure                level 1 dcl 2-7 set ref 201 217 221 232
level                     1            based           fixed bin(3,0)           level 2 dcl 2-7 ref 118 204
major                     0(02)        based           bit(4)                   level 2 packed packed unaligned dcl 3-5 ref 132 139
                                                                                  145 147 157 159 166 173 185
mod                                                    builtin function         dcl 47 ref 208 220 222 232
modes                    20            based           structure                level 2 packed packed unaligned dcl 1-27
next_buf_offset           0(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-108
                                                                                  ref 64
null                                                   builtin function         dcl 47 ref 59 68 90 210
order_queued             20(17)        based           bit(1)                   level 3 packed packed unaligned dcl 1-27 ref 101
p_buffer_data_ptr                      parameter       pointer                  dcl 24 ref 54 58
p_status_ptr                           parameter       pointer                  dcl 25 ref 106 109
p_tioi_id                              parameter       bit(36)                  dcl 26 set ref 72 80 81
p_wksp                                 parameter       pointer                  dcl 27 set ref 54 57 72 87* 90* 97 100 194 197 228
                                                                                  231
power                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3-5 ref 116
ptr                                                    builtin function         dcl 47 ref 62 63 64 66 86 201 217 221
read_queued              20(18)        based           bit(1)                   level 3 packed packed unaligned dcl 1-27 ref 101
segno                                  based           bit(18)                  level 2 packed packed unaligned dcl 41 ref 80
size                                                   builtin function         dcl 47 ref 201 217 221 232
st                                     based           bit(1)                   level 3 packed packed unaligned dcl 2-7 set ref 203
                                                                                  204* 217 223*
status_entry_count       15(18)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 1-27
                                                                                  ref 208 220 222 232
status_entry_idx         15(27)        based           fixed bin(9,0)           level 2 in structure "tai" packed packed unsigned
                                                                                  unaligned dcl 1-27 in procedure "tape_ioi_utils"
                                                                                  set ref 198 201 208* 208 210 216* 217 220* 220 221
                                                                                  222* 222 232
status_entry_idx                000107 automatic       fixed bin(9,0)           unsigned dcl 35 in procedure "tape_ioi_utils" set
                                                                                  ref 198* 210 216
status_queue_offset      16            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-27
                                                                                  ref 201 217 221 232
sub                       0(06)        based           bit(6)                   level 2 packed packed unaligned dcl 3-5 ref 133 135
                                                                                  140 148 150 152 160 162 167 167 169 174 174 174
                                                                                  174 174 174 181 186
tai                                    based           structure                level 1 dcl 1-27
tbi                                    based           structure                level 1 dcl 1-108
test_read                       000110 automatic       fixed bin(35,0)          dcl 36 set ref 86*
tioi_id                   1            based           structure                level 2 packed packed unaligned dcl 1-27 ref 81
unspec                                                 builtin function         dcl 47 ref 81
wksp                            000120 automatic       pointer                  dcl 1-25 set ref 57* 59 62 62 63 63 64 66 80* 81 86
                                                                                  86 87 100* 101 101 101 197* 198 201 201 201 208
                                                                                  208 208 210 216 217 217 217 220 220 220 221 221
                                                                                  221 222 222 222 231* 232 232 232
workspace_len            12(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 1-27
                                                                                  ref 86
write_queued             20(19)        based           bit(1)                   level 3 packed packed unaligned dcl 1-27 ref 101

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IO_MARKER_INTERRUPT_LEVEL              internal static fixed bin(17,0)          initial dcl 4-10
IO_SYSTEM_FAULT_INTERRUPT_LEVEL        internal static fixed bin(17,0)          initial dcl 4-6
IO_TERMINATE_INTERRUPT_LEVEL           internal static fixed bin(17,0)          initial dcl 4-8
addrel                                                 builtin function         dcl 47
imess                                  based           structure                level 1 dcl 2-21
imp                                    automatic       pointer                  dcl 2-19

NAMES DECLARED BY EXPLICIT CONTEXT.
CANT_RETURN_PTR                 000316 constant        label                    dcl 90 set ref 77 81
get_buffer_ptr                  000036 constant        entry                    external dcl 54
get_status                      001704 constant        entry                    external dcl 194
get_status_class                000441 constant        entry                    external dcl 106
get_workspace_ptr               000225 constant        entry                    external dcl 72
io_in_progress                  000344 constant        entry                    external dcl 97
last_status_entry_offset        002134 constant        entry                    external dcl 228
tape_ioi_utils                  000022 constant        entry                    external dcl 19

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2370        2400    2256        2400
Length      2644    2256        10         230     111           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_ioi_utils                      272 external procedure  is an external procedure.  
on unit on line 75                   64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tape_ioi_utils           000100 buffer_data_ptr             tape_ioi_utils
                         000102 buffer_idx                  tape_ioi_utils
                         000104 buffer_ptr                  tape_ioi_utils
                         000106 done                        tape_ioi_utils
                         000107 status_entry_idx            tape_ioi_utils
                         000110 test_read                   tape_ioi_utils
                         000120 wksp                        tape_ioi_utils
                         000122 isp                         tape_ioi_utils
                         000124 io_status_word_ptr          tape_ioi_utils

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
return_mac          tra_ext_1           mdfx1               signal_op           enable_op           ext_entry
int_entry           any_to_any_truncate_

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 000021        54 000031        57 000052        58 000055        59 000061        62 000106        63 000114
     64 000136        65 000143        66 000145        68 000177        72 000220        75 000237        77 000253
     80 000256        81 000264        86 000267        87 000275        88 000276        90 000316        92 000320
     97 000340       100 000356       101 000361       106 000434       109 000450       110 000454       116 000456
    118 000501       120 000526       121 000532       123 000555       125 000576       126 000602       128 000625
    130 000653       132 000674       133 000677       135 000726       137 000755       139 000776       140 001003
    143 001031       145 001052       147 001100       148 001105       150 001133       152 001161       155 001210
    157 001231       159 001257       160 001264       162 001312       164 001336       166 001357       167 001364
    169 001416       171 001444       173 001465       174 001472       181 001533       183 001561       185 001602
    186 001607       188 001635       190 001656       194 001677       197 001720       198 001723       199 001726
    200 001727       201 001732       203 001746       204 001751       206 001757       208 001761       210 001776
    212 002025       216 002026       217 002031       220 002045       221 002060       222 002071       223 002104
    224 002106       228 002127       231 002145       232 002150       242 002234


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
