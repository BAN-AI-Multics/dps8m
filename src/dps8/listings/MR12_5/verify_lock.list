	COMPILATION LISTING OF SEGMENT verify_lock
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1020.1 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style3 */
       13 
       14 verify_lock:
       15      procedure;
       16 
       17 /*
       18*
       19*   verify_lock: called by signal_ before we leave ring 0.
       20*
       21*   USAGE: call verify_lock;
       22*
       23*   NOTES:
       24*   1. If an error condition exist this proc will crash the system
       25*   with an appropriate error message.
       26*
       27*   Modification history:
       28*   75-05-30, A. Bensoussan: Initial coding
       29*   76-07-26, Greenberg: Modified to avoid online-salv recursion in pdir salv
       30*   79-02-03, D. Spector: Modified to log only crawl-outs which unlock locks
       31*   79-07-28, W. Olin Sibert: Modified to unlock all dir locks, even if
       32*     they don't correspond to real dirs -- fixes Volume_Dumper lossage
       33*     which causes notify timeouts when fake dir remains locked
       34*   81-04-09, J. Bongiovanni: Modified to call vtoc_man$crawlout if vtoc
       35*     buffer lock held, and to correct syserr logging of history registers
       36*   82-02-23, BIM: Modified for improved dir locking and other stuff.
       37*   82-04-01, J. Bongiovanni: Modified for PVT locks
       38*   82-04-15, JIS: Changed to cleanup system_free_seg before checking lock array
       39*   82-04-28, BIM: Modified for removal of system free seg entirely.
       40*   83-01-18, BIM: Modified to cleanup of write_sw in dirlockt.
       41*   83-03-12, BIM: Modified for readers in the dir_lock_seg_, better messages.
       42*   83-08-05, Chris Jones: Modified for ioi_verify_lock.
       43*   84-10-25, WOS: Changed for syserr_seg_manager$verify
       44*   83-11-08, BIM: Change for better readers in dir_lock_seg_, check for masked.
       45*   84-11-01, Keith Loepere to remove unused notion of directory detectability.
       46*   85-02-21, EJ Sharpe: use syserr_fault_msg include for binary messages,
       47*		added condition_nolog entrypoint for initial use by scavenger
       48*   85-03-28, EJ Sharpe: chaged to log MC/HREG only if some lock unlocked for phx16862
       49*   85-05-13, EJ Sharpe: added check for lock on dm_journal_seg_ 
       50**/
       51 
       52 /****^  HISTORY COMMENTS:
       53*  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
       54*     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1091):
       55*     Correct error message documentation.
       56*  2) change(86-10-23,Fawcett), approve(86-10-23,MCR7517),
       57*     audit(86-10-30,Beattie), install(86-11-03,MR12.0-1206):
       58*     Changed to remove the word BOS from Error message documentation.
       59*                                                   END HISTORY COMMENTS */
       60 
       61 dcl	1 dirs_locked	aligned,			/* remember them here, */
       62 	  2 count		fixed bin,		/* so they can all be unlocked before */
       63 	  2 array		(30) aligned,		/* any are salvaged */
       64 	    3 seg_ptr	pointer,
       65 	    3 uid		bit (36) aligned;
       66 
       67 dcl	code		fixed bin (35);
       68 dcl	cond_name		char (32);
       69 
       70 dcl	check_masked	bit (1) aligned;
       71 dcl	log_condition	bit (1) aligned;		/* flag indicating we should log this condition */
       72 dcl	unlock_occurred	bit (1) aligned;		/* indicates something was force unlocked */
       73 dcl	mcptr		ptr;
       74 dcl	pvtx		fixed bin;
       75 dcl	pagex		fixed bin;
       76 dcl	p99		pic "99";
       77 dcl	tsdw		fixed bin (71);
       78 
  1     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  1     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  1     3*   encourages name conflicts.
  1     4*   USE HC_FAST_LOCK INSTEAD!
  1     5**/
  1     6 
  1     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  1     8 
  1     9 /* format: style3 */
  1    10 
  1    11 declare	lock_ptr		pointer;
  1    12 declare	1 lock		aligned based (lock_ptr),
  1    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  1    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  1    15 	  2 flags		aligned,
  1    16 	    3 notify_sw	bit (1) unaligned,
  1    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  1    18 
  1    19 /* End include file hc_lock.incl.pl1 */
       79 
       80 
       81 dcl	condition_	entry (char (*), entry);
       82 dcl	ioi_verify_lock	entry () returns (bit (1) aligned);
       83 dcl	reversion_	entry (char (*));
       84 dcl	syserr		entry options (variable);
       85 dcl	syserr$binary	entry options (variable);
       86 dcl	syserr$error_code	entry options (variable);
       87 dcl	on_line_salvager	entry (ptr, fixed bin (35));
       88 dcl	lock$dir_unlock_given_uid
       89 			entry (bit (36) aligned);
       90 dcl	lock$dir_lock_salvage
       91 			entry (ptr, bit (36) aligned, fixed bin (35));
       92 dcl	lock$unlock_fast	entry (ptr);
       93 dcl	lock$lock_fast	entry (pointer);
       94 dcl	pxss$notify	entry (bit (36) aligned);
       95 dcl	get_pvtx$cleanup	entry () returns (bit (1) aligned);
       96 dcl	debug_check	entry (char (4) aligned) returns (bit (1));
       97 dcl	vtoc_man$crawlout	entry;
       98 dcl	tty_lock$verify	entry () returns (bit (1) aligned);
       99 dcl	syserr_seg_manager$verify_lock
      100 			entry () returns (bit (1) aligned);
      101 dcl	kstsrch		entry (bit (36) aligned, fixed bin (17), ptr);
      102 dcl	page$write_volmap_page_unwired
      103 			entry (ptr, fixed bin);
      104 dcl	page$unlock_volmap	entry (ptr);
      105 dcl	pmut$swap_sdw	entry (ptr, ptr);
      106 dcl	pmut$read_mask	entry (fixed bin (71));
      107 dcl	vtoce_stock_man$force_unlock
      108 			entry (ptr);
      109 
      110 dcl	pds$process_group_id
      111 			external char (32) aligned;
      112 dcl	pds$processid	external bit (36) aligned;
      113 dcl	pds$block_lock_count
      114 			external fixed bin (17);
      115 dcl	scs$sys_level	fixed bin (71) external static;
      116 dcl	error_table_$salv_pdir_procterm
      117 			external fixed bin (35);
      118 dcl	ahd$search_rules_lock
      119 			external;
      120 dcl	sst$astl		bit (36) aligned external static;
      121 dcl	tc_data$system_shutdown
      122 			external bit (1) aligned;
      123 dcl	tc_data$lock_error_severity
      124 			fixed bin external static;
      125 dcl	pvt$n_entries	fixed bin external static;
      126 dcl	volmap_abs_seg$	external static;
      127 
      128 dcl	seg_fault_error	condition;
      129 dcl	page_fault_error	condition;
      130 dcl	subscriptrange	condition;
      131 
      132 dcl	(addr, addrel, baseptr, convert, hbound, null, unspec)
      133 			builtin;
      134 
      135 /* MAIN PROGRAM */
      136 
      137 	cond_name = "r0 process termination";
      138 	check_masked = "0"b;
      139 	mcptr = null;
      140 	log_condition = "1"b;
      141 
      142 start:
      143 	if debug_check ("crwl")
      144 	then call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: Crawlout stop specified on PARM card.");
      145 
      146 	unlock_occurred = "0"b;
      147 	code = 0;
      148 
      149 	if (syserr_seg_manager$verify_lock ())
      150 	then call NOTE_UNLOCK ("syserr_log");
      151 
      152 	call VERIFY_PVT_LOCKS;
      153 
      154 	call VERIFY_VTOC_BUFFERS;
      155 
      156 	if (ioi_verify_lock ())			/* logs own messages */
      157 	then unlock_occurred = "1"b;
      158 
      159 	call VERIFY_DBM;
      160 
      161 	call VERIFY_DM_JOURNAL_SEG;
      162 
      163 	if (get_pvtx$cleanup ())			/* logs own messages */
      164 	then unlock_occurred = "1"b;
      165 
      166 	call VERIFY_DIR_LOCK_SEG;
      167 
      168 	call VERIFY_AST (code);
      169 	if code ^= 0
      170 	then call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: Crawlout with AST lock set.");
      171 
      172 	call VERIFY_SEARCH_RULES;
      173 
      174 	if (tty_lock$verify ())			/* logs own messages */
      175 	then unlock_occurred = "1"b;
      176 
      177 	dirs_locked.count = 0;
      178 	dirs_locked.seg_ptr (*) = null ();
      179 	dirs_locked.uid (*) = (36)"0"b;
      180 
      181 	call VERIFY_DIRECTORIES (code);
      182 	if code ^= 0
      183 	then call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: Crawlout error on directory cleanup.");
      184 
      185 	call SALVAGE_DIRECTORIES;
      186 
      187 	if pds$block_lock_count ^= 0
      188 	then call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: block_lock_count ^d, should be 0", pds$block_lock_count);
      189 
      190 	if check_masked
      191 	then call VERIFY_MASKED;
      192 
      193 
      194 	if log_condition & unlock_occurred
      195 	then if mcptr = null
      196 	     then call syserr (SYSERR_LOG_OR_PRINT, "verify_lock: ^a condition by ^a", cond_name, pds$process_group_id);
      197 	     else call make_syserr_message (cond_name, mcptr);
      198 
      199 	return;
      200 
      201 /* These entry points are called when hardcore wants to log a message about the condition. */
      202 
      203 verify_lock_bad_dir:
      204      entry (a_mcptr);
      205 
      206 	cond_name = "bad_dir_";
      207 	mcptr = null;
      208 	check_masked = "1"b;
      209 	log_condition = "1"b;
      210 	go to start;
      211 
      212 condition:
      213      entry (a_name, a_mcptr);
      214 
      215 dcl	a_name		char (*);
      216 dcl	a_mcptr		ptr;
      217 
      218 	cond_name = a_name;
      219 	mcptr = a_mcptr;
      220 	check_masked = "1"b;
      221 	log_condition = "1"b;
      222 	go to start;
      223 
      224 
      225 /* The following entrypoint is used by hardcore procedures which perform
      226*their own logging of the condition. */
      227 
      228 condition_nolog:
      229      entry (a_name, a_mcptr);
      230 
      231 	cond_name = a_name;
      232 	mcptr = a_mcptr;
      233 	check_masked = "1"b;
      234 	log_condition = "0"b;
      235 	go to start;
      236 
      237 VERIFY_VTOC_BUFFERS:
      238      proc;
      239 
      240 	vtoc_buffer_segp = addr (vtoc_buffer_seg$);
      241 	lock_ptr = addr (vtoc_buffer.lock);
      242 
      243 	if lock.pid = pds$processid
      244 	then do;
      245 		call vtoc_man$crawlout;
      246 		call lock$unlock_fast (lock_ptr);
      247 		call NOTE_UNLOCK ("vtoc_buffer_seg");
      248 	     end;
      249 	else call CHECK_NOTIFY (lock_ptr);
      250 	return;
      251      end VERIFY_VTOC_BUFFERS;
      252 
      253 VERIFY_DBM:
      254      procedure;
      255 
  2     1 /* BEGIN INCLUDE FILE ... dbm.incl.pl1  ... Feb 1976 */
  2     2 
  2     3 dcl  dbm_seg$ ext;
  2     4 dcl  dbmp ptr;
  2     5 
  2     6 dcl 1 dbm based (dbmp) aligned,
  2     7     2 lock_data,
  2     8       3 lock bit (36),
  2     9       3 event bit (36),
  2    10       3 notify bit (1),
  2    11     2 control,
  2    12       3 init bit (1) unal,
  2    13       3 pad1 bit (35) unal,
  2    14     2 stats,
  2    15       3 sets fixed bin unal,
  2    16       3 resets fixed bin unal,
  2    17       3 allocs fixed bin unal,
  2    18       3 frees fixed bin unal,
  2    19     2 pad2 (2) bit (36),
  2    20     2 area area (255*1024 -8);
  2    21 
  2    22 /* END INCLUDE FILE ... dbm.incl.pl1 */
      256 
      257 
      258 	dbmp = addr (dbm_seg$);
      259 	lock_ptr = addr (dbm.lock_data);
      260 	if lock.pid = pds$processid
      261 	then do;
      262 		call lock$unlock_fast (lock_ptr);
      263 		call NOTE_UNLOCK ("dbm_seg");
      264 	     end;
      265 	else call CHECK_NOTIFY (lock_ptr);
      266 	return;
      267      end VERIFY_DBM;
      268 
      269 VERIFY_DM_JOURNAL_SEG:
      270      procedure;
      271 
  3     1 /*  START OF:	dm_journal_seg_.incl.pl1	October 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 /*                                                modified June 1982 by M. Pandolf for more meters *  *  *  *  *  *  *  */
  3     3 
  3     4      dcl	   dm_journal_seg_$	      external;
  3     5 
  3     6      dcl	   dm_journal_segp	      ptr;
  3     7      dcl	   dm_per_journalp	      ptr;
  3     8      dcl	   dm_per_journal_arrayp  ptr;
  3     9      dcl	   dm_page_entryp	      ptr;
  3    10 
  3    11      dcl	   n_dm_journals	      fixed bin;
  3    12      dcl	   max_dm_pages	      fixed bin;
  3    13 
  3    14 
  3    15      dcl	   1 dm_journal	      aligned based (dm_journal_segp),
  3    16 
  3    17 	     2 lock	      bit (36) aligned,	/* Lock for manipulating journal entries */
  3    18 	     2 wait_event	      bit (36) aligned,	/* Wait Event for lock */
  3    19 	     2 notify_sw	      bit (1) aligned,
  3    20 
  3    21 	     2 n_journals	      fixed bin,		/* Number of journals */
  3    22 	     2 n_journals_inuse   fixed bin,		/* Number of journals in use now */
  3    23 	     2 max_held_pages_mem fixed bin,		/* Maximum number of pages held in memory */
  3    24 	     2 n_held_pages_mem   fixed bin,		/* Number of pages held in memory */
  3    25 	     2 max_held_per_journal fixed bin,		/* max_held_pages_mem / n_journals_inuse */
  3    26 	     2 per_aste_pool      (0:3) aligned,
  3    27 	       3 threshold	      fixed bin,		/* Maximum number of active segments */
  3    28 	       3 n_active	      fixed bin,		/* Number currently active */
  3    29 	     2 free_list_relp     bit (18) aligned,	/* Free entry list first ptr */
  3    30 	     2 synch_write_calls  fixed bin (35),	/* Number of calls to check write */
  3    31 	     2 synch_write_holds  fixed bin (35),	/* Number of times page held for call */
  3    32 	     2 synch_write_no_stamp
  3    33 			      fixed bin (35),	/* Number of times page had null DM stamp */
  3    34 	     2 synch_write_inv_vers
  3    35 			      fixed bin (35),	/* Number of times page had invalid DM stamp */
  3    36 	     2 synch_write_inv_ix
  3    37 			      fixed bin (35),	/* Number of times page had invalid BJ index */
  3    38 	     2 synch_write_inv_time
  3    39 			      fixed bin (35),	/* Number of times page had future time stamp */
  3    40 	     2 synch_write_tosses fixed bin (35),	/* Number of times page tossed because of threshold */
  3    41 	     2 unlink_calls	      fixed bin (35),	/* Number of calls to unlink all entries to a journal */
  3    42 	     2 unlink_steps	      fixed bin (35),	/* Number of CMEs unlinked */
  3    43 	     2 activate_calls     fixed bin (35),	/* Number of times synch segment activated */
  3    44 	     2 deactivate_calls   fixed bin (35),	/* Number of times synch segment deactivated */
  3    45 	     2 activate_denied    fixed bin (35),	/* Number of times activation threshold exceeded */
  3    46 	     2 set_stamp_calls    fixed bin (35),	/* Number of times called to set time stamp */
  3    47 	     2 allocate_calls     fixed bin (35),	/* Number of times called to allocate a journal */
  3    48 	     2 free_calls	      fixed bin (35),	/* Number of times called to free a journal */
  3    49 
  3    50 	     2 per_journal	      (n_dm_journals refer (dm_journal.n_journals)) aligned like dm_per_journal,
  3    51 	     2 page_entry	      (max_dm_pages refer (dm_journal.max_held_pages_mem)) aligned like dm_page_entry;
  3    52 
  3    53 
  3    54      dcl	   1 dm_per_journal_array (dm_journal.n_journals) aligned like dm_per_journal based (dm_per_journal_arrayp);
  3    55 
  3    56      dcl	   1 dm_per_journal	      aligned based (dm_per_journalp), /* One entry per DM journal */
  3    57 	     2 time_stamp	      fixed bin (71),	/* Pages before this time can be written */
  3    58 	     2 n_held	      fixed bin,		/* Number of pages held in memory */
  3    59 	     2 uid	      bit (36) aligned,	/* Unique ID for owner - ""b => not used */
  3    60 	     2 access_class	      bit (72) aligned,	/* Access Class of Owner */
  3    61 	     2 entry_relp	      bit (18) aligned,	/* Pointer to list of pages held for this journal */
  3    62 	     2 pad	      bit (36) aligned;
  3    63 
  3    64 
  3    65      dcl	   1 dm_page_entry	      aligned based (dm_page_entryp),
  3    66 	     2 fp		      bit (18) unal,	/* Forward pointer */
  3    67 	     2 bp		      bit (18) unal,	/* Backward pointer */
  3    68 	     2 cme_relp	      bit (18) unal,	/* Rel ptr -> CME */
  3    69 	     2 journal_relp	      bit (18) unal;	/* Rel ptr -> dm_per_journal */
  3    70 
  3    71 
  3    72 /*  END OF:	dm_journal_seg_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3    73 
      272 
      273 
      274 	dm_journal_segp = addr (dm_journal_seg_$);
      275 	lock_ptr = addr (dm_journal.lock);
      276 	if lock.pid = pds$processid
      277 	then do;
      278 		call lock$unlock_fast (lock_ptr);
      279 		call NOTE_UNLOCK ("dm_journal_seg_");
      280 	     end;
      281 	else call CHECK_NOTIFY (lock_ptr);
      282 	return;
      283      end VERIFY_DM_JOURNAL_SEG;
      284 
      285 VERIFY_DIR_LOCK_SEG:
      286      procedure;
      287 
      288 	dir_lock_segp = addr (dir_lock_seg$);
      289 	lock_ptr = addr (dir_lock_seg.seg_lock);
      290 
      291 	if lock.pid = pds$processid
      292 	then do;
      293 		call NOTE_UNLOCK ("dir_lock_seg");
      294 		call lock$unlock_fast (lock_ptr);
      295 	     end;
      296 	else call CHECK_NOTIFY (lock_ptr);
      297 	return;
      298      end VERIFY_DIR_LOCK_SEG;
      299 
      300 
      301 
      302 VERIFY_AST:
      303      proc (code);
      304 
      305 dcl	code		fixed bin (35);
      306 
      307 	lock_ptr = addr (sst$astl);
      308 
      309 	if lock.pid = pds$processid
      310 	then do;
      311 		code = 1;
      312 	     end;
      313 	else call CHECK_NOTIFY (lock_ptr);
      314 	return;
      315      end VERIFY_AST;
      316 
      317 
      318 /* Check for dir locks */
      319 
      320 
      321 VERIFY_DIRECTORIES:
      322      procedure (code);
      323 
      324 dcl	code		fixed bin (35);
      325 dcl	i		fixed bin (17);
      326 dcl	rx		fixed bin;
      327 dcl	this_dir_locked	bit (1) aligned;
      328 
      329 	code = 0;
      330 	dir_lock_segp = addr (dir_lock_seg$);
      331 	dir_lock_all_locksp = dir_lock_seg.header.locks_ptr;
      332 	dir_lock_all_readersp = dir_lock_seg.header.readers_ptr;
      333 
      334 LOOP_OVER_DIRS:
      335 	do i = 1 to dir_lock_seg.header.highest_in_use;
      336 	     this_dir_locked = "0"b;
      337 	     dir_lockp = addr (dir_lock_all_dir_locks (i));
      338 	     dir_read_lockers_ptr = addr (dir_lock_all_readers (i, 1));
      339 	     if dir_lock.lock_count ^= 0
      340 	     then do;
      341 		     call lock$lock_fast (addr (dir_lock_seg.header.seg_lock));
      342 						/* make sure this is for real */
      343 		     if dir_lock.lock_count > 0
      344 		     then if dir_lock.write_locker = pds$processid
      345 			then this_dir_locked = "1"b;
      346 			else ;			/* locked exclusively to someone else */
      347 		     else if dir_lock.lock_count < 0
      348 		     then /* read locked */
      349 LOOP_OVER_LOCKERS:
      350 			do rx = 1 to hbound (dir_read_lockers, 1);
      351 			     if dir_read_lockers (rx) = pds$processid
      352 			     then this_dir_locked = "1"b;
      353 			end LOOP_OVER_LOCKERS;
      354 
      355 		     call lock$unlock_fast (addr (dir_lock_seg.header.seg_lock));
      356 		     if this_dir_locked
      357 		     then call VERIFY_DIR (dir_lock.uid, (dir_lock.salvage_sw), (dir_lock.lock_count > 0));
      358 		end;
      359 
      360 	end LOOP_OVER_DIRS;
      361 	return;
      362 
      363      end VERIFY_DIRECTORIES;
      364 
      365 
      366 VERIFY_DIR:
      367      procedure (uid, salvage_sw, write_sw) options (non_quick);
      368 
      369 dcl	uid		bit (36) aligned;
      370 dcl	salvage_sw	bit (1) aligned;
      371 dcl	write_sw		bit (1) aligned;
      372 
      373 	dp = GET_SEG_PTR (uid);
      374 
      375 	if salvage_sw				/* Salvager had it locked */
      376 	then do;					/* Do nearly nothing */
      377 		call syserr (SYSERR_LOG_OR_PRINT, "verify_lock: Crawlout while in directory salvager, dir (^w,^p).",
      378 		     uid, dp);
      379 		go to unlock_return;
      380 	     end;
      381 
      382 	if dp = null				/* This is not the KST uid, the dir may not even be there */
      383 	then go to unlock_return;
      384 
      385 	on seg_fault_error, page_fault_error go to NO_MODIFY_CHECK;
      386 	if (dir.modify ^= pds$processid) & (dir.modify ^= ""b)
      387 	then do;
      388 		call syserr (tc_data$lock_error_severity, "verify_lock: dir.modify ^p ^w ^^= processid.", dp,
      389 		     dp -> dir.modify);
      390 	     end;
      391 
      392 NO_MODIFY_CHECK:
      393 	revert seg_fault_error, page_fault_error;
      394 
      395 	on subscriptrange
      396 	     call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: more than ^d directories locked to process.",
      397 		hbound (dirs_locked.seg_ptr, 1));
      398 
      399 	dirs_locked.count = dirs_locked.count + 1;
      400 (subscriptrange):
      401 	dirs_locked.seg_ptr (dirs_locked.count) = dp;
      402 	revert subscriptrange;
      403 
      404 	dirs_locked.uid (dirs_locked.count) = uid;
      405 unlock_return:
      406 	call syserr (SYSERR_LOG_OR_PRINT, "verify_lock: Unlocking dir ^w. Locked for ^[read^]^[write^]^[, salvage^].",
      407 	     uid, ^write_sw, write_sw, salvage_sw);
      408 	unlock_occurred = "1"b;
      409 
      410 	call lock$dir_unlock_given_uid (uid);		/* we may be one of many readers */
      411 
      412      end VERIFY_DIR;
      413 
      414 SALVAGE_DIRECTORIES:
      415      procedure;
      416 
      417 declare	dirx		fixed bin;
      418 declare	uid		bit (36) aligned;
      419 
      420 	if dirs_locked.count = 0
      421 	then return;
      422 
      423 	do dirx = 1 to dirs_locked.count;
      424 	     call lock$dir_lock_salvage (dirs_locked.seg_ptr (dirx), uid, (0));
      425 						/* get unique lock */
      426 
      427 	     call syserr (SYSERR_LOG_OR_PRINT, "verify_lock: Salvaging dir ^p ^w on crawlout.", dp, uid);
      428 
      429 	     call condition_ ("any_other", salvager_handler);
      430 
      431 	     code = 0;
      432 
      433 	     call on_line_salvager (dirs_locked.seg_ptr (dirx), code);
      434 
      435 	     call reversion_ ("any_other");
      436 
      437 
      438 	     if code = error_table_$salv_pdir_procterm
      439 	     then call syserr$error_code (SYSERR_TERMINATE_PROCESS, code, "Terminating user process ^a: ",
      440 		     pds$process_group_id);
      441 
      442 CONTINUE_VERIFY_LOCK:
      443 	     call lock$dir_unlock_given_uid (uid);	/* unlock it even if it isn't a real dir */
      444 	end;
      445 	return;
      446 
      447 salvager_handler:
      448      procedure (mc_ptr, condition_name, wc_ptr, info_ptr, continue_flag);
      449 
      450 declare	(mc_ptr, wc_ptr, info_ptr)
      451 			pointer;
      452 declare	condition_name	character (*);
      453 declare	continue_flag	bit (1) aligned;
      454 
      455 
      456 	call syserr (SYSERR_PRINT_ON_CONSOLE, "verify_lock: ^a condition by ^a while salvaging directory.",
      457 	     condition_name, pds$process_group_id);
      458 
      459 	if mc_ptr ^= null
      460 	then call make_syserr_message (condition_name, mc_ptr);
      461 
      462 	go to CONTINUE_VERIFY_LOCK;			/* unwind stack, running cleanup handlers */
      463 						/* in salvager subsystem */
      464      end salvager_handler;
      465 
      466      end SALVAGE_DIRECTORIES;
      467 
      468 VERIFY_PVT_LOCKS:
      469      procedure;
      470 
      471 	pvt_arrayp = addr (pvt$array);
      472 	do pvtx = 1 to pvt$n_entries;
      473 
      474 	     pvtep = addr (pvt_array (pvtx));
      475 
      476 	     if pvte.vtoc_map_lock = pds$processid
      477 	     then do;
      478 		     call vtoce_stock_man$force_unlock (pvtep);
      479 		     call syserr (SYSERR_LOG_OR_PRINT,
      480 			"verify_lock: Force unlocked VTOC Map lock (^a_^a^[^a^;^s^]) on crawlout for ^a", pvte.devname,
      481 			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);
      482 		     pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      483 		     tsdw = 0;
      484 		     unlock_occurred = "1"b;
      485 		     call pmut$swap_sdw (addr (volmap_abs_seg$), addr (tsdw));
      486 		end;
      487 
      488 	     if pvte.volmap_lock = pds$processid
      489 	     then do;
      490 		     call pmut$swap_sdw (addr (volmap_abs_seg$), addr (pvte.volmap_seg_sdw));
      491 		     record_stockp = pvte.volmap_stock_ptr;
      492 		     do pagex = 0 to record_stock.n_volmap_pages;
      493 			call page$write_volmap_page_unwired (pvtep, pagex);
      494 		     end;
      495 		     call page$unlock_volmap (pvtep);
      496 		     call syserr (SYSERR_LOG_OR_PRINT,
      497 			"verify_lock: Force unlocked Volmap lock (^a_^a^[^a^;^s^]) on crawlout for ^a", pvte.devname,
      498 			convert (p99, pvte.logical_area_number), pvte.is_sv, pvte.sv_name, pds$process_group_id);
      499 		     tsdw = 0;
      500 		     unlock_occurred = "1"b;
      501 		     call pmut$swap_sdw (addr (volmap_abs_seg$), addr (tsdw));
      502 		end;
      503 
      504 	end;
      505 
      506      end VERIFY_PVT_LOCKS;
      507 
      508 VERIFY_SEARCH_RULES:
      509      proc;
      510 
      511 	if tc_data$system_shutdown
      512 	then return;
      513 	lock_ptr = addr (ahd$search_rules_lock);
      514 	if lock.pid = pds$processid
      515 	then do;
      516 		call NOTE_UNLOCK ("search rules");
      517 		call lock$unlock_fast (lock_ptr);
      518 	     end;
      519 	else call CHECK_NOTIFY (lock_ptr);
      520      end VERIFY_SEARCH_RULES;
      521 
      522 
      523 
      524 VERIFY_MASKED:
      525      procedure;
      526 
      527 declare	mask		fixed bin (71);
      528 
      529 	call pmut$read_mask (mask);
      530 	if mask = scs$sys_level
      531 	then call syserr (SYSERR_CRASH_SYSTEM, "verify_lock: Crawlout while masked.");
      532 
      533 	return;
      534      end VERIFY_MASKED;
      535 
      536 
      537 CHECK_NOTIFY:
      538      proc (a_lock_ptr);
      539 
      540 dcl	a_lock_ptr	ptr;
      541 
      542 	lock_ptr = a_lock_ptr;
      543 	if lock.pid = (36)"0"b & lock.flags.notify_sw = "1"b
      544 	then call pxss$notify (lock.event);
      545 	return;
      546      end CHECK_NOTIFY;
      547 
      548 
      549 NOTE_UNLOCK:
      550      procedure (What_did_we_unlock);
      551 
      552 declare	What_did_we_unlock	char (*);
      553 
      554 	call syserr (SYSERR_LOG_OR_PRINT, "verify_lock: Unlocked ^a.", What_did_we_unlock);
      555 	unlock_occurred = "1"b;
      556      end NOTE_UNLOCK;
      557 
      558 
      559 GET_SEG_PTR:
      560      proc (uid) returns (ptr);
      561 
      562 dcl	uid		bit (36) aligned;
      563 dcl	segptr		ptr;
      564 
      565 	call kstsrch (uid, (0), kstep);
      566 	if kstep ^= null
      567 	then segptr = baseptr (kstep -> kste.segno);
      568 	else segptr = null;
      569 	return (segptr);
      570      end GET_SEG_PTR;
      571 
      572 
      573 make_syserr_message:
      574      procedure (cond_name, mcptr);
      575 
      576 dcl	cond_name		character (*);
      577 dcl	mcptr		pointer;
      578 dcl	1 auto_fault_msg	aligned like fault_msg;	/* Machine conditions and history for syserr logging */
      579 dcl	ssptr		pointer;			/* pointer to signaller stack frame */
      580 
      581 	ssptr = addrel (mcptr, -8);			/* signaller_stack.pad is 8 words long! */
      582 						/* Construct contiguous machine conditions and history registers */
      583 	unspec (auto_fault_msg.mach_cond) = unspec (ssptr -> signaller_stack.mach_cond);
      584 	auto_fault_msg.hist_reg = ssptr -> signaller_stack.history_registers;
      585 	call syserr$binary (SYSERR_LOG_OR_PRINT, addr (auto_fault_msg), SB_verify_lock, SBL_verify_lock,
      586 	     "verify_lock: ^a condition by ^a", cond_name, pds$process_group_id);
      587 						/* Save machine cond (and history) if known */
      588 
      589      end make_syserr_message;
      590 
      591 /* format: off */
      592 
      593  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  4     2 /* Modified 8/74 for NSS */
  4     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  4     4 /* Modified 3/82 BIM for change pclock */
  4     5 /* format: style3 */
  4     6 
  4     7 /* Template for the directory header. Length = 64 words. */
  4     8 
  4     9 dcl  dp ptr;
  4    10 
  4    11 dcl 1 dir based (dp) aligned,
  4    12 
  4    13    2 modify bit (36),				/* Process ID of last modifier */
  4    14    2 type bit (18) unaligned,			/* type of object = dir header */
  4    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  4    16     2 dtc (3),					/* date-time checked by salvager array */
  4    17       3 date bit (36),				/* the date */
  4    18       3 error bit (36),				/* what errors were discovered */
  4    19 
  4    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  4    21 
  4    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  4    23 
  4    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  4    25 
  4    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  4    27 
  4    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  4    29     2 version_number fixed bin (17),			/* version number of header */
  4    30 
  4    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  4    32     2 pad2 bit (18),
  4    33 
  4    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  4    35     2 pad3 bit (18),
  4    36 
  4    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  4    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  4    39 
  4    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  4    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  4    42 
  4    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  4    44     2 dir_count fixed bin (17),			/* number of directory branches */
  4    45 
  4    46     2 lcount fixed bin (17),				/* number of links */
  4    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  4    48 
  4    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  4    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  4    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  4    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  4    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  4    54     2 pad4 bit (14),
  4    55 
  4    56     2 iacl_count (0:7),
  4    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  4    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  4    59 
  4    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  4    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  4    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  4    63 
  4    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  4    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  4    66 
  4    67     2 htsize fixed bin (17),				/* size of hash table */
  4    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  4    69 
  4    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  4    71     2 pad6 fixed bin (17),
  4    72 
  4    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  4    74     2 pad7 bit (18)) unaligned,
  4    75 
  4    76     2 dts bit (36),					/* date-time directory last salvaged */
  4    77 
  4    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  4    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  4    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  4    81     2 checksum bit (36),				/* checksummed from uid on */
  4    82     2 owner bit (36);				/* uid of parent dir */
  4    83 
  4    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  4    85 
  4    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      593 
      594  /* Begin include file dir_lock_seg_.incl.pl1 BIM 830312 */
  5     2 /* From dirlockt.incl.pl1 */
  5     3 
  5     4 /* format: style3,idind25,indcomtxt */
  5     5 
  5     6 /**** Several arrays in this program are zero based. The zero-th
  5     7*      entries are NEVER USED. referencers should start at 1, not lbound.
  5     8*      The zero entries are there to improve the compiler's subscript
  5     9*      calculations. The compiler can fetch dir_lock_all_dir_locks (foo).uid
  5    10*      with an lda pr6|FOO,*ql */
  5    11 
  5    12 dcl	dir_lock_seg$	     external static;	/* name of the segment containing the directory locks */
  5    13 
  5    14 dcl	dir_lock_segp	     pointer;		/* pointer to the dirlock table */
  5    15 
  5    16 dcl	1 dir_lock_seg	     based (dir_lock_segp) aligned,
  5    17 	  2 header	     aligned like dir_lock_seg_header,
  5    18 	  2 dir_locks	     (0:dir_lock_seg.header.n_dir_locks) aligned like dir_lock,
  5    19 	  2 readers	     (0:dir_lock_seg.header.n_dir_locks, dir_lock_seg.header.max_readers) bit (36) aligned;
  5    20 
  5    21 declare	(dir_lock_all_locksp, dir_lock_all_readersp)
  5    22 			     pointer;
  5    23 
  5    24 declare	1 dir_lock_all_dir_locks (0:dir_lock_seg.header.n_dir_locks) aligned like dir_lock based (dir_lock_all_locksp);
  5    25 declare	dir_lock_all_readers     (0:dir_lock_seg.header.n_dir_locks, dir_lock_seg.header.max_readers) bit (36)
  5    26 			     aligned based (dir_lock_all_readersp);
  5    27 
  5    28 declare	DIR_LOCK_SEG_EVENT	     char (4) aligned init ("drls") int static options (constant);
  5    29 
  5    30 declare	1 dir_lock_seg_header    aligned based,
  5    31 	  2 seg_lock	     aligned like lock,
  5    32 	  2 n_dir_locks	     fixed bin,		/* max number */
  5    33 	  2 highest_in_use	     fixed bin,
  5    34 	  2 max_readers	     fixed bin,
  5    35 	  2 pad_even	     bit (36) aligned,
  5    36 	  2 readers_ptr	     pointer,
  5    37 	  2 locks_ptr	     pointer,
  5    38 	  2 meters	     aligned,
  5    39 	    3 find_calls	     fixed bin (35),
  5    40 	    3 find_failures	     fixed bin (35),
  5    41 	    3 max_in_use	     fixed bin (35),
  5    42 	    3 pad_meters	     fixed bin (35),
  5    43 	  2 pad		     (16) bit (36) aligned;	/* to 32 */
  5    44 
  5    45 declare	dir_lockp		     pointer;
  5    46 declare	1 dir_lock	     aligned based (dir_lockp),
  5    47 	  2 uid		     bit (36) aligned,
  5    48 	  2 flags		     aligned,
  5    49 	    3 notify_sw	     bit (1) unaligned,
  5    50 	    3 salvage_sw	     bit (1) unaligned,	/* ON if dir was locked for salvage */
  5    51 	    3 pad		     bit (34) unaligned,
  5    52 	  2 lock_count	     fixed bin (17),	/* POSITIVE --> write_lock */
  5    53 						/* NEGATIVE --> -number of lockers */
  5    54 						/* ZERO --> not locked */
  5    55 	  2 write_locker	     bit (36) aligned;	/* in case of read, see next declaration, and expect this 0 */
  5    56 
  5    57 declare	dir_read_lockers_ptr     pointer;
  5    58 declare	dir_read_lockers	     (dir_lock_seg.header.max_readers) bit (36) aligned based (dir_read_lockers_ptr);
  5    59 
  5    60 /* End include file dir_lock_seg_.incl.pl1 */
      594 
      595  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  6     2 
  6     3 /*
  6     4*Modified March 1976 by R. Bratt 
  6     5*Modified November 1984 to remove hdr, Keith Loepere. */
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  6    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  6    11*     Add warning on use of kste.entryp.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl  pds$kstp ext ptr,
  6    16     (kstp, kstep) ptr;
  6    17 
  6    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  6    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  6    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  6    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  6    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  6    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  6    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  6    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  6    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  6    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  6    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  6    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  6    30     2 unused_2 bit (9) unaligned,
  6    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  6    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  6    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  6    34     2 end_of_kst bit (36);
  6    35 
  6    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  6    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  6    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  6    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  6    40     2 entryp ptr unaligned,				/* branch pointer */
  6    41 						/* See WARNING below for requirements to use entryp. */
  6    42     2 uid bit (36) aligned,				/* unique identifier */
  6    43     2 access_information unaligned,
  6    44       3 dtbm bit (36),				/* date time branch modified */
  6    45       3 extended_access bit (33),			/* extended access from the branch */
  6    46       3 access bit (3),				/* rew */
  6    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  6    48     2 pad1 bit (3) unaligned,
  6    49     2 flags unaligned,
  6    50       3 dirsw bit (1),				/* directory switch */
  6    51       3 allow_write bit (1),				/* set if initiated with write permission */
  6    52       3 priv_init bit (1),				/* privileged initiation */
  6    53       3 tms bit (1),				/* transparent modification switch */
  6    54       3 tus bit (1),				/* transparent usage switch */
  6    55       3 tpd bit (1),				/* transparent paging device switch */
  6    56       3 audit bit (1),				/* audit switch */
  6    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  6    58       3 pad bit (3),
  6    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  6    60 
  6    61 
  6    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    63 /*							       */
  6    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  6    65 /* entry associated with the kst entry, you must first validate its value    */
  6    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  6    67 /* the containing directory.  The containing directory must remain locked    */
  6    68 /* during the entire period when kste.entryp and the directory entry are     */
  6    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  6    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  6    71 /* directory since the dir entry could have been moved within the directory  */
  6    72 /* by another processor.					       */
  6    73 /*							       */
  6    74 /* If you only need a pointer to the directory containing the associated     */
  6    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  6    76 /*    pointer (kste.entryp, 0)				       */
  6    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  6    78 /*							       */
  6    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    80 
  6    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      595 
      596  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  7     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7     8*     Add the support for subvolumes
  7     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  7    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  7    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  7    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  7    14*     Added inconsistent_dbm bit for determining the status of volume
  7    15*     dumper bit maps.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18      dcl	   pvt$array	      aligned external;
  7    19      dcl	   pvt$max_n_entries      fixed bin external;
  7    20 
  7    21      dcl	   pvt_arrayp	      ptr;
  7    22      dcl	   pvtep		      ptr;
  7    23 
  7    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  7    25 
  7    26      dcl	   1 pvte		      based (pvtep) aligned,
  7    27 
  7    28 	     2 pvid	      bit (36),		/* physical volume ID */
  7    29 
  7    30 	     2 lvid	      bit (36),		/* logical volume ID */
  7    31 
  7    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  7    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  7    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  7    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  7    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  7    37 	     2 pad3	      bit (2) unaligned,
  7    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  7    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  7    40 
  7    41 
  7    42 
  7    43 	     2 devname	      char (4),		/* device name */
  7    44 
  7    45 	     (2 device_type	      fixed bin (8),	/* device type */
  7    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  7    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  7    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  7    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  7    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  7    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  7    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  7    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  7    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  7    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  7    56 	     2 scav_check_address
  7    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  7    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  7    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  7    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  7    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  7    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  7    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  7    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  7    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  7    66 
  7    67 
  7    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  7    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  7    70 
  7    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  7    72 
  7    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  7    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  7    75 
  7    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  7    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  7    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  7    79 	     2 records_per_cyl    fixed bin,
  7    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  7    81 	     2 sv_name            char (2) aligned,
  7    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  7    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  7    84 
  7    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  7    86 	     2 pad2	      bit (18) unaligned,
  7    87 
  7    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  7    89 
  7    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  7    91 
  7    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  7    93 
  7    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  7    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  7    96 
  7    97 
  7    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  7    99 
  7   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  7   101 
  7   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  7   103 
  7   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  7   105 
  7   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  7   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  7   108 
  7   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  7   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  7   111 
  7   112 
  7   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  7   114 	   VOLMAP_ASYNC_READ      init (1),
  7   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  7   116 
  7   117 
  7   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      596 
      597  /*	BEGIN INCLUDE FILE ... signaller_stack.incl.pl1 ... Created Feb 79 by D.Spector */
  8     2 
  8     3 /*	This file matches signaller_stack.incl.alm and is currently used only by verify_lock */
  8     4 
  8     5 declare	1 signaller_stack based unaligned,
  8     6 	  2 pad (8) bit (36),		/* Make machine conditions 0 mod 16 */
  8     7 	  2 mach_cond (48) bit (36),		/* Machine conditions */
  8     8 	  2 mc_ptr ptr aligned,		/* Pointer to machine conditions */
  8     9 	  2 null_ptr ptr aligned,		/* Null pointer */
  8    10 	  2 string_descriptor bit (36),	/* Condition name descriptor */
  8    11 	  2 ptr_descriptor bit (36),		/* M.C. ptr descriptor */
  8    12 	  2 arglist (18) bit (36),		/* Arg list for call to signal */
  8    13 	  2 signal_string char (32),		/* Condition name */
  8    14 	  2 on_unit (16) bit (36),		/* Must be at 128 in stack frame */
  8    15 	  2 history_registers (128) bit (36);
  8    16 
  8    17 /* on_unit must start at 128 because trap_caller_caller_ sets up a stack frame
  8    18*   assuming this to be so.  Similarly mach_cond must start at 48. */
  8    19 
  8    20 /*	END INCLUDE FILE ... signaller_stack.incl.pl1 ... */
      597 
      598  /*  START OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3      dcl	   stock_segp	      ptr;
  9     4      dcl	   record_stockp	      ptr;
  9     5      dcl	   vtoce_stockp	      ptr;
  9     6      dcl	   stock_seg$	      ext;
  9     7 
  9     8      dcl	   n_in_record_stock      fixed bin;
  9     9      dcl	   n_volmap_pages	      fixed bin;
  9    10      dcl	   n_in_vtoce_stock	      fixed bin;
  9    11 
  9    12 
  9    13      dcl	   1 stock_seg	      aligned based (stock_segp),
  9    14 
  9    15 	     2 meters	      aligned like rsmeters,
  9    16 
  9    17 	     2 record_stock_entries fixed bin,		/* Number of entries in a record stock */
  9    18 	     2 vtoce_stock_entries fixed bin,		/* Number of entries in a VTOCE stock */
  9    19 	     2 record_stock_size  fixed bin,		/* Size of a record stock in words */
  9    20 	     2 vtoce_stock_size   fixed bin,		/* Size of a VTOCE stock in words */
  9    21 	     2 n_stock_entries    fixed bin,		/* Number of stocks of each type */
  9    22 	     2 record_stock_arrayp ptr,		/* Record stock region */
  9    23 	     2 vtoce_stock_arrayp ptr;		/* VTOCE stock region */
  9    24 
  9    25 
  9    26      dcl	   1 record_stock	      aligned based (record_stockp),
  9    27 
  9    28 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  9    29 
  9    30 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number of addresses in stock */
  9    31 	     2 n_volmap_pages     fixed bin (18) uns unal,/* Number of pages in Volume Map */
  9    32 
  9    33 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number addresses currently free */
  9    34 	     2 n_os_in_stock      fixed bin (18) uns unal,/* Number addresses currently out-of-service */
  9    35 
  9    36 	     2 low_threshold      fixed bin (18) uns unal,/* Low threshold for withdrawing from volmap */
  9    37 	     2 high_threshold     fixed bin (18) uns unal,/* High threshold for depositing to volmap */
  9    38 
  9    39 	     2 target	      fixed bin (18) uns unal,/* Target for stock */
  9    40 	     2 stock_offset	      bit (18) unal,	/* Offset of stock in this structure */
  9    41 
  9    42 	     2 n_words_in_stock   fixed bin (18) uns unal,/* Number of words = Number of entries / 2 */
  9    43 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  9    44 
  9    45 	     2 old_volmap_page    (3) aligned,		/* N_OLD_VOLMAP_PAGES (cif) */
  9    46 	       3 last	      fixed bin (18) uns unal,/* Roving pointer */
  9    47 	       3 pad	      bit (18) unal,
  9    48 
  9    49 	     2 volmap_page	      (n_volmap_pages refer (record_stock.n_volmap_pages)) aligned,
  9    50 	       3 n_free	      fixed bin (18) uns unal,/* Number free records in this volmap page */
  9    51 	       3 baseadd	      fixed bin (17) unal,	/* First record address described by this page */
  9    52 
  9    53 	     2 stock	      (n_in_record_stock refer (record_stock.n_in_stock)) bit (18) unal; /* Stock array of addresses */
  9    54 						/* bit 0 ON => out-of-service */
  9    55 
  9    56 
  9    57      dcl	   1 vtoce_stock	      aligned based (vtoce_stockp),
  9    58 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  9    59 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number indices in stock */
  9    60 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number indices currently free */
  9    61 	     2 target	      fixed bin (18) uns unal,/* Target when withdrawing/depositing */
  9    62 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  9    63 	     2 stock	      (n_in_vtoce_stock refer (vtoce_stock.n_in_stock)) fixed bin (17) unal; /* Stock array of VTOCE indices */
  9    64 
  9    65 
  9    66      dcl	   1 rsmeters	      aligned based,
  9    67 
  9    68 	     2 async_read_calls   fixed bin (35),	/* Number of asynchronous read attempts */
  9    69 	     2 async_page_reads   fixed bin (35),	/* Number of times page read was required */
  9    70 	     2 async_post_io_calls fixed bin (35),	/* Number of times read or write posted */
  9    71 	     2 deposit_calls      fixed bin (35),	/* Number of times deposit called */
  9    72 	     2 async_post_io_time fixed bin (71),	/* CPU time posting I/Os (interrupt side) */
  9    73 	     2 deposit_time	      fixed bin (71),	/* CPU time in deposit (call side) */
  9    74 	     2 low_thresh_detected fixed bin (35),	/* Number of times stock below low threshold */
  9    75 	     2 high_thresh_detected fixed bin (35),	/* Number of times stock above high threshold */
  9    76 	     2 low_thresh_fails   fixed bin (35),	/* Number of times no records in volmap */
  9    77 	     2 withdraw_stock_steps fixed bin (35),	/* Number steps thru stock in withdraw */
  9    78 	     2 withdraw_stock_losses fixed bin (35),	/* Number lockless losses */
  9    79 	     2 n_withdraw_attempt fixed bin (35),	/* Number attempts to withdraw a page */
  9    80 	     2 n_withdraw_range   fixed bin (35),	/* Number attempts to withdraw within range */
  9    81 	     2 n_pages_withdraw_stock fixed bin (35),	/* Number pages withdrawn from stock */
  9    82 	     2 n_pages_withdraw_async fixed bin (35),	/* Number pages withdrawn from volmap */
  9    83 	     2 n_v_withdraw_attempts fixed bin (35),	/* Number attempts to withdraw from volmap */
  9    84 	     2 withdraw_volmap_steps fixed bin (35),	/* Number steps thru volmap in withdraw */
  9    85 	     2 deposit_stock_steps fixed bin (35),	/* Number steps thru stock in deposit */
  9    86 	     2 deposit_stock_losses fixed bin (35),	/* Number lockless losses */
  9    87 	     2 n_deposit_attempt  fixed bin (35),	/* Number attempts to deposit a page */
  9    88 	     2 n_pages_deposit_stock fixed bin (35),	/* Number pages deposited to stock */
  9    89 	     2 n_pages_deposit_volmap fixed bin (35),	/* Number pages deposited to volmap */
  9    90 	     2 n_v_deposit_attempts fixed bin (35),	/* Number attempts to deposit to volmap */
  9    91 	     2 reset_os_calls     fixed bin (35),	/* Number calls to reset_os */
  9    92 	     2 reset_os_losses    fixed bin (35),	/* Number lockless losses */
  9    93 	     2 withdraw_calls     fixed bin (35),	/* Number calls to withdraw */
  9    94 	     2 withdraw_time      fixed bin (71),	/* CPU time in withdraw (page-fault) */
  9    95 	     2 pc_deposit_time    fixed bin (71),	/* CPU time in pc_deposit */
  9    96 	     2 pc_deposit_calls   fixed bin (35),	/* Number calls to pc_deposit */
  9    97 	     2 pc_deposit_pages   fixed bin (35),	/* Number pages deposited by pc_deposit */
  9    98 	     2 get_free_vtoce_calls fixed bin (35),	/* Number calls to get_free_vtoce */
  9    99 	     2 return_free_vtoce_call fixed bin (35),	/* Number calls to return_free_vtoce */
  9   100 	     2 deposit_vstock_calls fixed bin (35),	/* Number attempts to deposit to vtoce stock */
  9   101 	     2 deposit_vstock_fails fixed bin (35),	/* Number times deposit failed */
  9   102 	     2 withdraw_vstock_calls fixed bin (35),	/* Number attempts to withdraw from vtoce stock */
  9   103 	     2 withdraw_vstock_fails fixed bin (35),	/* Number times withdraw failed */
  9   104 	     2 deposit_vtoc_map fixed bin (35),		/* Number times vtoce deposited to map */
  9   105 	     2 withdraw_check_scav fixed bin (35),	/* Number times withdraw checked an address for scavenge */
  9   106 	     2 withdraw_conflict fixed bin (35),	/* Number times conflict found */
  9   107 	     2 pad (11)	      fixed bin (35);
  9   108 	
  9   109 
  9   110      dcl	   N_OLD_VOLMAP_PAGES     fixed bin init (3) int static options (constant);
  9   111      dcl	   DEFAULT_N_IN_RECORD_STOCK fixed bin init (104) int static options (constant);
  9   112      dcl	   DEFAULT_N_IN_VTOCE_STOCK fixed bin init (10) int static options (constant);
  9   113 
  9   114 
  9   115 /*  END OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      598 
      599  /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
 10     2 
 10     3 /* This include file has an ALM version, keep 'em in sync. */
 10     4 
 10     5 /* format: off */
 10     6 
 10     7 /* Modified January 1984 by Paul Farley to add an array of entry values
 10     8*   to be examined by display_cpu_error. */
 10     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
 10    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
 10    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
 10    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
 10    13*		also changed some codes to "SB_unused_NN" - see line comments */
 10    14 
 10    15 /* In the future, these will be the only constants needed in this include
 10    16*file.  They are the binary data class strings for messages in the new format
 10    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
 10    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
 10    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
 10    20 
 10    21 dcl (						/* include file name */
 10    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
 10    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
 10    24 SB_mos_data_class		init ("mos"),		/* scr */
 10    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
 10    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
 10    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
 10    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
 10    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
 10    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
 10    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
 10    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
 10    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
 10    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
 10    35 ) static internal char (16) varying options (constant);
 10    36 
 10    37 
 10    38 /************************
 10    39*Once the syserr$binary is replaced with something that takes real data classes
 10    40*and all system modules and tools are upgraded to use the new interface, the
 10    41*rest of this include file may be discarded.
 10    42*************************/
 10    43 
 10    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
 10    45*   extended at any time. */
 10    46 
 10    47 dcl (
 10    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
 10    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
 10    50 SB_io_err		init (3),		SBL_io_err	init (5),
 10    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
 10    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
 10    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
 10    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
 10    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
 10    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
 10    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
 10    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
 10    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
 10    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
 10    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
 10    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
 10    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
 10    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
 10    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
 10    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
 10    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
 10    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
 10    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
 10    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
 10    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
 10    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
 10    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
 10    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
 10    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
 10    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
 10    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
 10    78   ) internal static options (constant) fixed bin;
 10    79 
 10    80 
 10    81 /* The following array is a mapping of the old syserr$binary codes into the
 10    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
 10    83*the binary data codes stored in the wired syserr log (see above) into the data
 10    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
 10    85*is also used by syserr_log_util_ to translate the data classes back into the
 10    86*corresponding binary code (for tools not yet upgraded to deal with the new
 10    87*format log messages). */
 10    88 
 10    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
 10    90 	init (	"io_status",		/* 1 */
 10    91 		"hwfault",		/* 2 */
 10    92 		"io_status",		/* 3 */
 10    93 		"unused_4",		/* 4 */
 10    94 		"mos",			/* 5 */
 10    95 
 10    96 		"unused_6",		/* 6 */
 10    97 		"unused_7",		/* 7 */
 10    98 		"unused_8",		/* 8 */
 10    99 		"unused_9",		/* 9 */ 
 10   100 		"unused_10",		/* 10 */
 10   101 
 10   102 		"segdamage",		/* 11 */
 10   103 		"unused_12",		/* 12 */
 10   104 		"segdamage",		/* 13 */
 10   105 		"unused_14",		/* 14 */
 10   106 		"unused_15",		/* 15 */
 10   107 
 10   108 		"segdamage",		/* 16 */
 10   109 		"voldamage",		/* 17 */
 10   110 		"unused_18",		/* 18 */
 10   111 		"mdc_del_uidpath",		/* 19 */
 10   112 		"io_status",		/* 20 */
 10   113 
 10   114 		"mmdam",			/* 21 */
 10   115 		"hwfault",		/* 22 */
 10   116 		"io_status",		/* 23 */
 10   117 		"mpc_poll",		/* 24 */
 10   118 		"fnp_poll",		/* 25 */
 10   119 
 10   120 		"config_deck",		/* 26 */
 10   121 		"vtoce",			/* 27 */
 10   122 		"access_audit",		/* 28 */
 10   123 		"unused_29",		/* 29 */
 10   124 		"unused_30",		/* 30 */
 10   125 		"unused_31",		/* 31 */
 10   126 		"unused_32",		/* 32 */
 10   127 		"unused_33",		/* 33 */
 10   128 		"unused_34",		/* 34 */
 10   129 		"ibm3270_mde",		/* 35 */
 10   130 		"unused_36"		/* 36 */
 10   131 	);
 10   132 
 10   133 
 10   134 /* format: on */
 10   135 
 10   136 /* These constants are used by various tools which analyze syserr messages and
 10   137*still call the old interface "syserr_log_util_". */
 10   138 
 10   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
 10   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
 10   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
 10   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
 10   143 
 10   144      dcl	   display_cpu_error_binary_defs (2) init (
 10   145 			      2,			/** SB_hw_fault */
 10   146 			      22			/** SB_verify_lock */
 10   147 			      ) internal static options (constant) fixed bin;
 10   148 
 10   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      599 
      600  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 11     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 11     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 11     4 
 11     5 /* This include file has an ALM version.  Keep 'em in sync! */
 11     6 
 11     7 dcl (
 11     8 
 11     9 /* The following constants define the message action codes.  This indicates
 11    10*how a message is to be handled.  */
 11    11 
 11    12      SYSERR_CRASH_SYSTEM	init (1),			
 11    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 11    14 
 11    15      SYSERR_TERMINATE_PROCESS	init (2),
 11    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 11    17 
 11    18      SYSERR_PRINT_WITH_ALARM	init (3),
 11    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 11    20 
 11    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 11    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 11    23 
 11    24      SYSERR_LOG_OR_PRINT	init (4),
 11    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 11    26 
 11    27      SYSERR_LOG_OR_DISCARD	init (5),
 11    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 11    29 
 11    30 
 11    31 /* The following constants are added to the normal severities to indicate
 11    32*different sorting classes of messages.  */
 11    33 
 11    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 11    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 11    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 11    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 11    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 11    39 	) fixed bin internal static options (constant);
 11    40 
 11    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      600 
      601  
 12     2 /* Begin include file ...... syserr_fault_msg.incl.pl1
 12     3*	Modified 1985-02-21, EJ Sharpe: changed mach_cond to be "like mc"
 12     4*	Modified 8/12/76 by Noel I. Morris	*/
 12     5 
 12     6 
 12     7 /* This include file defines the format of the syserr message
 12     8*   generated on faults handled by various modules.
 12     9*NOTE: program must also include "mc". */
 12    10 
 12    11 dcl  fmsgp ptr;					/* pointer to structure */
 12    12 
 12    13 dcl 1 fault_msg based (fmsgp) aligned,
 12    14     2 mach_cond like mc,				/* machine conditions */
 12    15     2 hist_reg (0:127) bit (36);			/* history registers */
 12    16 		/* someday the hist_reg should be increased to 256 wds to accomodate all DPS8 data */
 12    17 
 12    18 /* End of include file ...... syserr_fault_msg.incl.pl1 */
 12    19 
      601 
      602  /*  */
 13     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
 13     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
 13     4 /* Modified 07/07/76 by Morris for fault register data */
 13     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
 13     6 /* Modified '82 to make values constant */
 13     7 
 13     8 /* words 0-15 pointer registers */
 13     9 
 13    10 dcl  mcp ptr;
 13    11 
 13    12 dcl 1 mc based (mcp) aligned,
 13    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
 13    14    (2 regs,					/* registers */
 13    15       3 x (0:7) bit (18),				/* index registers */
 13    16       3 a bit (36),					/* accumulator */
 13    17       3 q bit (36),					/* q-register */
 13    18       3 e bit (8),					/* exponent */
 13    19       3 pad1 bit (28),
 13    20       3 t bit (27),					/* timer register */
 13    21       3 pad2 bit (6),
 13    22       3 ralr bit (3),				/* ring alarm register */
 13    23 
 13    24     2 scu (0:7) bit (36),
 13    25 
 13    26     2 mask bit (72),				/* mem controller mask at time of fault */
 13    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
 13    28     2 errcode fixed bin (35),				/* fault handler's error code */
 13    29     2 fim_temp,
 13    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
 13    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
 13    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
 13    33     2 fault_reg bit (36),				/* fault register */
 13    34     2 pad2 bit (1),
 13    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
 13    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
 13    37     2 fault_time bit (54),				/* time of fault */
 13    38 
 13    39     2 eis_info (0:7) bit (36)) unaligned;
 13    40 
 13    41 
 13    42 dcl (apx fixed bin init (0),
 13    43      abx fixed bin init (1),
 13    44      bpx fixed bin init (2),
 13    45      bbx fixed bin init (3),
 13    46      lpx fixed bin init (4),
 13    47      lbx fixed bin init (5),
 13    48      spx fixed bin init (6),
 13    49      sbx fixed bin init (7)) internal static options (constant);
 13    50 
 13    51 
 13    52 
 13    53 
 13    54 dcl  scup ptr;
 13    55 
 13    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
 13    57 
 13    58 
 13    59 /*	WORD (0)		*/
 13    60 
 13    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
 13    62       3 prr bit (3),				/* procedure ring register */
 13    63       3 psr bit (15),				/* procedure segment register */
 13    64       3 p bit (1),					/* procedure privileged bit */
 13    65 
 13    66     2 apu,					/* APPENDING UNIT STATUS */
 13    67       3 xsf bit (1),				/* ext seg flag - IT modification */
 13    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
 13    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
 13    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
 13    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
 13    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
 13    73       3 dsptw bit (1),				/* Fetch of DSPTW */
 13    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
 13    75       3 sdwp bit (1),				/* Fetch of SDW paged */
 13    76       3 ptw bit (1),				/* Fetch of PTW */
 13    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
 13    78       3 fap bit (1),				/* Fetch of final address paged */
 13    79       3 fanp bit (1),				/* Fetch of final address non-paged */
 13    80       3 fabs bit (1),				/* Fetch of final address absolute */
 13    81 
 13    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
 13    83 
 13    84 
 13    85 /*	WORD (1)		*/
 13    86 
 13    87     2 fd,						/* FAULT  DATA */
 13    88       3 iro bit (1),				/* illegal ring order */
 13    89       3 oeb bit (1),				/* out of execute bracket */
 13    90       3 e_off bit (1),				/* no execute */
 13    91       3 orb bit (1),				/* out of read bracket */
 13    92       3 r_off bit (1),				/* no read */
 13    93       3 owb bit (1),				/* out of write bracket */
 13    94       3 w_off bit (1),				/* no write */
 13    95       3 no_ga bit (1),				/* not a gate */
 13    96       3 ocb bit (1),				/* out of call bracket */
 13    97       3 ocall bit (1),				/* outward call */
 13    98       3 boc bit (1),				/* bad outward call */
 13    99       3 inret bit (1),				/* inward return */
 13   100       3 crt bit (1),				/* cross ring transfer */
 13   101       3 ralr bit (1),				/* ring alarm register */
 13   102       3 am_er bit (1),				/* associative memory fault */
 13   103       3 oosb bit (1),				/* out of segment bounds */
 13   104       3 paru bit (1),				/* processor parity upper */
 13   105       3 parl bit (1),				/* processor parity lower */
 13   106       3 onc_1 bit (1),				/* op not complete type 1 */
 13   107       3 onc_2 bit (1),				/* op not complete type 2 */
 13   108 
 13   109     2 port_stat,					/* PORT  STATUS */
 13   110       3 ial bit (4),				/* illegal action lines */
 13   111       3 iac bit (3),				/* illegal action channel */
 13   112       3 con_chan bit (3),				/* connect channel */
 13   113 
 13   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
 13   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
 13   116 
 13   117 
 13   118 /*	WORD (2)		*/
 13   119 
 13   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
 13   121       3 trr bit (3),				/* temporary ring register */
 13   122       3 tsr bit (15),				/* temporary segment register */
 13   123 
 13   124     2 pad2 bit (9),
 13   125 
 13   126     2 cpu_no bit (3),				/* CPU number */
 13   127 
 13   128     2 delta bit (6),				/* tally modification DELTA */
 13   129 
 13   130 
 13   131 /*	WORD (3)		*/
 13   132 
 13   133     2 word3 bit (18),
 13   134 
 13   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
 13   136       3 tsna,					/* Word 1 status */
 13   137         4 prn bit (3),				/* Word 1  PR  number */
 13   138         4 prv bit (1),				/* Word 1  PR  valid bit */
 13   139       3 tsnb,					/* Word 2  status */
 13   140         4 prn bit (3),				/* Word 2  PR  number */
 13   141         4 prv bit (1),				/* Word 2  PR  valid bit */
 13   142       3 tsnc,					/* Word 3  status */
 13   143         4 prn bit (3),				/* Word 3  PR  number */
 13   144         4 prv bit (1),				/* Word 3  PR  valid bit */
 13   145 
 13   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
 13   147 
 13   148 
 13   149 /* 	WORD (4)		*/
 13   150 
 13   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
 13   152 
 13   153     2 ir,						/* INDICATOR  REGISTERS */
 13   154       3 zero bit (1),				/* zero indicator */
 13   155       3 neg bit (1),				/* negative indicator */
 13   156       3 carry bit (1),				/* carryry indicator */
 13   157       3 ovfl bit (1),				/* overflow indicator */
 13   158       3 eovf bit (1),				/* eponent overflow */
 13   159       3 eufl bit (1),				/* exponent underflow */
 13   160       3 oflm bit (1),				/* overflow mask */
 13   161       3 tro bit (1),				/* tally runout */
 13   162       3 par bit (1),				/* parity error */
 13   163       3 parm bit (1),				/* parity mask */
 13   164       3 bm bit (1),					/* ^bar mode */
 13   165       3 tru bit (1),				/* truncation mode */
 13   166       3 mif bit (1),				/* multi-word instruction mode */
 13   167       3 abs bit (1),				/* absolute mode */
 13   168       3 hex bit (1),				/* hexadecimal exponent mode */
 13   169       3 pad bit (3),
 13   170 
 13   171 
 13   172 /*	WORD (5)		*/
 13   173 
 13   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
 13   175 
 13   176     2 cu,						/* CONTROL UNIT STATUS */
 13   177       3 rf bit (1),					/* on first cycle of repeat instr */
 13   178       3 rpt bit (1),				/* repeat instruction */
 13   179       3 rd bit (1),					/* repeat double instruction */
 13   180       3 rl bit (1),					/* repeat link instruciton */
 13   181       3 pot bit (1),				/* IT  modification */
 13   182       3 pon bit (1),				/* return type instruction */
 13   183       3 xde bit (1),				/* XDE from Even location */
 13   184       3 xdo bit (1),				/* XDE from Odd  location */
 13   185       3 poa bit (1),				/* operation preparation */
 13   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
 13   187       3 its bit (1),				/* ITS modification */
 13   188       3 if bit (1),					/* fault occured during instruction fetch */
 13   189 
 13   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
 13   191 
 13   192 
 13   193 /*	WORDS (6,7)	*/
 13   194 
 13   195     2 even_inst bit (36),				/* even instruction of faulting pair */
 13   196 
 13   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
 13   198 
 13   199 
 13   200 
 13   201 
 13   202 
 13   203 
 13   204 /*	ALTERNATE   SCU  DECLARATION		*/
 13   205 
 13   206 
 13   207 dcl 1 scux based (scup) aligned,
 13   208 
 13   209    (2 pad0 bit (36),
 13   210 
 13   211     2 fd,						/* GROUP II  FAULT DATA */
 13   212       3 isn bit (1),				/* illegal segment number */
 13   213       3 ioc bit (1),				/* illegal op  code  */
 13   214       3 ia_am bit (1),				/* illegal address - modifier */
 13   215       3 isp bit (1),				/* illegal slave  procedure */
 13   216       3 ipr bit (1),				/* illegal procedure */
 13   217       3 nea bit (1),				/* non existent address */
 13   218       3 oobb bit (1),				/* out of bounds */
 13   219       3 pad bit (29),
 13   220 
 13   221     2 pad2 bit (36),
 13   222 
 13   223     2 pad3a bit (18),
 13   224 
 13   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
 13   226       3 prn bit (3),				/* PR  number */
 13   227       3 prv bit (1),				/* PR  valid bit */
 13   228 
 13   229     2 pad3b bit (6)) unaligned,
 13   230 
 13   231     2 pad45 (0:1) bit (36),
 13   232 
 13   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
 13   234 
 13   235 
 13   236 
 13   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      602 
      603  /*  START OF:	vtoc_buffer.incl.pl1   November 1982      *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 14     2 
 14     3      
 14     4 
 14     5 /****^  HISTORY COMMENTS:
 14     6*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
 14     7*     audit(86-05-27,GDixon), install(86-07-18,MR12.0-1098):
 14     8*     Add the software read-alter-rewrite when needed for devices that do only
 14     9*     512 word IO.
 14    10*                                                   END HISTORY COMMENTS */
 14    11 
 14    12 
 14    13 dcl	   vtoc_buffer_seg$	      ext;
 14    14 
 14    15      dcl	   vtoc_buffer_segp	      ptr;
 14    16      dcl	   vtoc_buf_descp	      ptr;
 14    17      dcl	   vtoc_bufp	      ptr;
 14    18      dcl	   vtoc_buf_desc_arrayp   ptr;
 14    19      dcl	   vtoc_buf_arrayp	      ptr;
 14    20 
 14    21      dcl	   vtoc_buf_n_buffers     fixed bin;
 14    22      dcl	   vtoc_buf_n_buckets     fixed bin;
 14    23 
 14    24 
 14    25      dcl	   1 vtoc_buffer	      aligned based (vtoc_buffer_segp),
 14    26 
 14    27 	     2 lock,				/* Global lock for VTOC buffers */
 14    28 	       3 processid	      bit (36) aligned,	/* Owner */
 14    29 	       3 wait_event	      bit (36) aligned,	/* For lock */
 14    30 	       3 notify_sw	      bit (1) aligned,	/* ON => notify on unlock */
 14    31 
 14    32 	     2 n_bufs	      fixed bin,		/* Number of full VTOCE buffers */
 14    33 	     2 n_hash_buckets     fixed bin,		/* Number of hash table buckets */
 14    34 	     2 hash_mask	      bit (36) aligned,	/* Mask for hash algorithm */
 14    35 	     2 abs_addr	      fixed bin (24),	/* Absolute address of vtoc_buffer_seg */
 14    36 	     2 wait_event_constant fixed bin (36) uns unal,    /* Constant to add to part index to form wait event */
 14    37 	     2 buf_desc_offset    bit (18),		/* Offset of buf_desc */
 14    38 	     2 buf_offset	      bit (18),		/* Offset of buf */
 14    39 	     2 hash_table_offset  bit (18),		/* Offset of hash_table */
 14    40 	     2 search_index	      fixed bin,		/* Roving pointer for buffer selection */
 14    41 	     2 unsafe_pvtx	      fixed bin,		/* PVTE index with update in progress */
 14    42 	     2 scavenger_free_p_clock
 14    43                                     fixed bin (35),	/* Pseudo-Clock for scavenger-free-other-allocate race */
 14    44 	     2 meters,
 14    45 	       3 call_get	      fixed bin (35),	/* Calls to get_vtoce */
 14    46 	       3 call_put	      fixed bin (35),	/* Calls to put_vtoce */
 14    47 	       3 call_alloc	      fixed bin (35),	/* Calls to alloc_and_put_vtoce */
 14    48 	       3 call_free	      fixed bin (35),	/* Calls to free_vtoce */
 14    49 	       3 call_await	      fixed bin (35),	/* Calls to await_vtoce */
 14    50 	       3 steps	      fixed bin (35),	/* Steps through buffer allocation */
 14    51 	       3 skip_os	      fixed bin (35),	/* Skipped because out-of-service */
 14    52 	       3 skip_hot	      fixed bin (35),	/* Skipped because buffer hot */
 14    53 	       3 skip_wait	      fixed bin (35),	/* Skipped because notify_sw set */
 14    54 	       3 disk_reads	      fixed bin (35),	/* Number of same */
 14    55 	       3 disk_writes      fixed bin (35),	/* Number of same */
 14    56 	       3 get_buffer_calls fixed bin (35),	/* Number of calls to GET_BUFFER */
 14    57 	       3 get_buffer_hits  fixed bin (35),	/* Number times VTOCE in buffer */
 14    58 	       3 wait_calls	      fixed bin (35),	/* Number of calls to WAIT */
 14    59 	       3 wait_os	      fixed bin (35),	/* Number of times had to wait */
 14    60 	       3 scavenger_free_checks
 14    61                                     fixed bin (35),	/* Number of times had to check pseudo-clock */
 14    62 	       3 scavenger_free_losses
 14    63                                     fixed bin (35),	/* Number of times race lost between scavenger freeing and other allocate */
 14    64 	       3 soft_rar	      fixed bin (35),         /* Nunber of times a software read_alter_rewrite performed */
 14    65 
 14    66 	       3 pad (14)	      fixed bin (35),
 14    67 
 14    68 	     2 hash_table	      (vtoc_buf_n_buckets refer (vtoc_buffer.n_hash_buckets)) bit (18) aligned,
 14    69 
 14    70 
 14    71 	     2 buf_desc	      (vtoc_buf_n_buffers refer (vtoc_buffer.n_bufs)) aligned like vtoc_buf_desc,
 14    72 
 14    73 	     2 buffer	      (vtoc_buf_n_buffers refer (vtoc_buffer.n_bufs)) aligned like vtoce_buffer;
 14    74 
 14    75 
 14    76 
 14    77      dcl	   1 vtoc_buf_desc_array  (vtoc_buffer.n_bufs) aligned based (vtoc_buf_desc_arrayp) like vtoc_buf_desc;
 14    78 
 14    79 
 14    80      dcl	   1 vtoc_buf_desc	      aligned based (vtoc_buf_descp),
 14    81 	     2 pvtx	      fixed bin (17) unal,	/* PVTE index */
 14    82 	     2 vtocx	      fixed bin (17) unal,	/* VTOCE Index */
 14    83 	     2 parts_used	      bit (3) unal,		/* Mask of parts used or os */
 14    84 	     2 err	      bit (1) unal,		/* ON => I/O error on buffer */
 14    85 	     2 notify_sw	      bit (1) unal,		/* ON => notify requied on I/O completion */
 14    86 	     2 write_sw	      bit (1) unal,		/* ON => write I/O */
 14    87 	     2 os		      bit (1) unal,		/* ON => I/O in progress */
 14    88 	     2 ioq	      bit (1) unal,		/* ON => I/O has been requested */
 14    89 	     2 used	      bit (1) unal,		/* ON => this descriptor is in use */
 14    90 	     2 pad	      bit (9) unal,
 14    91 	     2 wait_index	      fixed bin (17) unal,	/* Buffer index for forming wait event */
 14    92 	     2 ht_thread	      bit (18) unal,	/* Offset of next entry in hash table */
 14    93 	     2 buf_rel	      bit (18) unal;	/* Offset of buffer in segment */
 14    94 
 14    95      dcl	   1 vtoce_buffer_array   (vtoc_buffer.n_bufs) aligned based (vtoc_buf_arrayp) like vtoce_buffer;
 14    96 
 14    97      dcl	   1 vtoce_buffer	      aligned based (vtoc_bufp),
 14    98 	     2 parts	      (3) aligned,
 14    99 	       3 words	      (64) bit (36) aligned;
 14   100 
 14   101 
 14   102      dcl	   N_PARTS_PER_VTOCE      fixed bin int static options (constant) init (3);
 14   103      dcl	   VTOCE_PART_SIZE	      fixed bin int static options (constant) init (64);
 14   104      dcl	   VTOCE_BUFFER_SIZE      fixed bin int static options (constant) init (3 * 64);
 14   105      dcl	   N_VTOCE_PER_RECORD     fixed bin int static options (constant) init (5);
 14   106      dcl	   N_SECTOR_PER_VTOCE     fixed bin int static options (constant) init (3);
 14   107 
 14   108 
 14   109 /*  END OF:	vtoc_buffer.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      603 
      604 
      605 /* BEGIN MESSAGE DOCUMENTATION
      606*
      607*   Message:
      608*   verify_lock: Crawlout stop specified on PARM card.
      609*
      610*   S:	$crash
      611*
      612*   T:	$run
      613*
      614*   M:	The system PARM card specified the CRWL parameter.
      615*   A process is attempting to crawl out.
      616*   This message will occur so that system programmers can take a dump.
      617*
      618*   A:	Take a dump.
      619*   Issuing the BCE go command
      620*   will cause the system to continue.
      621*
      622*   Message:
      623*   verify_lock: Crawlout with AST lock set.
      624*
      625*   S:	$crash
      626*
      627*   T:	$run
      628*
      629*   M:	A user process encountered
      630*   a condition while processing with the AST locked.
      631*   This condition may have been due to a
      632*   hardware or software failure.
      633*   $crashes
      634*
      635*   A:	$recover
      636*
      637*   Message:
      638*   verify_lock: Crawlout error on directory cleanup.
      639*
      640*   S:	$crash
      641*
      642*   T:	$run
      643*
      644*   M:	A process encountered a signalled condition
      645*   with one or more directories locked.
      646*   Before the system causes a crawlout,
      647*   it unlocks and salvages
      648*   all locked directories for the process.
      649*   This process of cleanup encountered an unrecoverable error.
      650*   $crashes
      651*
      652*   A:	$recover
      653*
      654*   Message:
      655*   verify_lock: block_lock_count XX, should be 0
      656*
      657*   S:	$crash
      658*
      659*   T:	$run
      660*
      661*   M:	A process has encountered
      662*   a condition in ring 0,
      663*   and is in the process of attempting a crawlout.
      664*   The system must unlock all locks
      665*   before it performs the crawlout;
      666*   all known locks have been unlocked
      667*   but the process' lock counter is still nonzero.
      668*   $err
      669*   $crashes
      670*
      671*   A:	$recover
      672*
      673*   Message:
      674*   verify_lock: NAME condition by PERS.PROJ
      675*
      676*   S:	$log
      677*
      678*   T:	$run
      679*
      680*   M:	User PERS.PROJ encountered a NAME condition in ring 0.
      681*   The system attempts to unlock and reset all ring 0 data bases
      682*   locked by the process.
      683*
      684*   A:     These messages almost always indicate benign errors in
      685*   the supervisor. They should be reported, nonetheless. They are
      686*   accompanied by the binary machine condition information.
      687*   This message is logged only when the condition occured while
      688*   some ring-0 lock was set.  One or more messages preceeding
      689*   this one will indicate which locks were held by the process
      690*   and forcibly reset.
      691*
      692*   Message:
      693*   verify_lock: Crawlout while in directory salvager, dir (UID,PTR).
      694*
      695*   S:	$log
      696*
      697*   T:	$run
      698*
      699*   M:	A process faulted while salvaging a dir on crawlout.
      700*
      701*   A:     $ignore
      702*
      703*   Message:
      704*   verify_lock: dir.modify PPPP WWWW ^^= processid.
      705*
      706*   S:	$crash
      707*
      708*   T:	$run
      709*
      710*   M:	A process is attempting to crawl out.
      711*   The system has discovered that a directory
      712*   which is marked locked to the process
      713*   has its "modify" field
      714*   not equal to the processid of the process.
      715*   $err
      716*   $crashes
      717*
      718*   A:	$recover
      719*
      720*   Message:
      721*   verify_lock: more than N directory locks locked to process.
      722*
      723*   S:     $crash
      724*
      725*   T:     $run
      726*
      727*   M:     The process held more dir locks than verify lock
      728*   could store for later salvaging. This indicates a logic error
      729*   in the supervisor.
      730*
      731*   A:    $crashes
      732*   $recover
      733*
      734*   Message:
      735*   verify_lock: Unlocking dir UUUUUUUUUUUU. Locked for READ_OR_WRITE {,salvage}.
      736*
      737*   S:	$log
      738*
      739*   T:	$run
      740*
      741*   M:	The directory with UID UUUUUUUUUUUU was found locked at crawl-out
      742*   time. It is salvaged and then unlocked.
      743*
      744*   A:	$inform
      745*
      746*   Message:
      747*   verify_lock: Salvaging dir PTR UID on crawlout.
      748*
      749*   S:	$log
      750*
      751*   T:	$run
      752*
      753*   M:	This message is displayed for each directory found locked on a
      754*   crawlout.  The online salvager will be called and the directory unlocked.
      755*
      756*   A:	$ignore
      757*
      758*   Message:
      759*   Terminating user process NAME: Fatal salvaging of process directory.
      760*
      761*   S:	$term
      762*
      763*   T:	$run
      764*
      765*   M:	A process is attempting to crawl out. The system discovered that
      766*   the process was interrupted while its process directory was locked, and has
      767*   salvaged the process directory. Salvaging the process directory may delete
      768*   critical process segments and cause the process to terminate, so the process
      769*   is terminated cleanly instead.
      770*
      771*   A:	$ignore
      772*
      773*   Message: 
      774*   verify_lock: COND condition by USER while salvaging directory.
      775*
      776*   S:	$announce
      777*
      778*   T:	$salvt
      779*
      780*   M:	A fault occurred while salvaging a directory found locked at
      781*   crawlout. This indicates a serious problem with the directory.
      782*
      783*   A:	$inform
      784*
      785*   Message:
      786*   verify_lock: Force unlocked VTOC Map lock (dskX_NN) on crawlout for PERSON.PROJECT.TAG
      787*
      788*   S:     $log
      789*
      790*   T:	$run
      791*
      792*   M:	The VTOC Map lock for the device indicated was found locked to the
      793*   process on crawlout. The lock has been reset, and the count of volume
      794*   inconsistencies has been incremented by one.
      795*
      796*   A:     Any free records or VTOCEs lost because of the crawlout can be
      797*   recovered by a volume salvage.
      798*
      799*   Message:
      800*   verify_lock: Force unlocked Volmap lock (dskX_NN) on crawlout for PERSON.PROJECT.TAG
      801*
      802*   S:     $log
      803*
      804*   T:	$run
      805*
      806*   M:	The Volmap Lock for the device indicated was found locked to a
      807*   process on crawlout. The lock has been reset, and the count of volume
      808*   inconsistencies for the device has been incremented by one.
      809*
      810*   A:     Any free records or VTOCEs lost because of the crawlout can
      811*   be recovered by a volume salvage.
      812*
      813*   Message:
      814*   verify_lock: Crawlout while masked.
      815*
      816*   S:	$crash
      817*
      818*   T:	$run
      819*
      820*   M:	$crashes
      821*
      822*   A:	$inform
      823*
      824*   Message:
      825*   verify_lock: Unlocked LOCK.
      826*
      827*   S:	$log
      828*
      829*   T:	$run
      830*
      831*   M:	The lock LOCK was found locked at crawlout and unlocked.
      832*
      833*   A:	$ignore
      834*
      835*   END MESSAGE DOCUMENTATION */
      836 
      837      end verify_lock;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0808.5  verify_lock.pl1                   >spec>install>1112>verify_lock.pl1
79           1    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
256          2    05/27/82  1525.6  dbm.incl.pl1                      >ldd>include>dbm.incl.pl1
272          3    09/07/83  1610.6  dm_journal_seg_.incl.pl1          >ldd>include>dm_journal_seg_.incl.pl1
593          4    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
594          5    11/29/83  0931.2  dir_lock_seg_.incl.pl1            >ldd>include>dir_lock_seg_.incl.pl1
595          6    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
596          7    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
597          8    03/08/79  1715.0  signaller_stack.incl.pl1          >ldd>include>signaller_stack.incl.pl1
598          9    10/25/82  1015.6  stock_seg.incl.pl1                >ldd>include>stock_seg.incl.pl1
599         10    03/15/85  0953.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
600         11    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
601         12    03/15/85  0953.1  syserr_fault_msg.incl.pl1         >ldd>include>syserr_fault_msg.incl.pl1
602         13    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
603         14    07/24/86  2051.8  vtoc_buffer.incl.pl1              >ldd>include>vtoc_buffer.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SBL_verify_lock                 000000 constant        fixed bin(17,0)          initial dcl 10-47 set ref 585*
SB_verify_lock                  000001 constant        fixed bin(17,0)          initial dcl 10-47 set ref 585*
SYSERR_CRASH_SYSTEM             000044 constant        fixed bin(17,0)          initial dcl 11-7 set ref 142* 169* 182* 187* 395*
                                                                                  530*
SYSERR_LOG_OR_PRINT             000047 constant        fixed bin(17,0)          initial dcl 11-7 set ref 194* 377* 405* 427* 479*
                                                                                  496* 554* 585*
SYSERR_PRINT_ON_CONSOLE         000040 constant        fixed bin(17,0)          initial dcl 11-7 set ref 456*
SYSERR_TERMINATE_PROCESS        000041 constant        fixed bin(17,0)          initial dcl 11-7 set ref 438*
What_did_we_unlock                     parameter       char                     packed unaligned dcl 552 set ref 549 554*
a_lock_ptr                             parameter       pointer                  dcl 540 ref 537 542
a_mcptr                                parameter       pointer                  dcl 216 ref 203 212 219 228 232
a_name                                 parameter       char                     packed unaligned dcl 215 ref 212 218 228 231
addr                                                   builtin function         dcl 132 ref 240 241 258 259 274 275 288 289 307 330
                                                                                  337 338 341 341 355 355 471 474 485 485 485 485
                                                                                  490 490 490 490 501 501 501 501 513 585 585
addrel                                                 builtin function         dcl 132 ref 581
ahd$search_rules_lock           000100 external static fixed bin(17,0)          dcl 118 set ref 513
array                     2     000100 automatic       structure                array level 2 dcl 61
auto_fault_msg                  000100 automatic       structure                level 1 dcl 578 set ref 585 585
baseptr                                                builtin function         dcl 132 ref 566
check_masked                    000303 automatic       bit(1)                   dcl 70 set ref 138* 190 208* 220* 233*
code                                   parameter       fixed bin(35,0)          dcl 324 in procedure "VERIFY_DIRECTORIES" set ref
                                                                                  321 329*
code                            000272 automatic       fixed bin(35,0)          dcl 67 in procedure "verify_lock" set ref 147* 168*
                                                                                  169 181* 182 431* 433* 438 438*
code                                   parameter       fixed bin(35,0)          dcl 305 in procedure "VERIFY_AST" set ref 302 311*
cond_name                              parameter       char                     packed unaligned dcl 576 in procedure
                                                                                  "make_syserr_message" set ref 573 585*
cond_name                       000273 automatic       char(32)                 packed unaligned dcl 68 in procedure "verify_lock"
                                                                                  set ref 137* 194* 197* 206* 218* 231*
condition_                      000010 constant        entry                    external dcl 81 ref 429
condition_name                         parameter       char                     packed unaligned dcl 452 set ref 447 456* 459*
continue_flag                          parameter       bit(1)                   dcl 453 ref 447
convert                                                builtin function         dcl 132 ref 479 479 496 496
count                           000100 automatic       fixed bin(17,0)          level 2 dcl 61 set ref 177* 399* 399 400 404 420 423
dbm                                    based           structure                level 1 dcl 2-6
dbm_seg$                        000122 external static fixed bin(17,0)          dcl 2-3 set ref 258
dbmp                            000364 automatic       pointer                  dcl 2-4 set ref 258* 259
debug_check                     000042 constant        entry                    external dcl 96 ref 142
devname                   3            based           char(4)                  level 2 dcl 7-26 set ref 479* 496*
dir                                    based           structure                level 1 dcl 4-11
dir_lock                               based           structure                level 1 dcl 5-46
dir_lock_all_dir_locks                 based           structure                array level 1 dcl 5-24 set ref 337
dir_lock_all_locksp             000322 automatic       pointer                  dcl 5-21 set ref 331* 337
dir_lock_all_readers                   based           bit(36)                  array dcl 5-25 set ref 338
dir_lock_all_readersp           000324 automatic       pointer                  dcl 5-21 set ref 332* 338
dir_lock_seg                           based           structure                level 1 dcl 5-16
dir_lock_seg$                   000114 external static fixed bin(17,0)          dcl 5-12 set ref 288 330
dir_lock_seg_header                    based           structure                level 1 dcl 5-30
dir_lock_segp                   000320 automatic       pointer                  dcl 5-14 set ref 288* 289 330* 331 332 334 338 341
                                                                                  341 347 355 355
dir_lockp                       000326 automatic       pointer                  dcl 5-45 set ref 337* 339 343 343 347 356 356 356
dir_read_lockers                       based           bit(36)                  array dcl 5-58 ref 347 351
dir_read_lockers_ptr            000330 automatic       pointer                  dcl 5-57 set ref 338* 347 351
dirs_locked                     000100 automatic       structure                level 1 dcl 61
dirx                            000434 automatic       fixed bin(17,0)          dcl 417 set ref 423* 424 433*
dm_journal                             based           structure                level 1 dcl 3-15
dm_journal_seg_$                000124 external static fixed bin(17,0)          dcl 3-4 set ref 274
dm_journal_segp                 000374 automatic       pointer                  dcl 3-6 set ref 274* 275
dm_page_entry                          based           structure                level 1 dcl 3-65
dm_per_journal                         based           structure                level 1 dcl 3-56
dp                              000316 automatic       pointer                  dcl 4-9 set ref 373* 377* 382 386 386 388* 388 400
                                                                                  427*
error_table_$salv_pdir_procterm 000076 external static fixed bin(35,0)          dcl 116 ref 438
event                     1            based           bit(36)                  level 2 dcl 1-12 set ref 543*
fault_msg                              based           structure                level 1 dcl 12-13
flags                     2            based           structure                level 2 in structure "lock" dcl 1-12 in procedure
                                                                                  "verify_lock"
flags                     1            based           structure                level 2 in structure "dir_lock" dcl 5-46
                                                                                  in procedure "verify_lock"
get_pvtx$cleanup                000040 constant        entry                    external dcl 95 ref 163
hbound                                                 builtin function         dcl 132 ref 347 395 395
header                                 based           structure                level 2 dcl 5-16
highest_in_use            4            based           fixed bin(17,0)          level 3 dcl 5-16 ref 334
hist_reg                 60     000100 automatic       bit(36)                  array level 2 dcl 578 set ref 584*
history_registers       150            based           bit(36)                  array level 2 packed packed unaligned dcl 8-5 ref
                                                                                  584
i                               000420 automatic       fixed bin(17,0)          dcl 325 set ref 334* 337 338*
info_ptr                               parameter       pointer                  dcl 450 ref 447
ioi_verify_lock                 000012 constant        entry                    external dcl 82 ref 156
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 7-26 set ref
                                                                                  479* 496*
kste                                   based           structure                level 1 dcl 6-36
kstep                           000332 automatic       pointer                  dcl 6-15 set ref 565* 566 566
kstsrch                         000052 constant        entry                    external dcl 101 ref 565
lock                                   based           bit(36)                  level 2 in structure "dm_journal" dcl 3-15
                                                                                  in procedure "VERIFY_DM_JOURNAL_SEG" set ref 275
lock                                   based           structure                level 1 dcl 1-12 in procedure "verify_lock"
lock                                   based           structure                level 2 in structure "vtoc_buffer" dcl 14-25
                                                                                  in procedure "verify_lock" set ref 241
lock$dir_lock_salvage           000030 constant        entry                    external dcl 90 ref 424
lock$dir_unlock_given_uid       000026 constant        entry                    external dcl 88 ref 410 442
lock$lock_fast                  000034 constant        entry                    external dcl 93 ref 341
lock$unlock_fast                000032 constant        entry                    external dcl 92 ref 246 262 278 294 355 517
lock_count                2            based           fixed bin(17,0)          level 2 dcl 5-46 ref 339 343 347 356
lock_data                              based           structure                level 2 dcl 2-6 set ref 259
lock_ptr                        000314 automatic       pointer                  dcl 1-11 set ref 241* 243 246* 249* 259* 260 262*
                                                                                  265* 275* 276 278* 281* 289* 291 294* 296* 307*
                                                                                  309 313* 513* 514 517* 519* 542* 543 543 543
locks_ptr                12            based           pointer                  level 3 dcl 5-16 ref 331
log_condition                   000304 automatic       bit(1)                   dcl 71 set ref 140* 194 209* 221* 234*
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 7-26 ref 479 479
                                                                                  496 496
mach_cond                10            based           bit(36)                  array level 2 in structure "signaller_stack" packed
                                                                                  packed unaligned dcl 8-5 in procedure
                                                                                  "verify_lock" ref 583
mach_cond                       000100 automatic       structure                level 2 in structure "auto_fault_msg" dcl 578
                                                                                  in procedure "make_syserr_message" set ref 583*
mask                            000506 automatic       fixed bin(71,0)          dcl 527 set ref 529* 530
max_readers               5            based           fixed bin(17,0)          level 3 dcl 5-16 ref 338 347
mc                                     based           structure                level 1 dcl 13-12
mc_ptr                                 parameter       pointer                  dcl 450 set ref 447 459 459*
mcptr                           000306 automatic       pointer                  dcl 73 in procedure "verify_lock" set ref 139* 194
                                                                                  197* 207* 219* 232*
mcptr                                  parameter       pointer                  dcl 577 in procedure "make_syserr_message" ref 573
                                                                                  581
modify                                 based           bit(36)                  level 2 dcl 4-11 set ref 386 386 388*
n_volmap_pages            1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 9-26
                                                                                  ref 492
notify_sw                 2            based           bit(1)                   level 3 packed packed unaligned dcl 1-12 ref 543
null                                                   builtin function         dcl 132 ref 139 178 194 207 382 459 566 568
on_line_salvager                000024 constant        entry                    external dcl 87 ref 433
p99                                    automatic       picture(2)               packed unaligned dcl 76 ref 479 479 496 496
page$unlock_volmap              000056 constant        entry                    external dcl 104 ref 495
page$write_volmap_page_unwired  000054 constant        entry                    external dcl 102 ref 493
page_fault_error                000000 stack reference condition                dcl 129 ref 385 392
pagex                           000311 automatic       fixed bin(17,0)          dcl 75 set ref 492* 493*
pds$block_lock_count            000072 external static fixed bin(17,0)          dcl 113 set ref 187 187*
pds$process_group_id            000066 external static char(32)                 dcl 110 set ref 194* 438* 456* 479* 496* 585*
pds$processid                   000070 external static bit(36)                  dcl 112 ref 243 260 276 291 309 343 351 386 476 488
                                                                                  514
pid                                    based           bit(36)                  level 2 dcl 1-12 ref 243 260 276 291 309 514 543
pmut$read_mask                  000062 constant        entry                    external dcl 106 ref 529
pmut$swap_sdw                   000060 constant        entry                    external dcl 105 ref 485 490 501
pvt$array                       000116 external static fixed bin(17,0)          dcl 7-18 set ref 471
pvt$n_entries                   000110 external static fixed bin(17,0)          dcl 125 ref 472
pvt_array                              based           structure                array level 1 dcl 7-24 set ref 474
pvt_arrayp                      000334 automatic       pointer                  dcl 7-21 set ref 471* 474
pvte                                   based           structure                level 1 dcl 7-26
pvtep                           000336 automatic       pointer                  dcl 7-22 set ref 474* 476 478* 479 479 479 479 479
                                                                                  482 482 488 490 490 491 493* 495* 496 496 496 496
                                                                                  496
pvtx                            000310 automatic       fixed bin(17,0)          dcl 74 set ref 472* 474*
pxss$notify                     000036 constant        entry                    external dcl 94 ref 543
readers_ptr              10            based           pointer                  level 3 dcl 5-16 ref 332
record_stock                           based           structure                level 1 dcl 9-26
record_stockp                   000340 automatic       pointer                  dcl 9-4 set ref 491* 492
reversion_                      000014 constant        entry                    external dcl 83 ref 435
rsmeters                               based           structure                level 1 dcl 9-66
rx                              000421 automatic       fixed bin(17,0)          dcl 326 set ref 347* 351*
salvage_sw                1(01)        based           bit(1)                   level 3 in structure "dir_lock" packed packed
                                                                                  unaligned dcl 5-46 in procedure "verify_lock" ref
                                                                                  356
salvage_sw                             parameter       bit(1)                   dcl 370 in procedure "VERIFY_DIR" set ref 366 375
                                                                                  405*
scs$sys_level                   000074 external static fixed bin(71,0)          dcl 115 ref 530
seg_fault_error                 000000 stack reference condition                dcl 128 ref 385 392
seg_lock                               based           structure                level 3 dcl 5-16 set ref 289 341 341 355 355
seg_ptr                   2     000100 automatic       pointer                  array level 3 dcl 61 set ref 178* 395 395 400* 424*
                                                                                  433*
segno                     0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-36 ref 566
segptr                          000130 automatic       pointer                  dcl 563 set ref 566* 568* 569
signaller_stack                        based           structure                level 1 unaligned dcl 8-5
ssptr                           000360 automatic       pointer                  dcl 579 set ref 581* 583 584
sst$astl                        000102 external static bit(36)                  dcl 120 set ref 307
subscriptrange                  000000 stack reference condition                dcl 130 ref 395 402
sv_name                  15            based           char(2)                  level 2 dcl 7-26 set ref 479* 496*
syserr                          000016 constant        entry                    external dcl 84 ref 142 169 182 187 194 377 388 395
                                                                                  405 427 456 479 496 530 554
syserr$binary                   000020 constant        entry                    external dcl 85 ref 585
syserr$error_code               000022 constant        entry                    external dcl 86 ref 438
syserr_seg_manager$verify_lock  000050 constant        entry                    external dcl 99 ref 149
tc_data$lock_error_severity     000106 external static fixed bin(17,0)          dcl 123 set ref 388*
tc_data$system_shutdown         000104 external static bit(1)                   dcl 121 ref 511
this_dir_locked                 000422 automatic       bit(1)                   dcl 327 set ref 336* 343* 351* 356
tsdw                            000312 automatic       fixed bin(71,0)          dcl 77 set ref 483* 485 485 499* 501 501
tty_lock$verify                 000046 constant        entry                    external dcl 98 ref 174
uid                             000435 automatic       bit(36)                  dcl 418 in procedure "SALVAGE_DIRECTORIES" set ref
                                                                                  424* 427* 442*
uid                                    based           bit(36)                  level 2 in structure "dir_lock" dcl 5-46
                                                                                  in procedure "verify_lock" set ref 356*
uid                                    parameter       bit(36)                  dcl 369 in procedure "VERIFY_DIR" set ref 366 373*
                                                                                  377* 404 405* 410*
uid                                    parameter       bit(36)                  dcl 562 in procedure "GET_SEG_PTR" set ref 559 565*
uid                       4     000100 automatic       bit(36)                  array level 3 in structure "dirs_locked" dcl 61
                                                                                  in procedure "verify_lock" set ref 179* 404*
unlock_occurred                 000305 automatic       bit(1)                   dcl 72 set ref 146* 156* 163* 174* 194 408* 484*
                                                                                  500* 555*
unspec                                                 builtin function         dcl 132 set ref 583* 583
vol_trouble_count        33            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 set ref
                                                                                  482* 482
volmap_abs_seg$                 000112 external static fixed bin(17,0)          dcl 126 set ref 485 485 490 490 501 501
volmap_lock              26            based           bit(36)                  level 2 dcl 7-26 ref 488
volmap_seg_sdw           22            based           fixed bin(71,0)          level 2 dcl 7-26 set ref 490 490
volmap_stock_ptr         30            based           pointer                  level 2 packed packed unaligned dcl 7-26 ref 491
vtoc_buf_desc                          based           structure                level 1 dcl 14-80
vtoc_buffer                            based           structure                level 1 dcl 14-25
vtoc_buffer_seg$                000120 external static fixed bin(17,0)          dcl 14-13 set ref 240
vtoc_buffer_segp                000342 automatic       pointer                  dcl 14-15 set ref 240* 241
vtoc_man$crawlout               000044 constant        entry                    external dcl 97 ref 245
vtoc_map_lock            27            based           bit(36)                  level 2 dcl 7-26 ref 476
vtoce_buffer                           based           structure                level 1 dcl 14-97
vtoce_stock_man$force_unlock    000064 constant        entry                    external dcl 107 ref 478
wc_ptr                                 parameter       pointer                  dcl 450 ref 447
write_locker              3            based           bit(36)                  level 2 dcl 5-46 ref 343
write_sw                               parameter       bit(1)                   dcl 371 set ref 366 405 405*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 11-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 11-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 11-7
DEFAULT_N_IN_RECORD_STOCK              internal static fixed bin(17,0)          initial dcl 9-111
DEFAULT_N_IN_VTOCE_STOCK               internal static fixed bin(17,0)          initial dcl 9-112
DIR_LOCK_SEG_EVENT                     internal static char(4)                  initial dcl 5-28
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 11-7
LOG                                    internal static fixed bin(17,0)          initial dcl 11-7
N_OLD_VOLMAP_PAGES                     internal static fixed bin(17,0)          initial dcl 9-110
N_PARTS_PER_VTOCE                      internal static fixed bin(17,0)          initial dcl 14-102
N_SECTOR_PER_VTOCE                     internal static fixed bin(17,0)          initial dcl 14-106
N_VTOCE_PER_RECORD                     internal static fixed bin(17,0)          initial dcl 14-105
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 10-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 10-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 10-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 10-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 10-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 10-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 10-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 10-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 10-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 10-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 10-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 10-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 10-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 10-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 10-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 10-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 10-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 10-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 10-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 10-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 10-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 10-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 10-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 10-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 10-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 10-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 10-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 10-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 10-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 10-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 10-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 10-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 10-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 10-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 10-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 10-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 10-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 10-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 10-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 10-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 10-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 10-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 10-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 10-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 10-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 10-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 10-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 10-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 10-47
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 11-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 11-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 11-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 7-113
VTOCE_BUFFER_SIZE                      internal static fixed bin(17,0)          initial dcl 14-104
VTOCE_PART_SIZE                        internal static fixed bin(17,0)          initial dcl 14-103
abx                                    internal static fixed bin(17,0)          initial dcl 13-42
apx                                    internal static fixed bin(17,0)          initial dcl 13-42
bbx                                    internal static fixed bin(17,0)          initial dcl 13-42
bpx                                    internal static fixed bin(17,0)          initial dcl 13-42
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 10-144
dm_page_entryp                         automatic       pointer                  dcl 3-9
dm_per_journal_array                   based           structure                array level 1 dcl 3-54
dm_per_journal_arrayp                  automatic       pointer                  dcl 3-8
dm_per_journalp                        automatic       pointer                  dcl 3-7
fmsgp                                  automatic       pointer                  dcl 12-11
kst                                    based           structure                level 1 dcl 6-18
kstp                                   automatic       pointer                  dcl 6-15
lbx                                    internal static fixed bin(17,0)          initial dcl 13-42
lpx                                    internal static fixed bin(17,0)          initial dcl 13-42
max_dm_pages                           automatic       fixed bin(17,0)          dcl 3-12
mcp                                    automatic       pointer                  dcl 13-10
n_dm_journals                          automatic       fixed bin(17,0)          dcl 3-11
n_in_record_stock                      automatic       fixed bin(17,0)          dcl 9-8
n_in_vtoce_stock                       automatic       fixed bin(17,0)          dcl 9-10
n_volmap_pages                         automatic       fixed bin(17,0)          dcl 9-9
pds$kstp                               external static pointer                  dcl 6-15
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 7-19
sbx                                    internal static fixed bin(17,0)          initial dcl 13-42
scu                                    based           structure                level 1 dcl 13-56
scup                                   automatic       pointer                  dcl 13-54
scux                                   based           structure                level 1 dcl 13-207
spx                                    internal static fixed bin(17,0)          initial dcl 13-42
stock_seg                              based           structure                level 1 dcl 9-13
stock_seg$                             external static fixed bin(17,0)          dcl 9-6
stock_segp                             automatic       pointer                  dcl 9-3
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 10-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 10-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 10-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 10-141
version_number_2                       internal static fixed bin(17,0)          initial dcl 4-84
vtoc_buf_arrayp                        automatic       pointer                  dcl 14-19
vtoc_buf_desc_array                    based           structure                array level 1 dcl 14-77
vtoc_buf_desc_arrayp                   automatic       pointer                  dcl 14-18
vtoc_buf_descp                         automatic       pointer                  dcl 14-16
vtoc_buf_n_buckets                     automatic       fixed bin(17,0)          dcl 14-22
vtoc_buf_n_buffers                     automatic       fixed bin(17,0)          dcl 14-21
vtoc_bufp                              automatic       pointer                  dcl 14-17
vtoce_buffer_array                     based           structure                array level 1 dcl 14-95
vtoce_stock                            based           structure                level 1 dcl 9-57
vtoce_stockp                           automatic       pointer                  dcl 9-5

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_NOTIFY                    002723 constant        entry                    internal dcl 537 ref 249 265 281 296 313 519
CONTINUE_VERIFY_LOCK            002202 constant        label                    dcl 442 ref 462
GET_SEG_PTR                     003010 constant        entry                    internal dcl 559 ref 373
LOOP_OVER_DIRS                  001350 constant        label                    dcl 334
LOOP_OVER_LOCKERS               001416 constant        label                    dcl 347
NOTE_UNLOCK                     002746 constant        entry                    internal dcl 549 ref 149 247 263 279 293 516
NO_MODIFY_CHECK                 001645 constant        label                    dcl 392 set ref 385
SALVAGE_DIRECTORIES             002011 constant        entry                    internal dcl 414 ref 185
VERIFY_AST                      001320 constant        entry                    internal dcl 302 ref 168
VERIFY_DBM                      001203 constant        entry                    internal dcl 253 ref 159
VERIFY_DIR                      001501 constant        entry                    internal dcl 366 ref 356
VERIFY_DIRECTORIES              001336 constant        entry                    internal dcl 321 ref 181
VERIFY_DIR_LOCK_SEG             001265 constant        entry                    internal dcl 285 ref 166
VERIFY_DM_JOURNAL_SEG           001233 constant        entry                    internal dcl 269 ref 161
VERIFY_MASKED                   002667 constant        entry                    internal dcl 524 ref 190
VERIFY_PVT_LOCKS                002306 constant        entry                    internal dcl 468 ref 152
VERIFY_SEARCH_RULES             002633 constant        entry                    internal dcl 508 ref 172
VERIFY_VTOC_BUFFERS             001144 constant        entry                    internal dcl 237 ref 154
condition                       001054 constant        entry                    external dcl 212
condition_nolog                 001111 constant        entry                    external dcl 228
make_syserr_message             003052 constant        entry                    internal dcl 573 ref 197 459
salvager_handler                002215 constant        entry                    internal dcl 447 ref 429 429
start                           000462 constant        label                    dcl 142 ref 210 222 235
unlock_return                   001732 constant        label                    dcl 405 ref 379 382
verify_lock                     000445 constant        entry                    external dcl 14
verify_lock_bad_dir             001027 constant        entry                    external dcl 203

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4016        4144    3236        4026
Length      4724    3236       126         544     557           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
verify_lock                         608 external procedure  is an external procedure.  
VERIFY_VTOC_BUFFERS                     internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_DBM                              internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_DM_JOURNAL_SEG                   internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_DIR_LOCK_SEG                     internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_AST                              internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_DIRECTORIES                      internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_DIR                          188 internal procedure  enables or reverts conditions, and is declared options(non_quick).  
on unit on line 385                  64 on unit               
on unit on line 395                  94 on unit               
SALVAGE_DIRECTORIES                     internal procedure  shares stack frame of external procedure verify_lock.  
salvager_handler                    100 internal procedure  is assigned to an entry variable.  
VERIFY_PVT_LOCKS                        internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_SEARCH_RULES                     internal procedure  shares stack frame of external procedure verify_lock.  
VERIFY_MASKED                           internal procedure  shares stack frame of external procedure verify_lock.  
CHECK_NOTIFY                            internal procedure  shares stack frame of external procedure verify_lock.  
NOTE_UNLOCK                             internal procedure  shares stack frame of external procedure verify_lock.  
GET_SEG_PTR                             internal procedure  shares stack frame of internal procedure VERIFY_DIR.  
make_syserr_message                 284 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
VERIFY_DIR               000130 segptr                      GET_SEG_PTR
make_syserr_message      000100 auto_fault_msg              make_syserr_message
                         000360 ssptr                       make_syserr_message
verify_lock              000100 dirs_locked                 verify_lock
                         000272 code                        verify_lock
                         000273 cond_name                   verify_lock
                         000303 check_masked                verify_lock
                         000304 log_condition               verify_lock
                         000305 unlock_occurred             verify_lock
                         000306 mcptr                       verify_lock
                         000310 pvtx                        verify_lock
                         000311 pagex                       verify_lock
                         000312 tsdw                        verify_lock
                         000314 lock_ptr                    verify_lock
                         000316 dp                          verify_lock
                         000320 dir_lock_segp               verify_lock
                         000322 dir_lock_all_locksp         verify_lock
                         000324 dir_lock_all_readersp       verify_lock
                         000326 dir_lockp                   verify_lock
                         000330 dir_read_lockers_ptr        verify_lock
                         000332 kstep                       verify_lock
                         000334 pvt_arrayp                  verify_lock
                         000336 pvtep                       verify_lock
                         000340 record_stockp               verify_lock
                         000342 vtoc_buffer_segp            verify_lock
                         000364 dbmp                        VERIFY_DBM
                         000374 dm_journal_segp             VERIFY_DM_JOURNAL_SEG
                         000420 i                           VERIFY_DIRECTORIES
                         000421 rx                          VERIFY_DIRECTORIES
                         000422 this_dir_locked             VERIFY_DIRECTORIES
                         000434 dirx                        SALVAGE_DIRECTORIES
                         000435 uid                         SALVAGE_DIRECTORIES
                         000506 mask                        VERIFY_MASKED

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
return_mac          tra_ext_1           bound_ck_signal     enable_op           ext_entry           ext_entry_desc
int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
condition_                    debug_check                   get_pvtx$cleanup              ioi_verify_lock
kstsrch                       lock$dir_lock_salvage         lock$dir_unlock_given_uid     lock$lock_fast
lock$unlock_fast              on_line_salvager              page$unlock_volmap
page$write_volmap_page_unwired                              pmut$read_mask                pmut$swap_sdw
pxss$notify                   reversion_                    syserr                        syserr$binary
syserr$error_code             syserr_seg_manager$verify_lock                              tty_lock$verify
vtoc_man$crawlout             vtoce_stock_man$force_unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
ahd$search_rules_lock         dbm_seg$                      dir_lock_seg$                 dm_journal_seg_$
error_table_$salv_pdir_procterm                             pds$block_lock_count          pds$process_group_id
pds$processid                 pvt$array                     pvt$n_entries                 scs$sys_level
sst$astl                      tc_data$lock_error_severity   tc_data$system_shutdown       volmap_abs_seg$
vtoc_buffer_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000444       137 000452       138 000455       139 000456       140 000460       142 000462       146 000520
    147 000521       149 000522       152 000544       154 000545       156 000546       159 000562       161 000563
    163 000564       166 000600       168 000601       169 000603       172 000625       174 000626       177 000642
    178 000643       179 000657       181 000671       182 000673       185 000715       187 000716       190 000743
    194 000746       197 001007       199 001023       203 001024       206 001037       207 001042       208 001044
    209 001046       210 001047       212 001050       218 001072       219 001100       220 001103       221 001105
    222 001106       228 001107       231 001127       232 001135       233 001140       234 001142       235 001143
    237 001144       240 001145       241 001150       243 001152       245 001155       246 001161       247 001170
    248 001177       249 001200       250 001202       253 001203       258 001204       259 001207       260 001211
    262 001214       263 001222       264 001227       265 001230       266 001232       269 001233       274 001234
    275 001237       276 001241       278 001244       279 001252       280 001261       281 001262       282 001264
    285 001265       288 001266       289 001271       291 001273       293 001276       294 001305       295 001314
    296 001315       297 001317       302 001320       307 001322       309 001325       311 001330       312 001332
    313 001333       314 001335       321 001336       329 001340       330 001341       331 001344       332 001346
    334 001350       336 001357       337 001360       338 001363       339 001370       341 001372       343 001403
    346 001414       347 001415       351 001427       353 001436       355 001440       356 001451       360 001475
    361 001477       366 001500       373 001506       375 001520       377 001524       379 001555       382 001556
    385 001563       386 001607       388 001616       392 001645       395 001647       399 001711       400 001713
    402 001724       404 001725       405 001732       408 001775       410 002000       412 002010       414 002011
    420 002012       423 002015       424 002023       427 002040       429 002070       431 002115       433 002116
    435 002131       438 002147       442 002202       444 002211       445 002213       447 002214       456 002230
    459 002260       462 002303       468 002306       471 002307       472 002312       474 002321       476 002325
    478 002331       479 002337       482 002421       483 002427       484 002431       485 002433       488 002450
    490 002455       491 002471       492 002474       493 002503       494 002514       495 002516       496 002525
    499 002607       500 002611       501 002613       504 002630       506 002632       508 002633       511 002634
    513 002640       514 002642       516 002645       517 002654       518 002663       519 002664       520 002666
    524 002667       529 002670       530 002677       533 002722       537 002723       542 002725       543 002730
    545 002745       549 002746       554 002757       555 003005       556 003007       559 003010       565 003012
    566 003027       568 003043       569 003045       573 003051       581 003065       583 003072       584 003075
    585 003110       589 003156


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
