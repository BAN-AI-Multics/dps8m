	COMPILATION LISTING OF SEGMENT scavenge_volume
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1026.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style3,idind30,indcomtxt */
       10 scavenge_volume:
       11      proc (Pvtep, Scavenger_blockp, Scavenger_Optionsp, Sc_metersp, Code);
       12 
       13 /*  The Volume Scavenger
       14*
       15*   Written July 1982 by J. Bongiovanni
       16*   Modified October 1982 by J. Bongiovanni for Filemap Checksum, fm_damaged
       17*   Modified May 1983 by E. N. Kittlitz for free_map/in-use conflict.
       18*   Modified August 1983 by E. N. Kittlitz for search_ast$check.
       19*   Modified 83-12-13 BIM for fault for debugging locking.
       20**/
       21 
       22 
       23 /****^  HISTORY COMMENTS:
       24*  1) change(86-10-23,Fawcett), approve(86-10-23,MCR7517),
       25*     audit(86-10-30,Beattie), install(86-11-03,MR12.0-1206):
       26*     Change Error Documentation to remove the word BOS.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 
       30 /*  Parameter  */
       31 
       32 dcl	Pvtep			ptr;		/* -> PVTE for volume */
       33 dcl	Scavenger_blockp		ptr;		/* -> scavenger block allocated for scavenge */
       34 dcl	Scavenger_Optionsp		ptr;		/* -> options for this scavenge */
       35 dcl	Sc_metersp		ptr;		/* -> metering cells */
       36 dcl	Code			fixed bin (35);	/* Error code */
       37 
       38 /*  Automatic  */
       39 
       40 dcl	base_vtocx		fixed bin;
       41 dcl	conflicts_unclaimed		fixed bin;
       42 dcl	1 copy_options		aligned like scavenger_options;
       43 dcl	damaged_vtoces		bit (MAX_VTOCE_PER_PACK) aligned;
       44 dcl	device_name		char (8);
       45 dcl	freed_vtoces		bit (MAX_VTOCE_PER_PACK) aligned;
       46 dcl	get_vtoce_errors		fixed bin;
       47 dcl	old_mask			fixed bin (71);
       48 dcl	p99			pic "99";
       49 dcl	ptp			ptr;
       50 dcl	ptwp			ptr;
       51 dcl	pvtx			fixed bin;
       52 dcl	restart_sw		bit (1) aligned;
       53 dcl	tsdw			fixed bin (71);
       54 dcl	vastep			ptr;
       55 dcl	vtoce_bitsp		ptr;
       56 dcl	vtoces_damaged		fixed bin;
       57 dcl	vtoces_damaged_by_me	fixed bin;
       58 
       59 /*  Static  */
       60 
       61 dcl	ALL_PARTS			bit (3) int static options (constant) init ("111"b);
       62 dcl	GET_VTOCE_ERROR_THRESHOLD	fixed bin int static options (constant) init (30);
       63 dcl	RLV_INITIALIZED		fixed bin int static options (constant) init (2);
       64 
       65 /*  Based  */
       66 
       67 dcl	1 file_map		aligned based,
       68 	  2 fm			(0:255) fixed bin (18) uns unal;
       69 dcl	1 Scavenger_Options		aligned like scavenger_options based (Scavenger_Optionsp);
       70 dcl	1 vtoce_bits		aligned based (vtoce_bitsp),
       71 	  2 pad			bit (base_vtocx) unaligned,
       72 	  2 remaining		bit (MAX_VTOCE_PER_PACK - base_vtocx) unaligned;
       73 
       74 /*  External  */
       75 
       76 dcl	active_hardcore_data$pdd_uid	bit (36) aligned external;
       77 dcl	active_hardcore_data$sl1_uid	bit (36) aligned external;
       78 dcl	error_table_$scavenge_aborted fixed bin (35) external;
       79 dcl	error_table_$vtoce_free	fixed bin (35) external;
       80 dcl	pds$process_group_id	char (32) ext static;
       81 dcl	pvt$root_lvid		bit (36) aligned external;
       82 dcl	sst$astap			ptr external;
       83 dcl	sst$checksum_filemap	fixed bin (35) external;
       84 dcl	sst$cmp			ptr external;
       85 dcl	sst$damaged_ct		fixed bin (35) external;
       86 dcl	1 sst$level		(0:3) aligned external,
       87 	  2 ausedp		bit (18) unaligned,
       88 	  2 no_aste		bit (18) unaligned;
       89 dcl	sst$pts			(0:3) fixed bin external;
       90 dcl	sys_info$initialization_state fixed bin external;
       91 dcl	volmap_abs_seg$		external;
       92 
       93 /*  Entry  */
       94 
       95 dcl	filemap_checksum_		entry (ptr, fixed bin, bit (36) aligned);
       96 dcl	fsout_vol			entry (fixed bin, fixed bin);
       97 dcl	lock$lock_ast		entry;
       98 dcl	lock$unlock_ast		entry;
       99 dcl	page$free_address_for_scavenge
      100 				entry (fixed bin, fixed bin (18));
      101 dcl	page$lock_volmap		entry (ptr);
      102 dcl	page$unlock_volmap		entry (ptr);
      103 dcl	pc$deposit_list		entry (fixed bin, fixed bin, ptr, fixed bin, ptr);
      104 dcl	pc$cleanup		entry (ptr);
      105 dcl	pmut$lock_ptl		entry (fixed bin (71), ptr);
      106 dcl	pmut$swap_sdw		entry (ptr, ptr);
      107 dcl	pmut$unlock_ptl		entry (fixed bin (71), ptr);
      108 dcl	priv_delete_vtoce		entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (35));
      109 dcl	pxss$relinquish_priority	entry;
      110 dcl	search_ast$check		entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (35))
      111 				returns (ptr);
      112 dcl	setfaults			entry (ptr, bit (1) aligned);
      113 dcl	syserr			entry options (variable);
      114 dcl	syserr$binary		entry options (variable);
      115 dcl	syserr$error_code		entry options (variable);
      116 dcl	tc_util$check_abort		entry (fixed bin (35));
      117 dcl	update_vtoce		entry (ptr);
      118 dcl	vtoc_man$free_vtoce_for_scavenge
      119 				entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      120 dcl	vtoc_man$get_vtoce		entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr, fixed bin (35));
      121 dcl	vtoc_man$put_vtoce		entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr, fixed bin (35));
      122 dcl	vtoc_man$read_ahead_vtoce	entry (bit (36) aligned, fixed bin, fixed bin, bit (3), fixed bin (35));
      123 
      124 declare	(addr, addrel, bin, bit, clock, convert, divide, fixed, hbound, index, null, ptr, rel, rtrim, size, stacq, substr,
      125 	unspec, mod)		builtin;
      126 
      127 
      128 
      129 	pvtep = Pvtep;
      130 	scavenger_blockp = Scavenger_blockp;
      131 	sc_metersp = Sc_metersp;
      132 	copy_options = Scavenger_Options;
      133 	Code = 0;
      134 
      135 
      136 	scavenger_datap = addr (scavenger_data$);
      137 	pvt_arrayp = addr (pvt$array);
      138 	pvtx = divide (bin (rel (pvtep)) - bin (rel (pvt_arrayp)), size (pvte), 17) + 1;
      139 	device_name = pvte.devname || "_" || convert (p99, pvte.logical_area_number) || rtrim (pvte.sv_name);
      140 
      141 
      142 	call pmut$swap_sdw (addr (volmap_abs_seg$), addr (pvte.volmap_seg_sdw));
      143 	vol_mapp = ptr (addr (volmap_abs_seg$), pvte.volmap_offset);
      144 	vtoc_mapp = ptr (vol_mapp, pvte.vtoc_map_offset);
      145 
      146 RESTART:
      147 	restart_sw = "0"b;
      148 
      149 	vtoces_damaged, vtoces_damaged_by_me = 0;
      150 	get_vtoce_errors = 0;
      151 	conflicts_unclaimed = 0;
      152 
      153 	unspec (freed_vtoces) = ""b;
      154 	unspec (damaged_vtoces) = ""b;
      155 
      156 	call lock$lock_ast;
      157 
      158 	if copy_options.fault_under_ast
      159 	then call FAULT ("AST Lock");
      160 
      161 	call page$lock_volmap (pvtep);
      162 	if copy_options.fault_under_volmap
      163 	then call FAULT ("VOLMAP Lock");
      164 
      165 	call COPY_VOLMAP;
      166 
      167 	pvte.deposit_to_volmap = "1"b;
      168 	call pmut$lock_ptl (old_mask, ptwp);
      169 	if copy_options.fault_under_pt
      170 	then call FAULT ("Global PTL");
      171 
      172 	pvte.scav_check_address = "1"b;
      173 	call COPY_STOCK;
      174 	call WALK_SST;
      175 	call pmut$unlock_ptl (old_mask, ptwp);
      176 	pvte.deposit_to_volmap = "0"b;
      177 
      178 	call page$unlock_volmap (pvtep);
      179 	call lock$unlock_ast;
      180 
      181 	call WALK_VOLUME;
      182 
      183 RECOVER_OVERFLOW:
      184 	call RESOLVE_CONFLICTS;
      185 
      186 	if get_vtoce_errors = 0
      187 	then call FREE_RECORDS;
      188 	pvte.scav_check_address = "0"b;
      189 
      190 	if restart_sw
      191 	then do;
      192 		unspec (scavenger_block.records) = ""b;
      193 		unspec (scavenger_block.overflow) = ""b;
      194 		scavenger_block.ovfl_free_ix = 1;
      195 		goto RESTART;
      196 	     end;
      197 
      198 	call CHECK_VTOCE_DAMAGE;
      199 	call FREE_VTOCES;
      200 
      201 	if get_vtoce_errors = 0
      202 	then do;
      203 		pvte.vol_trouble_count = 0;
      204 		call fsout_vol (pvtx, 0);
      205 	     end;
      206 
      207 
      208 	if get_vtoce_errors > 0
      209 	then call syserr (ANNOUNCE, "scavenge_volume: ^d errors reading VTOCEs on ^a", get_vtoce_errors, device_name);
      210 
      211 	if vtoces_damaged > 0
      212 	then call syserr (ANNOUNCE,
      213 		"scavenge_volume: ^d VTOCEs on ^a damaged.^[ ^d damaged during this scavenge.^;^1s^]", vtoces_damaged,
      214 		device_name, (vtoces_damaged_by_me > 0), vtoces_damaged_by_me);
      215 
      216 ABORT_JOIN:
      217 	pvte.scav_check_address = "0"b;
      218 
      219 	tsdw = 0;
      220 	call pmut$swap_sdw (addr (volmap_abs_seg$), addr (tsdw));
      221 
      222 	if copy_options.trap
      223 	then call syserr (CRASH, "scavenge_volume: Debug Trap on scavenge of ^a", device_name);
      224 
      225 
      226 	return;
      227 
      228 /*  Internal Procedure to find all free records in the volume map
      229*   and mark them as free in the scavenger block. It is assumed that there
      230*   will be no conflicts. This must be called with the volume map locked.
      231*   This prevents record addresses from migrating between the volume map
      232*   and the record stock.
      233**/
      234 
      235 COPY_VOLMAP:
      236      proc;
      237 
      238 dcl	bit_mapx			fixed bin;
      239 dcl	bx			fixed bin;
      240 dcl	rec_add			fixed bin (18);
      241 dcl	word_baseadd		fixed bin (18);
      242 
      243 
      244 	do bit_mapx = 1 to vol_map.bit_map_n_words;
      245 	     bit_map_wordp = addr (vol_map.bit_map (bit_mapx));
      246 	     if bit_map_word.bits ^= ""b		/* Some free this word */
      247 	     then do;
      248 		     word_baseadd = (bit_mapx - 1) * 32;
      249 		     do bx = 1 to 32;
      250 			if substr (bit_map_word.bits, bx, 1) = "1"b
      251 			then do;
      252 				rec_add = word_baseadd + bx;
      253 				scavenger_block.records (rec_add).state = STATE_FREE;
      254 			     end;
      255 		     end;
      256 		end;
      257 	end;
      258 
      259      end COPY_VOLMAP;
      260 
      261 /*  Internal Procedure to find all free addresses in the record stock and
      262*   mark them as free in the scavenger block. Any conflicts are marked as
      263*   such (this can only happen if an address in the stock was found in the
      264*   volume map, which can only happen if an address deposited recently is
      265*   marked as free in the volume map). Both the volume map and the Page
      266*   Table Lock must be held to ensure the stability of free addresses during
      267*   this scan. The Page Table Lock prevents withdrawal from the stock.
      268*   pvte.deposit_to_volmap ON disables lockless stock deposits,
      269*   and so deposits are done under the volume map lock.
      270**/
      271 
      272 COPY_STOCK:
      273      proc;
      274 
      275 dcl	rec_add			fixed bin (18);
      276 dcl	sx			fixed bin;
      277 
      278 
      279 	record_stockp = pvte.volmap_stock_ptr;
      280 	do sx = 1 to record_stock.n_in_stock;
      281 	     if record_stock.stock (sx) ^= ""b		/* Record address this slot */
      282 	     then if substr (record_stock.stock (sx), 1, 1) = "1"b
      283 						/* Out-of-service */
      284 		then call syserr (CRASH, "scavenge_volume: Out-of-service address in stock for ^a", device_name);
      285 		else do;
      286 			rec_add = bin (record_stock.stock (sx), 18) - pvte.baseadd + 1;
      287 			if scavenger_block.records (rec_add).state ^= STATE_UNSEEN
      288 			then scavenger_block.records (rec_add).state = STATE_CONFLICT;
      289 
      290 			else scavenger_block.records (rec_add).state = STATE_FREE;
      291 		     end;
      292 	end;
      293 
      294      end COPY_STOCK;
      295 
      296 /*  Internal Procedure to walk the SST. For each non-special ASTE on this
      297*   physical volume, we construct its file map from the page table and
      298*   core map entries. We then check the file map, as is done for each
      299*   VTOCE at another time.  The AST Lock and the Page Table Lock must be held.
      300**/
      301 WALK_SST:
      302      proc;
      303 
      304 
      305 dcl	astx			fixed bin;
      306 dcl	1 aste_file_map		aligned like file_map;
      307 dcl	n_pages			fixed bin;
      308 dcl	px			fixed bin;
      309 
      310 
      311 	astep = sst$astap;
      312 
      313 	do px = 0 to hbound (sst$level, 1);
      314 	     n_pages = sst$pts (px);
      315 	     do astx = 1 to bin (sst$level.no_aste (px));
      316 		if aste.usedf & (aste.pvtx = pvtx)
      317 		then if (aste.vtocx ^= -1) & ^aste.hc_part & ^aste.volmap_seg
      318 		     then do;
      319 			     call BUILD_FILEMAP_FROM_ASTE (astep, addr (aste_file_map), n_pages);
      320 			     call CHECK_FILE_MAP ((aste.vtocx), addr (aste_file_map), n_pages, (aste.fm_damaged));
      321 			     if aste.fm_damaged
      322 			     then substr (damaged_vtoces, aste.vtocx + 1, 1) = "1"b;
      323 			end;
      324 		astep = addrel (astep, size (aste) + n_pages);
      325 	     end;
      326 	end;
      327 
      328      end WALK_SST;
      329 
      330 /*  Internal Procedure to examine all VTOCEs on a volume. Each VTOCE is
      331*   validated syntactically, and the file map is checked for conflicts.
      332*   A list of VTOCEs to be freed and of damaged VTOCEs is maintained. However,
      333*   none are freed or damaged in this pass. The goal is to minimize the
      334*   time through this pass, due to the overhead in Page Control deposit/
      335*   withdraw while this is going on.
      336*
      337*   Any free VTOCE is checked against the VTOC map. If it is not there,
      338*   it is marked to-be-freed. This is an optimization. Any VTOCE in the
      339*   VTOC map is not lost. It doesn't matter if we mark a VTOCE which is
      340*   not lost to-be-freed, since we'll detect this later.
      341*
      342**/
      343 
      344 WALK_VOLUME:
      345      proc;
      346 
      347 dcl	bitx			fixed bin;
      348 dcl	code			fixed bin (35);
      349 dcl	free_it			bit (1) aligned;
      350 dcl	1 local_vtoce		aligned like vtoce;
      351 dcl	1 vtoce_file_map		aligned like file_map;
      352 dcl	vtocx			fixed bin;
      353 dcl	wordx			fixed bin;
      354 
      355 
      356 	do vtocx = 0 to pvte.n_vtoce - 1;
      357 
      358 	     if copy_options.debug
      359 	     then if mod (vtocx, 1024) = 0
      360 		then call syserr (ANNOUNCE, "scavenge_volume: Processing vtocx ^o on ^a.", vtocx, device_name);
      361 
      362 	     sc_meters.n_vtoces = sc_meters.n_vtoces + 1;
      363 	     call vtoc_man$get_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
      364 	     if code ^= 0
      365 	     then do;
      366 		     call syserr$error_code (SEVERITY (LOG), code, "scavenge_volume: Error reading vtocx ^o on ^a",
      367 			vtocx, device_name);
      368 		     get_vtoce_errors = get_vtoce_errors + 1;
      369 		     goto NEXT_VTOCE;
      370 		end;
      371 
      372 	     if copy_options.no_optimize
      373 	     then call pxss$relinquish_priority;	/* Give up the CPU */
      374 	     else if vtocx < pvte.n_vtoce - 1
      375 	     then call vtoc_man$read_ahead_vtoce (""b, pvtx, vtocx + 1, ALL_PARTS, code);
      376 
      377 	     if local_vtoce.uid = ""b
      378 	     then do;
      379 		     wordx = divide (vtocx, 32, 17);
      380 		     bit_map_wordp = addr (vtoc_map.bit_map (wordx));
      381 		     bitx = mod (vtocx, 32);
      382 		     if substr (bit_map_word.bits, bitx + 1, 1) ^= "1"b
      383 		     then substr (freed_vtoces, vtocx + 1, 1) = "1"b;
      384 		     goto NEXT_VTOCE;
      385 		end;
      386 
      387 	     call CHECK_VTOCE_FOR_FREE (addr (local_vtoce), "0"b, (""), free_it);
      388 	     if free_it
      389 	     then substr (freed_vtoces, vtocx + 1, 1) = "1"b;
      390 
      391 	     call CHECK_VTOCE (vtocx, addr (local_vtoce), "0"b, ("0"b));
      392 	     if local_vtoce.damaged | local_vtoce.fm_damaged
      393 	     then substr (damaged_vtoces, vtocx + 1, 1) = "1"b;
      394 
      395 	     call BUILD_FILEMAP_FROM_VTOCE (addr (local_vtoce), addr (vtoce_file_map));
      396 	     call CHECK_FILE_MAP (vtocx, addr (vtoce_file_map), bin (local_vtoce.csl), (local_vtoce.fm_damaged));
      397 
      398 NEXT_VTOCE:
      399 	     if get_vtoce_errors > GET_VTOCE_ERROR_THRESHOLD
      400 	     then do;
      401 		     pvte.scav_check_address = "0"b;
      402 		     Code = error_table_$scavenge_aborted;
      403 		     goto ABORT_JOIN;
      404 		end;
      405 	     call CHECK_ABORT;
      406 	end;
      407 
      408 
      409 
      410      end WALK_VOLUME;
      411 
      412 
      413 /*  Internal Procedure to construct a file map from an ASTE. The AST and Page
      414*   Table Locks must be held.
      415**/
      416 
      417 BUILD_FILEMAP_FROM_ASTE:
      418      proc (Astep, File_Mapp, PT_Size);
      419 
      420 dcl	Astep			ptr;
      421 dcl	File_Mapp			ptr;
      422 dcl	PT_Size			fixed bin;
      423 
      424 dcl	page_tablep		ptr;
      425 dcl	px			fixed bin;
      426 
      427 dcl	1 Aste			aligned like aste based (Astep);
      428 dcl	1 File_Map		aligned like file_map based (File_Mapp);
      429 
      430 	page_tablep = addrel (Astep, size (Aste));
      431 	unspec (File_Map) = ""b;
      432 
      433 	do px = 0 to PT_Size - 1;
      434 	     ptp = addrel (page_tablep, px);
      435 	     if l68_ptw.flags.add_type = ""b
      436 	     then File_Map.fm (px) = 0;
      437 	     else if l68_ptw.flags.add_type = add_type.core
      438 	     then do;
      439 		     cmep = addr (sst$cmp -> cma (l68_core_ptw.frame));
      440 		     if mcme.add_type = add_type.disk
      441 		     then File_Map.fm (px) = bin (substr (mcme.record_no, 2, 17));
      442 		     else File_Map.fm (px) = 0;
      443 		end;
      444 	     else if l68_ptw.flags.add_type = add_type.disk
      445 	     then File_Map.fm (px) = bin (substr (l68_ptw.add, 2, 17));
      446 	     else File_Map.fm (px) = 0;
      447 	end;
      448 
      449      end BUILD_FILEMAP_FROM_ASTE;
      450 
      451 /*  Internal Procedure to construct a file map from a VTOCE */
      452 
      453 BUILD_FILEMAP_FROM_VTOCE:
      454      proc (Vtocep, File_Mapp);
      455 
      456 dcl	Vtocep			ptr;
      457 dcl	File_Mapp			ptr;
      458 
      459 dcl	px			fixed bin;
      460 
      461 dcl	1 File_Map		aligned like file_map based (File_Mapp);
      462 dcl	1 Vtoce			aligned like vtoce based (Vtocep);
      463 
      464 
      465 	do px = 0 to hbound (Vtoce.fm, 1);
      466 	     if substr (Vtoce.fm (px), 1, 1) = "1"b
      467 	     then File_Map.fm (px) = 0;
      468 	     else File_Map.fm (px) = bin (Vtoce.fm (px), 18);
      469 	end;
      470 
      471      end BUILD_FILEMAP_FROM_VTOCE;
      472 
      473 
      474 
      475 /*  Internal Procedure to examine the list of VTOCEs marked as damaged
      476*   during the first pass. Each is checked again for damage under the
      477*   AST lock (if the segment is active it is skipped, since activate
      478*   checks most of the fields we check). If damage is found, the
      479*   segment is damaged for real, and messages dumped into the syserr
      480*   log.
      481**/
      482 CHECK_VTOCE_DAMAGE:
      483      proc;
      484 
      485 dcl	code			fixed bin (35);
      486 dcl	1 copy_vtoce		aligned like vtoce;
      487 dcl	damaged_sw		bit (1) aligned;
      488 dcl	done_damage		bit (1) aligned;
      489 dcl	1 local_vtoce		aligned like vtoce;
      490 dcl	prev_damaged		bit (1) aligned;
      491 dcl	prev_fm_damaged		bit (1) aligned;
      492 dcl	vtocx			fixed bin;
      493 
      494 
      495 	vtoce_bitsp = addr (damaged_vtoces);
      496 
      497 	base_vtocx = 0;
      498 	done_damage = "0"b;
      499 
      500 	do while (^done_damage);
      501 
      502 	     vtocx = index (vtoce_bits.remaining, "1"b);
      503 	     if vtocx = 0
      504 	     then do;				/* None left */
      505 		     done_damage = "1"b;
      506 		     goto NEXT;
      507 		end;
      508 
      509 	     vtocx = vtocx + base_vtocx - 1;
      510 	     base_vtocx = vtocx + 1;
      511 	     call vtoc_man$get_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
      512 	     if code ^= 0
      513 	     then do;
      514 		     call syserr$error_code (SEVERITY (LOG), "scavenge_volume: Error reading vtocx ^o on ^a", vtocx,
      515 			device_name);
      516 		     goto NEXT;
      517 		end;
      518 
      519 	     if copy_options.dump
      520 	     then unspec (copy_vtoce) = unspec (local_vtoce);
      521 
      522 	     call LOCK_AST_CHECK_UID ((local_vtoce.uid), vtocx, astep);
      523 	     if astep = null ()
      524 	     then do;				/* Only non-active segments. lock prevent activation */
      525 
      526 		     prev_damaged = local_vtoce.damaged;
      527 		     call CHECK_VTOCE (vtocx, addr (local_vtoce), "1"b, damaged_sw);
      528 
      529 		     if local_vtoce.damaged
      530 		     then vtoces_damaged = vtoces_damaged + 1;
      531 		     if (local_vtoce.damaged & ^prev_damaged)
      532 		     then vtoces_damaged_by_me = vtoces_damaged_by_me + 1;
      533 
      534 		     if damaged_sw | prev_damaged
      535 		     then call SEGDAMAGE (vtocx, addr (local_vtoce), addr (copy_vtoce), prev_damaged);
      536 
      537 		     if local_vtoce.fm_damaged
      538 		     then do;
      539 			     prev_fm_damaged = "1"b;
      540 			     local_vtoce.fm_damaged = "0"b;
      541 			     if sst$checksum_filemap ^= 0
      542 			     then do;
      543 				     call filemap_checksum_ (addr (local_vtoce.fm), fixed (local_vtoce.csl),
      544 					local_vtoce.fm_checksum);
      545 				     local_vtoce.fm_checksum_valid = "1"b;
      546 				end;
      547 			     else do;
      548 				     local_vtoce.fm_checksum_valid = "0"b;
      549 				     local_vtoce.fm_checksum = ""b;
      550 				end;
      551 			     sc_meters.n_vtoces_fmd = sc_meters.n_vtoces_fmd + 1;
      552 			end;
      553 
      554 		     if damaged_sw | prev_fm_damaged
      555 		     then do;
      556 			     call vtoc_man$put_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
      557 			     if code ^= 0
      558 			     then call syserr$error_code (SEVERITY (LOG), code,
      559 				     "scavenge_volume: Error writing vtocx ^a on ^a.", vtocx, device_name);
      560 			end;
      561 
      562 		end;
      563 	     else do;				/* active */
      564 		     if aste.fm_damaged
      565 		     then do;
      566 			     sc_meters.n_vtoces_fmd = sc_meters.n_vtoces_fmd + 1;
      567 			     aste.fm_damaged = "0"b;
      568 			end;
      569 		end;
      570 
      571 	     call lock$unlock_ast;
      572 
      573 NEXT:
      574 	end;
      575 
      576 
      577 
      578 
      579      end CHECK_VTOCE_DAMAGE;
      580 
      581 /*  Internal Procedure to free any records which are unseen. Any unseen
      582*   records are known not to be claimed by any VTOCE and not to be in
      583*   the Volume Map. It is safe to free these without further examination
      584*   or adieu.
      585**/
      586 
      587 FREE_RECORDS:
      588      proc;
      589 
      590 dcl	1 deposit_list		(256) aligned,
      591 	  2 record		fixed bin (18) uns unal,
      592 	  2 pad			bit (18) unal;
      593 dcl	dx			fixed bin;
      594 dcl	records_freed		fixed bin;
      595 dcl	rx			fixed bin;
      596 
      597 	unspec (deposit_list) = ""b;
      598 	records_freed = 0;
      599 	dx = 0;
      600 
      601 	do rx = 1 to scavenger_block.n_records;
      602 
      603 	     record_blockp = addr (scavenger_block.records (rx));
      604 	     if record_block.state = STATE_UNSEEN
      605 	     then do;
      606 		     dx = dx + 1;
      607 		     records_freed = records_freed + 1;
      608 		     deposit_list (dx).record = rx + pvte.baseadd - 1;
      609 		     if dx >= hbound (deposit_list, 1)
      610 		     then do;
      611 			     call pc$deposit_list (pvtx, dx, addr (deposit_list), -1, null ());
      612 			     dx = 0;
      613 			     call CHECK_ABORT;
      614 			end;
      615 		end;
      616 
      617 	end;
      618 
      619 	if dx > 0
      620 	then call pc$deposit_list (pvtx, dx, addr (deposit_list), -1, null ());
      621 
      622 	records_freed = records_freed - conflicts_unclaimed;
      623 						/* Adjust for those really lost */
      624 	sc_meters.n_lost_records = records_freed;
      625 	if records_freed > 0
      626 	then call syserr (SEVERITY (LOG), "scavenge_volume: Freed ^d records on ^a", records_freed, device_name);
      627 
      628      end FREE_RECORDS;
      629 
      630 /*  Internal Procedure to look for record addresses which have potential
      631*   conflicts. A routine to resolve the conflict is called for each such.
      632*   This driver routine is split out for logic clarity.
      633**/
      634 
      635 RESOLVE_CONFLICTS:
      636      proc;
      637 
      638 dcl	rx			fixed bin;
      639 
      640 
      641 	do rx = 1 to scavenger_block.n_records;
      642 	     record_blockp = addr (scavenger_block.records (rx));
      643 	     if record_block.state = STATE_CONFLICT
      644 	     then do;
      645 		     call RESOLVE_THIS_CONFLICT ((rx - 1 + pvte.baseadd), record_blockp);
      646 		     call CHECK_ABORT;
      647 		end;
      648 	end;
      649 
      650      end RESOLVE_CONFLICTS;
      651 
      652 /*  Internal Procedure to resolve conflicts for a given record address.
      653*   This routine is the real hair of the scavenger, the complexity due
      654*   to the many races, both here and in the first pass (which flagged
      655*   the potential conflicts).
      656*
      657*   The logic is as follows:
      658*
      659*   1. Make sure that the address is not marked as free in the
      660*   stock or Volume Map (using a special page control entry for us).
      661*
      662*   2. Walk the thread of potential conflicts. For each entry, note
      663*   whether the conflict in fact exists. Of those segments still
      664*   claiming the address, select at most one to get it, according
      665*   to the following rules:
      666*
      667*   If only one segment claims the address, it gets it.
      668*
      669*   If only one directory claims the address, it gets it. The
      670*   directory salvager is presumed capable of straightening
      671*   any mess out.
      672*
      673*   If only one segment which has no record of file map damage
      674*   claims the address, it gets it.
      675*
      676*   Otherwise nobody gets it. Note that our covenant with page control
      677*   deposit/withdraw prevents any segment from getting this address other
      678*   than the ones we know about.
      679*
      680*   3. Walk the thread of potential conflicts again. For each entry which
      681*   doesn't get the address, attempt to bust the address loose.
      682*   A setfaults is used to disconnect the segment from active processes.
      683*   If the segment is entry-held, we log a message and give up. The
      684*   address is nulled, and the segment is damaged.
      685*   This is all done under the AST lock.
      686*
      687*   4. Under the AST lock, check whether the lucky segment which gets
      688*   the address still has it. If not, deposit it after setting the
      689*   state "unseen" (so that the deposit takes).
      690*
      691*   It is assumed that conflicts are relatively rare, and that efficiency
      692*   can be sacrificed for a modicum of simplicity.
      693**/
      694 
      695 RESOLVE_THIS_CONFLICT:
      696      proc (Record_Address, Record_Blockp);
      697 
      698 dcl	Record_Address		fixed bin (18);
      699 dcl	Record_Blockp		ptr;
      700 
      701 dcl	checksum			bit (36) aligned;
      702 dcl	claim_count		fixed bin;
      703 dcl	claims_address		bit (1) aligned;
      704 dcl	code			fixed bin (35);
      705 dcl	conflict_blockp		ptr;
      706 dcl	1 copy_vtoce		aligned like vtoce;
      707 dcl	csl			fixed bin;
      708 dcl	dir_count			fixed bin;
      709 dcl	done_thread		bit (1) aligned;
      710 dcl	1 local_file_map		aligned like file_map;
      711 dcl	1 local_vtoce		aligned like vtoce;
      712 dcl	not_fmd_count		fixed bin;
      713 dcl	owner_pageno		fixed bin;
      714 dcl	owner_vtocx		fixed bin;
      715 dcl	pageno			fixed bin;
      716 dcl	prev_damaged		bit (1) aligned;
      717 dcl	real_conflict		bit (1) aligned;
      718 dcl	records			fixed bin;
      719 dcl	vtocx			fixed bin;
      720 
      721 dcl	1 conflict_block		aligned like record_block based (conflict_blockp);
      722 dcl	1 Record_Block		aligned like record_block based (Record_Blockp);
      723 
      724 
      725 /* Free the address. Check whether each conflict is real, and select an
      726*   owner for the address. */
      727 
      728 	sc_meters.n_conflicts = sc_meters.n_conflicts + 1;
      729 	real_conflict = "0"b;
      730 
      731 	conflict_blockp = Record_Blockp;
      732 
      733 	call page$free_address_for_scavenge (pvtx, Record_Address);
      734 
      735 	dir_count, claim_count, not_fmd_count = 0;
      736 	owner_vtocx = -1;
      737 	done_thread = "0"b;
      738 	do while (^done_thread);
      739 
      740 	     vtocx = conflict_block.vtocx;
      741 	     pageno = conflict_block.pageno;
      742 
      743 	     call GET_VTOCE_CHECK_ADDRESS (vtocx, addr (local_vtoce), pageno, Record_Address, astep, claims_address,
      744 		code);
      745 	     if code ^= 0
      746 	     then do;
      747 ERROR_PUNT:
      748 		     call syserr$error_code (SEVERITY (LOG), code,
      749 			"scavenge_volume: Unable to resolve conflict for address ^o on ^a. Error at vtocx ^o.",
      750 			Record_Address, device_name, vtocx);
      751 		     get_vtoce_errors = get_vtoce_errors + 1;
      752 		     return;
      753 		end;
      754 	     if claims_address
      755 	     then do;
      756 		     call lock$unlock_ast;
      757 		     claim_count = claim_count + 1;
      758 		     if local_vtoce.dirsw
      759 		     then dir_count = dir_count + 1;
      760 		     if ^local_vtoce.fm_damaged & local_vtoce.fm_checksum_valid
      761 		     then do;
      762 			     call filemap_checksum_ (addr (local_vtoce.fm), fixed (local_vtoce.csl, 9), checksum);
      763 			     if local_vtoce.fm_checksum ^= checksum
      764 			     then local_vtoce.fm_damaged = "1"b;
      765 			end;
      766 		     if ^local_vtoce.fm_damaged
      767 		     then not_fmd_count = not_fmd_count + 1;
      768 		     if (claim_count = 1) | (local_vtoce.dirsw & (dir_count = 1))
      769 			| (^local_vtoce.fm_damaged & (not_fmd_count = 1) & (dir_count = 0))
      770 		     then do;
      771 			     owner_vtocx = vtocx;
      772 			     owner_pageno = pageno;
      773 			end;
      774 		end;
      775 	     if conflict_block.ovflx = 0
      776 	     then done_thread = "1"b;
      777 	     else conflict_blockp = addr (scavenger_block.overflow (conflict_block.ovflx));
      778 
      779 	end;
      780 
      781 
      782 /*  If there are no claimants, mark the address as unseen. This will
      783*   cause it to be freed later.
      784**/
      785 
      786 	if claim_count = 0
      787 	then do;
      788 FREE_RETURN:
      789 		call LOCK_RECORD (record_blockp);
      790 		Record_Block.state = STATE_UNSEEN;
      791 		record_block.lock = "0"b;
      792 		conflicts_unclaimed = conflicts_unclaimed + 1;
      793 		return;
      794 	     end;
      795 
      796 
      797 /*  Walk the list of conflicts, and attempt to bust the address loose
      798*   from all except the owner. Note that there may be no owner.  */
      799 
      800 	done_thread = "0"b;
      801 	conflict_blockp = Record_Blockp;
      802 
      803 	if (claim_count > 1) & (dir_count ^= 1) & (not_fmd_count ^= 1)
      804 	then owner_vtocx = -1;
      805 
      806 	do while (^done_thread);
      807 
      808 	     vtocx = conflict_block.vtocx;
      809 	     pageno = conflict_block.pageno;
      810 	     if ((vtocx ^= owner_vtocx) | (pageno ^= owner_pageno))
      811 	     then do;
      812 
      813 		     call GET_VTOCE_CHECK_ADDRESS (vtocx, addr (local_vtoce), pageno, Record_Address, astep,
      814 			claims_address, code);
      815 		     if code ^= 0
      816 		     then goto ERROR_PUNT;
      817 		     if ^claims_address
      818 		     then goto NEXT;
      819 		     real_conflict = "1"b;
      820 
      821 		     if copy_options.dump
      822 		     then unspec (copy_vtoce) = unspec (local_vtoce);
      823 
      824 		     if astep ^= null ()
      825 		     then do;
      826 			     if aste.ehs | aste.hc_sdw | aste.hc | aste.hc_part
      827 			     then do;
      828 PUNT_ASTE:
      829 				     call lock$unlock_ast;
      830 				     call syserr (SEVERITY (LOG),
      831 					"scavenge_volume: Unable to resolve conflict for address ^o on ^a. astep=^p"
      832 					, Record_Address, device_name, astep);
      833 				     return;
      834 				end;
      835 			     call setfaults (astep, "0"b);
      836 			     call pc$cleanup (astep);
      837 			     ptp = addrel (astep, size (aste) + pageno);
      838 			     if l68_ptw.add_type ^= add_type.disk
      839 			     then goto PUNT_ASTE;
      840 			     l68_ptw.add_type = ""b;
      841 			     l68_ptw.add = pv_scav_null_addr;
      842 			     prev_damaged = aste.damaged;
      843 			     aste.damaged = "1"b;
      844 			     aste.fmchanged = "1"b;
      845 
      846 			     call BUILD_FILEMAP_FROM_ASTE (astep, addr (local_file_map), sst$pts (bin (aste.ptsi)));
      847 			     call COMPUTE_RECORDS_CSL (addr (local_file_map), records, csl);
      848 			     aste.records = bit (bin (records, 9), 9);
      849 			     aste.csl = bit (bin (csl, 9), 9);
      850 
      851 			     call update_vtoce (astep);
      852 						/* Reflect into VTOCE */
      853 
      854 			end;
      855 		     else do;
      856 			     call vtoc_man$get_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
      857 			     if code ^= 0
      858 			     then do;
      859 				     call lock$unlock_ast;
      860 				     goto ERROR_PUNT;
      861 				end;
      862 			     prev_damaged = local_vtoce.damaged;
      863 			     local_vtoce.fm (pageno) = pv_scav_null_addr;
      864 			     call BUILD_FILEMAP_FROM_VTOCE (addr (local_vtoce), addr (local_file_map));
      865 			     call COMPUTE_RECORDS_CSL (addr (local_file_map), records, csl);
      866 			     local_vtoce.csl = bit (bin (csl, 9), 9);
      867 			     local_vtoce.records = bit (bin (records, 9), 9);
      868 			     if sst$checksum_filemap = 0
      869 			     then do;
      870 				     local_vtoce.fm_checksum_valid = "0"b;
      871 				     local_vtoce.fm_checksum = ""b;
      872 				end;
      873 			     else do;
      874 				     local_vtoce.fm_checksum_valid = "1"b;
      875 				     call filemap_checksum_ (addr (local_vtoce.fm), csl, local_vtoce.fm_checksum);
      876 				end;
      877 
      878 			     local_vtoce.damaged = "1"b;
      879 			     call vtoc_man$put_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
      880 			     if code ^= 0
      881 			     then do;
      882 				     call lock$unlock_ast;
      883 				     goto ERROR_PUNT;
      884 				end;
      885 			end;
      886 		     call lock$unlock_ast;
      887 		     call syserr (SEVERITY (LOG),
      888 			"scavenge_volume: vtoce ^a at ^o (^a). ref to pageno ^o at addr ^o deleted",
      889 			local_vtoce.primary_name, vtocx, device_name, pageno, Record_Address);
      890 		     if ^prev_damaged
      891 		     then do;
      892 			     call SEGDAMAGE (vtocx, addr (local_vtoce), addr (copy_vtoce), prev_damaged);
      893 			     vtoces_damaged = vtoces_damaged + 1;
      894 			     vtoces_damaged_by_me = vtoces_damaged_by_me + 1;
      895 			end;
      896 		end;
      897 
      898 NEXT:
      899 	     if conflict_block.ovflx = 0
      900 	     then done_thread = "1"b;
      901 	     else conflict_blockp = addr (scavenger_block.overflow (conflict_block.ovflx));
      902 	end;
      903 
      904 	if real_conflict
      905 	then sc_meters.n_real_conflicts = sc_meters.n_real_conflicts + 1;
      906 
      907 /*  Now check whether the owner (if any) still claims the address. If not,
      908*   free it.  */
      909 
      910 	if owner_vtocx = -1
      911 	then do;
      912 		call LOCK_RECORD (record_blockp);
      913 		record_block.state = STATE_UNSEEN;
      914 		record_block.lock = "0"b;
      915 		return;
      916 	     end;
      917 
      918 	call GET_VTOCE_CHECK_ADDRESS (owner_vtocx, addr (local_vtoce), owner_pageno, Record_Address, astep,
      919 	     claims_address, code);
      920 	if code ^= 0
      921 	then return;
      922 
      923 
      924 	if ^claims_address
      925 	then goto FREE_RETURN;
      926 
      927 	call lock$unlock_ast;
      928 
      929      end RESOLVE_THIS_CONFLICT;
      930 
      931 
      932 /*  Internal Procedure to recompute the number of records and current
      933*   segment length from a file map.
      934**/
      935 
      936 COMPUTE_RECORDS_CSL:
      937      proc (File_Mapp, Records, Csl);
      938 
      939 dcl	File_Mapp			ptr;
      940 dcl	Records			fixed bin;
      941 dcl	Csl			fixed bin;
      942 
      943 dcl	px			fixed bin;
      944 
      945 dcl	1 File_Map		aligned like file_map based (File_Mapp);
      946 
      947 	Records, Csl = 0;
      948 	do px = 0 to hbound (File_Map.fm, 1);
      949 	     if File_Map.fm (px) ^= 0
      950 	     then do;
      951 		     Csl = px + 1;
      952 		     Records = Records + 1;
      953 		end;
      954 	end;
      955 
      956      end COMPUTE_RECORDS_CSL;
      957 
      958 /*  Internal Procedure to read a VTOCE, check whether the segment is active,
      959*   and whether the segment claims a specified address for a certain page.
      960*   The AST is locked, and left locked if the address is claimed.
      961**/
      962 GET_VTOCE_CHECK_ADDRESS:
      963      proc (Vtocx, Vtocep, Pageno, Record_Address, Astep, Claims, Code);
      964 
      965 dcl	Vtocx			fixed bin;
      966 dcl	Vtocep			ptr;
      967 dcl	Pageno			fixed bin;
      968 dcl	Record_Address		fixed bin (18);
      969 dcl	Astep			ptr;
      970 dcl	Claims			bit (1) aligned;
      971 dcl	Code			fixed bin (35);
      972 
      973 dcl	old_mask			fixed bin (71);
      974 dcl	ptwp			ptr;
      975 
      976 dcl	1 Vtoce			aligned like vtoce based (Vtocep);
      977 
      978 
      979 	Code = 0;
      980 	Astep = null ();
      981 	Claims = "0"b;
      982 
      983 	call vtoc_man$get_vtoce (""b, pvtx, Vtocx, ALL_PARTS, Vtocep, Code);
      984 	if Code ^= 0
      985 	then return;
      986 
      987 	call LOCK_AST_CHECK_UID ((Vtoce.uid), Vtocx, Astep);
      988 	if Astep = null ()
      989 	then do;
      990 		if substr (Vtoce.fm (Pageno), 1, 1) = "0"b
      991 		then if bin (Vtoce.fm (Pageno), 18) = Record_Address
      992 		     then Claims = "1"b;
      993 	     end;
      994 	else do;
      995 		if Pageno < sst$pts (fixed (Astep -> aste.ptsi, 3))
      996 						/* silly scoping */
      997 		then do;
      998 			ptp = addrel (Astep, size (aste) + Pageno);
      999 			call pmut$lock_ptl (old_mask, ptwp);
     1000 			if l68_ptw.flags.add_type = add_type.core
     1001 			then do;
     1002 				cmep = addr (sst$cmp -> cma (l68_core_ptw.frame));
     1003 				if mcme.add_type = add_type.disk
     1004 				then if bin (substr (mcme.record_no, 2, 17)) = Record_Address
     1005 				     then Claims = "1"b;
     1006 			     end;
     1007 			else if l68_ptw.flags.add_type = add_type.disk
     1008 			then if bin (substr (l68_ptw.add, 2, 17)) = Record_Address
     1009 			     then Claims = "1"b;
     1010 			call pmut$unlock_ptl (old_mask, ptwp);
     1011 		     end;
     1012 	     end;
     1013 
     1014 	if ^Claims
     1015 	then call lock$unlock_ast;
     1016 
     1017 
     1018      end GET_VTOCE_CHECK_ADDRESS;
     1019 
     1020 
     1021 
     1022 /*  Internal Procedure to examine the list of VTOCEs to be freed which
     1023*   were found in the first pass. Each is examined again.
     1024*   If not active and still to-be-freed, it is freed. Potentially lost
     1025*   VTOCEs are freed using a special entry to vtoc_man to avoid the
     1026*   race with an in-progress allocation. Other VTOCEs are freed by
     1027*   priv_delete_vtoce, which  protects against races and active segments.
     1028**/
     1029 FREE_VTOCES:
     1030      proc;
     1031 
     1032 dcl	code			fixed bin (35);
     1033 dcl	done_free			bit (1) aligned;
     1034 dcl	free_it			bit (1) aligned;
     1035 dcl	1 local_vtoce		aligned like vtoce;
     1036 dcl	message			char (32);
     1037 dcl	vtoces_freed		fixed bin;
     1038 dcl	vtocx			fixed bin;
     1039 
     1040 
     1041 	vtoces_freed = 0;
     1042 	vtoce_bitsp = addr (freed_vtoces);
     1043 
     1044 	base_vtocx = 0;
     1045 	done_free = "0"b;
     1046 
     1047 	do while (^done_free);
     1048 
     1049 	     vtocx = index (vtoce_bits.remaining, "1"b);
     1050 	     if vtocx = 0
     1051 	     then do;				/* None left */
     1052 		     done_free = "1"b;
     1053 		     goto NEXT;
     1054 		end;
     1055 
     1056 	     vtocx = vtocx + base_vtocx - 1;
     1057 	     base_vtocx = vtocx + 1;
     1058 	     call vtoc_man$get_vtoce (""b, pvtx, vtocx, ALL_PARTS, addr (local_vtoce), code);
     1059 	     if code ^= 0
     1060 	     then do;
     1061 		     call syserr$error_code (SEVERITY (LOG), code, "scavenge_volume: Error reading vtocx ^a on ^a.",
     1062 			vtocx, device_name);
     1063 		     get_vtoce_errors = get_vtoce_errors + 1;
     1064 		     goto NEXT;
     1065 		end;
     1066 
     1067 
     1068 	     call CHECK_VTOCE_FOR_FREE (addr (local_vtoce), "1"b, message, free_it);
     1069 	     if free_it
     1070 	     then do;
     1071 
     1072 		     if local_vtoce.uid = ""b
     1073 		     then call vtoc_man$free_vtoce_for_scavenge (""b, pvtx, vtocx, code);
     1074 
     1075 		     else call priv_delete_vtoce ((local_vtoce.uid), pvte.pvid, vtocx, code);
     1076 
     1077 		     if code = 0
     1078 		     then do;
     1079 			     vtoces_freed = vtoces_freed + 1;
     1080 			     if copy_options.debug
     1081 			     then call syserr (SEVERITY (JUST_LOG),
     1082 				     "scavenge_volume: Freeing ^a VTOCE ^[^a ^;^1s^]at ^o (^a)", message,
     1083 				     (local_vtoce.uid ^= ""b), local_vtoce.primary_name, vtocx, device_name);
     1084 			end;
     1085 		     else if code ^= error_table_$vtoce_free
     1086 		     then call syserr$error_code (SEVERITY (LOG), code,
     1087 			     "scavenge_volume: Error freeing ^a vtocx ^o on ^a", message, vtocx, device_name);
     1088 
     1089 
     1090 		end;
     1091 
     1092 NEXT:
     1093 	     call CHECK_ABORT;
     1094 	end;
     1095 
     1096 	sc_meters.n_vtoces_freed = vtoces_freed;
     1097 	if vtoces_freed > 0
     1098 	then call syserr (SEVERITY (LOG), "scavenge_volume: Freed ^d VTOCEs on ^a", vtoces_freed, device_name);
     1099 
     1100      end FREE_VTOCES;
     1101 
     1102 
     1103 /*  Internal Procedure to lock the AST Lock and find the ASTE (if any)
     1104*   corresponding to a supplied UID.
     1105**/
     1106 LOCK_AST_CHECK_UID:
     1107      proc (Uid, Vtocx, Astep);
     1108 
     1109 dcl	Uid			bit (36) aligned;
     1110 dcl	Vtocx			fixed bin;
     1111 dcl	Astep			ptr;
     1112 
     1113 
     1114 	call lock$lock_ast;
     1115 	if Uid = ""b
     1116 	then Astep = null ();
     1117 	else Astep = search_ast$check (Uid, pvte.pvid, Vtocx, (0));
     1118 						/* use global pvid (!), ignore double-uid error */
     1119 
     1120      end LOCK_AST_CHECK_UID;
     1121 
     1122 
     1123 
     1124 
     1125 /*  Internal Procedure to validate a VTOCE. Invalid fields are corrected,
     1126*   to the extent possible. If the corrections are "for real" (second
     1127*   pass), they are reported into the syserr log.
     1128**/
     1129 
     1130 CHECK_VTOCE:
     1131      proc (Vtocx, Vtocep, Loud, Damaged);
     1132 
     1133 dcl	Vtocx			fixed bin;
     1134 dcl	Vtocep			ptr;
     1135 dcl	Loud			bit (1) aligned;
     1136 dcl	Damaged			bit (1) aligned;
     1137 
     1138 dcl	checksum			bit (36) aligned;
     1139 dcl	csl			fixed bin;
     1140 dcl	cur_fstime		bit (36) aligned;
     1141 dcl	low_add			fixed bin (18);
     1142 dcl	high_add			fixed bin (18);
     1143 dcl	px			fixed bin;
     1144 dcl	rec_add			fixed bin (18);
     1145 dcl	records			fixed bin;
     1146 dcl	trp_bad			bit (1) aligned;
     1147 dcl	tx			fixed bin;
     1148 
     1149 dcl	1 Vtoce			aligned like vtoce based (Vtocep);
     1150 
     1151 
     1152 	Damaged = "0"b;
     1153 
     1154 	low_add = pvte.baseadd;
     1155 	high_add = pvte.baseadd + pvte.totrec - 1;
     1156 	csl, records = 0;
     1157 
     1158 	cur_fstime = substr (bit (bin (clock (), 71), 71), 20, 36);
     1159 
     1160 	do px = 0 to hbound (Vtoce.fm, 1);
     1161 	     if substr (Vtoce.fm (px), 1, 1) = "0"b
     1162 	     then do;
     1163 		     rec_add = bin (Vtoce.fm (px), 18);
     1164 		     if rec_add < low_add | rec_add > high_add
     1165 		     then do;
     1166 			     Damaged = "1"b;
     1167 			     Vtoce.damaged = "1"b;
     1168 			     Vtoce.fm (px) = pv_scav_null_addr;
     1169 			     if Loud & copy_options.debug
     1170 			     then call syserr (SEVERITY (JUST_LOG),
     1171 				     "scavenge_volume: vtoce ^a at ^o (^a) disk addr ^o bad", Vtoce.primary_name,
     1172 				     Vtocx, pvte.devname, device_name, rec_add);
     1173 			end;
     1174 		     else do;
     1175 			     csl = px + 1;
     1176 			     records = records + 1;
     1177 			end;
     1178 		end;
     1179 	end;
     1180 
     1181 	if bin (Vtoce.records) ^= records
     1182 	then do;
     1183 		if Loud
     1184 		then call syserr (SEVERITY (JUST_LOG),
     1185 			"scavnege_volume: vtoce ^a at ^o (^a). rec used changed from ^o to ^o", Vtoce.primary_name,
     1186 			Vtocx, device_name, bin (Vtoce.records), records);
     1187 		Damaged = "1"b;
     1188 		Vtoce.damaged = "1"b;
     1189 		Vtoce.records = bit (bin (records, 9), 9);
     1190 	     end;
     1191 
     1192 	if bin (Vtoce.csl) ^= csl
     1193 	then do;
     1194 		if Loud
     1195 		then call syserr (SEVERITY (JUST_LOG),
     1196 			"scavenge_volume: vtoce ^a at ^o (^a). cur len changed from ^o to ^o", Vtoce.primary_name,
     1197 			Vtocx, device_name, bin (Vtoce.csl), csl);
     1198 		Damaged = "1"b;
     1199 		Vtoce.damaged = "1"b;
     1200 		Vtoce.csl = bit (bin (csl, 9), 9);
     1201 	     end;
     1202 
     1203 	if (bin (Vtoce.msl) > 256) | (bin (Vtoce.msl) < 0) | (bin (Vtoce.msl) < csl)
     1204 	then do;
     1205 		if Loud
     1206 		then call syserr (SEVERITY (JUST_LOG),
     1207 			"scavenge_volume: vtoce ^a at ^o (^a). max len changed from ^o to 400", Vtoce.primary_name,
     1208 			Vtocx, device_name, bin (Vtoce.msl));
     1209 		Damaged = "1"b;
     1210 		Vtoce.damaged = "1"b;
     1211 		Vtoce.msl = bit (bin (256, 9), 9);
     1212 	     end;
     1213 
     1214 	trp_bad = "0"b;
     1215 	do tx = 0 to 1;
     1216 	     if Vtoce.trp (tx) < 0 | bin (Vtoce.trp (tx), 36) > bin (cur_fstime, 36)
     1217 	     then trp_bad = "1"b;
     1218 	end;
     1219 	if trp_bad
     1220 	then do;
     1221 		do tx = 0 to 1;
     1222 		     Vtoce.trp (tx) = 0;
     1223 		     Vtoce.trp_time (tx) = cur_fstime;
     1224 		end;
     1225 		if Loud
     1226 		then call syserr (SEVERITY (JUST_LOG),
     1227 			"scavenge_volume: vtoce ^a at ^o (^a). time-record-product reset to zero",
     1228 			Vtoce.primary_name, Vtocx, device_name);
     1229 	     end;
     1230 
     1231 	if Vtoce.dirsw & pvte.lvid ^= pvt$root_lvid
     1232 	then do;
     1233 		if Loud
     1234 		then call syserr (SEVERITY (JUST_LOG), "scavenge_volume: dirsw turned off for ^a at ^o (^a)",
     1235 			Vtoce.primary_name, Vtocx, device_name);
     1236 		Damaged = "1"b;
     1237 		Vtoce.damaged = "1"b;
     1238 		Vtoce.dirsw = "0"b;
     1239 	     end;
     1240 
     1241 	if Vtoce.fm_checksum_valid
     1242 	then do;
     1243 		call filemap_checksum_ (addr (Vtoce.fm), fixed (Vtoce.csl, 9), checksum);
     1244 		if Vtoce.fm_checksum ^= checksum
     1245 		then do;
     1246 			Vtoce.fm_damaged = "1"b;
     1247 			if Loud & copy_options.debug
     1248 			then call syserr (SEVERITY (JUST_LOG),
     1249 				"scavenge_volume: Invalid File Map Checksum for ^a at ^o (^a)",
     1250 				Vtoce.primary_name, Vtocx, device_name);
     1251 		     end;
     1252 	     end;
     1253 
     1254      end CHECK_VTOCE;
     1255 
     1256 
     1257 
     1258 
     1259 /*  Internal Procedure which is the brains of the scavenger. It examines
     1260*   a file map and updates the scavenger data base for this volume. It
     1261*   is operating asynchronously on this data base along with page
     1262*   control deposit/withdraw.
     1263**/
     1264 
     1265 CHECK_FILE_MAP:
     1266      proc (Vtocx, File_Mapp, N_Pages, Fm_Damaged);
     1267 
     1268 dcl	Vtocx			fixed bin;
     1269 dcl	File_Mapp			ptr;
     1270 dcl	N_Pages			fixed bin;
     1271 dcl	Fm_Damaged		bit (1) aligned;
     1272 
     1273 dcl	high_add			fixed bin (18);
     1274 dcl	low_add			fixed bin (18);
     1275 dcl	px			fixed bin;
     1276 dcl	rec_add			fixed bin (18);
     1277 
     1278 dcl	1 File_Map		aligned like file_map based (File_Mapp);
     1279 
     1280 	low_add = pvte.baseadd;
     1281 	high_add = pvte.baseadd + pvte.totrec - 1;
     1282 	do px = 0 to N_Pages - 1;
     1283 	     if File_Map.fm (px) ^= 0
     1284 	     then if (File_Map.fm (px) >= low_add) & (File_Map.fm (px) <= high_add)
     1285 		then do;
     1286 			rec_add = File_Map.fm (px) - pvte.baseadd + 1;
     1287 			sc_meters.n_records = sc_meters.n_records + 1;
     1288 			record_blockp = addr (scavenger_block.records (rec_add));
     1289 
     1290 /*  Lock the record block */
     1291 
     1292 			call LOCK_RECORD (record_blockp);
     1293 
     1294 
     1295 /*  Update scavenger data for this record. If the File Map is potentially
     1296*   damaged (invalid checksum at some point), all record addresses must
     1297*   be marked as conflicts, since they are not deposited. This way, truncations
     1298*   happening at the same time as the scavenge will not result in lost
     1299*   addresses.  */
     1300 
     1301 			if Fm_Damaged
     1302 			then do;
     1303 				call THREAD_IN_CONFLICT (record_blockp, Vtocx, px);
     1304 				sc_meters.n_fmd_conflicts = sc_meters.n_fmd_conflicts + 1;
     1305 			     end;
     1306 			else if record_block.state = STATE_UNSEEN
     1307 			then do;
     1308 				record_block.state = STATE_IN_USE;
     1309 				record_block.vtocx = Vtocx;
     1310 				record_block.pageno = px;
     1311 			     end;
     1312 			else if record_block.state = STATE_IN_USE
     1313 			then do;
     1314 				if record_block.vtocx ^= Vtocx | record_block.pageno ^= px
     1315 				then call THREAD_IN_CONFLICT (record_blockp, Vtocx, px);
     1316 			     end;
     1317 			else if record_block.state = STATE_FREE | record_block.state = STATE_CONFLICT
     1318 			then call THREAD_IN_CONFLICT (record_blockp, Vtocx, px);
     1319 
     1320 
     1321 			record_block.lock = "0"b;
     1322 		     end;
     1323 	end;
     1324      end CHECK_FILE_MAP;
     1325 
     1326 /*  Internal Procedure to check whether a VTOCE should be freed, or perhaps
     1327*   already is free.
     1328**/
     1329 
     1330 CHECK_VTOCE_FOR_FREE:
     1331      proc (Vtocep, Meter_It, Reason, Free_It);
     1332 
     1333 dcl	Vtocep			ptr;
     1334 dcl	Reason			char (*);
     1335 dcl	Meter_It			bit (1) aligned;
     1336 dcl	Free_It			bit (1) aligned;
     1337 
     1338 dcl	1 Vtoce			aligned like vtoce based (Vtocep);
     1339 
     1340 
     1341 	Free_It = "0"b;
     1342 
     1343 	if Vtoce.uid = ""b
     1344 	then do;
     1345 		Free_It = "1"b;
     1346 		Reason = "lost";
     1347 	     end;
     1348 	else if ^Vtoce.dirsw
     1349 	then do;
     1350 		if Vtoce.per_process & (Vtoce.uid_path (1) ^= active_hardcore_data$pdd_uid)
     1351 		then do;
     1352 			Free_It = "1"b;
     1353 			Reason = "per-process";
     1354 			if Meter_It
     1355 			then sc_meters.n_vtoces_per_proc = sc_meters.n_vtoces_per_proc + 1;
     1356 		     end;
     1357 		else if Vtoce.deciduous & (Vtoce.uid_path (1) ^= active_hardcore_data$sl1_uid)
     1358 		then do;
     1359 			Free_It = "1"b;
     1360 			Reason = "deciduous";
     1361 			if Meter_It
     1362 			then sc_meters.n_vtoces_per_boot = sc_meters.n_vtoces_per_boot + 1;
     1363 		     end;
     1364 		else if Vtoce.perm_flags.per_bootload & (Vtoce.uid_path (1) ^= active_hardcore_data$sl1_uid)
     1365 		then do;
     1366 			Free_It = "1"b;
     1367 			Reason = "per-bootload";
     1368 			if Meter_It
     1369 			then sc_meters.n_vtoces_per_boot = sc_meters.n_vtoces_per_boot + 1;
     1370 		     end;
     1371 	     end;
     1372 
     1373      end CHECK_VTOCE_FOR_FREE;
     1374 
     1375 /*  Internal Procedure to report segment damage to the syserr log  */
     1376 
     1377 SEGDAMAGE:
     1378      proc (Vtocx, Vtocep, Dump_Vtocep, Prev_Damaged);
     1379 
     1380 dcl	Vtocx			fixed bin;
     1381 dcl	Vtocep			ptr;
     1382 dcl	Dump_Vtocep		ptr;
     1383 dcl	Prev_Damaged		bit (1) aligned;
     1384 
     1385 dcl	1 Vtoce			aligned like vtoce based (Vtocep);
     1386 
     1387 
     1388 	segdamage.pvid = pvte.pvid;
     1389 	segdamage.lvid = pvte.lvid;
     1390 	segdamage.uid = Vtoce.uid;
     1391 	segdamage.vtocx = Vtocx;
     1392 	segdamage.pno = -1;
     1393 	segdamage.uid_path = Vtoce.uid_path;
     1394 	call syserr$binary (SEVERITY (LOG), addr (segdamage), SB_vtoc_salv_dam, SBL_vtoc_salv_dam,
     1395 	     "scavenge_volume: ^[damaged switch found on for^;setting damaged switch on^] ^a at ^o (^a).", Prev_Damaged,
     1396 	     Vtoce.primary_name, Vtocx, device_name);
     1397 
     1398 	if ^Prev_Damaged
     1399 	then do;
     1400 		sst$damaged_ct = sst$damaged_ct + 1;
     1401 		sc_meters.n_vtoces_damaged = sc_meters.n_vtoces_damaged + 1;
     1402 		if copy_options.dump
     1403 		then call syserr$binary (SEVERITY (JUST_LOG), Dump_Vtocep, SB_vtoce, SBL_vtoce,
     1404 			"scavenge_volume: Damaged vtoce ^o (^a).", Vtocx, device_name);
     1405 	     end;
     1406 
     1407 
  1     1 /*	BEGIN INCLUDE FILE  segdamage_msg.incl.pl1 Bernard Greenberg 7/15/77 */
  1     2 
  1     3 /* This binary syserr message should be sent when the system damages a segment.
  1     4*   The value of sst$damaged_ct whould be incremented at this time. */
  1     5 
  1     6 dcl 1 segdamage aligned,
  1     7     2 pvid bit (36) aligned,			/* Volume PVID */
  1     8     2 lvid bit (36) aligned,			/* Volume LVID */
  1     9     2 pno fixed bin (17) unaligned,		/* Page number, -1 => don't know/care */
  1    10     2 vtocx fixed bin (17) unaligned,		/* VTOC index, -1 => none, -2 => don't know */
  1    11     2 uid bit (36) aligned,			/* Seg UID */
  1    12     2 uid_path (0:15) bit (36) aligned;	/* Parent dir uid path, zero padded on right */
  1    13 
  1    14 /* END INCLUDE FILE segdamage_msg.incl.pl1 */
     1408 
     1409 
     1410      end SEGDAMAGE;
     1411 
     1412 /*  Internal procedure to lock a record address  */
     1413 
     1414 LOCK_RECORD:
     1415      proc (Record_Blockp);
     1416 
     1417 dcl	Record_Blockp		ptr;
     1418 
     1419 dcl	1 A_record_block		aligned like record_block;
     1420 dcl	Ap			ptr;
     1421 dcl	locked			bit (1) aligned;
     1422 dcl	1 Q_record_block		aligned like record_block;
     1423 dcl	Qp			ptr;
     1424 dcl	Wp			ptr;
     1425 
     1426 dcl	A			bit (36) aligned based (Ap);
     1427 dcl	Q			bit (36) aligned based (Qp);
     1428 dcl	1 Record_Block		aligned like record_block based (Record_Blockp);
     1429 dcl	W			bit (36) aligned based (Wp);
     1430 
     1431 
     1432 	locked = "0"b;
     1433 	Ap = addr (A_record_block);
     1434 	Qp = addr (Q_record_block);
     1435 	Wp = Record_Blockp;
     1436 	do while (^locked);
     1437 	     unspec (Q_record_block) = unspec (Record_Block);
     1438 	     unspec (A_record_block) = unspec (Q_record_block);
     1439 	     if ^A_record_block.lock
     1440 	     then do;
     1441 		     A_record_block.lock = "1"b;
     1442 		     locked = stacq (W, A, Q);
     1443 		end;
     1444 	end;
     1445 
     1446      end LOCK_RECORD;
     1447 
     1448 /*  Internal Procedure to check whether the invoker requested an abort. */
     1449 
     1450 CHECK_ABORT:
     1451      proc;
     1452 
     1453 	call tc_util$check_abort (Code);
     1454 	if Code ^= 0
     1455 	then goto ABORT_JOIN;
     1456 
     1457      end CHECK_ABORT;
     1458 
     1459 /*  Internal Procedure to translate syserr severity codes, based on
     1460*   attendant circumstances. Only severity codes of 4 or higher are
     1461*   affected, as follows:
     1462*
     1463*   debug option in effect - all messages are printed
     1464*
     1465*   scavenge during initialization - 4 becomes 0, 5 becomes 4
     1466*
     1467*   otherwise 5 becomes 4.
     1468**/
     1469 
     1470 SEVERITY:
     1471      proc (Severity) returns (fixed bin);
     1472 
     1473 dcl	Severity			fixed bin;
     1474 
     1475 	if Severity <= BEEP
     1476 	then return (Severity);
     1477 
     1478 	if copy_options.debug
     1479 	then return (ANNOUNCE);
     1480 
     1481 	if sys_info$initialization_state < RLV_INITIALIZED
     1482 	then do;
     1483 		if Severity = LOG
     1484 		then return (ANNOUNCE);
     1485 		else return (LOG);
     1486 	     end;
     1487 
     1488 	return (LOG);
     1489 
     1490 
     1491      end SEVERITY;
     1492 
     1493 
     1494 
     1495 /*  Internal Procedure to add an entry to the thread of conflicts for this
     1496*   record address.
     1497**/
     1498 
     1499 THREAD_IN_CONFLICT:
     1500      proc (Record_Blockp, Vtocx, Page_No);
     1501 
     1502 dcl	Record_Blockp		ptr;
     1503 dcl	Vtocx			fixed bin;
     1504 dcl	Page_No			fixed bin;
     1505 
     1506 dcl	A			bit (36) aligned;
     1507 dcl	free_ix			fixed bin;
     1508 dcl	got_free			bit (1) aligned;
     1509 dcl	next_free			fixed bin;
     1510 dcl	ovfl_blockp		ptr;
     1511 dcl	Q			bit (36) aligned;
     1512 dcl	Wp			ptr;
     1513 
     1514 dcl	1 ovfl_block		aligned like record_block based (ovfl_blockp);
     1515 dcl	1 Record_Block		aligned like record_block based (Record_Blockp);
     1516 dcl	W			bit (36) aligned based (Wp);
     1517 
     1518 	if (Record_Block.state = STATE_UNSEEN) | (Record_Block.state = STATE_FREE)
     1519 	then do;
     1520 		Record_Block.vtocx = Vtocx;
     1521 		Record_Block.pageno = Page_No;
     1522 	     end;
     1523 	else if (Record_Block.vtocx ^= Vtocx) | (Record_Block.pageno ^= Page_No)
     1524 	then do;
     1525 
     1526 		got_free = "0"b;
     1527 		do while (^got_free);
     1528 		     free_ix = scavenger_block.ovfl_free_ix;
     1529 		     if free_ix <= 0 | free_ix > scavenger_block.n_ovfl
     1530 		     then do;			/* Fix damage so far and restart */
     1531 			     call syserr (ANNOUNCE, "scavenge_volume: Overflow on scavenge of ^a. Restarting.",
     1532 				device_name);
     1533 			     restart_sw = "1"b;
     1534 			     Record_Block.lock = "0"b;
     1535 			     goto RECOVER_OVERFLOW;
     1536 			end;
     1537 		     next_free = free_ix + 1;
     1538 		     Q = bit (bin (free_ix, 36), 36);
     1539 		     A = bit (bin (next_free, 36), 36);
     1540 		     Wp = addr (scavenger_block.ovfl_free_ix);
     1541 		     got_free = stacq (W, A, Q);
     1542 		end;
     1543 
     1544 		ovfl_blockp = addr (scavenger_block.overflow (free_ix));
     1545 
     1546 		ovfl_block.vtocx = Vtocx;
     1547 		ovfl_block.pageno = Page_No;
     1548 		ovfl_block.state = STATE_CONFLICT;
     1549 		ovfl_block.ovflx = Record_Block.ovflx;
     1550 		Record_Block.ovflx = free_ix;
     1551 	     end;
     1552 
     1553 	Record_Block.state = STATE_CONFLICT;
     1554 
     1555 
     1556      end THREAD_IN_CONFLICT;
     1557 
     1558 FAULT:
     1559      procedure (Lock_name);
     1560 
     1561 declare	Lock_name			char (*);
     1562 
     1563 declare	faulting_ptr		pointer;
     1564 declare	1 faulting_ptr_under_construction
     1565 				aligned like its_unsigned;
     1566 declare	foo			bit (36) aligned;	/* any old thing */
     1567 declare	based_foo			bit (36) aligned based;
     1568 
     1569 	unspec (faulting_ptr_under_construction) = ""b;
     1570 	faulting_ptr_under_construction.its_mod = "47"b3; /* DF 2 */
     1571 	unspec (faulting_ptr) = unspec (faulting_ptr_under_construction);
     1572 
     1573 	call syserr (BEEP, "scavenge_volume: Faulting under the ^a for debugging for ^a.", Lock_name,
     1574 	     pds$process_group_id);
     1575 
     1576 	foo = faulting_ptr -> based_foo;
     1577 	return;
     1578      end FAULT;
     1579 
     1580 /* format: off */
     1581   
  2     2 	/* BEGIN INCLUDE FILE add_type.incl.pl1 */
  2     3 	/* 02/26/75 by Bernard S. Greenberg */
  2     4 
  2     5 	/* This file provides a structure for checking
  2     6*		PTW/CME address type fields in PL/I */
  2     7 
  2     8 dcl 1 add_type unaligned static internal,
  2     9 	2 core bit (4) init ("1000"b),		/* in core- S/B only in PTW */
  2    10 	2 disk bit (4) init ("0100"b),		/* Disk address */
  2    11 	2 pd   bit (4) init ("0010"b),		/* Paging Device */
  2    12 	2 reserved bit (4) init ("0001"b),		/* Reserved */
  2    13 	2 non_null bit (4) init ("1111"b);		/* Not null address */
  2    14 
  2    15 dcl 1 badd_type unaligned based,
  2    16     2 (core, disk, pd, reserved) bit (1) unaligned;
  2    17 
  2    18 	/* END INCLUDE FILE add_type.incl.pl1 */
     1581 
     1582   /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  3     2 
  3     3 /* Template for an AST entry. Length = 12 words. */
  3     4 
  3     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  3     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  3     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  3     8 
  3     9 dcl  astep ptr;
  3    10 
  3    11 dcl 1 aste based (astep) aligned,
  3    12 
  3    13     (2 fp bit (18),					/* forward  used list rel pointer */
  3    14     2 bp bit (18),					/* backward used list rel pointer */
  3    15 
  3    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  3    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  3    18 
  3    19     2 strp bit (18),				/* rel pointer to process trailer */
  3    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  3    21 
  3    22     2 uid bit (36),					/* segment unique id */
  3    23 
  3    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  3    25     2 pvtx fixed bin (8),				/* physical volume table index */
  3    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    27 
  3    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  3    29     2 init bit (1),					/* used bit - insure 1 lap */
  3    30     2 gtus bit (1),					/* global transparent usage switch */
  3    31     2 gtms bit (1),					/* global transparent modified switch */
  3    32     2 hc bit (1),					/* hard core segment */
  3    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  3    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  3    35     2 write_access_on bit (1),			/* any sdw allows write access */
  3    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  3    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  3    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  3    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  3    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  3    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  3    42     2 pad1 bit (2),					/* OO */
  3    43     2 dius bit (1),					/* dumper in use switch */
  3    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  3    45     2 dmpr_pad bit (1),
  3    46     2 ehs bit (1),					/* entry hold switch */
  3    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  3    48     2 dirsw bit (1),				/* directory switch */
  3    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  3    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  3    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  3    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  3    53 
  3    54     2 dtu bit (36),					/* date and time segment last used */
  3    55 
  3    56     2 dtm bit (36),					/* date and time segment last modified */
  3    57 
  3    58 
  3    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  3    60 
  3    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  3    62 
  3    63     2 csl bit (9),					/* current segment length in 1024 words units */
  3    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  3    65     2 fms bit (1),					/* file modified switch */
  3    66     2 npfs bit (1),					/* no page fault switch */
  3    67     2 gtpd bit (1),					/* global transparent paging device switch */
  3    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  3    69     2 per_process bit (1),				/* use master quota for this entry */
  3    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  3    71     2 pad2 bit (2),
  3    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  3    73     2 np bit (9),					/* number of pages in core */
  3    74 
  3    75 
  3    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  3    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  3    78     2 damaged bit (1),				/* PC declared segment unusable */
  3    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  3    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  3    81     2 pad3 bit (6),					/* OOOOOOOOO */
  3    82     2 ptsi bit (2),					/* page table size index */
  3    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  3    84 
  3    85 
  3    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  3    87 
  3    88 
  3    89 dcl 1 aste_part aligned based (astep),
  3    90 
  3    91     2 one bit (36) unaligned,				/* fp and bp */
  3    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  3    93     2 three bit (8) unaligned;			/* ptsi and marker */
  3    94 
  3    95 
  3    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  3    97     2 pad1 bit (8*36),
  3    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  3    99     2 pad2 bit (3*36);
  3   100 
  3   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
     1582 
     1583   /* BEGIN INCLUDE FILE cmp.incl.pl1 --- October 1982 */
  4     2 /* Note: This include file has an ALM counterpart NOT made with cif (for historical reasons). Keep it up to date */
  4     3 
  4     4 dcl  cmep ptr;					/* pointer to core map entry */
  4     5 
  4     6 dcl 1 cme based (cmep) aligned,			/* core map entry */
  4     7     2 fp bit (18) unaligned,				/* forward pointer to next entry */
  4     8     2 bp bit (18) unaligned,				/* backward pointer to previous entry */
  4     9 
  4    10     2 devadd bit (22) unaligned,			/* device address of page in the core block */
  4    11     2 pad5 bit (1) unaligned,
  4    12     2 synch_held bit (1) unaligned,			/* Page of synchronized seg held in memory */
  4    13     2 io bit (1) unaligned,				/* input/output indicator 1=output, 0=input */
  4    14     2 pad2 bit (1) unaligned,
  4    15     2 er bit (1) unaligned,				/* indicates error in previous IO activity */
  4    16     2 removing bit (1) unaligned,			/* core is being removed by reconfiguration */
  4    17     2 abs_w bit (1) unaligned,			/* absolute address must not be changed for page */
  4    18     2 abs_usable bit (1) unaligned,			/* page may be assigned with fixed absolute address */
  4    19     2 notify_requested bit (1) unaligned,		/* notify requested on I/O completion */
  4    20     2 pad3 bit (1) unaligned,
  4    21     2 phm_hedge bit (1) unaligned,			/* on => pc$flush_core ought write. */
  4    22     2 contr bit (3) unaligned,			/* controller in which core block is located */
  4    23 
  4    24     2 ptwp bit (18) unaligned,			/* pointer to page table word for the page */
  4    25     2 astep bit (18) unaligned,			/* relative AST entry pointer of page */
  4    26     2 pin_counter fixed bin (17) unaligned,		/* number of times to skip eviction */
  4    27     2 synch_page_entryp bit (18) unaligned;		/* relp to synch page entry */
  4    28 
  4    29 
  4    30 dcl 1 cma (0: 1) based aligned like cme;		/* Core map array */
  4    31 
  4    32 dcl 1 mcme based (cmep) aligned,			/* core map entry for extracting DID */
  4    33     2 pad bit (36) unaligned,
  4    34     2 record_no bit (18) unaligned,			/* record number of device */
  4    35     2 add_type bit (4) unaligned,			/* see add_type.incl.pl1 */
  4    36     2 flags bit (14) unal,
  4    37     2 pad1 bit (18) unal;
  4    38 
  4    39 
  4    40 /* END INCLUDE FILE  cmp.incl.pl1 */
     1583 
     1584   /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  5     2 
  5     3 
  5     4 
  5     5 
  5     6 /****^  HISTORY COMMENTS:
  5     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  5     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  5     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  5    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  5    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  5    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  5    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  5    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  5    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18 
  5    19 /*
  5    20*   All disk packs have the standard layout described below:
  5    21*
  5    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  5    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  5    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  5    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  5    26*   Record  7		: formerly contained bad track list; no longer used.
  5    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  5    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  5    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  5    30*
  5    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  5    32*   of the particular partition.
  5    33*
  5    34*
  5    35*
  5    36*   A conceptual declaration for a disk pack could be:
  5    37*
  5    38*   dcl 1 disk_pack,
  5    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  5    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  5    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  5    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  5    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  5    44*   2 vtoc_array_records	(8 : n-1),
  5    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  5    46*   3 unused				bit(36 * 64),
  5    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  5    48*
  5    49*
  5    50*
  5    51*
  5    52**/
  5    53 
  5    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  5    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  5    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  5    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  5    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  5    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  5    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  5    61 		         fixed bin (17) int static options (constant);
  5    62 
  5    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  5    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  5    65 /* or the physical volume table entry (pvte) device type.		      */
  5    66 
  5    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  5    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  5    69 
  5    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  5    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  5    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  5    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  5    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  5    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  5    76 
  5    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
     1584 
     1585   /* BEGIN INCLUDE FILE its.incl.pl1
  6     2*   modified 27 July 79 by JRDavis to add its_unsigned
  6     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  6     4 
  6     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  6     6     2 pad1 bit (3) unaligned,
  6     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  6     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  6     9     2 pad2 bit (9) unaligned,
  6    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  6    11 
  6    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  6    13     2 pad3 bit (3) unaligned,
  6    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  6    15     2 pad4 bit (3) unaligned,
  6    16     2 mod bit (6) unaligned;				/* further modification */
  6    17 
  6    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  6    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  6    20     2 pad1 bit (27) unaligned,
  6    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  6    22 
  6    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  6    24     2 pad2 bit (3) unaligned,
  6    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  6    26     2 pad3 bit (3) unaligned,
  6    27     2 mod bit (6) unaligned;				/* further modification */
  6    28 
  6    29 
  6    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  6    31     2 pad1 bit (3) unaligned,
  6    32     2 segno fixed bin (15) unsigned unaligned,
  6    33     2 ringno fixed bin (3) unsigned unaligned,
  6    34     2 pad2 bit (9) unaligned,
  6    35     2 its_mod bit (6) unaligned,
  6    36 
  6    37     2 offset fixed bin (18) unsigned unaligned,
  6    38     2 pad3 bit (3) unaligned,
  6    39     2 bit_offset fixed bin (6) unsigned unaligned,
  6    40     2 pad4 bit (3) unaligned,
  6    41     2 mod bit (6) unaligned;
  6    42 
  6    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  6    44     2 pr_no fixed bin (3) unsigned unaligned,
  6    45     2 pad1 bit (27) unaligned,
  6    46     2 itp_mod bit (6) unaligned,
  6    47 
  6    48     2 offset fixed bin (18) unsigned unaligned,
  6    49     2 pad2 bit (3) unaligned,
  6    50     2 bit_offset fixed bin (6) unsigned unaligned,
  6    51     2 pad3 bit (3) unaligned,
  6    52     2 mod bit (6) unaligned;
  6    53 
  6    54 
  6    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  6    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  6    57 
  6    58 /* END INCLUDE FILE   its.incl.pl1 */
     1585 
     1586   /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  7     2 /* Added segmove values, Benson Margulies, 84-01 */
  7     3 
  7     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  7     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  7     6      get_aste_null_addr init			("3770110"b3),
  7     7      make_sdw_null_addr init			("3770120"b3),
  7     8      put_aste_null_addr init			("3770130"b3),
  7     9      page_bad_pd_null_addr init		("3770150"b3),
  7    10      list_deposit_null_addr init		("3770160"b3),
  7    11      get_file_map_null_addr init		("3770170"b3),
  7    12      fill_page_table_null_addr init		("3770200"b3),
  7    13      init_sst_null_addr init			("3770210"b3),
  7    14      get_file_map_vt_null_addr init		("3770220"b3),
  7    15      unprotected_null_addr init		("3770230"b3),
  7    16      page_bad_null_addr init			("3770240"b3),
  7    17      page_problem_null_addr init		("3770250"b3),
  7    18      page_parity_null_addr init		("3770260"b3),
  7    19      page_devparity_null_addr init		("3770270"b3),
  7    20      segmove_old_addr_null_addr init              ("3770300"b3),
  7    21      segmove_new_addr_null_addr init		("3770310"b3),
  7    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  7    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  7    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  7    25 
  7    26 dcl (create_vtoce_null_addr init		("777777"b3),
  7    27      update_vtoce_null_addr init		("777776"b3),
  7    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  7    29      truncate_vtoce_null_addr init		("777002"b3),
  7    30      pv_salv_null_addr init			("777004"b3),
  7    31      pv_scav_null_addr init			("777006"b3),
  7    32      volume_reloader_null_addr init		("777774"b3),
  7    33      volume_retriever_null_addr init		("777773"b3),
  7    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  7    35 
  7    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
     1586 
     1587   /* BEGIN INCLUDE FILE ... ptw.l68.incl.pl1 ... 02/26/81, for ADP conversion */
  8     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  8     3 
  8     4 dcl 1 l68_core_ptw aligned based (ptp), 		/* In-core page descriptor */
  8     5     2 frame fixed bin (14) unsigned unaligned,		/* Core frame number */
  8     6     2 pad1 bit (4) unaligned,
  8     7     2 flags unaligned like l68_ptw_flags;
  8     8 
  8     9 dcl 1 l68_ptw aligned based (ptp),			/* General declaration for out-of-core PTW */
  8    10     2 add bit (18) unaligned,
  8    11     2 flags like l68_ptw_flags unaligned;
  8    12 
  8    13 dcl 1 l68_special_ptw aligned based (ptp) like l68_ptw;	/* Page is somewhere peculiar -- add_type = "01"b */
  8    14 dcl 1 l68_real_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page actually on disk -- add_type = "10"b */
  8    15 dcl 1 l68_null_disk_ptw aligned based (ptp) like l68_ptw;	/* PTW for page not yet on disk -- add_type = "11"b */
  8    16 
  8    17 dcl 1 l68_ptw_flags unaligned based,			/* Various software/hardware flags */
  8    18    (2 add_type bit (4),				/* 0000=null, 1000=core, 0100=disk, 0010=pd, 0001=swap */
  8    19     2 first bit (1),				/* the page has not yet been written out */
  8    20     2 er bit (1),					/* error on last page I/O (also used by post-purge as temp) */
  8    21 
  8    22     2 pad1 bit (1),
  8    23     2 unusable1 bit (1),				/* can't be used because hardware resets this bit */
  8    24     2 phu bit (1),					/* page has been used bit */
  8    25 
  8    26     2 phm1 bit (1), 				/* Cumulative OR of hardware phm's */
  8    27     2 nypd bit (1), 				/* must be moved to paging device */
  8    28     2 phm bit (1),					/* page has been modified bit */
  8    29 
  8    30     2 phu1 bit (1), 				/* page has been used in the quantum */
  8    31     2 wired bit (1),				/* page is to remain in core */
  8    32     2 os bit (1),					/* page is out-of-service (I/O in progress) */
  8    33     2 valid bit (1),				/* directed fault if this is 0 (page not in core) */
  8    34     2 df_no bit (2)) unaligned;			/* directed fault number for page faults */
  8    35 
  8    36 /* END INCLUDE FILE ... ptw.l68.incl.pl1 */
     1587 
     1588   /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  9     2 
  9     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  9     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  9     8*     Add the support for subvolumes
  9     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  9    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  9    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  9    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  9    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  9    14*     Added inconsistent_dbm bit for determining the status of volume
  9    15*     dumper bit maps.
  9    16*                                                   END HISTORY COMMENTS */
  9    17 
  9    18      dcl	   pvt$array	      aligned external;
  9    19      dcl	   pvt$max_n_entries      fixed bin external;
  9    20 
  9    21      dcl	   pvt_arrayp	      ptr;
  9    22      dcl	   pvtep		      ptr;
  9    23 
  9    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  9    25 
  9    26      dcl	   1 pvte		      based (pvtep) aligned,
  9    27 
  9    28 	     2 pvid	      bit (36),		/* physical volume ID */
  9    29 
  9    30 	     2 lvid	      bit (36),		/* logical volume ID */
  9    31 
  9    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  9    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  9    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  9    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  9    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  9    37 	     2 pad3	      bit (2) unaligned,
  9    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  9    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  9    40 
  9    41 
  9    42 
  9    43 	     2 devname	      char (4),		/* device name */
  9    44 
  9    45 	     (2 device_type	      fixed bin (8),	/* device type */
  9    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  9    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  9    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  9    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  9    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  9    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  9    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  9    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  9    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  9    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  9    56 	     2 scav_check_address
  9    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  9    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  9    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  9    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  9    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  9    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  9    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  9    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  9    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  9    66 
  9    67 
  9    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  9    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  9    70 
  9    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  9    72 
  9    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  9    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  9    75 
  9    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  9    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  9    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  9    79 	     2 records_per_cyl    fixed bin,
  9    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  9    81 	     2 sv_name            char (2) aligned,
  9    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  9    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  9    84 
  9    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  9    86 	     2 pad2	      bit (18) unaligned,
  9    87 
  9    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  9    89 
  9    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  9    91 
  9    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  9    93 
  9    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  9    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  9    96 
  9    97 
  9    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  9    99 
  9   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  9   101 
  9   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  9   103 
  9   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  9   105 
  9   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  9   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  9   108 
  9   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  9   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  9   111 
  9   112 
  9   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  9   114 	   VOLMAP_ASYNC_READ      init (1),
  9   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  9   116 
  9   117 
  9   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1588 
     1589   /*  START OF:	scavenger_data.incl.pl1   November 1982       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 10     2 
 10     3 /* format: style3 */
 10     4 dcl	scavenger_data$	external;
 10     5 
 10     6 dcl	scavenger_datap	ptr;
 10     7 dcl	sc_metersp	ptr;
 10     8 dcl	sc_process_tablep	ptr;
 10     9 dcl	scavenger_blockp	ptr;
 10    10 dcl	record_blockp	ptr;
 10    11 dcl	scavenger_optionsp	ptr;
 10    12 
 10    13 dcl	sc_n_processes	fixed bin;
 10    14 dcl	scavenger_n_records fixed bin;
 10    15 dcl	scavenger_n_ovfl	fixed bin;
 10    16 
 10    17 
 10    18 dcl	1 scavenger_data	aligned based (scavenger_datap),
 10    19 	  2 lock		aligned,			/* Lock on scavenger_data */
 10    20 	    3 lock_word	bit (36) aligned,
 10    21 	    3 wait_event	bit (36) aligned,
 10    22 	    3 notify_sw	bit (1) aligned,
 10    23 	  2 process_table_ptr
 10    24 			ptr,			/* Pointer to scavenger process table */
 10    25 	  2 error_severity	fixed bin,		/* Severity of unexpected error condition */
 10    26 	  2 meters	aligned like sc_meters,
 10    27 	  2 free		bit (1) aligned;		/* Available region */
 10    28 
 10    29 
 10    30 dcl	1 sc_meters	aligned based (sc_metersp),	/* Meters */
 10    31 	  2 n_scavenge	fixed bin (35),		/* Number of volume scavenges */
 10    32 	  2 pf		fixed bin (35),		/* Total page faults */
 10    33 	  2 vcpu		fixed bin (71),		/* Total virtual CPU time */
 10    34 	  2 clock_time	fixed bin (71),		/* Total clock time */
 10    35 	  2 n_vtoces	fixed bin (35),		/* Number VTOCEs examined */
 10    36 	  2 n_vtoces_damaged
 10    37 			fixed bin (35),		/* Number VTOCEs damaged by scavenge */
 10    38 	  2 n_vtoces_per_proc
 10    39 			fixed bin (35),		/* Number per-process VTOCEs freed */
 10    40 	  2 n_vtoces_per_boot
 10    41 			fixed bin (35),		/* Number per-bootload VTOCEs freed */
 10    42 	  2 n_vtoces_freed	fixed bin (35),		/* Total number VTOCEs freed */
 10    43 	  2 n_vtoces_fmd	fixed bin (35),		/* Number VTOCEs with fm_damaged reset */
 10    44 	  2 n_records	fixed bin (35),		/* Number non-null filemap entries examined */
 10    45 	  2 n_conflicts	fixed bin (35),		/* Number potential conflicts detected */
 10    46 	  2 n_fmd_conflicts fixed bin (35),		/* Number potential conflicts due to fm_damaged */
 10    47 	  2 n_real_conflicts
 10    48 			fixed bin (35),		/* Number real conflicts */
 10    49 	  2 n_lost_records	fixed bin (35);		/* Number lost records freed */
 10    50 
 10    51 
 10    52 dcl	1 sc_process_table	aligned based (sc_process_tablep),
 10    53 	  2 max_n_processes fixed bin,		/* Number of table entries */
 10    54 	  2 n_processes	fixed bin,		/* Number active entries */
 10    55 	  2 process	(sc_n_processes refer (sc_process_table.max_n_processes)) aligned,
 10    56 	    3 processid	bit (36) aligned,		/* Owner. 0=>empty */
 10    57 	    3 pvtep	ptr unal,			/* PVTE of volume being scavenged */
 10    58 	    3 blockp	ptr unal,			/* Block w/i scavenger_data */
 10    59 	    3 first_block_page
 10    60 			fixed bin,		/* Index of first page of block */
 10    61 	    3 n_block_pages fixed bin;		/* Number of pages in block */
 10    62 
 10    63 
 10    64 dcl	1 scavenger_block	aligned based (scavenger_blockp),
 10    65 	  2 n_records	fixed bin,		/* Number of record addresses */
 10    66 	  2 n_ovfl	fixed bin,		/* Number of overflow blocks */
 10    67 	  2 ovfl_free_ix	fixed bin,		/* Index of first free overflow block */
 10    68 	  2 records	(scavenger_n_records refer (scavenger_block.n_records)) aligned like record_block,
 10    69 	  2 overflow	(scavenger_n_ovfl refer (scavenger_block.n_ovfl)) aligned like record_block;
 10    70 
 10    71 
 10    72 dcl	1 record_block	aligned based (record_blockp),/* One per record address */
 10    73 	  2 vtocx		fixed bin (15) uns unal,	/* Owning VTOCE index */
 10    74 	  2 pageno	fixed bin (8) uns unal,	/* Owning page number */
 10    75 	  2 state		fixed bin (2) uns unal,	/* State */
 10    76 	  2 lock		bit (1) unal,		/* Lock bit on this block */
 10    77 	  2 ovflx		fixed bin (10) uns unal;	/* Index of first overflow block on chain */
 10    78 
 10    79 dcl	1 scavenger_data_pages
 10    80 			aligned based (scavenger_datap),
 10    81 	  2 page		(0:255) aligned,
 10    82 	    3 word	(1024) bit (36) aligned;
 10    83 
 10    84 dcl	1 scavenger_options aligned based (scavenger_optionsp),
 10    85 	  2 print_meters	bit (1) unaligned,		/* ON => meter each scavenge into the log */
 10    86 	  2 debug		bit (1) unaligned,		/* ON => do special debugging things */
 10    87 	  2 dump		bit (1) unaligned,		/* ON => dump bad VTOCEs into syserr log */
 10    88 	  2 trap		bit (1) unaligned,		/* ON => trap to BOS for debug */
 10    89 	  2 no_optimize	bit (1) unaligned,		/* ON => no VTOCE read-ahead */
 10    90 	  2 fault_under_ast bit (1) unaligned,		/* ON => fault under AST lock, benign */
 10    91 	  2 fault_under_volmap bit (1) unaligned,	/* ON => fault under volmap lock, benign */
 10    92 	  2 fault_under_pt bit (1) unaligned;		/* ON => fault inder PTL, NOT BENIGN */
 10    93 
 10    94 dcl	(
 10    95 	STATE_UNSEEN	init (0),
 10    96 	STATE_FREE	init (1),
 10    97 	STATE_IN_USE	init (2),
 10    98 	STATE_CONFLICT	init (3)
 10    99 	)		fixed bin int static options (constant);
 10   100 
 10   101 
 10   102 
 10   103 
 10   104 /*  END OF:	scavenger_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1589 
     1590   /*  START OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 11     2 
 11     3      dcl	   stock_segp	      ptr;
 11     4      dcl	   record_stockp	      ptr;
 11     5      dcl	   vtoce_stockp	      ptr;
 11     6      dcl	   stock_seg$	      ext;
 11     7 
 11     8      dcl	   n_in_record_stock      fixed bin;
 11     9      dcl	   n_volmap_pages	      fixed bin;
 11    10      dcl	   n_in_vtoce_stock	      fixed bin;
 11    11 
 11    12 
 11    13      dcl	   1 stock_seg	      aligned based (stock_segp),
 11    14 
 11    15 	     2 meters	      aligned like rsmeters,
 11    16 
 11    17 	     2 record_stock_entries fixed bin,		/* Number of entries in a record stock */
 11    18 	     2 vtoce_stock_entries fixed bin,		/* Number of entries in a VTOCE stock */
 11    19 	     2 record_stock_size  fixed bin,		/* Size of a record stock in words */
 11    20 	     2 vtoce_stock_size   fixed bin,		/* Size of a VTOCE stock in words */
 11    21 	     2 n_stock_entries    fixed bin,		/* Number of stocks of each type */
 11    22 	     2 record_stock_arrayp ptr,		/* Record stock region */
 11    23 	     2 vtoce_stock_arrayp ptr;		/* VTOCE stock region */
 11    24 
 11    25 
 11    26      dcl	   1 record_stock	      aligned based (record_stockp),
 11    27 
 11    28 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
 11    29 
 11    30 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number of addresses in stock */
 11    31 	     2 n_volmap_pages     fixed bin (18) uns unal,/* Number of pages in Volume Map */
 11    32 
 11    33 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number addresses currently free */
 11    34 	     2 n_os_in_stock      fixed bin (18) uns unal,/* Number addresses currently out-of-service */
 11    35 
 11    36 	     2 low_threshold      fixed bin (18) uns unal,/* Low threshold for withdrawing from volmap */
 11    37 	     2 high_threshold     fixed bin (18) uns unal,/* High threshold for depositing to volmap */
 11    38 
 11    39 	     2 target	      fixed bin (18) uns unal,/* Target for stock */
 11    40 	     2 stock_offset	      bit (18) unal,	/* Offset of stock in this structure */
 11    41 
 11    42 	     2 n_words_in_stock   fixed bin (18) uns unal,/* Number of words = Number of entries / 2 */
 11    43 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
 11    44 
 11    45 	     2 old_volmap_page    (3) aligned,		/* N_OLD_VOLMAP_PAGES (cif) */
 11    46 	       3 last	      fixed bin (18) uns unal,/* Roving pointer */
 11    47 	       3 pad	      bit (18) unal,
 11    48 
 11    49 	     2 volmap_page	      (n_volmap_pages refer (record_stock.n_volmap_pages)) aligned,
 11    50 	       3 n_free	      fixed bin (18) uns unal,/* Number free records in this volmap page */
 11    51 	       3 baseadd	      fixed bin (17) unal,	/* First record address described by this page */
 11    52 
 11    53 	     2 stock	      (n_in_record_stock refer (record_stock.n_in_stock)) bit (18) unal; /* Stock array of addresses */
 11    54 						/* bit 0 ON => out-of-service */
 11    55 
 11    56 
 11    57      dcl	   1 vtoce_stock	      aligned based (vtoce_stockp),
 11    58 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
 11    59 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number indices in stock */
 11    60 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number indices currently free */
 11    61 	     2 target	      fixed bin (18) uns unal,/* Target when withdrawing/depositing */
 11    62 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
 11    63 	     2 stock	      (n_in_vtoce_stock refer (vtoce_stock.n_in_stock)) fixed bin (17) unal; /* Stock array of VTOCE indices */
 11    64 
 11    65 
 11    66      dcl	   1 rsmeters	      aligned based,
 11    67 
 11    68 	     2 async_read_calls   fixed bin (35),	/* Number of asynchronous read attempts */
 11    69 	     2 async_page_reads   fixed bin (35),	/* Number of times page read was required */
 11    70 	     2 async_post_io_calls fixed bin (35),	/* Number of times read or write posted */
 11    71 	     2 deposit_calls      fixed bin (35),	/* Number of times deposit called */
 11    72 	     2 async_post_io_time fixed bin (71),	/* CPU time posting I/Os (interrupt side) */
 11    73 	     2 deposit_time	      fixed bin (71),	/* CPU time in deposit (call side) */
 11    74 	     2 low_thresh_detected fixed bin (35),	/* Number of times stock below low threshold */
 11    75 	     2 high_thresh_detected fixed bin (35),	/* Number of times stock above high threshold */
 11    76 	     2 low_thresh_fails   fixed bin (35),	/* Number of times no records in volmap */
 11    77 	     2 withdraw_stock_steps fixed bin (35),	/* Number steps thru stock in withdraw */
 11    78 	     2 withdraw_stock_losses fixed bin (35),	/* Number lockless losses */
 11    79 	     2 n_withdraw_attempt fixed bin (35),	/* Number attempts to withdraw a page */
 11    80 	     2 n_withdraw_range   fixed bin (35),	/* Number attempts to withdraw within range */
 11    81 	     2 n_pages_withdraw_stock fixed bin (35),	/* Number pages withdrawn from stock */
 11    82 	     2 n_pages_withdraw_async fixed bin (35),	/* Number pages withdrawn from volmap */
 11    83 	     2 n_v_withdraw_attempts fixed bin (35),	/* Number attempts to withdraw from volmap */
 11    84 	     2 withdraw_volmap_steps fixed bin (35),	/* Number steps thru volmap in withdraw */
 11    85 	     2 deposit_stock_steps fixed bin (35),	/* Number steps thru stock in deposit */
 11    86 	     2 deposit_stock_losses fixed bin (35),	/* Number lockless losses */
 11    87 	     2 n_deposit_attempt  fixed bin (35),	/* Number attempts to deposit a page */
 11    88 	     2 n_pages_deposit_stock fixed bin (35),	/* Number pages deposited to stock */
 11    89 	     2 n_pages_deposit_volmap fixed bin (35),	/* Number pages deposited to volmap */
 11    90 	     2 n_v_deposit_attempts fixed bin (35),	/* Number attempts to deposit to volmap */
 11    91 	     2 reset_os_calls     fixed bin (35),	/* Number calls to reset_os */
 11    92 	     2 reset_os_losses    fixed bin (35),	/* Number lockless losses */
 11    93 	     2 withdraw_calls     fixed bin (35),	/* Number calls to withdraw */
 11    94 	     2 withdraw_time      fixed bin (71),	/* CPU time in withdraw (page-fault) */
 11    95 	     2 pc_deposit_time    fixed bin (71),	/* CPU time in pc_deposit */
 11    96 	     2 pc_deposit_calls   fixed bin (35),	/* Number calls to pc_deposit */
 11    97 	     2 pc_deposit_pages   fixed bin (35),	/* Number pages deposited by pc_deposit */
 11    98 	     2 get_free_vtoce_calls fixed bin (35),	/* Number calls to get_free_vtoce */
 11    99 	     2 return_free_vtoce_call fixed bin (35),	/* Number calls to return_free_vtoce */
 11   100 	     2 deposit_vstock_calls fixed bin (35),	/* Number attempts to deposit to vtoce stock */
 11   101 	     2 deposit_vstock_fails fixed bin (35),	/* Number times deposit failed */
 11   102 	     2 withdraw_vstock_calls fixed bin (35),	/* Number attempts to withdraw from vtoce stock */
 11   103 	     2 withdraw_vstock_fails fixed bin (35),	/* Number times withdraw failed */
 11   104 	     2 deposit_vtoc_map fixed bin (35),		/* Number times vtoce deposited to map */
 11   105 	     2 withdraw_check_scav fixed bin (35),	/* Number times withdraw checked an address for scavenge */
 11   106 	     2 withdraw_conflict fixed bin (35),	/* Number times conflict found */
 11   107 	     2 pad (11)	      fixed bin (35);
 11   108 	
 11   109 
 11   110      dcl	   N_OLD_VOLMAP_PAGES     fixed bin init (3) int static options (constant);
 11   111      dcl	   DEFAULT_N_IN_RECORD_STOCK fixed bin init (104) int static options (constant);
 11   112      dcl	   DEFAULT_N_IN_VTOCE_STOCK fixed bin init (10) int static options (constant);
 11   113 
 11   114 
 11   115 /*  END OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1590 
     1591   /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
 12     2 
 12     3 /* This include file has an ALM version, keep 'em in sync. */
 12     4 
 12     5 /* format: off */
 12     6 
 12     7 /* Modified January 1984 by Paul Farley to add an array of entry values
 12     8*   to be examined by display_cpu_error. */
 12     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
 12    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
 12    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
 12    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
 12    13*		also changed some codes to "SB_unused_NN" - see line comments */
 12    14 
 12    15 /* In the future, these will be the only constants needed in this include
 12    16*file.  They are the binary data class strings for messages in the new format
 12    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
 12    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
 12    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
 12    20 
 12    21 dcl (						/* include file name */
 12    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
 12    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
 12    24 SB_mos_data_class		init ("mos"),		/* scr */
 12    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
 12    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
 12    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
 12    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
 12    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
 12    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
 12    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
 12    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
 12    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
 12    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
 12    35 ) static internal char (16) varying options (constant);
 12    36 
 12    37 
 12    38 /************************
 12    39*Once the syserr$binary is replaced with something that takes real data classes
 12    40*and all system modules and tools are upgraded to use the new interface, the
 12    41*rest of this include file may be discarded.
 12    42*************************/
 12    43 
 12    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
 12    45*   extended at any time. */
 12    46 
 12    47 dcl (
 12    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
 12    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
 12    50 SB_io_err		init (3),		SBL_io_err	init (5),
 12    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
 12    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
 12    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
 12    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
 12    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
 12    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
 12    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
 12    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
 12    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
 12    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
 12    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
 12    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
 12    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
 12    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
 12    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
 12    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
 12    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
 12    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
 12    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
 12    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
 12    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
 12    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
 12    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
 12    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
 12    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
 12    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
 12    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
 12    78   ) internal static options (constant) fixed bin;
 12    79 
 12    80 
 12    81 /* The following array is a mapping of the old syserr$binary codes into the
 12    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
 12    83*the binary data codes stored in the wired syserr log (see above) into the data
 12    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
 12    85*is also used by syserr_log_util_ to translate the data classes back into the
 12    86*corresponding binary code (for tools not yet upgraded to deal with the new
 12    87*format log messages). */
 12    88 
 12    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
 12    90 	init (	"io_status",		/* 1 */
 12    91 		"hwfault",		/* 2 */
 12    92 		"io_status",		/* 3 */
 12    93 		"unused_4",		/* 4 */
 12    94 		"mos",			/* 5 */
 12    95 
 12    96 		"unused_6",		/* 6 */
 12    97 		"unused_7",		/* 7 */
 12    98 		"unused_8",		/* 8 */
 12    99 		"unused_9",		/* 9 */ 
 12   100 		"unused_10",		/* 10 */
 12   101 
 12   102 		"segdamage",		/* 11 */
 12   103 		"unused_12",		/* 12 */
 12   104 		"segdamage",		/* 13 */
 12   105 		"unused_14",		/* 14 */
 12   106 		"unused_15",		/* 15 */
 12   107 
 12   108 		"segdamage",		/* 16 */
 12   109 		"voldamage",		/* 17 */
 12   110 		"unused_18",		/* 18 */
 12   111 		"mdc_del_uidpath",		/* 19 */
 12   112 		"io_status",		/* 20 */
 12   113 
 12   114 		"mmdam",			/* 21 */
 12   115 		"hwfault",		/* 22 */
 12   116 		"io_status",		/* 23 */
 12   117 		"mpc_poll",		/* 24 */
 12   118 		"fnp_poll",		/* 25 */
 12   119 
 12   120 		"config_deck",		/* 26 */
 12   121 		"vtoce",			/* 27 */
 12   122 		"access_audit",		/* 28 */
 12   123 		"unused_29",		/* 29 */
 12   124 		"unused_30",		/* 30 */
 12   125 		"unused_31",		/* 31 */
 12   126 		"unused_32",		/* 32 */
 12   127 		"unused_33",		/* 33 */
 12   128 		"unused_34",		/* 34 */
 12   129 		"ibm3270_mde",		/* 35 */
 12   130 		"unused_36"		/* 36 */
 12   131 	);
 12   132 
 12   133 
 12   134 /* format: on */
 12   135 
 12   136 /* These constants are used by various tools which analyze syserr messages and
 12   137*still call the old interface "syserr_log_util_". */
 12   138 
 12   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
 12   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
 12   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
 12   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
 12   143 
 12   144      dcl	   display_cpu_error_binary_defs (2) init (
 12   145 			      2,			/** SB_hw_fault */
 12   146 			      22			/** SB_verify_lock */
 12   147 			      ) internal static options (constant) fixed bin;
 12   148 
 12   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
     1591 
     1592   /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 13     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 13     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 13     4 
 13     5 /* This include file has an ALM version.  Keep 'em in sync! */
 13     6 
 13     7 dcl (
 13     8 
 13     9 /* The following constants define the message action codes.  This indicates
 13    10*how a message is to be handled.  */
 13    11 
 13    12      SYSERR_CRASH_SYSTEM	init (1),			
 13    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 13    14 
 13    15      SYSERR_TERMINATE_PROCESS	init (2),
 13    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 13    17 
 13    18      SYSERR_PRINT_WITH_ALARM	init (3),
 13    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 13    20 
 13    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 13    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 13    23 
 13    24      SYSERR_LOG_OR_PRINT	init (4),
 13    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 13    26 
 13    27      SYSERR_LOG_OR_DISCARD	init (5),
 13    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 13    29 
 13    30 
 13    31 /* The following constants are added to the normal severities to indicate
 13    32*different sorting classes of messages.  */
 13    33 
 13    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 13    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 13    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 13    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 13    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 13    39 	) fixed bin internal static options (constant);
 13    40 
 13    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     1592 
     1593   /* BEGIN INCLUDE FILE ... vol_map.incl.pl1 */
 14     2 
 14     3 dcl   vol_mapp	ptr;
 14     4 
 14     5 dcl 1 vol_map based (vol_mapp) aligned,
 14     6 
 14     7     2 n_rec fixed bin(17),				/* number of records represented in the map */
 14     8     2 base_add fixed bin(17),				/* record number for first bit in bit map */
 14     9     2 n_free_rec fixed bin(17),			/* number of free records */
 14    10     2 bit_map_n_words fixed bin(17),			/* number of words of the bit map */
 14    11     2 pad (60) bit(36),				/* pad to 64 words */
 14    12     2 bit_map (3*1024 - 64) bit(36) ;			/* bit map - the entire vol map occupies 3 records */
 14    13 
 14    14 /* END INCLUDE ... vol_map */
     1593 
     1594   /*  START OF:	vtoc_map.incl.pl1	... March 1982 ...	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 15     2 
 15     3      dcl	   vtoc_mapp	      ptr;
 15     4      dcl	   bit_map_wordp	      ptr;
 15     5 
 15     6      dcl	   1 vtoc_map	      aligned based (vtoc_mapp),
 15     7 	     2 n_vtoce	      fixed bin,		/* Number of VTOCEs on the device */
 15     8 	     2 n_free_vtoce	      fixed bin,		/* Number of free VTOCEs */
 15     9 	     2 bit_map_n_words    fixed bin,		/* Number of words in the bit map below */
 15    10 	     2 vtoc_last_recno    fixed bin,		/* Last record number in VTOC */
 15    11 	     2 pad	      (4) fixed bin,
 15    12 	     2 bit_map	      (0:1024 - 9) bit (36);	/* This structure consumes exactly 1 page */
 15    13 
 15    14      dcl	   1 bit_map_word	      aligned based (bit_map_wordp),
 15    15 	     2 pad1	      bit (1) unal,
 15    16 	     2 bits	      bit (32) unal,	/* 32 VTOCES ON => free */
 15    17 	     2 pad2	      bit (3) unal;
 15    18 
 15    19 
 15    20 
 15    21 /*  END OF:	vtoc_map.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1594 
     1595   /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 16     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 16     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 16     4 
 16     5 dcl  vtocep ptr;
 16     6 
 16     7 dcl 1 vtoce based (vtocep) aligned,
 16     8 
 16     9 
 16    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 16    11 
 16    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 16    13 
 16    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 16    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 16    16     2 records bit (9),				/* number of records used by the seg in second storage */
 16    17     2 pad2 bit (9),
 16    18 
 16    19     2 dtu bit (36),					/* date and time segment was last used */
 16    20 
 16    21     2 dtm bit (36),					/* date and time segment was last modified */
 16    22 
 16    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 16    24     2 deciduous bit (1),				/* true if hc_sdw */
 16    25     2 nid bit (1),					/* no incremental dump switch */
 16    26     2 dnzp bit (1),					/* Dont null zero pages */
 16    27     2 gtpd bit (1),					/* Global transparent paging device */
 16    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 16    29     2 damaged bit (1),				/* TRUE if contents damaged */
 16    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 16    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 16    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 16    33     2 pad3 bit (8),
 16    34     2 dirsw bit (1),				/* directory switch */
 16    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 16    36     2 pad4 bit (16)) unaligned,			/* not used */
 16    37 
 16    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 16    39 
 16    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 16    41 
 16    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 16    43 
 16    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 16    45 
 16    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 16    47 
 16    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 16    49 
 16    50 
 16    51 
 16    52 
 16    53 
 16    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 16    55 
 16    56     2 pad6 (10) bit (36),				/* not used */
 16    57 
 16    58     2 ncd bit (1),					/* no complete dump switch */
 16    59     2 pad7 bit (17),
 16    60     2 pad8 bit (18),
 16    61 
 16    62     2 dtd bit (36),					/* date-time-dumped */
 16    63 
 16    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 16    65 
 16    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 16    67 
 16    68 
 16    69 
 16    70 
 16    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 16    72 
 16    73     2 primary_name char (32),				/* primary name of the segment */
 16    74 
 16    75     2 time_created bit (36),				/* time the segment was created */
 16    76 
 16    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 16    78 
 16    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 16    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 16    81 
 16    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 16    83 
 16    84     2 access_class bit (72),				/* access class in branch */
 16    85     2 perm_flags aligned,
 16    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 16    87       3 pad9 bit (35) unal,
 16    88     2 owner bit (36);				/* pvid of this volume */
 16    89 
 16    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 16    91 
 16    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 16    93     2 pad1 bit (7*36),
 16    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 16    95     2 pad2 bit (184*36);
 16    96 
 16    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
     1595 
     1596 
     1597 /* BEGIN MESSAGE DOCUMENTATION
     1598*
     1599*   Message:
     1600*   scavenge_volume: NNN errors reading VTOCEs on dskX_NN{S}
     1601*
     1602*   S:	$info
     1603*
     1604*   T: 	During a physical volume scavenge of dskX_NN{S}
     1605*
     1606*   M:	Errors were encountered reading VTOCEs. A message describing
     1607*   each error was recorded into the syserr log. The VTOCEs with errors
     1608*   are skipped, and lost records are not recovered.
     1609*
     1610*   A:	When the volume has been repaired, rerun the scavenger to 
     1611*   recover the lost records.
     1612*
     1613*   Message:
     1614*   scavenge_volume: NNN VTOCEs on dskX_NN{S} damaged. MMM damaged during this scavenge.
     1615*
     1616*   S:	$info
     1617*
     1618*   T:	At the completion of a volume scavenge of dskX_NN{S}
     1619*
     1620*   M:	The scavenger found a total of NNN damaged segments on the volume.
     1621*   Of these, MMM were damaged by the scavenger due to inconsistencies in the
     1622*   VTOCEs for these segments. A message for each was recorded into the
     1623*   syserr log.
     1624*
     1625*   A:	Examine the syserr log to find the damaged segments and recover them.
     1626*
     1627*   Message:
     1628*   scavenge_volume: Debug Trap on scavenge of dskX_NN{S}
     1629*
     1630*   S:	$crash
     1631*
     1632*   T:	At the completion of a volume scavenge of dskX_NN{S}
     1633*
     1634*   M:	This is a debugging trap which results when scavenge_vol
     1635*   is used with the -trap control argument.
     1636*
     1637*   A:	Type GO to resume Multics operation.
     1638*
     1639*   Message:
     1640*   scavenge_volume: Out-of-service address in stock for dskX_NN{S}
     1641*
     1642*   S:	$crash
     1643*
     1644*   T:	During a scavenge of dskX_NN{S}
     1645*
     1646*   M:	While examining the record stock, and out-of-service address was
     1647*   encountered.  Due to the volume map locking protocols used, this should
     1648*   never happen. It indicates hardware or software malfunction.
     1649*
     1650*   A:	$recover
     1651*
     1652*   Message:	
     1653*   scavenge_volume: Processing vtocx NNNNN on dskX_NN{S}
     1654*
     1655*   S:	$info
     1656*
     1657*   T:	During a volume scavenge of dskX_NN{S}
     1658*
     1659*   M:	This message is printed every 2000 (octal) VTOCEs during the
     1660*   scan of the VTOC by the scavenger if scavenge_vol was invoked with
     1661*   the -debug option.
     1662*
     1663*   A:	$ignore
     1664*
     1665*   Message:
     1666*   scavenge_volume: Error reading vtocx NNNN on dskX_NN{S}. ERRORMESSAGE
     1667*
     1668*   S:	$log
     1669*
     1670*   T:	During a physical volume scavenge of dskX_NN{S}
     1671*
     1672*   M:	An error was encountered attempting to read the VTOCE indicated.
     1673*   The VTOCE is skipped, and lost records are not recovered. The count
     1674*   of volume inconsistencies is not reset to zero.
     1675*
     1676*   A:	After the problems with the volume have been repaired, run
     1677*   the scavenger again to recover lost records.
     1678*
     1679*   Message:
     1680*   scavenge_volume: Error writing vtocx NNNNN on dskX_NN{S}. ERRORMESSAGE
     1681*
     1682*   S:	$log
     1683*
     1684*   T:	During a physical volume scavenge of dskX_NN{S}
     1685*
     1686*   M:	The error indicated was encountered writing a VTOCE.
     1687*
     1688*   A:	$ignore
     1689*
     1690*   Message:
     1691*   scavenge_volume: Freed NNNN records on dskX_NN{S}
     1692*
     1693*   S:	$log
     1694*
     1695*   T:	During a physical volume scavenge of dskX_NN{S}
     1696*
     1697*   M:	NNNN records were not claimed by any VTOCE and were not listed as
     1698*   free in the volume map. These records have been freed.
     1699*
     1700*   A:	$ignore
     1701*
     1702*   Message:
     1703*   scavenge_volume: Unable to resolve conflict for address RRR on dskX_NN{S}. Error at vtocx NNNN. ERRORMESSAGE.
     1704*
     1705*   S:	$log
     1706*
     1707*   T:	During a physical volume scavenge of dskX_NN{S}
     1708*
     1709*   M:	During the VTOC walk, the scavenger found several VTOCEs claiming the
     1710*   save address RRR. It was unable to resolve the conflict due to a VTOCE read
     1711*   error.
     1712*
     1713*   A:	After the volume has been repaired, rerun the scavenger.
     1714*
     1715*   Message:
     1716*   scavenge_volume: Unable to resolve conflict for address RRR on dskX_NN{S}. astep=PTR
     1717*
     1718*   S:	$log
     1719*
     1720*   T:	During a physical volume scavenge of dskX_NN{S}
     1721*
     1722*   M:	During the scan of the VTOC, the scavenger found several VTOCEs which
     1723*   claimed the same record address RRR. It could not resolve the conflict,
     1724*   since the segment with the ASTE indicated was active and could not be
     1725*   deactivated.
     1726*
     1727*   A:	Rerun the scavenger at a later time. It may be necessary to
     1728*   wait until the next bootload.
     1729*
     1730*   Message:
     1731*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}). ref to pageno PPP at addr RRR deleted
     1732*
     1733*   S:	$log
     1734*
     1735*   T:	During a physical volume scavenge of dskX_NN{S}
     1736*
     1737*   M:	Address RRR was claimed by more than one VTOCE. The page indicated
     1738*   has been changed to a null page, and the segment has been damaged.
     1739*
     1740*   A:	Recover the segment.
     1741*
     1742*   Message:
     1743*   scavenge_volume: freeing TYPE VTOCE NAME at VTOCX (dskX_NN{S})
     1744*
     1745*   S:	$log
     1746*
     1747*   T:	During a physical volume scavenge of dskX_NN{S}
     1748*
     1749*   M:	The message appears for each VTOCE freed if scavenge_vol was
     1750*   invoked with the -debug control argument.
     1751*
     1752*   A:	$ignore
     1753*
     1754*   Message:
     1755*   scavenge_volume: Error freeing TYPE vtocx VTOCX on dskX_NN{S}. ERRORMESSAGE
     1756*
     1757*   S:	$log
     1758*
     1759*   T:	During a physical volume scavenge of dskX_NN{S}. 
     1760*
     1761*   M:	The VTOCE indicated could not be freed due to the error
     1762*   indicated.
     1763*
     1764*   A:	$ignore
     1765*
     1766*   Message:
     1767*   scavenge_volume: Freed NNN VTOCEs on dskX_NN{S}
     1768*
     1769*   S:	$log
     1770*
     1771*   T:	During a physical volume scavenge of dskX_NN{S}
     1772*
     1773*   M:	NNN VTOCEs were added to the free pool. These VTOCEs are VTOCEs
     1774*   found free but not marked as free in the VTOC map, per-process VTOCEs from
     1775*   a prior bootload, and per-bootload VTOCEs from a prior bootload.
     1776*
     1777*   Message: 
     1778*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}) disk addr RRR bad
     1779*
     1780*   S:	$log
     1781*
     1782*   T:	During a physical volume scavenge of dskX_NN{S}
     1783*
     1784*   M:	Record address RRR in the VTOCE indicated is outside of the paging 
     1785*   region for the volume. The segment has been damaged.
     1786*
     1787*   A:	Recover the segment.
     1788*
     1789*   Message:
     1790*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}). rec used changed from X to Y
     1791*
     1792*   S:	$log
     1793*
     1794*   T:	During a physical volume scavenge of dskX_NN{S}
     1795*
     1796*   M:	The records used field in the VTOCE has been corrected.  The segment
     1797*   has been damaged.
     1798*
     1799*   A:	Recover the segment.
     1800*
     1801*   Message:
     1802*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}). cur len changed from X to Y
     1803*
     1804*   S:	$log
     1805*
     1806*   T:	During a physical volume scavenge of dskX_NN{S}
     1807*
     1808*   M:	The current segment length field in the VTOCE has been corrected.
     1809*   The segment has been damaged.
     1810*
     1811*   A:	Recover the segment.
     1812*
     1813*   Message:
     1814*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}). max len changed from X to Y
     1815*
     1816*   S:	$log
     1817*
     1818*   T:	During a physical volume scavenge of dskX_NN{S}
     1819*
     1820*   M:	The max length field in the VTOCE has been corrected. The segment has
     1821*   been damaged.
     1822*
     1823*   A:	Recover the segment.
     1824*
     1825*   Message:
     1826*   scavenge_volume: vtoce NAME at VTOCX (dskX_NN{S}). time-record-product reset to zero
     1827*
     1828*   S:	$log
     1829*
     1830*   T:	During a physical volume scavenge of dskX_NN{S}
     1831*
     1832*   M:	An invalid value was found in the time-record-product field of
     1833*   the VTOCE indicated. This field has been reset to zero.
     1834*
     1835*   A:	$ignore
     1836*
     1837*   Message:
     1838*   scavenge_volume: dirsw turned off for NAME at VTOCX (dskX_NN{S})
     1839*
     1840*   S:	$log
     1841*
     1842*   T:	During a physical volume scavenge of dskX_NN{S}
     1843*
     1844*   M:	The directory switch in the VTOCE was found on for a non-directory
     1845*   segment. It has been turned off. The segment has been damaged.
     1846*
     1847*   A:	Recover the segment.
     1848*
     1849*   Message:
     1850*   scavenge_volume: Invalid File Map Checksum for NAME at VTOCX (dskX_NN{S}).
     1851*
     1852*   S:        $log
     1853*
     1854*   T:	During a physical volume scavenge of dskX_NN{S}.
     1855*
     1856*   M:	The filemap checksum was incorrect, indicating damage to the
     1857*   VTOCE. The checksum is corrected. Other damage, if found, is reported.
     1858*
     1859*   A:        $ignore
     1860*
     1861*   Message:
     1862*   scavenge_volume: damaged switch found on for NAME at VTOCX (dskX_NN{S})
     1863*
     1864*   S:	$log
     1865*
     1866*   T:	During a physical volume scavenge of dskX_NN{S}
     1867*
     1868*   M:	The damaged switch in the VTOCEwas set prior to the scavenge.
     1869*
     1870*   A:	Recover the segment.
     1871*
     1872*   Message:
     1873*   scavenge_volume: setting damaged switch on NAME at VTOCX (dskX_NN{S}).
     1874*
     1875*   S:	$log
     1876*
     1877*   T:	During a physical volume scavenge of dskX_NN{S}
     1878*
     1879*   M:	An inconsistency has been detected in the VTOCE and the damaged
     1880*   switch has been set. A message describing the inconsistency has been
     1881*   recorded in the syserr log. The binary information associated with this
     1882*   message includes the segment UID-path.
     1883*
     1884*   A:	Recover the segment.
     1885*
     1886*   Message:
     1887*   scavenge_volume: Damaged vtoce VTOCX (dskX_NN{S}).
     1888*
     1889*   S:	$log
     1890*
     1891*   T:	During a physical volume scavenge of dskX_NN{S}
     1892*
     1893*   M:	The VTOCE image before correction is recorded into
     1894*   the syserr log if scavenge_vol was invoked with the -dump control
     1895*   argument.
     1896*
     1897*   A:	$ignore
     1898*
     1899*   Message:
     1900*   scavenge_volume: Overflow on scavenge of dskX_NN{S}. Restarting.
     1901*
     1902*   S:	$info
     1903*
     1904*   T:	During a physical volume scavenge of dskX_NN{S}.
     1905*
     1906*   M:	An internal table which tracks reused record addresses overflowed.
     1907*   All conflicts detected so far are resolved, and the scavenge is restarted
     1908*   from the beginning.
     1909*
     1910*   A:	$ignore
     1911*
     1912*   Message:
     1913*   scavenge_volume: Faulting under the LOCK for debugging for USER
     1914*
     1915*   S:	$beep
     1916*
     1917*   T:	During a physical volume salvage.
     1918*
     1919*   M:	A fault tag three fault is taken to exercise fault recovery.
     1920*
     1921*   A:	$ignore
     1922*
     1923*END MESSAGE DOCUMENTATION */
     1924 
     1925      end scavenge_volume;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.7  scavenge_volume.pl1               >spec>install>1112>scavenge_volume.pl1
1408         1    08/18/77  0954.0  segdamage_msg.incl.pl1            >ldd>include>segdamage_msg.incl.pl1
1581         2    09/29/77  1502.7  add_type.incl.pl1                 >ldd>include>add_type.incl.pl1
1582         3    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
1583         4    11/23/82  0953.7  cmp.incl.pl1                      >ldd>include>cmp.incl.pl1
1584         5    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
1585         6    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
1586         7    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
1587         8    03/27/82  0430.2  ptw.l68.incl.pl1                  >ldd>include>ptw.l68.incl.pl1
1588         9    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
1589        10    02/27/84  1141.4  scavenger_data.incl.pl1           >ldd>include>scavenger_data.incl.pl1
1590        11    10/25/82  1015.6  stock_seg.incl.pl1                >ldd>include>stock_seg.incl.pl1
1591        12    03/15/85  0953.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
1592        13    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
1593        14    04/29/76  1050.5  vol_map.incl.pl1                  >ldd>include>vol_map.incl.pl1
1594        15    05/27/82  1525.9  vtoc_map.incl.pl1                 >ldd>include>vtoc_map.incl.pl1
1595        16    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A                               004210 automatic       bit(36)                  dcl 1506 in procedure "THREAD_IN_CONFLICT" set ref
                                                                                  1539* 1541
A                                      based           bit(36)                  dcl 1426 in procedure "LOCK_RECORD" ref 1442
ALL_PARTS                       000004 constant        bit(3)                   initial packed unaligned dcl 61 set ref 363* 374*
                                                                                  511* 556* 856* 879* 983* 1058*
ANNOUNCE                        000047 constant        fixed bin(17,0)          initial dcl 13-7 set ref 208* 211* 358* 1478 1483
                                                                                  1531*
A_record_block                  004154 automatic       structure                level 1 dcl 1419 set ref 1433 1438*
Ap                              004156 automatic       pointer                  dcl 1420 set ref 1433* 1442
Aste                                   based           structure                level 1 dcl 427 ref 430
Astep                                  parameter       pointer                  dcl 420 in procedure "BUILD_FILEMAP_FROM_ASTE" ref
                                                                                  417 430 430
Astep                                  parameter       pointer                  dcl 1111 in procedure "LOCK_AST_CHECK_UID" set ref
                                                                                  1106 1115* 1117*
Astep                                  parameter       pointer                  dcl 969 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 962 980* 987* 988 995 998
BEEP                            000054 constant        fixed bin(17,0)          initial dcl 13-7 set ref 1475 1573*
CRASH                           000055 constant        fixed bin(17,0)          initial dcl 13-7 set ref 222* 281*
Claims                                 parameter       bit(1)                   dcl 970 set ref 962 981* 990* 1003* 1007* 1014
Code                                   parameter       fixed bin(35,0)          dcl 971 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 962 979* 983* 984
Code                                   parameter       fixed bin(35,0)          dcl 36 in procedure "scavenge_volume" set ref 10
                                                                                  133* 402* 1453* 1454
Csl                                    parameter       fixed bin(17,0)          dcl 941 set ref 936 947* 951*
Damaged                                parameter       bit(1)                   dcl 1136 set ref 1130 1152* 1166* 1187* 1198* 1209*
                                                                                  1236*
Dump_Vtocep                            parameter       pointer                  dcl 1382 set ref 1377 1402*
File_Map                               based           structure                level 1 dcl 461 in procedure
                                                                                  "BUILD_FILEMAP_FROM_VTOCE"
File_Map                               based           structure                level 1 dcl 428 in procedure
                                                                                  "BUILD_FILEMAP_FROM_ASTE" set ref 431*
File_Map                               based           structure                level 1 dcl 1278 in procedure "CHECK_FILE_MAP"
File_Map                               based           structure                level 1 dcl 945 in procedure "COMPUTE_RECORDS_CSL"
File_Mapp                              parameter       pointer                  dcl 421 in procedure "BUILD_FILEMAP_FROM_ASTE" ref
                                                                                  417 431 435 440 442 444 446
File_Mapp                              parameter       pointer                  dcl 939 in procedure "COMPUTE_RECORDS_CSL" ref 936
                                                                                  948 949
File_Mapp                              parameter       pointer                  dcl 1269 in procedure "CHECK_FILE_MAP" ref 1265 1283
                                                                                  1283 1283 1286
File_Mapp                              parameter       pointer                  dcl 457 in procedure "BUILD_FILEMAP_FROM_VTOCE" ref
                                                                                  453 466 468
Fm_Damaged                             parameter       bit(1)                   dcl 1271 ref 1265 1301
Free_It                                parameter       bit(1)                   dcl 1336 set ref 1330 1341* 1345* 1352* 1359* 1366*
GET_VTOCE_ERROR_THRESHOLD              constant        fixed bin(17,0)          initial dcl 62 ref 398
JUST_LOG                               constant        fixed bin(17,0)          initial dcl 13-7 set ref 1080* 1080* 1169* 1169*
                                                                                  1183* 1183* 1194* 1194* 1205* 1205* 1225* 1225*
                                                                                  1233* 1233* 1247* 1247* 1402* 1402*
LOG                                    constant        fixed bin(17,0)          initial dcl 13-7 set ref 366* 366* 514* 514* 557*
                                                                                  557* 625* 625* 747* 747* 830* 830* 887* 887* 1061*
                                                                                  1061* 1085* 1085* 1097* 1097* 1394* 1394* 1483
                                                                                  1485 1488
Lock_name                              parameter       char                     packed unaligned dcl 1561 set ref 1558 1573*
Loud                                   parameter       bit(1)                   dcl 1135 ref 1130 1169 1183 1194 1205 1225 1233 1247
MAX_VTOCE_PER_PACK                     constant        fixed bin(17,0)          initial dcl 5-54 ref 43 45 502 1049
Meter_It                               parameter       bit(1)                   dcl 1335 ref 1330 1354 1361 1368
N_Pages                                parameter       fixed bin(17,0)          dcl 1270 ref 1265 1282
PT_Size                                parameter       fixed bin(17,0)          dcl 422 ref 417 433
Page_No                                parameter       fixed bin(17,0)          dcl 1504 ref 1499 1521 1523 1547
Pageno                                 parameter       fixed bin(17,0)          dcl 967 ref 962 990 990 995 998
Prev_Damaged                           parameter       bit(1)                   dcl 1383 set ref 1377 1394* 1398
Pvtep                                  parameter       pointer                  dcl 32 ref 10 129
Q                               004216 automatic       bit(36)                  dcl 1511 in procedure "THREAD_IN_CONFLICT" set ref
                                                                                  1538* 1541
Q                                      based           bit(36)                  dcl 1427 in procedure "LOCK_RECORD" ref 1442
Q_record_block                  004161 automatic       structure                level 1 dcl 1422 set ref 1434 1437* 1438
Qp                              004162 automatic       pointer                  dcl 1423 set ref 1434* 1442
RLV_INITIALIZED                        constant        fixed bin(17,0)          initial dcl 63 ref 1481
Reason                                 parameter       char                     packed unaligned dcl 1334 set ref 1330 1346* 1353*
                                                                                  1360* 1367*
Record_Address                         parameter       fixed bin(18,0)          dcl 698 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  695 733* 743* 747* 813* 830* 887* 918*
Record_Address                         parameter       fixed bin(18,0)          dcl 968 in procedure "GET_VTOCE_CHECK_ADDRESS" ref
                                                                                  962 990 1003 1007
Record_Block                           based           structure                level 1 dcl 1428 in procedure "LOCK_RECORD" ref 1437
Record_Block                           based           structure                level 1 dcl 722 in procedure "RESOLVE_THIS_CONFLICT"
Record_Block                           based           structure                level 1 dcl 1515 in procedure "THREAD_IN_CONFLICT"
Record_Blockp                          parameter       pointer                  dcl 1502 in procedure "THREAD_IN_CONFLICT" ref 1499
                                                                                  1518 1518 1520 1521 1523 1523 1534 1549 1550 1553
Record_Blockp                          parameter       pointer                  dcl 1417 in procedure "LOCK_RECORD" ref 1414 1435
                                                                                  1437
Record_Blockp                          parameter       pointer                  dcl 699 in procedure "RESOLVE_THIS_CONFLICT" ref 695
                                                                                  731 790 801
Records                                parameter       fixed bin(17,0)          dcl 940 set ref 936 947* 952* 952
SBL_vtoc_salv_dam               000020 constant        fixed bin(17,0)          initial dcl 12-47 set ref 1394*
SBL_vtoce                       000001 constant        fixed bin(17,0)          initial dcl 12-47 set ref 1402*
SB_vtoc_salv_dam                000003 constant        fixed bin(17,0)          initial dcl 12-47 set ref 1394*
SB_vtoce                        000002 constant        fixed bin(17,0)          initial dcl 12-47 set ref 1402*
STATE_CONFLICT                         constant        fixed bin(17,0)          initial dcl 10-94 ref 287 643 1317 1548 1553
STATE_FREE                             constant        fixed bin(17,0)          initial dcl 10-94 ref 253 290 1317 1518
STATE_IN_USE                           constant        fixed bin(17,0)          initial dcl 10-94 ref 1308 1312
STATE_UNSEEN                           constant        fixed bin(17,0)          initial dcl 10-94 ref 287 604 790 913 1306 1518
Sc_metersp                             parameter       pointer                  dcl 35 ref 10 131
Scavenger_Options                      based           structure                level 1 dcl 69 ref 132
Scavenger_Optionsp                     parameter       pointer                  dcl 34 ref 10 132
Scavenger_blockp                       parameter       pointer                  dcl 33 ref 10 130
Severity                               parameter       fixed bin(17,0)          dcl 1473 ref 1470 1475 1475 1483
Uid                                    parameter       bit(36)                  dcl 1109 set ref 1106 1115 1117*
Vtoce                                  based           structure                level 1 dcl 1338 in procedure "CHECK_VTOCE_FOR_FREE"
Vtoce                                  based           structure                level 1 dcl 976 in procedure
                                                                                  "GET_VTOCE_CHECK_ADDRESS"
Vtoce                                  based           structure                level 1 dcl 1149 in procedure "CHECK_VTOCE"
Vtoce                                  based           structure                level 1 dcl 462 in procedure
                                                                                  "BUILD_FILEMAP_FROM_VTOCE"
Vtoce                                  based           structure                level 1 dcl 1385 in procedure "SEGDAMAGE"
Vtocep                                 parameter       pointer                  dcl 456 in procedure "BUILD_FILEMAP_FROM_VTOCE" ref
                                                                                  453 465 466 468
Vtocep                                 parameter       pointer                  dcl 1134 in procedure "CHECK_VTOCE" ref 1130 1160
                                                                                  1161 1163 1167 1168 1169 1181 1183 1183 1183 1188
                                                                                  1189 1192 1194 1194 1194 1199 1200 1203 1203 1203
                                                                                  1205 1205 1205 1210 1211 1216 1216 1222 1223 1225
                                                                                  1231 1233 1237 1238 1241 1243 1243 1243 1243 1244
                                                                                  1246 1247
Vtocep                                 parameter       pointer                  dcl 1333 in procedure "CHECK_VTOCE_FOR_FREE" ref
                                                                                  1330 1343 1348 1350 1350 1357 1357 1364 1364
Vtocep                                 parameter       pointer                  dcl 966 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 962 983* 987 990 990
Vtocep                                 parameter       pointer                  dcl 1381 in procedure "SEGDAMAGE" ref 1377 1390 1393
                                                                                  1394
Vtocx                                  parameter       fixed bin(17,0)          dcl 965 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 962 983* 987*
Vtocx                                  parameter       fixed bin(17,0)          dcl 1380 in procedure "SEGDAMAGE" set ref 1377 1391
                                                                                  1394* 1402*
Vtocx                                  parameter       fixed bin(17,0)          dcl 1110 in procedure "LOCK_AST_CHECK_UID" set ref
                                                                                  1106 1117*
Vtocx                                  parameter       fixed bin(17,0)          dcl 1503 in procedure "THREAD_IN_CONFLICT" ref 1499
                                                                                  1520 1523 1546
Vtocx                                  parameter       fixed bin(17,0)          dcl 1133 in procedure "CHECK_VTOCE" set ref 1130
                                                                                  1169* 1183* 1194* 1205* 1225* 1233* 1247*
Vtocx                                  parameter       fixed bin(17,0)          dcl 1268 in procedure "CHECK_FILE_MAP" set ref 1265
                                                                                  1303* 1309 1314 1314* 1317*
W                                      based           bit(36)                  dcl 1429 in procedure "LOCK_RECORD" ref 1442
W                                      based           bit(36)                  dcl 1516 in procedure "THREAD_IN_CONFLICT" ref 1541
Wp                              004220 automatic       pointer                  dcl 1512 in procedure "THREAD_IN_CONFLICT" set ref
                                                                                  1540* 1541
Wp                              004164 automatic       pointer                  dcl 1424 in procedure "LOCK_RECORD" set ref 1435*
                                                                                  1442
active_hardcore_data$pdd_uid    000010 external static bit(36)                  dcl 76 ref 1350
active_hardcore_data$sl1_uid    000012 external static bit(36)                  dcl 77 ref 1357 1364
add                                    based           bit(18)                  level 2 packed packed unaligned dcl 8-9 set ref 444
                                                                                  841* 1007
add_type                  0(18)        based           bit(4)                   level 3 in structure "l68_ptw" packed packed
                                                                                  unaligned dcl 8-9 in procedure "scavenge_volume"
                                                                                  set ref 435 437 444 838 840* 1000 1007
add_type                        000000 constant        structure                level 1 packed packed unaligned dcl 2-8 in procedure
                                                                                  "scavenge_volume"
add_type                  1(18)        based           bit(4)                   level 2 in structure "mcme" packed packed unaligned
                                                                                  dcl 4-32 in procedure "scavenge_volume" ref 440
                                                                                  1003
addr                                                   builtin function         dcl 124 ref 136 137 142 142 142 142 143 220 220 220
                                                                                  220 245 319 319 320 320 363 363 380 387 387 391
                                                                                  391 395 395 395 395 396 396 439 495 511 511 527
                                                                                  527 534 534 534 534 543 543 556 556 603 611 611
                                                                                  619 619 642 743 743 762 762 777 813 813 846 846
                                                                                  847 847 856 856 864 864 864 864 865 865 875 875
                                                                                  879 879 892 892 892 892 901 918 918 1002 1042 1058
                                                                                  1058 1068 1068 1243 1243 1288 1394 1394 1433 1434
                                                                                  1540 1544
addrel                                                 builtin function         dcl 124 ref 324 430 434 837 998
aste                                   based           structure                level 1 dcl 3-11 set ref 324 837 998
aste_file_map                   000243 automatic       structure                level 1 dcl 306 set ref 319 319 320 320
astep                           000126 automatic       pointer                  dcl 3-9 set ref 311* 316 316 316 316 316 319* 320
                                                                                  320 321 321 324* 324 324 522* 523 564 567 743*
                                                                                  813* 824 826 826 826 826 830* 835* 836* 837 837
                                                                                  842 843 844 846* 846 848 849 851* 918* 998
astx                            000242 automatic       fixed bin(17,0)          dcl 305 set ref 315*
base_vtocx                      000100 automatic       fixed bin(17,0)          dcl 40 set ref 497* 502 502 509 510* 1044* 1049 1049
                                                                                  1056 1057*
baseadd                  20            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 9-26
                                                                                  ref 286 608 645 1154 1155 1280 1281 1286
based_foo                              based           bit(36)                  dcl 1567 ref 1576
bin                                                    builtin function         dcl 124 ref 138 138 286 315 396 396 440 444 468 846
                                                                                  848 849 866 867 990 1003 1007 1158 1163 1181 1183
                                                                                  1183 1189 1192 1194 1194 1200 1203 1203 1203 1205
                                                                                  1205 1211 1216 1216 1538 1539
bit                                                    builtin function         dcl 124 ref 848 849 866 867 1158 1189 1200 1211 1538
                                                                                  1539
bit_map                  10            based           bit(36)                  array level 2 in structure "vtoc_map" dcl 15-6
                                                                                  in procedure "scavenge_volume" set ref 380
bit_map                 100            based           bit(36)                  array level 2 in structure "vol_map" dcl 14-5
                                                                                  in procedure "scavenge_volume" set ref 245
bit_map_n_words           3            based           fixed bin(17,0)          level 2 dcl 14-5 ref 244
bit_map_word                           based           structure                level 1 dcl 15-14
bit_map_wordp                   000154 automatic       pointer                  dcl 15-4 set ref 245* 246 250 380* 382
bit_mapx                        000174 automatic       fixed bin(17,0)          dcl 238 set ref 244* 245 248*
bits                      0(01)        based           bit(32)                  level 2 packed packed unaligned dcl 15-14 ref 246
                                                                                  250 382
bitx                            000456 automatic       fixed bin(17,0)          dcl 347 set ref 381* 382
bx                              000175 automatic       fixed bin(17,0)          dcl 239 set ref 249* 250 252*
checksum                        004056 automatic       bit(36)                  dcl 1138 in procedure "CHECK_VTOCE" set ref 1243*
                                                                                  1244
checksum                        002452 automatic       bit(36)                  dcl 701 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  762* 763
claim_count                     002453 automatic       fixed bin(17,0)          dcl 702 set ref 735* 757* 757 768 786 803
claims_address                  002454 automatic       bit(1)                   dcl 703 set ref 743* 754 813* 817 918* 924
clock                                                  builtin function         dcl 124 ref 1158
cma                                    based           structure                array level 1 dcl 4-30 set ref 439 1002
cme                                    based           structure                level 1 dcl 4-6
cmep                            000130 automatic       pointer                  dcl 4-4 set ref 439* 440 440 1002* 1003 1003
code                            001214 automatic       fixed bin(35,0)          dcl 485 in procedure "CHECK_VTOCE_DAMAGE" set ref
                                                                                  511* 512 556* 557 557*
code                            000457 automatic       fixed bin(35,0)          dcl 348 in procedure "WALK_VOLUME" set ref 363* 364
                                                                                  366* 374*
code                            003524 automatic       fixed bin(35,0)          dcl 1032 in procedure "FREE_VTOCES" set ref 1058*
                                                                                  1059 1061* 1072* 1075* 1077 1085 1085*
code                            002455 automatic       fixed bin(35,0)          dcl 704 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  743* 745 747* 813* 815 856* 857 879* 880 918* 920
conflict_block                         based           structure                level 1 dcl 721
conflict_blockp                 002456 automatic       pointer                  dcl 705 set ref 731* 740 741 775 777* 777 801* 808
                                                                                  809 898 901* 901
conflicts_unclaimed             000101 automatic       fixed bin(17,0)          dcl 41 set ref 151* 622 792* 792
convert                                                builtin function         dcl 124 ref 139
copy_options                    000102 automatic       structure                level 1 dcl 42 set ref 132*
copy_vtoce                      002460 automatic       structure                level 1 dcl 706 in procedure "RESOLVE_THIS_CONFLICT"
                                                                                  set ref 821* 892 892
copy_vtoce                      001215 automatic       structure                level 1 dcl 486 in procedure "CHECK_VTOCE_DAMAGE"
                                                                                  set ref 519* 534 534
core                            000000 constant        bit(4)                   initial level 2 packed packed unaligned dcl 2-8 ref
                                                                                  437 1000
csl                             004057 automatic       fixed bin(17,0)          dcl 1139 in procedure "CHECK_VTOCE" set ref 1156*
                                                                                  1175* 1192 1194* 1200 1203
csl                             002760 automatic       fixed bin(17,0)          dcl 707 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  847* 849 865* 866 875*
csl                      12            based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" set ref
                                                                                  849*
csl                       2(09)        based           bit(9)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1192
                                                                                  1194 1194 1200* 1243 1243
csl                       2(09) 000461 automatic       bit(9)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 350 in procedure "WALK_VOLUME" set
                                                                                  ref 396 396
csl                       2(09) 001517 automatic       bit(9)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 543 543
csl                       2(09) 003163 automatic       bit(9)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 762 762 866*
cur_fstime                      004060 automatic       bit(36)                  dcl 1140 set ref 1158* 1216 1223
damaged                   5(06) 003163 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 862 878*
damaged                   5(06) 001517 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 526 529 531
damaged                   5(06) 000461 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 350 in procedure "WALK_VOLUME" set
                                                                                  ref 392
damaged                   5(06)        based           bit(1)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1167*
                                                                                  1188* 1199* 1210* 1237*
damaged                  13(19)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" set ref
                                                                                  842 843*
damaged_sw                      001515 automatic       bit(1)                   dcl 487 set ref 527* 534 554
damaged_vtoces                  000103 automatic       bit                      dcl 43 set ref 154* 321* 392* 495
debug                     0(01) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 358
                                                                                  1080 1169 1247 1478
deciduous                 5(01)        based           bit(1)                   level 2 packed packed unaligned dcl 1338 ref 1357
deposit_list                    002030 automatic       structure                array level 1 dcl 590 set ref 597* 609 611 611 619
                                                                                  619
deposit_to_volmap         4(28)        based           bit(1)                   level 2 packed packed unaligned dcl 9-26 set ref
                                                                                  167* 176*
device_name                     000104 automatic       char(8)                  packed unaligned dcl 44 set ref 139* 208* 211* 222*
                                                                                  281* 358* 366* 514* 557* 625* 747* 830* 887* 1061*
                                                                                  1080* 1085* 1097* 1169* 1183* 1194* 1205* 1225*
                                                                                  1233* 1247* 1394* 1402* 1531*
devname                   3            based           char(4)                  level 2 dcl 9-26 set ref 139 1169*
dir_count                       002761 automatic       fixed bin(17,0)          dcl 708 set ref 735* 758* 758 768 768 803
dirsw                     5(18)        based           bit(1)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1231
                                                                                  1238*
dirsw                     5(18)        based           bit(1)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1338 in procedure "CHECK_VTOCE_FOR_FREE" ref
                                                                                  1348
dirsw                     5(18) 003163 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 758 768
disk                      0(04) 000000 constant        bit(4)                   initial level 2 packed packed unaligned dcl 2-8 ref
                                                                                  440 444 838 1003 1007
divide                                                 builtin function         dcl 124 ref 138 379
done_damage                     001516 automatic       bit(1)                   dcl 488 set ref 498* 500 505*
done_free                       003525 automatic       bit(1)                   dcl 1033 set ref 1045* 1047 1052*
done_thread                     002762 automatic       bit(1)                   dcl 709 set ref 737* 738 775* 800* 806 898*
dump                      0(02) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 519
                                                                                  821 1402
dx                              002430 automatic       fixed bin(17,0)          dcl 593 set ref 599* 606* 606 608 609 611* 612* 619
                                                                                  619*
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 826
error_table_$scavenge_aborted   000014 external static fixed bin(35,0)          dcl 78 ref 402
error_table_$vtoce_free         000016 external static fixed bin(35,0)          dcl 79 ref 1085
fault_under_ast           0(05) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 158
fault_under_pt            0(07) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 169
fault_under_volmap        0(06) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 162
faulting_ptr                    004230 automatic       pointer                  dcl 1563 set ref 1571* 1576
faulting_ptr_under_construction 004232 automatic       structure                level 1 dcl 1564 set ref 1569* 1571
file_map                               based           structure                level 1 dcl 67
filemap_checksum_               000044 constant        entry                    external dcl 95 ref 543 762 875 1243
fixed                                                  builtin function         dcl 124 ref 543 543 762 762 995 1243 1243
flags                     0(18)        based           structure                level 2 packed packed unaligned dcl 8-9
fm                                     based           fixed bin(18,0)          array level 2 in structure "File_Map" packed packed
                                                                                  unsigned unaligned dcl 1278 in procedure
                                                                                  "CHECK_FILE_MAP" ref 1283 1283 1283 1286
fm                       20     003163 automatic       bit(18)                  array level 2 in structure "local_vtoce" packed
                                                                                  packed unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 762 762 863* 875
                                                                                  875
fm                       20            based           bit(18)                  array level 2 in structure "Vtoce" packed packed
                                                                                  unaligned dcl 462 in procedure
                                                                                  "BUILD_FILEMAP_FROM_VTOCE" ref 465 466 468
fm                       20            based           bit(18)                  array level 2 in structure "Vtoce" packed packed
                                                                                  unaligned dcl 976 in procedure
                                                                                  "GET_VTOCE_CHECK_ADDRESS" ref 990 990
fm                       20            based           bit(18)                  array level 2 in structure "Vtoce" packed packed
                                                                                  unaligned dcl 1149 in procedure "CHECK_VTOCE" set
                                                                                  ref 1160 1161 1163 1168* 1243 1243
fm                                     based           fixed bin(18,0)          array level 2 in structure "File_Map" packed packed
                                                                                  unsigned unaligned dcl 428 in procedure
                                                                                  "BUILD_FILEMAP_FROM_ASTE" set ref 435* 440* 442*
                                                                                  444* 446*
fm                                     based           fixed bin(18,0)          array level 2 in structure "File_Map" packed packed
                                                                                  unsigned unaligned dcl 945 in procedure
                                                                                  "COMPUTE_RECORDS_CSL" ref 948 949
fm                                     based           fixed bin(18,0)          array level 2 in structure "File_Map" packed packed
                                                                                  unsigned unaligned dcl 461 in procedure
                                                                                  "BUILD_FILEMAP_FROM_VTOCE" set ref 466* 468*
fm                       20     001517 automatic       bit(18)                  array level 2 in structure "local_vtoce" packed
                                                                                  packed unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 543 543
fm_checksum               6     003163 automatic       bit(36)                  level 2 in structure "local_vtoce" dcl 711
                                                                                  in procedure "RESOLVE_THIS_CONFLICT" set ref 763
                                                                                  871* 875*
fm_checksum               6            based           bit(36)                  level 2 in structure "Vtoce" dcl 1149 in procedure
                                                                                  "CHECK_VTOCE" ref 1244
fm_checksum               6     001517 automatic       bit(36)                  level 2 in structure "local_vtoce" dcl 489
                                                                                  in procedure "CHECK_VTOCE_DAMAGE" set ref 543*
                                                                                  549*
fm_checksum_valid         5(08) 003163 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 760 870* 874*
fm_checksum_valid         5(08)        based           bit(1)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" ref 1241
fm_checksum_valid         5(08) 001517 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 545* 548*
fm_damaged                5(07) 001517 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 537 540*
fm_damaged                5(07) 000461 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 350 in procedure "WALK_VOLUME" set
                                                                                  ref 392 396
fm_damaged                5(12)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" set ref
                                                                                  320 321 564 567*
fm_damaged                5(07)        based           bit(1)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1246*
fm_damaged                5(07) 003163 automatic       bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 760 763* 766 768
fmchanged                12(09)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 set ref
                                                                                  844*
foo                             004234 automatic       bit(36)                  dcl 1566 set ref 1576*
frame                                  based           fixed bin(14,0)          level 2 packed packed unsigned unaligned dcl 8-4 ref
                                                                                  439 1002
free_it                         003526 automatic       bit(1)                   dcl 1034 in procedure "FREE_VTOCES" set ref 1068*
                                                                                  1069
free_it                         000460 automatic       bit(1)                   dcl 349 in procedure "WALK_VOLUME" set ref 387* 388
free_ix                         004211 automatic       fixed bin(17,0)          dcl 1507 set ref 1528* 1529 1529 1537 1538 1544 1550
freed_vtoces                    000106 automatic       bit                      dcl 45 set ref 153* 382* 388* 1042
fsout_vol                       000046 constant        entry                    external dcl 96 ref 204
get_vtoce_errors                000106 automatic       fixed bin(17,0)          dcl 46 set ref 150* 186 201 208 208* 368* 368 398
                                                                                  751* 751 1063* 1063
got_free                        004212 automatic       bit(1)                   dcl 1508 set ref 1526* 1527 1541*
hbound                                                 builtin function         dcl 124 ref 313 465 609 948 1160
hc                        5(04)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 826
hc_part                   5(11)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 316 826
hc_sdw                    5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 826
high_add                        004062 automatic       fixed bin(18,0)          dcl 1142 in procedure "CHECK_VTOCE" set ref 1155*
                                                                                  1164
high_add                        004076 automatic       fixed bin(18,0)          dcl 1273 in procedure "CHECK_FILE_MAP" set ref 1281*
                                                                                  1283
index                                                  builtin function         dcl 124 ref 502 1049
its_mod                   0(30) 004232 automatic       bit(6)                   level 2 packed packed unaligned dcl 1564 set ref
                                                                                  1570*
its_unsigned                           based           structure                level 1 dcl 6-30
l68_core_ptw                           based           structure                level 1 dcl 8-4
l68_ptw                                based           structure                level 1 dcl 8-9
l68_ptw_flags                          based           structure                level 1 packed packed unaligned dcl 8-17
local_file_map                  002763 automatic       structure                level 1 dcl 710 set ref 846 846 847 847 864 864 865
                                                                                  865
local_vtoce                     003527 automatic       structure                level 1 dcl 1035 in procedure "FREE_VTOCES" set ref
                                                                                  1058 1058 1068 1068
local_vtoce                     001517 automatic       structure                level 1 dcl 489 in procedure "CHECK_VTOCE_DAMAGE"
                                                                                  set ref 511 511 519 527 527 534 534 556 556
local_vtoce                     000461 automatic       structure                level 1 dcl 350 in procedure "WALK_VOLUME" set ref
                                                                                  363 363 387 387 391 391 395 395
local_vtoce                     003163 automatic       structure                level 1 dcl 711 in procedure "RESOLVE_THIS_CONFLICT"
                                                                                  set ref 743 743 813 813 821 856 856 864 864 879
                                                                                  879 892 892 918 918
lock                      0(25)        based           bit(1)                   level 2 in structure "record_block" packed packed
                                                                                  unaligned dcl 10-72 in procedure "scavenge_volume"
                                                                                  set ref 791* 914* 1321*
lock                      0(25) 004154 automatic       bit(1)                   level 2 in structure "A_record_block" packed packed
                                                                                  unaligned dcl 1419 in procedure "LOCK_RECORD" set
                                                                                  ref 1439 1441*
lock                      0(25)        based           bit(1)                   level 2 in structure "Record_Block" packed packed
                                                                                  unaligned dcl 1515 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1534*
lock$lock_ast                   000050 constant        entry                    external dcl 97 ref 156 1114
lock$unlock_ast                 000052 constant        entry                    external dcl 98 ref 179 571 756 828 859 882 886 927
                                                                                  1014
locked                          004160 automatic       bit(1)                   dcl 1421 set ref 1432* 1436 1442*
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 9-26 ref 139
low_add                         004061 automatic       fixed bin(18,0)          dcl 1141 in procedure "CHECK_VTOCE" set ref 1154*
                                                                                  1164
low_add                         004077 automatic       fixed bin(18,0)          dcl 1274 in procedure "CHECK_FILE_MAP" set ref 1280*
                                                                                  1283
lvid                      1            based           bit(36)                  level 2 in structure "pvte" dcl 9-26 in procedure
                                                                                  "scavenge_volume" ref 1231 1389
lvid                      1     004120 automatic       bit(36)                  level 2 in structure "segdamage" dcl 1-6
                                                                                  in procedure "SEGDAMAGE" set ref 1389*
mcme                                   based           structure                level 1 dcl 4-32
message                         004027 automatic       char(32)                 packed unaligned dcl 1036 set ref 1068* 1080* 1085*
mod                                                    builtin function         dcl 124 ref 358 381
msl                       2            based           bit(9)                   level 2 packed packed unaligned dcl 1149 set ref
                                                                                  1203 1203 1203 1205 1205 1211*
n_conflicts              15            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 728* 728
n_fmd_conflicts          16            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 1304* 1304
n_in_stock                1            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 11-26
                                                                                  ref 280
n_lost_records           20            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 624*
n_ovfl                    1            based           fixed bin(17,0)          level 2 dcl 10-64 ref 193 1529
n_pages                         000443 automatic       fixed bin(17,0)          dcl 307 set ref 314* 319* 320* 324
n_real_conflicts         17            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 904* 904
n_records                              based           fixed bin(17,0)          level 2 in structure "scavenger_block" dcl 10-64
                                                                                  in procedure "scavenge_volume" ref 192 193 601 641
                                                                                  777 901 1544
n_records                14            based           fixed bin(35,0)          level 2 in structure "sc_meters" dcl 10-30
                                                                                  in procedure "scavenge_volume" set ref 1287* 1287
n_volmap_pages            1(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 11-26
                                                                                  ref 281 281 286
n_vtoce                  17(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 9-26 ref 356 374
n_vtoces                  6            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 362* 362
n_vtoces_damaged          7            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 1401* 1401
n_vtoces_fmd             13            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 551* 551 566* 566
n_vtoces_freed           12            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 1096*
n_vtoces_per_boot        11            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 1361* 1361 1368* 1368
n_vtoces_per_proc        10            based           fixed bin(35,0)          level 2 dcl 10-30 set ref 1354* 1354
next_free                       004213 automatic       fixed bin(17,0)          dcl 1509 set ref 1537* 1539
no_aste                   0(18) 000034 external static bit(18)                  array level 2 packed packed unaligned dcl 86 ref 315
no_optimize               0(04) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 372
not_fmd_count                   003463 automatic       fixed bin(17,0)          dcl 712 set ref 735* 766* 766 768 803
null                                                   builtin function         dcl 124 ref 523 611 611 619 619 824 980 988 1115
old_mask                        000110 automatic       fixed bin(71,0)          dcl 47 in procedure "scavenge_volume" set ref 168*
                                                                                  175*
old_mask                        003512 automatic       fixed bin(71,0)          dcl 973 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 999* 1010*
overflow                               based           structure                array level 2 dcl 10-64 set ref 193* 777 901 1544
ovfl_block                             based           structure                level 1 dcl 1514
ovfl_blockp                     004214 automatic       pointer                  dcl 1510 set ref 1544* 1546 1547 1548 1549
ovfl_free_ix              2            based           fixed bin(17,0)          level 2 dcl 10-64 set ref 194* 1528 1540
ovflx                     0(26)        based           fixed bin(10,0)          level 2 in structure "conflict_block" packed packed
                                                                                  unsigned unaligned dcl 721 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" ref 775 777 898 901
ovflx                     0(26)        based           fixed bin(10,0)          level 2 in structure "Record_Block" packed packed
                                                                                  unsigned unaligned dcl 1515 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1549 1550*
ovflx                     0(26)        based           fixed bin(10,0)          level 2 in structure "ovfl_block" packed packed
                                                                                  unsigned unaligned dcl 1514 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1549*
owner_pageno                    003464 automatic       fixed bin(17,0)          dcl 713 set ref 772* 810 918*
owner_vtocx                     003465 automatic       fixed bin(17,0)          dcl 714 set ref 736* 771* 803* 810 910 918*
p99                                    automatic       picture(2)               packed unaligned dcl 48 ref 139
page$free_address_for_scavenge  000054 constant        entry                    external dcl 99 ref 733
page$lock_volmap                000056 constant        entry                    external dcl 101 ref 161
page$unlock_volmap              000060 constant        entry                    external dcl 102 ref 178
page_tablep                     001172 automatic       pointer                  dcl 424 set ref 430* 434
pageno                    0(15)        based           fixed bin(8,0)           level 2 in structure "conflict_block" packed packed
                                                                                  unsigned unaligned dcl 721 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" ref 741 809
pageno                          003466 automatic       fixed bin(17,0)          dcl 715 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  741* 743* 772 809* 810 813* 837 863 887*
pageno                    0(15)        based           fixed bin(8,0)           level 2 in structure "ovfl_block" packed packed
                                                                                  unsigned unaligned dcl 1514 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1547*
pageno                    0(15)        based           fixed bin(8,0)           level 2 in structure "Record_Block" packed packed
                                                                                  unsigned unaligned dcl 1515 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1521* 1523
pageno                    0(15)        based           fixed bin(8,0)           level 2 in structure "record_block" packed packed
                                                                                  unsigned unaligned dcl 10-72 in procedure
                                                                                  "scavenge_volume" set ref 1310* 1314
pc$cleanup                      000064 constant        entry                    external dcl 104 ref 836
pc$deposit_list                 000062 constant        entry                    external dcl 103 ref 611 619
pds$process_group_id            000020 external static char(32)                 packed unaligned dcl 80 set ref 1573*
per_bootload            276            based           bit(1)                   level 3 packed packed unaligned dcl 1338 ref 1364
per_process               5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 1338 ref 1350
perm_flags              276            based           structure                level 2 dcl 1338
pmut$lock_ptl                   000066 constant        entry                    external dcl 105 ref 168 999
pmut$swap_sdw                   000070 constant        entry                    external dcl 106 ref 142 220
pmut$unlock_ptl                 000072 constant        entry                    external dcl 107 ref 175 1010
pno                       2     004120 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 1-6 set ref
                                                                                  1392*
prev_damaged                    003467 automatic       bit(1)                   dcl 716 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  842* 862* 890 892*
prev_damaged                    002017 automatic       bit(1)                   dcl 490 in procedure "CHECK_VTOCE_DAMAGE" set ref
                                                                                  526* 531 534 534*
prev_fm_damaged                 002020 automatic       bit(1)                   dcl 491 set ref 539* 554
primary_name            260            based           char(32)                 level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1169*
                                                                                  1183* 1194* 1205* 1225* 1233* 1247*
primary_name            260     003163 automatic       char(32)                 level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 887*
primary_name            260            based           char(32)                 level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1385 in procedure "SEGDAMAGE" set ref 1394*
primary_name            260     003527 automatic       char(32)                 level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 1035 in procedure "FREE_VTOCES" set
                                                                                  ref 1080*
priv_delete_vtoce               000074 constant        entry                    external dcl 108 ref 1075
ptp                             000112 automatic       pointer                  dcl 49 set ref 434* 435 437 439 444 444 837* 838 840
                                                                                  841 998* 1000 1002 1007 1007
ptr                                                    builtin function         dcl 124 ref 143 144
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 3-11 ref 846 995
ptwp                            000114 automatic       pointer                  dcl 50 in procedure "scavenge_volume" set ref 168*
                                                                                  175*
ptwp                            003514 automatic       pointer                  dcl 974 in procedure "GET_VTOCE_CHECK_ADDRESS" set
                                                                                  ref 999* 1010*
pv_scav_null_addr               010165 constant        bit(18)                  initial dcl 7-26 ref 841 863 1168
pvid                                   based           bit(36)                  level 2 in structure "pvte" dcl 9-26 in procedure
                                                                                  "scavenge_volume" set ref 1075* 1117* 1388
pvid                            004120 automatic       bit(36)                  level 2 in structure "segdamage" dcl 1-6
                                                                                  in procedure "SEGDAMAGE" set ref 1388*
pvt$array                       000126 external static fixed bin(17,0)          dcl 9-18 set ref 137
pvt$root_lvid                   000022 external static bit(36)                  dcl 81 ref 1231
pvt_arrayp                      000132 automatic       pointer                  dcl 9-21 set ref 137* 138
pvte                                   based           structure                level 1 dcl 9-26 set ref 138
pvtep                           000134 automatic       pointer                  dcl 9-22 set ref 129* 138 138 139 139 139 142 142
                                                                                  143 144 161* 167 172 176 178* 188 203 216 279 286
                                                                                  356 374 401 608 645 1075 1117 1154 1155 1155 1169
                                                                                  1231 1280 1281 1281 1286 1388 1389
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" ref 316
pvtx                            000116 automatic       fixed bin(17,0)          dcl 51 in procedure "scavenge_volume" set ref 138*
                                                                                  204* 316 363* 374* 511* 556* 611* 619* 733* 856*
                                                                                  879* 983* 1058* 1072*
px                              004063 automatic       fixed bin(17,0)          dcl 1143 in procedure "CHECK_VTOCE" set ref 1160*
                                                                                  1161 1163 1168 1175*
px                              001174 automatic       fixed bin(17,0)          dcl 425 in procedure "BUILD_FILEMAP_FROM_ASTE" set
                                                                                  ref 433* 434 435 440 442 444 446*
px                              001204 automatic       fixed bin(17,0)          dcl 459 in procedure "BUILD_FILEMAP_FROM_VTOCE" set
                                                                                  ref 465* 466 466 468 468*
px                              003502 automatic       fixed bin(17,0)          dcl 943 in procedure "COMPUTE_RECORDS_CSL" set ref
                                                                                  948* 949 951*
px                              004100 automatic       fixed bin(17,0)          dcl 1275 in procedure "CHECK_FILE_MAP" set ref 1282*
                                                                                  1283 1283 1283 1286 1303* 1310 1314 1314* 1317*
px                              000444 automatic       fixed bin(17,0)          dcl 308 in procedure "WALK_SST" set ref 313* 314
                                                                                  315*
pxss$relinquish_priority        000076 constant        entry                    external dcl 109 ref 372
real_conflict                   003470 automatic       bit(1)                   dcl 717 set ref 729* 819* 904
rec_add                         000210 automatic       fixed bin(18,0)          dcl 275 in procedure "COPY_STOCK" set ref 286* 287
                                                                                  287 290
rec_add                         004101 automatic       fixed bin(18,0)          dcl 1276 in procedure "CHECK_FILE_MAP" set ref 1286*
                                                                                  1288
rec_add                         004064 automatic       fixed bin(18,0)          dcl 1144 in procedure "CHECK_VTOCE" set ref 1163*
                                                                                  1164 1164 1169*
rec_add                         000176 automatic       fixed bin(18,0)          dcl 240 in procedure "COPY_VOLMAP" set ref 252* 253
record                          002030 automatic       fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 590 set ref 608*
record_block                           based           structure                level 1 dcl 10-72
record_blockp                   000144 automatic       pointer                  dcl 10-10 set ref 603* 604 642* 643 645* 788* 791
                                                                                  912* 913 914 1288* 1292* 1303* 1306 1308 1309 1310
                                                                                  1312 1314 1314 1314* 1317 1317 1317* 1321
record_no                 1            based           bit(18)                  level 2 packed packed unaligned dcl 4-32 ref 440
                                                                                  1003
record_stock                           based           structure                level 1 dcl 11-26
record_stockp                   000146 automatic       pointer                  dcl 11-4 set ref 279* 280 281 281 286
records                         003471 automatic       fixed bin(17,0)          dcl 718 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  847* 848 865* 867
records                   2(18) 003163 automatic       bit(9)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 711 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 867*
records                   2(18)        based           bit(9)                   level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1149 in procedure "CHECK_VTOCE" set ref 1181
                                                                                  1183 1183 1189*
records                         004065 automatic       fixed bin(17,0)          dcl 1145 in procedure "CHECK_VTOCE" set ref 1156*
                                                                                  1176* 1176 1181 1183* 1189
records                   3            based           structure                array level 2 in structure "scavenger_block"
                                                                                  dcl 10-64 in procedure "scavenge_volume" set ref
                                                                                  192* 603 642 1288
records                  12(18)        based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" set ref
                                                                                  848*
records_freed                   002431 automatic       fixed bin(17,0)          dcl 594 set ref 598* 607* 607 622* 622 624 625 625*
rel                                                    builtin function         dcl 124 ref 138 138
remaining                              based           bit                      level 2 packed packed unaligned dcl 70 ref 502 1049
restart_sw                      000117 automatic       bit(1)                   dcl 52 set ref 146* 190 1533*
rsmeters                               based           structure                level 1 dcl 11-66
rtrim                                                  builtin function         dcl 124 ref 139
rx                              002432 automatic       fixed bin(17,0)          dcl 595 in procedure "FREE_RECORDS" set ref 601* 603
                                                                                  608*
rx                              002442 automatic       fixed bin(17,0)          dcl 638 in procedure "RESOLVE_CONFLICTS" set ref
                                                                                  641* 642 645*
sc_meters                              based           structure                level 1 dcl 10-30
sc_metersp                      000140 automatic       pointer                  dcl 10-7 set ref 131* 362 362 551 551 566 566 624
                                                                                  728 728 904 904 1096 1287 1287 1304 1304 1354 1354
                                                                                  1361 1361 1368 1368 1401 1401
scav_check_address        4(27)        based           bit(1)                   level 2 packed packed unaligned dcl 9-26 set ref
                                                                                  172* 188* 216* 401*
scavenger_block                        based           structure                level 1 dcl 10-64
scavenger_blockp                000142 automatic       pointer                  dcl 10-9 set ref 130* 192 193 194 253 287 287 290
                                                                                  601 603 641 642 777 901 1288 1528 1529 1540 1544
scavenger_data$                 000130 external static fixed bin(17,0)          dcl 10-4 set ref 136
scavenger_datap                 000136 automatic       pointer                  dcl 10-6 set ref 136*
scavenger_options                      based           structure                level 1 dcl 10-84
search_ast$check                000100 constant        entry                    external dcl 110 ref 1117
segdamage                       004120 automatic       structure                level 1 dcl 1-6 set ref 1394 1394
setfaults                       000102 constant        entry                    external dcl 112 ref 835
size                                                   builtin function         dcl 124 ref 138 324 430 837 998
sst$astap                       000024 external static pointer                  dcl 82 ref 311
sst$checksum_filemap            000026 external static fixed bin(35,0)          dcl 83 ref 541 868
sst$cmp                         000030 external static pointer                  dcl 84 ref 439 1002
sst$damaged_ct                  000032 external static fixed bin(35,0)          dcl 85 set ref 1400* 1400
sst$level                       000034 external static structure                array level 1 dcl 86 ref 313
sst$pts                         000036 external static fixed bin(17,0)          array dcl 89 set ref 314 846* 995
stacq                                                  builtin function         dcl 124 ref 1442 1541
state                     0(23)        based           fixed bin(2,0)           level 2 in structure "ovfl_block" packed packed
                                                                                  unsigned unaligned dcl 1514 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1548*
state                     0(23)        based           fixed bin(2,0)           level 2 in structure "record_block" packed packed
                                                                                  unsigned unaligned dcl 10-72 in procedure
                                                                                  "scavenge_volume" set ref 604 643 913* 1306 1308*
                                                                                  1312 1317 1317
state                     3(23)        based           fixed bin(2,0)           array level 3 in structure "scavenger_block" packed
                                                                                  packed unsigned unaligned dcl 10-64 in procedure
                                                                                  "scavenge_volume" set ref 253* 287 287* 290*
state                     0(23)        based           fixed bin(2,0)           level 2 in structure "Record_Block" packed packed
                                                                                  unsigned unaligned dcl 1515 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1518 1518 1553*
state                     0(23)        based           fixed bin(2,0)           level 2 in structure "Record_Block" packed packed
                                                                                  unsigned unaligned dcl 722 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" set ref 790*
stock                                  based           bit(18)                  array level 2 packed packed unaligned dcl 11-26 ref
                                                                                  281 281 286
substr                                                 builtin function         dcl 124 set ref 250 281 321* 382 382* 388* 392* 440
                                                                                  444 466 990 1003 1007 1158 1161
sv_name                  15            based           char(2)                  level 2 dcl 9-26 ref 139
sx                              000211 automatic       fixed bin(17,0)          dcl 276 set ref 280* 281 281 286*
sys_info$initialization_state   000040 external static fixed bin(17,0)          dcl 90 ref 1481
syserr                          000104 constant        entry                    external dcl 113 ref 208 211 222 281 358 625 830 887
                                                                                  1080 1097 1169 1183 1194 1205 1225 1233 1247 1531
                                                                                  1573
syserr$binary                   000106 constant        entry                    external dcl 114 ref 1394 1402
syserr$error_code               000110 constant        entry                    external dcl 115 ref 366 514 557 747 1061 1085
tc_util$check_abort             000112 constant        entry                    external dcl 116 ref 1453
totrec                    7(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 9-26 ref 1155
                                                                                  1281
trap                      0(03) 000102 automatic       bit(1)                   level 2 packed packed unaligned dcl 42 set ref 222
trp                      12            based           fixed bin(71,0)          array level 2 packed packed unaligned dcl 1149 set
                                                                                  ref 1216 1216 1222*
trp_bad                         004066 automatic       bit(1)                   dcl 1146 set ref 1214* 1216* 1219
trp_time                 16            based           bit(36)                  array level 2 packed packed unaligned dcl 1149 set
                                                                                  ref 1223*
tsdw                            000120 automatic       fixed bin(71,0)          dcl 53 set ref 219* 220 220
tx                              004067 automatic       fixed bin(17,0)          dcl 1147 set ref 1215* 1216 1216* 1221* 1222 1223*
uid                       1     003527 automatic       bit(36)                  level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 1035 in procedure "FREE_VTOCES" set
                                                                                  ref 1072 1075 1080
uid                       1            based           bit(36)                  level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 976 in procedure "GET_VTOCE_CHECK_ADDRESS" ref
                                                                                  987
uid                       3     004120 automatic       bit(36)                  level 2 in structure "segdamage" dcl 1-6
                                                                                  in procedure "SEGDAMAGE" set ref 1390*
uid                       1     001517 automatic       bit(36)                  level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 489 in procedure
                                                                                  "CHECK_VTOCE_DAMAGE" set ref 522
uid                       1            based           bit(36)                  level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1338 in procedure "CHECK_VTOCE_FOR_FREE" ref
                                                                                  1343
uid                       1     000461 automatic       bit(36)                  level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 350 in procedure "WALK_VOLUME" set
                                                                                  ref 377
uid                       1            based           bit(36)                  level 2 in structure "Vtoce" packed packed unaligned
                                                                                  dcl 1385 in procedure "SEGDAMAGE" ref 1390
uid_path                240            based           bit(36)                  array level 2 in structure "Vtoce" packed packed
                                                                                  unaligned dcl 1338 in procedure
                                                                                  "CHECK_VTOCE_FOR_FREE" ref 1350 1357 1364
uid_path                  4     004120 automatic       bit(36)                  array level 2 in structure "segdamage" dcl 1-6
                                                                                  in procedure "SEGDAMAGE" set ref 1393*
uid_path                240            based           bit(36)                  array level 2 in structure "Vtoce" packed packed
                                                                                  unaligned dcl 1385 in procedure "SEGDAMAGE" ref
                                                                                  1393
unspec                                                 builtin function         dcl 124 set ref 153* 154* 192* 193* 431* 519* 519
                                                                                  597* 821* 821 1437* 1437 1438* 1438 1569* 1571*
                                                                                  1571
update_vtoce                    000114 constant        entry                    external dcl 117 ref 851
usedf                     5            based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 316
vol_map                                based           structure                level 1 dcl 14-5
vol_mapp                        000150 automatic       pointer                  dcl 14-3 set ref 143* 144 244 245
vol_trouble_count        33            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 9-26 set ref
                                                                                  203*
volmap_abs_seg$                 000042 external static fixed bin(17,0)          dcl 91 set ref 142 142 143 220 220
volmap_offset            25            based           bit(18)                  level 2 packed packed unaligned dcl 9-26 ref 143
volmap_seg                5(23)        based           bit(1)                   level 2 packed packed unaligned dcl 3-11 ref 316
volmap_seg_sdw           22            based           fixed bin(71,0)          level 2 dcl 9-26 set ref 142 142
volmap_stock_ptr         30            based           pointer                  level 2 packed packed unaligned dcl 9-26 ref 279
vtoc_man$free_vtoce_for_scavenge
                                000116 constant        entry                    external dcl 118 ref 1072
vtoc_man$get_vtoce              000120 constant        entry                    external dcl 120 ref 363 511 856 983 1058
vtoc_man$put_vtoce              000122 constant        entry                    external dcl 121 ref 556 879
vtoc_man$read_ahead_vtoce       000124 constant        entry                    external dcl 122 ref 374
vtoc_map                               based           structure                level 1 dcl 15-6
vtoc_map_offset          25(18)        based           bit(18)                  level 2 packed packed unaligned dcl 9-26 ref 144
vtoc_mapp                       000152 automatic       pointer                  dcl 15-3 set ref 144* 380
vtoce                                  based           structure                level 1 dcl 16-7
vtoce_bits                             based           structure                level 1 dcl 70
vtoce_bitsp                     000122 automatic       pointer                  dcl 55 set ref 495* 502 1042* 1049
vtoce_file_map                  000761 automatic       structure                level 1 dcl 351 set ref 395 395 396 396
vtoces_damaged                  000124 automatic       fixed bin(17,0)          dcl 56 set ref 149* 211 211* 529* 529 893* 893
vtoces_damaged_by_me            000125 automatic       fixed bin(17,0)          dcl 57 set ref 149* 211 211* 531* 531 894* 894
vtoces_freed                    004037 automatic       fixed bin(17,0)          dcl 1037 set ref 1041* 1079* 1079 1096 1097 1097*
vtocx                           003472 automatic       fixed bin(17,0)          dcl 719 in procedure "RESOLVE_THIS_CONFLICT" set ref
                                                                                  740* 743* 747* 771 808* 810 813* 856* 879* 887*
                                                                                  892*
vtocx                           002021 automatic       fixed bin(17,0)          dcl 492 in procedure "CHECK_VTOCE_DAMAGE" set ref
                                                                                  502* 503 509* 509 510 511* 514* 522* 527* 534*
                                                                                  556* 557*
vtocx                                  based           fixed bin(15,0)          level 2 in structure "ovfl_block" packed packed
                                                                                  unsigned unaligned dcl 1514 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1546*
vtocx                     4(18)        based           fixed bin(17,0)          level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 3-11 in procedure "scavenge_volume" ref 316
                                                                                  320 321
vtocx                                  based           fixed bin(15,0)          level 2 in structure "record_block" packed packed
                                                                                  unsigned unaligned dcl 10-72 in procedure
                                                                                  "scavenge_volume" set ref 1309* 1314
vtocx                           004040 automatic       fixed bin(17,0)          dcl 1038 in procedure "FREE_VTOCES" set ref 1049*
                                                                                  1050 1056* 1056 1057 1058* 1061* 1072* 1075* 1080*
                                                                                  1085*
vtocx                                  based           fixed bin(15,0)          level 2 in structure "Record_Block" packed packed
                                                                                  unsigned unaligned dcl 1515 in procedure
                                                                                  "THREAD_IN_CONFLICT" set ref 1520* 1523
vtocx                           001161 automatic       fixed bin(17,0)          dcl 352 in procedure "WALK_VOLUME" set ref 356* 358
                                                                                  358* 363* 366* 374 374 379 381 382 388 391* 392
                                                                                  396*
vtocx                     2(18) 004120 automatic       fixed bin(17,0)          level 2 in structure "segdamage" packed packed
                                                                                  unaligned dcl 1-6 in procedure "SEGDAMAGE" set ref
                                                                                  1391*
vtocx                                  based           fixed bin(15,0)          level 2 in structure "conflict_block" packed packed
                                                                                  unsigned unaligned dcl 721 in procedure
                                                                                  "RESOLVE_THIS_CONFLICT" ref 740 808
word_baseadd                    000177 automatic       fixed bin(18,0)          dcl 241 set ref 248* 252
wordx                           001162 automatic       fixed bin(17,0)          dcl 353 set ref 379* 380

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 5-54
DEFAULT_N_IN_RECORD_STOCK              internal static fixed bin(17,0)          initial dcl 11-111
DEFAULT_N_IN_VTOCE_STOCK               internal static fixed bin(17,0)          initial dcl 11-112
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 5-54
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 6-55
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 5-54
N_OLD_VOLMAP_PAGES                     internal static fixed bin(17,0)          initial dcl 11-110
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 5-67
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 12-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 12-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 12-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 12-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 12-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 12-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 12-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 12-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 12-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 12-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 12-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 12-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 12-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 12-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 12-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 12-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 12-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 12-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 12-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 12-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 12-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 12-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 12-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 12-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 12-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 12-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 12-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 12-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 12-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 12-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 12-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 12-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 12-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 12-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 12-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 12-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 12-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 12-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 12-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 12-21
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 12-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 12-47
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 5-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 5-70
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 13-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 13-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 13-7
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 5-54
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 9-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 9-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 9-113
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 5-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 5-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 5-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 5-54
append_null_addr                       internal static bit(22)                  initial dcl 7-4
asta                                   based           bit(432)                 array dcl 3-86
aste_part                              based           structure                level 1 dcl 3-89
badd_type                              based           structure                level 1 packed packed unaligned dcl 2-15
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 7-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 7-26
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 12-144
fill_page_table_null_addr              internal static bit(22)                  initial dcl 7-4
get_aste_null_addr                     internal static bit(22)                  initial dcl 7-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 7-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 7-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 7-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 7-4
itp                                    based           structure                level 1 dcl 6-18
itp_unsigned                           based           structure                level 1 dcl 6-43
its                                    based           structure                level 1 dcl 6-5
l68_null_disk_ptw                      based           structure                level 1 dcl 8-15
l68_real_disk_ptw                      based           structure                level 1 dcl 8-14
l68_special_ptw                        based           structure                level 1 dcl 8-13
list_deposit_null_addr                 internal static bit(22)                  initial dcl 7-4
make_sdw_null_addr                     internal static bit(22)                  initial dcl 7-4
n_in_record_stock                      automatic       fixed bin(17,0)          dcl 11-8
n_in_vtoce_stock                       automatic       fixed bin(17,0)          dcl 11-10
n_volmap_pages                         automatic       fixed bin(17,0)          dcl 11-9
page_bad_null_addr                     internal static bit(22)                  initial dcl 7-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 7-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 7-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 7-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 7-4
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 7-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 7-4
put_aste_null_addr                     internal static bit(22)                  initial dcl 7-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 7-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 9-19
pvt_array                              based           structure                array level 1 dcl 9-24
salv_truncate_null_addr                internal static bit(18)                  initial dcl 7-26
sc_n_processes                         automatic       fixed bin(17,0)          dcl 10-13
sc_process_table                       based           structure                level 1 dcl 10-52
sc_process_tablep                      automatic       pointer                  dcl 10-8
scavenger_data                         based           structure                level 1 dcl 10-18
scavenger_data_pages                   based           structure                level 1 dcl 10-79
scavenger_n_ovfl                       automatic       fixed bin(17,0)          dcl 10-15
scavenger_n_records                    automatic       fixed bin(17,0)          dcl 10-14
scavenger_optionsp                     automatic       pointer                  dcl 10-11
seg_aste                               based           structure                level 1 dcl 3-96
seg_vtoce                              based           structure                level 1 dcl 16-92
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 7-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 7-4
stock_seg                              based           structure                level 1 dcl 11-13
stock_seg$                             external static fixed bin(17,0)          dcl 11-6
stock_segp                             automatic       pointer                  dcl 11-3
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 12-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 12-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 12-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 12-141
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 7-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 7-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 7-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 7-26
vastep                                 automatic       pointer                  dcl 54
volume_reloader_null_addr              internal static bit(18)                  initial dcl 7-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 7-26
vtoce_parts                            based           bit(2304)                array dcl 16-90
vtoce_stock                            based           structure                level 1 dcl 11-57
vtoce_stockp                           automatic       pointer                  dcl 11-5
vtocep                                 automatic       pointer                  dcl 16-5

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_JOIN                      001423 constant        label                    dcl 216 set ref 403 1454
BUILD_FILEMAP_FROM_ASTE         002340 constant        entry                    internal dcl 417 ref 319 846
BUILD_FILEMAP_FROM_VTOCE        002517 constant        entry                    internal dcl 453 ref 395 864
CHECK_ABORT                     007251 constant        entry                    internal dcl 1450 ref 405 613 646 1092
CHECK_FILE_MAP                  006446 constant        entry                    internal dcl 1265 ref 320 396
CHECK_VTOCE                     005435 constant        entry                    internal dcl 1130 ref 391 527
CHECK_VTOCE_DAMAGE              002564 constant        entry                    internal dcl 482 ref 198
CHECK_VTOCE_FOR_FREE            006657 constant        entry                    internal dcl 1330 ref 387 1068
COMPUTE_RECORDS_CSL             004533 constant        entry                    internal dcl 936 ref 847 865
COPY_STOCK                      001546 constant        entry                    internal dcl 272 ref 173
COPY_VOLMAP                     001475 constant        entry                    internal dcl 235 ref 165
ERROR_PUNT                      003454 constant        label                    dcl 747 ref 815 860 883
FAULT                           007517 constant        entry                    internal dcl 1558 ref 158 162 169
FREE_RECORDS                    003137 constant        entry                    internal dcl 587 ref 186
FREE_RETURN                     003645 constant        label                    dcl 788 ref 924
FREE_VTOCES                     005024 constant        entry                    internal dcl 1029 ref 199
GET_VTOCE_CHECK_ADDRESS         004565 constant        entry                    internal dcl 962 ref 743 813 918
LOCK_AST_CHECK_UID              005377 constant        entry                    internal dcl 1106 ref 522 987
LOCK_RECORD                     007214 constant        entry                    internal dcl 1414 ref 788 912 1292
NEXT                            004430 constant        label                    dcl 898 in procedure "RESOLVE_THIS_CONFLICT" ref 817
NEXT                            003135 constant        label                    dcl 573 in procedure "CHECK_VTOCE_DAMAGE" ref 506
                                                                                  516
NEXT                            005337 constant        label                    dcl 1092 in procedure "FREE_VTOCES" ref 1053 1064
NEXT_VTOCE                      002321 constant        label                    dcl 398 ref 369 384
PUNT_ASTE                       003771 constant        label                    dcl 828 set ref 838
RECOVER_OVERFLOW                001251 constant        label                    dcl 183 ref 1535
RESOLVE_CONFLICTS               003322 constant        entry                    internal dcl 635 ref 183
RESOLVE_THIS_CONFLICT           003361 constant        entry                    internal dcl 695 ref 645
RESTART                         001101 constant        label                    dcl 146 set ref 195
SEGDAMAGE                       007012 constant        entry                    internal dcl 1377 ref 534 892
SEVERITY                        007266 constant        entry                    internal dcl 1470 ref 366 366 514 514 557 557 625
                                                                                  625 747 747 830 830 887 887 1061 1061 1080 1080
                                                                                  1085 1085 1097 1097 1169 1169 1183 1183 1194 1194
                                                                                  1205 1205 1225 1225 1233 1233 1247 1247 1394 1394
                                                                                  1402 1402
THREAD_IN_CONFLICT              007323 constant        entry                    internal dcl 1499 ref 1303 1314 1317
WALK_SST                        001671 constant        entry                    internal dcl 301 ref 174
WALK_VOLUME                     002004 constant        entry                    internal dcl 344 ref 181
scavenge_volume                 000712 constant        entry                    external dcl 10

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10670       11022   10173       10700
Length     11634   10173       132         576     474           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
scavenge_volume                    2930 external procedure  is an external procedure.  
COPY_VOLMAP                             internal procedure  shares stack frame of external procedure scavenge_volume.  
COPY_STOCK                              internal procedure  shares stack frame of external procedure scavenge_volume.  
WALK_SST                                internal procedure  shares stack frame of external procedure scavenge_volume.  
WALK_VOLUME                             internal procedure  shares stack frame of external procedure scavenge_volume.  
BUILD_FILEMAP_FROM_ASTE                 internal procedure  shares stack frame of external procedure scavenge_volume.  
BUILD_FILEMAP_FROM_VTOCE                internal procedure  shares stack frame of external procedure scavenge_volume.  
CHECK_VTOCE_DAMAGE                      internal procedure  shares stack frame of external procedure scavenge_volume.  
FREE_RECORDS                            internal procedure  shares stack frame of external procedure scavenge_volume.  
RESOLVE_CONFLICTS                       internal procedure  shares stack frame of external procedure scavenge_volume.  
RESOLVE_THIS_CONFLICT                   internal procedure  shares stack frame of external procedure scavenge_volume.  
COMPUTE_RECORDS_CSL                     internal procedure  shares stack frame of external procedure scavenge_volume.  
GET_VTOCE_CHECK_ADDRESS                 internal procedure  shares stack frame of external procedure scavenge_volume.  
FREE_VTOCES                             internal procedure  shares stack frame of external procedure scavenge_volume.  
LOCK_AST_CHECK_UID                      internal procedure  shares stack frame of external procedure scavenge_volume.  
CHECK_VTOCE                             internal procedure  shares stack frame of external procedure scavenge_volume.  
CHECK_FILE_MAP                          internal procedure  shares stack frame of external procedure scavenge_volume.  
CHECK_VTOCE_FOR_FREE                    internal procedure  shares stack frame of external procedure scavenge_volume.  
SEGDAMAGE                               internal procedure  shares stack frame of external procedure scavenge_volume.  
LOCK_RECORD                             internal procedure  shares stack frame of external procedure scavenge_volume.  
CHECK_ABORT                             internal procedure  shares stack frame of external procedure scavenge_volume.  
SEVERITY                                internal procedure  shares stack frame of external procedure scavenge_volume.  
THREAD_IN_CONFLICT                      internal procedure  shares stack frame of external procedure scavenge_volume.  
FAULT                                   internal procedure  shares stack frame of external procedure scavenge_volume.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
scavenge_volume          000100 base_vtocx                  scavenge_volume
                         000101 conflicts_unclaimed         scavenge_volume
                         000102 copy_options                scavenge_volume
                         000103 damaged_vtoces              scavenge_volume
                         000104 device_name                 scavenge_volume
                         000106 freed_vtoces                scavenge_volume
                         000106 get_vtoce_errors            scavenge_volume
                         000110 old_mask                    scavenge_volume
                         000112 ptp                         scavenge_volume
                         000114 ptwp                        scavenge_volume
                         000116 pvtx                        scavenge_volume
                         000117 restart_sw                  scavenge_volume
                         000120 tsdw                        scavenge_volume
                         000122 vtoce_bitsp                 scavenge_volume
                         000124 vtoces_damaged              scavenge_volume
                         000125 vtoces_damaged_by_me        scavenge_volume
                         000126 astep                       scavenge_volume
                         000130 cmep                        scavenge_volume
                         000132 pvt_arrayp                  scavenge_volume
                         000134 pvtep                       scavenge_volume
                         000136 scavenger_datap             scavenge_volume
                         000140 sc_metersp                  scavenge_volume
                         000142 scavenger_blockp            scavenge_volume
                         000144 record_blockp               scavenge_volume
                         000146 record_stockp               scavenge_volume
                         000150 vol_mapp                    scavenge_volume
                         000152 vtoc_mapp                   scavenge_volume
                         000154 bit_map_wordp               scavenge_volume
                         000174 bit_mapx                    COPY_VOLMAP
                         000175 bx                          COPY_VOLMAP
                         000176 rec_add                     COPY_VOLMAP
                         000177 word_baseadd                COPY_VOLMAP
                         000210 rec_add                     COPY_STOCK
                         000211 sx                          COPY_STOCK
                         000242 astx                        WALK_SST
                         000243 aste_file_map               WALK_SST
                         000443 n_pages                     WALK_SST
                         000444 px                          WALK_SST
                         000456 bitx                        WALK_VOLUME
                         000457 code                        WALK_VOLUME
                         000460 free_it                     WALK_VOLUME
                         000461 local_vtoce                 WALK_VOLUME
                         000761 vtoce_file_map              WALK_VOLUME
                         001161 vtocx                       WALK_VOLUME
                         001162 wordx                       WALK_VOLUME
                         001172 page_tablep                 BUILD_FILEMAP_FROM_ASTE
                         001174 px                          BUILD_FILEMAP_FROM_ASTE
                         001204 px                          BUILD_FILEMAP_FROM_VTOCE
                         001214 code                        CHECK_VTOCE_DAMAGE
                         001215 copy_vtoce                  CHECK_VTOCE_DAMAGE
                         001515 damaged_sw                  CHECK_VTOCE_DAMAGE
                         001516 done_damage                 CHECK_VTOCE_DAMAGE
                         001517 local_vtoce                 CHECK_VTOCE_DAMAGE
                         002017 prev_damaged                CHECK_VTOCE_DAMAGE
                         002020 prev_fm_damaged             CHECK_VTOCE_DAMAGE
                         002021 vtocx                       CHECK_VTOCE_DAMAGE
                         002030 deposit_list                FREE_RECORDS
                         002430 dx                          FREE_RECORDS
                         002431 records_freed               FREE_RECORDS
                         002432 rx                          FREE_RECORDS
                         002442 rx                          RESOLVE_CONFLICTS
                         002452 checksum                    RESOLVE_THIS_CONFLICT
                         002453 claim_count                 RESOLVE_THIS_CONFLICT
                         002454 claims_address              RESOLVE_THIS_CONFLICT
                         002455 code                        RESOLVE_THIS_CONFLICT
                         002456 conflict_blockp             RESOLVE_THIS_CONFLICT
                         002460 copy_vtoce                  RESOLVE_THIS_CONFLICT
                         002760 csl                         RESOLVE_THIS_CONFLICT
                         002761 dir_count                   RESOLVE_THIS_CONFLICT
                         002762 done_thread                 RESOLVE_THIS_CONFLICT
                         002763 local_file_map              RESOLVE_THIS_CONFLICT
                         003163 local_vtoce                 RESOLVE_THIS_CONFLICT
                         003463 not_fmd_count               RESOLVE_THIS_CONFLICT
                         003464 owner_pageno                RESOLVE_THIS_CONFLICT
                         003465 owner_vtocx                 RESOLVE_THIS_CONFLICT
                         003466 pageno                      RESOLVE_THIS_CONFLICT
                         003467 prev_damaged                RESOLVE_THIS_CONFLICT
                         003470 real_conflict               RESOLVE_THIS_CONFLICT
                         003471 records                     RESOLVE_THIS_CONFLICT
                         003472 vtocx                       RESOLVE_THIS_CONFLICT
                         003502 px                          COMPUTE_RECORDS_CSL
                         003512 old_mask                    GET_VTOCE_CHECK_ADDRESS
                         003514 ptwp                        GET_VTOCE_CHECK_ADDRESS
                         003524 code                        FREE_VTOCES
                         003525 done_free                   FREE_VTOCES
                         003526 free_it                     FREE_VTOCES
                         003527 local_vtoce                 FREE_VTOCES
                         004027 message                     FREE_VTOCES
                         004037 vtoces_freed                FREE_VTOCES
                         004040 vtocx                       FREE_VTOCES
                         004056 checksum                    CHECK_VTOCE
                         004057 csl                         CHECK_VTOCE
                         004060 cur_fstime                  CHECK_VTOCE
                         004061 low_add                     CHECK_VTOCE
                         004062 high_add                    CHECK_VTOCE
                         004063 px                          CHECK_VTOCE
                         004064 rec_add                     CHECK_VTOCE
                         004065 records                     CHECK_VTOCE
                         004066 trp_bad                     CHECK_VTOCE
                         004067 tx                          CHECK_VTOCE
                         004076 high_add                    CHECK_FILE_MAP
                         004077 low_add                     CHECK_FILE_MAP
                         004100 px                          CHECK_FILE_MAP
                         004101 rec_add                     CHECK_FILE_MAP
                         004120 segdamage                   SEGDAMAGE
                         004154 A_record_block              LOCK_RECORD
                         004156 Ap                          LOCK_RECORD
                         004160 locked                      LOCK_RECORD
                         004161 Q_record_block              LOCK_RECORD
                         004162 Qp                          LOCK_RECORD
                         004164 Wp                          LOCK_RECORD
                         004210 A                           THREAD_IN_CONFLICT
                         004211 free_ix                     THREAD_IN_CONFLICT
                         004212 got_free                    THREAD_IN_CONFLICT
                         004213 next_free                   THREAD_IN_CONFLICT
                         004214 ovfl_blockp                 THREAD_IN_CONFLICT
                         004216 Q                           THREAD_IN_CONFLICT
                         004220 Wp                          THREAD_IN_CONFLICT
                         004230 faulting_ptr                FAULT
                         004232 faulting_ptr_under_construction
                                                            FAULT
                         004234 foo                         FAULT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
alloc_auto_adj      mdfx1               shorten_stack       ext_entry           index_bs_1_eis      divide_fx3
stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
filemap_checksum_             fsout_vol                     lock$lock_ast                 lock$unlock_ast
page$free_address_for_scavenge                              page$lock_volmap              page$unlock_volmap
pc$cleanup                    pc$deposit_list               pmut$lock_ptl                 pmut$swap_sdw
pmut$unlock_ptl               priv_delete_vtoce             pxss$relinquish_priority      search_ast$check
setfaults                     syserr                        syserr$binary                 syserr$error_code
tc_util$check_abort           update_vtoce                  vtoc_man$free_vtoce_for_scavenge
vtoc_man$get_vtoce            vtoc_man$put_vtoce            vtoc_man$read_ahead_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_hardcore_data$pdd_uid  active_hardcore_data$sl1_uid  error_table_$scavenge_aborted error_table_$vtoce_free
pds$process_group_id          pvt$array                     pvt$root_lvid                 scavenger_data$
sst$astap                     sst$checksum_filemap          sst$cmp                       sst$damaged_ct
sst$level                     sst$pts                       sys_info$initialization_state volmap_abs_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     10 000705        43 000717        45 000726       129 000735       130 000741       131 000744       132 000747
    133 000752       136 000753       137 000755       138 000757       139 000772       142 001046       143 001064
    144 001074       146 001101       149 001103       150 001105       151 001106       153 001107       154 001116
    156 001125       158 001132       161 001142       162 001151       165 001163       167 001164       168 001167
    169 001200       172 001213       173 001216       174 001217       175 001220       176 001231       178 001234
    179 001243       181 001250       183 001251       186 001252       188 001255       190 001260       192 001262
    193 001272       194 001303       195 001305       198 001306       199 001307       201 001310       203 001312
    204 001315       208 001327       211 001360       216 001423       219 001426       220 001430       222 001445
    226 001474       235 001475       244 001476       245 001507       246 001512       248 001515       249 001520
    250 001525       252 001532       253 001534       255 001541       257 001543       259 001545       272 001546
    279 001547       280 001552       281 001563       286 001631       287 001646       290 001661       292 001666
    294 001670       301 001671       311 001672       313 001676       314 001703       315 001706       316 001720
    319 001741       320 001745       321 001762       324 001773       325 001777       326 002001       328 002003
    344 002004       356 002005       358 002017       362 002054       363 002061       364 002106       366 002110
    368 002145       369 002146       372 002147       374 002160       377 002213       379 002215       380 002220
    381 002223       382 002227       384 002240       387 002241       388 002250       391 002260       392 002267
    395 002277       396 002305       398 002321       401 002324       402 002327       403 002333       405 002334
    406 002335       410 002337       417 002340       430 002342       431 002346       433 002353       434 002363
    435 002366       437 002404       439 002410       440 002417       442 002447       443 002457       444 002460
    446 002504       447 002514       449 002516       453 002517       465 002521       466 002525       468 002544
    469 002561       471 002563       482 002564       495 002565       497 002567       498 002570       500 002571
    502 002574       503 002604       505 002605       506 002607       509 002610       510 002613       511 002615
    512 002642       514 002644       516 002675       519 002676       522 002704       523 002710       526 002714
    527 002720       529 002726       531 002734       534 002742       537 002756       539 002761       540 002763
    541 002765       543 002770       545 003010       546 003012       548 003013       549 003015       551 003016
    554 003023       556 003030       557 003055       562 003114       564 003115       566 003121       567 003126
    571 003130       573 003135       579 003136       587 003137       597 003140       598 003143       599 003144
    601 003145       603 003155       604 003160       606 003164       607 003165       608 003166       609 003177
    611 003202       612 003227       613 003230       617 003231       619 003233       622 003262       624 003264
    625 003267       628 003321       635 003322       641 003323       642 003333       643 003336       645 003343
    646 003355       648 003356       650 003360       695 003361       728 003363       729 003370       731 003371
    733 003374       735 003406       736 003411       737 003413       738 003414       740 003416       741 003421
    743 003425       745 003452       747 003454       751 003516       752 003517       754 003520       756 003523
    757 003530       758 003531       760 003535       762 003543       763 003564       766 003571       768 003600
    771 003620       772 003622       775 003624       777 003633       779 003642       786 003643       788 003645
    790 003647       791 003655       792 003657       793 003660       800 003661       801 003662       803 003666
    806 003700       808 003702       809 003705       810 003711       813 003717       815 003744       817 003746
    819 003751       821 003753       824 003761       826 003765       828 003771       830 003776       833 004035
    835 004036       836 004051       837 004060       838 004065       840 004076       841 004100       842 004102
    843 004107       844 004111       846 004113       847 004133       848 004137       849 004146       851 004153
    854 004162       856 004163       857 004210       859 004212       860 004217       862 004220       863 004224
    864 004231       865 004237       866 004243       867 004251       868 004257       870 004262       871 004264
    872 004265       874 004266       875 004270       878 004304       879 004306       880 004333       882 004335
    883 004342       886 004343       887 004350       890 004415       892 004420       893 004426       894 004427
    898 004430       901 004437       902 004446       904 004447       910 004456       912 004461       913 004463
    914 004467       915 004471       918 004472       920 004517       924 004522       927 004525       929 004532
    936 004533       947 004535       948 004537       949 004543       951 004556       952 004561       954 004562
    956 004564       962 004565       979 004567       980 004570       981 004572       983 004573       984 004617
    987 004623       988 004641       990 004646       993 004667       995 004670       998 004702       999 004705
   1000 004715      1002 004725      1003 004734      1006 004760      1007 004761      1010 005001      1014 005012
   1018 005023      1029 005024      1041 005025      1042 005026      1044 005030      1045 005031      1047 005032
   1049 005034      1050 005044      1052 005045      1053 005047      1056 005050      1057 005053      1058 005055
   1059 005102      1061 005104      1063 005141      1064 005142      1068 005143      1069 005152      1072 005155
   1075 005177      1077 005215      1079 005217      1080 005220      1084 005272      1085 005273      1092 005337
   1094 005340      1096 005341      1097 005344      1100 005376      1106 005377      1114 005401      1115 005406
   1117 005414      1120 005434      1130 005435      1152 005437      1154 005440      1155 005444      1156 005453
   1158 005455      1160 005464      1161 005471      1163 005501      1164 005510      1166 005514      1167 005516
   1168 005520      1169 005524      1173 005603      1175 005604      1176 005607      1179 005610      1181 005612
   1183 005625      1187 005703      1188 005706      1189 005712      1192 005720      1194 005732      1198 006010
   1199 006013      1200 006017      1203 006025      1205 006044      1209 006116      1210 006121      1211 006125
   1214 006132      1215 006133      1216 006137      1218 006161      1219 006163      1221 006165      1222 006171
   1223 006201      1224 006204      1225 006206      1231 006252      1233 006265      1236 006330      1237 006333
   1238 006337      1241 006341      1243 006346      1244 006367      1246 006375      1247 006377      1254 006445
   1265 006446      1280 006450      1281 006454      1282 006463      1283 006473      1286 006512      1287 006523
   1288 006530      1292 006534      1301 006536      1303 006542      1304 006554      1305 006561      1306 006562
   1308 006567      1309 006573      1310 006600      1311 006605      1312 006606      1314 006610      1316 006633
   1317 006634      1321 006652      1323 006654      1324 006656      1330 006657      1341 006670      1343 006672
   1345 006676      1346 006700      1347 006704      1348 006705      1350 006710      1352 006717      1353 006721
   1354 006725      1356 006735      1357 006736      1359 006747      1360 006751      1361 006755      1363 006765
   1364 006766      1366 006773      1367 006775      1368 007001      1373 007011      1377 007012      1388 007014
   1389 007016      1390 007021      1391 007025      1392 007027      1393 007031      1394 007046      1398 007126
   1400 007132      1401 007137      1402 007144      1410 007213      1414 007214      1432 007216      1433 007217
   1434 007221      1435 007223      1436 007226      1437 007230      1438 007234      1439 007235      1441 007240
   1442 007242      1444 007247      1446 007250      1450 007251      1453 007252      1454 007262      1457 007265
   1470 007266      1475 007270      1478 007275      1481 007303      1483 007307      1485 007315      1488 007320
   1499 007323      1518 007325      1520 007335      1521 007342      1522 007347      1523 007350      1526 007361
   1527 007362      1528 007364      1529 007367      1531 007372      1533 007416      1534 007420      1535 007424
   1537 007425      1538 007427      1539 007435      1540 007443      1541 007445      1542 007451      1544 007452
   1546 007460      1547 007466      1548 007473      1549 007477      1550 007504      1553 007510      1556 007516
   1558 007517      1569 007530      1570 007532      1571 007534      1573 007536      1576 007570      1577 007572


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
