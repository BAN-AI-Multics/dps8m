	COMPILATION LISTING OF SEGMENT rcp_reserve_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0943.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       13 rcp_reserve_:
       14      proc (a_resource_desc_ptr, a_resource_res_ptr, a_code);
       15 
       16 /*
       17*   *       This subroutine implements reservation in RCP.  It takes a
       18*   *  reservation description and a resource description and manipulates
       19*   *  rcp_data to make the reservations.
       20*   *       This is a radical departure from RCP protocol which in the
       21*   *  past required calling rcp_initializer_ to change rcp_data_.
       22**/
       23 
       24 /*
       25*   Written by R.J.C. Kissel 5/78.
       26*   Modified by R.J.C. Kissel 1/79 to add unprivileged user reservations.
       27*   Modified by R.J.C. Kissel 3/79 to allow multiple density requests.
       28*   Modified 6/79 by Michael R. Jordan for MR7.0R.
       29*   Modified 6/81 by C. D. Tavares to make scratch tapes re-usable.
       30*   Modified 12/84 by Chris Jones for B2 security cleanup.
       31**/
       32 
       33 
       34 /****^  HISTORY COMMENTS:
       35*  1) change(85-07-12,Pozzo), approve(86-02-21,MCR7346), audit(86-07-29,Farley),
       36*     install(86-08-01,MR12.0-1108):
       37*     Modified to add auditing for denial of reservations of devices requested
       38*     by name.
       39*  2) change(85-07-24,ABall), approve(86-02-21,MCR7346), audit(86-07-29,Farley),
       40*     install(86-08-01,MR12.0-1108):
       41*     Fix bug involving validation level not being the caller's before calling
       42*     rcprm_find_resource_$(reserve reserve_proxy).
       43*  3) change(87-06-25,Rauschelbach), approve(87-06-29,MCR7736),
       44*     audit(87-07-21,Farley), install(87-08-06,MR12.1-1063):
       45*     System error message documentation was added.
       46*                                                   END HISTORY COMMENTS */
       47 
       48 
       49 /* Arguments */
       50 
       51 dcl	a_resource_desc_ptr	   ptr;			/* The resource description structure. */
       52 dcl	a_resource_res_ptr	   ptr;			/* The reservation description structure. */
       53 dcl	a_code		   fixed bin (35);		/* A standard system status code. */
       54 
       55 /* Local Variables */
       56 
       57 /* See the resource_control_desc include file for local declarations of the input argument pointers. */
       58 
       59 dcl	any_reserved	   bit (1) aligned;		/* Have any reservations been made. (for cleanup). */
       60 dcl	attributes	   char (256) varying;	/* Storage for the attributes character string. */
       61 dcl	authorization	   bit (72) aligned;	/* Authorization to be used for the reservation. */
       62 dcl	caller_level	   fixed bin;		/* Caller's validation level. */
       63 dcl	callers_resource_desc_ptr
       64 			   ptr;			/* copy of caller supplied pointer */
       65 dcl	callers_resource_res_ptr
       66 			   ptr;			/* copy of caller supplied pointer */
       67 dcl	code		   fixed bin (35);
       68 dcl	density		   bit (5) aligned;		/* Density value for a tape drive. */
       69 dcl	dtype_idx		   fixed bin;		/* Index into the dtype structure in rcpd. */
       70 dcl	i		   fixed bin;		/* Current resource index. */
       71 dcl	is_volume		   bit (1);		/* ON => resource type is a volume type */
       72 dcl	log_res_id	   char (19);
       73 dcl	model		   fixed bin (35);		/* Model number of a resource. */
       74 dcl	num_free		   fixed bin;
       75 dcl	operation		   bit (36) aligned;	/* RCP operation */
       76 dcl	primary_type	   char (32);
       77 dcl	process_id	   bit (36) aligned;
       78 dcl	1 req_info	   aligned like requestor_info;
       79 dcl	res_by		   char (32);
       80 dcl	res_for		   char (32);		/* for cleanup handling. */
       81 dcl	res_id		   fixed bin (71);		/* Copies of critical information needed */
       82 dcl	1 res_info	   aligned like resource_info;
       83 dcl	registry_directory	   char (64);		/* local var */
       84 dcl	ret_ptr		   ptr;
       85 dcl	rsc_name		   char (32);
       86 dcl	rsc_type		   char (32);
       87 dcl	saved_code	   fixed bin (35);		/* so we can remember we saw at least one error */
       88 dcl	special_rdesc_ptr	   ptr;
       89 dcl	special_resv_ptr	   ptr;
       90 dcl	speed		   bit (3) aligned;		/* Allowable speeds */
       91 dcl	system		   bit (1) aligned;		/* True if called through rcp_sys_ gate. */
       92 dcl	tot_disk_drives	   fixed bin;		/* Number of tdisk drives requested. */
       93 dcl	tot_tape_drives	   fixed bin;		/* Number of tape drives requested. */
       94 dcl	tracks		   fixed bin (35);		/* Number of tracks for a tape drive. */
       95 
       96 dcl	system_free_area	   area based (get_system_free_area_ ());
       97 
       98 /* External Entries */
       99 
      100 dcl	access_audit_r1_$log_general
      101 			   entry options (variable);
      102 dcl	admin_gate_$syserr	   entry options (variable);
      103 dcl	cu_$level_get	   entry (fixed bin);
      104 dcl	cu_$level_set	   entry (fixed bin);
      105 dcl	cv_rcp_attributes_$to_string_rel
      106 			   entry (char (*), bit (72) dim (4), char (*) varying, fixed bin (35));
      107 dcl	get_authorization_	   entry () returns (bit (72) aligned);
      108 dcl	get_ring_		   entry returns (fixed bin);
      109 dcl	get_process_id_	   entry () returns (bit (36));
      110 dcl	get_system_free_area_  entry () returns (ptr);
      111 dcl	hcs_$wakeup	   entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      112 dcl	mode_string_$parse	   entry (char (*), ptr, ptr, fixed bin (35));
      113 dcl	rcp_access_kernel_	   entry (bit (36) aligned, ptr, ptr, bit (3), fixed bin (35));
      114 dcl	rcp_pointers_$data	   entry returns (ptr);
      115 dcl	rcp_pointers_$com_seg  entry returns (ptr);
      116 dcl	rcp_lock_$lock	   entry (ptr, fixed bin (35));
      117 dcl	rcp_lock_$unlock	   entry (ptr);
      118 dcl	rcprm_find_resource_$reserve
      119 			   entry (ptr, char (*), ptr, fixed bin (35));
      120 dcl	rcprm_find_resource_$reserve_proxy
      121 			   entry (ptr, char (*), ptr, char (*), bit (72) aligned, fixed bin (35));
      122 dcl	request_id_	   entry (fixed bin (71)) returns (char (19));
      123 dcl	resource_info_$get_type
      124 			   entry (char (*), bit (1), fixed bin (35));
      125 dcl	resource_info_$get_primary_type
      126 			   entry (char (*), char (*), fixed bin (35));
      127 
      128 /* External Constants */
      129 
      130 dcl	error_table_$bad_conversion
      131 			   fixed bin (35) external;
      132 dcl	error_table_$badcall   fixed bin (35) external;
      133 dcl	error_table_$resource_unknown
      134 			   fixed bin (35) external;
      135 dcl	error_table_$reservation_failed
      136 			   fixed bin (35) external;
      137 dcl	error_table_$unimplemented_version
      138 			   fixed bin (35) external;
      139 dcl	error_table_$device_limit_exceeded
      140 			   fixed bin (35) external;
      141 
      142 dcl	access_operations_$rcp_reserve
      143 			   bit (36) aligned ext static;
      144 
      145 /* Builtin Functions and Conditions */
      146 
      147 dcl	(addr, clock, hbound, lbound, null, ptr, rel, rtrim, size, unspec)
      148 			   builtin;
      149 dcl	(cleanup)		   condition;
      150 
      151 	authorization = get_authorization_ ();
      152 	system = "0"b;
      153 	goto START;
      154 
      155 sys:
      156      entry (a_resource_desc_ptr, a_resource_res_ptr, a_authorization, a_code);
      157 
      158 dcl	a_authorization	   bit (72) aligned;
      159 
      160 	authorization = a_authorization;
      161 	system = "1"b;
      162 	goto START;
      163 
      164 START:
      165 	operation = access_operations_$rcp_reserve;
      166 
      167 	any_reserved = "0"b;
      168 	rcpd_ptr = null ();
      169 	rcs_ptr = null ();
      170 	registry_directory = ">sc1>rcp";
      171 	resource_desc_ptr = null ();
      172 	resource_res_ptr = null ();
      173 	mode_string_info_ptr = null ();
      174 	special_rdesc_ptr = null ();
      175 	special_resv_ptr = null ();
      176 
      177 	call cu_$level_get (caller_level);
      178 
      179 	on cleanup call cleanup_handler;
      180 
      181 	call cu_$level_set (get_ring_ ());
      182 
      183 	call copy_resource_and_reservation_structures;
      184 
      185 	rcpd_ptr = rcp_pointers_$data ();
      186 	rcs_ptr = rcp_pointers_$com_seg ();
      187 
      188 	res_for = reservation_description.reserved_for;
      189 	res_by = reservation_description.reserved_by;
      190 	res_id = clock ();
      191 	log_res_id = request_id_ (res_id);
      192 	process_id = get_process_id_ ();
      193 
      194 /*
      195*   *       The following code will do some consistency checks and
      196*   *  limit checks on the input structures before actually trying
      197*   *  to make the reservations.
      198**/
      199 
      200 	if ^system & (res_for ^= res_by) then
      201 	     goto BAD_NAME;
      202 
      203 	if resource_descriptions.version_no ^= resource_desc_version_1
      204 	     | reservation_description.version_no ^= resource_res_version_1 then
      205 	     goto BAD_VERSION;
      206 
      207 	if resource_descriptions.n_items ^= reservation_description.n_items | resource_descriptions.n_items = 0 then
      208 	     goto BAD_CALL;
      209 
      210 	tot_tape_drives = 0;
      211 	tot_disk_drives = 0;
      212 
      213 	saved_code = 0;
      214 	do i = 1 to Resource_count;			/* Check device limits. */
      215 
      216 	     call resource_info_$get_primary_type ((resource_descriptions.item (i).type), primary_type, code);
      217 
      218 	     if code ^= 0 then do;
      219 		rsc_type = resource_descriptions.item (i).type;
      220 		saved_code, callers_resource_desc_ptr -> resource_descriptions.item (i).status_code = code;
      221 	     end;
      222 	     else callers_resource_desc_ptr -> resource_descriptions.item (i).type = primary_type;
      223 
      224 	     if primary_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then
      225 		tot_tape_drives = tot_tape_drives + 1;
      226 
      227 	     else if primary_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
      228 		tot_disk_drives = tot_disk_drives + 1;
      229 
      230 	end;					/* Check device limits. */
      231 
      232 	if saved_code ^= 0 then
      233 	     goto BAD_RESOURCE;
      234 
      235 	if ^system then do;				/* Check all device usage for this process. */
      236 	     do device_ptr = ptr (rcpd_ptr, rcpd.dtype (TAPE_DRIVE_DTYPEX).first_off)
      237 		repeat ptr (device_ptr, device.next_off) while (rel (device_ptr) ^= ""b);
      238 
      239 		if device.state ^= FREE & device.process_id = process_id then
      240 		     tot_tape_drives = tot_tape_drives + 1;
      241 
      242 	     end;
      243 
      244 	     do device_ptr = ptr (rcpd_ptr, rcpd.dtype (DISK_DRIVE_DTYPEX).first_off)
      245 		repeat ptr (device_ptr, device.next_off) while (rel (device_ptr) ^= ""b);
      246 		if device.state ^= FREE & device.process_id = process_id then
      247 		     tot_disk_drives = tot_disk_drives + 1;
      248 
      249 	     end;
      250 	end;					/* Check all device usage for this process. */
      251 
      252 	if rcpd.dtype (TAPE_DRIVE_DTYPEX).max_concurrent < tot_tape_drives
      253 	     | rcpd.dtype (DISK_DRIVE_DTYPEX).max_concurrent < tot_disk_drives then
      254 	     goto TOO_MANY_DEVICES;
      255 
      256 /*
      257*   *       Process each resource in turn, doing all the work ourselves.
      258*   *  Rcp_initializer_ is not called to manipulate rcp_data.  This is a
      259*   *  break with the past protocol for RCP.
      260*   *       The cleanup handler will cancel any reservations already
      261*   *  made if any one fails.  This makes the reservation of a group
      262*   *  of resources appear as an indivisible operation to the caller
      263*   *  of this subroutine.
      264**/
      265 
      266 	call rcp_lock_$lock (addr (rcpd.lock_info), code);
      267 
      268 	if code ^= 0 then
      269 	     goto BAD_ERROR;
      270 
      271 	allocate resource_descriptions in (system_free_area) set (special_rdesc_ptr);
      272 	allocate reservation_description in (system_free_area) set (special_resv_ptr);
      273 	call copy_rdesc_and_resv ();
      274 	do i = 1 to resource_descriptions.n_items;
      275 
      276 	     special_rdesc_ptr -> resource_descriptions.item (1) = resource_descriptions.item (i);
      277 	     special_resv_ptr -> reservation_description.reservation_group (1) =
      278 		reservation_description.reservation_group (i);
      279 	     rsc_type = resource_descriptions.item (i).type;
      280 	     rsc_name = resource_descriptions.item (i).name;
      281 
      282 	     if rsc_type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then
      283 		dtype_idx = TAPE_DRIVE_DTYPEX;
      284 
      285 	     else if rsc_type = DEVICE_TYPE (DISK_DRIVE_DTYPEX) then
      286 		dtype_idx = DISK_DRIVE_DTYPEX;
      287 
      288 	     else if rsc_type = VOLUME_TYPE (TAPE_VOL_VTYPEX) | rsc_type = VOLUME_TYPE (DISK_VOL_VTYPEX) then
      289 		dtype_idx = 0;
      290 
      291 	     else goto BAD_RESOURCE;
      292 
      293 	     if dtype_idx ^= 0 then do;		/* Reserve a device. */
      294 		dtype_ptr = addr (rcpd.dtype (dtype_idx));
      295 
      296 		call select_device (ret_ptr);
      297 
      298 		if ret_ptr = null then
      299 		     goto RESERVATION_FAILED;
      300 
      301 		device_ptr = ret_ptr;
      302 
      303 /*
      304*   The device.group_id will be set later after we know that the reservation
      305*   is possible.  This will avoid destroying information needed for
      306*   pre-loaded volumes if the reservation fails.
      307**/
      308 
      309 		device.reservation_id = res_id;
      310 		device.reserved_by = res_by;
      311 
      312 		if system then
      313 		     device.process_id = "0"b;
      314 		else device.process_id = process_id;
      315 
      316 		device.current_authorization = authorization;
      317 
      318 		device.state_time = clock ();
      319 		device.state = RESERVED;
      320 
      321 		any_reserved = "1"b;
      322 
      323 		if ^system			/* For system, call is in rcp_pre_claim_ */
      324 		     then
      325 		     call ACCOUNT_WAKEUP (device_ptr, RCP_ACCTMSG_assign);
      326 
      327 		call admin_gate_$syserr (JUST_LOG, "RCP: Reserved device ^a for ^a (id=^a)", device.device_name,
      328 		     res_for, log_res_id);
      329 	     end;					/* Reserve a device. */
      330 
      331 	     else do;				/* Reserve a volume. */
      332 
      333 		call select_volume (ret_ptr);
      334 
      335 		if ret_ptr = null then
      336 		     goto RESERVATION_FAILED;
      337 
      338 		volume_ptr = ret_ptr;
      339 
      340 		volume.volume_name = rsc_name;
      341 		volume.group_id = res_for;
      342 
      343 		do volume.vtypex = lbound (VOLUME_TYPE, 1) to hbound (VOLUME_TYPE, 1)
      344 		     while (rsc_type ^= VOLUME_TYPE (volume.vtypex));
      345 		end;				/* Look up the volume type index. */
      346 
      347 		if volume.volume_name = "scratch" then
      348 		     volume.volume_name = "";
      349 
      350 		volume.reservation_id = res_id;
      351 		volume.reserved_by = res_by;
      352 
      353 		if system then
      354 		     volume.process_id = "0"b;
      355 		else volume.process_id = process_id;
      356 
      357 		volume.current_authorization = authorization;
      358 
      359 		volume.state_time = clock ();
      360 		volume.state = RESERVED;
      361 
      362 		any_reserved = "1"b;
      363 
      364 		call admin_gate_$syserr (JUST_LOG, "RCP: Reserved volume ^a for ^a (id=^a)", volume.volume_name,
      365 		     volume.group_id, log_res_id);
      366 	     end;					/* Reserve a volume. */
      367 
      368 	     call copy_back_rdesc_and_resv (i);
      369 	end;					/* do loop */
      370 
      371 /* If these reservations would leave too few tape drives for system processes,
      372*   the reservation must fail. */
      373 
      374 	num_free = 0;
      375 
      376 	do device_ptr = ptr (rcpd_ptr, rcpd.dtype (TAPE_DRIVE_DTYPEX).first_off)
      377 	     repeat ptr (device_ptr, device.next_off) while (rel (device_ptr) ^= ""b);
      378 	     if device.state = FREE then
      379 		num_free = num_free + 1;
      380 	end;
      381 
      382 	if num_free < rcpd.dtype (TAPE_DRIVE_DTYPEX).num_reserved then
      383 	     goto RESERVATION_FAILED;
      384 
      385 	do i = 1 to rcpd.tot_devices;			/* Set group id's for a successful reservation. */
      386 	     if rcpd.device (i).reservation_id = res_id then
      387 						/* Set the group id and interact with preloaded volumes. */
      388 		rcpd.device (i).group_id = res_for;
      389 	end;
      390 
      391 	call rcp_lock_$unlock (addr (rcpd.lock_info));
      392 	call free_storage;
      393 	callers_resource_res_ptr -> reservation_description.reservation_id = res_id;
      394 	a_code = 0;				/* Everything went all right. */
      395 	call cu_$level_set (caller_level);
      396 	return;
      397 
      398 approve_schedule:
      399      entry (a_resource_desc_ptr, resource_no, registry_dir, reserver_info_ptr, reserver_chain, a_code);
      400 
      401 /* This entry is called by rcprm_find_resource_$reserve when it wants to ask if its choice of
      402*   an appropriate and accessible resource happens to be available at the required time. */
      403 /* Currently, only tape or disk volumes will be checked, devices are handled at other places in RCP. */
      404 
      405 dcl	(
      406 	resource_no	   fixed bin,
      407 	registry_dir	   char (*),
      408 	reserver_info_ptr	   pointer,
      409 	reserver_chain	   bit (18) unaligned
      410 	)		   parameter;
      411 
      412 dcl	error_table_$resource_reserved
      413 			   fixed bin (35) external;
      414 
      415 	resource_desc_ptr = a_resource_desc_ptr;	/* special copying not necessary since caller has done it */
      416 	rsc_name = resource_descriptions.item (resource_no).name;
      417 	call resource_info_$get_type ((resource_descriptions.item (resource_no).type), is_volume, code);
      418 	if code ^= 0 then do;
      419 	     a_code, resource_descriptions.item (resource_no).status_code = code;
      420 	     return;
      421 	end;
      422 
      423 	if is_volume then do;			/* Check rcpdata for these. */
      424 	     rcpd_ptr = rcp_pointers_$data ();
      425 
      426 	     do i = 1 to rcpd.last_volume while (rcpd.volume (i).volume_name ^= rsc_name);
      427 	     end;
      428 
      429 	     if i > rcpd.last_volume then
      430 		a_code = 0;
      431 	     else if rcpd.volume (i).state = FREE then
      432 		a_code = 0;
      433 	     else a_code = error_table_$resource_reserved;
      434 	end;					/* Check rcp data for these. */
      435 
      436 	else a_code = 0;
      437 
      438 	return;
      439 
      440 BAD_CALL:
      441 	call cleanup_handler;
      442 	a_code = error_table_$badcall;
      443 	return;
      444 
      445 BAD_VERSION:
      446 	call cleanup_handler;
      447 	a_code = error_table_$unimplemented_version;
      448 	return;
      449 
      450 TOO_MANY_DEVICES:
      451 	call cleanup_handler;
      452 	a_code = error_table_$device_limit_exceeded;
      453 	return;
      454 
      455 BAD_RESOURCE:
      456 	call cleanup_handler;
      457 	a_code = error_table_$resource_unknown;
      458 	return;
      459 
      460 BAD_ERROR:
      461 	call admin_gate_$syserr (JUST_LOG,
      462 	     "RCP: An error locking rcpd for reservation for ^a ^[^s^;^xby^x^a^] (id=^a).", res_for, res_for = res_by,
      463 	     res_by, log_res_id);
      464 	call cleanup_handler;
      465 	a_code = code;
      466 	return;
      467 
      468 RESERVATION_FAILED:
      469 	call cleanup_handler;
      470 	a_code = error_table_$reservation_failed;
      471 	return;
      472 
      473 BAD_NAME:
      474 	call cleanup_handler;
      475 	a_code = error_table_$reservation_failed;
      476 	return;
      477 
      478 BAD_ATTRIBUTE:
      479 	call cleanup_handler;
      480 	a_code = error_table_$bad_conversion;
      481 	return;
      482 
      483 select_device:
      484      proc (dptr);
      485 
      486 /* Arguments */
      487 
      488 dcl	dptr		   ptr;			/* Pointer to device entry we eventurally select. */
      489 
      490 /* Local Variables */
      491 
      492 dcl	MAX_AVAILABLE	   fixed bin (17) static internal options (constant) init (128);
      493 dcl	1 AA_array	   (MAX_AVAILABLE),
      494 	  2 name		   char (8),
      495 	  2 last_time	   fixed bin (71),
      496 	  2 dptr		   ptr;
      497 dcl	loop		   fixed bin;
      498 dcl	current_AA	   fixed bin;
      499 dcl	start		   fixed bin;
      500 dcl	found		   bit (1);
      501 
      502 	call get_attr_values ();
      503 
      504 	dptr = null;
      505 	current_AA = 0;
      506 
      507 	do device_ptr = ptr (rcpd_ptr, dtype.first_off) repeat ptr (device_ptr, device.next_off)
      508 	     while (rel (device_ptr) ^= ""b & (current_AA <= MAX_AVAILABLE));
      509 
      510 	     if device.state = FREE then		/* It's available. */
      511 		if (model = 0 | device.model = model) then
      512 		     if (tracks = 0 | device.qualifiers (1) = tracks) then
      513 			if (density = "0"b | (unspec (device.qualifiers (2)) & density) = density) then
      514 			     if (speed = ""b | (unspec (device.qualifiers (3)) & speed) ^= "0"b) then
      515 				if (rsc_name = "" | device.device_name = rsc_name) then do;
      516 				     start = 1;
      517 				     found = "0"b;
      518 				     do start = 1 to current_AA while (^found);
      519 					if device.state_time < AA_array.last_time (start) then
      520 					     found = "1"b;
      521 				     end;
      522 				     if found & (start ^= 1) then
      523 					start = start - 1;
      524 				     do loop = current_AA to start by -1;
      525 					AA_array.dptr (loop + 1) = AA_array.dptr (loop);
      526 					AA_array.name (loop + 1) = AA_array.name (loop);
      527 					AA_array.last_time (loop + 1) = AA_array.last_time (loop);
      528 				     end;
      529 				     AA_array.dptr (start) = device_ptr;
      530 				     AA_array.name (start) = device.device_name;
      531 				     AA_array.last_time (start) = device.state_time;
      532 				     current_AA = current_AA + 1;
      533 				end;
      534 	end;
      535 
      536 /* Now let's see if we have access to any of the AA devices. */
      537 /* The AA_array is sorted with the device used the longest */
      538 /* time ago first.  So they will be checked in order of when */
      539 /* they were used last. */
      540 
      541 	found = "0"b;
      542 	do loop = 1 to current_AA while (^found);
      543 	     if have_access (AA_array.name (loop)) then
      544 		found = "1"b;
      545 	end;
      546 
      547 /*  If we found one that we have access to then it was also audited in */
      548 /*  rcprm_find_resource_.  If a specific device was not asked for then */
      549 /*  no auditing was needed.  However, if a specific device was requested */
      550 /*  and we did not have access to it then the auditing still needs to be */
      551 /*  done.  It can't be done in rcprm_find_resource_ since that routine has */
      552 /*  no way of knowing if the name it recieves comes from rcp_reserve_ or */
      553 /*  the user.  So we audit it here. */
      554 
      555 	if found then
      556 	     dptr = AA_array.dptr (loop - 1);
      557 	else if rsc_name ^= "" then
      558 	     call audit (rsc_name);
      559 
      560      end select_device;
      561 
      562 audit:
      563      proc (P_rsc_name);
      564 
      565 dcl	P_rsc_name	   char (*);
      566 dcl	1 auto_event_flags	   like audit_event_flags aligned;
      567 
      568 	unspec (auto_event_flags) = ""b;
      569 	auto_event_flags.grant = "0"b;
      570 	auto_event_flags.priv_op = system;
      571 	call access_audit_r1_$log_general ("rcp_reserve_", caller_level, unspec (auto_event_flags),
      572 	     access_operations_$rcp_reserve, (rtrim (rsc_type) || " " || P_rsc_name), (error_table_$reservation_failed),
      573 	     null (), 0);
      574 	return;
      575      end audit;
      576 
      577 select_volume:
      578      proc (vptr);
      579 
      580 /* Arguments */
      581 
      582 dcl	vptr		   ptr;			/* Pointer to the volume entry we eventually select. */
      583 dcl	i		   fixed bin;		/* Index for rcpd. */
      584 
      585 
      586 	vptr = null;
      587 
      588 	if rsc_name = "scratch" then
      589 	     rsc_name = "";
      590 
      591 	if ^have_access (rsc_name) then
      592 	     return;				/* Make sure user has access to this volume. */
      593 
      594 	do i = 1 to rcpd.last_volume;
      595 
      596 	     volume_ptr = addr (rcpd.volume (i));
      597 
      598 	     if volume.volume_name = rsc_name & rsc_name ^= "" then do;
      599 		if volume.state = FREE then do;
      600 		     vptr = volume_ptr;
      601 		end;
      602 
      603 		else do;
      604 		     vptr = null;
      605 		     return;
      606 		end;
      607 	     end;
      608 
      609 	     else do;
      610 		if volume.volume_name = "" & volume.state = FREE then do;
      611 		     if vptr = null then
      612 			vptr = volume_ptr;
      613 		end;
      614 	     end;
      615 	end;
      616 
      617 	if vptr = null then do;
      618 	     if rcpd.last_volume < rcpd.tot_volumes then do;
      619 		rcpd.last_volume = rcpd.last_volume + 1;
      620 		vptr = addr (rcpd.volume (rcpd.last_volume));
      621 	     end;
      622 	end;
      623 
      624      end select_volume;
      625 
      626 have_access:
      627      proc (resource_name) returns (bit (1));
      628 
      629 dcl	resource_name	   char (*);		/* Name of the resource in question. */
      630 
      631 /* Local Variables */
      632 
      633 dcl	actual_access	   bit (3);
      634 dcl	local_code	   fixed bin (35);
      635 
      636 dcl	addr		   builtin;
      637 
      638 
      639 	if rcpd.modes.resource_mgmt_enabled then do;
      640 	     special_rdesc_ptr -> resource_descriptions.item (1).name = resource_name;
      641 	     special_rdesc_ptr -> resource_descriptions.item (1).given.name = "1"b;
      642 /**** Set the validation level back up so RCPRM will make the correct access decisions. ****/
      643 	     call cu_$level_set (caller_level);
      644 	     if system then
      645 		call rcprm_find_resource_$reserve_proxy (special_rdesc_ptr, registry_directory, special_resv_ptr,
      646 		     (reserved_for), authorization, local_code);
      647 	     else call rcprm_find_resource_$reserve (special_rdesc_ptr, registry_directory, special_resv_ptr,
      648 		     local_code);
      649 /**** Now set the validation level back so we can get on with our work. ****/
      650 	     call cu_$level_set (get_ring_ ());
      651 	end;
      652 	else do;
      653 	     req_info.user_id = res_for;
      654 	     req_info.current_authorization = authorization;
      655 	     req_info.validation_level = caller_level;
      656 	     res_info.registry_dir = "";
      657 	     res_info.registry_record_ptr, res_info.registry_switch_ptr = null ();
      658 	     res_info.resource_type = rsc_type;
      659 	     res_info.resource_name = resource_name;
      660 	     call rcp_access_kernel_ (operation, addr (req_info), addr (res_info), actual_access, local_code);
      661 	end;
      662 
      663 	return (local_code = 0);
      664 
      665      end have_access;
      666 
      667 get_attr_values:
      668      proc;
      669 
      670 /*
      671*   This routine takes the caller's attribute string and turns it into
      672*   a form suitable for the rest of RCP.
      673**/
      674 
      675 dcl	mode_idx		   fixed bin;
      676 
      677 	model = 0;
      678 	tracks = 0;
      679 	density = "0"b;
      680 	speed = ""b;
      681 
      682 	if resource_descriptions.item (i).given.desired_attributes then do;
      683 						/* Use what the user set. */
      684 	     call cv_rcp_attributes_$to_string_rel ((resource_descriptions.item (i).type),
      685 		(resource_descriptions.item (i).desired_attributes (*)), attributes, code);
      686 	     if code ^= 0 then
      687 		goto BAD_ERROR;
      688 	     call mode_string_$parse ((attributes), get_system_free_area_ (), mode_string_info_ptr, code);
      689 	     if code ^= 0 then
      690 		goto BAD_ERROR;
      691 
      692 	     do mode_idx = 1 to mode_string_info.number;
      693 		if ^mode_string_info.modes (mode_idx).numeric_valuep then
      694 		     goto BAD_ATTRIBUTE;
      695 		if mode_string_info.modes (mode_idx).mode_name = "model" then
      696 		     call model_mode_proc;
      697 		else if resource_descriptions.item (i).type = DEVICE_TYPE (TAPE_DRIVE_DTYPEX) then do;
      698 		     if mode_string_info.modes (mode_idx).mode_name = "track" then
      699 			call track_mode_proc;
      700 		     else if mode_string_info.modes (mode_idx).mode_name = "den" then
      701 			call den_mode_proc;
      702 		     else if mode_string_info.modes (mode_idx).mode_name = "speed" then
      703 			call speed_mode_proc;
      704 		end;
      705 	     end;
      706 	end;					/* Use what the user set. */
      707 	return;
      708 
      709 model_mode_proc:
      710 	proc;
      711 
      712 	     if model ^= 0 then
      713 		goto BAD_ATTRIBUTE;
      714 
      715 	     model = mode_string_info.modes (mode_idx).numeric_value;
      716 
      717 	end model_mode_proc;
      718 
      719 track_mode_proc:
      720 	proc;
      721 
      722 	     if tracks ^= 0 then
      723 		goto BAD_ATTRIBUTE;
      724 
      725 	     tracks = mode_string_info.modes (mode_idx).numeric_value;
      726 
      727 	end track_mode_proc;
      728 
      729 den_mode_proc:
      730 	proc;
      731 
      732 dcl	den_conversion_idx	   fixed bin;
      733 
      734 dcl	den_conversion_table   (5) fixed bin internal static options (constant) init (200, 556, 800, 1600, 6250);
      735 dcl	density_in_bits	   (5) bit (5) aligned internal static options (constant)
      736 			   init ("10000"b, "01000"b, "00100"b, "00010"b, "00001"b);
      737 
      738 	     do den_conversion_idx = lbound (den_conversion_table, 1) to hbound (den_conversion_table, 1)
      739 		while (mode_string_info.modes (mode_idx).numeric_value ^= den_conversion_table (den_conversion_idx));
      740 	     end;
      741 	     if den_conversion_idx > hbound (den_conversion_table, 1) then
      742 		goto BAD_ATTRIBUTE;
      743 	     density = density | density_in_bits (den_conversion_idx);
      744 
      745 	end den_mode_proc;
      746 
      747 speed_mode_proc:
      748 	proc;
      749 
      750 dcl	speed_conversion_idx   fixed bin;
      751 
      752 dcl	speed_conversion_table (3) fixed bin internal static options (constant) init (75, 125, 200);
      753 
      754 dcl	speed_in_bits	   (3) bit (3) aligned internal static options (constant) init ("100"b, "010"b, "001"b);
      755 
      756 	     do speed_conversion_idx = lbound (speed_conversion_table, 1) to hbound (speed_conversion_table, 1)
      757 		while (speed_conversion_table (speed_conversion_idx)
      758 		^= mode_string_info.modes (mode_idx).numeric_value);
      759 	     end;
      760 	     if speed_conversion_idx > hbound (speed_conversion_table, 1) then
      761 		goto BAD_ATTRIBUTE;
      762 
      763 	     speed = speed | speed_in_bits (speed_conversion_idx);
      764 
      765 	end speed_mode_proc;
      766 
      767      end get_attr_values;
      768 
      769 ACCOUNT_WAKEUP:
      770      procedure (a_devptr, a_action);
      771 
      772 /*	This procedure is called to format an accounting message, and send it to the
      773*   *	accounting process.  If the accounting event channel has not been set up, no message is sent.
      774**/
      775 
      776 
      777 dcl	a_devptr		   ptr;			/* Pointer to rcp_data entry */
      778 dcl	a_action		   fixed bin;		/* Accounting action */
      779 
      780 dcl	wakeup_buf	   fixed bin (71);
      781 dcl	1 auto_rcpamsg	   like rcp_account_msg aligned;
      782 
      783 	unspec (auto_rcpamsg) = "0"b;
      784 
      785 	auto_rcpamsg.device_user_procid = a_devptr -> device.process_id;
      786 	auto_rcpamsg.rcp_data_relp = rel (a_devptr);
      787 	auto_rcpamsg.devtype = a_devptr -> device.dtypex;
      788 	auto_rcpamsg.action = a_action;
      789 
      790 	unspec (wakeup_buf) = unspec (auto_rcpamsg);
      791 	if rcpd.accounting_chan ^= 0 then
      792 	     call hcs_$wakeup (rcpd.accounting_pid, rcpd.accounting_chan, wakeup_buf, (0));
      793 
      794      end ACCOUNT_WAKEUP;
      795 
      796 cleanup_handler:
      797      proc;
      798 
      799 /*
      800*   This subroutine will clean up everything and cancel any
      801*   reservations which may have already been made so that the
      802*   reservation of a group of resources can appear as an indivisible
      803*   operation.
      804**/
      805 
      806 /*
      807*   *       Scan through all device and volume entries cleaning up the ones
      808*   *  with the appropriate reservation_id.  We will ignore the group_id
      809*   *  since the reservation_id is assumed to be right.
      810**/
      811 
      812 	call free_storage;
      813 	if any_reserved then do;
      814 	     do i = 1 to rcpd.tot_devices;
      815 
      816 		if rcpd.device (i).reservation_id = res_id then do;
      817 		     device_ptr = addr (rcpd.device (i));
      818 		     call admin_gate_$syserr (JUST_LOG, "RCP: Cancelled device ^a for ^a (id=^a)", device.device_name,
      819 			device.group_id, log_res_id);
      820 
      821 		     if device.volume_name = "" then
      822 			device.group_id = "";	/* Might be preloaded. */
      823 
      824 		     device.reservation_id = 0;
      825 		     device.reserved_by = "";
      826 		     device.process_id = "0"b;
      827 		     device.state_time = clock ();
      828 		     device.state = FREE;
      829 		end;
      830 
      831 	     end;
      832 
      833 	     do i = 1 to rcpd.last_volume;
      834 
      835 		if rcpd.volume (i).reservation_id = res_id then do;
      836 		     volume_ptr = addr (rcpd.volume (i));
      837 		     call admin_gate_$syserr (JUST_LOG, "RCP: Cancelled volume ^a for ^a (id=^a)", volume.volume_name,
      838 			volume.group_id, log_res_id);
      839 		     volume.group_id = "";
      840 		     volume.reservation_id = 0;
      841 		     volume.reserved_by = "";
      842 		     volume.process_id = "0"b;
      843 		     volume.state_time = clock ();
      844 		     volume.state = FREE;
      845 		end;
      846 
      847 	     end;
      848 	end;
      849 
      850 
      851 	if rcpd_ptr ^= null () then
      852 	     call rcp_lock_$unlock (addr (rcpd.lock_info));
      853 
      854 	call cu_$level_set (caller_level);
      855 
      856 	if callers_resource_res_ptr ^= null () then
      857 	     callers_resource_res_ptr -> reservation_description.reservation_id = 0b;
      858 
      859      end cleanup_handler;
      860 
      861 free_storage:
      862      proc;
      863 
      864 	if resource_desc_ptr ^= null () then do;
      865 	     free resource_descriptions;
      866 	     resource_desc_ptr = null ();
      867 	end;
      868 	if resource_res_ptr ^= null () then do;
      869 	     free reservation_description;
      870 	     resource_res_ptr = null ();
      871 	end;
      872 	if mode_string_info_ptr ^= null () then do;
      873 	     free mode_string_info;
      874 	     mode_string_info_ptr = null ();
      875 	end;
      876 	if special_rdesc_ptr ^= null () then do;
      877 	     free special_rdesc_ptr -> resource_descriptions;
      878 	     special_rdesc_ptr = null ();
      879 	end;
      880 	if special_resv_ptr ^= null () then do;
      881 	     free special_resv_ptr -> reservation_description;
      882 	     special_resv_ptr = null ();
      883 	end;
      884 
      885      end free_storage;
      886 
      887 copy_resource_and_reservation_structures:
      888      proc;
      889 
      890 /**** Routine to copy the resource and reservation structures from the caller's stack to ours.  It is done
      891*      pretty carefully to ensure that we get a consistent copy (i.e. no fiddling by the caller can cause us
      892*      to screw up). ****/
      893 
      894 dcl	based_bits	   (wordcount) bit (36) aligned based;
      895 dcl	wordcount		   fixed bin (21);
      896 
      897 	callers_resource_desc_ptr = a_resource_desc_ptr;
      898 	callers_resource_res_ptr = a_resource_res_ptr;
      899 	Resource_count = callers_resource_desc_ptr -> resource_descriptions.n_items;
      900 	wordcount = size (resource_descriptions);
      901 	allocate resource_descriptions in (system_free_area);
      902 	resource_desc_ptr -> based_bits = callers_resource_desc_ptr -> based_bits;
      903 	resource_descriptions.n_items = Resource_count;	/* avoid any tomfoolery on caller's part */
      904 	wordcount = size (reservation_description);
      905 	allocate reservation_description in (system_free_area);
      906 	resource_res_ptr -> based_bits = callers_resource_res_ptr -> based_bits;
      907 
      908      end copy_resource_and_reservation_structures;
      909 
      910 copy_rdesc_and_resv:
      911      proc ();
      912 
      913 	special_rdesc_ptr -> resource_descriptions.n_items = 1;
      914 	special_resv_ptr -> reservation_description.n_items = 1;
      915 	special_rdesc_ptr -> resource_descriptions.version_no = resource_descriptions.version_no;
      916 	special_resv_ptr -> reservation_description.version_no = reservation_description.version_no;
      917 	special_resv_ptr -> reservation_description.reserved_for = reservation_description.reserved_for;
      918 	special_resv_ptr -> reservation_description.reserved_by = reservation_description.reserved_by;
      919 	special_resv_ptr -> reservation_description.reservation_id = reservation_description.reservation_id;
      920 	special_resv_ptr -> reservation_description.group_starting_time = reservation_description.group_starting_time;
      921 	special_resv_ptr -> reservation_description.asap_duration = reservation_description.asap_duration;
      922 	special_resv_ptr -> reservation_description.flags = reservation_description.flags;
      923      end copy_rdesc_and_resv;
      924 
      925 copy_back_rdesc_and_resv:
      926      proc (ii);
      927 
      928 dcl	ii		   fixed bin;
      929 
      930 	resource_descriptions.item (ii) = special_rdesc_ptr -> resource_descriptions.item (1);
      931 	reservation_description.reservation_group (ii) =
      932 	     special_resv_ptr -> reservation_description.reservation_group (1);
      933      end copy_back_rdesc_and_resv;
      934 
  1     1 /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
      935 
      936 
  2     1 /* --------------- BEGIN include file resource_control_desc.incl.pl1 --------------- */
  2     2 
  2     3 /* Written by R.J.C. Kissel 3/78. */
  2     4 /* Modified 09/28/78 by C. D. Tavares */
  2     5 
  2     6 dcl 1 resource_descriptions based (resource_desc_ptr) aligned,
  2     7     2 version_no fixed bin,				/* caller must set this to resource_desc_version_1 */
  2     8     2 n_items fixed bin,				/* Number of resources described by this structure. */
  2     9     2 item (Resource_count refer (resource_descriptions.n_items)) aligned,
  2    10       3 type char (32),				/* e.g., "tape_drive" */
  2    11       3 name char (32),				/* e.g., "tapa_03" */
  2    12       3 uid bit (36),				/* The resource unique id. */
  2    13       3 potential_attributes bit (72),			/* resource's permissible attributes */
  2    14       3 attributes (2) bit (72),			/* RCP attribute description (output) */
  2    15       3 desired_attributes (4) bit (72),		/* desired attributes (input) */
  2    16       3 potential_aim_range (2) bit (72),		/* Lowest and highest possible AIM bounds for resource */
  2    17       3 aim_range (2) bit (72),			/* Current AIM range */
  2    18       3 owner char (32),				/* e.g., "Smith.Project" */
  2    19       3 acs_path char (168),				/* Access control segment pathname. */
  2    20       3 location char (168),				/* String describing location in unusual cases */
  2    21       3 comment char (168),				/* User-settable comment string */
  2    22       3 charge_type char (32),			/* accounting identifier for this resource */
  2    23       3 rew bit (3) unaligned,			/* user's effective access to resource */
  2    24       3 (usage_lock,				/* This resource may not be acquired or used. */
  2    25          release_lock,				/* The owner is not allowed to release the resource. */
  2    26          awaiting_clear,				/* Resource awaiting manual clear */
  2    27          user_alloc) bit (1) unaligned,			/* User claims volume contains useful data */
  2    28       3 pad2 bit (29) unaligned,			/* Ignored field. */
  2    29       3 given aligned,				/* each of these bits says the corresponding */
  2    30 						/* item is significant on input */
  2    31        (4 (name,
  2    32 	 uid,
  2    33 	 potential_attributes,
  2    34 	 desired_attributes,
  2    35 	 potential_aim_range,
  2    36 	 aim_range,
  2    37 	 owner,
  2    38 	 acs_path,
  2    39 	 location,
  2    40 	 comment,
  2    41 	 charge_type,
  2    42 	 usage_lock,
  2    43 	 release_lock,
  2    44 	 user_alloc) bit (1),
  2    45         4 pad1 bit (22)) unaligned,
  2    46       3 state bit (36) aligned,			/* For use of resource_control_ only */
  2    47       3 status_code fixed bin (35);			/* Standard system status code for this resource. */
  2    48 
  2    49 
  2    50 /* Note that the reservation description must always be used with a resource
  2    51*   description structure.  When they are used together the two structures must
  2    52*   have the same number of entries, i.e. Resource_count is the same for both. */
  2    53 
  2    54 
  2    55 dcl 1 reservation_description based (resource_res_ptr) aligned,
  2    56     2 version_no fixed bin,				/* The version number for this structure. */
  2    57     2 reserved_for char (32),				/* Group id of reserved for process. */
  2    58     2 reserved_by char (32),				/* Group id of reserved by process. */
  2    59     2 reservation_id fixed bin (71),			/* Reservation id of this reservation group. */
  2    60     2 group_starting_time fixed bin (71),		/* Starting time for this reservation group. */
  2    61     2 asap_duration fixed bin (71),			/* Duration after which as soon as possible is no longer good. */
  2    62     2 flags aligned,
  2    63      (3 auto_expire bit (1),				/* Should reservation expire when this process terminates. */
  2    64       3 asap bit (1),				/* Make this reservation group as soon as possible. */
  2    65       3 rel bit (1),				/* Times are relative/absolute. */
  2    66       3 sec bit (1)) unaligned,			/* Times are in sec/microsec. */
  2    67     2 n_items fixed bin,				/* Number of resources reserved in this group. */
  2    68     2 reservation_group (Resource_count refer (reservation_description.n_items)),
  2    69       3 starting_time fixed bin (71),			/* When this resource res. starts in the group. */
  2    70       3 duration fixed bin (71);			/* Duration of this resource res. in the group. */
  2    71 
  2    72 dcl (resource_desc_ptr,
  2    73      resource_res_ptr) pointer;
  2    74 
  2    75 dcl (resource_desc_version_1 initial (1),
  2    76      resource_res_version_1 initial (1)) internal static options (constant);
  2    77 
  2    78 dcl  Resource_count fixed bin;			/* The number of resources described in the structures. */
  2    79 
  2    80 /* ---------------- END include file resource_control_desc.incl.pl1 ---------------- */
      937 
      938 
  3     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  3     2*   *
  3     3*   *	Created on 11/20/74 by Bill Silver.
  3     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  3     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  3     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  3     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  3     8*   *	Modified 11/84 by Paul Farley to add fips flag.
  3     9*   *      Modified 1/3/85 by Fawcett to allow room for mca device type
  3    10*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  3    11*   *	This include file defines the Resource Control Package communication segment.
  3    12*   *	This segment is used to communicate requests between the various internal
  3    13*   *	parts of RCP.
  3    14**/
  3    15 
  3    16 /****^  HISTORY COMMENTS:
  3    17*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3    18*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  3    19*     Support MCA and FIPS.
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  3    23 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  3    24 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  3    25 
  3    26 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  3    27    (2 id_count fixed bin (17),			/* Unique count index. */
  3    28     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  3    29 
  3    30 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  3    31     2 lock_info like lock_info,			/* Data used to lock this segment. */
  3    32     2 ws_maxs (8) fixed bin (19),			/* Max IOI workspace size in words. */
  3    33     2 ws_pmaxs (8) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  3    34     2 to_maxs (8) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  3    35     2 sys_directory char (32),			/* Directory  used to define a system process. */
  3    36     2 sys_acs char (32),				/* Entry name used to define a system process. */
  3    37     2 acs_directory char (32),			/* Directory containing device ACSs. */
  3    38     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  3    39     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  3    40     2 num_entries fixed bin,				/* Total number of entries. */
  3    41     2 first_free_off bit (18),			/* Offset of first free entry. */
  3    42     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  3    43      like rcse,					/* See structure below. */
  3    44     2 end bit (36);					/* End of rcp_com_seg. */
  3    45 
  3    46 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  3    47     2 lock bit (36),				/* The lock itself. */
  3    48     2 num_locks fixed bin (35),			/* Number of times locked. */
  3    49     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  3    50     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  3    51     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  3    52     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  3    53     2 starting_time fixed bin (71);			/* Time metering started. */
  3    54 
  3    55 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  3    56     2 device_name char (8),				/* Name of device associated with this entry. */
  3    57     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  3    58     2 dtypex fixed bin,				/* Device type index. */
  3    59     2 model fixed bin,				/* Device model number. */
  3    60     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  3    61     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  3    62     2 state_time fixed bin (71),			/* Time device put into current state. */
  3    63     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  3    64 						/* 3 - attaching  4 - attached   5 - completed. */
  3    65 
  3    66 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  3    67     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  3    68     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  3    69     2 user_off bit (18),				/* Offset of next entry in user list. */
  3    70     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  3    71     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  3    72     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  3    73     2 caller_level fixed bin,				/* Caller's validation level. */
  3    74     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  3    75     2 flags,					/* Special info flags. */
  3    76      (3 device bit (1),				/* ON => assigning a specific device. */
  3    77       3 priv bit (1),				/* ON => attached with IOI privilege. */
  3    78       3 system bit (1),				/* ON => assigned to a system process. */
  3    79       3 t_and_d bit (1),				/* ON => T&D attachment. */
  3    80       3 volume bit (1),				/* ON => volume associated with this device. */
  3    81       3 writing bit (1),				/* ON => writing on volume. */
  3    82       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  3    83       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  3    84       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  3    85       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  3    86       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  3    87       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  3    88       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  3    89       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  3    90       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  3    91       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  3    92       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  3    93       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  3    94       3 fips bit (1),				/* ON => FIPS device. */
  3    95       3 no_protect bit (1),				/* ON => device has no protect sw. */
  3    96       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  3    97       3 unused bit (6),
  3    98       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  3    99       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  3   100     2 rcp_id bit (36),				/* ID of this entry. */
  3   101     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  3   102     2 process_id bit (36),				/* ID of calling process. */
  3   103     2 group_id char (32),				/* Group ID of calling process. */
  3   104     2 ecode fixed bin (35),				/* Assignment error code. */
  3   105     2 version_num fixed bin,				/* Device info version number. */
  3   106     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  3   107     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  3   108     2 ioi_index fixed bin,				/* IOI device index. */
  3   109     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  3   110     2 caller_comment char (64);			/* Caller's comment. */
  3   111 
  3   112 /*	End of include file ... rcp_com_seg.incl.pl1	*/
      939 
      940 
  4     1 /*	Begin  include file ... rcp_data.incl.pl1
  4     2*   *
  4     3*   *	Created on 09/06/74 by Bill Silver.
  4     4*   *	This include file defines the Resource Control Package data base, rcp_data.
  4     5*   *	It is initialized in ring 0 by rcp_init.  It is maintained in ring 1 by RCP.
  4     6*   *	It contains information about all of the devices and volumes managed by RCP.
  4     7*   *	This include file references rcp_com_seg.incl.pl1.
  4     8*
  4     9*   *	Modified by R.J.C. Kissel on 10/5/77 to add the check_label bit.
  4    10*   *	Modified by Michael R. Jordan on 04/24/78 to add modes and attached flag.
  4    11*   *	Modified on 12/09/78 to add removable media bit.
  4    12*   *	Modified 3/79 by Michael R. Jordan for MR7.0R.
  4    13*   *	Modified 3/79 by C. D. Tavares for expandable RCP modes.
  4    14*   *	Modified 11/84 by Paul Farley to add fips flag.
  4    15*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  4    16**/
  4    17 
  4    18 /****^  HISTORY COMMENTS:
  4    19*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4    20*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  4    21*     Support FIPS and IMU.
  4    22*                                                   END HISTORY COMMENTS */
  4    23 
  4    24 dcl  rcpd_ptr ptr;					/* Points to base of RCPD. */
  4    25 dcl  dtype_ptr ptr;					/* Points to a device type entry. */
  4    26 dcl  device_ptr ptr;				/* Points to a device entry. */
  4    27 dcl  volume_ptr ptr;				/* Points to a volume entry. */
  4    28 
  4    29 dcl 1 rcpd based (rcpd_ptr) aligned,			/* Begin at word 0 of RCPD. */
  4    30     2 lock_info like lock_info,			/* Data used to lock this segment. */
  4    31     2 init bit (1) unal,				/* ON => rcp_ring1_init_ has executed */
  4    32     2 modes like rcp_init_flags unaligned,
  4    33     2 tot_dtypes fixed bin,				/* Number of known device types. */
  4    34     2 tot_devices fixed bin,				/* Total number of devices configured. */
  4    35     2 tot_volumes fixed bin,				/* Number of possible attached volumes. */
  4    36     2 last_volume fixed bin,				/* The last volume entry currently in use. */
  4    37     2 mtimer_chan fixed bin (71),			/* Event channel for mount timer. */
  4    38     2 mtimer_pid bit (36),				/* ID of mount timer process. */
  4    39     2 accounting_chan fixed bin (71),			/* Event channel for device accounting */
  4    40     2 accounting_pid bit (36),			/* ID of accounting process */
  4    41     2 unload_sleep_time fixed bin (71),			/* Number of microseconds to wait for unload completion. */
  4    42     2 pad (7) fixed bin,
  4    43     2 dtype (0 refer (rcpd.tot_dtypes))			/* One entry per device type. */
  4    44      like dtype,					/* See structure below. */
  4    45     2 device (0 refer (rcpd.tot_devices))		/* One entry per configured device. */
  4    46      like device,					/* See structure below. */
  4    47     2 volume (0 refer (rcpd.tot_volumes))		/* One entry per possible attached volume. */
  4    48      like volume,					/* See structure below. */
  4    49     2 end bit (36) aligned;				/* End of rcp_data. */
  4    50 
  4    51 dcl 1 dtype based (dtype_ptr) aligned,			/* Entry for one device type. */
  4    52     2 device_type char (32),				/* Name of this device type. */
  4    53     2 max_concurrent fixed bin,			/* Max number of concurrently assigned devices. */
  4    54     2 num_reserved fixed bin,				/* Num of devices reserved for system processes. */
  4    55     2 num_devices fixed bin,				/* Num of devices of this type that are configured. */
  4    56     2 first_off bit (18),				/* Offset of first device entry. */
  4    57     2 histo_times (3) fixed bin;			/* Used to compute histograms for this device type. */
  4    58 
  4    59 dcl 1 device based (device_ptr) aligned,		/* Up to state must = rcs.rcse. */
  4    60     2 device_name char (8),				/* Name of device associated with this entry. */
  4    61     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  4    62     2 dtypex fixed bin,				/* Device type index. */
  4    63     2 model fixed bin,				/* Device model number. */
  4    64     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  4    65     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  4    66     2 state_time fixed bin (71),			/* Time device put into current state. */
  4    67     2 state fixed bin,				/* 0 => free,  1 => assigned,  2 => deleted,
  4    68*						   3 => storage system, 4 => reserved */
  4    69 
  4    70 /*	*	*	*	*	** Following fields are unique to device entry. */
  4    71 
  4    72     2 unassign_state fixed bin,			/* State to return when unassigning. */
  4    73     2 acs_name char (12),				/* Entry name of ACS for this device. */
  4    74     2 next_off bit (18),				/* Offset of next entry for this device type. */
  4    75     2 iom_num fixed bin,				/* IOM number for this device. */
  4    76     2 chan_num fixed bin,				/* Channel number for this device. */
  4    77     2 num_channels fixed bin,				/* Num channels that may address device. */
  4    78     2 flags,					/* Special info flags. */
  4    79      (3 delete bit (1),				/* ON => Delete device when it is unassigned. */
  4    80       3 priv bit (1),				/* ON => Deleted device assigned for priv attach. */
  4    81       3 reservable bit (1),				/* ON => may be reserved for system process. */
  4    82       3 reserved bit (1),				/* ON => reserved to a reserved process. */
  4    83       3 mounting bit (1),				/* ON => mount pending. */
  4    84       3 writing bit (1),				/* ON => mounting for writing. */
  4    85       3 attached bit (1) unal,			/* ON => device is attached. */
  4    86       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  4    87       3 fips bit (1),				/* ON => FIPS device. */
  4    88       3 no_protect bit (1),				/* ON => device has no protect sw. */
  4    89       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  4    90       3 unused bit (25)) unal,
  4    91     2 process_id bit (36),				/* ID of assigned process. */
  4    92     2 group_id char (32),				/* Process group ID. */
  4    93     2 error_count fixed bin (35),			/* Total error count.  Defined by user ring. */
  4    94     2 num_assigns fixed bin (35),			/* Total # of times device assigned & unassigned. */
  4    95     2 tot_assign_time fixed bin (71),			/* Total time that device was assigned. */
  4    96     2 histogram (4) fixed bin,			/* Assignment time histogram. */
  4    97     2 reservation_id fixed bin (71),
  4    98     2 reserved_by char (32),				/* Who made this reservation. */
  4    99     2 current_authorization bit (72) aligned;		/* Authoization of process using this device. */
  4   100 
  4   101 dcl 1 volume based (volume_ptr) aligned,		/* Entry for one volume. */
  4   102     2 process_id bit (36),				/* "0"b => unassigned. */
  4   103     2 volume_name char (32),				/* Volume name. */
  4   104     2 vtypex fixed bin,				/* Volume type index. */
  4   105     2 group_id char (32),				/* This is used for the reserved_for field. */
  4   106     2 reserved_by char (32),
  4   107     2 reservation_id fixed bin (71),
  4   108     2 state_time fixed bin (71),			/* Same as for a device. */
  4   109     2 state fixed bin,				/* Same as for a device. */
  4   110     2 unassign_state fixed bin,			/* State to return when unassigning. */
  4   111     2 current_authorization bit (72) aligned;		/* Authorization of process using this volume. */
  4   112 
  5     1 /* BEGIN INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  5     2 
  5     3 /* Created on 04/24/78 by Michael R. Jordan */
  5     4 /* Modified 04/10/79 by C. D. Tavares */
  5     5 
  5     6 dcl  rifp ptr;
  5     7 
  5     8 dcl 1 rcp_init_flags based (rifp),
  5     9     2 unload_on_detach bit (1) unaligned,		/* ON => tape volumes are unloaded after detaching */
  5    10     2 pad1 bit (2) unaligned,				/* obsolete */
  5    11     2 resource_mgmt_enabled bit (1) unaligned,		/* ON => resource management has been enabled */
  5    12     2 auto_registration bit (1) unaligned,		/* ON => auto registration allowed */
  5    13     2 pad2 bit (2) unaligned,				/* future expansion, possibly of authentication_level */
  5    14     2 authentication_level fixed bin (2) unaligned unsigned; /* see below for values */
  5    15 
  5    16 dcl (No_authentication initial (0),
  5    17      Nominal_authentication initial (1),
  5    18      Automatic_authentication initial (2),
  5    19      Manual_authentication initial (3)) fixed bin internal static options (constant);
  5    20 
  5    21 dcl  authentication_level_names (0:3) char (12) internal static options (constant) initial
  5    22     ("none", "nominal", "automatic", "manual");
  5    23 
  5    24 /* END INCLUDE FILE ... rcp_init_flags.incl.pl1 */
  4   113 
  4   114 
  4   115 /*	End of include file ... rcp_data.incl.pl1	*/
      941 
      942 
  6     1 /* BEGIN INCLUDE FILE rcp_account_msg.incl.pl1    B. Greenberg 8/1/77 */
  6     2 
  6     3 dcl 1 rcp_account_msg based aligned,			/* Message format */
  6     4     2 device_user_procid bit (36),			/* id of process using the device */
  6     5 
  6     6     2 rcp_data_relp bit (18) unal,			/* Ptr to rcp_data entry for device */
  6     7     2 devtype fixed bin (8) unal,			/* rcp device type involved */
  6     8     2 pad bit (6) unal,
  6     9     2 action fixed bin (2) unal;			/* see below... */
  6    10 
  6    11 dcl (
  6    12      RCP_ACCTMSG_assign init (0),
  6    13      RCP_ACCTMSG_unassign init (1),
  6    14      RCP_ACCTMSG_attach init (2)
  6    15      ) options (constant) fixed bin (17) static;
  6    16 
  6    17 /* END INCLUDE FILE rcp_account_msg.incl.pl1 */
      943 
      944 
  7     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  7     2*   *
  7     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  7     4*   *
  7     5*   *	This include file defines the official RCP resource types.
  7     6*   *	The array of names is indexed by the corresponding device type.
  7     7*   *      MOD by RAF for MCA
  7     8**/
  7     9 
  7    10 
  7    11 
  7    12 /****^  HISTORY COMMENTS:
  7    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  7    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  7    15*     Support of MCA.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 dcl  DEVICE_TYPE (8) char (32)
  7    19 	internal static options (constant)
  7    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  7    21 
  7    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  7    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  7    24 
  7    25 dcl  VOLUME_TYPE (8) char (32)
  7    26 	internal static options (constant)
  7    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  7    28 
  7    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  7    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  7    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  7    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  7    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  7    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  7    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  7    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  7    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  7    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  7    39 
  7    40 
  7    41 /*	End include file ... rcp_resource_types.incl.pl1 */
      945 
      946 
  8     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8     2 /*       Begin include file rcp_requestor_info.incl.pl1
  8     3* *       
  8     4* *       This include file gives information about the subject,
  8     5* *       or requestor of the RCP operation.  In one case, absentee
  8     6* *       requests, the user is the Initializer, so this piece of
  8     7* *       information tells us about the real requestor of the RCP
  8     8* *       operation.
  8     9**/
  8    10 
  8    11 dcl requestor_info_ptr ptr;
  8    12 
  8    13 dcl 1 requestor_info aligned based (requestor_info_ptr),
  8    14     2 user_id char (32),
  8    15     2 current_authorization bit (72) aligned,
  8    16     2 validation_level fixed bin (3);
  8    17 
  8    18 /*  end include file .. rcp_requestor_info.incl.pl1 */
      947 
      948 
  9     1 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  9     2 /*       Begin include file rcp_resource_info.incl.pl1
  9     3*   *
  9     4*   *       This include file gives information about the object,
  9     5*   *       or resource for the RCP operation.  If RM is enabled this
  9     6*   *       information will provide the registry name and switch pointer
  9     7*   *       for the registry so additional resource information can be
  9     8*   *       determined.  If RM is disabled, this information will include
  9     9*   *       the resource name and/or type.
  9    10**/
  9    11 
  9    12 dcl	resource_info_ptr	   ptr;
  9    13 
  9    14 dcl	1 resource_info	   based (resource_info_ptr),
  9    15 	  2 registry_dir	   aligned char (64),	/*  Could be a different if it is reconstruct operation */
  9    16 	  2 registry_switch_ptr
  9    17 			   ptr,			/*  Switch to the registry */
  9    18 	  2 registry_record_ptr
  9    19 			   ptr,			/*  Pointer to the registry record */
  9    20 	  2 resource_type	   char (32),		/*  Resource type */
  9    21 	  2 resource_name	   char (32);		/*  Resource name */
  9    22 
  9    23 /*  end include file .. rcp_resource_info.incl.pl1 */
      949 
      950 
 10     1 /*        Begin include file rcp_resource_states.incl.pl1
 10     2**
 10     3**         Created by M. M. Pozzo on 841005
 10     4**	Modified by Chris Jones, 12/84, to add volume states.
 10     5**
 10     6**/
 10     7 
 10     8 declare FREE fixed bin static internal options (constant) init (0);
 10     9 declare ASSIGNED fixed bin static internal options (constant) init (1);
 10    10 declare DELETED fixed bin static internal options (constant) init (2);
 10    11 declare STORAGE_SYSTEM fixed bin static internal options (constant) init (3);
 10    12 declare RESERVED fixed bin static internal options (constant) init (4);
 10    13 
 10    14 /* End include file ... rcp_resource_states.incl.pl1  */
      951 
      952 
 11     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
 11     2 
 11     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
 11     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
 11     5 
 11     6 declare	mode_value_ptr		ptr,
 11     7 	number_of_modes		fixed bin;
 11     8 
 11     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
 11    10 	  2 version		fixed bin,
 11    11 	  2 number		fixed bin,
 11    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
 11    13 
 11    14 declare	mode_string_info_ptr	ptr;
 11    15 
 11    16 declare	1 mode_value		aligned based (mode_value_ptr),
 11    17 	  2 version		fixed bin,
 11    18 	  2 mode_name		char (32) unaligned,
 11    19 	  2 flags,
 11    20 	    3 boolean_valuep	bit (1) unaligned,
 11    21 	    3 numeric_valuep	bit (1) unaligned,
 11    22 	    3 char_valuep		bit (1) unaligned,
 11    23 	    3 boolean_value		bit (1) unaligned,
 11    24 	    3 pad1		bit (32) unaligned,
 11    25 	  2 numeric_value		fixed bin (35),
 11    26 	  2 char_value		char (32) varying,
 11    27 	  2 code			fixed bin (35),
 11    28 	  2 pad2			bit (36);
 11    29 
 11    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
 11    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
 11    32 
 11    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
      953 
      954 
 12     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 12     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 12     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 12     4 
 12     5 /* This include file has an ALM version.  Keep 'em in sync! */
 12     6 
 12     7 dcl (
 12     8 
 12     9 /* The following constants define the message action codes.  This indicates
 12    10*how a message is to be handled.  */
 12    11 
 12    12      SYSERR_CRASH_SYSTEM	init (1),			
 12    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 12    14 
 12    15      SYSERR_TERMINATE_PROCESS	init (2),
 12    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 12    17 
 12    18      SYSERR_PRINT_WITH_ALARM	init (3),
 12    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 12    20 
 12    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 12    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 12    23 
 12    24      SYSERR_LOG_OR_PRINT	init (4),
 12    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 12    26 
 12    27      SYSERR_LOG_OR_DISCARD	init (5),
 12    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 12    29 
 12    30 
 12    31 /* The following constants are added to the normal severities to indicate
 12    32*different sorting classes of messages.  */
 12    33 
 12    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 12    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 12    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 12    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 12    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 12    39 	) fixed bin internal static options (constant);
 12    40 
 12    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      955 
      956 
      957 /* BEGIN MESSAGE DOCUMENTATION
      958*
      959*   Message:
      960*   RCP: Reserved device devX_MM for RESERVER (id=RES_ID)
      961*
      962*   S:	$log
      963*
      964*   T:	$run
      965*
      966*   M:	Device devX_MM has been reserved for RESERVER.
      967*
      968*   A:	$ignore
      969*
      970*  Message:
      971*   RCP: Reserved volume volume_name for RESERVER (id=RES_ID)
      972*
      973*   S:	$log
      974*
      975*   T:	$run
      976*
      977*   M:	Volume volume_name has been reserved for RESERVER.
      978*
      979*   A:	$ignore
      980*
      981*   Message:
      982*   RCP: An error locking rcpd for reservation for RESERVED_FOR
      983*            by RESERVER [if they're not the same] (id=RES_ID).
      984*
      985*   S:	$log
      986*
      987*   T:	$run
      988*
      989*   M:     An error was found in the locking data for the resource.
      990*
      991*   A:	$ignore
      992*
      993*   Message:
      994*   RCP: Cancelled device devX_MM for GRP_ID (id=RES_ID)
      995*
      996*   S:	$log
      997*
      998*   T:	$run
      999*
     1000*   M:	The reservation for the named device has been cancelled.
     1001*
     1002*   A:	$ignore
     1003*
     1004*   Message:
     1005*   RCP: Cancelled volume volume_name for GRP_ID (id=RES_ID)
     1006*
     1007*   S:	$log
     1008*
     1009*   T:	$run
     1010*
     1011*   M:	The reservation for the named volume has been cancelled.
     1012*
     1013*   A:	$ignore
     1014*
     1015*   END MESSAGE DOCUMENTATION */
     1016 
     1017      end rcp_reserve_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0805.5  rcp_reserve_.pl1                  >spec>install>1111>rcp_reserve_.pl1
935          1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
937          2    02/13/79  1715.0  resource_control_desc.incl.pl1    >ldd>include>resource_control_desc.incl.pl1
939          3    03/27/86  1120.0  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
941          4    03/27/86  1120.0  rcp_data.incl.pl1                 >ldd>include>rcp_data.incl.pl1
4-113        5    11/21/79  1458.3  rcp_init_flags.incl.pl1           >ldd>include>rcp_init_flags.incl.pl1
943          6    11/09/77  0713.6  rcp_account_msg.incl.pl1          >ldd>include>rcp_account_msg.incl.pl1
945          7    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
947          8    03/15/85  0953.1  rcp_requestor_info.incl.pl1       >ldd>include>rcp_requestor_info.incl.pl1
949          9    03/15/85  0953.1  rcp_resource_info.incl.pl1        >ldd>include>rcp_resource_info.incl.pl1
951         10    03/15/85  0953.1  rcp_resource_states.incl.pl1      >ldd>include>rcp_resource_states.incl.pl1
953         11    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
955         12    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AA_array                        000466 automatic       structure                array level 1 unaligned dcl 493
DEVICE_TYPE                     000120 constant        char(32)                 initial array packed unaligned dcl 7-18 ref 224 227
                                                                                  282 285 697
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 7-30 ref 227 244 252 285 285
DISK_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 7-38 ref 288
FREE                                   constant        fixed bin(17,0)          initial dcl 10-8 ref 239 246 378 431 510 599 610 828
                                                                                  844
JUST_LOG                        000241 constant        fixed bin(17,0)          initial dcl 12-7 set ref 327* 364* 460* 818* 837*
MAX_AVAILABLE                          constant        fixed bin(17,0)          initial dcl 492 ref 493 507
P_rsc_name                             parameter       char                     packed unaligned dcl 565 ref 562 571
RCP_ACCTMSG_assign                     constant        fixed bin(17,0)          initial dcl 6-11 set ref 323*
RESERVED                               constant        fixed bin(17,0)          initial dcl 10-12 ref 319 360
Resource_count                  000432 automatic       fixed bin(17,0)          dcl 2-78 set ref 214 271 271 272 272 899* 900 901
                                                                                  901 903 904 905 905
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 7-29 ref 224 236 252 282 282 376 382 697
TAPE_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 7-37 ref 288
VOLUME_TYPE                     000020 constant        char(32)                 initial array packed unaligned dcl 7-25 ref 288 288
                                                                                  343 343 343
a_action                               parameter       fixed bin(17,0)          dcl 778 ref 769 788
a_authorization                        parameter       bit(72)                  dcl 158 ref 155 160
a_code                                 parameter       fixed bin(35,0)          dcl 53 set ref 13 155 394* 398 419* 429* 431* 433*
                                                                                  436* 442* 447* 452* 457* 465* 470* 475* 480*
a_devptr                               parameter       pointer                  dcl 777 ref 769 785 786 787
a_resource_desc_ptr                    parameter       pointer                  dcl 51 ref 13 155 398 415 897
a_resource_res_ptr                     parameter       pointer                  dcl 52 ref 13 155 898
access_audit_r1_$log_general    000010 constant        entry                    external dcl 100 ref 571
access_operations_$rcp_reserve  000076 external static bit(36)                  dcl 142 set ref 164 571*
accounting_chan          26            based           fixed bin(71,0)          level 2 dcl 4-29 set ref 791 791*
accounting_pid           30            based           bit(36)                  level 2 dcl 4-29 set ref 791*
action                    1(33) 002204 automatic       fixed bin(2,0)           level 2 packed packed unaligned dcl 781 set ref 788*
actual_access                   002124 automatic       bit(3)                   packed unaligned dcl 633 set ref 660*
addr                                                   builtin function         dcl 636 in procedure "have_access" ref 660 660 660
                                                                                  660
addr                                                   builtin function         dcl 147 in procedure "rcp_reserve_" ref 266 266 294
                                                                                  391 391 596 620 817 836 851 851
admin_gate_$syserr              000012 constant        entry                    external dcl 102 ref 327 364 460 818 837
any_reserved                    000100 automatic       bit(1)                   dcl 59 set ref 167* 321* 362* 813
asap_duration            26            based           fixed bin(71,0)          level 2 dcl 2-55 set ref 921* 921
attributes                      000101 automatic       varying char(256)        dcl 60 set ref 684* 688
audit_event_flags                      based           structure                level 1 dcl 1-5
authorization                   000202 automatic       bit(72)                  dcl 61 set ref 151* 160* 316 357 644* 654
auto_event_flags                002104 automatic       structure                level 1 dcl 566 set ref 568* 571 571
auto_rcpamsg                    002204 automatic       structure                level 1 dcl 781 set ref 783* 790
based_bits                             based           bit(36)                  array dcl 894 set ref 902* 902 906* 906
caller_level                    000204 automatic       fixed bin(17,0)          dcl 62 set ref 177* 395* 571* 643* 655 854*
callers_resource_desc_ptr       000206 automatic       pointer                  dcl 63 set ref 220 222 897* 899 902
callers_resource_res_ptr        000210 automatic       pointer                  dcl 65 set ref 393 856 856 898* 906
cleanup                         000420 stack reference condition                dcl 149 ref 179
clock                                                  builtin function         dcl 147 ref 190 318 359 827 843
code                            000212 automatic       fixed bin(35,0)          dcl 67 set ref 216* 218 220 266* 268 417* 418 419
                                                                                  465 684* 686 688* 689
cu_$level_get                   000014 constant        entry                    external dcl 103 ref 177
cu_$level_set                   000016 constant        entry                    external dcl 104 ref 181 395 643 650 854
current_AA                      002067 automatic       fixed bin(17,0)          dcl 498 set ref 505* 507 518 524 532* 532 542
current_authorization
                         72            based           bit(72)                  level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 316*
current_authorization
                         10     000240 automatic       bit(72)                  level 2 in structure "req_info" dcl 78 in procedure
                                                                                  "rcp_reserve_" set ref 654*
current_authorization
                         40            based           bit(72)                  level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 357*
cv_rcp_attributes_$to_string_rel
                                000020 constant        entry                    external dcl 105 ref 684
den_conversion_idx              002162 automatic       fixed bin(17,0)          dcl 732 set ref 738* 738* 741 743
den_conversion_table            000013 constant        fixed bin(17,0)          initial array dcl 734 ref 738 738 738 741
density                         000213 automatic       bit(5)                   dcl 68 set ref 510 510 510 679* 743* 743
density_in_bits                 000006 constant        bit(5)                   initial array dcl 735 ref 743
desired_attributes       31            based           bit(72)                  array level 3 in structure "resource_descriptions"
                                                                                  dcl 2-6 in procedure "rcp_reserve_" set ref 684
desired_attributes      270(03)        based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed packed unaligned dcl 2-6 in procedure
                                                                                  "rcp_reserve_" set ref 682
device                                 based           structure                level 1 dcl 4-59 in procedure "rcp_reserve_"
device                                 based           structure                array level 2 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 817
device_name                            based           char(8)                  level 2 dcl 4-59 set ref 327* 510 530 818*
device_ptr                      000442 automatic       pointer                  dcl 4-26 set ref 236* 236* 239 239* 242 242 244*
                                                                                  244* 246 246* 249 249 301* 309 310 312 314 316 318
                                                                                  319 323* 327 376* 376* 378* 380 380 507* 507* 510
                                                                                  510 510 510 510 510 519 529 530 531* 534 534 817*
                                                                                  818 818 821 821 824 825 826 827 828
device_user_procid              002204 automatic       bit(36)                  level 2 dcl 781 set ref 785*
devtype                   1(18) 002204 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 781 set ref 787*
dptr                                   parameter       pointer                  dcl 488 in procedure "select_device" set ref 483
                                                                                  504* 555*
dptr                      4     000466 automatic       pointer                  array level 2 in structure "AA_array" dcl 493
                                                                                  in procedure "select_device" set ref 525* 525 529*
                                                                                  555
dtype                                  based           structure                level 1 dcl 4-51 in procedure "rcp_reserve_"
dtype                    43            based           structure                array level 2 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 294
dtype_idx                       000214 automatic       fixed bin(17,0)          dcl 69 set ref 282* 285* 288* 293 294
dtype_ptr                       000440 automatic       pointer                  dcl 4-25 set ref 294* 507
dtypex                   12            based           fixed bin(17,0)          level 2 dcl 4-59 ref 787
error_table_$bad_conversion     000062 external static fixed bin(35,0)          dcl 130 ref 480
error_table_$badcall            000064 external static fixed bin(35,0)          dcl 132 ref 442
error_table_$device_limit_exceeded
                                000074 external static fixed bin(35,0)          dcl 139 ref 452
error_table_$reservation_failed 000070 external static fixed bin(35,0)          dcl 135 ref 470 475 571
error_table_$resource_reserved  000100 external static fixed bin(35,0)          dcl 412 ref 433
error_table_$resource_unknown   000066 external static fixed bin(35,0)          dcl 133 ref 457
error_table_$unimplemented_version
                                000072 external static fixed bin(35,0)          dcl 137 ref 447
first_off                56            based           bit(18)                  array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 236 244 376
first_off                13            based           bit(18)                  level 2 in structure "dtype" dcl 4-51 in procedure
                                                                                  "rcp_reserve_" ref 507
flags                    13            based           structure                array level 3 in structure "mode_string_info"
                                                                                  dcl 11-9 in procedure "rcp_reserve_"
flags                    30            based           structure                level 2 in structure "reservation_description"
                                                                                  dcl 2-55 in procedure "rcp_reserve_" set ref 922*
                                                                                  922
found                           002071 automatic       bit(1)                   packed unaligned dcl 500 set ref 517* 518 519* 522
                                                                                  541* 542 543* 555
get_authorization_              000022 constant        entry                    external dcl 107 ref 151
get_process_id_                 000026 constant        entry                    external dcl 109 ref 192
get_ring_                       000024 constant        entry                    external dcl 108 ref 181 181 650 650
get_system_free_area_           000030 constant        entry                    external dcl 110 ref 271 272 688 688 901 905
given                   270            based           structure                array level 3 dcl 2-6
group_id                 37            based           char(32)                 level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 818* 821*
group_id                 12            based           char(32)                 level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 341* 364* 837* 839*
group_id                               based           char(32)                 array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 386*
group_starting_time      24            based           fixed bin(71,0)          level 2 dcl 2-55 set ref 920* 920
hbound                                                 builtin function         dcl 147 ref 343 738 741 756 760
hcs_$wakeup                     000032 constant        entry                    external dcl 111 ref 791
i                               002114 automatic       fixed bin(17,0)          dcl 583 in procedure "select_volume" set ref 594*
                                                                                  596*
i                               000215 automatic       fixed bin(17,0)          dcl 70 in procedure "rcp_reserve_" set ref 214* 216
                                                                                  219 220 222* 274* 276 277 279 280 368* 385* 386
                                                                                  386* 426* 426* 429 431 682 684 684 697 814* 816
                                                                                  817* 833* 835 836*
ii                                     parameter       fixed bin(17,0)          dcl 928 ref 925 930 931
is_volume                       000216 automatic       bit(1)                   packed unaligned dcl 71 set ref 417* 423
item                      2            based           structure                array level 2 dcl 2-6 set ref 276* 276 930* 930
last_time                 2     000466 automatic       fixed bin(71,0)          array level 2 dcl 493 set ref 519 527* 527 531*
last_volume              20            based           fixed bin(17,0)          level 2 dcl 4-29 set ref 426 429 594 618 619* 619
                                                                                  620 833
lbound                                                 builtin function         dcl 147 ref 343 738 756
local_code                      002125 automatic       fixed bin(35,0)          dcl 634 set ref 644* 647* 660* 663
lock_info                              based           structure                level 1 dcl 3-46 in procedure "rcp_reserve_"
lock_info                              based           structure                level 2 in structure "rcpd" dcl 4-29 in procedure
                                                                                  "rcp_reserve_" set ref 266 266 391 391 851 851
log_res_id                      000217 automatic       char(19)                 packed unaligned dcl 72 set ref 191* 327* 364* 460*
                                                                                  818* 837*
loop                            002066 automatic       fixed bin(17,0)          dcl 497 set ref 524* 525 525 526 526 527 527* 542*
                                                                                  543* 555
max_concurrent           53            based           fixed bin(17,0)          array level 3 dcl 4-29 set ref 252 252
mode_idx                        002134 automatic       fixed bin(17,0)          dcl 675 set ref 692* 693 695 698 700 702* 715 725
                                                                                  738 756
mode_name                 3            based           char(32)                 array level 3 packed packed unaligned dcl 11-9 ref
                                                                                  695 698 700 702
mode_string_$parse              000034 constant        entry                    external dcl 112 ref 688
mode_string_info                       based           structure                level 1 dcl 11-9 ref 873
mode_string_info_ptr            000446 automatic       pointer                  dcl 11-14 set ref 173* 688* 692 693 695 698 700 702
                                                                                  715 725 738 756 872 873 874*
mode_value                             based           structure                level 1 dcl 11-16
model                    13            based           fixed bin(17,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" ref 510
model                           000224 automatic       fixed bin(35,0)          dcl 73 in procedure "rcp_reserve_" set ref 510 510
                                                                                  677* 712 715*
modes                    14(01)        based           structure                level 2 in structure "rcpd" packed packed unaligned
                                                                                  dcl 4-29 in procedure "rcp_reserve_"
modes                     2            based           structure                array level 2 in structure "mode_string_info"
                                                                                  dcl 11-9 in procedure "rcp_reserve_"
n_items                  31            based           fixed bin(17,0)          level 2 in structure "reservation_description"
                                                                                  dcl 2-55 in procedure "rcp_reserve_" set ref 207
                                                                                  272* 869 881 905* 914*
n_items                   1            based           fixed bin(17,0)          level 2 in structure "resource_descriptions" dcl 2-6
                                                                                  in procedure "rcp_reserve_" set ref 207 207 271*
                                                                                  274 865 877 899 901* 903* 913*
name                     12            based           char(32)                 array level 3 in structure "resource_descriptions"
                                                                                  dcl 2-6 in procedure "rcp_reserve_" set ref 280
                                                                                  416 640*
name                            000466 automatic       char(8)                  array level 2 in structure "AA_array" packed packed
                                                                                  unaligned dcl 493 in procedure "select_device" set
                                                                                  ref 526* 526 530* 543*
name                    270            based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed packed unaligned dcl 2-6 in procedure
                                                                                  "rcp_reserve_" set ref 641*
next_off                 31            based           bit(18)                  level 2 dcl 4-59 ref 242 249 380 534
null                                                   builtin function         dcl 147 ref 168 169 171 172 173 174 175 298 335 504
                                                                                  571 571 586 604 611 617 657 851 856 864 866 868
                                                                                  870 872 874 876 878 880 882
num_free                        000225 automatic       fixed bin(17,0)          dcl 74 set ref 374* 378* 378 382
num_reserved             54            based           fixed bin(17,0)          array level 3 dcl 4-29 set ref 382
number                    1            based           fixed bin(17,0)          level 2 dcl 11-9 ref 692 873
numeric_value            14            based           fixed bin(35,0)          array level 3 dcl 11-9 ref 715 725 738 756
numeric_valuep           13(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 11-9 ref
                                                                                  693
operation                       000226 automatic       bit(36)                  dcl 75 set ref 164* 660*
primary_type                    000227 automatic       char(32)                 packed unaligned dcl 76 set ref 216* 222 224 227
process_id                             based           bit(36)                  level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 353* 355* 842*
process_id               36            based           bit(36)                  level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 239 246 312* 314* 785 826*
process_id                      000237 automatic       bit(36)                  dcl 77 in procedure "rcp_reserve_" set ref 192* 239
                                                                                  246 314 355
ptr                                                    builtin function         dcl 147 ref 236 242 244 249 376 380 507 534
qualifiers               15            based           fixed bin(35,0)          array level 2 dcl 4-59 ref 510 510 510
rcp_access_kernel_              000036 constant        entry                    external dcl 113 ref 660
rcp_account_msg                        based           structure                level 1 dcl 6-3
rcp_data_relp             1     002204 automatic       bit(18)                  level 2 packed packed unaligned dcl 781 set ref 786*
rcp_init_flags                         based           structure                level 1 packed packed unaligned dcl 5-8
rcp_lock_$lock                  000044 constant        entry                    external dcl 116 ref 266
rcp_lock_$unlock                000046 constant        entry                    external dcl 117 ref 391 851
rcp_pointers_$com_seg           000042 constant        entry                    external dcl 115 ref 186
rcp_pointers_$data              000040 constant        entry                    external dcl 114 ref 185 424
rcpd                                   based           structure                level 1 dcl 4-29
rcpd_ptr                        000436 automatic       pointer                  dcl 4-24 set ref 168* 185* 236 236 244 244 252 252
                                                                                  266 266 294 376 376 382 385 386 386 391 391 424*
                                                                                  426 426 429 431 507 594 596 618 618 619 619 620
                                                                                  620 639 791 791 791 814 816 817 833 835 836 851
                                                                                  851 851
rcprm_find_resource_$reserve    000050 constant        entry                    external dcl 118 ref 647
rcprm_find_resource_$reserve_proxy
                                000052 constant        entry                    external dcl 120 ref 644
rcs_ptr                         000434 automatic       pointer                  dcl 3-23 set ref 169* 186*
rcse                                   based           structure                level 1 dcl 3-55
registry_dir                    000276 automatic       char(64)                 level 2 in structure "res_info" dcl 82 in procedure
                                                                                  "rcp_reserve_" set ref 656*
registry_dir                           parameter       char                     packed unaligned dcl 405 in procedure "rcp_reserve_"
                                                                                  ref 398
registry_directory              000342 automatic       char(64)                 packed unaligned dcl 83 set ref 170* 644* 647*
registry_record_ptr      22     000276 automatic       pointer                  level 2 dcl 82 set ref 657*
registry_switch_ptr      20     000276 automatic       pointer                  level 2 dcl 82 set ref 657*
rel                                                    builtin function         dcl 147 ref 236 244 376 507 786
req_info                        000240 automatic       structure                level 1 dcl 78 set ref 660 660
request_id_                     000054 constant        entry                    external dcl 122 ref 191
requestor_info                         based           structure                level 1 dcl 8-13
res_by                          000253 automatic       char(32)                 packed unaligned dcl 79 set ref 189* 200 310 351 460
                                                                                  460*
res_for                         000263 automatic       char(32)                 packed unaligned dcl 80 set ref 188* 200 327* 341
                                                                                  386 460* 460 653
res_id                          000274 automatic       fixed bin(71,0)          dcl 81 set ref 190* 191* 309 350 386 393 816 835
res_info                        000276 automatic       structure                level 1 dcl 82 set ref 660 660
reservation_description                based           structure                level 1 dcl 2-55 set ref 272 869 881 904 905
reservation_group        32            based           structure                array level 2 dcl 2-55 set ref 277* 277 931* 931
reservation_id           22            based           fixed bin(71,0)          level 2 in structure "reservation_description"
                                                                                  dcl 2-55 in procedure "rcp_reserve_" set ref 393*
                                                                                  856* 919* 919
reservation_id           60            based           fixed bin(71,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 309* 824*
reservation_id                         based           fixed bin(71,0)          array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 386 816
reservation_id           32            based           fixed bin(71,0)          level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 350* 840*
reservation_id                         based           fixed bin(71,0)          array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 835
reserved_by              11            based           char(32)                 level 2 in structure "reservation_description"
                                                                                  dcl 2-55 in procedure "rcp_reserve_" set ref 189
                                                                                  918* 918
reserved_by              22            based           char(32)                 level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 351* 841*
reserved_by              62            based           char(32)                 level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 310* 825*
reserved_for              1            based           char(32)                 level 2 dcl 2-55 set ref 188 644 917* 917
reserver_chain                         parameter       bit(18)                  packed unaligned dcl 405 ref 398
reserver_info_ptr                      parameter       pointer                  dcl 405 ref 398
resource_desc_ptr               000426 automatic       pointer                  dcl 2-72 set ref 171* 203 207 207 216 219 274 276
                                                                                  279 280 415* 416 417 419 682 684 684 697 864 865
                                                                                  866* 900 901* 902 903 915 930
resource_desc_version_1                constant        fixed bin(17,0)          initial dcl 2-75 ref 203
resource_descriptions                  based           structure                level 1 dcl 2-6 set ref 271 865 877 900 901
resource_info                          based           structure                level 1 unaligned dcl 9-14
resource_info_$get_primary_type 000060 constant        entry                    external dcl 125 ref 216
resource_info_$get_type         000056 constant        entry                    external dcl 123 ref 417
resource_mgmt_enabled
                         14(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-29 ref 639
resource_name            34     000276 automatic       char(32)                 level 2 in structure "res_info" dcl 82 in procedure
                                                                                  "rcp_reserve_" set ref 659*
resource_name                          parameter       char                     packed unaligned dcl 629 in procedure "have_access"
                                                                                  ref 626 640 659
resource_no                            parameter       fixed bin(17,0)          dcl 405 ref 398 416 417 419
resource_res_ptr                000430 automatic       pointer                  dcl 2-72 set ref 172* 188 189 203 207 277 644 868
                                                                                  869 870* 904 905* 906 916 917 918 919 920 921 922
                                                                                  931
resource_res_version_1                 constant        fixed bin(17,0)          initial dcl 2-75 ref 203
resource_type            24     000276 automatic       char(32)                 level 2 dcl 82 set ref 658*
ret_ptr                         000362 automatic       pointer                  dcl 84 set ref 296* 298 301 333* 335 338
rsc_name                        000364 automatic       char(32)                 packed unaligned dcl 85 set ref 280* 340 416* 426
                                                                                  510 510 557 557* 588 588* 591* 598 598
rsc_type                        000374 automatic       char(32)                 packed unaligned dcl 86 set ref 219* 279* 282 285
                                                                                  288 288 343 571 658
rtrim                                                  builtin function         dcl 147 ref 571
saved_code                      000404 automatic       fixed bin(35,0)          dcl 87 set ref 213* 220* 232
size                                                   builtin function         dcl 147 ref 900 904
special_rdesc_ptr               000406 automatic       pointer                  dcl 88 set ref 174* 271* 276 640 641 644* 647* 876
                                                                                  877 878* 913 915 930
special_resv_ptr                000410 automatic       pointer                  dcl 89 set ref 175* 272* 277 644* 647* 880 881 882*
                                                                                  914 916 917 918 919 920 921 922 931
speed                           000412 automatic       bit(3)                   dcl 90 set ref 510 510 680* 763* 763
speed_conversion_idx            002172 automatic       fixed bin(17,0)          dcl 750 set ref 756* 756* 760 763
speed_conversion_table          000003 constant        fixed bin(17,0)          initial array dcl 752 ref 756 756 756 760
speed_in_bits                   000000 constant        bit(3)                   initial array dcl 754 ref 763
start                           002070 automatic       fixed bin(17,0)          dcl 499 set ref 516* 518* 519* 522 522* 522 524 529
                                                                                  530 531
state                    36            based           fixed bin(17,0)          level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 360* 599 610 844*
state                    24            based           fixed bin(17,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 239 246 319* 378 510 828*
state                                  based           fixed bin(17,0)          array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 431
state_time               22            based           fixed bin(71,0)          level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" set ref 318* 519 531 827*
state_time               34            based           fixed bin(71,0)          level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 359* 843*
status_code             272            based           fixed bin(35,0)          array level 3 dcl 2-6 set ref 220* 419*
system                          000413 automatic       bit(1)                   dcl 91 set ref 152* 161* 200 235 312 323 353 570 644
system_free_area                       based           area(1024)               dcl 96 ref 271 272 901 905
tot_devices              16            based           fixed bin(17,0)          level 2 dcl 4-29 ref 385 426 431 596 620 814 835 836
tot_disk_drives                 000414 automatic       fixed bin(17,0)          dcl 92 set ref 211* 227* 227 246* 246 252
tot_dtypes               15            based           fixed bin(17,0)          level 2 dcl 4-29 ref 386 386 426 431 596 620 816 817
                                                                                  835 836
tot_tape_drives                 000415 automatic       fixed bin(17,0)          dcl 93 set ref 210* 224* 224 239* 239 252
tot_volumes              17            based           fixed bin(17,0)          level 2 dcl 4-29 ref 618
tracks                          000416 automatic       fixed bin(35,0)          dcl 94 set ref 510 510 678* 722 725*
type                      2            based           char(32)                 array level 3 dcl 2-6 set ref 216 219 222* 279 417
                                                                                  684 697
unspec                                                 builtin function         dcl 147 set ref 510 510 568* 571 571 783* 790* 790
user_id                         000240 automatic       char(32)                 level 2 dcl 78 set ref 653*
validation_level         12     000240 automatic       fixed bin(3,0)           level 2 dcl 78 set ref 655*
version_no                             based           fixed bin(17,0)          level 2 in structure "resource_descriptions" dcl 2-6
                                                                                  in procedure "rcp_reserve_" set ref 203 915* 915
version_no                             based           fixed bin(17,0)          level 2 in structure "reservation_description"
                                                                                  dcl 2-55 in procedure "rcp_reserve_" set ref 203
                                                                                  916* 916
volume                                 based           structure                level 1 dcl 4-101 in procedure "rcp_reserve_"
volume                                 based           structure                array level 2 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 596 620 836
volume_name               1            based           char(32)                 level 2 in structure "volume" dcl 4-101 in procedure
                                                                                  "rcp_reserve_" set ref 340* 347 347* 364* 598 610
                                                                                  837*
volume_name               2            based           char(32)                 level 2 in structure "device" dcl 4-59 in procedure
                                                                                  "rcp_reserve_" ref 821
volume_name                            based           char(32)                 array level 3 in structure "rcpd" dcl 4-29
                                                                                  in procedure "rcp_reserve_" set ref 426
volume_ptr                      000444 automatic       pointer                  dcl 4-27 set ref 338* 340 341 343 343 347 347 350
                                                                                  351 353 355 357 359 360 364 364 596* 598 599 600
                                                                                  610 610 611 836* 837 837 839 840 841 842 843 844
vptr                                   parameter       pointer                  dcl 582 set ref 577 586* 600* 604* 611 611* 617 620*
vtypex                   11            based           fixed bin(17,0)          level 2 dcl 4-101 set ref 343* 343*
wakeup_buf                      002202 automatic       fixed bin(71,0)          dcl 780 set ref 790* 791*
wordcount                       002214 automatic       fixed bin(21,0)          dcl 895 set ref 900* 902 904* 906

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 12-7
ASSIGNED                               internal static fixed bin(17,0)          initial dcl 10-9
Automatic_authentication               internal static fixed bin(17,0)          initial dcl 5-16
BEEP                                   internal static fixed bin(17,0)          initial dcl 12-7
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 7-31
CRASH                                  internal static fixed bin(17,0)          initial dcl 12-7
DELETED                                internal static fixed bin(17,0)          initial dcl 10-10
LOG                                    internal static fixed bin(17,0)          initial dcl 12-7
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 7-36
Manual_authentication                  internal static fixed bin(17,0)          initial dcl 5-16
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 7-22
No_authentication                      internal static fixed bin(17,0)          initial dcl 5-16
Nominal_authentication                 internal static fixed bin(17,0)          initial dcl 5-16
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 7-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 7-33
RCP_ACCTMSG_attach                     internal static fixed bin(17,0)          initial dcl 6-11
RCP_ACCTMSG_unassign                   internal static fixed bin(17,0)          initial dcl 6-11
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 7-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 7-35
STORAGE_SYSTEM                         internal static fixed bin(17,0)          initial dcl 10-11
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 12-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 12-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 12-7
authentication_level_names             internal static char(12)                 initial array packed unaligned dcl 5-21
based_rcp_id                           based           structure                level 1 dcl 3-26
lock_info_ptr                          automatic       pointer                  dcl 3-22
mode_string_info_version_2             internal static fixed bin(17,0)          initial dcl 11-30
mode_value_ptr                         automatic       pointer                  dcl 11-6
mode_value_version_3                   internal static fixed bin(17,0)          initial dcl 11-30
number_of_modes                        automatic       fixed bin(17,0)          dcl 11-6
rcs                                    based           structure                level 1 dcl 3-30
rcse_ptr                               automatic       pointer                  dcl 3-24
requestor_info_ptr                     automatic       pointer                  dcl 8-11
resource_info_ptr                      automatic       pointer                  dcl 9-12
rifp                                   automatic       pointer                  dcl 5-6

NAMES DECLARED BY EXPLICIT CONTEXT.
ACCOUNT_WAKEUP                  003465 constant        entry                    internal dcl 769 ref 323
BAD_ATTRIBUTE                   002137 constant        label                    dcl 478 ref 693 712 722 741 760
BAD_CALL                        002004 constant        label                    dcl 440 ref 207
BAD_ERROR                       002044 constant        label                    dcl 460 ref 268 686 689
BAD_NAME                        002127 constant        label                    dcl 473 ref 200
BAD_RESOURCE                    002034 constant        label                    dcl 455 ref 232 288
BAD_VERSION                     002014 constant        label                    dcl 445 ref 203
RESERVATION_FAILED              002117 constant        label                    dcl 468 ref 298 335 382
START                           000445 constant        label                    dcl 164 set ref 153 162
TOO_MANY_DEVICES                002024 constant        label                    dcl 450 set ref 252
approve_schedule                001602 constant        entry                    external dcl 398
audit                           002402 constant        entry                    internal dcl 562 ref 557
cleanup_handler                 003533 constant        entry                    internal dcl 796 ref 179 440 445 450 455 464 468 473
                                                                                  478
copy_back_rdesc_and_resv        004304 constant        entry                    internal dcl 925 ref 368
copy_rdesc_and_resv             004252 constant        entry                    internal dcl 910 ref 273
copy_resource_and_reservation_structures
                                004154 constant        entry                    internal dcl 887 ref 183
den_mode_proc                   003411 constant        entry                    internal dcl 729 ref 700
free_storage                    004044 constant        entry                    internal dcl 861 ref 392 812
get_attr_values                 003140 constant        entry                    internal dcl 667 ref 502
have_access                     002714 constant        entry                    internal dcl 626 ref 543 591
model_mode_proc                 003367 constant        entry                    internal dcl 709 ref 695
rcp_reserve_                    000400 constant        entry                    external dcl 13
select_device                   002147 constant        entry                    internal dcl 483 ref 296
select_volume                   002545 constant        entry                    internal dcl 577 ref 333
speed_mode_proc                 003436 constant        entry                    internal dcl 747 ref 702
sys                             000425 constant        entry                    external dcl 155
track_mode_proc                 003400 constant        entry                    internal dcl 719 ref 698

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5032        5134    4371        5042
Length      5656    4371       102         506     441           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_reserve_                       1431 external procedure  is an external procedure.  
on unit on line 179                  64 on unit               
select_device                           internal procedure  shares stack frame of external procedure rcp_reserve_.  
audit                                   internal procedure  shares stack frame of external procedure rcp_reserve_.  
select_volume                           internal procedure  shares stack frame of external procedure rcp_reserve_.  
have_access                             internal procedure  shares stack frame of external procedure rcp_reserve_.  
get_attr_values                         internal procedure  shares stack frame of external procedure rcp_reserve_.  
model_mode_proc                         internal procedure  shares stack frame of external procedure rcp_reserve_.  
track_mode_proc                         internal procedure  shares stack frame of external procedure rcp_reserve_.  
den_mode_proc                           internal procedure  shares stack frame of external procedure rcp_reserve_.  
speed_mode_proc                         internal procedure  shares stack frame of external procedure rcp_reserve_.  
ACCOUNT_WAKEUP                          internal procedure  shares stack frame of external procedure rcp_reserve_.  
cleanup_handler                     102 internal procedure  is called by several nonquick procedures.  
free_storage                         64 internal procedure  is called by several nonquick procedures.  
copy_resource_and_reservation_structures
                                        internal procedure  shares stack frame of external procedure rcp_reserve_.  
copy_rdesc_and_resv                     internal procedure  shares stack frame of external procedure rcp_reserve_.  
copy_back_rdesc_and_resv                internal procedure  shares stack frame of external procedure rcp_reserve_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_reserve_             000100 any_reserved                rcp_reserve_
                         000101 attributes                  rcp_reserve_
                         000202 authorization               rcp_reserve_
                         000204 caller_level                rcp_reserve_
                         000206 callers_resource_desc_ptr   rcp_reserve_
                         000210 callers_resource_res_ptr    rcp_reserve_
                         000212 code                        rcp_reserve_
                         000213 density                     rcp_reserve_
                         000214 dtype_idx                   rcp_reserve_
                         000215 i                           rcp_reserve_
                         000216 is_volume                   rcp_reserve_
                         000217 log_res_id                  rcp_reserve_
                         000224 model                       rcp_reserve_
                         000225 num_free                    rcp_reserve_
                         000226 operation                   rcp_reserve_
                         000227 primary_type                rcp_reserve_
                         000237 process_id                  rcp_reserve_
                         000240 req_info                    rcp_reserve_
                         000253 res_by                      rcp_reserve_
                         000263 res_for                     rcp_reserve_
                         000274 res_id                      rcp_reserve_
                         000276 res_info                    rcp_reserve_
                         000342 registry_directory          rcp_reserve_
                         000362 ret_ptr                     rcp_reserve_
                         000364 rsc_name                    rcp_reserve_
                         000374 rsc_type                    rcp_reserve_
                         000404 saved_code                  rcp_reserve_
                         000406 special_rdesc_ptr           rcp_reserve_
                         000410 special_resv_ptr            rcp_reserve_
                         000412 speed                       rcp_reserve_
                         000413 system                      rcp_reserve_
                         000414 tot_disk_drives             rcp_reserve_
                         000415 tot_tape_drives             rcp_reserve_
                         000416 tracks                      rcp_reserve_
                         000426 resource_desc_ptr           rcp_reserve_
                         000430 resource_res_ptr            rcp_reserve_
                         000432 Resource_count              rcp_reserve_
                         000434 rcs_ptr                     rcp_reserve_
                         000436 rcpd_ptr                    rcp_reserve_
                         000440 dtype_ptr                   rcp_reserve_
                         000442 device_ptr                  rcp_reserve_
                         000444 volume_ptr                  rcp_reserve_
                         000446 mode_string_info_ptr        rcp_reserve_
                         000466 AA_array                    select_device
                         002066 loop                        select_device
                         002067 current_AA                  select_device
                         002070 start                       select_device
                         002071 found                       select_device
                         002104 auto_event_flags            audit
                         002114 i                           select_volume
                         002124 actual_access               have_access
                         002125 local_code                  have_access
                         002134 mode_idx                    get_attr_values
                         002162 den_conversion_idx          den_mode_proc
                         002172 speed_conversion_idx        speed_mode_proc
                         002202 wakeup_buf                  ACCOUNT_WAKEUP
                         002204 auto_rcpamsg                ACCOUNT_WAKEUP
                         002214 wordcount                   copy_resource_and_reservation_structures

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry           ext_entry_desc
int_entry           op_alloc_           op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_r1_$log_general  admin_gate_$syserr            cu_$level_get                 cu_$level_set
cv_rcp_attributes_$to_string_rel                            get_authorization_            get_process_id_
get_ring_                     get_system_free_area_         hcs_$wakeup                   mode_string_$parse
rcp_access_kernel_            rcp_lock_$lock                rcp_lock_$unlock              rcp_pointers_$com_seg
rcp_pointers_$data            rcprm_find_resource_$reserve  rcprm_find_resource_$reserve_proxy
request_id_                   resource_info_$get_primary_type                             resource_info_$get_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$rcp_reserve                              error_table_$bad_conversion   error_table_$badcall
error_table_$device_limit_exceeded                          error_table_$reservation_failed
error_table_$resource_reserved                              error_table_$resource_unknown
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000374       151 000410       152 000416       153 000417       155 000420       160 000435       161 000442
    162 000444       164 000445       167 000450       168 000451       169 000453       170 000454       171 000457
    172 000460       173 000461       174 000462       175 000463       177 000464       179 000472       181 000514
    183 000532       185 000533       186 000542       188 000551       189 000555       190 000560       191 000562
    192 000573       200 000604       203 000612       207 000620       210 000627       211 000630       213 000631
    214 000632       216 000641       218 000670       219 000672       220 000701       221 000706       222 000707
    224 000716       227 000727       230 000737       232 000741       235 000743       236 000745       239 000756
    242 000765       244 000771       246 001002       249 001011       252 001015       266 001030       268 001043
    271 001045       272 001065       273 001105       274 001106       276 001117       277 001126       279 001140
    280 001145       282 001152       285 001164       288 001176       293 001214       294 001216       296 001222
    298 001224       301 001230       309 001232       310 001235       312 001240       314 001244       316 001246
    318 001251       319 001253       321 001255       323 001257       327 001263       329 001317       333 001320
    335 001322       338 001326       340 001330       341 001334       343 001337       345 001360       347 001362
    350 001372       351 001374       353 001377       355 001403       357 001405       359 001410       360 001412
    362 001414       364 001416       368 001451       369 001453       374 001455       376 001456       378 001466
    380 001472       382 001476       385 001504       386 001513       389 001541       391 001543       392 001554
    393 001560       394 001563       395 001564       396 001573       398 001574       415 001620       416 001624
    417 001632       418 001657       419 001661       420 001672       423 001673       424 001676       426 001705
    427 001742       429 001744       431 001752       433 001776       434 002001       436 002002       438 002003
    440 002004       442 002010       443 002013       445 002014       447 002020       448 002023       450 002024
    452 002030       453 002033       455 002034       457 002040       458 002043       460 002044       464 002110
    465 002114       466 002116       468 002117       470 002123       471 002126       473 002127       475 002133
    476 002136       478 002137       480 002143       481 002146       483 002147       502 002151       504 002152
    505 002155       507 002156       510 002171       516 002225       517 002227       518 002230       519 002237
    521 002247       522 002251       524 002257       525 002267       526 002272       527 002277       528 002301
    529 002304       530 002310       531 002315       532 002317       534 002320       541 002324       542 002325
    543 002337       545 002361       555 002363       557 002372       560 002401       562 002402       568 002413
    569 002414       570 002416       571 002423       574 002543       577 002545       586 002547       588 002551
    591 002560       594 002567       596 002577       598 002620       599 002630       600 002632       601 002634
    604 002635       605 002640       607 002641       610 002642       611 002650       615 002656       617 002660
    618 002665       619 002671       620 002672       624 002713       626 002714       639 002725       640 002731
    641 002737       643 002741       644 002750       647 003013       650 003037       651 003055       653 003056
    654 003061       655 003063       656 003065       657 003070       658 003073       659 003076       660 003104
    663 003127       667 003140       677 003141       678 003142       679 003143       680 003144       682 003145
    684 003153       686 003230       688 003232       689 003277       692 003302       693 003313       695 003320
    697 003330       698 003343       700 003351       702 003357       705 003364       707 003366       709 003367
    712 003370       715 003372       717 003377       719 003400       722 003401       725 003403       727 003410
    729 003411       738 003412       740 003426       741 003430       743 003433       745 003435       747 003436
    756 003437       759 003455       760 003457       763 003462       765 003464       769 003465       783 003467
    785 003471       786 003475       787 003477       788 003502       790 003506       791 003510       794 003531
    796 003532       812 003540       813 003545       814 003550       816 003562       817 003600       818 003604
    821 003640       824 003651       825 003653       826 003656       827 003657       828 003661       831 003663
    833 003666       835 003700       836 003724       837 003730       839 003763       840 003770       841 003772
    842 003775       843 003776       844 004000       847 004002       851 004005       854 004022       856 004032
    859 004042       861 004043       864 004051       865 004056       866 004064       868 004067       869 004073
    870 004101       872 004104       873 004110       874 004116       876 004121       877 004125       878 004133
    880 004136       881 004142       882 004150       885 004153       887 004154       897 004155       898 004161
    899 004164       900 004166       901 004171       902 004211       904 004217       905 004223       906 004243
    908 004251       910 004252       913 004253       914 004256       915 004260       916 004262       917 004264
    918 004270       919 004273       920 004275       921 004277       922 004301       923 004303       925 004304
    930 004306       931 004316       933 004327


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
