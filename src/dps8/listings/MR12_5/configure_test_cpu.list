	COMPILATION LISTING OF SEGMENT configure_test_cpu
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1028.4 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* configure_test_cpu - procedure to do the physical work of CPU reconfiguration for ISOLTS. A primitive CPU
       14*   confidence test of the CPU is also accomplished to assure that the storage system will not be
       15*   compromised by user ring testing with ISOLTS
       16*
       17*   Initial coding by J. A. Bush - 10/78
       18*   Modified 9/16/80 by J. A. Bush for the DPS8/70M CPU
       19*   Modified 4/81 by J. A. Bush to correct bug in read switch code for DPS8/70M CPU
       20*   Modified October 1981 by J. Bongiovanni for set_procs_required
       21*   Modified 12/81 by J. A. Bush to correct bug in assigning SCU masks for SCUs with type codes > "0010"b
       22*   Modified 1/82 by J. A. Bush to report no response from RSW program, if inst. word 0 was not changed
       23*   Modified April 1982 by J. Bongiovanni for expanded SCS switch data/masks
       24*   Modified June 23, 1982 by J. A. Bush to clear cache while waiting for
       25*   a response from the cpu under test, due to the isolts_/Multics address mismatch
       26*   Modified Sept 21, 1983 by J. A. Bush to set scs$processor_data (tag).cache_size to ignore and
       27*   to reserve 128K for DPS8 cpus
       28**/
       29 
       30 /* format: style4 */
       31 
       32 configure_test_cpu: proc (rcode);
       33 
       34 dcl  rcode fixed bin (35);				/* entry parameter */
       35 
       36 /* External entries */
       37 
       38 dcl  scr_util$assign_mask entry (fixed bin (3), fixed bin (3));
       39 dcl  scr_util$isolts_scu_p1 entry;
       40 dcl  scr_util$isolts_scu_p2 entry;
       41 dcl  scr_util$isolts_scu_p3 entry;
       42 dcl  scr_util$set_mask entry (fixed bin (3), fixed bin (3), bit (72) aligned);
       43 dcl  privileged_mode_ut$swap_sdw entry (ptr, ptr);
       44 dcl  privileged_mode_ut$smic_port entry (bit (36) aligned, fixed bin (5));
       45 dcl  privileged_mode_ut$cioc entry (ptr);
       46 dcl  privileged_mode_ut$clear_cache entry;
       47 dcl  privileged_mode_ut$wire_and_mask entry (fixed bin (71), ptr);
       48 dcl  privileged_mode_ut$unwire_unmask entry (fixed bin (71), ptr);
       49 dcl  wire_proc$wire_me entry;
       50 dcl  wire_proc$unwire_me entry;
       51 dcl  set_procs_required entry (bit (8) aligned, fixed bin (35));
       52 dcl  pc_abs$remove_core entry (fixed bin, fixed bin, fixed bin (35));
       53 dcl  freecore entry (fixed bin);
       54 dcl  syserr$error_code entry options (variable);
       55 
       56 /* External static */
       57 
       58 dcl  isolts_abs_seg$ fixed bin ext;			/* abs seg for isolts */
       59 dcl  fault_vector$ fixed bin ext;			/* fault vector segment */
       60 dcl  pds$processid bit (36) aligned ext;
       61 dcl  prds$processor_tag fixed bin (3) ext;
       62 dcl  prds$processor_pattern bit (8) aligned ext;
       63 
       64 /* Automatic */
       65 
       66 dcl  (icpu, iscu) fixed bin (5);			/* ISOLTS CPU and SCU tags */
       67 dcl  pdp ptr;					/* pointer to processor data for new CPU */
       68 dcl  cdp ptr;					/* pointer to controller data */
       69 dcl  old_pdp ptr;					/* pointer to processor data for CPU losing mask */
       70 dcl  ptp ptr;					/* temporary for wire_and_mask */
       71 dcl  mask_temp fixed bin (71);			/* temporary for wire_and_mask */
       72 dcl  int_vec_save (2) bit (36) aligned;			/* for saving interrupt vector */
       73 dcl  trouble_save (2) bit (36) aligned;			/* for saving trouble fault vector */
       74 dcl  startup_save (2) bit (36) aligned;			/* for saving startup fault vector */
       75 dcl  onc_save (2) bit (36) aligned;			/* for saving onc fault vector */
       76 dcl  lockup_save (2) bit (36) aligned;			/* for saving lockup fault vector */
       77 dcl  (i, j, k) fixed bin;				/* iteration variables */
       78 dcl  l fixed bin (18);				/* iteration variable for > 128k */
       79 dcl  abs_seg_p ptr;					/* pointer to abs_seg */
       80 dcl  pip ptr;					/* pointer to port info */
       81 dcl  switchp ptr;					/* pointer to switch readings */
       82 dcl  found bit (1);					/* useful flag */
       83 dcl  dps8 bit (1);					/* dps8 cpu flag */
       84 dcl  reconfig_err bit (1);				/* flag for error checking */
       85 dcl  remember (0:7) fixed bin;			/* base of controllers with vector template */
       86 dcl  base fixed bin;				/* base address of controller */
       87 dcl  size fixed bin;				/* size of a controller */
       88 dcl  req_mem fixed bin;				/* Memory to reserve for ring 4 testing */
       89 dcl  str_flt_operand bit (18);			/*  address that will generate store fault */
       90 dcl  tcode fixed bin (35);				/* temporary for error code */
       91 dcl  isolts_switch_mask (0:4) bit (36) aligned;		/* mask for checking switches */
       92 dcl  isolts_switch_template (0:4) bit (36) aligned;	/* template for checking switches */
       93 dcl  cpu_mask bit (8) aligned;			/* for set_procs_required */
       94 
       95 /* Structures and based variables */
       96 
       97 dcl  1 tsdw (0:7) aligned like sdw;			/* for saving abs_seg SDW's */
       98 dcl  1 tsdw1 aligned like sdw;			/* automatic copy of SDW */
       99 dcl  1 tsdw2 aligned like sdw;			/* safe storage for dedicated memory sdw */
      100 dcl  1 pi like rsw_1_3.port_info based (pip) unal;	/* port info */
      101 dcl  1 pdata like scs$processor_data based (pdp) aligned;	/* single element of processor data */
      102 dcl  1 cdata based (cdp) like scs$controller_data aligned;	/* single element of controller data */
      103 dcl  inst (0:262143) bit (36) based (abs_seg_p) aligned;	/* decicated memory as a 256k array */
      104 
      105 /* Constants */
      106 
      107 dcl  (trouble_fault init (31),			/* trouble fault number */
      108      startup_fault init (0),				/* startup fault number */
      109      store_fault init (1),				/* store fault number */
      110      onc_fault init (11),				/* onc fault number */
      111      lockup_fault init (7))				/* lockup fault number */
      112 	fixed bin (5) static options (constant);
      113 dcl  IGNORE_CACHE_SIZE fixed bin int static options (constant) init (7);
      114 dcl  LETTERS char (8) int static options (constant) init ("ABCDEFGH");
      115 dcl  cell12 bit (36) aligned static options (constant) init ("000040000000"b3);
      116 dcl  (addr, bin, bit, bool, fixed, hbound, rel, stac, stacq, string, substr) builtin;
      117 
      118 	if scs$reconfig_lock ^= pds$processid | ^scs$processor_test_data.active then do; /* if not ISOLTS process */
      119 	     rcode = rcerr_isolts_not;		/* return error code */
      120 	     return;
      121 	end;
      122 	else rcode = 0;				/* otherwise return 0 */
      123 	reconfig_err = "0"b;			/* reset reconfiguration error flag */
      124 
      125 	iscu = scs$processor_test_data.scu_tag;		/* copy scu and cpu tags */
      126 	icpu = scs$processor_test_data.cpu_tag;
      127 	cdp = addr (scs$controller_data (iscu));	/* Get ptr to data for this SCU. */
      128 
      129 /* set up our read_switch template */
      130 
      131 	isolts_switch_template, isolts_switch_mask = "0"b;/* clear them first */
      132 	rswp = addr (isolts_switch_template (2));	/* set up rsw 2 first */
      133 	switchp = addr (isolts_switch_mask (2));
      134 	dps_rsw_2.fault_base = "0000010"b;		/* set up expected fault base */
      135 	switchp -> dps_rsw_2.fault_base = "1111111"b;	/* set up fault base mask */
      136 	dps_rsw_2.cpu_num = icpu;			/* set up expected cpu tag */
      137 	switchp -> dps_rsw_2.cpu_num = 7;		/* set up cpu tag mask */
      138 	if iscu < 4 then do;			/* pick rsw 1 if scu tags A, B, C, or D */
      139 	     i = 1;
      140 	     j = iscu;
      141 	     switchp -> dps8_rsw_2.interlace_info (iscu) = "1"b; /* check possible interlace onf dps8 cpu */
      142 	end;
      143 	else do;					/* pick rsw 3 if scu tags E, F, G, or H */
      144 	     i = 3;
      145 	     j = iscu - 4;
      146 	end;
      147 	rswp = addr (isolts_switch_template (i));	/* set up rsw 1 - 3 data */
      148 	pip = addr (rsw_1_3.port_info (j));		/* set template first */
      149 	pi.port_enable = "1"b;			/* port enable bit must be on */
      150 	rswp = addr (isolts_switch_mask (i));		/* set up mask for expected port info */
      151 	pip = addr (rsw_1_3.port_info (j));
      152 	pi.port_assignment = "7"b3;
      153 	pi.initialize_enable = "1"b;
      154 	pi.interlace_enable = "1"b;
      155 	rswp = addr (isolts_switch_mask (4));		/* set rsw 4 mask */
      156 	rsw_4.port_info (iscu).four = "1"b;
      157 	rsw_4.port_info (iscu).half = "1"b;
      158 	scs$processor_switch_data, scs$processor_switch_compare = "0"b; /* clear out switch data */
      159 	switchp = addr (scs$processor_switch_compare (1));/* set pointer */
      160 
      161 
      162 /* Find online CPU with mask set in this SCU */
      163 
      164 	found = "0"b;
      165 	do i = 1 to 4 while (^found);
      166 	     if cdata.eima_data (i).mask_available then	/* if this mask available */
      167 		if cdata.eima_data (i).mask_assigned then do; /* if this mask assigned */
      168 		     do j = 0 to hbound (scs$processor_data, 1) while (^found);
      169 			pdp = addr (scs$processor_data (j));
      170 			if pdata.controller_port = cdata.eima_data (i).mask_assignment then
      171 			     if pdata.online then do; /* if mask assigned to this cpu and online */
      172 				found = "1"b;
      173 				scs$processor_test_data.mask_cpu = j;
      174 			     end;
      175 		     end;
      176 		end;
      177 		else if cdata.type >= "0010"b then do;	/* mask not assigned to online cpu but avail. */
      178 		     do j = 0 to hbound (scs$processor_data, 1) while (^found);
      179 			pdp = addr (scs$processor_data (j));
      180 			if pdata.online then do;	/* if this cpu is online, he is candidate for our mask cpu */
      181 			     found = "1"b;
      182 			     scs$processor_test_data.mask_cpu = j; /* save tag and assign mask to this cpu */
      183 			     call scr_util$assign_mask ((iscu), (pdata.controller_port));
      184 			end;
      185 		     end;
      186 		end;
      187 	end;
      188 	if ^found then do;				/* didn't find mask */
      189 	     rcode = rcerr_isolts_no_mask;
      190 	     return;
      191 	end;
      192 
      193 /* Force our process to run on the active CPU */
      194 
      195 	cpu_mask = "0"b;
      196 	substr (cpu_mask, scs$processor_test_data.mask_cpu + 1, 1) = "1"b;
      197 	call set_procs_required (cpu_mask, tcode);
      198 	if tcode ^= 0 then do;
      199 	     rcode = rcerr_sprq_failed;
      200 	     return;
      201 	end;
      202 
      203 /* safe store original config data for this SCU (to be restored later) and remove core in this SCU from paging pool */
      204 
      205 	scs$cfg_data_save = scs$cfg_data (iscu);
      206 	base = cdata.base;				/* set base and size values */
      207 	size = cdata.size;
      208 	call pc_abs$remove_core (base, size, tcode);
      209 	if tcode ^= 0 then do;			/* some problem get out */
      210 	     rcode = tcode;
      211 	     return;
      212 	end;
      213 	scs$processor_test_data.scu_state = "01"b;	/* change scu state */
      214 	call scr_util$isolts_scu_p1;			/* reconfig SCU */
      215 
      216 
      217 /* Set scs$cpu_test_pattern to start interrupt level */
      218 
      219 	scs$cpu_test_pattern = scs$processor_start_pattern;
      220 
      221 /* Grab base 2k of all other non-bootload SCUs and pad with STA *, DIS pairs */
      222 
      223 	remember = 0;				/* clear remember array */
      224 	do i = 0 to hbound (scs$controller_data, 1);
      225 	     if scs$controller_data (i).online & i ^= iscu & i ^= scs$interrupt_controller then do; /* if online */
      226 		base = scs$controller_data (i).base;	/* and not bootload and not our SCU */
      227 		call pc_abs$remove_core (base, 2, tcode); /* remove the core */
      228 		if tcode = 0 then do;
      229 		     call pad_mem (base, 2);		/* if no problem pad mem with STA *,DIS pairs */
      230 		     remember (i) = base;		/* remember this scu */
      231 		     string (tsdw (i)) = string (tsdw1);
      232 		end;
      233 	     end;
      234 	end;
      235 
      236 /* pad lower 256k of selected SCU's memory with STA *, DIS pairs */
      237 
      238 	base = scs$controller_data (iscu).base;
      239 	if scs$controller_data (iscu).size < 256 then	/* protect against store faults */
      240 	     size = scs$controller_data (iscu).size;
      241 	else size = 256;
      242 	call pad_mem (base, size);
      243 	tsdw2 = tsdw1;				/* save sdw to our dedicated memory */
      244 
      245 /* Send connects to make all other processors suspend normal operation. */
      246 
      247 	call wire_proc$wire_me;			/* Take no interrupts or page faults here. */
      248 	call privileged_mode_ut$wire_and_mask (mask_temp, ptp);
      249 
      250 	do while (^stac (addr (scs$connect_lock), pds$processid));
      251 	end;					/* Lock up the connect lock. */
      252 
      253 	scs$processor_start_wait = scs$processor & ^prds$processor_pattern;
      254 						/* Stop all other processors. */
      255 	do i = 0 to 7;				/* Loop through all processors. */
      256 	     old_pdp = addr (scs$processor_data (i));	/* Get pointer to data for processor. */
      257 	     if (i ^= prds$processor_tag) & old_pdp -> pdata.online then
      258 		call privileged_mode_ut$cioc (old_pdp); /* Send connects to other processors. */
      259 	end;
      260 
      261 	do while (scs$processor_start_wait);		/* Wait for other processors to respond. */
      262 	end;
      263 
      264 /* Set up selected fault and interrupt vectors in system zero based memory */
      265 
      266 	fvp = addr (fault_vector$);			/* Get pointer to fault vector. */
      267 
      268 /* Set up STA *, DIS pair for CPU start interrupt. */
      269 	int_vec_save (1) = fv.ipair (scs$processor_start_int_no).scu;
      270 	int_vec_save (2) = fv.ipair (scs$processor_start_int_no).tra;
      271 	fv.ipair (scs$processor_start_int_no).scu = rel (addr (fv.ipair (scs$processor_start_int_no).scu))
      272 	     || "755200"b3;
      273 	fv.ipair (scs$processor_start_int_no).tra = rel (addr (fv.ipair (scs$processor_start_int_no).tra))
      274 	     || "616200"b3;
      275 
      276 /* Set up STA *, DIS pair for trouble fault. */
      277 	trouble_save (1) = fv.fpair (trouble_fault).scu;
      278 	trouble_save (2) = fv.fpair (trouble_fault).tra;
      279 	fv.fpair (trouble_fault).scu = rel (addr (fv.fpair (trouble_fault).scu)) || "755200"b3;
      280 	fv.fpair (trouble_fault).tra = rel (addr (fv.fpair (trouble_fault).tra)) || "616200"b3;
      281 
      282 /* Set up STA *, DIS pair for startup fault. */
      283 	startup_save (1) = fv.fpair (startup_fault).scu;
      284 	startup_save (2) = fv.fpair (startup_fault).tra;
      285 	fv.fpair (startup_fault).scu = rel (addr (fv.fpair (startup_fault).scu)) || "755200"b3;
      286 	fv.fpair (startup_fault).tra = rel (addr (fv.fpair (startup_fault).tra)) || "616200"b3;
      287 
      288 /* Set up STA *, DIS pair for onc fault. */
      289 	onc_save (1) = fv.fpair (onc_fault).scu;
      290 	onc_save (2) = fv.fpair (onc_fault).tra;
      291 	fv.fpair (onc_fault).scu = rel (addr (fv.fpair (onc_fault).scu)) || "755200"b3;
      292 	fv.fpair (onc_fault).tra = rel (addr (fv.fpair (onc_fault).tra)) || "616200"b3;
      293 
      294 /* Set up STA *, DIS pair for lockup fault */
      295 	lockup_save (1) = fv.fpair (lockup_fault).scu;
      296 	lockup_save (2) = fv.fpair (lockup_fault).tra;
      297 	fv.fpair (lockup_fault).scu = rel (addr (fv.fpair (lockup_fault).scu)) || "755200"b3;
      298 	fv.fpair (lockup_fault).tra = rel (addr (fv.fpair (lockup_fault).tra)) || "616200"b3;
      299 
      300 /* Send processor start interrupt, open processor's mask, and wait for it to respond. */
      301 
      302 	call int_test_cpu (tcode);
      303 
      304 /* delay until the STA * takes effect */
      305 
      306 	do i = 1 to 500 while (inst (0) = "000000755200"b3);
      307 	     call privileged_mode_ut$clear_cache;	/* Make sure cache gets updated */
      308 	end;
      309 
      310 /* if location 0 of our dedicated memory did not change then something is wrong */
      311 
      312 	if inst (0) = "000000755200"b3 then do;		/* failure */
      313 	     reconfig_err = "1"b;			/* set error flag */
      314 
      315 /* now check the bootload SCU to see if the switches were set wrong */
      316 
      317 	     if fv.ipair (scs$processor_start_int_no).scu ^= rel (addr (fv.ipair (scs$processor_start_int_no).scu))
      318 		|| "755200"b3 then do;
      319 		tcode = rcerr_isolts_wrong_scu;	/* answered on wrong scu */
      320 		switchp -> switch_w1.errtag = scs$interrupt_controller;
      321 	     end;
      322 	     else if fv.fpair (trouble_fault).scu ^= rel (addr (fv.fpair (trouble_fault).scu)) || "755200"b3 then do;
      323 		tcode = rcerr_isolts_wrong_scu_cell;	/* trouble fault on bootload scu */
      324 		switchp -> switch_w1.offset = rel (addr (fv.fpair (trouble_fault).scu));
      325 		switchp -> switch_w1.valid = "1"b;
      326 		switchp -> switch_w1.errtag = scs$interrupt_controller;
      327 	     end;
      328 	     else if fv.fpair (startup_fault).scu ^= rel (addr (fv.fpair (startup_fault).scu)) || "755200"b3 then do;
      329 		tcode = rcerr_isolts_wrong_scu_cell;	/* got startup fault on bootload scu */
      330 		switchp -> switch_w1.offset = rel (addr (fv.fpair (startup_fault).scu));
      331 		switchp -> switch_w1.valid = "1"b;
      332 		switchp -> switch_w1.errtag = scs$interrupt_controller;
      333 	     end;
      334 	     else if fv.fpair (onc_fault).scu ^= rel (addr (fv.fpair (onc_fault).scu)) || "755200"b3 then do;
      335 		tcode = rcerr_isolts_wrong_scu_cell;	/* onc fault on bootload scu */
      336 		switchp -> switch_w1.offset = rel (addr (fv.fpair (onc_fault).scu));
      337 		switchp -> switch_w1.valid = "1"b;
      338 		switchp -> switch_w1.errtag = scs$interrupt_controller;
      339 	     end;
      340 	     else if fv.fpair (lockup_fault).scu ^= rel (addr (fv.fpair (lockup_fault).scu)) || "755200"b3 then do;
      341 		tcode = rcerr_isolts_wrong_scu_cell;	/* lockup fault on bootload scu */
      342 		switchp -> switch_w1.offset = rel (addr (fv.fpair (lockup_fault).scu));
      343 		switchp -> switch_w1.valid = "1"b;
      344 		switchp -> switch_w1.errtag = scs$interrupt_controller;
      345 	     end;
      346 	end;
      347 
      348 /* restore system fault and int vectors */
      349 
      350 	fv.ipair (scs$processor_start_int_no).scu = int_vec_save (1);
      351 	fv.ipair (scs$processor_start_int_no).tra = int_vec_save (2);
      352 	fv.fpair (trouble_fault).scu = trouble_save (1);
      353 	fv.fpair (trouble_fault).tra = trouble_save (2);
      354 	fv.fpair (startup_fault).scu = startup_save (1);
      355 	fv.fpair (startup_fault).tra = startup_save (2);
      356 	fv.fpair (onc_fault).scu = onc_save (1);
      357 	fv.fpair (onc_fault).tra = onc_save (2);
      358 	fv.fpair (lockup_fault).scu = lockup_save (1);
      359 	fv.fpair (lockup_fault).tra = lockup_save (2);
      360 
      361 /* reset connect lock */
      362 
      363 	if ^stacq (scs$connect_lock, (36)"0"b, scs$connect_lock) then ; /* just reset lock, null then cluse */
      364 
      365 	call privileged_mode_ut$unwire_unmask (mask_temp, ptp);
      366 	call wire_proc$unwire_me;			/* Can unwire now. */
      367 
      368 /* if we had an error but did not find it above, check lower 2 k of all non-bootload scus */
      369 
      370 	if reconfig_err & tcode = 0 then do;		/* check lower 2k of other non-bootload scus */
      371 	     do i = 0 to 7 while (tcode = 0);		/* go through each scu if neccessary */
      372 		if remember (i) ^= 0 then do;		/* if we deallocated core from this SCU */
      373 		     call privileged_mode_ut$swap_sdw (abs_seg_p, addr (tsdw (i))); /* get correct sdw */
      374 		     if inst (0) ^= "000000755200"b3 then /* answered on wrong SCU */
      375 			tcode = rcerr_isolts_wrong_scu;
      376 
      377 		     else do k = 2 to 2046 by 2 while (tcode = 0);
      378 			if inst (k) ^= bit (bin (k, 18), 18) || "755200"b3 then do; /* found it */
      379 			     tcode = rcerr_isolts_wrong_scu_cell;
      380 			     switchp -> switch_w1.offset = bit (bin (k, 18), 18);
      381 			     switchp -> switch_w1.valid = "1"b;
      382 			end;
      383 		     end;
      384 		end;
      385 	     end;
      386 	     if tcode ^= 0 then			/* if we found error */
      387 		switchp -> switch_w1.errtag = i - 1;	/* set error tag */
      388 	end;
      389 
      390 /* Now give back the double pages we borrowed */
      391 
      392 	do i = 0 to hbound (scs$controller_data, 1);
      393 	     base = remember (i);
      394 	     if base > 0 then do;
      395 		call freecore (base);
      396 		call freecore (base + 1);
      397 	     end;
      398 	end;
      399 	call privileged_mode_ut$swap_sdw (abs_seg_p, addr (tsdw2)); /* restore sdw to our dedicated memory */
      400 
      401 /* if we had an error but did not find it above, check our dedicated memory */
      402 
      403 	if reconfig_err & tcode = 0 then
      404 	     call check_mem (0);			/* go check our dedicated memory */
      405 	if tcode ^= 0 then do;			/* if some problem above - get out */
      406 	     rcode = tcode;				/* copy error code */
      407 	     return;
      408 	end;
      409 
      410 /* Execute read switch program to determine if cpu is configured correctly */
      411 
      412 	inst (1) = "000001616200"b3;			/* set DIS instruction in loc 1 */
      413 
      414 	dps8 = "0"b;				/* reset dps8 indicator */
      415 	rswp = addr (scs$processor_switch_data (2));	/* preset rsw (2) ptr */
      416 	do i = 1 to 4 while (^dps8);			/* read each of 4 possible read switch types */
      417 	     do j = 1 to 2;				/* RSW first followed by STA */
      418 		if j = 1 then			/* if first iteration set up RSW */
      419 		     inst (0) = bit (bin (i, 18), 18) || "231200"b3; /* set RSW instruction */
      420 		else inst (0) = "000000755200"b3;	/* 2nd iteration, set STA * in loc 0 */
      421 		call int_test_cpu (tcode);		/* send interrupt */
      422 		do k = 1 to 500;			/* delay awhile */
      423 		end;
      424 		call privileged_mode_ut$clear_cache;	/* Make sure cache gets updated */
      425 		if j = 2 then			/* if second iteration */
      426 		     if inst (0) ^= "000000755200"b3 then do; /* if we didn't time out.... */
      427 			scs$processor_switch_data (i) = inst (0); /* copy rsw data out */
      428 			if i = 2 then		/* if rsw (2) complete, check cpu type */
      429 			     if dps8_rsw_2.cpu_type > 0 then /* If dps8 cpu */
      430 				dps8 = "1"b;	/* quit now */
      431 		     end;
      432 		     else do;			/* no response from cpu we are adding */
      433 			call check_mem (2);		/* go check if we answered on another int cell */
      434 			rcode = tcode;		/* copy error code */
      435 			scs$processor_switch_compare (2) = /* save RSW inst we were using */
      436 			     bit (bin (i, 18), 18) || "231200"b3;
      437 			return;			/* and let user report error */
      438 		     end;
      439 	     end;
      440 	end;
      441 	if dps8 then do;				/* set up for dps8 cpu */
      442 	     req_mem, scs$processor_test_data.req_mem = 128; /* reserve 128K for DPS8s */
      443 	     str_flt_operand = "400000"b3;		/* should take str flt at 128K */
      444 	     isolts_switch_template (1) = isolts_switch_template (1) | "002002002002"b3;
      445 	     isolts_switch_mask (1) = isolts_switch_mask (1) | "042042042042"b3;
      446 	     isolts_switch_template (3), isolts_switch_mask (3) = "0"b; /* No RSW (3) for dps8 */
      447 	end;
      448 	else do;					/* /* set up for L68 cpu */
      449 	     req_mem, scs$processor_test_data.req_mem = 64; /* reserve 64K for L68s */
      450 	     str_flt_operand = "200000"b3;		/* should take str flt at 64K */
      451 	     isolts_switch_template (1) = isolts_switch_template (1) | "001001001001"b3;
      452 	     isolts_switch_mask (1) = isolts_switch_mask (1) | "041041041041"b3;
      453 	     isolts_switch_template (3) = isolts_switch_template (3) | "001001001001"b3;
      454 	     isolts_switch_mask (3) = isolts_switch_mask (3) | "041041041041"b3;
      455 	end;
      456 
      457 /* Exclusive or the switches with our switch template and "and" the result with our mask */
      458 
      459 	scs$processor_switch_compare = (bool (scs$processor_switch_data, isolts_switch_template, "0110"b))
      460 	     & isolts_switch_mask;
      461 
      462 /* if any descrepencies exist return now */
      463 
      464 	found = "0"b;				/* reset error indicator */
      465 	do i = 1 to 4 while (^found);			/* go through each read switch data word */
      466 	     if scs$processor_switch_compare (i) ^= "0"b then do;
      467 		rcode = rcerr_isolts_bad_switches;
      468 		return;
      469 	     end;
      470 	     if i = 2 then				/* if rsw (2) */
      471 		if dps8 then			/* and a dps8 cpu... */
      472 		     found = "1"b;			/* that is it, exit */
      473 	end;
      474 	scs$processor_switch_compare = scs$processor_switch_data; /* return good switch readings to user */
      475 
      476 /* Check to see if a LDA instruction works correctly */
      477 
      478 	inst (2) = "0"b;				/* set cell 2 of our dedicated memory area to 0 */
      479 	inst (0) = "000002235200"b3;			/* set LDA 2 inst in loc 0 */
      480 	call int_test_cpu (tcode);			/* issue interrupt to test cpu */
      481 	do k = 1 to 500;				/* delay for awhile */
      482 	end;
      483 	inst (0) = "000000755200"b3;			/* set STA 0 in loc 0 */
      484 	call int_test_cpu (tcode);
      485 	do k = 1 to 500;				/* delay for awhile */
      486 	end;
      487 	call privileged_mode_ut$clear_cache;		/* Make sure cache gets updated */
      488 
      489 /* if the LDA worked correctly, location 0 should contain a value of 0 */
      490 
      491 	if inst (0) ^= "0"b then do;			/* LDA did not work correctly */
      492 	     rcode = rcerr_isolts_lda_fail;
      493 	     return;
      494 	end;
      495 
      496 /* Check to make sure that a LDA to an address >= <port_size> will generate a store fault */
      497 
      498 	inst (0) = "000002710000"b3;			/* must tra out of vector to avoid trb flt */
      499 	inst (2) = str_flt_operand || "235000"b3;	/* set lda to req_mem */
      500 	call int_test_cpu (tcode);			/* issue interrupt to test cpu */
      501 	do k = 1 to 500;				/* delay for awhile */
      502 	end;
      503 	call privileged_mode_ut$clear_cache;		/* Make sure cache gets updated */
      504 
      505 /* If the store fault vector equals zero then a store fault occurred */
      506 
      507 	if abs_seg_p -> fv.fpair (store_fault).scu = rel (addr (fv.fpair (store_fault).scu))
      508 	     || "755200"b3 then do;			/* failure */
      509 	     rcode = rcerr_isolts_no_str_flt;
      510 	     return;
      511 	end;
      512 
      513 /* Since we will be using a simulated IOM 0 terminate interrupt for ISOLTS testing
      514*   lets make sure that our test processor will answer it */
      515 
      516 	scs$cpu_test_pattern = cell12;		/* set test pattern for interrupt cell 12 */
      517 	call int_test_cpu (tcode);			/* execute simulated interrupt */
      518 	do k = 1 to 500;				/* delay for awhile */
      519 	end;
      520 	call privileged_mode_ut$clear_cache;		/* Make sure cache gets updated */
      521 	if abs_seg_p -> fv.ipair (12).scu = rel (addr (fv.ipair (12).scu))
      522 	     || "755200"b3 then do;			/* interrupt failed */
      523 	     rcode = rcerr_isolts_wrong_cell;
      524 	     switchp -> switch_w1.cell = 12;		/* set cell number */
      525 	     return;
      526 	end;
      527 
      528 /* Now we can return to the system all memory in our selected SCU above req_mem */
      529 
      530 	call scr_util$isolts_scu_p2;			/* re-enable original active ports */
      531 	call set_procs_required ("0"b, tcode);		/* reset proc required */
      532 
      533 	if scs$controller_data (iscu).size > req_mem then do; /* only give it back if it is there */
      534 	     base = scs$controller_data (iscu).base;	/* pick up system base and size of our SCU */
      535 	     size = scs$controller_data (iscu).size;
      536 	     do i = base + req_mem to size + base - 1;	/* give back each page */
      537 		call freecore (i);
      538 	     end;
      539 	end;
      540 
      541 /* Now set scu_state indicator to indicate that we only have lower memory now */
      542 
      543 	scs$processor_test_data.scu_state = "11"b;
      544 	scs$processor_data (icpu).cache_size = IGNORE_CACHE_SIZE; /* set so validate_cpu_card will ignore size */
      545 	return;					/* return to caller */
      546 
      547 
      548 
      549 /* int_test_cpu - entry to set up conditions to issue a SMIC instruction to the CPU being tested with ISOLTS */
      550 
      551 int_test_cpu: entry (rcode);
      552 
      553 	if scs$reconfig_lock ^= pds$processid | ^scs$processor_test_data.active then do; /* if not ISOLTS process */
      554 	     rcode = rcerr_isolts_not;		/* return error code */
      555 	     return;
      556 	end;
      557 	else rcode = 0;				/* otherwise return 0 */
      558 
      559 	if scs$processor_test_data.scu_state = "11"b then do; /* if running on lower memory */
      560 	     cpu_mask = "0"b;
      561 	     substr (cpu_mask, scs$processor_test_data.mask_cpu + 1, 1) = "1"b;
      562 	     call set_procs_required (cpu_mask, rcode);	/* run on CPU with mask set */
      563 	     if rcode ^= 0 then do;
      564 		rcode = rcerr_sprq_failed;
      565 		return;
      566 	     end;
      567 	end;
      568 
      569 	call scr_util$set_mask ((scs$processor_test_data.scu_tag), /* mask to system level first */
      570 	     (scs$processor_data (scs$processor_test_data.cpu_tag).controller_port),
      571 	     "000000000017000000000017"b3 & scs$cpu_test_mask);
      572 
      573 	call privileged_mode_ut$smic_port (scs$cpu_test_pattern, (scs$processor_test_data.scu_tag)); /* do the SMIC */
      574 
      575 	call scr_util$set_mask ((scs$processor_test_data.scu_tag), /* open interrupts to test cpu */
      576 	     (scs$processor_data (scs$processor_test_data.cpu_tag).controller_port), scs$cpu_test_mask);
      577 
      578 	if scs$processor_test_data.scu_state = "11"b then /* if running on lower memory */
      579 	     call set_procs_required ("0"b, (0));	/* reset proc required */
      580 
      581 	return;
      582 
      583 
      584 
      585 /* isolts_final - entry to remove SCU from ISOLTS test CPU depending on state of scs$processor_test_data.scu_state */
      586 
      587 isolts_final: entry;
      588 
      589 	i = fixed (scs$processor_test_data.scu_state, 2); /* convert scu_state to fixed bin */
      590 	if i = 0 then return;			/* if scu_state = "00"b - NOP */
      591 
      592 	iscu = scs$processor_test_data.scu_tag;		/* pick up scu_tag */
      593 	cdp = addr (scs$controller_data (iscu));
      594 
      595 	if i = 2 | i = 3 then do;			/* if either of these two states, we must restore SCU masks */
      596 	     cpu_mask = "0"b;
      597 	     substr (cpu_mask, scs$processor_test_data.mask_cpu + 1, 1) = "1"b;
      598 	     call set_procs_required (cpu_mask, tcode);
      599 	     if tcode ^= 0 then
      600 		call syserr$error_code (CRASH, tcode, "configure_test_cpu: Unable to run on CPU ^a",
      601 		     substr (LETTERS, scs$processor_test_data.mask_cpu + 1, 1));
      602 
      603 	     call scr_util$isolts_scu_p3;		/* go change masks */
      604 	     call set_procs_required ("0"b, (0));	/* reset cpu required */
      605 	end;
      606 
      607 	base = cdata.base;				/* pick up base address of controller */
      608 	if i = 1 | i = 2 then			/* if state is "01"b | "10"b */
      609 	     size = cdata.size;			/* restoe all of scus memory to system */
      610 	else size = scs$processor_test_data.req_mem;	/* if state is = "11"b then only req_mem needs to be restored */
      611 
      612 	do k = base to base + size - 1;		/* return memory to system */
      613 	     call freecore (k);
      614 	end;
      615 
      616 	scs$cpu_test_mask, scs$cpu_test_pattern = "0"b;	/* reset ISOLTS specific info */
      617 	scs$cfg_data_save = 0;
      618 
      619 	return;					/* return to caller */
      620 
      621 
      622 
      623 /* pad_mem - subroutine to pad up to 256k of desired memory with sta *, dis * instructions */
      624 
      625 pad_mem: proc (base, pages);
      626 
      627 dcl  (base, pages) fixed bin;
      628 
      629 	abs_seg_p = addr (isolts_abs_seg$);		/* get ptr to isolts_abs_seg */
      630 	string (tsdw1) = "0"b;			/* clear out  sdw */
      631 	tsdw1.df = "1"b;
      632 	tsdw1.read = "1"b;
      633 	tsdw1.write = "1"b;
      634 	tsdw1.unpaged = "1"b;
      635 	tsdw1.add = bit (bin (base * 1024, 24), 24);
      636 	tsdw1.bound = bit (bin (((pages * 1024) / 16) - 1, 14), 14); /* set bounds to number of pages */
      637 	call privileged_mode_ut$swap_sdw (abs_seg_p, addr (tsdw1)); /* swap the sdw */
      638 
      639 	do l = 0 to pages * 1024 - 2 by 2;		/* iterate through desired memory */
      640 	     inst (l) = bit (l) || "755200"b3;
      641 	     inst (l + 1) = bit (l) || "616200"b3;
      642 	end;
      643      end pad_mem;
      644 
      645 /* check_mem - subroutine to check if cpu answered on a different interrupt cell, than expected */
      646 
      647 check_mem: proc (si);
      648 
      649 dcl  si fixed bin;
      650 
      651 	found = "0"b;
      652 	do k = si to size - 2 by 2 while (^found);	/* check all of our memory */
      653 	     if inst (k) ^= bit (bin (k, 18)) || "755200"b3 then /* found error */
      654 		found = "1"b;
      655 	end;
      656 	if found then do;				/* if  we answered on wrong cell */
      657 	     tcode = rcerr_isolts_wrong_cell;
      658 	     switchp -> switch_w1.offset = bit (bin (k - 2, 18)); /* set offset */
      659 	     switchp -> switch_w1.valid = "1"b;
      660 	     switchp -> switch_w1.errtag = iscu;
      661 	end;
      662 	else tcode = rcerr_isolts_no_response;		/* if can't find no other reason */
      663 
      664      end check_mem;
      665 
      666 
  1     1 
  1     2 /* Begin include file ...... rcerr.incl.pl1 */
  1     3 /* These are the reconfiguration error codes. */
  1     4 /*	Created 4/5/76 by Noel I. Morris	*/
  1     5 /* Modified 5/25/78 by J. A. Bush to add ISOLTS  reconfig error codes */
  1     6 /* Modified 5/79 by BSG for port expander */
  1     7 
  1     8 
  1     9 /****^  HISTORY COMMENTS:
  1    10*  1) change(88-07-27,Farley), approve(88-10-05,MCR7968),
  1    11*     audit(88-10-10,Beattie), install(88-10-14,MR12.2-1166):
  1    12*     Added new rcerr_addscu_memoverlap error code.
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 dcl (rcerr_addcpu_no_response init (1),			/* no response from CPU */
  1    17      rcerr_addcpu_bad_switches init (2),		/* CPU config switches set improperly */
  1    18      rcerr_addcpu_trouble init (3),			/* trouble fault adding CPU */
  1    19      rcerr_addcpu_startup init (4),			/* startup fault adding CPU */
  1    20      rcerr_addcpu_lockup init (5),			/* lockup fault adding CPU */
  1    21      rcerr_addcpu_gcos init (6),			/* attempt to add processor in GCOS mode */
  1    22      rcerr_addcpu_amoff init (7),			/* attempt to add processor with assoc mem off */
  1    23      rcerr_addcpu_enable init (8)			/* controller port for CPU not enabled */
  1    24      ) fixed bin static options (constant);
  1    25 
  1    26 dcl (rcerr_delcpu_no_stop init (1),			/* CPU did not stop running */
  1    27      rcerr_delcpu_last init (2),			/* attempt to delete last CPU */
  1    28      rcerr_delcpu_no_good_blcpu init (3)		/* no suitable bootload CPU left */
  1    29      ) fixed bin static options (constant);
  1    30 
  1    31 dcl (rcerr_addscu_size init (1),			/* memory size discrepancy */
  1    32      rcerr_addscu_dup_mask init (2),			/* duplicate mask assignment */
  1    33      rcerr_addscu_no_mask init (3),			/* no mask assigned to CPU */
  1    34      rcerr_addscu_bad_mask init (4),			/* mask assigned to non-CPU port */
  1    35      rcerr_addscu_fault init (5),			/* fault trying to add controller */
  1    36      rcerr_addscu_switches init (6),			/* some active module has incorrect switches */
  1    37      rcerr_addscu_enable init (7),			/* some active module not enabled */
  1    38      rcerr_addscu_manual init (8),			/* 4MW SCU is in manual mode */
  1    39      rcerr_addscu_oldexpand init (9),			/* Adding 6000 SCU with port expander */
  1    40      rcerr_addscu_bigconfig init (10),			/* SCU has less memory than config cards say */
  1    41      rcerr_addscu_memoverlap init (11)			/* SCU has possible memory address overlap */
  1    42      ) fixed bin static options (constant);
  1    43 
  1    44 dcl (rcerr_delmain_nomem init (1),			/* not enough main memory left */
  1    45      rcerr_delmain_abs_wired init (2)			/* abs wired pages in memory */
  1    46      ) fixed bin static options (constant);
  1    47 
  1    48 dcl (rcerr_locked init (12),				/* database already locked */
  1    49      rcerr_online init (13),				/* device already online */
  1    50      rcerr_no_config init (14),			/* device not in configuration */
  1    51      rcerr_not_online init (15),			/* device not online */
  1    52      rcerr_range init (16),				/* request is out of range */
  1    53      rcerr_sprq_failed init (17)			/* could not set CPU required */
  1    54 
  1    55      ) fixed bin static options (constant);
  1    56 
  1    57 dcl (rcerr_isolts_locked init (1),			/* reconfig_lock locked to another process */
  1    58      rcerr_isolts_illegal_cpu init (2),			/* illegal cpu tag */
  1    59      rcerr_isolts_cpu_online init (3),			/* requested cpu is online */
  1    60      rcerr_isolts_no_config init (4),			/* requested cpu is not configured */
  1    61      rcerr_isolts_two_scu init (5),			/* Must have at least two SCUs to run ISOLTS */
  1    62      rcerr_isolts_illegal_scu init (6),			/* illegal scu tag */
  1    63      rcerr_isolts_bootload_scu init (7),		/* requested scu is the bootload memory */
  1    64      rcerr_isolts_scu_not init (8),			/* requested scu is not configured */
  1    65      rcerr_isolts_not init (9),			/* requesting process is not ISOLTS process */
  1    66      rcerr_isolts_wrong_cell init (10),			/* interrupt answered in correct scu but wrong cell */
  1    67      rcerr_isolts_wrong_scu init (11),			/* interrupt answered in wrong scu */
  1    68      rcerr_isolts_wrong_scu_cell init (12),		/* interrupt answered in wrong scu on wrong cell */
  1    69      rcerr_isolts_no_response init (13),		/* No response to a processor start interrupt */
  1    70      rcerr_isolts_bad_switches init (14),		/* read switch data is not in expected format */
  1    71      rcerr_isolts_lda_fail init (15),			/* A LDA 2 did not operate correctly */
  1    72      rcerr_isolts_no_str_flt init (16),			/* No store falt when a LDA 64k was executed */
  1    73      rcerr_isolts_no_mask init (17)			/* No mask set for test cpu */
  1    74      ) fixed bin static options (constant);
  1    75 
  1    76 dcl 1 switch_w1 aligned based,			/* template for switch word 1, when containing diagnostic info */
  1    77    (2 cell fixed bin (5),				/* interrupt cell being used */
  1    78     2 errtag fixed bin (5),				/* tag of scu in error */
  1    79     2 valid bit (1),				/* if on then offset field is valid */
  1    80     2 pad bit (5),
  1    81     2 offset bit (18)) unaligned;			/* offset of error if any */
  1    82 
  1    83 /* End of include file ...... rcerr.incl.pl1 */
  1    84 
      667 
      668 
      669 
      670 
  2     1 /* BEGIN INCLUDE FILE scs.incl.pl1 ... March 1983 */
  2     2 /* format: style4 */
  2     3 
  2     4 /* Information about system controllers */
  2     5 
  2     6 dcl  1 scs$controller_data (0:7) aligned ext,		/* per-controller info */
  2     7        2 size fixed bin (17) unaligned,			/* size (in 1024 word blocks) of this controller */
  2     8        2 base fixed bin (17) unaligned,			/* abs address (0 mod 1024) for base of this controller */
  2     9        2 eima_data (4) unaligned,			/* EIMA information for this controller */
  2    10          3 mask_available bit (1) unaligned,		/* ON if corresponding mask exists */
  2    11          3 mask_assigned bit (1) unaligned,		/* ON if mask assigned to a port */
  2    12          3 mbz bit (3) unaligned,
  2    13          3 mask_assignment fixed bin (3) unaligned,	/* port to which mask is assigned */
  2    14        2 info aligned,
  2    15          3 online bit (1) unaligned,			/* ON if controller is online */
  2    16          3 offline bit (1) unaligned,			/* ON if controller is offline but can be added */
  2    17          3 store_a_online bit (1) unaligned,		/* ON if store A is online */
  2    18          3 store_a1_online bit (1) unaligned,		/* ON if store A1 is online */
  2    19          3 store_b_online bit (1) unaligned,		/* ON if store B is online */
  2    20          3 store_b1_online bit (1) unaligned,		/* ON if store B1 is online */
  2    21          3 store_b_is_lower bit (1) unaligned,		/* ON if store B is lower */
  2    22          3 ext_interlaced bit (1) unaligned,		/* ON if this SCU is interlaced with other SCU */
  2    23          3 int_interlaced bit (1) unaligned,		/* ON if this SCU is internally interlaced */
  2    24          3 four_word bit (1) unaligned,			/* ON if external interlace is 4-word */
  2    25          3 cyclic_priority (7) bit (1) unaligned,		/* Cyclic priority for adjacent ports */
  2    26          3 type bit (4) unaligned,			/* Model number for this controller */
  2    27          3 abs_wired bit (1) unaligned,			/* ON if controller can have abs_wired pages */
  2    28          3 program bit (1) unaligned,			/* PROGRAM/MANUAL switch setting */
  2    29          3 mbz bit (13) unaligned,
  2    30        2 lower_store_size fixed bin (17) unaligned,	/* size (in 1024 word blocks) of lower store */
  2    31        2 upper_store_size fixed bin (17) unaligned;	/* size (in 1024 word blocks) of upper store */
  2    32 
  2    33 /* Information about CPUs */
  2    34 
  2    35 dcl  1 scs$processor_data (0:7) aligned ext,		/* information about CPUs in the system */
  2    36        (
  2    37        2 online bit (1),				/* "1"b if CPU is online */
  2    38        2 offline bit (1),				/* "1"b if CPU is offline but can be added */
  2    39        2 release_mask bit (1),			/* "1"b is this CPU is to give up its mask */
  2    40        2 accept_mask bit (1),				/* "1"b if this CPU is to grap mask in idle loop */
  2    41        2 delete_cpu bit (1),				/* "1"b if this CPU is to delete itself */
  2    42        2 interrupt_cpu bit (1),			/* "1"b if this CPU takes hardware interrupts */
  2    43        2 halted_cpu bit (1),				/* "1"b if this CPU has stopped itself (going to BOS) */
  2    44        2 cpu_type fixed bin (2) unsigned,		/*  0 => DPS or L68, 1 => DPS8 */
  2    45        2 mbz1 bit (6),
  2    46        2 cache_size fixed bin (3) unsigned,		/* 0 = No cache; 1 = L68 2K cache;
  2    47*						   2 = DPS8 8K cache; 3 = DPS8 VS&SC 8K cache;
  2    48*						   4 = DPS8 VS&SC 16K cache; 5 = DPS8 VS&SC 32K cache
  2    49*						   7 = ignore cache size (set by ISOLTS reconfig) */
  2    50        2 mbz2 bit (12),
  2    51        2 expanded_port bit (1),			/* "1"b = on expanded port */
  2    52        2 expander_port fixed bin (2) unsigned,		/* The actual expander port */
  2    53        2 controller_port fixed bin (3) unsigned
  2    54        ) unaligned;					/* Port on controller */
  2    55 
  2    56 dcl  1 scs$port_data (0:7) aligned external static,	/* Info about what is connected to each SCU port */
  2    57        2 assigned fixed bin (4) unsigned unaligned,	/* Type of device on this port		*/
  2    58        2 expander_port bit (1) unaligned,		/* "1"b => this port has a port expander */
  2    59        2 expanded_cpu (0:3) bit (1) unaligned,		/* "1"b => this expander port has a CPU attached */
  2    60        2 iom_number fixed bin (3) unsigned unaligned,	/* IOM number of IOM attached to this port */
  2    61        2 cpu_number (0:3) fixed bin (3) unsigned unaligned, /* CPU number of CPU(s) attached to this port */
  2    62 						/* cpu_number (0) is only one if expander_port is "0"b */
  2    63        2 pad bit (12) unaligned;
  2    64 
  2    65 dcl  1 scs$cow (0:7) aligned external,			/* Actual connect words */
  2    66        2 pad bit (36) aligned,			/* Expander COW's must be odd-word */
  2    67        2 cow,
  2    68          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    69          3 mbz1 bit (13) unaligned,
  2    70          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    71          3 mbz2 bit (2) unaligned,
  2    72          3 expanded_port bit (1) unaligned,		/* "1"b = on expanded port */
  2    73          3 expander_port fixed bin (3) unsigned unaligned,	/* Port on expander for cioc */
  2    74          3 mbz3 bit (3) unaligned,
  2    75          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    76 
  2    77 dcl  1 scs$cow_ptrs (0:7) external aligned,		/* Pointers to COW's */
  2    78        2 rel_cow_ptr bit (18) unal,			/* Relative pointer to COW */
  2    79        2 pad bit (12) unal,
  2    80        2 tag bit (6) unal;				/* Better be zero. */
  2    81 
  2    82 dcl  1 scs$reconfig_general_cow aligned external,		/* Used during reconfig ops. */
  2    83        2 pad bit (36) aligned,
  2    84        2 cow,					/* Connect operand word, in odd location. */
  2    85          3 sub_mask bit (8) unaligned,			/* Expander sub-port mask */
  2    86          3 mbz1 bit (13) unaligned,
  2    87          3 expander_command bit (3) unaligned,		/* Expander command. */
  2    88          3 mbz2 bit (9) unaligned,
  2    89          3 controller_port fixed bin (3) unaligned unsigned;/* controller port for this CPU */
  2    90 
  2    91 /* MASKS and PATTERNS */
  2    92 
  2    93 dcl  scs$sys_level bit (72) aligned ext;		/* mask used while handling I/O interrupts */
  2    94 dcl  scs$open_level bit (72) aligned ext;		/* mask used during normal operation */
  2    95 dcl  scs$processor_start_mask bit (72) aligned ext;	/* mask used when starting up a CPU */
  2    96 dcl  scs$cpu_test_mask bit (72) aligned ext;		/* mask used for ISOLTS CPU testing */
  2    97 dcl  scs$number_of_masks fixed bin ext;			/* number of masks (starting at sys_level) */
  2    98 dcl  scs$processor_start_pattern bit (36) aligned ext;	/* SMIC pattern used to send processor start interrupt */
  2    99 dcl  scs$cpu_test_pattern bit (36) aligned ext;		/* SMIC pattern used for ISOLTS processor testing */
  2   100 
  2   101 /* CAM and CACHE clear info */
  2   102 
  2   103 dcl  scs$cam_pair fixed bin (71) ext;			/* instructions XEDd when CAMing and clearing CACHE */
  2   104 dcl  scs$cam_wait bit (8) aligned ext;			/* Used when evicting pages from main memory */
  2   105 
  2   106 /* MASKING INSTRUCTIONS & POINTERS */
  2   107 
  2   108 dcl  scs$set_mask (0:7) bit (36) aligned ext;		/* instructions to set mask (STAQ or SMCM) */
  2   109 dcl  scs$read_mask (0:7) bit (36) aligned ext;		/* instructions to read mask (LDAQ or RMCM) */
  2   110 dcl  scs$mask_ptr (0:7) ptr unaligned ext;		/* pointers for real or simulated masks */
  2   111 
  2   112 /* MISCELLANEOUS */
  2   113 
  2   114 dcl  1 scs$processor_test_data aligned ext,		/* info used for cpu testing */
  2   115        (
  2   116        2 active bit (1),				/* = "1"b if cpu currently under test */
  2   117        2 scu_state bit (2),				/* state of scu being used for testing (see definition below) */
  2   118        2 pad1 bit (4),
  2   119        2 req_mem fixed bin (10),			/* dedicated memory required to test this cpu */
  2   120        2 cpu_tag fixed bin (5),			/* tag of cpu under test */
  2   121        2 scu_tag fixed bin (5),			/* tag of scu being used for cpu testing */
  2   122        2 mask_cpu fixed bin (5)
  2   123        ) unaligned;					/* tag of active cpu that has mask asigned to above scu */
  2   124 
  2   125 /* scu_state = "00"b => SCU defined by scs$processor_test_data.scu_tag not yet effected */
  2   126 /* scu_state = "01"b => all core removed from SCU, port mask not yet changed */
  2   127 /* scu_state = "10"b => all core removed from SCU, port mask changed */
  2   128 /* scu_state = "11"b => only 64k at base of SCU being used for testing, original port mask restored */
  2   129 
  2   130 dcl  scs$idle_aptep (0:7) ptr unaligned ext;		/* pointer to idle process APTE for each processor */
  2   131 
  2   132 dcl  scs$connect_lock bit (36) aligned ext;		/* lock for sending connects */
  2   133 dcl  scs$reconfig_lock bit (36) aligned ext;		/* Lock used during reconfiguration */
  2   134 dcl  scs$trouble_flags bit (8) aligned ext;		/* checkoff flags for sys_trouble stopping */
  2   135 dcl  scs$bos_restart_flags bit (8) aligned ext;		/* checkoff flags for restarting after sys_trouble */
  2   136 dcl  scs$nprocessors fixed bin ext;			/* number of runnung processors */
  2   137 dcl  scs$bos_processor_tag fixed bin (3) ext;		/* CPU tag of processor running BOS */
  2   138 dcl  scs$faults_initialized bit (1) aligned ext;		/* ON after faults have been enabled */
  2   139 dcl  scs$sys_trouble_pending bit (1) aligned ext;		/* sys_trouble event is pending in the system */
  2   140 dcl  scs$fast_cam_pending (0:7) bit (36) aligned ext;	/* checkoff cells for cam connect		*/
  2   141 dcl  scs$interrupt_controller fixed bin (3) ext;		/* port number of low order controller */
  2   142 dcl  scs$processor_start_int_no fixed bin (5) ext;	/* interrupt cell for starting a processor */
  2   143 dcl  scs$processor bit (8) aligned ext;			/* bits ON for online CPUs */
  2   144 dcl  scs$processor_start_wait bit (8) aligned ext;	/* checkoff flags for waiting for new processor */
  2   145 
  2   146 dcl  scs$trouble_dbrs (0:7) fixed bin (71);		/* DBR values at system crash time */
  2   147 
  2   148 dcl  scs$port_addressing_word (0:7) bit (3) aligned ext;	/* active module port number for each controller */
  2   149 
  2   150 dcl  scs$cfg_data (0:7) fixed bin (71) aligned ext;	/* RSCR-CFG data from each controller */
  2   151 
  2   152 dcl  scs$cfg_data_save fixed bin (71) aligned ext;	/* RSCR-CFG save area for ISOLTS CPU testing */
  2   153 
  2   154 dcl  scs$expanded_ports bit (1) unaligned dim (0:7) external;
  2   155 						/* Which ports have expanders */
  2   156 
  2   157 dcl  scs$processor_switch_data (0:4) bit (36) aligned ext;	/* raw data from RSW 0 thru 4 */
  2   158 dcl  scs$processor_switch_template (0:4) bit (36) aligned ext; /* expected data from RSW 0 thru 4 */
  2   159 dcl  scs$processor_switch_compare (0:4) bit (36) aligned ext; /* discrepancies from expected data */
  2   160 dcl  scs$processor_switch_mask (0:4) bit (36) aligned ext;	/* masks for comparing switch data */
  2   161 
  2   162 dcl  scs$processor_data_switch_value bit (36) aligned ext;	/* Correct value for CPU data switches */
  2   163 
  2   164 dcl  scs$controller_config_size (0:7) fixed bin (14) aligned ext;
  2   165 						/* Controller size on config card */
  2   166 
  2   167 dcl  scs$reconfig_locker_id char (32) aligned ext;	/* process group ID of process doing reconfiguration */
  2   168 
  2   169 dcl  scs$scas_page_table (0:31) bit (36) aligned external static;
  2   170 						/* PTWs for SCAS pages */
  2   171 
  2   172 dcl  scs$cycle_priority_template bit (7) aligned ext;	/* template for setting anti-hog switches	*/
  2   173 dcl  scs$set_cycle_switches bit (1) aligned ext;		/* flag to set ant-hog switches		*/
  2   174 
  2   175 
  2   176 dcl  (
  2   177      IOM_PORT init (1),
  2   178      CPU_PORT init (2),
  2   179      BULK_PORT init (3)
  2   180      ) fixed bin int static options (constant);		/* values for scs$port_data.assigned		*/
  2   181 
  2   182 
  2   183 /* END INCLUDE FILE scs.incl.pl1 */
      671 
      672 
  3     1 /* ***********************************************************
  3     2*   *                                                         *
  3     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  3     4*   *                                                         *
  3     5*   *********************************************************** */
  3     6 /* Begin include file ...... rsw.incl.pl1
  3     7*   Modified 3/26/77 by Noel I. Morris
  3     8*   Modified 9/03/80 by J. A. Bush for the DPS8/70M CPU
  3     9*   Modified 3/24/82 by J. A. Bush to allow the L68 CPU to address 4MW/port */
  3    10 
  3    11 dcl  rswp ptr;
  3    12 
  3    13 dcl 1 dps_rsw_2 aligned based (rswp),			/* rsw 2 template for DPS and L68 CPUs */
  3    14    (2 pad1 bit (4),
  3    15     2 cpu_type fixed bin (2) unsigned,			/* 0 = L68 or DPS, 1 = DPS8 */
  3    16     2 fault_base bit (7),				/* high order bits of fault vector */
  3    17     2 pad2 bit (6),
  3    18     2 dps_option bit (1),				/* "1"b => DPS CPU, "0"b => L68 CPU */
  3    19     2 pad3 bit (7),
  3    20     2 cache2 bit (1),				/* "1"b => 2k cache installed, "0"b => no cache */
  3    21     2 ext_gcos bit (1),				/* "1"b => ext gcos option installed */
  3    22     2 id bit (4),					/* CPU ID - "1110"b => L68 */
  3    23     2 cpu_num fixed bin (3) unsigned) unaligned;		/* processor number */
  3    24 
  3    25 dcl 1 dps8_rsw_2 aligned based (rswp),			/* rsw 2 template for DPS8 CPUs */
  3    26    (2 interlace_info (0:3) bit (1),			/* if interlace enabled; "0"b => 4-word, "1"b => 2-word */
  3    27     2 cpu_type fixed bin (2) unsigned,			/* 0 = L68 or DPS, 1 = DPS8 */
  3    28     2 fault_base bit (7),				/* high order bits of fault vector */
  3    29     2 id_prom bit (1),				/* "1"b => id_prom present */
  3    30     2 pad1 bit (5),
  3    31     2 dps_option bit (1),				/* always "1"b for DPS8 CPU */
  3    32     2 cache8 bit (1),				/* "1"b => 8k cache installed, "0"b => no cache */
  3    33     2 pad2 bit (2),
  3    34     2 multics_cpu bit (1),				/* always "1"b for Multics cpu */
  3    35     2 pad3 bit (5),
  3    36     2 cpu_speed bit (4),				/* cpu speed options */
  3    37     2 cpu_num fixed bin (3) unsigned) unaligned;		/* processor number */
  3    38 
  3    39 dcl 1 rsw_1_3 aligned based (rswp),			/* rsw 3 only valid on DPS and L68 CPUs */
  3    40    (2 port_info (0:3),				/* controller port information */
  3    41       3 port_assignment bit (3),			/* port address assignment */
  3    42       3 port_enable bit (1),				/* "1"b => port enabled */
  3    43       3 initialize_enable bit (1),			/* "1"b => system initialize enabled */
  3    44       3 interlace_enable bit (1),			/* "1"b => port is interlaced with neighbor */
  3    45       3 mem_size fixed bin (3) unsigned) unaligned;	/* encoded memory size on port */
  3    46 
  3    47 dcl 1 rsw_4 aligned based (rswp),			/* rsw 4 only valid on DPS and L68 CPUs */
  3    48    (2 pad1 bit (13),
  3    49     2 port_info (0:7),				/* additional controller port information */
  3    50       3 four bit (1),				/* "0"b => 4-word interlace - "1"b => 2-word interlace */
  3    51       3 half bit (1),				/* "1"b => only half of memory on controller in use */
  3    52     2 pad2 bit (7)) unaligned;
  3    53 
  3    54 dcl  dps_mem_size_table (0:7) fixed bin (24) static options (constant) init /* DPS and L68 memory sizes */
  3    55     (32768, 65536, 4194304, 131072, 524288, 1048576, 2097152, 262144);
  3    56 
  3    57 /* Note that the third array element above, is changed incompatibly in MR10.0.
  3    58*   In previous releases, this array element was used to decode a port size of
  3    59*   98304 (96K). With MR10.0 it is now possible to address 4MW per CPU port, by
  3    60*   installing  FCO # PHAF183 and using a group 10 patch plug, on L68 and DPS CPUs.
  3    61**/
  3    62 
  3    63 dcl  dps8_mem_size_table (0:7) fixed bin (24) static options (constant) init /* DPS8 memory sizes */
  3    64     (32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304);
  3    65 
  3    66 dcl  rsw_valid (0:1) fixed bin static options (constant) init (5, 3); /* # of rsw valid per cpu type */
  3    67 
  3    68 /* End of include file ...... rsw.incl.pl1 */
      673 
      674 
      675 
  4     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  4     2 
  4     3 dcl  sdwp ptr;
  4     4 
  4     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  4     6 
  4     7    (2 add bit (24),					/* main memory address of page table */
  4     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  4     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  4    10     2 df_no bit (2),				/* directed fault number */
  4    11 
  4    12     2 pad1 bit (1),
  4    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  4    14     2 access,					/* access bits */
  4    15       3 read bit (1),				/* read permission bit */
  4    16       3 execute bit (1),				/* execute permission bit */
  4    17       3 write bit (1),				/* write permission bit */
  4    18       3 privileged bit (1),				/* privileged bit */
  4    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  4    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  4    21     2 cache bit (1),				/* cache enable bit */
  4    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  4    23 
  4    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  4    25 
  4    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      676 
      677 
      678 
      679 
  5     1 
  5     2 /* BEGIN INCLUDE FILE ... fault_vector.incl.pl1 ... last modified February 1981 */
  5     3 
  5     4 dcl  fvp ptr;					/* pointer to the fault and interrupt vectors */
  5     5 
  5     6 dcl 1 fv based (fvp) aligned,				/* fault and interrupt vectors */
  5     7     2 ipair (0: 31),				/* interrupt pairs */
  5     8       3 scu bit (36),				/* SCU instruction */
  5     9       3 tra bit (36),				/* TRA instruction */
  5    10     2 fpair (0: 31),				/* fault pairs */
  5    11       3 scu bit (36),				/* SCU instruction */
  5    12       3 tra bit (36),				/* TRA instruction */
  5    13     2 i_tra_ptr (0: 31) ptr,				/* ITS pair for interrupt TRA instruction */
  5    14     2 i_scu_ptr (0: 31) ptr,				/* ITS pair for interrupt SCU instruction */
  5    15     2 f_tra_ptr (0: 31) ptr,				/* ITS pairs for fault TRA instruction */
  5    16     2 f_scu_ptr (0: 31) ptr;				/* ITS pairs for fault SCU instruction */
  5    17 
  5    18 /* Fault Types by fault number								*/
  5    19 	
  5    20    dcl (FAULT_NO_SDF  init (0),			/* Shutdown 				*/
  5    21         FAULT_NO_STR  init (1),			/* Store 				*/
  5    22         FAULT_NO_MME  init (2),			/* Master Mode Entry 1			*/
  5    23         FAULT_NO_F1   init (3),			/* Fault Tag 1				*/
  5    24         FAULT_NO_TRO  init (4),			/* Timer Runout				*/
  5    25         FAULT_NO_CMD  init (5),			/* Command				*/
  5    26         FAULT_NO_DRL  init (6),			/* Derail					*/
  5    27         FAULT_NO_LUF  init (7),			/* Lockup					*/
  5    28         FAULT_NO_CON  init (8),			/* Connect				*/
  5    29         FAULT_NO_PAR  init (9),			/* Parity					*/
  5    30         FAULT_NO_IPR  init (10),			/* Illegal Procedure			*/
  5    31         FAULT_NO_ONC  init (11),			/* Operation Not Complete			*/
  5    32         FAULT_NO_SUF  init (12),			/* Startup				*/
  5    33         FAULT_NO_OFL  init (13),			/* Overflow				*/
  5    34         FAULT_NO_DIV  init (14),			/* Divide Check				*/
  5    35         FAULT_NO_EXF  init (15),			/* Execute				*/
  5    36         FAULT_NO_DF0  init (16),			/* Directed Fault 0 (Segment Fault)		*/
  5    37         FAULT_NO_DF1  init (17),			/* Directed Fault 1 (Page Fault)		*/
  5    38         FAULT_NO_DF2  init (18),			/* Directed Fault 2				*/
  5    39         FAULT_NO_DF3  init (19),			/* Directed Fault 3				*/
  5    40         FAULT_NO_ACV  init (20),			/* Access Violation				*/
  5    41         FAULT_NO_MME2 init (21),			/* Master Mode Entry 2			*/
  5    42         FAULT_NO_MME3 init (22),			/* Master Mode Entry 3			*/
  5    43         FAULT_NO_MME4 init (23),			/* Master Mode Entry 4			*/
  5    44         FAULT_NO_F2   init (24),			/* Fault Tag 2 (Linkage Fault)		*/
  5    45         FAULT_NO_F3   init (25),			/* Fault Tag 3				*/
  5    46 						/* Fault Numbers 26-30 unassigned 		*/
  5    47         FAULT_NO_TRB  init (31)			/* Trouble				*/
  5    48 	
  5    49                                 ) fixed bin (17) int static options (constant);
  5    50 	
  5    51 
  5    52 
  5    53 /* END INCLUDE FILE ... fault_vector.incl.pl1 */
  5    54 
      680 
      681 
  6     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  6     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  6     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  6     4 
  6     5 /* This include file has an ALM version.  Keep 'em in sync! */
  6     6 
  6     7 dcl (
  6     8 
  6     9 /* The following constants define the message action codes.  This indicates
  6    10*how a message is to be handled.  */
  6    11 
  6    12      SYSERR_CRASH_SYSTEM	init (1),			
  6    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  6    14 
  6    15      SYSERR_TERMINATE_PROCESS	init (2),
  6    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  6    17 
  6    18      SYSERR_PRINT_WITH_ALARM	init (3),
  6    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  6    20 
  6    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  6    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  6    23 
  6    24      SYSERR_LOG_OR_PRINT	init (4),
  6    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  6    26 
  6    27      SYSERR_LOG_OR_DISCARD	init (5),
  6    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  6    29 
  6    30 
  6    31 /* The following constants are added to the normal severities to indicate
  6    32*different sorting classes of messages.  */
  6    33 
  6    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  6    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  6    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  6    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  6    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  6    39 	) fixed bin internal static options (constant);
  6    40 
  6    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      682 
      683 
      684 
      685 /* BEGIN MESSAGE DOCUMENTATION
      686*
      687*   Message:
      688*   configure_test_cpu: Unable to run on CPU X ERRORMESSAGE
      689*
      690*   S: $crash
      691*
      692*   T: When ISOLTS is terminating
      693*
      694*   M: The system is attempting to restore the ISOLTS CPU to service.
      695*   In attempting to reassign its interrupt mask, it was unable
      696*   to run on that CPU.  This indicates hardware or software malfunction.
      697*
      698*   A: $recover
      699*
      700*   END MESSAGE DOCUMENTATION */
      701 
      702      end configure_test_cpu;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  configure_test_cpu.pl1            >spec>install>1110>configure_test_cpu.pl1
667          1    10/18/88  1206.7  rcerr.incl.pl1                    >ldd>include>rcerr.incl.pl1
671          2    10/12/83  0943.5  scs.incl.pl1                      >ldd>include>scs.incl.pl1
673          3    06/10/82  1045.2  rsw.incl.pl1                      >ldd>include>rsw.incl.pl1
676          4    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
680          5    06/22/81  1815.3  fault_vector.incl.pl1             >ldd>include>fault_vector.incl.pl1
682          6    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000014 constant        fixed bin(17,0)          initial dcl 6-7 set ref 599*
IGNORE_CACHE_SIZE                      constant        fixed bin(17,0)          initial dcl 113 ref 544
LETTERS                         000000 constant        char(8)                  initial packed unaligned dcl 114 ref 599 599
abs_seg_p                       000132 automatic       pointer                  dcl 79 set ref 306 312 373* 374 378 399* 412 418 420
                                                                                  425 427 478 479 483 491 498 499 507 521 629* 637*
                                                                                  640 641 653
access                    1(15) 000214 automatic       structure                level 2 packed packed unaligned dcl 98
active                          000076 external static bit(1)                   level 2 packed packed unaligned dcl 2-114 ref 118
                                                                                  553
add                             000214 automatic       bit(24)                  level 2 packed packed unaligned dcl 98 set ref 635*
addr                                                   builtin function         dcl 116 ref 127 132 133 147 148 150 151 155 159 169
                                                                                  179 250 256 266 271 273 279 280 285 286 291 292
                                                                                  297 298 317 322 324 328 330 334 336 340 342 373
                                                                                  373 399 399 415 507 521 593 629 637 637
base                                   parameter       fixed bin(17,0)          dcl 627 in procedure "pad_mem" ref 625 635
base                      0(18)        based           fixed bin(17,0)          level 2 in structure "cdata" packed packed unaligned
                                                                                  dcl 102 in procedure "configure_test_cpu" ref 206
                                                                                  607
base                            000153 automatic       fixed bin(17,0)          dcl 86 in procedure "configure_test_cpu" set ref
                                                                                  206* 208* 226* 227* 229* 230 238* 242* 393* 394
                                                                                  395* 396 534* 536 536 607* 612 612
base                      0(18) 000064 external static fixed bin(17,0)          array level 2 in structure "scs$controller_data"
                                                                                  packed packed unaligned dcl 2-6 in procedure
                                                                                  "configure_test_cpu" set ref 226 238 534
bin                                                    builtin function         dcl 116 ref 378 380 418 435 635 636 653 658
bit                                                    builtin function         dcl 116 ref 378 380 418 435 635 636 640 641 653 658
bool                                                   builtin function         dcl 116 ref 459
bound                     1(01) 000214 automatic       bit(14)                  level 2 packed packed unaligned dcl 98 set ref 636*
cache_size                0(15) 000066 external static fixed bin(3,0)           array level 2 packed packed unsigned unaligned
                                                                                  dcl 2-35 set ref 544*
cdata                                  based           structure                level 1 dcl 102
cdp                             000104 automatic       pointer                  dcl 68 set ref 127* 166 166 170 177 206 207 593* 607
                                                                                  608
cell                                   based           fixed bin(5,0)           level 2 packed packed unaligned dcl 1-76 set ref
                                                                                  524*
cell12                                 constant        bit(36)                  initial dcl 115 ref 516
controller_port           0(33)        based           fixed bin(3,0)           level 2 in structure "pdata" packed packed unsigned
                                                                                  unaligned dcl 101 in procedure
                                                                                  "configure_test_cpu" ref 170 183
controller_port           0(33) 000066 external static fixed bin(3,0)           array level 2 in structure "scs$processor_data"
                                                                                  packed packed unsigned unaligned dcl 2-35
                                                                                  in procedure "configure_test_cpu" set ref 569 575
cpu_mask                        000172 automatic       bit(8)                   dcl 93 set ref 195* 196* 197* 560* 561* 562* 596*
                                                                                  597* 598*
cpu_num                   0(33)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 3-13
                                                                                  set ref 136* 137*
cpu_tag                   0(18) 000076 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 2-114 ref 126
                                                                                  569 575
cpu_type                  0(04)        based           fixed bin(2,0)           level 2 packed packed unsigned unaligned dcl 3-25
                                                                                  ref 428
df                        0(33) 000214 automatic       bit(1)                   level 2 packed packed unaligned dcl 98 set ref 631*
dps8                            000141 automatic       bit(1)                   packed unaligned dcl 83 set ref 414* 416 428* 441
                                                                                  470
dps8_rsw_2                             based           structure                level 1 dcl 3-25
dps_rsw_2                              based           structure                level 1 dcl 3-13
eima_data                 1            based           structure                array level 2 packed packed unaligned dcl 102
errtag                    0(06)        based           fixed bin(5,0)           level 2 packed packed unaligned dcl 1-76 set ref
                                                                                  320* 326* 332* 338* 344* 386* 660*
fault_base                0(06)        based           bit(7)                   level 2 packed packed unaligned dcl 3-13 set ref
                                                                                  134* 135*
fault_vector$                   000054 external static fixed bin(17,0)          dcl 59 set ref 266
fixed                                                  builtin function         dcl 116 ref 589
found                           000140 automatic       bit(1)                   packed unaligned dcl 82 set ref 164* 165 168 172*
                                                                                  178 181* 188 464* 465 470* 651* 652 653* 656
four                      0(13)        based           bit(1)                   array level 3 packed packed unaligned dcl 3-47 set
                                                                                  ref 156*
fpair                   100            based           structure                array level 2 dcl 5-6
freecore                        000046 constant        entry                    external dcl 53 ref 395 396 537 613
fv                                     based           structure                level 1 dcl 5-6
fvp                             000222 automatic       pointer                  dcl 5-4 set ref 266* 269 270 271 271 273 273 277 278
                                                                                  279 279 280 280 283 284 285 285 286 286 289 290
                                                                                  291 291 292 292 295 296 297 297 298 298 317 317
                                                                                  322 322 324 328 328 330 334 334 336 340 340 342
                                                                                  350 351 352 353 354 355 356 357 358 359 507 521
half                      0(14)        based           bit(1)                   array level 3 packed packed unaligned dcl 3-47 set
                                                                                  ref 157*
hbound                                                 builtin function         dcl 116 ref 168 178 224 392
i                               000126 automatic       fixed bin(17,0)          dcl 77 set ref 139* 144* 147 150 165* 166 166 170*
                                                                                  224* 225 225 225 226 230 231* 255* 256 257* 306*
                                                                                  371* 372 373 373* 386 392* 393* 416* 418 427 428
                                                                                  435* 465* 466 470* 536* 537* 589* 590 595 595 608
                                                                                  608
icpu                            000100 automatic       fixed bin(5,0)           dcl 66 set ref 126* 136 544
info                      2            based           structure                level 2 in structure "cdata" dcl 102 in procedure
                                                                                  "configure_test_cpu"
info                      2     000064 external static structure                array level 2 in structure "scs$controller_data"
                                                                                  dcl 2-6 in procedure "configure_test_cpu"
initialize_enable         0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 100 set ref 153*
inst                                   based           bit(36)                  array dcl 103 set ref 306 312 374 378 412* 418* 420*
                                                                                  425 427 478* 479* 483* 491 498* 499* 640* 641* 653
int_vec_save                    000114 automatic       bit(36)                  array dcl 72 set ref 269* 270* 350 351
interlace_enable          0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 100 set ref 154*
interlace_info                         based           bit(1)                   array level 2 packed packed unaligned dcl 3-25 set
                                                                                  ref 141*
ipair                                  based           structure                array level 2 dcl 5-6
iscu                            000101 automatic       fixed bin(5,0)           dcl 66 set ref 125* 127 138 140 141 145 156 157 183
                                                                                  205 225 238 239 239 533 534 535 592* 593 660
isolts_abs_seg$                 000052 external static fixed bin(17,0)          dcl 58 set ref 629
isolts_switch_mask              000160 automatic       bit(36)                  array dcl 91 set ref 131* 133 150 155 445* 445 446*
                                                                                  452* 452 454* 454 459
isolts_switch_template          000165 automatic       bit(36)                  array dcl 92 set ref 131* 132 147 444* 444 446* 451*
                                                                                  451 453* 453 459
j                               000127 automatic       fixed bin(17,0)          dcl 77 set ref 140* 145* 148 151 168* 169 173* 178*
                                                                                  179 182* 417* 418 425*
k                               000130 automatic       fixed bin(17,0)          dcl 77 set ref 377* 378 378 380* 422* 481* 485* 501*
                                                                                  518* 612* 613* 652* 653 653* 658
l                               000131 automatic       fixed bin(18,0)          dcl 78 set ref 639* 640 640 641 641*
lockup_fault                           constant        fixed bin(5,0)           initial dcl 107 ref 295 296 297 297 298 298 340 340
                                                                                  342 358 359
lockup_save                     000124 automatic       bit(36)                  array dcl 76 set ref 295* 296* 358 359
mask_assigned             1(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 102 ref
                                                                                  166
mask_assignment           1(05)        based           fixed bin(3,0)           array level 3 packed packed unaligned dcl 102 ref
                                                                                  170
mask_available            1            based           bit(1)                   array level 3 packed packed unaligned dcl 102 ref
                                                                                  166
mask_cpu                  0(30) 000076 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 2-114 set ref
                                                                                  173* 182* 196 561 597 599 599
mask_temp                       000112 automatic       fixed bin(71,0)          dcl 71 set ref 248* 365*
offset                    0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-76 set ref
                                                                                  324* 330* 336* 342* 380* 658*
old_pdp                         000106 automatic       pointer                  dcl 69 set ref 256* 257 257*
onc_fault                              constant        fixed bin(5,0)           initial dcl 107 ref 289 290 291 291 292 292 334 334
                                                                                  336 356 357
onc_save                        000122 automatic       bit(36)                  array dcl 75 set ref 289* 290* 356 357
online                                 based           bit(1)                   level 2 in structure "pdata" packed packed unaligned
                                                                                  dcl 101 in procedure "configure_test_cpu" ref 170
                                                                                  180 257
online                    2     000064 external static bit(1)                   array level 3 in structure "scs$controller_data"
                                                                                  packed packed unaligned dcl 2-6 in procedure
                                                                                  "configure_test_cpu" set ref 225
pages                                  parameter       fixed bin(17,0)          dcl 627 ref 625 636 639
pc_abs$remove_core              000044 constant        entry                    external dcl 52 ref 208 227
pdata                                  based           structure                level 1 dcl 101
pdp                             000102 automatic       pointer                  dcl 67 set ref 169* 170 170 179* 180 183
pds$processid                   000056 external static bit(36)                  dcl 60 ref 118 250 553
pi                                     based           structure                level 1 packed packed unaligned dcl 100
pip                             000134 automatic       pointer                  dcl 80 set ref 148* 149 151* 152 153 154
port_assignment                        based           bit(3)                   level 2 packed packed unaligned dcl 100 set ref 152*
port_enable               0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 100 set ref 149*
port_info                              based           structure                array level 2 in structure "rsw_1_3" packed packed
                                                                                  unaligned dcl 3-39 in procedure
                                                                                  "configure_test_cpu" set ref 148 151
port_info                 0(13)        based           structure                array level 2 in structure "rsw_4" packed packed
                                                                                  unaligned dcl 3-47 in procedure
                                                                                  "configure_test_cpu"
prds$processor_pattern          000062 external static bit(8)                   dcl 62 ref 253
prds$processor_tag              000060 external static fixed bin(3,0)           dcl 61 ref 257
privileged_mode_ut$cioc         000026 constant        entry                    external dcl 45 ref 257
privileged_mode_ut$clear_cache  000030 constant        entry                    external dcl 46 ref 307 424 487 503 520
privileged_mode_ut$smic_port    000024 constant        entry                    external dcl 44 ref 573
privileged_mode_ut$swap_sdw     000022 constant        entry                    external dcl 43 ref 373 399 637
privileged_mode_ut$unwire_unmask
                                000034 constant        entry                    external dcl 48 ref 365
privileged_mode_ut$wire_and_mask
                                000032 constant        entry                    external dcl 47 ref 248
ptp                             000110 automatic       pointer                  dcl 70 set ref 248* 365*
rcerr_isolts_bad_switches              constant        fixed bin(17,0)          initial dcl 1-57 ref 467
rcerr_isolts_lda_fail                  constant        fixed bin(17,0)          initial dcl 1-57 ref 492
rcerr_isolts_no_mask                   constant        fixed bin(17,0)          initial dcl 1-57 ref 189
rcerr_isolts_no_response               constant        fixed bin(17,0)          initial dcl 1-57 ref 662
rcerr_isolts_no_str_flt                constant        fixed bin(17,0)          initial dcl 1-57 ref 509
rcerr_isolts_not                       constant        fixed bin(17,0)          initial dcl 1-57 ref 119 554
rcerr_isolts_wrong_cell                constant        fixed bin(17,0)          initial dcl 1-57 ref 523 657
rcerr_isolts_wrong_scu                 constant        fixed bin(17,0)          initial dcl 1-57 ref 319 374
rcerr_isolts_wrong_scu_cell            constant        fixed bin(17,0)          initial dcl 1-57 ref 323 329 335 341 379
rcerr_sprq_failed                      constant        fixed bin(17,0)          initial dcl 1-48 ref 199 564
rcode                                  parameter       fixed bin(35,0)          dcl 34 set ref 32 119* 122* 189* 199* 210* 406* 434*
                                                                                  467* 492* 509* 523* 551 554* 557* 562* 563 564*
read                      1(15) 000214 automatic       bit(1)                   level 3 packed packed unaligned dcl 98 set ref 632*
reconfig_err                    000142 automatic       bit(1)                   packed unaligned dcl 84 set ref 123* 313* 370 403
rel                                                    builtin function         dcl 116 ref 271 273 279 280 285 286 291 292 297 298
                                                                                  317 322 324 328 330 334 336 340 342 507 521
remember                        000143 automatic       fixed bin(17,0)          array dcl 85 set ref 223* 230* 372 393
req_mem                         000155 automatic       fixed bin(17,0)          dcl 88 in procedure "configure_test_cpu" set ref
                                                                                  442* 449* 533 536
req_mem                   0(07) 000076 external static fixed bin(10,0)          level 2 in structure "scs$processor_test_data"
                                                                                  packed packed unaligned dcl 2-114 in procedure
                                                                                  "configure_test_cpu" set ref 442* 449* 610
rsw_1_3                                based           structure                level 1 dcl 3-39
rsw_4                                  based           structure                level 1 dcl 3-47
rswp                            000220 automatic       pointer                  dcl 3-11 set ref 132* 134 136 147* 148 150* 151 155*
                                                                                  156 157 415* 428
scr_util$assign_mask            000010 constant        entry                    external dcl 38 ref 183
scr_util$isolts_scu_p1          000012 constant        entry                    external dcl 39 ref 214
scr_util$isolts_scu_p2          000014 constant        entry                    external dcl 40 ref 530
scr_util$isolts_scu_p3          000016 constant        entry                    external dcl 41 ref 603
scr_util$set_mask               000020 constant        entry                    external dcl 42 ref 569 575
scs$cfg_data                    000114 external static fixed bin(71,0)          array dcl 2-150 ref 205
scs$cfg_data_save               000116 external static fixed bin(71,0)          dcl 2-152 set ref 205* 617*
scs$connect_lock                000100 external static bit(36)                  dcl 2-132 set ref 250 363 363
scs$controller_data             000064 external static structure                array level 1 dcl 2-6 set ref 127 224 392 593
scs$cpu_test_mask               000070 external static bit(72)                  dcl 2-96 set ref 569 575* 616*
scs$cpu_test_pattern            000074 external static bit(36)                  dcl 2-99 set ref 219* 516* 573* 616*
scs$interrupt_controller        000104 external static fixed bin(3,0)           dcl 2-141 ref 225 320 326 332 338 344
scs$processor                   000110 external static bit(8)                   dcl 2-143 ref 253
scs$processor_data              000066 external static structure                array level 1 dcl 2-35 set ref 168 169 178 179 256
scs$processor_start_int_no      000106 external static fixed bin(5,0)           dcl 2-142 ref 269 270 271 271 273 273 317 317 350
                                                                                  351
scs$processor_start_pattern     000072 external static bit(36)                  dcl 2-98 ref 219
scs$processor_start_wait        000112 external static bit(8)                   dcl 2-144 set ref 253* 261
scs$processor_switch_compare    000122 external static bit(36)                  array dcl 2-159 set ref 158* 159 435* 459* 466 474*
scs$processor_switch_data       000120 external static bit(36)                  array dcl 2-157 set ref 158* 415 427* 459 474
scs$processor_test_data         000076 external static structure                level 1 dcl 2-114
scs$reconfig_lock               000102 external static bit(36)                  dcl 2-133 ref 118 553
scu                     100            based           bit(36)                  array level 3 in structure "fv" dcl 5-6 in procedure
                                                                                  "configure_test_cpu" set ref 277 279* 279 283 285*
                                                                                  285 289 291* 291 295 297* 297 322 322 324 328 328
                                                                                  330 334 334 336 340 340 342 352* 354* 356* 358*
                                                                                  507 507
scu                                    based           bit(36)                  array level 3 in structure "fv" dcl 5-6 in procedure
                                                                                  "configure_test_cpu" set ref 269 271* 271 317 317
                                                                                  350* 521 521
scu_state                 0(01) 000076 external static bit(2)                   level 2 packed packed unaligned dcl 2-114 set ref
                                                                                  213* 543* 559 578 589
scu_tag                   0(24) 000076 external static fixed bin(5,0)           level 2 packed packed unaligned dcl 2-114 ref 125
                                                                                  569 573 575 592
sdw                                    based           structure                level 1 dcl 4-5
set_procs_required              000042 constant        entry                    external dcl 51 ref 197 531 562 578 598 604
si                                     parameter       fixed bin(17,0)          dcl 649 ref 647 652
size                                   based           fixed bin(17,0)          level 2 in structure "cdata" packed packed unaligned
                                                                                  dcl 102 in procedure "configure_test_cpu" ref 207
                                                                                  608
size                            000154 automatic       fixed bin(17,0)          dcl 87 in procedure "configure_test_cpu" set ref
                                                                                  207* 208* 239* 241* 242* 535* 536 608* 610* 612
                                                                                  652
size                            000064 external static fixed bin(17,0)          array level 2 in structure "scs$controller_data"
                                                                                  packed packed unaligned dcl 2-6 in procedure
                                                                                  "configure_test_cpu" set ref 239 239 533 535
stac                                                   builtin function         dcl 116 ref 250
stacq                                                  builtin function         dcl 116 ref 363
startup_fault                          constant        fixed bin(5,0)           initial dcl 107 ref 283 284 285 285 286 286 328 328
                                                                                  330 354 355
startup_save                    000120 automatic       bit(36)                  array dcl 74 set ref 283* 284* 354 355
store_fault                            constant        fixed bin(5,0)           initial dcl 107 ref 507 507
str_flt_operand                 000156 automatic       bit(18)                  packed unaligned dcl 89 set ref 443* 450* 499
string                                                 builtin function         dcl 116 set ref 231* 231 630*
substr                                                 builtin function         dcl 116 set ref 196* 561* 597* 599 599
switch_w1                              based           structure                level 1 dcl 1-76
switchp                         000136 automatic       pointer                  dcl 81 set ref 133* 135 137 141 159* 320 324 325 326
                                                                                  330 331 332 336 337 338 342 343 344 380 381 386
                                                                                  524 658 659 660
syserr$error_code               000050 constant        entry                    external dcl 54 ref 599
tcode                           000157 automatic       fixed bin(35,0)          dcl 90 set ref 197* 198 208* 209 210 227* 228 302*
                                                                                  319* 323* 329* 335* 341* 370 371 374* 377 379* 386
                                                                                  403 405 406 421* 434 480* 484* 500* 517* 531* 598*
                                                                                  599 599* 657* 662*
tra                       1            based           bit(36)                  array level 3 in structure "fv" dcl 5-6 in procedure
                                                                                  "configure_test_cpu" set ref 270 273* 273 351*
tra                     101            based           bit(36)                  array level 3 in structure "fv" dcl 5-6 in procedure
                                                                                  "configure_test_cpu" set ref 278 280* 280 284 286*
                                                                                  286 290 292* 292 296 298* 298 353* 355* 357* 359*
trouble_fault                          constant        fixed bin(5,0)           initial dcl 107 ref 277 278 279 279 280 280 322 322
                                                                                  324 352 353
trouble_save                    000116 automatic       bit(36)                  array dcl 73 set ref 277* 278* 352 353
tsdw                            000173 automatic       structure                array level 1 dcl 97 set ref 231* 373 373
tsdw1                           000214 automatic       structure                level 1 dcl 98 set ref 231 243 630* 637 637
tsdw2                           000216 automatic       structure                level 1 dcl 99 set ref 243* 399 399
type                      2(17)        based           bit(4)                   level 3 packed packed unaligned dcl 102 ref 177
unpaged                   1(19) 000214 automatic       bit(1)                   level 2 packed packed unaligned dcl 98 set ref 634*
valid                     0(12)        based           bit(1)                   level 2 packed packed unaligned dcl 1-76 set ref
                                                                                  325* 331* 337* 343* 381* 659*
wire_proc$unwire_me             000040 constant        entry                    external dcl 50 ref 366
wire_proc$wire_me               000036 constant        entry                    external dcl 49 ref 247
write                     1(17) 000214 automatic       bit(1)                   level 3 packed packed unaligned dcl 98 set ref 633*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 6-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 6-7
BULK_PORT                              internal static fixed bin(17,0)          initial dcl 2-176
CPU_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
FAULT_NO_ACV                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_CMD                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_CON                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DF0                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DF1                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DF2                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DF3                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DIV                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_DRL                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_EXF                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_F1                            internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_F2                            internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_F3                            internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_IPR                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_LUF                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_MME                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_MME2                          internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_MME3                          internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_MME4                          internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_OFL                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_ONC                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_PAR                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_SDF                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_STR                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_SUF                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_TRB                           internal static fixed bin(17,0)          initial dcl 5-20
FAULT_NO_TRO                           internal static fixed bin(17,0)          initial dcl 5-20
IOM_PORT                               internal static fixed bin(17,0)          initial dcl 2-176
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 6-7
LOG                                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 6-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 6-7
dps8_mem_size_table                    internal static fixed bin(24,0)          initial array dcl 3-63
dps_mem_size_table                     internal static fixed bin(24,0)          initial array dcl 3-54
rcerr_addcpu_amoff                     internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_bad_switches              internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_enable                    internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_gcos                      internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_lockup                    internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_no_response               internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_startup                   internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addcpu_trouble                   internal static fixed bin(17,0)          initial dcl 1-16
rcerr_addscu_bad_mask                  internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_bigconfig                 internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_dup_mask                  internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_enable                    internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_fault                     internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_manual                    internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_memoverlap                internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_no_mask                   internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_oldexpand                 internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_size                      internal static fixed bin(17,0)          initial dcl 1-31
rcerr_addscu_switches                  internal static fixed bin(17,0)          initial dcl 1-31
rcerr_delcpu_last                      internal static fixed bin(17,0)          initial dcl 1-26
rcerr_delcpu_no_good_blcpu             internal static fixed bin(17,0)          initial dcl 1-26
rcerr_delcpu_no_stop                   internal static fixed bin(17,0)          initial dcl 1-26
rcerr_delmain_abs_wired                internal static fixed bin(17,0)          initial dcl 1-44
rcerr_delmain_nomem                    internal static fixed bin(17,0)          initial dcl 1-44
rcerr_isolts_bootload_scu              internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_cpu_online                internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_illegal_cpu               internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_illegal_scu               internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_locked                    internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_no_config                 internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_scu_not                   internal static fixed bin(17,0)          initial dcl 1-57
rcerr_isolts_two_scu                   internal static fixed bin(17,0)          initial dcl 1-57
rcerr_locked                           internal static fixed bin(17,0)          initial dcl 1-48
rcerr_no_config                        internal static fixed bin(17,0)          initial dcl 1-48
rcerr_not_online                       internal static fixed bin(17,0)          initial dcl 1-48
rcerr_online                           internal static fixed bin(17,0)          initial dcl 1-48
rcerr_range                            internal static fixed bin(17,0)          initial dcl 1-48
rsw_valid                              internal static fixed bin(17,0)          initial array dcl 3-66
scs$bos_processor_tag                  external static fixed bin(3,0)           dcl 2-137
scs$bos_restart_flags                  external static bit(8)                   dcl 2-135
scs$cam_pair                           external static fixed bin(71,0)          dcl 2-103
scs$cam_wait                           external static bit(8)                   dcl 2-104
scs$controller_config_size             external static fixed bin(14,0)          array dcl 2-164
scs$cow                                external static structure                array level 1 dcl 2-65
scs$cow_ptrs                           external static structure                array level 1 dcl 2-77
scs$cycle_priority_template            external static bit(7)                   dcl 2-172
scs$expanded_ports                     external static bit(1)                   array packed unaligned dcl 2-154
scs$fast_cam_pending                   external static bit(36)                  array dcl 2-140
scs$faults_initialized                 external static bit(1)                   dcl 2-138
scs$idle_aptep                         external static pointer                  array packed unaligned dcl 2-130
scs$mask_ptr                           external static pointer                  array packed unaligned dcl 2-110
scs$nprocessors                        external static fixed bin(17,0)          dcl 2-136
scs$number_of_masks                    external static fixed bin(17,0)          dcl 2-97
scs$open_level                         external static bit(72)                  dcl 2-94
scs$port_addressing_word               external static bit(3)                   array dcl 2-148
scs$port_data                          external static structure                array level 1 dcl 2-56
scs$processor_data_switch_value        external static bit(36)                  dcl 2-162
scs$processor_start_mask               external static bit(72)                  dcl 2-95
scs$processor_switch_mask              external static bit(36)                  array dcl 2-160
scs$processor_switch_template          external static bit(36)                  array dcl 2-158
scs$read_mask                          external static bit(36)                  array dcl 2-109
scs$reconfig_general_cow               external static structure                level 1 dcl 2-82
scs$reconfig_locker_id                 external static char(32)                 dcl 2-167
scs$scas_page_table                    external static bit(36)                  array dcl 2-169
scs$set_cycle_switches                 external static bit(1)                   dcl 2-173
scs$set_mask                           external static bit(36)                  array dcl 2-108
scs$sys_level                          external static bit(72)                  dcl 2-93
scs$sys_trouble_pending                external static bit(1)                   dcl 2-139
scs$trouble_dbrs                       automatic       fixed bin(71,0)          array dcl 2-146
scs$trouble_flags                      external static bit(8)                   dcl 2-134
sdwa                                   based           structure                array level 1 dcl 4-24
sdwp                                   automatic       pointer                  dcl 4-3

NAMES DECLARED BY EXPLICIT CONTEXT.
check_mem                       003047 constant        entry                    internal dcl 647 ref 403 433
configure_test_cpu              000040 constant        entry                    external dcl 32
int_test_cpu                    002327 constant        entry                    external dcl 551 ref 302 421 480 484 500 517
isolts_final                    002522 constant        entry                    external dcl 587
pad_mem                         002731 constant        entry                    internal dcl 625 ref 229 242

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3656        4002    3153        3666
Length      4416    3153       124         377     502           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
configure_test_cpu                  254 external procedure  is an external procedure.  
pad_mem                                 internal procedure  shares stack frame of external procedure configure_test_cpu.  
check_mem                               internal procedure  shares stack frame of external procedure configure_test_cpu.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
configure_test_cpu       000100 icpu                        configure_test_cpu
                         000101 iscu                        configure_test_cpu
                         000102 pdp                         configure_test_cpu
                         000104 cdp                         configure_test_cpu
                         000106 old_pdp                     configure_test_cpu
                         000110 ptp                         configure_test_cpu
                         000112 mask_temp                   configure_test_cpu
                         000114 int_vec_save                configure_test_cpu
                         000116 trouble_save                configure_test_cpu
                         000120 startup_save                configure_test_cpu
                         000122 onc_save                    configure_test_cpu
                         000124 lockup_save                 configure_test_cpu
                         000126 i                           configure_test_cpu
                         000127 j                           configure_test_cpu
                         000130 k                           configure_test_cpu
                         000131 l                           configure_test_cpu
                         000132 abs_seg_p                   configure_test_cpu
                         000134 pip                         configure_test_cpu
                         000136 switchp                     configure_test_cpu
                         000140 found                       configure_test_cpu
                         000141 dps8                        configure_test_cpu
                         000142 reconfig_err                configure_test_cpu
                         000143 remember                    configure_test_cpu
                         000153 base                        configure_test_cpu
                         000154 size                        configure_test_cpu
                         000155 req_mem                     configure_test_cpu
                         000156 str_flt_operand             configure_test_cpu
                         000157 tcode                       configure_test_cpu
                         000160 isolts_switch_mask          configure_test_cpu
                         000165 isolts_switch_template      configure_test_cpu
                         000172 cpu_mask                    configure_test_cpu
                         000173 tsdw                        configure_test_cpu
                         000214 tsdw1                       configure_test_cpu
                         000216 tsdw2                       configure_test_cpu
                         000220 rswp                        configure_test_cpu
                         000222 fvp                         configure_test_cpu

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_in         call_ext_out_desc   call_ext_out        return_mac          stac_mac
ext_entry           trunc_fx2           divide_fx1          stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
freecore                      pc_abs$remove_core            privileged_mode_ut$cioc
privileged_mode_ut$clear_cache                              privileged_mode_ut$smic_port  privileged_mode_ut$swap_sdw
privileged_mode_ut$unwire_unmask                            privileged_mode_ut$wire_and_mask
scr_util$assign_mask          scr_util$isolts_scu_p1        scr_util$isolts_scu_p2        scr_util$isolts_scu_p3
scr_util$set_mask             set_procs_required            syserr$error_code             wire_proc$unwire_me
wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
fault_vector$                 isolts_abs_seg$               pds$processid                 prds$processor_pattern
prds$processor_tag            scs$cfg_data                  scs$cfg_data_save             scs$connect_lock
scs$controller_data           scs$cpu_test_mask             scs$cpu_test_pattern          scs$interrupt_controller
scs$processor                 scs$processor_data            scs$processor_start_int_no    scs$processor_start_pattern
scs$processor_start_wait      scs$processor_switch_compare  scs$processor_switch_data     scs$processor_test_data
scs$reconfig_lock




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000035       118 000045       119 000053       120 000056       122 000057       123 000061       125 000062
    126 000066       127 000072       131 000076       132 000116       133 000120       134 000122       135 000126
    136 000130       137 000134       138 000140       139 000143       140 000145       141 000147       142 000152
    144 000153       145 000155       147 000160       148 000163       149 000167       150 000172       151 000174
    152 000177       153 000202       154 000205       155 000210       156 000212       157 000217       158 000222
    159 000246       164 000250       165 000251       166 000261       168 000274       169 000303       170 000306
    172 000327       173 000331       175 000334       176 000336       177 000337       178 000344       179 000353
    180 000356       181 000361       182 000363       183 000365       185 000402       187 000404       188 000406
    189 000410       190 000413       195 000414       196 000415       197 000424       198 000434       199 000436
    200 000441       205 000442       206 000447       207 000453       208 000456       209 000470       210 000472
    211 000474       213 000475       214 000502       219 000506       223 000511       224 000522       225 000527
    226 000543       227 000550       228 000564       229 000566       230 000572       231 000575       234 000603
    238 000605       239 000615       241 000624       242 000626       243 000630       247 000632       248 000637
    250 000650       251 000657       253 000660       255 000664       256 000671       257 000674       259 000707
    261 000711       262 000715       266 000716       269 000720       270 000724       271 000726       273 000734
    277 000742       278 000745       279 000747       280 000755       283 000765       284 000770       285 000772
    286 001002       289 001012       290 001015       291 001017       292 001027       295 001037       296 001042
    297 001044       298 001054       302 001064       306 001075       307 001106       308 001113       312 001115
    313 001120       317 001122       319 001136       320 001140       321 001144       322 001145       323 001161
    324 001163       325 001167       326 001171       327 001175       328 001176       329 001210       330 001212
    331 001216       332 001220       333 001224       334 001225       335 001237       336 001241       337 001245
    338 001247       339 001253       340 001254       341 001266       342 001270       343 001274       344 001276
    350 001302       351 001307       352 001312       353 001315       354 001317       355 001322       356 001324
    357 001327       358 001331       359 001334       363 001336       365 001343       366 001353       370 001360
    371 001364       372 001373       373 001376       374 001413       377 001421       378 001431       379 001445
    380 001447       381 001455       383 001457       385 001462       386 001464       392 001473       393 001477
    394 001501       395 001502       396 001511       398 001523       399 001525       403 001540       405 001547
    406 001551       407 001553       412 001554       414 001557       415 001560       416 001564       417 001573
    418 001601       420 001614       421 001616       422 001624       423 001631       424 001633       425 001640
    427 001646       428 001651       431 001662       433 001663       434 001667       435 001672       437 001704
    439 001705       440 001707       441 001711       442 001713       443 001722       444 001724       445 001726
    446 001730       447 001732       449 001733       450 001742       451 001744       452 001746       453 001750
    454 001752       459 001754       464 001772       465 001773       466 002003       467 002006       468 002011
    470 002012       473 002020       474 002022       478 002036       479 002040       480 002042       481 002050
    482 002055       483 002057       484 002061       485 002067       486 002075       487 002077       491 002104
    492 002106       493 002111       498 002112       499 002114       500 002120       501 002126       502 002133
    503 002135       507 002142       509 002156       510 002161       516 002162       517 002165       518 002173
    519 002201       520 002203       521 002210       523 002222       524 002225       525 002230       530 002231
    531 002236       533 002251       534 002261       535 002267       536 002271       537 002303       538 002312
    543 002314       544 002317       545 002324       551 002325       553 002334       554 002343       555 002346
    557 002347       559 002351       560 002356       561 002357       562 002365       563 002375       564 002400
    565 002402       569 002403       573 002435       575 002452       578 002477       581 002520       587 002521
    589 002527       590 002534       592 002536       593 002542       595 002545       596 002554       597 002555
    598 002563       599 002573       603 002634       604 002641       607 002655       608 002661       610 002672
    612 002677       613 002707       614 002716       616 002720       617 002726       619 002730       625 002731
    629 002733       630 002736       631 002740       632 002742       633 002744       634 002746       635 002750
    636 002760       637 003003       639 003015       640 003027       641 003037       642 003043       643 003046
    647 003047       651 003051       652 003052       653 003065       655 003100       656 003103       657 003105
    658 003107       659 003120       660 003122       661 003126       662 003127       664 003131


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
