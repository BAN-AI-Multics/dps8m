	COMPILATION LISTING OF SEGMENT boundfault
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1024.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-10-30,Swenson), approve(88-07-04,MCR7930),
       15*     audit(88-07-11,Parisek), install(88-07-15,MR12.2-1057):
       16*     Modified to really fix maxlength increases.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 boundfault: proc (a_mcptr);
       21 
       22 /* Last modified BIM 84-02-06 to handle removal of setfaults for maxlength increases. */
       23 /* last modified by M. Grady on 08/17/79 to fix EIS decimal boundfault case  */
       24 /* last modified by R. Bratt on 09/17/76 for per-process boundfault metering */
       25 /* last modified by A. Bensoussan on 04/25/75 for the new storage system. */
       26 /* last modified by Greenberg on 10-14-74 for SST name table */
       27 /* last modified by Kobziar on 11-15-73 to respect only max_length */
       28 dcl  a_mcptr ptr;
       29 
       30 dcl (tsdwp, old_astep, new_astep, pastep, temptr, kstp, par_astep) ptr,
       31     (pw1, pw2, pageno, segno, csl, pts, old_pts, ptsi) fixed bin,
       32      offset fixed bin (18),
       33      code fixed bin (35),
       34     (time1, time2) fixed bin (71),
       35     (last, relp) bit (18) aligned,
       36     (lsw, par_ehs_status) bit (1) aligned,
       37      tsdw fixed bin (71),
       38      read_lock bit (36) aligned init ("0"b);
       39 
       40 dcl (error_table_$boundviol, error_table_$illegal_deactivation, error_table_$synch_seg_limit,
       41      error_table_$mylock, error_table_$root) ext fixed bin (35),
       42      kst_seg$ ext fixed bin,
       43      pds$bounds_faults fixed bin (35) ext,
       44      dseg$ (0 : 512) bit (72) aligned ext;
       45 
       46 dcl  page$enter_data ext entry (fixed bin, fixed bin),
       47      pc$move_page_table ext entry (ptr, ptr),
       48      syserr entry options (variable),
       49      usage_values ext entry (fixed bin, fixed bin (71)),
       50      sum$getbranch_root_my ext entry (ptr, bit (36) aligned, ptr, fixed bin (35)),
       51      lock$dir_unlock ext entry (ptr),
       52      lock$lock_ast entry,
       53      lock$unlock_ast entry,
       54      get_ptrs_$given_segno ext entry (fixed bin) returns (ptr),
       55      get_aste ext entry (fixed bin) returns (ptr),
       56      get_aste$synchronized entry (fixed bin) returns (ptr),
       57      put_aste ext entry (ptr),
       58      search_ast$hash_in ext entry (ptr),
       59      search_ast$hash_out ext entry (ptr),
       60      setfaults ext entry (ptr, bit (1) aligned);
       61 
       62 declare pmut$swap_sdw entry (pointer, pointer);
       63 declare sdw_util_$set_size entry (pointer, fixed binary (19));
       64 declare sdw_util_$get_address entry (pointer) returns (fixed bin (26));
       65 dcl  sst_seg$ external static;
       66 dcl  sst$pts (0 : 3) fixed bin external static;
       67 dcl  sst$cpu_bf_time fixed bin (71) external static;
       68 dcl  sst$total_bf_pf fixed bin (35) external static;
       69 dcl  sst$total_bf fixed bin (35) external static;
       70 dcl  sstp pointer;
       71 
       72 dcl (addr, baseptr, bin, divide, max, min, null, ptr, rel) builtin;
       73 
       74 
  1     1 /*  */
  1     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  1     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  1     4 /* Modified 07/07/76 by Morris for fault register data */
  1     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  1     6 /* Modified '82 to make values constant */
  1     7 
  1     8 /* words 0-15 pointer registers */
  1     9 
  1    10 dcl  mcp ptr;
  1    11 
  1    12 dcl 1 mc based (mcp) aligned,
  1    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  1    14    (2 regs,					/* registers */
  1    15       3 x (0:7) bit (18),				/* index registers */
  1    16       3 a bit (36),					/* accumulator */
  1    17       3 q bit (36),					/* q-register */
  1    18       3 e bit (8),					/* exponent */
  1    19       3 pad1 bit (28),
  1    20       3 t bit (27),					/* timer register */
  1    21       3 pad2 bit (6),
  1    22       3 ralr bit (3),				/* ring alarm register */
  1    23 
  1    24     2 scu (0:7) bit (36),
  1    25 
  1    26     2 mask bit (72),				/* mem controller mask at time of fault */
  1    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  1    28     2 errcode fixed bin (35),				/* fault handler's error code */
  1    29     2 fim_temp,
  1    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  1    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  1    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  1    33     2 fault_reg bit (36),				/* fault register */
  1    34     2 pad2 bit (1),
  1    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  1    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  1    37     2 fault_time bit (54),				/* time of fault */
  1    38 
  1    39     2 eis_info (0:7) bit (36)) unaligned;
  1    40 
  1    41 
  1    42 dcl (apx fixed bin init (0),
  1    43      abx fixed bin init (1),
  1    44      bpx fixed bin init (2),
  1    45      bbx fixed bin init (3),
  1    46      lpx fixed bin init (4),
  1    47      lbx fixed bin init (5),
  1    48      spx fixed bin init (6),
  1    49      sbx fixed bin init (7)) internal static options (constant);
  1    50 
  1    51 
  1    52 
  1    53 
  1    54 dcl  scup ptr;
  1    55 
  1    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  1    57 
  1    58 
  1    59 /*	WORD (0)		*/
  1    60 
  1    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  1    62       3 prr bit (3),				/* procedure ring register */
  1    63       3 psr bit (15),				/* procedure segment register */
  1    64       3 p bit (1),					/* procedure privileged bit */
  1    65 
  1    66     2 apu,					/* APPENDING UNIT STATUS */
  1    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  1    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  1    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  1    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  1    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  1    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  1    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  1    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  1    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  1    76       3 ptw bit (1),				/* Fetch of PTW */
  1    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  1    78       3 fap bit (1),				/* Fetch of final address paged */
  1    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  1    80       3 fabs bit (1),				/* Fetch of final address absolute */
  1    81 
  1    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  1    83 
  1    84 
  1    85 /*	WORD (1)		*/
  1    86 
  1    87     2 fd,						/* FAULT  DATA */
  1    88       3 iro bit (1),				/* illegal ring order */
  1    89       3 oeb bit (1),				/* out of execute bracket */
  1    90       3 e_off bit (1),				/* no execute */
  1    91       3 orb bit (1),				/* out of read bracket */
  1    92       3 r_off bit (1),				/* no read */
  1    93       3 owb bit (1),				/* out of write bracket */
  1    94       3 w_off bit (1),				/* no write */
  1    95       3 no_ga bit (1),				/* not a gate */
  1    96       3 ocb bit (1),				/* out of call bracket */
  1    97       3 ocall bit (1),				/* outward call */
  1    98       3 boc bit (1),				/* bad outward call */
  1    99       3 inret bit (1),				/* inward return */
  1   100       3 crt bit (1),				/* cross ring transfer */
  1   101       3 ralr bit (1),				/* ring alarm register */
  1   102       3 am_er bit (1),				/* associative memory fault */
  1   103       3 oosb bit (1),				/* out of segment bounds */
  1   104       3 paru bit (1),				/* processor parity upper */
  1   105       3 parl bit (1),				/* processor parity lower */
  1   106       3 onc_1 bit (1),				/* op not complete type 1 */
  1   107       3 onc_2 bit (1),				/* op not complete type 2 */
  1   108 
  1   109     2 port_stat,					/* PORT  STATUS */
  1   110       3 ial bit (4),				/* illegal action lines */
  1   111       3 iac bit (3),				/* illegal action channel */
  1   112       3 con_chan bit (3),				/* connect channel */
  1   113 
  1   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  1   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  1   116 
  1   117 
  1   118 /*	WORD (2)		*/
  1   119 
  1   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  1   121       3 trr bit (3),				/* temporary ring register */
  1   122       3 tsr bit (15),				/* temporary segment register */
  1   123 
  1   124     2 pad2 bit (9),
  1   125 
  1   126     2 cpu_no bit (3),				/* CPU number */
  1   127 
  1   128     2 delta bit (6),				/* tally modification DELTA */
  1   129 
  1   130 
  1   131 /*	WORD (3)		*/
  1   132 
  1   133     2 word3 bit (18),
  1   134 
  1   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  1   136       3 tsna,					/* Word 1 status */
  1   137         4 prn bit (3),				/* Word 1  PR  number */
  1   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  1   139       3 tsnb,					/* Word 2  status */
  1   140         4 prn bit (3),				/* Word 2  PR  number */
  1   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  1   142       3 tsnc,					/* Word 3  status */
  1   143         4 prn bit (3),				/* Word 3  PR  number */
  1   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  1   145 
  1   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  1   147 
  1   148 
  1   149 /* 	WORD (4)		*/
  1   150 
  1   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  1   152 
  1   153     2 ir,						/* INDICATOR  REGISTERS */
  1   154       3 zero bit (1),				/* zero indicator */
  1   155       3 neg bit (1),				/* negative indicator */
  1   156       3 carry bit (1),				/* carryry indicator */
  1   157       3 ovfl bit (1),				/* overflow indicator */
  1   158       3 eovf bit (1),				/* eponent overflow */
  1   159       3 eufl bit (1),				/* exponent underflow */
  1   160       3 oflm bit (1),				/* overflow mask */
  1   161       3 tro bit (1),				/* tally runout */
  1   162       3 par bit (1),				/* parity error */
  1   163       3 parm bit (1),				/* parity mask */
  1   164       3 bm bit (1),					/* ^bar mode */
  1   165       3 tru bit (1),				/* truncation mode */
  1   166       3 mif bit (1),				/* multi-word instruction mode */
  1   167       3 abs bit (1),				/* absolute mode */
  1   168       3 hex bit (1),				/* hexadecimal exponent mode */
  1   169       3 pad bit (3),
  1   170 
  1   171 
  1   172 /*	WORD (5)		*/
  1   173 
  1   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  1   175 
  1   176     2 cu,						/* CONTROL UNIT STATUS */
  1   177       3 rf bit (1),					/* on first cycle of repeat instr */
  1   178       3 rpt bit (1),				/* repeat instruction */
  1   179       3 rd bit (1),					/* repeat double instruction */
  1   180       3 rl bit (1),					/* repeat link instruciton */
  1   181       3 pot bit (1),				/* IT  modification */
  1   182       3 pon bit (1),				/* return type instruction */
  1   183       3 xde bit (1),				/* XDE from Even location */
  1   184       3 xdo bit (1),				/* XDE from Odd  location */
  1   185       3 poa bit (1),				/* operation preparation */
  1   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  1   187       3 its bit (1),				/* ITS modification */
  1   188       3 if bit (1),					/* fault occured during instruction fetch */
  1   189 
  1   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  1   191 
  1   192 
  1   193 /*	WORDS (6,7)	*/
  1   194 
  1   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  1   196 
  1   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  1   198 
  1   199 
  1   200 
  1   201 
  1   202 
  1   203 
  1   204 /*	ALTERNATE   SCU  DECLARATION		*/
  1   205 
  1   206 
  1   207 dcl 1 scux based (scup) aligned,
  1   208 
  1   209    (2 pad0 bit (36),
  1   210 
  1   211     2 fd,						/* GROUP II  FAULT DATA */
  1   212       3 isn bit (1),				/* illegal segment number */
  1   213       3 ioc bit (1),				/* illegal op  code  */
  1   214       3 ia_am bit (1),				/* illegal address - modifier */
  1   215       3 isp bit (1),				/* illegal slave  procedure */
  1   216       3 ipr bit (1),				/* illegal procedure */
  1   217       3 nea bit (1),				/* non existent address */
  1   218       3 oobb bit (1),				/* out of bounds */
  1   219       3 pad bit (29),
  1   220 
  1   221     2 pad2 bit (36),
  1   222 
  1   223     2 pad3a bit (18),
  1   224 
  1   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  1   226       3 prn bit (3),				/* PR  number */
  1   227       3 prv bit (1),				/* PR  valid bit */
  1   228 
  1   229     2 pad3b bit (6)) unaligned,
  1   230 
  1   231     2 pad45 (0:1) bit (36),
  1   232 
  1   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  1   234 
  1   235 
  1   236 
  1   237 /*  END INCLUDE FILE   mc.incl.pl1 */
       75 
  2     1 /* BEGIN INCLUDE FILE trace_types.incl.pl1  --  Last modified Jan 1982 */
  2     2 
  2     3      dcl	   (page_fault_type	      init (0),
  2     4 	   seg_fault_start	      init (2),
  2     5 	   seg_fault_end	      init (3),
  2     6 	   linkage_fault_start    init (4),
  2     7 	   linkage_fault_end      init (5),
  2     8 	   boundfault_start	      init (6),
  2     9 	   boundfault_end	      init (7),
  2    10 	   signaller_type	      init (8),
  2    11 	   restart_fault_type     init (9),
  2    12 	   reschedule_type	      init (10),
  2    13 	   marker_type	      init (11),
  2    14 	   interrupt_type	      init (12),
  2    15 	   extended_page_fault_type init (15)) fixed bin int static options (constant);
  2    16 
  2    17 
  2    18 /* END INCLUDE FILE trace_types.incl.pl1 */
       76 
  3     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
       77 
  4     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
       78 
  5     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
       79 
  6     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  6     2 
  6     3 /* Template for an AST entry. Length = 12 words. */
  6     4 
  6     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  6     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  6     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  6     8 
  6     9 dcl  astep ptr;
  6    10 
  6    11 dcl 1 aste based (astep) aligned,
  6    12 
  6    13     (2 fp bit (18),					/* forward  used list rel pointer */
  6    14     2 bp bit (18),					/* backward used list rel pointer */
  6    15 
  6    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  6    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  6    18 
  6    19     2 strp bit (18),				/* rel pointer to process trailer */
  6    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  6    21 
  6    22     2 uid bit (36),					/* segment unique id */
  6    23 
  6    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  6    25     2 pvtx fixed bin (8),				/* physical volume table index */
  6    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  6    27 
  6    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  6    29     2 init bit (1),					/* used bit - insure 1 lap */
  6    30     2 gtus bit (1),					/* global transparent usage switch */
  6    31     2 gtms bit (1),					/* global transparent modified switch */
  6    32     2 hc bit (1),					/* hard core segment */
  6    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  6    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  6    35     2 write_access_on bit (1),			/* any sdw allows write access */
  6    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  6    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  6    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  6    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  6    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  6    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  6    42     2 pad1 bit (2),					/* OO */
  6    43     2 dius bit (1),					/* dumper in use switch */
  6    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  6    45     2 dmpr_pad bit (1),
  6    46     2 ehs bit (1),					/* entry hold switch */
  6    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  6    48     2 dirsw bit (1),				/* directory switch */
  6    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  6    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  6    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  6    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  6    53 
  6    54     2 dtu bit (36),					/* date and time segment last used */
  6    55 
  6    56     2 dtm bit (36),					/* date and time segment last modified */
  6    57 
  6    58 
  6    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  6    60 
  6    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  6    62 
  6    63     2 csl bit (9),					/* current segment length in 1024 words units */
  6    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  6    65     2 fms bit (1),					/* file modified switch */
  6    66     2 npfs bit (1),					/* no page fault switch */
  6    67     2 gtpd bit (1),					/* global transparent paging device switch */
  6    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  6    69     2 per_process bit (1),				/* use master quota for this entry */
  6    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  6    71     2 pad2 bit (2),
  6    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  6    73     2 np bit (9),					/* number of pages in core */
  6    74 
  6    75 
  6    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  6    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  6    78     2 damaged bit (1),				/* PC declared segment unusable */
  6    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  6    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  6    81     2 pad3 bit (6),					/* OOOOOOOOO */
  6    82     2 ptsi bit (2),					/* page table size index */
  6    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  6    84 
  6    85 
  6    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  6    87 
  6    88 
  6    89 dcl 1 aste_part aligned based (astep),
  6    90 
  6    91     2 one bit (36) unaligned,				/* fp and bp */
  6    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  6    93     2 three bit (8) unaligned;			/* ptsi and marker */
  6    94 
  6    95 
  6    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  6    97     2 pad1 bit (8*36),
  6    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  6    99     2 pad2 bit (3*36);
  6   100 
  6   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
       80 
  7     1 /* Begin include file sstnt.incl.pl1   */
  7     2 
  7     3 /* Created 10/03/74 by Bernard Greenberg */
  7     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  7     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  7     6 
  7     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  7     8 
  7     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  7    10 
  7    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  7    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  7    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  7    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  7    15     2 pad1 (5) fixed bin,
  7    16 
  7    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  7    18      ast_name_offsets,				/* Starting index for names at each level */
  7    19      ast_offsets,					/* Starting rel addr of each AST region */
  7    20      pad2) (0 : 3) fixed bin,
  7    21 
  7    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  7    23 
  7    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  7    25 
  7    26 dcl  nm_astep ptr;					/* astep to be used */
  7    27 
  7    28 /* End include file sstnt.incl.pl1 */
       81 
       82 
       83 
       84 	call usage_values (pw1, time1);		/* meter bound fault time */
       85 	code = 0;
       86 	sstp = addr (sst_seg$);			/* get pointers */
       87 	kstp = addr (kst_seg$);
       88 	tsdwp = addr (tsdw);
       89 
       90 	scup = addr (a_mcptr -> mc.scu (0));
       91 	offset = bin (scup -> scu.ca, 18);		/* get the word offset causing the OOB */
       92 	pageno = divide (offset, 1024, 17, 0);		/* get the page number in which the word is */
       93 	if scup -> scu.apu.ptw2 then pageno = pageno + 1;	/* if decimal unit prepage, up page number */
       94 	segno = bin (bin (scup -> scu.tsr, 15), 17);	/* get the segment number of the faulting segment */
       95 	call page$enter_data (segno, boundfault_start);	/* place entry in the trace list */
       96 
       97 	lsw = "1"b;				/* set lock switch on */
       98 						/* return with entry pointer and dir locked */
       99 	call sum$getbranch_root_my (baseptr (segno), read_lock, ep, code);
      100 	if code ^= 0
      101 	then if code = error_table_$mylock		/* dir already locked */
      102 	     then lsw = "0"b;			/* turn off lock switch */
      103 	     else if code = error_table_$root		/* this is the root */
      104 	     then call syserr (2, "boundfault: on the root");
      105 	     else go to update;			/* for any other error */
      106 
      107 	code = 0;					/* May have had a mylock */
      108 	dp = ptr (ep, 0);				/* pointer to directory */
      109 	if sdw_util_$get_address (addr (dseg$ (segno))) = 0 then go to un; /* if segment not connected, return */
      110 
      111 	temp_entry_name = (addr (ep -> entry.primary_name) -> names.name);
      112 						/* Copy name into stack, as we cannot
      113*						   touch branch with AST locked */
      114 	call lock$lock_ast;				/* lock the AST */
      115 
      116 	old_astep = get_ptrs_$given_segno (segno);	/* get a pointer to the AST entry */
      117 	if old_astep = null then goto unlock_set;	/* If deactivated since boundfault, return and retake */
      118 
      119 	if pageno >= bin (old_astep -> aste.msl, 9)	/* check max length of segment */
      120 	then do;
      121 	     code = error_table_$boundviol;		/* return OOB error code */
      122 	     go to unlock_set;			/* unlock ASTE and DIR and return code */
      123 	end;
      124 
      125 	if old_astep -> aste.ehs then do;		/* check for the entry hold switch being ON */
      126 	     code = error_table_$illegal_deactivation;	/* return illegal deactivation */
      127 	     goto unlock_set;
      128 	end;
      129 
      130 	ptsi = bin (old_astep -> aste.ptsi, 2);		/* get the page table index for the old aste */
      131 	old_pts = sst$pts (ptsi);		/* get the page table size of the old AST */
      132      /**** Before we attempt to find a new, adequately sized page table, ensure
      133*           that the current page table size is not adequate.  If it is, then all
      134*           we need to do is update the SDW bounds field.  This discrepancy may
      135*           occur because, for efficiency reasons, we do not fault the SDW when
      136*           the maximum length of a segment is increased.  We just wait until
      137*           the next OOB occurs (this one).  Note that we've already ascertained
      138*           that the page being referenced is within the ASTE max length. */
      139 
      140               if pageno < old_pts then                          /* fits within current page table */
      141                     begin;
      142      declare  temp_sdw bit (72) aligned;
      143 
      144 	     temp_sdw = dseg$ (segno);
      145 
      146 	     call sdw_util_$set_size ( addr (temp_sdw), min (old_pts, bin (old_astep -> aste.msl, 9)) * 1024); /* fix the sdw */
      147 	     call pmut$swap_sdw (baseptr (segno), addr (temp_sdw));
      148 
      149 	     call lock$unlock_ast;
      150 	     code = 0;				/* make fim restart */
      151 	     go to un;
      152 	end;
      153 
      154 	/* ? */ if ptsi >= 3 then do;			/* already at largest allowed page table size */
      155 	     code = error_table_$boundviol;		/* return illegal bounds violation code */
      156 
      157 unlock_set:    call lock$unlock_ast;			/* Unlock the AST */
      158 	     go to un;				/* unlock the directory and update meters */
      159 	end;
      160 
      161 	call setfaults (old_astep, "0"b);		/* set faults for old AST entry */
      162 
      163 	csl = bin (old_astep -> aste.csl, 9);		/* get the current length of the segment (in pages) */
      164 	pts = max (pageno+1, csl);			/* get new page table size */
      165 
      166 	if pts <= old_pts then do;			/* Used to happen for prepage decimal ops */
      167 	     call lock$unlock_ast;
      168 	     code = error_table_$boundviol;
      169 	     go to un;
      170 	end;
      171 
      172 /* Entry hold the father to avoid deactivating him during get_aste */
      173 
      174 	par_astep = ptr (sstp, old_astep -> aste.par_astep);
      175 	par_ehs_status = par_astep -> aste.ehs;
      176 	par_astep -> aste.ehs = "1"b;
      177 
      178 
      179 	if ^old_astep -> aste.synchronized
      180 	then new_astep = get_aste (pts);		/* get a new AST entry */
      181 	else do;
      182 	     new_astep = get_aste$synchronized (pts);
      183 	     if new_astep = null () then do;
      184 		call lock$unlock_ast;
      185 		code = error_table_$synch_seg_limit;
      186 		goto un;
      187 	     end;
      188 	end;
      189 	
      190 
      191 /* Copy the synchronized switch. This will ensure that page control does the
      192*   right thing during the page table move, preventing writes before they
      193*   should be done. */
      194 
      195 	new_astep -> aste.synchronized = old_astep -> aste.synchronized;
      196 
      197 /* Restore father's ehs status */
      198 
      199 	if new_astep = par_astep then call syserr (1, "boundfault: activating into father ^p", new_astep);
      200 	par_astep -> aste.ehs = par_ehs_status;
      201 
      202 /* Now copy the page table from the old entry into the new */
      203 
      204 	call pc$move_page_table (old_astep, new_astep);	/* clean up the page table move */
      205 	nm_astep = new_astep;
      206 
      207 
      208 /* Now replace the old aste by the new one in the inferior list */
      209 
      210 	pastep = ptr (sstp, old_astep -> aste.par_astep); /* get a pointer to the parent to update the inferior list */
      211 
      212 	last = "0"b;
      213 	relp = pastep -> aste.infp;			/* get a pointer to the inferiror list */
      214 	do while (relp ^= rel (old_astep));		/* loop searching for the current entry */
      215 	     last = relp;				/* chain to next, save old */
      216 	     relp = ptr (sstp, relp) -> aste.infl;	/* get next entry in list */
      217 	end;
      218 	if last = "0"b then pastep -> aste.infp = rel (new_astep);
      219 	else ptr (sstp, last) -> aste.infl = rel (new_astep);
      220 
      221 
      222 
      223 /* Now update the parent pointers of all inferior entries ( if it's a directory) */
      224 
      225 	relp = old_astep -> aste.infp;
      226 	do while (relp);				/* loop until the end of the list */
      227 	     temptr = ptr (sstp, relp);
      228 	     temptr -> aste.par_astep = rel (new_astep);	/* put in new parent pointer */
      229 	     relp = temptr -> aste.infl;		/* get the next entry */
      230 	end;
      231 
      232 
      233 
      234 	call search_ast$hash_out (old_astep);
      235 	call search_ast$hash_in (new_astep);
      236 
      237 	call put_aste (old_astep);			/* Return old ASTE in the free pool */
      238 
  8     1 /* Begin include file make_sstnt_entry.incl.pl1 Bernard Greenberg 2/18/75 */
  8     2 /* Modified 84-01-08 BIM for sst$ versus sst. */
  8     3 
  8     4 	/* If the SST name table is enabled, fill in the name table slot. */
  8     5 
  8     6     begin; /* quick */
  8     7        declare sst$ast_track bit (1) aligned external static;
  8     8       
  8     9 	if sst$ast_track then do;
  8    10 
  8    11 	     sstnp = addr (sst_names_$);		/* Establish name seg addressability */
  8    12 	     ptsi_a= bin (nm_astep -> aste.ptsi, 2);	/* Pick up PT size index */
  8    13 	     sstnmx = sstnt.ast_name_offsets (ptsi_a)
  8    14 			+ divide (bin (rel (nm_astep), 18)
  8    15 				- sstnt.ast_offsets (ptsi_a),
  8    16 				sstnt.ast_sizes (ptsi_a), 17, 0);
  8    17 
  8    18 	     sstnp -> sstnt.names (sstnmx) = rtrim (temp_entry_name);
  8    19 
  8    20 	end;
  8    21       end;
  8    22 
  8    23        declare temp_entry_name char (32) aligned;
  8    24 
  8    25 /* End of include file make_sstnt_entry.incl.pl1 */
      239 
      240 
      241 	call lock$unlock_ast;
      242 un:	if lsw then call lock$dir_unlock (dp);		/* unlock the directory */
      243 
      244 update:
      245 	a_mcptr -> mc.errcode = code;
      246 	call usage_values (pw2, time2);		/* finish metering */
      247 	sst$cpu_bf_time = sst$cpu_bf_time + time2 - time1;
      248 	sst$total_bf_pf = sst$total_bf_pf + pw2 - pw1;
      249 	sst$total_bf = sst$total_bf + 1;
      250 	pds$bounds_faults = pds$bounds_faults + 1;
      251 	call page$enter_data (segno, boundfault_end);
      252 	return;
      253 
      254 ill_op_code: entry (a_mcptr);
      255 
      256 
      257 	a_mcptr -> mc.errcode = 1;
      258 	return;
      259 
      260 /* BEGIN MESSAGE DOCUMENTATION
      261*
      262*   Message:
      263*   boundfault: on the root
      264*
      265*   S:	$term
      266*
      267*   T:	$run
      268*
      269*   M:	A boundfault on the root directory has been encountered.
      270*   $err
      271*
      272*   A:	$inform
      273*
      274*
      275*   Message:
      276*   boundfault: activating into father XXX|YYY
      277*
      278*   S:	$crash
      279*
      280*   T:	$run
      281*
      282*   M:	While activating a segment,
      283*   the parent directory for the segment became deactivated.
      284*   $err
      285*
      286*   A:	$recover
      287*
      288*
      289*   END MESSAGE DOCUMENTATION */
      290 
      291      end boundfault;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0807.4  boundfault.pl1                    >spec>install>1112>boundfault.pl1
75           1    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
76           2    03/29/82  1006.9  trace_types.incl.pl1              >ldd>include>trace_types.incl.pl1
77           3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
78           4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
79           5    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
80           6    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
81           7    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
239          8    07/11/84  0937.3  make_sstnt_entry.incl.pl1         >ldd>include>make_sstnt_entry.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_mcptr                                parameter       pointer                  dcl 28 ref 20 90 244 254 257
addr                                                   builtin function         dcl 72 ref 86 87 88 90 109 109 111 146 146 147 147
                                                                                  8-11
apu                       0(19)        based           structure                level 2 packed packed unaligned dcl 1-56
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 7-11 ref 8-13
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 7-11 ref 8-13
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 7-11 ref 8-13
aste                                   based           structure                level 1 dcl 6-11
baseptr                                                builtin function         dcl 72 ref 99 99 147 147
bin                                                    builtin function         dcl 72 ref 91 94 94 119 130 146 163 8-12 8-13
boundfault_end                  000000 constant        fixed bin(17,0)          initial dcl 2-3 set ref 251*
boundfault_start                000001 constant        fixed bin(17,0)          initial dcl 2-3 set ref 95*
ca                        5            based           bit(18)                  level 2 packed packed unaligned dcl 1-56 ref 91
code                            000127 automatic       fixed bin(35,0)          dcl 30 set ref 85* 99* 100 100 103 107* 121* 126*
                                                                                  150* 155* 168* 185* 244
csl                      12            based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 6-11 in procedure "boundfault" ref 163
csl                             000122 automatic       fixed bin(17,0)          dcl 30 in procedure "boundfault" set ref 163* 164
divide                                                 builtin function         dcl 72 ref 92 8-13
dp                              000150 automatic       pointer                  dcl 3-9 set ref 108* 242*
dseg$                           000026 external static bit(72)                  array dcl 40 set ref 109 109 144
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 6-11 set ref 125
                                                                                  175 176* 200*
entry                                  based           structure                level 1 dcl 4-8
ep                              000152 automatic       pointer                  dcl 4-6 set ref 99* 108 111
errcode                  43            based           fixed bin(35,0)          level 2 packed packed unaligned dcl 1-12 set ref
                                                                                  244* 257*
error_table_$boundviol          000010 external static fixed bin(35,0)          dcl 40 ref 121 155 168
error_table_$illegal_deactivation
                                000012 external static fixed bin(35,0)          dcl 40 ref 126
error_table_$mylock             000016 external static fixed bin(35,0)          dcl 40 ref 100
error_table_$root               000020 external static fixed bin(35,0)          dcl 40 ref 103
error_table_$synch_seg_limit    000014 external static fixed bin(35,0)          dcl 40 ref 185
get_aste                        000052 constant        entry                    external dcl 46 ref 179
get_aste$synchronized           000054 constant        entry                    external dcl 46 ref 182
get_ptrs_$given_segno           000050 constant        entry                    external dcl 46 ref 116
infl                      1            based           bit(18)                  level 2 packed packed unaligned dcl 6-11 set ref 216
                                                                                  219* 229
infp                      1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-11 set ref 213
                                                                                  218* 225
kst_seg$                        000022 external static fixed bin(17,0)          dcl 40 set ref 87
kstp                            000112 automatic       pointer                  dcl 30 set ref 87*
last                            000134 automatic       bit(18)                  dcl 30 set ref 212* 215* 218 219
lock$dir_unlock                 000042 constant        entry                    external dcl 46 ref 242
lock$lock_ast                   000044 constant        entry                    external dcl 46 ref 114
lock$unlock_ast                 000046 constant        entry                    external dcl 46 ref 149 157 167 184 241
lsw                             000136 automatic       bit(1)                   dcl 30 set ref 97* 100* 242
max                                                    builtin function         dcl 72 ref 164
mc                                     based           structure                level 1 dcl 1-12
min                                                    builtin function         dcl 72 ref 146
msl                       4            based           bit(9)                   level 2 packed packed unaligned dcl 6-11 ref 119 146
name                      4            based           char(32)                 level 2 dcl 5-7 ref 111
names                    30            based           varying char(32)         array level 2 in structure "sstnt" dcl 7-11
                                                                                  in procedure "boundfault" set ref 8-18*
names                                  based           structure                level 1 dcl 5-7 in procedure "boundfault"
new_astep                       000104 automatic       pointer                  dcl 30 set ref 179* 182* 183 195 199 199* 204* 205
                                                                                  218 219 228 235*
nm_astep                        000160 automatic       pointer                  dcl 7-26 set ref 205* 8-12 8-13
null                                                   builtin function         dcl 72 ref 117 183
offset                          000126 automatic       fixed bin(18,0)          dcl 30 set ref 91* 92
old_astep                       000102 automatic       pointer                  dcl 30 set ref 116* 117 119 125 130 146 161* 163 174
                                                                                  179 195 204* 210 214 225 234* 237*
old_pts                         000124 automatic       fixed bin(17,0)          dcl 30 set ref 131* 140 146 166
page$enter_data                 000030 constant        entry                    external dcl 46 ref 95 251
pageno                          000120 automatic       fixed bin(17,0)          dcl 30 set ref 92* 93* 93 119 140 164
par_astep                       000114 automatic       pointer                  dcl 30 in procedure "boundfault" set ref 174* 175
                                                                                  176 199 200
par_astep                 2(18)        based           bit(18)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 6-11 in procedure "boundfault" set ref 174 210
                                                                                  228*
par_ehs_status                  000137 automatic       bit(1)                   dcl 30 set ref 175* 200
pastep                          000106 automatic       pointer                  dcl 30 set ref 210* 213 218
pc$move_page_table              000032 constant        entry                    external dcl 46 ref 204
pds$bounds_faults               000024 external static fixed bin(35,0)          dcl 40 set ref 250* 250
pmut$swap_sdw                   000066 constant        entry                    external dcl 62 ref 147
primary_name             10            based           bit(504)                 level 2 packed packed unaligned dcl 4-8 set ref 111
ptr                                                    builtin function         dcl 72 ref 108 174 210 216 219 227
pts                             000123 automatic       fixed bin(17,0)          dcl 30 set ref 164* 166 179* 182*
ptsi                     13(28)        based           bit(2)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 6-11 in procedure "boundfault" ref 130 8-12
ptsi                            000125 automatic       fixed bin(17,0)          dcl 30 in procedure "boundfault" set ref 130* 131
                                                                                  154
ptsi_a                          000157 automatic       fixed bin(17,0)          dcl 7-24 set ref 8-12* 8-13 8-13 8-13
ptw2                      0(29)        based           bit(1)                   level 3 packed packed unaligned dcl 1-56 ref 93
put_aste                        000056 constant        entry                    external dcl 46 ref 237
pw1                             000116 automatic       fixed bin(17,0)          dcl 30 set ref 84* 248
pw2                             000117 automatic       fixed bin(17,0)          dcl 30 set ref 246* 248
read_lock                       000142 automatic       bit(36)                  initial dcl 30 set ref 30* 99*
rel                                                    builtin function         dcl 72 ref 214 218 219 228 8-13
relp                            000135 automatic       bit(18)                  dcl 30 set ref 213* 214 215 216* 216 225* 226 227
                                                                                  229*
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 1-12 in procedure "boundfault" set
                                                                                  ref 90
scu                                    based           structure                level 1 dcl 1-56 in procedure "boundfault"
scup                            000146 automatic       pointer                  dcl 1-54 set ref 90* 91 93 94
sdw_util_$get_address           000072 constant        entry                    external dcl 64 ref 109
sdw_util_$set_size              000070 constant        entry                    external dcl 63 ref 146
search_ast$hash_in              000060 constant        entry                    external dcl 46 ref 235
search_ast$hash_out             000062 constant        entry                    external dcl 46 ref 234
segno                           000121 automatic       fixed bin(17,0)          dcl 30 set ref 94* 95* 99 99 109 109 116* 144 147
                                                                                  147 251*
setfaults                       000064 constant        entry                    external dcl 46 ref 161
sst$ast_track                   000110 external static bit(1)                   dcl 8-7 ref 8-9
sst$cpu_bf_time                 000100 external static fixed bin(71,0)          dcl 67 set ref 247* 247
sst$pts                         000076 external static fixed bin(17,0)          array dcl 66 ref 131
sst$total_bf                    000104 external static fixed bin(35,0)          dcl 69 set ref 249* 249
sst$total_bf_pf                 000102 external static fixed bin(35,0)          dcl 68 set ref 248* 248
sst_names_$                     000106 external static fixed bin(17,0)          dcl 7-7 set ref 8-11
sst_seg$                        000074 external static fixed bin(17,0)          dcl 65 set ref 86
sstnmx                          000156 automatic       fixed bin(17,0)          dcl 7-24 set ref 8-13* 8-18
sstnp                           000154 automatic       pointer                  dcl 7-9 set ref 8-11* 8-13 8-13 8-13 8-18
sstnt                                  based           structure                level 1 dcl 7-11
sstp                            000144 automatic       pointer                  dcl 70 set ref 86* 174 210 216 219 227
sum$getbranch_root_my           000040 constant        entry                    external dcl 46 ref 99
synchronized             13(21)        based           bit(1)                   level 2 packed packed unaligned dcl 6-11 set ref 179
                                                                                  195* 195
syserr                          000034 constant        entry                    external dcl 46 ref 103 199
temp_entry_name                 000162 automatic       char(32)                 dcl 8-23 set ref 111* 8-18
temp_sdw                        000172 automatic       bit(72)                  dcl 142 set ref 144* 146 146 147 147
temptr                          000110 automatic       pointer                  dcl 30 set ref 227* 228 229
time1                           000130 automatic       fixed bin(71,0)          dcl 30 set ref 84* 247
time2                           000132 automatic       fixed bin(71,0)          dcl 30 set ref 246* 247
tpr                       2            based           structure                level 2 packed packed unaligned dcl 1-56
tsdw                            000140 automatic       fixed bin(71,0)          dcl 30 set ref 88
tsdwp                           000100 automatic       pointer                  dcl 30 set ref 88*
tsr                       2(03)        based           bit(15)                  level 3 packed packed unaligned dcl 1-56 ref 94
usage_values                    000036 constant        entry                    external dcl 46 ref 84 246

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 1-42
apx                                    internal static fixed bin(17,0)          initial dcl 1-42
asta                                   based           bit(432)                 array dcl 6-86
aste_part                              based           structure                level 1 dcl 6-89
astep                                  automatic       pointer                  dcl 6-9
bbx                                    internal static fixed bin(17,0)          initial dcl 1-42
bpx                                    internal static fixed bin(17,0)          initial dcl 1-42
dir                                    based           structure                level 1 dcl 3-11
extended_page_fault_type               internal static fixed bin(17,0)          initial dcl 2-3
interrupt_type                         internal static fixed bin(17,0)          initial dcl 2-3
lbx                                    internal static fixed bin(17,0)          initial dcl 1-42
linkage_fault_end                      internal static fixed bin(17,0)          initial dcl 2-3
linkage_fault_start                    internal static fixed bin(17,0)          initial dcl 2-3
lpx                                    internal static fixed bin(17,0)          initial dcl 1-42
marker_type                            internal static fixed bin(17,0)          initial dcl 2-3
mcp                                    automatic       pointer                  dcl 1-10
np                                     automatic       pointer                  dcl 5-5
page_fault_type                        internal static fixed bin(17,0)          initial dcl 2-3
reschedule_type                        internal static fixed bin(17,0)          initial dcl 2-3
restart_fault_type                     internal static fixed bin(17,0)          initial dcl 2-3
sbx                                    internal static fixed bin(17,0)          initial dcl 1-42
scux                                   based           structure                level 1 dcl 1-207
seg_aste                               based           structure                level 1 dcl 6-96
seg_fault_end                          internal static fixed bin(17,0)          initial dcl 2-3
seg_fault_start                        internal static fixed bin(17,0)          initial dcl 2-3
signaller_type                         internal static fixed bin(17,0)          initial dcl 2-3
spx                                    internal static fixed bin(17,0)          initial dcl 1-42
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
boundfault                      000041 constant        entry                    external dcl 20
ill_op_code                     001041 constant        entry                    external dcl 254
un                              000753 constant        label                    dcl 242 ref 109 151 158 169 186
unlock_set                      000370 constant        label                    dcl 157 ref 117 122 127
update                          000764 constant        label                    dcl 244 ref 103

NAME DECLARED BY CONTEXT OR IMPLICATION.
rtrim                                                  builtin function         ref 8-18

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1446        1560    1055        1456
Length      2150    1055       112         353     370           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
boundfault                          172 external procedure  is an external procedure.  
begin block on line 140                 begin block         shares stack frame of external procedure boundfault.  
begin block on line 8-6                 begin block         shares stack frame of external procedure boundfault.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
boundfault               000100 tsdwp                       boundfault
                         000102 old_astep                   boundfault
                         000104 new_astep                   boundfault
                         000106 pastep                      boundfault
                         000110 temptr                      boundfault
                         000112 kstp                        boundfault
                         000114 par_astep                   boundfault
                         000116 pw1                         boundfault
                         000117 pw2                         boundfault
                         000120 pageno                      boundfault
                         000121 segno                       boundfault
                         000122 csl                         boundfault
                         000123 pts                         boundfault
                         000124 old_pts                     boundfault
                         000125 ptsi                        boundfault
                         000126 offset                      boundfault
                         000127 code                        boundfault
                         000130 time1                       boundfault
                         000132 time2                       boundfault
                         000134 last                        boundfault
                         000135 relp                        boundfault
                         000136 lsw                         boundfault
                         000137 par_ehs_status              boundfault
                         000140 tsdw                        boundfault
                         000142 read_lock                   boundfault
                         000144 sstp                        boundfault
                         000146 scup                        boundfault
                         000150 dp                          boundfault
                         000152 ep                          boundfault
                         000154 sstnp                       boundfault
                         000156 sstnmx                      boundfault
                         000157 ptsi_a                      boundfault
                         000160 nm_astep                    boundfault
                         000162 temp_entry_name             boundfault
                         000172 temp_sdw                    begin block on line 140

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_aste                      get_aste$synchronized         get_ptrs_$given_segno         lock$dir_unlock
lock$lock_ast                 lock$unlock_ast               page$enter_data               pc$move_page_table
pmut$swap_sdw                 put_aste                      sdw_util_$get_address         sdw_util_$set_size
search_ast$hash_in            search_ast$hash_out           setfaults                     sum$getbranch_root_my
syserr                        usage_values

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         error_table_$boundviol        error_table_$illegal_deactivation
error_table_$mylock           error_table_$root             error_table_$synch_seg_limit  kst_seg$
pds$bounds_faults             sst$ast_track                 sst$cpu_bf_time               sst$pts
sst$total_bf                  sst$total_bf_pf               sst_names_$                   sst_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000033        20 000036        84 000047        85 000060        86 000061        87 000064        88 000066
     90 000070        91 000075        92 000100        93 000102        94 000106        95 000112        97 000122
     99 000124       100 000145       103 000154       107 000202       108 000203       109 000205       111 000224
    114 000230       116 000235       117 000246       119 000252       121 000257       122 000262       125 000263
    126 000266       127 000271       130 000272       131 000276       140 000301       144 000303       146 000312
    147 000334       149 000353       150 000360       151 000361       154 000362       155 000365       157 000370
    158 000375       161 000376       163 000411       164 000415       166 000423       167 000425       168 000432
    169 000435       174 000436       175 000443       176 000447       179 000451       182 000466       183 000477
    184 000503       185 000510       186 000513       195 000514       199 000522       200 000554       204 000562
    205 000573       210 000575       212 000603       213 000604       214 000607       215 000613       216 000615
    217 000622       218 000623       219 000632       225 000636       226 000642       227 000644       228 000647
    229 000652       230 000655       234 000656       235 000665       237 000674    8    9 000703    8   11 000706
 8   12 000710    8   13 000715    8   18 000724       241 000747       242 000753       244 000764       246 000771
    247 001002       248 001007       249 001016       250 001022       251 001026       252 001036       254 001037
    257 001047       258 001054


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
