	COMPILATION LISTING OF SEGMENT init_scavenger_data
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0939.9 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-01-15,Fawcett), approve(86-04-11,MCR7383),
       12*     audit(86-05-21,Coppola), install(86-07-17,MR12.0-1097):
       13*     Add subvolume support.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 /* format: style3 */
       18 init_scavenger_data:
       19      proc;
       20 
       21 
       22 /*  Program to initialize scavenger_data. The number of processes allowed
       23*    to scavenge simultaneously is based on the size of scavenger_data,
       24*    which may be changed by a TBLS SCAV card. 
       25*
       26*    Written July 1982 by J. Bongiovanni
       27*    Modified November 1982 by J. Bongiovanni for static process memory assignment
       28**/
       29 
       30 /*  Automatic  */
       31 
       32 
       33 dcl	first_free_page	fixed bin;
       34 dcl	max_rec_per_sv	fixed bin;
       35 dcl	n_free_pages	fixed bin;
       36 dcl	pages_per_process	fixed bin;
       37 dcl	processx		fixed bin;
       38 dcl	pvtx		fixed bin;
       39 dcl	sc_data_pages	fixed bin;
       40 dcl	sc_data_words	fixed bin (19);
       41 
       42 /*  Static  */
       43 
       44 dcl	N_OVFL		fixed bin int static options (constant) init (1023);
       45 dcl	N_OVERHEAD_PAGES	fixed bin int static options (constant) init (1);
       46 dcl	SCAVENGER_WAIT_EVENT
       47 			bit (36) aligned int static options (constant) init ("555000000000"b3);
       48 
       49 /*  External  */
       50 
       51 dcl	dseg$		(0:1023) fixed bin (71) external;
       52 
       53 /*  Entry  */
       54 
       55 dcl	sdw_util_$get_size	entry (ptr, fixed bin (19));
       56 dcl	syserr		entry options (variable);
       57 
       58 /*  Builtin  */
       59 
       60 dcl	addr		builtin;
       61 dcl	baseno		builtin;
       62 dcl	bin		builtin;
       63 dcl	divide		builtin;
       64 dcl	hbound		builtin;
       65 dcl       lbound		builtin;
       66 dcl	rel		builtin;
       67 dcl	size		builtin;
       68 
       69 
       70 	max_rec_per_sv = 0;
       71 	pvt_arrayp = addr(pvt$array);
       72 	/* set the max record number for the largest device configured */
       73 	do pvtx = lbound (pvt_array, 1) to hbound (pvt_array, 1);
       74 	     pvtep = addr(pvt_array(pvtx));
       75 	     if rec_per_sv (pvte.device_type) > max_rec_per_sv
       76 	     then max_rec_per_sv = rec_per_sv (pvte.device_type);
       77 	end;
       78 
       79 	scavenger_n_records = max_rec_per_sv;
       80 	scavenger_n_ovfl = N_OVFL;
       81 	pages_per_process = divide (size (scavenger_block) + 1023, 1024, 17);
       82 
       83 	scavenger_datap = addr (scavenger_data$);
       84 
       85 	call sdw_util_$get_size (addr (dseg$ (bin (baseno (scavenger_datap)))), sc_data_words);
       86 	sc_data_pages = divide (sc_data_words, 1024, 17);
       87 
       88 	scavenger_data.lock.wait_event = SCAVENGER_WAIT_EVENT;
       89 
       90 	sc_n_processes = divide (sc_data_pages - N_OVERHEAD_PAGES, pages_per_process, 17);
       91 						/* Assume header is 1 page */
       92 	if sc_n_processes < 1
       93 	then call syserr (CRASH, "init_scavenger_data: scavenger_data is too small.");
       94 
       95 	sc_process_tablep = addr (scavenger_data.free);
       96 	scavenger_data.process_table_ptr = sc_process_tablep;
       97 	sc_process_table.max_n_processes = sc_n_processes;
       98 
       99 	first_free_page = divide (bin (rel (addr (scavenger_data.free))) + size (sc_process_table) + 1023, 1024, 17);
      100 	n_free_pages = sc_data_pages - first_free_page + 1;
      101 	if first_free_page > N_OVERHEAD_PAGES
      102 	then call syserr (CRASH, "init_scavenger_data: scavenger_data inconsistency.");
      103 
      104 	do processx = 1 to sc_n_processes;
      105 	     sc_process_table.process (processx).blockp = addr (scavenger_data_pages.page (first_free_page));
      106 	     sc_process_table.process (processx).first_block_page = first_free_page;
      107 	     first_free_page = first_free_page + pages_per_process;
      108 	     n_free_pages = n_free_pages - pages_per_process;
      109 	     if n_free_pages < 0
      110 	     then call syserr (CRASH, "init_scavenger_data: scavenger_data inconsistency.");
      111 	end;
      112 
      113 	scavenger_data.error_severity = ANNOUNCE;
      114 
      115 
      116 	return;					/* format: off */
      117   /* Begin include file ...... fs_dev_types.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  1     6*     Add support for FIPS
  1     7*     3380.
  1     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  1     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  1    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  1    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  1    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  1    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 /* Modified 5/19/76 by N. I. Morris */
  1    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  1    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  1    19 /* Modified '82 by BIM for needs_alt_part */
  1    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  1    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  1    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  1    23*   volmap and record stock can be expanded. */
  1    24 
  1    25 /*
  1    26********************************************************************************
  1    27**							        *
  1    28**                           WARNING:                                          *
  1    29**							        *
  1    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  1    31**   type is added.						        *
  1    32**							        *
  1    33**   There are other include files that contain arrays indexed by the device   *
  1    34**   index obtained by references to MODELX or MODELN in this include file.    *
  1    35**   These must be modified when a new device type is added:		        *
  1    36**   disk_pack.incl.pl1					        *
  1    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  1    38**							        *
  1    39********************************************************************************
  1    40**/
  1    41 
  1    42 
  1    43 dcl (maxdevt init (9),				/* maximum legal devt */
  1    44      bulkdevt init (1),				/* bulk store devt */
  1    45      msu0500devt init (2),				/* MSU0500 device type */
  1    46      msu0451devt init (3),				/* MSU0451 device type */
  1    47      msu0450devt init (3),				/* MSU0450 device type */
  1    48      msu0400devt init (4),				/* MSU0400 device type */
  1    49      dsu191devt init (4),				/* DSU191 device type */
  1    50      dsu190devt init (5),				/* DSU190 device type */
  1    51      dsu181devt init (6),				/* DSU181 device type */
  1    52      msu0501devt init (7),				/* MSU0501 device type */
  1    53      fips3380devt init (8),				/* 3380D FIPS device type */
  1    54      fips3381devt init (9)				/* 3380E FIPS device type */
  1    55      ) fixed bin (4) static options (constant);
  1    56 
  1    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  1    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  1    59 
  1    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  1    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  1    62 
  1    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  1    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  1    65 
  1    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  1    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  1    68 
  1    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  1    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  1    71 
  1    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  1    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  1    74 
  1    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  1    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  1    77 
  1    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  1    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  1    80 
  1    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  1    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  1    83 
  1    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  1    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  1    86 
  1    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  1    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  1    89 
  1    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  1    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  1    92 
  1    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  1    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  1    95 
  1    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  1    97      ("abc");
  1    98 
  1    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  1   100      init ("a","b","c");
  1   101 
  1   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  1   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  1   104 
  1   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  1   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  1   107 
  1   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  1   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  1   110 
  1   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  1   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  1   113 
  1   114 
  1   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  1   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  1   117 
  1   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  1   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  1   120 
  1   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  1   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  1   123 
  1   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  1   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  1   126 
  1   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  1   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  1   129 
  1   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  1   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  1   132 
  1   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  1   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  1   135 
  1   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  1   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  1   138 
  1   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  1   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  1   141 
  2     1 /* Begin fs_dev_types_sector.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  2     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  2     7*     Add the sector differance for devices that do 64 word IO and devices that
  2     8*     do 512 word IO.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  2    12*	 need all the data in fs_dev_types. This is also included in
  2    13*	 fs_dev_types.incl.pl1  */
  2    14 
  2    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  2    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  2    17 
  2    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  2    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  2    20 
  2    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  2    22  /* table of # of sectors per record on each device */
  2    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  2    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    25 
  2    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  2    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    28 	
  2    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  2    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  2    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    32 
  2    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  2    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  2    35 
  2    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  2    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  2    38 
  2    39 /* End fs_dev_types_sector.incl.pl1 */
  2    40 
  1   142 
  1   143 
  1   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      117 
      118   /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  3     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3     8*     Add the support for subvolumes
  3     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  3    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  3    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3    14*     Added inconsistent_dbm bit for determining the status of volume
  3    15*     dumper bit maps.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18      dcl	   pvt$array	      aligned external;
  3    19      dcl	   pvt$max_n_entries      fixed bin external;
  3    20 
  3    21      dcl	   pvt_arrayp	      ptr;
  3    22      dcl	   pvtep		      ptr;
  3    23 
  3    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  3    25 
  3    26      dcl	   1 pvte		      based (pvtep) aligned,
  3    27 
  3    28 	     2 pvid	      bit (36),		/* physical volume ID */
  3    29 
  3    30 	     2 lvid	      bit (36),		/* logical volume ID */
  3    31 
  3    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  3    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  3    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  3    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  3    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  3    37 	     2 pad3	      bit (2) unaligned,
  3    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  3    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  3    40 
  3    41 
  3    42 
  3    43 	     2 devname	      char (4),		/* device name */
  3    44 
  3    45 	     (2 device_type	      fixed bin (8),	/* device type */
  3    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  3    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  3    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  3    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  3    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  3    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  3    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  3    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  3    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  3    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  3    56 	     2 scav_check_address
  3    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  3    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  3    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  3    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  3    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  3    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  3    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  3    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  3    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  3    66 
  3    67 
  3    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  3    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  3    70 
  3    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  3    72 
  3    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  3    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  3    75 
  3    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  3    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  3    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  3    79 	     2 records_per_cyl    fixed bin,
  3    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  3    81 	     2 sv_name            char (2) aligned,
  3    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  3    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  3    84 
  3    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  3    86 	     2 pad2	      bit (18) unaligned,
  3    87 
  3    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  3    89 
  3    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  3    91 
  3    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  3    93 
  3    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  3    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  3    96 
  3    97 
  3    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  3    99 
  3   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  3   101 
  3   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  3   103 
  3   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  3   105 
  3   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  3   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  3   108 
  3   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  3   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  3   111 
  3   112 
  3   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  3   114 	   VOLMAP_ASYNC_READ      init (1),
  3   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  3   116 
  3   117 
  3   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      118 
      119   /*  START OF:	scavenger_data.incl.pl1   November 1982       *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 /* format: style3 */
  4     4 dcl	scavenger_data$	external;
  4     5 
  4     6 dcl	scavenger_datap	ptr;
  4     7 dcl	sc_metersp	ptr;
  4     8 dcl	sc_process_tablep	ptr;
  4     9 dcl	scavenger_blockp	ptr;
  4    10 dcl	record_blockp	ptr;
  4    11 dcl	scavenger_optionsp	ptr;
  4    12 
  4    13 dcl	sc_n_processes	fixed bin;
  4    14 dcl	scavenger_n_records fixed bin;
  4    15 dcl	scavenger_n_ovfl	fixed bin;
  4    16 
  4    17 
  4    18 dcl	1 scavenger_data	aligned based (scavenger_datap),
  4    19 	  2 lock		aligned,			/* Lock on scavenger_data */
  4    20 	    3 lock_word	bit (36) aligned,
  4    21 	    3 wait_event	bit (36) aligned,
  4    22 	    3 notify_sw	bit (1) aligned,
  4    23 	  2 process_table_ptr
  4    24 			ptr,			/* Pointer to scavenger process table */
  4    25 	  2 error_severity	fixed bin,		/* Severity of unexpected error condition */
  4    26 	  2 meters	aligned like sc_meters,
  4    27 	  2 free		bit (1) aligned;		/* Available region */
  4    28 
  4    29 
  4    30 dcl	1 sc_meters	aligned based (sc_metersp),	/* Meters */
  4    31 	  2 n_scavenge	fixed bin (35),		/* Number of volume scavenges */
  4    32 	  2 pf		fixed bin (35),		/* Total page faults */
  4    33 	  2 vcpu		fixed bin (71),		/* Total virtual CPU time */
  4    34 	  2 clock_time	fixed bin (71),		/* Total clock time */
  4    35 	  2 n_vtoces	fixed bin (35),		/* Number VTOCEs examined */
  4    36 	  2 n_vtoces_damaged
  4    37 			fixed bin (35),		/* Number VTOCEs damaged by scavenge */
  4    38 	  2 n_vtoces_per_proc
  4    39 			fixed bin (35),		/* Number per-process VTOCEs freed */
  4    40 	  2 n_vtoces_per_boot
  4    41 			fixed bin (35),		/* Number per-bootload VTOCEs freed */
  4    42 	  2 n_vtoces_freed	fixed bin (35),		/* Total number VTOCEs freed */
  4    43 	  2 n_vtoces_fmd	fixed bin (35),		/* Number VTOCEs with fm_damaged reset */
  4    44 	  2 n_records	fixed bin (35),		/* Number non-null filemap entries examined */
  4    45 	  2 n_conflicts	fixed bin (35),		/* Number potential conflicts detected */
  4    46 	  2 n_fmd_conflicts fixed bin (35),		/* Number potential conflicts due to fm_damaged */
  4    47 	  2 n_real_conflicts
  4    48 			fixed bin (35),		/* Number real conflicts */
  4    49 	  2 n_lost_records	fixed bin (35);		/* Number lost records freed */
  4    50 
  4    51 
  4    52 dcl	1 sc_process_table	aligned based (sc_process_tablep),
  4    53 	  2 max_n_processes fixed bin,		/* Number of table entries */
  4    54 	  2 n_processes	fixed bin,		/* Number active entries */
  4    55 	  2 process	(sc_n_processes refer (sc_process_table.max_n_processes)) aligned,
  4    56 	    3 processid	bit (36) aligned,		/* Owner. 0=>empty */
  4    57 	    3 pvtep	ptr unal,			/* PVTE of volume being scavenged */
  4    58 	    3 blockp	ptr unal,			/* Block w/i scavenger_data */
  4    59 	    3 first_block_page
  4    60 			fixed bin,		/* Index of first page of block */
  4    61 	    3 n_block_pages fixed bin;		/* Number of pages in block */
  4    62 
  4    63 
  4    64 dcl	1 scavenger_block	aligned based (scavenger_blockp),
  4    65 	  2 n_records	fixed bin,		/* Number of record addresses */
  4    66 	  2 n_ovfl	fixed bin,		/* Number of overflow blocks */
  4    67 	  2 ovfl_free_ix	fixed bin,		/* Index of first free overflow block */
  4    68 	  2 records	(scavenger_n_records refer (scavenger_block.n_records)) aligned like record_block,
  4    69 	  2 overflow	(scavenger_n_ovfl refer (scavenger_block.n_ovfl)) aligned like record_block;
  4    70 
  4    71 
  4    72 dcl	1 record_block	aligned based (record_blockp),/* One per record address */
  4    73 	  2 vtocx		fixed bin (15) uns unal,	/* Owning VTOCE index */
  4    74 	  2 pageno	fixed bin (8) uns unal,	/* Owning page number */
  4    75 	  2 state		fixed bin (2) uns unal,	/* State */
  4    76 	  2 lock		bit (1) unal,		/* Lock bit on this block */
  4    77 	  2 ovflx		fixed bin (10) uns unal;	/* Index of first overflow block on chain */
  4    78 
  4    79 dcl	1 scavenger_data_pages
  4    80 			aligned based (scavenger_datap),
  4    81 	  2 page		(0:255) aligned,
  4    82 	    3 word	(1024) bit (36) aligned;
  4    83 
  4    84 dcl	1 scavenger_options aligned based (scavenger_optionsp),
  4    85 	  2 print_meters	bit (1) unaligned,		/* ON => meter each scavenge into the log */
  4    86 	  2 debug		bit (1) unaligned,		/* ON => do special debugging things */
  4    87 	  2 dump		bit (1) unaligned,		/* ON => dump bad VTOCEs into syserr log */
  4    88 	  2 trap		bit (1) unaligned,		/* ON => trap to BOS for debug */
  4    89 	  2 no_optimize	bit (1) unaligned,		/* ON => no VTOCE read-ahead */
  4    90 	  2 fault_under_ast bit (1) unaligned,		/* ON => fault under AST lock, benign */
  4    91 	  2 fault_under_volmap bit (1) unaligned,	/* ON => fault under volmap lock, benign */
  4    92 	  2 fault_under_pt bit (1) unaligned;		/* ON => fault inder PTL, NOT BENIGN */
  4    93 
  4    94 dcl	(
  4    95 	STATE_UNSEEN	init (0),
  4    96 	STATE_FREE	init (1),
  4    97 	STATE_IN_USE	init (2),
  4    98 	STATE_CONFLICT	init (3)
  4    99 	)		fixed bin int static options (constant);
  4   100 
  4   101 
  4   102 
  4   103 
  4   104 /*  END OF:	scavenger_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      119 
      120   /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  5     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  5     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  5     4 
  5     5 /* This include file has an ALM version.  Keep 'em in sync! */
  5     6 
  5     7 dcl (
  5     8 
  5     9 /* The following constants define the message action codes.  This indicates
  5    10*how a message is to be handled.  */
  5    11 
  5    12      SYSERR_CRASH_SYSTEM	init (1),			
  5    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  5    14 
  5    15      SYSERR_TERMINATE_PROCESS	init (2),
  5    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  5    17 
  5    18      SYSERR_PRINT_WITH_ALARM	init (3),
  5    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  5    20 
  5    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  5    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  5    23 
  5    24      SYSERR_LOG_OR_PRINT	init (4),
  5    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  5    26 
  5    27      SYSERR_LOG_OR_DISCARD	init (5),
  5    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  5    29 
  5    30 
  5    31 /* The following constants are added to the normal severities to indicate
  5    32*different sorting classes of messages.  */
  5    33 
  5    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  5    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  5    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  5    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  5    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  5    39 	) fixed bin internal static options (constant);
  5    40 
  5    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      120 
      121 
      122 /* BEGIN MESSAGE DOCUMENTATION
      123*
      124*Message:
      125*init_scavenger_data: scavenger_data too small.
      126*
      127*S:        $crash
      128*
      129*T:        $init
      130*
      131*M:        The size of the scavenger_data segment is too small. It can be 
      132*increased by the TBLS SCAV config card. It must be at least 68KW, with an
      133*additional 67KW for each additional process (beyond 1) which is to be
      134*scavenging simultaneously.
      135*
      136*A:        Correct the configuration deck and reboot.
      137*
      138*Message:
      139*init_scavenger_data: scavenger_data inconsistency.
      140*
      141*T:        $init
      142*
      143*S:	$crash
      144*
      145*M:	An error was encountered initializing the scavenger's data base.
      146*
      147*A:	$contact
      148*
      149*END MESSAGE DOCUMENTATION */
      150 
      151      end init_scavenger_data;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.9  init_scavenger_data.pl1           >spec>install>1112>init_scavenger_data.pl1
117          1    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
1-142        2    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
118          3    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
119          4    02/27/84  1141.4  scavenger_data.incl.pl1           >ldd>include>scavenger_data.incl.pl1
120          5    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                               constant        fixed bin(17,0)          initial dcl 5-7 ref 113
CRASH                           000014 constant        fixed bin(17,0)          initial dcl 5-7 set ref 92* 101* 109*
N_OVERHEAD_PAGES                       constant        fixed bin(17,0)          initial dcl 45 ref 90 101
N_OVFL                                 constant        fixed bin(17,0)          initial dcl 44 ref 80
SCAVENGER_WAIT_EVENT                   constant        bit(36)                  initial dcl 46 ref 88
addr                                                   builtin function         dcl 60 ref 71 74 83 85 85 95 99 105
baseno                                                 builtin function         dcl 61 ref 85 85
bin                                                    builtin function         dcl 62 ref 85 85 99
blockp                    4            based           pointer                  array level 3 packed packed unaligned dcl 4-52 set
                                                                                  ref 105*
device_type               4            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 3-26 ref 75 75
divide                                                 builtin function         dcl 63 ref 81 86 90 99
dseg$                           000010 external static fixed bin(71,0)          array dcl 51 set ref 85 85
error_severity            6            based           fixed bin(17,0)          level 2 dcl 4-18 set ref 113*
first_block_page          5            based           fixed bin(17,0)          array level 3 dcl 4-52 set ref 106*
first_free_page                 000100 automatic       fixed bin(17,0)          dcl 33 set ref 99* 100 101 105 106 107* 107
free                     31            based           bit(1)                   level 2 dcl 4-18 set ref 95 99
hbound                                                 builtin function         dcl 64 ref 73
lbound                                                 builtin function         dcl 65 ref 73
lock                                   based           structure                level 2 dcl 4-18
max_n_processes                        based           fixed bin(17,0)          level 2 dcl 4-52 set ref 97*
max_rec_per_sv                  000101 automatic       fixed bin(17,0)          dcl 34 set ref 70* 75 75* 79
n_free_pages                    000102 automatic       fixed bin(17,0)          dcl 35 set ref 100* 108* 108 109
page                                   based           structure                array level 2 dcl 4-79 set ref 105
pages_per_process               000103 automatic       fixed bin(17,0)          dcl 36 set ref 81* 90 107 108
process                   2            based           structure                array level 2 dcl 4-52
process_table_ptr         4            based           pointer                  level 2 dcl 4-18 set ref 96*
processx                        000104 automatic       fixed bin(17,0)          dcl 37 set ref 104* 105 106*
pvt$array                       000016 external static fixed bin(17,0)          dcl 3-18 set ref 71
pvt$max_n_entries               000020 external static fixed bin(17,0)          dcl 3-19 ref 73
pvt_array                              based           structure                array level 1 dcl 3-24 set ref 73 73 74
pvt_arrayp                      000112 automatic       pointer                  dcl 3-21 set ref 71* 73 73 74
pvte                                   based           structure                level 1 dcl 3-26
pvtep                           000114 automatic       pointer                  dcl 3-22 set ref 74* 75 75
pvtx                            000105 automatic       fixed bin(17,0)          dcl 38 set ref 73* 74*
rec_per_sv                      000000 constant        fixed bin(17,0)          initial array dcl 1-90 ref 75 75
record_block                           based           structure                level 1 dcl 4-72
rel                                                    builtin function         dcl 66 ref 99
sc_data_pages                   000106 automatic       fixed bin(17,0)          dcl 39 set ref 86* 90 100
sc_data_words                   000107 automatic       fixed bin(19,0)          dcl 40 set ref 85* 86
sc_meters                              based           structure                level 1 dcl 4-30
sc_n_processes                  000122 automatic       fixed bin(17,0)          dcl 4-13 set ref 90* 92 97 99 104
sc_process_table                       based           structure                level 1 dcl 4-52 set ref 99
sc_process_tablep               000120 automatic       pointer                  dcl 4-8 set ref 95* 96 97 99 105 106
scavenger_block                        based           structure                level 1 dcl 4-64 ref 81
scavenger_blockp                       automatic       pointer                  dcl 4-9 ref 81
scavenger_data                         based           structure                level 1 dcl 4-18
scavenger_data$                 000022 external static fixed bin(17,0)          dcl 4-4 set ref 83
scavenger_data_pages                   based           structure                level 1 dcl 4-79
scavenger_datap                 000116 automatic       pointer                  dcl 4-6 set ref 83* 85 85 88 95 96 99 105 113
scavenger_n_ovfl                000124 automatic       fixed bin(17,0)          dcl 4-15 set ref 80* 81
scavenger_n_records             000123 automatic       fixed bin(17,0)          dcl 4-14 set ref 79* 81
sdw_util_$get_size              000012 constant        entry                    external dcl 55 ref 85
seek_command                    000110 automatic       bit(6)                   initial array packed unaligned dcl 1-84 set ref
                                                                                  1-84* 1-84* 1-84* 1-84* 1-84* 1-84* 1-84* 1-84*
                                                                                  1-84*
size                                                   builtin function         dcl 67 ref 81 99
syserr                          000014 constant        entry                    external dcl 56 ref 92 101 109
wait_event                1            based           bit(36)                  level 3 dcl 4-18 set ref 88*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 5-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 5-7
LOG                                    internal static fixed bin(17,0)          initial dcl 5-7
MODEL                                  internal static fixed bin(17,0)          initial array dcl 1-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 1-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 1-60
STATE_CONFLICT                         internal static fixed bin(17,0)          initial dcl 4-94
STATE_FREE                             internal static fixed bin(17,0)          initial dcl 4-94
STATE_IN_USE                           internal static fixed bin(17,0)          initial dcl 4-94
STATE_UNSEEN                           internal static fixed bin(17,0)          initial dcl 4-94
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 5-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 5-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 5-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 3-113
bulkdevt                               internal static fixed bin(4,0)           initial dcl 1-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 1-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 1-105
dev_time                               internal static float bin(27)            initial array dcl 1-139
device_names                           internal static char(4)                  initial array dcl 1-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 1-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 1-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 1-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 1-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 1-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 1-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 1-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 1-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 1-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 1-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 1-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 1-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 1-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 1-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 1-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 1-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 1-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 1-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 1-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 1-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 1-93
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 1-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 1-87
record_blockp                          automatic       pointer                  dcl 4-10
sc_metersp                             automatic       pointer                  dcl 4-7
scavenger_options                      based           structure                level 1 dcl 4-84
scavenger_optionsp                     automatic       pointer                  dcl 4-11
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 2-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 2-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 2-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 2-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 2-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 1-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 1-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 1-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 1-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 2-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 2-36

NAME DECLARED BY EXPLICIT CONTEXT.
init_scavenger_data             000050 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       516         542     420         526
Length      1022     420        24         244      75           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_scavenger_data                 124 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_scavenger_data      000100 first_free_page             init_scavenger_data
                         000101 max_rec_per_sv              init_scavenger_data
                         000102 n_free_pages                init_scavenger_data
                         000103 pages_per_process           init_scavenger_data
                         000104 processx                    init_scavenger_data
                         000105 pvtx                        init_scavenger_data
                         000106 sc_data_pages               init_scavenger_data
                         000107 sc_data_words               init_scavenger_data
                         000110 seek_command                init_scavenger_data
                         000112 pvt_arrayp                  init_scavenger_data
                         000114 pvtep                       init_scavenger_data
                         000116 scavenger_datap             init_scavenger_data
                         000120 sc_process_tablep           init_scavenger_data
                         000122 sc_n_processes              init_scavenger_data
                         000123 scavenger_n_records         init_scavenger_data
                         000124 scavenger_n_ovfl            init_scavenger_data

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mpfx2               ext_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sdw_util_$get_size            syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         pvt$array                     pvt$max_n_entries             scavenger_data$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000047    1   84 000055        70 000144        71 000145        73 000147        74 000157        75 000163
     77 000172        79 000174        80 000176        81 000200        83 000206        85 000211        86 000232
     88 000235        90 000240        92 000243        95 000265        96 000270        97 000272        99 000274
    100 000310       101 000314       104 000340       105 000347       106 000356       107 000360       108 000362
    109 000364       111 000407       113 000411       116 000414


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
