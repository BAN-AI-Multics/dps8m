	COMPILATION LISTING OF SEGMENT ioi_workspace
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1016.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       10 
       11 ioi_workspace:
       12      proc;
       13 
       14 /* ioi_workspace--creation, deletion, and ring bracket setting entries for the IOI workspace */
       15 /* Written March 1983 by Chris Jones (based on ioi_buffer) */
       16 
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(85-10-01,Farley), approve(86-07-18,MCR7439),
       20*     audit(86-08-18,Fawcett), install(86-10-20,MR12.0-1189):
       21*     Changed to execute in the BCE environment.
       22*  2) change(86-11-17,Farley), approve(86-11-20,MECR0002),
       23*     audit(86-11-19,Fawcett), install(86-11-20,MR12.0-1222):
       24*     Added check to unwire any active workspace pages before releasing the
       25*     workspace in the set_max_size entry.
       26*  3) change(86-12-19,Farley), approve(86-12-19,MCR7587),
       27*     audit(86-12-19,Fawcett), install(87-01-05,MR12.0-1253):
       28*     Formal installation to close out above MECR0002.
       29*  4) change(87-04-27,Farley), approve(87-07-06,MCR7717),
       30*     audit(87-07-13,Lippard), install(87-07-17,MR12.1-1043):
       31*     Changed code to use bce_early_ioi_workspace when the bootload_temp_N
       32*     segments are not yet available.
       33*                                                   END HISTORY COMMENTS */
       34 
       35 
       36 dcl	p_code		   fixed bin (35);		/* error code (O) */
       37 dcl	p_dtep		   ptr;			/* pointer to dte (I) */
       38 
       39 dcl	code		   fixed bin (35);		/* local error code */
       40 dcl	dname		   char (168);		/* workspace segment directory name */
       41 dcl	ename		   char (32);		/* workspace segment name */
       42 dcl	rba		   (3) fixed bin (3);	/* ring bracket array */
       43 dcl	workspace_segno	   fixed bin (17);		/* seg# for finding astep */
       44 dcl	validation_level	   fixed bin (3);		/* current validation level */
       45 
       46 dcl	bce_early_ioi_workspace$
       47 			   bit (36) aligned external static;
       48 dcl	dseg$		   (0:1023) fixed bin (71) external static;
       49 dcl	pds$process_dir_name   char (32) ext;
       50 dcl	sys_info$service_system
       51 			   bit (1) aligned external static;
       52 
       53 dcl	append$branch	   entry (char (*), char (*), fixed bin (5), fixed bin (35));
       54 dcl	delentry$dseg	   entry (ptr, fixed bin (35));
       55 dcl	fs_get$path_name	   entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
       56 dcl	get_ptrs_$given_astep  entry (ptr) returns (fixed bin (71));
       57 dcl	get_ptrs_$given_segno  entry (fixed bin (17)) returns (ptr);
       58 dcl	get_temp_segment_	   entry (char (*), ptr, fixed bin (35));
       59 dcl	grab_aste$grab_aste_io entry (ptr, fixed bin (19), fixed bin (35)) returns (ptr);
       60 dcl	grab_aste$release_io   entry (ptr);
       61 dcl	initiate		   entry (char (*), char (*), char (*), fixed bin (1), fixed bin (1), ptr, fixed bin (35));
       62 dcl	ioi_wire$unwire	   entry (ptr);
       63 dcl	level$get		   entry returns (fixed bin (3));
       64 dcl	level$set		   entry (fixed bin (3));
       65 dcl	release_temp_segment_  entry (char (*), ptr, fixed bin (35));
       66 dcl	ringbr_$set	   entry (char (*), char (*), (3) fixed bin (3), fixed bin (35));
       67 dcl	sdw_util_$get_valid	   entry (ptr) returns (bit (1) aligned);
       68 dcl	set$max_length_ptr	   entry (ptr, fixed bin (19), fixed bin (35));
       69 dcl	slt_manager$get_seg_ptr
       70 			   entry (char (32) aligned) returns (ptr);
       71 dcl	unique_chars_	   entry (bit (*)) returns (char (15));
       72 
       73 dcl	(addr, baseno, fixed, null)
       74 			   builtin;
       75 
       76 	return;
       77 
       78 create:
       79      entry (p_dtep, p_code);
       80 
       81 	dtep = p_dtep;
       82 	p_code = 0;
       83 
       84 	if ^sys_info$service_system then do;		/* at BCE */
       85 	     if ^(sdw_util_$get_valid (addr (dseg$ (fixed (baseno (slt_manager$get_seg_ptr ("bootload_temp_1")), 18)))))
       86 		then
       87 		dte.workspace_ptr = addr (bce_early_ioi_workspace$);
       88 						/* temp segments not yet available */
       89 	     else do;
       90 		call get_temp_segment_ ("ioi_workspace", dte.workspace_ptr, code);
       91 						/* bootload_temp_XX segment */
       92 		if code ^= 0 then do;		/* unable to continue */
       93 		     p_code = code;
       94 		     return;
       95 		end;
       96 	     end;
       97 
       98 	     workspace_segno = fixed (baseno (dte.workspace_ptr), 17);
       99 	     dte.workspace_astep = get_ptrs_$given_segno (workspace_segno);
      100 	     dte.workspace_sdw = get_ptrs_$given_astep (dte.workspace_astep);
      101 	     return;
      102 	end;
      103 
      104 	dname = pds$process_dir_name;			/* the workspace lives in our process directory */
      105 	ename = unique_chars_ ("0"b) || ".ioi";		/* create unique workspace segment name. */
      106 
      107 	validation_level = level$get ();		/* save current validation level */
      108 	call level$set (0);				/* set hardcore ring validation level */
      109 
      110 	call append$branch (dname, ename, RW_ACCESS_BIN, code);
      111 	call quit_if_error;
      112 	call initiate (dname, ename, "", 0b, 1b, dte.workspace_ptr, code);
      113 	call quit_if_error;
      114 	call set_rb_proc;				/* set the ring brackets */
      115 	call set$max_length_ptr (dte.workspace_ptr, dte.max_bound, code);
      116 	call grab;
      117 	call quit_if_error;
      118 
      119 	call level$set (validation_level);		/* restore original validation level */
      120 	return;
      121 
      122 destroy:
      123      entry (p_dtep, p_code);
      124 
      125 	dtep = p_dtep;
      126 	p_code = 0;
      127 
      128 	if ^sys_info$service_system then do;		/* at BCE */
      129 	     if sdw_util_$get_valid (addr (dseg$ (fixed (baseno (slt_manager$get_seg_ptr ("bootload_temp_1")), 18))))
      130 	     then do;
      131 		if dte.workspace_wired then		/* if segment is active */
      132 		     call ioi_wire$unwire (dtep);	/* unwire the pages NOW */
      133 		call release_temp_segment_ ("ioi_workspace", dte.workspace_ptr, code);
      134 						/* bootload_temp_XX segment */
      135 		if code ^= 0 then do;
      136 		     p_code = code;
      137 		     return;
      138 		end;
      139 	     end;
      140 
      141 	     dte.workspace_ptr = null ();
      142 	     dte.workspace_astep = null ();
      143 	     dte.workspace_sdw = 0;
      144 	     return;
      145 	end;
      146 
      147 	if dte.workspace_wired then			/* if segment is active */
      148 	     call ioi_wire$unwire (dtep);		/* unwire the pages NOW */
      149 
      150 	if dte.workspace_ptr ^= null () then do;	/* if workspace exists... */
      151 	     validation_level = level$get ();		/* save current validation level */
      152 	     call level$set (0);			/* set hardcore ring validation level */
      153 
      154 	     call release;
      155 	     call delentry$dseg (dte.workspace_ptr, code);
      156 	     call quit_if_error;
      157 	     dte.workspace_ptr = null ();
      158 
      159 	     call level$set (validation_level);		/* restore original validation level */
      160 	end;
      161 
      162 	return;
      163 
      164 release_aste:
      165      entry (p_dtep);
      166 
      167 	dtep = p_dtep;
      168 	if ^sys_info$service_system then
      169 	     dte.workspace_astep = null ();
      170 	else call release;
      171 	return;
      172 
      173 set_max_size:
      174      entry (p_dtep, p_code);
      175 
      176 	dtep = p_dtep;
      177 	p_code = 0;
      178 
      179 	if ^sys_info$service_system then
      180 	     return;				/* No need at BCE */
      181 
      182 	if dte.workspace_ptr ^= null () then do;	/* if workspace exists */
      183 	     if dte.workspace_wired then
      184 		call ioi_wire$unwire (dtep);		/* unwire active pages */
      185 	     validation_level = level$get ();
      186 	     call level$set (0);
      187 	     call release;
      188 	     call set$max_length_ptr (dte.workspace_ptr, dte.max_bound, code);
      189 	     call quit_if_error;
      190 	     call grab;
      191 	     call level$set (validation_level);
      192 	end;
      193 	return;
      194 
      195 set_rb:
      196      entry (p_dtep, p_code);
      197 
      198 	dtep = p_dtep;
      199 	p_code = 0;
      200 
      201 	if ^sys_info$service_system then
      202 	     return;				/* No need at BCE */
      203 
      204 	if dte.workspace_ptr ^= null () then do;	/* if workspace exists */
      205 	     validation_level = level$get ();
      206 	     call level$set (0);
      207 	     call fs_get$path_name (dte.workspace_ptr, dname, (0), ename, code);
      208 	     call quit_if_error;
      209 	     call set_rb_proc;
      210 	     call level$set (validation_level);
      211 	end;
      212 	return;
      213 
      214 set_rb_proc:
      215      proc;
      216 
      217 	rba (*) = dte.ring;				/* set up ring bracket array */
      218 	call ringbr_$set (dname, ename, rba, code);	/* change the ring brackets of the workspace segment */
      219 	call quit_if_error;
      220 
      221      end set_rb_proc;
      222 
      223 /* routine to grab the aste and get the sdw */
      224 
      225 grab:
      226      proc;
      227 
      228 	if dte.max_bound ^= 0 then do;
      229 	     dte.workspace_astep = grab_aste$grab_aste_io (dte.workspace_ptr, dte.max_bound, code);
      230 	     call quit_if_error;
      231 	     dte.workspace_sdw = get_ptrs_$given_astep (dte.workspace_astep);
      232 	end;
      233 
      234      end grab;
      235 
      236 /* routine to release the aste */
      237 
      238 release:
      239      proc;
      240 
      241 	if dte.workspace_astep ^= null () then do;
      242 	     call grab_aste$release_io (dte.workspace_astep);
      243 	     dte.workspace_astep = null ();
      244 	end;
      245 
      246      end release;
      247 
      248 quit_if_error:
      249      proc;
      250 
      251 	if code ^= 0 then
      252 	     call quit (code);
      253 
      254      end quit_if_error;
      255 
      256 quit:
      257      proc (code);
      258 
      259 dcl	code		   fixed bin (35) parameter;
      260 
      261 	call level$set (validation_level);
      262 	p_code = code;
      263 	goto QUIT;
      264 
      265      end quit;
      266 
      267 QUIT:
      268 	return;
      269 
  1     1 /* Begin include file ...... ioi_data.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1     6*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  1     7*     Support for FIPS and
  1     8*     IMU.
  1     9*  2) change(86-05-16,Kissel), approve(86-07-30,MCR7461), audit(86-07-31,Coren),
  1    10*     install(86-08-19,MR12.0-1120):
  1    11*     Changed the value of IOI_DEFAULT_MAX_BOUND from 4096 to 1024.  This
  1    12*     corrects a problem when RCP tries to set the maximum workspace size if it
  1    13*     is less than 4096.  Since ioi_ (actually grab_aste) touched all the pages
  1    14*     at assignment time, the current length is 4, and trying to set the max
  1    15*     length to less than 4 (e.g. because the max unprivileged workspace size in
  1    16*     RCP for a special device is 1) returns an error.
  1    17*                                                   END HISTORY COMMENTS */
  1    18 
  1    19 /* Rewritten May 1982 by C. Hornig for new ioi_ */
  1    20 /* Rewrite finished March 1983 by Chris Jones */
  1    21 /* Extended for reconfiguration April 1983 by Chris Jones. */
  1    22 /* Modified November 1983 by Chris Jones to separate items in the dte protected by different locks. */
  1    23 /* Modified January 1984 by Chris Jones to add ite's. */
  1    24 /* Modified Feb 1984 by Rich Fawcett to add ipc and fips */
  1    25 /* Modified Sept 1985 by Paul Farley to add controller flag to dte. */
  1    26 
  1    27 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    28 
  1    29 dcl	idp		   ptr;			/* pointer to IOI data structure */
  1    30 dcl	gtep		   ptr;			/* pointer to channel/device group entry */
  1    31 dcl	ctep		   ptr;			/* pointer to channel table entry */
  1    32 dcl	dtep		   ptr;			/* pointer to wired device table entry */
  1    33 dcl	itep		   ptr;			/* pointer to I/O multiplexer entry */
  1    34 
  1    35 dcl	(ioi_subsystems, ioi_devices, ioi_channels, ioi_multiplexers)
  1    36 			   fixed bin;
  1    37 dcl	ioi_data$		   external;		/* IOI data segment */
  1    38 
  1    39 
  1    40 dcl	1 ioi_data	   based (idp) aligned,	/* I/O Interfacer data structure */
  1    41 	  2 ngt		   fixed bin,		/* number of groups */
  1    42 	  2 nct		   fixed bin,		/* number of channels */
  1    43 	  2 ndt		   fixed bin,		/* number of devices */
  1    44 	  2 nit		   fixed bin,		/* number of IOMs */
  1    45 	  2 spurious_interrupts
  1    46 			   fixed bin (35),		/* interrupts with no status */
  1    47 	  2 reconfig_lock	   like lock,		/* lock for reconfiguring devices, channels, etc. */
  1    48 	  2 flags,
  1    49 	    3 setup	   bit (1) unal,		/* "1"b => ioi_init has run */
  1    50 	    3 pad1	   bit (35) unal,
  1    51 	  2 rss_idcw	   bit (36),		/* reset status IDCW */
  1    52 	  2 pad2		   (6) fixed bin (35),	/* pad to 16 words */
  1    53 	  2 dt		   (ioi_devices refer (ioi_data.ndt)) like dte aligned,
  1    54 						/* device table */
  1    55 	  2 gt		   (ioi_subsystems refer (ioi_data.ngt)) like gte aligned,
  1    56 						/* channel/device group table */
  1    57 	  2 ct		   (ioi_channels refer (ioi_data.nct)) like cte aligned,
  1    58 						/* channel table */
  1    59 	  2 it		   (ioi_multiplexers refer (ioi_data.nit)) like ite aligned;
  1    60 						/* multiplexer table */
  2     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  2     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  2     3*   encourages name conflicts.
  2     4*   USE HC_FAST_LOCK INSTEAD!
  2     5**/
  2     6 
  2     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     8 
  2     9 /* format: style3 */
  2    10 
  2    11 declare	lock_ptr		pointer;
  2    12 declare	1 lock		aligned based (lock_ptr),
  2    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    15 	  2 flags		aligned,
  2    16 	    3 notify_sw	bit (1) unaligned,
  2    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    18 
  2    19 /* End include file hc_lock.incl.pl1 */
  1    61 
  1    62 
  1    63 dcl	1 ite		   based (itep) aligned,	/* I/O multiplexer table entry */
  1    64 	  2 model		   char (4),		/* which flavor we are */
  1    65 	  2 flags,
  1    66 	  ( 3 deleting	   bit (1),
  1    67 	    3 deleted	   bit (1)
  1    68 	    )		   unaligned,
  1    69 	  2 pad1		   bit (16) unaligned,
  1    70 	  2 iom_table_idx	   fixed bin (17) unaligned,
  1    71 	  2 tag		   fixed bin (3),
  1    72 	  2 pad2		   (5) bit (36);
  1    73 
  1    74 dcl	1 gte		   based (gtep) aligned,	/* channel/device group table entry */
  1    75 	  2 lock		   bit (36),		/* (0) loop lock */
  1    76 	  2 name		   char (4),		/* (1) subsystem name */
  1    77 	  2 dtep		   bit (18) unaligned,	/* (2) rel ptr to device just serviced */
  1    78 	  2 ctep		   bit (18) unaligned,	/* (2) rel ptr to thread of channel table entries */
  1    79 	  2 detailed_status_cmd
  1    80 			   bit (6) unal,		/* (3) idcw command to read detailed status */
  1    81 	  2 flags		   unaligned,		/* (3) */
  1    82 	    3 psia	   bit (1),		/* "1"b if channel is PSIA */
  1    83 	    3 suspend_devices  bit (1),		/* "1"b if device I/O suspended */
  1    84 	    3 dual_controller  bit (1),		/* "1"b if dual controller subsystem (disk only) */
  1    85 	    3 ascii_dtst	   bit (1),		/* "1"b if detailed status sent in ASCII mode */
  1    86 	    3 mplex	   bit (1),		/* "1"b if channels are multiplexed among devices */
  1    87 	    3 ipc		   bit (1),		/* "1"b if devices are on an IMU */
  1    88 	    3 fips	   bit (1),		/* "1"b if devices start at zero */
  1    89 	    3 pad		   bit (23),
  1    90 	  2 n_devices	   fixed bin,		/* (4) number of devices in device table thread */
  1    91 	  2 pending_connects   fixed bin,		/* (5) count of pending connect requests */
  1    92 	  2 io_log_info_index  fixed bin,		/* (6) index into io_log_status_info table */
  1    93 	  2 disk_data_subsystem_idx
  1    94 			   fixed bin;		/* (7) index into disk_data.array for disks */
  1    95 
  1    96 dcl	1 cte		   based (ctep) aligned,	/* channel table entry */
  1    97 	  2 next_ctep	   bit (18) unaligned,	/* (0) rel ptr to next channel table entry */
  1    98 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
  1    99 	  2 flags1	   unaligned,		/* (1) */
  1   100 	    3 ioi_use	   bit (1),		/* "1"b if channel currently being used */
  1   101 	    3 connected	   bit (1),		/* "1"b if channel is connected */
  1   102 	    3 toss_status	   bit (1),		/* "1"b if status is to be ignored */
  1   103 	    3 quiescing	   bit (1),		/* "1"b if the channel is just finishing what it's doing */
  1   104 	    3 direct	   bit (1),		/* "1"b if this is a direct channel */
  1   105 	    3 pad1	   bit (4),
  1   106 	  2 disktab_ctx	   fixed bin (9) uns unal,	/* (1) index into disktab.chantab for this channel */
  1   107 	  2 cur_dtep	   bit (18) unaligned,	/* (1) current device table entry */
  1   108 	  2 chanid	   char (8),		/* (2) io_manager's name for channel */
  1   109 	  2 statusp	   ptr unal,		/* (4) pointer to first word of status */
  1   110 	  2 chx		   fixed bin (35),		/* (5) channel index for io_manager */
  1   111 	  2 time_limit	   fixed bin (71),		/* (6) connect time limit */
  1   112 	  2 saved_status	   unaligned,		/* (8) status repository while reading detailed status */
  1   113 	    3 word1	   bit (36),
  1   114 	    3 word2	   bit (36),
  1   115 	    3 word4	   bit (36),
  1   116 	    3 next_lpw_offset  bit (18),
  1   117 	    3 command	   bit (6),
  1   118 	  2 pad3		   bit (12) unaligned,	/* (11) */
  1   119 	  2 base_ctep	   bit (18) unaligned,	/* (12) rel ptr to base logical chan. of physical chan. */
  1   120 	  2 itep		   bit (18) unaligned,	/* (12) rel ptr to itep */
  1   121 	  2 flags2	   unaligned,		/* (13) */
  1   122 	    3 deleting	   bit (1),		/* "1"b if attempting to delete this channel */
  1   123 	    3 deleted	   bit (1),		/* "1"b if channel deleted */
  1   124 	  2 pad4		   bit (16) unaligned,	/* (13) */
  1   125 	  2 channel_table_idx  fixed bin (17) unaligned,
  1   126 	  2 pad5		   (2) bit (36);		/* (14) pad to 8 word boundary */
  1   127 
  1   128 dcl	1 dte		   based (dtep) aligned,	/* wired device table entry */
  1   129 	  2 next_dtep	   bit (18) unaligned,	/* (0) rel ptr to next entry in thread */
  1   130 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
  1   131 	  2 cur_ctep	   bit (18) unaligned,	/* (1) rel ptr to channel in use */
  1   132 	  2 flags1	   unaligned,		/* (1) flags protected by gte lock */
  1   133 	    3 connected	   bit (1),		/* "1"b if device has a channel */
  1   134 	    3 log_status_cnt   bit (1),		/* "1"b if count in log_status is valid */
  1   135 	    3 reading_detailed_status
  1   136 			   bit (1),		/* "1"b if read of detailed device status in progress */
  1   137 	    3 pad1	   bit (15),
  1   138 	  2 channel_required   char (8),		/* (2) channel name of required channel */
  1   139 	  2 ev_chn	   fixed bin (71),		/* (4) event ID for status wakeups */
  1   140 	  2 workspace_ptr	   ptr,			/* (6) workspace pointer */
  1   141 	  2 workspace_astep	   ptr,			/* (8) workspace ASTE ptr */
  1   142 	  2 workspace_sdw	   fixed bin (71),		/* (10) SDW of workspace segment */
  1   143 	  2 ptp		   ptr,			/* (12) device page table */
  1   144 	  2 max_bound	   fixed bin (19),		/* (14) largest allowable bound of workspace segment */
  1   145 	  2 bound		   fixed bin (19),		/* (15) bound of workspace */
  1   146 	  2 process_id	   bit (36),		/* (16) ID of process owning device */
  1   147 	  2 ring		   fixed bin (3),		/* (17) highest ring allowed to access device */
  1   148 	  2 device	   bit (6) unal,		/* (18) device code */
  1   149 	  2 flags2	   unal,			/* (18) constant or protected by dte lock */
  1   150 	    3 priv	   bit (1),		/* "1"b if privileged user */
  1   151 	    3 in_use	   bit (1),		/* "1"b if device is to be used */
  1   152 	    3 deleting	   bit (1),		/* "1"b if trying to delete this device */
  1   153 	    3 deleted	   bit (1),		/* "1"b if this device is deleted */
  1   154 	    3 suspended	   bit (1),		/* "1"b if device isn't to be used temporarily */
  1   155 	    3 workspace_wired  bit (1),		/* "1"b if workspace is wired */
  1   156               3 direct           bit (1),                   /* "1"b if device is connected to a direct channel */
  1   157 	    3 controller	   bit (1),		/* "1"b if dte for the devices controller */
  1   158 	    3 pad2	   bit (4),
  1   159 	  2 device_table_idx   fixed bin (17) unaligned,
  1   160 	  2 listx		   uns fixed bin (18) unal,	/* (19) DCW list index for connect */
  1   161 	  2 idcw_listx	   uns fixed bin (18) unal,	/* (19) DCW list index of IDCW */
  1   162 	  2 timeout	   fixed bin (35),		/* (20) time limit for I/O completion (usec) */
  1   163 	  2 max_timeout	   fixed bin (35),		/* (21) maximum allowable timeout grace time (usec) */
  1   164 	  2 unwire_time	   fixed bin (71),		/* (22) when to unwire the workspace */
  1   165 	  2 pcw		   bit (36),		/* (24) peripheral control word (PCW) */
  1   166 	  2 status_control,				/* (25) */
  1   167 	    3 status_offset	   fixed bin (18) unsigned unaligned,
  1   168 						/* offset of status queue in user workspace */
  1   169 	    3 status_entries   fixed bin (9) unsigned unaligned,
  1   170 						/* number of entries in status queue */
  1   171 	    3 status_entry_idx fixed bin (9) unsigned unaligned,
  1   172 						/* next entry to be used */
  1   173 	  2 idcw		   bit (36),		/* (26) instruction DCW (KEEP ON EVEN WORD BOUNDARY) */
  1   174 	  2 tdcw		   bit (36),		/* (27) transfer DCW to remainder of list */
  1   175 	  2 special_status	   bit (36),		/* (28) special interrupt status */
  1   176 	  2 lock		   like lock,		/* (29) wait lock */
  1   177 	  2 log_status,				/* (32) */
  1   178 	  ( 3 level	   fixed bin (3) unsigned,
  1   179 	    3 time_out	   bit (1),
  1   180 	    3 type	   bit (2),
  1   181 	    3 command	   bit (6),
  1   182 	    3 count	   fixed bin (6) unsigned,
  1   183 	    3 channel	   bit (18),
  1   184 	    3 status	   bit (36)
  1   185 	    )		   unaligned,
  1   186 	  2 ptx		   fixed bin,		/* (34) index of page table */
  1   187 	  2 active	   bit (1),		/* (35) "1"b if device running or to run */
  1   188 	  2 special_interrupt  bit (1),		/* (36) "1"b if special interrupt received */
  1   189 	  2 detailed_status_valid
  1   190 			   bit (1),		/* (37) "1"b if detailed status read sucessfully */
  1   191 	  2 last_log_time	   fixed bin (71),		/* (38) when status was last logged */
  1   192 	  2 detailed_status	   (8) bit (36),		/* (40) (buffer for reading most recent detailed status */
  1   193 	  2 log_detailed_status
  1   194 			   (8) bit (36);		/* (48) copy of last detailed status logged */
  1   195 
  1   196 /**** Defaults for various I/O parameters */
  1   197 
  1   198 dcl	IOI_DEFAULT_MAX_BOUND  fixed bin (19) static options (constant) init (1024);
  1   199 dcl	IOI_DEFAULT_MAX_TIMEOUT
  1   200 			   fixed bin (35) static options (constant) init (30000000);
  1   201 dcl	IOI_DEFAULT_TIMEOUT	   fixed bin (35) static options (constant) init (30000000);
  1   202 
  1   203 dcl	IO_STATUS_ERROR_MASK   bit (36) static options (constant) init ("370000770000"b3);
  1   204 
  1   205 dcl	IO_CHANNEL_LOCK_TEMPLATE
  1   206 			   char (2) int static options (constant) init ("ch");
  1   207 dcl	IOI_DEVICE_LOCK_EVENT_TEMPLATE
  1   208 			   char (2) static options (constant) init ("dv");
  1   209 
  1   210 /* End of include file ...... ioi_data.incl.pl1 */
      270 
      271 
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      272 
      273 
      274      end ioi_workspace;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.3  ioi_workspace.pl1                 >spec>install>1110>ioi_workspace.pl1
270          1    09/02/86  1552.9  ioi_data.incl.pl1                 >ldd>include>ioi_data.incl.pl1
1-61         2    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
272          3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RW_ACCESS_BIN                   000000 constant        fixed bin(5,0)           initial dcl 3-36 set ref 110*
addr                                                   builtin function         dcl 73 ref 85 85 85 129 129
append$branch                   000020 constant        entry                    external dcl 53 ref 110
baseno                                                 builtin function         dcl 73 ref 85 85 98 129 129
bce_early_ioi_workspace$        000010 external static bit(36)                  dcl 46 set ref 85
code                            000100 automatic       fixed bin(35,0)          dcl 39 in procedure "ioi_workspace" set ref 90* 92
                                                                                  93 110* 112* 115* 133* 135 136 155* 188* 207* 218*
                                                                                  229* 251 251*
code                                   parameter       fixed bin(35,0)          dcl 259 in procedure "quit" ref 256 262
cte                                    based           structure                level 1 dcl 1-96
delentry$dseg                   000022 constant        entry                    external dcl 54 ref 155
dname                           000101 automatic       char(168)                packed unaligned dcl 40 set ref 104* 110* 112* 207*
                                                                                  218*
dseg$                           000012 external static fixed bin(71,0)          array dcl 48 set ref 85 85 129 129
dte                                    based           structure                level 1 dcl 1-128
dtep                            000170 automatic       pointer                  dcl 1-32 set ref 81* 85 90 98 99 100 100 112 115 115
                                                                                  125* 131 131* 133 141 142 143 147 147* 150 155 157
                                                                                  167* 168 176* 182 183 183* 188 188 198* 204 207
                                                                                  217 228 229 229 229 231 231 241 242 243
ename                           000153 automatic       char(32)                 packed unaligned dcl 41 set ref 105* 110* 112* 207*
                                                                                  218*
fixed                                                  builtin function         dcl 73 ref 85 85 98 129 129
flags2                   22(06)        based           structure                level 2 packed packed unaligned dcl 1-128
fs_get$path_name                000024 constant        entry                    external dcl 55 ref 207
get_ptrs_$given_astep           000026 constant        entry                    external dcl 56 ref 100 231
get_ptrs_$given_segno           000030 constant        entry                    external dcl 57 ref 99
get_temp_segment_               000032 constant        entry                    external dcl 58 ref 90
grab_aste$grab_aste_io          000034 constant        entry                    external dcl 59 ref 229
grab_aste$release_io            000036 constant        entry                    external dcl 60 ref 242
gte                                    based           structure                level 1 dcl 1-74
initiate                        000040 constant        entry                    external dcl 61 ref 112
ioi_wire$unwire                 000042 constant        entry                    external dcl 62 ref 131 147 183
ite                                    based           structure                level 1 dcl 1-63
level$get                       000044 constant        entry                    external dcl 63 ref 107 151 185 205
level$set                       000046 constant        entry                    external dcl 64 ref 108 119 152 159 186 191 206 210
                                                                                  261
lock                                   based           structure                level 1 dcl 2-12
max_bound                16            based           fixed bin(19,0)          level 2 dcl 1-128 set ref 115* 188* 228 229*
null                                                   builtin function         dcl 73 ref 141 142 150 157 168 182 204 241 243
p_code                                 parameter       fixed bin(35,0)          dcl 36 set ref 78 82* 93* 122 126* 136* 173 177* 195
                                                                                  199* 262*
p_dtep                                 parameter       pointer                  dcl 37 ref 78 81 122 125 164 167 173 176 195 198
pds$process_dir_name            000014 external static char(32)                 packed unaligned dcl 49 ref 104
rba                             000163 automatic       fixed bin(3,0)           array dcl 42 set ref 217* 218*
release_temp_segment_           000050 constant        entry                    external dcl 65 ref 133
ring                     21            based           fixed bin(3,0)           level 2 dcl 1-128 ref 217
ringbr_$set                     000052 constant        entry                    external dcl 66 ref 218
sdw_util_$get_valid             000054 constant        entry                    external dcl 67 ref 85 129
set$max_length_ptr              000056 constant        entry                    external dcl 68 ref 115 188
slt_manager$get_seg_ptr         000060 constant        entry                    external dcl 69 ref 85 85 129 129
sys_info$service_system         000016 external static bit(1)                   dcl 50 ref 84 128 168 179 201
unique_chars_                   000062 constant        entry                    external dcl 71 ref 105
validation_level                000167 automatic       fixed bin(3,0)           dcl 44 set ref 107* 119* 151* 159* 185* 191* 205*
                                                                                  210* 261*
workspace_astep          10            based           pointer                  level 2 dcl 1-128 set ref 99* 100* 142* 168* 229*
                                                                                  231* 241 242* 243*
workspace_ptr             6            based           pointer                  level 2 dcl 1-128 set ref 85* 90* 98 112* 115* 133*
                                                                                  141* 150 155* 157* 182 188* 204 207* 229*
workspace_sdw            12            based           fixed bin(71,0)          level 2 dcl 1-128 set ref 100* 143* 231*
workspace_segno                 000166 automatic       fixed bin(17,0)          dcl 43 set ref 98* 99*
workspace_wired          22(11)        based           bit(1)                   level 3 packed packed unaligned dcl 1-128 ref 131
                                                                                  147 183

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
IOI_DEFAULT_MAX_BOUND                  internal static fixed bin(19,0)          initial dcl 1-198
IOI_DEFAULT_MAX_TIMEOUT                internal static fixed bin(35,0)          initial dcl 1-199
IOI_DEFAULT_TIMEOUT                    internal static fixed bin(35,0)          initial dcl 1-201
IOI_DEVICE_LOCK_EVENT_TEMPLATE         internal static char(2)                  initial packed unaligned dcl 1-207
IO_CHANNEL_LOCK_TEMPLATE               internal static char(2)                  initial packed unaligned dcl 1-205
IO_STATUS_ERROR_MASK                   internal static bit(36)                  initial packed unaligned dcl 1-203
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
ctep                                   automatic       pointer                  dcl 1-31
gtep                                   automatic       pointer                  dcl 1-30
idp                                    automatic       pointer                  dcl 1-29
ioi_channels                           automatic       fixed bin(17,0)          dcl 1-35
ioi_data                               based           structure                level 1 dcl 1-40
ioi_data$                              external static fixed bin(17,0)          dcl 1-37
ioi_devices                            automatic       fixed bin(17,0)          dcl 1-35
ioi_multiplexers                       automatic       fixed bin(17,0)          dcl 1-35
ioi_subsystems                         automatic       fixed bin(17,0)          dcl 1-35
itep                                   automatic       pointer                  dcl 1-33
lock_ptr                               automatic       pointer                  dcl 2-11

NAMES DECLARED BY EXPLICIT CONTEXT.
QUIT                            001066 constant        label                    dcl 267 set ref 263
create                          000053 constant        entry                    external dcl 78
destroy                         000417 constant        entry                    external dcl 122
grab                            001134 constant        entry                    internal dcl 225 ref 116 190
ioi_workspace                   000041 constant        entry                    external dcl 11
quit                            001220 constant        entry                    internal dcl 256 ref 251
quit_if_error                   001212 constant        entry                    internal dcl 248 ref 111 113 117 156 189 208 219 230
release                         001171 constant        entry                    internal dcl 238 ref 154 170 187
release_aste                    000635 constant        entry                    external dcl 164
set_max_size                    000660 constant        entry                    external dcl 173
set_rb                          000762 constant        entry                    external dcl 195
set_rb_proc                     001067 constant        entry                    internal dcl 214 ref 114 209

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1570        1654    1242        1600
Length      2152    1242        64         261     325           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ioi_workspace                       274 external procedure  is an external procedure.  
set_rb_proc                             internal procedure  shares stack frame of external procedure ioi_workspace.  
grab                                    internal procedure  shares stack frame of external procedure ioi_workspace.  
release                                 internal procedure  shares stack frame of external procedure ioi_workspace.  
quit_if_error                           internal procedure  shares stack frame of external procedure ioi_workspace.  
quit                                    internal procedure  shares stack frame of external procedure ioi_workspace.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ioi_workspace            000100 code                        ioi_workspace
                         000101 dname                       ioi_workspace
                         000153 ename                       ioi_workspace
                         000163 rba                         ioi_workspace
                         000166 workspace_segno             ioi_workspace
                         000167 validation_level            ioi_workspace
                         000170 dtep                        ioi_workspace

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
append$branch                 delentry$dseg                 fs_get$path_name              get_ptrs_$given_astep
get_ptrs_$given_segno         get_temp_segment_             grab_aste$grab_aste_io        grab_aste$release_io
initiate                      ioi_wire$unwire               level$get                     level$set
release_temp_segment_         ringbr_$set                   sdw_util_$get_valid           set$max_length_ptr
slt_manager$get_seg_ptr       unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bce_early_ioi_workspace$      dseg$                         pds$process_dir_name          sys_info$service_system




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000040        76 000046        78 000047        81 000060        82 000064        84 000065        85 000070
     90 000132        92 000160        93 000162        94 000164        98 000165        99 000172       100 000203
    101 000215       104 000216       105 000222       107 000253       108 000263       110 000273       111 000320
    112 000321       113 000365       114 000366       115 000367       116 000403       117 000404       119 000405
    120 000414       122 000415       125 000424       126 000430       128 000431       129 000434       131 000471
    133 000504       135 000532       136 000534       137 000536       141 000537       142 000542       143 000543
    144 000545       147 000546       150 000557       151 000564       152 000573       154 000603       155 000604
    156 000616       157 000617       159 000622       162 000631       164 000632       167 000642       168 000646
    170 000654       171 000655       173 000656       176 000665       177 000671       179 000672       182 000675
    183 000701       185 000712       186 000721       187 000731       188 000732       189 000746       190 000747
    191 000750       193 000757       195 000760       198 000767       199 000773       201 000774       204 000777
    205 001003       206 001011       207 001021       208 001054       209 001055       210 001056       212 001065
    267 001066       214 001067       217 001070       218 001105       219 001132       221 001133       225 001134
    228 001135       229 001140       230 001155       231 001156       234 001170       238 001171       241 001172
    242 001177       243 001206       246 001211       248 001212       251 001213       254 001217       256 001220
    261 001222       262 001231       263 001235


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
