	COMPILATION LISTING OF SEGMENT ioi_usurp_channels
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1109.40_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /*
        9*   Rewritten May 1983 by Chris Jones.
       10*   Modified January 1984 by Chris Jones for IOM reconfiguration.
       11**/
       12 
       13 /* This procedure is responsible for managing the sharing of disk subsystem
       14*   channels between page control and the I/O Interfacer.  When channels are
       15*   needed for IOI operation, they are taken away from page control.  When
       16*   IOI no longer needs the channels, they are given back to page control. */
       17 
       18 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       19 ioi_usurp_channels:
       20      proc;
       21 
       22 dcl	p_code		   fixed bin (35);		/* (O) error code */
       23 dcl	p_ctep		   ptr;			/* (I) pointer to channel table entry */
       24 dcl	p_dtep		   ptr;			/* (I) pointer to device table Entry */
       25 dcl	p_gtep		   ptr;			/* (I) group table entry pointer */
       26 
       27 dcl	ctep_to_retain	   ptr;			/* never cede this channel */
       28 dcl	max_chan_count	   fixed bin;		/* maximum number of channels to use */
       29 dcl	mcp		   ptr;			/* pointer to MPC config card */
       30 dcl	required		   bit (1) aligned;		/* "1"b if specific channel required */
       31 dcl	statusp		   ptr;			/* pointer to where io_manager stuffs status */
       32 dcl	used_chan_count	   fixed bin;		/* count of channels in use by IOI */
       33 dcl	usurped		   bit (1) aligned;		/* "1"b if channel successfully usurped */
       34 
       35 dcl	config$find_2	   entry (char (4) aligned, char (4) aligned, ptr);
       36 dcl	disk_control$usurp_channel
       37 			   entry (fixed bin (8), fixed bin (35), bit (1) aligned, fixed bin (35), ptr);
       38 dcl	disk_control$cede_channel
       39 			   entry (fixed bin (8), fixed bin (35), fixed bin (35), ptr);
       40 dcl	ioi_config$find_controller_card
       41 			   entry (char (8) aligned) returns (ptr);
       42 dcl	ioi_masked$getwork_channel
       43 			   entry (ptr);
       44 dcl	ioi_masked$quiesce_channel
       45 			   entry (ptr);
       46 dcl	error_table_$no_operation
       47 			   fixed bin (35) ext;
       48 
       49 dcl	(max, min, null, ptr, rel)
       50 			   builtin;
       51 
       52 assign:
       53      entry (p_gtep, p_code);				/* entry to usurp enough channels */
       54 
       55 	p_code = 0;
       56 	gtep = p_gtep;
       57 	required = "0"b;				/* we'll take any channel */
       58 
       59 	used_chan_count = cur_chans ();		/* get count of channels currently usurped */
       60 	max_chan_count = max_chans ();		/* get maximum number to usurp */
       61 	do while (used_chan_count < max_chan_count);	/* try to usurp enough channels */
       62 	     usurped = "0"b;			/* no channel usurped as yet */
       63 	     call walk_channels (usurp_unused);		/* usurp an unused channel */
       64 	     if ^usurped then
       65 		max_chan_count = 0;			/* stop if no usurpable channel usurped */
       66 	end;
       67 
       68 	if (used_chan_count <= 0) & (gte.n_devices > 0) then
       69 						/* if no channel was found ... */
       70 	     p_code = error_table_$no_operation;
       71 	return;
       72 
       73 /* Routine to usurp exactly one channel.  It is called by walk_channels, and only usurps if no channel has been
       74*   usurped during this walk (i.e. if the variable "usurped" isn't set). */
       75 
       76 usurp_unused:
       77      proc;
       78 
       79 	if ^usurped then				/* if no channel usurped as yet ... */
       80 	     if ^(cte.ioi_use | cte.deleted | cte.deleting) then
       81 						/* if channel not already in use ... */
       82 		call usurp_chan;			/* try to grab it */
       83 
       84      end usurp_unused;
       85 
       86 
       87 /* Entry to cede channels back to disk control when a channel is unassigned. */
       88 
       89 unassign:
       90      entry (p_gtep, p_code);
       91 
       92 	ctep_to_retain = null ();
       93 	p_code = 0;
       94 	gtep = p_gtep;
       95 	if gte.suspend_devices then
       96 	     return;				/* cannot cede channels if controller suspended */
       97 
       98 unassign_join:
       99 	used_chan_count = cur_chans ();		/* get count of channels currently usurped */
      100 	max_chan_count = max_chans ();		/* get maximum number to usurp */
      101 	do while (used_chan_count > max_chan_count);	/* give back excess channels */
      102 	     usurped = "1"b;			/* no cedable channel ceded as yet */
      103 	     call walk_channels (cede_used);		/* give back one used channel */
      104 	     if usurped then
      105 		return;				/* return if no candidate found */
      106 	end;
      107 
      108 	return;
      109 
      110 /* Routine to cede exactly one cedable channel.  It works like "usurped_unused", only backwards. */
      111 cede_used:
      112      proc;
      113 
      114 	if (ctep ^= ctep_to_retain)			/* if not holding on to this channel */
      115 	     & usurped				/* if no channel ceded as yet ... */
      116 	     & cte.ioi_use				/* if this channel is in use ... */
      117 	     & ^(cte.deleted | cte.deleting)		/* ...for real */
      118 	     & (^test_chan_req ()) then do;		/* if no device requires this channel ... */
      119 	     call cede_chan;			/* give up the channel */
      120 	     usurped = "0"b;			/* found channel to cede */
      121 	end;
      122 
      123 test_chan_req:
      124 	proc returns (bit (1) aligned);		/* internal proc to see if channel required */
      125 
      126 dcl	chan_req		   bit (1) aligned;
      127 
      128 	     chan_req = "0"b;			/* set if some device requires this channel */
      129 	     call walk_devices (test_req);		/* test each device */
      130 	     return (chan_req);
      131 
      132 /* sets chan_req if the given channel is required by the given device (where the given entities are pointed to
      133*   by ctep and dtep respectively). */
      134 
      135 test_req:
      136 	     proc;
      137 
      138 		if dte.channel_required = cte.chanid then
      139 		     chan_req = "1"b;		/* set bit if channel is required */
      140 
      141 	     end test_req;
      142 
      143 	end test_chan_req;
      144 
      145      end cede_used;
      146 
      147 /* Entry to usurp a given channel. */
      148 
      149 required:
      150      entry (p_ctep, p_code);
      151 
      152 	p_code = 0;
      153 	ctep = p_ctep;
      154 
      155 	gtep = ptr (ctep, cte.gtep);			/* get pointer to group table entry */
      156 	if gte.suspend_devices then do;		/* cannot do this if controller suspended */
      157 	     p_code = error_table_$no_operation;
      158 	     return;
      159 	end;
      160 
      161 	required = "1"b;				/* we need this specific channel */
      162 	usurped = "0"b;
      163 	do while (^usurped);
      164 	     ctep = p_ctep;				/* grab desired channel, now */
      165 	     call usurp_chan;
      166 
      167 	     if ^usurped then do;			/* if we did not get desired channel ... */
      168 		if cte.deleting then do;		/* can't give any back since we're about to lose this one */
      169 		     p_code = error_table_$no_operation;
      170 		     return;
      171 		end;
      172 		usurped = "1"b;			/* no channel to cede found yet */
      173 		call walk_channels (cede_used);	/* cede one channel */
      174 		if usurped then do;			/* if no other candidate for ceding ... */
      175 		     p_code = error_table_$no_operation;
      176 		     return;
      177 		end;
      178 	     end;					/* now try again */
      179 	end;
      180 
      181 	ctep_to_retain = ctep;
      182 	goto unassign_join;				/* cede excess channels */
      183 /****	never returns	****/
      184 
      185 
      186 ioi_usurp_channels$suspend:
      187      entry (p_dtep, p_gtep, p_code);
      188 
      189 	p_code = 0;
      190 	dtep = p_dtep;
      191 	gtep = p_gtep;
      192 	required = "1"b;				/* specific channels are required */
      193 
      194 	mcp = ioi_config$find_controller_card (dte.channel_required);
      195 						/* Get pointer to MPC card for this channel. */
      196 
      197 	if test_other_controller () then do;		/* No channels may be required for other controller. */
      198 	     p_code = error_table_$no_operation;
      199 	     return;
      200 	end;
      201 
      202 	call walk_channels (usurp_controller);		/* Grab all channels on this controller. */
      203 
      204 	return;
      205 
      206 
      207 
      208 test_other_controller:
      209      proc returns (bit (1) aligned);
      210 
      211 dcl	other_controller	   bit (1) aligned init ("0"b);
      212 						/* set to "1"b if channel on other controller required */
      213 
      214 
      215 	call walk_devices (test_controller);		/* See if any device requires other controller. */
      216 
      217 	return (other_controller);			/* Return bit setting. */
      218 
      219 
      220 
      221 test_controller:
      222 	proc;
      223 
      224 	     if dte.channel_required ^= "" then		/* If this device requires a channel ... */
      225 		if mcp ^= ioi_config$find_controller_card (dte.channel_required) then
      226 		     other_controller = "1"b;		/* Channel should be on same controller. */
      227 
      228 	     return;
      229 
      230 
      231 	end test_controller;
      232 
      233      end test_other_controller;
      234 
      235 
      236 usurp_controller:
      237      proc;
      238 
      239 dcl	same_controller	   bit (1) aligned;		/* "1"b if two channels share same MPC */
      240 
      241 	same_controller = (mcp = ioi_config$find_controller_card (cte.chanid));
      242 
      243 	if cte.ioi_use then				/* If channel already in use ... */
      244 	     if ^same_controller then			/* If channel on another MPC ... */
      245 		call cede_chan;			/* Give it up. */
      246 	     else ;
      247 	else					/* If channel not in use ... */
      248 	     if same_controller & ^cte.deleted then do;	/* If channel on this MPC ... */
      249 	     call usurp_chan;			/* Usurp it now. */
      250 	     if ^usurped then
      251 		goto suspend_failure;		/* Abort everything if channel not available. */
      252 	end;
      253 
      254 	return;
      255 
      256 
      257      end usurp_controller;
      258 
      259 
      260 
      261 suspend_failure:
      262 	call unassign (gtep, p_code);			/* Adjust usurped channels properly. */
      263 
      264 	p_code = error_table_$no_operation;		/* Couldn't get desired channel on controller. */
      265 
      266 	return;
      267 
      268 
      269 max_chans:
      270      proc returns (fixed bin);
      271 
      272 	call config$find_2 ("udsk", gte.name, udsk_cardp);/* Search for UDSK card. */
      273 	if udsk_cardp ^= null () then			/* If card found ... */
      274 	     return (min (max (udsk_card.nchan, 1), gte.n_devices));
      275 						/* Allow at least one channel. */
      276 	else					/* Otherwise ... */
      277 	     return (min (gte.n_devices, 1));		/* Usurp only one channel. */
      278 
      279 
      280      end max_chans;
      281 
      282 
      283 
      284 cur_chans:
      285      proc returns (fixed bin);
      286 
      287 dcl	count		   fixed bin;		/* count of usurped channels */
      288 
      289 
      290 	count = 0;				/* Initialize count. */
      291 
      292 	call walk_channels (count_used);		/* Count all usurped channels. */
      293 
      294 	return (count);				/* And return the count. */
      295 
      296 
      297 
      298 count_used:
      299 	proc;
      300 
      301 	     if cte.ioi_use then			/* Count surped channels. */
      302 		count = count + 1;
      303 
      304 
      305 	end count_used;
      306 
      307      end cur_chans;
      308 
      309 
      310 walk_channels:
      311      proc (examine_channel);
      312 
      313 dcl	examine_channel	   entry;
      314 
      315 	do ctep = ptr (gtep, gte.ctep) repeat ptr (gtep, cte.next_ctep) while (rel (ctep) ^= ""b);
      316 	     call examine_channel;			/* check out channel. */
      317 	end;
      318 
      319      end walk_channels;
      320 
      321 walk_devices:
      322      proc (examine_device);
      323 
      324 dcl	examine_device	   entry;
      325 
      326 dcl	done		   bit (1) aligned;
      327 dcl	list_head		   bit (18);
      328 
      329 	done = "0"b;
      330 	list_head = gte.dtep;
      331 	do dtep = ptr (gtep, list_head) repeat ptr (gtep, dte.next_dtep) while (^done);
      332 	     call examine_device;			/* check out device. */
      333 	     done = (dte.next_dtep = list_head);
      334 	end;
      335 
      336      end walk_devices;
      337 
      338 
      339 usurp_chan:
      340      proc;
      341 
      342 	call disk_control$usurp_channel ((gte.disk_data_subsystem_idx), (cte.disktab_ctx), required, cte.chx, statusp);
      343 						/* Take channel from disk control. */
      344 	usurped = (cte.chx ^= 0);
      345 	if ^usurped then
      346 	     return;				/* Return now if channel not usurped. */
      347 
      348 	cte.statusp = statusp;
      349 	cte.ioi_use = "1"b;				/* Place channel in use for IOI. */
      350 	used_chan_count = used_chan_count + 1;		/* Keep track of count. */
      351 	call ioi_masked$getwork_channel (ctep);		/* use the channel if possible */
      352 
      353      end usurp_chan;
      354 
      355 
      356 
      357 cede_chan:
      358      proc;					/* internal procedure to return disk channel */
      359 
      360 
      361 	call ioi_masked$quiesce_channel (ctep);
      362 	do while (cte.connected | cte.quiescing);	/* Wait for channel to stop. */
      363 	end;
      364 	cte.ioi_use = "0"b;				/* Take channel away from IOI. */
      365 	used_chan_count = used_chan_count - 1;		/* Keep track of count. */
      366 
      367 	call disk_control$cede_channel ((gte.disk_data_subsystem_idx), (cte.disktab_ctx), cte.chx, (cte.statusp));
      368 						/* Give channel back to disk control. */
      369 
      370      end cede_chan;
      371 
  1     1 /* Begin include file ...... ioi_data.incl.pl1 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1     6*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  1     7*     Support for FIPS and
  1     8*     IMU.
  1     9*  2) change(86-05-16,Kissel), approve(86-07-30,MCR7461), audit(86-07-31,Coren),
  1    10*     install(86-08-19,MR12.0-1120):
  1    11*     Changed the value of IOI_DEFAULT_MAX_BOUND from 4096 to 1024.  This
  1    12*     corrects a problem when RCP tries to set the maximum workspace size if it
  1    13*     is less than 4096.  Since ioi_ (actually grab_aste) touched all the pages
  1    14*     at assignment time, the current length is 4, and trying to set the max
  1    15*     length to less than 4 (e.g. because the max unprivileged workspace size in
  1    16*     RCP for a special device is 1) returns an error.
  1    17*                                                   END HISTORY COMMENTS */
  1    18 
  1    19 /* Rewritten May 1982 by C. Hornig for new ioi_ */
  1    20 /* Rewrite finished March 1983 by Chris Jones */
  1    21 /* Extended for reconfiguration April 1983 by Chris Jones. */
  1    22 /* Modified November 1983 by Chris Jones to separate items in the dte protected by different locks. */
  1    23 /* Modified January 1984 by Chris Jones to add ite's. */
  1    24 /* Modified Feb 1984 by Rich Fawcett to add ipc and fips */
  1    25 /* Modified Sept 1985 by Paul Farley to add controller flag to dte. */
  1    26 
  1    27 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    28 
  1    29 dcl	idp		   ptr;			/* pointer to IOI data structure */
  1    30 dcl	gtep		   ptr;			/* pointer to channel/device group entry */
  1    31 dcl	ctep		   ptr;			/* pointer to channel table entry */
  1    32 dcl	dtep		   ptr;			/* pointer to wired device table entry */
  1    33 dcl	itep		   ptr;			/* pointer to I/O multiplexer entry */
  1    34 
  1    35 dcl	(ioi_subsystems, ioi_devices, ioi_channels, ioi_multiplexers)
  1    36 			   fixed bin;
  1    37 dcl	ioi_data$		   external;		/* IOI data segment */
  1    38 
  1    39 
  1    40 dcl	1 ioi_data	   based (idp) aligned,	/* I/O Interfacer data structure */
  1    41 	  2 ngt		   fixed bin,		/* number of groups */
  1    42 	  2 nct		   fixed bin,		/* number of channels */
  1    43 	  2 ndt		   fixed bin,		/* number of devices */
  1    44 	  2 nit		   fixed bin,		/* number of IOMs */
  1    45 	  2 spurious_interrupts
  1    46 			   fixed bin (35),		/* interrupts with no status */
  1    47 	  2 reconfig_lock	   like lock,		/* lock for reconfiguring devices, channels, etc. */
  1    48 	  2 flags,
  1    49 	    3 setup	   bit (1) unal,		/* "1"b => ioi_init has run */
  1    50 	    3 pad1	   bit (35) unal,
  1    51 	  2 rss_idcw	   bit (36),		/* reset status IDCW */
  1    52 	  2 pad2		   (6) fixed bin (35),	/* pad to 16 words */
  1    53 	  2 dt		   (ioi_devices refer (ioi_data.ndt)) like dte aligned,
  1    54 						/* device table */
  1    55 	  2 gt		   (ioi_subsystems refer (ioi_data.ngt)) like gte aligned,
  1    56 						/* channel/device group table */
  1    57 	  2 ct		   (ioi_channels refer (ioi_data.nct)) like cte aligned,
  1    58 						/* channel table */
  1    59 	  2 it		   (ioi_multiplexers refer (ioi_data.nit)) like ite aligned;
  1    60 						/* multiplexer table */
  2     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  2     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  2     3*   encourages name conflicts.
  2     4*   USE HC_FAST_LOCK INSTEAD!
  2     5**/
  2     6 
  2     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     8 
  2     9 /* format: style3 */
  2    10 
  2    11 declare	lock_ptr		pointer;
  2    12 declare	1 lock		aligned based (lock_ptr),
  2    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    15 	  2 flags		aligned,
  2    16 	    3 notify_sw	bit (1) unaligned,
  2    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    18 
  2    19 /* End include file hc_lock.incl.pl1 */
  1    61 
  1    62 
  1    63 dcl	1 ite		   based (itep) aligned,	/* I/O multiplexer table entry */
  1    64 	  2 model		   char (4),		/* which flavor we are */
  1    65 	  2 flags,
  1    66 	  ( 3 deleting	   bit (1),
  1    67 	    3 deleted	   bit (1)
  1    68 	    )		   unaligned,
  1    69 	  2 pad1		   bit (16) unaligned,
  1    70 	  2 iom_table_idx	   fixed bin (17) unaligned,
  1    71 	  2 tag		   fixed bin (3),
  1    72 	  2 pad2		   (5) bit (36);
  1    73 
  1    74 dcl	1 gte		   based (gtep) aligned,	/* channel/device group table entry */
  1    75 	  2 lock		   bit (36),		/* (0) loop lock */
  1    76 	  2 name		   char (4),		/* (1) subsystem name */
  1    77 	  2 dtep		   bit (18) unaligned,	/* (2) rel ptr to device just serviced */
  1    78 	  2 ctep		   bit (18) unaligned,	/* (2) rel ptr to thread of channel table entries */
  1    79 	  2 detailed_status_cmd
  1    80 			   bit (6) unal,		/* (3) idcw command to read detailed status */
  1    81 	  2 flags		   unaligned,		/* (3) */
  1    82 	    3 psia	   bit (1),		/* "1"b if channel is PSIA */
  1    83 	    3 suspend_devices  bit (1),		/* "1"b if device I/O suspended */
  1    84 	    3 dual_controller  bit (1),		/* "1"b if dual controller subsystem (disk only) */
  1    85 	    3 ascii_dtst	   bit (1),		/* "1"b if detailed status sent in ASCII mode */
  1    86 	    3 mplex	   bit (1),		/* "1"b if channels are multiplexed among devices */
  1    87 	    3 ipc		   bit (1),		/* "1"b if devices are on an IMU */
  1    88 	    3 fips	   bit (1),		/* "1"b if devices start at zero */
  1    89 	    3 pad		   bit (23),
  1    90 	  2 n_devices	   fixed bin,		/* (4) number of devices in device table thread */
  1    91 	  2 pending_connects   fixed bin,		/* (5) count of pending connect requests */
  1    92 	  2 io_log_info_index  fixed bin,		/* (6) index into io_log_status_info table */
  1    93 	  2 disk_data_subsystem_idx
  1    94 			   fixed bin;		/* (7) index into disk_data.array for disks */
  1    95 
  1    96 dcl	1 cte		   based (ctep) aligned,	/* channel table entry */
  1    97 	  2 next_ctep	   bit (18) unaligned,	/* (0) rel ptr to next channel table entry */
  1    98 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
  1    99 	  2 flags1	   unaligned,		/* (1) */
  1   100 	    3 ioi_use	   bit (1),		/* "1"b if channel currently being used */
  1   101 	    3 connected	   bit (1),		/* "1"b if channel is connected */
  1   102 	    3 toss_status	   bit (1),		/* "1"b if status is to be ignored */
  1   103 	    3 quiescing	   bit (1),		/* "1"b if the channel is just finishing what it's doing */
  1   104 	    3 direct	   bit (1),		/* "1"b if this is a direct channel */
  1   105 	    3 pad1	   bit (4),
  1   106 	  2 disktab_ctx	   fixed bin (9) uns unal,	/* (1) index into disktab.chantab for this channel */
  1   107 	  2 cur_dtep	   bit (18) unaligned,	/* (1) current device table entry */
  1   108 	  2 chanid	   char (8),		/* (2) io_manager's name for channel */
  1   109 	  2 statusp	   ptr unal,		/* (4) pointer to first word of status */
  1   110 	  2 chx		   fixed bin (35),		/* (5) channel index for io_manager */
  1   111 	  2 time_limit	   fixed bin (71),		/* (6) connect time limit */
  1   112 	  2 saved_status	   unaligned,		/* (8) status repository while reading detailed status */
  1   113 	    3 word1	   bit (36),
  1   114 	    3 word2	   bit (36),
  1   115 	    3 word4	   bit (36),
  1   116 	    3 next_lpw_offset  bit (18),
  1   117 	    3 command	   bit (6),
  1   118 	  2 pad3		   bit (12) unaligned,	/* (11) */
  1   119 	  2 base_ctep	   bit (18) unaligned,	/* (12) rel ptr to base logical chan. of physical chan. */
  1   120 	  2 itep		   bit (18) unaligned,	/* (12) rel ptr to itep */
  1   121 	  2 flags2	   unaligned,		/* (13) */
  1   122 	    3 deleting	   bit (1),		/* "1"b if attempting to delete this channel */
  1   123 	    3 deleted	   bit (1),		/* "1"b if channel deleted */
  1   124 	  2 pad4		   bit (16) unaligned,	/* (13) */
  1   125 	  2 channel_table_idx  fixed bin (17) unaligned,
  1   126 	  2 pad5		   (2) bit (36);		/* (14) pad to 8 word boundary */
  1   127 
  1   128 dcl	1 dte		   based (dtep) aligned,	/* wired device table entry */
  1   129 	  2 next_dtep	   bit (18) unaligned,	/* (0) rel ptr to next entry in thread */
  1   130 	  2 gtep		   bit (18) unaligned,	/* (0) rel ptr to channel/device group table entry */
  1   131 	  2 cur_ctep	   bit (18) unaligned,	/* (1) rel ptr to channel in use */
  1   132 	  2 flags1	   unaligned,		/* (1) flags protected by gte lock */
  1   133 	    3 connected	   bit (1),		/* "1"b if device has a channel */
  1   134 	    3 log_status_cnt   bit (1),		/* "1"b if count in log_status is valid */
  1   135 	    3 reading_detailed_status
  1   136 			   bit (1),		/* "1"b if read of detailed device status in progress */
  1   137 	    3 pad1	   bit (15),
  1   138 	  2 channel_required   char (8),		/* (2) channel name of required channel */
  1   139 	  2 ev_chn	   fixed bin (71),		/* (4) event ID for status wakeups */
  1   140 	  2 workspace_ptr	   ptr,			/* (6) workspace pointer */
  1   141 	  2 workspace_astep	   ptr,			/* (8) workspace ASTE ptr */
  1   142 	  2 workspace_sdw	   fixed bin (71),		/* (10) SDW of workspace segment */
  1   143 	  2 ptp		   ptr,			/* (12) device page table */
  1   144 	  2 max_bound	   fixed bin (19),		/* (14) largest allowable bound of workspace segment */
  1   145 	  2 bound		   fixed bin (19),		/* (15) bound of workspace */
  1   146 	  2 process_id	   bit (36),		/* (16) ID of process owning device */
  1   147 	  2 ring		   fixed bin (3),		/* (17) highest ring allowed to access device */
  1   148 	  2 device	   bit (6) unal,		/* (18) device code */
  1   149 	  2 flags2	   unal,			/* (18) constant or protected by dte lock */
  1   150 	    3 priv	   bit (1),		/* "1"b if privileged user */
  1   151 	    3 in_use	   bit (1),		/* "1"b if device is to be used */
  1   152 	    3 deleting	   bit (1),		/* "1"b if trying to delete this device */
  1   153 	    3 deleted	   bit (1),		/* "1"b if this device is deleted */
  1   154 	    3 suspended	   bit (1),		/* "1"b if device isn't to be used temporarily */
  1   155 	    3 workspace_wired  bit (1),		/* "1"b if workspace is wired */
  1   156               3 direct           bit (1),                   /* "1"b if device is connected to a direct channel */
  1   157 	    3 controller	   bit (1),		/* "1"b if dte for the devices controller */
  1   158 	    3 pad2	   bit (4),
  1   159 	  2 device_table_idx   fixed bin (17) unaligned,
  1   160 	  2 listx		   uns fixed bin (18) unal,	/* (19) DCW list index for connect */
  1   161 	  2 idcw_listx	   uns fixed bin (18) unal,	/* (19) DCW list index of IDCW */
  1   162 	  2 timeout	   fixed bin (35),		/* (20) time limit for I/O completion (usec) */
  1   163 	  2 max_timeout	   fixed bin (35),		/* (21) maximum allowable timeout grace time (usec) */
  1   164 	  2 unwire_time	   fixed bin (71),		/* (22) when to unwire the workspace */
  1   165 	  2 pcw		   bit (36),		/* (24) peripheral control word (PCW) */
  1   166 	  2 status_control,				/* (25) */
  1   167 	    3 status_offset	   fixed bin (18) unsigned unaligned,
  1   168 						/* offset of status queue in user workspace */
  1   169 	    3 status_entries   fixed bin (9) unsigned unaligned,
  1   170 						/* number of entries in status queue */
  1   171 	    3 status_entry_idx fixed bin (9) unsigned unaligned,
  1   172 						/* next entry to be used */
  1   173 	  2 idcw		   bit (36),		/* (26) instruction DCW (KEEP ON EVEN WORD BOUNDARY) */
  1   174 	  2 tdcw		   bit (36),		/* (27) transfer DCW to remainder of list */
  1   175 	  2 special_status	   bit (36),		/* (28) special interrupt status */
  1   176 	  2 lock		   like lock,		/* (29) wait lock */
  1   177 	  2 log_status,				/* (32) */
  1   178 	  ( 3 level	   fixed bin (3) unsigned,
  1   179 	    3 time_out	   bit (1),
  1   180 	    3 type	   bit (2),
  1   181 	    3 command	   bit (6),
  1   182 	    3 count	   fixed bin (6) unsigned,
  1   183 	    3 channel	   bit (18),
  1   184 	    3 status	   bit (36)
  1   185 	    )		   unaligned,
  1   186 	  2 ptx		   fixed bin,		/* (34) index of page table */
  1   187 	  2 active	   bit (1),		/* (35) "1"b if device running or to run */
  1   188 	  2 special_interrupt  bit (1),		/* (36) "1"b if special interrupt received */
  1   189 	  2 detailed_status_valid
  1   190 			   bit (1),		/* (37) "1"b if detailed status read sucessfully */
  1   191 	  2 last_log_time	   fixed bin (71),		/* (38) when status was last logged */
  1   192 	  2 detailed_status	   (8) bit (36),		/* (40) (buffer for reading most recent detailed status */
  1   193 	  2 log_detailed_status
  1   194 			   (8) bit (36);		/* (48) copy of last detailed status logged */
  1   195 
  1   196 /**** Defaults for various I/O parameters */
  1   197 
  1   198 dcl	IOI_DEFAULT_MAX_BOUND  fixed bin (19) static options (constant) init (1024);
  1   199 dcl	IOI_DEFAULT_MAX_TIMEOUT
  1   200 			   fixed bin (35) static options (constant) init (30000000);
  1   201 dcl	IOI_DEFAULT_TIMEOUT	   fixed bin (35) static options (constant) init (30000000);
  1   202 
  1   203 dcl	IO_STATUS_ERROR_MASK   bit (36) static options (constant) init ("370000770000"b3);
  1   204 
  1   205 dcl	IO_CHANNEL_LOCK_TEMPLATE
  1   206 			   char (2) int static options (constant) init ("ch");
  1   207 dcl	IOI_DEVICE_LOCK_EVENT_TEMPLATE
  1   208 			   char (2) static options (constant) init ("dv");
  1   209 
  1   210 /* End of include file ...... ioi_data.incl.pl1 */
      372 
      373 
  3     1 /* BEGIN INCLUDE FILE ... config_udsk_card.incl.pl1 ... 11/27/80 W. Olin Sibert */
  3     2 
  3     3 dcl  udsk_cardp pointer;				/* pointer to UDSK card */
  3     4 
  3     5 dcl 1 udsk_card aligned based (udsk_cardp),		/* UDSK card declaration */
  3     6     2 word char (4),				/* "udsk" */
  3     7     2 subsystem char (4),				/* Name of disk subsystem */
  3     8     2 nchan fixed bin,				/* Max number of channels usable by ioi */
  3     9 
  3    10     2 group (6),					/* Groups of drives available for ioi use */
  3    11       3 drive fixed bin,				/* Index of first drive in group */
  3    12       3 ndrives fixed bin,				/* Number of drives in group */
  3    13 
  3    14     2 type_word aligned,
  3    15       3 field_type (14) bit (2) unaligned,		/* type of each field; see config_deck.incl.pl1 */
  3    16       3 pad1 bit (4) unaligned,
  3    17       3 n_fields fixed bin (4) unsigned unaligned;	/* number of fields used on card */
  3    18 
  3    19 dcl 1 udsk_card_array aligned based (udsk_cardp),		/* Overlay for counting drive groups */
  3    20     2 pad (3) bit (36) aligned,
  3    21     2 group (divide (max (0, udsk_card.n_fields - 2), 2, 17, 0)),
  3    22       3 drive fixed bin,				/* Index of first drive in group */
  3    23       3 ndrives fixed bin;				/* Number of drives in group */
  3    24 
  3    25 dcl  UDSK_CARD_WORD char (4) aligned internal static options (constant) init ("udsk");
  3    26 
  3    27 /* END INCLUDE FILE ... config_udsk_card.incl.pl1 */
      374 
      375 
      376      end ioi_usurp_channels;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1109.4  ioi_usurp_channels.pl1            >udd>sm>ds>w>ml>ioi_usurp_channels.pl1
372          1    09/02/86  1652.9  ioi_data.incl.pl1                 >ldd>incl>ioi_data.incl.pl1
1-61         2    01/06/85  1522.1  hc_lock.incl.pl1                  >ldd>incl>hc_lock.incl.pl1
374          3    05/08/81  1953.7  config_udsk_card.incl.pl1         >ldd>incl>config_udsk_card.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
chan_req                        000106 automatic       bit(1)                   dcl 126 set ref 128* 130 138*
chanid                    2            based           char(8)                  level 2 dcl 1-96 set ref 138 241*
channel_required          2            based           char(8)                  level 2 dcl 1-128 set ref 138 194* 224 224*
chx                       5            based           fixed bin(35,0)          level 2 dcl 1-96 set ref 342* 344 367*
config$find_2                   000010 constant        entry                    external dcl 35 ref 272
connected                 1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-96 ref 362
count                           000154 automatic       fixed bin(17,0)          dcl 287 set ref 290* 294 301* 301
cte                                    based           structure                level 1 dcl 1-96
ctep                      2(18)        based           bit(18)                  level 2 in structure "gte" packed packed unaligned
                                                                                  dcl 1-74 in procedure "ioi_usurp_channels" ref 315
ctep                            000116 automatic       pointer                  dcl 1-31 in procedure "ioi_usurp_channels" set ref
                                                                                  79 79 79 114 114 114 114 138 153* 155 155 164* 168
                                                                                  181 241 243 247 301 315* 315* 317 342 342 344 348
                                                                                  349 351* 361* 362 362 364 367 367 367
ctep_to_retain                  000100 automatic       pointer                  dcl 27 set ref 92* 114 181*
deleted                  15(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-96 ref 79 114
                                                                                  247
deleting                 15            based           bit(1)                   level 3 packed packed unaligned dcl 1-96 ref 79 114
                                                                                  168
disk_control$cede_channel       000014 constant        entry                    external dcl 38 ref 367
disk_control$usurp_channel      000012 constant        entry                    external dcl 36 ref 342
disk_data_subsystem_idx
                          7            based           fixed bin(17,0)          level 2 dcl 1-74 ref 342 367
disktab_ctx               1(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 1-96
                                                                                  ref 342 367
done                            000100 automatic       bit(1)                   dcl 326 set ref 329* 331 333*
dte                                    based           structure                level 1 dcl 1-128
dtep                      2            based           bit(18)                  level 2 in structure "gte" packed packed unaligned
                                                                                  dcl 1-74 in procedure "ioi_usurp_channels" ref 330
dtep                            000120 automatic       pointer                  dcl 1-32 in procedure "ioi_usurp_channels" set ref
                                                                                  138 190* 194 224 224 331* 333* 334*
error_table_$no_operation       000024 external static fixed bin(35,0)          dcl 46 ref 68 157 169 175 198 264
examine_channel                        parameter       entry variable           dcl 313 ref 310 316
examine_device                         parameter       entry variable           dcl 324 ref 321 332
flags                     3(06)        based           structure                level 2 packed packed unaligned dcl 1-74
flags1                    1            based           structure                level 2 packed packed unaligned dcl 1-96
flags2                   15            based           structure                level 2 packed packed unaligned dcl 1-96
gte                                    based           structure                level 1 dcl 1-74
gtep                            000114 automatic       pointer                  dcl 1-30 in procedure "ioi_usurp_channels" set ref
                                                                                  56* 68 94* 95 155* 156 191* 261* 272 273 276 315
                                                                                  315 317 330 331 334 342 367
gtep                      0(18)        based           bit(18)                  level 2 in structure "cte" packed packed unaligned
                                                                                  dcl 1-96 in procedure "ioi_usurp_channels" ref 155
ioi_config$find_controller_card 000016 constant        entry                    external dcl 40 ref 194 224 241
ioi_masked$getwork_channel      000020 constant        entry                    external dcl 42 ref 351
ioi_masked$quiesce_channel      000022 constant        entry                    external dcl 44 ref 361
ioi_use                   1            based           bit(1)                   level 3 packed packed unaligned dcl 1-96 set ref 79
                                                                                  114 243 301 349* 364*
ite                                    based           structure                level 1 dcl 1-63
list_head                       000101 automatic       bit(18)                  packed unaligned dcl 327 set ref 330* 331 333
lock                                   based           structure                level 1 dcl 2-12
max                                                    builtin function         dcl 49 ref 273
max_chan_count                  000102 automatic       fixed bin(17,0)          dcl 28 set ref 60* 61 64* 100* 101
mcp                             000104 automatic       pointer                  dcl 29 set ref 194* 224 241
min                                                    builtin function         dcl 49 ref 273 276
n_devices                 4            based           fixed bin(17,0)          level 2 dcl 1-74 ref 68 273 276
name                      1            based           char(4)                  level 2 dcl 1-74 set ref 272*
nchan                     2            based           fixed bin(17,0)          level 2 dcl 3-5 ref 273
next_ctep                              based           bit(18)                  level 2 packed packed unaligned dcl 1-96 ref 317
next_dtep                              based           bit(18)                  level 2 packed packed unaligned dcl 1-128 ref 333
                                                                                  334
null                                                   builtin function         dcl 49 ref 92 273
other_controller                000136 automatic       bit(1)                   initial dcl 211 set ref 211* 217 224*
p_code                                 parameter       fixed bin(35,0)          dcl 22 set ref 52 55* 68* 89 93* 149 152* 157* 169*
                                                                                  175* 186 189* 198* 261* 264*
p_ctep                                 parameter       pointer                  dcl 23 ref 149 153 164
p_dtep                                 parameter       pointer                  dcl 24 ref 186 190
p_gtep                                 parameter       pointer                  dcl 25 ref 52 56 89 94 186 191
ptr                                                    builtin function         dcl 49 ref 155 315 317 331 334
quiescing                 1(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-96 ref 362
rel                                                    builtin function         dcl 49 ref 315
required                        000106 automatic       bit(1)                   dcl 30 set ref 57* 161* 192* 342*
same_controller                 000100 automatic       bit(1)                   dcl 239 set ref 241* 243 247
statusp                         000110 automatic       pointer                  dcl 31 in procedure "ioi_usurp_channels" set ref
                                                                                  342* 348
statusp                   4            based           pointer                  level 2 in structure "cte" packed packed unaligned
                                                                                  dcl 1-96 in procedure "ioi_usurp_channels" set ref
                                                                                  348* 367
suspend_devices           3(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-74 ref 95 156
udsk_card                              based           structure                level 1 dcl 3-5
udsk_cardp                      000122 automatic       pointer                  dcl 3-3 set ref 272* 273 273
used_chan_count                 000112 automatic       fixed bin(17,0)          dcl 32 set ref 59* 61 68 98* 101 350* 350 365* 365
usurped                         000113 automatic       bit(1)                   dcl 33 set ref 62* 64 79 102* 104 114 120* 162* 163
                                                                                  167 172* 174 250 344* 345

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IOI_DEFAULT_MAX_BOUND                  internal static fixed bin(19,0)          initial dcl 1-198
IOI_DEFAULT_MAX_TIMEOUT                internal static fixed bin(35,0)          initial dcl 1-199
IOI_DEFAULT_TIMEOUT                    internal static fixed bin(35,0)          initial dcl 1-201
IOI_DEVICE_LOCK_EVENT_TEMPLATE         internal static char(2)                  initial packed unaligned dcl 1-207
IO_CHANNEL_LOCK_TEMPLATE               internal static char(2)                  initial packed unaligned dcl 1-205
IO_STATUS_ERROR_MASK                   internal static bit(36)                  initial packed unaligned dcl 1-203
UDSK_CARD_WORD                         internal static char(4)                  initial dcl 3-25
idp                                    automatic       pointer                  dcl 1-29
ioi_channels                           automatic       fixed bin(17,0)          dcl 1-35
ioi_data                               based           structure                level 1 dcl 1-40
ioi_data$                              external static fixed bin(17,0)          dcl 1-37
ioi_devices                            automatic       fixed bin(17,0)          dcl 1-35
ioi_multiplexers                       automatic       fixed bin(17,0)          dcl 1-35
ioi_subsystems                         automatic       fixed bin(17,0)          dcl 1-35
itep                                   automatic       pointer                  dcl 1-33
lock_ptr                               automatic       pointer                  dcl 2-11
udsk_card_array                        based           structure                level 1 dcl 3-19

NAMES DECLARED BY EXPLICIT CONTEXT.
assign                          000023 constant        entry                    external dcl 52
cede_chan                       001147 constant        entry                    internal dcl 357 ref 119 243
cede_used                       000406 constant        entry                    internal dcl 111 ref 103 103 173 173
count_used                      000757 constant        entry                    internal dcl 298 ref 292 292
cur_chans                       000742 constant        entry                    internal dcl 284 ref 59 98
ioi_usurp_channels              000011 constant        entry                    external dcl 19
ioi_usurp_channels$suspend      000263 constant        entry                    external dcl 186
max_chans                       000672 constant        entry                    internal dcl 269 ref 60 100
required                        000156 constant        entry                    external dcl 149
suspend_failure                 000343 constant        label                    dcl 261 ref 250
test_chan_req                   000464 constant        entry                    internal dcl 123 ref 114
test_controller                 000552 constant        entry                    internal dcl 221 ref 215 215
test_other_controller           000531 constant        entry                    internal dcl 208 ref 197
test_req                        000506 constant        entry                    internal dcl 135 ref 129 129
unassign                        000102 constant        entry                    external dcl 89 ref 261
unassign_join                   000125 constant        label                    dcl 98 ref 182
usurp_chan                      001067 constant        entry                    internal dcl 339 ref 79 165 249
usurp_controller                000610 constant        entry                    internal dcl 236 ref 202 202
usurp_unused                    000360 constant        entry                    internal dcl 76 ref 63 63
walk_channels                   000773 constant        entry                    internal dcl 310 ref 63 103 173 202 292
walk_devices                    001023 constant        entry                    internal dcl 321 ref 129 215

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1524        1552    1242        1534
Length      2026    1242        26         237     262           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ioi_usurp_channels                  148 external procedure  is an external procedure.  
usurp_unused                         64 internal procedure  is assigned to an entry variable.  
cede_used                            90 internal procedure  is assigned to an entry variable.  
test_chan_req                           internal procedure  shares stack frame of internal procedure cede_used.  
test_req                             64 internal procedure  is assigned to an entry variable.  
test_other_controller                   internal procedure  shares stack frame of external procedure ioi_usurp_channels.  
test_controller                      72 internal procedure  is assigned to an entry variable.  
usurp_controller                     74 internal procedure  is assigned to an entry variable.  
max_chans                               internal procedure  shares stack frame of external procedure ioi_usurp_channels.  
cur_chans                               internal procedure  shares stack frame of external procedure ioi_usurp_channels.  
count_used                           64 internal procedure  is assigned to an entry variable.  
walk_channels                           internal procedure  shares stack frame of external procedure ioi_usurp_channels.  
walk_devices                         67 internal procedure  is called by several nonquick procedures.  
usurp_chan                           78 internal procedure  is called by several nonquick procedures.  
cede_chan                            82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cede_used                000106 chan_req                    test_chan_req
ioi_usurp_channels       000100 ctep_to_retain              ioi_usurp_channels
                         000102 max_chan_count              ioi_usurp_channels
                         000104 mcp                         ioi_usurp_channels
                         000106 required                    ioi_usurp_channels
                         000110 statusp                     ioi_usurp_channels
                         000112 used_chan_count             ioi_usurp_channels
                         000113 usurped                     ioi_usurp_channels
                         000114 gtep                        ioi_usurp_channels
                         000116 ctep                        ioi_usurp_channels
                         000120 dtep                        ioi_usurp_channels
                         000122 udsk_cardp                  ioi_usurp_channels
                         000136 other_controller            test_other_controller
                         000154 count                       cur_chans
usurp_controller         000100 same_controller             usurp_controller
walk_devices             000100 done                        walk_devices
                         000101 list_head                   walk_devices

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ent_var        call_ext_in         call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
config$find_2                 disk_control$cede_channel     disk_control$usurp_channel
ioi_config$find_controller_card                             ioi_masked$getwork_channel    ioi_masked$quiesce_channel

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$no_operation


CONSTANTS
001225  aa     377777777777

001226  aa     000002000000
001227  aa     000000000000
001230  aa     600000000041
001231  aa     000220000000

001232  aa     000002000000
001233  aa     000000000000
001234  aa     600000000041
001235  aa     000164000000

001236  aa     000002000000
001237  aa     000000000000
001240  aa     600000000041
001241  aa     000102000000

000000  aa     500000000000

000001  aa  165 144 163 153	udsk

000002  aa     404000000021

000003  aa     514000000001

000004  aa     464000000000

000005  aa     404000000043

000006  aa     077777000043
000007  aa     000001000000

BEGIN PROCEDURE ioi_usurp_channels
ENTRY TO ioi_usurp_channels                                 STATEMENT 1 ON LINE 19
ioi_usurp_channels:
     proc;

000010  da     000123200000
000011  aa   000240 6270 00	eax7 	160
000012  aa  7 00034 3521 20	epp2 	pr7|28,*
000013  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000014  aa     000000000000
000015  aa     000000000000
						STATEMENT 1 ON LINE 52
assign:
     entry (p_gtep, p_code);

000016  aa   000017 7100 04	tra  	15,ic		000035
ENTRY TO assign                                             STATEMENT 1 ON LINE 52
assign:
     entry (p_gtep, p_code);

000017  at     000002000004
000020  ta     000005000000
000021  ta     000017000000
000022  da     000130300000
000023  aa   000240 6270 00	eax7 	160
000024  aa  7 00034 3521 20	epp2 	pr7|28,*
000025  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000026  aa     000004000000
000027  aa     000000000000
000030  aa  6 00032 3735 20	epp7 	pr6|26,*
000031  aa  7 00002 3715 20	epp5 	pr7|2,*
000032  aa  6 00126 6515 00	spri5	pr6|86
000033  aa  7 00004 3535 20	epp3 	pr7|4,*
000034  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 55
	p_code = 0;

000035  aa  6 00124 4501 20	stz  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 56
	gtep = p_gtep;

000036  aa  6 00126 3735 20	epp7 	pr6|86,*		p_gtep
000037  aa  7 00000 3735 20	epp7 	pr7|0,*		p_gtep
000040  aa  6 00114 6535 00	spri7	pr6|76		gtep
						STATEMENT 1 ON LINE 57
	required = "0"b;

000041  aa  6 00106 4501 00	stz  	pr6|70		required
						STATEMENT 1 ON LINE 59
	used_chan_count = cur_chans ();

000042  aa  6 00112 3521 00	epp2 	pr6|74		used_chan_count
000043  aa  6 00166 2521 00	spri2	pr6|118
000044  aa  6 00164 3521 00	epp2 	pr6|116
000045  aa   004000 4310 07	fld  	2048,dl
000046  aa  2 00000 7571 00	staq 	pr2|0
000047  aa   000673 6700 04	tsp4 	443,ic		000742
						STATEMENT 1 ON LINE 60
	max_chan_count = max_chans ();

000050  aa   001166 3520 04	epp2 	630,ic		001236 = 000002000000
000051  aa   000621 6700 04	tsp4 	401,ic		000672
						STATEMENT 1 ON LINE 61
	do while (used_chan_count < max_chan_count);

000052  aa  6 00112 2361 00	ldq  	pr6|74		used_chan_count
000053  aa  6 00102 1161 00	cmpq 	pr6|66		max_chan_count
000054  aa   000013 6050 04	tpl  	11,ic		000067
						STATEMENT 1 ON LINE 62
	     usurped = "0"b;

000055  aa  6 00113 4501 00	stz  	pr6|75		usurped
						STATEMENT 1 ON LINE 63
	     call walk_channels (usurp_unused);

000056  aa   000302 3520 04	epp2 	194,ic		000360 = 000100627000
000057  aa  6 00164 2521 00	spri2	pr6|116		cp.224
000060  aa  6 00166 6521 00	spri6	pr6|118		cp.224
000061  aa   001151 3520 04	epp2 	617,ic		001232 = 000002000000
000062  aa   000711 6700 04	tsp4 	457,ic		000773
						STATEMENT 1 ON LINE 64
	     if ^usurped then
		max_chan_count = 0;

000063  aa  6 00113 2351 00	lda  	pr6|75		usurped
000064  aa   777766 6010 04	tnz  	-10,ic		000052
000065  aa  6 00102 4501 00	stz  	pr6|66		max_chan_count
						STATEMENT 1 ON LINE 66
	end;

000066  aa   777764 7100 04	tra  	-12,ic		000052
						STATEMENT 1 ON LINE 68
	if (used_chan_count <= 0) & (gte.n_devices > 0) then
						/* if no channel was found ... */
	     p_code = error_table_$no_operation;

000067  aa  6 00112 2361 00	ldq  	pr6|74		used_chan_count
000070  aa   000007 6054 04	tpnz 	7,ic		000077
000071  aa  6 00114 3735 20	epp7 	pr6|76,*		gtep
000072  aa  7 00004 2361 00	ldq  	pr7|4		gte.n_devices
000073  aa   000004 6044 04	tmoz 	4,ic		000077
000074  aa  6 00044 3701 20	epp4 	pr6|36,*
000075  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000076  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 71
	return;

000077  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO unassign                                           STATEMENT 1 ON LINE 89
unassign:
     entry (p_gtep, p_code);

000100  ta     000017000000
000101  da     000136300000
000102  aa   000240 6270 00	eax7 	160
000103  aa  7 00034 3521 20	epp2 	pr7|28,*
000104  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000105  aa     000004000000
000106  aa     000000000000
000107  aa  6 00032 3735 20	epp7 	pr6|26,*
000110  aa  7 00002 3715 20	epp5 	pr7|2,*
000111  aa  6 00126 6515 00	spri5	pr6|86
000112  aa  7 00004 3535 20	epp3 	pr7|4,*
000113  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 92
	ctep_to_retain = null ();

000114  aa   777672 2370 04	ldaq 	-70,ic		000006 = 077777000043 000001000000
000115  aa  6 00100 7571 00	staq 	pr6|64		ctep_to_retain
						STATEMENT 1 ON LINE 93
	p_code = 0;

000116  aa  6 00124 4501 20	stz  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 94
	gtep = p_gtep;

000117  aa  6 00126 3735 20	epp7 	pr6|86,*		p_gtep
000120  aa  7 00000 3735 20	epp7 	pr7|0,*		p_gtep
000121  aa  6 00114 6535 00	spri7	pr6|76		gtep
						STATEMENT 1 ON LINE 95
	if gte.suspend_devices then
	     return;

000122  aa  7 00003 2351 00	lda  	pr7|3		gte.suspend_devices
000123  aa   002000 3150 03	cana 	1024,du
000124  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 98
unassign_join:
	used_chan_count = cur_chans ();

000125  aa  6 00112 3521 00	epp2 	pr6|74		used_chan_count
000126  aa  6 00166 2521 00	spri2	pr6|118
000127  aa  6 00164 3521 00	epp2 	pr6|116
000130  aa   004000 4310 07	fld  	2048,dl
000131  aa  2 00000 7571 00	staq 	pr2|0
000132  aa   000610 6700 04	tsp4 	392,ic		000742
						STATEMENT 1 ON LINE 100
	max_chan_count = max_chans ();

000133  aa   001103 3520 04	epp2 	579,ic		001236 = 000002000000
000134  aa   000536 6700 04	tsp4 	350,ic		000672
						STATEMENT 1 ON LINE 101
	do while (used_chan_count > max_chan_count);

000135  aa   000000 0110 03	nop  	0,du
000136  aa  6 00112 2361 00	ldq  	pr6|74		used_chan_count
000137  aa  6 00102 1161 00	cmpq 	pr6|66		max_chan_count
000140  aa   000013 6044 04	tmoz 	11,ic		000153
						STATEMENT 1 ON LINE 102
	     usurped = "1"b;

000141  aa   400000 2350 03	lda  	131072,du
000142  aa  6 00113 7551 00	sta  	pr6|75		usurped
						STATEMENT 1 ON LINE 103
	     call walk_channels (cede_used);

000143  aa   000243 3520 04	epp2 	163,ic		000406 = 000140627000
000144  aa  6 00164 2521 00	spri2	pr6|116		cp.224
000145  aa  6 00166 6521 00	spri6	pr6|118		cp.224
000146  aa   001064 3520 04	epp2 	564,ic		001232 = 000002000000
000147  aa   000624 6700 04	tsp4 	404,ic		000773
						STATEMENT 1 ON LINE 104
	     if usurped then
		return;

000150  aa  6 00113 2351 00	lda  	pr6|75		usurped
000151  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 106
	end;

000152  aa   777764 7100 04	tra  	-12,ic		000136
						STATEMENT 1 ON LINE 108
	return;

000153  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO required                                           STATEMENT 1 ON LINE 149
required:
     entry (p_ctep, p_code);

000154  ta     000017000000
000155  da     000144300000
000156  aa   000240 6270 00	eax7 	160
000157  aa  7 00034 3521 20	epp2 	pr7|28,*
000160  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000161  aa     000004000000
000162  aa     000000000000
000163  aa  6 00032 3735 20	epp7 	pr6|26,*
000164  aa  7 00004 3715 20	epp5 	pr7|4,*
000165  aa  6 00124 6515 00	spri5	pr6|84
						STATEMENT 1 ON LINE 152
	p_code = 0;

000166  aa  6 00124 4501 20	stz  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 153
	ctep = p_ctep;

000167  aa  6 00032 3735 20	epp7 	pr6|26,*
000170  aa  7 00002 3715 20	epp5 	pr7|2,*		p_ctep
000171  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ctep
000172  aa  6 00116 6515 00	spri5	pr6|78		ctep
						STATEMENT 1 ON LINE 155
	gtep = ptr (ctep, cte.gtep);

000173  aa  5 00000 2351 00	lda  	pr5|0		cte.gtep
000174  aa   000022 7350 00	als  	18
000175  aa  5 00000 3521 00	epp2 	pr5|0
000176  aa   000000 3120 01	eawp2	0,au
000177  aa  6 00114 2521 00	spri2	pr6|76		gtep
						STATEMENT 1 ON LINE 156
	if gte.suspend_devices then do;

000200  aa  2 00003 2351 00	lda  	pr2|3		gte.suspend_devices
000201  aa   002000 3150 03	cana 	1024,du
000202  aa   000005 6000 04	tze  	5,ic		000207
						STATEMENT 1 ON LINE 157
	     p_code = error_table_$no_operation;

000203  aa  6 00044 3701 20	epp4 	pr6|36,*
000204  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000205  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 158
	     return;

000206  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 159
	end;

						STATEMENT 1 ON LINE 161
	required = "1"b;

000207  aa   400000 2350 03	lda  	131072,du
000210  aa  6 00106 7551 00	sta  	pr6|70		required
						STATEMENT 1 ON LINE 162
	usurped = "0"b;

000211  aa  6 00113 4501 00	stz  	pr6|75		usurped
						STATEMENT 1 ON LINE 163
	do while (^usurped);

000212  aa  6 00113 2351 00	lda  	pr6|75		usurped
000213  aa   000041 6010 04	tnz  	33,ic		000254
						STATEMENT 1 ON LINE 164
	     ctep = p_ctep;

000214  aa  6 00032 3735 20	epp7 	pr6|26,*
000215  aa  7 00002 3715 20	epp5 	pr7|2,*		p_ctep
000216  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ctep
000217  aa  6 00116 6515 00	spri5	pr6|78		ctep
						STATEMENT 1 ON LINE 165
	     call usurp_chan;

000220  aa  6 00056 6211 00	eax1 	pr6|46
000221  aa   000000 4310 07	fld  	0,dl
000222  aa   000645 3520 04	epp2 	421,ic		001067 = 000120627000
000223  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 167
	     if ^usurped then do;

000224  aa  6 00113 2351 00	lda  	pr6|75		usurped
000225  aa   777765 6010 04	tnz  	-11,ic		000212
						STATEMENT 1 ON LINE 168
		if cte.deleting then do;

000226  aa  6 00116 3735 20	epp7 	pr6|78,*		ctep
000227  aa  7 00015 2351 00	lda  	pr7|13		cte.deleting
000230  aa   400000 3150 03	cana 	131072,du
000231  aa   000005 6000 04	tze  	5,ic		000236
						STATEMENT 1 ON LINE 169
		     p_code = error_table_$no_operation;

000232  aa  6 00044 3701 20	epp4 	pr6|36,*
000233  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000234  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 170
		     return;

000235  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 171
		end;

						STATEMENT 1 ON LINE 172
		usurped = "1"b;

000236  aa   400000 2350 03	lda  	131072,du
000237  aa  6 00113 7551 00	sta  	pr6|75		usurped
						STATEMENT 1 ON LINE 173
		call walk_channels (cede_used);

000240  aa   000146 3520 04	epp2 	102,ic		000406 = 000140627000
000241  aa  6 00164 2521 00	spri2	pr6|116		cp.224
000242  aa  6 00166 6521 00	spri6	pr6|118		cp.224
000243  aa   000767 3520 04	epp2 	503,ic		001232 = 000002000000
000244  aa   000527 6700 04	tsp4 	343,ic		000773
						STATEMENT 1 ON LINE 174
		if usurped then do;

000245  aa  6 00113 2351 00	lda  	pr6|75		usurped
000246  aa   777744 6000 04	tze  	-28,ic		000212
						STATEMENT 1 ON LINE 175
		     p_code = error_table_$no_operation;

000247  aa  6 00044 3701 20	epp4 	pr6|36,*
000250  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000251  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 176
		     return;

000252  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 177
		end;

						STATEMENT 1 ON LINE 178
	     end;

						STATEMENT 1 ON LINE 179
	end;

000253  aa   777737 7100 04	tra  	-33,ic		000212
						STATEMENT 1 ON LINE 181
	ctep_to_retain = ctep;

000254  aa  6 00116 3735 20	epp7 	pr6|78,*		ctep
000255  aa  6 00100 6535 00	spri7	pr6|64		ctep_to_retain
						STATEMENT 1 ON LINE 182
	goto unassign_join;

000256  aa   777647 7100 04	tra  	-89,ic		000125
ENTRY TO ioi_usurp_channels$suspend                         STATEMENT 1 ON LINE 186
ioi_usurp_channels$suspend:
     entry (p_dtep, p_gtep, p_code);

000257  at     000003000004
000260  tt     000004000005
000261  ta     000257000000
000262  da     000163300000
000263  aa   000240 6270 00	eax7 	160
000264  aa  7 00034 3521 20	epp2 	pr7|28,*
000265  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000266  aa     000006000000
000267  aa     000000000000
000270  aa  6 00032 3735 20	epp7 	pr6|26,*
000271  aa  7 00004 3715 20	epp5 	pr7|4,*
000272  aa  6 00126 6515 00	spri5	pr6|86
000273  aa  7 00006 3535 20	epp3 	pr7|6,*
000274  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 189
	p_code = 0;

000275  aa  6 00124 4501 20	stz  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 190
	dtep = p_dtep;

000276  aa  6 00032 3735 20	epp7 	pr6|26,*
000277  aa  7 00002 3715 20	epp5 	pr7|2,*		p_dtep
000300  aa  5 00000 3715 20	epp5 	pr5|0,*		p_dtep
000301  aa  6 00120 6515 00	spri5	pr6|80		dtep
						STATEMENT 1 ON LINE 191
	gtep = p_gtep;

000302  aa  6 00126 3535 20	epp3 	pr6|86,*		p_gtep
000303  aa  3 00000 3535 20	epp3 	pr3|0,*		p_gtep
000304  aa  6 00114 2535 00	spri3	pr6|76		gtep
						STATEMENT 1 ON LINE 192
	required = "1"b;

000305  aa   400000 2350 03	lda  	131072,du
000306  aa  6 00106 7551 00	sta  	pr6|70		required
						STATEMENT 1 ON LINE 194
	mcp = ioi_config$find_controller_card (dte.channel_required);

000307  aa  5 00002 3521 00	epp2 	pr5|2		dte.channel_required
000310  aa  6 00166 2521 00	spri2	pr6|118
000311  aa  6 00104 3521 00	epp2 	pr6|68		mcp
000312  aa  6 00170 2521 00	spri2	pr6|120
000313  aa  6 00164 6211 00	eax1 	pr6|116
000314  aa   010000 4310 07	fld  	4096,dl
000315  aa  6 00044 3701 20	epp4 	pr6|36,*
000316  la  4 00016 3521 20	epp2 	pr4|14,*		ioi_config$find_controller_card
000317  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 197
	if test_other_controller () then do;

000320  aa  6 00172 3521 00	epp2 	pr6|122
000321  aa  6 00166 2521 00	spri2	pr6|118
000322  aa  6 00164 3521 00	epp2 	pr6|116
000323  aa   004000 4310 07	fld  	2048,dl
000324  aa  2 00000 7571 00	staq 	pr2|0
000325  aa   000204 6700 04	tsp4 	132,ic		000531
000326  aa  6 00172 2351 00	lda  	pr6|122
000327  aa   400000 3150 03	cana 	131072,du
000330  aa   000005 6000 04	tze  	5,ic		000335
						STATEMENT 1 ON LINE 198
	     p_code = error_table_$no_operation;

000331  aa  6 00044 3701 20	epp4 	pr6|36,*
000332  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000333  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 199
	     return;

000334  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 200
	end;

						STATEMENT 1 ON LINE 202
	call walk_channels (usurp_controller);

000335  aa   000253 3520 04	epp2 	171,ic		000610 = 000120627000
000336  aa  6 00164 2521 00	spri2	pr6|116		cp.224
000337  aa  6 00166 6521 00	spri6	pr6|118		cp.224
000340  aa   000672 3520 04	epp2 	442,ic		001232 = 000002000000
000341  aa   000432 6700 04	tsp4 	282,ic		000773
						STATEMENT 1 ON LINE 204
	return;

000342  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 261
suspend_failure:
	call unassign (gtep, p_code);

000343  aa  6 00114 3521 00	epp2 	pr6|76		gtep
000344  aa  6 00166 2521 00	spri2	pr6|118
000345  aa  6 00124 3521 20	epp2 	pr6|84,*		p_code
000346  aa  6 00170 2521 00	spri2	pr6|120
000347  aa  6 00164 6211 00	eax1 	pr6|116
000350  aa   010000 4310 07	fld  	4096,dl
000351  aa   777531 3520 04	epp2 	-167,ic		000102 = 000240627000
000352  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 264
	p_code = error_table_$no_operation;

000353  aa  6 00044 3701 20	epp4 	pr6|36,*
000354  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$no_operation
000355  aa  6 00124 7561 20	stq  	pr6|84,*		p_code
						STATEMENT 1 ON LINE 266
	return;

000356  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 376
     end ioi_usurp_channels;

BEGIN PROCEDURE usurp_unused
ENTRY TO usurp_unused                                       STATEMENT 1 ON LINE 76
usurp_unused:
     proc;

000357  da     000172200000
000360  aa   000100 6270 00	eax7 	64
000361  aa  7 00034 3521 20	epp2 	pr7|28,*
000362  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000363  aa     000000000000
000364  aa     000000000000
						STATEMENT 1 ON LINE 79
	if ^usurped then				/* if no channel usurped as yet ... */
	     if ^(cte.ioi_use | cte.deleted | cte.deleting) then
						/* if channel not already in use ... */
		call usurp_chan;

000365  aa  6 00040 3735 20	epp7 	pr6|32,*
000366  aa  7 00113 2351 00	lda  	pr7|75		usurped
000367  aa   000015 6010 04	tnz  	13,ic		000404
000370  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
000371  aa  5 00001 2351 00	lda  	pr5|1		cte.ioi_use
000372  aa   400000 3150 03	cana 	131072,du
000373  aa   000011 6010 04	tnz  	9,ic		000404
000374  aa  5 00015 2351 00	lda  	pr5|13		cte.deleting
000375  aa   600000 3150 03	cana 	196608,du
000376  aa   000006 6010 04	tnz  	6,ic		000404
000377  aa   000001 7270 07	lxl7 	1,dl
000400  aa  6 00056 6211 00	eax1 	pr6|46
000401  aa   000000 4310 07	fld  	0,dl
000402  aa   000465 3520 04	epp2 	309,ic		001067 = 000120627000
000403  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 84
     end usurp_unused;

000404  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE usurp_unused
BEGIN PROCEDURE cede_used
ENTRY TO cede_used                                          STATEMENT 1 ON LINE 111
cede_used:
     proc;

000405  da     000200200000
000406  aa   000140 6270 00	eax7 	96
000407  aa  7 00034 3521 20	epp2 	pr7|28,*
000410  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000411  aa     000000000000
000412  aa     000000000000
						STATEMENT 1 ON LINE 114
	if (ctep ^= ctep_to_retain)			/* if not holding on to this channel */
	     & usurped				/* if no channel ceded as yet ... */
	     & cte.ioi_use				/* if this channel is in use ... */
	     & ^(cte.deleted | cte.deleting)		/* ...for real */
	     & (^test_chan_req ()) then do;

000413  aa  6 00107 3521 00	epp2 	pr6|71
000414  aa  6 00112 2521 00	spri2	pr6|74
000415  aa  6 00110 3521 00	epp2 	pr6|72
000416  aa   004000 4310 07	fld  	2048,dl
000417  aa  2 00000 7571 00	staq 	pr2|0
000420  aa   000044 6700 04	tsp4 	36,ic		000464
000421  aa  6 00107 2351 00	lda  	pr6|71
000422  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000423  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000424  aa  6 00107 7551 00	sta  	pr6|71
000425  aa  6 00040 3735 20	epp7 	pr6|32,*
000426  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
000427  aa  5 00015 2351 00	lda  	pr5|13		cte.deleting
000430  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000431  aa  6 00116 7551 00	sta  	pr6|78		cte.deleting
000432  aa  5 00015 2351 00	lda  	pr5|13		cte.deleted
000433  aa   000001 7350 00	als  	1
000434  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000435  aa  6 00116 2751 00	ora  	pr6|78		cte.deleting
000436  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000437  aa  6 00116 7551 00	sta  	pr6|78
000440  aa  5 00001 2351 00	lda  	pr5|1		cte.ioi_use
000441  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000442  aa  6 00117 7551 00	sta  	pr6|79		cte.ioi_use
000443  aa  7 00116 2371 00	ldaq 	pr7|78		ctep
000444  aa  7 00100 6771 00	eraq 	pr7|64		ctep_to_retain
000445  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000446  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
000447  aa  7 00113 3751 00	ana  	pr7|75		usurped
000450  aa  6 00117 3751 00	ana  	pr6|79		cte.ioi_use
000451  aa  6 00116 3751 00	ana  	pr6|78
000452  aa  6 00107 3151 00	cana 	pr6|71
000453  aa   000010 6000 04	tze  	8,ic		000463
						STATEMENT 1 ON LINE 119
	     call cede_chan;

000454  aa   000001 7270 07	lxl7 	1,dl
000455  aa  6 00056 6211 00	eax1 	pr6|46
000456  aa   000000 4310 07	fld  	0,dl
000457  aa   000470 3520 04	epp2 	312,ic		001147 = 000140627000
000460  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 120
	     usurped = "0"b;

000461  aa  6 00040 3735 20	epp7 	pr6|32,*
000462  aa  7 00113 4501 00	stz  	pr7|75		usurped
						STATEMENT 1 ON LINE 121
	end;

						STATEMENT 1 ON LINE 145
     end cede_used;

000463  aa  0 00631 7101 00	tra  	pr0|409		return_mac
BEGIN PROCEDURE test_chan_req
ENTRY TO test_chan_req                                      STATEMENT 1 ON LINE 123
test_chan_req:
	proc returns (bit (1) aligned);

000464  aa  6 00100 6501 00	spri4	pr6|64
000465  aa  6 00102 2521 00	spri2	pr6|66
						STATEMENT 1 ON LINE 128
	     chan_req = "0"b;

000466  aa  6 00106 4501 00	stz  	pr6|70		chan_req
						STATEMENT 1 ON LINE 129
	     call walk_devices (test_req);

000467  aa   000017 3520 04	epp2 	15,ic		000506 = 000100627000
000470  aa  6 00120 2521 00	spri2	pr6|80		cp.224
000471  aa  6 00122 6521 00	spri6	pr6|82		cp.224
000472  aa  6 00120 3521 00	epp2 	pr6|80		cp.224
000473  aa  6 00126 2521 00	spri2	pr6|86
000474  aa   000001 7270 07	lxl7 	1,dl
000475  aa  6 00124 6211 00	eax1 	pr6|84
000476  aa   004000 4310 07	fld  	2048,dl
000477  aa   000324 3520 04	epp2 	212,ic		001023 = 000120627000
000500  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 130
	     return (chan_req);

000501  aa  6 00106 2351 00	lda  	pr6|70		chan_req
000502  aa  6 00102 3735 20	epp7 	pr6|66,*
000503  aa  7 00002 7551 20	sta  	pr7|2,*
000504  aa  6 00100 6101 00	rtcd 	pr6|64
						STATEMENT 1 ON LINE 143
	end test_chan_req;

BEGIN PROCEDURE test_req
ENTRY TO test_req                                           STATEMENT 1 ON LINE 135
test_req:
	     proc;

000505  da     000206200000
000506  aa   000100 6270 00	eax7 	64
000507  aa  7 00034 3521 20	epp2 	pr7|28,*
000510  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000511  aa     000000000000
000512  aa     000000000000
						STATEMENT 1 ON LINE 138
		if dte.channel_required = cte.chanid then
		     chan_req = "1"b;

000513  aa  6 00040 3735 20	epp7 	pr6|32,*
000514  aa  7 00040 3735 20	epp7 	pr7|32,*
000515  aa  7 00120 3715 20	epp5 	pr7|80,*		dtep
000516  aa  5 00002 2351 00	lda  	pr5|2		dte.channel_required
000517  aa  5 00003 2361 00	ldq  	pr5|3		dte.channel_required
000520  aa  7 00116 3535 20	epp3 	pr7|78,*		ctep
000521  aa  3 00002 1151 00	cmpa 	pr3|2		cte.chanid
000522  aa   000002 6010 04	tnz  	2,ic		000524
000523  aa  3 00003 1161 00	cmpq 	pr3|3		cte.chanid
000524  aa   000004 6010 04	tnz  	4,ic		000530
000525  aa   400000 2350 03	lda  	131072,du
000526  aa  6 00040 3515 20	epp1 	pr6|32,*
000527  aa  1 00106 7551 00	sta  	pr1|70		chan_req
						STATEMENT 1 ON LINE 141
	     end test_req;

000530  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE test_req
  END PROCEDURE test_chan_req
  END PROCEDURE cede_used
BEGIN PROCEDURE test_other_controller
ENTRY TO test_other_controller                              STATEMENT 1 ON LINE 208
test_other_controller:
     proc returns (bit (1) aligned);

000531  aa  6 00130 6501 00	spri4	pr6|88
000532  aa  6 00132 2521 00	spri2	pr6|90
						STATEMENT 1 ON LINE 211
000533  aa  6 00136 4501 00	stz  	pr6|94		other_controller
						STATEMENT 1 ON LINE 215
	call walk_devices (test_controller);

000534  aa   000016 3520 04	epp2 	14,ic		000552 = 000120627000
000535  aa  6 00174 2521 00	spri2	pr6|124		cp.224
000536  aa  6 00176 6521 00	spri6	pr6|126		cp.224
000537  aa  6 00174 3521 00	epp2 	pr6|124		cp.224
000540  aa  6 00202 2521 00	spri2	pr6|130
000541  aa  6 00200 6211 00	eax1 	pr6|128
000542  aa   004000 4310 07	fld  	2048,dl
000543  aa   000260 3520 04	epp2 	176,ic		001023 = 000120627000
000544  aa  0 00625 7001 00	tsx0 	pr0|405		call_int_this
						STATEMENT 1 ON LINE 217
	return (other_controller);

000545  aa  6 00136 2351 00	lda  	pr6|94		other_controller
000546  aa  6 00132 3735 20	epp7 	pr6|90,*
000547  aa  7 00002 7551 20	sta  	pr7|2,*
000550  aa  6 00130 6101 00	rtcd 	pr6|88
						STATEMENT 1 ON LINE 233
     end test_other_controller;

BEGIN PROCEDURE test_controller
ENTRY TO test_controller                                    STATEMENT 1 ON LINE 221
test_controller:
	proc;

000551  da     000215200000
000552  aa   000120 6270 00	eax7 	80
000553  aa  7 00034 3521 20	epp2 	pr7|28,*
000554  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000555  aa     000000000000
000556  aa     000000000000
						STATEMENT 1 ON LINE 224
	     if dte.channel_required ^= "" then		/* If this device requires a channel ... */
		if mcp ^= ioi_config$find_controller_card (dte.channel_required) then
		     other_controller = "1"b;

000557  aa   000000 4310 07	fld  	0,dl
000560  aa  0 00440 2771 00	oraq 	pr0|288		= 040040040040 040040040040
000561  aa  6 00040 3735 20	epp7 	pr6|32,*
000562  aa  7 00120 3715 20	epp5 	pr7|80,*		dtep
000563  aa  5 00002 1151 00	cmpa 	pr5|2		dte.channel_required
000564  aa   000002 6010 04	tnz  	2,ic		000566
000565  aa  5 00003 1161 00	cmpq 	pr5|3		dte.channel_required
000566  aa   000020 6000 04	tze  	16,ic		000606
000567  aa  5 00002 3521 00	epp2 	pr5|2		dte.channel_required
000570  aa  6 00104 2521 00	spri2	pr6|68
000571  aa  6 00100 3521 00	epp2 	pr6|64
000572  aa  6 00106 2521 00	spri2	pr6|70
000573  aa  6 00102 6211 00	eax1 	pr6|66
000574  aa   010000 4310 07	fld  	4096,dl
000575  la  4 00016 3521 20	epp2 	pr4|14,*		ioi_config$find_controller_card
000576  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000577  aa  6 00040 3735 20	epp7 	pr6|32,*
000600  aa  7 00104 2371 00	ldaq 	pr7|68		mcp
000601  aa  6 00100 6771 00	eraq 	pr6|64
000602  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000603  aa   000003 6000 04	tze  	3,ic		000606
000604  aa   400000 2350 03	lda  	131072,du
000605  aa  7 00136 7551 00	sta  	pr7|94		other_controller
						STATEMENT 1 ON LINE 228
	     return;

000606  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 231
	end test_controller;

  END PROCEDURE test_controller
  END PROCEDURE test_other_controller
BEGIN PROCEDURE usurp_controller
ENTRY TO usurp_controller                                   STATEMENT 1 ON LINE 236
usurp_controller:
     proc;

000607  da     000225200000
000610  aa   000120 6270 00	eax7 	80
000611  aa  7 00034 3521 20	epp2 	pr7|28,*
000612  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000613  aa     000000000000
000614  aa     000000000000
						STATEMENT 1 ON LINE 241
	same_controller = (mcp = ioi_config$find_controller_card (cte.chanid));

000615  aa  6 00040 3735 20	epp7 	pr6|32,*
000616  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
000617  aa  5 00002 3521 00	epp2 	pr5|2		cte.chanid
000620  aa  6 00106 2521 00	spri2	pr6|70
000621  aa  6 00102 3521 00	epp2 	pr6|66
000622  aa  6 00110 2521 00	spri2	pr6|72
000623  aa  6 00104 6211 00	eax1 	pr6|68
000624  aa   010000 4310 07	fld  	4096,dl
000625  la  4 00016 3521 20	epp2 	pr4|14,*		ioi_config$find_controller_card
000626  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000627  aa  6 00040 3735 20	epp7 	pr6|32,*
000630  aa  7 00104 2371 00	ldaq 	pr7|68		mcp
000631  aa  6 00102 6771 00	eraq 	pr6|66
000632  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000633  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000634  aa  6 00100 7551 00	sta  	pr6|64		same_controller
						STATEMENT 1 ON LINE 243
	if cte.ioi_use then				/* If channel already in use ... */
	     if ^same_controller then			/* If channel on another MPC ... */
		call cede_chan;

000635  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
000636  aa  5 00001 2351 00	lda  	pr5|1		cte.ioi_use
000637  aa   400000 3150 03	cana 	131072,du
000640  aa   000011 6000 04	tze  	9,ic		000651
000641  aa  6 00100 2351 00	lda  	pr6|64		same_controller
000642  aa   000027 6010 04	tnz  	23,ic		000671
000643  aa   000001 7270 07	lxl7 	1,dl
000644  aa  6 00056 6211 00	eax1 	pr6|46
000645  aa   000000 4310 07	fld  	0,dl
000646  aa   000301 3520 04	epp2 	193,ic		001147 = 000140627000
000647  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 246
	     else ;

000650  aa   000021 7100 04	tra  	17,ic		000671
						STATEMENT 1 ON LINE 247
	else					/* If channel not in use ... */
	     if same_controller & ^cte.deleted then do;

000651  aa  6 00100 2351 00	lda  	pr6|64		same_controller
000652  aa   000017 6000 04	tze  	15,ic		000671
000653  aa  5 00015 2351 00	lda  	pr5|13		cte.deleted
000654  aa   200000 3150 03	cana 	65536,du
000655  aa   000014 6010 04	tnz  	12,ic		000671
						STATEMENT 1 ON LINE 249
	     call usurp_chan;

000656  aa   000001 7270 07	lxl7 	1,dl
000657  aa  6 00056 6211 00	eax1 	pr6|46
000660  aa   000000 4310 07	fld  	0,dl
000661  aa   000206 3520 04	epp2 	134,ic		001067 = 000120627000
000662  aa  0 00627 7001 00	tsx0 	pr0|407		call_int_other
						STATEMENT 1 ON LINE 250
	     if ^usurped then
		goto suspend_failure;

000663  aa  6 00040 3735 20	epp7 	pr6|32,*
000664  aa  7 00113 2351 00	lda  	pr7|75		usurped
000665  aa   000004 6010 04	tnz  	4,ic		000671
000666  aa   777455 3520 04	epp2 	-211,ic		000343 = 600114352100
000667  aa   000001 7270 07	lxl7 	1,dl
000670  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 252
	end;

						STATEMENT 1 ON LINE 254
	return;

000671  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 257
     end usurp_controller;

  END PROCEDURE usurp_controller
BEGIN PROCEDURE max_chans
ENTRY TO max_chans                                          STATEMENT 1 ON LINE 269
max_chans:
     proc returns (fixed bin);

000672  aa  6 00140 6501 00	spri4	pr6|96
000673  aa  6 00142 2521 00	spri2	pr6|98
						STATEMENT 1 ON LINE 272
	call config$find_2 ("udsk", gte.name, udsk_cardp);

000674  aa   777105 2350 04	lda  	-443,ic		000001 = 165144163153
000675  aa  6 00206 7551 00	sta  	pr6|134
000676  aa  6 00206 3521 00	epp2 	pr6|134
000677  aa  6 00212 2521 00	spri2	pr6|138
000700  aa  6 00114 3735 20	epp7 	pr6|76,*		gtep
000701  aa  7 00001 3521 00	epp2 	pr7|1		gte.name
000702  aa  6 00214 2521 00	spri2	pr6|140
000703  aa  6 00122 3521 00	epp2 	pr6|82		udsk_cardp
000704  aa  6 00216 2521 00	spri2	pr6|142
000705  aa  6 00210 6211 00	eax1 	pr6|136
000706  aa   014000 4310 07	fld  	6144,dl
000707  aa  6 00044 3701 20	epp4 	pr6|36,*
000710  la  4 00010 3521 20	epp2 	pr4|8,*		config$find_2
000711  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 273
	if udsk_cardp ^= null () then			/* If card found ... */
	     return (min (max (udsk_card.nchan, 1), gte.n_devices));

000712  aa  6 00122 2371 00	ldaq 	pr6|82		udsk_cardp
000713  aa   777073 6770 04	eraq 	-453,ic		000006 = 077777000043 000001000000
000714  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000715  aa   000015 6000 04	tze  	13,ic		000732
000716  aa  6 00122 3735 20	epp7 	pr6|82,*		udsk_cardp
000717  aa  7 00002 2361 00	ldq  	pr7|2		udsk_card.nchan
000720  aa   000001 1160 07	cmpq 	1,dl
000721  aa   000002 6050 04	tpl  	2,ic		000723
000722  aa   000001 2360 07	ldq  	1,dl
000723  aa  6 00114 3715 20	epp5 	pr6|76,*		gtep
000724  aa  5 00004 1161 00	cmpq 	pr5|4		gte.n_devices
000725  aa   000002 6040 04	tmi  	2,ic		000727
000726  aa  5 00004 2361 00	ldq  	pr5|4		gte.n_devices
000727  aa  6 00142 3535 20	epp3 	pr6|98,*
000730  aa  3 00002 7561 20	stq  	pr3|2,*
000731  aa  6 00140 6101 00	rtcd 	pr6|96
						STATEMENT 1 ON LINE 276
	else					/* Otherwise ... */
	     return (min (gte.n_devices, 1));

000732  aa  6 00114 3735 20	epp7 	pr6|76,*		gtep
000733  aa  7 00004 2361 00	ldq  	pr7|4		gte.n_devices
000734  aa   000001 1160 07	cmpq 	1,dl
000735  aa   000002 6040 04	tmi  	2,ic		000737
000736  aa   000001 2360 07	ldq  	1,dl
000737  aa  6 00142 3715 20	epp5 	pr6|98,*
000740  aa  5 00002 7561 20	stq  	pr5|2,*
000741  aa  6 00140 6101 00	rtcd 	pr6|96
						STATEMENT 1 ON LINE 280
     end max_chans;

  END PROCEDURE max_chans
BEGIN PROCEDURE cur_chans
ENTRY TO cur_chans                                          STATEMENT 1 ON LINE 284
cur_chans:
     proc returns (fixed bin);

000742  aa  6 00146 6501 00	spri4	pr6|102
000743  aa  6 00150 2521 00	spri2	pr6|104
						STATEMENT 1 ON LINE 290
	count = 0;

000744  aa  6 00154 4501 00	stz  	pr6|108		count
						STATEMENT 1 ON LINE 292
	call walk_channels (count_used);

000745  aa   000012 3520 04	epp2 	10,ic		000757 = 000100627000
000746  aa  6 00220 2521 00	spri2	pr6|144		cp.224
000747  aa  6 00222 6521 00	spri6	pr6|146		cp.224
000750  aa   000256 3520 04	epp2 	174,ic		001226 = 000002000000
000751  aa   000022 6700 04	tsp4 	18,ic		000773
						STATEMENT 1 ON LINE 294
	return (count);

000752  aa  6 00154 2361 00	ldq  	pr6|108		count
000753  aa  6 00150 3735 20	epp7 	pr6|104,*
000754  aa  7 00002 7561 20	stq  	pr7|2,*
000755  aa  6 00146 6101 00	rtcd 	pr6|102
						STATEMENT 1 ON LINE 307
     end cur_chans;

BEGIN PROCEDURE count_used
ENTRY TO count_used                                         STATEMENT 1 ON LINE 298
count_used:
	proc;

000756  da     000233200000
000757  aa   000100 6270 00	eax7 	64
000760  aa  7 00034 3521 20	epp2 	pr7|28,*
000761  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000762  aa     000000000000
000763  aa     000000000000
						STATEMENT 1 ON LINE 301
	     if cte.ioi_use then			/* Count surped channels. */
		count = count + 1;

000764  aa  6 00040 3735 20	epp7 	pr6|32,*
000765  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
000766  aa  5 00001 2351 00	lda  	pr5|1		cte.ioi_use
000767  aa   400000 3150 03	cana 	131072,du
000770  aa   000002 6000 04	tze  	2,ic		000772
000771  aa  7 00154 0541 00	aos  	pr7|108		count
						STATEMENT 1 ON LINE 305
	end count_used;

000772  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE count_used
  END PROCEDURE cur_chans
BEGIN PROCEDURE walk_channels
ENTRY TO walk_channels                                      STATEMENT 1 ON LINE 310
walk_channels:
     proc (examine_channel);

000773  aa  6 00156 6501 00	spri4	pr6|110
000774  aa  6 00160 2521 00	spri2	pr6|112
						STATEMENT 1 ON LINE 315
	do ctep = ptr (gtep, gte.ctep) repeat ptr (gtep, cte.next_ctep) while (rel (ctep) ^= ""b);

000775  aa  6 00114 3735 20	epp7 	pr6|76,*		gtep
000776  aa  7 00002 2351 00	lda  	pr7|2		gte.ctep
000777  aa   000022 7350 00	als  	18
001000  aa  7 00000 3515 00	epp1 	pr7|0
001001  aa   000000 3114 01	eawp1	0,au
001002  aa  6 00116 2515 00	spri1	pr6|78		ctep
001003  aa   000000 0110 03	nop  	0,du
001004  aa  6 00116 6351 20	eaa  	pr6|78,*		ctep
001005  aa   000014 6000 04	tze  	12,ic		001021
						STATEMENT 1 ON LINE 316
	     call examine_channel;

001006  aa  6 00056 6211 00	eax1 	pr6|46
001007  aa   000000 4310 07	fld  	0,dl
001010  aa  6 00160 3735 20	epp7 	pr6|112,*
001011  aa  7 00002 3521 20	epp2 	pr7|2,*		examine_channel
001012  aa  0 00617 7001 00	tsx0 	pr0|399		call_ent_var
						STATEMENT 1 ON LINE 317
	end;

001013  aa  6 00116 2351 20	lda  	pr6|78,*		cte.next_ctep
001014  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001015  aa  6 00114 3521 20	epp2 	pr6|76,*		gtep
001016  aa   000000 3120 01	eawp2	0,au
001017  aa  6 00116 2521 00	spri2	pr6|78		ctep
001020  aa   777764 7100 04	tra  	-12,ic		001004
						STATEMENT 1 ON LINE 319
     end walk_channels;

001021  aa  6 00156 6101 00	rtcd 	pr6|110
  END PROCEDURE walk_channels
BEGIN PROCEDURE walk_devices
ENTRY TO walk_devices                                       STATEMENT 1 ON LINE 321
walk_devices:
     proc (examine_device);

001022  da     000242200000
001023  aa   000120 6270 00	eax7 	80
001024  aa  7 00034 3521 20	epp2 	pr7|28,*
001025  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001026  aa     000002000000
001027  aa     000000000000
						STATEMENT 1 ON LINE 329
	done = "0"b;

001030  aa  6 00100 4501 00	stz  	pr6|64		done
						STATEMENT 1 ON LINE 330
	list_head = gte.dtep;

001031  aa  6 00040 3735 20	epp7 	pr6|32,*
001032  aa  7 00114 3715 20	epp5 	pr7|76,*		gtep
001033  aa  5 00002 2351 00	lda  	pr5|2		gte.dtep
001034  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001035  aa  6 00101 7551 00	sta  	pr6|65		list_head
						STATEMENT 1 ON LINE 331
	do dtep = ptr (gtep, list_head) repeat ptr (gtep, dte.next_dtep) while (^done);

001036  aa  5 00000 3521 00	epp2 	pr5|0
001037  aa   000000 3120 01	eawp2	0,au
001040  aa  7 00120 2521 00	spri2	pr7|80		dtep
001041  aa   000000 0110 03	nop  	0,du
001042  aa  6 00100 2351 00	lda  	pr6|64		done
001043  aa   000022 6010 04	tnz  	18,ic		001065
						STATEMENT 1 ON LINE 332
	     call examine_device;

001044  aa  6 00056 6211 00	eax1 	pr6|46
001045  aa   000000 4310 07	fld  	0,dl
001046  aa  6 00032 3735 20	epp7 	pr6|26,*
001047  aa  7 00002 3521 20	epp2 	pr7|2,*		examine_device
001050  aa  0 00617 7001 00	tsx0 	pr0|399		call_ent_var
						STATEMENT 1 ON LINE 333
	     done = (dte.next_dtep = list_head);

001051  aa  6 00040 3735 20	epp7 	pr6|32,*
001052  aa  7 00120 2351 20	lda  	pr7|80,*		dte.next_dtep
001053  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001054  aa  6 00101 1151 00	cmpa 	pr6|65		list_head
001055  aa  6 00102 7551 00	sta  	pr6|66		dte.next_dtep
001056  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
001057  aa  6 00100 7551 00	sta  	pr6|64		done
						STATEMENT 1 ON LINE 334
	end;

001060  aa  6 00102 2351 00	lda  	pr6|66		dte.next_dtep
001061  aa  7 00114 3521 20	epp2 	pr7|76,*		gtep
001062  aa   000000 3120 01	eawp2	0,au
001063  aa  7 00120 2521 00	spri2	pr7|80		dtep
001064  aa   777756 7100 04	tra  	-18,ic		001042
						STATEMENT 1 ON LINE 336
     end walk_devices;

001065  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE walk_devices
BEGIN PROCEDURE usurp_chan
ENTRY TO usurp_chan                                         STATEMENT 1 ON LINE 339
usurp_chan:
     proc;

001066  da     000250200000
001067  aa   000120 6270 00	eax7 	80
001070  aa  7 00034 3521 20	epp2 	pr7|28,*
001071  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001072  aa     000000000000
001073  aa     000000000000
						STATEMENT 1 ON LINE 342
	call disk_control$usurp_channel ((gte.disk_data_subsystem_idx), (cte.disktab_ctx), required, cte.chx, statusp);

001074  aa  6 00040 3735 20	epp7 	pr6|32,*
001075  aa  7 00114 3715 20	epp5 	pr7|76,*		gtep
001076  aa  5 00007 2361 00	ldq  	pr5|7		gte.disk_data_subsystem_idx
001077  aa  6 00100 7561 00	stq  	pr6|64
001100  aa  7 00116 3535 20	epp3 	pr7|78,*		ctep
001101  aa  3 00001 2351 00	lda  	pr3|1		cte.disktab_ctx
001102  aa   000011 7350 00	als  	9
001103  aa   000077 7730 00	lrl  	63
001104  aa  6 00101 7561 00	stq  	pr6|65
001105  aa  6 00100 3521 00	epp2 	pr6|64
001106  aa  6 00104 2521 00	spri2	pr6|68
001107  aa  6 00101 3521 00	epp2 	pr6|65
001110  aa  6 00106 2521 00	spri2	pr6|70
001111  aa  7 00106 3521 00	epp2 	pr7|70		required
001112  aa  6 00110 2521 00	spri2	pr6|72
001113  aa  3 00005 3521 00	epp2 	pr3|5		cte.chx
001114  aa  6 00112 2521 00	spri2	pr6|74
001115  aa  7 00110 3521 00	epp2 	pr7|72		statusp
001116  aa  6 00114 2521 00	spri2	pr6|76
001117  aa  6 00102 6211 00	eax1 	pr6|66
001120  aa   024000 4310 07	fld  	10240,dl
001121  la  4 00012 3521 20	epp2 	pr4|10,*		disk_control$usurp_channel
001122  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 344
	usurped = (cte.chx ^= 0);

001123  aa  6 00040 3735 20	epp7 	pr6|32,*
001124  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
001125  aa  5 00005 2361 00	ldq  	pr5|5		cte.chx
001126  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
001127  aa  7 00113 7551 00	sta  	pr7|75		usurped
						STATEMENT 1 ON LINE 345
	if ^usurped then
	     return;

001130  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 348
	cte.statusp = statusp;

001131  aa  7 00110 3535 20	epp3 	pr7|72,*		statusp
001132  aa  5 00004 5431 00	sprp3	pr5|4		cte.statusp
						STATEMENT 1 ON LINE 349
	cte.ioi_use = "1"b;

001133  aa   400000 2350 03	lda  	131072,du
001134  aa  5 00001 2551 00	orsa 	pr5|1		cte.ioi_use
						STATEMENT 1 ON LINE 350
	used_chan_count = used_chan_count + 1;

001135  aa  7 00112 0541 00	aos  	pr7|74		used_chan_count
						STATEMENT 1 ON LINE 351
	call ioi_masked$getwork_channel (ctep);

001136  aa  7 00116 3521 00	epp2 	pr7|78		ctep
001137  aa  6 00104 2521 00	spri2	pr6|68
001140  aa  6 00102 6211 00	eax1 	pr6|66
001141  aa   004000 4310 07	fld  	2048,dl
001142  aa  6 00044 3701 20	epp4 	pr6|36,*
001143  la  4 00020 3521 20	epp2 	pr4|16,*		ioi_masked$getwork_channel
001144  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 353
     end usurp_chan;

001145  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE usurp_chan
BEGIN PROCEDURE cede_chan
ENTRY TO cede_chan                                          STATEMENT 1 ON LINE 357
cede_chan:
     proc;

001146  da     000256200000
001147  aa   000140 6270 00	eax7 	96
001150  aa  7 00034 3521 20	epp2 	pr7|28,*
001151  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
001152  aa     000000000000
001153  aa     000000000000
						STATEMENT 1 ON LINE 361
	call ioi_masked$quiesce_channel (ctep);

001154  aa  6 00040 3735 20	epp7 	pr6|32,*
001155  aa  7 00116 3521 00	epp2 	pr7|78		ctep
001156  aa  6 00102 2521 00	spri2	pr6|66
001157  aa  6 00100 6211 00	eax1 	pr6|64
001160  aa   004000 4310 07	fld  	2048,dl
001161  la  4 00022 3521 20	epp2 	pr4|18,*		ioi_masked$quiesce_channel
001162  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 362
	do while (cte.connected | cte.quiescing);

001163  aa   000000 0110 03	nop  	0,du
001164  aa  6 00040 3735 20	epp7 	pr6|32,*
001165  aa  7 00116 3715 20	epp5 	pr7|78,*		ctep
001166  aa  5 00001 2351 00	lda  	pr5|1		cte.quiescing
001167  aa   240000 3150 03	cana 	81920,du
001170  aa   000002 6000 04	tze  	2,ic		001172
						STATEMENT 1 ON LINE 363
	end;

001171  aa   777773 7100 04	tra  	-5,ic		001164
						STATEMENT 1 ON LINE 364
	cte.ioi_use = "0"b;

001172  aa   000033 2350 04	lda  	27,ic		001225 = 377777777777
001173  aa  5 00001 3551 00	ansa 	pr5|1		cte.ioi_use
						STATEMENT 1 ON LINE 365
	used_chan_count = used_chan_count - 1;

001174  aa   000001 3360 07	lcq  	1,dl
001175  aa  7 00112 0561 00	asq  	pr7|74		used_chan_count
						STATEMENT 1 ON LINE 367
	call disk_control$cede_channel ((gte.disk_data_subsystem_idx), (cte.disktab_ctx), cte.chx, (cte.statusp));

001176  aa  7 00114 3535 20	epp3 	pr7|76,*		gtep
001177  aa  3 00007 2361 00	ldq  	pr3|7		gte.disk_data_subsystem_idx
001200  aa  6 00104 7561 00	stq  	pr6|68
001201  aa  5 00001 2351 00	lda  	pr5|1		cte.disktab_ctx
001202  aa   000011 7350 00	als  	9
001203  aa   000077 7730 00	lrl  	63
001204  aa  6 00105 7561 00	stq  	pr6|69
001205  aa  5 00004 7611 00	lprp1	pr5|4		cte.statusp
001206  aa  6 00106 2515 00	spri1	pr6|70
001207  aa  6 00104 3521 00	epp2 	pr6|68
001210  aa  6 00112 2521 00	spri2	pr6|74
001211  aa  6 00105 3521 00	epp2 	pr6|69
001212  aa  6 00114 2521 00	spri2	pr6|76
001213  aa  5 00005 3521 00	epp2 	pr5|5		cte.chx
001214  aa  6 00116 2521 00	spri2	pr6|78
001215  aa  6 00106 3521 00	epp2 	pr6|70
001216  aa  6 00120 2521 00	spri2	pr6|80
001217  aa  6 00110 6211 00	eax1 	pr6|72
001220  aa   020000 4310 07	fld  	8192,dl
001221  aa  6 00044 3701 20	epp4 	pr6|36,*
001222  la  4 00014 3521 20	epp2 	pr4|12,*		disk_control$cede_channel
001223  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 370
     end cede_chan;

001224  aa  0 00631 7101 00	tra  	pr0|409		return_mac
  END PROCEDURE cede_chan
  END PROCEDURE ioi_usurp_channels


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
