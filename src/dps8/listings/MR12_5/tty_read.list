	COMPILATION LISTING OF SEGMENT tty_read
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0935.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(88-06-20,Berno), approve(88-07-13,MCR7928),
       17*     audit(88-06-20,Parisek), install(88-07-19,MR12.2-1061):
       18*     Removed reference to wtcb.prompt_len and "enter_receive" order call as
       19*     part of the UNCP multiplexer (DSA gateway) implementation.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /* format: style4,delnl,insnl,^ifthendo */
       24 tty_read:
       25      proc (twx, a_readp, a_offset, a_nelem, a_nelemt, state, ercode);
       26 						/* to convert from read chain */
       27 
       28 /* Read portion of the ring 0 ttydim
       29*   Rewritten by Robert S. Coren, 2/12/76
       30*   Modified 04/22/77 by J. Stern to introduce TCBs and WTCBs
       31*   Modified 12/29/77 by Robert Coren to use tty_space_man
       32*   Modified 05/05/78 by Robert Coren to add get_line entry
       33*   Modified August 78 by J. Nicholls to use channel_manager$ to get data to process for multiplexer implementation
       34*   Modified June 29 1979 by B. Greenberg for Multiplexer-Echo Negotiation.
       35*   Modified 18 September 1980 by G. Palter to fix MCS bug #203
       36*   Modified: 11 November 1980 by G. Palter to support can_type mode
       37*   Modified February 1981 by Robert Coren to add read_with_mark entry
       38*   Modified May 1981 by J. Bongiovanni for response time metering
       39*   Modified May 1981 by Robert Coren to make sure fblock and lblock always consistent
       40*   Modified 19 March 1982 by W. York to add tty_read_echoed entry as replacement
       41*   for echo_negotiate_get_chars, and fix bug in mark handling in
       42*   procedure get_more_data.
       43*   Modified November 1982 by Robert Coren to return wtcb.error_code.
       44*   Report on June 83 - modifications for the Datanet 7100.fd
       45*   Date of the last modification 04/17/84 */
       46 
       47 /* PARAMETERS */
       48 
       49 dcl  twx fixed bin;					/* device index */
       50 dcl  a_readp ptr;					/* pointer to caller's buffer */
       51 dcl  a_offset fixed bin (24);				/* offset in buffer to start at */
       52 dcl  a_buffer char (*);				/* caller's buffer (used by read_with_mark entry) */
       53 dcl  a_nelem fixed bin (24);				/* maximum number of chars to return */
       54 dcl  a_nelemt fixed bin (24);				/* actual number of characters returned */
       55 						/* (OUTPUT) */
       56 dcl  a_screen_left fixed bin;				/* Space left on line, negotiate entry */
       57 dcl  a_echoed fixed bin (24);				/* Chars echoed by interrupt side */
       58 						/* (OUTPUT) */
       59 dcl  nl_found bit (1);				/* whether get_line found newline (OUTPUT) */
       60 dcl  a_mark_index fixed bin (21);			/* index in returned string of "mark" (OUTPUT) */
       61 dcl  state fixed bin;				/* current state of channel (OUTPUT) */
       62 dcl  ercode fixed bin (35);				/* status code (OUTPUT) */
       63 
       64 
       65 /* AUTOMATIC */
       66 
       67 dcl  devx fixed bin;				/* local copy of twx */
       68 dcl  output_ptr ptr;				/*  "      "   " readp */
       69 dcl  offset fixed bin (24);				/*  "      "   " a_offset */
       70 dcl  nelem fixed bin (24);				/*  "      "   " a_nelem */
       71 dcl  nelemt fixed bin (24);				/*  "      "   " a_nelemt */
       72 dcl  echoed fixed bin (24);				/*  "      "   " a_echoed */
       73 dcl  screen_left fixed bin;				/*  "      "   " a_screen_left */
       74 
       75 dcl  ttytp ptr;					/* pointer to tty_tables segment */
       76 dcl  special_ptr ptr;
       77 dcl  mvtp ptr;
       78 dcl  tctp ptr;
       79 dcl  get_line_entry bit (1);				/* "1"b if get_line entry called, otherwise "0"b */
       80 dcl  negotiate_entry bit (1);				/* "1"b if negotiate entry called, otherwise "0"b */
       81 dcl  obsolete_negotiate_entry bit (1);			/* "1"b if echo_negotaite_get_chars, otherwise tty_read_echoed */
       82 dcl  mark_entry bit (1);				/* "1"b if read_with_mark entry called, otherwise "0"b */
       83 dcl  break_found bit (1);
       84 dcl  convert bit (1);				/* used to indicate copying from converted buffers */
       85 dcl  throw_away bit (1);				/* indicates last char was hardware esc */
       86 dcl  have_more_data bit (1) aligned;			/* lower level mux has another buffer chain he didnt give us this time */
       87 dcl  unconverted_break bit (1);
       88 dcl  no_break_anywhere bit (1);			/* no break anywhere in current input chain */
       89 dcl  orig_output_ptr ptr;				/* first set value of output_ptr */
       90 dcl  source_ptr ptr;
       91 dcl  target_ptr ptr;
       92 dcl  old_sourcep ptr;
       93 dcl  old_targetp ptr;
       94 dcl  source_len fixed bin;
       95 dcl  target_len fixed bin;
       96 
       97 dcl  new_blockp ptr;
       98 dcl  data_ptr ptr;
       99 dcl  new_block fixed bin (18);
      100 dcl  room_left fixed bin;
      101 dcl  first_char fixed bin;
      102 dcl  old_fblock fixed bin (18);
      103 dcl  last_block fixed bin (18);
      104 dcl  new_tally fixed bin;
      105 dcl  temp_buf char (60) aligned;			/* automatic copy of data from tty buffer */
      106 dcl  orig_fchar fixed bin;
      107 dcl  mark_index fixed bin;
      108 dcl  pmark_index fixed bin;				/* mark index used for preconverted input */
      109 
      110 dcl  time_spent fixed bin (71);
      111 dcl  start_time fixed bin (71);			/* clock time at entry */
      112 dcl  max_len fixed bin;
      113 dcl  break char (1);				/* break character from device_defaults */
      114 dcl  chars_in_buf fixed bin;
      115 dcl  next_break fixed bin;
      116 
      117 dcl  xr fixed bin;					/* used for result of index builtin */
      118 dcl  can_called bit (1);				/* indicates whether canon_procedure called */
      119 dcl  canon_procedure variable
      120 	entry (pointer, fixed binary, fixed binary, character (1) aligned, character (1) aligned, fixed binary (35));
      121 dcl  code fixed bin (35);
      122 
      123 dcl  tempp ptr;
      124 
      125 dcl  kill_char char (1) aligned;
      126 dcl  erase_char char (1) aligned;
      127 dcl  bx fixed bin;					/* used in verify of white space */
      128 dcl  i fixed bin;					/* temporary work variable */
      129 dcl  next_char char (1) aligned;
      130 dcl  uncp_flag bit (1);				/* designate UNCP mpx */
      131 
      132 dcl  1 octal aligned,
      133        2 pad bit (27) unal,
      134        2 result fixed bin (8) unal;			/* so arithmetic value can be easily addressed as char */
      135 
      136 dcl  1 echo_start_data aligned,
      137        2 ctr fixed bin (35),
      138        2 screenleft fixed bin (35);
      139 
      140 dcl  digit fixed bin;
      141 dcl  rawcnt fixed bin;
      142 dcl  old_rawcnt fixed bin;
      143 dcl  raw_mode bit (1);
      144 
      145 dcl  1 util aligned,				/* structure passed to tty_util_$tct */
      146 						/* first 3 items in this structure are */
      147 						/* also used as general automatic variables */
      148        2 stringp ptr,
      149        2 stringl fixed bin,
      150        2 ctally fixed bin,
      151        2 tablep ptr,
      152        2 indicator fixed bin,
      153        2 pad (3) fixed bin;				/* workspace for tty_util_ */
      154 
      155 dcl  buffer_1 char (720) aligned;
      156 dcl  buffer_2 char (720) aligned;
      157 
      158 /* INTERNAL STATIC CONSTANTS */
      159 
      160 dcl  crash fixed bin int static options (constant) init (1);/* for crashing system with syserr */
      161 dcl  BSIZE fixed bin int static options (constant) init (16);
      162 						/* word size for preconverted buffers */
      163 dcl  BREAK_CHAR fixed bin int static options (constant) init (1);
      164 dcl  ESCAPE_CHAR fixed bin int static options (constant) init (2);
      165 dcl  THROW_AWAY fixed bin int static options (constant) init (3);
      166 dcl  FORM_FEED fixed bin int static options (constant) init (4);
      167 dcl  HARDWARE_CONTROL fixed bin int static options (constant) init (5);
      168 dcl  DIALED_UP fixed bin int static options (constant) init (5);
      169 
      170 /* various strange-looking character strings */
      171 
      172 dcl  left_motion char (2) aligned int static options (constant) init ("");
      173 						/* BS, CR */
      174 
      175 dcl  right_motion char (2) aligned int static options (constant) init ("	 ");
      176 						/* HT, SP */
      177 
      178 dcl  vertical_motion char (2) aligned int static options (constant) init
      179 						/* FF, VT */
      180 	("");
      181 
      182 dcl  all_white char (6) aligned int static options (constant) init
      183 						/* NUL, BS, HT, NL, CR, SP */
      184 	(" 	
      185  ");
      186 
      187 dcl  nl char (1) aligned int static options (constant) init ("
      188 ");						/* NL */
      189 
      190 dcl  bs char (1) aligned int static options (constant) init ("");
      191 						/* BS */
      192 
      193 dcl  nul_char char (1) aligned int static options (constant) init (" ");
      194 						/* NUL */
      195 
      196 dcl  no_control_input (16) bit (1) int static options (constant) init ("0"b, (2) (1)"1"b, (13) (1)"0"b);
      197 
      198 dcl  nocontrol (128) bit (9) int static options (constant)
      199 	init ("000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "010"b3, "011"b3, "012"b3,
      200 	"013"b3, "014"b3, "015"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3, "000"b3,
      201 	"000"b3, "000"b3, "000"b3, "000"b3, "033"b3, "000"b3, "000"b3, "000"b3, "000"b3, "040"b3, "041"b3, "042"b3,
      202 	"043"b3, "044"b3, "045"b3, "046"b3, "047"b3, "050"b3, "051"b3, "052"b3, "053"b3, "054"b3, "055"b3, "056"b3,
      203 	"057"b3, "060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3, "070"b3, "071"b3, "072"b3,
      204 	"073"b3, "074"b3, "075"b3, "076"b3, "077"b3, "100"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3,
      205 	"107"b3, "110"b3, "111"b3, "112"b3, "113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3, "121"b3, "122"b3,
      206 	"123"b3, "124"b3, "125"b3, "126"b3, "127"b3, "130"b3, "131"b3, "132"b3, "133"b3, "134"b3, "135"b3, "136"b3,
      207 	"137"b3, "140"b3, "141"b3, "142"b3, "143"b3, "144"b3, "145"b3, "146"b3, "147"b3, "150"b3, "151"b3, "152"b3,
      208 	"153"b3, "154"b3, "155"b3, "156"b3, "157"b3, "160"b3, "161"b3, "162"b3, "163"b3, "164"b3, "165"b3, "166"b3,
      209 	"167"b3, "170"b3, "171"b3, "172"b3, "173"b3, "174"b3, "175"b3, "176"b3, "000"b3);
      210 
      211 
      212 /* ENTRIES */
      213 
      214 dcl  meter_response_time entry (bit (36) aligned, fixed bin),
      215      syserr ext entry options (variable),
      216      tty_lock$lock_channel entry (fixed bin, fixed bin (35)),
      217      tty_lock$unlock_channel entry (fixed bin);
      218 
      219 dcl  tty_index$initialize_tcb entry (ptr, ptr);
      220 dcl  tty_util_$mvt entry (ptr);
      221 dcl  tty_util_$tct entry (ptr);
      222 dcl  tty_overstrike_canon
      223 	entry (pointer, fixed binary, fixed binary, character (1) aligned, character (1) aligned, fixed binary (35));
      224 dcl  tty_replace_canon
      225 	entry (pointer, fixed binary, fixed binary, character (1) aligned, character (1) aligned, fixed binary (35));
      226 dcl  tty_write$locked entry (fixed bin, ptr, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin (35));
      227 
      228 
      229 /* EXTERNAL STATIC */
      230 
      231 dcl  tty_tables$ ext static;
      232 dcl  error_table_$invalid_write ext static fixed bin (35);
      233 dcl  error_table_$badcall ext static fixed bin (35);
      234 dcl  error_table_$improper_data_format ext static fixed bin (35);
      235 dcl  error_table_$io_no_permission ext static fixed bin (35);
      236 dcl  error_table_$invalid_device ext static fixed bin (35);
      237 dcl  error_table_$line_status_pending ext static fixed bin (35);
      238 dcl  error_table_$echnego_awaiting_stop_sync ext static fixed bin (35);
      239 dcl  error_table_$no_table ext static fixed bin (35);
      240 dcl  pds$processid ext static bit (36) aligned;
      241 
      242 
      243 /* BASED */
      244 
      245 dcl  based_buf char (60) based;
      246 dcl  based_chars (0:10) char (1) unal based;
      247 dcl  based_one_char char (1) unal based;
      248 dcl  based_string char (stringl) based (stringp);
      249 dcl  based_source char (source_len) based (old_sourcep);
      250 dcl  based_target char (target_len) based (old_targetp);
      251 dcl  table (0:127) fixed bin (8) unaligned based;
      252 
      253 
      254 dcl  1 mvt_args aligned based (addr (util)),		/* overlay of util structure for tty_util_$mvt */
      255        2 stringptr ptr,
      256        2 stringlen fixed bin,
      257        2 pad fixed bin,
      258        2 tablep ptr,
      259        2 targetp ptr;
      260 
      261 /* BUILTINS */
      262 
      263 dcl  (addr, bin, clock, divide, fixed, index, length, min, null, ptr, rank, rel, reverse, search, substr, verify) builtin;
      264 
      265 dcl  cleanup condition;				/*						*/
  1     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
  1     2 
  1     3 /* tty_ conversion tables */
  1     4 /* Created 11/3/75 by Robert S. Coren */
  1     5 /* Info structures added 5/19/77 by Robert S. Coren */
  1     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
  1     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
  1     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
  1     9 
  1    10 
  1    11 /****^  HISTORY COMMENTS:
  1    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
  1    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
  1    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
  1    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
  1    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
  1    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
  1    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
  1    19*     SPECIAL_INFO_STRUCT_VERSION_1.
  1    20*                                                   END HISTORY COMMENTS */
  1    21 
  1    22 
  1    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  1    24 
  1    25 
  1    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
  1    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
  1    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  1    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
  1    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  1    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  1    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  1    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
  1    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
  1    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
  1    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
  1    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  1    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
  1    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  1    40 						/* use in ^edited mode */
  1    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  1    42 						/* use in edited mode */
  1    43 	  2 input_escapes	     aligned,
  1    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
  1    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
  1    46 						/* escape sequence characters */
  1    47 	  2 input_results	     aligned,
  1    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
  1    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
  1    50 						/* results of escape sequences */
  1    51 
  1    52 
  1    53      dcl	c_chars_ptr	     ptr;
  1    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
  1    55 	  2 count		     fixed bin (8) unaligned,
  1    56 	  2 chars		     (15) char (1) unaligned;
  1    57 
  1    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
  1    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
  1    60 
  1    61 
  1    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
  1    63 	  2 value		     (0:255) fixed bin (8) unal;
  1    64 
  1    65 
  1    66      dcl	1 delay		     based aligned,		/* delay counts for output */
  1    67 	  2 vert_nl	     fixed bin,
  1    68 	  2 horz_nl	     float bin,
  1    69 	  2 const_tab	     fixed bin,
  1    70 	  2 var_tab	     float bin,
  1    71 	  2 backspace	     fixed bin,
  1    72 	  2 vt_ff		     fixed bin;
  1    73 
  1    74 /* info structures used with orders */
  1    75 
  1    76      dcl	1 special_chars_struc    aligned based,
  1    77 	  2 version	     fixed bin,
  1    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
  1    79 	  2 special_chars,				/* same as level-1 above */
  1    80 						/* has to be spelled out instead of using like */
  1    81 						/* because of refer options */
  1    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
  1    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  1    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
  1    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  1    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  1    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  1    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
  1    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
  1    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
  1    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
  1    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  1    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
  1    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  1    95 						/* use in ^edited mode */
  1    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  1    97 						/* use in edited mode */
  1    98 	    3 input_escapes	     aligned,
  1    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
  1   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
  1   101 						/* escape sequence characters */
  1   102 	    3 input_results	     aligned,
  1   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
  1   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
  1   105 						/* results of escape sequences */
  1   106 
  1   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
  1   108 	  2 version	     fixed bin,
  1   109 	  2 default	     fixed bin,		/* as above */
  1   110 	  2 cv_trans	     like cv_trans;
  1   111 
  1   112      dcl	1 delay_struc	     aligned based,
  1   113 	  2 version	     fixed bin,
  1   114 	  2 default	     fixed bin,		/* as above */
  1   115 	  2 delay		     like delay;
  1   116 
  1   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
  1   118 	  2 version	     char (8),
  1   119 	  2 area_ptr	     pointer,
  1   120 	  2 table_ptr	     pointer;
  1   121 
  1   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
  1   123 			     char (8) int static options (constant) init ("sisv1000");
  1   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
  1   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
  1   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
  1   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
  1   128 
  1   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
  1   130 						/* indexed by version number */
  1   131 
  1   132 
  1   133 /* values for input and output conversion tables */
  1   134 
  1   135      dcl	(
  1   136 	INPUT_CONVERT_ORDINARY   init (0),
  1   137 	INPUT_CONVERT_BREAK	     init (1),
  1   138 	INPUT_CONVERT_ESCAPE     init (2),
  1   139 	INPUT_CONVERT_DISCARD    init (3),
  1   140 	INPUT_CONVERT_FORMFEED   init (4),
  1   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
  1   142 			     init (5),
  1   143 	INPUT_CONVERT_DSA_CR_PROCESSING
  1   144 			     init (6)
  1   145 	)		     fixed bin (8) unaligned internal static options (constant);
  1   146 
  1   147      dcl	(
  1   148 	OUTPUT_CONVERT_ORDINARY  init (0),
  1   149 	OUTPUT_CONVERT_NEWLINE   init (1),
  1   150 	OUTPUT_CONVERT_CR	     init (2),
  1   151 	OUTPUT_CONVERT_HT	     init (3),
  1   152 	OUTPUT_CONVERT_BS	     init (4),
  1   153 	OUTPUT_CONVERT_VT	     init (5),
  1   154 	OUTPUT_CONVERT_FF	     init (6),
  1   155 	OUTPUT_CONVERT_OCTAL     init (7),
  1   156 	OUTPUT_CONVERT_RRS	     init (8),
  1   157 	OUTPUT_CONVERT_BRS	     init (9),
  1   158 	OUTPUT_CONVERT_NO_MOTION init (10),
  1   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
  1   160 			     init (11),
  1   161 	OUTPUT_CONVERT_DONT_SEND init (12),
  1   162 	OUTPUT_CONVERT_NOT_USED_13
  1   163 			     init (13),
  1   164 	OUTPUT_CONVERT_NOT_USED_14
  1   165 			     init (14),
  1   166 	OUTPUT_CONVERT_NOT_USED_15
  1   167 			     init (15),
  1   168 	OUTPUT_CONVERT_NOT_USED_16
  1   169 			     init (16),
  1   170 	OUTPUT_CONVERT_FIRST_SPECIAL
  1   171 			     init (17)
  1   172 	)		     fixed bin (8) unaligned internal static options (constant);
  1   173 
  1   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
      266 
      267 /**/
  2     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      268 
      269 
  4     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  4     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  4     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  4     9*     implementation.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  4    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  4    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  4    17**/
  4    18 
  4    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  4    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  4    21 
  4    22 
  4    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  4    24     2 next bit (18),				/* foward pointer to next free block */
  4    25     2 size fixed bin;				/* number of words in this block */
  4    26 
  4    27 
  4    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  4    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  4    30     2 flags unaligned,
  4    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  4    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  4    33       3 break bit (1) unaligned,			/* buffer contains break character */
  4    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  4    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  4    36       3 pad bit (1) unaligned,
  4    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  4    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  4    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  4    40 
  4    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  4    42 
  4    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  4    44 
  4    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      270 
      271 
  5     1 /*  BEGIN INCLUDE FILE ... wtcb.incl.pl1 */
  5     2 						                                                                                                              
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  5     6*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  5     7*     Add data needed for the uncp multiplexer (DSA gateway) interface
  5     8*     implementation.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /*
  5    13*   Moved from tty_buf.incl.pl1 Aug 78 by J. Nicholls plus changes for ring 0 demultiplexing
  5    14*   Error code added Nov. 1982 by Robert Coren
  5    15*   Modified December 1984 by Robert Coren to invent "more_flags" structure and
  5    16*    its first flag, line_status_disabled
  5    17*   Reported modifications for the DN7100 interim in August 85.
  5    18**/
  5    19 
  5    20 dcl  wtcbp ptr;					/* pointer to head of wtcb */
  5    21 
  5    22 dcl 1 wtcb based (wtcbp) aligned,			/* wired terminal control block */
  5    23     2 hevent fixed bin (71) aligned,			/* event channel for hangup/dialup signal */
  5    24     2 event fixed bin (71) aligned,			/* users event channel, for uproc */
  5    25 
  5    26     2 line_status bit (72) aligned,			/* actual line status sent by fnp */
  5    27 
  5    28     2 tcb_ptr ptr unal,				/* pointer to tcb */
  5    29     2 pad1 fixed bin (35),				/* formerly time dialedup */
  5    30 
  5    31     2 hproc bit (36) aligned,				/* boss processid */
  5    32     2 uproc bit (36) aligned,				/* tty user processid */
  5    33 
  5    34     2 baud_rate fixed bin (18) unal uns,		/* baud rate of this line */
  5    35     2 line_type fixed bin (18) unal uns,		/* line type for line protocol */
  5    36 
  5    37     2 flags unaligned,
  5    38       3 listen bit (1) unaligned,			/* if on, listen for dialups */
  5    39       3 dialed bit (1) unaligned,			/* if on, line is dialed up */
  5    40       3 send_output bit (1) unaligned,			/* on if DN355 requested more output */
  5    41 
  5    42       3 qenable bit (1) unaligned,			/* if on, signal quits */
  5    43       3 qflag bit (1) unaligned,			/* on after quit, causes writes to be ignored */
  5    44       3 end_frame bit (1) unaligned,			/* write chain fills ards frame */
  5    45 
  5    46       3 notify_reqd bit (1) unaligned,			/* if on, do notify after unlocking lock */
  5    47       3 work_reqd bit (1) unaligned,			/* if on, call dn355 before returning */
  5    48       3 dialing bit (1) unaligned,			/* if on, 355 is dialing a phone number */
  5    49 
  5    50       3 dial_status_valid bit (1) unaligned,		/* if on, dial_status_code is valid */
  5    51       3 input_available bit (1) unaligned,		/* input for this device is waiting in wired space */
  5    52       3 tcb_initialized bit (1) unaligned,		/* if on, tcb has been initialized */
  5    53 
  5    54       3 wflag bit (1) unaligned,			/* process blocked on output */
  5    55       3 rflag bit (1) unaligned,			/* process blocked on input */
  5    56       3 wru bit (1) unaligned,			/* reading answerback */
  5    57 
  5    58       3 hndlquit bit (1) unaligned,			/* on if in hndlquit mode */
  5    59       3 count_lines bit (1) unaligned,			/* on if tcb.linemax > 0 */
  5    60       3 line_status_present bit (1) unaligned,		/* fnp has sent line status */
  5    61 
  5    62       3 sync_line bit (1) unaligned,			/* channel is synchronous line type */
  5    63       3 breakall bit (1) unaligned,			/* channel is in breakall mode */
  5    64       3 scroll bit (1) unaligned,			/* channel is in scroll mode */
  5    65 
  5    66       3 negotiating_echo bit (1) unaligned,		/* ring zero to echo chars. */
  5    67       3 wake_tbl bit (1) unaligned,			/* on if in wake_tbl mode */
  5    68       3 allow_wakeup bit (1) unaligned,			/* on to allow input wakeup in wake_tbl mode */
  5    69 
  5    70       3 receive_mode_device bit (1) unaligned,		/* device must be told to enter receive mode */
  5    71       3 mark_set bit (1) unal,			/* write_with_mark call outstanding */
  5    72       3 masked bit (1) unal,				/* channel masked by FNP */
  5    73 
  5    74     2 dial_status_code fixed bin (8) unaligned,		/* code returned by 355 after dialing a phone number */
  5    75 
  5    76     2 fblock fixed bin (17) unaligned,			/* oldest read pointer, block */
  5    77     2 lblock fixed bin (17) unaligned,			/* newest read block */
  5    78 
  5    79     2 fchar fixed bin (9) unsigned unaligned,		/* first block char index */
  5    80     2 actline fixed bin (9) unsigned unaligned,		/* line number of current line */
  5    81     2 actcol fixed bin (9) unsigned unaligned,		/* tty column position */
  5    82     2 nramsgs fixed bin (9) unsigned unaligned,		/* current number of read-ahead msgs */
  5    83 
  5    84     2 write_first fixed bin (17) unaligned,		/* first write block */
  5    85     2 write_last fixed bin (17) unaligned,		/* last write block */
  5    86     2 write_cnt fixed bin (17) unaligned,		/* count of chars in write chain */
  5    87     2 white_col fixed bin (17) unaligned,		/* column position resulting from trailing white space */
  5    88 
  5    89     2 max_buf_size fixed bin (9) unal uns,		/* maximum-size buffer to be allocated for this channel */
  5    90     2 buffer_pad fixed bin (9) unal uns,		/* amount of pad to be left in output buffers */
  5    91     2 devx fixed bin (17) unaligned,			/* index into lct of channel's entry */
  5    92     2 echdp bit (18) unaligned,			/* echo negotiation data ptr */
  5    93     2 waketp bit (18) unaligned,			/* wakeup table offset */
  5    94     2 prompt_len fixed bin (8) unaligned,		/* number of chars in prompt string */
  5    95     2 prompt char (3) unaligned,			/* text of prompt message */
  5    96     2 line_delimiter char (1) unal,			/* line delimiter for tty_read parse */
  5    97     2 more_flags unaligned,				/* in addition to flags (above) */
  5    98       3 line_status_disabled bit (1) unaligned,		/* "1"b => don't relay line_status interrupts */
  5    99     2 send_turn bit (1) unal,				/* For the Dn7100 interim */
  5   100     2 pad bit (25) unal,
  5   101     2 error_code fixed bin (35),			/* error code returned by channel_manager to tty_interrupt */
  5   102     2 pad2 bit (36);
  5   103 
  5   104 /* Ends on doubleword boundary */
  5   105 
  5   106 /* END INCLUDE FILE ... wtcb.incl.pl1 */
      272 
      273 
  6     1 /* BEGIN INCLUDE FILE ... tcb.incl.pl1 */
  6     2 
  6     3 /* Date Last Modified and Reason
  6     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  6     5*   Modified 2/6/78 by Robert Coren to add input_msg_size
  6     6*   Modified 4/18/78 by Robert Coren to add framing_chars
  6     7*   Modified 8/31/78 by J. Nicholls to add scroll mode
  6     8*   Extracted 9/12/78 by J. Stern from tty_data.incl.pl1
  6     9*   Modified Oct.1979 by Robert Coren to expand to 36 possible modes
  6    10*   Modified 1/21/80 by Robert Coren to add no_outp, oddp, & eight_bit modes
  6    11*   Modified 10/08/80 by Robert Coren to add meters for tty_read & tty_write
  6    12*   Modified: 10 November 1980 by G. Palter to add can_type and explicit padding
  6    13*   Modified 12/04/80 by Robert Coren to add saved copy of meters
  6    14*   Modified 2/24/81 by Robert Coren to add time spent in tty_read and _write
  6    15*   Modified April 1981 by Robert Coren to add time last dialed up
  6    16**/
  6    17 
  6    18 dcl  tcbp ptr;
  6    19 
  6    20 dcl 1 tcb based (tcbp) aligned,			/* declaration of per terminal control block */
  6    21 
  6    22     2 terminal_type char (32) unaligned,		/* terminal type name */
  6    23     2 tables,
  6    24       3 input_mvtrp bit (18) unaligned,			/* rel pointer to current input mvt table */
  6    25       3 output_mvtrp bit (18) unaligned,		/* rel pointer to current output mvt table */
  6    26       3 input_tctrp bit (18) unaligned,			/* rel pointer to current input tct table */
  6    27       3 output_tctrp bit (18) unaligned,		/* rel pointer to current output tct table */
  6    28       3 specialrp bit (18) unaligned,			/* rel pointer to current special chars table */
  6    29       3 delayrp bit (18) unaligned,			/* rel pointer to current delay table */
  6    30     2 default_tables,
  6    31       3 df_input_mvtrp bit (18) unaligned,		/* rel pointer to default input mvt table */
  6    32       3 df_output_mvtrp bit (18) unaligned,		/* rel pointer to default output mvt table */
  6    33       3 df_input_tctrp bit (18) unaligned,		/* rel pointer to default input tct table */
  6    34       3 df_output_tctrp bit (18) unaligned,		/* rel pointer to default output tct table */
  6    35       3 df_specialrp bit (18) unaligned,		/* rel pointer to default special chars table */
  6    36       3 df_delayrp bit (18) unaligned,			/* rel pointer to default delay table */
  6    37     2 special_input_chars unaligned,
  6    38       3 erase char (1) unaligned,			/* erase character */
  6    39       3 kill char (1) unaligned,			/* kill character */
  6    40     2 old_type fixed bin (17) unaligned,		/* old terminal type number */
  6    41 
  6    42     2 modes unaligned,				/* modes set by order call */
  6    43       3 edited bit (1) unaligned,			/* edited output mode */
  6    44       3 tabm bit (1) unaligned,			/* insert output tabs mode */
  6    45       3 canm bit (1) unaligned,			/* do canonical form conversion */
  6    46 
  6    47       3 escm bit (1) unaligned,			/* do input escape conversions */
  6    48       3 erklm bit (1) unaligned,			/* do erase kill processing */
  6    49       3 rawim bit (1) unaligned,			/* don't convert input */
  6    50 
  6    51       3 rawom bit (1) unaligned,			/* don't convert output */
  6    52       3 redm bit (1) unaligned,			/* has red-shift function */
  6    53       3 vertsp bit (1) unaligned,			/* send real ff's and vt's if on, else escape them */
  6    54 
  6    55       3 echo_cr bit (1) unaligned,			/* echo carriage returns */
  6    56       3 echo_lf bit (1) unaligned,			/* echo line feeds */
  6    57       3 echo_tab bit (1) unaligned,			/* echo tabs */
  6    58 
  6    59       3 hndlquit bit (1) unaligned,			/* cr's on quit */
  6    60       3 full_duplex bit (1) unaligned,			/* xmit and receive simultaneously */
  6    61       3 echoplex bit (1) unaligned,			/* echo input characters on terminal */
  6    62 
  6    63       3 upper_case bit (1) unaligned,			/* map lower-case output into upper-case */
  6    64       3 replay bit (1) unaligned,			/* replay interrupted input */
  6    65       3 polite bit (1) unaligned,			/* output must start at left margin */
  6    66 
  6    67       3 control bit (1) unaligned,			/* accept control characters */
  6    68       3 blk_xfer bit (1) unaligned,			/* block transfer or "frame" mode */
  6    69       3 breakall bit (1) unaligned,			/* break on all characters */
  6    70 
  6    71       3 scroll bit (1) unaligned,			/* scroll mode for crt terminals */
  6    72       3 prefixnl bit (1) unaligned,			/* prefix output iwth nl when input interrupted */
  6    73       3 wake_tbl bit (1) unaligned,			/* input wakeups determined by wakeup table */
  6    74 
  6    75       3 iflow bit (1) unaligned,			/* input flow control */
  6    76       3 oflow bit (1) unaligned,			/* output flow control */
  6    77       3 no_outp bit (1) unaligned,			/* don't generate output parity */
  6    78 
  6    79       3 eight_bit bit (1) unaligned,			/* don't strip input parity */
  6    80       3 odd_parity bit (1) unaligned,			/* generate odd parity (if any) */
  6    81 
  6    82       3 modes_pad bit (7) unaligned,
  6    83 
  6    84     2 id char (4) unaligned,				/* terminal id */
  6    85 
  6    86     2 colmax fixed bin (8) unaligned,			/* current maximum number of columns */
  6    87     2 linemax fixed bin (8) unaligned,			/* current maximum number of lines/frame */
  6    88     2 wrt_lchar fixed bin (17) unaligned,		/* char within last write block */
  6    89 
  6    90     2 input_msg_size fixed bin,			/* maximum input message size in chars */
  6    91     2 framing_chars unaligned,
  6    92       3 frame_begin char (1) unaligned,			/* frame-begin character */
  6    93       3 frame_end char (1) unaligned,			/* frame-end character */
  6    94     2 max_output_block fixed bin (18) unsigned unaligned,	/* maximum size of output block in block_acknowledge */
  6    95 
  6    96     2 input_suspend_seq unaligned,			/* sequence for input suspension */
  6    97       3 count fixed bin (9) unsigned,
  6    98       3 chars char (3),
  6    99     2 input_resume_seq unaligned,			/* likewise for input resumption */
  6   100       3 count fixed bin (9) unsigned,
  6   101       3 chars char (3),
  6   102 
  6   103     2 output_suspend_etb_seq unaligned,			/* sequence for output suspension or end_of_block */
  6   104       3 count fixed bin (9) unsigned,
  6   105       3 chars char (3),
  6   106     2 output_resume_ack_seq unaligned,			/* likewise for resumption or ack */
  6   107       3 count fixed bin (9) unsigned,
  6   108       3 chars char (3),
  6   109 
  6   110     2 flags unaligned,				/* tty dim flag bits */
  6   111       3 breakall_enabled bit (1) unaligned,		/* channel is permitted to use breakall mode */
  6   112       3 dont_count_next bit (1) unaligned,		/* next output character is escaped */
  6   113       3 keyboard_locking bit (1) unaligned,		/* ON if doing keybd locking for ASCIi line type */
  6   114       3 no_printer_off bit (1) unaligned,		/* reject printer_off/printer_on orders */
  6   115       3 break_char_pending bit (1) unaligned,		/* break character is in preconverted buffer */
  6   116       3 uproc_attached bit (1) unaligned,		/* user process has attached device */
  6   117       3 block_acknowledge bit (1) unaligned,		/* block acknowledgement output protocol */
  6   118       3 flags_pad bit (27) unaligned,
  6   119 
  6   120     2 actshift bit (2) unaligned,			/* tty shift, 00 none, 01 lower, 10 upper, 11 unknown */
  6   121 
  6   122     2 cumulative_meters,				/* continuously running meters */
  6   123       3 read_calls fixed bin (35),			/* number of calls to tty_read */
  6   124       3 write_calls fixed bin (35),			/* number of calls to tty_write */
  6   125       3 read_chars fixed bin (35),			/* after conversion */
  6   126       3 write_chars fixed bin (35),			/* before conversion */
  6   127       3 read_time fixed bin (71),			/* total time spent in tty_read */
  6   128       3 write_time fixed bin (71),			/* total time spent in tty_write */
  6   129     2 saved_meters like tcb.cumulative_meters,		/* meters saved at last dialup */
  6   130 
  6   131     2 can_type fixed binary (9) unaligned unsigned,	/* type of canonicalization to use on this channel */
  6   132     2 pad1 bit (27) unaligned,			/* to word boundary */
  6   133     2 time_dialed fixed bin (71);			/* clock time of last copy_meters order */
  6   134 
  6   135 /* END INCLUDE FILE ... tcb.incl.pl1 */
      274 
      275 
  7     1 /* BEGIN INCLUDE FILE ... tty_can_types.incl.pl1 */
  7     2 /* Created:  10 November 1980 by G. Palter */
  7     3 
  7     4 dcl (CAN_TYPE_OVERSTRIKE	initial (1),
  7     5      CAN_TYPE_REPLACE	initial (2))
  7     6 	fixed binary static options (constant);
  7     7 
  7     8 dcl  CAN_TYPE_NAMES (2) character (32) aligned static options (constant) initial
  7     9          ("can_type=overstrike", "can_type=replace");
  7    10 
  7    11 /* END INCLUDE FILE ... tty_can_types.incl.pl1 */
      276 
      277 
  8     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  8     2 
  8     3 /* Created by J. Stern 7/26/78 */
  8     4 /* Metering information added by C. Hornig, March 1980. */
  8     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  8     6 
  8     7 dcl  lctp ptr;					/* ptr to logical channel table */
  8     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  8     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  8    10 
  8    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  8    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  8    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  8    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  8    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  8    16     2 pad (11) fixed bin,
  8    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  8    18 
  8    19 
  8    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  8    21     2 lock bit (36),				/* channel lock */
  8    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  8    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  8    24     2 flags unal,
  8    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  8    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  8    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  8    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  8    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  8    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  8    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  8    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  8    33       3 trace bit (1) unal,				/* ON to trace this channel */
  8    34       3 unused bit (1) unal,
  8    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  8    36     2 major_channel_info,
  8    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  8    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  8    39     2 queue_entries,
  8    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  8    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  8    42     2 word_counts,
  8    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  8    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  8    45 
  8    46     2 meters,
  8    47       3 in_bytes fixed bin (35),
  8    48       3 out_bytes fixed bin (35),
  8    49       3 in,
  8    50         4 calls fixed bin (35),
  8    51         4 interrupts fixed bin (35),
  8    52         4 call_time fixed bin (71),
  8    53         4 interrupt_time fixed bin (71),
  8    54       3 out like lcte.meters.in,
  8    55       3 control like lcte.meters.in,
  8    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  8    57 
  8    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  8    59 
  8    60     2 pad (3) fixed bin (35);
  8    61 
  8    62 
  8    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  8    64 
  8    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  8    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  8    67 
  8    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  8    69 
  8    70 
  8    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      278 
      279 
  9     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  9     2 
  9     3 /* This include file declares all the entries in tty_space_man and defines the constants
  9     4**  to be used for the flags argument
  9     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  9     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  9     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  9     8**/
  9     9 
  9    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  9    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  9    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  9    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  9    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  9    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  9    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  9    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  9    18 dcl  tty_space_man$needs_space entry (fixed bin);
  9    19 
  9    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  9    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  9    22 
  9    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      280 
      281 
 10     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
 10     2 
 10     3 /* Created 8/25/78 by J. Stern */
 10     4 
 10     5 
 10     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
 10     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
 10     8 
 10     9 /* call channel_manager$write (devx, output_ptr, code) */
 10    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
 10    11 
 10    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
 10    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
 10    14 
 10    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
 10    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
 10    17 
 10    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
 10    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
 10    20 
 10    21 /* call channel_manager$get_modes (devx, modes, code) */
 10    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
 10    23 
 10    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
 10    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 10    26 
 10    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
 10    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
 10    29 
 10    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
 10    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 10    32 
 10    33 
 10    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      282 
      283 
 11     1 /* BEGIN INCLUDE FILE mcs_echo_neg_sys.incl.pl1   Bernard Greenberg 1/20/79 */
 11     2 
 11     3 /* Modified 6/29/79 by BSG for FNP echo negotiation */
 11     4 
 11     5 
 11     6 /****^  HISTORY COMMENTS:
 11     7*  1) change(86-04-23,Coren), approve(86-04-23,MCR7300),
 11     8*     audit(86-05-19,Beattie), install(86-07-08,MR12.0-1089):
 11     9*     To increase size of break table and to add named constants for the size.
 11    10*                                                   END HISTORY COMMENTS */
 11    11 
 11    12 
 11    13 /* This include file defines the wired structure for MCS echo negotiation */
 11    14 
 11    15 dcl echo_datap ptr;					/* Wired echo data ptr */
 11    16 dcl WIRED_ECHO_BREAK_SIZE fixed bin internal static options (constant) init (255);
 11    17 dcl WORDS_IN_ECHO_BREAK_TABLE fixed bin internal static options (constant) init (8);
 11    18 
 11    19 dcl 1 echo_data based (echo_datap) aligned,		/* Wired echo data */
 11    20     2 break (0: 255) bit (1) unaligned,			/* 1 = break on this character */
 11    21     2 synchronized bit (1) unal,			/* Mux echo negotiation is synchronized */
 11    22     2 mux_will_echnego bit (1) unal,			/* Multiplexer accepted start_neg_echnego */
 11    23     2 echo_start_pending_sndopt bit (1) unal,		/* Send start_n_e when SEND_OUTPUT comes */
 11    24     2 awaiting_start_sync bit (1) unal,			/* Awaiting mux reply ACK for start */
 11    25     2 awaiting_stop_sync bit (1) unal,			/* Awaiting mux reply ACK for stop */
 11    26     2 pad bit (27) unaligned,
 11    27     2 sync_ctr fixed bin (35),			/* Protocol ctr for MUX echo neg */
 11    28     2 chars_echoed fixed bin (9) unsigned unaligned,	/* Count of chars echoed */
 11    29     2 horiz_room_left fixed bin (9) unsigned unaligned,	/* Room left on line */
 11    30     2 rubout_trigger_chars (2) unaligned,		/* Characters that cause rubout action */
 11    31       3 char char (1) unaligned,
 11    32     2 rubout_sequence_length fixed bin (4) unsigned unaligned, /* Length of rubout sequence, output */
 11    33     2 rubout_pad_count fixed bin (4) unsigned unaligned,	/* Count of pads needed */
 11    34     2 buffer_rubouts bit (1) unaligned,			/* 1 = put rubouts and rubbed out in buffer */
 11    35     2 rubout_sequence char (12) unaligned;		/* Actual rubout sequence */
 11    36 
 11    37 /* END INCLUDE FILE mcs_echo_neg_sys.incl.pl1 */
      284 
      285 
 12     1 /*  START OF:	response_transitions.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
 12     2 
 12     3 /*  Transition identifiers for metering response time
 12     4*
 12     5*    Written April 1981 by J. Bongiovanni							*/
 12     6 
 12     7      dcl	  (AWARD_ELIGIBILITY      init(1),
 12     8 	   CALL_RING_0_TTY	      init (2),
 12     9 	   RETURN_RING_0_TTY      init (3),
 12    10 	   BLOCK_PROCESS	      init (4),
 12    11 	   NON_TTY_WAKEUP	      init (5),
 12    12 	   TTY_WAKEUP	      init (6),
 12    13 
 12    14 	   MAX_TRANSITION	      init (6)) fixed bin int static options (constant);
 12    15 
 12    16 /*  END OF:	response_transitions.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      286 
      287 
 13     1 /* Begin include file ..... multiplexer_types.incl.pl1 */
 13     2 
 13     3 
 13     4 
 13     5 /****^  HISTORY COMMENTS:
 13     6*  1) change(89-03-20,Parisek), approve(89-06-01,MCR8110),
 13     7*     audit(89-10-09,Farley), install(89-10-25,MR12.3-1100):
 13     8*     Add support of protocol mpx.
 13     9*                                                   END HISTORY COMMENTS */
 13    10 
 13    11 
 13    12 /* This include file defines known multiplexer types */
 13    13 /* Prepared August 1978 by Larry Johnson */
 13    14 /* Changed April 1979 to rename the fnp multiplexer mcs */
 13    15 
 13    16 dcl (TTY_MPX init (0),				/* nonmultiplexed channel */
 13    17      MCS_MPX init (1),				/* FNP running MCS */
 13    18      USER1_MPX init (2),				/* a range of values for user defined multiplexers */
 13    19      USER2_MPX init (3),
 13    20      USER3_MPX init (4),
 13    21      USER4_MPX init (5),
 13    22      USER5_MPX init (6),
 13    23      IBM3270_MPX init (7),				/* IBM 3270 display terminal controller */
 13    24      VIP7760_MPX init (8),				/* Honeywell VIP 7760 terminal controller */
 13    25      STY_MPX init (9),				/* Software Terminal Facility */
 13    26      LAP_MPX init (10),				/* Link Access Protocol (X.25 level 2) */
 13    27      X25_MPX init (11),				/* CCITT X.25 level 3 */
 13    28      HASP_MPX init (12),				/* HASP RJE protocol */
 13    29      UNCP_MPX init (13),				/* DSA protocol */
 13    30      SYSTEM2_MPX init (14),
 13    31      SYSTEM1_MPX init (15),
 13    32      PROTOCOL_MPX init (16))				/* TCP/IP network X.25 protocol */
 13    33      int static options (constant);
 13    34 
 13    35 dcl  mpx_types (0:16) char (32) int static options (constant) init (
 13    36      "tty", "mcs", "user1", "user2", "user3", "user4", "user5", "ibm3270",
 13    37      "vip7760", "sty", "lap", "x25", "hasp", "uncp", "system2", "system1",
 13    38      "protocol");
 13    39 
 13    40 dcl  mpx_special_lock (0:16) bit (1) int static options (constant) init (
 13    41      "0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b,
 13    42      "0"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b);
 13    43 
 13    44 /* End include file ..... multiplexer_types.incl.pl1 */
      288 
      289 /**/
      290 	get_line_entry = "0"b;			/* regular entry */
      291 	negotiate_entry = "0"b;
      292 	go to join;
      293 
      294 
      295 tty_get_line:
      296      entry (twx, a_readp, a_offset, a_nelem, a_nelemt, nl_found, state, ercode);
      297 
      298 	get_line_entry = "1"b;
      299 	negotiate_entry = "0"b;
      300 	go to join;
      301 
      302 tty_read_with_mark:
      303      entry (twx, a_buffer, a_nelemt, a_mark_index, state, ercode);
      304 
      305 	negotiate_entry, get_line_entry = "0"b;
      306 	output_ptr = addr (a_buffer);
      307 	nelem = length (a_buffer);
      308 	mark_entry = "1"b;
      309 	mark_index = 0;
      310 	go to mark_join;
      311 
      312 
      313 /* new entrpoint to return proper code in awaiting_stop_sync case */
      314 tty_read_echoed:
      315      entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_echoed, a_screen_left, state, ercode);
      316 
      317 	get_line_entry = "0"b;
      318 	negotiate_entry = "1"b;
      319 	obsolete_negotiate_entry = "0"b;
      320 	screen_left = a_screen_left;
      321 	echoed = 0;
      322 	goto join;
      323 
      324 /* obsolete entry left in to allow time for switchover */
      325 echo_negotiate_get_chars:
      326      entry (twx, a_readp, a_offset, a_nelem, a_nelemt, a_echoed, a_screen_left, state, ercode);
      327 
      328 	get_line_entry = "0"b;
      329 	negotiate_entry = "1"b;
      330 	obsolete_negotiate_entry = "1"b;
      331 	screen_left = a_screen_left;
      332 	echoed = 0;
      333 	goto join;
      334 
      335 join:
      336 	mark_entry = "0"b;
      337 	output_ptr = a_readp;
      338 	nelem = a_nelem;
      339 mark_join:
      340 	start_time = clock ();
      341 	ttybp = addr (tty_buf$);			/* get ptrs to tty_buf, tty_data */
      342 	call meter_response_time (pds$processid, CALL_RING_0_TTY);
      343 
      344 	devx = twx;				/* copy device index */
      345 	lctp = tty_buf.lct_ptr;			/* init pointer to lct */
      346 	if devx < 1 | devx > lct.max_no_lctes
      347 	then do;
      348 	     ercode = error_table_$invalid_device;
      349 	     call clean_up;
      350 	     return;
      351 	end;
      352 
      353 	uncp_flag = is_parent_mpx (UNCP_MPX);
      354 
      355 	call tty_lock$lock_channel (devx, ercode);	/* lock the channel lock */
      356 	if ercode ^= 0
      357 	then do;
      358 	     call clean_up;
      359 	     return;
      360 	end;
      361 
      362 	on cleanup call tty_lock$unlock_channel (devx);
      363 	lctep = addr (lct.lcte_array (devx));		/* get pointer to lcte of interest */
      364 	if lcte.channel_type ^= 0			/* don't talk to strangers */
      365 	then go to no_permission;
      366 	wtcbp = lcte.data_base_ptr;			/* get pointers to control blocks */
      367 	if ^wtcb.flags.dialed			/* if not dialed up */
      368 	then do;
      369 no_permission:
      370 	     call tty_lock$unlock_channel (devx);	/* unlock channel lock */
      371 	     ercode = error_table_$io_no_permission;
      372 	     call clean_up;
      373 	     return;
      374 	end;
      375 	state = DIALED_UP;
      376 
      377 	tcbp = wtcb.tcb_ptr;
      378 	if ^wtcb.tcb_initialized
      379 	then call tty_index$initialize_tcb (wtcbp, tcbp);
      380 
      381 	if wtcb.hproc ^= pds$processid		/* if not boss */
      382 	then if (wtcb.uproc ^= pds$processid) | ^tcb.uproc_attached
      383 						/* if not user */
      384 	     then do;
      385 		call tty_lock$unlock_channel (devx);	/* unlock channel lock */
      386 		call clean_up;
      387 		ercode = error_table_$io_no_permission;
      388 		return;
      389 	     end;
      390 
      391 	if wtcb.flags.line_status_present
      392 	then do;
      393 	     call clean_up;
      394 	     ercode = error_table_$line_status_pending;
      395 	     call tty_lock$unlock_channel (devx);
      396 	     return;
      397 	end;
      398 
      399 	if wtcb.error_code ^= 0
      400 	then do;
      401 	     ercode = wtcb.error_code;
      402 	     wtcb.error_code = 0;
      403 	     call tty_lock$unlock_channel (devx);
      404 	     return;
      405 	end;
      406 
      407 
      408 /**/
      409 	tcb.cumulative_meters.read_calls = tcb.cumulative_meters.read_calls + 1;
      410 	tty_buf.read_calls = tty_buf.read_calls + 1;
      411 	nelemt = 0;
      412 	if negotiate_entry
      413 	then do;
      414 	     if wtcb.echdp = "000000"b3
      415 	     then do;				/* Can't negotiate with no table! */
      416 		ercode = error_table_$no_table;
      417 		go to all_done;
      418 	     end;
      419 	     echo_datap = ptr (ttybp, wtcb.echdp);
      420 	     if screen_left = 0			/* Force stop echo magic */
      421 		& (wtcb.negotiating_echo | echo_data.awaiting_start_sync)
      422 	     then do;
      423 
      424 		echo_data.echo_start_pending_sndopt = "0"b;
      425 		if ^echo_data.awaiting_stop_sync
      426 		then do;
      427 		     call channel_manager$control (devx, "stop_negotiated_echo", null (), code);
      428 		     if code = 0
      429 		     then echo_data.awaiting_stop_sync = "1"b;
      430 		     else wtcb.negotiating_echo = "0"b;
      431 		end;
      432 		if echo_data.awaiting_stop_sync
      433 		then do;
      434 		     call tty_lock$unlock_channel (devx);
      435 		     call clean_up;
      436 		     a_echoed = 0;
      437 		     ercode = error_table_$echnego_awaiting_stop_sync;
      438 
      439 /* echo_negotiate_get_chars returns the wrong error code in this case
      440*   and must continue to do so for compatability for at least one release,
      441*   at which point the entry and this code can be flushed and everyone
      442*   will have switched to using tty_read_echoed */
      443 		     if obsolete_negotiate_entry
      444 		     then ercode = error_table_$line_status_pending;
      445 
      446 		     return;
      447 		end;
      448 	     end;
      449 	end;
      450 	if nelem = 0
      451 	then do;
      452 	     if ^negotiate_entry
      453 	     then wtcb.negotiating_echo = "0"b;
      454 
      455 /* Magic kludge to turn off echoing on ring-4 detected break conditions */
      456 /* This is "clean" because all non-negotiating calls are supposed to turn it off. */
      457 
      458 	     ercode = 0;
      459 	     go to all_done;
      460 	end;
      461 
      462 	if ^mark_entry
      463 	then offset = a_offset;
      464 	else offset = 0;
      465 	target_len = 0;
      466 	rawcnt = 0;
      467 	have_more_data = "0"b;
      468 	if offset ^= 0
      469 	then output_ptr = addr (output_ptr -> based_chars (offset));
      470 	orig_output_ptr = output_ptr;			/* in case we need this later */
      471 
      472 	if ^tcb.rawim
      473 	then do;
      474 	     if mark_entry				/* only supposed to be called in rawi */
      475 	     then do;
      476 		ercode = error_table_$badcall;
      477 		go to all_done;
      478 	     end;
      479 
      480 	     ttytp = addr (tty_tables$);
      481 	     if tcb.input_mvtrp = ""b
      482 	     then mvtp = null;
      483 	     else mvtp = ptr (ttytp, tcb.input_mvtrp);
      484 	     if tcb.input_tctrp = ""b
      485 	     then tctp = null;
      486 	     else tctp = ptr (ttytp, tcb.input_tctrp);
      487 	     if tcb.specialrp = ""b
      488 	     then special_ptr = null;
      489 	     else special_ptr = ptr (ttytp, tcb.specialrp);
      490 	end;
      491 
      492 	if wtcb.fblock = 0
      493 	then do;					/* go get some data to process */
      494 	     call get_more_data (blockp);		/* find more input_data */
      495 	     if ercode ^= 0
      496 	     then go to all_done;			/* if problem get out */
      497 	end;
      498 	else blockp = ptr (ttybp, wtcb.fblock);		/* get pointer to buffer left from last time */
      499 						/*						*/
      500 	if wtcb.fblock ^= 0
      501 	then do;					/* yes, process it */
      502 	     target_ptr = output_ptr;
      503 
      504 	     if tcb.rawim				/* raw input mode */
      505 	     then do;				/* just copy data */
      506 		break_found = "0"b;			/* we'll need this if get_line called */
      507 		do while (wtcb.fblock ^= 0 & nelemt < nelem & ^break_found);
      508 
      509 		     source_ptr = addr (buffer.chars (wtcb.fchar));
      510 		     ctally = min (buffer.tally - wtcb.fchar, nelem - nelemt);
      511 		     if get_line_entry		/* want to stop at NL */
      512 		     then do;
      513 			next_break = index (substr (source_ptr -> based_buf, 1, ctally), wtcb.line_delimiter);
      514 			if next_break ^= 0		/* there is one in this buffer */
      515 			then do;
      516 			     ctally = next_break;	/* stop at it */
      517 			     break_found = "1"b;	/* and don't go around again */
      518 			end;
      519 		     end;
      520 
      521 		     if mark_entry
      522 		     then if buffer.mark
      523 			then mark_index = target_len + 1;
      524 
      525 		     call copy_chars;
      526 
      527 		     nelemt = target_len;
      528 
      529 		     if ctally < buffer.tally - wtcb.fchar
      530 						/* if this is last buffer we're copying */
      531 		     then do;
      532 			wtcb.fchar = wtcb.fchar + ctally;
      533 			buffer.mark = "0"b;		/* we've picked up the mark */
      534 		     end;
      535 
      536 		     else do;
      537 			wtcb.fchar = 0;		/* not in the middle of a buffer now */
      538 			new_block = buffer.next;
      539 
      540 			call tty_space_man$free_buffer (devx, INPUT, blockp);
      541 						/* free buffer just copied from */
      542 
      543 			wtcb.fblock = new_block;	/* next buffer (if any) is now head of chain */
      544 			blockp = ptr (ttybp, new_block);
      545 			if (new_block = 0 & wtcb.input_available)
      546 			then do;			/* see if more to do, finished with this chain */
      547 			     call get_more_data (blockp);
      548 						/* go try to get a buffer */
      549 			     if ercode ^= 0
      550 			     then go to all_done;	/* if problem get out */
      551 			end;
      552 		     end;
      553 		end;
      554 
      555 		rawcnt = nelemt;			/* that's how many we really picked up */
      556 	     end;					/*						*/
      557 	     else do;				/* not raw input */
      558 		if tcb.erklm
      559 		then do;				/* make local copies of erase and kill characters */
      560 		     erase_char = tcb.erase;
      561 		     kill_char = tcb.kill;
      562 		end;
      563 		else erase_char, kill_char = " ";	/* so canon_procedure won't see erases & kills */
      564 
      565 		if (tcb.can_type = CAN_TYPE_OVERSTRIKE)
      566 		then canon_procedure = tty_overstrike_canon;
      567 		else if (tcb.can_type = CAN_TYPE_REPLACE)
      568 		then canon_procedure = tty_replace_canon;
      569 		else canon_procedure = tty_overstrike_canon;
      570 						/* can't happen, but just in case */
      571 
      572 		call pickup_preconverted;
      573 
      574 		nelemt = target_len;		/* total returned so far */
      575 		throw_away = "0"b;
      576 
      577 /* CONVERSION STARTS HERE */
      578 /* if there's any to do */
      579 
      580 		if wtcb.fblock = 0
      581 		then do;				/* finished with preconvertedand no none converted pending */
      582 		     call get_more_data (blockp);	/* try to get a buffer */
      583 		     if ercode ^= 0
      584 		     then go to all_done;		/* if error get out */
      585 		end;
      586 		max_len = 1;			/* init so loop starts */
      587 		do while ((^break_found | ^get_line_entry) & nelemt < nelem & wtcb.fblock ^= 0 & max_len > 0);
      588 		     old_rawcnt = rawcnt;		/* in case we have to do retry */
      589 		     break = wtcb.line_delimiter;	/* this is untranslated break, which we will search for */
      590 		     output_ptr = target_ptr;		/* allows for possible already-converted chars */
      591 		     max_len = length (buffer_1);
      592 		     orig_fchar = wtcb.fchar;		/* so we can restore this */
      593 
      594 /* come here if canon_procedure overflows */
      595 retry:
      596 		     if max_len > 0
      597 		     then do;			/* only continue if we have something to do it into */
      598 			target_ptr = addr (buffer_1);
      599 			room_left = max_len;
      600 			target_len = 0;
      601 			last_block = 0;
      602 			wtcb.fchar = orig_fchar;	/* in case we started over */
      603 			call copy_loop;
      604 			if ^break_found & get_line_entry & room_left > 0
      605 			then do;			/* there's no break anywhere in chain */
      606 			     no_break_anywhere = "1"b;
      607 			     wtcb.fchar = orig_fchar; /* copy_loop might have changed this */
      608 			     go to no_line;		/* get out of conversion loop */
      609 			end;
      610 
      611 			no_break_anywhere = "0"b;
      612 			call translation;
      613 
      614 /* ** CANONICALIZATION ** */
      615 
      616 			can_called = "0"b;
      617 			if tcb.canm
      618 			then do;
      619 			     call canonicalization;
      620 			     if code ^= 0		/* overflowed the space */
      621 			     then do;		/* have to start again */
      622 				max_len = divide (2 * max_len, 3, 17, 0);
      623 				if max_len > 0
      624 				then do;
      625 				     blockp = ptr (ttybp, wtcb.fblock);
      626 				     rawcnt = old_rawcnt;
      627 				     break_found = "0"b;
      628 						/* start clean */
      629 				     tty_buf.input_restart = tty_buf.input_restart + 1;
      630 				     go to retry;
      631 				end;
      632 			     end;
      633 			end;
      634 		     end;
      635 
      636 /* ** FREE BUFFERS NOW ** */
      637 
      638 		     if last_block ^= 0		/* if there are any to free */
      639 		     then do;			/* this was the first chance we had to release some buffer space in the buffer */
      640 			tempp = ptr (ttybp, last_block);
      641 						/* point to last one */
      642 			tempp -> buffer.next = 0;	/* cut off chain here */
      643 			call tty_space_man$free_chain (devx, INPUT, ptr (ttybp, wtcb.fblock));
      644 			wtcb.fblock = fixed (rel (blockp), 17);
      645 		     end;
      646 
      647 		     if (wtcb.fblock = 0 & wtcb.input_available)
      648 		     then do;			/* see if more to do, finished with this chain */
      649 			call get_more_data (blockp);	/* get the buffer of interest */
      650 			if ercode ^= 0
      651 			then go to all_done;
      652 			wtcb.fchar = 0;		/* we can update this now too */
      653 		     end;				/* we'll get back to this buffer after we finish the rest of the present buffer we have */
      654 
      655 /* set up for rest of conversion */
      656 
      657 		     source_len = stringl;
      658 		     stringp = source_ptr;
      659 		     target_len = 0;
      660 
      661 /* if tty_canon wasn't called, we have to eliminate NULs by hand */
      662 
      663 		     if ^can_called & (^tcb.control | no_control_input (wtcb.line_type))
      664 		     then call strip_nulls;
      665 
      666 /* ** ERASE/KILL PROCESSING ** */
      667 
      668 		     if tcb.erklm
      669 		     then call process_erase_kill;
      670 
      671 /* ** ESCAPE AND BREAK PROCESSING ** */
      672 
      673 		     if tctp ^= null		/* can't do this without input conversion table */
      674 		     then call process_escape_break;
      675 
      676 		     if target_len ^= 0
      677 		     then do;
      678 			source_ptr = old_targetp;
      679 			source_len = target_len;
      680 		     end;
      681 
      682 		     target_len = nelemt;		/* number of characters in caller's buffer so far */
      683 		     target_ptr = output_ptr;		/* place to put the rest */
      684 		     ctally = min (nelem - nelemt, source_len);
      685 						/* copy as many more as we can hold */
      686 		     if ctally > 0
      687 		     then call copy_chars;
      688 
      689 		     nelemt = nelemt + source_len;
      690 
      691 /* if we have to convert any more, we will now go back to top and copy some more */
      692 
      693 		end;
      694 
      695 /* we've converted all we're going to convert. Do we have any */
      696 /* that wouldn't fit in caller's buffer? */
      697 
      698 		if nelemt > nelem
      699 		then do;				/* yes */
      700 
      701 		     source_len = nelemt - nelem;
      702 		     if mark_entry
      703 		     then if mark_index > nelem	/* we didn't get up to the mark */
      704 			then pmark_index = mark_index - nelem;
      705 			else pmark_index = 0;
      706 		     call copy_to_preconverted;
      707 		end;
      708 
      709 		else if (get_line_entry & ^break_found) /* don't have a complete line */
      710 		then do;
      711 no_line:
      712 		     if target_len > 0		/* if there's anything at all */
      713 		     then do;			/* search through buffers to see if he'll get a break sooner or later */
      714 			if wtcb.fblock = 0 | no_break_anywhere
      715 			then unconverted_break = "0"b;/* we know there aren't any breaks */
      716 			else if tcb.break_char_pending
      717 			then unconverted_break = "1"b;/* we dont have to search */
      718 
      719 			else do;			/* scan buffer to see what we can find */
      720 			     blockp = ptr (ttybp, wtcb.fblock);
      721 			     next_break = 0;	/* init the "while" variable */
      722 
      723 			     break = wtcb.line_delimiter;
      724 						/* make sure it is set, may have fallen through to here */
      725 			     do while (next_break = 0);
      726 				source_ptr = addr (buffer.chars (wtcb.fchar));
      727 				next_break =
      728 				     index (substr (source_ptr -> based_buf, 1, buffer.tally - wtcb.fchar), break)
      729 				     ;		/* look for break in next buffers */
      730 				if next_break ^= 0
      731 				then unconverted_break = "1"b;
      732 						/* we found one */
      733 				else if buffer.next = 0
      734 				then do;		/* nothing else to look at so give up */
      735 				     unconverted_break = "0"b;
      736 				     next_break = 1;/* to break out of loop */
      737 				end;
      738 
      739 				else blockp = ptr (ttybp, buffer.next);
      740 			     end;
      741 			end;
      742 
      743 			if /* tree */ unconverted_break
      744 			then tcb.break_char_pending = "1"b;
      745 
      746 			else if ^no_break_anywhere
      747 			     then do;
      748 				source_ptr = orig_output_ptr;
      749 						/* we will save everything the caller would have gotten */
      750 				source_len = target_len;
      751 						/* this is the total in the caller's buffer */
      752 				call copy_to_preconverted;
      753 				nelemt = 0;	/* he will get nothing till we know for sure */
      754 			     end;
      755 		     end;
      756 		end;
      757 	     end;					/* whether rawi or not */
      758 	end;					/* whether a read chain or not */
      759 
      760 /* we always end up here */
      761 /* if no read chain or no space we will ask for wakeup since
      762*   nelemt will be 0 */
      763 
      764 	nelemt = min (nelemt, nelem);
      765 	if nelemt = 0
      766 	then do;
      767 	     if negotiate_entry
      768 	     then do;				/* OK, flip on echoing. */
      769 		echo_data.horiz_room_left = screen_left;/* Indicate room left. */
      770 		echo_data.chars_echoed = 0;		/* Didn't echo anything */
      771 		if screen_left = 0
      772 		then wtcb.negotiating_echo = "0"b;
      773 		else if tty_buf.echo_neg_mux_inhibit
      774 		then wtcb.negotiating_echo = "1"b;
      775 		else if wtcb.write_first ^= 0
      776 		then do;
      777 		     wtcb.negotiating_echo = "1"b;
      778 		     if echo_data.synchronized
      779 		     then echo_data.echo_start_pending_sndopt = "1"b;
      780 		end;				/* If output sits in ring 0, only ring 0 can append logically to it, not mux. */
      781 		else if echo_data.synchronized
      782 		then do;				/* mux _d_o_e_s echnego */
      783 		     wtcb.negotiating_echo = "1"b;	/* Tell tty_interrupt to echo. */
      784 		     echo_start_data.ctr = echo_data.sync_ctr;
      785 						/* Tell MUX to echo, */
      786 						/* Sending counters as part of protocol game. */
      787 		     echo_start_data.screenleft = echo_data.horiz_room_left;
      788 		     call channel_manager$control (devx, "start_negotiated_echo", addr (echo_start_data), code);
      789 		     if code = 0
      790 		     then ;
      791 		     else if code = error_table_$invalid_write
      792 		     then echo_data.echo_start_pending_sndopt = "1"b;
      793 
      794 /* This little bit of obscurity means that the mux had output queued in r0, */
      795 /* and tty_interrupt is to try sending this again when a SEND_OUTPUT */
      796 /* indicates that this is no longer the case. */
      797 		end;
      798 		else do;				/* Not synchronized */
      799 		     call channel_manager$control (devx, "init_echo_negotiation", null (), code);
      800 		     if code = 0
      801 		     then do;
      802 			echo_data.awaiting_start_sync = "1"b;
      803 			echo_data.mux_will_echnego = "1"b;
      804 		     end;
      805 		     else wtcb.negotiating_echo = "1"b; /* Ring zero will do it */
      806 		end;
      807 		if wtcb.negotiating_echo
      808 		then tty_buf.echo_neg_entries = tty_buf.echo_neg_entries + 1;
      809 	     end;
      810 	     else do;				/* Regular call turns off */
      811 		if wtcb.negotiating_echo
      812 		then do;
      813 		     wtcb.negotiating_echo = "0"b;	/* This really really should not happen -- should we cm$control (echoff) here */
      814 		end;
      815 	     end;
      816 
      817 	     if (uncp_flag & ^wtcb.flags.rflag) |
      818 		(^uncp_flag & ^wtcb.flags.rflag & wtcb.prompt_len > 0)
      819 
      820 	     then do;
      821 		raw_mode = tcb.rawom;
      822 		tcb.rawom = "1"b;			/* write prompt in rawo mode */
      823 		call tty_write$locked (devx, addr (wtcb.prompt), 0, (wtcb.prompt_len), 0, 0, code);
      824 		tcb.rawom = raw_mode;
      825 	     end;
      826 
      827 	     wtcb.flags.rflag = "1"b;			/* we want a wakeup */
      828 	     tty_buf.readblocked = tty_buf.readblocked + 1;
      829 						/* blocked again */
      830 	     if ^uncp_flag then do;
      831 		if ^wtcb.flags.wru			/* if not reading answerback */
      832 		     then if wtcb.receive_mode_device	/* must we tell multiplexer to turn line around? */
      833 		     then call channel_manager$control (devx, "enter_receive", null, ercode);
      834 						/* yes, do it */
      835 		else ;
      836 
      837 		else wtcb.flags.wru = "0"b;		/* won't be reading answerback again */
      838 	     end;
      839 	end;
      840 
      841 	else do;
      842 	     wtcb.flags.rflag, wtcb.flags.wru = "0"b;
      843 	     wtcb.negotiating_echo = "0"b;
      844 	     if negotiate_entry
      845 	     then do;				/* Return echoed count. */
      846 		echoed = min (nelem, echo_data.chars_echoed);
      847 		echo_data.chars_echoed = echo_data.chars_echoed - echoed;
      848 	     end;
      849 	     tcb.cumulative_meters.read_chars = tcb.cumulative_meters.read_chars + nelemt;
      850 	     tty_buf.ninchars = tty_buf.ninchars + nelemt;/* count input chars */
      851 	     tty_buf.nrawread = tty_buf.nrawread + rawcnt;/* count raw chars input */
      852 
      853 	     if (tcb.modes.scroll & (tcb.linemax > 0))
      854 	     then wtcb.actline = 0;			/* scroll by resetting the line count */
      855 						/* that is if we care about the line count in the first place */
      856 
      857 	end;
      858 
      859 	ercode = 0;
      860 	if get_line_entry
      861 	then nl_found = break_found;			/* report this to caller */
      862 all_done:
      863 	if wtcb.fblock = 0
      864 	then do;
      865 	     wtcb.lblock = 0;
      866 	     wtcb.flags.allow_wakeup = "0"b;
      867 	end;
      868 
      869 	if ercode ^= 0
      870 	then do;
      871 	     call clean_up;				/* don't give him anything extra */
      872 	     wtcb.negotiating_echo = "0"b;
      873 	end;
      874 	time_spent = clock () - start_time;
      875 	tcb.cumulative_meters.read_time = tcb.cumulative_meters.read_time + time_spent;
      876 	tty_buf.read_time = tty_buf.read_time + time_spent;
      877 	call tty_lock$unlock_channel (devx);		/* unlock channel lock */
      878 	a_nelemt = nelemt;
      879 	if nelemt > 0
      880 	then call meter_response_time (pds$processid, RETURN_RING_0_TTY);
      881 	if negotiate_entry
      882 	then a_echoed = echoed;
      883 	if mark_entry
      884 	then if mark_index <= nelemt
      885 	     then a_mark_index = mark_index;
      886 	     else a_mark_index = 0;
      887 	return;					/*						*/
      888 
      889 /* ** INTERNAL PROCEDURES ** */
      890 
      891 copy_chars:
      892      proc;
      893 
      894 /* this procedure copies ctally characters from source_ptr to target_ptr. It updates both pointers */
      895 /* and increments target_len by ctally */
      896 
      897 dcl  tally_chars char (ctally) based;
      898 
      899 	target_ptr -> tally_chars = source_ptr -> tally_chars;
      900 
      901 	source_ptr = addr (source_ptr -> based_chars (ctally));
      902 	target_ptr = addr (target_ptr -> based_chars (ctally));
      903 	target_len = target_len + ctally;
      904 
      905 	return;
      906 
      907      end /* copy_chars */;
      908 
      909 clean_up:
      910      proc;
      911 
      912 /*
      913*   This procedure is to insure that the user does not get returned
      914*   any values that might convey any information to hime that he should not have
      915**/
      916 
      917 	nelemt, a_nelemt = 0;
      918 	nl_found = "0"b;
      919 	state = 0;
      920 	return;
      921 
      922      end clean_up;
      923 
      924 
      925 get_more_data:
      926      proc (new_blockp);
      927 
      928 /* this proc calls channel_manager$read to get more buffers of data and set the buffer pointer (blockp)
      929*   and the the first block (wtcb.fblock) if it si not already set.  Both are set to null values if no data is pending */
      930 
      931 dcl  new_blockp ptr;
      932 dcl  prev_blockp ptr;
      933 dcl  orig_blockp ptr;
      934 
      935 	if wtcb.input_available
      936 	then do;					/* If there is input, go get it. */
      937 	     call channel_manager$read (devx, blockp, have_more_data, ercode);
      938 						/* get the buffer of interest */
      939 	     if ercode ^= 0
      940 	     then nelemt = 0;			/* reset to zero */
      941 	     wtcb.input_available = have_more_data;
      942 	end;
      943 	else blockp = null;				/* else nothing there or physical channel and he puts everything he has into fblock on interrupt */
      944 
      945 	if blockp ^= null
      946 	then do;
      947 	     if wtcb.fblock = 0			/* if there's not a pending chain */
      948 	     then wtcb.fblock = fixed (rel (blockp), 17, 0);
      949 						/* break pointer back into an offset */
      950 	     else do;				/* attach new stuff to existing chain */
      951 		prev_blockp = ptr (ttybp, wtcb.lblock);
      952 		prev_blockp -> buffer.next = fixed (rel (blockp), 17, 0);
      953 	     end;
      954 
      955 	     orig_blockp = blockp;
      956 
      957 	     do while (buffer.next ^= 0);		/* find end of chain to set wtcb.lblock */
      958 		blockp = ptr (blockp, buffer.next);
      959 	     end;
      960 
      961 	     wtcb.lblock = bin (rel (blockp), 17);
      962 	     blockp = orig_blockp;
      963 
      964 	     if wtcb.mark_set
      965 	     then do;
      966 		buffer.mark = "1"b;			/* set mark in first block */
      967 		wtcb.mark_set = "0"b;
      968 	     end;
      969 	end;
      970 	new_blockp = blockp;
      971 	return;
      972      end;						/* get_more_data */
      973 
      974 /**/
      975 insert_char:
      976      proc (i_char);
      977 
      978 /* this procedure inserts one character at target_ptr, and increments target_ptr and target_len by one character */
      979 
      980 dcl  i_char char (1) aligned;
      981 
      982 	target_ptr -> based_one_char = i_char;
      983 	target_ptr = addr (target_ptr -> based_chars (1));
      984 	target_len = target_len + 1;
      985 	return;
      986 
      987      end /* insert_char */;				/*						*/
      988 skip:
      989      proc (to_skip);
      990 
      991 /* this procedure discards a specified number of characters from stringp */
      992 
      993 dcl  to_skip fixed bin;
      994 
      995 	stringp = addr (stringp -> based_chars (to_skip));/* skip over character */
      996 	if source_len = stringl			/* if it's first character in the string */
      997 	then source_len = source_len - to_skip;		/* then make sure it doesn't get picked up */
      998 	stringl = stringl - to_skip;
      999 
     1000 	return;
     1001 
     1002      end /* skip */;
     1003 
     1004 escaped:
     1005      proc returns (bit (1) aligned);
     1006 
     1007 /* this procedure returns "1"b if the character at index xr in the string based on stringp */
     1008 /* is preceded by a non-overstruck escape character; otherwise it returns "0"b */
     1009 
     1010 	if ^tcb.escm
     1011 	then return ("0"b);
     1012 
     1013 	if xr <= 1				/* no preceding character */
     1014 	then return ("0"b);
     1015 
     1016 	if tctp = null				/* no conversion table so no escapes */
     1017 	then return ("0"b);
     1018 
     1019 	if tctp -> table (rank (substr (based_string, xr - 1, 1))) ^= 2
     1020 						/* not preceded by an escape */
     1021 	then return ("0"b);
     1022 
     1023 	if xr = 2					/* escape can't be overstruck, it's first char */
     1024 	then return ("1"b);
     1025 
     1026 	if substr (based_string, xr - 2, 1) = bs	/* escape is overstruck */
     1027 	then return ("0"b);
     1028 
     1029 	else return ("1"b);
     1030 
     1031      end /* escaped */;				/*						*/
     1032 char_value:
     1033      proc (a_char) returns (fixed bin);
     1034 
     1035 /* this procedure returns the numeric equivalent of an ASCII character if the character is 0 to 7; */
     1036 /* otherwise it returns -1 */
     1037 
     1038 dcl  a_char char (1) aligned;
     1039 dcl  numeric fixed bin;
     1040 
     1041 	numeric = rank (a_char);
     1042 	if numeric >= 48				/* i.e., "0" */
     1043 	     & numeric <= 55			/* i.e., "7" */
     1044 	then return (numeric - 48);
     1045 
     1046 	else return (-1);
     1047 
     1048      end /* char_value */;
     1049 
     1050 copy_to_preconverted:
     1051      proc;
     1052 
     1053 /* This procedure copies source_len characters from source_ptr to buffers marked "preconverted" */
     1054 
     1055 dcl  mark_next_buffer bit (1);
     1056 
     1057 	tty_buf.preconverted = tty_buf.preconverted + source_len;
     1058 
     1059 	old_fblock = wtcb.fblock;
     1060 
     1061 /* we will copy extra ones into tty_buf "converted" buffers */
     1062 
     1063 	call tty_space_man$get_buffer (devx, BSIZE, INPUT, new_blockp);
     1064 	if new_blockp = null
     1065 	then go to no_space;
     1066 
     1067 	wtcb.fblock = bin (bin (rel (new_blockp), 18), 17);
     1068 
     1069 	target_len = 0;
     1070 	mark_next_buffer = "0"b;
     1071 
     1072 	do while (source_len > 0);
     1073 	     blockp = new_blockp;
     1074 	     buffer.converted = "1"b;
     1075 
     1076 	     ctally = min (source_len, bsizec);
     1077 	     if mark_entry
     1078 	     then do;
     1079 		if /* tree */ mark_next_buffer	/* we broke previous buffer at mark */
     1080 		then do;
     1081 		     buffer.mark = "1"b;
     1082 		     mark_next_buffer = "0"b;
     1083 		end;
     1084 
     1085 		else if pmark_index > 0
     1086 		     then if pmark_index = target_len + 1
     1087 						/* it's exactly here */
     1088 			then do;
     1089 			     buffer.mark = "1"b;
     1090 			     pmark_index = 0;	/* we've done it now */
     1091 			end;
     1092 			else if pmark_index <= target_len + ctally
     1093 						/* it's due to be in this buffer */
     1094 			     then do;
     1095 				ctally = pmark_index - target_len - 1;
     1096 						/* break so mark will be at start of next buffer */
     1097 				mark_next_buffer = "1"b;
     1098 						/* and remember to do it */
     1099 				pmark_index = 0;	/* taken care of now */
     1100 			     end;
     1101 	     end;
     1102 
     1103 	     buffer.tally = ctally;
     1104 	     target_ptr = addr (buffer.chars (0));
     1105 	     call copy_chars;
     1106 
     1107 	     source_len = source_len - ctally;
     1108 	     if source_len > 0			/* more to do? */
     1109 	     then do;
     1110 
     1111 /* get another buffer */
     1112 
     1113 		call tty_space_man$get_buffer (devx, BSIZE, INPUT, new_blockp);
     1114 		if new_blockp = null
     1115 		then do;
     1116 no_space:
     1117 		     call syserr (crash, "tty_read: No buffers available for preconverted input.");
     1118 		     return;
     1119 		end;
     1120 
     1121 		buffer.next = bin (bin (rel (new_blockp), 18), 17);
     1122 						/* set forward pointer in previous block */
     1123 	     end;
     1124 	end;
     1125 
     1126 /* done filling "converted" buffers */
     1127 
     1128 	buffer.next = old_fblock;			/* set forward pointer in last one */
     1129 	if break_found
     1130 	then buffer.break, tcb.flags.break_char_pending = "1"b;
     1131 						/* had we found a break earlier? */
     1132 	break_found = "0"b;				/* we're not sending the NL to the caller or else we wouldn't be here */
     1133 
     1134 	if old_fblock = 0
     1135 	then wtcb.lblock = fixed (rel (blockp), 17);
     1136 
     1137 	return;
     1138 
     1139      end /* copy_to_preconverted */;
     1140 
     1141 pickup_preconverted:
     1142      proc;
     1143 
     1144 /* check for already-converted input left over from last call and use it up first */
     1145 
     1146 	break_found = "0"b;
     1147 	convert = buffer.converted;
     1148 
     1149 	do while (wtcb.fblock ^= 0 & convert);		/* scan chain of converted buffers */
     1150 	     data_ptr, source_ptr = addr (buffer.chars (0));
     1151 	     ctally = min (buffer.tally, nelem - target_len);
     1152 	     call copy_chars;
     1153 
     1154 	     if ctally < buffer.tally			/* didn't take whole buffer, no room left for the rest */
     1155 	     then do;
     1156 		new_tally = buffer.tally - ctally;
     1157 		buffer.tally = new_tally;
     1158 
     1159 /* copy remaining characters to beginning of buffer */
     1160 
     1161 		substr (temp_buf, 1, new_tally) = substr (data_ptr -> based_buf, ctally + 1, new_tally);
     1162 		substr (data_ptr -> based_buf, 1, new_tally) = substr (temp_buf, 1, new_tally);
     1163 
     1164 		convert = "0"b;			/* so we'll stop copying */
     1165 		tcb.flags.break_char_pending = "0"b;	/* if end clear any pending flag will reset later if called for */
     1166 	     end;
     1167 
     1168 	     else do;				/* copied whole buffer */
     1169 		break_found = buffer.break;
     1170 		new_block = buffer.next;
     1171 
     1172 		call tty_space_man$free_buffer (devx, INPUT, blockp);
     1173 						/* free the buffer just copied from */
     1174 		wtcb.fblock = new_block;
     1175 
     1176 		if wtcb.fblock ^= 0			/* there's more */
     1177 		then do;
     1178 		     blockp = ptr (ttybp, wtcb.fblock);
     1179 		     if break_found | target_len >= nelem
     1180 						/* have we got enough? */
     1181 		     then convert = "0"b;		/* yes, no more copying */
     1182 		     else convert = buffer.converted;
     1183 		end;
     1184 		else wtcb.lblock = 0;		/* just to be safe */
     1185 
     1186 		if break_found
     1187 		then tcb.flags.break_char_pending = "0"b;
     1188 						/* assume this is the one we flaged */
     1189 	     end;
     1190 	end;					/* end of copy-converted loop */
     1191 
     1192 	return;
     1193 
     1194      end pickup_preconverted;
     1195 
     1196 copy_loop:
     1197      proc;
     1198 
     1199 /*
     1200*   This procedure copies data from the available input buffer and places
     1201*   it into an internal working buffer
     1202**/
     1203 
     1204 dcl  new_blockp ptr;
     1205 dcl  orig_blockp ptr;
     1206 
     1207 	first_char = wtcb.fchar;			/* keep in automatic for convenience */
     1208 	if ^get_line_entry
     1209 	then break_found = "0"b;			/* so we're not fooled by preconverted break */
     1210 	do while (^break_found & rel (blockp) ^= "0"b & room_left > 0);
     1211 	     chars_in_buf = buffer.tally - first_char;
     1212 	     source_ptr = addr (buffer.chars (first_char));
     1213 
     1214 	     ctally = index (substr (source_ptr -> based_buf, 1, chars_in_buf), break);
     1215 	     if ctally = 0
     1216 	     then ctally = chars_in_buf;
     1217 	     else break_found = "1"b;
     1218 
     1219 	     if ctally > room_left			/* there has to be room internally */
     1220 	     then ctally = room_left;
     1221 
     1222 	     call copy_chars;			/* get the data */
     1223 
     1224 	     room_left = room_left - ctally;
     1225 	     rawcnt = rawcnt + ctally;
     1226 
     1227 	     if ctally < chars_in_buf			/* we reached some limit */
     1228 	     then first_char = first_char + ctally;	/* this buffer will be around later */
     1229 	     else do;
     1230 		last_block = fixed (rel (blockp), 17);
     1231 		first_char = 0;			/* next buffer begins at beginning */
     1232 		blockp = ptr (ttybp, buffer.next);
     1233 	     end;
     1234 
     1235 	     if rel (blockp) = "0"b			/* if we reached end */
     1236 	     then if ^break_found			/* without finding break */
     1237 		then if wtcb.input_available		/* but lower level has more data */
     1238 		     then do;			/* get it now */
     1239 			orig_blockp = blockp;
     1240 			call get_more_data (new_blockp);
     1241 			if ercode ^= 0
     1242 			then go to all_done;
     1243 			if new_blockp ^= null	/* if there really was some */
     1244 			then blockp = new_blockp;
     1245 			else blockp = orig_blockp;	/* get_more_data probably changed it */
     1246 		     end;
     1247 	end;
     1248 
     1249 	wtcb.fchar = first_char;			/* update this now */
     1250 
     1251 	return;
     1252 
     1253      end copy_loop;					/*						*/
     1254 translation:
     1255      proc;
     1256 
     1257 /*
     1258*   This procedure sets up the necessary variables and then calls the move and translate
     1259*   operation
     1260**/
     1261 
     1262 	source_ptr = addr (buffer_1);
     1263 	target_ptr = addr (buffer_2);
     1264 
     1265 	if throw_away
     1266 	then do;					/* remove first character */
     1267 	     source_ptr = addr (source_ptr -> based_chars (1));
     1268 	     target_len = target_len - 1;
     1269 	     throw_away = "0"b;
     1270 	end;
     1271 
     1272 	stringl = target_len;			/* the number of chars in buffer_1 now */
     1273 	stringp = source_ptr;
     1274 
     1275 	if mvtp ^= null
     1276 	then do;
     1277 	     mvt_args.tablep = mvtp;
     1278 	     mvt_args.targetp = target_ptr;
     1279 
     1280 	     call tty_util_$mvt (addr (util));		/* this does the translation */
     1281 
     1282 	     source_ptr = addr (buffer_2);
     1283 	     target_ptr = addr (buffer_1);
     1284 	     stringp = source_ptr;
     1285 	end;
     1286 
     1287 	if ^tcb.control				/* get rid of invisible characters if appropriate */
     1288 	then if ^no_control_input (wtcb.line_type)	/* and necessary */
     1289 	     then do;
     1290 		mvt_args.tablep = addr (nocontrol);
     1291 		mvt_args.targetp = target_ptr;
     1292 
     1293 		call tty_util_$mvt (addr (util));
     1294 
     1295 		stringp = target_ptr;		/* switch buffers back */
     1296 		target_ptr = source_ptr;
     1297 		source_ptr = stringp;
     1298 	     end;
     1299 
     1300 	return;
     1301 
     1302      end translation;
     1303 
     1304 canonicalization:
     1305      proc;
     1306 
     1307 /*
     1308*   This procedure sets up the necessary variables then calls the cannonicalizer
     1309**/
     1310 /* search for cr and bs */
     1311 
     1312 	code = 0;
     1313 	xr = 1;					/* to make sure we do loop at least once */
     1314 	do while (xr = 1);
     1315 
     1316 	     xr = search (based_string, left_motion);
     1317 
     1318 	     if xr = 1				/* at left margin, skip over it */
     1319 	     then do;
     1320 		stringp = addr (stringp -> based_chars (1));
     1321 		stringl = stringl - 1;
     1322 	     end;
     1323 
     1324 	     else if search (based_string, vertical_motion) ^= 0
     1325 	     then go to MUST_CALL_CANONICALIZE;		/* FF or HT in string: must call canonicalize routine to
     1326*						   insure that whitespace before the HT or FF is stripped */
     1327 
     1328 	     else if xr ^= 0			/* we found one somewhere else */
     1329 	     then do;				/* find out if at end */
     1330 
     1331 		if (tcb.can_type ^= CAN_TYPE_REPLACE) & (verify (substr (based_string, xr), all_white) = 0)
     1332 						/* rest of string white: not significant unless
     1333*						   can_type=replace where trailing whitespace can replace
     1334*						   prior characters on the line */
     1335 		then do;
     1336 		     if substr (based_string, stringl, 1) = nl
     1337 		     then do;			/* copy newline if any */
     1338 			substr (based_string, xr, 1) = nl;
     1339 			stringl = xr;
     1340 		     end;
     1341 
     1342 		     else stringl = xr - 1;
     1343 
     1344 		     source_ptr = stringp;		/* so we won't get leading bs/cr back */
     1345 		end;
     1346 
     1347 		else do;				/* left motion in middle, must call tty_canon */
     1348 MUST_CALL_CANONICALIZE:
     1349 		     if stringp ^= source_ptr		/* did we skip over leading bs/cr? */
     1350 		     then do;			/* copy so tty_canon can use whole buffer */
     1351 			target_ptr -> based_string = stringp -> based_string;
     1352 			data_ptr = target_ptr;
     1353 			target_ptr = source_ptr;
     1354 			source_ptr = data_ptr;
     1355 		     end;
     1356 
     1357 		     can_called = "1"b;
     1358 		     call canon_procedure (source_ptr, stringl, length (buffer_1), erase_char, kill_char, code);
     1359 		end;
     1360 	     end;
     1361 
     1362 	     else source_ptr = stringp;		/* update for possible skipped leading left motion */
     1363 	end;
     1364 
     1365 	return;
     1366 
     1367      end canonicalization;				/* end of canonicalization */
     1368 
     1369 strip_nulls:
     1370      proc;
     1371 
     1372 /*
     1373*   This procedure eliminates nulls from an input buffer.  It is used if tty_cannon
     1374*   was not called earlier for some reason or another
     1375**/
     1376 	old_sourcep = source_ptr;
     1377 	old_targetp = target_ptr;
     1378 
     1379 	xr = index (based_string, nul_char);
     1380 
     1381 	do while (xr ^= 0 & stringl > 0);
     1382 	     if xr = 1				/* NUL at beginning of string */
     1383 	     then do;
     1384 		stringl = stringl - 1;
     1385 		source_len = source_len - 1;
     1386 	     end;
     1387 
     1388 	     else do;
     1389 		ctally = xr - 1;			/* copy characters from before NUL */
     1390 		call copy_chars;
     1391 		stringl = stringl - xr;
     1392 	     end;
     1393 
     1394 	     if stringl > 0
     1395 	     then do;				/* search remainder for further nulls */
     1396 		source_ptr, stringp = addr (stringp -> based_chars (xr));
     1397 		xr = index (based_string, nul_char);
     1398 	     end;
     1399 
     1400 	end;
     1401 
     1402 	if target_len > 0				/* if we moved any at all */
     1403 	then do;
     1404 	     if stringl > 0				/* any more that we didn't move? */
     1405 	     then do;
     1406 		ctally = stringl;
     1407 		call copy_chars;			/* move 'em */
     1408 	     end;
     1409 	     source_len = target_len;			/* source for next pass */
     1410 	     source_ptr = old_targetp;		/* switch buffers */
     1411 	     target_ptr = old_sourcep;
     1412 	end;
     1413 
     1414 	stringp = source_ptr;
     1415 
     1416 	return;
     1417 
     1418      end strip_nulls;
     1419 
     1420 process_erase_kill:
     1421      proc;
     1422 
     1423 /*
     1424*   This procedure does the erase and kill processing by killing all characters
     1425*   to the left of the kill character, and erasing the character (or specified
     1426*   number of characters) to the left of the erase character.
     1427**/
     1428 	old_sourcep = source_ptr;
     1429 	old_targetp = target_ptr;
     1430 	stringl = source_len;
     1431 
     1432 /* kill first */
     1433 
     1434 	xr = 0;
     1435 
     1436 	do while (xr < stringl);
     1437 
     1438 /* search from the right, only last kill is interesting */
     1439 
     1440 	     xr = stringl - index (reverse (based_string), kill_char);
     1441 
     1442 	     if xr < stringl			/* found one */
     1443 	     then do;
     1444 		xr = xr + 1;			/* makes xr actual index of kill */
     1445 
     1446 		if ^escaped ()			/* it's a real kill */
     1447 		then do;
     1448 		     source_ptr, stringp = addr (stringp -> based_chars (xr));
     1449 						/* point to char after kill */
     1450 		     source_len = source_len - xr;
     1451 		     xr = stringl;			/* so as not to index again */
     1452 		end;
     1453 
     1454 		else do;				/* it was escaped, we must scan rest of string */
     1455 		     stringl = xr - 2;
     1456 		     xr = 0;
     1457 		end;
     1458 	     end;
     1459 	end;					/* finished with kills */
     1460 
     1461 
     1462 /**/
     1463 /* now erase */
     1464 
     1465 	stringl = source_len;
     1466 	target_len = 0;
     1467 	xr = 1;
     1468 
     1469 	do while (xr ^= 0 & stringl > 0);
     1470 	     xr = index (based_string, erase_char);	/* look for first erase */
     1471 
     1472 	     if xr = 1				/* first char */
     1473 	     then do;
     1474 		if target_len ^= 0			/* if not first char in whole string */
     1475 		then do;				/* we have to erase some already copied chars */
     1476 		     bx = verify (reverse (based_target), right_motion);
     1477 						/* skip white space */
     1478 		     if bx = 0			/* all white */
     1479 		     then do;
     1480 			target_ptr = old_targetp;	/* wipe it all out */
     1481 			target_len = 0;
     1482 		     end;
     1483 
     1484 		     else do;
     1485 			if bx ^= 1		/* there's some white space */
     1486 			then ctally = bx - 1;	/* we'll erase it all */
     1487 						/* no white, check for overstrikes */
     1488 			else do ctally = 1 to target_len - 2 by 2
     1489 				while (substr (based_target, target_len - ctally, 1) = bs);
     1490 			end;
     1491 
     1492 			target_len = target_len - ctally;
     1493 			target_ptr = addr (old_targetp -> based_chars (target_len));
     1494 		     end;
     1495 		end;
     1496 
     1497 		if target_len <= 0			/* we erased whole target string */
     1498 		then source_len = stringl - 1;
     1499 	     end;
     1500 
     1501 /* not first char, see if it's escaped */
     1502 
     1503 	     else if xr ^= 0
     1504 	     then do;
     1505 		if escaped ()
     1506 		then ctally = xr;			/* copy everything */
     1507 
     1508 		else do;
     1509 		     bx = verify (reverse (substr (based_string, 1, xr - 1)), right_motion);
     1510 
     1511 		     if bx = 0			/* all white */
     1512 		     then ctally = 0;		/* copy nothing */
     1513 
     1514 		     else if bx ^= 1		/* some white */
     1515 		     then ctally = xr - bx;		/* which will not be copied */
     1516 		     else do ctally = xr - 2 to 2 by -2 while (substr (based_string, ctally, 1) = bs);
     1517 		     end;
     1518 
     1519 		end;
     1520 		if ctally > 0
     1521 		then call copy_chars;
     1522 		else source_len = source_len - xr;
     1523 	     end;
     1524 
     1525 	     if xr > 0				/* if we're going around again */
     1526 	     then do;
     1527 		source_ptr, stringp = addr (stringp -> based_chars (xr));
     1528 						/* point past erase */
     1529 		stringl = stringl - xr;
     1530 	     end;
     1531 	end;					/* end of erase search */
     1532 
     1533 	if target_len > 0				/* if we moved any */
     1534 	then do;
     1535 	     if stringl > 0				/* if there are any more */
     1536 	     then do;
     1537 		ctally = stringl;
     1538 		call copy_chars;
     1539 	     end;
     1540 
     1541 	     source_len = target_len;
     1542 	     source_ptr = old_targetp;
     1543 	     target_ptr = old_sourcep;		/* switch buffers */
     1544 	end;
     1545 
     1546 	return;
     1547 
     1548      end process_erase_kill;				/* end of erase-kill phase */
     1549 
     1550 process_escape_break:
     1551      proc;
     1552 
     1553 /*
     1554*   This procedure processes a break character if it was proceded by an escape character
     1555*   in which case, it is not counted as a real break character
     1556**/
     1557 	old_targetp = target_ptr;
     1558 	target_len = 0;
     1559 	break_found = "0"b;
     1560 	stringp = source_ptr;
     1561 	stringl = source_len;
     1562 	util.tablep = tctp;
     1563 
     1564 	do while (stringl > 0);
     1565 
     1566 /* scan for interesting char */
     1567 
     1568 	     call tty_util_$tct (addr (util));
     1569 
     1570 	     if util.indicator = 0 & stringl = 0 & target_len = 0
     1571 						/* never no nothing */
     1572 	     then ;
     1573 
     1574 	     else do;				/* there's work to do */
     1575 		if ctally > 0			/* copy uninteresting characters */
     1576 		then do;
     1577 		     old_sourcep = source_ptr;
     1578 		     call copy_chars;
     1579 		end;
     1580 
     1581 		if indicator = BREAK_CHAR		/* break char */
     1582 		then call process_break_char;
     1583 
     1584 		else if indicator = ESCAPE_CHAR	/* escape char */
     1585 		then do;
     1586 		     if ^tcb.escm			/* we're not escaping */
     1587 			| stringl <= 1		/* there's nothing after it */
     1588 		     then call insert_and_update;
     1589 		     else call process_escape_char;
     1590 		end;
     1591 
     1592 
     1593 		else if indicator = THROW_AWAY	/* throw away */
     1594 		then call skip (1);
     1595 
     1596 		else if indicator = FORM_FEED		/* form feed */
     1597 		then do;
     1598 		     if tcb.linemax > 0		/* using page length */
     1599 		     then call skip (1);		/* so throw form feed away */
     1600 
     1601 		     else call insert_and_update;
     1602 		end;
     1603 
     1604 		else if indicator = HARDWARE_CONTROL	/* hardware control sequence */
     1605 		then if ^tcb.modes.control		/* no control chars wanted */
     1606 		     then do;
     1607 			call skip (2);		/* skip this and following char */
     1608 			if stringl < 0		/* there wasn't another one */
     1609 			then throw_away = "1"b;	/* we'll throw away first if we go around again */
     1610 		     end;
     1611 		     else call insert_and_update;
     1612 
     1613 		else if indicator ^= 0		/* what else could it be? */
     1614 		then do;
     1615 		     nelemt = 0;			/* nothing for you, chief */
     1616 		     ercode = error_table_$improper_data_format;
     1617 		     go to all_done;
     1618 		end;
     1619 
     1620 		source_ptr = stringp;
     1621 	     end;
     1622 	end;
     1623 
     1624 	return;
     1625 
     1626      end process_escape_break;			/* of tct loop */
     1627 
     1628 process_break_char:
     1629      proc;
     1630 
     1631 /*
     1632*   This procedure processes the actual break character and manipulates the white space as necessary
     1633**/
     1634 	break_found = "1"b;				/* it can't be escaped or we'd have found the escape */
     1635 
     1636 	if tcb.canm
     1637 	then if ctally > 0				/* scan back for preceding white space */
     1638 	     then do;
     1639 		bx = verify (reverse (substr (based_source, 1, ctally)), right_motion) - 1;
     1640 
     1641 		if bx < 0				/* all white */
     1642 		then bx = ctally;
     1643 
     1644 		if bx > 0				/* any white */
     1645 		then do;
     1646 		     target_len = target_len - bx;
     1647 		     target_ptr = addr (old_targetp -> based_chars (target_len));
     1648 		end;
     1649 	     end;
     1650 
     1651 /* target_ptr shows where to put nl now in any case */
     1652 
     1653 	call insert_and_update;
     1654 
     1655 	return;
     1656 
     1657      end process_break_char;
     1658 
     1659 process_escape_char:
     1660      proc;
     1661 
     1662 /* This procedure does the processing of a character if it is proceded by
     1663*   an escape character
     1664**/
     1665 	if ctally > 0				/* check for overstruck escape */
     1666 	then do;
     1667 	     i = -1;				/* necessary to make compiler accept next statement */
     1668 	     if stringp -> based_chars (i) = bs
     1669 	     then do;
     1670 		call insert_and_update;
     1671 		return;
     1672 	     end;
     1673 	end;
     1674 
     1675 	next_char = stringp -> based_chars (1);
     1676 	if next_char = bs
     1677 	then do;
     1678 	     call insert_and_update;
     1679 	     return;
     1680 	end;
     1681 
     1682 	if stringl > 2				/* check for following character overstruck */
     1683 	then if stringp -> based_chars (2) = bs
     1684 	     then do;
     1685 		call insert_and_update;
     1686 		return;
     1687 	     end;
     1688 
     1689 	if tctp -> table (rank (next_char)) = 2 |	/* next char is escape */
     1690 	     next_char = tcb.erase | next_char = tcb.kill
     1691 	then do;
     1692 
     1693 	     stringp = addr (stringp -> based_chars (1)); /* skip over escape */
     1694 	     stringl = stringl - 1;
     1695 	     call insert_and_update;			/* put in following char as is */
     1696 	     return;
     1697 	end;
     1698 
     1699 /**/
     1700 /* check for octal escape */
     1701 
     1702 	digit = char_value (next_char);
     1703 	if digit >= 0
     1704 	then do;					/* we have octal digit(s) */
     1705 
     1706 	     octal.result = 0;
     1707 	     stringp = addr (stringp -> based_chars (1)); /* look at next */
     1708 
     1709 	     do i = 1 to 3 while (digit >= 0);
     1710 		octal.result = 8 * octal.result + digit;
     1711 
     1712 		if stringl > i & i < 3
     1713 		then do;
     1714 		     digit = char_value ((stringp -> based_chars (i)));
     1715 		     if digit >= 0			/* next char is digit, see if it's overstruck */
     1716 		     then if stringl > i + 1
     1717 			then if stringp -> based_chars (i + 1) = bs
     1718 			     then digit = -1;
     1719 		end;
     1720 
     1721 		else digit = -1;			/* no more chars, or we already have 3 */
     1722 	     end;
     1723 
     1724 	     call insert_char ((addr (octal.result) -> based_one_char));
     1725 	     stringp = addr (stringp -> based_chars (i - 1));
     1726 						/* skip over octal digits */
     1727 	     stringl = stringl - i;
     1728 	end;
     1729 
     1730 /**/
     1731 /* see if it's escaped newline (with possible intervening white space) */
     1732 
     1733 	else if verify (substr (based_string, 2, stringl - 2), right_motion) = 0
     1734 		& substr (based_string, stringl, 1) = nl
     1735 	then do;
     1736 	     if stringl = source_len			/* first thing in the string? */
     1737 	     then source_len = 0;			/* then nothing */
     1738 	     stringl = 0;				/* we've reached end */
     1739 	end;
     1740 
     1741 	else do;					/* look up next_char in input escape table */
     1742 	     if special_ptr = null			/* no table means no escapes */
     1743 	     then call insert_and_update;
     1744 	     else if special_ptr -> special_chars.input_escapes.len = 0
     1745 	     then call insert_and_update;
     1746 
     1747 	     else do;
     1748 		xr = index (special_ptr -> special_chars.input_escapes.str, next_char);
     1749 		if xr ^= 0			/* it's there */
     1750 		then do;
     1751 		     call insert_char ((substr (special_ptr -> special_chars.input_results.str, xr, 1)));
     1752 		     stringp = addr (stringp -> based_chars (2));
     1753 						/* point past escape sequence */
     1754 		     stringl = stringl - 2;
     1755 		end;
     1756 
     1757 		else call insert_and_update;
     1758 	     end;
     1759 	end;
     1760 
     1761 	return;
     1762 
     1763      end process_escape_char;				/* of escape character */
     1764 
     1765 insert_and_update:
     1766      proc;
     1767 
     1768 /*
     1769*   This procdure passes insert_char a character pointed to by stringp
     1770*   to be inserted, then it updates the string pointer and the
     1771*   string length
     1772**/
     1773 
     1774 	call insert_char ((stringp -> based_one_char));
     1775 	stringp = addr (stringp -> based_chars (1));
     1776 	stringl = stringl - 1;
     1777 
     1778 	return;
     1779 
     1780      end insert_and_update;
     1781 
     1782 
     1783 is_parent_mpx:					/* Check match of channel's parent mpx type against input mpx type */
     1784      proc (parent_mpx_type) returns (bit (1));
     1785 
     1786 dcl parent_mpx_type fixed bin;
     1787 dcl temp_lctep ptr;
     1788      
     1789 	lctep = addr (lct.lcte_array (devx));
     1790 	if lcte.major_channel_devx ^= 0 then do;
     1791 	     temp_lctep = addr (lct.lcte_array (lcte.major_channel_devx));
     1792 	     if temp_lctep->lcte.channel_type = parent_mpx_type then return ("1"b);
     1793 	end;
     1794 	else if lcte.channel_type = parent_mpx_type then return ("1"b);
     1795 	return ("0"b);
     1796      end is_parent_mpx;
     1797 
     1798      end /* tty_read */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.9  tty_read.pl1                      >spec>install>1112>tty_read.pl1
266          1    10/18/88  1210.6  tty_convert.incl.pl1              >ldd>include>tty_convert.incl.pl1
268          2    01/06/85  1422.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
2-152        3    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
270          4    07/21/88  2036.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
272          5    07/21/88  2036.0  wtcb.incl.pl1                     >ldd>include>wtcb.incl.pl1
274          6    06/18/81  0900.8  tcb.incl.pl1                      >ldd>include>tcb.incl.pl1
276          7    03/19/81  1206.8  tty_can_types.incl.pl1            >ldd>include>tty_can_types.incl.pl1
278          8    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
280          9    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
282         10    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
284         11    07/10/86  2015.0  mcs_echo_neg_sys.incl.pl1         >ldd>include>mcs_echo_neg_sys.incl.pl1
286         12    06/29/81  2258.5  response_transitions.incl.pl1     >ldd>include>response_transitions.incl.pl1
288         13    10/26/89  2011.9  multiplexer_types.incl.pl1        >ldd>include>multiplexer_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAK_CHAR                             constant        fixed bin(17,0)          initial dcl 163 ref 1581
BSIZE                           000052 constant        fixed bin(17,0)          initial dcl 161 set ref 1063* 1113*
CALL_RING_0_TTY                 000061 constant        fixed bin(17,0)          initial dcl 12-7 set ref 342*
CAN_TYPE_OVERSTRIKE                    constant        fixed bin(17,0)          initial dcl 7-4 ref 565
CAN_TYPE_REPLACE                       constant        fixed bin(17,0)          initial dcl 7-4 ref 567 1331
DIALED_UP                              constant        fixed bin(17,0)          initial dcl 168 ref 375
ESCAPE_CHAR                            constant        fixed bin(17,0)          initial dcl 164 ref 1584
FORM_FEED                              constant        fixed bin(17,0)          initial dcl 166 ref 1596
HARDWARE_CONTROL                       constant        fixed bin(17,0)          initial dcl 167 ref 1604
INPUT                           000001 constant        bit(1)                   initial packed unaligned dcl 9-20 set ref 540* 643*
                                                                                  1063* 1113* 1172*
RETURN_RING_0_TTY               000057 constant        fixed bin(17,0)          initial dcl 12-7 set ref 879*
THROW_AWAY                             constant        fixed bin(17,0)          initial dcl 165 ref 1593
UNCP_MPX                        000000 constant        fixed bin(17,0)          initial dcl 13-16 set ref 353*
a_buffer                               parameter       char                     packed unaligned dcl 52 set ref 302 306 307
a_char                                 parameter       char(1)                  dcl 1038 ref 1032 1041
a_echoed                               parameter       fixed bin(24,0)          dcl 57 set ref 314 325 436* 881*
a_mark_index                           parameter       fixed bin(21,0)          dcl 60 set ref 302 883* 886*
a_nelem                                parameter       fixed bin(24,0)          dcl 53 ref 24 295 314 325 338
a_nelemt                               parameter       fixed bin(24,0)          dcl 54 set ref 24 295 302 314 325 878* 917*
a_offset                               parameter       fixed bin(24,0)          dcl 51 ref 24 295 314 325 462
a_readp                                parameter       pointer                  dcl 50 ref 24 295 314 325 337
a_screen_left                          parameter       fixed bin(17,0)          dcl 56 ref 314 320 325 331
actline                  15(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  set ref 853*
addr                                                   builtin function         dcl 263 ref 306 341 363 468 480 509 598 726 788 788
                                                                                  823 823 901 902 983 995 1104 1150 1212 1262 1263
                                                                                  1267 1277 1278 1280 1280 1282 1283 1290 1290 1291
                                                                                  1293 1293 1320 1396 1448 1493 1527 1568 1568 1647
                                                                                  1693 1707 1724 1725 1752 1775 1789 1791
all_white                       000042 constant        char(6)                  initial dcl 182 ref 1331
allow_wakeup             13(23)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref
                                                                                  866*
awaiting_start_sync       7(07)        based           bit(1)                   level 2 packed packed unaligned dcl 11-19 set ref
                                                                                  420 802*
awaiting_stop_sync        7(08)        based           bit(1)                   level 2 packed packed unaligned dcl 11-19 set ref
                                                                                  425 428* 432
based_buf                              based           char(60)                 packed unaligned dcl 245 set ref 513 727 1161 1162*
                                                                                  1214
based_chars                            based           char(1)                  array packed unaligned dcl 246 set ref 468 901 902
                                                                                  983 995 1267 1320 1396 1448 1493 1527 1647 1668
                                                                                  1675 1682 1693 1707 1714 1715 1725 1752 1775
based_one_char                         based           char(1)                  packed unaligned dcl 247 set ref 982* 1724 1774
based_source                           based           char                     packed unaligned dcl 249 ref 1639
based_string                           based           char                     packed unaligned dcl 248 set ref 1019 1026 1316 1324
                                                                                  1331 1336 1338* 1351* 1351 1379 1397 1440 1470
                                                                                  1509 1516 1733 1733
based_target                           based           char                     packed unaligned dcl 250 ref 1476 1488
bin                                                    builtin function         dcl 263 ref 961 1067 1067 1121 1121
blockp                          001036 automatic       pointer                  dcl 4-19 set ref 494* 498* 509 510 521 529 533 538
                                                                                  540* 544* 547* 582* 625* 644 649* 720* 726 727 733
                                                                                  739* 739 937* 943* 945 947 952 955 957 958* 958
                                                                                  958 961 962* 966 970 1073* 1074 1081 1089 1103
                                                                                  1104 1121 1128 1129 1134 1147 1150 1151 1154 1156
                                                                                  1157 1169 1170 1172* 1178* 1182 1210 1211 1212
                                                                                  1230 1232* 1232 1235 1239 1243* 1245*
break                           000211 automatic       char(1)                  packed unaligned dcl 113 in procedure "tty_read" set
                                                                                  ref 589* 723* 727 1214
break                     0(20)        based           bit(1)                   level 3 in structure "buffer" packed packed
                                                                                  unaligned dcl 4-28 in procedure "tty_read" set ref
                                                                                  1129* 1169
break_char_pending       30(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 set ref 716
                                                                                  743* 1129* 1165* 1186*
break_found                     000126 automatic       bit(1)                   packed unaligned dcl 83 set ref 506* 507 517* 587
                                                                                  604 627* 709 860 1129 1132* 1146* 1169* 1179 1186
                                                                                  1208* 1210 1217* 1235 1559* 1634*
bs                              006400 constant        char(1)                  initial dcl 190 ref 1026 1488 1516 1668 1676 1682
                                                                                  1715
bsizec                                 constant        fixed bin(17,0)          initial dcl 2-28 ref 1076
buffer                                 based           structure                level 1 dcl 4-28
buffer_1                        000256 automatic       char(720)                dcl 155 set ref 591 598 1262 1283 1358 1358
buffer_2                        000542 automatic       char(720)                dcl 156 set ref 1263 1282
bx                              000230 automatic       fixed bin(17,0)          dcl 127 set ref 1476* 1478 1485 1485 1509* 1511 1514
                                                                                  1514 1639* 1641 1641* 1644 1646
c_chars                                based           structure                level 1 dcl 1-54
can_called                      000215 automatic       bit(1)                   packed unaligned dcl 118 set ref 616* 663 1357*
can_type                 52            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 6-20
                                                                                  ref 565 567 1331
canm                     17(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 617
                                                                                  1636
canon_procedure                 000216 automatic       entry variable           dcl 119 set ref 565* 567* 569* 1358
channel_manager$control         000072 constant        entry                    external dcl 10-13 ref 427 788 799 831
channel_manager$read            000070 constant        entry                    external dcl 10-7 ref 937
channel_type              2            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 8-20 ref 364
                                                                                  1792 1794
chars                     1            based           char(1)                  array level 2 packed packed unaligned dcl 4-28 set
                                                                                  ref 509 726 1104 1150 1212
chars_echoed             11            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 11-19
                                                                                  set ref 770* 846 847* 847
chars_in_buf                    000212 automatic       fixed bin(17,0)          dcl 114 set ref 1211* 1214 1215 1227
cleanup                         001026 stack reference condition                dcl 265 ref 362
clock                                                  builtin function         dcl 263 ref 339 874
code                            000222 automatic       fixed bin(35,0)          dcl 121 set ref 427* 428 620 788* 789 791 799* 800
                                                                                  823* 1312* 1358*
control                  17(18)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 663
                                                                                  1287 1604
convert                         000127 automatic       bit(1)                   packed unaligned dcl 84 set ref 1147* 1149 1164*
                                                                                  1179* 1182*
converted                 0(19)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref
                                                                                  1074* 1147 1182
crash                           000063 constant        fixed bin(17,0)          initial dcl 160 set ref 1116*
ctally                    3     000244 automatic       fixed bin(17,0)          level 2 dcl 145 set ref 510* 513 516* 529 532 684*
                                                                                  686 899 899 901 902 903 1076* 1092 1095* 1103 1107
                                                                                  1151* 1154 1156 1161 1214* 1215 1215* 1219 1219*
                                                                                  1224 1225 1227 1227 1389* 1406* 1485* 1488* 1488*
                                                                                  1492 1505* 1511* 1514* 1516* 1516* 1520 1537* 1575
                                                                                  1636 1639 1641 1665
ctr                             000236 automatic       fixed bin(35,0)          level 2 dcl 136 set ref 784*
cumulative_meters        32            based           structure                level 2 dcl 6-20
cv_trans                               based           structure                level 1 dcl 1-62
data_base_ptr             1            based           pointer                  level 2 packed packed unaligned dcl 8-20 ref 366
data_ptr                        000152 automatic       pointer                  dcl 98 set ref 1150* 1161 1162 1352* 1354
delay                                  based           structure                level 1 dcl 1-66
devx                            000100 automatic       fixed bin(17,0)          dcl 67 set ref 344* 346 346 355* 362* 363 369* 385*
                                                                                  395* 403* 427* 434* 540* 643* 788* 799* 823* 831*
                                                                                  877* 937* 1063* 1113* 1172* 1789
dialed                   13(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 367
digit                           000240 automatic       fixed bin(17,0)          dcl 140 set ref 1702* 1703 1709 1710 1714* 1715
                                                                                  1715* 1721*
divide                                                 builtin function         dcl 263 ref 622
echdp                    21            based           bit(18)                  level 2 packed packed unaligned dcl 5-22 ref 414 419
echo_data                              based           structure                level 1 dcl 11-19
echo_datap                      001050 automatic       pointer                  dcl 11-15 set ref 419* 420 424 425 428 432 769 770
                                                                                  778 778 781 784 787 791 802 803 846 847 847
echo_neg_entries         77            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 807* 807
echo_neg_mux_inhibit    100            based           bit(1)                   level 2 dcl 2-35 ref 773
echo_start_data                 000236 automatic       structure                level 1 dcl 136 set ref 788 788
echo_start_pending_sndopt
                          7(06)        based           bit(1)                   level 2 packed packed unaligned dcl 11-19 set ref
                                                                                  424* 778* 791*
echoed                          000107 automatic       fixed bin(24,0)          dcl 72 set ref 321* 332* 846* 847 881
erase                    16            based           char(1)                  level 3 packed packed unaligned dcl 6-20 ref 560
                                                                                  1689
erase_char                      000227 automatic       char(1)                  dcl 126 set ref 560* 563* 1358* 1470
ercode                                 parameter       fixed bin(35,0)          dcl 62 set ref 24 295 302 314 325 348* 355* 356 371*
                                                                                  387* 394* 401* 416* 437* 443* 458* 476* 495 549
                                                                                  583 650 831* 859* 869 937* 939 1241 1616*
erklm                    17(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 558 668
error_code               24            based           fixed bin(35,0)          level 2 dcl 5-22 set ref 399 401 402*
error_table_$badcall            000040 external static fixed bin(35,0)          dcl 233 ref 476
error_table_$echnego_awaiting_stop_sync
                                000052 external static fixed bin(35,0)          dcl 238 ref 437
error_table_$improper_data_format
                                000042 external static fixed bin(35,0)          dcl 234 ref 1616
error_table_$invalid_device     000046 external static fixed bin(35,0)          dcl 236 ref 348
error_table_$invalid_write      000036 external static fixed bin(35,0)          dcl 232 ref 791
error_table_$io_no_permission   000044 external static fixed bin(35,0)          dcl 235 ref 371 387
error_table_$line_status_pending
                                000050 external static fixed bin(35,0)          dcl 237 ref 394 443
error_table_$no_table           000054 external static fixed bin(35,0)          dcl 239 ref 416
escape_length            54            based           fixed bin(17,0)          level 2 dcl 1-26 ref 1744 1744 1748 1748 1748 1748
                                                                                  1751 1751 1751 1751 1751 1751
escm                     17(03)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 1010
                                                                                  1586
fblock                   14            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 set ref 492
                                                                                  498 500 507 543* 580 587 625 643 643 644* 647 714
                                                                                  720 862 947 947* 1059 1067* 1149 1174* 1176 1178
fchar                    15            based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  set ref 509 510 529 532* 532 537* 592 602* 607*
                                                                                  652* 726 727 1207 1249*
first_char                      000156 automatic       fixed bin(17,0)          dcl 101 set ref 1207* 1211 1212 1227* 1227 1231*
                                                                                  1249
fixed                                                  builtin function         dcl 263 ref 644 947 952 1134 1230
flags                    30            based           structure                level 2 in structure "tcb" packed packed unaligned
                                                                                  dcl 6-20 in procedure "tty_read"
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 4-28 in procedure "tty_read"
flags                    13            based           structure                level 2 in structure "wtcb" packed packed unaligned
                                                                                  dcl 5-22 in procedure "tty_read"
get_line_entry                  000122 automatic       bit(1)                   packed unaligned dcl 79 set ref 290* 298* 305* 317*
                                                                                  328* 511 587 604 709 860 1208
have_more_data                  000131 automatic       bit(1)                   dcl 86 set ref 467* 937* 941
hc_fast_lock                           based           structure                level 1 dcl 3-10
horiz_room_left          11(09)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 11-19
                                                                                  set ref 769* 787
hproc                    10            based           bit(36)                  level 2 dcl 5-22 ref 381
i                               000231 automatic       fixed bin(17,0)          dcl 128 set ref 1667* 1668 1709* 1712 1712 1714 1715
                                                                                  1715* 1725 1727
i_char                                 parameter       char(1)                  dcl 980 ref 975 982
in                        2            based           structure                level 2 in structure "saved_meters" dcl 8-68
                                                                                  in procedure "tty_read"
in                       30            based           structure                array level 4 in structure "lct" dcl 8-11
                                                                                  in procedure "tty_read"
in                       10            based           structure                level 3 in structure "lcte" dcl 8-20 in procedure
                                                                                  "tty_read"
index                                                  builtin function         dcl 263 ref 513 727 1214 1379 1397 1440 1470 1748
indicator                 6     000244 automatic       fixed bin(17,0)          level 2 dcl 145 set ref 1570 1581 1584 1593 1596
                                                                                  1604 1613
input_available          13(10)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 545
                                                                                  647 935 941* 1235
input_escapes                          based           structure                level 2 dcl 1-26
input_mvtrp              10            based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 481 483
input_restart            21            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 629* 629
input_results                          based           structure                level 2 dcl 1-26
input_tctrp              11            based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 484 486
kill                     16(09)        based           char(1)                  level 3 packed packed unaligned dcl 6-20 ref 561
                                                                                  1689
kill_char                       000226 automatic       char(1)                  dcl 125 set ref 561* 563* 1358* 1440
last_block                      000160 automatic       fixed bin(18,0)          dcl 103 set ref 601* 638 640 1230*
lblock                   14(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 set ref
                                                                                  865* 951 961* 1134* 1184*
lct                                    based           structure                level 1 dcl 8-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 345
lcte                                   based           structure                level 1 dcl 8-20
lcte_array               20            based           structure                array level 2 dcl 8-11 set ref 363 1789 1791
lctep                           001046 automatic       pointer                  dcl 8-8 set ref 363* 364 366 1789* 1790 1791 1794
lctp                            001044 automatic       pointer                  dcl 8-7 set ref 345* 346 363 1789 1791
left_motion                            constant        char(2)                  initial dcl 172 ref 1316
len                                    based           fixed bin(8,0)           level 3 packed packed unaligned dcl 1-26 ref 1744
                                                                                  1748 1751 1751
length                                                 builtin function         dcl 263 ref 307 591 1358 1358
line_delimiter           23            based           char(1)                  level 2 packed packed unaligned dcl 5-22 ref 513 589
                                                                                  723
line_status_present      13(17)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 391
line_type                12(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 5-22
                                                                                  ref 663 1287
linemax                  21(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-20 ref 853
                                                                                  1598
major_channel_devx        3            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 8-20 ref 1790
                                                                                  1791
major_channel_info        3            based           structure                level 2 dcl 8-20
mark                      0(21)        based           bit(1)                   level 3 packed packed unaligned dcl 4-28 set ref 521
                                                                                  533* 966* 1081* 1089*
mark_entry                      000125 automatic       bit(1)                   packed unaligned dcl 82 set ref 308* 335* 462 474
                                                                                  521 702 883 1077
mark_index                      000202 automatic       fixed bin(17,0)          dcl 107 set ref 309* 521* 702 702 883 883
mark_next_buffer                001146 automatic       bit(1)                   packed unaligned dcl 1055 set ref 1070* 1079 1082*
                                                                                  1097*
mark_set                 13(25)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 964
                                                                                  967*
max_len                         000210 automatic       fixed bin(17,0)          dcl 112 set ref 586* 587 591* 595 599 622* 622 623
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 8-11 ref 346
meter_response_time             000010 constant        entry                    external dcl 214 ref 342 879
meters                   26            based           structure                array level 3 in structure "lct" dcl 8-11
                                                                                  in procedure "tty_read"
meters                    6            based           structure                level 2 in structure "lcte" dcl 8-20 in procedure
                                                                                  "tty_read"
min                                                    builtin function         dcl 263 ref 510 684 764 846 1076 1151
modes                    17            based           structure                level 2 packed packed unaligned dcl 6-20
mux_will_echnego          7(05)        based           bit(1)                   level 2 packed packed unaligned dcl 11-19 set ref
                                                                                  803*
mvt_args                               based           structure                level 1 dcl 254
mvtp                            000116 automatic       pointer                  dcl 77 set ref 481* 483* 1275 1277
negotiate_entry                 000123 automatic       bit(1)                   packed unaligned dcl 80 set ref 291* 299* 305* 318*
                                                                                  329* 412 452 767 844 881
negotiating_echo         13(21)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 420
                                                                                  430* 452* 771* 773* 777* 783* 805* 807 811 813*
                                                                                  843* 872*
nelem                           000105 automatic       fixed bin(24,0)          dcl 70 set ref 307* 338* 450 507 510 587 684 698 701
                                                                                  702 702 764 846 1151 1179
nelemt                          000106 automatic       fixed bin(24,0)          dcl 71 set ref 411* 507 510 527* 555 574* 587 682
                                                                                  684 689* 689 698 701 753* 764* 764 765 849 850 878
                                                                                  879 883 917* 939* 1615*
new_block                       000154 automatic       fixed bin(18,0)          dcl 99 set ref 538* 543 544 545 1170* 1174
new_blockp                      000150 automatic       pointer                  dcl 97 in procedure "tty_read" set ref 1063* 1064
                                                                                  1067 1073 1113* 1114 1121
new_blockp                             parameter       pointer                  dcl 931 in procedure "get_more_data" set ref 925
                                                                                  970*
new_blockp                      001164 automatic       pointer                  dcl 1204 in procedure "copy_loop" set ref 1240* 1243
                                                                                  1243
new_tally                       000161 automatic       fixed bin(17,0)          dcl 104 set ref 1156* 1157 1161 1161 1162 1162
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 4-28
                                                                                  set ref 538 642* 733 739 952* 957 958 1121* 1128*
                                                                                  1170 1232
next_break                      000213 automatic       fixed bin(17,0)          dcl 115 set ref 513* 514 516 721* 725 727* 730 736*
next_char                       000232 automatic       char(1)                  dcl 129 set ref 1675* 1676 1689 1689 1689 1702* 1748
ninchars                 12            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 850* 850
nl                              006401 constant        char(1)                  initial dcl 187 ref 1336 1338 1733
nl_found                               parameter       bit(1)                   packed unaligned dcl 59 set ref 295 860* 918*
no_break_anywhere               000133 automatic       bit(1)                   packed unaligned dcl 88 set ref 606* 611* 714 746
no_control_input                000041 constant        bit(1)                   initial array packed unaligned dcl 196 ref 663 1287
nocontrol                       000001 constant        bit(9)                   initial array packed unaligned dcl 198 set ref 1290
nrawread                 10            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 851* 851
nul_char                               constant        char(1)                  initial dcl 193 ref 1379 1397
null                                                   builtin function         dcl 263 ref 427 427 481 484 487 673 799 799 831 831
                                                                                  943 945 1016 1064 1114 1243 1275 1742
numeric                         001136 automatic       fixed bin(17,0)          dcl 1039 set ref 1041* 1042 1042 1042
obsolete_negotiate_entry        000124 automatic       bit(1)                   packed unaligned dcl 81 set ref 319* 330* 443
octal                           000234 automatic       structure                level 1 dcl 132
offset                          000104 automatic       fixed bin(24,0)          dcl 69 set ref 462* 464* 468 468
old_fblock                      000157 automatic       fixed bin(18,0)          dcl 102 set ref 1059* 1128 1134
old_rawcnt                      000242 automatic       fixed bin(17,0)          dcl 142 set ref 588* 626
old_sourcep                     000142 automatic       pointer                  dcl 92 set ref 1376* 1411 1428* 1543 1577* 1639
old_targetp                     000144 automatic       pointer                  dcl 93 set ref 678 1377* 1410 1429* 1476 1480 1488
                                                                                  1493 1542 1557* 1647
orig_blockp                     001104 automatic       pointer                  dcl 933 in procedure "get_more_data" set ref 955*
                                                                                  962
orig_blockp                     001166 automatic       pointer                  dcl 1205 in procedure "copy_loop" set ref 1239* 1245
orig_fchar                      000201 automatic       fixed bin(17,0)          dcl 106 set ref 592* 602 607
orig_output_ptr                 000134 automatic       pointer                  dcl 89 set ref 470* 748
output_ptr                      000102 automatic       pointer                  dcl 68 set ref 306* 337* 468* 468 470 502 590* 683
parent_mpx_type                        parameter       fixed bin(17,0)          dcl 1786 ref 1783 1792 1794
pds$processid                   000056 external static bit(36)                  dcl 240 set ref 342* 381 381 879*
pmark_index                     000203 automatic       fixed bin(17,0)          dcl 108 set ref 702* 705* 1085 1085 1090* 1092 1095
                                                                                  1099*
preconverted             20            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 1057* 1057
prev_blockp                     001102 automatic       pointer                  dcl 932 set ref 951* 952
prompt                   22(09)        based           char(3)                  level 2 packed packed unaligned dcl 5-22 set ref 823
                                                                                  823
prompt_len               22            based           fixed bin(8,0)           level 2 packed packed unaligned dcl 5-22 ref 817 823
ptr                                                    builtin function         dcl 263 ref 419 483 486 489 498 544 625 640 643 643
                                                                                  720 739 951 958 1178 1232
rank                                                   builtin function         dcl 263 ref 1019 1041 1689
raw_mode                        000243 automatic       bit(1)                   packed unaligned dcl 143 set ref 821* 824
rawcnt                          000241 automatic       fixed bin(17,0)          dcl 141 set ref 466* 555* 588 626* 851 1225* 1225
rawim                    17(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 472 504
rawom                    17(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 set ref 821
                                                                                  822* 824*
read_calls               32            based           fixed bin(35,0)          level 3 in structure "tcb" dcl 6-20 in procedure
                                                                                  "tty_read" set ref 409* 409
read_calls               30            based           fixed bin(35,0)          level 2 in structure "tty_buf" dcl 2-35 in procedure
                                                                                  "tty_read" set ref 410* 410
read_chars               34            based           fixed bin(35,0)          level 3 dcl 6-20 set ref 849* 849
read_time                24            based           fixed bin(71,0)          level 2 in structure "tty_buf" dcl 2-35 in procedure
                                                                                  "tty_read" set ref 876* 876
read_time                36            based           fixed bin(71,0)          level 3 in structure "tcb" dcl 6-20 in procedure
                                                                                  "tty_read" set ref 875* 875
readblocked              14            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 828* 828
receive_mode_device      13(24)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 831
rel                                                    builtin function         dcl 263 ref 644 947 952 961 1067 1121 1134 1210 1230
                                                                                  1235
result                    0(27) 000234 automatic       fixed bin(8,0)           level 2 packed packed unaligned dcl 132 set ref
                                                                                  1706* 1710* 1710 1724
reverse                                                builtin function         dcl 263 ref 1440 1476 1509 1639
rflag                    13(13)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 817
                                                                                  817 827* 842*
right_motion                           constant        char(2)                  initial dcl 175 ref 1476 1509 1639 1733
room_left                       000155 automatic       fixed bin(17,0)          dcl 100 set ref 599* 604 1210 1219 1219 1224* 1224
screen_left                     000110 automatic       fixed bin(17,0)          dcl 73 set ref 320* 331* 420 769 771
screenleft                1     000236 automatic       fixed bin(35,0)          level 2 dcl 136 set ref 787*
scroll                   17(21)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 853
search                                                 builtin function         dcl 263 ref 1316 1324
source_len                      000146 automatic       fixed bin(17,0)          dcl 94 set ref 657* 679* 684 689 701* 750* 996 996*
                                                                                  996 1057 1072 1076 1107* 1107 1108 1385* 1385
                                                                                  1409* 1430 1450* 1450 1465 1497* 1522* 1522 1541*
                                                                                  1561 1639 1736 1736*
source_ptr                      000136 automatic       pointer                  dcl 90 set ref 509* 513 658 678* 726* 727 748* 899
                                                                                  901* 901 1150* 1212* 1214 1262* 1267* 1267 1273
                                                                                  1282* 1284 1296 1297* 1344* 1348 1353 1354* 1358*
                                                                                  1362* 1376 1396* 1410* 1414 1428 1448* 1527* 1542*
                                                                                  1560 1577 1620*
special_chars                          based           structure                level 1 dcl 1-26
special_input_chars      16            based           structure                level 2 packed packed unaligned dcl 6-20
special_ptr                     000114 automatic       pointer                  dcl 76 set ref 487* 489* 1742 1744 1748 1751
specialrp                12            based           bit(18)                  level 3 packed packed unaligned dcl 6-20 ref 487 489
start_time                      000206 automatic       fixed bin(71,0)          dcl 111 set ref 339* 874
state                                  parameter       fixed bin(17,0)          dcl 61 set ref 24 295 302 314 325 375* 919*
str                                    based           char                     level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 1-26 in procedure "tty_read" ref
                                                                                  1751
str                                    based           char                     level 3 in structure "special_chars" packed packed
                                                                                  unaligned dcl 1-26 in procedure "tty_read" ref
                                                                                  1748
stringl                   2     000244 automatic       fixed bin(17,0)          level 2 dcl 145 set ref 657 996 998* 998 1019 1026
                                                                                  1272* 1316 1321* 1321 1324 1331 1336 1336 1338
                                                                                  1339* 1342* 1351 1351 1358* 1379 1381 1384* 1384
                                                                                  1391* 1391 1394 1397 1404 1406 1430* 1436 1440
                                                                                  1440 1442 1451 1455* 1465* 1469 1470 1497 1509
                                                                                  1516 1529* 1529 1535 1537 1561* 1564 1570 1586
                                                                                  1608 1682 1694* 1694 1712 1715 1727* 1727 1733
                                                                                  1733 1733 1733 1736 1738* 1754* 1754 1776* 1776
stringp                         000244 automatic       pointer                  level 2 dcl 145 set ref 658* 995* 995 1019 1026
                                                                                  1273* 1284* 1295* 1297 1316 1320* 1320 1324 1331
                                                                                  1336 1338 1344 1348 1351 1362 1379 1396 1396* 1397
                                                                                  1414* 1440 1448 1448* 1470 1509 1516 1527 1527*
                                                                                  1560* 1620 1668 1675 1682 1693* 1693 1707* 1707
                                                                                  1714 1715 1725* 1725 1733 1733 1752* 1752 1774
                                                                                  1775* 1775
substr                                                 builtin function         dcl 263 set ref 513 727 1019 1026 1161* 1161 1162*
                                                                                  1162 1214 1331 1336 1338* 1488 1509 1516 1639 1733
                                                                                  1733 1751
sync_ctr                 10            based           fixed bin(35,0)          level 2 dcl 11-19 ref 784
synchronized              7(04)        based           bit(1)                   level 2 packed packed unaligned dcl 11-19 ref 778
                                                                                  781
syserr                          000012 constant        entry                    external dcl 214 ref 1116
table                                  based           fixed bin(8,0)           array packed unaligned dcl 251 ref 1019 1689
tablep                    4            based           pointer                  level 2 in structure "mvt_args" dcl 254 in procedure
                                                                                  "tty_read" set ref 1277* 1290*
tablep                    4     000244 automatic       pointer                  level 2 in structure "util" dcl 145 in procedure
                                                                                  "tty_read" set ref 1562*
tables                   10            based           structure                level 2 dcl 6-20
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 4-28
                                                                                  set ref 510 529 727 1103* 1151 1154 1156 1157*
                                                                                  1211
tally_chars                            based           char                     packed unaligned dcl 897 set ref 899* 899
target_len                      000147 automatic       fixed bin(17,0)          dcl 95 set ref 465* 521 527 574 600* 659* 676 679
                                                                                  682* 711 750 903* 903 984* 984 1069* 1085 1092
                                                                                  1095 1151 1179 1268* 1268 1272 1402 1409 1466*
                                                                                  1474 1476 1481* 1488 1488 1488 1492* 1492 1493
                                                                                  1497 1533 1541 1558* 1570 1646* 1646 1647
target_ptr                      000140 automatic       pointer                  dcl 91 set ref 502* 590 598* 683* 899 902* 902 982
                                                                                  983* 983 1104* 1263* 1278 1283* 1291 1295 1296*
                                                                                  1351 1352 1353* 1377 1411* 1429 1480* 1493* 1543*
                                                                                  1557 1647*
targetp                   6            based           pointer                  level 2 dcl 254 set ref 1278* 1291*
tcb                                    based           structure                level 1 dcl 6-20
tcb_initialized          13(11)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 ref 378
tcb_ptr                   6            based           pointer                  level 2 packed packed unaligned dcl 5-22 ref 377
tcbp                            001042 automatic       pointer                  dcl 6-18 set ref 377* 378* 381 409 409 472 481 483
                                                                                  484 486 487 489 504 558 560 561 565 567 617 663
                                                                                  668 716 743 821 822 824 849 849 853 853 875 875
                                                                                  1010 1129 1165 1186 1287 1331 1586 1598 1604 1636
                                                                                  1689 1689
tctp                            000120 automatic       pointer                  dcl 78 set ref 484* 486* 673 1016 1019 1562 1689
temp_buf                        000162 automatic       char(60)                 dcl 105 set ref 1161* 1162
temp_lctep                      001260 automatic       pointer                  dcl 1787 set ref 1791* 1792
tempp                           000224 automatic       pointer                  dcl 123 set ref 640* 642
throw_away                      000130 automatic       bit(1)                   packed unaligned dcl 85 set ref 575* 1265 1269*
                                                                                  1608*
time_spent                      000204 automatic       fixed bin(71,0)          dcl 110 set ref 874* 875 876
to_skip                                parameter       fixed bin(17,0)          dcl 993 ref 988 995 996 998
tty_buf                                based           structure                level 1 dcl 2-35
tty_buf$                        000060 external static fixed bin(17,0)          dcl 2-19 set ref 341
tty_index$initialize_tcb        000020 constant        entry                    external dcl 219 ref 378
tty_lock$lock_channel           000014 constant        entry                    external dcl 214 ref 355
tty_lock$unlock_channel         000016 constant        entry                    external dcl 214 ref 362 369 385 395 403 434 877
tty_overstrike_canon            000026 constant        entry                    external dcl 222 ref 565 569
tty_replace_canon               000030 constant        entry                    external dcl 224 ref 567
tty_space_man$free_buffer       000064 constant        entry                    external dcl 9-14 ref 540 1172
tty_space_man$free_chain        000066 constant        entry                    external dcl 9-16 ref 643
tty_space_man$get_buffer        000062 constant        entry                    external dcl 9-13 ref 1063 1113
tty_tables$                     000034 external static fixed bin(17,0)          dcl 231 set ref 480
tty_util_$mvt                   000022 constant        entry                    external dcl 220 ref 1280 1293
tty_util_$tct                   000024 constant        entry                    external dcl 221 ref 1568
tty_write$locked                000032 constant        entry                    external dcl 226 ref 823
ttybp                           001034 automatic       pointer                  dcl 2-19 set ref 341* 345 410 410 419 498 544 625
                                                                                  629 629 640 643 643 720 739 773 807 807 828 828
                                                                                  850 850 851 851 876 876 951 1057 1057 1178 1232
ttytp                           000112 automatic       pointer                  dcl 75 set ref 480* 483 486 489
twx                                    parameter       fixed bin(17,0)          dcl 49 ref 24 295 302 314 325 344
unconverted_break               000132 automatic       bit(1)                   packed unaligned dcl 87 set ref 714* 716* 730* 735*
                                                                                  743
uncp_flag                       000233 automatic       bit(1)                   packed unaligned dcl 130 set ref 353* 817 817 830
uproc                    11            based           bit(36)                  level 2 dcl 5-22 ref 381
uproc_attached           30(05)        based           bit(1)                   level 3 packed packed unaligned dcl 6-20 ref 381
util                            000244 automatic       structure                level 1 dcl 145 set ref 1277 1278 1280 1280 1290
                                                                                  1291 1293 1293 1568 1568
verify                                                 builtin function         dcl 263 ref 1331 1476 1509 1639 1733
vertical_motion                        constant        char(2)                  initial dcl 178 ref 1324
write_first              16            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-22 ref 775
wru                      13(14)        based           bit(1)                   level 3 packed packed unaligned dcl 5-22 set ref 831
                                                                                  837* 842*
wtcb                                   based           structure                level 1 dcl 5-22
wtcbp                           001040 automatic       pointer                  dcl 5-20 set ref 366* 367 377 378 378* 381 381 391
                                                                                  399 401 402 414 419 420 430 452 492 498 500 507
                                                                                  509 510 513 529 532 532 537 543 545 580 587 589
                                                                                  592 602 607 625 643 643 644 647 647 652 663 714
                                                                                  720 723 726 727 771 773 775 777 783 805 807 811
                                                                                  813 817 817 817 823 823 823 827 831 831 837 842
                                                                                  842 843 853 862 865 866 872 935 941 947 947 951
                                                                                  961 964 967 1059 1067 1134 1149 1174 1176 1178
                                                                                  1184 1207 1235 1249 1287
xr                              000214 automatic       fixed bin(17,0)          dcl 117 set ref 1013 1019 1023 1026 1313* 1314 1316*
                                                                                  1318 1328 1331 1338 1339 1342 1379* 1381 1382 1389
                                                                                  1391 1396 1397* 1434* 1436 1440* 1442 1444* 1444
                                                                                  1448 1450 1451* 1455 1456* 1467* 1469 1470* 1472
                                                                                  1503 1505 1509 1514 1516 1522 1525 1527 1529 1748*
                                                                                  1749 1751

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AWARD_ELIGIBILITY                      internal static fixed bin(17,0)          initial dcl 12-7
BLOCK_PROCESS                          internal static fixed bin(17,0)          initial dcl 12-7
CAN_TYPE_NAMES                         internal static char(32)                 initial array dcl 7-8
CV_TRANS_SIZE                          internal static fixed bin(17,0)          initial array dcl 1-129
CV_TRANS_VERSION                       internal static fixed bin(17,0)          initial dcl 1-127
DELAY_VERSION                          internal static fixed bin(17,0)          initial dcl 1-126
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
HASP_MPX                               internal static fixed bin(17,0)          initial dcl 13-16
IBM3270_MPX                            internal static fixed bin(17,0)          initial dcl 13-16
INPUT_CONVERT_BREAK                    internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_DISCARD                  internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_DSA_CR_PROCESSING        internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_ESCAPE                   internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_FORMFEED                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_ORDINARY                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
INPUT_CONVERT_PRECEDENCE_DISCARD       internal static fixed bin(8,0)           initial packed unaligned dcl 1-135
LAP_MPX                                internal static fixed bin(17,0)          initial dcl 13-16
MAX_TRANSITION                         internal static fixed bin(17,0)          initial dcl 12-7
MCS_MPX                                internal static fixed bin(17,0)          initial dcl 13-16
NON_TTY_WAKEUP                         internal static fixed bin(17,0)          initial dcl 12-7
OUTPUT                                 internal static bit(1)                   initial packed unaligned dcl 9-21
OUTPUT_CONVERT_BRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_BS                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_CR                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_DONT_SEND               internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_FF                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_FIRST_SPECIAL           internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_HT                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NEWLINE                 internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_13             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_14             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_15             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NOT_USED_16             internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_NO_MOTION               internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_OCTAL                   internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_ORDINARY                internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_PRECEDENCE_NO_MOTION    internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_RRS                     internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
OUTPUT_CONVERT_VT                      internal static fixed bin(8,0)           initial packed unaligned dcl 1-147
PROTOCOL_MPX                           internal static fixed bin(17,0)          initial dcl 13-16
SPECIAL_INFO_STRUCT_VERSION_1          internal static char(8)                  initial packed unaligned dcl 1-122
SPECIAL_VERSION                        internal static fixed bin(17,0)          initial dcl 1-124
SPECIAL_VERSION_2                      internal static fixed bin(17,0)          initial dcl 1-125
STY_MPX                                internal static fixed bin(17,0)          initial dcl 13-16
SYSTEM1_MPX                            internal static fixed bin(17,0)          initial dcl 13-16
SYSTEM2_MPX                            internal static fixed bin(17,0)          initial dcl 13-16
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
TTY_MPX                                internal static fixed bin(17,0)          initial dcl 13-16
TTY_WAKEUP                             internal static fixed bin(17,0)          initial dcl 12-7
USER1_MPX                              internal static fixed bin(17,0)          initial dcl 13-16
USER2_MPX                              internal static fixed bin(17,0)          initial dcl 13-16
USER3_MPX                              internal static fixed bin(17,0)          initial dcl 13-16
USER4_MPX                              internal static fixed bin(17,0)          initial dcl 13-16
USER5_MPX                              internal static fixed bin(17,0)          initial dcl 13-16
VIP7760_MPX                            internal static fixed bin(17,0)          initial dcl 13-16
WIRED_ECHO_BREAK_SIZE                  internal static fixed bin(17,0)          initial dcl 11-16
WORDS_IN_ECHO_BREAK_TABLE              internal static fixed bin(17,0)          initial dcl 11-17
X25_MPX                                internal static fixed bin(17,0)          initial dcl 13-16
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
c_chars_ptr                            automatic       pointer                  dcl 1-53
channel_manager$check_modes     000000 constant        entry                    external dcl 10-19
channel_manager$get_modes       000000 constant        entry                    external dcl 10-22
channel_manager$interrupt       000000 constant        entry                    external dcl 10-25
channel_manager$interrupt_later 000000 constant        entry                    external dcl 10-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 10-31
channel_manager$set_modes       000000 constant        entry                    external dcl 10-16
channel_manager$write           000000 constant        entry                    external dcl 10-10
cv_trans_struc                         based           structure                level 1 dcl 1-107
delay_struc                            based           structure                level 1 dcl 1-112
free_block                             based           structure                level 1 dcl 4-23
free_blockp                            automatic       pointer                  dcl 4-20
get_special_info_struc                 based           structure                level 1 dcl 1-117
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
lcnt                                   based           structure                level 1 dcl 8-65
lcntp                                  automatic       pointer                  dcl 8-63
lct_size                               automatic       fixed bin(17,0)          dcl 8-9
lock_ptr                               automatic       pointer                  dcl 3-9
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 4-43
mpx_special_lock                       internal static bit(1)                   initial array packed unaligned dcl 13-40
mpx_types                              internal static char(32)                 initial array packed unaligned dcl 13-35
output_bpart                           internal static fixed bin(18,0)          initial dcl 2-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
saved_meters                           based           structure                level 1 dcl 8-68
sc_escape_len                          automatic       fixed bin(17,0)          dcl 1-58
sc_input_escape_len                    automatic       fixed bin(17,0)          dcl 1-59
special_chars_struc                    based           structure                level 1 dcl 1-76
tty_ev                                 internal static fixed bin(17,0)          initial dcl 2-19
tty_space_man$free_space        000000 constant        entry                    external dcl 9-12
tty_space_man$get_chain         000000 constant        entry                    external dcl 9-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 9-11
tty_space_man$get_space         000000 constant        entry                    external dcl 9-10
tty_space_man$needs_space       000000 constant        entry                    external dcl 9-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 9-17

NAMES DECLARED BY EXPLICIT CONTEXT.
MUST_CALL_CANONICALIZE          003770 constant        label                    dcl 1348 ref 1324
all_done                        002423 constant        label                    dcl 862 ref 417 459 477 495 549 583 650 1241 1617
canonicalization                003653 constant        entry                    internal dcl 1304 ref 619
char_value                      003013 constant        entry                    internal dcl 1032 ref 1702 1714
clean_up                        002536 constant        entry                    internal dcl 909 ref 349 358 372 386 393 435 871
copy_chars                      002516 constant        entry                    internal dcl 891 ref 525 686 1105 1152 1222 1390
                                                                                  1407 1520 1538 1578
copy_loop                       003415 constant        entry                    internal dcl 1196 ref 603
copy_to_preconverted            003032 constant        entry                    internal dcl 1050 ref 706 752
echo_negotiate_get_chars        000316 constant        entry                    external dcl 325
escaped                         002727 constant        entry                    internal dcl 1004 ref 1446 1505
get_more_data                   002550 constant        entry                    internal dcl 925 ref 494 547 582 649 1240
insert_and_update               005214 constant        entry                    internal dcl 1765 ref 1586 1601 1611 1653 1670 1678
                                                                                  1685 1695 1742 1744 1757
insert_char                     002672 constant        entry                    internal dcl 975 ref 1724 1751 1774
is_parent_mpx                   005233 constant        entry                    internal dcl 1783 ref 353
join                            000343 constant        label                    dcl 335 ref 292 300 322 333
mark_join                       000352 constant        label                    dcl 339 ref 310
no_line                         001630 constant        label                    dcl 711 ref 608
no_permission                   000466 constant        label                    dcl 369 ref 364
no_space                        003177 constant        label                    dcl 1116 ref 1064
pickup_preconverted             003251 constant        entry                    internal dcl 1141 ref 572
process_break_char              004620 constant        entry                    internal dcl 1628 ref 1581
process_erase_kill              004141 constant        entry                    internal dcl 1420 ref 668
process_escape_break            004452 constant        entry                    internal dcl 1550 ref 673
process_escape_char             004657 constant        entry                    internal dcl 1659 ref 1589
retry                           001365 constant        label                    dcl 595 ref 630
skip                            002707 constant        entry                    internal dcl 988 ref 1593 1598 1607
strip_nulls                     004035 constant        entry                    internal dcl 1369 ref 663
translation                     003547 constant        entry                    internal dcl 1254 ref 612
tty_get_line                    000171 constant        entry                    external dcl 295
tty_read                        000143 constant        entry                    external dcl 24
tty_read_echoed                 000267 constant        entry                    external dcl 314
tty_read_with_mark              000217 constant        entry                    external dcl 302

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6776        7072    6402        7006
Length      7602    6402        74         474     374           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tty_read                            814 external procedure  is an external procedure.  
on unit on line 362                  68 on unit               
copy_chars                              internal procedure  shares stack frame of external procedure tty_read.  
clean_up                                internal procedure  shares stack frame of external procedure tty_read.  
get_more_data                           internal procedure  shares stack frame of external procedure tty_read.  
insert_char                             internal procedure  shares stack frame of external procedure tty_read.  
skip                                    internal procedure  shares stack frame of external procedure tty_read.  
escaped                                 internal procedure  shares stack frame of external procedure tty_read.  
char_value                              internal procedure  shares stack frame of external procedure tty_read.  
copy_to_preconverted                    internal procedure  shares stack frame of external procedure tty_read.  
pickup_preconverted                     internal procedure  shares stack frame of external procedure tty_read.  
copy_loop                               internal procedure  shares stack frame of external procedure tty_read.  
translation                             internal procedure  shares stack frame of external procedure tty_read.  
canonicalization                        internal procedure  shares stack frame of external procedure tty_read.  
strip_nulls                             internal procedure  shares stack frame of external procedure tty_read.  
process_erase_kill                      internal procedure  shares stack frame of external procedure tty_read.  
process_escape_break                    internal procedure  shares stack frame of external procedure tty_read.  
process_break_char                      internal procedure  shares stack frame of external procedure tty_read.  
process_escape_char                     internal procedure  shares stack frame of external procedure tty_read.  
insert_and_update                       internal procedure  shares stack frame of external procedure tty_read.  
is_parent_mpx                           internal procedure  shares stack frame of external procedure tty_read.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tty_read                 000100 devx                        tty_read
                         000102 output_ptr                  tty_read
                         000104 offset                      tty_read
                         000105 nelem                       tty_read
                         000106 nelemt                      tty_read
                         000107 echoed                      tty_read
                         000110 screen_left                 tty_read
                         000112 ttytp                       tty_read
                         000114 special_ptr                 tty_read
                         000116 mvtp                        tty_read
                         000120 tctp                        tty_read
                         000122 get_line_entry              tty_read
                         000123 negotiate_entry             tty_read
                         000124 obsolete_negotiate_entry    tty_read
                         000125 mark_entry                  tty_read
                         000126 break_found                 tty_read
                         000127 convert                     tty_read
                         000130 throw_away                  tty_read
                         000131 have_more_data              tty_read
                         000132 unconverted_break           tty_read
                         000133 no_break_anywhere           tty_read
                         000134 orig_output_ptr             tty_read
                         000136 source_ptr                  tty_read
                         000140 target_ptr                  tty_read
                         000142 old_sourcep                 tty_read
                         000144 old_targetp                 tty_read
                         000146 source_len                  tty_read
                         000147 target_len                  tty_read
                         000150 new_blockp                  tty_read
                         000152 data_ptr                    tty_read
                         000154 new_block                   tty_read
                         000155 room_left                   tty_read
                         000156 first_char                  tty_read
                         000157 old_fblock                  tty_read
                         000160 last_block                  tty_read
                         000161 new_tally                   tty_read
                         000162 temp_buf                    tty_read
                         000201 orig_fchar                  tty_read
                         000202 mark_index                  tty_read
                         000203 pmark_index                 tty_read
                         000204 time_spent                  tty_read
                         000206 start_time                  tty_read
                         000210 max_len                     tty_read
                         000211 break                       tty_read
                         000212 chars_in_buf                tty_read
                         000213 next_break                  tty_read
                         000214 xr                          tty_read
                         000215 can_called                  tty_read
                         000216 canon_procedure             tty_read
                         000222 code                        tty_read
                         000224 tempp                       tty_read
                         000226 kill_char                   tty_read
                         000227 erase_char                  tty_read
                         000230 bx                          tty_read
                         000231 i                           tty_read
                         000232 next_char                   tty_read
                         000233 uncp_flag                   tty_read
                         000234 octal                       tty_read
                         000236 echo_start_data             tty_read
                         000240 digit                       tty_read
                         000241 rawcnt                      tty_read
                         000242 old_rawcnt                  tty_read
                         000243 raw_mode                    tty_read
                         000244 util                        tty_read
                         000256 buffer_1                    tty_read
                         000542 buffer_2                    tty_read
                         001034 ttybp                       tty_read
                         001036 blockp                      tty_read
                         001040 wtcbp                       tty_read
                         001042 tcbp                        tty_read
                         001044 lctp                        tty_read
                         001046 lctep                       tty_read
                         001050 echo_datap                  tty_read
                         001102 prev_blockp                 get_more_data
                         001104 orig_blockp                 get_more_data
                         001136 numeric                     char_value
                         001146 mark_next_buffer            copy_to_preconverted
                         001164 new_blockp                  copy_loop
                         001166 orig_blockp                 copy_loop
                         001260 temp_lctep                  is_parent_mpx

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry
ext_entry_desc      int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$control       channel_manager$read          meter_response_time           syserr
tty_index$initialize_tcb      tty_lock$lock_channel         tty_lock$unlock_channel       tty_overstrike_canon
tty_replace_canon             tty_space_man$free_buffer     tty_space_man$free_chain      tty_space_man$get_buffer
tty_util_$mvt                 tty_util_$tct                 tty_write$locked

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badcall          error_table_$echnego_awaiting_stop_sync
error_table_$improper_data_format                           error_table_$invalid_device   error_table_$invalid_write
error_table_$io_no_permission error_table_$line_status_pending                            error_table_$no_table
pds$processid                 tty_buf$                      tty_tables$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000135       290 000157       291 000160       292 000161       295 000162       298 000205       299 000207
    300 000210       302 000211       305 000241       306 000243       307 000246       308 000254       309 000256
    310 000257       314 000260       317 000303       318 000304       319 000306       320 000307       321 000312
    322 000313       325 000314       328 000332       329 000333       330 000335       331 000336       332 000341
    333 000342       335 000343       337 000344       338 000350       339 000352       341 000354       342 000357
    344 000367       345 000372       346 000375       348 000401       349 000404       350 000405       353 000406
    355 000410       356 000421       358 000423       359 000424       362 000425       363 000451       364 000456
    366 000461       367 000463       369 000466       371 000475       372 000500       373 000501       375 000502
    377 000504       378 000506       381 000522       385 000536       386 000544       387 000545       388 000550
    391 000551       393 000554       394 000555       395 000560       396 000566       399 000567       401 000571
    402 000572       403 000573       404 000601       409 000602       410 000607       411 000614       412 000615
    414 000617       416 000623       417 000625       419 000626       420 000631       424 000641       425 000643
    427 000646       428 000702       430 000710       432 000713       434 000717       435 000726       436 000727
    437 000731       443 000734       446 000740       450 000741       452 000743       458 000750       459 000751
    462 000752       464 000760       465 000761       466 000762       467 000763       468 000764       470 000771
    472 000773       474 000777       476 001001       477 001004       480 001005       481 001010       483 001017
    484 001022       486 001031       487 001034       489 001043       492 001046       494 001053       495 001055
    497 001057       498 001060       500 001063       502 001067       504 001071       506 001075       507 001076
    509 001107       510 001115       511 001130       513 001132       514 001143       516 001144       517 001145
    521 001147       525 001157       527 001160       529 001162       532 001173       533 001177       534 001201
    537 001202       538 001204       540 001207       543 001222       544 001226       545 001232       547 001236
    549 001240       553 001242       555 001243       556 001245       558 001246       560 001251       561 001254
    562 001260       563 001261       565 001264       567 001277       569 001307       572 001314       574 001315
    575 001317       580 001320       582 001324       583 001326       586 001330       587 001332       588 001351
    589 001353       590 001356       591 001360       592 001362       595 001365       598 001367       599 001371
    600 001372       601 001373       602 001374       603 001400       604 001401       606 001407       607 001411
    608 001415       611 001416       612 001417       616 001420       617 001421       619 001425       620 001426
    622 001430       623 001434       625 001435       626 001443       627 001445       629 001446       630 001450
    638 001451       640 001453       642 001456       643 001460       644 001501       647 001506       649 001515
    650 001517       652 001521       657 001524       658 001526       659 001530       663 001531       668 001545
    673 001552       676 001557       678 001561       679 001563       682 001564       683 001566       684 001570
    686 001576       689 001601       693 001603       698 001604       701 001607       702 001611       705 001621
    706 001622       707 001623       709 001624       711 001630       714 001632       716 001643       720 001652
    721 001655       723 001656       725 001661       726 001664       727 001673       730 001711       733 001715
    735 001721       736 001722       737 001724       739 001725       740 001730       743 001731       746 001737
    748 001741       750 001743       752 001745       753 001746       764 001747       765 001754       767 001756
    769 001760       770 001764       771 001766       773 001774       775 002003       777 002007       778 002011
    780 002016       781 002017       783 002022       784 002024       787 002026       788 002032       789 002064
    791 002067       797 002075       799 002076       800 002130       802 002132       803 002135       804 002137
    805 002140       807 002143       809 002154       811 002155       813 002161       817 002163       821 002206
    822 002213       823 002215       824 002251       827 002257       828 002262       830 002267       831 002272
    835 002333       837 002334       839 002336       842 002337       843 002344       844 002346       846 002350
    847 002360       849 002364       850 002371       851 002376       853 002402       859 002413       860 002414
    862 002423       865 002427       866 002431       869 002433       871 002435       872 002436       874 002441
    875 002444       876 002447       877 002453       878 002462       879 002464       881 002476       883 002503
    886 002513       887 002515       891 002516       899 002517       901 002525       902 002530       903 002533
    905 002535       909 002536       917 002537       918 002541       919 002546       920 002547       925 002550
    935 002552       937 002556       939 002573       941 002576       942 002604       943 002605       945 002607
    947 002613       951 002624       952 002632       955 002636       957 002640       958 002644       959 002647
    961 002650       962 002654       964 002656       966 002662       967 002664       970 002666       971 002671
    975 002672       982 002674       983 002701       984 002705       985 002706       988 002707       995 002711
    996 002715       998 002723      1000 002726      1004 002727      1010 002731      1013 002737      1016 002744
   1019 002752      1023 002774      1026 003002      1029 003010      1032 003013      1041 003015      1042 003020
   1046 003027      1050 003032      1057 003033      1059 003040      1063 003044      1064 003061      1067 003065
   1069 003072      1070 003073      1072 003074      1073 003076      1074 003100      1076 003102      1077 003106
   1079 003110      1081 003112      1082 003114      1083 003115      1085 003116      1089 003124      1090 003126
   1091 003127      1092 003130      1095 003134      1097 003140      1099 003142      1103 003143      1104 003146
   1105 003151      1107 003152      1108 003154      1113 003156      1114 003173      1116 003177      1118 003217
   1121 003220      1124 003225      1128 003226      1129 003232      1132 003241      1134 003242      1137 003250
   1141 003251      1146 003252      1147 003253      1149 003257      1150 003266      1151 003273      1152 003304
   1154 003305      1156 003312      1157 003314      1161 003316      1162 003323      1164 003326      1165 003327
   1166 003332      1169 003333      1170 003337      1172 003342      1174 003355      1176 003361      1178 003365
   1179 003370      1182 003377      1183 003403      1184 003404      1186 003406      1190 003413      1192 003414
   1196 003415      1207 003416      1208 003422      1210 003425      1211 003434      1212 003440      1214 003445
   1215 003456      1217 003462      1219 003464      1222 003470      1224 003471      1225 003473      1227 003475
   1230 003501      1231 003504      1232 003505      1235 003512      1239 003522      1240 003524      1241 003526
   1243 003530      1245 003537      1247 003541      1249 003542      1251 003546      1254 003547      1262 003550
   1263 003552      1265 003554      1267 003556      1268 003562      1269 003564      1272 003565      1273 003567
   1275 003571      1277 003575      1278 003577      1280 003600      1282 003611      1283 003613      1284 003615
   1287 003616      1290 003630      1291 003632      1293 003633      1295 003644      1296 003646      1297 003650
   1300 003652      1304 003653      1312 003654      1313 003655      1314 003657      1316 003663      1318 003677
   1320 003701      1321 003705      1322 003707      1324 003710      1328 003722      1331 003724      1336 003751
   1338 003755      1339 003760      1340 003762      1342 003763      1344 003766      1345 003767      1348 003770
   1351 003774      1352 004000      1353 004001      1354 004003      1357 004005      1358 004007      1360 004031
   1362 004032      1363 004033      1365 004034      1369 004035      1376 004036      1377 004040      1379 004042
   1381 004055      1382 004062      1384 004065      1385 004067      1386 004071      1389 004072      1390 004074
   1391 004075      1394 004077      1396 004101      1397 004107      1400 004121      1402 004122      1404 004124
   1406 004126      1407 004127      1409 004130      1410 004132      1411 004134      1414 004136      1416 004140
   1420 004141      1428 004142      1429 004144      1430 004146      1434 004150      1436 004151      1440 004155
   1442 004173      1444 004175      1446 004176      1448 004203      1450 004211      1451 004213      1452 004215
   1455 004216      1456 004221      1459 004222      1465 004223      1466 004225      1467 004226      1469 004230
   1470 004234      1472 004246      1474 004250      1476 004252      1478 004265      1480 004266      1481 004267
   1482 004270      1485 004271      1488 004276      1490 004316      1492 004321      1493 004323      1497 004327
   1499 004334      1503 004335      1505 004337      1509 004347      1511 004365      1514 004370      1516 004376
   1517 004412      1520 004415      1522 004421      1525 004423      1527 004425      1529 004432      1531 004434
   1533 004435      1535 004437      1537 004441      1538 004442      1541 004443      1542 004445      1543 004447
   1546 004451      1550 004452      1557 004453      1558 004455      1559 004456      1560 004457      1561 004461
   1562 004463      1564 004465      1568 004470      1570 004501      1575 004510      1577 004512      1578 004514
   1581 004515      1584 004522      1586 004524      1589 004535      1590 004536      1593 004537      1596 004546
   1598 004550      1601 004562      1602 004563      1604 004564      1607 004572      1608 004576      1610 004602
   1611 004603      1613 004605      1615 004607      1616 004610      1617 004613      1620 004614      1622 004616
   1624 004617      1628 004620      1634 004621      1636 004623      1639 004631      1641 004643      1644 004646
   1646 004647      1647 004651      1653 004655      1655 004656      1659 004657      1665 004660      1667 004662
   1668 004664      1670 004671      1671 004672      1675 004673      1676 004700      1678 004704      1679 004705
   1682 004706      1685 004715      1686 004716      1689 004717      1693 004752      1694 004756      1695 004760
   1696 004761      1702 004762      1703 004764      1706 004766      1707 004770      1709 004774      1710 005003
   1712 005011      1714 005017      1715 005026      1719 005044      1721 005045      1722 005047      1724 005051
   1725 005056      1727 005064      1728 005066      1733 005067      1736 005111      1738 005115      1739 005116
   1742 005117      1744 005125      1748 005142      1749 005163      1751 005164      1752 005203      1754 005207
   1755 005211      1757 005212      1761 005213      1765 005214      1774 005215      1775 005224      1776 005230
   1778 005232      1783 005233      1789 005235      1790 005242      1791 005246      1792 005252      1793 005263
   1794 005264      1795 005275


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
