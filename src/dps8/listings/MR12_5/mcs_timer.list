	COMPILATION LISTING OF SEGMENT mcs_timer
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1030.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
        9 mcs_timer:
       10      procedure ();
       11 
       12 MAIN_RETURN:					/* This is the only way out of this program. Everything */
       13 	return;					/* does a non-local goto to here */
       14 
       15 /* *	MCS_TIMER -- Ring zero MCS timer manager
       16*   *
       17*   *	This procedure implements timers for ring zero MCS. When a timer comes due,
       18*   *	a TIMER interrupt is delivered to the lucky channel. For all the frankly
       19*   *	fascinating details, see MTB-xxx.
       20*   *
       21*   *	Written 24 March 1982, W. Olin Sibert, for the ASEA Hyperchannel project.
       22*   *	Modification history:
       23*   *	24 Mar 82, WOS: Initial coding, for the ASEA Hyperchannel project.
       24*   *	30 May 82, WOS: Added subchan_idx parameters, changed timer_id to bit (36).
       25*   *	October 1982, CAH: Redesigned to use an hproc.
       26**/
       27 
       28 declare  P_devx fixed bin parameter;			/* Channel number */
       29 declare  P_subchan_idx fixed bin parameter;		/* Index of subchannel timer belongs to */
       30 declare  P_time fixed bin (71) parameter;		/* Time for timer to come due */
       31 declare  P_timer_id bit (36) aligned parameter;		/* Timer ID caller uses to tell timers apart */
       32 
       33 declare  devx fixed bin;				/* Local copies of parameters */
       34 declare  subchan_idx fixed bin;
       35 declare  time fixed bin (71);
       36 declare  timer_id bit (36) aligned;
       37 
       38 declare  wire_mask fixed bin (71);			/* pmut$wire_and_mask info */
       39 declare  wire_ptr pointer;
       40 declare  start_time fixed bin (71);			/* Time mcs_timer was entered, for metering */
       41 
       42 declare  timer_found bit (1) aligned;			/* Whether locate_timer found this sort of timer anywhere */
       43 declare  timer_was_queued bit (1) aligned;		/* Whether the located timer was in the interrupt queue */
       44 declare  channel_locked bit (1) aligned;		/* we managed to lock channel */
       45 
       46 declare  pds$processid bit (36) aligned external static;
       47 
       48 declare  channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
       49 declare  privileged_mode_ut$wire_and_mask entry (fixed bin (71), pointer);
       50 declare  privileged_mode_ut$unwire_unmask entry (fixed bin (71), pointer);
       51 declare  pxss$unique_ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       52 declare  syserr entry options (variable);
       53 declare  tty_lock$check_for_interrupt entry (fixed bin, fixed bin, bit (72) aligned) returns (bit (1) aligned);
       54 declare  tty_lock$dequeue_one_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
       55 declare  tty_lock$dequeue_all_interrupts entry (fixed bin, fixed bin);
       56 declare  tty_lock$lock_channel_int entry (fixed bin, fixed bin, bit (72) aligned, bit (1) aligned);
       57 declare  tty_lock$unlock_channel_int entry (fixed bin);
       58 
       59 declare  (addr, clock, null, pointer, rel, size, stacq, unspec) builtin;
       60 
       61 /* format: on */
       62 
       63 mcs_timer$set:
       64      entry (P_devx, P_subchan_idx, P_time, P_timer_id);
       65 
       66 	devx = P_devx;
       67 	time = P_time;
       68 	call get_id_and_subchan ();
       69 
       70 	call setup_channel ();
       71 
       72 	call locate_timer ();
       73 
       74 	if timer_found then call timer_error ("Duplicate timer ID. Cannot set");
       75 
       76 	call allocate_timer_block ();			/* Get space for the new timer */
       77 
       78 	call fill_timer_block ();			/* and fill it in */
       79 
       80 	call thread_timer_block ();			/* Add it to the lists */
       81 
       82 	call finished (tty_buf.timer_call_time, tty_buf.timer_set_calls);
       83 						/* All done */
       84 	call unlock_timer_lock ();
       85 	goto MAIN_RETURN;				/* Depart */
       86 
       87 mcs_timer$change:
       88      entry (P_devx, P_subchan_idx, P_time, P_timer_id);
       89 
       90 	devx = P_devx;
       91 	time = P_time;
       92 	call get_id_and_subchan ();
       93 
       94 	call setup_channel ();
       95 
       96 	call locate_timer ();
       97 
       98 	if ^timer_found then call timer_error ("Timer not found. Cannot change");
       99 
      100 	if timer_was_queued then do;
      101 	     call tty_lock$dequeue_one_interrupt (devx, TIMER, unspec (timer_info));
      102 						/* If it came from the interrupt queue, must get a new */
      103 	     call allocate_timer_block ();		/* timer block. Otherwise, we can just re-use the old one */
      104 	     end;
      105 	else call unthread_timer_block ();
      106 
      107 	call fill_timer_block ();
      108 
      109 	call thread_timer_block ();
      110 
      111 	call finished (tty_buf.timer_call_time, tty_buf.timer_change_calls);
      112 
      113 	call unlock_timer_lock ();
      114 
      115 	goto MAIN_RETURN;				/* Depart */
      116 
      117 mcs_timer$reset:
      118      entry (P_devx, P_subchan_idx, P_timer_id);
      119 
      120 	devx = P_devx;
      121 	call get_id_and_subchan ();
      122 
      123 	call setup_channel ();
      124 
      125 	call locate_timer ();
      126 
      127 	if ^timer_found then call timer_error ("Timer not found. Cannot reset");
      128 
      129 	if timer_was_queued
      130 	then call tty_lock$dequeue_one_interrupt (devx, TIMER, unspec (timer_info));
      131 	else do;					/* Remove from the lists and free */
      132 	     call unthread_timer_block ();
      133 	     call free_timer_block ();
      134 	     end;
      135 
      136 	call finished (tty_buf.timer_call_time, tty_buf.timer_reset_calls);
      137 
      138 	call unlock_timer_lock ();
      139 
      140 	goto MAIN_RETURN;				/* Depart */
      141 
      142 mcs_timer$reset_all:
      143      entry (P_devx);
      144 
      145 	devx = P_devx;
      146 	call setup_channel ();
      147 
      148 	call tty_lock$dequeue_all_interrupts (devx, TIMER);
      149 						/* Get the urgent ones first */
      150 
      151 	do while (lcte.timer_offset ^= ""b);		/* Keep flushing from the front of the queue */
      152 	     timer_ptr = pointer (ttybp, lcte.timer_offset);
      153 	     call unthread_timer_block ();
      154 	     call free_timer_block ();
      155 	end;
      156 
      157 	call finished (tty_buf.timer_call_time, tty_buf.timer_reset_calls);
      158 						/* There. That was easy, wasn't it? */
      159 
      160 	call unlock_timer_lock ();
      161 
      162 	goto MAIN_RETURN;				/* Depart */
      163 
      164 mcs_timer$verify_lock:
      165      entry ();
      166 
      167 	ttybp = addr (tty_buf$);			/* We can't call setup_global, since this entry doesn't */
      168 						/* follow the usual conventions about locking */
      169 	if (tty_buf.timer_lock = pds$processid)
      170 	then call syserr (CRASH, "mcs_timer: Crawlout with MCS timer lock locked.");
      171 
      172 	return;					/* not likely, but better than falling through */
      173 
      174 /* This is called by mcs_timer_daemon to do the work */
      175 
      176 mcs_timer$poll:
      177      entry () returns (fixed bin (71));
      178 
      179 	call setup_global ();
      180 
      181 POLLING_LOOP:
      182 	if tty_buf.next_timer_offset = ""b then do;	/* No more left */
      183 	     call finished (tty_buf.timer_polling_time, tty_buf.timer_poll_calls);
      184 	     call unlock_timer_lock ();
      185 	     return (0);
      186 	     end;
      187 
      188 	timer_ptr = pointer (ttybp, tty_buf.next_timer_offset);
      189 						/* Find the first one to deliver */
      190 	time = timer.time;				/* Copy data from the timer */
      191 	timer_id = timer.data;			/* since we are about to free it */
      192 	devx = timer.devx;
      193 	subchan_idx = timer.subchan_idx;
      194 
      195 	if (time > clock ()) then do;			/* No more left */
      196 	     call finished (tty_buf.timer_polling_time, tty_buf.timer_poll_calls);
      197 	     call unlock_timer_lock ();
      198 	     return (time);
      199 	     end;
      200 
      201 	call unthread_timer_block ();
      202 
      203 	call free_timer_block ();
      204 
      205 	timer_info.id = timer_id;
      206 	timer_info.subchan_idx = subchan_idx;
      207 
      208 	call tty_lock$lock_channel_int (devx, TIMER, unspec (timer_info), channel_locked);
      209 	if channel_locked then do;
      210 	     call unlock_timer_lock ();
      211 	     call channel_manager$queued_interrupt (devx, TIMER, unspec (timer_info));
      212 	     call tty_lock$unlock_channel_int (devx);
      213 	     call lock_timer_lock ();
      214 	     end;
      215 
      216 	goto POLLING_LOOP;
      217 
      218 locate_timer:
      219      procedure ();
      220 
      221 /* This procedure finds the requested timer for a channel, given the timer ID,
      222*   and sets the global variables to indicate its whereabouts. */
      223 
      224 	timer_found = tty_lock$check_for_interrupt (devx, TIMER, unspec (timer_info));
      225 	if timer_found then do;			/* There's one waiting for you when you get home */
      226 	     timer_ptr = null ();			/* for good measure */
      227 	     timer_was_queued = "1"b;			/* indicate where found */
      228 	     return;
      229 	     end;
      230 
      231 	timer_was_queued = "0"b;
      232 	timer_found = "1"b;
      233 
      234 	do timer_ptr = pointer (ttybp, lcte.timer_offset) repeat (pointer (ttybp, timer.next_for_lcte))
      235 	     while (rel (timer_ptr) ^= ""b);
      236 
      237 	     if (timer.data = timer_id)
      238 	     then if (timer.subchan_idx = subchan_idx) then return;
      239 						/* Jackpot */
      240 
      241 	end;
      242 
      243 	timer_found = "0"b;
      244 	timer_ptr = null ();			/* Again, for good measure */
      245 
      246 	return;
      247      end locate_timer;
      248 
      249 allocate_timer_block:
      250      procedure ();
      251 
      252 /* Procedure to get space for a timer block, and abort if it can't */
      253 
      254 	call tty_space_man$get_space (size (timer), timer_ptr);
      255 	if (timer_ptr = null ()) then call timer_error ("Cannot get space to set");
      256 
      257 	return;
      258      end allocate_timer_block;
      259 
      260 
      261 
      262 free_timer_block:
      263      procedure ();
      264 
      265 /* Procedure to return space used by a timer block */
      266 
      267 	call tty_space_man$free_space (size (timer), timer_ptr);
      268 
      269 	return;
      270      end free_timer_block;
      271 
      272 
      273 
      274 fill_timer_block:
      275      procedure ();
      276 
      277 /* Procedure to fill in a timer block from the global variables */
      278 
      279 	unspec (timer) = ""b;
      280 	timer.devx = devx;
      281 	timer.subchan_idx = subchan_idx;
      282 	timer.data = timer_id;
      283 	timer.time = time;
      284 
      285 	return;
      286      end fill_timer_block;
      287 
      288 thread_timer_block:
      289      procedure ();
      290 
      291 /* Procedure to thread in the current timer block onto the global timer queue and the queue for the lcte */
      292 /* Also updates the global variables in tty_buf */
      293 
      294 declare  soonest_timer_ptr pointer;
      295 declare  next_timer_ptr pointer;
      296 declare  prev_timer_ptr pointer;
      297 declare  found_it bit (1) aligned;
      298 
      299 
      300 	lctep = addr (lct.lcte_array (timer.devx));	/* Who this one belongs to */
      301 
      302 	if (tty_buf.next_timer_offset ^= ""b) then do;	/* Set soonest_timer_ptr to mean we need to update */
      303 	     soonest_timer_ptr = pointer (ttybp, tty_buf.next_timer_offset);
      304 
      305 	     if (soonest_timer_ptr -> timer.time >= timer.time)
      306 	     then soonest_timer_ptr = timer_ptr;	/* New one is soonest in the list */
      307 	     else soonest_timer_ptr = null ();		/* Otherwise, leave it alone */
      308 	     end;
      309 	else soonest_timer_ptr = timer_ptr;		/* There were none before, so this must be it */
      310 
      311 	prev_timer_ptr = pointer (ttybp, 0);		/* Prepare to rethread */
      312 	next_timer_ptr = pointer (ttybp, tty_buf.next_timer_offset);
      313 
      314 	found_it = "0"b;
      315 	do while ((rel (next_timer_ptr) ^= ""b) & (^found_it));
      316 						/* Look for a place to thread it in */
      317 	     if (next_timer_ptr -> timer.time > timer.time)
      318 	     then found_it = "1"b;
      319 	     else do;
      320 		prev_timer_ptr = next_timer_ptr;
      321 		next_timer_ptr = pointer (ttybp, next_timer_ptr -> timer.next_timer);
      322 		end;
      323 	end;
      324 
      325 	if rel (prev_timer_ptr) ^= ""b then prev_timer_ptr -> timer.next_timer = rel (timer_ptr);
      326 						/* Splice it in, if we can */
      327 	if rel (next_timer_ptr) ^= ""b then next_timer_ptr -> timer.prev_timer = rel (timer_ptr);
      328 
      329 	timer.next_timer = rel (next_timer_ptr);
      330 	timer.prev_timer = rel (prev_timer_ptr);
      331 
      332 	next_timer_ptr = pointer (ttybp, lcte.timer_offset);
      333 
      334 	timer.prev_for_lcte = ""b;			/* Thread in at the beginning of the LCTE list */
      335 	timer.next_for_lcte = rel (next_timer_ptr);
      336 
      337 	if (rel (next_timer_ptr) ^= ""b) then next_timer_ptr -> timer.prev_for_lcte = rel (timer_ptr);
      338 
      339 	lcte.timer_offset = rel (timer_ptr);
      340 
      341 	if (soonest_timer_ptr ^= null ()) then do;	/* Must update "next time" */
      342 	     tty_buf.next_timer_offset = rel (soonest_timer_ptr);
      343 	     call pxss$unique_ring_0_wakeup (tty_buf.timer_process, tty_buf.timer_ev_chn, 0, (0));
      344 	     end;
      345 
      346 	tty_buf.timer_count = tty_buf.timer_count + 1;
      347 
      348 	return;
      349      end thread_timer_block;
      350 
      351 unthread_timer_block:
      352      procedure ();
      353 
      354 /* Procedure to unthread the current timer block from the global timer queue and the lcte queue */
      355 /* Also updates the global variables in tty_buf, changing the next timer info if necessary */
      356 
      357 declare  soonest_timer_ptr pointer;			/* For updating tty_buf */
      358 declare  next_timer_ptr pointer;
      359 declare  prev_timer_ptr pointer;
      360 
      361 
      362 	prev_timer_ptr = pointer (ttybp, timer.prev_timer);
      363 						/* First, unthread it from the global list */
      364 	next_timer_ptr = pointer (ttybp, timer.next_timer);
      365 
      366 	if (rel (timer_ptr) = tty_buf.next_timer_offset)
      367 	then soonest_timer_ptr = next_timer_ptr;	/* If we're removing the first one, update */
      368 	else soonest_timer_ptr = null ();		/* If not skip this step */
      369 
      370 	if (timer.next_timer ^= ""b) then next_timer_ptr -> timer.prev_timer = timer.prev_timer;
      371 
      372 	if (timer.prev_timer ^= ""b) then prev_timer_ptr -> timer.next_timer = timer.next_timer;
      373 
      374 	tty_buf.timer_count = tty_buf.timer_count - 1;
      375 
      376 	if soonest_timer_ptr ^= null () then do;	/* This means the one we unthreaded was the first */
      377 	     tty_buf.next_timer_offset = rel (soonest_timer_ptr);
      378 	     end;					/* "That's longer than anybody's ever been gone before!" */
      379 
      380 	lctep = addr (lct.lcte_array (timer.devx));	/* Who this one belongs to */
      381 
      382 	prev_timer_ptr = pointer (ttybp, timer.prev_for_lcte);
      383 						/* Next, unthread it from the list for the LCTE */
      384 	next_timer_ptr = pointer (ttybp, timer.next_for_lcte);
      385 
      386 	if (timer.next_for_lcte ^= ""b) then next_timer_ptr -> timer.prev_for_lcte = timer.prev_for_lcte;
      387 
      388 	if (timer.prev_for_lcte ^= ""b) then prev_timer_ptr -> timer.next_for_lcte = timer.next_for_lcte;
      389 
      390 	if (rel (timer_ptr) = lcte.timer_offset) then lcte.timer_offset = rel (next_timer_ptr);
      391 
      392 	return;
      393      end unthread_timer_block;
      394 
      395 setup_global:
      396      procedure ();
      397 
      398 /* Set up for any kind of mcs_timer operation. Sets global variables, wires and masks,
      399*   and locks the timer lock */
      400 
      401 	ttybp = addr (tty_buf$);
      402 	lctp = tty_buf.lct_ptr;
      403 	lctep = null ();
      404 
      405 	start_time = clock ();
      406 
      407 	call lock_timer_lock ();
      408 
      409 	return;
      410      end setup_global;
      411 
      412 
      413 
      414 setup_channel:
      415      procedure ();
      416 
      417 /* This procedure performs additional setup up for an operation on a particular
      418*   channel, and checks that it is locked by the correct process. */
      419 
      420 	call setup_global ();
      421 
      422 	lctep = addr (lct.lcte_array (devx));
      423 
      424 	if (lcte.lock ^= pds$processid)
      425 	then call syserr (CRASH, "mcs_timer: Channel not locked by this process. Devx = ^d.", devx);
      426 
      427 	return;
      428      end setup_channel;
      429 
      430 
      431 
      432 
      433 get_id_and_subchan:
      434      procedure ();
      435 
      436 	timer_id = P_timer_id;
      437 	subchan_idx = P_subchan_idx;
      438 
      439 	timer_info.id = timer_id;
      440 	timer_info.subchan_idx = subchan_idx;
      441 
      442 	return;
      443      end get_id_and_subchan;
      444 
      445 timer_error:
      446      procedure (P_message);
      447 
      448 declare  P_message char (*) parameter;
      449 
      450 
      451 	call syserr (tty_buf.recoverable_error_severity, "mcs_timer: ^a timer ^w for devx(subchan) ^d(^d)", P_message,
      452 	     timer_id, devx, subchan_idx);
      453 
      454 	call finished ((0), tty_buf.timer_error_calls);	/* Don't meter calls that don't complete */
      455 
      456 	call unlock_timer_lock ();
      457 
      458 	goto MAIN_RETURN;				/* Depart */
      459 
      460      end timer_error;
      461 
      462 
      463 
      464 finished:
      465      procedure (P_time_meter, P_count);
      466 
      467 declare  P_time_meter fixed bin (71) parameter;
      468 declare  P_count fixed bin (35) parameter;
      469 
      470 
      471 	P_time_meter = P_time_meter + (clock () - start_time);
      472 	if (P_count < 34359738367)
      473 	then					/* Avoid overflows. That number is 2**35-1 */
      474 	     P_count = P_count + 1;
      475 	return;
      476      end finished;
      477 
      478 lock_timer_lock:
      479      procedure ();
      480 
      481 declare  spin_start_time fixed bin (71);
      482 
      483 
      484 	if (tty_buf.timer_lock = pds$processid)
      485 	then call syserr (CRASH, "mcs_timer: Timer lock already locked to this process.");
      486 
      487 	call privileged_mode_ut$wire_and_mask (wire_mask, wire_ptr);
      488 
      489 	if ^(stacq (tty_buf.timer_lock, pds$processid, ""b)) then do;
      490 
      491 	     spin_start_time = clock ();		/* Didn't lock at first attempt */
      492 	     tty_buf.timer_lock_wait_count = tty_buf.timer_lock_wait_count + 1;
      493 
      494 	     do while (^stacq (tty_buf.timer_lock, pds$processid, ""b));
      495 	     end;
      496 
      497 	     tty_buf.timer_lock_wait_time = tty_buf.timer_lock_wait_time + (clock () - spin_start_time);
      498 	     end;
      499 
      500 	tty_buf.timer_lock_count = tty_buf.timer_lock_count + 1;
      501 
      502 	return;
      503      end lock_timer_lock;
      504 
      505 
      506 
      507 unlock_timer_lock:
      508      procedure ();
      509 
      510 	if ^(stacq (tty_buf.timer_lock, "0"b, pds$processid))
      511 	then call syserr (CRASH, "mcs_timer: Timer lock not locked by this process.");
      512 
      513 	call privileged_mode_ut$unwire_unmask (wire_mask, wire_ptr);
      514 
      515 	return;
      516      end unlock_timer_lock;
      517 
  1     1 /* BEGIN INCLUDE FILE ... mcs_timer_data.incl.pl1 ... W. Olin Sibert ... 24 March 1982 */
  1     2 
  1     3 declare	timer_ptr pointer;
  1     4 
  1     5 declare 1 timer		aligned based (timer_ptr),
  1     6 	2 next_timer	bit (18) unaligned,
  1     7 	2 prev_timer	bit (18) unaligned,
  1     8 
  1     9 	2 next_for_lcte	bit (18) unaligned,
  1    10 	2 prev_for_lcte	bit (18) unaligned,
  1    11 
  1    12 	2 devx		fixed bin (17) unaligned,
  1    13 	2 subchan_idx	fixed bin (17) unaligned,
  1    14 
  1    15 	2 data		bit (36) aligned,
  1    16 	2 time		fixed bin (71);
  1    17 
  1    18 /* END INCLUDE FILE ... mcs_timer_data.incl.pl1 */
      518 
  2     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      519 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      520 
  5     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
  5     2 
  5     3 /* Defines constants and structures  used by MCS interrupt handlers */
  5     4 
  5     5 /* Created 08/21/78 by Robert Coren */
  5     6 /* Echo negotiation types added sometime by Bernie Greenberg */
  5     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
  5     8 /* MASKED type added June 23, 1982, by Robert Coren */
  5     9 
  5    10 dcl  DIALUP fixed bin int static options (constant) init (1);
  5    11 dcl  HANGUP fixed bin int static options (constant) init (2);
  5    12 dcl  CRASH fixed bin int static options (constant) init (3);
  5    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
  5    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
  5    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
  5    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
  5    17 dcl  QUIT fixed bin int static options (constant) init (8);
  5    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
  5    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
  5    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
  5    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
  5    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
  5    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
  5    24 dcl  TIMER fixed bin int static options (constant) init (15);
  5    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
  5    26 dcl  MASKED fixed bin int static options (constant) init (17);
  5    27 
  5    28 dcl  interrupt_info bit (72) aligned;
  5    29 
  5    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
  5    31     2 line_type fixed bin (9) unal uns,
  5    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
  5    33     2 baud_rate fixed bin (18) unal uns,
  5    34     2 max_buf_size fixed bin (9) unal uns,
  5    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
  5    36     2 pad bit (26) unal;
  5    37 
  5    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
  5    39     2 input_chain unaligned,
  5    40       3 chain_head bit (18) unaligned,
  5    41       3 chain_tail bit (18) unaligned,
  5    42     2 input_count fixed bin (18) unal uns,
  5    43     2 flags unaligned,
  5    44       3 break_char bit (1),				/* data contains a break character */
  5    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
  5    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
  5    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
  5    48       3 pad bit (14);
  5    49 
  5    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
  5    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
  5    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
  5    53 
  5    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
      521 
  6     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  6     2 
  6     3 /* This include file declares all the entries in tty_space_man and defines the constants
  6     4**  to be used for the flags argument
  6     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  6     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  6     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  6     8**/
  6     9 
  6    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  6    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  6    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  6    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  6    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  6    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  6    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  6    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  6    18 dcl  tty_space_man$needs_space entry (fixed bin);
  6    19 
  6    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  6    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  6    22 
  6    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      522 
      523 
      524 /* BEGIN MESSAGE DOCUMENTATION
      525*
      526*   Message:
      527*   mcs_timer: Timer lock already locked to this process.
      528*
      529*   S:	$crash
      530*
      531*   T:	$run
      532*
      533*   M:	A process that had the MCS timer lock locked tried to lock it again.
      534*
      535*   A:	$inform
      536*
      537*
      538*   Message:
      539*   mcs_timer: Timer lock not locked by this process.
      540*
      541*   S:	$crash
      542*
      543*   T:	$run
      544*
      545*   M:	A process called to unlock the MCS timer lock, but did not have it locked.
      546*
      547*   A:	$inform
      548*
      549*
      550*   Message:
      551*   mcs_timer: Channel not locked by this process. Devx = DDDD.
      552*
      553*   S:	$crash
      554*
      555*   T:	$run
      556*
      557*   M:	A process called to perform an MCS timer operation, but the channel it
      558*   specified (devx DDDD) was not locked by the calling process.
      559*   by the calling process.
      560*
      561*   A:	$inform
      562*
      563*
      564*   Message:
      565*   mcs_timer: Timer not found. Cannot OOOOO timer NNN for devx(subchan) DDD(SSS).
      566*
      567*   S:	$log
      568*
      569*   T:	$run
      570*
      571*   M:	An attempt was made to perform operation OOOOO (reset or change) on
      572*   an MCS timer when no timer or queued timer interrupt with the specified ID
      573*   could be found for the requesting channel. The call is ignored.
      574*
      575*   A:	$inform
      576*
      577*
      578*   Message:
      579*   mcs_timer: Duplicate timer ID. Cannot set timer NNN for devx(subchan) DDD(SSS).
      580*
      581*   S:	$log
      582*
      583*   T:	$run
      584*
      585*   M:	An attempt was made to set an MCS timer with the specified timer ID,
      586*   but the channel already had an outstanding timer or queued timer interrupt
      587*   with that ID. The call is ignored.
      588*
      589*   A:	$inform
      590*
      591*
      592*   Message:
      593*   mcs_timer: Cannot get space to set timer NNN for devx(subchan) DDD(SSS).
      594*
      595*   S:	$log
      596*
      597*   T:	$run
      598*
      599*   M:	An attempt was made to set an MCS timer with the specified timer ID,
      600*   but it was not possible to allocate the necessary space in tty_buf to hold
      601*   timer data block. The call is ignored.
      602*
      603*   A:	$inform
      604*
      605*
      606*   END MESSAGE DOCUMENTATION */
      607 
      608      end mcs_timer;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.4  mcs_timer.pl1                     >special_ldd>install>MR12.3-1114>mcs_timer.pl1
518          1    11/08/82  1005.8  mcs_timer_data.incl.pl1           >ldd>include>mcs_timer_data.incl.pl1
519          2    01/06/85  1422.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
2-152        3    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
520          4    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
521          5    10/20/82  0938.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
522          6    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000014 constant        fixed bin(17,0)          initial dcl 5-12 set ref 169* 424* 484* 510*
P_count                                parameter       fixed bin(35,0)          dcl 468 set ref 464 472 472* 472
P_devx                                 parameter       fixed bin(17,0)          dcl 28 ref 63 66 87 90 117 120 142 145
P_message                              parameter       char                     packed unaligned dcl 448 set ref 445 451*
P_subchan_idx                          parameter       fixed bin(17,0)          dcl 29 ref 63 87 117 437
P_time                                 parameter       fixed bin(71,0)          dcl 30 ref 63 67 87 91
P_time_meter                           parameter       fixed bin(71,0)          dcl 467 set ref 464 471* 471
P_timer_id                             parameter       bit(36)                  dcl 31 ref 63 87 117 436
TIMER                           000000 constant        fixed bin(17,0)          initial dcl 5-24 set ref 101* 129* 148* 208* 211*
                                                                                  224*
addr                                                   builtin function         dcl 59 ref 167 300 380 401 422
channel_locked                  000116 automatic       bit(1)                   dcl 44 set ref 208* 209
channel_manager$queued_interrupt
                                000012 constant        entry                    external dcl 48 ref 211
clock                                                  builtin function         dcl 59 ref 195 405 471 491 497
data                      3            based           bit(36)                  level 2 dcl 1-5 set ref 191 237 282*
devx                            000100 automatic       fixed bin(17,0)          dcl 33 in procedure "mcs_timer" set ref 66* 90* 101*
                                                                                  120* 129* 145* 148* 192* 208* 211* 212* 224* 280
                                                                                  422 424* 451*
devx                      2            based           fixed bin(17,0)          level 2 in structure "timer" packed packed unaligned
                                                                                  dcl 1-5 in procedure "mcs_timer" set ref 192 280*
                                                                                  300 380
found_it                        000202 automatic       bit(1)                   dcl 297 set ref 314* 315 317*
hc_fast_lock                           based           structure                level 1 dcl 3-10
id                              000130 automatic       bit(36)                  level 2 dcl 5-50 set ref 205* 439*
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "mcs_timer"
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "mcs_timer"
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcs_timer"
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 402
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 300 380 422
lctep                           000126 automatic       pointer                  dcl 4-8 set ref 151 152 234 300* 332 339 380* 390
                                                                                  390 403* 422* 424
lctp                            000124 automatic       pointer                  dcl 4-7 set ref 300 380 402* 422
lock                                   based           bit(36)                  level 2 dcl 4-20 ref 424
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "mcs_timer"
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "mcs_timer"
next_for_lcte             1            based           bit(18)                  level 2 packed packed unaligned dcl 1-5 set ref 241
                                                                                  335* 384 386 388* 388
next_timer                             based           bit(18)                  level 2 packed packed unaligned dcl 1-5 set ref 321
                                                                                  325* 329* 364 370 372* 372
next_timer_offset       105            based           bit(18)                  level 2 dcl 2-35 set ref 181 188 302 303 312 342*
                                                                                  366 377*
next_timer_ptr                  000176 automatic       pointer                  dcl 295 in procedure "thread_timer_block" set ref
                                                                                  312* 315 317 320 321* 321 327 327 329 332* 335 337
                                                                                  337
next_timer_ptr                  000214 automatic       pointer                  dcl 358 in procedure "unthread_timer_block" set ref
                                                                                  364* 366 370 384* 386 390
null                                                   builtin function         dcl 59 ref 226 244 255 307 341 368 376 403
pds$processid                   000010 external static bit(36)                  dcl 46 ref 169 424 484 489 494 510
pointer                                                builtin function         dcl 59 ref 152 188 234 241 303 311 312 321 332 362
                                                                                  364 382 384
prev_for_lcte             1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-5 set ref 334*
                                                                                  337* 382 386* 386 388
prev_timer                0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 1-5 set ref 327*
                                                                                  330* 362 370* 370 372
prev_timer_ptr                  000200 automatic       pointer                  dcl 296 in procedure "thread_timer_block" set ref
                                                                                  311* 320* 325 325 330
prev_timer_ptr                  000216 automatic       pointer                  dcl 359 in procedure "unthread_timer_block" set ref
                                                                                  362* 372 382* 388
privileged_mode_ut$unwire_unmask
                                000016 constant        entry                    external dcl 50 ref 513
privileged_mode_ut$wire_and_mask
                                000014 constant        entry                    external dcl 49 ref 487
pxss$unique_ring_0_wakeup       000020 constant        entry                    external dcl 51 ref 343
recoverable_error_severity
                        103            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 451*
rel                                                    builtin function         dcl 59 ref 234 315 325 325 327 327 329 330 335 337
                                                                                  337 339 342 366 377 390 390
size                                                   builtin function         dcl 59 ref 254 254 267 267
soonest_timer_ptr               000174 automatic       pointer                  dcl 294 in procedure "thread_timer_block" set ref
                                                                                  303* 305 305* 307* 309* 341 342
soonest_timer_ptr               000212 automatic       pointer                  dcl 357 in procedure "unthread_timer_block" set ref
                                                                                  366* 368* 376 377
spin_start_time                 000264 automatic       fixed bin(71,0)          dcl 481 set ref 491* 497
stacq                                                  builtin function         dcl 59 ref 489 494 510
start_time                      000112 automatic       fixed bin(71,0)          dcl 40 set ref 405* 471
subchan_idx               1     000130 automatic       fixed bin(17,0)          level 2 in structure "timer_info" dcl 5-50
                                                                                  in procedure "mcs_timer" set ref 206* 440*
subchan_idx                     000101 automatic       fixed bin(17,0)          dcl 34 in procedure "mcs_timer" set ref 193* 206 237
                                                                                  281 437* 440 451*
subchan_idx               2(18)        based           fixed bin(17,0)          level 2 in structure "timer" packed packed unaligned
                                                                                  dcl 1-5 in procedure "mcs_timer" set ref 193 237
                                                                                  281*
syserr                          000022 constant        entry                    external dcl 52 ref 169 424 451 484 510
time                            000102 automatic       fixed bin(71,0)          dcl 35 in procedure "mcs_timer" set ref 67* 91* 190*
                                                                                  195 198 283
time                      4            based           fixed bin(71,0)          level 2 in structure "timer" dcl 1-5 in procedure
                                                                                  "mcs_timer" set ref 190 283* 305 305 317 317
timer                                  based           structure                level 1 dcl 1-5 set ref 254 254 267 267 279*
timer_call_time         116            based           fixed bin(71,0)          level 2 dcl 2-35 set ref 82* 111* 136* 157*
timer_change_calls      124            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 111*
timer_count             106            based           fixed bin(17,0)          level 2 dcl 2-35 set ref 346* 346 374* 374
timer_error_calls       126            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 454*
timer_ev_chn            110            based           fixed bin(71,0)          level 2 dcl 2-35 set ref 343*
timer_found                     000114 automatic       bit(1)                   dcl 42 set ref 74 98 127 224* 225 232* 243*
timer_id                        000104 automatic       bit(36)                  dcl 36 set ref 191* 205 237 282 436* 439 451*
timer_info                      000130 automatic       structure                level 1 dcl 5-50 set ref 101 101 129 129 208 208 211
                                                                                  211 224 224
timer_lock              104            based           bit(36)                  level 2 dcl 2-35 ref 169 484 489 494 510
timer_lock_count        114            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 500* 500
timer_lock_wait_count
                        115            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 492* 492
timer_lock_wait_time    112            based           fixed bin(71,0)          level 2 dcl 2-35 set ref 497* 497
timer_offset             34            based           bit(18)                  level 2 dcl 4-20 set ref 151 152 234 332 339* 390
                                                                                  390*
timer_poll_calls        125            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 183* 196*
timer_polling_time      120            based           fixed bin(71,0)          level 2 dcl 2-35 set ref 183* 196*
timer_process           107            based           bit(36)                  level 2 dcl 2-35 set ref 343*
timer_ptr                       000120 automatic       pointer                  dcl 1-3 set ref 152* 188* 190 191 192 193 226* 234*
                                                                                  234* 237 237* 241 244* 254 254 254* 255 267 267
                                                                                  267* 279 280 281 282 283 300 305 305 309 317 325
                                                                                  327 329 330 334 335 337 339 362 364 366 370 370
                                                                                  372 372 380 382 384 386 386 388 388 390
timer_reset_calls       123            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 136* 157*
timer_set_calls         122            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 82*
timer_was_queued                000115 automatic       bit(1)                   dcl 43 set ref 100 129 227* 231*
tty_buf                                based           structure                level 1 dcl 2-35
tty_buf$                        000036 external static fixed bin(17,0)          dcl 2-19 set ref 167 401
tty_lock$check_for_interrupt    000024 constant        entry                    external dcl 53 ref 224
tty_lock$dequeue_all_interrupts 000030 constant        entry                    external dcl 55 ref 148
tty_lock$dequeue_one_interrupt  000026 constant        entry                    external dcl 54 ref 101 129
tty_lock$lock_channel_int       000032 constant        entry                    external dcl 56 ref 208
tty_lock$unlock_channel_int     000034 constant        entry                    external dcl 57 ref 212
tty_space_man$free_space        000042 constant        entry                    external dcl 6-12 ref 267
tty_space_man$get_space         000040 constant        entry                    external dcl 6-10 ref 254
ttybp                           000122 automatic       pointer                  dcl 2-19 set ref 82 82 111 111 136 136 152 157 157
                                                                                  167* 169 181 183 183 188 188 196 196 234 241 302
                                                                                  303 303 311 312 312 321 332 342 343 343 346 346
                                                                                  362 364 366 374 374 377 382 384 401* 402 451 454
                                                                                  484 489 492 492 494 497 497 500 500 510
unspec                                                 builtin function         dcl 59 set ref 101 101 129 129 208 208 211 211 224
                                                                                  224 279*
wire_mask                       000106 automatic       fixed bin(71,0)          dcl 38 set ref 487* 513*
wire_ptr                        000110 automatic       pointer                  dcl 39 set ref 487* 513*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_INPUT                           internal static fixed bin(17,0)          initial dcl 5-15
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 5-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 5-23
DIALUP                                 internal static fixed bin(17,0)          initial dcl 5-10
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 5-19
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
HANGUP                                 internal static fixed bin(17,0)          initial dcl 5-11
INPUT                                  internal static bit(1)                   initial packed unaligned dcl 6-20
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 5-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 5-16
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 5-18
MASKED                                 internal static fixed bin(17,0)          initial dcl 5-26
OUTPUT                                 internal static bit(1)                   initial packed unaligned dcl 6-21
QUIT                                   internal static fixed bin(17,0)          initial dcl 5-17
SEND_OUTPUT                            internal static fixed bin(17,0)          initial dcl 5-13
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 5-21
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 5-25
WRU_TIMEOUT                            internal static fixed bin(17,0)          initial dcl 5-20
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
bsizec                                 internal static fixed bin(17,0)          initial dcl 2-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
dialup_info                            automatic       structure                level 1 dcl 5-30
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
interrupt_info                         automatic       bit(72)                  dcl 5-28
lcnt                                   based           structure                level 1 dcl 4-65
lcntp                                  automatic       pointer                  dcl 4-63
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
lock_ptr                               automatic       pointer                  dcl 3-9
output_bpart                           internal static fixed bin(18,0)          initial dcl 2-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
rtx_info                               automatic       structure                level 1 dcl 5-38
saved_meters                           based           structure                level 1 dcl 4-68
tty_ev                                 internal static fixed bin(17,0)          initial dcl 2-19
tty_space_man$free_buffer       000000 constant        entry                    external dcl 6-14
tty_space_man$free_chain        000000 constant        entry                    external dcl 6-16
tty_space_man$get_buffer        000000 constant        entry                    external dcl 6-13
tty_space_man$get_chain         000000 constant        entry                    external dcl 6-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 6-11
tty_space_man$needs_space       000000 constant        entry                    external dcl 6-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 6-17

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000204 constant        label                    dcl 12 set ref 85 115 140 162 458
POLLING_LOOP                    000610 constant        label                    dcl 181 ref 216
allocate_timer_block            001050 constant        entry                    internal dcl 249 ref 76 103
fill_timer_block                001117 constant        entry                    internal dcl 274 ref 78 107
finished                        001601 constant        entry                    internal dcl 464 ref 82 111 136 157 183 196 454
free_timer_block                001102 constant        entry                    internal dcl 262 ref 133 154 203
get_id_and_subchan              001501 constant        entry                    internal dcl 433 ref 68 92 121
locate_timer                    000762 constant        entry                    internal dcl 218 ref 72 96 125
lock_timer_lock                 001620 constant        entry                    internal dcl 478 ref 213 407
mcs_timer                       000175 constant        entry                    external dcl 9
mcs_timer$change                000273 constant        entry                    external dcl 87
mcs_timer$poll                  000601 constant        entry                    external dcl 176
mcs_timer$reset                 000371 constant        entry                    external dcl 117
mcs_timer$reset_all             000462 constant        entry                    external dcl 142
mcs_timer$set                   000220 constant        entry                    external dcl 63
mcs_timer$verify_lock           000533 constant        entry                    external dcl 164
setup_channel                   001443 constant        entry                    internal dcl 414 ref 70 94 123 146
setup_global                    001427 constant        entry                    internal dcl 395 ref 179 420
thread_timer_block              001136 constant        entry                    internal dcl 288 ref 80 109
timer_error                     001512 constant        entry                    internal dcl 445 ref 74 98 127 255
unlock_timer_lock               001716 constant        entry                    internal dcl 507 ref 84 113 138 160 184 197 210 456
unthread_timer_block            001315 constant        entry                    internal dcl 351 ref 105 132 153 201

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2334        2400    2002        2344
Length      2736    2002        44         321     331           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mcs_timer                           386 external procedure  is an external procedure.  
locate_timer                            internal procedure  shares stack frame of external procedure mcs_timer.  
allocate_timer_block                    internal procedure  shares stack frame of external procedure mcs_timer.  
free_timer_block                        internal procedure  shares stack frame of external procedure mcs_timer.  
fill_timer_block                        internal procedure  shares stack frame of external procedure mcs_timer.  
thread_timer_block                      internal procedure  shares stack frame of external procedure mcs_timer.  
unthread_timer_block                    internal procedure  shares stack frame of external procedure mcs_timer.  
setup_global                            internal procedure  shares stack frame of external procedure mcs_timer.  
setup_channel                           internal procedure  shares stack frame of external procedure mcs_timer.  
get_id_and_subchan                      internal procedure  shares stack frame of external procedure mcs_timer.  
timer_error                             internal procedure  shares stack frame of external procedure mcs_timer.  
finished                                internal procedure  shares stack frame of external procedure mcs_timer.  
lock_timer_lock                         internal procedure  shares stack frame of external procedure mcs_timer.  
unlock_timer_lock                       internal procedure  shares stack frame of external procedure mcs_timer.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mcs_timer                000100 devx                        mcs_timer
                         000101 subchan_idx                 mcs_timer
                         000102 time                        mcs_timer
                         000104 timer_id                    mcs_timer
                         000106 wire_mask                   mcs_timer
                         000110 wire_ptr                    mcs_timer
                         000112 start_time                  mcs_timer
                         000114 timer_found                 mcs_timer
                         000115 timer_was_queued            mcs_timer
                         000116 channel_locked              mcs_timer
                         000120 timer_ptr                   mcs_timer
                         000122 ttybp                       mcs_timer
                         000124 lctp                        mcs_timer
                         000126 lctep                       mcs_timer
                         000130 timer_info                  mcs_timer
                         000174 soonest_timer_ptr           thread_timer_block
                         000176 next_timer_ptr              thread_timer_block
                         000200 prev_timer_ptr              thread_timer_block
                         000202 found_it                    thread_timer_block
                         000212 soonest_timer_ptr           unthread_timer_block
                         000214 next_timer_ptr              unthread_timer_block
                         000216 prev_timer_ptr              unthread_timer_block
                         000264 spin_start_time             lock_timer_lock

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          signal_op           ext_entry           stacq_mac
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$queued_interrupt                            privileged_mode_ut$unwire_unmask
privileged_mode_ut$wire_and_mask                            pxss$unique_ring_0_wakeup     syserr
tty_lock$check_for_interrupt  tty_lock$dequeue_all_interrupts
tty_lock$dequeue_one_interrupt                              tty_lock$lock_channel_int     tty_lock$unlock_channel_int
tty_space_man$free_space      tty_space_man$get_space

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pds$processid                 tty_buf$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000174        12 000204        63 000213        66 000232        67 000235        68 000237        70 000240
     72 000241        74 000242        76 000253        78 000254        80 000255        82 000256        84 000267
     85 000270        87 000271        90 000305        91 000310        92 000312        94 000313        96 000314
     98 000315       100 000326       101 000330       103 000345       104 000346       105 000347       107 000350
    109 000351       111 000352       113 000363       115 000364       117 000365       120 000403       121 000406
    123 000407       125 000410       127 000411       129 000422       132 000442       133 000443       136 000444
    138 000455       140 000456       142 000457       145 000471       146 000474       148 000475       151 000506
    152 000511       153 000514       154 000515       155 000516       157 000517       160 000530       162 000531
    164 000532       167 000542       169 000545       172 000567       176 000576       179 000607       181 000610
    183 000613       184 000623       185 000624       188 000636       190 000641       191 000643       192 000645
    193 000650       195 000654       196 000657       197 000670       198 000671       201 000703       203 000704
    205 000705       206 000707       208 000711       209 000730       210 000733       211 000734       212 000751
    213 000760       216 000761       218 000762       224 000763       225 001002       226 001005       227 001007
    228 001011       231 001012       232 001013       234 001015       237 001024       241 001036       243 001044
    244 001045       246 001047       249 001050       254 001051       255 001064       257 001101       262 001102
    267 001103       269 001116       274 001117       279 001120       280 001124       281 001127       282 001131
    283 001133       285 001135       288 001136       300 001137       302 001146       303 001151       305 001154
    307 001161       308 001163       309 001164       311 001165       312 001167       314 001173       315 001174
    317 001201       320 001211       321 001212       323 001217       325 001220       327 001225       329 001233
    330 001236       332 001242       334 001247       335 001252       337 001254       339 001261       341 001263
    342 001267       343 001272       346 001312       348 001314       351 001315       362 001316       364 001323
    366 001331       368 001341       370 001343       372 001350       374 001355       376 001357       377 001363
    380 001365       382 001374       384 001401       386 001407       388 001413       390 001421       392 001426
    395 001427       401 001430       402 001433       403 001435       405 001437       407 001441       409 001442
    414 001443       420 001444       422 001445       424 001452       427 001500       433 001501       436 001502
    437 001504       439 001507       440 001510       442 001511       445 001512       451 001523       454 001564
    456 001577       458 001600       464 001601       471 001603       472 001607       475 001617       478 001620
    484 001621       487 001645       489 001656       491 001665       492 001667       494 001674       495 001703
    497 001704       500 001711       502 001715       507 001716       510 001717       513 001745       515 001756


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
