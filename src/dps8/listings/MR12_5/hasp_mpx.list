	COMPILATION LISTING OF SEGMENT hasp_mpx
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0940.9 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* HASP multiplexer:  This multiplexer processes most of the HASP RJE protocol in either host or workstation mode.
       14*   This multiplexer expects data from the user ring to be already compressed and converted to EBCDIC.
       15*   This procedure implements the non-privileged entries of the multiplexer; it may be invoked at interrupt time
       16*   and must be wired.
       17*   */
       18 
       19 /* Created:  October 1979 by G. Palter */
       20 /* Modified: 15 October 1980 by G. Palter to correct bug which can cause null pointer reference at interrupt time, to
       21*	      always accept input for configured devices, and to re-enable tracing code */
       22 /* Modified: 25 November 1980 by G. Palter to use channel_manager$interrupt_later */
       23 /* Modified: December 1980 by G. Palter to fix the "loopback bug" */
       24 /* Modified: 9 January 1981 by G. Palter to correct bug which causes a system crash when a block received out of sequence
       25*	     is to be ignored */
       26 /* Modified: 11 January 1981 by G. Palter to correct bug where detecting a partial output record would take precedence
       27*	      over detecting an output record which exceeds the maximum block size for the multiplexer */
       28 /* Modified: 30 March 1981 by G. Palter to trap duplicate loopback blocks (possibly permanently) */
       29 /* Modified: 2 April 1981 by G. Palter to properly handle space restrictions during input and loopback processing, to
       30*	      transmit a status block if necessary after a resetread, and to correct problems with the interface to
       31*	      tty_space_man$needs_space */
       32 /* Modified: 16 April 1981 by G. Palter to support rts_mode, to not set off the beeper when calling syserr, and to add
       33*	        message documentation */
       34 /* Modified: July 1981 by G. Palter to complete SIGNON record processing and implement multiplexer metering */
       35 /* Modified: 25 August 1981 by G. Palter to correct bugs in wraparound processing (formerlly called loopback) */
       36 /* Modified: 5 February 1982 by G. Palter to always acknowledge requests to send input to a configured device */
       37 /* Modified: 11 August 1982 by G. Palter to correct the bug in classify_record that would cause it to reference beyond the
       38*	      end of a buffer when called from move_record_to_output_block to classify the record just added when the
       39*	      previous record in the block completely filled a buffer */
       40 /* Modified: August 1982 by Robert Coren to handle "MASKED" interrupt */
       41 /* Modified: February 1984 by G. Palter as part of the correct implementation of the system wait-a-bit */
       42 /* Modified: August 1984 by G. Palter to fix HASP error #0013 -- hasp_mpx frees the individual buffers of a record when
       43*      the buffer's data is copied into the output block under construction.  If there isn't sufficient space in tty_buf to
       44*      grow the output block, hasp_mpx will abort writing the record and return to its caller (channel_manager$write) while
       45*      indicating that the record in question has not yet been written.  However, some of the buffers which comprised the
       46*      record may have been freed.  As a result, when space in tty_buf is available and the write operation is retried,
       47*      hasp_mpx will be asked to process the original buffers of the record which are now either on the free chain or in
       48*      use by another channel.  In either case, the system will eventually crash with the message
       49*	 tty_space_man:  Attempt to free space already freed */
       50 /* Modified: December 1984 by G. Palter to fix HASP error #0015 -- If the first buffer of an input block from the FNP
       51*      contains only a single character, hasp_mpx will either take a fault while on the PRDS or move 262143 characters of
       52*      tty_buf one halfword to the "left".  In either case, the system will crash */
       53 
       54 
       55 /* Missing features and further design issues to be resolved:
       56*
       57*   o Change input block processing to allow (1) blocks to be split across ACCEPT INPUT interrupts or calls to
       58*     channel_manager$read, and (2) multiple blocks to be returned by a single interrupt or read call.
       59*
       60*   o Timeout mechanism to wait for acknowldegement of RTS records?
       61*   */
       62 
       63 
       64 hasp_mpx:
       65      procedure ();
       66 
       67 	return;					/* not an entrypoint */
       68 
       69 
       70 /* Parameters */
       71 
       72 dcl  P_hmd_ptr pointer parameter;			/* -> multiplexer data for this channel */
       73 dcl  P_subchannel_idx fixed binary parameter;		/* index of specific sub-channel referenced by this call */
       74 dcl  P_code fixed binary (35) parameter;		/* status code */
       75 
       76 dcl  P_chain_ptr pointer parameter;			/* read, write:  chain of buffers */
       77 
       78 dcl  P_more_input bit (1) aligned parameter;		/* read:  set ON => more input for sub-channel is available */
       79 
       80 dcl  P_interrupt_type fixed binary parameter;		/* interrupt:  type of interrupt encountered */
       81 dcl  P_interrupt_data bit (72) aligned parameter;		/* interrupt:  data associated with this interrupt (if any) */
       82 
       83 dcl  P_order character (*) parameter;			/* control:  order to be executed */
       84 dcl  P_info_ptr pointer parameter;			/* control:  -> additional data for this control order */
       85 
       86 dcl  P_mclp pointer parameter;			/* check_modes, set_modes:  -> modes to check/set */
       87 
       88 dcl  P_modes character (*) parameter;			/* get_modes:  set to modes in effect for sub-channel */
       89 
       90 
       91 /* Local copies of parameters (not in include files) */
       92 
       93 dcl  subchannel_idx fixed binary;
       94 dcl  code fixed binary (35);
       95 
       96 dcl  chain_ptr pointer;
       97 
       98 dcl  interrupt_type fixed binary;
       99 dcl  interrupt_data bit (72) aligned;
      100 
      101 dcl  order character (32);
      102 dcl  info_ptr pointer;
      103 
      104 
      105 /* Remaining declarations */
      106 
      107 dcl  ttybp pointer;					/* -> tty_buf$ */
      108 
      109 dcl 1 based_block_header unaligned based like TEMPLATE_HASP_BLOCK_HEADER;
      110 dcl 1 based_block_trailer unaligned based like TEMPLATE_HASP_BLOCK_TRAILER;
      111 
      112 dcl 1 based_signon_block unaligned based like TEMPLATE_HASP_SIGNON_BLOCK;
      113 
      114 dcl 1 based_bad_bcb_block unaligned based like TEMPLATE_HASP_BAD_BCB_BLOCK;
      115 dcl 1 based_bad_bcb_record unaligned based like TEMPLATE_HASP_BAD_BCB_RECORD;
      116 
      117 dcl 1 based_sync_block unaligned based like TEMPLATE_HASP_SYNC_BLOCK;
      118 
      119 dcl 1 based_rts_record unaligned based like TEMPLATE_HASP_RTS_RECORD;
      120 dcl 1 based_rts_ack_record unaligned based like TEMPLATE_HASP_RTS_ACK_RECORD;
      121 
      122 dcl  needs_space bit (1) aligned;			/* ON => some processing required more space than available */
      123 
      124 dcl  partial_record bit (1) aligned;			/* ON => output processing terminated when an incomplete
      125*						   record was found in output chain; wakeup must be sent
      126*						   to user ring */
      127 
      128 dcl  long_record bit (1) aligned;			/* ON => output processing terminated when a record was found
      129*						   which is simply too large to ever fit into output block */
      130 
      131 dcl  previously_scanned_bufferp pointer;		/* used by scan_input_records:  -> buffer before last buffer 
      132*						   of a record */
      133 dcl  last_bufferp pointer;
      134 
      135 dcl 1 abort_info aligned based (info_ptr),		/* data structure for "abort" control order */
      136     2 resetwrite bit (1) unaligned,
      137     2 resetread bit (1) unaligned;
      138 
      139 dcl 1 write_status_info aligned based (info_ptr),		/* data structure for "write_status" control order */
      140     2 event_channel fixed binary (71),
      141     2 output_pending bit (1);
      142 
      143 dcl  get_device_type_info fixed binary based (info_ptr);	/* device type returned by "get_device_type" control order */
      144 
      145 dcl 1 sri aligned based (info_ptr) like signon_record_info;	/* data structure for "signon_record" order */
      146 
      147 dcl  idx fixed binary;
      148 
      149 dcl  NUL character (1) static options (constant) initial (" ");   /* EBCDIC NUL character ("000"b3) */
      150 dcl  DLE character (1) static options (constant) initial ("");   /* EBCDIC DLE character ("020"b3) */
      151 
      152 dcl (LOG_AND_PRINT	initial (0),			/* log message and print it on console */
      153      LOG_ONLY	initial (5))			/* log message or throw it away */
      154 	fixed binary static options (constant);
      155 
      156 dcl (et_action_not_performed, et_bad_mode, et_incorrect_device_type, et_invalid_read, et_invalid_state, et_invalid_write,
      157      et_long_record, et_noalloc, et_null_info_ptr, et_out_of_sequence, et_undefined_order_request,
      158      et_unimplemented_version)
      159 	fixed binary (35) static;			/* local copies so no page faults during interrupts, etc. */
      160 
      161 dcl  pds$process_id bit (36) aligned external;
      162 
      163 dcl  tty_buf$ bit (36) aligned external;		/* MCS data buffer segment */
      164 
      165 dcl (error_table_$action_not_performed, error_table_$bad_mode, error_table_$incorrect_device_type,
      166      error_table_$invalid_read, error_table_$invalid_state, error_table_$invalid_write, error_table_$long_record,
      167      error_table_$noalloc, error_table_$null_info_ptr, error_table_$out_of_sequence, error_table_$undefined_order_request,
      168      error_table_$unimplemented_version)
      169 	fixed binary (35) external;
      170 
      171 dcl  mcs_trace entry () options (variable);
      172 dcl  mcs_trace$buffer_chain entry (fixed binary, pointer);
      173 dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed binary (71), fixed binary (71), fixed binary (35));
      174 dcl  syserr entry () options (variable);
      175 dcl  wire_proc$wire_me entry ();
      176 
      177 dcl (addr, binary, clock, copy, currentsize, divide, hbound, index, lbound, length, min, mod, null, pointer, rel, size,
      178      string, substr, unspec)
      179 	builtin;
      180 
      181 /* Once per bootload initialization:  called from priv_hasp_mpx */
      182 
      183 system_initialize:
      184      entry ();
      185 
      186 	et_action_not_performed = error_table_$action_not_performed;
      187 	et_bad_mode = error_table_$bad_mode;
      188 	et_incorrect_device_type = error_table_$incorrect_device_type;
      189 	et_invalid_read = error_table_$invalid_read;
      190 	et_invalid_state = error_table_$invalid_state;
      191 	et_invalid_write = error_table_$invalid_write;
      192 	et_long_record = error_table_$long_record;
      193 	et_noalloc = error_table_$noalloc;
      194 	et_null_info_ptr = error_table_$null_info_ptr;
      195 	et_out_of_sequence = error_table_$out_of_sequence;
      196 	et_undefined_order_request = error_table_$undefined_order_request;
      197 	et_unimplemented_version = error_table_$unimplemented_version;
      198 
      199 	call wire_proc$wire_me ();			/* Doctor Memory */
      200 
      201 	return;
      202 
      203 
      204 
      205 /* Dialup a sub-channel:  called from priv_hasp_mpx */
      206 
      207 dialup:
      208      entry (P_hmd_ptr, P_subchannel_idx);
      209 
      210 	hmd_ptr = P_hmd_ptr;
      211 	subchannel_idx = P_subchannel_idx;
      212 	hste_ptr = addr (hmd.subchannels (subchannel_idx));
      213 
      214 	call signal_dialup ();
      215 
      216 	return;
      217 
      218 
      219 
      220 /* Crash the multiplexer:  called from priv_hasp_mpx */
      221 
      222 crash:
      223      entry (P_hmd_ptr);
      224 
      225 	ttybp = addr (tty_buf$);
      226 	hmd_ptr = P_hmd_ptr;
      227 
      228 	call crash_mpx ();
      229 
      230 	return;
      231 
      232 
      233 ERROR_RETURN:
      234 	P_code = code;
      235 	return;
      236 
      237 /* Read input from a specified sub-channel:  return one complete HASP record if available */
      238 
      239 read:
      240      entry (P_hmd_ptr, P_subchannel_idx, P_chain_ptr, P_more_input, P_code);
      241 
      242 	ttybp = addr (tty_buf$);
      243 	call setup_subchannel ();
      244 	P_chain_ptr = null ();			/* setup for error returns */
      245 	P_more_input = "0"b;
      246 	P_code = 0;				/* assume success */
      247 
      248 	if hste.state ^= HSTE_DIALED then		/* not if channel isn't dialed up */
      249 	     return;
      250 
      251 	if hste.direction = HSTE_OUTPUT_ONLY then do;	/* can't read from this device */
      252 	     P_code = et_invalid_read;
      253 	     return;
      254 	end;
      255 
      256 
      257 /* Check for available input */
      258 
      259 	if hmd.flags.input_available then		/* something is waiting for us */
      260 	     call process_available_input_blocks ();
      261 
      262 	if (hmd.input.first_bufferp ^= null ()) then	/* some records are waiting to be processed */
      263 	     call process_input_records ();
      264 
      265 	if hste.input.first_bufferp = null () then do;	/* still no input for this sub-channel */
      266 	     hste.requested_input = "1"b;		/* request an interrupt when something is available */
      267 	     go to RETURN_FROM_READ_CALL;
      268 	end;
      269 
      270 
      271 /* Input exits:  return the first record and permit more input if the number of records being held is small enough */
      272 
      273 	P_chain_ptr = hste.input.first_bufferp;
      274 
      275 	last_bufferp = null ();			/* until the last buffer of the record is found */
      276 	do blockp = hste.input.first_bufferp repeat (pointer (ttybp, buffer.next)) while (last_bufferp = null ());
      277 	     if (buffer.next = 0) | buffer.break then	/* last buffer or end-of-record */
      278 		last_bufferp = blockp;
      279 	end;
      280 
      281 	if (last_bufferp -> buffer.next = 0) then	/* no more input records after this one */
      282 	     hste.input.first_bufferp, hste.input.last_bufferp = null ();
      283 	else do;
      284 	     hste.input.first_bufferp = pointer (ttybp, last_bufferp -> buffer.next);
      285 	     last_bufferp -> buffer.next = 0;		/* break the chain */
      286 	end;
      287 
      288 	hste.input.n_records = hste.input.n_records - 1;
      289 
      290 	if hste.input.n_records < hmd.max_device_input_records then
      291 	     hmd.input_wabs (hste.device_wab_idx) = "1"b; /* OK to send more from foreign side now */
      292 
      293 
      294 /* Post-processing:  interrupt other channels waiting for input and also (if possible) send an output block if any local
      295*   state changes have occured */
      296 
      297 RETURN_FROM_READ_CALL:
      298 	call interrupt_subchannels_with_input ();
      299 
      300 	if (hmd.minor_state = HMD_REPROCESS) then
      301 	     call process_loopback_records ();		/* still have some untouched loopbacked records */
      302 	else call process_output_block ();
      303 
      304 	return;
      305 
      306 /* Write output to the specified sub-channel:  accept only completed HASP records */
      307 
      308 write:
      309      entry (P_hmd_ptr, P_subchannel_idx, P_chain_ptr, P_code);
      310 
      311 	ttybp = addr (tty_buf$);			/* for addressing buffers */
      312 	call setup_subchannel ();
      313 	chain_ptr = P_chain_ptr;
      314 
      315 	if hste.state ^= HSTE_DIALED then do;		/* this line not in use */
      316 	     call tty_space_man$free_chain (hste.devx, OUTPUT, chain_ptr);
      317 	     P_chain_ptr = null ();
      318 	     P_code = 0;
      319 	     return;
      320 	end;
      321 
      322 	if hste.direction = HSTE_INPUT_ONLY then do;	/* can't write to this subchannel */
      323 	     call tty_space_man$free_chain (hste.devx, OUTPUT, chain_ptr);
      324 	     P_chain_ptr = null ();			/* we threw the output away already */
      325 	     P_code = et_invalid_write;
      326 	     return;
      327 	end;
      328 
      329 	P_code = 0;				/* if this far, the call is guarenteed to "work" */
      330 
      331 
      332 /* Add this sub-channel to the output queue for a later SEND OUTPUT; it may be removed later */
      333 
      334 	call enqueue_subchannel_for_output ();
      335 
      336 
      337 /* Determine if output is acceptable at this time from this sub-channel */
      338 
      339 	if (hmd.minor_state ^= HMD_NORMAL) |		/* multiplexer isn't accepting output at the moment */
      340 	   hmd.suspend_all_output |			/* foreign side has requested to stop all output */
      341 	   ^hmd.output_wabs (hste.device_wab_idx) |	/* this device temporarily shut down */
      342 	   (hste.loopback.first_bufferp ^= null ()) then	/* some loopbacked output is waiting to be sent */
      343 	     go to RETURN_FROM_WRITE_CALL;		/* see if there's anything to send anyway and then return */
      344 
      345 
      346 /* Splice any previously saved output to the beginning of this chain */
      347 
      348 	if hste.output.first_bufferp ^= null () then do;
      349 	     hste.output.last_bufferp -> buffer.next = binary (rel (chain_ptr), 18, 0);
      350 	     P_chain_ptr,
      351 		chain_ptr = hste.output.first_bufferp;
      352 	     hste.output.first_bufferp, hste.output.last_bufferp = null ();
      353 	end;
      354 
      355 
      356 /* Process the actual output */
      357 
      358 	partial_record = "0"b;			/* set by process_output_records if incomplete record found */
      359 	long_record = "0"b;				/* set by process_output_records if record is found which can
      360*						   never be placed into an output block */
      361 
      362 	if (hste.minor_state = HSTE_NORMAL) |
      363 	   (hste.device_type = HASP_CONSOLE) |
      364 	   ^hmd.rts_mode
      365 	then do;
      366 
      367 /* Transfer records:  if the multiplexer is so configured, it never requests permission to transmit a file; if the
      368*   sub-channel is the console, it never requests permission regardless of the setting of rts_mode; if the sub-channel
      369*   has already been given permission to transmit the file, continue transmission until an end-of-file record is
      370*   encountered */
      371 
      372 	     call process_output_records ();
      373 	     if needs_space then go to CANT_FINISH_WRITE_CALL;
      374 	end;
      375 
      376 
      377 	else if (hste.minor_state = HSTE_SEND_RTS) then
      378 
      379 /* Request permission:  the sub-channel has never transmitted any data or has previously transmitted an end-of-file
      380*   record, ask the foreign side for permission to transfer the next file */
      381 
      382 	     hmd.send_rts (hste.device_wab_idx) = "1"b;	/* when there's a free output block */
      383 
      384 
      385 	else if (hste.minor_state = HSTE_WAIT_RTS_ACK) then
      386 	     if hmd.input.first_bufferp ^= null ()
      387 	     then do;
      388 
      389 /* Sub-channel is waiting for permission:  if some input records are available, process them in order to check for a
      390*   possible acknowledgement record; if an acknowledgement is present, begin transmitting data */
      391 
      392 		call process_input_records ();	/* process as many input records as possible */
      393 		call interrupt_subchannels_with_input ();    /* inform any waiting sub-channels while we're at it */
      394 
      395 		if hste.minor_state = HSTE_NORMAL
      396 		then do;				/* processing the input records found the ACK record */
      397 		     call process_output_records ();
      398 		     if needs_space then go to CANT_FINISH_WRITE_CALL;
      399 		end;
      400 	     end;
      401 
      402 
      403 /* Post-processing:  if processing of output records terminated because a record was found which is too large to fit into
      404*   a block, return an error indication to tty_write.  Otherwise, if an incomplete record was found in the output chain, a
      405*   wakeup must be sent to the user ring to request more output; to do this, the multiplexer must hold the partial record
      406*   to prevent tty_write from deciding to not send the wakeup.  For the partial record case or if the entire output chain
      407*   is processed, a SEND OUTPUT interrupt will be sent; otherwise, the SEND OUTPUT interrupt will be queued to be sent at a
      408*   later time */
      409 
      410 	if long_record then				/* supplied record will not fit into a block */
      411 	     P_code = et_long_record;
      412 
      413 	else if partial_record & (chain_ptr ^= null ())
      414 	then do;					/* partial record terminated processing */
      415 
      416 	     hste.output.first_bufferp = chain_ptr;
      417 
      418    	     do last_bufferp = hste.output.first_bufferp repeat (pointer (ttybp, last_bufferp -> buffer.next))
      419 		     while (rel (last_bufferp) ^= ""b);
      420 		if (last_bufferp -> buffer.next) = 0 then hste.output.last_bufferp = last_bufferp;
      421 	     end;
      422 
      423 	     chain_ptr = null ();			/* have now taken entire output chain */
      424 	end;
      425 
      426 	P_chain_ptr = chain_ptr;			/* reflect what was processed to the caller */
      427 
      428 	if chain_ptr = null () then do;		/* took all output one way or another:  ask for more now */
      429 	     call dequeue_subchannel_for_output ();
      430 	     call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);
      431 	end;
      432 
      433 
      434 RETURN_FROM_WRITE_CALL:
      435 	if (hmd.minor_state = HMD_REPROCESS) then
      436 	     call process_loopback_records ();		/* still have untouched loopback records */
      437 	else call process_output_block ();			/* complete and send the block if OK */
      438 
      439 	return;
      440 
      441 
      442 /* When not enough space is available to process the entire output chain, control is transfered here */
      443 
      444 CANT_FINISH_WRITE_CALL:
      445 	P_chain_ptr = chain_ptr;			/* only return still unprocessed output */
      446 
      447 	call tty_space_man$needs_space (hmd.devx);
      448 
      449 	return;
      450 
      451 /* Process an interrupt */
      452 
      453 interrupt:
      454      entry (P_hmd_ptr, P_interrupt_type, P_interrupt_data);
      455 
      456 	ttybp = addr (tty_buf$);
      457 	hmd_ptr = P_hmd_ptr;
      458 	hste_ptr = null ();				/* avoid referencing unitialized values */
      459 	interrupt_type = P_interrupt_type;
      460 	interrupt_data = P_interrupt_data;
      461 
      462 	if (interrupt_type < lbound (INTERRUPT, 1)) | (interrupt_type > hbound (INTERRUPT, 1)) then
      463 	     return;				/* don't handle this kind */
      464 
      465 	go to INTERRUPT (interrupt_type);		/* process it */
      466 
      467 
      468 INTERRUPT (1):					/* DIALUP -- major channel has dialed up */
      469 	if hmd.state ^= HMD_LOADING then return;
      470 	unspec (hmd.dialup_info) = interrupt_data;	/* will need to dialup individual channels */
      471 	call do_line_control (SET_HASP_MODE, 0, 0, 0);	/* switch line to HASP mode */
      472 	call do_line_control (CONFIGURE, 3, 0, 0);	/* transparent EBCDIC */
      473 	call do_line_control (SET_MASTER_SLAVE_MODE,	/* indicate if workstation or host */
      474 			  binary ((hmd.type = HASP_WORKSTATION), 17, 0), 0, 0);
      475 	call do_line_control (SET_HASP_TIMERS, hmd.ic_timeout, hmd.receive_timeout, hmd.transmit_timeout);
      476 	call do_line_control (SET_NAK_LIMIT, hmd.max_naks, 0, 0);	/* maximum # of continous NAKs before line dies */
      477 	call do_line_control (ACCEPT_BID, 0, 0, 0);	/* start waiting for connection */
      478 	call channel_manager$control (hmd.devx, "set_input_message_size", addr (hmd.max_block_size), code);
      479 						/* set maximum block size allowed on input */
      480 	return;					/* still loading */
      481 
      482 LOADING_FAILS:					/* line control fails--crash or hangup to follow */
      483 	return;
      484 
      485 
      486 INTERRUPT (2):					/* HANGUP -- major channel has hungup */
      487 	call crash_mpx ();				/* death and destruction reigns */
      488 	call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_DOWN, code);
      489 	return;
      490 
      491 
      492 INTERRUPT (3):					/* CRASH -- parent multiplexer has crashed */
      493 	call crash_mpx ();
      494 	return;
      495 
      496 
      497 INTERRUPT (4):					/* SEND OUTPUT -- parent wants output */
      498 	hmd.send_output = "1"b;			/* have permission to send some output */
      499 	if (hmd.state < HMD_LOADED)
      500 	     then;				/* nothing to send yet */
      501 	else if (hmd.minor_state = HMD_REPROCESS) then
      502 	     call process_loopback_records ();		/* try to retransmit loopback'ed records if possible */
      503 	else call process_output_block ();		/* either finish last block or start transmitting a new one */
      504 	return;
      505 
      506 
      507 INTERRUPT (5):					/* INPUT AVAILABLE -- parent has input */
      508 	hmd.flags.input_available = "1"b;		/* remember that input is waiting */
      509 	if (hmd.state < HMD_LOADED)
      510 	     then;				/* no sub-channels are up yet */
      511 	else call interrupt_subchannels_requesting_input ();
      512 	return;					/* inform all sub-channels which have already 
      513*						   requested input */
      514 
      515 
      516 INTERRUPT (6):					/* ACCEPT INPUT -- parent has input */
      517 	hmd.flags.input_available = "0"b;		/* just to be safe -- parent shouldn't use both mechanisms */
      518 	if (hmd.state < HMD_LOADED)
      519 	     then;				/* can't take the input yet */
      520 	else do;
      521 	     unspec (rtx_info) = interrupt_data;
      522 	     chain_ptr = pointer (ttybp, rtx_info.chain_head);
      523 	     if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
      524 		call trace_block (chain_ptr, INPUT);
      525 	     call process_input_block (chain_ptr);	/* interpret the BCB and FCS */
      526 	     if (hmd.input.first_bufferp ^= null ()) & ^hmd.retry_process_input then
      527 		call process_input_records ();	/* have something to process and space OK */
      528 	     call interrupt_subchannels_with_input ();	/* inform the sub-channels that now have input */
      529 	     if (hmd.minor_state = HMD_REPROCESS) then
      530 		call process_loopback_records ();
      531 	     else call process_output_block ();		/* an output block might have to be sent because of above
      532*						   processing */
      533 	end;
      534 	return;
      535 
      536 
      537 INTERRUPT (7):					/* INPUT REJECTED -- some input rejected by FNP; ignore */
      538 	return;
      539 
      540 
      541 INTERRUPT (8):					/* QUIT -- break signal; ignore */
      542 	return;
      543 
      544 
      545 INTERRUPT (9):					/* LINE STATUS -- line status from FNP; process */
      546 	unspec (line_stat) = interrupt_data;
      547 	call process_line_status ();
      548 	return;
      549 
      550 
      551 INTERRUPT (10):					/* DIAL STATUS -- autocall status; ignore */
      552 	return;
      553 
      554 
      555 INTERRUPT (11):					/* WRU TIMEOUT -- timeout waiting for answerback; ignore */
      556 	return;
      557 
      558 
      559 INTERRUPT (12):					/* SPACE AVAILABLE	-- some buffer space freed; try again */
      560 	if hmd.state < HMD_LOADED then return;
      561 	call process_space_available ();
      562 	return;
      563 
      564 INTERRUPT (13):					/* various, not used by this multiplexer */
      565 INTERRUPT (14):
      566 INTERRUPT (15):
      567 INTERRUPT (16):
      568 	return;
      569 
      570 INTERRUPT (17):					/* MASKED -- treat like HANGUP but use different wakeup message */
      571 	call crash_mpx ();				/* death and destruction reigns */
      572 	call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_MASKED, code);
      573 	return;
      574 
      575 
      576 /* Process control orders */
      577 
      578 control:
      579      entry (P_hmd_ptr, P_subchannel_idx, P_order, P_info_ptr, P_code);
      580 
      581 	ttybp = addr (tty_buf$);
      582 	call setup_subchannel ();
      583 	order = P_order;
      584 	info_ptr = P_info_ptr;
      585 	code = 0;					/* assume success */
      586 
      587 	if (order = "listen") then			/* listen to this sub-channel */
      588 	     if (hmd.state < HMD_LOADED) then		/* multiplexer must be loaded for this to work */
      589 		code = et_invalid_state;
      590 	     else do;
      591 		if (hste.state < HSTE_LISTENING) then	/* this sub-channel wasn't already listening */
      592 		     hste.state = HSTE_LISTENING;
      593 		if (hmd.minor_state < HMD_NORMAL) then	/* can only dialup the console until SIGNON is sent */
      594 		     if (hste.device_type = HASP_CONSOLE) & (hmd.state = HMD_STARTED) &
      595 		        (hste.state = HSTE_LISTENING) then
      596 			call signal_dialup ();
      597 		     else;
      598 		else				/* any channel can dialup now */
      599 		if (hmd.state = HMD_STARTED) & (hste.state = HSTE_LISTENING) then
      600 		     call signal_dialup ();
      601 	     end;
      602 
      603 	else if (order = "hangup") then		/* hangup this sub-channel */
      604 	     call signal_hangup (HANGUP);
      605 
      606 	else if (order = "wru") then			/* read answerback: none available */
      607 	     call channel_manager$interrupt (hste.devx, WRU_TIMEOUT, ""b);
      608 
      609 	else if (order = "abort") then		/* resetwrite and/or resetread */
      610 	     if (info_ptr = null ()) then		/* info structure required */
      611 		code = et_null_info_ptr;
      612 	     else do;
      613 		if abort_info.resetwrite & (hste.direction ^= HSTE_INPUT_ONLY)
      614 		then do;				/* resetwrite only if it could do output in the first place */
      615 		     if (hste.output.first_bufferp ^= null ()) then do;
      616 			call tty_space_man$free_chain (hste.devx, OUTPUT, hste.output.first_bufferp);
      617 			hste.output.first_bufferp, hste.output.last_bufferp = null ();
      618 		     end;
      619 		     call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);
      620 		end;
      621 		if abort_info.resetread & (hste.input.first_bufferp ^= null ())
      622 		then do;				/* resetread only if it has some input already */
      623 		     call tty_space_man$free_chain (hste.devx, INPUT, hste.input.first_bufferp);
      624 		     hste.input.n_records = 0;
      625 		     hste.input.first_bufferp, hste.input.last_bufferp = null ();
      626 		     if ^hmd.input_wabs (hste.device_wab_idx)
      627 		     then do;			/* device was not-ready: it's now ready again */
      628 			hmd.input_wabs (hste.device_wab_idx) = "1"b;
      629 			if (hmd.minor_state = HMD_REPROCESS) then
      630 			     call process_loopback_records ();
      631 			else call process_output_block ();
      632 		     end;				/* may want to send a status block now */
      633 		end;
      634 	     end;
      635 
      636 	else if (order = "write_status") then		/* check if output still pending */
      637 	     if (info_ptr = null ()) then		/* info structure is required */
      638 		code = et_null_info_ptr;
      639 	     else if (hste.output.first_bufferp ^= null ()) then
      640 		write_status_info.output_pending = "1"b;
      641 	     else write_status_info.output_pending = "0"b;
      642 
      643 	else if (order = "get_device_type") then	/* return type of device attached to this sub-channel */
      644 	     if (info_ptr = null ()) then		/* info structure is required */
      645 		code = et_null_info_ptr;
      646 	     else get_device_type_info = hste.device_type;
      647 
      648 	else if (order = "signon_record") then		/* send SIGNON record for multiplexer */
      649 	     if (info_ptr = null ()) then		/* info structure is required */
      650 		code = et_null_info_ptr;
      651 	     else if (hmd.type = HASP_WORKSTATION) then	/* workstations only */
      652 		if (hste.device_type ^= HASP_CONSOLE) then
      653 		     code = et_incorrect_device_type;   /* only from the console please */
      654 		else if ^hmd.signon_mode then		/* remote isn't expecting one */
      655 		     code = et_invalid_state;
      656 		else if (hmd.signon_data_ptr = null ()) &    /* if waiting for a SIGNON... */
      657 		        (hmd.minor_state = HMD_SEND_SIGNON) then
      658 		     if (sri.version ^= SIGNON_RECORD_INFO_VERSION_1) then
      659 			code = et_unimplemented_version;
      660 		     else do;
      661 			call tty_space_man$get_space (size (hmd_signon_data), hsd_ptr);
      662 			if hsd_ptr ^= null ()
      663 			then do;			/* got the needed room */
      664 			     hmd.signon_data_ptr = hsd_ptr;
      665 			     hmd_signon_data.processid = pds$process_id;
      666 			     hmd_signon_data.event_channel = sri.event_channel;
      667 			     hmd_signon_data.record = sri.record;
      668 			     call process_output_block (); /* try to send it */
      669 			end;
      670 			else code = et_noalloc;	/* no room: let caller retry */
      671 		     end;
      672 		else code = et_out_of_sequence;	/* already sent one */
      673 	     else code = et_undefined_order_request;	/* not valid for a host */
      674 
      675 	else if (order = "no_signon_record") then	/* caller wants to verify no SIGNON record is needed */
      676 	     if (hmd.type = HASP_WORKSTATION) then	/* workstations only */
      677 		if hmd.signon_mode then
      678 		     code = et_invalid_state;		/* workstation requires a signon record */
      679 		else;				/* workstation does not need to send a SIGNON */
      680 	     else code = et_undefined_order_request;	/* not valid for a host */
      681 
      682 	else if (order = "copy_meters") then		/* save current meters for use with -since_dialup */
      683 	     hste.saved_meters_ptr -> hasp_subchannel_meters = hste.meters;
      684 
      685 	else if (order = "get_meters") then		/* return subchannel metering data */
      686 	     if (info_ptr = null ()) then		/* must have a place to put results */
      687 		code = et_null_info_ptr;
      688 	     else if (info_ptr -> get_comm_meters_info.version ^= GET_COMM_METERS_INFO_VERSION_1) then
      689 		code = et_unimplemented_version;	/* wrong structure or version of structure */
      690 	     else do;				/* OK so far ... */
      691 		hsmd_ptr = info_ptr -> get_comm_meters_info.parent_ptr;
      692 		if hsmd_ptr ^= null () then
      693 		     if (hasp_subchannel_meters_data.version ^= HASP_SUBCHANNEL_METERS_DATA_VERSION_1) then
      694 			code = et_unimplemented_version;
      695 		     else do;
      696 			string (hasp_subchannel_meters_data.flags) = ""b;
      697 			hasp_subchannel_meters_data.report_input_meters = (hste.direction ^= HSTE_OUTPUT_ONLY);
      698 			hasp_subchannel_meters_data.report_output_meters = (hste.direction ^= HSTE_INPUT_ONLY);
      699 			hasp_subchannel_meters_data.current_meters = hste.meters;
      700 			hasp_subchannel_meters_data.saved_meters = hste.saved_meters_ptr -> hasp_subchannel_meters;
      701 		     end;
      702 	     end;
      703 
      704 	else code = et_undefined_order_request;
      705 
      706 	P_code = code;
      707 	return;
      708 
      709 /* Validate a proposed mode setting */
      710 
      711 check_modes:
      712      entry (P_hmd_ptr, P_subchannel_idx, P_mclp, P_code);
      713 
      714 
      715 /* Set modes ON or OFF */
      716 
      717 set_modes:
      718      entry (P_hmd_ptr, P_subchannel_idx, P_mclp, P_code);
      719 
      720 	call setup_subchannel ();
      721 	mclp = P_mclp;
      722 	P_code = 0;
      723 
      724 	do idx = 1 to mcl.n_entries;
      725 
      726 	     mclep = addr (mcl.entries (idx));
      727 
      728 	     mcle.mpx_mode = (mcle.mode_name = "rawi") |	/* rawi, rawo, and echoplex only are checked */
      729 			 (mcle.mode_name = "rawo") | (mcle.mode_name = "echoplex");
      730 
      731 	     if mcle.mpx_mode then			/* process this mode */
      732 
      733 		if ((mcle.mode_name ^= "rawi") & (mcle.mode_name ^= "rawo") & (mcle.mode_name ^= "echoplex")) |
      734 		   ((mcle.mode_name = "rawi") & ^mcle.mode_switch) |
      735 		   ((mcle.mode_name = "rawo") & ^mcle.mode_switch) |
      736 		   ((mcle.mode_name = "echoplex") & mcle.mode_switch)
      737 		then do;				/* only accept:  rawo,rawi,^echoplex */
      738 		     mcle.error = "1"b;
      739 		     P_code = et_bad_mode;
      740 		end;
      741 	end;
      742 
      743 	return;
      744 
      745 
      746 
      747 /* Return multiplexer specific modes */
      748 
      749 get_modes:
      750      entry (P_hmd_ptr, P_subchannel_idx, P_modes, P_code);
      751 
      752 	P_modes = "";				/* no special modes defined */
      753 	P_code = 0;
      754 
      755 	return;
      756 
      757 /* Initialize sub-channel data pointer from parameters */
      758 
      759 setup_subchannel:
      760 	procedure ();
      761 
      762 	     hmd_ptr = P_hmd_ptr;
      763 
      764 	     if hmd.state < HMD_LOADED then do;		/* can't hack subchannels if not loaded */
      765 		code = et_action_not_performed;
      766 		go to ERROR_RETURN;
      767 	     end;
      768 
      769 	     subchannel_idx = P_subchannel_idx;
      770 	     hste_ptr = addr (hmd.subchannels (subchannel_idx));
      771 
      772 	     return;
      773 
      774 	end setup_subchannel;
      775 
      776 /* Signal dialup on the given subchannel:  A subchannel may be dialed-up and hungup several times during the life of a
      777*   multiplexer loading.  Therefore, any loopbacked records for the subchannel must be preserved across hangups/dial-ups of
      778*   the subchannel as those records were sucessfully transmitted as far as the user ring is concerned.  Additionally, input
      779*   is accepted for devices before they dialup to avoid loss of data in the original blocks which are received before the
      780*   Initializer can listen to all the subchannels */
      781 
      782 signal_dialup:
      783 	procedure ();
      784 
      785 dcl  saved_input_available bit (1) aligned;
      786 
      787 	     if (hmd.minor_state_stack = null ()) & (hste.loopback.first_bufferp = null ()) then
      788 						/* no loopbacked records available: this subchannel can't be
      789*						   retransmitting any records so it's minor state should be
      790*						   reset.  If it were retransmitting, that process controls
      791*						   the minor state */
      792 		if hmd.rts_mode & (hste.device_type ^= HASP_CONSOLE) & (hste.direction ^= HSTE_INPUT_ONLY) then
      793 		     hste.minor_state = HSTE_SEND_RTS;	/* must request permission before first output */
      794 		else hste.minor_state = HSTE_NORMAL;	/* console or multiplexer not configured to ask: OK to send */
      795 
      796 	     hste.next_subchannel_for_output = 0;	/* not in the queues yet */
      797 
      798 	     hste.output.first_bufferp, hste.output.last_bufferp = null ();	/* can't have output outstanding */
      799 
      800 	     saved_input_available = hste.flags.input_available;
      801 	     string (hste.flags) = ""b;		/* can't have done a read/write call yet */
      802 	     hste.flags.input_available = saved_input_available;
      803 
      804 	     if (hste.direction = HSTE_INPUT_ONLY) | (hste.direction = HSTE_INPUT_OUTPUT)
      805 	     then do;				/* input device:  OK to receive input ... */
      806 		hmd.input_wabs (hste.device_wab_idx) = "1"b;
      807 		hmd.send_rts_ack (hste.device_wab_idx) = "0"b;	/* ... but don't send ACKs yet */
      808 
      809 	     end;
      810 	     else hmd.send_rts (hste.device_wab_idx) = "0"b;
      811 
      812 	     hste.dialup_info = hmd.dialup_info;
      813 
      814 	     hste.state = HSTE_DIALED;		/* now have everything to qualify as dialed */
      815 
      816 	     call channel_manager$interrupt (hste.devx, DIALUP, unspec (hste.dialup_info));
      817 
      818 	     if (hste.direction ^= HSTE_INPUT_ONLY) then	/* authorize first output */
      819 		call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);
      820 
      821 	     if (hste.direction ^= HSTE_OUTPUT_ONLY) then
      822 		if hste.flags.input_available then do;	/* inform the channel something's already present */
      823 		     call channel_manager$interrupt (hste.devx, INPUT_AVAILABLE, ""b);
      824 		     hste.flags.input_available = "0"b;
      825 		end;
      826 
      827 	     return;
      828 
      829 	end signal_dialup;
      830 
      831 /* Signal hangup on the specified sub-channel */
      832 
      833 signal_hangup:
      834 	procedure (P_interrupt_type);
      835 
      836 dcl  P_interrupt_type fixed binary;			/* type of interrupt to give to sub-channel -- hangup/crash */
      837 
      838 	     hste.state = HSTE_HUNGUP;
      839 
      840 	     if hste.input.first_bufferp ^= null () then	/* throw away any held input */
      841 		call tty_space_man$free_chain (hste.devx, INPUT, hste.input.first_bufferp);
      842 
      843 	     if hste.output.first_bufferp ^= null () then
      844 		call tty_space_man$free_chain (hste.devx, OUTPUT, hste.output.first_bufferp);
      845 
      846 	     call dequeue_subchannel_for_output ();
      847 
      848 	     hste.input.n_records = 0;
      849 
      850 	     hste.input.first_bufferp, hste.input.last_bufferp,
      851 		hste.output.first_bufferp, hste.output.last_bufferp = null ();
      852 
      853 	     string (hste.flags) = ""b;
      854 
      855 	     if (hste.direction = HSTE_INPUT_ONLY) | (hste.direction = HSTE_INPUT_OUTPUT)
      856 	     then do;				/* input device:  shut it down and don't send RTS ack */
      857 		hmd.input_wabs (hste.device_wab_idx) = "0"b;
      858 		hmd.send_rts_ack (hste.device_wab_idx) = "0"b;
      859 	     end;
      860 	     else hmd.send_rts (hste.device_wab_idx) = "0"b;
      861 
      862 	     call channel_manager$interrupt (hste.devx, P_interrupt_type, ""b);
      863 
      864 	     return;
      865 
      866 	end signal_hangup;
      867 
      868 /* Indicate that the multiplexer is loaded: initialize the multiplexer database to the point where input will be buffered
      869*   and the initial SEND OUTPUT interrupt can be handled */
      870 
      871 load_mpx: procedure ();
      872 
      873 dcl (saved_send_output, saved_input_available) bit (1) aligned;
      874 dcl  idx fixed binary;
      875 
      876 	     hmd.state = HMD_LOADED;			/* we are not loaded, but no dialups on sub-channels */
      877 
      878 	     hmd.time_mpx_booted = clock ();		/* it's there now */
      879 
      880 	     if (hmd.type = HASP_WORKSTATION) & hmd.signon_mode then
      881 		hmd.minor_state = HMD_SEND_SIGNON;	/* must wait for console to send SIGNON record */
      882 	     else hmd.minor_state = HMD_NORMAL;		/* normal data transfer may begin */
      883 
      884 	     saved_send_output = hmd.send_output;	/* these flags are valid from time boot is started */
      885 	     saved_input_available = hmd.flags.input_available;
      886 
      887 	     string (hmd.flags) = ""b;
      888 
      889 	     hmd.send_output = saved_send_output;
      890 	     hmd.flags.input_available = saved_input_available;
      891 
      892 	     hmd.suspend_all_output = "1"b;		/* do not allow any output */
      893 	     hmd.first_foreign_block = "1"b;		/* haven't seen the first block yet */
      894 	     unspec (hmd.foreign_fcs_bytes) = "700600"b3; /* FCS that can't come from foreign side */
      895 
      896 	     hmd.suspend_all_input = "1"b;		/* do not accept any input */
      897 	     hmd.reset_local_block_count = "1"b;	/* force BCB reset to be sent */
      898 	     unspec (hmd.local_fcs_bytes) = "700600"b3;   /* force FCS to be computed */
      899 
      900 	     string (hmd.input_wabs) = ""b;		/* turn off all wait-a-bits to prevent data transfer */
      901 	     string (hmd.output_wabs) = ""b;
      902 	     string (hmd.send_rts) = ""b;		/* prevent accidental shipments of RTS or RTS-ack records */
      903 	     string (hmd.send_rts_ack) = ""b;
      904 
      905 	     hmd.minor_state_stack,			/* these stacks are empty as loopback is not preserved ... */
      906 		hmd.loopback_block_chain_stack = null ();    /* ... across multiplexer load/crash sequences */
      907 
      908 	     hmd.output_chain_ptr, hmd.signon_data_ptr,
      909 		hmd.input.first_bufferp, hmd.input.last_bufferp,
      910 		hmd.loopback.first_bufferp, hmd.loopback.last_bufferp,
      911 		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();
      912 
      913 	     hmd.output_block.subchannel_idx, hmd.output_block.tally = 0;
      914 
      915 	     do idx = 1 to hmd.n_subchannels;		/* indicate all sub-channels are still hungup */
      916 		hmd.subchannels(idx).state = HSTE_HUNGUP;
      917 		hmd.subchannels(idx).input.n_records = 0;    /* no input has arrived yet: some may arrive ... */
      918 		hmd.subchannels(idx).input.first_bufferp,    /* ... before dialup however */
      919 		     hmd.subchannels(idx).input.last_bufferp = null ();
      920 		hmd.subchannels(idx).loopback.n_records = 0; /* can't have any loopbacked records yet */
      921 		hmd.subchannels(idx).loopback.first_bufferp, hmd.subchannels(idx).loopback.last_bufferp = null ();
      922 	     end;
      923 
      924 	     call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_UP, code);
      925 
      926 	     return;
      927 
      928 	end load_mpx;
      929 
      930 /* Shutdown the multiplexer by "hanging up" all the sub-channels */
      931 
      932 crash_mpx:
      933 	procedure ();
      934 
      935 dcl (old_state, idx) fixed binary;
      936 
      937 
      938 	     old_state = hmd.state;
      939 
      940 	     hmd.state = HMD_DOWN;			/* multiplexer is now dead */
      941 
      942 	     if old_state < HMD_LOADED then		/* wasn't loaded:  couldn't be doing anything */
      943 		return;
      944 
      945 	     if (hmd.minor_state = HMD_SEND_SIGNON) | (hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE)
      946 	     then do;				/* inform console's owner that the SIGNON record failed */
      947 		hsd_ptr = hmd.signon_data_ptr;
      948 		if hsd_ptr ^= null () then		/* ... insure there's someone listening */
      949 		     call pxss$ring_0_wakeup (hmd_signon_data.processid, hmd_signon_data.event_channel,
      950 				          HASP_SIGNON_HANGUP, code);
      951 	     end;
      952 
      953 	     if hmd.output_chain_ptr ^= null () then	/* free up all unused data */
      954 		call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_chain_ptr);
      955 
      956 	     if hmd.input.first_bufferp ^= null () then
      957 		call tty_space_man$free_chain (hmd.devx, INPUT, hmd.input.first_bufferp);
      958 
      959 	     if hmd.loopback.first_bufferp ^= null () then
      960 		call tty_space_man$free_chain (hmd.devx, INPUT, hmd.loopback.first_bufferp);
      961 
      962 	     if hmd.output_block.first_bufferp ^= null () then
      963 		call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);
      964 
      965 	     if hmd.signon_data_ptr ^= null () then
      966 		call tty_space_man$free_space (currentsize (hmd.signon_data_ptr -> hmd_signon_data),
      967 					 hmd.signon_data_ptr);
      968 
      969 	     call empty_minor_state_stack ();
      970 	     call empty_loopback_block_chain_stack ();
      971 
      972 	     hmd.output_chain_ptr, hmd.signon_data_ptr,
      973 		hmd.input.first_bufferp, hmd.input.last_bufferp,
      974 		hmd.loopback.first_bufferp, hmd.loopback.last_bufferp,
      975 		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();
      976 
      977 	     hmd.output_block.subchannel_idx, hmd.output_block.tally = 0;
      978 
      979 	     hmd.subchannels_for_output = 0;		/* empty the queue */
      980 
      981 	     string (hmd.flags) = ""b;
      982 
      983 	     do idx = 1 to hmd.n_subchannels;
      984 		hste_ptr = addr (hmd.subchannels (idx));
      985 		call signal_hangup (CRASH);
      986 	     end;
      987 
      988 	     return;
      989 
      990 	end crash_mpx;
      991 
      992 /* Minor state stack manager:  The minor state stack is used to preserve the multiplexer state during the processing of
      993*   output blocks returned by the FNP.  This stack includes the previous minor state of the multiplexer and the individual
      994*   loopback chains of each subchannel.  These chains are saved to insure that, when a loopback occurs while retransmitting
      995*   previous output, the order of records for each subchannel will be preserved properly */
      996 
      997 minor_state_stack_manager:
      998 	procedure ();
      999 
     1000 	     return;				/* not an entry */
     1001 
     1002 
     1003 dcl  P_new_minor_state fixed binary parameter;		/* push_minor_state: new minor state for multiplexer */
     1004 
     1005 dcl  previous_msse_ptr pointer;
     1006 
     1007 dcl  idx fixed binary;
     1008 
     1009 
     1010 
     1011 /* Push the current minor state onto the stack */
     1012 
     1013 push_minor_state:
     1014 	entry (P_new_minor_state);
     1015 
     1016 	     call tty_space_man$get_space (size (msse), msse_ptr);
     1017 		if msse_ptr = null () then do;	/* punt ... */
     1018 		     call syserr (LOG_AND_PRINT,
     1019 			        "hasp_mpx (line ^a): No space available to preserve minor state; line will be hungup.",
     1020 			        hmd.name);
     1021 		     call channel_manager$control (hmd.devx, "hangup", null (), code);
     1022 		     return;
     1023 		end;
     1024 
     1025 	     do idx = 1 to hmd.n_subchannels;		/* save loopback chains */
     1026 		msse.subchannels(idx).loopback = hmd.subchannels(idx).loopback;
     1027 		hmd.subchannels(idx).loopback.n_records = 0;
     1028 		hmd.subchannels(idx).loopback.first_bufferp, hmd.subchannels(idx).loopback.last_bufferp = null ();
     1029 	     end;					/* empty chains so new records go at front */
     1030 
     1031 	     msse.minor_state = hmd.minor_state;	/* push state */
     1032 	     hmd.minor_state = P_new_minor_state;
     1033 
     1034 	     msse.previous = hmd.minor_state_stack;	/* push */
     1035 	     hmd.minor_state_stack = msse_ptr;
     1036 
     1037 	     return;
     1038 
     1039 
     1040 /* Pop the minor state stack: splice any newly created loopback chains onto the front of the old chains (if any) */
     1041 
     1042 pop_minor_state:
     1043 	entry ();
     1044 
     1045 	     if hmd.minor_state_stack = null () then	/* shouldn't happen */
     1046 		return;
     1047 
     1048 	     msse_ptr = hmd.minor_state_stack;
     1049 
     1050 	     do idx = 1 to hmd.n_subchannels;		/* splice chains */
     1051 		if msse.subchannels(idx).loopback.first_bufferp ^= null () then do;
     1052 		     hmd.subchannels(idx).loopback.n_records =
     1053 			hmd.subchannels(idx).loopback.n_records + msse.subchannels(idx).loopback.n_records;
     1054 		     if hmd.subchannels(idx).loopback.last_bufferp = null () then	/* didn't get any this time */
     1055 			hmd.subchannels(idx).loopback.first_bufferp = msse.subchannels(idx).loopback.first_bufferp;
     1056 		     else hmd.subchannels(idx).loopback.last_bufferp -> buffer.next =
     1057 			     binary (rel (msse.subchannels(idx).loopback.first_bufferp), 18, 0);
     1058 		     hmd.subchannels(idx).loopback.last_bufferp = msse.subchannels(idx).loopback.last_bufferp;
     1059 		end;
     1060 	     end;
     1061 
     1062 	     hmd.minor_state = msse.minor_state;	/* pop */
     1063 	     hmd.minor_state_stack = msse.previous;
     1064 
     1065 	     call tty_space_man$free_space (currentsize (msse), msse_ptr);
     1066 
     1067 	     return;
     1068 
     1069 
     1070 
     1071 /* Empty the stack: called at multiplexer crashes to flush all space used by the minor state stack */
     1072 
     1073 empty_minor_state_stack:
     1074 	entry ();
     1075 
     1076 	     do msse_ptr = hmd.minor_state_stack
     1077 		         repeat (previous_msse_ptr) while (msse_ptr ^= null ());
     1078 
     1079 		do idx = 1 to hmd.n_subchannels;
     1080 		     if msse.subchannels(idx).loopback.first_bufferp ^= null () then
     1081 			call tty_space_man$free_chain (hmd.subchannels(idx).devx, OUTPUT,
     1082 						 msse.subchannels(idx).loopback.first_bufferp);
     1083 		end;
     1084 
     1085 		previous_msse_ptr = msse.previous;
     1086 
     1087 		call tty_space_man$free_space (currentsize (msse), msse_ptr);
     1088 	     end;
     1089 
     1090 	     hmd.minor_state_stack = null ();
     1091 
     1092 	     return;
     1093 
     1094 	end minor_state_stack_manager;
     1095 
     1096 /* Loopback block chain stack manager:  The loopback block chain stack is when the FNP is returning output blocks to
     1097*   prevent retransmitted data from being processed out of order */
     1098 
     1099 loopback_block_chain_stack_manager:
     1100 	procedure ();
     1101 
     1102 	     return;				/* not an entry */
     1103 
     1104 dcl  previous_lbcse_ptr pointer;
     1105 
     1106 
     1107 /* Push the current loopback block chain onto the top of the stack */
     1108 
     1109 push_loopback_block_chain:
     1110 	entry ();
     1111 
     1112 	     call tty_space_man$get_space (size (lbcse), lbcse_ptr);
     1113 		if lbcse_ptr = null () then do;
     1114 		     call syserr (LOG_AND_PRINT,
     1115 			        "hasp_mpx (line ^a): No space available to save loopback chain; line will be hungup.",
     1116 			        hmd.name);
     1117 		     call channel_manager$control (hmd.devx, "hangup", null (), code);
     1118 		     return;
     1119 		end;
     1120 
     1121 	     lbcse.loopback = hmd.loopback;
     1122 	     hmd.loopback = null ();			/* start loopback chain afresh */
     1123 
     1124 	     lbcse.previous = hmd.loopback_block_chain_stack;  /* push */
     1125 	     hmd.loopback_block_chain_stack = lbcse_ptr;
     1126 
     1127 	     return;
     1128 
     1129 
     1130 
     1131 /* Pop the top entry from the stack: splice the current loopback block chain onto the front of the chain from the stack */
     1132 
     1133 pop_loopback_block_chain:
     1134 	entry ();
     1135 
     1136 	     if hmd.loopback_block_chain_stack = null () then
     1137 		return;				/* nothing there */
     1138 
     1139 	     lbcse_ptr = hmd.loopback_block_chain_stack;
     1140 
     1141 	     if lbcse.loopback.first_bufferp ^= null () then do;
     1142 		if hmd.loopback.last_bufferp = null () then  /* didn't pickup any data this time */
     1143 		     hmd.loopback.first_bufferp = lbcse.loopback.first_bufferp;
     1144 		else hmd.loopback.last_bufferp -> buffer.next = binary (rel (lbcse.loopback.first_bufferp), 18, 0);
     1145 		hmd.loopback.last_bufferp = lbcse.loopback.last_bufferp;
     1146 	     end;
     1147 
     1148 	     hmd.loopback_block_chain_stack = lbcse.previous;  /* pop */
     1149 
     1150 	     call tty_space_man$free_space (currentsize (lbcse), lbcse_ptr);
     1151 
     1152 	     return;
     1153 
     1154 
     1155 
     1156 /* Empty the stack: called at multiplexer crashes to flush all space used by the loopback block chain stack */
     1157 
     1158 empty_loopback_block_chain_stack:
     1159 	entry ();
     1160 
     1161 	     do lbcse_ptr = hmd.loopback_block_chain_stack
     1162 			repeat (previous_lbcse_ptr) while (lbcse_ptr ^= null ());
     1163 
     1164 		previous_lbcse_ptr = lbcse.previous;
     1165 
     1166 		if lbcse.loopback.first_bufferp ^= null () then
     1167 		     call tty_space_man$free_chain (hmd.devx, INPUT, lbcse.loopback.first_bufferp);
     1168 
     1169 		call tty_space_man$free_space (currentsize (lbcse), lbcse_ptr);
     1170 	     end;
     1171 
     1172 	     hmd.loopback_block_chain_stack = null ();	/* now empty */
     1173 
     1174 	     return;
     1175 
     1176 	end loopback_block_chain_stack_manager;
     1177 
     1178 /* Add the sub-channel to the end of the pending output queue */
     1179 
     1180 enqueue_subchannel_for_output:
     1181 	procedure ();
     1182 
     1183 dcl  idx fixed binary;
     1184 
     1185 	     do idx = hmd.subchannels_for_output.first
     1186 		    repeat (hmd.subchannels(idx).next_subchannel_for_output)
     1187 		     while (idx ^= 0);		/* see if it is already in the queue */
     1188 		if (idx = hste.subchannel_idx) then return;
     1189 	     end;
     1190 
     1191 	     hste.holding_output = "1"b;		/* now on the queue */
     1192 
     1193 	     if (hmd.subchannels_for_output.first = 0) then    /* queue empty:  this will be first element in queue */
     1194 		hmd.subchannels_for_output.first = hste.subchannel_idx;
     1195 
     1196 	     else hmd.subchannels(hmd.subchannels_for_output.last).next_subchannel_for_output = hste.subchannel_idx;
     1197 						/* chain to end of queue */
     1198 
     1199 	     hmd.subchannels_for_output.last = hste.subchannel_idx; /* last element on the queue */
     1200 	     hste.next_subchannel_for_output = 0;
     1201 
     1202 	     return;
     1203 
     1204 	end enqueue_subchannel_for_output;
     1205 
     1206 /* Remove the sub-channel from the output queue */
     1207 
     1208 dequeue_subchannel_for_output:
     1209 	procedure ();
     1210 
     1211 dcl  previous_subchannel_idx fixed binary;
     1212 
     1213 	     if hste.holding_output then do;		/* it is on the queue */
     1214 
     1215 		previous_subchannel_idx = 0;		/* in case it is first (and last) in the queue */
     1216 
     1217 		if (hmd.subchannels_for_output.first = hste.subchannel_idx) then
     1218 		     hmd.subchannels_for_output.first = hste.next_subchannel_for_output;
     1219 
     1220 		else				/* not first in queue:  find predecessor */
     1221 		do previous_subchannel_idx = hmd.subchannels_for_output.first
     1222 				      repeat (hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output)
     1223 			while (previous_subchannel_idx ^= 0);
     1224 		     if (hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output = hste.subchannel_idx)
     1225 		     then do;
     1226 			hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output =
     1227 				hste.next_subchannel_for_output;
     1228 			go to EXIT_SEARCH_FOR_PREVIOUS_LOOP;
     1229 		     end;
     1230 		end;
     1231 
     1232 EXIT_SEARCH_FOR_PREVIOUS_LOOP:
     1233 		if (hmd.subchannels_for_output.last = hste.subchannel_idx) then
     1234 		     hmd.subchannels_for_output.last = previous_subchannel_idx;
     1235 	     end;
     1236 
     1237 	     hste.next_subchannel_for_output = 0;
     1238 
     1239 	     hste.holding_output = "0"b;		/* no longer on the queue */
     1240 
     1241 	     return;
     1242 
     1243 	end dequeue_subchannel_for_output;
     1244 
     1245 /* Give a SEND OUTPUT interrupt to each sub-channel that is holding output */
     1246 
     1247 interrupt_subchannels_with_output:
     1248 	procedure ();
     1249 
     1250 dcl  saved_hste_ptr pointer;
     1251 dcl  queue (17) fixed binary;				/* local copy of output queue to avoid looping */
     1252 dcl (n_entries, idx) fixed binary;
     1253 
     1254 	     saved_hste_ptr = hste_ptr;		/* need to use this value */
     1255 
     1256 	     n_entries = 0;				/* make a copy of the current queue */
     1257 	     do idx = hmd.subchannels_for_output.first
     1258 		    repeat (hmd.subchannels(idx).next_subchannel_for_output) while (idx ^= 0);
     1259 		n_entries = n_entries + 1;
     1260 		queue (n_entries) = hmd.subchannels(idx).subchannel_idx;
     1261 	     end;
     1262 
     1263 	     if (n_entries = 0) then return;		/* no interrupts need be sent now */
     1264 
     1265 	     do idx = 1 to n_entries;
     1266 		hste_ptr = addr (hmd.subchannels (queue (idx)));
     1267 		call dequeue_subchannel_for_output ();	/* remove from front of queue */
     1268 		call channel_manager$interrupt_later (hste.devx, SEND_OUTPUT, ""b);
     1269 	     end;
     1270 
     1271 	     hste_ptr = saved_hste_ptr;
     1272 
     1273 	     return;
     1274 
     1275 	end interrupt_subchannels_with_output;
     1276 
     1277 
     1278 
     1279 /* Give an INPUT AVAILABLE interrupt to each sub-channel that actually has input waiting */
     1280 
     1281 interrupt_subchannels_with_input:
     1282 	procedure ();
     1283 
     1284 dcl  idx fixed binary;
     1285 
     1286 	     do idx = 1 to hmd.n_subchannels;
     1287 		if hmd.subchannels(idx).input_available | (hmd.subchannels(idx).input.first_bufferp ^= null ())
     1288 		then do;
     1289 		     hmd.subchannels(idx).requested_input, hmd.subchannels(idx).input_available = "0"b;
     1290 		     call channel_manager$interrupt (hmd.subchannels(idx).devx, INPUT_AVAILABLE, ""b);
     1291 		end;
     1292 	     end;
     1293 
     1294 	     return;
     1295 
     1296 	end interrupt_subchannels_with_input;
     1297 
     1298 /* Give an INPUT AVAILABLE interrupt to each sub-channel which has already requested input.  If no such sub-channels
     1299*   exist, interrupt the operator's console */
     1300 
     1301 interrupt_subchannels_requesting_input:
     1302 	procedure ();
     1303 
     1304 dcl  sent_interrupt bit (1) aligned;
     1305 dcl  idx fixed binary;
     1306 
     1307 	     sent_interrupt = "0"b;
     1308 
     1309 	     do idx = 1 to hmd.n_subchannels;
     1310 		if hmd.subchannels(idx).requested_input then do;
     1311 		     hmd.subchannels(idx).requested_input, hmd.subchannels(idx).input_available = "0"b;
     1312 		     call channel_manager$interrupt (hmd.subchannels(idx).devx, INPUT_AVAILABLE, ""b);
     1313 		     sent_interrupt = "1"b;
     1314 		end;
     1315 	     end;
     1316 
     1317 	     if ^sent_interrupt then			/* insure that someone is interrupted */
     1318 		call channel_manager$interrupt (hmd.subchannels(hmd.console_hste_idx).devx, INPUT_AVAILABLE, ""b);
     1319 
     1320 	     return;
     1321 
     1322 	end interrupt_subchannels_requesting_input;
     1323 
     1324 
     1325 
     1326 /* Process available input blocks:  retrieve any input blocks from the parent multiplexer and perform preliminary
     1327*   processing on them */
     1328 
     1329 process_available_input_blocks:
     1330 	procedure ();
     1331 
     1332 dcl  first_bufferp pointer;
     1333 dcl  more_input bit (1) aligned;			/* ON => parent is holding another block */
     1334 
     1335 
     1336 	     more_input = hmd.flags.input_available;
     1337 
     1338 	     do while (more_input);			/* while the parent has some input */
     1339 		call channel_manager$read (hmd.devx, first_bufferp, more_input, code);
     1340 		     if code ^= 0 then go to ERROR_RETURN;
     1341 		if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
     1342 		     call trace_block (first_bufferp, INPUT);
     1343 		if first_bufferp ^= null () then	/* got a block */
     1344 		     call process_input_block (first_bufferp);
     1345 	     end;
     1346 
     1347 	     hmd.flags.input_available = "0"b;		/* when here all input blocks have been processed */
     1348 
     1349 	     return;
     1350 
     1351 	end process_available_input_blocks;
     1352 
     1353 /* Process an input block:  check if the block is real input or returned output.  For real input, process the BCB and FCS;
     1354*   save the input for later processing; and notify the sub-channels that input has arrived.  For returned output, save the
     1355*   returned output for later processing; and, when all the output has been returned, permit the sub-channels to send
     1356*   output again */
     1357 
     1358 process_input_block:
     1359 	procedure (P_first_bufferp);
     1360 
     1361 dcl  P_first_bufferp pointer parameter;			/* -> first block of data in the block */
     1362 
     1363 dcl  foreign_bcb_char character (1) unaligned;		/* the BCB ... */
     1364 dcl  foreign_fcs_chars character (2) unaligned;		/* ... and the FCS for this input block */
     1365 
     1366 dcl 1 foreign_bcb unaligned based (addr (foreign_bcb_char)) like hasp_bcb_byte;
     1367 dcl 1 foreign_fcs unaligned based (addr (foreign_fcs_chars)) like hasp_fcs_bytes;
     1368 
     1369 dcl (first_bufferp, last_bufferp, next_to_last_bufferp) pointer;
     1370 
     1371 dcl  first_char character (1) aligned;
     1372 
     1373 
     1374 	     first_bufferp = P_first_bufferp;		/* start of input message */
     1375 
     1376 	     next_to_last_bufferp = null ();
     1377 	     do blockp = first_bufferp repeat (pointer (ttybp, buffer.next)) while (rel (blockp) ^= ""b);
     1378 		if buffer.next = 0 then		/* find the last buffer in the chain ... */
     1379 		     last_bufferp = blockp;
     1380 		else next_to_last_bufferp = blockp;	/* ... and the buffer just before it */
     1381 	     end;
     1382 
     1383 	     if last_bufferp -> buffer.tally > 2 then	/* strip DLE/SYN ETB from end */
     1384 		last_bufferp -> buffer.tally = last_bufferp -> buffer.tally - 2;
     1385 	     else do;				/* last buffer has part (or all) of trailer, free it */
     1386 		if next_to_last_bufferp = null () then go to BAD_INPUT_BLOCK;
     1387 		next_to_last_bufferp -> buffer.tally =	/* adjust to flush DLE/SYN ETB sequence */
     1388 		     next_to_last_bufferp -> buffer.tally - 2 + last_bufferp -> buffer.tally;
     1389 		call tty_space_man$free_buffer (hmd.devx, INPUT, last_bufferp);
     1390 		next_to_last_bufferp -> buffer.next = 0;/* this is now end of chain */
     1391 		last_bufferp = next_to_last_bufferp;
     1392 	     end;
     1393 
     1394 	     first_char = substr_of_chain (1, 1);	/* save the DLE or SOH */
     1395 	     call delete_leading_text (2);		/* remove DLE/SOH STX */
     1396 
     1397 	     if first_char = DLE then			/* transparent block, remove transparency codes */
     1398 		call strip_dles ();
     1399 
     1400 	     foreign_bcb_char = substr_of_chain (1, 1);	/* get the BCB and FCS from the buffer */
     1401 	     foreign_fcs_chars = substr_of_chain (2, 2);
     1402 
     1403 	     call delete_leading_text (3);		/* remove the BCB and FCS, leaving just records */
     1404 
     1405 
     1406 	     if ^foreign_fcs.returned_data then
     1407 
     1408 		call process_real_input_block ();	/* real input:  see below */
     1409 
     1410 
     1411 	     else do;
     1412 
     1413 /* Returned output:  This is an output block returned by the FNP because a foreign output device went not-ready.  If this
     1414*   is not a sync-block, place it onto the loopback chain for subsequent processing.  If it is a sync-block, enter
     1415*   a special state where the loopbacked records are processed until the loopback chain is exhausted.  (See
     1416*   process_loopback_records for more detail) */
     1417 
     1418 		if (foreign_fcs.block_type = HASP_FCS_SYNC_BLOCK) then
     1419 		     call process_sync_block ();	/* this code has gotten gravid */
     1420 
     1421 		else if (foreign_bcb_char = hmd.last_loopback_bcb)
     1422 		then do;				/* FNP returned the same block twice! */
     1423 		     call syserr (LOG_AND_PRINT,
     1424 			        "hasp_mpx (line ^a): Duplicate loopback block received: BCB = ^3.3b",
     1425 			        hmd.name, unspec (hmd.last_loopback_bcb));
     1426 		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1427 		end;
     1428 
     1429 		else do;				/* real loopback */
     1430 		     hmd.meters.n_wraparound_blocks = hmd.meters.n_wraparound_blocks + 1;
     1431 		     if hmd.loopback.first_bufferp = null () then
     1432 			hmd.loopback.first_bufferp = first_bufferp;
     1433 		     else hmd.loopback.last_bufferp -> buffer.next = binary (rel (first_bufferp), 18, 0);
     1434 		     hmd.loopback.last_bufferp = last_bufferp;
     1435 		     hmd.last_loopback_bcb = foreign_bcb_char;
     1436 		end;
     1437 	     end;
     1438 
     1439 	     return;
     1440 
     1441 
     1442 /* Control arrives here iff the input block's header/trailer was incomplete:  As the foreign system/workstation believed
     1443*   this block was OK and we could not interpret its content, we must drop the line */
     1444 
     1445 BAD_INPUT_BLOCK:
     1446 	     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1447 
     1448 	     call syserr (LOG_AND_PRINT, "hasp_mpx (line ^a): Invalid input block header/trailer; line will be hungup.", hmd.name);
     1449 	     call channel_manager$control (hmd.devx, "hangup", null (), code);
     1450 
     1451 	     return;
     1452 
     1453 /* Internal to process_input_block:  Returns the specified number of characters (up to four) from the input block */
     1454 
     1455 substr_of_chain:
     1456 	     procedure (p_start_idx, p_length) returns (character (4) varying);
     1457 
     1458 dcl  (p_start_idx, p_length) fixed binary parameter;
     1459 dcl  the_text character (4) varying;
     1460 dcl  (characters_to_skip, characters_to_pickup, characters_in_buffer, start) fixed binary;
     1461 
     1462 		blockp = first_bufferp;
     1463 		the_text = "";			/* nothing yet */
     1464 
     1465 		/*** Skip past those leading buffers which do not contain any of the desired substring */
     1466 		characters_to_skip = p_start_idx - 1;
     1467 		do while (buffer.tally <= characters_to_skip);
     1468 		     if buffer.next = 0 then go to BAD_INPUT_BLOCK;
     1469 		     characters_to_skip = characters_to_skip - buffer.tally;
     1470 		     blockp = pointer (ttybp, buffer.next);
     1471 		end;
     1472 
     1473 		/*** Collect the characters of the substring */
     1474 		start = characters_to_skip;		/* this buffer may contain some uninteresting data */
     1475 		characters_to_pickup = p_length;	/* caller will never ask for more than 4 characters */
     1476 		do while (characters_to_pickup > 0);
     1477 		     characters_in_buffer = min (characters_to_pickup, (buffer.tally - start));
     1478 		     begin;
     1479 dcl  text_in_buffer character (characters_in_buffer) unaligned defined (buffer.chars (start));
     1480 			the_text = the_text || text_in_buffer;
     1481 		     end;
     1482 		     characters_to_pickup = characters_to_pickup - characters_in_buffer;
     1483 		     if characters_to_pickup > 0 then do;
     1484 			if buffer.next = 0 then go to BAD_INPUT_BLOCK;
     1485 			blockp = pointer (ttybp, buffer.next);
     1486 			start = 0;		/* ... always from the beginning of subsequent buffers */
     1487 		     end;
     1488 		end;
     1489 
     1490 		return (the_text);
     1491 
     1492 	     end substr_of_chain;
     1493 
     1494 /* Internal to process_input_block:  Deletes the specified number of characters from the beginning of the input block */
     1495 
     1496 delete_leading_text:
     1497 	     procedure (p_n_characters);
     1498 
     1499 dcl  p_n_characters fixed binary parameter;
     1500 dcl  characters_left_to_delete fixed binary;
     1501 
     1502 		blockp = first_bufferp;
     1503 		characters_left_to_delete = p_n_characters;
     1504 
     1505 		/*** Delete any leading buffers completely emptied by this delete operation */
     1506 		do while (buffer.tally <= characters_left_to_delete);
     1507 		     if buffer.next ^= 0 then		/* ... there are more buffers */
     1508 			first_bufferp = pointer (ttybp, buffer.next);
     1509 		     else go to BAD_INPUT_BLOCK;	/* ... should have been at least n_characters in the block */
     1510 		     characters_left_to_delete = characters_left_to_delete - buffer.tally;
     1511 		     call tty_space_man$free_buffer (hmd.devx, INPUT, blockp);
     1512 		     blockp = first_bufferp;
     1513 		end;
     1514 
     1515 		/*** Delete the rest from this buffer as it has more than enough in it */
     1516 		if characters_left_to_delete > 0 then call delete_text (blockp, 0, characters_left_to_delete);
     1517 
     1518 		return;
     1519 
     1520 	     end delete_leading_text;
     1521 
     1522 /* Internal to process_input_block:  Remove the DLEs added to the chain for transparency's sake */
     1523 
     1524 strip_dles:    procedure ();
     1525 
     1526 dcl  buffer_text character (bufferp -> buffer.tally) unaligned based (addr (bufferp -> buffer.chars (0)));
     1527 dcl  bufferp pointer;
     1528 
     1529 dcl (start, dle_idx) fixed binary;
     1530 dcl  last_was_dle bit (1) aligned;
     1531 
     1532 
     1533 		last_was_dle = "0"b;		/* no previous buffer to end in DLE */
     1534 
     1535 		do bufferp = first_bufferp repeat (pointer (ttybp, bufferp -> buffer.next))
     1536 			while (rel (bufferp) ^= ""b);
     1537 
     1538 		     if last_was_dle then
     1539 			start = 2;		/* last in previous buffer a DLE: first here is escaped */
     1540 		     else start = 1;		/* previous buffer ended normally */
     1541 
     1542 		     last_was_dle = "0"b;
     1543 
     1544 		     dle_idx = index (substr (buffer_text, start), DLE);
     1545 
     1546 		     do while (dle_idx ^= 0);		/* scan buffer until no DLEs are found */
     1547 
     1548 			dle_idx = dle_idx + start - 1;     /* actual 1-based index in buffer */
     1549 
     1550 			if dle_idx < (bufferp -> buffer.tally) then
     1551 			     call delete_text (bufferp, (dle_idx - 1), 1);     /* DLE in middle: delete it */
     1552 			else do;			/* DLE last in buffer: escaped character in next buffer */
     1553 			     bufferp -> buffer.tally = (bufferp -> buffer.tally) - 1;
     1554 			     last_was_dle = "1"b;
     1555 			end;
     1556 
     1557 			start = dle_idx + 1;	/* "escaped" character now at dle_idx: start with next one */
     1558 
     1559 			if start > (bufferp -> buffer.tally) then
     1560 			     dle_idx = 0;		/* have reached the end of this buffer */
     1561 			else dle_idx = index (substr (buffer_text, start), DLE);
     1562 		     end;
     1563 		end;
     1564 
     1565 		return;
     1566 
     1567 	     end strip_dles;
     1568 
     1569 /* Process a real input block (not output returned by the FNP):  check for a foreign device going not-ready; validate the
     1570*   BCB; process the foreign FCS; process a bad BCB record; place input records onto the multiplexer's chain for later
     1571*   processing; notify waiting sub-channels that input has arrived */
     1572 
     1573 process_real_input_block:
     1574 	     procedure ();
     1575 
     1576 dcl  chain_to_release_ptr pointer;
     1577 dcl (expected_count, received_count, record_type, idx) fixed binary;
     1578 dcl  new_wab_bit bit (1) aligned;
     1579 
     1580 
     1581 /* FNP has detected a foreign device going not ready: save the current processing state and send a sync-block as soon as
     1582*   possible to tell the FNP that we have seen the state change and the FNP can send output to the remote system again */
     1583 
     1584 		if foreign_fcs.device_not_ready then do;
     1585 		     hmd.meters.n_wraparounds = hmd.meters.n_wraparounds + 1;
     1586 		     unspec (hmd.last_loopback_bcb) = "777"b3;
     1587 		     if hmd.minor_state = HMD_REPROCESS then /* in middle of reprocessing loopback: FNP is ... */
     1588 			call push_loopback_block_chain (); /* ... returning said reprocessed data; it goes first */
     1589 		     call push_minor_state (HMD_SEND_SYNC_BLOCK);
     1590 		end;
     1591 
     1592 
     1593 /* BCB processing:	check that the received block count in the BCB is the expected value or that the BCB specifies that
     1594*   the block count is to be ignored or reset.  If the received block count is wrong, log a message and either drop the
     1595*   line or ignore the input block depending on the size and direction of the discrepency in the count */
     1596 
     1597 		expected_count = mod (hmd.foreign_block_count + 1, 16);
     1598 		received_count = foreign_bcb.count;
     1599 
     1600 		if foreign_bcb.type = HASP_BCB_NORMAL then
     1601 		     if hmd.first_foreign_block
     1602 		     then do;			/* first foreign block:  trust the count therein */
     1603 			hmd.first_foreign_block = "0"b;
     1604 			hmd.foreign_block_count = received_count;
     1605 		     end;
     1606 		     else if received_count = expected_count then /* correct value:  remember it */
     1607 			hmd.foreign_block_count = received_count;
     1608 		     else				/* bad block count -- determine appropriate action */
     1609 		     if ((received_count < expected_count) & ((expected_count - received_count) <= 3)) |
     1610 		        ((received_count > expected_count) & ((expected_count - received_count + 16) <= 3))
     1611 		     then do;			/* duplicate block:	 log, ignore data, process FCS */
     1612 			hmd.meters.n_duplicate_input_blocks = hmd.meters.n_duplicate_input_blocks + 1;
     1613 			call syserr (LOG_ONLY,
     1614 				   "hasp_mpx (line ^a): Block received out of sequence: expected = ^d, received = ^d; block ignored.",
     1615 				   hmd.name, expected_count, received_count);
     1616 			first_bufferp -> buffer.tally = 1;  /* flush all but an RCB for end-of-block */
     1617 			first_bufferp -> buffer.chars (0) = HASP_EOB_RCB;
     1618 			last_bufferp = first_bufferp; /* this is now the only buffer in the block */
     1619 			chain_to_release_ptr = pointer (ttybp, first_bufferp -> buffer.next);
     1620 			first_bufferp -> buffer.next = 0;  /* break the chain now */
     1621 			if rel (chain_to_release_ptr) ^= ""b then    /* some data to be discarded */
     1622 			     call tty_space_man$free_chain (hmd.devx, INPUT, chain_to_release_ptr);
     1623 		     end;
     1624 		     else do;			/* out of sync:  log, queue bad BCB record and hangup */
     1625 			call syserr (LOG_AND_PRINT,
     1626 				   "hasp_mpx (line ^a): Block received out of sequence: expected = ^d, received = ^d; line will be hungup.",
     1627 				   hmd.name, expected_count, received_count);
     1628 			call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1629 			hmd.minor_state = HMD_SEND_BAD_BCB_BLOCK;
     1630 			hmd.foreign_block_count = received_count;    /* set state and save info for the block */
     1631 			hmd.local_block_count = expected_count;
     1632 			return;
     1633 		     end;
     1634 
     1635 		else if foreign_bcb.type = HASP_BCB_IGNORE
     1636 		     then;			/* ignore this block's counter */
     1637 
     1638 		else if foreign_bcb.type = HASP_BCB_RESET then
     1639 		     hmd.foreign_block_count = received_count - 1;     /* this is to be count of next block */
     1640 
     1641 
     1642 /* FCS processing:	if the foreign FCS has changed from the last input record, reflect these changes in the multiplexer's
     1643*   local state.  The FCS bits control whether output may be sent to the individual devices at the foreign site */
     1644 
     1645 		hmd.meters.n_input_blocks = hmd.meters.n_input_blocks + 1;
     1646 
     1647 		string (foreign_fcs.mcs1) = ""b;	/* remove bits possibly added by FNP */
     1648 		foreign_fcs.block_type = HASP_FCS_NORMAL_BLOCK;
     1649 
     1650 		if hmd.foreign_fcs_bytes ^= foreign_fcs_chars then do;
     1651 						/* only if the foreign FCS has been changed */
     1652 		     hmd.foreign_fcs_bytes = foreign_fcs_chars;	/* for the next time around */
     1653 
     1654 		     if foreign_fcs.system_wab & ^hmd.suspend_all_output then
     1655 			hmd.meters.n_foreign_wab_set = hmd.meters.n_foreign_wab_set + 1;
     1656 						/* foreign system just stopped taking output */
     1657 
     1658 		     hmd.suspend_all_output = foreign_fcs.system_wab;
     1659 
     1660 		     do idx = 1 to hmd.n_subchannels;
     1661 
     1662 			if hmd.subchannels(idx).direction = HSTE_INPUT_ONLY
     1663 			     then;		/* input only: never throttled by the foreign side */
     1664 
     1665 			else do;			/* output device or console */
     1666 			     if (hmd.subchannels(idx).device_wab_idx = 0) then
     1667 				new_wab_bit = foreign_fcs.console_wab;
     1668 			     else if (hmd.subchannels(idx).device_wab_idx <= 4) then
     1669 				new_wab_bit = foreign_fcs.wab_bits1 (hmd.subchannels(idx).device_wab_idx);
     1670 			     else new_wab_bit = foreign_fcs.wab_bits2 (hmd.subchannels(idx).device_wab_idx - 4);
     1671 			     if ^new_wab_bit & hmd.output_wabs (hmd.subchannels(idx).device_wab_idx) then
     1672 				hmd.subchannels(idx).meters.device_n_foreign_wab_set =
     1673 				     hmd.subchannels(idx).meters.device_n_foreign_wab_set + 1;
     1674 			     hmd.output_wabs (hmd.subchannels(idx).device_wab_idx) = new_wab_bit;
     1675 			end;
     1676 		     end;
     1677 		end;
     1678 
     1679 
     1680 /* Data processing:	 classify the first record of the data.  Check for a bad BCB record (which is a separate block) and,
     1681*   if found, log the error and hangup the line (crashing the multiplexer).  Otherwise, if data is present in the block,
     1682*   save it for subsequent processing */
     1683 
     1684 		record_type = classify_record (first_bufferp, 0); /* it starts at the first character in buffer */
     1685 
     1686 		if record_type = HASP_EOB_RECORD
     1687 		then do;				/* no data records:  status block, some devices might be able
     1688*						   to send output now, so ask everyone who's waiting */
     1689 		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1690 		     call interrupt_subchannels_with_output ();
     1691 		end;
     1692 
     1693 		else if record_type = HASP_BAD_BCB_RECORD
     1694 		then do;				/* foreign side detected out of sequence block: punt */
     1695 		     received_count = foreign_bcb.count;     /* extract the usefull information */
     1696 		     expected_count = addr (addr (first_bufferp -> buffer.chars (0)) -> based_bad_bcb_record.srcb) -> hasp_bcb_byte.count;
     1697 		     call syserr (LOG_AND_PRINT,
     1698 			        "hasp_mpx (line ^a): Block transmitted out of sequence: expected = ^d, received = ^d; line will be hungup.",
     1699 			        hmd.name, expected_count, received_count);
     1700 		     call channel_manager$control (hmd.devx, "hangup", null (), code);
     1701 		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1702 		end;
     1703 
     1704 		else do;				/* the block contains actual data:  save it for call time */
     1705 		     if hmd.input.first_bufferp = null () then
     1706 			hmd.input.first_bufferp = first_bufferp;     /* first block of unprocessed input */
     1707 		     else hmd.input.last_bufferp -> buffer.next = binary (rel (first_bufferp), 18, 0);
     1708 		     hmd.input.last_bufferp = last_bufferp;  /* this is now last buffer */
     1709 		     call interrupt_subchannels_with_output ();
     1710 		end;
     1711 
     1712 		return;
     1713 
     1714 	     end process_real_input_block;
     1715 
     1716 /* Process a sync-block (internal to process_input_block): pop the minor state if the preiovus minor state was either
     1717*   send-sync or loopback as the multiplexer was in the process of receiving returned data from the FNP when another
     1718*   foreign device went not ready; otherwise, enter the reprocess minor state to retransmit the data returned by the FNP.
     1719*   If the multiplexer was reprocessing data when this wraparound occured, splice the just returned output in front of the
     1720*   output that was being reprocessed originally as the newly returned data must be part of the older returned data */
     1721 
     1722 process_sync_block:
     1723 	     procedure ();
     1724 
     1725 dcl  previous_minor_state fixed binary;
     1726 
     1727 		call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);
     1728 						/* all done with this block */
     1729 
     1730 		if hmd.minor_state > HMD_REPROCESS then
     1731 		     return;			/* multiplexer is preparing to shutdown */
     1732 
     1733 		if hmd.minor_state_stack = null () then
     1734 		     previous_minor_state = HMD_NORMAL; /* no saved minor state? */
     1735 		else previous_minor_state = hmd.minor_state_stack -> msse.minor_state;
     1736 
     1737 		if (previous_minor_state = HMD_SEND_SYNC_BLOCK) | (previous_minor_state = HMD_LOOPBACK) then
     1738 		     call pop_minor_state ();		/* see above */
     1739 
     1740 		else do;
     1741 		     if previous_minor_state = HMD_REPROCESS then
     1742 			call pop_loopback_block_chain ();  /* merge chains */
     1743 		     hmd.reset_local_block_count = "1"b;/* force a reset BCB to be sent */
     1744 		     hmd.minor_state = HMD_REPROCESS;
     1745 		end;
     1746 
     1747 		return;
     1748 
     1749 	     end process_sync_block;
     1750 
     1751 	end process_input_block;
     1752 
     1753 /* Input records processing and loopbacked records processing */
     1754 
     1755 input_loopback_records_processor:
     1756 	procedure ();
     1757 	
     1758 	     return;				/* not an entry */
     1759 
     1760 
     1761 dcl  input_entry bit (1) aligned;			/* ON => process_input_records vs. process_loopback_records */
     1762 
     1763 dcl  saved_hste_ptr pointer;				/* -> sub-channel data of interest to caller: hste_ptr used
     1764*						   locally and must be preserved */
     1765 
     1766 dcl (start_bufferp, end_bufferp) pointer;		/* -> buffer containing start/end of the current record */
     1767 dcl (start_record_idx, end_record_idx) fixed binary;	/* index (0-based) in buffer of the current record's first and
     1768*						   last characters */
     1769 
     1770 dcl  rcb_char character (1) unaligned;			/* RCB of the current record */
     1771 dcl  srcb_char character (1) unaligned;			/* SRCB of the current record */
     1772 
     1773 dcl 1 rcb unaligned based (addr (rcb_char)) like hasp_rcb_byte;
     1774 
     1775 dcl (continue_scan, record_was_taken) bit (1) aligned;
     1776 
     1777 dcl  bufferp pointer;
     1778 dcl (record_type, record_tally, dle_count) fixed binary;
     1779 
     1780 /* Process input records:  a read call has been issued by a sub-channel and there is input data whic needs to be split
     1781*   into individual records and assigned to their appropriate sub-channels.  Also, process any RTS or RTS acknowledgement
     1782*   records amongst the records */
     1783 
     1784 process_input_records:
     1785 	entry ();
     1786 
     1787 	     input_entry = "1"b;			/* this is to process input records, not loopback records */
     1788 	     needs_space = "0"b;
     1789 
     1790 	     saved_hste_ptr = hste_ptr;		/* invoked at call time:  must not lose correct value */
     1791 
     1792 	     start_bufferp = hmd.input.first_bufferp;	/* start with the first piece of input */
     1793 	     start_record_idx = 0;
     1794 
     1795 	     continue_scan = "1"b;			/* will continue until we run out of space or input data */
     1796 
     1797 	     do while (continue_scan);
     1798 
     1799 		call find_next_record (start_bufferp, start_record_idx, "1"b, "0"b,
     1800 				   end_bufferp, end_record_idx, record_tally, (0));
     1801 
     1802 		if end_bufferp ^= null ()
     1803 		then do;
     1804 
     1805 		     record_type = classify_record (start_bufferp, start_record_idx);
     1806 
     1807 
     1808 /* Pick up the RCB and SRCB */
     1809 
     1810 		     record_tally = record_tally - 1;	/* don't count the RCB as it's not passed to user ring */
     1811 
     1812 		     rcb_char = start_bufferp -> buffer.chars (start_record_idx);
     1813 
     1814 		     if (start_record_idx < (start_bufferp -> buffer.tally - 1))
     1815 		     then				/* RCB is in middle of buffer */
     1816 			srcb_char = start_bufferp -> buffer.chars (start_record_idx + 1);
     1817 
     1818 		     else				/* RCB is last character in this buffer ... */
     1819 		     if ((start_bufferp -> buffer.next) ^= 0) & (record_tally ^= 0)
     1820 		     then do;			/* ... and more data exists in the record */
     1821 			bufferp = pointer (ttybp, start_bufferp -> buffer.next);
     1822 			srcb_char = bufferp -> buffer.chars (0);
     1823 		     end;
     1824 
     1825 		     else do;			/* ... and no more data exists in the record */
     1826 			record_type = HASP_EOB_RECORD;
     1827 			srcb_char = NUL;
     1828 		     end;
     1829 
     1830 
     1831 /* Process the record according to its type */
     1832 
     1833 		     if (record_type = HASP_DATA_RECORD) | (record_type = HASP_EOF_RECORD)
     1834 		     then do;
     1835 
     1836 /* Data records:  add the record to the input chain for the appropriate sub-channel if it can accept input.  If the device
     1837*   isn't the console and too many input records are present, request the foreign side to suspend further input */
     1838 
     1839 			hste_ptr = find_subchannel (rcb_char);	/* get the sub-channel for this record */
     1840 
     1841 			if hste_ptr ^= null () then
     1842 
     1843 			     if (hste.direction = HSTE_OUTPUT_ONLY) then
     1844 						/* output only:  flush the record */
     1845 				call flush_record_buffers ();
     1846 
     1847 			     else do;		/* input device: take the record */
     1848 				call move_record_to_device ();
     1849 				hste.meters.device_n_input_records = hste.meters.device_n_input_records + 1;
     1850 				if (record_type = HASP_EOF_RECORD) then
     1851 				     hste.meters.device_n_input_eof_records = hste.meters.device_n_input_eof_records + 1;
     1852 				if hste.input.n_records >= hmd.max_device_input_records then
     1853 				     if hste.device_type ^= HASP_CONSOLE
     1854 				     then do;
     1855 					if hmd.input_wabs (hste.device_wab_idx) then
     1856 					     hste.meters.device_n_local_wab_set = hste.meters.device_n_local_wab_set + 1;
     1857 					hmd.input_wabs (hste.device_wab_idx) = "0"b;
     1858 				     end;
     1859 			     end;
     1860 
     1861 			else do;			/* not configured:  flush record and disallow input... */
     1862 			     call flush_record_buffers ();	/* ... OK to set the bit: system WAB will not be set */
     1863 			     if (rcb.type = HASP_RCB_TYPE_READER_INPUT) | (rcb.type = HASP_RCB_TYPE_PRINT_OUTPUT) then
     1864 				hmd.input_wabs (rcb.stream) = "0"b;
     1865 			     else if (rcb.type = HASP_RCB_TYPE_PUNCH_OUTPUT) then
     1866 				hmd.input_wabs (9 - rcb.stream) = "0"b;
     1867 			end;
     1868 		     end;
     1869 
     1870 
     1871 		     else if (record_type = HASP_RTS_RECORD)
     1872 		     then do;
     1873 
     1874 /* Request-to-send record:  if the specified device is configured, queue an RTS acknowledgement record -- the
     1875*   acknowledgement is sent even though the device is not dialed up as some systems will send an RTS record, time out, and
     1876*   give up on the subchannel faster than Multics can load the multiplexer and dial-up all the subchannels */
     1877 
     1878 			hste_ptr = find_subchannel (srcb_char); /* this specified the device */
     1879 
     1880 			if hste_ptr ^= null () then
     1881 			     if (hste.direction ^= HSTE_OUTPUT_ONLY) & (hste.device_type ^= HASP_CONSOLE) then
     1882 				hmd.send_rts_ack (hste.device_wab_idx) = "1"b;
     1883 
     1884 			call flush_record_buffers ();
     1885 		     end;
     1886 
     1887 
     1888 		     else if (record_type = HASP_RTS_ACK_RECORD)
     1889 		     then do;
     1890 
     1891 /* RTS acknowledgement record:  indicate that the specific sub-channel may now send output.  If the device is waiting to
     1892*   send output, give it a SEND OUTPUT interrupt */
     1893 
     1894 			hste_ptr = find_subchannel (srcb_char);
     1895 
     1896 			if hste_ptr ^= null () then do;
     1897 			     hste.minor_state = HSTE_NORMAL;
     1898 			     if hste.holding_output then do;
     1899 				call dequeue_subchannel_for_output ();
     1900 				call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);
     1901 			     end;
     1902 			end;
     1903 
     1904 			call flush_record_buffers ();
     1905 		     end;
     1906 
     1907 		     else call flush_record_buffers (); /* end-of-block, SIGNON, others:  just flush it */
     1908 
     1909 
     1910 /* Update pointers to the next record in the block (if any) */
     1911 
     1912 		     if end_bufferp = null () then
     1913 			start_bufferp = null ();	/* record was last in chain:  don't look for next one */
     1914 
     1915 		     else if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
     1916 		     then do;			/* record ends at end of buffer:  go to next one */
     1917 			if end_bufferp -> buffer.next = 0 then
     1918 			     start_bufferp = null ();
     1919 			else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);
     1920 			start_record_idx = 0;
     1921 			call tty_space_man$free_buffer (hmd.devx, INPUT, end_bufferp);
     1922 		     end;
     1923 
     1924 		     else do;			/* more data in this buffer */
     1925 			start_bufferp = end_bufferp;
     1926 			start_record_idx = end_record_idx + 1;
     1927 		     end;
     1928 
     1929 		     hmd.meters.n_input_records = hmd.meters.n_input_records + 1;
     1930 
     1931 		     continue_scan = (start_bufferp ^= null ());
     1932 		end;
     1933 
     1934 		else continue_scan = "0"b;		/* no more complete records in the chain */
     1935 	     end;
     1936 
     1937 
     1938 RETURN_FROM_PROCESS_INPUT_RECORDS:
     1939 	     if start_bufferp ^= null () then		/* didn't process the entire chain:  return the rest */
     1940 		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
     1941 		     call delete_text (start_bufferp, 0, start_record_idx);
     1942 
     1943 	     hmd.input.first_bufferp = start_bufferp;
     1944 
     1945 	     if start_bufferp = null () then		/* got all of it */
     1946 		hmd.input.last_bufferp = null ();
     1947 
     1948 	     hmd.retry_process_input = needs_space;
     1949 	     if needs_space then			/* couldn't process it all right now */
     1950 		call tty_space_man$needs_space (hmd.devx);
     1951 
     1952 	     hste_ptr = saved_hste_ptr;		/* so caller will be happy */
     1953 
     1954 	     return;
     1955 
     1956 /* Process loopback records: called after all loopbacked output blocks have been returned by the FNP and the FNP has
     1957*   requested more output.  Process each record in the chain of loopbacked blocks by either (1) placing the record into a
     1958*   new output block if the device is not suspended or (2) placing the record onto the individual loopback chain of the
     1959*   device.  Stop processing when either (1) the new output block is full (can't include a zero length record) or (2) the
     1960*   chain of loopbacked blocks is exhausted.  Finally, transmit the newly created output block (if any) */
     1961 
     1962 process_loopback_records:
     1963 	entry ();
     1964 
     1965 	     input_entry = "0"b;			/* this is to process loopback records, not input records */
     1966 	     needs_space = "0"b;
     1967 
     1968 	     saved_hste_ptr = hste_ptr;		/* invoked at call time:  must not lose correct value */
     1969 
     1970 	     start_bufferp = hmd.loopback.first_bufferp;	/* start with the first piece of loopback */
     1971 	     start_record_idx = 0;
     1972 
     1973 	     continue_scan = ^full_output_blockp () &	/* while there's some room in the output block ... */
     1974 			 (hmd.loopback.first_bufferp ^= null ());    /* ... and something to work on */
     1975 
     1976 	     do while (continue_scan);
     1977 
     1978 		call find_next_record (start_bufferp, start_record_idx, "1"b, "1"b,
     1979 				   end_bufferp, end_record_idx, record_tally, dle_count);
     1980 
     1981 		if end_bufferp ^= null ()
     1982 		then do;
     1983 
     1984 		     record_type = classify_record (start_bufferp, start_record_idx);
     1985 
     1986 
     1987 /* Pick up the RCB and SRCB */
     1988 
     1989 		     record_tally = record_tally - 1;	/* don't count the RCB as it's not passed to user ring */
     1990 
     1991 		     rcb_char = start_bufferp -> buffer.chars (start_record_idx);
     1992 
     1993 		     if (start_record_idx < (start_bufferp -> buffer.tally - 1))
     1994 		     then				/* RCB is in middle of buffer */
     1995 			srcb_char = start_bufferp -> buffer.chars (start_record_idx + 1);
     1996 
     1997 		     else				/* RCB is last character in this buffer ... */
     1998 		     if ((start_bufferp -> buffer.next) ^= 0) & (record_tally ^= 0)
     1999 		     then do;			/* ... and more data exists in the record */
     2000 			bufferp = pointer (ttybp, start_bufferp -> buffer.next);
     2001 			srcb_char = bufferp -> buffer.chars (0);
     2002 		     end;
     2003 
     2004 		     else do;			/* ... and no more data exists in the record */
     2005 			record_type = HASP_EOB_RECORD;
     2006 			srcb_char = NUL;
     2007 		     end;
     2008 
     2009 
     2010 /* Process the record according to its type */
     2011 
     2012 		     if (record_type = HASP_DATA_RECORD) | (record_type = HASP_EOF_RECORD)
     2013 		     then do;
     2014 
     2015 /* Data records:  try to put the record in the output block being built; otherwise, hand the record back to the device for
     2016*   later processing */
     2017 
     2018 			hste_ptr = find_subchannel (rcb_char);	/* get the sub-channel for this record */
     2019 
     2020 			if hste_ptr ^= null () then
     2021 
     2022 			     if hste.direction = HSTE_INPUT_ONLY then
     2023 				call flush_record_buffers (); /* input only: couldn't have sent the record */
     2024 
     2025 			     else if hmd.output_wabs (hste.device_wab_idx) &
     2026 				   (hste.loopback.first_bufferp = null ())
     2027 			     then do;		/* device is ready and not already holding records */
     2028 				call process_single_loopback_record (start_bufferp, (start_record_idx + 1),
     2029 							       end_bufferp, end_record_idx, record_tally,
     2030 							       dle_count, record_was_taken);
     2031 				     if needs_space then /* can't do it now */
     2032 					go to RETURN_FROM_PROCESS_LOOPBACK_RECORDS;
     2033 				if record_was_taken then /* in output block now */
     2034 				     call flush_record_buffers ();
     2035 				else call move_record_to_device ();	/* try later */
     2036 			     end;
     2037 
     2038 			     else call move_record_to_device ();     /* device is suspended */
     2039 
     2040 			else call flush_record_buffers (); /* not configured: couldn't have sent it */
     2041 		     end;
     2042 
     2043 
     2044 		     else if (record_type = HASP_RTS_RECORD)
     2045 		     then do;
     2046 
     2047 /* Request-to-send record: this output sub-channel requested permission to send a file.  The actual RTS record is thrown
     2048*   away as it will be recreated; if, however, this is the first record of loopbacked output, then the sub-channel was
     2049*   previously not transmitting a file, and its state should be changed to force generation of an RTS record */
     2050 
     2051 			hste_ptr = find_subchannel (srcb_char); /* this specified the device */
     2052 
     2053 			if hste_ptr ^= null () then
     2054 			     if hste.loopback.first_bufferp = null () then
     2055 				hste.minor_state = HSTE_SEND_RTS;
     2056 
     2057 			call flush_record_buffers ();
     2058 		     end;
     2059 
     2060 
     2061 		     else if (record_type = HASP_RTS_ACK_RECORD)
     2062 		     then do;
     2063 
     2064 /* RTS acknowledgement record: this record was being sent in response to an RTS record for one of our devices.  Turn the
     2065*   appropriate bit back on so that the record will be sent again */
     2066 
     2067 			hste_ptr = find_subchannel (srcb_char);
     2068 
     2069 			if hste_ptr ^= null () then
     2070 			     hmd.send_rts_ack (hste.device_wab_idx) = "1"b;
     2071 
     2072 			call flush_record_buffers ();
     2073 		     end;
     2074 
     2075 
     2076 		     else call flush_record_buffers (); /* anything else can be ignored */
     2077 						/* SIGNON records are ignored as process_output_block will
     2078*						   rebuild them automatically */
     2079 
     2080 
     2081 /* Update pointers to the next record in the block (if any) */
     2082 
     2083 		     if end_bufferp = null () then
     2084 			start_bufferp = null ();	/* record was last in chain:  don't look for next one */
     2085 
     2086 		     else if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
     2087 		     then do;			/* record ends at end of buffer:  go to next one */
     2088 			if end_bufferp -> buffer.next = 0 then
     2089 			     start_bufferp = null ();
     2090 			else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);
     2091 			start_record_idx = 0;
     2092 			call tty_space_man$free_buffer (hmd.devx, INPUT, end_bufferp);
     2093 		     end;
     2094 
     2095 		     else do;			/* more data in this buffer */
     2096 			start_bufferp = end_bufferp;
     2097 			start_record_idx = end_record_idx + 1;
     2098 		     end;
     2099 
     2100 		     continue_scan = (start_bufferp ^= null ()) & /* something left in loopback chain ... */
     2101 			           ^full_output_blockp ();	/* ... and still room in the output block */
     2102 		end;
     2103 
     2104 		else continue_scan = "0"b;		/* no more complete records in the chain (shouldn't happen) */
     2105 	     end;
     2106 
     2107 
     2108 /* Post processing: transmit the output block if necessary and, if all loopbacked records have been processed, exit
     2109*   HMD_REPROCESS state and return to the previous state */
     2110 
     2111 RETURN_FROM_PROCESS_LOOPBACK_RECORDS:
     2112 	     if start_bufferp ^= null () then		/* didn't process the entire chain:  return the rest */
     2113 		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
     2114 		     call delete_text (start_bufferp, 0, start_record_idx);
     2115 
     2116 	     hmd.loopback.first_bufferp = start_bufferp;
     2117 
     2118 	     if start_bufferp = null () then		/* got all of it */
     2119 		hmd.loopback.last_bufferp = null ();
     2120 
     2121 	     hmd.retry_process_loopback_records = needs_space;
     2122 	     if needs_space then			/* couldn't reprocess it all now */
     2123 		call tty_space_man$needs_space (hmd.devx);
     2124 	     else call process_output_block ();		/* enough room: ship what we just built */
     2125 
     2126 	     if hmd.loopback.first_bufferp = null () then do;
     2127 		call pop_minor_state ();		/* involves much work */
     2128 		if (hmd.minor_state = HMD_NORMAL) then	/* OK for subchannels to send output again */
     2129 		     call interrupt_subchannels_with_output ();
     2130 	     end;
     2131 
     2132 	     hste_ptr = saved_hste_ptr;		/* so caller will be happy */
     2133 
     2134 	     return;
     2135 
     2136 /* Internal to input_loopback_records_processor:  find the sub-channel corresponding to the given RCB */
     2137 
     2138 find_subchannel: procedure (P_rcb_char) returns (pointer);
     2139 
     2140 dcl  P_rcb_char character (1) unaligned parameter;
     2141 
     2142 dcl  idx fixed binary;
     2143 
     2144 
     2145 		do idx = 1 to hmd.n_subchannels;
     2146 
     2147 		     if (hmd.subchannels(idx).device_type = HASP_CONSOLE) then   /* console is special case */
     2148 			if (P_rcb_char = HASP_CONSOLE_INPUT_RCB) | (P_rcb_char = HASP_CONSOLE_OUTPUT_RCB) then
     2149 			     return (addr (hmd.subchannels (idx)));
     2150 			else;			/* not the console */
     2151 
     2152 		     else if (hmd.subchannels(idx).rcb = P_rcb_char) then
     2153 			return (addr (hmd.subchannels (idx)));
     2154 		end;
     2155 
     2156 		return (null ());			/* no such sub-channel is configured */
     2157 
     2158 	     end find_subchannel;
     2159 
     2160 /* Internal to input_loopback_records_processor:  free all the buffers containing this record except for the last buffer
     2161*   as it also contains the next record */
     2162 
     2163 flush_record_buffers:
     2164 	     procedure ();
     2165 
     2166 dcl (bufferp, p) pointer;
     2167 
     2168 		bufferp = start_bufferp;
     2169 
     2170 		do while (bufferp ^= null ());
     2171 
     2172 		     if bufferp = end_bufferp then	/* never free the last buffer of the record:  caller will */
     2173 			bufferp = null ();
     2174 
     2175 		     else do;			/* some buffer in the middle of the record */
     2176 			if (bufferp -> buffer.next) = 0 then
     2177 			     p = null ();		/* last buffer:  this shouldn't occur, but ... */
     2178 			else p = pointer (ttybp, bufferp -> buffer.next);
     2179 			call tty_space_man$free_buffer (hmd.devx, INPUT, bufferp);
     2180 			bufferp = p;
     2181 		     end;
     2182 		end;
     2183 
     2184 		return;
     2185 
     2186 	     end flush_record_buffers;
     2187 
     2188 /* Internal to input_loopback_records_processor:  move the current record to the input/loopback chain of the selected
     2189*   sub-channel.  The record is, in the process, copied into new buffers of the size requested for the sub-channel */
     2190 
     2191 move_record_to_device:
     2192 	     procedure ();
     2193 
     2194 dcl 1 record_data aligned based (record_data_ptr) like hste.input;
     2195 dcl  record_data_ptr pointer;
     2196 
     2197 dcl  substring character (substr_lth) unaligned based;
     2198 dcl  substr_lth fixed binary;
     2199 
     2200 dcl (first_output_bufferp, last_output_bufferp, current_output_bufferp, current_input_bufferp, p) pointer;
     2201 dcl (buffer_size_code, n_buffers, n_words_in_last_buffer, idx, amount_to_copy, current_input_idx,
     2202      space_needed, space_left) fixed binary;
     2203 dcl  direction bit (1);
     2204 
     2205 
     2206 		if input_entry then
     2207 		     direction = INPUT;
     2208 		else direction = OUTPUT;		/* loopback records:  will be freed as output records */
     2209 
     2210 		buffer_size_code = divide (hste.dialup_info.max_buf_size, 16, 17, 0) - 1;
     2211 
     2212 		n_buffers = divide ((record_tally + max_buffer_tally (buffer_size_code) - 1),
     2213 			          max_buffer_tally (buffer_size_code), 17, 0);
     2214 
     2215 		if n_buffers = 1 then
     2216 		     first_output_bufferp = null ();	/* only one buffer:  created below */
     2217 
     2218 		else do;				/* more than 1 buffer:  all but last one are maximum size */
     2219 		     call tty_space_man$get_chain (hste.devx, (hste.dialup_info.max_buf_size), (n_buffers - 1),
     2220 					     direction, first_output_bufferp);
     2221 			if first_output_bufferp = null () then go to CANT_MOVE_RECORD_TO_DEVICE;
     2222 		     last_output_bufferp = first_output_bufferp;
     2223 		     do idx = 1 to (n_buffers - 2);	/* find the last buffer:  chase the chain to its end */
     2224 			last_output_bufferp = pointer (ttybp, last_output_bufferp -> buffer.next);
     2225 		     end;
     2226 		end;
     2227 
     2228 		n_words_in_last_buffer =		/* need a buffer big enough for remainder of record */
     2229 		     16 * divide ((record_tally - (n_buffers - 1) * max_buffer_tally (buffer_size_code)) + 67, 64, 17, 0);
     2230 
     2231 		call tty_space_man$get_buffer (hste.devx, n_words_in_last_buffer, direction, current_output_bufferp);
     2232 		     if current_output_bufferp = null () then do;
     2233 			if first_output_bufferp ^= null () then
     2234 			     call tty_space_man$free_chain (hste.devx, direction, first_output_bufferp);
     2235 			go to CANT_MOVE_RECORD_TO_DEVICE;
     2236 		     end;
     2237 
     2238 		if first_output_bufferp = null () then	/* only buffer needed */
     2239 		     first_output_bufferp = current_output_bufferp;
     2240 		else last_output_bufferp -> buffer.next = binary (rel (current_output_bufferp), 18, 0);
     2241 
     2242 		last_output_bufferp = current_output_bufferp;	/* remember both ends of the chain */
     2243 
     2244 		amount_to_copy = record_tally;	/* copy the entire record */
     2245 
     2246 		current_input_bufferp = start_bufferp;
     2247 		current_input_idx = start_record_idx + 1;    /* skip the RCB */
     2248 
     2249 		current_output_bufferp = first_output_bufferp;
     2250 
     2251 		do while (amount_to_copy > 0);
     2252 
     2253 		     space_left = max_buffer_tally (current_output_bufferp -> buffer.size_code) -
     2254 			           (current_output_bufferp -> buffer.tally);			            
     2255 		     space_needed = min ((current_input_bufferp -> buffer.tally - current_input_idx), amount_to_copy);
     2256 
     2257 		     if space_left >= space_needed then
     2258 			substr_lth = space_needed;	/* enough room for this piece of the buffer */
     2259 		     else substr_lth = space_left;	/* only copy a small piece */
     2260 
     2261 		     addr (current_output_bufferp -> buffer.chars (current_output_bufferp -> buffer.tally)) -> substring
     2262 			= addr (current_input_bufferp -> buffer.chars (current_input_idx)) -> substring;
     2263 
     2264 		     current_output_bufferp -> buffer.tally = (current_output_bufferp -> buffer.tally) + substr_lth;
     2265 		     current_input_idx = current_input_idx + substr_lth;
     2266 		     amount_to_copy = amount_to_copy - substr_lth;
     2267 
     2268 		     if (amount_to_copy > 0) & (current_input_idx = (current_input_bufferp -> buffer.tally))
     2269 		     then do;			/* used up this input buffer:  free it (if OK) and go on */
     2270 			if (current_input_bufferp -> buffer.next) = 0
     2271 			then do;			/* no more input????? */
     2272 			     p = null ();
     2273 			     amount_to_copy = 0;	/* avoid null pointer faults (sigh) */
     2274 			end;
     2275 			else p = pointer (ttybp, current_input_bufferp -> buffer.next);
     2276 			if current_input_bufferp ^= end_bufferp then
     2277 			     call tty_space_man$free_buffer (hmd.devx, INPUT, current_input_bufferp);
     2278 						/* never free the last buffer of a record */
     2279 			current_input_bufferp = p;
     2280 			current_input_idx = 0;
     2281 		     end;
     2282 
     2283 		     if (amount_to_copy > 0) &	/* if there is stuff left to copy ... */
     2284 		        ((current_output_bufferp -> buffer.tally) = 
     2285 		         max_buffer_tally (current_output_bufferp -> buffer.size_code))
     2286 		     then				/* ... and used up this output buffer:  grab next one */
     2287 		     if (current_output_bufferp -> buffer.next) = 0 then
     2288 			     amount_to_copy = 0;	/* ran out of buffer space????? */
     2289 			else current_output_bufferp = pointer (ttybp, current_output_bufferp -> buffer.next);
     2290 		end;
     2291 
     2292 		if current_output_bufferp ^= last_output_bufferp then do;
     2293 						/* didn't use the entire chain allocated */
     2294 		     p = pointer (ttybp, current_output_bufferp -> buffer.next);
     2295 		     call tty_space_man$free_chain (hste.devx, direction, p);
     2296 		     current_output_bufferp -> buffer.next = 0;
     2297 		     last_output_bufferp = current_output_bufferp;     /* new end of the chain (sigh) */
     2298 		end;
     2299 
     2300 		if input_entry then
     2301 		     record_data_ptr = addr (hste.input);    /* processing input records */
     2302 		else record_data_ptr = addr (hste.loopback);
     2303 
     2304 		last_output_bufferp -> buffer.break = "1"b;  /* end of a record */
     2305 
     2306 		if record_data.first_bufferp = null () then
     2307 		     record_data.first_bufferp = first_output_bufferp;
     2308 		else record_data.last_bufferp -> buffer.next = binary (rel (first_output_bufferp), 18, 0);
     2309 
     2310 		record_data.last_bufferp = last_output_bufferp;
     2311 
     2312 		record_data.n_records = record_data.n_records + 1;
     2313 
     2314 		return;
     2315 
     2316 
     2317 
     2318 /* Not being able to allocate buffers for the input record transfers here */
     2319 
     2320 CANT_MOVE_RECORD_TO_DEVICE:
     2321 		needs_space = "1"b;
     2322 		if input_entry then
     2323 		     go to RETURN_FROM_PROCESS_INPUT_RECORDS;
     2324 		else go to RETURN_FROM_PROCESS_LOOPBACK_RECORDS;
     2325 
     2326 	     end move_record_to_device;
     2327 
     2328 	end input_loopback_records_processor;
     2329 
     2330 /* Process an output block:  if output is not suspended, compute the new local BCB and FCS, complete the current output
     2331*   block by adding the block trailer, and start transmission of the block to the FNP.  If there is no partial block
     2332*   waiting to be sent, send a status block or a block with an RTS record or RTS acknowledgment record when necessary */
     2333 
     2334 process_output_block:
     2335 	procedure ();
     2336 
     2337 dcl  local_bcb_char character (1) unaligned;		/* the BCB ... */
     2338 dcl  local_fcs_chars character (2) unaligned;		/* ... and the FCS for this output block */
     2339 
     2340 dcl 1 local_bcb unaligned based (addr (local_bcb_char)) like hasp_bcb_byte;
     2341 dcl 1 local_fcs unaligned based (addr (local_fcs_chars)) like hasp_fcs_bytes;
     2342 
     2343 dcl  saved_hste_ptr pointer;
     2344 dcl  idx fixed binary;
     2345 
     2346 
     2347 /* Check for permission to send a block to the FNP */
     2348 
     2349 	     if hmd.output_in_progress then		/* finish what was already started */
     2350 		call transmit_output_block ();
     2351 
     2352 	     if ^hmd.send_output then return;		/* no permission: don't bother to finish building the block */
     2353 
     2354 	     if hmd.suspend_all_output &		/* remote wants us not to send anything */
     2355 	        (hmd.minor_state ^= HMD_SEND_SYNC_BLOCK) &     /* and needn't send special sync-block for FNP */
     2356 	        (hmd.minor_state ^= HMD_SEND_BAD_BCB_BLOCK) &  /* and needn't send a bad BCB error block */
     2357 	        (hmd.minor_state ^= HMD_HANGUP_LINE)	/* and needn't hangup the line to punt after fatal error */
     2358 	     then
     2359 		return;
     2360 
     2361 
     2362 	     if (hmd.minor_state = HMD_HANGUP_LINE) then
     2363 
     2364 /* Fatal error:  An error fatal to the operation of the multiplexer (eg: out of sequence input blocks) has occurred which
     2365*   needed to be acknowledged by a message from the multiplexer.  That message has been sent out to the FNP and the line
     2366*   should now be hungup which will crash the multiplexer */
     2367 
     2368 		call channel_manager$control (hmd.devx, "hangup", null (), code);
     2369 
     2370 
     2371 	     else if (hmd.minor_state = HMD_SEND_BAD_BCB_BLOCK)
     2372 	     then do;
     2373 
     2374 /* Out of sequence input block:  An input block was received which was out of sequence.  The multiplexer must now format
     2375*   and transmit a bad BCB error block to the foreign side before breaking the connection */
     2376 
     2377 		if hmd.output_block.first_bufferp ^= null ()
     2378 		then do;				/* throw out partial output block:  no need for it */
     2379 		     call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);
     2380 		     hmd.output_block.first_bufferp = null ();
     2381 		end;
     2382 
     2383 		call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);
     2384 		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2385 
     2386 		addr (buffer.chars (0)) -> based_bad_bcb_block = TEMPLATE_HASP_BAD_BCB_BLOCK;
     2387 		buffer.tally = length (string (TEMPLATE_HASP_BAD_BCB_BLOCK));
     2388 
     2389 		addr (addr (buffer.chars (0)) -> based_bad_bcb_block.bcb) -> hasp_bcb_byte.count =
     2390 		     hmd.foreign_block_count;		/* this is what was received */
     2391 
     2392 		addr (addr (buffer.chars (0)) -> based_bad_bcb_block.srcb) -> hasp_bcb_byte.count =
     2393 		     hmd.local_block_count;		/* this is what was expected */
     2394 
     2395 		hmd.output_block.tally = buffer.tally;	/* fill in information about the block */
     2396 		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = blockp;
     2397 
     2398 		hmd.minor_state = HMD_HANGUP_LINE;	/* hangup the connection after the block is transmitted */
     2399 	     end;
     2400 
     2401 
     2402 	     else if ^empty_output_blockp ()
     2403 	     then do;
     2404 
     2405 /* Have partial output block:	 compute local BCB and FCS, add the block trailer, and ship the block */
     2406 
     2407 		call compute_local_bcb_and_fcs ();
     2408 		call finish_output_block ();
     2409 	     end;
     2410 
     2411 
     2412 	     else if ((hmd.minor_state = HMD_SEND_SIGNON) | (hmd.minor_state = HMD_REPROCESS)) &
     2413 		   (hmd.signon_data_ptr ^= null ())
     2414 	     then do;
     2415 
     2416 /* No partial block and a SIGNON record needs to be transmitted: create the SIGNON record block and mark it as requiring
     2417*   an acknowledgement from the FNP; the acknowledgement from the FNP is used as the signal that the other sub-channels of
     2418*   the multiplexer may be dialed-up and normal data transfer may commence.  Checking hmd.signon_data_ptr and the minor
     2419*   state is sufficient as the minor state is changed upon transmission and the data block is not freed until the FNP
     2420*   acknowledges the message */
     2421 
     2422 		call compute_local_bcb_and_fcs ();
     2423 
     2424 		if hmd.output_block.first_bufferp ^= null () then /* we'll create our own buffers shortly */
     2425 		     call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);
     2426 
     2427 		call tty_space_man$get_buffer (hmd.devx, 32, OUTPUT, blockp);
     2428 		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2429 
     2430 		hmd.output_block.first_bufferp,	/* the only buffer in the block */
     2431 		     hmd.output_block.last_bufferp = blockp;
     2432 
     2433 		addr (buffer.chars (0)) -> based_signon_block.header = TEMPLATE_HASP_SIGNON_BLOCK.header;
     2434 		addr (buffer.chars (0)) -> based_signon_block.record = hmd.signon_data_ptr -> hmd_signon_data.record;
     2435 		hmd.output_block.tally,		/* how much just used */
     2436 		     buffer.tally = length (string (TEMPLATE_HASP_SIGNON_BLOCK.non_trailer));
     2437 		hmd.meters.n_output_records = hmd.meters.n_output_records + 1;
     2438 
     2439 		call finish_output_block ();		/* shouldn't grab another buffer... */
     2440 		addr (addr (buffer.chars (0)) -> based_block_header.fcs) -> hasp_fcs_bytes.block_type =
     2441 		     HASP_FCS_ACKNOWLEDGE_BLOCK;	/* tell us when it gets sent */
     2442 
     2443 		if hmd.minor_state = HMD_SEND_SIGNON then    /* not in loopback processing */
     2444 		     hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE;	/* ... wait for the reply */
     2445 	     end;
     2446 
     2447 
     2448 	     else if (hmd.minor_state = HMD_NORMAL)
     2449 	     then do;
     2450 
     2451 /* No partial block and multiplexer running normally: scan for any loopbacked records which couldn't be transmitted
     2452*   before (the remote device wasn't ready) but can be sent now */
     2453 
     2454 		saved_hste_ptr = hste_ptr;		/* need to use this value */
     2455 
     2456 		do idx = 1 to hmd.n_subchannels	/* check them all ... */
     2457 			while (^full_output_blockp ());    /* ... while there's still room */
     2458 		     hste_ptr = addr (hmd.subchannels (idx));
     2459 
     2460 		     if (hste.direction ^= HSTE_INPUT_ONLY) & hmd.output_wabs (hste.device_wab_idx) then
     2461 						/* it's a ready output device ... */
     2462 			if (hste.loopback.first_bufferp ^= null ())
     2463 			then do;			/* ... and it has some loopbacked data */
     2464 			     call process_subchannel_loopback_records ();
     2465 				if needs_space then /* couldn't finish */
     2466 				     go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2467 			     if (hste.loopback.first_bufferp = null ()) then do;
     2468 						/* took all of it: subchannel can send output again */
     2469 				call dequeue_subchannel_for_output ();
     2470 				call channel_manager$interrupt_later (hste.devx, SEND_OUTPUT, ""b);
     2471 			     end;
     2472 			end;
     2473 		end;
     2474 
     2475 		hste_ptr = saved_hste_ptr;		/* done with it so restore it */
     2476 
     2477 		if empty_output_blockp () then
     2478 		     go to TRY_STATUS_OR_RTS_BLOCK;	/* nothing found: try to make status, RTS, or RTS ack block */
     2479 		else do;				/* got something: done with this output block */
     2480 		     call compute_local_bcb_and_fcs ();
     2481 		     call finish_output_block ();
     2482 		end;
     2483 	     end;
     2484 
     2485 
     2486 	     else if ((hmd.minor_state = HMD_NORMAL) | (hmd.minor_state = HMD_REPROCESS)) & empty_output_blockp ()
     2487 	     then do;
     2488 
     2489 /* No partial block: create and transmit a block iff the local FCS has changed or an RTS record or an RTS acknowledgement
     2490*   record needs to be sent */
     2491 
     2492 TRY_STATUS_OR_RTS_BLOCK:
     2493 		call compute_local_bcb_and_fcs ();
     2494 
     2495 		if (hmd.local_fcs_bytes ^= local_fcs_chars) |
     2496 		   (string (hmd.send_rts) ^= ""b) | (string (hmd.send_rts_ack) ^= ""b)
     2497 		then do;
     2498 
     2499 		     if (hmd.output_block.first_bufferp = null ())
     2500 		     then do;			/* no empty block already started */
     2501 
     2502 			call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);
     2503 			     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2504 
     2505 			hmd.output_block.first_bufferp,	/* the only buffer in the block */
     2506 			     hmd.output_block.last_bufferp = blockp;
     2507 
     2508 			addr (buffer.chars (0)) -> based_block_header = TEMPLATE_HASP_BLOCK_HEADER;
     2509 			hmd.output_block.tally,
     2510 			     buffer.tally = length (string (TEMPLATE_HASP_BLOCK_HEADER));
     2511 		     end;
     2512 
     2513 		     call add_rts_or_rts_ack_record ();
     2514 		     call finish_output_block ();
     2515 		end;
     2516 	     end;
     2517 
     2518 
     2519 	     else if (hmd.minor_state = HMD_SEND_SYNC_BLOCK)
     2520 	     then do;
     2521 
     2522 /* Starting a loopback:  the FNP detected (from the FCS received in an input block) that one of the foreign devices just
     2523*   went not-ready.  It is possible that the FNP has (or is receiving) one or more output blocks containing records for
     2524*   that device.  Thus, the FNP has entered "loopback" state wherein it will return all output blocks it has or we send it
     2525*   until it returns the specially formatted block known as a sync-block */
     2526 
     2527 		call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);
     2528 		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2529 
     2530 		addr (buffer.chars (0)) -> based_sync_block = TEMPLATE_HASP_SYNC_BLOCK;
     2531 		buffer.tally = length (string (TEMPLATE_HASP_SYNC_BLOCK));
     2532 
     2533 		hmd.output_block.tally = buffer.tally;	/* fill in information about the block */
     2534 		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = blockp;
     2535 
     2536 		hmd.minor_state = HMD_LOOPBACK;	/* multiplexer now expects output blocks to be returned */
     2537 	     end;
     2538 
     2539 
     2540 	     else if (hmd.minor_state = HMD_LOOPBACK) then
     2541 		return;				/* already in loopback (see above):  send no output */
     2542 
     2543 	     else if (hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE) then
     2544 		return;				/* waiting for response from foreign system to SIGNON */
     2545 
     2546 
     2547 /* Begin transmission of the output block to the FNP and, if the multiplexer is not in an exceptional state, request all
     2548*   waiting sub-channels to send more output */
     2549 
     2550 	     if ^empty_output_blockp () then do;	/* tests at entry guarentee that no output is in progress */
     2551 		hmd.meters.n_output_blocks = hmd.meters.n_output_blocks + 1;
     2552 		hmd.output_chain_ptr = hmd.output_block.first_bufferp;
     2553 
     2554 		hmd.output_block.tally = 0;		/* "empty" the output block for next time around */
     2555 		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();
     2556 
     2557 		if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
     2558 		     call trace_block (hmd.output_chain_ptr, OUTPUT);
     2559 
     2560 		call transmit_output_block ();	/* send it */
     2561 
     2562 		if hmd.minor_state = HMD_NORMAL then	/* all is well:  can accept more output */
     2563 		     call interrupt_subchannels_with_output ();
     2564 	     end;
     2565 
     2566 	     hmd.retry_process_output = "0"b;		/* didn't run out of tty_buf space */
     2567 
     2568 	     return;
     2569 
     2570 
     2571 /* Not being able to allocate a buffer transfers here:  queue a request to be informed when space is available */
     2572 
     2573 CANT_FINISH_PROCESS_OUTPUT_BLOCK:
     2574 	     hmd.retry_process_output = "1"b;
     2575 	     call tty_space_man$needs_space (hmd.devx);
     2576 	     return;
     2577 
     2578 /* Internal to process_output_block:  compute the local BCB and FCS for the next block to be transmitted */
     2579 
     2580 compute_local_bcb_and_fcs:
     2581 	     procedure ();
     2582 
     2583 dcl  idx fixed binary;
     2584 
     2585 /* Construct the BCB:  get the next block number (modulo 16) from the previous block count unless requested to reset
     2586*   the counter; when resetting, the counter is always set to zero */
     2587 
     2588 		local_bcb_char = NUL;
     2589 		local_bcb.mbo1 = "1"b;		/* make it not be an EBCDIC control character */
     2590 
     2591 		if hmd.reset_local_block_count then	/* reset count to zero: local_bcb.count is already zero */
     2592 		     local_bcb.type = HASP_BCB_RESET;
     2593 		else do;
     2594 		     local_bcb.type = HASP_BCB_NORMAL;
     2595 		     local_bcb.count = mod (hmd.local_block_count + 1, 16);
     2596 		end;
     2597 
     2598 
     2599 /* Construct the FCS:  examine all the input wait-a-bits.  If the wait-a-bit for any individual device is off (not-ready),
     2600*   and the configuration data of the multiplexer specifies suspend_all_mode, turn the system wait-a-bit on also as foreign
     2601*   side does not interpret the individual device wait-a-bits */
     2602 
     2603 		local_fcs_chars = copy (NUL, 2);
     2604 		local_fcs.mbo1,
     2605 		     local_fcs.mbo2 = "1"b;
     2606 
     2607 		if hmd.suspend_all_input then		/* if the multiplexer isn't ready yet:  indicate no input */
     2608 		     local_fcs.system_wab = "1"b;
     2609 
     2610 		string (local_fcs.wab_bits1),		/* all devices not ready: insures that wait-a-bits for ... */
     2611 		     string (local_fcs.wab_bits2) = ""b;     /* ... devices that aren't used or dialed-up are OFF */
     2612 		local_fcs.console_wab = "0"b;
     2613 
     2614 		do idx = 1 to hmd.n_subchannels;
     2615 
     2616 		     if (hmd.subchannels(idx).direction = HSTE_OUTPUT_ONLY)
     2617 			then;			/* this device can't accept any input at all */
     2618 
     2619 		     else if (hmd.subchannels(idx).state = HSTE_DIALED) then
     2620 						/* this device is dialed up:  set wait-a-bit as desired */
     2621 			if hmd.input_wabs (hmd.subchannels(idx).device_wab_idx) then
     2622 						/* device is ready:  set appropriate bit */
     2623 			     if (hmd.subchannels(idx).device_wab_idx = 0) then
     2624 				local_fcs.console_wab = "1"b;
     2625 			     else if (hmd.subchannels(idx).device_wab_idx <= 4) then
     2626 				local_fcs.wab_bits1 (hmd.subchannels(idx).device_wab_idx) = "1"b;
     2627 			     else local_fcs.wab_bits2 (hmd.subchannels(idx).device_wab_idx-4) = "1"b;
     2628 
     2629 			else			/* device is not ready:  appropriate bit is already off ... */
     2630 			if hmd.suspend_all_mode then	/* ... but foreign side only interprets system wait-a-bit */
     2631 			     local_fcs.system_wab = "1"b;
     2632 		end;
     2633 
     2634 		return;
     2635 
     2636 	     end compute_local_bcb_and_fcs;
     2637 
     2638 /* Internal to process_output_block:  complete the current output block by adding the block trailer, entering the already
     2639*   computed BCB and FCS into the block, and updating the local state of the multiplexer to reflect shipment of this block
     2640*   */
     2641 
     2642 finish_output_block:
     2643 	     procedure ();
     2644 
     2645 dcl 1 hmd_local_fcs unaligned based (addr (hmd.local_fcs_bytes)) like hasp_fcs_bytes;
     2646 
     2647 dcl 1 based_split_block_trailer aligned based,
     2648     2 part1 character (space_left_in_buffer) unaligned,
     2649     2 part2 character (amount_needed - space_left_in_buffer) unaligned;
     2650 
     2651 dcl  based_part1 character (space_left_in_buffer) unaligned based;
     2652 dcl  based_part2 character (amount_needed - space_left_in_buffer) unaligned based;
     2653 
     2654 dcl (bufferp, new_bufferp) pointer;
     2655 dcl (space_left_in_buffer, amount_needed, saved_tally) fixed binary;
     2656 
     2657 
     2658 		bufferp = hmd.output_block.last_bufferp;
     2659 
     2660 		space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code) - (bufferp -> buffer.tally);
     2661 		amount_needed = length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));
     2662 
     2663 		if space_left_in_buffer >= amount_needed
     2664 		then do;				/* trailer fits neatly into this block */
     2665 		     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_block_trailer.non_crc =
     2666 			     TEMPLATE_HASP_BLOCK_TRAILER.non_crc;
     2667 		     bufferp -> buffer.tally = (bufferp -> buffer.tally) +
     2668 					  length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));
     2669 		end;
     2670 
     2671 		else do;				/* must be split into two parts */
     2672 		     saved_tally = bufferp -> buffer.tally;	/* in case tsm$get_buffer fails ... */
     2673 		     if space_left_in_buffer > 0 then do;
     2674 			addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_part1 =
     2675 				addr (TEMPLATE_HASP_BLOCK_TRAILER.non_crc) -> based_split_block_trailer.part1;
     2676 			bufferp -> buffer.tally = max_buffer_tally (bufferp -> buffer.size_code);
     2677 		     end;
     2678 		     call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, new_bufferp);
     2679 			if new_bufferp = null () then do;
     2680 			     bufferp -> buffer.tally = saved_tally;
     2681 			     go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;
     2682 			end;
     2683 		     addr (new_bufferp -> buffer.chars (0)) -> based_part2 =
     2684 			     addr (TEMPLATE_HASP_BLOCK_TRAILER.non_crc) -> based_split_block_trailer.part2;
     2685 		     new_bufferp -> buffer.tally = amount_needed - space_left_in_buffer;
     2686 		     bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);
     2687 		     hmd.output_block.last_bufferp = new_bufferp;
     2688 		end;
     2689 
     2690 		hmd.output_block.tally = hmd.output_block.tally +
     2691 				      length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));
     2692 
     2693 		addr (hmd.output_block.first_bufferp -> buffer.chars (0)) -> based_block_header.bcb = local_bcb_char;
     2694 		addr (hmd.output_block.first_bufferp -> buffer.chars (0)) -> based_block_header.fcs = local_fcs_chars;
     2695 
     2696 		if hmd.reset_local_block_count
     2697 		then do;				/* this block indicates next block will be #0 */
     2698 		     hmd.reset_local_block_count = "0"b;
     2699 		     hmd.local_block_count = -1;
     2700 		end;
     2701 		else hmd.local_block_count = local_bcb.count;
     2702 
     2703 		if local_fcs.system_wab & ^hmd_local_fcs.system_wab then	/* stopped taking input */
     2704 		     hmd.meters.n_local_wab_set = hmd.meters.n_local_wab_set + 1;
     2705 
     2706 		hmd.local_fcs_bytes = local_fcs_chars;	/* save BCB and FCS for next time around */
     2707 
     2708 		return;
     2709 
     2710 	     end finish_output_block;
     2711 
     2712 /* Internal to process_output_block:  add an RTS or RTS acknowledgement record to the output block.  This procedure is
     2713*   never called unless the current output block would be empty; only one record is added */
     2714 
     2715 add_rts_or_rts_ack_record:
     2716 	     procedure ();
     2717 
     2718 dcl  p pointer;
     2719 dcl  idx fixed binary;
     2720 
     2721 
     2722 		do idx = 1 to hmd.n_subchannels;	/* go by subchannel in order to have the RCB */
     2723 
     2724 		      if (hmd.subchannels(idx).direction ^= HSTE_INPUT_ONLY) & (idx ^= hmd.console_hste_idx)
     2725 			then if hmd.send_rts (hmd.subchannels(idx).device_wab_idx)
     2726 			     then do;
     2727 
     2728 /* An output device needs to request permission to send a file:  add an RTS record (guarenteed to be room) */
     2729 
     2730 				hmd.meters.n_output_records = hmd.meters.n_output_records + 1;
     2731 
     2732 				p = hmd.output_block.last_bufferp;
     2733 
     2734 				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_record =
     2735 					TEMPLATE_HASP_RTS_RECORD;
     2736 
     2737 				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_record.srcb =
     2738 					hmd.subchannels(idx).rcb;
     2739 
     2740 				p -> buffer.tally = (p -> buffer.tally) +
     2741 						 length (string (TEMPLATE_HASP_RTS_RECORD));
     2742 				hmd.output_block.tally = hmd.output_block.tally +
     2743 						      length (string (TEMPLATE_HASP_RTS_RECORD));
     2744 
     2745 				hmd.send_rts (hmd.subchannels(idx).device_wab_idx) = "0"b;
     2746 				hmd.subchannels(idx).minor_state = HSTE_WAIT_RTS_ACK;
     2747 				go to NO_MORE_RECORDS;   /* only one records goes in this block */
     2748 			     end;
     2749 
     2750 			     else;		/* sub-channel doesn't need an RTS record */
     2751 
     2752 
     2753 		     else if (hmd.subchannels(idx).direction ^= HSTE_OUTPUT_ONLY)
     2754 			then if hmd.send_rts_ack (hmd.subchannels(idx).device_wab_idx)
     2755 			     then do;
     2756 
     2757 /* Foreign side has requested permission to send a file for a given device:  add an RTS acknowledgement record */
     2758 
     2759 				hmd.meters.n_output_records = hmd.meters.n_output_records + 1;
     2760 
     2761 				p = hmd.output_block.last_bufferp;
     2762 
     2763 				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_ack_record =
     2764 					TEMPLATE_HASP_RTS_ACK_RECORD;
     2765 
     2766 				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_ack_record.srcb =
     2767 					hmd.subchannels(idx).rcb;
     2768 
     2769 				p -> buffer.tally = (p -> buffer.tally) +
     2770 						 length (string (TEMPLATE_HASP_RTS_ACK_RECORD));
     2771 				hmd.output_block.tally = hmd.output_block.tally +
     2772 						      length (string (TEMPLATE_HASP_RTS_ACK_RECORD));
     2773 
     2774 				hmd.send_rts_ack (hmd.subchannels(idx).device_wab_idx) = "0"b;
     2775 				go to NO_MORE_RECORDS;   /* only one record goes in this block */
     2776 			     end;
     2777 
     2778 			     else;		/* sub-channel doesn't want an RTS acknowledgement record */
     2779 		end;
     2780 
     2781 NO_MORE_RECORDS:	return;
     2782 
     2783 	     end add_rts_or_rts_ack_record;
     2784 
     2785 	end process_output_block;
     2786 
     2787 /* Output records processing */
     2788 
     2789 output_records_processor:
     2790 	procedure ();
     2791 
     2792 RETURN_FROM_CALLER:					/* not an entry */
     2793 	     return;
     2794 
     2795 
     2796 /* Parameters */
     2797 
     2798 dcl (P_start_bufferp, P_end_bufferp) pointer parameter;	/* process_single_loopback_record: -> the record */
     2799 dcl ( P_start_record_idx, P_end_record_idx) fixed binary parameter;	/* ... */
     2800 dcl  P_record_tally fixed binary parameter;		/* process_single_loopback_record: length of the record */
     2801 dcl  P_dle_count fixed binary parameter;		/* process_single_loopback_record: # of DLEs in record */
     2802 dcl  P_record_was_taken bit (1) aligned parameter;	/* process_single_loopback_record: set ON => record was put
     2803*									     into the output block */
     2804 
     2805 
     2806 /* Remaining declarations */
     2807 
     2808 dcl  loopback_entry bit (1) aligned;			/* ON => process_single_loopback_record;
     2809*						   OFF => process_output_records */
     2810 
     2811 dcl 1 saved_output_block aligned like hmd.output_block;	/* for recovery from running out of space */
     2812 dcl  saved_last_tally fixed binary;
     2813 
     2814 dcl (start_bufferp, end_bufferp) pointer;		/* -> buffer containing start and end of a record */
     2815 dcl (start_record_idx, end_record_idx) fixed binary;	/* index (0-based) in those buffers of first and last chars */
     2816 
     2817 dcl  continue_scan bit (1) aligned;			/* ON => continue scanning output records */
     2818 
     2819 dcl (bufferp, p) pointer;
     2820 
     2821 dcl (record_type, record_tally, dle_count, first_idx, last_idx) fixed binary;
     2822 
     2823 /* Process output records:  scan the supplied chain for complete records and add them to the output block presently being
     2824*   built until (1) there are no more complete records in the chain, (2) there is no room in the output block to add the
     2825*   record, (3) an end-of-file record is placed into the block and this device must request permission to send the next
     2826*   file, or (4) a record is found which is simply too large to place into an output block */
     2827 
     2828 process_output_records:
     2829 	entry ();
     2830 
     2831 	     loopback_entry = "0"b;
     2832 	     needs_space = "0"b;
     2833 
     2834 	     if cant_accept_records_from_this_device () then
     2835 		return;				/* records from this device can't be put into current block */
     2836 
     2837 
     2838 /* Records may be placed into this output block:  put as many completed records as will fit into the block */
     2839 
     2840 	     start_bufferp = chain_ptr;		/* start with first character in the chain */
     2841 	     start_record_idx = 0;
     2842 
     2843 	     continue_scan = "1"b;			/* until there is a reason to stop */
     2844 
     2845 	     do while (continue_scan);
     2846 
     2847 		call find_next_record (start_bufferp, start_record_idx, "0"b, "1"b,
     2848 				   end_bufferp, end_record_idx, record_tally, dle_count);
     2849 
     2850 		if end_bufferp ^= null ()
     2851 		then do;				/* found a record:	process it */
     2852 
     2853 		     record_tally = record_tally + dle_count + 1; /* the RCB and transparency */
     2854 
     2855 		     if ^space_in_empty_output_block_for_recordp (record_tally)
     2856 		     then do;			/* record is too long to fit into a buffer ... */
     2857 			continue_scan = "0"b;	/* ... stop processing now ... */
     2858 			long_record = "1"b;		/* ... and return error code to user ring */
     2859 		     end;
     2860 
     2861 		     else if space_in_output_block_for_recordp (record_tally)
     2862 		     then do;			/* the record will fit into this block */
     2863 			call move_record_to_output_block ("1"b);
     2864 			hmd.meters.n_output_records = hmd.meters.n_output_records + 1;
     2865 			hste.meters.device_n_output_records = hste.meters.device_n_output_records + 1;
     2866 			if record_type = HASP_EOF_RECORD then	/* set by move_record_to_output_block ... */
     2867 			     hste.meters.device_n_output_eof_records = hste.meters.device_n_output_eof_records + 1;
     2868 
     2869 			if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
     2870 			then do;			/* record ends at end of buffer, go to next one */
     2871 			     if end_bufferp -> buffer.next = 0 then
     2872 				start_bufferp = null ();
     2873 			     else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);
     2874 			     start_record_idx = 0;
     2875 			     call tty_space_man$free_buffer (hste.devx, OUTPUT, end_bufferp);
     2876 			end;
     2877 			else do;			/* more data in this buffer, examine it */
     2878 			     start_bufferp = end_bufferp;
     2879 			     start_record_idx = end_record_idx + 1;
     2880 			end;
     2881 
     2882 			continue_scan = (start_bufferp ^= null ()) &	/* must be more data ... */
     2883 				      (hste.minor_state = HSTE_NORMAL); /* ... and must be OK to send more */
     2884 		     end;
     2885 
     2886 		     else continue_scan = "0"b;	/* no room in output block for this record */
     2887 		end;
     2888 
     2889 		else do;				/* no more complete records ... */
     2890 		     continue_scan = "0"b;		/* ... stop processing now ... */
     2891 		     if ^space_in_empty_output_block_for_recordp ((record_tally + dle_count + 1)) then
     2892 			long_record = "1"b;		/* ... but it will never fit even when complete */
     2893 		     else partial_record = "1"b;	/* ... and ask user ring for more */
     2894 		end;
     2895 	     end;
     2896 
     2897 
     2898 RETURN_FROM_PROCESS_OUTPUT_RECORDS:
     2899 	     if start_bufferp ^= null () then		/* didn't process entire chain:  return the rest */
     2900 		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
     2901 		     call delete_text (start_bufferp, 0, start_record_idx);
     2902 
     2903 	     chain_ptr = start_bufferp;		/* this is untouched data */
     2904 
     2905 	     return;
     2906 
     2907 /* Process a single loopbacked data/EOF record: place the record into the current output block if there is room and the
     2908*   record would normally be permitted in this block */
     2909 
     2910 process_single_loopback_record:
     2911 	entry (P_start_bufferp, P_start_record_idx, P_end_bufferp, P_end_record_idx, P_record_tally, P_dle_count,
     2912 	       P_record_was_taken);
     2913 
     2914 	     start_bufferp = P_start_bufferp;		/* copy parameters */
     2915 	     start_record_idx = P_start_record_idx;
     2916 	     end_bufferp = P_end_bufferp;
     2917 	     end_record_idx = P_end_record_idx;
     2918 	     record_tally = P_record_tally + P_dle_count + 1;  /* include the RCB */
     2919 
     2920 	     P_record_was_taken = "0"b;		/* assume failure */
     2921 
     2922 	     loopback_entry = "1"b;
     2923 	     needs_space = "0"b;
     2924 
     2925 	     if cant_accept_records_from_this_device () then
     2926 		return;				/* can't be put into this buffer */
     2927 
     2928 	     if (hste.minor_state ^= HSTE_NORMAL) then do;    /* can't send records quite yet */
     2929 		if (hste.minor_state = HSTE_SEND_RTS) then
     2930 		     hmd.send_rts (hste.device_wab_idx) = "1"b;
     2931 		return;
     2932 	     end;
     2933 
     2934 	     if ^space_in_output_block_for_recordp (record_tally) then
     2935 		return;				/* won't fit into this block */
     2936 
     2937 	     call move_record_to_output_block ("0"b);	/* don't free the record here */
     2938 	     P_record_was_taken = "1"b;		/* got it */
     2939 
     2940 	     return;
     2941 
     2942 /* Process records loopbacked to a subchannel: these records are present when either (1) the device for this subchannel
     2943*   was not ready when reprocessing occured or (2) it wasn't possible to retransmit all the records of this subchannel at
     2944*   reprocessing time.  Retransmit as many now as possible */
     2945 
     2946 process_subchannel_loopback_records:
     2947 	entry ();
     2948 
     2949 	     loopback_entry = "1"b;
     2950 	     needs_space = "0"b;
     2951 
     2952 	     if cant_accept_records_from_this_device () then
     2953 		return;				/* can't put them into output now */
     2954 
     2955 	     if (hste.minor_state ^= HSTE_NORMAL) then do;     /* can't send records quite yet */
     2956 		if (hste.minor_state = HSTE_SEND_RTS) then 
     2957 		     hmd.send_rts (hste.device_wab_idx) = "1"b;
     2958 		return;
     2959 	     end;
     2960 
     2961 
     2962 /* Process records: records are separated by the buffer.break flag and no buffer contains data from multiple records
     2963*   (enforced by process_loopback_records) */
     2964 
     2965 	     start_bufferp = hste.loopback.first_bufferp;
     2966 
     2967 	     continue_scan = (start_bufferp ^= null ());
     2968 
     2969 	     do while (continue_scan);
     2970 
     2971 		record_tally, dle_count = 0;
     2972 		do bufferp = start_bufferp
     2973 			   repeat (bufferp) while (bufferp ^= null ());
     2974 		     record_tally = record_tally + (bufferp -> buffer.tally) + count_dles (bufferp);
     2975 		     if (bufferp -> buffer.next = 0) | (bufferp -> buffer.break)
     2976 		     then do;			/* found end of the record */
     2977 			end_bufferp = bufferp;
     2978 			bufferp = null ();
     2979 		     end;
     2980 		     else bufferp = pointer (ttybp, bufferp -> buffer.next);
     2981 		end;
     2982 
     2983 		start_record_idx = 0;		/* uses all of each buffer */
     2984 		end_record_idx = (end_bufferp -> buffer.tally) - 1;
     2985 
     2986 		if space_in_output_block_for_recordp (record_tally)
     2987 		then do;				/* room for this record: put it in */
     2988 		     call move_record_to_output_block ("1"b);
     2989 		     hste.loopback.n_records = hste.loopback.n_records - 1;
     2990 		     if (end_bufferp -> buffer.next = 0) then
     2991 			start_bufferp = null ();	/* last loopback record */
     2992 		     else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);
     2993 		     call tty_space_man$free_buffer (hste.devx, OUTPUT, end_bufferp);
     2994 		     continue_scan = ((start_bufferp ^= null ()) &     /* still something there ... */
     2995 			           (hste.minor_state = HSTE_NORMAL));	/* ... and still OK to send records */
     2996 		end;
     2997 		     
     2998 		else continue_scan = "0"b;		/* no room anymore */
     2999 	     end;
     3000 
     3001 
     3002 /* Post processing: update hste.loopback */
     3003 
     3004 	     hste.loopback.first_bufferp = start_bufferp;
     3005 
     3006 	     if (start_bufferp = null ()) then		/* none left */
     3007 		hste.loopback.last_bufferp = null ();
     3008 
     3009 	     return;
     3010 
     3011 /* Internal to output_records_processor: determines if records from the current device can be placed into the output block
     3012*   being constructed; if an output block isn't underway, a fresh one is started.  Records for the operator's console can
     3013*   only be placed in a block that contains other console records; in multileave mode, any device (other than the console)
     3014*   can share a block with any other device (other than the console); in non-multileave mode, no device can share a block
     3015*   with other devices */
     3016 
     3017 cant_accept_records_from_this_device:
     3018 	     procedure () returns (bit (1) aligned);
     3019 
     3020 dcl accept_records bit (1) aligned;
     3021 
     3022 		accept_records = "1"b;		/* assume you can accept 'till proven otherwise */
     3023 
     3024 		if empty_output_blockp ()
     3025 		then do;				/* no output block:  clearly can add records */
     3026 		     if hmd.output_block.first_bufferp = null () then
     3027 			call start_new_output_block ();
     3028 		     if hmd.multileave_mode & (hste.device_type ^= HASP_CONSOLE) then
     3029 			hmd.output_block.subchannel_idx = -1;	/* not console and multileaving:  shared block */
     3030 		     else hmd.output_block.subchannel_idx = hste.subchannel_idx;
     3031 		end;
     3032 
     3033 		else if hmd.multileave_mode & (hste.device_type ^= HASP_CONSOLE)
     3034 		     then if (hmd.output_block.subchannel_idx = -1)
     3035 			then;			/* multileaving and not console:  only if a shared block */
     3036 		     else accept_records = "0"b;
     3037 
     3038 		else if (hmd.output_block.subchannel_idx = hste.subchannel_idx)
     3039 		     then;			/* console or not multileaving:  no shared blocks */
     3040 		else accept_records = "0"b;
     3041 
     3042 		return (^accept_records);
     3043 
     3044 
     3045 
     3046 /* Internal to cant_accept_records_from_this_device: start a new output block */
     3047 
     3048 start_new_output_block:
     3049 		procedure ();
     3050 
     3051 dcl  bufferp pointer;
     3052 
     3053 		     call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT, bufferp);
     3054 			if bufferp = null () then do;
     3055 			     needs_space = "1"b;	/* ran out of room */
     3056 			     go to RETURN_FROM_CALLER;
     3057 			end;
     3058 
     3059 		     addr (bufferp -> buffer.chars (0)) -> based_block_header = TEMPLATE_HASP_BLOCK_HEADER;
     3060 
     3061 		     hmd.output_block.tally,
     3062 			bufferp -> buffer.tally = length (string (TEMPLATE_HASP_BLOCK_HEADER));
     3063 		     hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = bufferp;
     3064 
     3065 		     return;
     3066 
     3067 		end start_new_output_block;
     3068 
     3069 	     end cant_accept_records_from_this_device;
     3070 
     3071 /* Internal to output_records_processor:  Move the current record into the output block */
     3072 
     3073 move_record_to_output_block:
     3074 	     procedure (P_free_buffers);
     3075 
     3076 dcl  P_free_buffers bit (1) aligned parameter;		/* ON => free buffers as data is moved */
     3077 
     3078 		saved_output_block = hmd.output_block;	/* in case we run out of room */
     3079 		saved_last_tally = hmd.output_block.last_bufferp -> buffer.tally;
     3080 
     3081 		if (hste.device_type = HASP_CONSOLE) then    /* console:  RCB is special cased */
     3082 		     if (hmd.type = HASP_HOST) then
     3083 			call add_to_output_block (addr (HASP_CONSOLE_OUTPUT_RCB), 1);
     3084 		     else call add_to_output_block (addr (HASP_CONSOLE_INPUT_RCB), 1);
     3085 		else call add_to_output_block (addr (hste.rcb), 1);    /* normal device */
     3086 
     3087 		bufferp = start_bufferp;
     3088 
     3089 		do while (bufferp ^= null ());
     3090 
     3091 		     if bufferp = start_bufferp then
     3092 			first_idx = start_record_idx;
     3093 		     else first_idx = 0;		/* take from beginning of the buffer */
     3094 		     if bufferp = end_bufferp then
     3095 			last_idx = end_record_idx;
     3096 		     else last_idx = bufferp -> buffer.tally - 1; /* last character in buffer */
     3097 
     3098 		     call add_to_output_block (addr (bufferp -> buffer.chars (first_idx)),
     3099 					 (last_idx - first_idx + 1));
     3100 
     3101 		     if (bufferp = end_bufferp) then
     3102 			bufferp = null ();		/* got the whole record now */
     3103 		     else bufferp = pointer (ttybp, bufferp -> buffer.next);
     3104 		end;				/* go to next buffer */
     3105 
     3106 		record_type = classify_record (saved_output_block.last_bufferp, saved_last_tally);
     3107 
     3108 		if (record_type = HASP_EOF_RECORD) &
     3109 		   (hste.device_type ^= HASP_CONSOLE) & hmd.rts_mode then
     3110 		     hste.minor_state = HSTE_SEND_RTS;	/* reached EOF on device that must ask to send */
     3111 
     3112 		if P_free_buffers then		/* caller asked us to free the record's buffers ... */
     3113 		     do bufferp = start_bufferp	/* ... but not the last buffer which the caller will handle */
     3114 			        repeat (p) while (bufferp ^= end_bufferp);
     3115 			p = pointer (ttybp, bufferp -> buffer.next);
     3116 			call tty_space_man$free_buffer (hste.devx, OUTPUT, bufferp);
     3117 		     end;
     3118 
     3119 		return;
     3120 
     3121 /* Internal to move_record_to_output_block:  Add a string to the current output block, doubling any DLEs present in
     3122*   the string */
     3123 
     3124 add_to_output_block:
     3125 		procedure (P_text_ptr, P_text_lth);
     3126 
     3127 dcl  P_text_ptr pointer parameter;
     3128 dcl  P_text_lth fixed binary parameter;
     3129 
     3130 dcl  text character (text_lth) unaligned based (text_ptr);
     3131 dcl  text_ptr pointer;
     3132 dcl  text_lth fixed binary;
     3133 
     3134 dcl  based_substring character (substr_lth) unaligned based;
     3135 dcl  based_buffer_remainder character (space_left_in_buffer) unaligned based;
     3136 dcl  based_character character (1) unaligned based;
     3137 
     3138 dcl (bufferp, new_bufferp) pointer;
     3139 dcl (start, substr_lth, space_left_in_buffer) fixed binary;
     3140 dcl  add_dle bit (1) aligned;
     3141 
     3142 
     3143 		     text_ptr = P_text_ptr;
     3144 		     text_lth = P_text_lth;
     3145 
     3146 		     bufferp = hmd.output_block.last_bufferp;
     3147 
     3148 		     start = 1;			/* start from beginning of the text (obviously) */
     3149 
     3150 		     do while (start <= text_lth);
     3151 
     3152 			space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code)
     3153 							  - (bufferp -> buffer.tally);
     3154 
     3155 			substr_lth = index (substr (text, start), DLE);
     3156 						/* find next character requiring transparency */
     3157 			if substr_lth ^= 0 then
     3158 			     add_dle = "1"b;
     3159 			else do;			/* no special characters left:  take the rest */
     3160 			     substr_lth = text_lth - start + 1;
     3161 			     add_dle = "0"b;
     3162 			end;
     3163 
     3164 			do while (space_left_in_buffer < substr_lth);
     3165 			     if space_left_in_buffer > 0 then do;
     3166 				addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_buffer_remainder
     3167 				     = substr (text, start, space_left_in_buffer);
     3168 				bufferp -> buffer.tally = max_buffer_tally (bufferp -> buffer.size_code);
     3169 				start = start + space_left_in_buffer;
     3170 				substr_lth = substr_lth - space_left_in_buffer;
     3171 			     end;
     3172 			     call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT,
     3173 						      new_bufferp);
     3174 				if new_bufferp = null () then go to NO_MORE_ROOM;
     3175 			     bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);
     3176 			     hmd.output_block.last_bufferp, bufferp = new_bufferp;
     3177 			     space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code);
     3178 			end;
     3179 
     3180 			if substr_lth ^= 0 then do;	/* something left over from above loop */
     3181 			     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_substring =
     3182 				     substr (text, start, substr_lth);
     3183 			     bufferp -> buffer.tally = (bufferp -> buffer.tally) + substr_lth;
     3184 			     start = start + substr_lth;
     3185 			end;
     3186 
     3187 			if add_dle then do;		/* need to insert a DLE */
     3188 			     if (bufferp -> buffer.tally) = max_buffer_tally (bufferp -> buffer.size_code)
     3189 			     then do;		/* no room for it in this buffer, get another */
     3190 				call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT,
     3191 							 new_bufferp);
     3192 				     if new_bufferp = null () then go to NO_MORE_ROOM;
     3193 				bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);
     3194 				hmd.output_block.last_bufferp, bufferp = new_bufferp;
     3195 			     end;
     3196 			     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_character = DLE;
     3197 			     bufferp -> buffer.tally = (bufferp -> buffer.tally) + 1;
     3198 			     hmd.output_block.tally = hmd.output_block.tally + 1;
     3199 			end;
     3200 		     end;
     3201 
     3202 		     hmd.output_block.tally = hmd.output_block.tally + text_lth;
     3203 						/* the string has been added: DLEs added were counted above */
     3204 
     3205 		     return;
     3206 
     3207 
     3208 /* Not being able to allocate a buffer transfers here:  revert the output block to the state it was in before starting to
     3209*   add this record and abort the call to process_output_records */
     3210 
     3211 NO_MORE_ROOM:	     hmd.output_block = saved_output_block;
     3212 		     hmd.output_block.last_bufferp -> buffer.tally = saved_last_tally;
     3213 
     3214 		     if (hmd.output_block.last_bufferp -> buffer.next) ^= 0 
     3215 		     then do;			/* free part of chain added by this aborted call */
     3216 			bufferp = pointer (ttybp, hmd.output_block.last_bufferp -> buffer.next);
     3217 			call tty_space_man$free_chain (hmd.devx, OUTPUT, bufferp);
     3218 			hmd.output_block.last_bufferp -> buffer.next = 0;
     3219 		     end;
     3220 
     3221 		     needs_space = "1"b;		/* tell the caller about it */
     3222 
     3223 		     if loopback_entry then
     3224 			go to RETURN_FROM_CALLER;	/* nothing else to do */
     3225 		     else go to RETURN_FROM_PROCESS_OUTPUT_RECORDS;
     3226 
     3227 		end add_to_output_block;
     3228 
     3229 	     end move_record_to_output_block;
     3230 
     3231 /* Internal to output_records_processor: count DLEs in a buffer for computing # of characters added to a record by
     3232*   transparency */
     3233 
     3234 count_dles:    procedure (P_bufferp) returns (fixed binary);
     3235 
     3236 dcl P_bufferp pointer parameter;
     3237 
     3238 dcl  buffer_text character (bufferp -> buffer.tally) based (addr (bufferp -> buffer.chars (0)));
     3239 
     3240 dcl  bufferp pointer;
     3241 dcl (start, idx, dle_count) fixed binary;
     3242 
     3243 
     3244 		bufferp = P_bufferp;
     3245 
     3246 		start = 1;
     3247 		idx = index (buffer_text, DLE);
     3248 
     3249 		dle_count = 0;
     3250 
     3251 		do while (idx ^= 0);
     3252 		     dle_count = dle_count + 1;
     3253 		     start = start + idx;
     3254 		     if start > (bufferp -> buffer.tally) then
     3255 			idx = 0;
     3256 		     else idx = index (substr (buffer_text, start), DLE);
     3257 		end;
     3258 
     3259 		return (dle_count);
     3260 
     3261 	     end count_dles;
     3262 
     3263 	end output_records_processor;
     3264 
     3265 /* Transmit an output block:	send output to the FNP.  If it accepts the entire block, permit another block to be
     3266*   transmitted; otherwise, wait for the next SEND OUTPUT interrupt to try to complete transmission */
     3267 
     3268 transmit_output_block:
     3269 	procedure ();
     3270 
     3271 dcl  p pointer;
     3272 
     3273 
     3274 	     if ^hmd.send_output then return;		/* no permission to send anything */
     3275 
     3276 	     if hmd.output_chain_ptr ^= null () then do;	/* something to write */
     3277 		p = hmd.output_chain_ptr;
     3278 
     3279 		call channel_manager$write (hmd.devx, p, code);
     3280 		if code = 0 then
     3281 		     hmd.retry_transmit_output = "0"b;	/* this write request won */
     3282 		else if code = et_noalloc
     3283 		     then do;			/* not enough room, try later */
     3284 			hmd.retry_transmit_output = "1"b;
     3285 			call tty_space_man$needs_space (hmd.devx);
     3286 		     end;
     3287 		     else return;			/* write failed--crash to follow? */
     3288 
     3289 		hmd.output_chain_ptr = p;		/* remember what's left */
     3290 		hmd.send_output = "0"b;		/* no longer have permission */
     3291 	     end;
     3292 
     3293 	     if hmd.output_chain_ptr = null () then
     3294 		hmd.output_in_progress = "0"b;	/* it finished--OK to send the next block */
     3295 	     else hmd.output_in_progress = "1"b;
     3296 
     3297 	     return;
     3298 
     3299 	end transmit_output_block;
     3300 
     3301 /* Perform a line-control operation and abort loading the multiplexer if it fails */
     3302 
     3303 do_line_control:
     3304 	procedure (P_line_ctl_opcode, P_line_ctl_val1, P_line_ctl_val2, P_line_ctl_val3);
     3305 
     3306 dcl (P_line_ctl_opcode, P_line_ctl_val1, P_line_ctl_val2, P_line_ctl_val3) fixed binary parameter;
     3307 
     3308 	     line_ctl.op = P_line_ctl_opcode;
     3309 
     3310 	     line_ctl.val (1) = P_line_ctl_val1;
     3311 	     line_ctl.val (2) = P_line_ctl_val2;
     3312 	     line_ctl.val (3) = P_line_ctl_val3;
     3313 
     3314 	     call channel_manager$control (hmd.devx, "line_control", addr (line_ctl), code);
     3315 
     3316 	     if code = 0 then
     3317 		return;				/* all's well that ends well */
     3318 	     else go to LOADING_FAILS;
     3319 
     3320 	end do_line_control;
     3321 
     3322 /* Interpret line status from the FNP:  A check must be made for line status interrupts generated by the multiplexer in
     3323*   order to delay some type of processing from call time to interrupt time */
     3324 
     3325 process_line_status:
     3326 	procedure ();
     3327 
     3328 	     if (line_stat.op < lbound (LINE_STATUS, 1)) | (line_stat.op > hbound (LINE_STATUS, 1)) then
     3329 		return;				/* unrecognized line status */
     3330 
     3331 	     else go to LINE_STATUS (line_stat.op);
     3332 
     3333 
     3334 LINE_STATUS (1):					/* BID FAILED -- could not complete HASP initialization */
     3335 	     if hmd.state = HMD_LOADING then do;	/* What if the multiplexer isn't loading? */
     3336 		call crash_mpx ();
     3337 		call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_DOWN, code);
     3338 	     end;
     3339 	     return;
     3340 
     3341 
     3342 LINE_STATUS (2):					/* BAD BLOCK -- we sent badly formatted block */
     3343 	     call syserr (LOG_AND_PRINT,
     3344 		        "hasp_mpx (line ^a): Bad block line status from FNP; line will be hungup.", hmd.name);
     3345 	     call channel_manager$control (hmd.devx, "hangup", null (), code);
     3346 	     return;
     3347 
     3348 
     3349 LINE_STATUS (4):					/* TOO MANY NAKS -- line has gone bad */
     3350 	     call syserr (LOG_AND_PRINT, "hasp_mpx (line ^a): Too many NAKS; line will be hungup.", hmd.name);
     3351 	     call channel_manager$control (hmd.devx, "hangup", null (), code);
     3352 	     return;
     3353 
     3354 
     3355 LINE_STATUS (6):					/* WRITE COMPLETE -- indicates a SIGNON record was sent OK */
     3356 	     if hmd.minor_state ^= HMD_WAIT_SIGNON_RESPONSE then
     3357 		return;				/* ignore spurious line statuses */
     3358 	     if hmd.signon_data_ptr ^= null () then do;	/* inform owner of the console */
     3359 		hsd_ptr = hmd.signon_data_ptr;
     3360 		call pxss$ring_0_wakeup (hmd_signon_data.processid, hmd_signon_data.event_channel, HASP_SIGNON_OK,
     3361 				     code);
     3362 		call tty_space_man$free_space (currentsize (hmd_signon_data), hsd_ptr);
     3363 		hmd.signon_data_ptr = null ();
     3364 	     end;
     3365 	     hmd.minor_state = HMD_NORMAL;		/* allow normal data transmission */
     3366 	     if (hmd.state = HMD_STARTED) then
     3367 		do idx = 1 to hmd.n_subchannels;	/* dailup any listening subchannels */
     3368 		     hste_ptr = addr (hmd.subchannels (idx));
     3369 		     if hste.state = HSTE_LISTENING then
     3370 			call signal_dialup ();
     3371 		end;
     3372 	     call interrupt_subchannels_with_output ();	/* in case console has data waiting to ship */
     3373 	     return;
     3374 
     3375 
     3376 LINE_STATUS (13):					/* HASP INIT COMPLETE -- HASP handshake done; line is up */
     3377 	     if hmd.state = HMD_LOADING then
     3378 		call load_mpx ();			/* perform necessary initialization and notify Initializer */
     3379 	     return;
     3380 
     3381 
     3382 LINE_STATUS (14):					/* HASP FOREIGN READY -- other side reset its wait-a-bit */
     3383 	     hmd.suspend_all_output = "0"b;
     3384 	     if hmd.state >= HMD_LOADED then		/* it's OK to send output blocks ... */
     3385 		if hmd.minor_state = HMD_REPROCESS then
     3386 		     call process_loopback_records ();
     3387 		else call process_output_block ();	/* ... so start sending output again */
     3388 	     return;
     3389 
     3390 LINE_STATUS (3):					/* REVERSE INTERRUPT -- ignored */
     3391 LINE_STATUS (5):					/* FNP WRITE STATUS -- ignored */
     3392 LINE_STATUS (7):  LINE_STATUS (8):  LINE_STATUS (9):	/* IBM 3270 line status codes -- ignored */
     3393 LINE_STATUS (10):  LINE_STATUS (11): LINE_STATUS (12):
     3394 	     return;
     3395 
     3396 	end process_line_status;
     3397 
     3398 /* Process a SPACE AVAILABLE interrupt:	 Check each of the conditions that could have caused a wait for the interrupt
     3399*   and process them appropriately */
     3400 
     3401 process_space_available:
     3402 	procedure ();
     3403 
     3404 	     if hmd.retry_transmit_output then do;	/* parent rejected our write request, so retry it */
     3405 		call transmit_output_block ();
     3406 		if hmd.retry_transmit_output then return;    /* still rejecting ... */
     3407 	     end;
     3408 
     3409 	     if hmd.retry_process_loopback_records then	/* wasn't enough room to process loopbacked data */
     3410 		call process_loopback_records ();	/* calls process_output_block if all OK */
     3411 
     3412 	     else if hmd.retry_process_output then	/* wasn't enough room to finish an output block */
     3413 		call process_output_block ();
     3414 
     3415 	     if hmd.retry_process_input then		/* couldn't split up input block(s) */
     3416 		call process_input_records ();
     3417 
     3418 	     call interrupt_subchannels_with_output ();
     3419 
     3420 	     return;
     3421 
     3422 	end process_space_available;
     3423 
     3424 /* Scan a chain of buffers to find the next complete HASP record */
     3425 
     3426 find_next_record:
     3427 	procedure (P_start_bufferp, P_start_record_idx, P_rcb_included, P_count_dles,
     3428 		 P_end_bufferp, P_end_record_idx, P_record_tally, P_dle_count);
     3429 
     3430 dcl  P_start_bufferp pointer parameter;			/* -> buffer where search should begin */
     3431 dcl  P_start_record_idx fixed binary parameter;		/* index (0-based) in buffer of first character to check */
     3432 dcl  P_rcb_included bit (1) aligned parameter;		/* ON => buffer already contains the record's RCB */
     3433 dcl  P_count_dles bit (1) aligned parameter;		/* ON => caller wants a count of DLEs in the record */
     3434 
     3435 dcl  P_end_bufferp pointer parameter;			/* set -> buffer containing end of record/null if none */
     3436 dcl  P_end_record_idx fixed binary parameter;		/* set to index (0-based) in buffer of last character
     3437*						   of record found (if any) */
     3438 dcl  P_record_tally fixed binary parameter;		/* set to # of characters in the record */
     3439 dcl  P_dle_count fixed binary parameter;		/* set to # of characters in record requiring transparency */
     3440 
     3441 dcl (bufferp, previous_bufferp) pointer;
     3442 dcl (record_idx, previous_record_idx, record_tally, dle_count) fixed binary;
     3443 dcl (count_dles_sw, end_of_data_is_special) bit (1) aligned;
     3444 
     3445 dcl  scb_char character (1) unaligned;
     3446 
     3447 dcl 1 scb unaligned based (addr (scb_char)) like hasp_scb_byte;
     3448 dcl 1 compressed_scb unaligned based (addr (scb_char)) like hasp_compressed_scb_byte;
     3449 dcl 1 not_compressed_scb unaligned based (addr (scb_char)) like hasp_not_compressed_scb_byte;
     3450 
     3451 
     3452 	     P_end_bufferp = null ();			/* set output for failure */
     3453 	     P_end_record_idx, P_record_tally, P_dle_count = 0;
     3454 
     3455 	     bufferp = P_start_bufferp;
     3456 	     record_idx = P_start_record_idx;
     3457 	     count_dles_sw = P_count_dles;
     3458 
     3459 	     record_tally, dle_count = 0;
     3460 
     3461 	     end_of_data_is_special = "0"b;		/* used to stop advance_pointer from failing */
     3462 
     3463 
     3464 /* If an RCB is included, check for special records:  the special records currently are the end-of-block and general
     3465*   control records (SIGNON, for example) */
     3466 
     3467 	     if P_rcb_included then
     3468 
     3469 		if (bufferp -> buffer.chars (record_idx) = HASP_EOB_RCB) then
     3470 		     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;    /* end-of-block: just the RCB, counted below */
     3471 
     3472 		else if (bufferp -> buffer.chars (record_idx) = HASP_GENERAL_CONTROL_RCB)
     3473 		then do;				/* general control record:  terminated by a NUL, which is not
     3474*						   part of the record, but is the next RCB */
     3475 		     call advance_pointer (1);	/* skip the RCB */
     3476 		     end_of_data_is_special = "1"b;
     3477 		     do while ("1"b);		/* until we win or run off the end */
     3478 			previous_bufferp = bufferp;	/* will try to find the NUL, but want previous character */
     3479 			previous_record_idx = record_idx;
     3480 			call advance_pointer (1);
     3481 			if (bufferp -> buffer.chars (record_idx) = NUL) then do;
     3482 END_OF_GENERAL_CONTROL_RECORD_SCAN: bufferp = previous_bufferp;
     3483 			     record_idx = previous_record_idx;
     3484 			     record_tally = record_tally - 1;
     3485 			     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;
     3486 			end;
     3487 		     end;
     3488 		end;
     3489 
     3490 		else call advance_pointer (2);	/* normal record:  pass over RCB and SRCB */
     3491 
     3492 	     else call advance_pointer (1);		/* skip past just an SRCB */
     3493 
     3494 
     3495 /* Scan the actual record to find the end-of-record SCB */
     3496 
     3497 	     do while ("1"b);
     3498 
     3499 		scb_char = bufferp -> buffer.chars (record_idx);
     3500 
     3501 		if scb_char = HASP_EOR_SCB then	/* have reached the end-of-record */
     3502 		     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;
     3503 
     3504 		else 				/* an ordinary SCB */
     3505 		if scb.not_compressed then
     3506 		     call advance_pointer (not_compressed_scb.count + 1);
     3507 
     3508 		else if compressed_scb.not_blank then
     3509 		     call advance_pointer (2);	/* skip the SCB and the character */
     3510 		else call advance_pointer (1);	/* skip just the SCB */
     3511 	     end;
     3512 
     3513 
     3514 /* Return:  the above loop will have set bufferp, record_idx, and dle_count correctly; however, record_tally will not have
     3515*   counted the last character of the record; do that here */
     3516 
     3517 SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD:
     3518 	     P_end_bufferp = bufferp;
     3519 	     P_end_record_idx = record_idx;
     3520 	     P_record_tally = record_tally + 1;		/* count the last character of the record */
     3521 	     P_dle_count = dle_count;
     3522 
     3523 RETURN_FROM_FIND_NEXT_RECORD:
     3524 	     return;
     3525 
     3526 /* Internal to find_next_record:  skip over the specified number of characters, counting DLEs */
     3527 
     3528 advance_pointer:
     3529 	     procedure (P_n_characters);
     3530 
     3531 dcl  P_n_characters fixed binary parameter;
     3532 
     3533 dcl (amount_left, amount_in_buffer) fixed binary;
     3534 
     3535 
     3536 		record_tally = record_tally + P_n_characters;
     3537 						/* count the characters into the record */
     3538 
     3539 		amount_left = P_n_characters;
     3540 
     3541 		do while (amount_left > 0);
     3542 
     3543 		     amount_in_buffer = (bufferp -> buffer.tally) - record_idx;
     3544 
     3545 		     if amount_in_buffer > amount_left
     3546 		     then do;			/* first character after text is in this buffer */
     3547 			dle_count = dle_count + count_dles (amount_left);
     3548 			record_idx = record_idx + amount_left;
     3549 			amount_left = 0;
     3550 		     end;
     3551 
     3552 		     else do;			/* in next buffer (maybe): count DLEs and go to next buffer */
     3553 			previously_scanned_bufferp = bufferp;
     3554 			dle_count = dle_count + count_dles (amount_in_buffer);
     3555 			amount_left = amount_left - amount_in_buffer;
     3556 			if (bufferp -> buffer.next) = 0 then	/* no next buffer:  no complete record */
     3557 			     if end_of_data_is_special then
     3558 				go to END_OF_GENERAL_CONTROL_RECORD_SCAN;
     3559 			     else do;		/* need record_tally/dle_count to check for overly long ... */
     3560 				P_record_tally = record_tally - amount_left;
     3561 				P_dle_count = dle_count; /* ... records before partial records */
     3562 				go to RETURN_FROM_FIND_NEXT_RECORD;
     3563 			     end;
     3564 			bufferp = pointer (ttybp, bufferp -> buffer.next);
     3565 			record_idx = 0;
     3566 		     end;
     3567 		end;
     3568 
     3569 		return;
     3570 
     3571 
     3572 
     3573 /* Internal to advance_pointer:  count the number of DLEs in the given piece of text */
     3574 
     3575 count_dles:	procedure (P_n_characters) returns (fixed binary);
     3576 
     3577 dcl  P_n_characters fixed binary parameter;
     3578 
     3579 dcl  text character (n_characters) unaligned based (addr (bufferp -> buffer.chars (record_idx)));
     3580 dcl (n_characters, count, start, idx) fixed binary;
     3581 
     3582 
     3583 		     if ^count_dles_sw then		/* caller doesn't need a count */
     3584 			return (0);
     3585 
     3586 		     n_characters = P_n_characters;
     3587 
     3588 		     count = 0;
     3589 
     3590 		     start = 1;
     3591 		     idx = index (text, DLE);
     3592 
     3593 		     do while (idx ^= 0);		/* while there are DLEs in the text */
     3594 			count = count + 1;
     3595 			start = start + idx;	/* skip past that DLE */
     3596 			if start > n_characters then
     3597 			     idx = 0;
     3598 			else idx = index (substr (text, start), DLE);
     3599 		     end;
     3600 
     3601 		     return (count);
     3602 
     3603 		end count_dles;
     3604 
     3605 	     end advance_pointer;
     3606 
     3607 	end find_next_record;
     3608 
     3609 /* Classify a HASP record according to its functionality */
     3610 
     3611 classify_record:
     3612 	procedure (P_bufferp, P_rcb_idx) returns (fixed binary);
     3613 
     3614 dcl  P_bufferp pointer parameter;			/* -> tty buffer containing the record */
     3615 dcl  P_rcb_idx fixed binary parameter;			/* index of RCB in the buffer (0-based) */
     3616 
     3617 dcl  bufferp pointer;
     3618 dcl  rcb_idx fixed binary;
     3619 
     3620 dcl  rcb_char character (1) unaligned;
     3621 dcl  srcb_char character (1) unaligned;
     3622 dcl  first_scb_char character (1) unaligned;
     3623 
     3624 dcl 1 rcb unaligned based (addr (rcb_char)) like hasp_rcb_byte;
     3625 
     3626 
     3627 /* Pick up the record's RCB, SRCB, and first SCB */
     3628 
     3629 	     bufferp = P_bufferp;
     3630 	     rcb_idx = P_rcb_idx;
     3631 
     3632 	     if rcb_idx < bufferp -> buffer.tally then
     3633 		rcb_char = bufferp -> buffer.chars (rcb_idx);
     3634 	     else					/* RCB is in next block (blame move_record_to_output_block) */
     3635 	     if bufferp -> buffer.next = 0 then
     3636 		return (0);			/* ... but there is no next block (?) */
     3637 	     else do;
     3638 		bufferp = pointer (ttybp, bufferp -> buffer.next);
     3639 		rcb_idx = 0;			/* ... it's the first character in this buffer */
     3640 		rcb_char = bufferp -> buffer.chars (0);
     3641 	     end;
     3642 
     3643 	     if rcb_idx < (bufferp -> buffer.tally - 1) then
     3644 		srcb_char = bufferp -> buffer.chars (rcb_idx+1);
     3645 	     else					/* SRCB not in this block, check the next one */
     3646 	     if bufferp -> buffer.next = 0 then
     3647 		srcb_char = NUL;
     3648 	     else do;
     3649 		bufferp = pointer (ttybp, bufferp -> buffer.next);
     3650 		rcb_idx = -1;			/* not in this buffer */
     3651 		srcb_char = bufferp -> buffer.chars (0);
     3652 	     end;
     3653 
     3654 	     if rcb_idx < (bufferp -> buffer.tally - 2) then
     3655 		first_scb_char = bufferp -> buffer.chars (rcb_idx+2);
     3656 	     else					/* first SCB not in this block, check the next one */
     3657 	     if bufferp -> buffer.next = 0 then
     3658 		first_scb_char = NUL;
     3659 	     else first_scb_char = pointer (ttybp, bufferp -> buffer.next) -> buffer.chars (0);
     3660 
     3661 
     3662 /* Now classify the record */
     3663 
     3664 	     if rcb.not_eob then			/* not an end-of-block */
     3665 
     3666 		if rcb.type = HASP_RCB_TYPE_CONTROL then     /* some form of control record */
     3667 
     3668 		     if rcb.stream = HASP_RCB_STREAM_RTS then
     3669 			return (HASP_RTS_RECORD);
     3670 
     3671 		     else if rcb.stream = HASP_RCB_STREAM_RTS_ACK then
     3672 			return (HASP_RTS_ACK_RECORD);
     3673 
     3674 		     else if rcb.stream = HASP_RCB_STREAM_BAD_BCB then
     3675 			return (HASP_BAD_BCB_RECORD);
     3676 
     3677 		     else if rcb.stream = HASP_RCB_STREAM_CONTROL then
     3678 			if srcb_char = HASP_SIGNON_SRCB then
     3679 			     return (HASP_SIGNON_RECORD);
     3680 			else return (0);		/* unknown type */
     3681 		     else return (0);
     3682 
     3683 		else if (srcb_char = HASP_EOF_SRCB) & (first_scb_char = HASP_EOF_FIRST_SCB) then
     3684 			return (HASP_EOF_RECORD);
     3685 
     3686 		else return (HASP_DATA_RECORD);	/* simple data record */
     3687 
     3688 	     else return (HASP_EOB_RECORD);		/* first bit off -- end of block */
     3689 
     3690 	end classify_record;
     3691 
     3692 /* Return "1"b if the current output block is empty */
     3693 
     3694 empty_output_blockp:
     3695 	procedure () returns (bit (1) aligned);
     3696 
     3697 	     if hmd.output_block.first_bufferp = null () then
     3698 		return ("1"b);			/* there is no block right now */
     3699 
     3700 	     else return (hmd.output_block.tally <= length (string (TEMPLATE_HASP_BLOCK_HEADER)));
     3701 
     3702 	end empty_output_blockp;
     3703 
     3704 
     3705 
     3706 /* Return "1"b if there is room in the current output block for a record of the given length and the block trailer */
     3707 
     3708 space_in_output_block_for_recordp:
     3709 	procedure (P_record_lth) returns (bit (1) aligned);
     3710 
     3711 dcl  P_record_lth fixed binary parameter;
     3712 
     3713 	     return				/* check that record and trailer won't overflow the block */
     3714 	       (hmd.max_block_size >=
     3715 	        (hmd.output_block.tally + P_record_lth + length (string (TEMPLATE_HASP_BLOCK_TRAILER))));
     3716 
     3717 	end space_in_output_block_for_recordp;
     3718 
     3719 
     3720 
     3721 /* Return "1"b if there is no more room left in the current output block */
     3722 
     3723 full_output_blockp:
     3724 	procedure () returns (bit (1) aligned);
     3725 
     3726 	     if empty_output_blockp () then
     3727 		return ("0"b);			/* always room in an empty block */
     3728 	     else return (^space_in_output_block_for_recordp (length (string (TEMPLATE_HASP_RTS_RECORD))));
     3729 						/* block full if smallest record possible won't fit */
     3730 
     3731 	end full_output_blockp;
     3732 
     3733 
     3734 
     3735 /* Return "1"b if there is room in an empty output block for a record of the given length */
     3736 
     3737 space_in_empty_output_block_for_recordp:
     3738 	procedure (P_record_lth) returns (bit (1) aligned);
     3739 
     3740 dcl  P_record_lth fixed binary parameter;
     3741 
     3742 	     return				/* check that header, record, and trailer fit into block */
     3743 	       (hmd.max_block_size >=
     3744 	        (P_record_lth + length (string (TEMPLATE_HASP_BLOCK_HEADER)) +
     3745 			    length (string (TEMPLATE_HASP_BLOCK_TRAILER))));
     3746 
     3747 	end space_in_empty_output_block_for_recordp;
     3748 
     3749 /* Delete characters from a buffer */
     3750 
     3751 delete_text:
     3752 	procedure (P_bufferp, P_position, P_text_lth);
     3753 
     3754 dcl  P_bufferp pointer parameter;
     3755 dcl  P_position fixed binary parameter;			/* delete characters starting with this one (0-based) */
     3756 dcl  P_text_lth fixed binary parameter;			/* # of character to delete */
     3757 
     3758 dcl  based_remainder character (remainder_lth) unaligned based;
     3759 dcl  remainder_lth fixed binary;
     3760 
     3761 
     3762 	     remainder_lth = (P_bufferp -> buffer.tally) - P_text_lth - P_position;
     3763 
     3764 	     addr (P_bufferp -> buffer.chars (P_position)) -> based_remainder =
     3765 		addr (P_bufferp -> buffer.chars (P_position+P_text_lth)) -> based_remainder;
     3766 
     3767 	     P_bufferp -> buffer.tally = (P_bufferp -> buffer.tally) - P_text_lth;
     3768 
     3769 	     return;
     3770 
     3771 	end delete_text;
     3772 
     3773 
     3774 
     3775 /* Trace an input/output block:  simply dump each buffer of the block using the MCS tracing facility */
     3776 
     3777 trace_block:
     3778 	procedure (P_first_bufferp, P_direction);
     3779 
     3780 dcl  P_first_bufferp pointer parameter;			/* -> first buffer of block to be traced */
     3781 dcl  P_direction bit (1) parameter;			/* type of block:  ON => output; OFF => input */
     3782 
     3783 	     call mcs_trace (hmd.devx, "^[Output^;Input^] chain starting at ^p:", P_direction, P_first_bufferp);
     3784 
     3785 	     call mcs_trace$buffer_chain (hmd.devx, P_first_bufferp);
     3786 
     3787 	     return;
     3788 
     3789 	end trace_block;
     3790 
  1     1 /* BEGIN INCLUDE FILE ... hasp_mpx_data.incl.pl1 */
  1     2 /* Created: September-October 1979 by G. Palter */
  1     3 /* Modified: December 1980 by G. Palter as part of "loopback bug" fix */
  1     4 /* Modified: 30 March 1981 by G. Palter to add last_loopback_bcb */
  1     5 /* Modified: 24 July 1981 by G. Palter to add hmd_signon_data, update minor states, and add metering data */
  1     6 
  1     7 
  1     8 /* HASP multiplexer data */
  1     9 
  1    10 dcl 1 hmd aligned based (hmd_ptr),
  1    11     2 name character (32) unaligned,			/* name of major channel */
  1    12     2 devx fixed binary,				/* device (LCT) index of the channel */
  1    13     2 configuration_data like hasp_configuration_data,	/* data supplied by load operation that controls multiplexer
  1    14*						   operation (EG: type, block size, etc.) */
  1    15     2 loader_process_id bit (36),			/* process to be notified on state change for multiplexer */
  1    16     2 loader_event_channel fixed binary (71),		/* ... and the channel to be used */
  1    17     2 dialup_info like dialup_info,			/* information saved from DIALUP interrupt */
  1    18     2 state fixed binary,				/* state of multiplexer -- down/loading/loaded/started */
  1    19     2 minor_state fixed binary,			/* state when running -- normal/need sync/loopback/etc. */
  1    20     2 foreign_block_count fixed binary,			/* # of last block received from foreign side */
  1    21     2 foreign_fcs_bytes character (2) unaligned,		/* last FCS received from foreign side */
  1    22     2 local_block_count fixed binary,			/* # of last block sent by multiplexer */
  1    23     2 local_fcs_bytes character (2) unaligned,		/* last FCS sent by multiplexer */
  1    24     2 subchannels_for_output,				/* a queue of sub-channels waiting SEND OUTPUT interrupts */
  1    25       3 first fixed binary,				/* ... index of first sub-channel to interrupt */
  1    26       3 last fixed binary,				/* ... index of last sub-channel */
  1    27     2 output_chain_ptr pointer,			/* -> chain of buffers presently being sent to the FNP */
  1    28     2 input,					/* chain of input blocks waiting to be split into records */
  1    29       3 first_bufferp pointer,			/* ... -> first buffer in the chain */
  1    30       3 last_bufferp pointer,				/* ... -> last buffer in the chain */
  1    31     2 loopback,					/* chain of loopbacked blocks waiting to be retransmitted */
  1    32       3 first_bufferp pointer,
  1    33       3 last_bufferp pointer,
  1    34     2 output_block,					/* the output block presently being constructed */
  1    35       3 subchannel_idx fixed binary,			/* ... sub-channel whose records are contained in this block,
  1    36*						       or -1 if this block contains records from several */
  1    37       3 tally fixed binary,				/* ... # of characters in the block */
  1    38       3 first_bufferp pointer,			/* ... -> first buffer in the block */
  1    39       3 last_bufferp pointer,				/* ... -> last buffer in the block */
  1    40     2 signon_data_ptr pointer,			/* -> data needed to send a SIGNON record */
  1    41     2 minor_state_stack pointer,			/* -> top of minor state stack */
  1    42     2 loopback_block_chain_stack pointer,		/* -> top of loopback block chain stack */
  1    43     2 last_loopback_bcb character (1) unaligned,		/* BCB character of last block loopbacked from FNP */
  1    44     2 pad bit (27) unaligned,
  1    45     2 bit_arrays aligned,
  1    46       3 input_wabs (0:8) bit (1) unaligned,		/* input wait-a-bits:  OFF => input device not ready; foreign
  1    47*						    side should not send further data */
  1    48       3 output_wabs (0:8) bit (1) unaligned,		/* output wait-a-bits:  OFF => output device not ready;
  1    49*						   multiplexer should not send further data */
  1    50       3 send_rts (0:8) bit (1) unaligned,		/* ON => an RTS record should be sent */
  1    51       3 send_rts_ack (0:8) bit (1) unaligned,		/* ON => an RTS acknowledgement record should be sent */
  1    52     2 flags aligned,
  1    53       3 suspend_all_output bit (1) unaligned,		/* ON => don't send any output at all to foreign side */
  1    54       3 suspend_all_input bit (1) unaligned,		/* ON => foreign side should send no input:  this flag is only
  1    55*						   set while multiplexer is loaded but not started */
  1    56       3 send_output bit (1) unaligned,			/* ON => have permission to send data to FNP */
  1    57       3 input_available bit (1) unaligned,		/* ON => input is being held for us by our parent */
  1    58       3 output_in_progress bit (1) unaligned,		/* ON => a data block is being sent to the FNP */
  1    59       3 first_foreign_block bit (1) unaligned,		/* ON => first block yet to arrive from foreign side; when it
  1    60*						   does, accept it's block count without question */
  1    61       3 reset_local_block_count bit (1) unaligned,	/* ON => set local block count to known value in next block */
  1    62       3 retry_transmit_output bit (1) unaligned,		/* ON => write to the parent failed: lack of room */
  1    63       3 retry_process_output bit (1) unaligned,		/* ON => call to process_output_block failed: lack of room */
  1    64       3 retry_process_loopback_records bit (1) unaligned,	/* ON => call to process_loopback_records failed: no room */
  1    65       3 retry_process_input bit (1) unaligned,		/* ON => call to process_input_block failed: lack of room */
  1    66       3 pad bit (25) unaligned,
  1    67     2 time_mpx_booted fixed binary (71),		/* date/time when multiplexer completed loading */
  1    68     2 time_meters_copied fixed binary (71),		/* date/time multiplexer meters were last saved */
  1    69     2 meters like hasp_mpx_meters,			/* interesting events */
  1    70     2 saved_meters_ptr pointer,			/* -> hasp_mpx_meters structure for copy_meters order */
  1    71     2 console_hste_idx fixed binary,			/* index of sub-channel data for operator's console */
  1    72     2 n_subchannels fixed binary,			/* # of sub-channels configured in this multiplexer */
  1    73     2 subchannels (hmd_n_subchannels refer (hmd.n_subchannels)) like hste;
  1    74 
  1    75 dcl  hmd_ptr pointer;
  1    76 dcl  hmd_n_subchannels fixed binary;			/* to allocate hmd structure */
  1    77 
  1    78 dcl (HMD_DOWN		initial (1),		/* multiplexer is down */
  1    79      HMD_LOADING		initial (2),		/* multiplexer is being loaded */
  1    80      HMD_LOADED		initial (3),		/* multiplexer has been successfully loaded */
  1    81      HMD_STARTED		initial (4))		/* multiplexer has been started (will dialup sub-channels) */
  1    82 	fixed binary static options (constant);
  1    83 
  1    84 dcl (HMD_SEND_SIGNON	initial (1),		/* multiplexer waiting to transmit a SIGNON record */
  1    85      HMD_WAIT_SIGNON_RESPONSE initial (2),		/* multiplexer is waiting for remote system's response */
  1    86      HMD_NORMAL		initial (3),		/* normal data transfer */
  1    87      HMD_SEND_SYNC_BLOCK	initial (4),		/* multiplexer must send special block to FNP to cause the FNP
  1    88*						   to stop loopback process */
  1    89      HMD_LOOPBACK		initial (5),		/* FNP is returning previous output of multiplexer */
  1    90      HMD_REPROCESS		initial (6),		/* multiplexer is making initial pass over records loopbacked
  1    91*						   by FNP: records are being rewritten or saved */
  1    92      HMD_SEND_BAD_BCB_BLOCK	initial (7),		/* multiplexer must send bad BCB block on next SEND OUTPUT */
  1    93      HMD_HANGUP_LINE	initial (8))		/* multiplexer must hangup the line on next SEND OUTPUT */
  1    94 	fixed binary static options (constant);
  1    95 
  1    96 
  1    97 /* HASP sub-channel data */
  1    98 
  1    99 dcl 1 hste aligned based (hste_ptr),
  1   100     2 name character (8) unaligned,			/* name of device excluding name of multiplexer */
  1   101     2 subchannel_idx fixed binary,			/* index of this entry in hmd.subchannels array */
  1   102     2 device_type fixed binary,			/* type of device -- console/reader/printer/punch */
  1   103     2 direction fixed binary,				/* direction of transfers permitted */
  1   104     2 devx fixed binary,				/* channel (LCT) index of this subchannel */
  1   105     2 rcb character (1) unaligned,			/* the RCB for this sub-channel */
  1   106     2 device_wab_idx fixed binary,			/* index in wait-a-bit arrays for this device */
  1   107     2 dialup_info aligned like dialup_info,		/* information for DIALUP interrupt */
  1   108     2 state fixed binary,				/* state of sub-channel -- hungup/listening/dialed */
  1   109     2 minor_state fixed binary,			/* clarification of dialed-up state --
  1   110*						      normal/send-rts/wait-ack */
  1   111     2 next_subchannel_for_output fixed binary,		/* # of next sub-channel to receive SEND OUTPUT after us */
  1   112     2 input,					/* input records waiting to be supplied to user ring */
  1   113       3 n_records fixed binary,			/* ... # of records in the chain */
  1   114       3 first_bufferp pointer,			/* ... -> first buffer in chain:  individual records are
  1   115*							separated by buffer.break */
  1   116       3 last_bufferp pointer,				/* ... -> last buffer in chain */
  1   117     2 loopback,					/* loopbacked records waiting to be transmitted */
  1   118       3 n_records fixed binary,			/* ... # of records (not used) */
  1   119       3 first_bufferp pointer,
  1   120       3 last_bufferp pointer,
  1   121     2 output,					/* partial output record taken from tty_write to allow ... */
  1   122       3 first_bufferp pointer,			/* ... MCS to request yet more output from the user */
  1   123       3 last_bufferp pointer,
  1   124     2 flags aligned,
  1   125       3 requested_input bit (1) unaligned,		/* ON => read called with no input available:  send interrupt
  1   126*						    when some becomes available */
  1   127       3 input_available bit (1) unaligned,		/* ON => some input is present in an as yet not completely
  1   128*						   processed block:  send this sub-channel an interrupt */
  1   129       3 holding_output bit (1) unaligned,		/* ON => write called but not all output taken:  send
  1   130*						   interrupt when more output may be processed */
  1   131       3 pad bit (33) unaligned,
  1   132     2 meters like hasp_subchannel_meters,		/* interesting events for this subchannel */
  1   133     2 saved_meters_ptr pointer;			/* -> hasp_subchannel_meters structure for copy_meters call */
  1   134 
  1   135 dcl  hste_ptr pointer;
  1   136 
  1   137 dcl (HSTE_HUNGUP		initial (1),		/* sub-channel is hungup */
  1   138      HSTE_LISTENING		initial (2),		/* sub-channel is waiting for a dialup from major channel */
  1   139      HSTE_DIALED		initial (3))		/* sub-channel is dialed-up and capable of data transfer under
  1   140*						   the control of the following minor states */
  1   141 	fixed binary static options (constant);
  1   142 
  1   143 dcl (HSTE_NORMAL		initial (1),		/* sub-channel is in normal data transfer */
  1   144      HSTE_SEND_RTS		initial (2),		/* sub-channel needs to request permission from foreign side
  1   145*						   to transmit a file */
  1   146      HSTE_WAIT_RTS_ACK	initial (3))		/* sub-channel is waiting for permission from foreign side */
  1   147 	fixed binary static options (constant);
  1   148 
  1   149 dcl (HSTE_INPUT_OUTPUT	initial (0),		/* device can perform input and output */
  1   150      HSTE_INPUT_ONLY	initial (1),		/* device can perform input only */
  1   151      HSTE_OUTPUT_ONLY	initial (2))		/* device can perform output only */
  1   152 	fixed binary static options (constant);
  1   153 
  1   154 
  1   155 /* Data required to transmit a SIGNON record to the remote host */
  1   156 
  1   157 dcl 1 hmd_signon_data aligned based (hsd_ptr),
  1   158       2 processid bit (36),				/* process to be informed of results */
  1   159       2 pad bit (36),
  1   160       2 event_channel fixed binary (71),		/* IPC event channel on which signal is sent */
  1   161       2 record character (80) unaligned;		/* the actual SIGNON record */
  1   162 
  1   163 dcl  hsd_ptr pointer;
  1   164 
  1   165 
  1   166 /* HASP minor state stack entry */
  1   167 
  1   168 dcl 1 msse aligned based (msse_ptr),
  1   169     2 previous pointer,				/* -> prior entry on the stack */
  1   170     2 minor_state fixed binary,			/* minor state of multiplexer when this entry created */
  1   171     2 subchannels (hmd.n_subchannels),
  1   172       3 loopback,					/* subchannel's loopback chain when this entry created */
  1   173         4 n_records fixed binary,
  1   174         4 first_bufferp pointer,
  1   175         4 last_bufferp pointer;
  1   176 
  1   177 dcl  msse_ptr pointer;
  1   178 
  1   179 
  1   180 /* HASP loopback block chain stack entry */
  1   181 
  1   182 dcl 1 lbcse aligned based (lbcse_ptr),
  1   183     2 previous pointer,				/* -> previous entry on the stack */
  1   184     2 loopback,					/* loopback block chain when this entry was created */
  1   185       3 first_bufferp pointer,
  1   186       3 last_bufferp pointer;
  1   187 
  1   188 dcl  lbcse_ptr pointer;
  1   189 
  1   190 /* END INCLUDE FILE ... hasp_mpx_data.incl.pl1 */
     3791 
     3792 
  2     1 /* BEGIN INCLUDE FILE ... hasp_load_data.incl.pl1 */
  2     2 /* Created:  October 1979 by G. Palter */
  2     3 /* Modified: 16 April 1981 by G. Palter to add rts_mode */
  2     4 
  2     5 /* Data structure for "load_mpx" highly-privileged control order */
  2     6 
  2     7 dcl 1 hasp_load_data aligned based (hld_ptr),
  2     8     2 event_channel fixed binary (71),			/* event channel to signal loading, crashes, etc. */
  2     9     2 configuration_data like hasp_configuration_data,	/* data which controls multiplexer (see below) */
  2    10     2 n_subchannels fixed binary,			/* # of configured sub-channels */
  2    11     2 subchannels (hasp_load_data_n_subchannels refer (hasp_load_data.n_subchannels)),
  2    12       3 devx fixed binary,				/* device index of sub-channel for validating the load */
  2    13       3 device_type fixed binary,			/* type of device -- console/printer/reader/punch */
  2    14       3 device_number fixed binary;			/* if not console, the device's number (EG: printer 3) */
  2    15 
  2    16 dcl  hasp_load_data_n_subchannels fixed binary;
  2    17 dcl  hld_ptr pointer;
  2    18 
  2    19 
  2    20 /* Event messages for a HASP multiplexer bootload channel */
  2    21 
  2    22 dcl (HASP_MPX_UP	initial (1),			/* multiplexer has come up */
  2    23      HASP_MPX_DOWN	initial (2),			/* multiplexer has gone down */
  2    24      HASP_MPX_MASKED initial (3))			/* multiplexer channel was masked */
  2    25 	fixed binary (71) static options (constant);
  2    26 
  2    27 
  2    28 /* Multiplexer configuration data */
  2    29 
  2    30 dcl 1 hasp_configuration_data aligned based,
  2    31     2 type fixed binary,				/* type of multiplexer -- workstation/host */
  2    32     2 max_block_size fixed binary,			/* maximum block size for transmission over the line */
  2    33     2 max_device_input_records fixed binary,		/* maximum # of input records to be held for a device */
  2    34     2 max_device_output_records fixed binary,		/* maximum # of output records to be held */
  2    35     2 ic_timeout fixed binary,			/* # of seconds to wait for initial connection */
  2    36     2 receive_timeout fixed binary,			/* # of seconds to wait before sending a NAK */
  2    37     2 transmit_timeout fixed binary,			/* # of seconds to wait before sending ACK0 (workstation) */
  2    38     2 max_naks fixed binary,				/* # of NAKs received/transmitted before line considered down */
  2    39     2 flags,
  2    40       3 suspend_all_mode bit (1) unaligned,		/* ON => multiplexer should disallow all input whenever a
  2    41*						         single input device goes not ready */
  2    42       3 signon_mode bit (1) unaligned,			/* ON => multiplexer must send/receive a SIGNON record before
  2    43*						         allowing data transfer on other devices */
  2    44       3 multileave_mode bit (1) unaligned,		/* ON => multiplexer may include records for several devices
  2    45*						         in a single block */
  2    46       3 trace_mode bit (1) unaligned,			/* ON => multiplexer should record input and output blocks via
  2    47*						         MCS tracing mechansim */
  2    48       3 rts_mode bit (1) unaligned,			/* ON => multiplexer must request permission from remote
  2    49*						         host/workstation before transmitting new files */
  2    50       3 pad bit (31) unaligned;
  2    51 
  2    52 dcl (HASP_WORKSTATION	initial (0),		/* multiplexer is a workstation */
  2    53      HASP_HOST		initial (1))		/* multiplexer is a host */
  2    54 	fixed binary static options (constant);
  2    55 
  3     1 /* BEGIN INCLUDE FILE ... hasp_device_data.incl.pl1 */
  3     2 /* Created:  November 1979 by G. Palter */
  3     3 
  3     4 /* HASP device types */
  3     5 
  3     6 dcl (HASP_CONSOLE		initial (1),		/* operator's console */
  3     7      HASP_READER		initial (2),
  3     8      HASP_PRINTER		initial (3),
  3     9      HASP_PUNCH		initial (4))
  3    10 	fixed binary static options (constant);
  3    11 
  3    12 
  3    13 /* Name of each type of device as used by the remote I/O daemon software */
  3    14 
  3    15 dcl  HASP_DEVICE_NAMES (4) character (32) static options (constant) initial ("teleprinter", "reader", "printer", "punch");
  3    16 
  3    17 
  3    18 /* Maximum record length for each type of device */
  3    19 
  3    20 dcl  HASP_MAX_DEVICE_RECORD_LTHS (4) fixed binary (21) static options (constant) initial (80, 80, 132, 80);
  3    21 
  3    22 /* END INCLUDE FILE ... hasp_device_data.incl.pl1 */
  2    56 
  2    57 
  2    58 dcl (HASP_MIN_MAX_BLOCK_SIZE	initial (400),		/* minimum block size allowed as maximum block size */
  2    59      HASP_MAX_MAX_BLOCK_SIZE	initial (1017))
  2    60 	fixed binary static options (constant);
  2    61 
  2    62 
  2    63 /* Default values for HASP configuration */
  2    64 
  2    65 dcl 1 DEFAULT_HASP_CONFIGURATION_DATA aligned static options (constant),
  2    66     2 type fixed binary initial (1),			/* host */
  2    67     2 max_block_size fixed binary initial (400),
  2    68     2 max_device_input_records fixed binary initial (6),
  2    69     2 max_device_output_records fixed binary initial (6),
  2    70     2 ic_timeout fixed binary initial (30),
  2    71     2 receive_timeout fixed binary initial (3),
  2    72     2 transmit_timeout fixed binary initial (2),
  2    73     2 max_naks fixed binary initial (10),
  2    74     2 flags,
  2    75       3 suspend_all_mode bit (1) unaligned initial ("0"b),
  2    76       3 signon_mode bit (1) unaligned initial ("0"b),
  2    77       3 multileave_mode bit (1) unaligned initial ("1"b),
  2    78       3 trace_mode bit (1) unaligned initial ("0"b),
  2    79       3 rts_mode bit (1) unaligned initial ("0"b),
  2    80       3 pad bit (31) unaligned initial (""b);
  2    81 
  2    82 /* END INCLUDE FILE ... hasp_load_data.incl.pl1 */
     3793 
     3794 
  4     1 /* BEGIN INCLUDE FILE ... hasp_mpx_meters.incl.pl1 */
  4     2 /* Created:  24 July 1981 by G. Palter */
  4     3 
  4     4 /* Data returned by comm_meters_ for a HASP multiplexer channel */
  4     5 
  4     6 dcl 1 hasp_mpx_meters_data aligned based (hmmd_ptr),
  4     7       2 version fixed binary,
  4     8       2 time_mpx_booted fixed binary (71),		/* time when multiplexer actually loaded */
  4     9       2 time_meters_copied fixed binary (71),		/* time meters last copied */
  4    10       2 idle_interval fixed binary,			/* # of seconds to go once around the idle loop */
  4    11       2 current_meters like hasp_mpx_meters,
  4    12       2 saved_meters like hasp_mpx_meters;
  4    13 
  4    14 dcl  hmmd_ptr pointer;
  4    15 
  4    16 dcl  HASP_MPX_METERS_DATA_VERSION_1 fixed binary static options (constant) initial (1);
  4    17 
  4    18 
  4    19 /* Meters accumulated for a HASP multiplexer channel */
  4    20 
  4    21 dcl 1 hasp_mpx_meters aligned based (hmm_ptr),
  4    22       2 input_meters,
  4    23         3 n_local_wab_set fixed binary (35),		/* # times we stopped accepting ALL input */
  4    24         3 n_input_blocks fixed binary (35),
  4    25         3 n_input_records fixed binary (35),
  4    26         3 n_duplicate_input_blocks fixed binary (35),	/* # of input blocks ignored as duplicates */
  4    27       2 output_meters,
  4    28         3 n_foreign_wab_set fixed binary (35),		/* # times they stopped ALL our output */
  4    29         3 n_output_blocks fixed binary (35),
  4    30         3 n_output_records fixed binary (35),
  4    31       2 wraparound_meters,				/* describes when our output was returned by FNP */
  4    32         3 n_wraparounds fixed binary (35),
  4    33         3 n_wraparound_blocks fixed binary (35);
  4    34 
  4    35 dcl  hmm_ptr pointer;
  4    36 
  4    37 /* END INCLUDE FILE ... hasp_mpx_meters.incl.pl1 */
     3795 
     3796 
  5     1 /* BEGIN INCLUDE FILE ... hasp_subchannel_meters.incl.pl1 */
  5     2 /* Created:  24 July 1981 by G. Palter */
  5     3 
  5     4 /* Data returned by comm_meters_ for a subchannel of a HASP multiplexer channel */
  5     5 
  5     6 dcl 1 hasp_subchannel_meters_data aligned based (hsmd_ptr),
  5     7       2 version fixed binary,
  5     8       2 flags,
  5     9         3 report_input_meters bit (1) unaligned,		/* ON => report input meters for this subchannel */
  5    10         3 report_output_meters bit (1) unaligned,		/* ON => report output meters for this subchannel */
  5    11         3 pad bit (34) unaligned,
  5    12       2 current_meters like hasp_subchannel_meters,
  5    13       2 saved_meters like hasp_subchannel_meters;
  5    14 
  5    15 dcl  hsmd_ptr pointer;
  5    16 
  5    17 dcl  HASP_SUBCHANNEL_METERS_DATA_VERSION_1 fixed binary static options (constant) initial (1);
  5    18 
  5    19 
  5    20 /* Meters accumulated for a subchannel of a HASP multiplexer channel */
  5    21 
  5    22 dcl 1 hasp_subchannel_meters aligned based (hsm_ptr),
  5    23       2 input_meters,
  5    24         3 device_n_local_wab_set fixed binary (35),	/* # of times we had to stop accepting input */
  5    25         3 device_n_input_records fixed binary (35),
  5    26         3 device_n_input_eof_records fixed binary (35),
  5    27       2 output_meters,
  5    28         3 device_n_foreign_wab_set fixed binary (35),	/* # of times local system stopped our output */
  5    29         3 device_n_output_records fixed binary (35),
  5    30         3 device_n_output_eof_records fixed binary (35);
  5    31 
  5    32 dcl  hsm_ptr pointer;
  5    33 
  5    34 /* END INCLUDE FILE ... hasp_subchannel_meters.incl.pl1 */
     3797 
     3798 
  6     1 /* BEGIN INCLUDE FILE ... hasp_block_record_data.incl.pl1 */
  6     2 /* Created:  October 1979 by G. Palter */
  6     3 /* Modified: July 1981 by G. Palter to add SIGNON block template request-acknowledgement block type */
  6     4 
  6     5 
  6     6 /* Template HASP block header */
  6     7 
  6     8 dcl 1 TEMPLATE_HASP_BLOCK_HEADER_BITS aligned static options (constant),
  6     9     2 dle bit (9) unaligned initial ("020"b3),		/* DLE */
  6    10     2 stx bit (9) unaligned initial ("002"b3),		/* STX */
  6    11     2 bcb bit (9) unaligned initial ("000"b3),		/* block count byte (BCB) */
  6    12     2 fcs bit (18) unaligned initial ("000000"b3);	/* function control sequence (FCS) */
  6    13 
  6    14 dcl 1 TEMPLATE_HASP_BLOCK_HEADER aligned based (addr (TEMPLATE_HASP_BLOCK_HEADER_BITS)),
  6    15     2 text1 character (2) unaligned,			/* not referenced by the program */
  6    16     2 bcb character (1) unaligned,
  6    17     2 fcs character (2) unaligned;
  6    18 
  6    19 
  6    20 /* Template HASP block trailer */
  6    21 
  6    22 dcl 1 TEMPLATE_HASP_BLOCK_TRAILER_BITS aligned static options (constant),
  6    23     2 non_crc unaligned,				/* all but the CRC:  actually sent to FNP */
  6    24       3 eob_rcb bit (9) unaligned initial ("000"b3),	/* record control byte (RCB) indicating end of block */
  6    25       3 dle bit (9) unaligned initial ("020"b3),		/* DLE */
  6    26       3 etb bit (9) unaligned initial ("046"b3),		/* ETB */
  6    27     2 crc bit (18) unaligned initial ("000000"b3);	/* CRC:  added by FNP--not transmitted */
  6    28 
  6    29 dcl 1 TEMPLATE_HASP_BLOCK_TRAILER aligned based (addr (TEMPLATE_HASP_BLOCK_TRAILER_BITS)),
  6    30     2 non_crc character (3) unaligned,			/* not referenced by programs */
  6    31     2 crc character (2) unaligned;
  6    32 
  6    33 
  6    34 /* Template HASP SIGNON record block */
  6    35 
  6    36 dcl 1 TEMPLATE_HASP_SIGNON_BLOCK_BITS aligned static options (constant),
  6    37       2 start_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    38       2 stx bit (9) unaligned initial ("002"b3),		/* STX */
  6    39       2 bcb bit (9) unaligned initial ("240"b3),		/* BCB -- ignored */
  6    40       2 fcs bit (18) unaligned initial ("217317"b3),	/* FCS -- set by finish_output_block */
  6    41       2 rcb bit (9) unaligned initial ("360"b3),		/* RCB -- general control record */
  6    42       2 srcb bit (9) unaligned initial ("301"b3),		/* SRCB -- indicates SIGNON record */
  6    43       2 record_bits bit (720) unaligned initial (""b),	/* actual SIGNON record */
  6    44       2 eob_scb bit (9) unaligned initial ("000"b3),	/* SCB -- indicates end of record */
  6    45       2 eob_rcb bit (9) unaligned initial ("000"b3),	/* RCB -- indicates end of block */
  6    46       2 end_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    47       2 etb bit (9) unaligned initial ("046"b3);		/* ETB */
  6    48 
  6    49 dcl 1 TEMPLATE_HASP_SIGNON_BLOCK aligned based (addr (TEMPLATE_HASP_SIGNON_BLOCK_BITS)),
  6    50       2 non_trailer,				/* all but the trailer and CRC characters */
  6    51         3 header character (7) unaligned,
  6    52         3 record character (80) unaligned,		/* the actual text of the record */
  6    53         3 text1 character (1) unaligned,
  6    54       2 trailer character (3) unaligned;		/* supplied by finish_output_block */
  6    55 
  6    56 
  6    57 /* Template HASP bad BCB block:  transmitted when one side receives a block with an invalid BCB count */
  6    58 
  6    59 dcl 1 TEMPLATE_HASP_BAD_BCB_BLOCK_BITS aligned static options (constant),
  6    60     2 start_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    61     2 stx bit (9) unaligned initial ("002"b3),		/* STX */
  6    62     2 bcb bit (9) unaligned initial ("220"b3),		/* BCB -- contains the received (bad) count */
  6    63     2 fcs bit (18) unaligned initial ("217317"b3),	/* FCS */
  6    64     2 rcb bit (9) unaligned initial ("340"b3),		/* RCB -- bad BCB record */
  6    65     2 srcb bit (9) unaligned initial ("200"b3),		/* SRCB -- contains the expected count */
  6    66     2 eor_scb bit (9) unaligned initial ("000"b3),	/* SCB -- indicates end of record */
  6    67     2 eob_rcb bit (9) unaligned initial ("000"b3),	/* RCB -- indicates end of block */
  6    68     2 end_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    69     2 etb bit (9) unaligned initial ("046"b3);		/* ETB */
  6    70 
  6    71 dcl 1 TEMPLATE_HASP_BAD_BCB_BLOCK aligned based (addr (TEMPLATE_HASP_BAD_BCB_BLOCK_BITS)),
  6    72     2 text1 character (2) unaligned,			/* not referenced by programs */
  6    73     2 bcb character (1) unaligned,
  6    74     2 text2 character (3) unaligned,			/* not referenced by programs */
  6    75     2 srcb character (1) unaligned,
  6    76     2 text3 character (4) unaligned;			/* not referenced by programs */
  6    77 
  6    78 
  6    79 /* Template HASP synchronization block */
  6    80 
  6    81 dcl 1 TEMPLATE_HASP_SYNC_BLOCK_BITS aligned static options (constant),
  6    82     2 start_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    83     2 stx bit (9) unaligned initial ("002"b3),		/* STX */
  6    84     2 bcb bit (9) unaligned initial ("000"b3),		/* BCB -- ignored */
  6    85     2 fcs bit (18) unaligned initial ("237377"b3),	/* FCS -- bits 2&3 (0-based) of second byte => sync block */
  6    86     2 eob_rcb bit (9) unaligned initial ("000"b3),	/* RCB -- indicates end of block */
  6    87     2 end_dle bit (9) unaligned initial ("020"b3),	/* DLE */
  6    88     2 etb bit (9) unaligned initial ("046"b3);		/* ETB */
  6    89 
  6    90 dcl 1 TEMPLATE_HASP_SYNC_BLOCK aligned based (addr (TEMPLATE_HASP_SYNC_BLOCK_BITS)),
  6    91     2 text1 character (8) unaligned;			/* actual parts never referenced */
  6    92 
  6    93 
  6    94 /* HASP record types */
  6    95 
  6    96 dcl (HASP_EOB_RECORD initial (1),			/* end of transmission block */
  6    97      HASP_EOF_RECORD initial (2),			/* end of file block */
  6    98      HASP_SIGNON_RECORD initial (3),			/* SIGNON card */
  6    99      HASP_RTS_RECORD initial (4),			/* request-to-send file */
  6   100      HASP_RTS_ACK_RECORD initial (5),			/* request-to-send file granted */
  6   101      HASP_BAD_BCB_RECORD initial (6),			/* bad block count detected record */
  6   102      HASP_DATA_RECORD initial (7))			/* ordinary data record */
  6   103 	fixed binary static options (constant);
  6   104 
  6   105 
  6   106 /* Constant RCB, SRCB, and SCB characters used only by the multiplexer */
  6   107 
  6   108 dcl (HASP_EOB_RCB_BITS	initial ("000"b3),		/* RCB -- end of transmission block */
  6   109      HASP_GENERAL_CONTROL_RCB_BITS initial ("360"b3),	/* RCB -- generalized control record (eg: SIGNON record) */
  6   110      HASP_CONSOLE_INPUT_RCB_BITS  initial ("222"b3),	/* RCB -- record from console to host */
  6   111      HASP_CONSOLE_OUTPUT_RCB_BITS initial ("221"b3),	/* RCB -- record from host to console */
  6   112      HASP_SIGNON_SRCB_BITS	initial ("301"b3),		/* SRCB -- SIGNON record */
  6   113      HASP_EOF_SRCB_BITS	initial ("200"b3),		/* SRCB -- end of file record */
  6   114      HASP_EOF_FIRST_SCB_BITS	initial ("000"b3))		/* SCB -- first SCB in an end of file record */
  6   115 	bit (9) aligned static options (constant);
  6   116 
  6   117 dcl (HASP_EOB_RCB		based (addr (HASP_EOB_RCB_BITS)),
  6   118      HASP_GENERAL_CONTROL_RCB	based (addr (HASP_GENERAL_CONTROL_RCB_BITS)),
  6   119      HASP_CONSOLE_INPUT_RCB	based (addr (HASP_CONSOLE_INPUT_RCB_BITS)),
  6   120      HASP_CONSOLE_OUTPUT_RCB	based (addr (HASP_CONSOLE_OUTPUT_RCB_BITS)),
  6   121      HASP_SIGNON_SRCB	based (addr (HASP_SIGNON_SRCB_BITS)),
  6   122      HASP_EOF_SRCB		based (addr (HASP_EOF_SRCB_BITS)),
  6   123      HASP_EOF_FIRST_SCB	based (addr (HASP_EOF_FIRST_SCB_BITS)))
  6   124 	character (1) aligned;
  6   125 
  6   126 
  6   127 /* Template HASP bad BCB record (see above) */
  6   128 
  6   129 dcl 1 TEMPLATE_HASP_BAD_BCB_RECORD_BITS aligned static options (constant),
  6   130     2 rcb bit (9) unaligned initial ("340"b3),		/* RCB -- bad BCB record */
  6   131     2 srcb bit (9) unaligned initial ("200"b3),		/* SRCB -- contains expected count */
  6   132     2 eor_scb bit (9) unaligned initial ("000"b3);
  6   133 
  6   134 dcl 1 TEMPLATE_HASP_BAD_BCB_RECORD aligned based (addr (TEMPLATE_HASP_BAD_BCB_RECORD_BITS)),
  6   135     2 rcb character (1) unaligned,
  6   136     2 srcb character (1) unaligned,
  6   137     2 eor_scb character (1) unaligned;
  6   138 
  6   139 
  6   140 /* Template HASP request-to-send record */
  6   141 
  6   142 dcl 1 TEMPLATE_HASP_RTS_RECORD_BITS aligned static options (constant),
  6   143     2 rcb bit (9) unaligned initial ("220"b3),		/* RCB -- request permission to transmit file */
  6   144     2 srcb bit (9) unaligned initial ("000"b3),		/* SRCB -- RCB of the device requesting permission */
  6   145     2 eor_scb bit (9) unaligned initial ("000"b3);	/* SCB --  end of record */
  6   146 
  6   147 dcl 1 TEMPLATE_HASP_RTS_RECORD aligned based (addr (TEMPLATE_HASP_RTS_RECORD_BITS)),
  6   148     2 rcb character (1) unaligned,
  6   149     2 srcb character (1) unaligned,
  6   150     2 eor_scb character (1) unaligned;
  6   151 
  6   152 
  6   153 /* Template HASP request-to-send acknowledgement record */
  6   154 
  6   155 dcl 1 TEMPLATE_HASP_RTS_ACK_RECORD_BITS aligned static options (constant),
  6   156     2 rcb bit (9) unaligned initial ("240"b3),		/* RCB -- permission granted to send file */
  6   157     2 srcb bit (9) unaligned initial ("000"b3),		/* SRCB -- RCB of the device granted permission */
  6   158     2 eor_scb bit (9) unaligned initial ("000"b3);
  6   159 
  6   160 dcl 1 TEMPLATE_HASP_RTS_ACK_RECORD aligned based (addr (TEMPLATE_HASP_RTS_ACK_RECORD_BITS)),
  6   161     2 rcb character (1) unaligned,
  6   162     2 srcb character (1) unaligned,
  6   163     2 eor_scb character (1) unaligned;
  6   164 
  6   165 
  6   166 /* HASP Block Control Byte (BCB) */
  6   167 
  6   168 dcl 1 hasp_bcb_byte unaligned based (hasp_bcb_byte_ptr),
  6   169     2 pad1 bit (1) unaligned,				/* padding supplied by MCS */
  6   170     2 mbo1 bit (1) unaligned,				/* always ON */
  6   171     2 type fixed binary (3) unaligned unsigned,		/* type of BCB -- normal/ignore/reset */
  6   172     2 count fixed binary (4) unaligned unsigned;		/* the block count */
  6   173 
  6   174 dcl  hasp_bcb_byte_ptr pointer;
  6   175 
  6   176 dcl (HASP_BCB_NORMAL		initial (0),	/* normal BCB */
  6   177      HASP_BCB_IGNORE		initial (1),	/* normal: ignore this block count;
  6   178*						   in bad-BCB block: expected block count */
  6   179      HASP_BCB_RESET			initial (2))	/* reset exepected block count to this value */
  6   180 	fixed binary (3) unsigned static options (constant);
  6   181 
  6   182 
  6   183 /* HASP Function Control Sequence (FCS) */
  6   184 
  6   185 dcl 1 hasp_fcs_bytes unaligned based (hasp_fcs_bytes_ptr),
  6   186     2 pad1 bit (1) unaligned,				/* padding supplied by MCS (byte 1) */
  6   187     2 mbo1 bit (1) unaligned,				/* always ON */
  6   188     2 system_wab bit (1) unaligned,			/* ON => sending site wants all data transmissions stopped */
  6   189     2 mcs1 unaligned,				/* bits used by FNP and ring-0 multiplexer */
  6   190       3 device_not_ready bit (1) unaligned,		/* (from FNP): ON => some individual device went not ready */
  6   191       3 returned_data bit (1) unaligned,		/* (from FNP): ON => this is output block returned by FNP */
  6   192     2 wab_bits1 (4) bit (1) unaligned,			/* OFF => suspend data transmissions for this device */
  6   193     2 pad2 bit (1) unaligned,				/* padding supplied by MCS (byte 2) */
  6   194     2 mbo2 bit (1) unaligned,				/* always ON */
  6   195     2 console_wab bit (1) unaligned,			/* OFF => suspend data transmissions to/from console */
  6   196     2 mcs2 unaligned,				/* bits used by FNP and ring-0 multiplexer */
  6   197       3 block_type fixed binary (2) unaligned unsigned,	/* type of block -- normal/sync */
  6   198     2 wab_bits2 (4) bit (1) unaligned;			/* OFF => suspend data transmissions for this device */
  6   199 
  6   200 dcl  hasp_fcs_bytes_ptr pointer;
  6   201 
  6   202 dcl (HASP_FCS_NORMAL_BLOCK		initial (0),	/* normal block */
  6   203      HASP_FCS_ACKNOWLEDGE_BLOCK	initial (1),	/* requests FNP to acknowledge when block is sent */
  6   204      HASP_FCS_SYNC_BLOCK		initial (3))	/* synchronization block to terminate FNP loopback mode */
  6   205 	fixed binary (2) unsigned static options (constant);
  6   206 
  6   207 /* END INCLUDE FILE ... hasp_block_record_data.incl.pl1 */
     3799 
     3800 
  7     1 /* BEGIN INCLUDE FILE ... hasp_rcb_byte.incl.pl1 */
  7     2 /* Created:  October 1979 by G. Palter from hasp_block_record_data.incl because only the RCB is used by priv_hasp_mpx */
  7     3 
  7     4 /* HASP Record Control Byte (RCB) */
  7     5 
  7     6 dcl 1 hasp_rcb_byte unaligned based (hasp_rcb_byte_ptr),
  7     7     2 pad1 bit (1) unaligned,				/* padding supplied by MCS */
  7     8     2 not_eob bit (1) unaligned,			/* ON => not end-of-block indicator */
  7     9     2 stream fixed binary (3) unaligned unsigned,		/* identifies which device record is from or what control
  7    10*						    function depending on contents of type field below */
  7    11     2 type fixed binary (4) unaligned unsigned;		/* type of record */
  7    12 
  7    13 dcl  hasp_rcb_byte_ptr pointer;
  7    14 
  7    15 dcl (HASP_RCB_TYPE_CONTROL		initial (0),	/* RCB of some form of a control record */
  7    16      HASP_RCB_TYPE_CONSOLE_OUTPUT	initial (1),	/* RCB of message from host to workstation console */
  7    17      HASP_RCB_TYPE_CONSOLE_INPUT	initial (2),	/* RCB of input line from workstation console to host */
  7    18      HASP_RCB_TYPE_READER_INPUT	initial (3),	/* RCB of card from workstation card reader */
  7    19      HASP_RCB_TYPE_PRINT_OUTPUT	initial (4),	/* RCB ofprint line from host */
  7    20      HASP_RCB_TYPE_PUNCH_OUTPUT	initial (5))	/* RCB of card from host to workstation card punch */
  7    21 	fixed binary (4) unsigned static options (constant);
  7    22 
  7    23 dcl (HASP_RCB_STREAM_RTS		initial (1),	/* RCB of request-to-send control record */
  7    24      HASP_RCB_STREAM_RTS_ACK		initial (2),	/* RCB of acknowledgement to request-to-send control record */
  7    25      HASP_RCB_STREAM_BAD_BCB		initial (6),	/* RCB of bad-BCB control record */
  7    26      HASP_RCB_STREAM_CONTROL		initial (7))	/* RCB of "general" control record (escape) */
  7    27 	fixed binary (3) unsigned static options (constant);
  7    28 
  7    29 /* END INCLUDE FILE ... hasp_rcb_byte.incl.pl1 */
     3801 
     3802 
  8     1 /* BEGIN INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
  8     2 /* Created:  October 1979 by G. Palter */
  8     3 
  8     4 /* HASP End-Of-File record */
  8     5 
  8     6 dcl 1 TEMPLATE_HASP_EOF_RECORD_BITS aligned static options (constant),
  8     7     2 srcb bit (9) unaligned initial ("200"b3),		/* SRCB -- 200-bit is always ON */
  8     8     2 eor_scb bit (9) unaligned initial ("000"b3);	/* SCB -- end of record */
  8     9 
  8    10 dcl TEMPLATE_HASP_EOF_RECORD character (2) aligned based (addr (TEMPLATE_HASP_EOF_RECORD_BITS));
  8    11 
  8    12 
  8    13 /* HASP Sub-Record Control Byte (SRCB) -- operator's console */
  8    14 
  8    15 dcl  HASP_CONSOLE_SRCB_BITS bit (9) aligned static options (constant) initial ("200"b3);
  8    16 dcl  HASP_CONSOLE_SRCB character (1) aligned based (addr (HASP_CONSOLE_SRCB_BITS));
  8    17 
  8    18 
  8    19 /* HASP Sub-Record Control Byte (SRCB) -- reader/punch */
  8    20 
  8    21 dcl 1 hasp_card_srcb_byte unaligned based (hasp_card_srcb_byte_ptr),
  8    22     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  8    23     2 mbo1 bit (1) unaligned,				/* always ON */
  8    24     2 count_units fixed binary (2) unaligned unsigned,	/* SCB count units: 0 => 1; 1 => 2; 2 => 4 */
  8    25     2 binary bit (1) unaligned,			/* ON => binary data record */
  8    26     2 mbz1 bit (4) unaligned;				/* always OFF */
  8    27 
  8    28 dcl  hasp_card_srcb_byte_ptr pointer;
  8    29 
  8    30 dcl 1 TEMPLATE_HASP_CARD_SRCB_BITS aligned static options (constant),
  8    31     2 pad1 bit (1) unaligned initial ("0"b),
  8    32     2 mbo1 bit (1) unaligned initial ("1"b),
  8    33     2 count_units fixed binary (2) unaligned unsigned initial (0),	/* SCB counts single characters */
  8    34     2 binary bit (1) unaligned initial ("0"b),		/* not binary card */
  8    35     2 mbz1 bit (4) unaligned initial ("0000"b);
  8    36 
  8    37 dcl  TEMPLATE_HASP_CARD_SRCB character (1) aligned based (addr (TEMPLATE_HASP_CARD_SRCB_BITS));
  8    38 
  8    39 
  8    40 /* HASP Sub-Record Control Byte (SRCB) -- printer */
  8    41 
  8    42 dcl 1 hasp_printer_srcb_byte unaligned based (hasp_printer_srcb_byte_ptr),
  8    43     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  8    44     2 mbo1 bit (1) unaligned,				/* always ON */
  8    45     2 mbz1 bit (1) unaligned,				/* always OFF */
  8    46     2 prespace bit (1) unaligned,			/* ON => pre-spacing; OFF => post-spacing */
  8    47     2 skip_to_channel bit (1) unaligned,		/* ON => skip to given channel; OFF => skip # lines */
  8    48     2 number fixed binary (4) unaligned unsigned;		/* channel # or # or lines to skip */
  8    49 
  8    50 dcl  hasp_printer_srcb_byte_ptr pointer;
  8    51 
  8    52 dcl 1 TEMPLATE_HASP_PRINTER_SRCB_BITS aligned static options (constant),
  8    53     2 pad1 bit (1) unaligned initial ("0"b),
  8    54     2 mbo1 bit (1) unaligned initial ("1"b),
  8    55     2 mbz1 bit (1) unaligned initial ("0"b),
  8    56     2 prespace bit (1) unaligned initial ("0"b),		/* post-spacing */
  8    57     2 skip_to_channel bit (1) unaligned initial ("0"b),	/* # of lines */
  8    58     2 number fixed binary (4) unaligned unsigned initial (1);
  8    59 
  8    60 dcl  TEMPLATE_HASP_PRINTER_SRCB character (1) aligned based (addr (TEMPLATE_HASP_PRINTER_SRCB_BITS));
  8    61 
  8    62 dcl  HASP_MAX_SLEW_COUNT fixed binary static options (constant) initial (3);
  8    63 						/* max slew of 3 insures proper operation with 370's */
  8    64 
  8    65 dcl 1 HASP_FORMS_CHANGE_SRCB_BITS aligned static options (constant),
  8    66     2 pad1 bit (1) unaligned initial ("0"b),
  8    67     2 mbo1 bit (1) unaligned initial ("1"b),
  8    68     2 mbz1 bit (1) unaligned initial ("0"b),
  8    69     2 change bit (6) unaligned initial ("16"b3);		/* change forms record */
  8    70 
  8    71 dcl  HASP_FORMS_CHANGE_SRCB character (1) aligned based (addr (HASP_FORMS_CHANGE_SRCB_BITS));
  8    72 
  8    73 
  8    74 /* HASP String Control Byte (SCB) */
  8    75 
  8    76 dcl 1 hasp_scb_byte unaligned based (hasp_scb_byte_ptr),
  8    77     2 pad1 bit (1) unaligned,				/* supplied by MCS */
  8    78     2 not_eor bit (1) unaligned,			/* ON => not an end of record indicator */
  8    79     2 not_compressed bit (1) unaligned,			/* ON => this SCB refers to a non-compressed string */
  8    80     2 variant bit (6) unaligned;			/* dependent on setting of hasp_scb_byte.not_compressed */
  8    81 
  8    82 dcl 1 hasp_not_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  8    83     2 pad1 bit (1) unaligned,
  8    84     2 not_eor bit (1) unaligned,
  8    85     2 not_compressed bit (1) unaligned,			/* ON */
  8    86     2 count fixed binary (6) unaligned unsigned;		/* # of characters in string following the SCB */
  8    87 
  8    88 dcl 1 hasp_compressed_scb_byte unaligned based (hasp_scb_byte_ptr),
  8    89     2 pad1 bit (1) unaligned,
  8    90     2 not_eor bit (1) unaligned,
  8    91     2 not_compressed bit (1) unaligned,			/* OFF */
  8    92     2 not_blank bit (1) unaligned,			/* ON => repeated character isn't a blank and follows SCB */
  8    93     2 count fixed binary (5) unaligned unsigned;		/* # of occurrences of the character */
  8    94 
  8    95 dcl  hasp_scb_byte_ptr pointer;
  8    96 
  8    97 dcl  HASP_EOR_SCB_BITS bit (9) aligned static options (constant) initial ("000"b3);
  8    98 dcl  HASP_EOR_SCB character (1) aligned based (addr (HASP_EOR_SCB_BITS));
  8    99 
  8   100 dcl (HASP_MAX_NOT_COMPRESSED_TEXT_LTH	initial (62),	/* # of characters representable by a single SCB */
  8   101      HASP_MAX_COMPRESSED_TEXT_LTH	initial (31))	/* # of occurences of a character representable by
  8   102*						     a single SCB */
  8   103 	fixed binary static options (constant);
  8   104 
  8   105 /* END INCLUDE FILE ... hasp_srcb_scb_bytes.incl.pl1 */
     3803 
     3804 
  9     1 /* BEGIN INCLUDE FILE ... hasp_signon_record_info.incl.pl1 */
  9     2 /* Created:  July 1981 by G. Palter */
  9     3 
  9     4 /* Structure used by the signon_record control order of a HASP sub-channel */
  9     5 
  9     6 dcl 1 signon_record_info aligned based (signon_record_info_ptr),
  9     7       2 version fixed binary,
  9     8       2 pad bit (36),
  9     9       2 event_channel fixed binary (71),		/* IPC wait channel over which success/failure is signalled */
  9    10       2 record character (80) unaligned;		/*  actual record: hasp_host_ does necessary translations */
  9    11 
  9    12 dcl  signon_record_info_ptr pointer;
  9    13 
  9    14 dcl  SIGNON_RECORD_INFO_VERSION_1 fixed binary static options (constant) initial (1);
  9    15 
  9    16 
  9    17 /* Possible results of transmitting the SIGNON record: returned as the event message signalled by the multiplexer on the
  9    18*   supplied IPC event-wait channel */ 
  9    19 
  9    20 dcl (HASP_SIGNON_OK		initial (1),		/* remote system accepted the SIGNON record */
  9    21      HASP_SIGNON_REJECTED	initial (2),		/* remote system rejected it but allows a retry */
  9    22      HASP_SIGNON_HANGUP	initial (3))		/* remote system rejected it and disconnected the line */
  9    23 	fixed binary (71) static options (constant);
  9    24 
  9    25 /* END INCLUDE FILE ... hasp_signon_record_info.incl.pl1 */
     3805 
     3806 
 10     1 /* BEGIN INCLUDE FILE .... bisync_line_data.incl.pl1 */
 10     2 /* Written:  October 1977 by Larry Johnson */
 10     3 /* Modified: November 1979 by Larry Johnson and Gary Palter for HASP */
 10     4 /* Modified: February 1984 by G. Palter for HASP system wait-a-bit changes */
 10     5 
 10     6 /* Structures and codes for doing line_control and line_status operations on bisync lines */
 10     7 
 10     8 /* For line_control order */
 10     9 
 10    10 dcl 1 line_ctl aligned,
 10    11     2 op fixed binary (17) unaligned,			/* indicates action being performed */
 10    12     2 val (3) fixed binary (17) unaligned;		/* optional arguments with some ops */
 10    13 
 10    14 dcl 1 valchar based (addr (line_ctl.val (1))),		/* character overlay of line_ctl.val */
 10    15     2 data_len fixed binary (9) unaligned unsigned,
 10    16     2 data character (5) unaligned;
 10    17 
 10    18 
 10    19 /* Values for line_ctl.op */
 10    20 
 10    21 dcl (SET_BID_LIMIT		     initial (1),
 10    22      ACCEPT_BID		     initial (2),
 10    23      CONFIGURE		     initial (3),		/* val(1): 0 = non-transparent ASCII, 1 = not-tranparent EBCDIC,
 10    24*							 2 = transparent ASCII, 3 = transparent EBCDIC */
 10    25      SET_TTD_PARAMS		     initial (4),		/* val(1): ttd_time;  val(2): ttd_limit */
 10    26      REPORT_WRITE_STATUS	     initial (5),		/* Request FNP to report on output buffers */
 10    27      SET_3270_MODE		     initial (6),
 10    28      SET_POLLING_ADDR	     initial (7),
 10    29      START_POLL		     initial (8),
 10    30      SET_SELECT_ADDR	     initial (9),
 10    31      STOP_AUTO_POLL		     initial (10),
 10    32      SET_MASTER_SLAVE_MODE	     initial (11),		/* val(1): 0 = slave (host), 1 = master (workstation) */
 10    33      SET_HASP_MODE		     initial (12),
 10    34      SET_NAK_LIMIT		     initial (13),		/* val(1): maximum # of NAKs allowed in a row */
 10    35      SET_HASP_TIMERS	     initial (14))		/* val(1): initial connect timeout;  val(2): receive timeout;
 10    36*						   val(3): transmit timeout */
 10    37 	fixed binary static options (constant);
 10    38 
 10    39 
 10    40 /* For line status order */
 10    41 
 10    42 dcl 1 line_stat aligned,
 10    43     2 op fixed binary (17) unaligned,			/* contains reason for status */
 10    44     2 val (3) fixed binary (17) unaligned;
 10    45 
 10    46 
 10    47 /* Values for line_stat.op */
 10    48 
 10    49 dcl (BID_FAILED		     initial (1),
 10    50      BAD_BLOCK		     initial (2),
 10    51      REVERSE_INTERRUPT	     initial (3),
 10    52      TOO_MANY_NAKS		     initial (4),
 10    53      FNP_WRITE_STATUS	     initial (5),
 10    54      IBM3270_WRITE_COMPLETE	     initial (6),
 10    55      IBM3270_WACK_MESSAGE	     initial (7),
 10    56      IBM3270_WRITE_EOT	     initial (8),
 10    57      IBM3270_WRITE_ABORT	     initial (9),
 10    58      IBM3270_SELECT_FAILED	     initial (10),
 10    59      IBM3270_WACK_SELECT	     initial (11),
 10    60      IBM3270_NAK_OUTPUT	     initial (12),
 10    61      HASP_INIT_COMPLETE	     initial (13),
 10    62      HASP_FOREIGN_SWAB_RESET	     initial (14))
 10    63 	fixed binary static options (constant);
 10    64 	
 10    65 /* END INCLUDE FILE ..... bisync_line_data.incl.pl1 */
     3807 
     3808 
 11     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
 11     2 
 11     3 /* Defines constants and structures  used by MCS interrupt handlers */
 11     4 
 11     5 /* Created 08/21/78 by Robert Coren */
 11     6 /* Echo negotiation types added sometime by Bernie Greenberg */
 11     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
 11     8 /* MASKED type added June 23, 1982, by Robert Coren */
 11     9 
 11    10 dcl  DIALUP fixed bin int static options (constant) init (1);
 11    11 dcl  HANGUP fixed bin int static options (constant) init (2);
 11    12 dcl  CRASH fixed bin int static options (constant) init (3);
 11    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
 11    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
 11    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
 11    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
 11    17 dcl  QUIT fixed bin int static options (constant) init (8);
 11    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
 11    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
 11    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
 11    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
 11    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
 11    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
 11    24 dcl  TIMER fixed bin int static options (constant) init (15);
 11    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
 11    26 dcl  MASKED fixed bin int static options (constant) init (17);
 11    27 
 11    28 dcl  interrupt_info bit (72) aligned;
 11    29 
 11    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
 11    31     2 line_type fixed bin (9) unal uns,
 11    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
 11    33     2 baud_rate fixed bin (18) unal uns,
 11    34     2 max_buf_size fixed bin (9) unal uns,
 11    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
 11    36     2 pad bit (26) unal;
 11    37 
 11    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
 11    39     2 input_chain unaligned,
 11    40       3 chain_head bit (18) unaligned,
 11    41       3 chain_tail bit (18) unaligned,
 11    42     2 input_count fixed bin (18) unal uns,
 11    43     2 flags unaligned,
 11    44       3 break_char bit (1),				/* data contains a break character */
 11    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
 11    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
 11    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
 11    48       3 pad bit (14);
 11    49 
 11    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
 11    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
 11    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
 11    53 
 11    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
     3809 
     3810 
 12     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
 12     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
 12     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
 12     9*     implementation.
 12    10*                                                   END HISTORY COMMENTS */
 12    11 
 12    12 
 12    13 /*
 12    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
 12    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
 12    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
 12    17**/
 12    18 
 12    19 dcl  blockp ptr;					/* pointer which block entry is based on */
 12    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
 12    21 
 12    22 
 12    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
 12    24     2 next bit (18),				/* foward pointer to next free block */
 12    25     2 size fixed bin;				/* number of words in this block */
 12    26 
 12    27 
 12    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
 12    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
 12    30     2 flags unaligned,
 12    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
 12    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
 12    33       3 break bit (1) unaligned,			/* buffer contains break character */
 12    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
 12    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
 12    36       3 pad bit (1) unaligned,
 12    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
 12    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
 12    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
 12    40 
 12    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
 12    42 
 12    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
 12    44 
 12    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
     3811 
     3812 
 13     1 /* BEGIN INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
 13     2 
 13     3 /* Created 4/9/79 by J. Stern */
 13     4 /* Modified: 10 November 1980 by G. Palter to add can_type */
 13     5 
 13     6 
 13     7 dcl  mclp ptr;
 13     8 dcl  mcl_version_2 fixed bin int static options (constant) init (2);
 13     9 
 13    10 dcl 1 mcl aligned based (mclp),			/* modes change list */
 13    11       2 version fixed bin,				/* version number of this structure (Input) */
 13    12       2 n_entries fixed bin,				/* number of mode change entries (Input) */
 13    13       2 line_len fixed bin,				/* new line length (-1 => no change) (Input) */
 13    14       2 page_len fixed bin,				/* new page length (-1 => no change) (Input) */
 13    15       2 can_type fixed binary,			/* new canonicalization type (-1 => no change) (Input) */
 13    16       2 flags,
 13    17         3 init bit (1) unal,				/* ON if all modes to be reinitialized (Input) */
 13    18         3 ll_error bit (1) unal,			/* ON if line length error detected (Output) */
 13    19         3 pl_error bit (1) unal,			/* ON if page length error detected (Output) */
 13    20         3 can_type_error bit (1) unaligned,		/* ON if can_type error detected (Output) */
 13    21         3 mbz bit (32) unal,
 13    22       2 entries (36) like mcle;			 /* one entry per mode change */
 13    23 
 13    24 dcl  mclep ptr;
 13    25 
 13    26 dcl 1 mcle aligned based (mclep),			/* mode change list entry */
 13    27       2 mode_name char (16) unal,			/* name of mode to change (Input) */
 13    28       2 flags,
 13    29         3 mode_switch bit (1) unal,			/* ON to turn mode on, else OFF (Input) */
 13    30         3 force bit (1) unal,				/* ON to ignore errors for this mode change (Input) */
 13    31         3 mpx_mode bit (1) unal,			/* ON if mode recognized by multiplexer (Output) */
 13    32         3 error bit (1) unal,				/* ON if mode change is in error (Output) */
 13    33         3 mbz bit (32) unal;
 13    34 
 13    35 
 13    36 /* END INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
     3813 
     3814 
 14     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
 14     2 
 14     3 /* Created 8/25/78 by J. Stern */
 14     4 
 14     5 
 14     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
 14     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
 14     8 
 14     9 /* call channel_manager$write (devx, output_ptr, code) */
 14    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
 14    11 
 14    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
 14    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
 14    14 
 14    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
 14    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
 14    17 
 14    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
 14    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
 14    20 
 14    21 /* call channel_manager$get_modes (devx, modes, code) */
 14    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
 14    23 
 14    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
 14    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    26 
 14    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
 14    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
 14    29 
 14    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
 14    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
 14    32 
 14    33 
 14    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
     3815 
     3816 
 15     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
 15     2 
 15     3 /* This include file declares all the entries in tty_space_man and defines the constants
 15     4**  to be used for the flags argument
 15     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
 15     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
 15     7**   Modified April 1981 by Robert Coren to add switch_chain entry
 15     8**/
 15     9 
 15    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
 15    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
 15    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
 15    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
 15    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
 15    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
 15    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
 15    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
 15    18 dcl  tty_space_man$needs_space entry (fixed bin);
 15    19 
 15    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
 15    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
 15    22 
 15    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
     3817 
     3818 
 16     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
 16     2 
 16     3 /* Created by J. Stern 7/26/78 */
 16     4 /* Metering information added by C. Hornig, March 1980. */
 16     5 /* Unwired saved meters added by Robert Coren, December 1980 */
 16     6 
 16     7 dcl  lctp ptr;					/* ptr to logical channel table */
 16     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
 16     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
 16    10 
 16    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
 16    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
 16    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
 16    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
 16    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
 16    16     2 pad (11) fixed bin,
 16    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
 16    18 
 16    19 
 16    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
 16    21     2 lock bit (36),				/* channel lock */
 16    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
 16    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
 16    24     2 flags unal,
 16    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
 16    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
 16    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
 16    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
 16    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
 16    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
 16    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
 16    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
 16    33       3 trace bit (1) unal,				/* ON to trace this channel */
 16    34       3 unused bit (1) unal,
 16    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
 16    36     2 major_channel_info,
 16    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
 16    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
 16    39     2 queue_entries,
 16    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
 16    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
 16    42     2 word_counts,
 16    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
 16    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
 16    45 
 16    46     2 meters,
 16    47       3 in_bytes fixed bin (35),
 16    48       3 out_bytes fixed bin (35),
 16    49       3 in,
 16    50         4 calls fixed bin (35),
 16    51         4 interrupts fixed bin (35),
 16    52         4 call_time fixed bin (71),
 16    53         4 interrupt_time fixed bin (71),
 16    54       3 out like lcte.meters.in,
 16    55       3 control like lcte.meters.in,
 16    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
 16    57 
 16    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
 16    59 
 16    60     2 pad (3) fixed bin (35);
 16    61 
 16    62 
 16    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
 16    64 
 16    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
 16    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
 16    67 
 16    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
 16    69 
 16    70 
 16    71 /* END INCLUDE FILE ... lct.incl.pl1 */
     3819 
     3820 
 17     1 /* BEGIN INCLUDE FILE...get_comm_meters_info.incl.pl1 */
 17     2 
 17     3 /* This include file defines the info structure(s) used with the get_meters order to MCM */
 17     4 /* A program that includes this include file must alos include lct.incl.pl1 */
 17     5 
 17     6 /* Written Decemeber 1980 by Robert Coren */
 17     7 
 17     8 dcl 1 get_comm_meters_info aligned based,		/* info_ptr points to this */
 17     9     2 version fixed bin,
 17    10     2 pad fixed bin,
 17    11     2 subchan_ptr pointer,				/* pointer to meters kept by the subchannel */
 17    12     2 logical_chan_ptr pointer,			/* pointer to meters kept by channel_manager */
 17    13     2 parent_ptr pointer,				/* pointer to meters kept by the parent multiplexer */
 17    14     2 subchan_type fixed bin,				/* multiplexer type of subchannel */
 17    15     2 parent_type fixed bin;				/* multiplexer type of parent */
 17    16 
 17    17 dcl 1 logical_chan_meters based aligned,		/* pointed to by get_comm_meters_info.logical_chan_ptr */
 17    18        2 current_meters like lcte.meters,		/* latest values */
 17    19        2 saved_meters like lcte.meters;			/* values as of last copy_meters */
 17    20 
 17    21 dcl  GET_COMM_METERS_INFO_VERSION_1 fixed bin int static options (constant) init (1);
 17    22 
 17    23 /* END INCLUDE FILE...get_comm_meters_info.incl.pl1 */
     3821 
     3822 
     3823 /* BEGIN MESSAGE DOCUMENTATION
     3824*
     3825*   Message:
     3826*   hasp_mpx (line TTY): No space available to preserve minor state; line will be hungup.
     3827*
     3828*   S:  $info
     3829*
     3830*   M:  Insufficient space was available in tty_buf to perform part of the critical input processing of the HASP
     3831*   multiplexer on channel TTY.  The connection to the remote host/workstation is broken as communications cannot continue
     3832*   under these conditions.
     3833*
     3834*   A:  $inform
     3835*   It may be necessary to increase the size of tty_buf as specified on the PARM config card before using this multiplexer
     3836*   again.
     3837*
     3838*
     3839*   Message:
     3840*   hasp_mpx (line TTY): No space available to save loopback chain; line will be hungup.
     3841*
     3842*   S:  $info
     3843*
     3844*   M:  Insufficient space was available in tty_buf to perform part of the critical input processing of the HASP
     3845*   multiplexer on channel TTY.  The connection to the remote host/workstation is broken as communications cannot continue
     3846*   under these conditions.
     3847*
     3848*   A:  $inform
     3849*   It may be necessary to increase the size of tty_buf as specified on the PARM config card before using this multiplexer
     3850*   again.
     3851*
     3852*
     3853*   Message:
     3854*   hasp_mpx (line TTY): Duplicate loopback block received: BCB = NNN
     3855*
     3856*   S:  $note
     3857*
     3858*   T:  $run
     3859*
     3860*   M:  The output block identified by the 3-digit octal sequence NNN was returned to Multics twice by the FNP for
     3861*   reprocessing.
     3862*
     3863*   A:  $inform
     3864*
     3865*
     3866*   Message:
     3867*   hasp_mpx (line TTY): Invalid input block header/trailer; line will be hungup.
     3868*
     3869*   S:  $note
     3870*
     3871*   T:  $run
     3872*
     3873*   M:  A data block whose format does not conform to the HASP protocol was received from the remote host/workstation by
     3874*   the HASP multiplexer on channel TTY.  The connection to the remote host/workstation is broken as communications cannot
     3875*   continue under these conditions.
     3876*
     3877*   A:  Frequent occurences of this message indicate that hardware or software problems may exist in the remote
     3878*   host/workstation.  The operator should contact the appropriate personnel before reusing the multiplexer.
     3879*
     3880*
     3881*   Message:
     3882*   hasp_mpx (line TTY): Block recevied out of sequence: expected = N, received = M; block ignored.
     3883*
     3884*   S:  $log
     3885*
     3886*   T:  $run
     3887*
     3888*   M:  A duplicate data block was received by the HASP multiplexer on channel TTY from the foreign host/workstation.
     3889*
     3890*   A:  The operator should ignore this message unless it occurs quite frequently.  Frequent occurences of this message
     3891*   indicate possible problems in the communications equipment which should be investigated by the appropriate personnel.
     3892*
     3893*
     3894*   Message:
     3895*   hasp_mpx (line TTY): Block received out of sequence: expected = N, recevied = M; line will be hungup.
     3896*
     3897*   S:  $note
     3898*
     3899*   T:  $run
     3900*
     3901*   M:  One or more data blocks from the remote host/workstation for the HASP multiplexer on channel TTY were lost.  The
     3902*   connection to the remote host/workstation is broken as communications cannot continue under these conditions.
     3903*
     3904*   A:  There are two possible causes for this message: communications equipment failures or problems in the remote
     3905*   host/workstation itself.  The operator should contact the appropriate personnel before reusing the multiplexer.
     3906*
     3907*
     3908*   Message:
     3909*   hasp_mpx (line TTY): Block transmitted out of sequence: expected = N, received = M; line will be hungup.
     3910*
     3911*   S:  $note
     3912*
     3913*   T:  $run
     3914*
     3915*   M:  One or more data blocks transmitted by the HASP multiplexer on channel TTY were not received by the remote
     3916*   host/workstation.  The connection to the remote host/workstation is broken as communications cannot continue
     3917*   under these conditions.
     3918*
     3919*   A:  $inform
     3920*   The HASP software is designed to prevent this situation even if the communications equipment is not functioning
     3921*   properly.
     3922*
     3923*
     3924*   Message:
     3925*   hasp_mpx (line TTY): Bad block line status from FNP; line will be hungup.
     3926*
     3927*   S:  $note
     3928*
     3929*   T:  $run
     3930*
     3931*   M:  A block generated by the HASP multiplexer on channel TTY for transmission was malformed.  The connection to the
     3932*   remote host/workstation is broken as communications cannot continue under these conditions.
     3933*
     3934*   A:  $inform
     3935*
     3936*
     3937*   Message:
     3938*   hasp_mpx (line TTY): Too many NAKs; line will be hungup.
     3939*
     3940*   S:  $note
     3941*
     3942*   T:  $run
     3943*
     3944*   M:  A block could not be transmitted or received by the HASP multiplexer on channel TTY because of excessive line
     3945*   noise.  The connection to the remote host/workstation is broken as communications cannot continue
     3946*   under these conditions.
     3947*
     3948*   A:  The operator should contact the appropriate personnel to check the communications equipment used by the line before
     3949*   attempting to reuse this multiplexer.
     3950*
     3951*   END MESSAGE DOCUMENTATION */
     3952 
     3953      end hasp_mpx;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0857.7  hasp_mpx.pl1                      >spec>install>1115>hasp_mpx.pl1
3791         1    03/27/82  0429.7  hasp_mpx_data.incl.pl1            >ldd>include>hasp_mpx_data.incl.pl1
3793         2    10/20/82  0938.5  hasp_load_data.incl.pl1           >ldd>include>hasp_load_data.incl.pl1
2-56         3    03/27/82  0436.6  hasp_device_data.incl.pl1         >ldd>include>hasp_device_data.incl.pl1
3795         4    03/27/82  0429.7  hasp_mpx_meters.incl.pl1          >ldd>include>hasp_mpx_meters.incl.pl1
3797         5    03/27/82  0429.7  hasp_subchannel_meters.incl.pl1   >ldd>include>hasp_subchannel_meters.incl.pl1
3799         6    03/27/82  0429.7  hasp_block_record_data.incl.pl1   >ldd>include>hasp_block_record_data.incl.pl1
3801         7    03/27/82  0436.6  hasp_rcb_byte.incl.pl1            >ldd>include>hasp_rcb_byte.incl.pl1
3803         8    03/27/82  0436.6  hasp_srcb_scb_bytes.incl.pl1      >ldd>include>hasp_srcb_scb_bytes.incl.pl1
3805         9    03/27/82  0429.7  hasp_signon_record_info.incl.pl1  >ldd>include>hasp_signon_record_info.incl.pl1
3807        10    04/23/84  0745.1  bisync_line_data.incl.pl1         >ldd>include>bisync_line_data.incl.pl1
3809        11    10/20/82  0938.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
3811        12    07/21/88  2036.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
3813        13    03/19/81  1131.8  mcs_modes_change_list.incl.pl1    >ldd>include>mcs_modes_change_list.incl.pl1
3815        14    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
3817        15    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
3819        16    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
3821        17    06/18/81  0900.6  get_comm_meters_info.incl.pl1     >ldd>include>get_comm_meters_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCEPT_BID                             constant        fixed bin(17,0)          initial dcl 10-21 set ref 477*
CONFIGURE                              constant        fixed bin(17,0)          initial dcl 10-21 set ref 472*
CRASH                                  constant        fixed bin(17,0)          initial dcl 11-12 set ref 985*
DIALUP                          000176 constant        fixed bin(17,0)          initial dcl 11-10 set ref 816*
DLE                                    constant        char(1)                  initial packed unaligned dcl 150 ref 1397 1544 1561
                                                                                  3155 3196 3247 3256 3591 3598
GET_COMM_METERS_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 17-21 ref 688
HANGUP                                 constant        fixed bin(17,0)          initial dcl 11-11 set ref 603*
HASP_BAD_BCB_RECORD                    constant        fixed bin(17,0)          initial dcl 6-96 ref 1693 3674
HASP_BCB_IGNORE                        constant        fixed bin(3,0)           initial unsigned dcl 6-176 ref 1635
HASP_BCB_NORMAL                        constant        fixed bin(3,0)           initial unsigned dcl 6-176 ref 1600 2594
HASP_BCB_RESET                         constant        fixed bin(3,0)           initial unsigned dcl 6-176 ref 1638 2591
HASP_CONSOLE                           constant        fixed bin(17,0)          initial dcl 3-6 ref 362 593 651 787 1852 1880 2147
                                                                                  3028 3033 3081 3108
HASP_CONSOLE_INPUT_RCB                 based           char(1)                  dcl 6-117 set ref 2147 3084 3084
HASP_CONSOLE_INPUT_RCB_BITS     000121 constant        bit(9)                   initial dcl 6-108 set ref 2147 3084 3084
HASP_CONSOLE_OUTPUT_RCB                based           char(1)                  dcl 6-117 set ref 2147 3081 3081
HASP_CONSOLE_OUTPUT_RCB_BITS    000120 constant        bit(9)                   initial dcl 6-108 set ref 2147 3081 3081
HASP_DATA_RECORD                       constant        fixed bin(17,0)          initial dcl 6-96 ref 1833 2012 3686
HASP_EOB_RCB                           based           char(1)                  dcl 6-117 ref 1617 3467
HASP_EOB_RCB_BITS                      constant        bit(9)                   initial dcl 6-108 set ref 1617 3467
HASP_EOB_RECORD                        constant        fixed bin(17,0)          initial dcl 6-96 ref 1686 1826 2005 3688
HASP_EOF_FIRST_SCB                     based           char(1)                  dcl 6-117 ref 3683
HASP_EOF_FIRST_SCB_BITS                constant        bit(9)                   initial dcl 6-108 set ref 3683
HASP_EOF_RECORD                        constant        fixed bin(17,0)          initial dcl 6-96 ref 1833 1850 2012 2866 3108 3683
HASP_EOF_SRCB                          based           char(1)                  dcl 6-117 ref 3683
HASP_EOF_SRCB_BITS              000116 constant        bit(9)                   initial dcl 6-108 set ref 3683
HASP_EOR_SCB                           based           char(1)                  dcl 8-98 ref 3501
HASP_EOR_SCB_BITS                      constant        bit(9)                   initial dcl 8-97 set ref 3501
HASP_FCS_ACKNOWLEDGE_BLOCK             constant        fixed bin(2,0)           initial unsigned dcl 6-202 ref 2440
HASP_FCS_NORMAL_BLOCK                  constant        fixed bin(2,0)           initial unsigned dcl 6-202 ref 1648
HASP_FCS_SYNC_BLOCK                    constant        fixed bin(2,0)           initial unsigned dcl 6-202 ref 1418
HASP_GENERAL_CONTROL_RCB               based           char(1)                  dcl 6-117 ref 3472
HASP_GENERAL_CONTROL_RCB_BITS   000122 constant        bit(9)                   initial dcl 6-108 set ref 3472
HASP_HOST                              constant        fixed bin(17,0)          initial dcl 2-52 ref 3081
HASP_MPX_DOWN                   000126 constant        fixed bin(71,0)          initial dcl 2-22 set ref 488* 3337*
HASP_MPX_MASKED                 000124 constant        fixed bin(71,0)          initial dcl 2-22 set ref 572*
HASP_MPX_UP                     000130 constant        fixed bin(71,0)          initial dcl 2-22 set ref 924*
HASP_RCB_STREAM_BAD_BCB                constant        fixed bin(3,0)           initial unsigned dcl 7-23 ref 3674
HASP_RCB_STREAM_CONTROL                constant        fixed bin(3,0)           initial unsigned dcl 7-23 ref 3677
HASP_RCB_STREAM_RTS                    constant        fixed bin(3,0)           initial unsigned dcl 7-23 ref 3664
HASP_RCB_STREAM_RTS_ACK                constant        fixed bin(3,0)           initial unsigned dcl 7-23 ref 3671
HASP_RCB_TYPE_CONTROL                  constant        fixed bin(4,0)           initial unsigned dcl 7-15 ref 3664
HASP_RCB_TYPE_PRINT_OUTPUT             constant        fixed bin(4,0)           initial unsigned dcl 7-15 ref 1863
HASP_RCB_TYPE_PUNCH_OUTPUT             constant        fixed bin(4,0)           initial unsigned dcl 7-15 ref 1865
HASP_RCB_TYPE_READER_INPUT             constant        fixed bin(4,0)           initial unsigned dcl 7-15 ref 1863
HASP_RTS_ACK_RECORD                    constant        fixed bin(17,0)          initial dcl 6-96 ref 1888 2061 3671
HASP_RTS_RECORD                        constant        fixed bin(17,0)          initial dcl 6-96 ref 1871 2044 3664
HASP_SIGNON_HANGUP              000112 constant        fixed bin(71,0)          initial dcl 9-20 set ref 948*
HASP_SIGNON_OK                  000114 constant        fixed bin(71,0)          initial dcl 9-20 set ref 3360*
HASP_SIGNON_RECORD                     constant        fixed bin(17,0)          initial dcl 6-96 ref 3677
HASP_SIGNON_SRCB                       based           char(1)                  dcl 6-117 ref 3677
HASP_SIGNON_SRCB_BITS           000117 constant        bit(9)                   initial dcl 6-108 set ref 3677
HASP_SUBCHANNEL_METERS_DATA_VERSION_1  constant        fixed bin(17,0)          initial dcl 5-17 ref 692
HASP_WORKSTATION                       constant        fixed bin(17,0)          initial dcl 2-52 ref 473 473 651 675 880
HMD_DOWN                               constant        fixed bin(17,0)          initial dcl 1-78 ref 940
HMD_HANGUP_LINE                        constant        fixed bin(17,0)          initial dcl 1-84 ref 2354 2362 2398
HMD_LOADED                             constant        fixed bin(17,0)          initial dcl 1-78 ref 499 509 518 559 587 764 876 942
                                                                                  3384
HMD_LOADING                            constant        fixed bin(17,0)          initial dcl 1-78 ref 468 3334 3376
HMD_LOOPBACK                           constant        fixed bin(17,0)          initial dcl 1-84 ref 1737 2536 2540
HMD_NORMAL                             constant        fixed bin(17,0)          initial dcl 1-84 ref 339 593 882 1733 2128 2448 2486
                                                                                  2562 3365
HMD_REPROCESS                          constant        fixed bin(17,0)          initial dcl 1-84 ref 300 434 501 529 629 1587 1730
                                                                                  1741 1744 2412 2486 3384
HMD_SEND_BAD_BCB_BLOCK                 constant        fixed bin(17,0)          initial dcl 1-84 ref 1629 2354 2371
HMD_SEND_SIGNON                        constant        fixed bin(17,0)          initial dcl 1-84 ref 656 880 945 2412 2443
HMD_SEND_SYNC_BLOCK                    constant        fixed bin(17,0)          initial dcl 1-84 set ref 1589* 1737 2354 2519
HMD_STARTED                            constant        fixed bin(17,0)          initial dcl 1-78 ref 593 598 3366
HMD_WAIT_SIGNON_RESPONSE               constant        fixed bin(17,0)          initial dcl 1-84 ref 945 2443 2543 3355
HSTE_DIALED                            constant        fixed bin(17,0)          initial dcl 1-137 ref 248 315 814 2619
HSTE_HUNGUP                            constant        fixed bin(17,0)          initial dcl 1-137 ref 838 916
HSTE_INPUT_ONLY                        constant        fixed bin(17,0)          initial dcl 1-149 ref 322 613 698 787 804 818 855
                                                                                  1662 2020 2460 2724
HSTE_INPUT_OUTPUT                      constant        fixed bin(17,0)          initial dcl 1-149 ref 804 855
HSTE_LISTENING                         constant        fixed bin(17,0)          initial dcl 1-137 ref 591 591 593 598 3369
HSTE_NORMAL                            constant        fixed bin(17,0)          initial dcl 1-143 ref 362 395 794 1897 2882 2928
                                                                                  2955 2994
HSTE_OUTPUT_ONLY                       constant        fixed bin(17,0)          initial dcl 1-149 ref 251 697 821 1841 1880 2616
                                                                                  2753
HSTE_SEND_RTS                          constant        fixed bin(17,0)          initial dcl 1-143 ref 377 787 2053 2929 2956 3108
HSTE_WAIT_RTS_ACK                      constant        fixed bin(17,0)          initial dcl 1-143 ref 385 2746
INPUT                           000112 constant        bit(1)                   initial packed unaligned dcl 15-20 set ref 523* 623*
                                                                                  840* 956* 959* 1166* 1341* 1389* 1426* 1445* 1511*
                                                                                  1621* 1628* 1689* 1701* 1727* 1921* 2092* 2179*
                                                                                  2206 2276*
INPUT_AVAILABLE                 000164 constant        fixed bin(17,0)          initial dcl 11-14 set ref 823* 1290* 1312* 1317*
LOG_AND_PRINT                   000163 constant        fixed bin(17,0)          initial dcl 152 set ref 1018* 1114* 1423* 1448*
                                                                                  1625* 1697* 3342* 3349*
LOG_ONLY                        000164 constant        fixed bin(17,0)          initial dcl 152 set ref 1613*
NUL                             000163 constant        char(1)                  initial packed unaligned dcl 149 ref 1827 2006 2588
                                                                                  2603 3481 3645 3656
OUTPUT                          000162 constant        bit(1)                   initial packed unaligned dcl 15-21 set ref 316* 323*
                                                                                  616* 843* 953* 962* 1080* 2208 2379* 2383* 2424*
                                                                                  2427* 2502* 2527* 2557* 2678* 2875* 2993* 3053*
                                                                                  3116* 3172* 3190* 3217*
P_bufferp                              parameter       pointer                  dcl 3614 in procedure "classify_record" ref 3611
                                                                                  3629
P_bufferp                              parameter       pointer                  dcl 3754 in procedure "delete_text" ref 3751 3762
                                                                                  3764 3764 3767 3767
P_bufferp                              parameter       pointer                  dcl 3236 in procedure "count_dles" ref 3234 3244
P_chain_ptr                            parameter       pointer                  dcl 76 set ref 239 244* 273* 308 313 317* 324* 350*
                                                                                  426* 444*
P_code                                 parameter       fixed bin(35,0)          dcl 74 set ref 233* 239 246* 252* 308 318* 325* 329*
                                                                                  410* 578 706* 711 717 722* 739* 749 753*
P_count_dles                           parameter       bit(1)                   dcl 3433 ref 3426 3457
P_direction                            parameter       bit(1)                   packed unaligned dcl 3781 set ref 3777 3783*
P_dle_count                            parameter       fixed bin(17,0)          dcl 2801 in procedure "output_records_processor" ref
                                                                                  2910 2918
P_dle_count                            parameter       fixed bin(17,0)          dcl 3439 in procedure "find_next_record" set ref
                                                                                  3426 3453* 3521* 3561*
P_end_bufferp                          parameter       pointer                  dcl 2798 in procedure "output_records_processor" ref
                                                                                  2910 2916
P_end_bufferp                          parameter       pointer                  dcl 3435 in procedure "find_next_record" set ref
                                                                                  3426 3452* 3517*
P_end_record_idx                       parameter       fixed bin(17,0)          dcl 2799 in procedure "output_records_processor" ref
                                                                                  2910 2917
P_end_record_idx                       parameter       fixed bin(17,0)          dcl 3436 in procedure "find_next_record" set ref
                                                                                  3426 3453* 3519*
P_first_bufferp                        parameter       pointer                  dcl 3780 in procedure "trace_block" set ref 3777
                                                                                  3783* 3785*
P_first_bufferp                        parameter       pointer                  dcl 1361 in procedure "process_input_block" ref 1358
                                                                                  1374
P_free_buffers                         parameter       bit(1)                   dcl 3076 ref 3073 3112
P_hmd_ptr                              parameter       pointer                  dcl 72 ref 207 210 222 226 239 308 453 457 578 711
                                                                                  717 749 762
P_info_ptr                             parameter       pointer                  dcl 84 ref 578 584
P_interrupt_data                       parameter       bit(72)                  dcl 81 ref 453 460
P_interrupt_type                       parameter       fixed bin(17,0)          dcl 836 in procedure "signal_hangup" set ref 833
                                                                                  862*
P_interrupt_type                       parameter       fixed bin(17,0)          dcl 80 in procedure "hasp_mpx" ref 453 459
P_line_ctl_opcode                      parameter       fixed bin(17,0)          dcl 3306 ref 3303 3308
P_line_ctl_val1                        parameter       fixed bin(17,0)          dcl 3306 ref 3303 3310
P_line_ctl_val2                        parameter       fixed bin(17,0)          dcl 3306 ref 3303 3311
P_line_ctl_val3                        parameter       fixed bin(17,0)          dcl 3306 ref 3303 3312
P_mclp                                 parameter       pointer                  dcl 86 ref 711 717 721
P_modes                                parameter       char                     packed unaligned dcl 88 set ref 749 752*
P_more_input                           parameter       bit(1)                   dcl 78 set ref 239 245*
P_n_characters                         parameter       fixed bin(17,0)          dcl 3577 in procedure "count_dles" ref 3575 3586
P_n_characters                         parameter       fixed bin(17,0)          dcl 3531 in procedure "advance_pointer" ref 3528
                                                                                  3536 3539
P_new_minor_state                      parameter       fixed bin(17,0)          dcl 1003 ref 1013 1032
P_order                                parameter       char                     packed unaligned dcl 83 ref 578 583
P_position                             parameter       fixed bin(17,0)          dcl 3755 ref 3751 3762 3764 3764
P_rcb_char                             parameter       char(1)                  packed unaligned dcl 2140 ref 2138 2147 2147 2152
P_rcb_idx                              parameter       fixed bin(17,0)          dcl 3615 ref 3611 3630
P_rcb_included                         parameter       bit(1)                   dcl 3432 ref 3426 3467
P_record_lth                           parameter       fixed bin(17,0)          dcl 3740 in procedure
                                                                                  "space_in_empty_output_block_for_recordp" ref 3737
                                                                                  3742
P_record_lth                           parameter       fixed bin(17,0)          dcl 3711 in procedure
                                                                                  "space_in_output_block_for_recordp" ref 3708 3713
P_record_tally                         parameter       fixed bin(17,0)          dcl 2800 in procedure "output_records_processor" ref
                                                                                  2910 2918
P_record_tally                         parameter       fixed bin(17,0)          dcl 3438 in procedure "find_next_record" set ref
                                                                                  3426 3453* 3520* 3560*
P_record_was_taken                     parameter       bit(1)                   dcl 2802 set ref 2910 2920* 2938*
P_start_bufferp                        parameter       pointer                  dcl 2798 in procedure "output_records_processor" ref
                                                                                  2910 2914
P_start_bufferp                        parameter       pointer                  dcl 3430 in procedure "find_next_record" ref 3426
                                                                                  3455
P_start_record_idx                     parameter       fixed bin(17,0)          dcl 2799 in procedure "output_records_processor" ref
                                                                                  2910 2915
P_start_record_idx                     parameter       fixed bin(17,0)          dcl 3431 in procedure "find_next_record" ref 3426
                                                                                  3456
P_subchannel_idx                       parameter       fixed bin(17,0)          dcl 73 ref 207 211 239 308 578 711 717 749 769
P_text_lth                             parameter       fixed bin(17,0)          dcl 3128 in procedure "add_to_output_block" ref 3124
                                                                                  3144
P_text_lth                             parameter       fixed bin(17,0)          dcl 3756 in procedure "delete_text" ref 3751 3762
                                                                                  3764 3767
P_text_ptr                             parameter       pointer                  dcl 3127 ref 3124 3143
SEND_OUTPUT                     000170 constant        fixed bin(17,0)          initial dcl 11-13 set ref 430* 619* 818* 1268* 1900*
                                                                                  2470*
SET_HASP_MODE                          constant        fixed bin(17,0)          initial dcl 10-21 set ref 471*
SET_HASP_TIMERS                 000136 constant        fixed bin(17,0)          initial dcl 10-21 set ref 475*
SET_MASTER_SLAVE_MODE                  constant        fixed bin(17,0)          initial dcl 10-21 set ref 473*
SET_NAK_LIMIT                   000143 constant        fixed bin(17,0)          initial dcl 10-21 set ref 476*
SIGNON_RECORD_INFO_VERSION_1           constant        fixed bin(17,0)          initial dcl 9-14 ref 656
TEMPLATE_HASP_BAD_BCB_BLOCK            based           structure                level 1 dcl 6-71 ref 2386 2387
TEMPLATE_HASP_BAD_BCB_BLOCK_BITS
                                000055 constant        structure                level 1 dcl 6-59 set ref 2386 2387
TEMPLATE_HASP_BAD_BCB_RECORD           based           structure                level 1 dcl 6-134
TEMPLATE_HASP_BLOCK_HEADER             based           structure                level 1 dcl 6-14 ref 2508 2509 3059 3061 3700 3742
TEMPLATE_HASP_BLOCK_HEADER_BITS 000022 constant        structure                level 1 dcl 6-8 set ref 2508 2509 3059 3061 3700
                                                                                  3742
TEMPLATE_HASP_BLOCK_TRAILER            based           structure                level 1 dcl 6-29 set ref 3713 3742
TEMPLATE_HASP_BLOCK_TRAILER_BITS
                                000024 constant        structure                level 1 dcl 6-22 set ref 2661 2665 2667 2674 2683
                                                                                  2690 3713 3742
TEMPLATE_HASP_RTS_ACK_RECORD           based           structure                level 1 dcl 6-160 ref 2763 2769 2771
TEMPLATE_HASP_RTS_ACK_RECORD_BITS
                                000063 constant        structure                level 1 dcl 6-155 set ref 2763 2769 2771
TEMPLATE_HASP_RTS_RECORD               based           structure                level 1 dcl 6-147 ref 2734 2740 2742 3728 3728
TEMPLATE_HASP_RTS_RECORD_BITS   000062 constant        structure                level 1 dcl 6-142 set ref 2734 2740 2742 3728 3728
TEMPLATE_HASP_SIGNON_BLOCK             based           structure                level 1 dcl 6-49
TEMPLATE_HASP_SIGNON_BLOCK_BITS 000026 constant        structure                level 1 dcl 6-36 set ref 2433 2435
TEMPLATE_HASP_SYNC_BLOCK               based           structure                level 1 dcl 6-90 ref 2530 2531
TEMPLATE_HASP_SYNC_BLOCK_BITS   000060 constant        structure                level 1 dcl 6-81 set ref 2530 2531
WRU_TIMEOUT                     000140 constant        fixed bin(17,0)          initial dcl 11-20 set ref 606*
abort_info                             based           structure                level 1 dcl 135
accept_records                  000746 automatic       bit(1)                   dcl 3020 set ref 3022* 3036* 3040* 3042
add_dle                         001007 automatic       bit(1)                   dcl 3140 set ref 3157* 3161* 3187
addr                                                   builtin function         dcl 177 ref 212 225 242 311 456 478 478 581 726 770
                                                                                  984 1266 1406 1418 1544 1561 1584 1598 1600 1617
                                                                                  1635 1638 1647 1648 1654 1658 1666 1668 1670 1695
                                                                                  1696 1696 1863 1863 1863 1865 1865 2147 2147 2147
                                                                                  2152 2261 2261 2300 2302 2386 2386 2387 2389 2389
                                                                                  2392 2392 2433 2433 2434 2435 2440 2440 2458 2508
                                                                                  2508 2509 2530 2530 2531 2589 2591 2594 2595 2604
                                                                                  2604 2607 2610 2610 2612 2619 2625 2627 2629 2661
                                                                                  2665 2665 2667 2674 2674 2674 2683 2683 2683 2690
                                                                                  2693 2694 2701 2703 2703 2734 2734 2737 2740 2742
                                                                                  2763 2763 2766 2769 2771 3059 3059 3061 3081 3081
                                                                                  3081 3081 3084 3084 3084 3084 3085 3085 3098 3098
                                                                                  3166 3181 3196 3247 3256 3314 3314 3368 3467 3472
                                                                                  3501 3504 3504 3508 3591 3598 3664 3664 3664 3671
                                                                                  3674 3677 3677 3683 3683 3700 3713 3728 3728 3742
                                                                                  3742 3764 3764
amount_in_buffer                001111 automatic       fixed bin(17,0)          dcl 3533 set ref 3543* 3545 3554* 3555
amount_left                     001110 automatic       fixed bin(17,0)          dcl 3533 set ref 3539* 3541 3545 3547* 3548 3549*
                                                                                  3555* 3555 3560
amount_needed                   000661 automatic       fixed bin(17,0)          dcl 2655 set ref 2661* 2663 2683 2683 2685
amount_to_copy                  000614 automatic       fixed bin(17,0)          dcl 2201 set ref 2244* 2251 2255 2266* 2266 2268
                                                                                  2273* 2283 2283*
based_bad_bcb_block                    based           structure                level 1 packed packed unaligned dcl 114 set ref
                                                                                  2386*
based_bad_bcb_record                   based           structure                level 1 packed packed unaligned dcl 115
based_block_header                     based           structure                level 1 packed packed unaligned dcl 109 set ref
                                                                                  2508* 3059*
based_block_trailer                    based           structure                level 1 packed packed unaligned dcl 110
based_buffer_remainder                 based           char                     packed unaligned dcl 3135 set ref 3166*
based_character                        based           char(1)                  packed unaligned dcl 3136 set ref 3196*
based_part1                            based           char                     packed unaligned dcl 2651 set ref 2674*
based_part2                            based           char                     packed unaligned dcl 2652 set ref 2683*
based_remainder                        based           char                     packed unaligned dcl 3758 set ref 3764* 3764
based_rts_ack_record                   based           structure                level 1 packed packed unaligned dcl 120 set ref
                                                                                  2763*
based_rts_record                       based           structure                level 1 packed packed unaligned dcl 119 set ref
                                                                                  2734*
based_signon_block                     based           structure                level 1 packed packed unaligned dcl 112
based_split_block_trailer              based           structure                level 1 dcl 2647
based_substring                        based           char                     packed unaligned dcl 3134 set ref 3181*
based_sync_block                       based           structure                level 1 packed packed unaligned dcl 117 set ref
                                                                                  2530*
bcb                       0(18)        based           char(1)                  level 2 in structure "based_block_header" packed
                                                                                  packed unaligned dcl 109 in procedure "hasp_mpx"
                                                                                  set ref 2693*
bcb                       0(18)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_BAD_BCB_BLOCK"
                                                                                  packed packed unaligned dcl 6-71 in procedure
                                                                                  "hasp_mpx"
bcb                       0(18)        based           char(1)                  level 2 in structure "based_bad_bcb_block" packed
                                                                                  packed unaligned dcl 114 in procedure "hasp_mpx"
                                                                                  set ref 2389
bcb                       0(18)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_BLOCK_HEADER"
                                                                                  packed packed unaligned dcl 6-14 in procedure
                                                                                  "hasp_mpx"
binary                                                 builtin function         dcl 177 ref 349 473 473 1056 1144 1433 1707 2240
                                                                                  2308 2686 3175 3193
bit_arrays               67            based           structure                level 2 dcl 1-10
block_type                0(12)        based           fixed bin(2,0)           level 3 in structure "foreign_fcs" packed packed
                                                                                  unsigned unaligned dcl 1367 in procedure
                                                                                  "process_input_block" set ref 1418 1648*
block_type                0(12)        based           fixed bin(2,0)           level 3 in structure "hasp_fcs_bytes" packed packed
                                                                                  unsigned unaligned dcl 6-185 in procedure
                                                                                  "hasp_mpx" set ref 2440*
blockp                          000162 automatic       pointer                  dcl 12-19 set ref 276* 277 277 277* 279* 1377* 1377*
                                                                                  1378 1378 1380* 1381 1462* 1467 1468 1469 1470*
                                                                                  1470 1477 1480 1484 1485* 1485 1502* 1506 1507
                                                                                  1507 1510 1511* 1512* 1516* 2383* 2384 2386 2387
                                                                                  2389 2392 2395 2396 2427* 2428 2430 2433 2434 2435
                                                                                  2440 2502* 2503 2505 2508 2509 2527* 2528 2530
                                                                                  2531 2533 2534
break                     0(20)        based           bit(1)                   level 3 packed packed unaligned dcl 12-28 set ref
                                                                                  277 2304* 2975
buffer                                 based           structure                level 1 dcl 12-28
buffer_size_code                000610 automatic       fixed bin(17,0)          dcl 2201 set ref 2210* 2212 2212 2228
buffer_text                            based           char                     packed unaligned dcl 3238 in procedure "count_dles"
                                                                                  ref 3247 3256
buffer_text                            based           char                     packed unaligned dcl 1526 in procedure "strip_dles"
                                                                                  ref 1544 1561
bufferp                         000756 automatic       pointer                  dcl 3051 in procedure "start_new_output_block" set
                                                                                  ref 3053* 3054 3059 3061 3063
bufferp                         000726 automatic       pointer                  dcl 2819 in procedure "output_records_processor" set
                                                                                  ref 2972* 2972* 2974 2974* 2975 2975 2977 2978*
                                                                                  2980* 2980* 2981 3087* 3089 3091 3094 3096 3098
                                                                                  3098 3101 3101* 3103* 3103 3112* 3112* 3115 3116*
bufferp                         000534 automatic       pointer                  dcl 1777 in procedure
                                                                                  "input_loopback_records_processor" set ref 1821*
                                                                                  1822 2000* 2001
bufferp                         001066 automatic       pointer                  dcl 3441 in procedure "find_next_record" set ref
                                                                                  3455* 3467 3472 3478 3481 3482* 3499 3517 3543
                                                                                  3553 3556 3564* 3564 3591 3598
bufferp                         000560 automatic       pointer                  dcl 2166 in procedure "flush_record_buffers" set ref
                                                                                  2168* 2170 2172 2172* 2176 2178 2179* 2180*
bufferp                         000654 automatic       pointer                  dcl 2654 in procedure "finish_output_block" set ref
                                                                                  2658* 2660 2660 2665 2665 2667 2667 2672 2674 2674
                                                                                  2676 2676 2680 2686
bufferp                         001016 automatic       pointer                  dcl 3240 in procedure "count_dles" set ref 3244*
                                                                                  3247 3247 3254 3256 3256
bufferp                         000454 automatic       pointer                  dcl 1527 in procedure "strip_dles" set ref 1535*
                                                                                  1535* 1544 1544 1550 1550* 1553 1553 1559 1561
                                                                                  1561* 1563
bufferp                         001000 automatic       pointer                  dcl 3138 in procedure "add_to_output_block" set ref
                                                                                  3146* 3152 3152 3166 3166 3168 3168 3175 3176*
                                                                                  3177 3181 3181 3183 3183 3188 3188 3193 3194* 3196
                                                                                  3196 3197 3197 3216* 3217*
bufferp                         001132 automatic       pointer                  dcl 3617 in procedure "classify_record" set ref
                                                                                  3629* 3632 3632 3634 3638* 3638 3640 3643 3643
                                                                                  3645 3649* 3649 3651 3654 3654 3656 3659
chain_head                      000160 automatic       bit(18)                  level 3 packed packed unaligned dcl 11-38 set ref
                                                                                  522
chain_ptr                       000102 automatic       pointer                  dcl 96 set ref 313* 316* 323* 349 350* 413 416 423*
                                                                                  426 428 444 522* 523* 525* 2840 2903*
chain_to_release_ptr            000470 automatic       pointer                  dcl 1576 set ref 1619* 1621 1621*
channel_manager$control         000076 constant        entry                    external dcl 14-13 ref 478 1021 1117 1449 1700 2362
                                                                                  3314 3345 3351
channel_manager$interrupt       000100 constant        entry                    external dcl 14-25 ref 430 606 619 816 818 823 862
                                                                                  1290 1312 1317 1900
channel_manager$interrupt_later 000102 constant        entry                    external dcl 14-28 ref 1268 2470
channel_manager$read            000072 constant        entry                    external dcl 14-7 ref 1339
channel_manager$write           000074 constant        entry                    external dcl 14-10 ref 3279
characters_in_buffer            000432 automatic       fixed bin(17,0)          dcl 1460 set ref 1477* 1479 1482
characters_left_to_delete       000444 automatic       fixed bin(17,0)          dcl 1500 set ref 1503* 1506 1510* 1510 1516 1516*
characters_to_pickup            000431 automatic       fixed bin(17,0)          dcl 1460 set ref 1475* 1476 1477 1482* 1482 1483
characters_to_skip              000430 automatic       fixed bin(17,0)          dcl 1460 set ref 1466* 1467 1469* 1469 1474
chars                     1            based           char(1)                  array level 2 packed packed unaligned dcl 12-28 set
                                                                                  ref 1480 1480 1544 1561 1617* 1696 1812 1814 1822
                                                                                  1991 1993 2001 2261 2261 2386 2389 2392 2433 2434
                                                                                  2440 2508 2530 2665 2674 2683 2693 2694 2734 2737
                                                                                  2763 2766 3059 3098 3098 3166 3181 3196 3247 3256
                                                                                  3467 3472 3481 3499 3591 3598 3632 3640 3643 3651
                                                                                  3654 3659 3764 3764
clock                                                  builtin function         dcl 177 ref 878
code                            000101 automatic       fixed bin(35,0)          dcl 94 set ref 233 478* 488* 572* 585* 587* 609*
                                                                                  636* 643* 648* 651* 654* 656* 670* 672* 673* 675*
                                                                                  680* 685* 688* 692* 704* 706 765* 924* 948* 1021*
                                                                                  1117* 1339* 1340 1449* 1700* 2362* 3279* 3280 3282
                                                                                  3314* 3316 3337* 3345* 3351* 3360*
compressed_scb                         based           structure                level 1 packed packed unaligned dcl 3448
configuration_data       11            based           structure                level 2 dcl 1-10
console_hste_idx        112            based           fixed bin(17,0)          level 2 dcl 1-10 ref 1317 2724
console_wab               0(11)        based           bit(1)                   level 2 in structure "foreign_fcs" packed packed
                                                                                  unaligned dcl 1367 in procedure
                                                                                  "process_input_block" ref 1666
console_wab               0(11)        based           bit(1)                   level 2 in structure "local_fcs" packed packed
                                                                                  unaligned dcl 2341 in procedure
                                                                                  "process_output_block" set ref 2612* 2619*
continue_scan                   000532 automatic       bit(1)                   dcl 1775 in procedure
                                                                                  "input_loopback_records_processor" set ref 1795*
                                                                                  1797 1931* 1934* 1973* 1976 2100* 2104*
continue_scan                   000724 automatic       bit(1)                   dcl 2817 in procedure "output_records_processor" set
                                                                                  ref 2843* 2845 2857* 2882* 2886* 2890* 2967* 2969
                                                                                  2994* 2998*
copy                                                   builtin function         dcl 177 ref 2603
count                     0(05)        based           fixed bin(4,0)           level 2 in structure "local_bcb" packed packed
                                                                                  unsigned unaligned dcl 2340 in procedure
                                                                                  "process_output_block" set ref 2595* 2701
count                           001121 automatic       fixed bin(17,0)          dcl 3580 in procedure "count_dles" set ref 3588*
                                                                                  3594* 3594 3601
count                     0(05)        based           fixed bin(4,0)           level 2 in structure "foreign_bcb" packed packed
                                                                                  unsigned unaligned dcl 1366 in procedure
                                                                                  "process_input_block" ref 1598 1695
count                     0(05)        based           fixed bin(4,0)           level 2 in structure "hasp_bcb_byte" packed packed
                                                                                  unsigned unaligned dcl 6-168 in procedure
                                                                                  "hasp_mpx" set ref 1696 2389* 2392*
count                     0(03)        based           fixed bin(6,0)           level 2 in structure "not_compressed_scb" packed
                                                                                  packed unsigned unaligned dcl 3449 in procedure
                                                                                  "find_next_record" ref 3504
count_dles_sw                   001076 automatic       bit(1)                   dcl 3443 set ref 3457* 3583
current_input_bufferp           000604 automatic       pointer                  dcl 2200 set ref 2246* 2255 2261 2268 2270 2275 2276
                                                                                  2276* 2279*
current_input_idx               000615 automatic       fixed bin(17,0)          dcl 2201 set ref 2247* 2255 2261 2265* 2265 2268
                                                                                  2280*
current_meters            2            based           structure                level 2 dcl 5-6 set ref 699*
current_output_bufferp          000602 automatic       pointer                  dcl 2200 set ref 2231* 2232 2238 2240 2242 2249*
                                                                                  2253 2253 2261 2261 2264 2264 2283 2283 2283 2289*
                                                                                  2289 2292 2294 2296 2297
currentsize                                            builtin function         dcl 177 ref 965 965 1065 1065 1087 1087 1150 1150
                                                                                  1169 1169 3362 3362
device_n_foreign_wab_set
                        156            based           fixed bin(35,0)          array level 5 dcl 1-10 set ref 1671* 1671
device_n_input_eof_records
                         41            based           fixed bin(35,0)          level 4 dcl 1-99 set ref 1850* 1850
device_n_input_records
                         40            based           fixed bin(35,0)          level 4 dcl 1-99 set ref 1849* 1849
device_n_local_wab_set
                         37            based           fixed bin(35,0)          level 4 dcl 1-99 set ref 1855* 1855
device_n_output_eof_records
                         44            based           fixed bin(35,0)          level 4 dcl 1-99 set ref 2866* 2866
device_n_output_records
                         43            based           fixed bin(35,0)          level 4 dcl 1-99 set ref 2865* 2865
device_not_ready          0(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1367 set ref
                                                                                  1584
device_type               3            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" ref 362 593 646 651 787 1852 1880 3028
                                                                                  3033 3081 3108
device_type             117            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 2147
device_wab_idx          123            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1666 1668 1668
                                                                                  1670 1671 1674 2619 2619 2625 2625 2627 2724 2745
                                                                                  2753 2774
device_wab_idx            7            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" ref 290 339 377 626 628 806 807 810 857
                                                                                  858 860 1855 1857 1880 2025 2069 2460 2929 2956
devx                    121            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1080* 1290* 1312*
                                                                                  1317*
devx                      5            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 316* 323* 430* 606* 616* 619*
                                                                                  623* 816* 818* 823* 840* 843* 862* 1268* 1900*
                                                                                  2219* 2231* 2233* 2295* 2470* 2875* 2993* 3116*
devx                     10            based           fixed bin(17,0)          level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 447* 478* 953* 956* 959* 962*
                                                                                  1021* 1117* 1166* 1339* 1389* 1426* 1445* 1449*
                                                                                  1511* 1621* 1628* 1689* 1700* 1701* 1727* 1921*
                                                                                  1949* 2092* 2122* 2179* 2276* 2362* 2379* 2383*
                                                                                  2424* 2427* 2502* 2527* 2575* 2678* 3053* 3172*
                                                                                  3190* 3217* 3279* 3285* 3314* 3345* 3351* 3783*
                                                                                  3785*
dialup_info              26            based           structure                level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 470* 812
dialup_info                     000156 automatic       structure                level 1 dcl 11-30 in procedure "hasp_mpx"
dialup_info              10            based           structure                level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 812* 816 816
direction                 4            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" ref 251 322 613 697 698 787 804 804 818
                                                                                  821 855 855 1841 1880 2020 2460
direction                       000620 automatic       bit(1)                   packed unaligned dcl 2203 in procedure
                                                                                  "move_record_to_device" set ref 2206* 2208* 2219*
                                                                                  2231* 2233* 2295*
direction               120            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1662 2616 2724
                                                                                  2753
divide                                                 builtin function         dcl 177 ref 2210 2212 2228
dle_count                       000734 automatic       fixed bin(17,0)          dcl 2821 in procedure "output_records_processor" set
                                                                                  ref 2847* 2853 2891 2971*
dle_count                       000540 automatic       fixed bin(17,0)          dcl 1778 in procedure
                                                                                  "input_loopback_records_processor" set ref 1978*
                                                                                  2028*
dle_count                       001075 automatic       fixed bin(17,0)          dcl 3442 in procedure "find_next_record" set ref
                                                                                  3459* 3521 3547* 3547 3554* 3554 3561
dle_count                       001022 automatic       fixed bin(17,0)          dcl 3241 in procedure "count_dles" set ref 3249*
                                                                                  3252* 3252 3259
dle_idx                         000457 automatic       fixed bin(17,0)          dcl 1529 set ref 1544* 1546 1548* 1548 1550 1550
                                                                                  1557 1559* 1561*
end_bufferp                     000720 automatic       pointer                  dcl 2814 in procedure "output_records_processor" set
                                                                                  ref 2847* 2850 2869 2871 2873 2875* 2878 2916*
                                                                                  2977* 2984 2990 2992 2993* 3094 3101 3112
end_bufferp                     000524 automatic       pointer                  dcl 1766 in procedure
                                                                                  "input_loopback_records_processor" set ref 1799*
                                                                                  1802 1912 1915 1917 1919 1921* 1925 1978* 1981
                                                                                  2028* 2083 2086 2088 2090 2092* 2096 2172 2276
end_of_data_is_special          001077 automatic       bit(1)                   dcl 3443 set ref 3461* 3476* 3556
end_record_idx                  000527 automatic       fixed bin(17,0)          dcl 1767 in procedure
                                                                                  "input_loopback_records_processor" set ref 1799*
                                                                                  1915 1926 1978* 2028* 2086 2097
end_record_idx                  000723 automatic       fixed bin(17,0)          dcl 2815 in procedure "output_records_processor" set
                                                                                  ref 2847* 2869 2879 2917* 2984* 3094
entries                   6            based           structure                array level 2 dcl 13-10 set ref 726
eor_scb                   0(18)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_ACK_RECORD"
                                                                                  packed packed unaligned dcl 6-160 in procedure
                                                                                  "hasp_mpx"
eor_scb                   0(18)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_RECORD"
                                                                                  packed packed unaligned dcl 6-147 in procedure
                                                                                  "hasp_mpx"
error                     4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 13-26 set ref
                                                                                  738*
error_table_$action_not_performed
                                000030 external static fixed bin(35,0)          dcl 165 ref 186
error_table_$bad_mode           000032 external static fixed bin(35,0)          dcl 165 ref 187
error_table_$incorrect_device_type
                                000034 external static fixed bin(35,0)          dcl 165 ref 188
error_table_$invalid_read       000036 external static fixed bin(35,0)          dcl 165 ref 189
error_table_$invalid_state      000040 external static fixed bin(35,0)          dcl 165 ref 190
error_table_$invalid_write      000042 external static fixed bin(35,0)          dcl 165 ref 191
error_table_$long_record        000044 external static fixed bin(35,0)          dcl 165 ref 192
error_table_$noalloc            000046 external static fixed bin(35,0)          dcl 165 ref 193
error_table_$null_info_ptr      000050 external static fixed bin(35,0)          dcl 165 ref 194
error_table_$out_of_sequence    000052 external static fixed bin(35,0)          dcl 165 ref 195
error_table_$undefined_order_request
                                000054 external static fixed bin(35,0)          dcl 165 ref 196
error_table_$unimplemented_version
                                000056 external static fixed bin(35,0)          dcl 165 ref 197
et_action_not_performed         000010 internal static fixed bin(35,0)          dcl 156 set ref 186* 765
et_bad_mode                     000011 internal static fixed bin(35,0)          dcl 156 set ref 187* 739
et_incorrect_device_type        000012 internal static fixed bin(35,0)          dcl 156 set ref 188* 651
et_invalid_read                 000013 internal static fixed bin(35,0)          dcl 156 set ref 189* 252
et_invalid_state                000014 internal static fixed bin(35,0)          dcl 156 set ref 190* 587 654 675
et_invalid_write                000015 internal static fixed bin(35,0)          dcl 156 set ref 191* 325
et_long_record                  000016 internal static fixed bin(35,0)          dcl 156 set ref 192* 410
et_noalloc                      000017 internal static fixed bin(35,0)          dcl 156 set ref 193* 670 3282
et_null_info_ptr                000020 internal static fixed bin(35,0)          dcl 156 set ref 194* 609 636 643 648 685
et_out_of_sequence              000021 internal static fixed bin(35,0)          dcl 156 set ref 195* 672
et_undefined_order_request      000022 internal static fixed bin(35,0)          dcl 156 set ref 196* 673 680 704
et_unimplemented_version        000023 internal static fixed bin(35,0)          dcl 156 set ref 197* 656 688 692
event_channel             2            based           fixed bin(71,0)          level 2 in structure "sri" dcl 145 in procedure
                                                                                  "hasp_mpx" ref 666
event_channel             2            based           fixed bin(71,0)          level 2 in structure "hmd_signon_data" dcl 1-157
                                                                                  in procedure "hasp_mpx" set ref 666* 948* 3360*
expected_count                  000472 automatic       fixed bin(17,0)          dcl 1577 set ref 1597* 1606 1608 1608 1608 1608
                                                                                  1613* 1625* 1631 1696* 1697*
fcs                       0(27)        based           char(2)                  level 2 in structure "TEMPLATE_HASP_BLOCK_HEADER"
                                                                                  packed packed unaligned dcl 6-14 in procedure
                                                                                  "hasp_mpx"
fcs                       0(27)        based           char(2)                  level 2 in structure "based_block_header" packed
                                                                                  packed unaligned dcl 109 in procedure "hasp_mpx"
                                                                                  set ref 2440 2694*
first                    36            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 1185 1193 1193* 1217 1217*
                                                                                  1220 1257
first_bufferp                   000374 automatic       pointer                  dcl 1332 in procedure
                                                                                  "process_available_input_blocks" set ref 1339*
                                                                                  1341* 1343 1343*
first_bufferp                   000410 automatic       pointer                  dcl 1369 in procedure "process_input_block" set ref
                                                                                  1374* 1377 1426* 1431 1433 1445* 1462 1502 1507*
                                                                                  1512 1535 1616 1617 1618 1619 1620 1628* 1684*
                                                                                  1689* 1696 1701* 1705 1707 1727*
first_bufferp           134            based           pointer                  array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 918* 1287
first_bufferp             6            based           pointer                  array level 4 in structure "msse" dcl 1-168
                                                                                  in procedure "hasp_mpx" set ref 1051 1054 1056
                                                                                  1080 1080*
first_bufferp            54            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 908* 962 962* 972* 2377 2379*
                                                                                  2380* 2396* 2424 2424* 2430* 2499 2505* 2534* 2552
                                                                                  2555* 2693 2694 3026 3063* 3697
first_bufferp             2            based           pointer                  level 3 in structure "lbcse" dcl 1-182 in procedure
                                                                                  "hasp_mpx" set ref 1141 1142 1144 1166 1166*
first_bufferp            42            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 262 385 526 908* 956 956* 972*
                                                                                  1705 1705* 1792 1943*
first_bufferp           142            based           pointer                  array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 921* 1028* 1054*
first_bufferp             2            based           pointer                  level 2 in structure "record_data" dcl 2194
                                                                                  in procedure "move_record_to_device" set ref 2306
                                                                                  2306*
first_bufferp            26            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 339 787 2025 2053 2460 2467
                                                                                  2965 3004*
first_bufferp            32            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 348 350 352* 416* 418 615 616*
                                                                                  617* 639 798* 843 843* 850*
first_bufferp            46            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 908* 959 959* 972* 1142* 1431
                                                                                  1431* 1970 1973 2116* 2126
first_bufferp            20            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 265 273 276 281* 284* 621 623*
                                                                                  625* 840 840* 850*
first_char                      000416 automatic       char(1)                  dcl 1371 set ref 1394* 1397
first_foreign_block      70(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  893* 1600 1603*
first_idx                       000735 automatic       fixed bin(17,0)          dcl 2821 set ref 3091* 3093* 3098 3098 3098
first_output_bufferp            000576 automatic       pointer                  dcl 2200 set ref 2215* 2219* 2221 2222 2233 2233*
                                                                                  2238 2238* 2249 2306 2308
first_scb_char                  001137 automatic       char(1)                  packed unaligned dcl 3622 set ref 3654* 3656* 3659*
                                                                                  3683
flags                     1            based           structure                level 2 in structure "hasp_subchannel_meters_data"
                                                                                  dcl 5-6 in procedure "hasp_mpx" set ref 696*
flags                    21            based           structure                level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx"
flags                    70            based           structure                level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 887* 981*
flags                   152            based           structure                array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx"
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 12-28 in procedure "hasp_mpx"
flags                    36            based           structure                level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 801* 853*
flags                     4            based           structure                level 2 in structure "mcle" dcl 13-26 in procedure
                                                                                  "hasp_mpx"
foreign_bcb                            based           structure                level 1 packed packed unaligned dcl 1366
foreign_bcb_char                000406 automatic       char(1)                  packed unaligned dcl 1363 set ref 1400* 1421 1435
                                                                                  1598 1600 1635 1638 1695
foreign_block_count      32            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 1597 1604* 1606* 1630*
                                                                                  1638* 2389
foreign_fcs                            based           structure                level 1 packed packed unaligned dcl 1367
foreign_fcs_bytes        33            based           char(2)                  level 2 packed packed unaligned dcl 1-10 set ref
                                                                                  894* 1650 1652*
foreign_fcs_chars               000407 automatic       char(2)                  packed unaligned dcl 1364 set ref 1401* 1406 1418
                                                                                  1584 1647 1648 1650 1652 1654 1658 1666 1668 1670
get_comm_meters_info                   based           structure                level 1 dcl 17-8
get_device_type_info                   based           fixed bin(17,0)          dcl 143 set ref 646*
hasp_bcb_byte                          based           structure                level 1 packed packed unaligned dcl 6-168
hasp_compressed_scb_byte               based           structure                level 1 packed packed unaligned dcl 8-88
hasp_configuration_data                based           structure                level 1 dcl 2-30
hasp_fcs_bytes                         based           structure                level 1 packed packed unaligned dcl 6-185
hasp_mpx_meters                        based           structure                level 1 dcl 4-21
hasp_not_compressed_scb_byte           based           structure                level 1 packed packed unaligned dcl 8-82
hasp_rcb_byte                          based           structure                level 1 packed packed unaligned dcl 7-6
hasp_scb_byte                          based           structure                level 1 packed packed unaligned dcl 8-76
hasp_subchannel_meters                 based           structure                level 1 dcl 5-22 set ref 682* 700
hasp_subchannel_meters_data            based           structure                level 1 dcl 5-6
hbound                                                 builtin function         dcl 177 ref 462 3328
header                                 based           char(7)                  level 3 in structure "TEMPLATE_HASP_SIGNON_BLOCK"
                                                                                  packed packed unaligned dcl 6-49 in procedure
                                                                                  "hasp_mpx" ref 2433
header                                 based           char(7)                  level 3 in structure "based_signon_block" packed
                                                                                  packed unaligned dcl 112 in procedure "hasp_mpx"
                                                                                  set ref 2433*
hmd                                    based           structure                level 1 dcl 1-10
hmd_local_fcs                          based           structure                level 1 packed packed unaligned dcl 2645
hmd_ptr                         000136 automatic       pointer                  dcl 1-75 set ref 210* 212 226* 259 262 290 290 300
                                                                                  339 339 339 362 377 385 434 447 457* 468 470 473
                                                                                  473 475 475 475 476 478 478 478 488 488 497 499
                                                                                  501 507 509 516 518 523 526 526 529 559 572 572
                                                                                  587 593 593 598 626 628 629 651 654 656 656 664
                                                                                  675 675 762* 764 770 787 787 806 807 810 812 857
                                                                                  858 860 876 878 880 880 880 882 884 885 887 889
                                                                                  890 892 893 894 896 897 898 900 901 902 903 905
                                                                                  905 908 908 908 908 908 908 908 908 913 913 915
                                                                                  916 917 918 918 920 921 921 924 924 938 940 945
                                                                                  945 947 953 953 953 956 956 956 959 959 959 962
                                                                                  962 962 965 965 965 965 972 972 972 972 972 972
                                                                                  972 972 977 977 979 981 983 984 1016 1016 1018
                                                                                  1021 1025 1026 1027 1028 1028 1031 1032 1034 1035
                                                                                  1045 1048 1050 1052 1052 1054 1054 1056 1058 1062
                                                                                  1063 1065 1065 1076 1079 1080 1087 1087 1090 1114
                                                                                  1117 1121 1122 1124 1125 1136 1139 1142 1142 1144
                                                                                  1145 1148 1161 1166 1172 1185 1189 1193 1193 1196
                                                                                  1196 1199 1217 1217 1220 1224 1226 1230 1232 1232
                                                                                  1257 1260 1261 1266 1286 1287 1287 1289 1289 1290
                                                                                  1309 1310 1311 1311 1312 1317 1317 1336 1339 1341
                                                                                  1347 1389 1421 1423 1423 1423 1426 1430 1430 1431
                                                                                  1431 1433 1434 1435 1445 1448 1449 1511 1585 1585
                                                                                  1586 1587 1597 1600 1603 1604 1606 1612 1612 1613
                                                                                  1621 1625 1628 1629 1630 1631 1638 1645 1645 1650
                                                                                  1652 1654 1654 1654 1658 1660 1662 1666 1668 1668
                                                                                  1670 1671 1671 1671 1671 1674 1674 1689 1697 1700
                                                                                  1701 1705 1705 1707 1708 1727 1730 1733 1735 1743
                                                                                  1744 1792 1852 1855 1857 1863 1865 1880 1921 1929
                                                                                  1929 1943 1945 1948 1949 1970 1973 2025 2069 2092
                                                                                  2116 2118 2121 2122 2126 2128 2145 2147 2147 2152
                                                                                  2152 2179 2276 2349 2352 2354 2354 2354 2354 2362
                                                                                  2362 2371 2377 2379 2379 2380 2383 2389 2392 2395
                                                                                  2396 2396 2398 2412 2412 2412 2424 2424 2424 2427
                                                                                  2430 2430 2434 2435 2437 2437 2443 2443 2448 2456
                                                                                  2458 2460 2486 2486 2495 2495 2495 2499 2502 2505
                                                                                  2505 2509 2519 2527 2533 2534 2534 2536 2540 2543
                                                                                  2551 2551 2552 2552 2554 2555 2555 2557 2557 2562
                                                                                  2566 2573 2575 2591 2595 2607 2614 2616 2619 2619
                                                                                  2619 2619 2625 2625 2627 2629 2658 2678 2687 2690
                                                                                  2690 2693 2694 2696 2698 2699 2701 2703 2703 2703
                                                                                  2706 2722 2724 2724 2724 2724 2730 2730 2732 2737
                                                                                  2742 2742 2745 2745 2746 2753 2753 2753 2759 2759
                                                                                  2761 2766 2771 2771 2774 2774 2864 2864 2929 2956
                                                                                  3026 3028 3028 3030 3033 3033 3038 3053 3053 3061
                                                                                  3063 3063 3078 3079 3081 3108 3146 3172 3172 3176
                                                                                  3190 3190 3194 3198 3198 3202 3202 3211 3212 3214
                                                                                  3216 3217 3218 3274 3276 3277 3279 3280 3284 3285
                                                                                  3289 3290 3293 3293 3295 3314 3334 3337 3337 3342
                                                                                  3345 3349 3351 3355 3358 3359 3363 3365 3366 3366
                                                                                  3368 3376 3382 3384 3384 3404 3406 3409 3412 3415
                                                                                  3697 3700 3713 3713 3742 3783 3785
hmd_signon_data                        based           structure                level 1 dcl 1-157 set ref 661 661 965 965 3362 3362
holding_output           36(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-99 set ref
                                                                                  1191* 1213 1239* 1898
hsd_ptr                         000142 automatic       pointer                  dcl 1-163 set ref 661 661 661* 662 664 665 666 667
                                                                                  947* 948 948 948 3359* 3360 3360 3362 3362 3362*
hsmd_ptr                        000150 automatic       pointer                  dcl 5-15 set ref 691* 692 692 696 697 698 699 700
hste                                   based           structure                level 1 dcl 1-99
hste_ptr                        000140 automatic       pointer                  dcl 1-135 set ref 212* 248 251 265 266 273 276 281
                                                                                  281 284 288 288 290 290 315 316 322 323 339 339
                                                                                  348 349 350 352 352 362 362 377 377 385 395 416
                                                                                  418 420 430 458* 591 591 593 593 598 606 613 615
                                                                                  616 616 617 617 619 621 623 623 624 625 625 626
                                                                                  628 639 646 651 682 682 697 698 699 700 770* 787
                                                                                  787 787 787 794 796 798 798 800 801 802 804 804
                                                                                  806 807 810 812 814 816 816 816 818 818 821 821
                                                                                  823 824 838 840 840 840 843 843 843 848 850 850
                                                                                  850 850 853 855 855 857 858 860 862 984* 1188 1191
                                                                                  1193 1196 1199 1200 1213 1217 1217 1224 1226 1232
                                                                                  1237 1239 1254 1266* 1268 1271* 1790 1839* 1841
                                                                                  1841 1849 1849 1850 1850 1852 1852 1855 1855 1855
                                                                                  1857 1878* 1880 1880 1880 1880 1894* 1896 1897
                                                                                  1898 1900 1952* 1968 2018* 2020 2020 2025 2025
                                                                                  2051* 2053 2053 2053 2067* 2069 2069 2132* 2210
                                                                                  2219 2219 2231 2233 2295 2300 2302 2454 2458* 2460
                                                                                  2460 2460 2467 2470 2475* 2865 2865 2866 2866 2875
                                                                                  2882 2928 2929 2929 2955 2956 2956 2965 2989 2989
                                                                                  2993 2994 3004 3006 3028 3030 3033 3038 3081 3085
                                                                                  3085 3108 3108 3116 3368* 3369
ic_timeout               15            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 475*
idx                             000134 automatic       fixed bin(17,0)          dcl 147 in procedure "hasp_mpx" set ref 724* 726*
                                                                                  3366* 3368*
idx                             000276 automatic       fixed bin(17,0)          dcl 1183 in procedure
                                                                                  "enqueue_subchannel_for_output" set ref 1185*
                                                                                  1185* 1188* 1189
idx                             000644 automatic       fixed bin(17,0)          dcl 2583 in procedure "compute_local_bcb_and_fcs"
                                                                                  set ref 2614* 2616 2619 2619 2619 2625 2625 2627*
idx                             000230 automatic       fixed bin(17,0)          dcl 874 in procedure "load_mpx" set ref 915* 916 917
                                                                                  918 918 920 921 921*
idx                             000363 automatic       fixed bin(17,0)          dcl 1305 in procedure
                                                                                  "interrupt_subchannels_requesting_input" set ref
                                                                                  1309* 1310 1311 1311 1312*
idx                             000550 automatic       fixed bin(17,0)          dcl 2142 in procedure "find_subchannel" set ref
                                                                                  2145* 2147 2147 2152 2152*
idx                             000342 automatic       fixed bin(17,0)          dcl 1252 in procedure
                                                                                  "interrupt_subchannels_with_output" set ref 1257*
                                                                                  1257* 1260* 1261 1265* 1266*
idx                             001123 automatic       fixed bin(17,0)          dcl 3580 in procedure "count_dles" set ref 3591*
                                                                                  3593 3595 3596* 3598*
idx                             000475 automatic       fixed bin(17,0)          dcl 1577 in procedure "process_real_input_block" set
                                                                                  ref 1660* 1662 1666 1668 1668 1670 1671 1671 1671
                                                                                  1674*
idx                             001021 automatic       fixed bin(17,0)          dcl 3241 in procedure "count_dles" set ref 3247*
                                                                                  3251 3253 3254* 3256*
idx                             000613 automatic       fixed bin(17,0)          dcl 2201 in procedure "move_record_to_device" set
                                                                                  ref 2223*
idx                             000634 automatic       fixed bin(17,0)          dcl 2344 in procedure "process_output_block" set ref
                                                                                  2456* 2458*
idx                             000674 automatic       fixed bin(17,0)          dcl 2719 in procedure "add_rts_or_rts_ack_record"
                                                                                  set ref 2722* 2724 2724 2724 2737 2745 2746 2753
                                                                                  2753 2766 2774*
idx                             000241 automatic       fixed bin(17,0)          dcl 935 in procedure "crash_mpx" set ref 983* 984*
idx                             000352 automatic       fixed bin(17,0)          dcl 1284 in procedure
                                                                                  "interrupt_subchannels_with_input" set ref 1286*
                                                                                  1287 1287 1289 1289 1290*
idx                             000254 automatic       fixed bin(17,0)          dcl 1007 in procedure "minor_state_stack_manager"
                                                                                  set ref 1025* 1026 1026 1027 1028 1028* 1050* 1051
                                                                                  1052 1052 1052 1054 1054 1054 1056 1056 1058 1058*
                                                                                  1079* 1080 1080 1080*
in                        2            based           structure                level 2 in structure "saved_meters" dcl 16-68
                                                                                  in procedure "hasp_mpx"
in                       26            based           structure                level 3 in structure "logical_chan_meters" dcl 17-17
                                                                                  in procedure "hasp_mpx"
in                       10            based           structure                level 3 in structure "lcte" dcl 16-20 in procedure
                                                                                  "hasp_mpx"
in                        2            based           structure                level 3 in structure "logical_chan_meters" dcl 17-17
                                                                                  in procedure "hasp_mpx"
in                       30            based           structure                array level 4 in structure "lct" dcl 16-11
                                                                                  in procedure "hasp_mpx"
index                                                  builtin function         dcl 177 ref 1544 1561 3155 3247 3256 3591 3598
info_ptr                        000120 automatic       pointer                  dcl 102 set ref 584* 609 613 621 636 639 641 643 646
                                                                                  648 656 666 667 685 688 691
input                    42            based           structure                level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx"
input                   132            based           structure                array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx"
input                    16            based           structure                level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 2300
input_available         152(01)        based           bit(1)                   array level 4 in structure "hmd" packed packed
                                                                                  unaligned dcl 1-10 in procedure "hasp_mpx" set ref
                                                                                  1287 1289* 1311*
input_available          70(03)        based           bit(1)                   level 3 in structure "hmd" packed packed unaligned
                                                                                  dcl 1-10 in procedure "hasp_mpx" set ref 259 507*
                                                                                  516* 885 890* 1336 1347*
input_available          36(01)        based           bit(1)                   level 3 in structure "hste" packed packed unaligned
                                                                                  dcl 1-99 in procedure "hasp_mpx" set ref 800 802*
                                                                                  821 824*
input_chain                     000160 automatic       structure                level 2 packed packed unaligned dcl 11-38
input_entry                     000516 automatic       bit(1)                   dcl 1761 set ref 1787* 1965* 2206 2300 2322
input_meters             37            based           structure                level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx"
input_meters             76            based           structure                level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx"
input_wabs               67            based           bit(1)                   array level 3 packed packed unaligned dcl 1-10 set
                                                                                  ref 290* 626 628* 806* 857* 900* 1855 1857* 1863*
                                                                                  1865* 2619
interrupt_data                  000106 automatic       bit(72)                  dcl 99 set ref 460* 470 521 545
interrupt_type                  000104 automatic       fixed bin(17,0)          dcl 98 set ref 459* 462 462 465
last                     37            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 1196 1199* 1232 1232*
last_bufferp             30            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 3006*
last_bufferp                    000412 automatic       pointer                  dcl 1369 in procedure "process_input_block" set ref
                                                                                  1378* 1383 1383 1383 1387 1389* 1391* 1434 1618*
                                                                                  1708
last_bufferp              4            based           pointer                  level 3 in structure "lbcse" dcl 1-182 in procedure
                                                                                  "hasp_mpx" set ref 1145
last_bufferp              4            based           pointer                  level 2 in structure "record_data" dcl 2194
                                                                                  in procedure "move_record_to_device" set ref 2308
                                                                                  2310*
last_bufferp             10            based           pointer                  array level 4 in structure "msse" dcl 1-168
                                                                                  in procedure "hasp_mpx" set ref 1058
last_bufferp             56            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 908* 972* 2396* 2430* 2505*
                                                                                  2534* 2555* 2658 2687* 2732 2761 3063* 3079 3146
                                                                                  3176* 3194* 3212 3214 3216 3218
last_bufferp            144            based           pointer                  array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 921* 1028* 1054
                                                                                  1056 1058*
last_bufferp              4     000706 automatic       pointer                  level 2 in structure "saved_output_block" dcl 2811
                                                                                  in procedure "output_records_processor" set ref
                                                                                  3106*
last_bufferp             22            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 281* 625* 850*
last_bufferp             50            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 908* 972* 1142 1144 1145* 1433
                                                                                  1434* 2118*
last_bufferp                    000132 automatic       pointer                  dcl 133 in procedure "hasp_mpx" set ref 275* 276
                                                                                  277* 281 284 285 418* 418* 420 420* 421
last_bufferp            136            based           pointer                  array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 918*
last_bufferp             44            based           pointer                  level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 908* 972* 1707 1708* 1945*
last_bufferp             34            based           pointer                  level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 349 352* 420* 617* 798* 850*
last_idx                        000736 automatic       fixed bin(17,0)          dcl 2821 set ref 3094* 3096* 3098
last_loopback_bcb        66            based           char(1)                  level 2 packed packed unaligned dcl 1-10 set ref
                                                                                  1421 1423 1423 1435* 1586*
last_output_bufferp             000600 automatic       pointer                  dcl 2200 set ref 2222* 2224* 2224 2240 2242* 2292
                                                                                  2297* 2304 2310
last_was_dle                    000460 automatic       bit(1)                   dcl 1530 set ref 1533* 1538 1542* 1554*
lbcse                                  based           structure                level 1 dcl 1-182 set ref 1112 1112 1150 1150 1169
                                                                                  1169
lbcse_ptr                       000146 automatic       pointer                  dcl 1-188 set ref 1112 1112 1112* 1113 1121 1124
                                                                                  1125 1139* 1141 1142 1144 1145 1148 1150 1150
                                                                                  1150* 1161* 1161* 1164 1166 1166 1169 1169 1169*
lbound                                                 builtin function         dcl 177 ref 462 3328
lcte                                   based           structure                level 1 dcl 16-20
length                                                 builtin function         dcl 177 ref 2387 2435 2509 2531 2661 2667 2690 2740
                                                                                  2742 2769 2771 3061 3700 3713 3728 3728 3742 3742
line_ctl                        000152 automatic       structure                level 1 dcl 10-10 set ref 3314 3314
line_stat                       000154 automatic       structure                level 1 dcl 10-42 set ref 545*
loader_event_channel     24            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 488* 572* 924* 3337*
loader_process_id        22            based           bit(36)                  level 2 dcl 1-10 set ref 488* 572* 924* 3337*
local_bcb                              based           structure                level 1 packed packed unaligned dcl 2340
local_bcb_char                  000630 automatic       char(1)                  packed unaligned dcl 2337 set ref 2588* 2589 2591
                                                                                  2594 2595 2693 2701
local_block_count        34            based           fixed bin(17,0)          level 2 dcl 1-10 set ref 1631* 2392 2595 2699* 2701*
local_fcs                              based           structure                level 1 packed packed unaligned dcl 2341
local_fcs_bytes          35            based           char(2)                  level 2 packed packed unaligned dcl 1-10 set ref
                                                                                  898* 2495 2703 2706*
local_fcs_chars                 000631 automatic       char(2)                  packed unaligned dcl 2338 set ref 2495 2603* 2604
                                                                                  2604 2607 2610 2610 2612 2619 2625 2627 2629 2694
                                                                                  2703 2706
long_record                     000126 automatic       bit(1)                   dcl 128 set ref 359* 410 2858* 2891*
loopback                 46            based           structure                level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 1121 1122*
loopback                  4            based           structure                array level 3 in structure "msse" dcl 1-168
                                                                                  in procedure "hasp_mpx" set ref 1026*
loopback                140            based           structure                array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1026
loopback                 24            based           structure                level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 2302
loopback                  2            based           structure                level 2 in structure "lbcse" dcl 1-182 in procedure
                                                                                  "hasp_mpx" set ref 1121*
loopback_block_chain_stack
                         64            based           pointer                  level 2 dcl 1-10 set ref 905* 1124 1125* 1136 1139
                                                                                  1148* 1161 1172*
loopback_entry                  000704 automatic       bit(1)                   dcl 2808 set ref 2831* 2922* 2949* 3223
max_block_size           12            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 478 478 3713 3742
max_buf_size             11            based           fixed bin(9,0)           level 3 in structure "hste" packed packed unsigned
                                                                                  unaligned dcl 1-99 in procedure "hasp_mpx" set ref
                                                                                  2210 2219
max_buf_size             27            based           fixed bin(9,0)           level 3 in structure "hmd" packed packed unsigned
                                                                                  unaligned dcl 1-10 in procedure "hasp_mpx" set ref
                                                                                  3053 3172 3190
max_buffer_tally                000102 constant        fixed bin(17,0)          initial array dcl 12-43 ref 2212 2212 2228 2253 2283
                                                                                  2660 2676 3152 3168 3177 3188
max_device_input_records
                         13            based           fixed bin(17,0)          level 3 dcl 1-10 ref 290 1852
max_naks                 20            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 476*
mbo1                      0(01)        based           bit(1)                   level 2 in structure "local_bcb" packed packed
                                                                                  unaligned dcl 2340 in procedure
                                                                                  "process_output_block" set ref 2589*
mbo1                      0(01)        based           bit(1)                   level 2 in structure "local_fcs" packed packed
                                                                                  unaligned dcl 2341 in procedure
                                                                                  "process_output_block" set ref 2604*
mbo2                      0(10)        based           bit(1)                   level 2 packed packed unaligned dcl 2341 set ref
                                                                                  2604*
mcl                                    based           structure                level 1 dcl 13-10
mcle                                   based           structure                level 1 dcl 13-26
mclep                           000166 automatic       pointer                  dcl 13-24 set ref 726* 728 728 728 728 731 731 731
                                                                                  731 731 731 731 731 731 731 738
mclp                            000164 automatic       pointer                  dcl 13-7 set ref 721* 724 726
mcs1                      0(03)        based           structure                level 2 packed packed unaligned dcl 1367 set ref
                                                                                  1647*
mcs2                      0(12)        based           structure                level 2 in structure "hasp_fcs_bytes" packed packed
                                                                                  unaligned dcl 6-185 in procedure "hasp_mpx"
mcs2                      0(12)        based           structure                level 2 in structure "foreign_fcs" packed packed
                                                                                  unaligned dcl 1367 in procedure
                                                                                  "process_input_block"
mcs_trace                       000060 constant        entry                    external dcl 171 ref 3783
mcs_trace$buffer_chain          000062 constant        entry                    external dcl 172 ref 3785
meters                   37            based           structure                level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 682 699
meters                   76            based           structure                level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx"
meters                    6            based           structure                level 2 in structure "lcte" dcl 16-20 in procedure
                                                                                  "hasp_mpx"
meters                  153            based           structure                array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx"
meters                   26            based           structure                array level 3 in structure "lct" dcl 16-11
                                                                                  in procedure "hasp_mpx"
min                                                    builtin function         dcl 177 ref 1477 2255
minor_state              13            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 362 377 385 395 787* 794* 1897*
                                                                                  2053* 2882 2928 2929 2955 2956 2994 3108*
minor_state             127            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 2746*
minor_state              31            based           fixed bin(17,0)          level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 300 339 434 501 529 593 629 656
                                                                                  880* 882* 945 945 1031 1032* 1062* 1587 1629* 1730
                                                                                  1744* 2128 2354 2354 2354 2362 2371 2398* 2412
                                                                                  2412 2443 2443* 2448 2486 2486 2519 2536* 2540
                                                                                  2543 2562 3355 3365* 3384
minor_state               2            based           fixed bin(17,0)          level 2 in structure "msse" dcl 1-168 in procedure
                                                                                  "hasp_mpx" set ref 1031* 1062 1735
minor_state_stack        62            based           pointer                  level 2 dcl 1-10 set ref 787 905* 1034 1035* 1045
                                                                                  1048 1063* 1076 1090* 1733 1735
mod                                                    builtin function         dcl 177 ref 1597 2595
mode_name                              based           char(16)                 level 2 packed packed unaligned dcl 13-26 ref 728
                                                                                  728 728 731 731 731 731 731 731
mode_switch               4            based           bit(1)                   level 3 packed packed unaligned dcl 13-26 ref 731
                                                                                  731 731
more_input                      000376 automatic       bit(1)                   dcl 1333 set ref 1336* 1338 1339*
mpx_mode                  4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 13-26 set ref
                                                                                  728* 731
msse                                   based           structure                level 1 dcl 1-168 set ref 1016 1016 1065 1065 1087
                                                                                  1087
msse_ptr                        000144 automatic       pointer                  dcl 1-177 set ref 1016 1016 1016* 1017 1026 1031
                                                                                  1034 1035 1048* 1051 1052 1054 1056 1058 1062 1063
                                                                                  1065 1065 1065* 1076* 1076* 1080 1080 1085 1087
                                                                                  1087 1087*
multileave_mode          21(02)        based           bit(1)                   level 4 packed packed unaligned dcl 1-10 ref 3028
                                                                                  3033
n_buffers                       000611 automatic       fixed bin(17,0)          dcl 2201 set ref 2212* 2215 2219 2223 2228
n_characters                    001120 automatic       fixed bin(17,0)          dcl 3580 set ref 3586* 3591 3596 3598
n_duplicate_input_blocks
                        101            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1612* 1612
n_entries                       000341 automatic       fixed bin(17,0)          dcl 1252 in procedure
                                                                                  "interrupt_subchannels_with_output" set ref 1256*
                                                                                  1259* 1259 1260 1263 1265
n_entries                 1            based           fixed bin(17,0)          level 2 in structure "mcl" dcl 13-10 in procedure
                                                                                  "hasp_mpx" ref 724
n_foreign_wab_set       102            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1654* 1654
n_input_blocks           77            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1645* 1645
n_input_records         100            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1929* 1929
n_local_wab_set          76            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 2703* 2703
n_output_blocks         103            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 2551* 2551
n_output_records        104            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 2437* 2437 2730* 2730 2759*
                                                                                  2759 2864* 2864
n_records               132            based           fixed bin(17,0)          array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 917*
n_records               140            based           fixed bin(17,0)          array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 920* 1027* 1052*
                                                                                  1052
n_records                              based           fixed bin(17,0)          level 2 in structure "record_data" dcl 2194
                                                                                  in procedure "move_record_to_device" set ref 2312*
                                                                                  2312
n_records                16            based           fixed bin(17,0)          level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 288* 288 290 624* 848* 1852
n_records                24            based           fixed bin(17,0)          level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 2989* 2989
n_records                 4            based           fixed bin(17,0)          array level 4 in structure "msse" dcl 1-168
                                                                                  in procedure "hasp_mpx" set ref 1052
n_subchannels           113            based           fixed bin(17,0)          level 2 dcl 1-10 ref 915 983 1016 1016 1025 1050
                                                                                  1065 1065 1079 1087 1087 1286 1309 1660 2145 2456
                                                                                  2614 2722 3366
n_words_in_last_buffer          000612 automatic       fixed bin(17,0)          dcl 2201 set ref 2228* 2231*
n_wraparound_blocks     106            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1430* 1430
n_wraparounds           105            based           fixed bin(35,0)          level 4 dcl 1-10 set ref 1585* 1585
name                                   based           char(32)                 level 2 packed packed unaligned dcl 1-10 set ref
                                                                                  1018* 1114* 1423* 1448* 1613* 1625* 1697* 3342*
                                                                                  3349*
needs_space                     000124 automatic       bit(1)                   dcl 122 set ref 373 398 1788* 1948 1949 1966* 2031
                                                                                  2121 2122 2320* 2465 2832* 2923* 2950* 3055* 3221*
new_bufferp                     001002 automatic       pointer                  dcl 3138 in procedure "add_to_output_block" set ref
                                                                                  3172* 3174 3175 3176 3190* 3192 3193 3194
new_bufferp                     000656 automatic       pointer                  dcl 2654 in procedure "finish_output_block" set ref
                                                                                  2678* 2679 2683 2685 2686 2687
new_wab_bit                     000476 automatic       bit(1)                   dcl 1578 set ref 1666* 1668* 1670* 1671 1674
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 12-28
                                                                                  set ref 277 279 281 284 285* 349* 420 421 1056*
                                                                                  1144* 1378 1381 1390* 1433* 1468 1470 1484 1485
                                                                                  1507 1507 1563 1619 1620* 1707* 1818 1821 1917
                                                                                  1919 1997 2000 2088 2090 2176 2178 2224 2240* 2270
                                                                                  2275 2283 2289 2294 2296* 2308* 2686* 2871 2873
                                                                                  2975 2980 2990 2992 3103 3115 3175* 3193* 3214
                                                                                  3216 3218* 3556 3564 3634 3638 3645 3649 3656 3659
next_subchannel_for_output
                        130            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1189 1196* 1224
                                                                                  1226* 1230 1261
next_subchannel_for_output
                         14            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 796* 1200* 1217 1226 1237*
next_to_last_bufferp            000414 automatic       pointer                  dcl 1369 set ref 1376* 1380* 1386 1387 1387 1390
                                                                                  1391
non_crc                                based           char(3)                  level 2 in structure "TEMPLATE_HASP_BLOCK_TRAILER"
                                                                                  packed packed unaligned dcl 6-29 in procedure
                                                                                  "hasp_mpx" set ref 2661 2665 2667 2674 2683 2690
non_crc                                based           char(3)                  level 2 in structure "based_block_trailer" packed
                                                                                  packed unaligned dcl 110 in procedure "hasp_mpx"
                                                                                  set ref 2665*
non_trailer                            based           structure                level 2 in structure "TEMPLATE_HASP_SIGNON_BLOCK"
                                                                                  dcl 6-49 in procedure "hasp_mpx" ref 2435
non_trailer                            based           structure                level 2 in structure "based_signon_block" packed
                                                                                  packed unaligned dcl 112 in procedure "hasp_mpx"
not_blank                 0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 3448 ref 3508
not_compressed            0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3447 ref 3504
not_compressed_scb                     based           structure                level 1 packed packed unaligned dcl 3449
not_eob                   0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 3624 ref 3664
null                                                   builtin function         dcl 177 ref 244 262 265 275 276 281 317 324 339 348
                                                                                  352 385 413 423 428 458 526 609 615 617 621 625
                                                                                  636 639 643 648 656 662 685 692 787 787 798 840
                                                                                  843 850 905 908 918 921 948 953 956 959 962 965
                                                                                  972 1017 1021 1021 1028 1045 1051 1054 1076 1080
                                                                                  1090 1113 1117 1117 1122 1136 1141 1142 1161 1166
                                                                                  1172 1287 1343 1376 1386 1431 1449 1449 1700 1700
                                                                                  1705 1733 1802 1841 1880 1896 1912 1912 1917 1931
                                                                                  1938 1945 1945 1973 1981 2020 2025 2053 2053 2069
                                                                                  2083 2083 2088 2100 2111 2118 2118 2126 2156 2170
                                                                                  2172 2176 2215 2221 2232 2233 2238 2272 2306 2362
                                                                                  2362 2377 2380 2384 2412 2424 2428 2460 2467 2499
                                                                                  2503 2528 2555 2679 2850 2871 2882 2898 2967 2972
                                                                                  2978 2990 2994 3006 3006 3026 3054 3089 3101 3174
                                                                                  3192 3276 3293 3345 3345 3351 3351 3358 3363 3452
                                                                                  3697
old_state                       000240 automatic       fixed bin(17,0)          dcl 935 set ref 938* 942
op                              000152 automatic       fixed bin(17,0)          level 2 in structure "line_ctl" packed packed
                                                                                  unaligned dcl 10-10 in procedure "hasp_mpx" set
                                                                                  ref 3308*
op                              000154 automatic       fixed bin(17,0)          level 2 in structure "line_stat" packed packed
                                                                                  unaligned dcl 10-42 in procedure "hasp_mpx" set
                                                                                  ref 3328 3328 3328
order                           000110 automatic       char(32)                 packed unaligned dcl 101 set ref 583* 587 603 606
                                                                                  609 636 643 648 675 682 685
output                   32            based           structure                level 2 dcl 1-99
output_block             52            based           structure                level 2 dcl 1-10 set ref 3078 3211*
output_chain_ptr         40            based           pointer                  level 2 dcl 1-10 set ref 908* 953 953* 972* 2552*
                                                                                  2557* 3276 3277 3289* 3293
output_in_progress       70(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  2349 3293* 3295*
output_meters           156            based           structure                array level 4 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx"
output_meters           102            based           structure                level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx"
output_meters            42            based           structure                level 3 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx"
output_pending            2            based           bit(1)                   level 2 dcl 139 set ref 639* 641*
output_wabs              67(09)        based           bit(1)                   array level 3 packed packed unaligned dcl 1-10 set
                                                                                  ref 339 901* 1671 1674* 2025 2460
p                               001032 automatic       pointer                  dcl 3271 in procedure "transmit_output_block" set
                                                                                  ref 3277* 3279* 3289
p                               000562 automatic       pointer                  dcl 2166 in procedure "flush_record_buffers" set ref
                                                                                  2176* 2178* 2180
p                               000672 automatic       pointer                  dcl 2718 in procedure "add_rts_or_rts_ack_record"
                                                                                  set ref 2732* 2734 2734 2737 2737 2740 2740 2761*
                                                                                  2763 2763 2766 2766 2769 2769
p                               000606 automatic       pointer                  dcl 2200 in procedure "move_record_to_device" set
                                                                                  ref 2272* 2275* 2279 2294* 2295*
p                               000730 automatic       pointer                  dcl 2819 in procedure "output_records_processor" set
                                                                                  ref 3115* 3117
p_length                               parameter       fixed bin(17,0)          dcl 1458 ref 1455 1475
p_n_characters                         parameter       fixed bin(17,0)          dcl 1499 ref 1496 1503
p_start_idx                            parameter       fixed bin(17,0)          dcl 1458 ref 1455 1466
parent_ptr                6            based           pointer                  level 2 dcl 17-8 ref 691
part1                                  based           char                     level 2 packed packed unaligned dcl 2647 ref 2674
part2                                  based           char                     level 2 packed packed unaligned dcl 2647 ref 2683
partial_record                  000125 automatic       bit(1)                   dcl 124 set ref 358* 413 2893*
pds$process_id                  000024 external static bit(36)                  dcl 161 ref 665
pointer                                                builtin function         dcl 177 ref 279 284 421 522 1381 1470 1485 1507 1563
                                                                                  1619 1821 1919 2000 2090 2178 2224 2275 2289 2294
                                                                                  2873 2980 2992 3103 3115 3216 3564 3638 3649 3659
previous                               based           pointer                  level 2 in structure "msse" dcl 1-168 in procedure
                                                                                  "hasp_mpx" set ref 1034* 1063 1085
previous                               based           pointer                  level 2 in structure "lbcse" dcl 1-182 in procedure
                                                                                  "hasp_mpx" set ref 1124* 1148 1164
previous_bufferp                001070 automatic       pointer                  dcl 3441 set ref 3478* 3482
previous_lbcse_ptr              000266 automatic       pointer                  dcl 1104 set ref 1164* 1170
previous_minor_state            000506 automatic       fixed bin(17,0)          dcl 1725 set ref 1733* 1735* 1737 1737 1741
previous_msse_ptr               000252 automatic       pointer                  dcl 1005 set ref 1085* 1088
previous_record_idx             001073 automatic       fixed bin(17,0)          dcl 3442 set ref 3479* 3483
previous_subchannel_idx         000306 automatic       fixed bin(17,0)          dcl 1211 set ref 1215* 1220* 1220* 1224 1226* 1230
                                                                                  1232
previously_scanned_bufferp      000130 automatic       pointer                  dcl 131 set ref 3553*
processid                              based           bit(36)                  level 2 dcl 1-157 set ref 665* 948* 3360*
pxss$ring_0_wakeup              000064 constant        entry                    external dcl 173 ref 488 572 924 948 3337 3360
queue                           000320 automatic       fixed bin(17,0)          array dcl 1251 set ref 1260* 1266
rcb                                    based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_RECORD"
                                                                                  packed packed unaligned dcl 6-147 in procedure
                                                                                  "hasp_mpx"
rcb                                    based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_ACK_RECORD"
                                                                                  packed packed unaligned dcl 6-160 in procedure
                                                                                  "hasp_mpx"
rcb                                    based           structure                level 1 packed packed unaligned dcl 1773
                                                                                  in procedure "input_loopback_records_processor"
rcb                     122            based           char(1)                  array level 3 in structure "hmd" packed packed
                                                                                  unaligned dcl 1-10 in procedure "hasp_mpx" set ref
                                                                                  2152 2737 2766
rcb                       6            based           char(1)                  level 2 in structure "hste" packed packed unaligned
                                                                                  dcl 1-99 in procedure "hasp_mpx" set ref 3085 3085
rcb                                    based           structure                level 1 packed packed unaligned dcl 3624
                                                                                  in procedure "classify_record"
rcb_char                        000530 automatic       char(1)                  packed unaligned dcl 1770 in procedure
                                                                                  "input_loopback_records_processor" set ref 1812*
                                                                                  1839* 1863 1863 1863 1865 1865 1991* 2018*
rcb_char                        001135 automatic       char(1)                  packed unaligned dcl 3620 in procedure
                                                                                  "classify_record" set ref 3632* 3640* 3664 3664
                                                                                  3664 3671 3674 3677
rcb_idx                         001134 automatic       fixed bin(17,0)          dcl 3618 set ref 3630* 3632 3632 3639* 3643 3643
                                                                                  3650* 3654 3654
receive_timeout          16            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 475*
received_count                  000473 automatic       fixed bin(17,0)          dcl 1577 set ref 1598* 1604 1606 1606 1608 1608 1608
                                                                                  1608 1613* 1625* 1630 1638 1695* 1697*
record                    1(27)        based           char(80)                 level 3 in structure "based_signon_block" packed
                                                                                  packed unaligned dcl 112 in procedure "hasp_mpx"
                                                                                  set ref 2434*
record                    4            based           char(80)                 level 2 in structure "sri" packed packed unaligned
                                                                                  dcl 145 in procedure "hasp_mpx" ref 667
record                    4            based           char(80)                 level 2 in structure "hmd_signon_data" packed packed
                                                                                  unaligned dcl 1-157 in procedure "hasp_mpx" set
                                                                                  ref 667* 2434
record_data                            based           structure                level 1 dcl 2194
record_data_ptr                 000572 automatic       pointer                  dcl 2195 set ref 2300* 2302* 2306 2306 2308 2310
                                                                                  2312 2312
record_idx                      001072 automatic       fixed bin(17,0)          dcl 3442 set ref 3456* 3467 3472 3479 3481 3483*
                                                                                  3499 3519 3543 3548* 3548 3565* 3591 3598
record_tally                    000537 automatic       fixed bin(17,0)          dcl 1778 in procedure
                                                                                  "input_loopback_records_processor" set ref 1799*
                                                                                  1810* 1810 1818 1978* 1989* 1989 1997 2028* 2212
                                                                                  2228 2244
record_tally                    001074 automatic       fixed bin(17,0)          dcl 3442 in procedure "find_next_record" set ref
                                                                                  3459* 3484* 3484 3520 3536* 3536 3560
record_tally                    000733 automatic       fixed bin(17,0)          dcl 2821 in procedure "output_records_processor" set
                                                                                  ref 2847* 2853* 2853 2855* 2861* 2891 2918* 2934*
                                                                                  2971* 2974* 2974 2986*
record_type                     000536 automatic       fixed bin(17,0)          dcl 1778 in procedure
                                                                                  "input_loopback_records_processor" set ref 1805*
                                                                                  1826* 1833 1833 1850 1871 1888 1984* 2005* 2012
                                                                                  2012 2044 2061
record_type                     000474 automatic       fixed bin(17,0)          dcl 1577 in procedure "process_real_input_block" set
                                                                                  ref 1684* 1686 1693
record_type                     000732 automatic       fixed bin(17,0)          dcl 2821 in procedure "output_records_processor" set
                                                                                  ref 2866 3106* 3108
record_was_taken                000533 automatic       bit(1)                   dcl 1775 set ref 2028* 2033
rel                                                    builtin function         dcl 177 ref 349 418 1056 1144 1377 1433 1535 1621
                                                                                  1707 2240 2308 2686 3175 3193
remainder_lth                   001176 automatic       fixed bin(17,0)          dcl 3759 set ref 3762* 3764 3764
report_input_meters       1            based           bit(1)                   level 3 packed packed unaligned dcl 5-6 set ref 697*
report_output_meters      1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-6 set ref 698*
requested_input          36            based           bit(1)                   level 3 in structure "hste" packed packed unaligned
                                                                                  dcl 1-99 in procedure "hasp_mpx" set ref 266*
requested_input         152            based           bit(1)                   array level 4 in structure "hmd" packed packed
                                                                                  unaligned dcl 1-10 in procedure "hasp_mpx" set ref
                                                                                  1289* 1310 1311*
reset_local_block_count
                         70(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  897* 1743* 2591 2696 2698*
resetread                 0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 135 ref 621
resetwrite                             based           bit(1)                   level 2 packed packed unaligned dcl 135 ref 613
retry_process_input      70(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref 526
                                                                                  1948* 3415
retry_process_loopback_records
                         70(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  2121* 3409
retry_process_output     70(08)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  2566* 2573* 3412
retry_transmit_output
                         70(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  3280* 3284* 3404 3406
returned_data             0(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1367 set ref
                                                                                  1406
rts_mode                 21(04)        based           bit(1)                   level 4 packed packed unaligned dcl 1-10 ref 362 787
                                                                                  3108
rtx_info                        000160 automatic       structure                level 1 dcl 11-38 set ref 521*
saved_hste_ptr                  000520 automatic       pointer                  dcl 1763 in procedure
                                                                                  "input_loopback_records_processor" set ref 1790*
                                                                                  1952 1968* 2132
saved_hste_ptr                  000632 automatic       pointer                  dcl 2343 in procedure "process_output_block" set ref
                                                                                  2454* 2475
saved_hste_ptr                  000316 automatic       pointer                  dcl 1250 in procedure
                                                                                  "interrupt_subchannels_with_output" set ref 1254*
                                                                                  1271
saved_input_available           000227 automatic       bit(1)                   dcl 873 in procedure "load_mpx" set ref 885* 890
saved_input_available           000210 automatic       bit(1)                   dcl 785 in procedure "signal_dialup" set ref 800*
                                                                                  802
saved_last_tally                000714 automatic       fixed bin(17,0)          dcl 2812 set ref 3079* 3106* 3212
saved_meters             10            based           structure                level 2 dcl 5-6 set ref 700*
saved_meters_ptr         46            based           pointer                  level 2 dcl 1-99 ref 682 700
saved_output_block              000706 automatic       structure                level 1 dcl 2811 set ref 3078* 3211
saved_send_output               000226 automatic       bit(1)                   dcl 873 set ref 884* 889
saved_tally                     000662 automatic       fixed bin(17,0)          dcl 2655 set ref 2672* 2680
scb                                    based           structure                level 1 packed packed unaligned dcl 3447
scb_char                        001100 automatic       char(1)                  packed unaligned dcl 3445 set ref 3499* 3501 3504
                                                                                  3504 3508
send_output              70(02)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  497* 884 889* 2352 3274 3290*
send_rts                 67(18)        based           bit(1)                   array level 3 packed packed unaligned dcl 1-10 set
                                                                                  ref 377* 810* 860* 902* 2495 2724 2745* 2929*
                                                                                  2956*
send_rts_ack             67(27)        based           bit(1)                   array level 3 packed packed unaligned dcl 1-10 set
                                                                                  ref 807* 858* 903* 1880* 2069* 2495 2753 2774*
sent_interrupt                  000362 automatic       bit(1)                   dcl 1304 set ref 1307* 1313* 1317
signon_data_ptr          60            based           pointer                  level 2 dcl 1-10 set ref 656 664* 908* 947 965 965
                                                                                  965 965* 972* 2412 2434 3358 3359 3363*
signon_mode              21(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-10 ref 654 675
                                                                                  880
signon_record_info                     based           structure                level 1 dcl 9-6
size                                                   builtin function         dcl 177 ref 661 661 1016 1016 1112 1112
size_code                 0(24)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 12-28
                                                                                  ref 2253 2283 2660 2676 3152 3168 3177 3188
space_left                      000617 automatic       fixed bin(17,0)          dcl 2201 set ref 2253* 2257 2259
space_left_in_buffer            001006 automatic       fixed bin(17,0)          dcl 3139 in procedure "add_to_output_block" set ref
                                                                                  3152* 3164 3165 3166 3166 3169 3170 3177*
space_left_in_buffer            000660 automatic       fixed bin(17,0)          dcl 2655 in procedure "finish_output_block" set ref
                                                                                  2660* 2663 2673 2674 2674 2683 2683 2683 2685
space_needed                    000616 automatic       fixed bin(17,0)          dcl 2201 set ref 2255* 2257 2257
srcb                      0(09)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_RECORD"
                                                                                  packed packed unaligned dcl 6-147 in procedure
                                                                                  "hasp_mpx"
srcb                      1(18)        based           char(1)                  level 2 in structure "based_bad_bcb_block" packed
                                                                                  packed unaligned dcl 114 in procedure "hasp_mpx"
                                                                                  set ref 2392
srcb                      0(09)        based           char(1)                  level 2 in structure "based_rts_record" packed
                                                                                  packed unaligned dcl 119 in procedure "hasp_mpx"
                                                                                  set ref 2737*
srcb                      1(18)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_BAD_BCB_BLOCK"
                                                                                  packed packed unaligned dcl 6-71 in procedure
                                                                                  "hasp_mpx"
srcb                      0(09)        based           char(1)                  level 2 in structure "based_bad_bcb_record" packed
                                                                                  packed unaligned dcl 115 in procedure "hasp_mpx"
                                                                                  set ref 1696
srcb                      0(09)        based           char(1)                  level 2 in structure "TEMPLATE_HASP_RTS_ACK_RECORD"
                                                                                  packed packed unaligned dcl 6-160 in procedure
                                                                                  "hasp_mpx"
srcb                      0(09)        based           char(1)                  level 2 in structure "based_rts_ack_record" packed
                                                                                  packed unaligned dcl 120 in procedure "hasp_mpx"
                                                                                  set ref 2766*
srcb_char                       000531 automatic       char(1)                  packed unaligned dcl 1771 in procedure
                                                                                  "input_loopback_records_processor" set ref 1814*
                                                                                  1822* 1827* 1878* 1894* 1993* 2001* 2006* 2051*
                                                                                  2067*
srcb_char                       001136 automatic       char(1)                  packed unaligned dcl 3621 in procedure
                                                                                  "classify_record" set ref 3643* 3645* 3651* 3677
                                                                                  3683
sri                                    based           structure                level 1 dcl 145
start                           001004 automatic       fixed bin(17,0)          dcl 3139 in procedure "add_to_output_block" set ref
                                                                                  3148* 3150 3155 3160 3166 3169* 3169 3181 3184*
                                                                                  3184
start                           001020 automatic       fixed bin(17,0)          dcl 3241 in procedure "count_dles" set ref 3246*
                                                                                  3253* 3253 3254 3256
start                           001122 automatic       fixed bin(17,0)          dcl 3580 in procedure "count_dles" set ref 3590*
                                                                                  3595* 3595 3596 3598
start                           000433 automatic       fixed bin(17,0)          dcl 1460 in procedure "substr_of_chain" set ref
                                                                                  1474* 1477 1480 1486*
start                           000456 automatic       fixed bin(17,0)          dcl 1529 in procedure "strip_dles" set ref 1538*
                                                                                  1540* 1544 1548 1557* 1559 1561
start_bufferp                   000522 automatic       pointer                  dcl 1766 in procedure
                                                                                  "input_loopback_records_processor" set ref 1792*
                                                                                  1799* 1805* 1812 1814 1814 1818 1821 1912* 1917*
                                                                                  1919* 1925* 1931 1938 1938* 1943 1945 1970* 1978*
                                                                                  1984* 1991 1993 1993 1997 2000 2028* 2083* 2088*
                                                                                  2090* 2096* 2100 2111 2111* 2116 2118 2168 2246
start_bufferp                   000716 automatic       pointer                  dcl 2814 in procedure "output_records_processor" set
                                                                                  ref 2840* 2847* 2871* 2873* 2878* 2882 2898 2898*
                                                                                  2903 2914* 2965* 2967 2972 2990* 2992* 2994 3004
                                                                                  3006 3087 3091 3112
start_record_idx                000722 automatic       fixed bin(17,0)          dcl 2815 in procedure "output_records_processor" set
                                                                                  ref 2841* 2847* 2874* 2879* 2898 2898* 2915* 2983*
                                                                                  3091
start_record_idx                000526 automatic       fixed bin(17,0)          dcl 1767 in procedure
                                                                                  "input_loopback_records_processor" set ref 1793*
                                                                                  1799* 1805* 1812 1814 1814 1920* 1926* 1938 1938*
                                                                                  1971* 1978* 1984* 1991 1993 1993 2028 2091* 2097*
                                                                                  2111 2111* 2247
state                   126            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 916* 2619
state                    30            based           fixed bin(17,0)          level 2 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 468 499 509 518 559 587 593 598
                                                                                  764 876* 938 940* 3334 3366 3376 3384
state                    12            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" set ref 248 315 591 591* 593 598 814*
                                                                                  838* 3369
stream                    0(02)        based           fixed bin(3,0)           level 2 in structure "rcb" packed packed unsigned
                                                                                  unaligned dcl 1773 in procedure
                                                                                  "input_loopback_records_processor" ref 1863 1865
stream                    0(02)        based           fixed bin(3,0)           level 2 in structure "rcb" packed packed unsigned
                                                                                  unaligned dcl 3624 in procedure "classify_record"
                                                                                  ref 3664 3671 3674 3677
string                                                 builtin function         dcl 177 set ref 696* 801* 853* 887* 900* 901* 902*
                                                                                  903* 981* 1647* 2387 2435 2495 2495 2509 2531
                                                                                  2610* 2610* 2661 2667 2690 2740 2742 2769 2771
                                                                                  3061 3700 3713 3728 3728 3742 3742
subchannel_idx            2            based           fixed bin(17,0)          level 2 in structure "hste" dcl 1-99 in procedure
                                                                                  "hasp_mpx" ref 1188 1193 1196 1199 1217 1224 1232
                                                                                  3030 3038
subchannel_idx                  000100 automatic       fixed bin(17,0)          dcl 93 in procedure "hasp_mpx" set ref 211* 212 769*
                                                                                  770
subchannel_idx          116            based           fixed bin(17,0)          array level 3 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 1260
subchannel_idx           52            based           fixed bin(17,0)          level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 913* 977* 3028* 3030* 3033 3038
subchannels             114            based           structure                array level 2 in structure "hmd" dcl 1-10
                                                                                  in procedure "hasp_mpx" set ref 212 770 984 1266
                                                                                  2147 2152 2458 3368
subchannels               4            based           structure                array level 2 in structure "msse" dcl 1-168
                                                                                  in procedure "hasp_mpx"
subchannels_for_output
                         36            based           structure                level 2 dcl 1-10 set ref 979*
substr                                                 builtin function         dcl 177 ref 1544 1561 3155 3166 3181 3256 3598
substr_lth                      000574 automatic       fixed bin(17,0)          dcl 2198 in procedure "move_record_to_device" set
                                                                                  ref 2257* 2259* 2261 2261 2264 2265 2266
substr_lth                      001005 automatic       fixed bin(17,0)          dcl 3139 in procedure "add_to_output_block" set ref
                                                                                  3155* 3157 3160* 3164 3170* 3170 3180 3181 3181
                                                                                  3183 3184
substring                              based           char                     packed unaligned dcl 2197 set ref 2261* 2261
suspend_all_input        70(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref
                                                                                  896* 2607
suspend_all_mode         21            based           bit(1)                   level 4 packed packed unaligned dcl 1-10 ref 2629
suspend_all_output       70            based           bit(1)                   level 3 packed packed unaligned dcl 1-10 set ref 339
                                                                                  892* 1654 1658* 2354 3382*
syserr                          000066 constant        entry                    external dcl 174 ref 1018 1114 1423 1448 1613 1625
                                                                                  1697 3342 3349
system_wab                0(02)        based           bit(1)                   level 2 in structure "local_fcs" packed packed
                                                                                  unaligned dcl 2341 in procedure
                                                                                  "process_output_block" set ref 2607* 2629* 2703
system_wab                0(02)        based           bit(1)                   level 2 in structure "foreign_fcs" packed packed
                                                                                  unaligned dcl 1367 in procedure
                                                                                  "process_input_block" ref 1654 1658
system_wab                0(02)        based           bit(1)                   level 2 in structure "hmd_local_fcs" packed packed
                                                                                  unaligned dcl 2645 in procedure
                                                                                  "finish_output_block" ref 2703
tally                     0(27)        based           fixed bin(9,0)           level 2 in structure "buffer" packed packed unsigned
                                                                                  unaligned dcl 12-28 in procedure "hasp_mpx" set
                                                                                  ref 1383 1383* 1383 1387* 1387 1387 1467 1469 1477
                                                                                  1506 1510 1544 1550 1553* 1553 1559 1561 1616*
                                                                                  1814 1915 1993 2086 2253 2255 2261 2264* 2264 2268
                                                                                  2283 2387* 2395 2435* 2509* 2531* 2533 2660 2665
                                                                                  2667* 2667 2672 2674 2676* 2680* 2685* 2734 2737
                                                                                  2740* 2740 2763 2766 2769* 2769 2869 2974 2984
                                                                                  3061* 3079 3096 3152 3166 3168* 3181 3183* 3183
                                                                                  3188 3196 3197* 3197 3212* 3247 3254 3256 3543
                                                                                  3632 3643 3654 3762 3767* 3767
tally                    53            based           fixed bin(17,0)          level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" set ref 913* 977* 2395* 2435* 2509*
                                                                                  2533* 2554* 2690* 2690 2742* 2742 2771* 2771 3061*
                                                                                  3198* 3198 3202* 3202 3700 3713
text                                   based           char                     packed unaligned dcl 3579 in procedure "count_dles"
                                                                                  ref 3591 3598
text                                   based           char                     packed unaligned dcl 3130 in procedure
                                                                                  "add_to_output_block" ref 3155 3166 3181
text1                                  based           char(8)                  level 2 in structure "TEMPLATE_HASP_SYNC_BLOCK"
                                                                                  packed packed unaligned dcl 6-90 in procedure
                                                                                  "hasp_mpx"
text1                                  based           char(2)                  level 2 in structure "TEMPLATE_HASP_BLOCK_HEADER"
                                                                                  packed packed unaligned dcl 6-14 in procedure
                                                                                  "hasp_mpx"
text1                                  based           char(2)                  level 2 in structure "TEMPLATE_HASP_BAD_BCB_BLOCK"
                                                                                  packed packed unaligned dcl 6-71 in procedure
                                                                                  "hasp_mpx"
text2                     0(27)        based           char(3)                  level 2 packed packed unaligned dcl 6-71
text3                     1(27)        based           char(4)                  level 2 packed packed unaligned dcl 6-71
text_in_buffer                         defined         char                     packed unaligned dcl 1479 ref 1480
text_lth                        000776 automatic       fixed bin(17,0)          dcl 3132 set ref 3144* 3150 3155 3160 3166 3181 3202
text_ptr                        000774 automatic       pointer                  dcl 3131 set ref 3143* 3155 3166 3181
the_text                        000426 automatic       varying char(4)          dcl 1459 set ref 1463* 1480* 1480 1490
time_mpx_booted          72            based           fixed bin(71,0)          level 2 dcl 1-10 set ref 878*
trace_mode               21(03)        based           bit(1)                   level 4 packed packed unaligned dcl 1-10 ref 523
                                                                                  1341 2557
transmit_timeout         17            based           fixed bin(17,0)          level 3 dcl 1-10 set ref 475*
tty_buf$                        000026 external static bit(36)                  dcl 163 set ref 225 242 311 456 581
tty_space_man$free_buffer       000112 constant        entry                    external dcl 15-14 ref 1389 1511 1921 2092 2179 2276
                                                                                  2875 2993 3116
tty_space_man$free_chain        000116 constant        entry                    external dcl 15-16 ref 316 323 616 623 840 843 953
                                                                                  956 959 962 1080 1166 1426 1445 1621 1628 1689
                                                                                  1701 1727 2233 2295 2379 2424 3217
tty_space_man$free_space        000106 constant        entry                    external dcl 15-12 ref 965 1065 1087 1150 1169 3362
tty_space_man$get_buffer        000110 constant        entry                    external dcl 15-13 ref 2231 2383 2427 2502 2527 2678
                                                                                  3053 3172 3190
tty_space_man$get_chain         000114 constant        entry                    external dcl 15-15 ref 2219
tty_space_man$get_space         000104 constant        entry                    external dcl 15-10 ref 661 1016 1112
tty_space_man$needs_space       000120 constant        entry                    external dcl 15-18 ref 447 1949 2122 2575 3285
ttybp                           000122 automatic       pointer                  dcl 107 set ref 225* 242* 279 284 311* 421 456* 522
                                                                                  581* 1381 1470 1485 1507 1563 1619 1821 1919 2000
                                                                                  2090 2178 2224 2275 2289 2294 2873 2980 2992 3103
                                                                                  3115 3216 3564 3638 3649 3659
type                      0(05)        based           fixed bin(4,0)           level 2 in structure "rcb" packed packed unsigned
                                                                                  unaligned dcl 1773 in procedure
                                                                                  "input_loopback_records_processor" ref 1863 1863
                                                                                  1865
type                      0(05)        based           fixed bin(4,0)           level 2 in structure "rcb" packed packed unsigned
                                                                                  unaligned dcl 3624 in procedure "classify_record"
                                                                                  ref 3664
type                      0(02)        based           fixed bin(3,0)           level 2 in structure "local_bcb" packed packed
                                                                                  unsigned unaligned dcl 2340 in procedure
                                                                                  "process_output_block" set ref 2591* 2594*
type                      0(02)        based           fixed bin(3,0)           level 2 in structure "foreign_bcb" packed packed
                                                                                  unsigned unaligned dcl 1366 in procedure
                                                                                  "process_input_block" ref 1600 1635 1638
type                     11            based           fixed bin(17,0)          level 3 in structure "hmd" dcl 1-10 in procedure
                                                                                  "hasp_mpx" ref 473 473 651 675 880 3081
unspec                                                 builtin function         dcl 177 set ref 470* 521* 545* 816 816 894* 898*
                                                                                  1423 1423 1586*
val                       0(18) 000152 automatic       fixed bin(17,0)          array level 2 packed packed unaligned dcl 10-10 set
                                                                                  ref 3310* 3311* 3312*
version                                based           fixed bin(17,0)          level 2 in structure "get_comm_meters_info" dcl 17-8
                                                                                  in procedure "hasp_mpx" ref 688
version                                based           fixed bin(17,0)          level 2 in structure "hasp_subchannel_meters_data"
                                                                                  dcl 5-6 in procedure "hasp_mpx" ref 692
version                                based           fixed bin(17,0)          level 2 in structure "sri" dcl 145 in procedure
                                                                                  "hasp_mpx" ref 656
wab_bits1                 0(05)        based           bit(1)                   array level 2 in structure "foreign_fcs" packed
                                                                                  packed unaligned dcl 1367 in procedure
                                                                                  "process_input_block" ref 1668
wab_bits1                 0(05)        based           bit(1)                   array level 2 in structure "local_fcs" packed packed
                                                                                  unaligned dcl 2341 in procedure
                                                                                  "process_output_block" set ref 2610* 2625*
wab_bits2                 0(14)        based           bit(1)                   array level 2 in structure "foreign_fcs" packed
                                                                                  packed unaligned dcl 1367 in procedure
                                                                                  "process_input_block" ref 1670
wab_bits2                 0(14)        based           bit(1)                   array level 2 in structure "local_fcs" packed packed
                                                                                  unaligned dcl 2341 in procedure
                                                                                  "process_output_block" set ref 2610* 2627*
wire_proc$wire_me               000070 constant        entry                    external dcl 175 ref 199
wraparound_meters       105            based           structure                level 3 dcl 1-10
write_status_info                      based           structure                level 1 dcl 139

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_INPUT                           internal static fixed bin(17,0)          initial dcl 11-15
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 11-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 11-23
BAD_BLOCK                              internal static fixed bin(17,0)          initial dcl 10-49
BID_FAILED                             internal static fixed bin(17,0)          initial dcl 10-49
DEFAULT_HASP_CONFIGURATION_DATA        internal static structure                level 1 dcl 2-65
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 11-19
FNP_WRITE_STATUS                       internal static fixed bin(17,0)          initial dcl 10-49
HASP_CONSOLE_SRCB                      based           char(1)                  dcl 8-16
HASP_CONSOLE_SRCB_BITS                 internal static bit(9)                   initial dcl 8-15
HASP_DEVICE_NAMES                      internal static char(32)                 initial array packed unaligned dcl 3-15
HASP_FOREIGN_SWAB_RESET                internal static fixed bin(17,0)          initial dcl 10-49
HASP_FORMS_CHANGE_SRCB                 based           char(1)                  dcl 8-71
HASP_FORMS_CHANGE_SRCB_BITS            internal static structure                level 1 dcl 8-65
HASP_INIT_COMPLETE                     internal static fixed bin(17,0)          initial dcl 10-49
HASP_MAX_COMPRESSED_TEXT_LTH           internal static fixed bin(17,0)          initial dcl 8-100
HASP_MAX_DEVICE_RECORD_LTHS            internal static fixed bin(21,0)          initial array dcl 3-20
HASP_MAX_MAX_BLOCK_SIZE                internal static fixed bin(17,0)          initial dcl 2-58
HASP_MAX_NOT_COMPRESSED_TEXT_LTH       internal static fixed bin(17,0)          initial dcl 8-100
HASP_MAX_SLEW_COUNT                    internal static fixed bin(17,0)          initial dcl 8-62
HASP_MIN_MAX_BLOCK_SIZE                internal static fixed bin(17,0)          initial dcl 2-58
HASP_MPX_METERS_DATA_VERSION_1         internal static fixed bin(17,0)          initial dcl 4-16
HASP_PRINTER                           internal static fixed bin(17,0)          initial dcl 3-6
HASP_PUNCH                             internal static fixed bin(17,0)          initial dcl 3-6
HASP_RCB_TYPE_CONSOLE_INPUT            internal static fixed bin(4,0)           initial unsigned dcl 7-15
HASP_RCB_TYPE_CONSOLE_OUTPUT           internal static fixed bin(4,0)           initial unsigned dcl 7-15
HASP_READER                            internal static fixed bin(17,0)          initial dcl 3-6
HASP_SIGNON_REJECTED                   internal static fixed bin(71,0)          initial dcl 9-20
IBM3270_NAK_OUTPUT                     internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_SELECT_FAILED                  internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_WACK_MESSAGE                   internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_WACK_SELECT                    internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_WRITE_ABORT                    internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_WRITE_COMPLETE                 internal static fixed bin(17,0)          initial dcl 10-49
IBM3270_WRITE_EOT                      internal static fixed bin(17,0)          initial dcl 10-49
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 11-16
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 11-18
MASKED                                 internal static fixed bin(17,0)          initial dcl 11-26
QUIT                                   internal static fixed bin(17,0)          initial dcl 11-17
REPORT_WRITE_STATUS                    internal static fixed bin(17,0)          initial dcl 10-21
REVERSE_INTERRUPT                      internal static fixed bin(17,0)          initial dcl 10-49
SET_3270_MODE                          internal static fixed bin(17,0)          initial dcl 10-21
SET_BID_LIMIT                          internal static fixed bin(17,0)          initial dcl 10-21
SET_POLLING_ADDR                       internal static fixed bin(17,0)          initial dcl 10-21
SET_SELECT_ADDR                        internal static fixed bin(17,0)          initial dcl 10-21
SET_TTD_PARAMS                         internal static fixed bin(17,0)          initial dcl 10-21
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 11-21
START_POLL                             internal static fixed bin(17,0)          initial dcl 10-21
STOP_AUTO_POLL                         internal static fixed bin(17,0)          initial dcl 10-21
TEMPLATE_HASP_BAD_BCB_RECORD_BITS      internal static structure                level 1 dcl 6-129
TEMPLATE_HASP_CARD_SRCB                based           char(1)                  dcl 8-37
TEMPLATE_HASP_CARD_SRCB_BITS           internal static structure                level 1 dcl 8-30
TEMPLATE_HASP_EOF_RECORD               based           char(2)                  dcl 8-10
TEMPLATE_HASP_EOF_RECORD_BITS          internal static structure                level 1 dcl 8-6
TEMPLATE_HASP_PRINTER_SRCB             based           char(1)                  dcl 8-60
TEMPLATE_HASP_PRINTER_SRCB_BITS        internal static structure                level 1 dcl 8-52
TIMER                                  internal static fixed bin(17,0)          initial dcl 11-24
TOO_MANY_NAKS                          internal static fixed bin(17,0)          initial dcl 10-49
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 11-25
channel_manager$check_modes     000000 constant        entry                    external dcl 14-19
channel_manager$get_modes       000000 constant        entry                    external dcl 14-22
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 14-31
channel_manager$set_modes       000000 constant        entry                    external dcl 14-16
free_block                             based           structure                level 1 dcl 12-23
free_blockp                            automatic       pointer                  dcl 12-20
hasp_bcb_byte_ptr                      automatic       pointer                  dcl 6-174
hasp_card_srcb_byte                    based           structure                level 1 packed packed unaligned dcl 8-21
hasp_card_srcb_byte_ptr                automatic       pointer                  dcl 8-28
hasp_fcs_bytes_ptr                     automatic       pointer                  dcl 6-200
hasp_load_data                         based           structure                level 1 dcl 2-7
hasp_load_data_n_subchannels           automatic       fixed bin(17,0)          dcl 2-16
hasp_mpx_meters_data                   based           structure                level 1 dcl 4-6
hasp_printer_srcb_byte                 based           structure                level 1 packed packed unaligned dcl 8-42
hasp_printer_srcb_byte_ptr             automatic       pointer                  dcl 8-50
hasp_rcb_byte_ptr                      automatic       pointer                  dcl 7-13
hasp_scb_byte_ptr                      automatic       pointer                  dcl 8-95
hld_ptr                                automatic       pointer                  dcl 2-17
hmd_n_subchannels                      automatic       fixed bin(17,0)          dcl 1-76
hmm_ptr                                automatic       pointer                  dcl 4-35
hmmd_ptr                               automatic       pointer                  dcl 4-14
hsm_ptr                                automatic       pointer                  dcl 5-32
interrupt_info                         automatic       bit(72)                  dcl 11-28
lcnt                                   based           structure                level 1 dcl 16-65
lcntp                                  automatic       pointer                  dcl 16-63
lct                                    based           structure                level 1 dcl 16-11
lct_size                               automatic       fixed bin(17,0)          dcl 16-9
lctep                                  automatic       pointer                  dcl 16-8
lctp                                   automatic       pointer                  dcl 16-7
logical_chan_meters                    based           structure                level 1 dcl 17-17
mcl_version_2                          internal static fixed bin(17,0)          initial dcl 13-8
saved_meters                           based           structure                level 1 dcl 16-68
signon_record_info_ptr                 automatic       pointer                  dcl 9-12
timer_info                             automatic       structure                level 1 dcl 11-50
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 15-11
tty_space_man$switch_chain      000000 constant        entry                    external dcl 15-17
valchar                                based           structure                level 1 packed packed unaligned dcl 10-14

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_INPUT_BLOCK                 005467 constant        label                    dcl 1445 set ref 1386 1468 1484 1507
CANT_FINISH_PROCESS_OUTPUT_BLOCK
                                011466 constant        label                    dcl 2573 ref 2384 2428 2465 2503 2528 2681
CANT_FINISH_WRITE_CALL          001371 constant        label                    dcl 444 set ref 373 398
CANT_MOVE_RECORD_TO_DEVICE      010573 constant        label                    dcl 2320 ref 2221 2235
END_OF_GENERAL_CONTROL_RECORD_SCAN
                                014464 constant        label                    dcl 3482 ref 3556
ERROR_RETURN                    000677 constant        label                    dcl 233 ref 766 1340
EXIT_SEARCH_FOR_PREVIOUS_LOOP   004663 constant        label                    dcl 1232 ref 1228
INTERRUPT                       000000 constant        label                    array(17) dcl 468 ref 462 462 465
LINE_STATUS                     000064 constant        label                    array(14) dcl 3334 ref 3328 3328 3328
LOADING_FAILS                   001577 constant        label                    dcl 482 ref 3316
NO_MORE_RECORDS                 012170 constant        label                    dcl 2781 ref 2747 2775
NO_MORE_ROOM                    013532 constant        label                    dcl 3211 ref 3174 3192
RETURN_FROM_CALLER              012172 constant        label                    dcl 2792 ref 3056 3223
RETURN_FROM_FIND_NEXT_RECORD    014563 constant        label                    dcl 3523 ref 3562
RETURN_FROM_PROCESS_INPUT_RECORDS
                                007343 constant        label                    dcl 1938 ref 2322
RETURN_FROM_PROCESS_LOOPBACK_RECORDS
                                007724 constant        label                    dcl 2111 ref 2031 2324
RETURN_FROM_PROCESS_OUTPUT_RECORDS
                                012376 constant        label                    dcl 2898 ref 3225
RETURN_FROM_READ_CALL           001052 constant        label                    dcl 297 ref 267
RETURN_FROM_WRITE_CALL          001361 constant        label                    dcl 434 ref 339
SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD
                                014551 constant        label                    dcl 3517 ref 3467 3485 3501
TRY_STATUS_OR_RTS_BLOCK         011261 constant        label                    dcl 2492 ref 2477
add_rts_or_rts_ack_record       012022 constant        entry                    internal dcl 2715 ref 2513
add_to_output_block             013243 constant        entry                    internal dcl 3124 ref 3081 3084 3085 3098
advance_pointer                 014564 constant        entry                    internal dcl 3528 ref 3475 3480 3490 3492 3504 3508
                                                                                  3510
cant_accept_records_from_this_device
                                012676 constant        entry                    internal dcl 3017 ref 2834 2925 2952
check_modes                     002604 constant        entry                    external dcl 711
classify_record                 014734 constant        entry                    internal dcl 3611 ref 1684 1805 1984 3106
compute_local_bcb_and_fcs       011501 constant        entry                    internal dcl 2580 ref 2407 2422 2480 2492
control                         001765 constant        entry                    external dcl 578
count_dles                      014645 constant        entry                    internal dcl 3575 in procedure "advance_pointer" ref
                                                                                  3547 3554
count_dles                      013576 constant        entry                    internal dcl 3234 in procedure
                                                                                  "output_records_processor" ref 2974
crash                           000661 constant        entry                    external dcl 222
crash_mpx                       003507 constant        entry                    internal dcl 932 ref 228 486 492 570 3336
delete_leading_text             005673 constant        entry                    internal dcl 1496 ref 1395 1403
delete_text                     015232 constant        entry                    internal dcl 3751 ref 1516 1550 1938 2111 2898
dequeue_subchannel_for_output   004625 constant        entry                    internal dcl 1208 ref 429 846 1267 1899 2469
dialup                          000636 constant        entry                    external dcl 207
do_line_control                 013755 constant        entry                    internal dcl 3303 ref 471 472 473 475 476 477
empty_loopback_block_chain_stack
                                004506 constant        entry                    internal dcl 1158 ref 970
empty_minor_state_stack         004213 constant        entry                    internal dcl 1073 ref 969
empty_output_blockp             015144 constant        entry                    internal dcl 3694 ref 2402 2477 2486 2550 3024 3726
enqueue_subchannel_for_output   004564 constant        entry                    internal dcl 1180 ref 334
find_next_record                014402 constant        entry                    internal dcl 3426 ref 1799 1978 2847
find_subchannel                 010004 constant        entry                    internal dcl 2138 ref 1839 1878 1894 2018 2051 2067
finish_output_block             011640 constant        entry                    internal dcl 2642 ref 2408 2439 2481 2514
flush_record_buffers            010065 constant        entry                    internal dcl 2163 ref 1841 1862 1884 1904 1907 2020
                                                                                  2033 2040 2057 2072 2076
full_output_blockp              015175 constant        entry                    internal dcl 3723 ref 1973 2100 2456
get_modes                       002753 constant        entry                    external dcl 749
hasp_mpx                        000560 constant        entry                    external dcl 64
input_loopback_records_processor
                                006742 constant        entry                    internal dcl 1755
interrupt                       001411 constant        entry                    external dcl 453
interrupt_subchannels_requesting_input
                                005034 constant        entry                    internal dcl 1301 ref 511
interrupt_subchannels_with_input
                                004764 constant        entry                    internal dcl 1281 ref 297 393 528
interrupt_subchannels_with_output
                                004677 constant        entry                    internal dcl 1247 ref 1690 1709 2128 2562 3372 3418
load_mpx                        003334 constant        entry                    internal dcl 871 ref 3376
loopback_block_chain_stack_manager
                                004314 constant        entry                    internal dcl 1099
minor_state_stack_manager       003732 constant        entry                    internal dcl 997
move_record_to_device           010135 constant        entry                    internal dcl 2191 ref 1848 2035 2038
move_record_to_output_block     013035 constant        entry                    internal dcl 3073 ref 2863 2937 2988
output_records_processor        012171 constant        entry                    internal dcl 2789
pop_loopback_block_chain        004433 constant        entry                    internal dcl 1133 ref 1741
pop_minor_state                 004106 constant        entry                    internal dcl 1042 ref 1737 2127
process_available_input_blocks  005127 constant        entry                    internal dcl 1329 ref 259
process_input_block             005202 constant        entry                    internal dcl 1358 ref 525 1343
process_input_records           006744 constant        entry                    internal dcl 1784 ref 262 392 526 3415
process_line_status             014030 constant        entry                    internal dcl 3325 ref 547
process_loopback_records        007406 constant        entry                    internal dcl 1962 ref 300 434 501 529 629 3384 3409
process_output_block            010600 constant        entry                    internal dcl 2334 ref 302 437 503 531 631 668 2124
                                                                                  3387 3412
process_output_records          012173 constant        entry                    internal dcl 2828 ref 372 397
process_real_input_block        006075 constant        entry                    internal dcl 1573 ref 1406
process_single_loopback_record  012412 constant        entry                    internal dcl 2910 ref 2028
process_space_available         014347 constant        entry                    internal dcl 3401 ref 561
process_subchannel_loopback_records
                                012477 constant        entry                    internal dcl 2946 ref 2464
process_sync_block              006667 constant        entry                    internal dcl 1722 ref 1418
push_loopback_block_chain       004316 constant        entry                    internal dcl 1109 ref 1587
push_minor_state                003734 constant        entry                    internal dcl 1013 ref 1589
read                            000707 constant        entry                    external dcl 239
set_modes                       002617 constant        entry                    external dcl 717
setup_subchannel                003001 constant        entry                    internal dcl 759 ref 243 312 582 720
signal_dialup                   003023 constant        entry                    internal dcl 782 ref 214 593 598 3369
signal_hangup                   003211 constant        entry                    internal dcl 833 ref 603 985
space_in_empty_output_block_for_recordp
                                015221 constant        entry                    internal dcl 3737 ref 2855 2891
space_in_output_block_for_recordp
                                015163 constant        entry                    internal dcl 3708 ref 2861 2934 2986 3728
start_new_output_block          012765 constant        entry                    internal dcl 3048 ref 3026
strip_dles                      005746 constant        entry                    internal dcl 1524 ref 1397
substr_of_chain                 005562 constant        entry                    internal dcl 1455 ref 1394 1400 1401
system_initialize               000567 constant        entry                    external dcl 183
trace_block                     015257 constant        entry                    internal dcl 3777 ref 523 1341 2557
transmit_output_block           013662 constant        entry                    internal dcl 3268 ref 2349 2560 3405
write                           001070 constant        entry                    external dcl 308

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16520       16642   16063       16530
Length     17572   16063       122         714     435          14

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hasp_mpx                           1342 external procedure  is an external procedure.  
setup_subchannel                        internal procedure  shares stack frame of external procedure hasp_mpx.  
signal_dialup                           internal procedure  shares stack frame of external procedure hasp_mpx.  
signal_hangup                           internal procedure  shares stack frame of external procedure hasp_mpx.  
load_mpx                                internal procedure  shares stack frame of external procedure hasp_mpx.  
crash_mpx                               internal procedure  shares stack frame of external procedure hasp_mpx.  
minor_state_stack_manager               internal procedure  shares stack frame of external procedure hasp_mpx.  
loopback_block_chain_stack_manager
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
enqueue_subchannel_for_output           internal procedure  shares stack frame of external procedure hasp_mpx.  
dequeue_subchannel_for_output           internal procedure  shares stack frame of external procedure hasp_mpx.  
interrupt_subchannels_with_output
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
interrupt_subchannels_with_input
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
interrupt_subchannels_requesting_input
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
process_available_input_blocks
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
process_input_block                     internal procedure  shares stack frame of external procedure hasp_mpx.  
substr_of_chain                         internal procedure  shares stack frame of external procedure hasp_mpx.  
begin block on line 1478                begin block         shares stack frame of external procedure hasp_mpx.  
delete_leading_text                     internal procedure  shares stack frame of external procedure hasp_mpx.  
strip_dles                              internal procedure  shares stack frame of external procedure hasp_mpx.  
process_real_input_block                internal procedure  shares stack frame of external procedure hasp_mpx.  
process_sync_block                      internal procedure  shares stack frame of external procedure hasp_mpx.  
input_loopback_records_processor
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
find_subchannel                         internal procedure  shares stack frame of external procedure hasp_mpx.  
flush_record_buffers                    internal procedure  shares stack frame of external procedure hasp_mpx.  
move_record_to_device                   internal procedure  shares stack frame of external procedure hasp_mpx.  
process_output_block                    internal procedure  shares stack frame of external procedure hasp_mpx.  
compute_local_bcb_and_fcs               internal procedure  shares stack frame of external procedure hasp_mpx.  
finish_output_block                     internal procedure  shares stack frame of external procedure hasp_mpx.  
add_rts_or_rts_ack_record               internal procedure  shares stack frame of external procedure hasp_mpx.  
output_records_processor                internal procedure  shares stack frame of external procedure hasp_mpx.  
cant_accept_records_from_this_device
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
start_new_output_block                  internal procedure  shares stack frame of external procedure hasp_mpx.  
move_record_to_output_block             internal procedure  shares stack frame of external procedure hasp_mpx.  
add_to_output_block                     internal procedure  shares stack frame of external procedure hasp_mpx.  
count_dles                              internal procedure  shares stack frame of external procedure hasp_mpx.  
transmit_output_block                   internal procedure  shares stack frame of external procedure hasp_mpx.  
do_line_control                         internal procedure  shares stack frame of external procedure hasp_mpx.  
process_line_status                     internal procedure  shares stack frame of external procedure hasp_mpx.  
process_space_available                 internal procedure  shares stack frame of external procedure hasp_mpx.  
find_next_record                        internal procedure  shares stack frame of external procedure hasp_mpx.  
advance_pointer                         internal procedure  shares stack frame of external procedure hasp_mpx.  
count_dles                              internal procedure  shares stack frame of external procedure hasp_mpx.  
classify_record                         internal procedure  shares stack frame of external procedure hasp_mpx.  
empty_output_blockp                     internal procedure  shares stack frame of external procedure hasp_mpx.  
space_in_output_block_for_recordp
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
full_output_blockp                      internal procedure  shares stack frame of external procedure hasp_mpx.  
space_in_empty_output_block_for_recordp
                                        internal procedure  shares stack frame of external procedure hasp_mpx.  
delete_text                             internal procedure  shares stack frame of external procedure hasp_mpx.  
trace_block                             internal procedure  shares stack frame of external procedure hasp_mpx.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 et_action_not_performed     hasp_mpx
000011 et_bad_mode                 hasp_mpx
000012 et_incorrect_device_type    hasp_mpx
000013 et_invalid_read             hasp_mpx
000014 et_invalid_state            hasp_mpx
000015 et_invalid_write            hasp_mpx
000016 et_long_record              hasp_mpx
000017 et_noalloc                  hasp_mpx
000020 et_null_info_ptr            hasp_mpx
000021 et_out_of_sequence          hasp_mpx
000022 et_undefined_order_request  hasp_mpx
000023 et_unimplemented_version    hasp_mpx

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hasp_mpx                 000100 subchannel_idx              hasp_mpx
                         000101 code                        hasp_mpx
                         000102 chain_ptr                   hasp_mpx
                         000104 interrupt_type              hasp_mpx
                         000106 interrupt_data              hasp_mpx
                         000110 order                       hasp_mpx
                         000120 info_ptr                    hasp_mpx
                         000122 ttybp                       hasp_mpx
                         000124 needs_space                 hasp_mpx
                         000125 partial_record              hasp_mpx
                         000126 long_record                 hasp_mpx
                         000130 previously_scanned_bufferp  hasp_mpx
                         000132 last_bufferp                hasp_mpx
                         000134 idx                         hasp_mpx
                         000136 hmd_ptr                     hasp_mpx
                         000140 hste_ptr                    hasp_mpx
                         000142 hsd_ptr                     hasp_mpx
                         000144 msse_ptr                    hasp_mpx
                         000146 lbcse_ptr                   hasp_mpx
                         000150 hsmd_ptr                    hasp_mpx
                         000152 line_ctl                    hasp_mpx
                         000154 line_stat                   hasp_mpx
                         000156 dialup_info                 hasp_mpx
                         000160 rtx_info                    hasp_mpx
                         000162 blockp                      hasp_mpx
                         000164 mclp                        hasp_mpx
                         000166 mclep                       hasp_mpx
                         000210 saved_input_available       signal_dialup
                         000226 saved_send_output           load_mpx
                         000227 saved_input_available       load_mpx
                         000230 idx                         load_mpx
                         000240 old_state                   crash_mpx
                         000241 idx                         crash_mpx
                         000252 previous_msse_ptr           minor_state_stack_manager
                         000254 idx                         minor_state_stack_manager
                         000266 previous_lbcse_ptr          loopback_block_chain_stack_manager
                         000276 idx                         enqueue_subchannel_for_output
                         000306 previous_subchannel_idx     dequeue_subchannel_for_output
                         000316 saved_hste_ptr              interrupt_subchannels_with_output
                         000320 queue                       interrupt_subchannels_with_output
                         000341 n_entries                   interrupt_subchannels_with_output
                         000342 idx                         interrupt_subchannels_with_output
                         000352 idx                         interrupt_subchannels_with_input
                         000362 sent_interrupt              interrupt_subchannels_requesting_input
                         000363 idx                         interrupt_subchannels_requesting_input
                         000374 first_bufferp               process_available_input_blocks
                         000376 more_input                  process_available_input_blocks
                         000406 foreign_bcb_char            process_input_block
                         000407 foreign_fcs_chars           process_input_block
                         000410 first_bufferp               process_input_block
                         000412 last_bufferp                process_input_block
                         000414 next_to_last_bufferp        process_input_block
                         000416 first_char                  process_input_block
                         000426 the_text                    substr_of_chain
                         000430 characters_to_skip          substr_of_chain
                         000431 characters_to_pickup        substr_of_chain
                         000432 characters_in_buffer        substr_of_chain
                         000433 start                       substr_of_chain
                         000444 characters_left_to_delete   delete_leading_text
                         000454 bufferp                     strip_dles
                         000456 start                       strip_dles
                         000457 dle_idx                     strip_dles
                         000460 last_was_dle                strip_dles
                         000470 chain_to_release_ptr        process_real_input_block
                         000472 expected_count              process_real_input_block
                         000473 received_count              process_real_input_block
                         000474 record_type                 process_real_input_block
                         000475 idx                         process_real_input_block
                         000476 new_wab_bit                 process_real_input_block
                         000506 previous_minor_state        process_sync_block
                         000516 input_entry                 input_loopback_records_processor
                         000520 saved_hste_ptr              input_loopback_records_processor
                         000522 start_bufferp               input_loopback_records_processor
                         000524 end_bufferp                 input_loopback_records_processor
                         000526 start_record_idx            input_loopback_records_processor
                         000527 end_record_idx              input_loopback_records_processor
                         000530 rcb_char                    input_loopback_records_processor
                         000531 srcb_char                   input_loopback_records_processor
                         000532 continue_scan               input_loopback_records_processor
                         000533 record_was_taken            input_loopback_records_processor
                         000534 bufferp                     input_loopback_records_processor
                         000536 record_type                 input_loopback_records_processor
                         000537 record_tally                input_loopback_records_processor
                         000540 dle_count                   input_loopback_records_processor
                         000550 idx                         find_subchannel
                         000560 bufferp                     flush_record_buffers
                         000562 p                           flush_record_buffers
                         000572 record_data_ptr             move_record_to_device
                         000574 substr_lth                  move_record_to_device
                         000576 first_output_bufferp        move_record_to_device
                         000600 last_output_bufferp         move_record_to_device
                         000602 current_output_bufferp      move_record_to_device
                         000604 current_input_bufferp       move_record_to_device
                         000606 p                           move_record_to_device
                         000610 buffer_size_code            move_record_to_device
                         000611 n_buffers                   move_record_to_device
                         000612 n_words_in_last_buffer      move_record_to_device
                         000613 idx                         move_record_to_device
                         000614 amount_to_copy              move_record_to_device
                         000615 current_input_idx           move_record_to_device
                         000616 space_needed                move_record_to_device
                         000617 space_left                  move_record_to_device
                         000620 direction                   move_record_to_device
                         000630 local_bcb_char              process_output_block
                         000631 local_fcs_chars             process_output_block
                         000632 saved_hste_ptr              process_output_block
                         000634 idx                         process_output_block
                         000644 idx                         compute_local_bcb_and_fcs
                         000654 bufferp                     finish_output_block
                         000656 new_bufferp                 finish_output_block
                         000660 space_left_in_buffer        finish_output_block
                         000661 amount_needed               finish_output_block
                         000662 saved_tally                 finish_output_block
                         000672 p                           add_rts_or_rts_ack_record
                         000674 idx                         add_rts_or_rts_ack_record
                         000704 loopback_entry              output_records_processor
                         000706 saved_output_block          output_records_processor
                         000714 saved_last_tally            output_records_processor
                         000716 start_bufferp               output_records_processor
                         000720 end_bufferp                 output_records_processor
                         000722 start_record_idx            output_records_processor
                         000723 end_record_idx              output_records_processor
                         000724 continue_scan               output_records_processor
                         000726 bufferp                     output_records_processor
                         000730 p                           output_records_processor
                         000732 record_type                 output_records_processor
                         000733 record_tally                output_records_processor
                         000734 dle_count                   output_records_processor
                         000735 first_idx                   output_records_processor
                         000736 last_idx                    output_records_processor
                         000746 accept_records              cant_accept_records_from_this_device
                         000756 bufferp                     start_new_output_block
                         000774 text_ptr                    add_to_output_block
                         000776 text_lth                    add_to_output_block
                         001000 bufferp                     add_to_output_block
                         001002 new_bufferp                 add_to_output_block
                         001004 start                       add_to_output_block
                         001005 substr_lth                  add_to_output_block
                         001006 space_left_in_buffer        add_to_output_block
                         001007 add_dle                     add_to_output_block
                         001016 bufferp                     count_dles
                         001020 start                       count_dles
                         001021 idx                         count_dles
                         001022 dle_count                   count_dles
                         001032 p                           transmit_output_block
                         001066 bufferp                     find_next_record
                         001070 previous_bufferp            find_next_record
                         001072 record_idx                  find_next_record
                         001073 previous_record_idx         find_next_record
                         001074 record_tally                find_next_record
                         001075 dle_count                   find_next_record
                         001076 count_dles_sw               find_next_record
                         001077 end_of_data_is_special      find_next_record
                         001100 scb_char                    find_next_record
                         001110 amount_left                 advance_pointer
                         001111 amount_in_buffer            advance_pointer
                         001120 n_characters                count_dles
                         001121 count                       count_dles
                         001122 start                       count_dles
                         001123 idx                         count_dles
                         001132 bufferp                     classify_record
                         001134 rcb_idx                     classify_record
                         001135 rcb_char                    classify_record
                         001136 srcb_char                   classify_record
                         001137 first_scb_char              classify_record
                         001176 remainder_lth               delete_text

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             r_le_a              call_ext_out_desc   call_ext_out        return_mac
mdfx1               ext_entry           ext_entry_desc      divide_fx3          clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$control       channel_manager$interrupt     channel_manager$interrupt_later
channel_manager$read          channel_manager$write         mcs_trace                     mcs_trace$buffer_chain
pxss$ring_0_wakeup            syserr                        tty_space_man$free_buffer     tty_space_man$free_chain
tty_space_man$free_space      tty_space_man$get_buffer      tty_space_man$get_chain       tty_space_man$get_space
tty_space_man$needs_space     wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_mode
error_table_$incorrect_device_type                          error_table_$invalid_read     error_table_$invalid_state
error_table_$invalid_write    error_table_$long_record      error_table_$noalloc          error_table_$null_info_ptr
error_table_$out_of_sequence  error_table_$undefined_order_request
error_table_$unimplemented_version                          pds$process_id                tty_buf$


CONSTANTS
015330  aa     000004000000
015331  aa     000000000000
015332  aa     600000000041
015333  aa     002436000000
015334  aa     600000000041
015335  aa     002437000000

015336  aa     000002000000
015337  aa     000000000000
015340  aa     600000000041
015341  aa     002436000000

015342  aa     000004000000
015343  aa     000000000000
015344  aa     600000000041
015345  aa     001111000000
015346  aa     600000000041
015347  aa     002430000000

015350  aa     000004000000
015351  aa     000000000000
015352  aa     600000000041
015353  aa     001110000000
015354  aa     600000000041
015355  aa     002430000000

015356  aa     000002000000
015357  aa     000000000000
015360  aa     600000000041
015361  aa     002425000000

015362  aa     000002000000
015363  aa     000000000000
015364  aa     600000000041
015365  aa     002424000000

015366  aa     757777777777

015367  aa     775777777777

015370  aa     000006000000
015371  aa     000000000000
015372  aa     600000000041
015373  aa     000712000000
015374  aa     600000000041
015375  aa     000714000000
015376  aa     600000000041
015377  aa     000732000000

015400  aa     000004000000
015401  aa     000000000000
015402  aa     600000000041
015403  aa     002250000000
015404  aa     600000000041
015405  aa     002252000000

015406  aa     000002000000
015407  aa     000000000000
015410  aa     600000000041
015411  aa     002232000000

015412  aa     000004000000
015413  aa     000000000000
015414  aa     600000000041
015415  aa     000726000000
015416  aa     600000000041
015417  aa     002220000000

015420  aa     000004000000
015421  aa     000000000000
015422  aa     600000000041
015423  aa     000733000000
015424  aa     600000000041
015425  aa     002220000000

015426  aa     000006000000
015427  aa     000000000000
015430  aa     600000000041
015431  aa     000716000000
015432  aa     600000000041
015433  aa     002220000000
015434  aa     600000000041
015435  aa     000722000000

015436  aa     000004000000
015437  aa     000000000000
015440  aa     600000000041
015441  aa     002221000000
015442  aa     600000000041
015443  aa     002220000000

015444  aa     000002000000
015445  aa     000000000000
015446  aa     600000000041
015447  aa     002221000000

015450  aa     000004000000
015451  aa     000000000000
015452  aa     600000000041
015453  aa     000733000000
015454  aa     600000000041
015455  aa     002221000000

015456  aa     000020000000
015457  aa     000000000000
015460  aa     600000000041
015461  aa     000716000000
015462  aa     600000000041
015463  aa     000722000000
015464  aa     600000000041
015465  aa     002220000000
015466  aa     600000000041
015467  aa     002221000000
015470  aa     600000000041
015471  aa     000720000000
015472  aa     600000000041
015473  aa     000723000000
015474  aa     600000000041
015475  aa     000733000000
015476  aa     600000000041
015477  aa     000734000000

015500  aa     000002000000
015501  aa     000000000000
015502  aa     600000000041
015503  aa     002220000000

015504  aa     773777777777

015505  aa     777677777777

015506  aa     777760777777

015507  aa     760777777777

015510  aa     776777777777

015512  aa     000002000000
015513  aa     000000000000
015514  aa     600000000041
015515  aa     002175000000

015516  aa     200000000000

015520  aa     000002000000
015521  aa     000000000000
015522  aa     600000000041
015523  aa     002174000000

015524  aa     000006000000
015525  aa     000000000000
015526  aa     600000000041
015527  aa     000522000000
015530  aa     600000000041
015531  aa     002100000000
015532  aa     600000000041
015533  aa     000526000000

015534  aa     000016000000
015535  aa     000000000000
015536  aa     600000000041
015537  aa     000522000000
015540  aa     600000000041
015541  aa     002100000000
015542  aa     600000000041
015543  aa     000524000000
015544  aa     600000000041
015545  aa     000527000000
015546  aa     600000000041
015547  aa     000537000000
015550  aa     600000000041
015551  aa     000540000000
015552  aa     600000000041
015553  aa     000533000000

015554  aa     000020000000
015555  aa     000000000000
015556  aa     600000000041
015557  aa     000522000000
015560  aa     600000000041
015561  aa     000526000000
015562  aa     600000000041
015563  aa     002101000000
015564  aa     600000000041
015565  aa     002100000000
015566  aa     600000000041
015567  aa     000524000000
015570  aa     600000000041
015571  aa     000527000000
015572  aa     600000000041
015573  aa     000537000000
015574  aa     600000000041
015575  aa     000540000000

015576  aa     000002000000
015577  aa     000000000000
015600  aa     600000000041
015601  aa     002100000000

015602  aa     000006000000
015603  aa     000000000000
015604  aa     600000000041
015605  aa     000522000000
015606  aa     600000000041
015607  aa     002101000000
015610  aa     600000000041
015611  aa     000526000000

015612  aa     000004000000
015613  aa     000000000000
015614  aa     600000000041
015615  aa     000531000000
015616  aa     600000000041
015617  aa     000140000000

015620  aa     000004000000
015621  aa     000000000000
015622  aa     600000000041
015623  aa     000530000000
015624  aa     600000000041
015625  aa     000140000000

015626  aa     000006000000
015627  aa     000000000000
015630  aa     600000000041
015631  aa     000522000000
015632  aa     600000000041
015633  aa     000526000000
015634  aa     600000000041
015635  aa     000536000000

015636  aa     000020000000
015637  aa     000000000000
015640  aa     600000000041
015641  aa     000522000000
015642  aa     600000000041
015643  aa     000526000000
015644  aa     600000000041
015645  aa     002076000000
015646  aa     600000000041
015647  aa     002077000000
015650  aa     600000000041
015651  aa     000524000000
015652  aa     600000000041
015653  aa     000527000000
015654  aa     600000000041
015655  aa     000537000000
015656  aa     600000000041
015657  aa     002100000000

015660  aa     000006000000
015661  aa     000000000000
015662  aa     600000000041
015663  aa     000410000000
015664  aa     600000000041
015665  aa     001711000000
015666  aa     600000000041
015667  aa     000474000000

015670  aa     717777777777

015671  aa     767777777777

015672  aa     000002000000
015673  aa     000000000000
015674  ta     000170000000
015675  aa     000000000000

015676  aa     000006000000
015677  aa     000000000000
015700  aa     600000000041
015701  aa     000454000000
015702  aa     600000000041
015703  aa     001707000000
015704  aa     600000000041
015705  aa     001710000000

015706  aa     000006000000
015707  aa     000000000000
015710  aa     600000000041
015711  aa     000162000000
015712  aa     600000000041
015713  aa     001675000000
015714  aa     600000000041
015715  aa     000444000000

015716  aa     000006000000
015717  aa     000000000000
015720  aa     600000000041
015721  aa     001564000000
015722  aa     600000000041
015723  aa     001565000000
015724  aa     600000000041
015725  aa     001577000000

015726  aa     000002000000
015727  aa     000000000000
015730  aa     600000000041
015731  aa     001564000000

015732  aa     000006000000
015733  aa     000000000000
015734  aa     600000000041
015735  aa     001565000000
015736  aa     600000000041
015737  aa     001564000000
015740  aa     600000000041
015741  aa     001577000000

015742  aa     000002000000
015743  aa     000000000000
015744  aa     600000000041
015745  aa     000374000000

015746  aa     000004000000
015747  aa     000000000000
015750  aa     600000000041
015751  aa     000374000000
015752  ta     000112000000
015753  aa     000000000000

015754  aa     377777777777

015755  aa     677777777777

015756  aa     000002000000
015757  aa     000000000000
015760  ta     000172000000
015761  aa     000000000000

015762  aa     777777777000

015763  aa     777777000777

015764  aa     777000777777

015765  aa     000777777777

015766  aa     577777777777

015770  aa     000002000000
015771  aa     000000000000
015772  ta     000174000000
015773  aa     000000000000

015774  aa     000002000000
015775  aa     000000000000
015776  aa     600000000041
015777  aa     000102000000

016000  aa     000004000000
016001  aa     000000000000
016002  aa     600000000041
016003  aa     000102000000
016004  ta     000112000000
016005  aa     000000000000

016006  aa     737777777777

016010  aa     000010000000
016011  aa     000000000000
016012  ta     000174000000
016013  aa     000000000000
016014  aa     600000000041
016015  aa     001222000000
016016  aa     600000000041
016017  aa     001223000000
016020  aa     600000000041
016021  aa     001207000000

016022  aa     000010000000
016023  aa     000000000000
016024  ta     000140000000
016025  aa     000000000000
016026  aa     600000000041
016027  aa     001206000000
016030  aa     600000000041
016031  aa     001207000000
016032  aa     600000000041
016033  aa     001222000000

016034  aa     000010000000
016035  aa     000000000000
016036  ta     000172000000
016037  aa     000000000000
016040  aa     600000000041
016041  aa     001222000000
016042  aa     600000000041
016043  aa     001207000000
016044  aa     600000000041
016045  aa     001206000000

016046  aa     000010000000
016047  aa     000000000000
016050  ta     000165000000
016051  aa     000000000000
016052  aa     600000000041
016053  aa     001206000000
016054  aa     600000000041
016055  aa     001207000000
016056  aa     600000000041
016057  aa     001222000000

000102  aa     000000000074
000103  aa     000000000174
000104  aa     000000000274
000105  aa     000000000374
000106  aa     000000000474
000107  aa     000000000574
000110  aa     000000000674
000111  aa     000000000774

000112  aa     000000000000
000113  aa     000000000003

000114  aa     000000000000
000115  aa     000000000001

000116  aa     200000000000

000117  aa     301000000000

000120  aa     221000000000

000121  aa     222000000000

000122  aa     360000000000

000124  aa     000000000000
000125  aa     000000000003

000126  aa     000000000000
000127  aa     000000000002

000130  aa     000000000000
000131  aa     000000000001

000132  aa     524000000047

000133  aa     516000000001

000134  aa     524000000067

000135  aa     524000000110

000136  aa     000000000016

000137  aa     524000000014

000140  aa     000000000013

016060  aa     000000000100

000141  aa     526000000001

000142  aa     524000000151

000143  aa     000000000015

000144  aa     524000000146

000145  aa     524000000140

000146  aa     524000000114

000147  aa     514000000011

000150  aa     524000000102

000151  aa     530000000004

000152  aa     524000000123

000153  aa     524000000006

000154  aa     526000000040

000155  aa     524000000124

000156  aa  162 141 167 157	rawo

000157  aa  162 141 167 151	rawi

000160  aa  167 162 165 000	wru

000161  aa     524000000026

016062  aa     777777777777

000162  aa     400000000000

000163  aa     000000000000

016061  aa     000000000020

000164  aa     000000000005

000165  aa     000000000014

000166  aa     526077777777

000167  aa     514000000110

000170  aa     000000000004

000171  aa     514000000001

000172  aa     000000000003

000173  aa     404000000043

000174  aa     000000000002

000175  aa     404000000021

000176  aa     000000000001

000177  aa     464000000000

000200  aa  145 143 150 157	echo
000201  aa  160 154 145 170	plex

000202  aa  141 142 157 162	abor
000203  aa  164 000 000 000	t

000204  aa  150 141 156 147	hang
000205  aa  165 160 000 000	up

000206  aa  154 151 163 164	list
000207  aa  145 156 000 000	en

000210  aa     000000000000
000211  aa     000000000000

000212  aa     077777000043
000213  aa     000001000000

000214  aa  154 151 156 145	line
000215  aa  137 143 157 156	_con
000216  aa  164 162 157 154	trol

000217  aa  147 145 164 137	get_
000220  aa  155 145 164 145	mete
000221  aa  162 163 000 000	rs

000222  aa  143 157 160 171	copy
000223  aa  137 155 145 164	_met
000224  aa  145 162 163 000	ers

000225  aa  167 162 151 164	writ
000226  aa  145 137 163 164	e_st
000227  aa  141 164 165 163	atus

000230  aa  156 157 137 163	no_s
000231  aa  151 147 156 157	igno
000232  aa  156 137 162 145	n_re
000233  aa  143 157 162 144	cord

000234  aa  163 151 147 156	sign
000235  aa  157 156 137 162	on_r
000236  aa  145 143 157 162	ecor
000237  aa  144 000 000 000	d

000240  aa  147 145 164 137	get_
000241  aa  144 145 166 151	devi
000242  aa  143 145 137 164	ce_t
000243  aa  171 160 145 000	ype

000244  aa  163 145 164 137	set_
000245  aa  151 156 160 165	inpu
000246  aa  164 137 155 145	t_me
000247  aa  163 163 141 147	ssag
000250  aa  145 137 163 151	e_si
000251  aa  172 145 000 000	ze

000252  aa  136 133 117 165	^[Ou
000253  aa  164 160 165 164	tput
000254  aa  136 073 111 156	^;In
000255  aa  160 165 164 136	put^
000256  aa  135 040 143 150	] ch
000257  aa  141 151 156 040	ain 
000260  aa  163 164 141 162	star
000261  aa  164 151 156 147	ting
000262  aa  040 141 164 040	 at 
000263  aa  136 160 072 000	^p:

000264  aa  150 141 163 160	hasp
000265  aa  137 155 160 170	_mpx
000266  aa  040 050 154 151	 (li
000267  aa  156 145 040 136	ne ^
000270  aa  141 051 072 040	a): 
000271  aa  124 157 157 040	Too 
000272  aa  155 141 156 171	many
000273  aa  040 116 101 113	 NAK
000274  aa  123 073 040 154	S; l
000275  aa  151 156 145 040	ine 
000276  aa  167 151 154 154	will
000277  aa  040 142 145 040	 be 
000300  aa  150 165 156 147	hung
000301  aa  165 160 056 000	up.

000302  aa  150 141 163 160	hasp
000303  aa  137 155 160 170	_mpx
000304  aa  040 050 154 151	 (li
000305  aa  156 145 040 136	ne ^
000306  aa  141 051 072 040	a): 
000307  aa  104 165 160 154	Dupl
000310  aa  151 143 141 164	icat
000311  aa  145 040 154 157	e lo
000312  aa  157 160 142 141	opba
000313  aa  143 153 040 142	ck b
000314  aa  154 157 143 153	lock
000315  aa  040 162 145 143	 rec
000316  aa  145 151 166 145	eive
000317  aa  144 072 040 102	d: B
000320  aa  103 102 040 075	CB =
000321  aa  040 136 063 056	 ^3.
000322  aa  063 142 000 000	3b

000323  aa  150 141 163 160	hasp
000324  aa  137 155 160 170	_mpx
000325  aa  040 050 154 151	 (li
000326  aa  156 145 040 136	ne ^
000327  aa  141 051 072 040	a): 
000330  aa  102 141 144 040	Bad 
000331  aa  142 154 157 143	bloc
000332  aa  153 040 154 151	k li
000333  aa  156 145 040 163	ne s
000334  aa  164 141 164 165	tatu
000335  aa  163 040 146 162	s fr
000336  aa  157 155 040 106	om F
000337  aa  116 120 073 040	NP; 
000340  aa  154 151 156 145	line
000341  aa  040 167 151 154	 wil
000342  aa  154 040 142 145	l be
000343  aa  040 150 165 156	 hun
000344  aa  147 165 160 056	gup.

000345  aa  150 141 163 160	hasp
000346  aa  137 155 160 170	_mpx
000347  aa  040 050 154 151	 (li
000350  aa  156 145 040 136	ne ^
000351  aa  141 051 072 040	a): 
000352  aa  111 156 166 141	Inva
000353  aa  154 151 144 040	lid 
000354  aa  151 156 160 165	inpu
000355  aa  164 040 142 154	t bl
000356  aa  157 143 153 040	ock 
000357  aa  150 145 141 144	head
000360  aa  145 162 057 164	er/t
000361  aa  162 141 151 154	rail
000362  aa  145 162 073 040	er; 
000363  aa  154 151 156 145	line
000364  aa  040 167 151 154	 wil
000365  aa  154 040 142 145	l be
000366  aa  040 150 165 156	 hun
000367  aa  147 165 160 056	gup.

000370  aa  150 141 163 160	hasp
000371  aa  137 155 160 170	_mpx
000372  aa  040 050 154 151	 (li
000373  aa  156 145 040 136	ne ^
000374  aa  141 051 072 040	a): 
000375  aa  116 157 040 163	No s
000376  aa  160 141 143 145	pace
000377  aa  040 141 166 141	 ava
000400  aa  151 154 141 142	ilab
000401  aa  154 145 040 164	le t
000402  aa  157 040 163 141	o sa
000403  aa  166 145 040 154	ve l
000404  aa  157 157 160 142	oopb
000405  aa  141 143 153 040	ack 
000406  aa  143 150 141 151	chai
000407  aa  156 073 040 154	n; l
000410  aa  151 156 145 040	ine 
000411  aa  167 151 154 154	will
000412  aa  040 142 145 040	 be 
000413  aa  150 165 156 147	hung
000414  aa  165 160 056 000	up.

000415  aa  150 141 163 160	hasp
000416  aa  137 155 160 170	_mpx
000417  aa  040 050 154 151	 (li
000420  aa  156 145 040 136	ne ^
000421  aa  141 051 072 040	a): 
000422  aa  116 157 040 163	No s
000423  aa  160 141 143 145	pace
000424  aa  040 141 166 141	 ava
000425  aa  151 154 141 142	ilab
000426  aa  154 145 040 164	le t
000427  aa  157 040 160 162	o pr
000430  aa  145 163 145 162	eser
000431  aa  166 145 040 155	ve m
000432  aa  151 156 157 162	inor
000433  aa  040 163 164 141	 sta
000434  aa  164 145 073 040	te; 
000435  aa  154 151 156 145	line
000436  aa  040 167 151 154	 wil
000437  aa  154 040 142 145	l be
000440  aa  040 150 165 156	 hun
000441  aa  147 165 160 056	gup.

000442  aa  150 141 163 160	hasp
000443  aa  137 155 160 170	_mpx
000444  aa  040 050 154 151	 (li
000445  aa  156 145 040 136	ne ^
000446  aa  141 051 072 040	a): 
000447  aa  102 154 157 143	Bloc
000450  aa  153 040 162 145	k re
000451  aa  143 145 151 166	ceiv
000452  aa  145 144 040 157	ed o
000453  aa  165 164 040 157	ut o
000454  aa  146 040 163 145	f se
000455  aa  161 165 145 156	quen
000456  aa  143 145 072 040	ce: 
000457  aa  145 170 160 145	expe
000460  aa  143 164 145 144	cted
000461  aa  040 075 040 136	 = ^
000462  aa  144 054 040 162	d, r
000463  aa  145 143 145 151	ecei
000464  aa  166 145 144 040	ved 
000465  aa  075 040 136 144	= ^d
000466  aa  073 040 142 154	; bl
000467  aa  157 143 153 040	ock 
000470  aa  151 147 156 157	igno
000471  aa  162 145 144 056	red.

000472  aa  150 141 163 160	hasp
000473  aa  137 155 160 170	_mpx
000474  aa  040 050 154 151	 (li
000475  aa  156 145 040 136	ne ^
000476  aa  141 051 072 040	a): 
000477  aa  102 154 157 143	Bloc
000500  aa  153 040 162 145	k re
000501  aa  143 145 151 166	ceiv
000502  aa  145 144 040 157	ed o
000503  aa  165 164 040 157	ut o
000504  aa  146 040 163 145	f se
000505  aa  161 165 145 156	quen
000506  aa  143 145 072 040	ce: 
000507  aa  145 170 160 145	expe
000510  aa  143 164 145 144	cted
000511  aa  040 075 040 136	 = ^
000512  aa  144 054 040 162	d, r
000513  aa  145 143 145 151	ecei
000514  aa  166 145 144 040	ved 
000515  aa  075 040 136 144	= ^d
000516  aa  073 040 154 151	; li
000517  aa  156 145 040 167	ne w
000520  aa  151 154 154 040	ill 
000521  aa  142 145 040 150	be h
000522  aa  165 156 147 165	ungu
000523  aa  160 056 000 000	p.

000524  aa  150 141 163 160	hasp
000525  aa  137 155 160 170	_mpx
000526  aa  040 050 154 151	 (li
000527  aa  156 145 040 136	ne ^
000530  aa  141 051 072 040	a): 
000531  aa  102 154 157 143	Bloc
000532  aa  153 040 164 162	k tr
000533  aa  141 156 163 155	ansm
000534  aa  151 164 164 145	itte
000535  aa  144 040 157 165	d ou
000536  aa  164 040 157 146	t of
000537  aa  040 163 145 161	 seq
000540  aa  165 145 156 143	uenc
000541  aa  145 072 040 145	e: e
000542  aa  170 160 145 143	xpec
000543  aa  164 145 144 040	ted 
000544  aa  075 040 136 144	= ^d
000545  aa  054 040 162 145	, re
000546  aa  143 145 151 166	ceiv
000547  aa  145 144 040 075	ed =
000550  aa  040 136 144 073	 ^d;
000551  aa  040 154 151 156	 lin
000552  aa  145 040 167 151	e wi
000553  aa  154 154 040 142	ll b
000554  aa  145 040 150 165	e hu
000555  aa  156 147 165 160	ngup
000556  aa  056 000 000 000	.

LABEL ARRAYS
000000  aa   001443 7100 04	tra  	803,ic		001443
000001  aa   001577 7100 04	tra  	895,ic		001600
000002  aa   001616 7100 04	tra  	910,ic		001620
000003  aa   001617 7100 04	tra  	911,ic		001622
000004  aa   001634 7100 04	tra  	924,ic		001640
000005  aa   001644 7100 04	tra  	932,ic		001651
000006  aa   001712 7100 04	tra  	970,ic		001720
000007  aa   001712 7100 04	tra  	970,ic		001721
000010  aa   001712 7100 04	tra  	970,ic		001722
000011  aa   001715 7100 04	tra  	973,ic		001726
000012  aa   001715 7100 04	tra  	973,ic		001727
000013  aa   001715 7100 04	tra  	973,ic		001730
000014  aa   001723 7100 04	tra  	979,ic		001737
000015  aa   001722 7100 04	tra  	978,ic		001737
000016  aa   001721 7100 04	tra  	977,ic		001737
000017  aa   001720 7100 04	tra  	976,ic		001737
000020  aa   001720 7100 04	tra  	976,ic		001740

000064  aa   013757 7100 04	tra  	6127,ic		014043
000065  aa   014002 7100 04	tra  	6146,ic		014067
000066  aa   014260 7100 04	tra  	6320,ic		014346
000067  aa   014057 7100 04	tra  	6191,ic		014146
000070  aa   014256 7100 04	tra  	6318,ic		014346
000071  aa   014134 7100 04	tra  	6236,ic		014225
000072  aa   014254 7100 04	tra  	6316,ic		014346
000073  aa   014253 7100 04	tra  	6315,ic		014346
000074  aa   014252 7100 04	tra  	6314,ic		014346
000075  aa   014251 7100 04	tra  	6313,ic		014346
000076  aa   014250 7100 04	tra  	6312,ic		014346
000077  aa   014247 7100 04	tra  	6311,ic		014346
000100  aa   014223 7100 04	tra  	6291,ic		014323
000101  aa   014230 7100 04	tra  	6296,ic		014331

BEGIN PROCEDURE hasp_mpx
ENTRY TO hasp_mpx                                           STATEMENT 1 ON LINE 64
hasp_mpx:
     procedure ();

000557  da     000351200000
000560  aa   002500 6270 00	eax7 	1344
000561  aa  7 00034 3521 20	epp2 	pr7|28,*
000562  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000563  aa     000000000000
000564  aa     000000000000
						STATEMENT 1 ON LINE 67
	return;

000565  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO system_initialize                                  STATEMENT 1 ON LINE 183
system_initialize:
     entry ();

000566  da     000361200000
000567  aa   002500 6270 00	eax7 	1344
000570  aa  7 00034 3521 20	epp2 	pr7|28,*
000571  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000572  aa     000000000000
000573  aa     000000000000
						STATEMENT 1 ON LINE 186
	et_action_not_performed = error_table_$action_not_performed;

000574  aa  6 00044 3701 20	epp4 	pr6|36,*
000575  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$action_not_performed
000576  ia  4 00010 7561 00	stq  	pr4|8		et_action_not_performed
						STATEMENT 1 ON LINE 187
	et_bad_mode = error_table_$bad_mode;

000577  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$bad_mode
000600  ia  4 00011 7561 00	stq  	pr4|9		et_bad_mode
						STATEMENT 1 ON LINE 188
	et_incorrect_device_type = error_table_$incorrect_device_type;

000601  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$incorrect_device_type
000602  ia  4 00012 7561 00	stq  	pr4|10		et_incorrect_device_type
						STATEMENT 1 ON LINE 189
	et_invalid_read = error_table_$invalid_read;

000603  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$invalid_read
000604  ia  4 00013 7561 00	stq  	pr4|11		et_invalid_read
						STATEMENT 1 ON LINE 190
	et_invalid_state = error_table_$invalid_state;

000605  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$invalid_state
000606  ia  4 00014 7561 00	stq  	pr4|12		et_invalid_state
						STATEMENT 1 ON LINE 191
	et_invalid_write = error_table_$invalid_write;

000607  la  4 00042 2361 20	ldq  	pr4|34,*		error_table_$invalid_write
000610  ia  4 00015 7561 00	stq  	pr4|13		et_invalid_write
						STATEMENT 1 ON LINE 192
	et_long_record = error_table_$long_record;

000611  la  4 00044 2361 20	ldq  	pr4|36,*		error_table_$long_record
000612  ia  4 00016 7561 00	stq  	pr4|14		et_long_record
						STATEMENT 1 ON LINE 193
	et_noalloc = error_table_$noalloc;

000613  la  4 00046 2361 20	ldq  	pr4|38,*		error_table_$noalloc
000614  ia  4 00017 7561 00	stq  	pr4|15		et_noalloc
						STATEMENT 1 ON LINE 194
	et_null_info_ptr = error_table_$null_info_ptr;

000615  la  4 00050 2361 20	ldq  	pr4|40,*		error_table_$null_info_ptr
000616  ia  4 00020 7561 00	stq  	pr4|16		et_null_info_ptr
						STATEMENT 1 ON LINE 195
	et_out_of_sequence = error_table_$out_of_sequence;

000617  la  4 00052 2361 20	ldq  	pr4|42,*		error_table_$out_of_sequence
000620  ia  4 00021 7561 00	stq  	pr4|17		et_out_of_sequence
						STATEMENT 1 ON LINE 196
	et_undefined_order_request = error_table_$undefined_order_request;

000621  la  4 00054 2361 20	ldq  	pr4|44,*		error_table_$undefined_order_request
000622  ia  4 00022 7561 00	stq  	pr4|18		et_undefined_order_request
						STATEMENT 1 ON LINE 197
	et_unimplemented_version = error_table_$unimplemented_version;

000623  la  4 00056 2361 20	ldq  	pr4|46,*		error_table_$unimplemented_version
000624  ia  4 00023 7561 00	stq  	pr4|19		et_unimplemented_version
						STATEMENT 1 ON LINE 199
	call wire_proc$wire_me ();

000625  aa  6 00056 6211 00	eax1 	pr6|46
000626  aa   000000 4310 07	fld  	0,dl
000627  la  4 00070 3521 20	epp2 	pr4|56,*		wire_proc$wire_me
000630  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 201
	return;

000631  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO dialup                                             STATEMENT 1 ON LINE 207
dialup:
     entry (P_hmd_ptr, P_subchannel_idx);

000632  at     000002000177
000633  ta     000175000000
000634  ta     000632000000
000635  da     000366300000
000636  aa   002500 6270 00	eax7 	1344
000637  aa  7 00034 3521 20	epp2 	pr7|28,*
000640  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000641  aa     000004000000
000642  aa     000000000000
						STATEMENT 1 ON LINE 210
	hmd_ptr = P_hmd_ptr;

000643  aa  6 00032 3735 20	epp7 	pr6|26,*
000644  aa  7 00002 3715 20	epp5 	pr7|2,*		P_hmd_ptr
000645  aa  5 00000 3715 20	epp5 	pr5|0,*		P_hmd_ptr
000646  aa  6 00136 6515 00	spri5	pr6|94		hmd_ptr
						STATEMENT 1 ON LINE 211
	subchannel_idx = P_subchannel_idx;

000647  aa  7 00004 2361 20	ldq  	pr7|4,*		P_subchannel_idx
000650  aa  6 00100 7561 00	stq  	pr6|64		subchannel_idx
						STATEMENT 1 ON LINE 212
	hste_ptr = addr (hmd.subchannels (subchannel_idx));

000651  aa   000050 4020 07	mpy  	40,dl
000652  aa  5 00044 3535 06	epp3 	pr5|36,ql		hmd.subchannels
000653  aa  6 00140 2535 00	spri3	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 214
	call signal_dialup ();

000654  aa   002147 6700 04	tsp4 	1127,ic		003023
						STATEMENT 1 ON LINE 216
	return;

000655  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO crash                                              STATEMENT 1 ON LINE 222
crash:
     entry (P_hmd_ptr);

000656  at     000001000177
000657  ta     000656000000
000660  da     000373300000
000661  aa   002500 6270 00	eax7 	1344
000662  aa  7 00034 3521 20	epp2 	pr7|28,*
000663  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000664  aa     000002000000
000665  aa     000000000000
						STATEMENT 1 ON LINE 225
	ttybp = addr (tty_buf$);

000666  aa  6 00044 3701 20	epp4 	pr6|36,*
000667  la  4 00026 3735 20	epp7 	pr4|22,*		tty_buf$
000670  aa  6 00122 6535 00	spri7	pr6|82		ttybp
						STATEMENT 1 ON LINE 226
	hmd_ptr = P_hmd_ptr;

000671  aa  6 00032 3715 20	epp5 	pr6|26,*
000672  aa  5 00002 3535 20	epp3 	pr5|2,*		P_hmd_ptr
000673  aa  3 00000 3535 20	epp3 	pr3|0,*		P_hmd_ptr
000674  aa  6 00136 2535 00	spri3	pr6|94		hmd_ptr
						STATEMENT 1 ON LINE 228
	call crash_mpx ();

000675  aa   002612 6700 04	tsp4 	1418,ic		003507
						STATEMENT 1 ON LINE 230
	return;

000676  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 233
ERROR_RETURN:
	P_code = code;

000677  aa  6 00101 2361 00	ldq  	pr6|65		code
000700  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 235
	return;

000701  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read                                               STATEMENT 1 ON LINE 239
read:
     entry (P_hmd_ptr, P_subchannel_idx, P_chain_ptr, P_more_input, P_code);

000702  at     000005000177
000703  tt     000175000177
000704  tt     000171000173
000705  ta     000702000000
000706  da     000376300000
000707  aa   002500 6270 00	eax7 	1344
000710  aa  7 00034 3521 20	epp2 	pr7|28,*
000711  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000712  aa     000012000000
000713  aa     000000000000
000714  aa  6 00032 3735 20	epp7 	pr6|26,*
000715  aa  7 00012 3715 20	epp5 	pr7|10,*
000716  aa  6 00170 6515 00	spri5	pr6|120
						STATEMENT 1 ON LINE 242
	ttybp = addr (tty_buf$);

000717  aa  6 00044 3701 20	epp4 	pr6|36,*
000720  la  4 00026 3735 20	epp7 	pr4|22,*		tty_buf$
000721  aa  6 00122 6535 00	spri7	pr6|82		ttybp
						STATEMENT 1 ON LINE 243
	call setup_subchannel ();

000722  aa   002057 6700 04	tsp4 	1071,ic		003001
						STATEMENT 1 ON LINE 244
	P_chain_ptr = null ();

000723  aa   777267 2370 04	ldaq 	-329,ic		000212 = 077777000043 000001000000
000724  aa  6 00032 3735 20	epp7 	pr6|26,*
000725  aa  7 00006 7571 20	staq 	pr7|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 245
	P_more_input = "0"b;

000726  aa  7 00010 4501 20	stz  	pr7|8,*		P_more_input
						STATEMENT 1 ON LINE 246
	P_code = 0;

000727  aa  6 00170 4501 20	stz  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 248
	if hste.state ^= HSTE_DIALED then		/* not if channel isn't dialed up */
	     return;

000730  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
000731  aa  5 00012 2361 00	ldq  	pr5|10		hste.state
000732  aa   000003 1160 07	cmpq 	3,dl
000733  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 251
	if hste.direction = HSTE_OUTPUT_ONLY then do;

000734  aa  5 00004 2361 00	ldq  	pr5|4		hste.direction
000735  aa   000002 1160 07	cmpq 	2,dl
000736  aa   000005 6010 04	tnz  	5,ic		000743
						STATEMENT 1 ON LINE 252
	     P_code = et_invalid_read;

000737  aa  6 00044 3701 20	epp4 	pr6|36,*
000740  ia  4 00013 2361 00	ldq  	pr4|11		et_invalid_read
000741  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 253
	     return;

000742  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 254
	end;

						STATEMENT 1 ON LINE 259
	if hmd.flags.input_available then		/* something is waiting for us */
	     call process_available_input_blocks ();

000743  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
000744  aa  3 00070 2351 00	lda  	pr3|56		hmd.input_available
000745  aa   040000 3150 03	cana 	16384,du
000746  aa   000002 6000 04	tze  	2,ic		000750
000747  aa   004160 6700 04	tsp4 	2160,ic		005127
						STATEMENT 1 ON LINE 262
	if (hmd.input.first_bufferp ^= null ()) then	/* some records are waiting to be processed */
	     call process_input_records ();

000750  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
000751  aa  7 00042 2371 00	ldaq 	pr7|34		hmd.first_bufferp
000752  aa   777240 6770 04	eraq 	-352,ic		000212 = 077777000043 000001000000
000753  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000754  aa   000002 6000 04	tze  	2,ic		000756
000755  aa   005767 6700 04	tsp4 	3063,ic		006744
						STATEMENT 1 ON LINE 265
	if hste.input.first_bufferp = null () then do;

000756  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
000757  aa  7 00020 2371 00	ldaq 	pr7|16		hste.first_bufferp
000760  aa   777232 6770 04	eraq 	-358,ic		000212 = 077777000043 000001000000
000761  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000762  aa   000004 6010 04	tnz  	4,ic		000766
						STATEMENT 1 ON LINE 266
	     hste.requested_input = "1"b;

000763  aa   400000 2350 03	lda  	131072,du
000764  aa  7 00036 2551 00	orsa 	pr7|30		hste.requested_input
						STATEMENT 1 ON LINE 267
	     go to RETURN_FROM_READ_CALL;

000765  aa   000065 7100 04	tra  	53,ic		001052
						STATEMENT 1 ON LINE 268
	end;

						STATEMENT 1 ON LINE 273
	P_chain_ptr = hste.input.first_bufferp;

000766  aa  7 00020 3715 20	epp5 	pr7|16,*		hste.first_bufferp
000767  aa  6 00032 3535 20	epp3 	pr6|26,*
000770  aa  3 00006 6515 20	spri5	pr3|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 275
	last_bufferp = null ();

000771  aa   777221 2370 04	ldaq 	-367,ic		000212 = 077777000043 000001000000
000772  aa  6 00132 7571 00	staq 	pr6|90		last_bufferp
						STATEMENT 1 ON LINE 276
	do blockp = hste.input.first_bufferp repeat (pointer (ttybp, buffer.next)) while (last_bufferp = null ());

000773  aa  7 00020 3515 20	epp1 	pr7|16,*		hste.first_bufferp
000774  aa  6 00162 2515 00	spri1	pr6|114		blockp
000775  aa   000000 0110 03	nop  	0,du
000776  aa  6 00132 2371 00	ldaq 	pr6|90		last_bufferp
000777  aa   777213 6770 04	eraq 	-373,ic		000212 = 077777000043 000001000000
001000  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001001  aa   000016 6010 04	tnz  	14,ic		001017
						STATEMENT 1 ON LINE 277
	     if (buffer.next = 0) | buffer.break then	/* last buffer or end-of-record */
		last_bufferp = blockp;

001002  aa  6 00162 2351 20	lda  	pr6|114,*		buffer.next
001003  aa   000066 7730 00	lrl  	54
001004  aa  6 01206 7561 00	stq  	pr6|646		buffer.next
001005  aa   000004 6000 04	tze  	4,ic		001011
001006  aa  6 00162 2351 20	lda  	pr6|114,*		buffer.break
001007  aa   100000 3150 07	cana 	32768,dl
001010  aa   000003 6000 04	tze  	3,ic		001013
001011  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
001012  aa  6 00132 6535 00	spri7	pr6|90		last_bufferp
						STATEMENT 1 ON LINE 279
	end;

001013  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
001014  aa   000000 3120 06	eawp2	0,ql
001015  aa  6 00162 2521 00	spri2	pr6|114		blockp
001016  aa   777760 7100 04	tra  	-16,ic		000776
						STATEMENT 1 ON LINE 281
	if (last_bufferp -> buffer.next = 0) then	/* no more input records after this one */
	     hste.input.first_bufferp, hste.input.last_bufferp = null ();

001017  aa  6 00132 2351 20	lda  	pr6|90,*		buffer.next
001020  aa   000066 7730 00	lrl  	54
001021  aa  6 01206 7561 00	stq  	pr6|646		buffer.next
001022  aa   000006 6010 04	tnz  	6,ic		001030
001023  aa   777167 3734 24	epp7 	-393,ic*
001024  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
001025  aa  5 00020 6535 00	spri7	pr5|16		hste.first_bufferp
001026  aa  5 00022 6535 00	spri7	pr5|18		hste.last_bufferp
001027  aa   000010 7100 04	tra  	8,ic		001037
						STATEMENT 1 ON LINE 283
	else do;

						STATEMENT 1 ON LINE 284
	     hste.input.first_bufferp = pointer (ttybp, last_bufferp -> buffer.next);

001030  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
001031  aa   000000 3120 06	eawp2	0,ql
001032  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
001033  aa  7 00020 2521 00	spri2	pr7|16		hste.first_bufferp
						STATEMENT 1 ON LINE 285
	     last_bufferp -> buffer.next = 0;

001034  aa   000000 2350 07	lda  	0,dl
001035  aa  6 00132 3715 20	epp5 	pr6|90,*		buffer.next
001036  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 286
	end;

						STATEMENT 1 ON LINE 288
	hste.input.n_records = hste.input.n_records - 1;

001037  aa   000001 3360 07	lcq  	1,dl
001040  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
001041  aa  7 00016 0561 00	asq  	pr7|14		hste.n_records
						STATEMENT 1 ON LINE 290
	if hste.input.n_records < hmd.max_device_input_records then
	     hmd.input_wabs (hste.device_wab_idx) = "1"b;

001042  aa  7 00016 2361 00	ldq  	pr7|14		hste.n_records
001043  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
001044  aa  5 00013 1161 00	cmpq 	pr5|11		hmd.max_device_input_records
001045  aa   000005 6050 04	tpl  	5,ic		001052
001046  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
001047  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
001050  aa   000000 00 0000	descb	0,0
001051  aa  5 00067 00 0001	descb	pr5|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 297
RETURN_FROM_READ_CALL:
	call interrupt_subchannels_with_input ();

001052  aa   003712 6700 04	tsp4 	1994,ic		004764
						STATEMENT 1 ON LINE 300
	if (hmd.minor_state = HMD_REPROCESS) then
	     call process_loopback_records ();

001053  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001054  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
001055  aa   000006 1160 07	cmpq 	6,dl
001056  aa   000003 6010 04	tnz  	3,ic		001061
001057  aa   006327 6700 04	tsp4 	3287,ic		007406
001060  aa   000002 7100 04	tra  	2,ic		001062
						STATEMENT 1 ON LINE 302
	else call process_output_block ();

001061  aa   007517 6700 04	tsp4 	3919,ic		010600
						STATEMENT 1 ON LINE 304
	return;

001062  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO write                                              STATEMENT 1 ON LINE 308
write:
     entry (P_hmd_ptr, P_subchannel_idx, P_chain_ptr, P_code);

001063  at     000004000177
001064  tt     000175000177
001065  ta     000173000000
001066  ta     001063000000
001067  da     000401300000
001070  aa   002500 6270 00	eax7 	1344
001071  aa  7 00034 3521 20	epp2 	pr7|28,*
001072  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001073  aa     000010000000
001074  aa     000000000000
001075  aa  6 00032 3735 20	epp7 	pr6|26,*
001076  aa  7 00010 3715 20	epp5 	pr7|8,*
001077  aa  6 00170 6515 00	spri5	pr6|120
						STATEMENT 1 ON LINE 311
	ttybp = addr (tty_buf$);

001100  aa  6 00044 3701 20	epp4 	pr6|36,*
001101  la  4 00026 3735 20	epp7 	pr4|22,*		tty_buf$
001102  aa  6 00122 6535 00	spri7	pr6|82		ttybp
						STATEMENT 1 ON LINE 312
	call setup_subchannel ();

001103  aa   001676 6700 04	tsp4 	958,ic		003001
						STATEMENT 1 ON LINE 313
	chain_ptr = P_chain_ptr;

001104  aa  6 00032 3735 20	epp7 	pr6|26,*
001105  aa  7 00006 3715 20	epp5 	pr7|6,*		P_chain_ptr
001106  aa  5 00000 3715 20	epp5 	pr5|0,*		P_chain_ptr
001107  aa  6 00102 6515 00	spri5	pr6|66		chain_ptr
						STATEMENT 1 ON LINE 315
	if hste.state ^= HSTE_DIALED then do;

001110  aa  6 00140 3535 20	epp3 	pr6|96,*		hste_ptr
001111  aa  3 00012 2361 00	ldq  	pr3|10		hste.state
001112  aa   000003 1160 07	cmpq 	3,dl
001113  aa   000021 6000 04	tze  	17,ic		001134
						STATEMENT 1 ON LINE 316
	     call tty_space_man$free_chain (hste.devx, OUTPUT, chain_ptr);

001114  aa  3 00005 3521 00	epp2 	pr3|5		hste.devx
001115  aa  6 01214 2521 00	spri2	pr6|652
001116  aa   777044 3520 04	epp2 	-476,ic		000162 = 400000000000
001117  aa  6 01216 2521 00	spri2	pr6|654
001120  aa  6 00102 3521 00	epp2 	pr6|66		chain_ptr
001121  aa  6 01220 2521 00	spri2	pr6|656
001122  aa  6 01212 6211 00	eax1 	pr6|650
001123  aa   014000 4310 07	fld  	6144,dl
001124  aa  6 00044 3701 20	epp4 	pr6|36,*
001125  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
001126  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 317
	     P_chain_ptr = null ();

001127  aa   777063 2370 04	ldaq 	-461,ic		000212 = 077777000043 000001000000
001130  aa  6 00032 3735 20	epp7 	pr6|26,*
001131  aa  7 00006 7571 20	staq 	pr7|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 318
	     P_code = 0;

001132  aa  6 00170 4501 20	stz  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 319
	     return;

001133  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 320
	end;

						STATEMENT 1 ON LINE 322
	if hste.direction = HSTE_INPUT_ONLY then do;

001134  aa  3 00004 2361 00	ldq  	pr3|4		hste.direction
001135  aa   000001 1160 07	cmpq 	1,dl
001136  aa   000023 6010 04	tnz  	19,ic		001161
						STATEMENT 1 ON LINE 323
	     call tty_space_man$free_chain (hste.devx, OUTPUT, chain_ptr);

001137  aa  3 00005 3521 00	epp2 	pr3|5		hste.devx
001140  aa  6 01214 2521 00	spri2	pr6|652
001141  aa   777021 3520 04	epp2 	-495,ic		000162 = 400000000000
001142  aa  6 01216 2521 00	spri2	pr6|654
001143  aa  6 00102 3521 00	epp2 	pr6|66		chain_ptr
001144  aa  6 01220 2521 00	spri2	pr6|656
001145  aa  6 01212 6211 00	eax1 	pr6|650
001146  aa   014000 4310 07	fld  	6144,dl
001147  aa  6 00044 3701 20	epp4 	pr6|36,*
001150  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
001151  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 324
	     P_chain_ptr = null ();

001152  aa   777040 2370 04	ldaq 	-480,ic		000212 = 077777000043 000001000000
001153  aa  6 00032 3735 20	epp7 	pr6|26,*
001154  aa  7 00006 7571 20	staq 	pr7|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 325
	     P_code = et_invalid_write;

001155  aa  6 00044 3701 20	epp4 	pr6|36,*
001156  ia  4 00015 2361 00	ldq  	pr4|13		et_invalid_write
001157  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 326
	     return;

001160  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 327
	end;

						STATEMENT 1 ON LINE 329
	P_code = 0;

001161  aa  6 00170 4501 20	stz  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 334
	call enqueue_subchannel_for_output ();

001162  aa   003402 6700 04	tsp4 	1794,ic		004564
						STATEMENT 1 ON LINE 339
	if (hmd.minor_state ^= HMD_NORMAL) |		/* multiplexer isn't accepting output at the moment */
	   hmd.suspend_all_output |			/* foreign side has requested to stop all output */
	   ^hmd.output_wabs (hste.device_wab_idx) |	/* this device temporarily shut down */
	   (hste.loopback.first_bufferp ^= null ()) then	/* some loopbacked output is waiting to be sent */
	     go to RETURN_FROM_WRITE_CALL;

001163  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001164  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
001165  aa   000003 1160 07	cmpq 	3,dl
001166  aa   000173 6010 04	tnz  	123,ic		001361
001167  aa  7 00070 2351 00	lda  	pr7|56		hmd.suspend_all_output
001170  aa   400000 3150 03	cana 	131072,du
001171  aa   000170 6010 04	tnz  	120,ic		001361
001172  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
001173  aa  5 00007 7271 00	lxl7 	pr5|7		hste.device_wab_idx
001174  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
001175  aa  7 00067 20 0001	descb	pr7|55(9),1	hmd.output_wabs
001176  aa   000000 00 0000	descb	0,0
001177  aa   000162 6000 04	tze  	114,ic		001361
001200  aa  5 00026 2371 00	ldaq 	pr5|22		hste.first_bufferp
001201  aa   777011 6770 04	eraq 	-503,ic		000212 = 077777000043 000001000000
001202  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001203  aa   000156 6010 04	tnz  	110,ic		001361
						STATEMENT 1 ON LINE 348
	if hste.output.first_bufferp ^= null () then do;

001204  aa  5 00032 2371 00	ldaq 	pr5|26		hste.first_bufferp
001205  aa   777005 6770 04	eraq 	-507,ic		000212 = 077777000043 000001000000
001206  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001207  aa   000015 6000 04	tze  	13,ic		001224
						STATEMENT 1 ON LINE 349
	     hste.output.last_bufferp -> buffer.next = binary (rel (chain_ptr), 18, 0);

001210  aa  6 00102 6351 20	eaa  	pr6|66,*		chain_ptr
001211  aa   000066 7730 00	lrl  	54
001212  aa   000066 7370 00	lls  	54
001213  aa  5 00034 3535 20	epp3 	pr5|28,*		buffer.next
001214  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 350
	     P_chain_ptr,
		chain_ptr = hste.output.first_bufferp;

001215  aa  5 00032 3515 20	epp1 	pr5|26,*		hste.first_bufferp
001216  aa  6 00032 3535 20	epp3 	pr6|26,*
001217  aa  3 00006 2515 20	spri1	pr3|6,*		P_chain_ptr
001220  aa  6 00102 2515 00	spri1	pr6|66		chain_ptr
						STATEMENT 1 ON LINE 352
	     hste.output.first_bufferp, hste.output.last_bufferp = null ();

001221  aa   776771 3734 24	epp7 	-519,ic*
001222  aa  5 00032 6535 00	spri7	pr5|26		hste.first_bufferp
001223  aa  5 00034 6535 00	spri7	pr5|28		hste.last_bufferp
						STATEMENT 1 ON LINE 353
	end;

						STATEMENT 1 ON LINE 358
	partial_record = "0"b;

001224  aa  6 00125 4501 00	stz  	pr6|85		partial_record
						STATEMENT 1 ON LINE 359
	long_record = "0"b;

001225  aa  6 00126 4501 00	stz  	pr6|86		long_record
						STATEMENT 1 ON LINE 362
	if (hste.minor_state = HSTE_NORMAL) |
	   (hste.device_type = HASP_CONSOLE) |
	   ^hmd.rts_mode
	then do;

001226  aa  5 00013 2361 00	ldq  	pr5|11		hste.minor_state
001227  aa   000001 1160 07	cmpq 	1,dl
001230  aa   000010 6000 04	tze  	8,ic		001240
001231  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
001232  aa   000001 1160 07	cmpq 	1,dl
001233  aa   000005 6000 04	tze  	5,ic		001240
001234  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001235  aa  7 00021 2351 00	lda  	pr7|17		hmd.rts_mode
001236  aa   020000 3150 03	cana 	8192,du
001237  aa   000005 6010 04	tnz  	5,ic		001244
						STATEMENT 1 ON LINE 372
	     call process_output_records ();

001240  aa   010733 6700 04	tsp4 	4571,ic		012173
						STATEMENT 1 ON LINE 373
	     if needs_space then go to CANT_FINISH_WRITE_CALL;

001241  aa  6 00124 2351 00	lda  	pr6|84		needs_space
001242  aa   000127 6010 04	tnz  	87,ic		001371
						STATEMENT 1 ON LINE 374
	end;

001243  aa   000027 7100 04	tra  	23,ic		001272
						STATEMENT 1 ON LINE 377
	else if (hste.minor_state = HSTE_SEND_RTS) then

/* Request permission:  the sub-channel has never transmitted any data or has previously transmitted an end-of-file
   record, ask the foreign side for permission to transfer the next file */

	     hmd.send_rts (hste.device_wab_idx) = "1"b;

001244  aa  5 00013 2361 00	ldq  	pr5|11		hste.minor_state
001245  aa   000002 1160 07	cmpq 	2,dl
001246  aa   000005 6010 04	tnz  	5,ic		001253
001247  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
001250  aa   000000 00 0000	descb	0,0
001251  aa  7 00067 40 0001	descb	pr7|55(18),1	hmd.send_rts
001252  aa   000020 7100 04	tra  	16,ic		001272
						STATEMENT 1 ON LINE 385
	else if (hste.minor_state = HSTE_WAIT_RTS_ACK) then
	     if hmd.input.first_bufferp ^= null ()
	     then do;

001253  aa   000003 1160 07	cmpq 	3,dl
001254  aa   000016 6010 04	tnz  	14,ic		001272
001255  aa  7 00042 2371 00	ldaq 	pr7|34		hmd.first_bufferp
001256  aa   776734 6770 04	eraq 	-548,ic		000212 = 077777000043 000001000000
001257  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001260  aa   000012 6000 04	tze  	10,ic		001272
						STATEMENT 1 ON LINE 392
		call process_input_records ();

001261  aa   005463 6700 04	tsp4 	2867,ic		006744
						STATEMENT 1 ON LINE 393
		call interrupt_subchannels_with_input ();

001262  aa   003502 6700 04	tsp4 	1858,ic		004764
						STATEMENT 1 ON LINE 395
		if hste.minor_state = HSTE_NORMAL
		then do;

001263  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
001264  aa  7 00013 2361 00	ldq  	pr7|11		hste.minor_state
001265  aa   000001 1160 07	cmpq 	1,dl
001266  aa   000004 6010 04	tnz  	4,ic		001272
						STATEMENT 1 ON LINE 397
		     call process_output_records ();

001267  aa   010704 6700 04	tsp4 	4548,ic		012173
						STATEMENT 1 ON LINE 398
		     if needs_space then go to CANT_FINISH_WRITE_CALL;

001270  aa  6 00124 2351 00	lda  	pr6|84		needs_space
001271  aa   000100 6010 04	tnz  	64,ic		001371
						STATEMENT 1 ON LINE 399
		end;

						STATEMENT 1 ON LINE 400
	     end;

						STATEMENT 1 ON LINE 410
	if long_record then				/* supplied record will not fit into a block */
	     P_code = et_long_record;

001272  aa  6 00126 2351 00	lda  	pr6|86		long_record
001273  aa   000005 6000 04	tze  	5,ic		001300
001274  aa  6 00044 3701 20	epp4 	pr6|36,*
001275  ia  4 00016 2361 00	ldq  	pr4|14		et_long_record
001276  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
001277  aa   000034 7100 04	tra  	28,ic		001333
						STATEMENT 1 ON LINE 413
	else if partial_record & (chain_ptr ^= null ())
	then do;

001300  aa  6 00125 2351 00	lda  	pr6|85		partial_record
001301  aa   000032 6000 04	tze  	26,ic		001333
001302  aa  6 00102 2371 00	ldaq 	pr6|66		chain_ptr
001303  aa   776707 6770 04	eraq 	-569,ic		000212 = 077777000043 000001000000
001304  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001305  aa   000026 6000 04	tze  	22,ic		001333
						STATEMENT 1 ON LINE 416
	     hste.output.first_bufferp = chain_ptr;

001306  aa  6 00102 3735 20	epp7 	pr6|66,*		chain_ptr
001307  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
001310  aa  5 00032 6535 00	spri7	pr5|26		hste.first_bufferp
						STATEMENT 1 ON LINE 418
   	     do last_bufferp = hste.output.first_bufferp repeat (pointer (ttybp, last_bufferp -> buffer.next))
		     while (rel (last_bufferp) ^= ""b);

001311  aa  5 00032 3535 20	epp3 	pr5|26,*		hste.first_bufferp
001312  aa  6 00132 2535 00	spri3	pr6|90		last_bufferp
001313  aa   000000 0110 03	nop  	0,du
001314  aa  6 00132 6351 20	eaa  	pr6|90,*		last_bufferp
001315  aa   000014 6000 04	tze  	12,ic		001331
						STATEMENT 1 ON LINE 420
		if (last_bufferp -> buffer.next) = 0 then hste.output.last_bufferp = last_bufferp;

001316  aa  6 00132 2351 20	lda  	pr6|90,*		buffer.next
001317  aa   000066 7730 00	lrl  	54
001320  aa  6 01206 7561 00	stq  	pr6|646		buffer.next
001321  aa   000004 6010 04	tnz  	4,ic		001325
001322  aa  6 00132 3735 20	epp7 	pr6|90,*		last_bufferp
001323  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
001324  aa  5 00034 6535 00	spri7	pr5|28		hste.last_bufferp
						STATEMENT 1 ON LINE 421
	     end;

001325  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
001326  aa   000000 3120 06	eawp2	0,ql
001327  aa  6 00132 2521 00	spri2	pr6|90		last_bufferp
001330  aa   777764 7100 04	tra  	-12,ic		001314
						STATEMENT 1 ON LINE 423
	     chain_ptr = null ();

001331  aa   776661 2370 04	ldaq 	-591,ic		000212 = 077777000043 000001000000
001332  aa  6 00102 7571 00	staq 	pr6|66		chain_ptr
						STATEMENT 1 ON LINE 424
	end;

						STATEMENT 1 ON LINE 426
	P_chain_ptr = chain_ptr;

001333  aa  6 00102 3735 20	epp7 	pr6|66,*		chain_ptr
001334  aa  6 00032 3715 20	epp5 	pr6|26,*
001335  aa  5 00006 6535 20	spri7	pr5|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 428
	if chain_ptr = null () then do;

001336  aa  6 00102 2371 00	ldaq 	pr6|66		chain_ptr
001337  aa   776653 6770 04	eraq 	-597,ic		000212 = 077777000043 000001000000
001340  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001341  aa   000020 6010 04	tnz  	16,ic		001361
						STATEMENT 1 ON LINE 429
	     call dequeue_subchannel_for_output ();

001342  aa   003263 6700 04	tsp4 	1715,ic		004625
						STATEMENT 1 ON LINE 430
	     call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);

001343  aa   776645 2370 04	ldaq 	-603,ic		000210 = 000000000000 000000000000
001344  aa  6 01210 7571 00	staq 	pr6|648
001345  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
001346  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
001347  aa  6 01214 2521 00	spri2	pr6|652
001350  aa   776620 3520 04	epp2 	-624,ic		000170 = 000000000004
001351  aa  6 01216 2521 00	spri2	pr6|654
001352  aa  6 01210 3521 00	epp2 	pr6|648
001353  aa  6 01220 2521 00	spri2	pr6|656
001354  aa  6 01212 6211 00	eax1 	pr6|650
001355  aa   014000 4310 07	fld  	6144,dl
001356  aa  6 00044 3701 20	epp4 	pr6|36,*
001357  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
001360  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 431
	end;

						STATEMENT 1 ON LINE 434
RETURN_FROM_WRITE_CALL:
	if (hmd.minor_state = HMD_REPROCESS) then
	     call process_loopback_records ();

001361  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001362  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
001363  aa   000006 1160 07	cmpq 	6,dl
001364  aa   000003 6010 04	tnz  	3,ic		001367
001365  aa   006021 6700 04	tsp4 	3089,ic		007406
001366  aa   000002 7100 04	tra  	2,ic		001370
						STATEMENT 1 ON LINE 437
	else call process_output_block ();

001367  aa   007211 6700 04	tsp4 	3721,ic		010600
						STATEMENT 1 ON LINE 439
	return;

001370  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 444
CANT_FINISH_WRITE_CALL:
	P_chain_ptr = chain_ptr;

001371  aa  6 00102 3735 20	epp7 	pr6|66,*		chain_ptr
001372  aa  6 00032 3715 20	epp5 	pr6|26,*
001373  aa  5 00006 6535 20	spri7	pr5|6,*		P_chain_ptr
						STATEMENT 1 ON LINE 447
	call tty_space_man$needs_space (hmd.devx);

001374  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
001375  aa  3 00010 3521 00	epp2 	pr3|8		hmd.devx
001376  aa  6 01214 2521 00	spri2	pr6|652
001377  aa  6 01212 6211 00	eax1 	pr6|650
001400  aa   004000 4310 07	fld  	2048,dl
001401  aa  6 00044 3701 20	epp4 	pr6|36,*
001402  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$needs_space
001403  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 449
	return;

001404  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO interrupt                                          STATEMENT 1 ON LINE 453
interrupt:
     entry (P_hmd_ptr, P_interrupt_type, P_interrupt_data);

001405  at     000003000177
001406  tt     000175000167
001407  ta     001405000000
001410  da     000404300000
001411  aa   002500 6270 00	eax7 	1344
001412  aa  7 00034 3521 20	epp2 	pr7|28,*
001413  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001414  aa     000006000000
001415  aa     000000000000
						STATEMENT 1 ON LINE 456
	ttybp = addr (tty_buf$);

001416  aa  6 00044 3701 20	epp4 	pr6|36,*
001417  la  4 00026 3735 20	epp7 	pr4|22,*		tty_buf$
001420  aa  6 00122 6535 00	spri7	pr6|82		ttybp
						STATEMENT 1 ON LINE 457
	hmd_ptr = P_hmd_ptr;

001421  aa  6 00032 3715 20	epp5 	pr6|26,*
001422  aa  5 00002 3535 20	epp3 	pr5|2,*		P_hmd_ptr
001423  aa  3 00000 3535 20	epp3 	pr3|0,*		P_hmd_ptr
001424  aa  6 00136 2535 00	spri3	pr6|94		hmd_ptr
						STATEMENT 1 ON LINE 458
	hste_ptr = null ();

001425  aa   776565 2370 04	ldaq 	-651,ic		000212 = 077777000043 000001000000
001426  aa  6 00140 7571 00	staq 	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 459
	interrupt_type = P_interrupt_type;

001427  aa  5 00004 2361 20	ldq  	pr5|4,*		P_interrupt_type
001430  aa  6 00104 7561 00	stq  	pr6|68		interrupt_type
						STATEMENT 1 ON LINE 460
	interrupt_data = P_interrupt_data;

001431  aa  5 00006 3515 20	epp1 	pr5|6,*
001432  aa  1 00000 2351 00	lda  	pr1|0		P_interrupt_data
001433  aa  1 00001 2361 00	ldq  	pr1|1		P_interrupt_data
001434  aa  6 00106 7571 00	staq 	pr6|70		interrupt_data
						STATEMENT 1 ON LINE 462
	if (interrupt_type < lbound (INTERRUPT, 1)) | (interrupt_type > hbound (INTERRUPT, 1)) then
	     return;

001435  aa  6 00104 2361 00	ldq  	pr6|68		interrupt_type
001436  aa   000001 1160 07	cmpq 	1,dl
001437  aa  0 00631 6041 00	tmi  	pr0|409		return_mac
001440  aa   000021 1160 07	cmpq 	17,dl
001441  aa  0 00631 6055 00	tpnz 	pr0|409		return_mac
						STATEMENT 1 ON LINE 465
	go to INTERRUPT (interrupt_type);

001442  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 468
INTERRUPT (1):					/* DIALUP -- major channel has dialed up */
	if hmd.state ^= HMD_LOADING then return;

001443  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001444  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
001445  aa   000002 1160 07	cmpq 	2,dl
001446  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 470
	unspec (hmd.dialup_info) = interrupt_data;

001447  aa  6 00106 2371 00	ldaq 	pr6|70		interrupt_data
001450  aa  7 00026 7551 00	sta  	pr7|22
001451  aa  7 00027 7561 00	stq  	pr7|23
						STATEMENT 1 ON LINE 471
	call do_line_control (SET_HASP_MODE, 0, 0, 0);

001452  aa  6 01206 4501 00	stz  	pr6|646
001453  aa  6 01207 4501 00	stz  	pr6|647
001454  aa  6 01222 4501 00	stz  	pr6|658
001455  aa   014371 3520 04	epp2 	6393,ic		016046 = 000010000000
001456  aa   012277 6700 04	tsp4 	5311,ic		013755
						STATEMENT 1 ON LINE 472
	call do_line_control (CONFIGURE, 3, 0, 0);

001457  aa   000003 2360 07	ldq  	3,dl
001460  aa  6 01222 7561 00	stq  	pr6|658
001461  aa  6 01207 4501 00	stz  	pr6|647
001462  aa  6 01206 4501 00	stz  	pr6|646
001463  aa   014351 3520 04	epp2 	6377,ic		016034 = 000010000000
001464  aa   012271 6700 04	tsp4 	5305,ic		013755
						STATEMENT 1 ON LINE 473
	call do_line_control (SET_MASTER_SLAVE_MODE,	/* indicate if workstation or host */
			  binary ((hmd.type = HASP_WORKSTATION), 17, 0), 0, 0);

001465  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001466  aa  7 00011 2361 00	ldq  	pr7|9		hmd.type
001467  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
001470  aa   000107 7730 00	lrl  	71
001471  aa  6 01206 7561 00	stq  	pr6|646
001472  aa  6 01207 4501 00	stz  	pr6|647
001473  aa  6 01222 4501 00	stz  	pr6|658
001474  aa   014326 3520 04	epp2 	6358,ic		016022 = 000010000000
001475  aa   012260 6700 04	tsp4 	5296,ic		013755
						STATEMENT 1 ON LINE 475
	call do_line_control (SET_HASP_TIMERS, hmd.ic_timeout, hmd.receive_timeout, hmd.transmit_timeout);

001476  aa   776440 3520 04	epp2 	-736,ic		000136 = 000000000016
001477  aa  6 01226 2521 00	spri2	pr6|662
001500  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001501  aa  7 00015 3521 00	epp2 	pr7|13		hmd.ic_timeout
001502  aa  6 01230 2521 00	spri2	pr6|664
001503  aa  7 00016 3521 00	epp2 	pr7|14		hmd.receive_timeout
001504  aa  6 01232 2521 00	spri2	pr6|666
001505  aa  7 00017 3521 00	epp2 	pr7|15		hmd.transmit_timeout
001506  aa  6 01234 2521 00	spri2	pr6|668
001507  aa  6 01224 3521 00	epp2 	pr6|660
001510  aa   020000 4310 07	fld  	8192,dl
001511  aa  2 00000 7571 00	staq 	pr2|0
001512  aa   012243 6700 04	tsp4 	5283,ic		013755
						STATEMENT 1 ON LINE 476
	call do_line_control (SET_NAK_LIMIT, hmd.max_naks, 0, 0);

001513  aa  6 01223 4501 00	stz  	pr6|659
001514  aa  6 01222 4501 00	stz  	pr6|658
001515  aa   776426 3520 04	epp2 	-746,ic		000143 = 000000000015
001516  aa  6 01226 2521 00	spri2	pr6|662
001517  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001520  aa  7 00020 3521 00	epp2 	pr7|16		hmd.max_naks
001521  aa  6 01230 2521 00	spri2	pr6|664
001522  aa  6 01223 3521 00	epp2 	pr6|659
001523  aa  6 01232 2521 00	spri2	pr6|666
001524  aa  6 01222 3521 00	epp2 	pr6|658
001525  aa  6 01234 2521 00	spri2	pr6|668
001526  aa  6 01224 3521 00	epp2 	pr6|660
001527  aa   020000 4310 07	fld  	8192,dl
001530  aa  2 00000 7571 00	staq 	pr2|0
001531  aa   012224 6700 04	tsp4 	5268,ic		013755
						STATEMENT 1 ON LINE 477
	call do_line_control (ACCEPT_BID, 0, 0, 0);

001532  aa  6 01222 4501 00	stz  	pr6|658
001533  aa  6 01223 4501 00	stz  	pr6|659
001534  aa  6 01207 4501 00	stz  	pr6|647
001535  aa   014253 3520 04	epp2 	6315,ic		016010 = 000010000000
001536  aa   012217 6700 04	tsp4 	5263,ic		013755
						STATEMENT 1 ON LINE 478
	call channel_manager$control (hmd.devx, "set_input_message_size", addr (hmd.max_block_size), code);

001537  aa   776505 2370 04	ldaq 	-699,ic		000244 = 163145164137 151156160165
001540  aa  6 01212 7571 00	staq 	pr6|650
001541  aa   776505 2370 04	ldaq 	-699,ic		000246 = 164137155145 163163141147
001542  aa  6 01214 7571 00	staq 	pr6|652
001543  aa   776505 2370 04	ldaq 	-699,ic		000250 = 145137163151 172145000000
001544  aa  6 01216 7571 00	staq 	pr6|654
001545  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001546  aa  7 00012 3735 00	epp7 	pr7|10		hmd.max_block_size
001547  aa  6 01210 6535 00	spri7	pr6|648
001550  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
001551  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
001552  aa  6 01242 2521 00	spri2	pr6|674
001553  aa  6 01212 3521 00	epp2 	pr6|650
001554  aa  6 01244 2521 00	spri2	pr6|676
001555  aa  6 01210 3521 00	epp2 	pr6|648
001556  aa  6 01246 2521 00	spri2	pr6|678
001557  aa  6 00101 3521 00	epp2 	pr6|65		code
001560  aa  6 01250 2521 00	spri2	pr6|680
001561  aa   776414 3520 04	epp2 	-756,ic		000175 = 404000000021
001562  aa  6 01252 2521 00	spri2	pr6|682
001563  aa   776376 3520 04	epp2 	-770,ic		000161 = 524000000026
001564  aa  6 01254 2521 00	spri2	pr6|684
001565  aa   776412 3520 04	epp2 	-758,ic		000177 = 464000000000
001566  aa  6 01256 2521 00	spri2	pr6|686
001567  aa   776404 3520 04	epp2 	-764,ic		000173 = 404000000043
001570  aa  6 01260 2521 00	spri2	pr6|688
001571  aa  6 01240 6211 00	eax1 	pr6|672
001572  aa   020000 4310 07	fld  	8192,dl
001573  aa  6 00044 3701 20	epp4 	pr6|36,*
001574  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
001575  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 480
	return;

001576  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 482
LOADING_FAILS:					/* line control fails--crash or hangup to follow */
	return;

001577  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 486
INTERRUPT (2):					/* HANGUP -- major channel has hungup */
	call crash_mpx ();

001600  aa   001707 6700 04	tsp4 	967,ic		003507
						STATEMENT 1 ON LINE 488
	call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_DOWN, code);

001601  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001602  aa  7 00022 3521 00	epp2 	pr7|18		hmd.loader_process_id
001603  aa  6 01226 2521 00	spri2	pr6|662
001604  aa  7 00024 3521 00	epp2 	pr7|20		hmd.loader_event_channel
001605  aa  6 01230 2521 00	spri2	pr6|664
001606  aa   776320 3520 04	epp2 	-816,ic		000126 = 000000000000
001607  aa  6 01232 2521 00	spri2	pr6|666
001610  aa  6 00101 3521 00	epp2 	pr6|65		code
001611  aa  6 01234 2521 00	spri2	pr6|668
001612  aa  6 01224 6211 00	eax1 	pr6|660
001613  aa   020000 4310 07	fld  	8192,dl
001614  aa  6 00044 3701 20	epp4 	pr6|36,*
001615  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
001616  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 489
	return;

001617  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 492
INTERRUPT (3):					/* CRASH -- parent multiplexer has crashed */
	call crash_mpx ();

001620  aa   001667 6700 04	tsp4 	951,ic		003507
						STATEMENT 1 ON LINE 494
	return;

001621  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 497
INTERRUPT (4):					/* SEND OUTPUT -- parent wants output */
	hmd.send_output = "1"b;

001622  aa   100000 2350 03	lda  	32768,du
001623  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001624  aa  7 00070 2551 00	orsa 	pr7|56		hmd.send_output
						STATEMENT 1 ON LINE 499
	if (hmd.state < HMD_LOADED)
	     then;

001625  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
001626  aa   000003 1160 07	cmpq 	3,dl
001627  aa   000002 6050 04	tpl  	2,ic		001631
001630  aa   000007 7100 04	tra  	7,ic		001637
						STATEMENT 1 ON LINE 501
	else if (hmd.minor_state = HMD_REPROCESS) then
	     call process_loopback_records ();

001631  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
001632  aa   000006 1160 07	cmpq 	6,dl
001633  aa   000003 6010 04	tnz  	3,ic		001636
001634  aa   005552 6700 04	tsp4 	2922,ic		007406
001635  aa   000002 7100 04	tra  	2,ic		001637
						STATEMENT 1 ON LINE 503
	else call process_output_block ();

001636  aa   006742 6700 04	tsp4 	3554,ic		010600
						STATEMENT 1 ON LINE 504
	return;

001637  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 507
INTERRUPT (5):					/* INPUT AVAILABLE -- parent has input */
	hmd.flags.input_available = "1"b;

001640  aa   040000 2350 03	lda  	16384,du
001641  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001642  aa  7 00070 2551 00	orsa 	pr7|56		hmd.input_available
						STATEMENT 1 ON LINE 509
	if (hmd.state < HMD_LOADED)
	     then;

001643  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
001644  aa   000003 1160 07	cmpq 	3,dl
001645  aa   000002 6050 04	tpl  	2,ic		001647
001646  aa   000002 7100 04	tra  	2,ic		001650
						STATEMENT 1 ON LINE 511
	else call interrupt_subchannels_requesting_input ();

001647  aa   003165 6700 04	tsp4 	1653,ic		005034
						STATEMENT 1 ON LINE 512
	return;

001650  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 516
INTERRUPT (6):					/* ACCEPT INPUT -- parent has input */
	hmd.flags.input_available = "0"b;

001651  aa   014135 2350 04	lda  	6237,ic		016006 = 737777777777
001652  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001653  aa  7 00070 3551 00	ansa 	pr7|56		hmd.input_available
						STATEMENT 1 ON LINE 518
	if (hmd.state < HMD_LOADED)
	     then;

001654  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
001655  aa   000003 1160 07	cmpq 	3,dl
001656  aa   000002 6050 04	tpl  	2,ic		001660
001657  aa   000040 7100 04	tra  	32,ic		001717
						STATEMENT 1 ON LINE 520
	else do;

						STATEMENT 1 ON LINE 521
	     unspec (rtx_info) = interrupt_data;

001660  aa  6 00106 2371 00	ldaq 	pr6|70		interrupt_data
001661  aa  6 00160 7571 00	staq 	pr6|112
						STATEMENT 1 ON LINE 522
	     chain_ptr = pointer (ttybp, rtx_info.chain_head);

001662  aa  6 00160 2351 00	lda  	pr6|112		rtx_info.chain_head
001663  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001664  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
001665  aa   000000 3120 01	eawp2	0,au
001666  aa  6 00102 2521 00	spri2	pr6|66		chain_ptr
						STATEMENT 1 ON LINE 523
	     if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
		call trace_block (chain_ptr, INPUT);

001667  aa  7 00021 2351 00	lda  	pr7|17		hmd.trace_mode
001670  aa   040000 3150 03	cana 	16384,du
001671  aa   000003 6000 04	tze  	3,ic		001674
001672  aa   014106 3520 04	epp2 	6214,ic		016000 = 000004000000
001673  aa   013364 6700 04	tsp4 	5876,ic		015257
						STATEMENT 1 ON LINE 525
	     call process_input_block (chain_ptr);

001674  aa   014100 3520 04	epp2 	6208,ic		015774 = 000002000000
001675  aa   003305 6700 04	tsp4 	1733,ic		005202
						STATEMENT 1 ON LINE 526
	     if (hmd.input.first_bufferp ^= null ()) & ^hmd.retry_process_input then
		call process_input_records ();

001676  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001677  aa  7 00042 2371 00	ldaq 	pr7|34		hmd.first_bufferp
001700  aa   776312 6770 04	eraq 	-822,ic		000212 = 077777000043 000001000000
001701  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001702  aa   000005 6000 04	tze  	5,ic		001707
001703  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_process_input
001704  aa   000200 3150 03	cana 	128,du
001705  aa   000002 6010 04	tnz  	2,ic		001707
001706  aa   005036 6700 04	tsp4 	2590,ic		006744
						STATEMENT 1 ON LINE 528
	     call interrupt_subchannels_with_input ();

001707  aa   003055 6700 04	tsp4 	1581,ic		004764
						STATEMENT 1 ON LINE 529
	     if (hmd.minor_state = HMD_REPROCESS) then
		call process_loopback_records ();

001710  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001711  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
001712  aa   000006 1160 07	cmpq 	6,dl
001713  aa   000003 6010 04	tnz  	3,ic		001716
001714  aa   005472 6700 04	tsp4 	2874,ic		007406
001715  aa   000002 7100 04	tra  	2,ic		001717
						STATEMENT 1 ON LINE 531
	     else call process_output_block ();

001716  aa   006662 6700 04	tsp4 	3506,ic		010600
						STATEMENT 1 ON LINE 533
	end;

						STATEMENT 1 ON LINE 534
	return;

001717  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 537
INTERRUPT (7):					/* INPUT REJECTED -- some input rejected by FNP; ignore */
	return;

001720  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 541
INTERRUPT (8):					/* QUIT -- break signal; ignore */
	return;

001721  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 545
INTERRUPT (9):					/* LINE STATUS -- line status from FNP; process */
	unspec (line_stat) = interrupt_data;

001722  aa  6 00106 2371 00	ldaq 	pr6|70		interrupt_data
001723  aa  6 00154 7571 00	staq 	pr6|108
						STATEMENT 1 ON LINE 547
	call process_line_status ();

001724  aa   012104 6700 04	tsp4 	5188,ic		014030
						STATEMENT 1 ON LINE 548
	return;

001725  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 551
INTERRUPT (10):					/* DIAL STATUS -- autocall status; ignore */
	return;

001726  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 555
INTERRUPT (11):					/* WRU TIMEOUT -- timeout waiting for answerback; ignore */
	return;

001727  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 559
INTERRUPT (12):					/* SPACE AVAILABLE	-- some buffer space freed; try again */
	if hmd.state < HMD_LOADED then return;

001730  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001731  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
001732  aa   000003 1160 07	cmpq 	3,dl
001733  aa   000002 6050 04	tpl  	2,ic		001735
001734  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 561
	call process_space_available ();

001735  aa   012412 6700 04	tsp4 	5386,ic		014347
						STATEMENT 1 ON LINE 562
	return;

001736  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 564
INTERRUPT (13):					/* various, not used by this multiplexer */
INTERRUPT (14):
INTERRUPT (15):
INTERRUPT (16):
	return;

001737  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 570
INTERRUPT (17):					/* MASKED -- treat like HANGUP but use different wakeup message */
	call crash_mpx ();

001740  aa   001547 6700 04	tsp4 	871,ic		003507
						STATEMENT 1 ON LINE 572
	call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_MASKED, code);

001741  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
001742  aa  7 00022 3521 00	epp2 	pr7|18		hmd.loader_process_id
001743  aa  6 01226 2521 00	spri2	pr6|662
001744  aa  7 00024 3521 00	epp2 	pr7|20		hmd.loader_event_channel
001745  aa  6 01230 2521 00	spri2	pr6|664
001746  aa   776156 3520 04	epp2 	-914,ic		000124 = 000000000000
001747  aa  6 01232 2521 00	spri2	pr6|666
001750  aa  6 00101 3521 00	epp2 	pr6|65		code
001751  aa  6 01234 2521 00	spri2	pr6|668
001752  aa  6 01224 6211 00	eax1 	pr6|660
001753  aa   020000 4310 07	fld  	8192,dl
001754  aa  6 00044 3701 20	epp4 	pr6|36,*
001755  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
001756  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 573
	return;

001757  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO control                                            STATEMENT 1 ON LINE 578
control:
     entry (P_hmd_ptr, P_subchannel_idx, P_order, P_info_ptr, P_code);

001760  at     000005000177
001761  tt     000175000166
001762  tt     000177000173
001763  ta     001760000000
001764  da     000407300000
001765  aa   002500 6270 00	eax7 	1344
001766  aa  7 00034 3521 20	epp2 	pr7|28,*
001767  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001770  aa     000012000000
001771  aa     000000000000
001772  aa  6 00042 3735 20	epp7 	pr6|34,*
001773  aa  7 00004 2361 20	ldq  	pr7|4,*
001774  aa   000002 6040 04	tmi  	2,ic		001776
001775  aa   777777 3760 07	anq  	262143,dl
001776  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001777  aa  6 01262 7561 00	stq  	pr6|690
002000  aa  6 00032 3715 20	epp5 	pr6|26,*
002001  aa  5 00012 3535 20	epp3 	pr5|10,*
002002  aa  6 00170 2535 00	spri3	pr6|120
						STATEMENT 1 ON LINE 581
	ttybp = addr (tty_buf$);

002003  aa  6 00044 3701 20	epp4 	pr6|36,*
002004  la  4 00026 3735 20	epp7 	pr4|22,*		tty_buf$
002005  aa  6 00122 6535 00	spri7	pr6|82		ttybp
						STATEMENT 1 ON LINE 582
	call setup_subchannel ();

002006  aa   000773 6700 04	tsp4 	507,ic		003001
						STATEMENT 1 ON LINE 583
	order = P_order;

002007  aa  6 00032 3735 20	epp7 	pr6|26,*
002010  aa  7 00006 3715 20	epp5 	pr7|6,*
002011  aa  6 01262 2351 00	lda  	pr6|690
002012  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
002013  aa  5 00000 00 0005	desc9a	pr5|0,al		P_order
002014  aa  6 00110 00 0040	desc9a	pr6|72,32		order
						STATEMENT 1 ON LINE 584
	info_ptr = P_info_ptr;

002015  aa  7 00010 3535 20	epp3 	pr7|8,*		P_info_ptr
002016  aa  3 00000 3535 20	epp3 	pr3|0,*		P_info_ptr
002017  aa  6 00120 2535 00	spri3	pr6|80		info_ptr
						STATEMENT 1 ON LINE 585
	code = 0;

002020  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 587
	if (order = "listen") then			/* listen to this sub-channel */
	     if (hmd.state < HMD_LOADED) then		/* multiplexer must be loaded for this to work */
		code = et_invalid_state;

002021  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002022  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002023  aa   776165 00 0006	desc9a	-907,6		000206 = 154151163164
002024  aa   000045 6010 04	tnz  	37,ic		002071
002025  aa  6 00136 3515 20	epp1 	pr6|94,*		hmd_ptr
002026  aa  1 00030 2361 00	ldq  	pr1|24		hmd.state
002027  aa   000003 1160 07	cmpq 	3,dl
002030  aa   000005 6050 04	tpl  	5,ic		002035
002031  aa  6 00044 3701 20	epp4 	pr6|36,*
002032  ia  4 00014 2361 00	ldq  	pr4|12		et_invalid_state
002033  aa  6 00101 7561 00	stq  	pr6|65		code
002034  aa   000543 7100 04	tra  	355,ic		002577
						STATEMENT 1 ON LINE 590
	     else do;

						STATEMENT 1 ON LINE 591
		if (hste.state < HSTE_LISTENING) then	/* this sub-channel wasn't already listening */
		     hste.state = HSTE_LISTENING;

002035  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
002036  aa  5 00012 2361 00	ldq  	pr5|10		hste.state
002037  aa   000002 1160 07	cmpq 	2,dl
002040  aa   000003 6050 04	tpl  	3,ic		002043
002041  aa   000002 2360 07	ldq  	2,dl
002042  aa  5 00012 7561 00	stq  	pr5|10		hste.state
						STATEMENT 1 ON LINE 593
		if (hmd.minor_state < HMD_NORMAL) then	/* can only dialup the console until SIGNON is sent */
		     if (hste.device_type = HASP_CONSOLE) & (hmd.state = HMD_STARTED) &
		        (hste.state = HSTE_LISTENING) then
			call signal_dialup ();

002043  aa  1 00031 2361 00	ldq  	pr1|25		hmd.minor_state
002044  aa   000003 1160 07	cmpq 	3,dl
002045  aa   000014 6050 04	tpl  	12,ic		002061
002046  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
002047  aa   000001 1160 07	cmpq 	1,dl
002050  aa   000527 6010 04	tnz  	343,ic		002577
002051  aa  1 00030 2361 00	ldq  	pr1|24		hmd.state
002052  aa   000004 1160 07	cmpq 	4,dl
002053  aa   000524 6010 04	tnz  	340,ic		002577
002054  aa  5 00012 2361 00	ldq  	pr5|10		hste.state
002055  aa   000002 1160 07	cmpq 	2,dl
002056  aa   000521 6010 04	tnz  	337,ic		002577
002057  aa   000744 6700 04	tsp4 	484,ic		003023
						STATEMENT 1 ON LINE 597
		     else;

002060  aa   000517 7100 04	tra  	335,ic		002577
						STATEMENT 1 ON LINE 598
		else				/* any channel can dialup now */
		if (hmd.state = HMD_STARTED) & (hste.state = HSTE_LISTENING) then
		     call signal_dialup ();

002061  aa  1 00030 2361 00	ldq  	pr1|24		hmd.state
002062  aa   000004 1160 07	cmpq 	4,dl
002063  aa   000514 6010 04	tnz  	332,ic		002577
002064  aa  5 00012 2361 00	ldq  	pr5|10		hste.state
002065  aa   000002 1160 07	cmpq 	2,dl
002066  aa   000511 6010 04	tnz  	329,ic		002577
002067  aa   000734 6700 04	tsp4 	476,ic		003023
						STATEMENT 1 ON LINE 601
	     end;

002070  aa   000507 7100 04	tra  	327,ic		002577
						STATEMENT 1 ON LINE 603
	else if (order = "hangup") then		/* hangup this sub-channel */
	     call signal_hangup (HANGUP);

002071  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002072  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002073  aa   776113 00 0006	desc9a	-949,6		000204 = 150141156147
002074  aa   000004 6010 04	tnz  	4,ic		002100
002075  aa   013673 3520 04	epp2 	6075,ic		015770 = 000002000000
002076  aa   001113 6700 04	tsp4 	587,ic		003211
002077  aa   000500 7100 04	tra  	320,ic		002577
						STATEMENT 1 ON LINE 606
	else if (order = "wru") then			/* read answerback: none available */
	     call channel_manager$interrupt (hste.devx, WRU_TIMEOUT, ""b);

002100  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002101  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002102  aa   776060 00 0003	desc9a	-976,3		000160 = 167162165000
002103  aa   000020 6010 04	tnz  	16,ic		002123
002104  aa   776104 2370 04	ldaq 	-956,ic		000210 = 000000000000 000000000000
002105  aa  6 01210 7571 00	staq 	pr6|648
002106  aa  6 00140 3515 20	epp1 	pr6|96,*		hste_ptr
002107  aa  1 00005 3521 00	epp2 	pr1|5		hste.devx
002110  aa  6 01214 2521 00	spri2	pr6|652
002111  aa   776027 3520 04	epp2 	-1001,ic		000140 = 000000000013
002112  aa  6 01216 2521 00	spri2	pr6|654
002113  aa  6 01210 3521 00	epp2 	pr6|648
002114  aa  6 01220 2521 00	spri2	pr6|656
002115  aa  6 01212 6211 00	eax1 	pr6|650
002116  aa   014000 4310 07	fld  	6144,dl
002117  aa  6 00044 3701 20	epp4 	pr6|36,*
002120  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
002121  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
002122  aa   000455 7100 04	tra  	301,ic		002577
						STATEMENT 1 ON LINE 609
	else if (order = "abort") then		/* resetwrite and/or resetread */
	     if (info_ptr = null ()) then		/* info structure required */
		code = et_null_info_ptr;

002123  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002124  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002125  aa   776057 00 0005	desc9a	-977,5		000202 = 141142157162
002126  aa   000131 6010 04	tnz  	89,ic		002257
002127  aa  6 00120 2371 00	ldaq 	pr6|80		info_ptr
002130  aa   776062 6770 04	eraq 	-974,ic		000212 = 077777000043 000001000000
002131  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002132  aa   000005 6010 04	tnz  	5,ic		002137
002133  aa  6 00044 3701 20	epp4 	pr6|36,*
002134  ia  4 00020 2361 00	ldq  	pr4|16		et_null_info_ptr
002135  aa  6 00101 7561 00	stq  	pr6|65		code
002136  aa   000441 7100 04	tra  	289,ic		002577
						STATEMENT 1 ON LINE 612
	     else do;

						STATEMENT 1 ON LINE 613
		if abort_info.resetwrite & (hste.direction ^= HSTE_INPUT_ONLY)
		then do;

002137  aa  3 00000 2351 00	lda  	pr3|0		abort_info.resetwrite
002140  aa   400000 3150 03	cana 	131072,du
002141  aa   000046 6000 04	tze  	38,ic		002207
002142  aa  6 00140 3515 20	epp1 	pr6|96,*		hste_ptr
002143  aa  1 00004 2361 00	ldq  	pr1|4		hste.direction
002144  aa   000001 1160 07	cmpq 	1,dl
002145  aa   000042 6000 04	tze  	34,ic		002207
						STATEMENT 1 ON LINE 615
		     if (hste.output.first_bufferp ^= null ()) then do;

002146  aa  1 00032 2371 00	ldaq 	pr1|26		hste.first_bufferp
002147  aa   776043 6770 04	eraq 	-989,ic		000212 = 077777000043 000001000000
002150  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002151  aa   000020 6000 04	tze  	16,ic		002171
						STATEMENT 1 ON LINE 616
			call tty_space_man$free_chain (hste.devx, OUTPUT, hste.output.first_bufferp);

002152  aa  1 00005 3521 00	epp2 	pr1|5		hste.devx
002153  aa  6 01214 2521 00	spri2	pr6|652
002154  aa   776006 3520 04	epp2 	-1018,ic		000162 = 400000000000
002155  aa  6 01216 2521 00	spri2	pr6|654
002156  aa  1 00032 3521 00	epp2 	pr1|26		hste.first_bufferp
002157  aa  6 01220 2521 00	spri2	pr6|656
002160  aa  6 01212 6211 00	eax1 	pr6|650
002161  aa   014000 4310 07	fld  	6144,dl
002162  aa  6 00044 3701 20	epp4 	pr6|36,*
002163  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
002164  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 617
			hste.output.first_bufferp, hste.output.last_bufferp = null ();

002165  aa   776025 3734 24	epp7 	-1003,ic*
002166  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
002167  aa  5 00032 6535 00	spri7	pr5|26		hste.first_bufferp
002170  aa  5 00034 6535 00	spri7	pr5|28		hste.last_bufferp
						STATEMENT 1 ON LINE 618
		     end;

						STATEMENT 1 ON LINE 619
		     call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);

002171  aa   776017 2370 04	ldaq 	-1009,ic		000210 = 000000000000 000000000000
002172  aa  6 01210 7571 00	staq 	pr6|648
002173  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
002174  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
002175  aa  6 01214 2521 00	spri2	pr6|652
002176  aa   775772 3520 04	epp2 	-1030,ic		000170 = 000000000004
002177  aa  6 01216 2521 00	spri2	pr6|654
002200  aa  6 01210 3521 00	epp2 	pr6|648
002201  aa  6 01220 2521 00	spri2	pr6|656
002202  aa  6 01212 6211 00	eax1 	pr6|650
002203  aa   014000 4310 07	fld  	6144,dl
002204  aa  6 00044 3701 20	epp4 	pr6|36,*
002205  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
002206  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 620
		end;

						STATEMENT 1 ON LINE 621
		if abort_info.resetread & (hste.input.first_bufferp ^= null ())
		then do;

002207  aa  6 00120 2351 20	lda  	pr6|80,*		abort_info.resetread
002210  aa   200000 3150 03	cana 	65536,du
002211  aa   000366 6000 04	tze  	246,ic		002577
002212  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
002213  aa  7 00020 2371 00	ldaq 	pr7|16		hste.first_bufferp
002214  aa   775776 6770 04	eraq 	-1026,ic		000212 = 077777000043 000001000000
002215  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002216  aa   000361 6000 04	tze  	241,ic		002577
						STATEMENT 1 ON LINE 623
		     call tty_space_man$free_chain (hste.devx, INPUT, hste.input.first_bufferp);

002217  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
002220  aa  6 01214 2521 00	spri2	pr6|652
002221  aa   775671 3520 04	epp2 	-1095,ic		000112 = 000000000000
002222  aa  6 01216 2521 00	spri2	pr6|654
002223  aa  7 00020 3521 00	epp2 	pr7|16		hste.first_bufferp
002224  aa  6 01220 2521 00	spri2	pr6|656
002225  aa  6 01212 6211 00	eax1 	pr6|650
002226  aa   014000 4310 07	fld  	6144,dl
002227  aa  6 00044 3701 20	epp4 	pr6|36,*
002230  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
002231  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 624
		     hste.input.n_records = 0;

002232  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
002233  aa  7 00016 4501 00	stz  	pr7|14		hste.n_records
						STATEMENT 1 ON LINE 625
		     hste.input.first_bufferp, hste.input.last_bufferp = null ();

002234  aa   775756 3714 24	epp5 	-1042,ic*
002235  aa  7 00020 6515 00	spri5	pr7|16		hste.first_bufferp
002236  aa  7 00022 6515 00	spri5	pr7|18		hste.last_bufferp
						STATEMENT 1 ON LINE 626
		     if ^hmd.input_wabs (hste.device_wab_idx)
		     then do;

002237  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
002240  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
002241  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
002242  aa  3 00067 00 0001	descb	pr3|55,1		hmd.input_wabs
002243  aa   000000 00 0000	descb	0,0
002244  aa   000333 6010 04	tnz  	219,ic		002577
						STATEMENT 1 ON LINE 628
			hmd.input_wabs (hste.device_wab_idx) = "1"b;

002245  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
002246  aa   000000 00 0000	descb	0,0
002247  aa  3 00067 00 0001	descb	pr3|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 629
			if (hmd.minor_state = HMD_REPROCESS) then
			     call process_loopback_records ();

002250  aa  3 00031 2361 00	ldq  	pr3|25		hmd.minor_state
002251  aa   000006 1160 07	cmpq 	6,dl
002252  aa   000003 6010 04	tnz  	3,ic		002255
002253  aa   005133 6700 04	tsp4 	2651,ic		007406
002254  aa   000323 7100 04	tra  	211,ic		002577
						STATEMENT 1 ON LINE 631
			else call process_output_block ();

002255  aa   006323 6700 04	tsp4 	3283,ic		010600
						STATEMENT 1 ON LINE 632
		     end;

						STATEMENT 1 ON LINE 633
		end;

						STATEMENT 1 ON LINE 634
	     end;

002256  aa   000321 7100 04	tra  	209,ic		002577
						STATEMENT 1 ON LINE 636
	else if (order = "write_status") then		/* check if output still pending */
	     if (info_ptr = null ()) then		/* info structure is required */
		code = et_null_info_ptr;

002257  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002260  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002261  aa   775746 00 0014	desc9a	-1050,12		000225 = 167162151164
002262  aa   000023 6010 04	tnz  	19,ic		002305
002263  aa  6 00120 2371 00	ldaq 	pr6|80		info_ptr
002264  aa   775726 6770 04	eraq 	-1066,ic		000212 = 077777000043 000001000000
002265  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002266  aa   000005 6010 04	tnz  	5,ic		002273
002267  aa  6 00044 3701 20	epp4 	pr6|36,*
002270  ia  4 00020 2361 00	ldq  	pr4|16		et_null_info_ptr
002271  aa  6 00101 7561 00	stq  	pr6|65		code
002272  aa   000305 7100 04	tra  	197,ic		002577
						STATEMENT 1 ON LINE 639
	     else if (hste.output.first_bufferp ^= null ()) then
		write_status_info.output_pending = "1"b;

002273  aa  6 00140 3515 20	epp1 	pr6|96,*		hste_ptr
002274  aa  1 00032 2371 00	ldaq 	pr1|26		hste.first_bufferp
002275  aa   775715 6770 04	eraq 	-1075,ic		000212 = 077777000043 000001000000
002276  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002277  aa   000004 6000 04	tze  	4,ic		002303
002300  aa   400000 2350 03	lda  	131072,du
002301  aa  3 00002 7551 00	sta  	pr3|2		write_status_info.output_pending
002302  aa   000275 7100 04	tra  	189,ic		002577
						STATEMENT 1 ON LINE 641
	     else write_status_info.output_pending = "0"b;

002303  aa  3 00002 4501 00	stz  	pr3|2		write_status_info.output_pending
002304  aa   000273 7100 04	tra  	187,ic		002577
						STATEMENT 1 ON LINE 643
	else if (order = "get_device_type") then	/* return type of device attached to this sub-channel */
	     if (info_ptr = null ()) then		/* info structure is required */
		code = et_null_info_ptr;

002305  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002306  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002307  aa   775733 00 0017	desc9a	-1061,15		000240 = 147145164137
002310  aa   000015 6010 04	tnz  	13,ic		002325
002311  aa  6 00120 2371 00	ldaq 	pr6|80		info_ptr
002312  aa   775700 6770 04	eraq 	-1088,ic		000212 = 077777000043 000001000000
002313  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002314  aa   000005 6010 04	tnz  	5,ic		002321
002315  aa  6 00044 3701 20	epp4 	pr6|36,*
002316  ia  4 00020 2361 00	ldq  	pr4|16		et_null_info_ptr
002317  aa  6 00101 7561 00	stq  	pr6|65		code
002320  aa   000257 7100 04	tra  	175,ic		002577
						STATEMENT 1 ON LINE 646
	     else get_device_type_info = hste.device_type;

002321  aa  6 00140 3515 20	epp1 	pr6|96,*		hste_ptr
002322  aa  1 00003 2361 00	ldq  	pr1|3		hste.device_type
002323  aa  3 00000 7561 00	stq  	pr3|0		get_device_type_info
002324  aa   000253 7100 04	tra  	171,ic		002577
						STATEMENT 1 ON LINE 648
	else if (order = "signon_record") then		/* send SIGNON record for multiplexer */
	     if (info_ptr = null ()) then		/* info structure is required */
		code = et_null_info_ptr;

002325  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002326  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002327  aa   775707 00 0015	desc9a	-1081,13		000234 = 163151147156
002330  aa   000122 6010 04	tnz  	82,ic		002452
002331  aa  6 00120 2371 00	ldaq 	pr6|80		info_ptr
002332  aa   775660 6770 04	eraq 	-1104,ic		000212 = 077777000043 000001000000
002333  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002334  aa   000005 6010 04	tnz  	5,ic		002341
002335  aa  6 00044 3701 20	epp4 	pr6|36,*
002336  ia  4 00020 2361 00	ldq  	pr4|16		et_null_info_ptr
002337  aa  6 00101 7561 00	stq  	pr6|65		code
002340  aa   000237 7100 04	tra  	159,ic		002577
						STATEMENT 1 ON LINE 651
	     else if (hmd.type = HASP_WORKSTATION) then	/* workstations only */
		if (hste.device_type ^= HASP_CONSOLE) then
		     code = et_incorrect_device_type;

002341  aa  6 00136 3515 20	epp1 	pr6|94,*		hmd_ptr
002342  aa  1 00011 2361 00	ldq  	pr1|9		hmd.type
002343  aa   000103 6010 04	tnz  	67,ic		002446
002344  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
002345  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
002346  aa   000001 1160 07	cmpq 	1,dl
002347  aa   000005 6000 04	tze  	5,ic		002354
002350  aa  6 00044 3701 20	epp4 	pr6|36,*
002351  ia  4 00012 2361 00	ldq  	pr4|10		et_incorrect_device_type
002352  aa  6 00101 7561 00	stq  	pr6|65		code
002353  aa   000224 7100 04	tra  	148,ic		002577
						STATEMENT 1 ON LINE 654
		else if ^hmd.signon_mode then		/* remote isn't expecting one */
		     code = et_invalid_state;

002354  aa  1 00021 2351 00	lda  	pr1|17		hmd.signon_mode
002355  aa   200000 3150 03	cana 	65536,du
002356  aa   000005 6010 04	tnz  	5,ic		002363
002357  aa  6 00044 3701 20	epp4 	pr6|36,*
002360  ia  4 00014 2361 00	ldq  	pr4|12		et_invalid_state
002361  aa  6 00101 7561 00	stq  	pr6|65		code
002362  aa   000215 7100 04	tra  	141,ic		002577
						STATEMENT 1 ON LINE 656
		else if (hmd.signon_data_ptr = null ()) &    /* if waiting for a SIGNON... */
		        (hmd.minor_state = HMD_SEND_SIGNON) then
		     if (sri.version ^= SIGNON_RECORD_INFO_VERSION_1) then
			code = et_unimplemented_version;

002363  aa  1 00060 2371 00	ldaq 	pr1|48		hmd.signon_data_ptr
002364  aa   775626 6770 04	eraq 	-1130,ic		000212 = 077777000043 000001000000
002365  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002366  aa   000054 6010 04	tnz  	44,ic		002442
002367  aa  1 00031 2361 00	ldq  	pr1|25		hmd.minor_state
002370  aa   000001 1160 07	cmpq 	1,dl
002371  aa   000051 6010 04	tnz  	41,ic		002442
002372  aa  3 00000 2361 00	ldq  	pr3|0		sri.version
002373  aa   000001 1160 07	cmpq 	1,dl
002374  aa   000005 6000 04	tze  	5,ic		002401
002375  aa  6 00044 3701 20	epp4 	pr6|36,*
002376  ia  4 00023 2361 00	ldq  	pr4|19		et_unimplemented_version
002377  aa  6 00101 7561 00	stq  	pr6|65		code
002400  aa   000177 7100 04	tra  	127,ic		002577
						STATEMENT 1 ON LINE 660
		     else do;

						STATEMENT 1 ON LINE 661
			call tty_space_man$get_space (size (hmd_signon_data), hsd_ptr);

002401  aa   000030 2360 07	ldq  	24,dl
002402  aa  6 01207 7561 00	stq  	pr6|647
002403  aa  6 01207 3521 00	epp2 	pr6|647
002404  aa  6 01214 2521 00	spri2	pr6|652
002405  aa  6 00142 3521 00	epp2 	pr6|98		hsd_ptr
002406  aa  6 01216 2521 00	spri2	pr6|654
002407  aa  6 01212 6211 00	eax1 	pr6|650
002410  aa   010000 4310 07	fld  	4096,dl
002411  aa  6 00044 3701 20	epp4 	pr6|36,*
002412  la  4 00104 3521 20	epp2 	pr4|68,*		tty_space_man$get_space
002413  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 662
			if hsd_ptr ^= null ()
			then do;

002414  aa  6 00142 2371 00	ldaq 	pr6|98		hsd_ptr
002415  aa   775575 6770 04	eraq 	-1155,ic		000212 = 077777000043 000001000000
002416  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002417  aa   000017 6000 04	tze  	15,ic		002436
						STATEMENT 1 ON LINE 664
			     hmd.signon_data_ptr = hsd_ptr;

002420  aa  6 00142 3735 20	epp7 	pr6|98,*		hsd_ptr
002421  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
002422  aa  5 00060 6535 00	spri7	pr5|48		hmd.signon_data_ptr
						STATEMENT 1 ON LINE 665
			     hmd_signon_data.processid = pds$process_id;

002423  aa  6 00044 3701 20	epp4 	pr6|36,*
002424  la  4 00024 2351 20	lda  	pr4|20,*		pds$process_id
002425  aa  7 00000 7551 00	sta  	pr7|0		hmd_signon_data.processid
						STATEMENT 1 ON LINE 666
			     hmd_signon_data.event_channel = sri.event_channel;

002426  aa  6 00120 3535 20	epp3 	pr6|80,*		info_ptr
002427  aa  3 00002 2371 00	ldaq 	pr3|2		sri.event_channel
002430  aa  7 00002 7571 00	staq 	pr7|2		hmd_signon_data.event_channel
						STATEMENT 1 ON LINE 667
			     hmd_signon_data.record = sri.record;

002431  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002432  aa  3 00004 00 0120	desc9a	pr3|4,80		sri.record
002433  aa  7 00004 00 0120	desc9a	pr7|4,80		hmd_signon_data.record
						STATEMENT 1 ON LINE 668
			     call process_output_block ();

002434  aa   006144 6700 04	tsp4 	3172,ic		010600
						STATEMENT 1 ON LINE 669
			end;

002435  aa   000142 7100 04	tra  	98,ic		002577
						STATEMENT 1 ON LINE 670
			else code = et_noalloc;

002436  aa  6 00044 3701 20	epp4 	pr6|36,*
002437  ia  4 00017 2361 00	ldq  	pr4|15		et_noalloc
002440  aa  6 00101 7561 00	stq  	pr6|65		code
						STATEMENT 1 ON LINE 671
		     end;

002441  aa   000136 7100 04	tra  	94,ic		002577
						STATEMENT 1 ON LINE 672
		else code = et_out_of_sequence;

002442  aa  6 00044 3701 20	epp4 	pr6|36,*
002443  ia  4 00021 2361 00	ldq  	pr4|17		et_out_of_sequence
002444  aa  6 00101 7561 00	stq  	pr6|65		code
002445  aa   000132 7100 04	tra  	90,ic		002577
						STATEMENT 1 ON LINE 673
	     else code = et_undefined_order_request;

002446  aa  6 00044 3701 20	epp4 	pr6|36,*
002447  ia  4 00022 2361 00	ldq  	pr4|18		et_undefined_order_request
002450  aa  6 00101 7561 00	stq  	pr6|65		code
002451  aa   000126 7100 04	tra  	86,ic		002577
						STATEMENT 1 ON LINE 675
	else if (order = "no_signon_record") then	/* caller wants to verify no SIGNON record is needed */
	     if (hmd.type = HASP_WORKSTATION) then	/* workstations only */
		if hmd.signon_mode then
		     code = et_invalid_state;

002452  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002453  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002454  aa   775556 00 0020	desc9a	-1170,16		000230 = 156157137163
002455  aa   000017 6010 04	tnz  	15,ic		002474
002456  aa  6 00136 3515 20	epp1 	pr6|94,*		hmd_ptr
002457  aa  1 00011 2361 00	ldq  	pr1|9		hmd.type
002460  aa   000010 6010 04	tnz  	8,ic		002470
002461  aa  1 00021 2351 00	lda  	pr1|17		hmd.signon_mode
002462  aa   200000 3150 03	cana 	65536,du
002463  aa   000114 6000 04	tze  	76,ic		002577
002464  aa  6 00044 3701 20	epp4 	pr6|36,*
002465  ia  4 00014 2361 00	ldq  	pr4|12		et_invalid_state
002466  aa  6 00101 7561 00	stq  	pr6|65		code
						STATEMENT 1 ON LINE 679
		else;

002467  aa   000110 7100 04	tra  	72,ic		002577
						STATEMENT 1 ON LINE 680
	     else code = et_undefined_order_request;

002470  aa  6 00044 3701 20	epp4 	pr6|36,*
002471  ia  4 00022 2361 00	ldq  	pr4|18		et_undefined_order_request
002472  aa  6 00101 7561 00	stq  	pr6|65		code
002473  aa   000104 7100 04	tra  	68,ic		002577
						STATEMENT 1 ON LINE 682
	else if (order = "copy_meters") then		/* save current meters for use with -since_dialup */
	     hste.saved_meters_ptr -> hasp_subchannel_meters = hste.meters;

002474  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002475  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002476  aa   775526 00 0013	desc9a	-1194,11		000222 = 143157160171
002477  aa   000007 6010 04	tnz  	7,ic		002506
002500  aa  6 00140 3515 20	epp1 	pr6|96,*		hste_ptr
002501  aa  1 00046 3715 20	epp5 	pr1|38,*		hste.saved_meters_ptr
002502  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002503  aa  1 00037 00 0030	desc9a	pr1|31,24		hste.meters
002504  aa  5 00000 00 0030	desc9a	pr5|0,24		hasp_subchannel_meters
002505  aa   000072 7100 04	tra  	58,ic		002577
						STATEMENT 1 ON LINE 685
	else if (order = "get_meters") then		/* return subchannel metering data */
	     if (info_ptr = null ()) then		/* must have a place to put results */
		code = et_null_info_ptr;

002506  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002507  aa  6 00110 00 0040	desc9a	pr6|72,32		order
002510  aa   775511 00 0012	desc9a	-1207,10		000217 = 147145164137
002511  aa   000063 6010 04	tnz  	51,ic		002574
002512  aa  6 00120 2371 00	ldaq 	pr6|80		info_ptr
002513  aa   775477 6770 04	eraq 	-1217,ic		000212 = 077777000043 000001000000
002514  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002515  aa   000005 6010 04	tnz  	5,ic		002522
002516  aa  6 00044 3701 20	epp4 	pr6|36,*
002517  ia  4 00020 2361 00	ldq  	pr4|16		et_null_info_ptr
002520  aa  6 00101 7561 00	stq  	pr6|65		code
002521  aa   000056 7100 04	tra  	46,ic		002577
						STATEMENT 1 ON LINE 688
	     else if (info_ptr -> get_comm_meters_info.version ^= GET_COMM_METERS_INFO_VERSION_1) then
		code = et_unimplemented_version;

002522  aa  3 00000 2361 00	ldq  	pr3|0		get_comm_meters_info.version
002523  aa   000001 1160 07	cmpq 	1,dl
002524  aa   000005 6000 04	tze  	5,ic		002531
002525  aa  6 00044 3701 20	epp4 	pr6|36,*
002526  ia  4 00023 2361 00	ldq  	pr4|19		et_unimplemented_version
002527  aa  6 00101 7561 00	stq  	pr6|65		code
002530  aa   000047 7100 04	tra  	39,ic		002577
						STATEMENT 1 ON LINE 690
	     else do;

						STATEMENT 1 ON LINE 691
		hsmd_ptr = info_ptr -> get_comm_meters_info.parent_ptr;

002531  aa  3 00006 3515 20	epp1 	pr3|6,*		get_comm_meters_info.parent_ptr
002532  aa  6 00150 2515 00	spri1	pr6|104		hsmd_ptr
						STATEMENT 1 ON LINE 692
		if hsmd_ptr ^= null () then
		     if (hasp_subchannel_meters_data.version ^= HASP_SUBCHANNEL_METERS_DATA_VERSION_1) then
			code = et_unimplemented_version;

002533  aa  6 00150 2371 00	ldaq 	pr6|104		hsmd_ptr
002534  aa   775456 6770 04	eraq 	-1234,ic		000212 = 077777000043 000001000000
002535  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002536  aa   000041 6000 04	tze  	33,ic		002577
002537  aa  1 00000 2361 00	ldq  	pr1|0		hasp_subchannel_meters_data.version
002540  aa   000001 1160 07	cmpq 	1,dl
002541  aa   000005 6000 04	tze  	5,ic		002546
002542  aa  6 00044 3701 20	epp4 	pr6|36,*
002543  ia  4 00023 2361 00	ldq  	pr4|19		et_unimplemented_version
002544  aa  6 00101 7561 00	stq  	pr6|65		code
002545  aa   000032 7100 04	tra  	26,ic		002577
						STATEMENT 1 ON LINE 695
		     else do;

						STATEMENT 1 ON LINE 696
			string (hasp_subchannel_meters_data.flags) = ""b;

002546  aa  1 00001 4501 00	stz  	pr1|1
						STATEMENT 1 ON LINE 697
			hasp_subchannel_meters_data.report_input_meters = (hste.direction ^= HSTE_OUTPUT_ONLY);

002547  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
002550  aa  5 00004 2361 00	ldq  	pr5|4		hste.direction
002551  aa   000002 1160 07	cmpq 	2,dl
002552  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
002553  aa  1 00001 6751 00	era  	pr1|1		hasp_subchannel_meters_data.report_input_meters
002554  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
002555  aa  1 00001 6551 00	ersa 	pr1|1		hasp_subchannel_meters_data.report_input_meters
						STATEMENT 1 ON LINE 698
			hasp_subchannel_meters_data.report_output_meters = (hste.direction ^= HSTE_INPUT_ONLY);

002556  aa   000001 1160 07	cmpq 	1,dl
002557  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
002560  aa   000001 7710 00	arl  	1
002561  aa  1 00001 6751 00	era  	pr1|1		hasp_subchannel_meters_data.report_output_meters
002562  aa   200000 3750 03	ana  	65536,du
002563  aa  1 00001 6551 00	ersa 	pr1|1		hasp_subchannel_meters_data.report_output_meters
						STATEMENT 1 ON LINE 699
			hasp_subchannel_meters_data.current_meters = hste.meters;

002564  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002565  aa  5 00037 00 0030	desc9a	pr5|31,24		hste.meters
002566  aa  1 00002 00 0030	desc9a	pr1|2,24		hasp_subchannel_meters_data.current_meters
						STATEMENT 1 ON LINE 700
			hasp_subchannel_meters_data.saved_meters = hste.saved_meters_ptr -> hasp_subchannel_meters;

002567  aa  5 00046 3535 20	epp3 	pr5|38,*		hste.saved_meters_ptr
002570  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
002571  aa  3 00000 00 0030	desc9a	pr3|0,24		hasp_subchannel_meters
002572  aa  1 00010 00 0030	desc9a	pr1|8,24		hasp_subchannel_meters_data.saved_meters
						STATEMENT 1 ON LINE 701
		     end;

						STATEMENT 1 ON LINE 702
	     end;

002573  aa   000004 7100 04	tra  	4,ic		002577
						STATEMENT 1 ON LINE 704
	else code = et_undefined_order_request;

002574  aa  6 00044 3701 20	epp4 	pr6|36,*
002575  ia  4 00022 2361 00	ldq  	pr4|18		et_undefined_order_request
002576  aa  6 00101 7561 00	stq  	pr6|65		code
						STATEMENT 1 ON LINE 706
	P_code = code;

002577  aa  6 00101 2361 00	ldq  	pr6|65		code
002600  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 707
	return;

002601  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO check_modes                                        STATEMENT 1 ON LINE 711
check_modes:
     entry (P_hmd_ptr, P_subchannel_idx, P_mclp, P_code);

002602  ta     001063000000
002603  da     000415300000
002604  aa   002500 6270 00	eax7 	1344
002605  aa  7 00034 3521 20	epp2 	pr7|28,*
002606  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002607  aa     000010000000
002610  aa     000000000000
002611  aa  6 00032 3735 20	epp7 	pr6|26,*
002612  aa  7 00010 3715 20	epp5 	pr7|8,*
002613  aa  6 00170 6515 00	spri5	pr6|120
						STATEMENT 1 ON LINE 717
set_modes:
     entry (P_hmd_ptr, P_subchannel_idx, P_mclp, P_code);

002614  aa   000013 7100 04	tra  	11,ic		002627
ENTRY TO set_modes                                          STATEMENT 1 ON LINE 717
set_modes:
     entry (P_hmd_ptr, P_subchannel_idx, P_mclp, P_code);

002615  ta     001063000000
002616  da     000423300000
002617  aa   002500 6270 00	eax7 	1344
002620  aa  7 00034 3521 20	epp2 	pr7|28,*
002621  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002622  aa     000010000000
002623  aa     000000000000
002624  aa  6 00032 3735 20	epp7 	pr6|26,*
002625  aa  7 00010 3715 20	epp5 	pr7|8,*
002626  aa  6 00170 6515 00	spri5	pr6|120
						STATEMENT 1 ON LINE 720
	call setup_subchannel ();

002627  aa   000152 6700 04	tsp4 	106,ic		003001
						STATEMENT 1 ON LINE 721
	mclp = P_mclp;

002630  aa  6 00032 3735 20	epp7 	pr6|26,*
002631  aa  7 00006 3715 20	epp5 	pr7|6,*		P_mclp
002632  aa  5 00000 3715 20	epp5 	pr5|0,*		P_mclp
002633  aa  6 00164 6515 00	spri5	pr6|116		mclp
						STATEMENT 1 ON LINE 722
	P_code = 0;

002634  aa  6 00170 4501 20	stz  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 724
	do idx = 1 to mcl.n_entries;

002635  aa  5 00001 2361 00	ldq  	pr5|1		mcl.n_entries
002636  aa  6 00172 7561 00	stq  	pr6|122
002637  aa   000001 2360 07	ldq  	1,dl
002640  aa  6 00134 7561 00	stq  	pr6|92		idx
002641  aa   000000 0110 03	nop  	0,du
002642  aa  6 00134 2361 00	ldq  	pr6|92		idx
002643  aa  6 00172 1161 00	cmpq 	pr6|122
002644  aa   000101 6054 04	tpnz 	65,ic		002745
						STATEMENT 1 ON LINE 726
	     mclep = addr (mcl.entries (idx));

002645  aa   000005 4020 07	mpy  	5,dl
002646  aa  6 00164 3735 20	epp7 	pr6|116,*		mclp
002647  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
002650  aa  6 00166 6535 00	spri7	pr6|118		mclep
						STATEMENT 1 ON LINE 728
	     mcle.mpx_mode = (mcle.mode_name = "rawi") |	/* rawi, rawo, and echoplex only are checked */
			 (mcle.mode_name = "rawo") | (mcle.mode_name = "echoplex");

002651  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002652  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002653  aa   775327 00 0010	desc9a	-1321,8		000200 = 145143150157
002654  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
002655  aa  6 01207 7551 00	sta  	pr6|647
002656  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002657  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002660  aa   775300 00 0004	desc9a	-1344,4		000156 = 162141167157
002661  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
002662  aa  6 01223 7551 00	sta  	pr6|659
002663  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002664  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002665  aa   775274 00 0004	desc9a	-1348,4		000157 = 162141167151
002666  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
002667  aa  6 01222 7551 00	sta  	pr6|658
002670  aa  6 01223 2751 00	ora  	pr6|659
002671  aa  6 01207 2751 00	ora  	pr6|647
002672  aa   000002 7710 00	arl  	2
002673  aa  7 00004 6751 00	era  	pr7|4		mcle.mpx_mode
002674  aa   100000 3750 03	ana  	32768,du
002675  aa  7 00004 6551 00	ersa 	pr7|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 731
	     if mcle.mpx_mode then			/* process this mode */

		if ((mcle.mode_name ^= "rawi") & (mcle.mode_name ^= "rawo") & (mcle.mode_name ^= "echoplex")) |
		   ((mcle.mode_name = "rawi") & ^mcle.mode_switch) |
		   ((mcle.mode_name = "rawo") & ^mcle.mode_switch) |
		   ((mcle.mode_name = "echoplex") & mcle.mode_switch)
		then do;

002676  aa  7 00004 2351 00	lda  	pr7|4		mcle.mpx_mode
002677  aa   100000 3150 03	cana 	32768,du
002700  aa   000043 6000 04	tze  	35,ic		002743
002701  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
002702  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
002703  aa  6 01206 7551 00	sta  	pr6|646		mcle.mode_switch
002704  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
002705  aa  6 01263 7551 00	sta  	pr6|691
002706  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002707  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002710  aa   775251 00 0004	desc9a	-1367,4		000157 = 162141167151
002711  aa   000011 6000 04	tze  	9,ic		002722
002712  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002713  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002714  aa   775244 00 0004	desc9a	-1372,4		000156 = 162141167157
002715  aa   000005 6000 04	tze  	5,ic		002722
002716  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002717  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
002720  aa   775262 00 0010	desc9a	-1358,8		000200 = 145143150157
002721  aa   000015 6010 04	tnz  	13,ic		002736
002722  aa  6 01263 2351 00	lda  	pr6|691
002723  aa   000003 6000 04	tze  	3,ic		002726
002724  aa  6 01222 2351 00	lda  	pr6|658
002725  aa   000011 6010 04	tnz  	9,ic		002736
002726  aa  6 01263 2351 00	lda  	pr6|691
002727  aa   000003 6000 04	tze  	3,ic		002732
002730  aa  6 01223 2351 00	lda  	pr6|659
002731  aa   000005 6010 04	tnz  	5,ic		002736
002732  aa  6 01207 2351 00	lda  	pr6|647
002733  aa   000010 6000 04	tze  	8,ic		002743
002734  aa  6 01206 2351 00	lda  	pr6|646		mcle.mode_switch
002735  aa   000006 6000 04	tze  	6,ic		002743
						STATEMENT 1 ON LINE 738
		     mcle.error = "1"b;

002736  aa   040000 2350 03	lda  	16384,du
002737  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 739
		     P_code = et_bad_mode;

002740  aa  6 00044 3701 20	epp4 	pr6|36,*
002741  ia  4 00011 2361 00	ldq  	pr4|9		et_bad_mode
002742  aa  6 00170 7561 20	stq  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 740
		end;

						STATEMENT 1 ON LINE 741
	end;

002743  aa  6 00134 0541 00	aos  	pr6|92		idx
002744  aa   777676 7100 04	tra  	-66,ic		002642
						STATEMENT 1 ON LINE 743
	return;

002745  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_modes                                          STATEMENT 1 ON LINE 749
get_modes:
     entry (P_hmd_ptr, P_subchannel_idx, P_modes, P_code);

002746  at     000004000177
002747  tt     000175000166
002750  ta     000173000000
002751  ta     002746000000
002752  da     000431300000
002753  aa   002500 6270 00	eax7 	1344
002754  aa  7 00034 3521 20	epp2 	pr7|28,*
002755  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
002756  aa     000010000000
002757  aa     000000000000
002760  aa  6 00042 3735 20	epp7 	pr6|34,*
002761  aa  7 00004 2361 20	ldq  	pr7|4,*
002762  aa   000002 6040 04	tmi  	2,ic		002764
002763  aa   777777 3760 07	anq  	262143,dl
002764  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002765  aa  6 01262 7561 00	stq  	pr6|690
002766  aa  6 00032 3715 20	epp5 	pr6|26,*
002767  aa  5 00010 3535 20	epp3 	pr5|8,*
002770  aa  6 00170 2535 00	spri3	pr6|120
						STATEMENT 1 ON LINE 752
	P_modes = "";

002771  aa  6 00032 3735 20	epp7 	pr6|26,*
002772  aa  7 00006 3715 20	epp5 	pr7|6,*
002773  aa  6 01262 2351 00	lda  	pr6|690
002774  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
002775  aa   000000 00 0000	desc9a	0,0
002776  aa  5 00000 00 0005	desc9a	pr5|0,al		P_modes
						STATEMENT 1 ON LINE 753
	P_code = 0;

002777  aa  6 00170 4501 20	stz  	pr6|120,*		P_code
						STATEMENT 1 ON LINE 755
	return;

003000  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 3953
     end hasp_mpx;

BEGIN PROCEDURE setup_subchannel
ENTRY TO setup_subchannel                                   STATEMENT 1 ON LINE 759
setup_subchannel:
	procedure ();

003001  aa  6 00174 6501 00	spri4	pr6|124
						STATEMENT 1 ON LINE 762
	     hmd_ptr = P_hmd_ptr;

003002  aa  6 00032 3735 20	epp7 	pr6|26,*
003003  aa  7 00002 3715 20	epp5 	pr7|2,*		P_hmd_ptr
003004  aa  5 00000 3715 20	epp5 	pr5|0,*		P_hmd_ptr
003005  aa  6 00136 6515 00	spri5	pr6|94		hmd_ptr
						STATEMENT 1 ON LINE 764
	     if hmd.state < HMD_LOADED then do;

003006  aa  5 00030 2361 00	ldq  	pr5|24		hmd.state
003007  aa   000003 1160 07	cmpq 	3,dl
003010  aa   000005 6050 04	tpl  	5,ic		003015
						STATEMENT 1 ON LINE 765
		code = et_action_not_performed;

003011  aa  6 00044 3701 20	epp4 	pr6|36,*
003012  ia  4 00010 2361 00	ldq  	pr4|8		et_action_not_performed
003013  aa  6 00101 7561 00	stq  	pr6|65		code
						STATEMENT 1 ON LINE 766
		go to ERROR_RETURN;

003014  aa   775663 7100 04	tra  	-1101,ic		000677
						STATEMENT 1 ON LINE 767
	     end;

						STATEMENT 1 ON LINE 769
	     subchannel_idx = P_subchannel_idx;

003015  aa  7 00004 2361 20	ldq  	pr7|4,*		P_subchannel_idx
003016  aa  6 00100 7561 00	stq  	pr6|64		subchannel_idx
						STATEMENT 1 ON LINE 770
	     hste_ptr = addr (hmd.subchannels (subchannel_idx));

003017  aa   000050 4020 07	mpy  	40,dl
003020  aa  5 00044 3535 06	epp3 	pr5|36,ql		hmd.subchannels
003021  aa  6 00140 2535 00	spri3	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 772
	     return;

003022  aa  6 00174 6101 00	rtcd 	pr6|124
						STATEMENT 1 ON LINE 774
	end setup_subchannel;

  END PROCEDURE setup_subchannel
BEGIN PROCEDURE signal_dialup
ENTRY TO signal_dialup                                      STATEMENT 1 ON LINE 782
signal_dialup:
	procedure ();

003023  aa  6 00202 6501 00	spri4	pr6|130
						STATEMENT 1 ON LINE 787
	     if (hmd.minor_state_stack = null ()) & (hste.loopback.first_bufferp = null ()) then
						/* no loopbacked records available: this subchannel can't be
						   retransmitting any records so it's minor state should be
						   reset.  If it were retransmitting, that process controls
						   the minor state */
		if hmd.rts_mode & (hste.device_type ^= HASP_CONSOLE) & (hste.direction ^= HSTE_INPUT_ONLY) then
		     hste.minor_state = HSTE_SEND_RTS;

003024  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003025  aa  7 00062 2371 00	ldaq 	pr7|50		hmd.minor_state_stack
003026  aa   775164 6770 04	eraq 	-1420,ic		000212 = 077777000043 000001000000
003027  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003030  aa   000024 6010 04	tnz  	20,ic		003054
003031  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
003032  aa  5 00026 2371 00	ldaq 	pr5|22		hste.first_bufferp
003033  aa   775157 6770 04	eraq 	-1425,ic		000212 = 077777000043 000001000000
003034  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003035  aa   000017 6010 04	tnz  	15,ic		003054
003036  aa  7 00021 2351 00	lda  	pr7|17		hmd.rts_mode
003037  aa   020000 3150 03	cana 	8192,du
003040  aa   000012 6000 04	tze  	10,ic		003052
003041  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
003042  aa   000001 1160 07	cmpq 	1,dl
003043  aa   000007 6000 04	tze  	7,ic		003052
003044  aa  5 00004 2361 00	ldq  	pr5|4		hste.direction
003045  aa   000001 1160 07	cmpq 	1,dl
003046  aa   000004 6000 04	tze  	4,ic		003052
003047  aa   000002 2360 07	ldq  	2,dl
003050  aa  5 00013 7561 00	stq  	pr5|11		hste.minor_state
003051  aa   000003 7100 04	tra  	3,ic		003054
						STATEMENT 1 ON LINE 794
		else hste.minor_state = HSTE_NORMAL;

003052  aa   000001 2360 07	ldq  	1,dl
003053  aa  5 00013 7561 00	stq  	pr5|11		hste.minor_state
						STATEMENT 1 ON LINE 796
	     hste.next_subchannel_for_output = 0;

003054  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
003055  aa  5 00014 4501 00	stz  	pr5|12		hste.next_subchannel_for_output
						STATEMENT 1 ON LINE 798
	     hste.output.first_bufferp, hste.output.last_bufferp = null ();

003056  aa   775134 3534 24	epp3 	-1444,ic*
003057  aa  5 00032 2535 00	spri3	pr5|26		hste.first_bufferp
003060  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
003061  aa  5 00034 2535 00	spri3	pr5|28		hste.last_bufferp
						STATEMENT 1 ON LINE 800
	     saved_input_available = hste.flags.input_available;

003062  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
003063  aa  5 00036 2351 00	lda  	pr5|30		hste.input_available
003064  aa   000001 7350 00	als  	1
003065  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003066  aa  6 00210 7551 00	sta  	pr6|136		saved_input_available
						STATEMENT 1 ON LINE 801
	     string (hste.flags) = ""b;

003067  aa  5 00036 4501 00	stz  	pr5|30
						STATEMENT 1 ON LINE 802
	     hste.flags.input_available = saved_input_available;

003070  aa   000001 7730 00	lrl  	1
003071  aa  5 00036 6751 00	era  	pr5|30		hste.input_available
003072  aa   200000 3750 03	ana  	65536,du
003073  aa  5 00036 6551 00	ersa 	pr5|30		hste.input_available
						STATEMENT 1 ON LINE 804
	     if (hste.direction = HSTE_INPUT_ONLY) | (hste.direction = HSTE_INPUT_OUTPUT)
	     then do;

003074  aa  5 00004 2361 00	ldq  	pr5|4		hste.direction
003075  aa   000001 1160 07	cmpq 	1,dl
003076  aa   000003 6000 04	tze  	3,ic		003101
003077  aa  5 00004 2361 00	ldq  	pr5|4		hste.direction
003100  aa   000011 6010 04	tnz  	9,ic		003111
						STATEMENT 1 ON LINE 806
		hmd.input_wabs (hste.device_wab_idx) = "1"b;

003101  aa  5 00007 7271 00	lxl7 	pr5|7		hste.device_wab_idx
003102  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
003103  aa   000000 00 0000	descb	0,0
003104  aa  7 00067 00 0001	descb	pr7|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 807
		hmd.send_rts_ack (hste.device_wab_idx) = "0"b;

003105  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
003106  aa   000000 00 0000	descb	0,0
003107  aa  7 00067 60 0001	descb	pr7|55(27),1	hmd.send_rts_ack
						STATEMENT 1 ON LINE 809
	     end;

003110  aa   000005 7100 04	tra  	5,ic		003115
						STATEMENT 1 ON LINE 810
	     else hmd.send_rts (hste.device_wab_idx) = "0"b;

003111  aa  5 00007 7271 00	lxl7 	pr5|7		hste.device_wab_idx
003112  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
003113  aa   000000 00 0000	descb	0,0
003114  aa  7 00067 40 0001	descb	pr7|55(18),1	hmd.send_rts
						STATEMENT 1 ON LINE 812
	     hste.dialup_info = hmd.dialup_info;

003115  aa  7 00026 2371 00	ldaq 	pr7|22		hmd.dialup_info
003116  aa  5 00010 7551 00	sta  	pr5|8		hste.dialup_info
003117  aa  5 00011 7561 00	stq  	pr5|9		hste.dialup_info
						STATEMENT 1 ON LINE 814
	     hste.state = HSTE_DIALED;

003120  aa   000003 2360 07	ldq  	3,dl
003121  aa  5 00012 7561 00	stq  	pr5|10		hste.state
						STATEMENT 1 ON LINE 816
	     call channel_manager$interrupt (hste.devx, DIALUP, unspec (hste.dialup_info));

003122  aa  5 00010 2351 00	lda  	pr5|8
003123  aa  5 00011 2361 00	ldq  	pr5|9
003124  aa  6 01264 7571 00	staq 	pr6|692
003125  aa  5 00005 3521 00	epp2 	pr5|5		hste.devx
003126  aa  6 01270 2521 00	spri2	pr6|696
003127  aa   775047 3520 04	epp2 	-1497,ic		000176 = 000000000001
003130  aa  6 01272 2521 00	spri2	pr6|698
003131  aa  6 01264 3521 00	epp2 	pr6|692
003132  aa  6 01274 2521 00	spri2	pr6|700
003133  aa  6 01266 6211 00	eax1 	pr6|694
003134  aa   014000 4310 07	fld  	6144,dl
003135  aa  6 00044 3701 20	epp4 	pr6|36,*
003136  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
003137  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 818
	     if (hste.direction ^= HSTE_INPUT_ONLY) then	/* authorize first output */
		call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);

003140  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003141  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
003142  aa   000001 1160 07	cmpq 	1,dl
003143  aa   000016 6000 04	tze  	14,ic		003161
003144  aa   775044 2370 04	ldaq 	-1500,ic		000210 = 000000000000 000000000000
003145  aa  6 01264 7571 00	staq 	pr6|692
003146  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
003147  aa  6 01270 2521 00	spri2	pr6|696
003150  aa   775020 3520 04	epp2 	-1520,ic		000170 = 000000000004
003151  aa  6 01272 2521 00	spri2	pr6|698
003152  aa  6 01264 3521 00	epp2 	pr6|692
003153  aa  6 01274 2521 00	spri2	pr6|700
003154  aa  6 01266 6211 00	eax1 	pr6|694
003155  aa   014000 4310 07	fld  	6144,dl
003156  aa  6 00044 3701 20	epp4 	pr6|36,*
003157  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
003160  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 821
	     if (hste.direction ^= HSTE_OUTPUT_ONLY) then
		if hste.flags.input_available then do;

003161  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003162  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
003163  aa   000002 1160 07	cmpq 	2,dl
003164  aa   000024 6000 04	tze  	20,ic		003210
003165  aa  7 00036 2351 00	lda  	pr7|30		hste.input_available
003166  aa   200000 3150 03	cana 	65536,du
003167  aa   000021 6000 04	tze  	17,ic		003210
						STATEMENT 1 ON LINE 823
		     call channel_manager$interrupt (hste.devx, INPUT_AVAILABLE, ""b);

003170  aa   775020 2370 04	ldaq 	-1520,ic		000210 = 000000000000 000000000000
003171  aa  6 01264 7571 00	staq 	pr6|692
003172  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
003173  aa  6 01270 2521 00	spri2	pr6|696
003174  aa   774770 3520 04	epp2 	-1544,ic		000164 = 000000000005
003175  aa  6 01272 2521 00	spri2	pr6|698
003176  aa  6 01264 3521 00	epp2 	pr6|692
003177  aa  6 01274 2521 00	spri2	pr6|700
003200  aa  6 01266 6211 00	eax1 	pr6|694
003201  aa   014000 4310 07	fld  	6144,dl
003202  aa  6 00044 3701 20	epp4 	pr6|36,*
003203  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
003204  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 824
		     hste.flags.input_available = "0"b;

003205  aa   012561 2350 04	lda  	5489,ic		015766 = 577777777777
003206  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003207  aa  7 00036 3551 00	ansa 	pr7|30		hste.input_available
						STATEMENT 1 ON LINE 825
		end;

						STATEMENT 1 ON LINE 827
	     return;

003210  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 829
	end signal_dialup;

  END PROCEDURE signal_dialup
BEGIN PROCEDURE signal_hangup
ENTRY TO signal_hangup                                      STATEMENT 1 ON LINE 833
signal_hangup:
	procedure (P_interrupt_type);

003211  aa  6 00212 6501 00	spri4	pr6|138
003212  aa  6 00214 2521 00	spri2	pr6|140
						STATEMENT 1 ON LINE 838
	     hste.state = HSTE_HUNGUP;

003213  aa   000001 2360 07	ldq  	1,dl
003214  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003215  aa  7 00012 7561 00	stq  	pr7|10		hste.state
						STATEMENT 1 ON LINE 840
	     if hste.input.first_bufferp ^= null () then	/* throw away any held input */
		call tty_space_man$free_chain (hste.devx, INPUT, hste.input.first_bufferp);

003216  aa  7 00020 2371 00	ldaq 	pr7|16		hste.first_bufferp
003217  aa   774773 6770 04	eraq 	-1541,ic		000212 = 077777000043 000001000000
003220  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003221  aa   000014 6000 04	tze  	12,ic		003235
003222  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
003223  aa  6 01300 2521 00	spri2	pr6|704
003224  aa   774666 3520 04	epp2 	-1610,ic		000112 = 000000000000
003225  aa  6 01302 2521 00	spri2	pr6|706
003226  aa  7 00020 3521 00	epp2 	pr7|16		hste.first_bufferp
003227  aa  6 01304 2521 00	spri2	pr6|708
003230  aa  6 01276 6211 00	eax1 	pr6|702
003231  aa   014000 4310 07	fld  	6144,dl
003232  aa  6 00044 3701 20	epp4 	pr6|36,*
003233  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003234  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 843
	     if hste.output.first_bufferp ^= null () then
		call tty_space_man$free_chain (hste.devx, OUTPUT, hste.output.first_bufferp);

003235  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003236  aa  7 00032 2371 00	ldaq 	pr7|26		hste.first_bufferp
003237  aa   774753 6770 04	eraq 	-1557,ic		000212 = 077777000043 000001000000
003240  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003241  aa   000014 6000 04	tze  	12,ic		003255
003242  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
003243  aa  6 01300 2521 00	spri2	pr6|704
003244  aa   774716 3520 04	epp2 	-1586,ic		000162 = 400000000000
003245  aa  6 01302 2521 00	spri2	pr6|706
003246  aa  7 00032 3521 00	epp2 	pr7|26		hste.first_bufferp
003247  aa  6 01304 2521 00	spri2	pr6|708
003250  aa  6 01276 6211 00	eax1 	pr6|702
003251  aa   014000 4310 07	fld  	6144,dl
003252  aa  6 00044 3701 20	epp4 	pr6|36,*
003253  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003254  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 846
	     call dequeue_subchannel_for_output ();

003255  aa   001350 6700 04	tsp4 	744,ic		004625
						STATEMENT 1 ON LINE 848
	     hste.input.n_records = 0;

003256  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003257  aa  7 00016 4501 00	stz  	pr7|14		hste.n_records
						STATEMENT 1 ON LINE 850
	     hste.input.first_bufferp, hste.input.last_bufferp,
		hste.output.first_bufferp, hste.output.last_bufferp = null ();

003260  aa   774732 3714 24	epp5 	-1574,ic*
003261  aa  7 00020 6515 00	spri5	pr7|16		hste.first_bufferp
003262  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003263  aa  7 00022 6515 00	spri5	pr7|18		hste.last_bufferp
003264  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003265  aa  7 00032 6515 00	spri5	pr7|26		hste.first_bufferp
003266  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003267  aa  7 00034 6515 00	spri5	pr7|28		hste.last_bufferp
						STATEMENT 1 ON LINE 853
	     string (hste.flags) = ""b;

003270  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
003271  aa  7 00036 4501 00	stz  	pr7|30
						STATEMENT 1 ON LINE 855
	     if (hste.direction = HSTE_INPUT_ONLY) | (hste.direction = HSTE_INPUT_OUTPUT)
	     then do;

003272  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
003273  aa   000001 1160 07	cmpq 	1,dl
003274  aa   000003 6000 04	tze  	3,ic		003277
003275  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
003276  aa   000012 6010 04	tnz  	10,ic		003310
						STATEMENT 1 ON LINE 857
		hmd.input_wabs (hste.device_wab_idx) = "0"b;

003277  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
003300  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
003301  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
003302  aa   000000 00 0000	descb	0,0
003303  aa  3 00067 00 0001	descb	pr3|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 858
		hmd.send_rts_ack (hste.device_wab_idx) = "0"b;

003304  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
003305  aa   000000 00 0000	descb	0,0
003306  aa  3 00067 60 0001	descb	pr3|55(27),1	hmd.send_rts_ack
						STATEMENT 1 ON LINE 859
	     end;

003307  aa   000006 7100 04	tra  	6,ic		003315
						STATEMENT 1 ON LINE 860
	     else hmd.send_rts (hste.device_wab_idx) = "0"b;

003310  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
003311  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
003312  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
003313  aa   000000 00 0000	descb	0,0
003314  aa  3 00067 40 0001	descb	pr3|55(18),1	hmd.send_rts
						STATEMENT 1 ON LINE 862
	     call channel_manager$interrupt (hste.devx, P_interrupt_type, ""b);

003315  aa   774673 2370 04	ldaq 	-1605,ic		000210 = 000000000000 000000000000
003316  aa  6 01306 7571 00	staq 	pr6|710
003317  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
003320  aa  6 01300 2521 00	spri2	pr6|704
003321  aa  6 00214 3515 20	epp1 	pr6|140,*
003322  aa  1 00002 3521 20	epp2 	pr1|2,*		P_interrupt_type
003323  aa  6 01302 2521 00	spri2	pr6|706
003324  aa  6 01306 3521 00	epp2 	pr6|710
003325  aa  6 01304 2521 00	spri2	pr6|708
003326  aa  6 01276 6211 00	eax1 	pr6|702
003327  aa   014000 4310 07	fld  	6144,dl
003330  aa  6 00044 3701 20	epp4 	pr6|36,*
003331  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
003332  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 864
	     return;

003333  aa  6 00212 6101 00	rtcd 	pr6|138
						STATEMENT 1 ON LINE 866
	end signal_hangup;

  END PROCEDURE signal_hangup
BEGIN PROCEDURE load_mpx
ENTRY TO load_mpx                                           STATEMENT 1 ON LINE 871
load_mpx: procedure ();

003334  aa  6 00220 6501 00	spri4	pr6|144
						STATEMENT 1 ON LINE 876
	     hmd.state = HMD_LOADED;

003335  aa   000003 2360 07	ldq  	3,dl
003336  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003337  aa  7 00030 7561 00	stq  	pr7|24		hmd.state
						STATEMENT 1 ON LINE 878
	     hmd.time_mpx_booted = clock ();

003340  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
003341  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003342  aa  7 00072 7571 00	staq 	pr7|58		hmd.time_mpx_booted
						STATEMENT 1 ON LINE 880
	     if (hmd.type = HASP_WORKSTATION) & hmd.signon_mode then
		hmd.minor_state = HMD_SEND_SIGNON;

003343  aa  7 00011 2361 00	ldq  	pr7|9		hmd.type
003344  aa   000007 6010 04	tnz  	7,ic		003353
003345  aa  7 00021 2351 00	lda  	pr7|17		hmd.signon_mode
003346  aa   200000 3150 03	cana 	65536,du
003347  aa   000004 6000 04	tze  	4,ic		003353
003350  aa   000001 2360 07	ldq  	1,dl
003351  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
003352  aa   000003 7100 04	tra  	3,ic		003355
						STATEMENT 1 ON LINE 882
	     else hmd.minor_state = HMD_NORMAL;

003353  aa   000003 2360 07	ldq  	3,dl
003354  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
						STATEMENT 1 ON LINE 884
	     saved_send_output = hmd.send_output;

003355  aa  7 00070 2351 00	lda  	pr7|56		hmd.send_output
003356  aa   000002 7350 00	als  	2
003357  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003360  aa  6 00226 7551 00	sta  	pr6|150		saved_send_output
						STATEMENT 1 ON LINE 885
	     saved_input_available = hmd.flags.input_available;

003361  aa  7 00070 2351 00	lda  	pr7|56		hmd.input_available
003362  aa   000003 7350 00	als  	3
003363  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
003364  aa  6 00227 7551 00	sta  	pr6|151		saved_input_available
						STATEMENT 1 ON LINE 887
	     string (hmd.flags) = ""b;

003365  aa  7 00070 4501 00	stz  	pr7|56
						STATEMENT 1 ON LINE 889
	     hmd.send_output = saved_send_output;

003366  aa  6 00226 2351 00	lda  	pr6|150		saved_send_output
003367  aa   000002 7710 00	arl  	2
003370  aa  7 00070 6751 00	era  	pr7|56		hmd.send_output
003371  aa   100000 3750 03	ana  	32768,du
003372  aa  7 00070 6551 00	ersa 	pr7|56		hmd.send_output
						STATEMENT 1 ON LINE 890
	     hmd.flags.input_available = saved_input_available;

003373  aa  6 00227 2351 00	lda  	pr6|151		saved_input_available
003374  aa   000003 7710 00	arl  	3
003375  aa  7 00070 6751 00	era  	pr7|56		hmd.input_available
003376  aa   040000 3750 03	ana  	16384,du
003377  aa  7 00070 6551 00	ersa 	pr7|56		hmd.input_available
						STATEMENT 1 ON LINE 892
	     hmd.suspend_all_output = "1"b;

003400  aa   400000 2350 03	lda  	131072,du
003401  aa  7 00070 2551 00	orsa 	pr7|56		hmd.suspend_all_output
						STATEMENT 1 ON LINE 893
	     hmd.first_foreign_block = "1"b;

003402  aa   010000 2350 03	lda  	4096,du
003403  aa  7 00070 2551 00	orsa 	pr7|56		hmd.first_foreign_block
						STATEMENT 1 ON LINE 894
	     unspec (hmd.foreign_fcs_bytes) = "700600"b3;

003404  aa   700600 2350 03	lda  	229760,du
003405  aa  7 00033 5511 60	stba 	pr7|27,60
						STATEMENT 1 ON LINE 896
	     hmd.suspend_all_input = "1"b;

003406  aa   200000 2350 03	lda  	65536,du
003407  aa  7 00070 2551 00	orsa 	pr7|56		hmd.suspend_all_input
						STATEMENT 1 ON LINE 897
	     hmd.reset_local_block_count = "1"b;

003410  aa   004000 2350 03	lda  	2048,du
003411  aa  7 00070 2551 00	orsa 	pr7|56		hmd.reset_local_block_count
						STATEMENT 1 ON LINE 898
	     unspec (hmd.local_fcs_bytes) = "700600"b3;

003412  aa   700600 2350 03	lda  	229760,du
003413  aa  7 00035 5511 60	stba 	pr7|29,60
						STATEMENT 1 ON LINE 900
	     string (hmd.input_wabs) = ""b;

003414  aa   012351 2350 04	lda  	5353,ic		015765 = 000777777777
003415  aa  7 00067 3551 00	ansa 	pr7|55
						STATEMENT 1 ON LINE 901
	     string (hmd.output_wabs) = ""b;

003416  aa   012346 2350 04	lda  	5350,ic		015764 = 777000777777
003417  aa  7 00067 3551 00	ansa 	pr7|55
						STATEMENT 1 ON LINE 902
	     string (hmd.send_rts) = ""b;

003420  aa   012343 2350 04	lda  	5347,ic		015763 = 777777000777
003421  aa  7 00067 3551 00	ansa 	pr7|55
						STATEMENT 1 ON LINE 903
	     string (hmd.send_rts_ack) = ""b;

003422  aa   012340 2350 04	lda  	5344,ic		015762 = 777777777000
003423  aa  7 00067 3551 00	ansa 	pr7|55
						STATEMENT 1 ON LINE 905
	     hmd.minor_state_stack,			/* these stacks are empty as loopback is not preserved ... */
		hmd.loopback_block_chain_stack = null ();

003424  aa   774566 3714 24	epp5 	-1674,ic*
003425  aa  7 00062 6515 00	spri5	pr7|50		hmd.minor_state_stack
003426  aa  7 00064 6515 00	spri5	pr7|52		hmd.loopback_block_chain_stack
						STATEMENT 1 ON LINE 908
	     hmd.output_chain_ptr, hmd.signon_data_ptr,
		hmd.input.first_bufferp, hmd.input.last_bufferp,
		hmd.loopback.first_bufferp, hmd.loopback.last_bufferp,
		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();

003427  aa   774563 3534 24	epp3 	-1677,ic*
003430  aa  7 00040 2535 00	spri3	pr7|32		hmd.output_chain_ptr
003431  aa  7 00060 2535 00	spri3	pr7|48		hmd.signon_data_ptr
003432  aa  7 00042 2535 00	spri3	pr7|34		hmd.first_bufferp
003433  aa  7 00044 2535 00	spri3	pr7|36		hmd.last_bufferp
003434  aa  7 00046 2535 00	spri3	pr7|38		hmd.first_bufferp
003435  aa  7 00050 2535 00	spri3	pr7|40		hmd.last_bufferp
003436  aa  7 00054 2535 00	spri3	pr7|44		hmd.first_bufferp
003437  aa  7 00056 2535 00	spri3	pr7|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 913
	     hmd.output_block.subchannel_idx, hmd.output_block.tally = 0;

003440  aa  7 00052 4501 00	stz  	pr7|42		hmd.subchannel_idx
003441  aa  7 00053 4501 00	stz  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 915
	     do idx = 1 to hmd.n_subchannels;

003442  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
003443  aa  6 00231 7561 00	stq  	pr6|153
003444  aa   000001 2360 07	ldq  	1,dl
003445  aa  6 00230 7561 00	stq  	pr6|152		idx
003446  aa  6 00230 2361 00	ldq  	pr6|152		idx
003447  aa  6 00231 1161 00	cmpq 	pr6|153
003450  aa   000020 6054 04	tpnz 	16,ic		003470
						STATEMENT 1 ON LINE 916
		hmd.subchannels(idx).state = HSTE_HUNGUP;

003451  aa   000050 4020 07	mpy  	40,dl
003452  aa   000000 6270 06	eax7 	0,ql
003453  aa   000001 2360 07	ldq  	1,dl
003454  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003455  aa  7 00056 7561 17	stq  	pr7|46,7		hmd.state
						STATEMENT 1 ON LINE 917
		hmd.subchannels(idx).input.n_records = 0;

003456  aa  7 00062 4501 17	stz  	pr7|50,7		hmd.n_records
						STATEMENT 1 ON LINE 918
		hmd.subchannels(idx).input.first_bufferp,    /* ... before dialup however */
		     hmd.subchannels(idx).input.last_bufferp = null ();

003457  aa   774533 3714 24	epp5 	-1701,ic*
003460  aa  7 00064 6515 17	spri5	pr7|52,7		hmd.first_bufferp
003461  aa  7 00066 6515 17	spri5	pr7|54,7		hmd.last_bufferp
						STATEMENT 1 ON LINE 920
		hmd.subchannels(idx).loopback.n_records = 0;

003462  aa  7 00070 4501 17	stz  	pr7|56,7		hmd.n_records
						STATEMENT 1 ON LINE 921
		hmd.subchannels(idx).loopback.first_bufferp, hmd.subchannels(idx).loopback.last_bufferp = null ();

003463  aa   774527 3534 24	epp3 	-1705,ic*
003464  aa  7 00072 2535 17	spri3	pr7|58,7		hmd.first_bufferp
003465  aa  7 00074 2535 17	spri3	pr7|60,7		hmd.last_bufferp
						STATEMENT 1 ON LINE 922
	     end;

003466  aa  6 00230 0541 00	aos  	pr6|152		idx
003467  aa   777757 7100 04	tra  	-17,ic		003446
						STATEMENT 1 ON LINE 924
	     call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_UP, code);

003470  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003471  aa  7 00022 3521 00	epp2 	pr7|18		hmd.loader_process_id
003472  aa  6 01316 2521 00	spri2	pr6|718
003473  aa  7 00024 3521 00	epp2 	pr7|20		hmd.loader_event_channel
003474  aa  6 01320 2521 00	spri2	pr6|720
003475  aa   774433 3520 04	epp2 	-1765,ic		000130 = 000000000000
003476  aa  6 01322 2521 00	spri2	pr6|722
003477  aa  6 00101 3521 00	epp2 	pr6|65		code
003500  aa  6 01324 2521 00	spri2	pr6|724
003501  aa  6 01314 6211 00	eax1 	pr6|716
003502  aa   020000 4310 07	fld  	8192,dl
003503  aa  6 00044 3701 20	epp4 	pr6|36,*
003504  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
003505  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 926
	     return;

003506  aa  6 00220 6101 00	rtcd 	pr6|144
						STATEMENT 1 ON LINE 928
	end load_mpx;

  END PROCEDURE load_mpx
BEGIN PROCEDURE crash_mpx
ENTRY TO crash_mpx                                          STATEMENT 1 ON LINE 932
crash_mpx:
	procedure ();

003507  aa  6 00232 6501 00	spri4	pr6|154
						STATEMENT 1 ON LINE 938
	     old_state = hmd.state;

003510  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003511  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
003512  aa  6 00240 7561 00	stq  	pr6|160		old_state
						STATEMENT 1 ON LINE 940
	     hmd.state = HMD_DOWN;

003513  aa   000001 2360 07	ldq  	1,dl
003514  aa  7 00030 7561 00	stq  	pr7|24		hmd.state
						STATEMENT 1 ON LINE 942
	     if old_state < HMD_LOADED then		/* wasn't loaded:  couldn't be doing anything */
		return;

003515  aa  6 00240 2361 00	ldq  	pr6|160		old_state
003516  aa   000003 1160 07	cmpq 	3,dl
003517  aa   000002 6050 04	tpl  	2,ic		003521
003520  aa  6 00232 6101 00	rtcd 	pr6|154
						STATEMENT 1 ON LINE 945
	     if (hmd.minor_state = HMD_SEND_SIGNON) | (hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE)
	     then do;

003521  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
003522  aa   000001 1160 07	cmpq 	1,dl
003523  aa   000003 6000 04	tze  	3,ic		003526
003524  aa   000002 1160 07	cmpq 	2,dl
003525  aa   000024 6010 04	tnz  	20,ic		003551
						STATEMENT 1 ON LINE 947
		hsd_ptr = hmd.signon_data_ptr;

003526  aa  7 00060 3715 20	epp5 	pr7|48,*		hmd.signon_data_ptr
003527  aa  6 00142 6515 00	spri5	pr6|98		hsd_ptr
						STATEMENT 1 ON LINE 948
		if hsd_ptr ^= null () then		/* ... insure there's someone listening */
		     call pxss$ring_0_wakeup (hmd_signon_data.processid, hmd_signon_data.event_channel,
				          HASP_SIGNON_HANGUP, code);

003530  aa  6 00142 2371 00	ldaq 	pr6|98		hsd_ptr
003531  aa   774461 6770 04	eraq 	-1743,ic		000212 = 077777000043 000001000000
003532  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003533  aa   000016 6000 04	tze  	14,ic		003551
003534  aa  5 00000 3521 00	epp2 	pr5|0		hmd_signon_data.processid
003535  aa  6 01330 2521 00	spri2	pr6|728
003536  aa  5 00002 3521 00	epp2 	pr5|2		hmd_signon_data.event_channel
003537  aa  6 01332 2521 00	spri2	pr6|730
003540  aa   774352 3520 04	epp2 	-1814,ic		000112 = 000000000000
003541  aa  6 01334 2521 00	spri2	pr6|732
003542  aa  6 00101 3521 00	epp2 	pr6|65		code
003543  aa  6 01336 2521 00	spri2	pr6|734
003544  aa  6 01326 6211 00	eax1 	pr6|726
003545  aa   020000 4310 07	fld  	8192,dl
003546  aa  6 00044 3701 20	epp4 	pr6|36,*
003547  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
003550  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 951
	     end;

						STATEMENT 1 ON LINE 953
	     if hmd.output_chain_ptr ^= null () then	/* free up all unused data */
		call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_chain_ptr);

003551  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003552  aa  7 00040 2371 00	ldaq 	pr7|32		hmd.output_chain_ptr
003553  aa   774437 6770 04	eraq 	-1761,ic		000212 = 077777000043 000001000000
003554  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003555  aa   000014 6000 04	tze  	12,ic		003571
003556  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
003557  aa  6 01330 2521 00	spri2	pr6|728
003560  aa   774402 3520 04	epp2 	-1790,ic		000162 = 400000000000
003561  aa  6 01332 2521 00	spri2	pr6|730
003562  aa  7 00040 3521 00	epp2 	pr7|32		hmd.output_chain_ptr
003563  aa  6 01334 2521 00	spri2	pr6|732
003564  aa  6 01326 6211 00	eax1 	pr6|726
003565  aa   014000 4310 07	fld  	6144,dl
003566  aa  6 00044 3701 20	epp4 	pr6|36,*
003567  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003570  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 956
	     if hmd.input.first_bufferp ^= null () then
		call tty_space_man$free_chain (hmd.devx, INPUT, hmd.input.first_bufferp);

003571  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003572  aa  7 00042 2371 00	ldaq 	pr7|34		hmd.first_bufferp
003573  aa   774417 6770 04	eraq 	-1777,ic		000212 = 077777000043 000001000000
003574  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003575  aa   000014 6000 04	tze  	12,ic		003611
003576  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
003577  aa  6 01330 2521 00	spri2	pr6|728
003600  aa   774312 3520 04	epp2 	-1846,ic		000112 = 000000000000
003601  aa  6 01332 2521 00	spri2	pr6|730
003602  aa  7 00042 3521 00	epp2 	pr7|34		hmd.first_bufferp
003603  aa  6 01334 2521 00	spri2	pr6|732
003604  aa  6 01326 6211 00	eax1 	pr6|726
003605  aa   014000 4310 07	fld  	6144,dl
003606  aa  6 00044 3701 20	epp4 	pr6|36,*
003607  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003610  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 959
	     if hmd.loopback.first_bufferp ^= null () then
		call tty_space_man$free_chain (hmd.devx, INPUT, hmd.loopback.first_bufferp);

003611  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003612  aa  7 00046 2371 00	ldaq 	pr7|38		hmd.first_bufferp
003613  aa   774377 6770 04	eraq 	-1793,ic		000212 = 077777000043 000001000000
003614  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003615  aa   000014 6000 04	tze  	12,ic		003631
003616  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
003617  aa  6 01330 2521 00	spri2	pr6|728
003620  aa   774272 3520 04	epp2 	-1862,ic		000112 = 000000000000
003621  aa  6 01332 2521 00	spri2	pr6|730
003622  aa  7 00046 3521 00	epp2 	pr7|38		hmd.first_bufferp
003623  aa  6 01334 2521 00	spri2	pr6|732
003624  aa  6 01326 6211 00	eax1 	pr6|726
003625  aa   014000 4310 07	fld  	6144,dl
003626  aa  6 00044 3701 20	epp4 	pr6|36,*
003627  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003630  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 962
	     if hmd.output_block.first_bufferp ^= null () then
		call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);

003631  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003632  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
003633  aa   774357 6770 04	eraq 	-1809,ic		000212 = 077777000043 000001000000
003634  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003635  aa   000014 6000 04	tze  	12,ic		003651
003636  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
003637  aa  6 01330 2521 00	spri2	pr6|728
003640  aa   774322 3520 04	epp2 	-1838,ic		000162 = 400000000000
003641  aa  6 01332 2521 00	spri2	pr6|730
003642  aa  7 00054 3521 00	epp2 	pr7|44		hmd.first_bufferp
003643  aa  6 01334 2521 00	spri2	pr6|732
003644  aa  6 01326 6211 00	eax1 	pr6|726
003645  aa   014000 4310 07	fld  	6144,dl
003646  aa  6 00044 3701 20	epp4 	pr6|36,*
003647  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
003650  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 965
	     if hmd.signon_data_ptr ^= null () then
		call tty_space_man$free_space (currentsize (hmd.signon_data_ptr -> hmd_signon_data),
					 hmd.signon_data_ptr);

003651  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003652  aa  7 00060 2371 00	ldaq 	pr7|48		hmd.signon_data_ptr
003653  aa   774337 6770 04	eraq 	-1825,ic		000212 = 077777000043 000001000000
003654  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003655  aa   000014 6000 04	tze  	12,ic		003671
003656  aa   000030 2360 07	ldq  	24,dl
003657  aa  6 01340 7561 00	stq  	pr6|736
003660  aa  6 01340 3521 00	epp2 	pr6|736
003661  aa  6 01330 2521 00	spri2	pr6|728
003662  aa  7 00060 3521 00	epp2 	pr7|48		hmd.signon_data_ptr
003663  aa  6 01332 2521 00	spri2	pr6|730
003664  aa  6 01326 6211 00	eax1 	pr6|726
003665  aa   010000 4310 07	fld  	4096,dl
003666  aa  6 00044 3701 20	epp4 	pr6|36,*
003667  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
003670  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 969
	     call empty_minor_state_stack ();

003671  aa   000322 6700 04	tsp4 	210,ic		004213
						STATEMENT 1 ON LINE 970
	     call empty_loopback_block_chain_stack ();

003672  aa   000614 6700 04	tsp4 	396,ic		004506
						STATEMENT 1 ON LINE 972
	     hmd.output_chain_ptr, hmd.signon_data_ptr,
		hmd.input.first_bufferp, hmd.input.last_bufferp,
		hmd.loopback.first_bufferp, hmd.loopback.last_bufferp,
		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();

003673  aa   774317 3734 24	epp7 	-1841,ic*
003674  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
003675  aa  5 00040 6535 00	spri7	pr5|32		hmd.output_chain_ptr
003676  aa  5 00060 6535 00	spri7	pr5|48		hmd.signon_data_ptr
003677  aa  5 00042 6535 00	spri7	pr5|34		hmd.first_bufferp
003700  aa  5 00044 6535 00	spri7	pr5|36		hmd.last_bufferp
003701  aa  5 00046 6535 00	spri7	pr5|38		hmd.first_bufferp
003702  aa  5 00050 6535 00	spri7	pr5|40		hmd.last_bufferp
003703  aa  5 00054 6535 00	spri7	pr5|44		hmd.first_bufferp
003704  aa  5 00056 6535 00	spri7	pr5|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 977
	     hmd.output_block.subchannel_idx, hmd.output_block.tally = 0;

003705  aa  5 00052 4501 00	stz  	pr5|42		hmd.subchannel_idx
003706  aa  5 00053 4501 00	stz  	pr5|43		hmd.tally
						STATEMENT 1 ON LINE 979
	     hmd.subchannels_for_output = 0;

003707  aa  5 00036 4501 00	stz  	pr5|30		hmd.first
003710  aa  5 00037 4501 00	stz  	pr5|31		hmd.last
						STATEMENT 1 ON LINE 981
	     string (hmd.flags) = ""b;

003711  aa  5 00070 4501 00	stz  	pr5|56
						STATEMENT 1 ON LINE 983
	     do idx = 1 to hmd.n_subchannels;

003712  aa  5 00113 2361 00	ldq  	pr5|75		hmd.n_subchannels
003713  aa  6 00242 7561 00	stq  	pr6|162
003714  aa   000001 2360 07	ldq  	1,dl
003715  aa  6 00241 7561 00	stq  	pr6|161		idx
003716  aa  6 00241 2361 00	ldq  	pr6|161		idx
003717  aa  6 00242 1161 00	cmpq 	pr6|162
003720  aa   000011 6054 04	tpnz 	9,ic		003731
						STATEMENT 1 ON LINE 984
		hste_ptr = addr (hmd.subchannels (idx));

003721  aa   000050 4020 07	mpy  	40,dl
003722  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003723  aa  7 00044 3735 06	epp7 	pr7|36,ql		hmd.subchannels
003724  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 985
		call signal_hangup (CRASH);

003725  aa   012031 3520 04	epp2 	5145,ic		015756 = 000002000000
003726  aa   777263 6700 04	tsp4 	-333,ic		003211
						STATEMENT 1 ON LINE 986
	     end;

003727  aa  6 00241 0541 00	aos  	pr6|161		idx
003730  aa   777766 7100 04	tra  	-10,ic		003716
						STATEMENT 1 ON LINE 988
	     return;

003731  aa  6 00232 6101 00	rtcd 	pr6|154
						STATEMENT 1 ON LINE 990
	end crash_mpx;

  END PROCEDURE crash_mpx
BEGIN PROCEDURE minor_state_stack_manager
ENTRY TO minor_state_stack_manager                          STATEMENT 1 ON LINE 997
minor_state_stack_manager:
	procedure ();

003732  aa  6 00244 6501 00	spri4	pr6|164
						STATEMENT 1 ON LINE 1000
	     return;

003733  aa  6 00244 6101 00	rtcd 	pr6|164
ENTRY TO push_minor_state                                   STATEMENT 1 ON LINE 1013
push_minor_state:
	entry (P_new_minor_state);

003734  aa  6 00244 6501 00	spri4	pr6|164
003735  aa  6 00246 2521 00	spri2	pr6|166
						STATEMENT 1 ON LINE 1016
	     call tty_space_man$get_space (size (msse), msse_ptr);

003736  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
003737  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
003740  aa   000006 4020 07	mpy  	6,dl
003741  aa   000004 0760 07	adq  	4,dl
003742  aa  6 01344 7561 00	stq  	pr6|740
003743  aa  6 01344 3521 00	epp2 	pr6|740
003744  aa  6 01350 2521 00	spri2	pr6|744
003745  aa  6 00144 3521 00	epp2 	pr6|100		msse_ptr
003746  aa  6 01352 2521 00	spri2	pr6|746
003747  aa  6 01346 6211 00	eax1 	pr6|742
003750  aa   010000 4310 07	fld  	4096,dl
003751  aa  6 00044 3701 20	epp4 	pr6|36,*
003752  la  4 00104 3521 20	epp2 	pr4|68,*		tty_space_man$get_space
003753  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1017
		if msse_ptr = null () then do;

003754  aa  6 00144 2371 00	ldaq 	pr6|100		msse_ptr
003755  aa   774235 6770 04	eraq 	-1891,ic		000212 = 077777000043 000001000000
003756  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003757  aa   000060 6010 04	tnz  	48,ic		004037
						STATEMENT 1 ON LINE 1018
		     call syserr (LOG_AND_PRINT,
			        "hasp_mpx (line ^a): No space available to preserve minor state; line will be hungup.",
			        hmd.name);

003760  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003761  aa   774435 00 0124	desc9a	-1763,84		000415 = 150141163160
003762  aa  6 01354 00 0124	desc9a	pr6|748,84
003763  aa   774200 3520 04	epp2 	-1920,ic		000163 = 000000000000
003764  aa  6 01404 2521 00	spri2	pr6|772
003765  aa  6 01354 3521 00	epp2 	pr6|748
003766  aa  6 01406 2521 00	spri2	pr6|774
003767  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
003770  aa  6 01410 2521 00	spri2	pr6|776
003771  aa   774204 3520 04	epp2 	-1916,ic		000175 = 404000000021
003772  aa  6 01412 2521 00	spri2	pr6|778
003773  aa   774162 3520 04	epp2 	-1934,ic		000155 = 524000000124
003774  aa  6 01414 2521 00	spri2	pr6|780
003775  aa   774157 3520 04	epp2 	-1937,ic		000154 = 526000000040
003776  aa  6 01416 2521 00	spri2	pr6|782
003777  aa  6 01402 6211 00	eax1 	pr6|770
004000  aa   014000 4310 07	fld  	6144,dl
004001  aa  6 00044 3701 20	epp4 	pr6|36,*
004002  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
004003  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1021
		     call channel_manager$control (hmd.devx, "hangup", null (), code);

004004  aa   774200 2370 04	ldaq 	-1920,ic		000204 = 150141156147 165160000000
004005  aa  6 01420 7571 00	staq 	pr6|784
004006  aa   774204 3734 24	epp7 	-1916,ic*
004007  aa  6 01422 6535 00	spri7	pr6|786
004010  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004011  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
004012  aa  6 01356 2521 00	spri2	pr6|750
004013  aa  6 01420 3521 00	epp2 	pr6|784
004014  aa  6 01360 2521 00	spri2	pr6|752
004015  aa  6 01422 3521 00	epp2 	pr6|786
004016  aa  6 01362 2521 00	spri2	pr6|754
004017  aa  6 00101 3521 00	epp2 	pr6|65		code
004020  aa  6 01364 2521 00	spri2	pr6|756
004021  aa   774154 3520 04	epp2 	-1940,ic		000175 = 404000000021
004022  aa  6 01366 2521 00	spri2	pr6|758
004023  aa   774130 3520 04	epp2 	-1960,ic		000153 = 524000000006
004024  aa  6 01370 2521 00	spri2	pr6|760
004025  aa   774152 3520 04	epp2 	-1942,ic		000177 = 464000000000
004026  aa  6 01372 2521 00	spri2	pr6|762
004027  aa   774144 3520 04	epp2 	-1948,ic		000173 = 404000000043
004030  aa  6 01374 2521 00	spri2	pr6|764
004031  aa  6 01354 6211 00	eax1 	pr6|748
004032  aa   020000 4310 07	fld  	8192,dl
004033  aa  6 00044 3701 20	epp4 	pr6|36,*
004034  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
004035  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1022
		     return;

004036  aa  6 00244 6101 00	rtcd 	pr6|164
						STATEMENT 1 ON LINE 1023
		end;

						STATEMENT 1 ON LINE 1025
	     do idx = 1 to hmd.n_subchannels;

004037  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004040  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
004041  aa  6 00255 7561 00	stq  	pr6|173
004042  aa   000001 2360 07	ldq  	1,dl
004043  aa  6 00254 7561 00	stq  	pr6|172		idx
004044  aa  6 00254 2361 00	ldq  	pr6|172		idx
004045  aa  6 00255 1161 00	cmpq 	pr6|173
004046  aa   000024 6054 04	tpnz 	20,ic		004072
						STATEMENT 1 ON LINE 1026
		msse.subchannels(idx).loopback = hmd.subchannels(idx).loopback;

004047  aa   000006 4020 07	mpy  	6,dl
004050  aa   000000 6270 06	eax7 	0,ql
004051  aa  6 00254 2361 00	ldq  	pr6|172		idx
004052  aa   000050 4020 07	mpy  	40,dl
004053  aa   000000 6260 06	eax6 	0,ql
004054  aa  6 00144 3735 20	epp7 	pr6|100,*		msse_ptr
004055  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004056  aa  5 00070 2371 16	ldaq 	pr5|56,6		hmd.loopback
004057  aa  7 77776 7571 17	staq 	pr7|-2,7		msse.loopback
004060  aa  5 00072 2371 16	ldaq 	pr5|58,6		hmd.loopback
004061  aa  7 00000 7571 17	staq 	pr7|0,7		msse.loopback
004062  aa  5 00074 2371 16	ldaq 	pr5|60,6		hmd.loopback
004063  aa  7 00002 7571 17	staq 	pr7|2,7		msse.loopback
						STATEMENT 1 ON LINE 1027
		hmd.subchannels(idx).loopback.n_records = 0;

004064  aa  5 00070 4501 16	stz  	pr5|56,6		hmd.n_records
						STATEMENT 1 ON LINE 1028
		hmd.subchannels(idx).loopback.first_bufferp, hmd.subchannels(idx).loopback.last_bufferp = null ();

004065  aa   774125 3534 24	epp3 	-1963,ic*
004066  aa  5 00072 2535 16	spri3	pr5|58,6		hmd.first_bufferp
004067  aa  5 00074 2535 16	spri3	pr5|60,6		hmd.last_bufferp
						STATEMENT 1 ON LINE 1029
	     end;

004070  aa  6 00254 0541 00	aos  	pr6|172		idx
004071  aa   777753 7100 04	tra  	-21,ic		004044
						STATEMENT 1 ON LINE 1031
	     msse.minor_state = hmd.minor_state;

004072  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004073  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
004074  aa  6 00144 3715 20	epp5 	pr6|100,*		msse_ptr
004075  aa  5 00002 7561 00	stq  	pr5|2		msse.minor_state
						STATEMENT 1 ON LINE 1032
	     hmd.minor_state = P_new_minor_state;

004076  aa  6 00246 3535 20	epp3 	pr6|166,*
004077  aa  3 00002 2361 20	ldq  	pr3|2,*		P_new_minor_state
004100  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
						STATEMENT 1 ON LINE 1034
	     msse.previous = hmd.minor_state_stack;

004101  aa  7 00062 3515 20	epp1 	pr7|50,*		hmd.minor_state_stack
004102  aa  5 00000 2515 00	spri1	pr5|0		msse.previous
						STATEMENT 1 ON LINE 1035
	     hmd.minor_state_stack = msse_ptr;

004103  aa  6 00144 3715 20	epp5 	pr6|100,*		msse_ptr
004104  aa  7 00062 6515 00	spri5	pr7|50		hmd.minor_state_stack
						STATEMENT 1 ON LINE 1037
	     return;

004105  aa  6 00244 6101 00	rtcd 	pr6|164
ENTRY TO pop_minor_state                                    STATEMENT 1 ON LINE 1042
pop_minor_state:
	entry ();

004106  aa  6 00244 6501 00	spri4	pr6|164
						STATEMENT 1 ON LINE 1045
	     if hmd.minor_state_stack = null () then	/* shouldn't happen */
		return;

004107  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004110  aa  7 00062 2371 00	ldaq 	pr7|50		hmd.minor_state_stack
004111  aa   774101 6770 04	eraq 	-1983,ic		000212 = 077777000043 000001000000
004112  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004113  aa   000002 6010 04	tnz  	2,ic		004115
004114  aa  6 00244 6101 00	rtcd 	pr6|164
						STATEMENT 1 ON LINE 1048
	     msse_ptr = hmd.minor_state_stack;

004115  aa  7 00062 3715 20	epp5 	pr7|50,*		hmd.minor_state_stack
004116  aa  6 00144 6515 00	spri5	pr6|100		msse_ptr
						STATEMENT 1 ON LINE 1050
	     do idx = 1 to hmd.n_subchannels;

004117  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
004120  aa  6 00256 7561 00	stq  	pr6|174
004121  aa   000001 2360 07	ldq  	1,dl
004122  aa  6 00254 7561 00	stq  	pr6|172		idx
004123  aa   000000 0110 03	nop  	0,du
004124  aa  6 00254 2361 00	ldq  	pr6|172		idx
004125  aa  6 00256 1161 00	cmpq 	pr6|174
004126  aa   000041 6054 04	tpnz 	33,ic		004167
						STATEMENT 1 ON LINE 1051
		if msse.subchannels(idx).loopback.first_bufferp ^= null () then do;

004127  aa   000006 4020 07	mpy  	6,dl
004130  aa  6 01344 7561 00	stq  	pr6|740
004131  aa  6 00144 2371 66	ldaq 	pr6|100,*ql	msse.first_bufferp
004132  aa   774060 6770 04	eraq 	-2000,ic		000212 = 077777000043 000001000000
004133  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004134  aa   000031 6000 04	tze  	25,ic		004165
						STATEMENT 1 ON LINE 1052
		     hmd.subchannels(idx).loopback.n_records =
			hmd.subchannels(idx).loopback.n_records + msse.subchannels(idx).loopback.n_records;

004135  aa  6 00254 2361 00	ldq  	pr6|172		idx
004136  aa   000050 4020 07	mpy  	40,dl
004137  aa  6 01344 7271 00	lxl7 	pr6|740
004140  aa  6 00144 3735 20	epp7 	pr6|100,*		msse_ptr
004141  aa   000000 6260 06	eax6 	0,ql
004142  aa  7 77776 2361 17	ldq  	pr7|-2,7		msse.n_records
004143  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004144  aa  5 00070 0561 16	asq  	pr5|56,6		hmd.n_records
						STATEMENT 1 ON LINE 1054
		     if hmd.subchannels(idx).loopback.last_bufferp = null () then	/* didn't get any this time */
			hmd.subchannels(idx).loopback.first_bufferp = msse.subchannels(idx).loopback.first_bufferp;

004145  aa  6 01401 7461 00	stx6 	pr6|769
004146  aa  5 00074 2371 16	ldaq 	pr5|60,6		hmd.last_bufferp
004147  aa   774043 6770 04	eraq 	-2013,ic		000212 = 077777000043 000001000000
004150  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004151  aa   000004 6010 04	tnz  	4,ic		004155
004152  aa  7 00000 3535 37	epp3 	pr7|0,7*		msse.first_bufferp
004153  aa  5 00072 2535 16	spri3	pr5|58,6		hmd.first_bufferp
004154  aa   000006 7100 04	tra  	6,ic		004162
						STATEMENT 1 ON LINE 1056
		     else hmd.subchannels(idx).loopback.last_bufferp -> buffer.next =
			     binary (rel (msse.subchannels(idx).loopback.first_bufferp), 18, 0);

004155  aa  7 00000 6351 37	eaa  	pr7|0,7*		msse.first_bufferp
004156  aa   000066 7730 00	lrl  	54
004157  aa   000066 7370 00	lls  	54
004160  aa  5 00074 3535 36	epp3 	pr5|60,6*		buffer.next
004161  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 1058
		     hmd.subchannels(idx).loopback.last_bufferp = msse.subchannels(idx).loopback.last_bufferp;

004162  aa  6 00144 3735 20	epp7 	pr6|100,*		msse_ptr
004163  aa  7 00002 3735 37	epp7 	pr7|2,7*		msse.last_bufferp
004164  aa  5 00074 6535 16	spri7	pr5|60,6		hmd.last_bufferp
						STATEMENT 1 ON LINE 1059
		end;

						STATEMENT 1 ON LINE 1060
	     end;

004165  aa  6 00254 0541 00	aos  	pr6|172		idx
004166  aa   777736 7100 04	tra  	-34,ic		004124
						STATEMENT 1 ON LINE 1062
	     hmd.minor_state = msse.minor_state;

004167  aa  6 00144 3735 20	epp7 	pr6|100,*		msse_ptr
004170  aa  7 00002 2361 00	ldq  	pr7|2		msse.minor_state
004171  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004172  aa  5 00031 7561 00	stq  	pr5|25		hmd.minor_state
						STATEMENT 1 ON LINE 1063
	     hmd.minor_state_stack = msse.previous;

004173  aa  7 00000 3535 20	epp3 	pr7|0,*		msse.previous
004174  aa  5 00062 2535 00	spri3	pr5|50		hmd.minor_state_stack
						STATEMENT 1 ON LINE 1065
	     call tty_space_man$free_space (currentsize (msse), msse_ptr);

004175  aa  5 00113 2361 00	ldq  	pr5|75		hmd.n_subchannels
004176  aa   000006 4020 07	mpy  	6,dl
004177  aa   000004 0760 07	adq  	4,dl
004200  aa  6 01401 7561 00	stq  	pr6|769
004201  aa  6 01401 3521 00	epp2 	pr6|769
004202  aa  6 01350 2521 00	spri2	pr6|744
004203  aa  6 00144 3521 00	epp2 	pr6|100		msse_ptr
004204  aa  6 01352 2521 00	spri2	pr6|746
004205  aa  6 01346 6211 00	eax1 	pr6|742
004206  aa   010000 4310 07	fld  	4096,dl
004207  aa  6 00044 3701 20	epp4 	pr6|36,*
004210  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
004211  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1067
	     return;

004212  aa  6 00244 6101 00	rtcd 	pr6|164
ENTRY TO empty_minor_state_stack                            STATEMENT 1 ON LINE 1073
empty_minor_state_stack:
	entry ();

004213  aa  6 00244 6501 00	spri4	pr6|164
						STATEMENT 1 ON LINE 1076
	     do msse_ptr = hmd.minor_state_stack
		         repeat (previous_msse_ptr) while (msse_ptr ^= null ());

004214  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004215  aa  7 00062 3735 20	epp7 	pr7|50,*		hmd.minor_state_stack
004216  aa  6 00144 6535 00	spri7	pr6|100		msse_ptr
004217  aa   000000 0110 03	nop  	0,du
004220  aa  6 00144 2371 00	ldaq 	pr6|100		msse_ptr
004221  aa   773771 6770 04	eraq 	-2055,ic		000212 = 077777000043 000001000000
004222  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004223  aa   000065 6000 04	tze  	53,ic		004310
						STATEMENT 1 ON LINE 1079
		do idx = 1 to hmd.n_subchannels;

004224  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004225  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
004226  aa  6 00257 7561 00	stq  	pr6|175
004227  aa   000001 2360 07	ldq  	1,dl
004230  aa  6 00254 7561 00	stq  	pr6|172		idx
004231  aa   000000 0110 03	nop  	0,du
004232  aa  6 00254 2361 00	ldq  	pr6|172		idx
004233  aa  6 00257 1161 00	cmpq 	pr6|175
004234  aa   000030 6054 04	tpnz 	24,ic		004264
						STATEMENT 1 ON LINE 1080
		     if msse.subchannels(idx).loopback.first_bufferp ^= null () then
			call tty_space_man$free_chain (hmd.subchannels(idx).devx, OUTPUT,
						 msse.subchannels(idx).loopback.first_bufferp);

004235  aa   000006 4020 07	mpy  	6,dl
004236  aa  6 01401 7561 00	stq  	pr6|769
004237  aa  6 00144 2371 66	ldaq 	pr6|100,*ql	msse.first_bufferp
004240  aa   773752 6770 04	eraq 	-2070,ic		000212 = 077777000043 000001000000
004241  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004242  aa   000020 6000 04	tze  	16,ic		004262
004243  aa  6 00254 2361 00	ldq  	pr6|172		idx
004244  aa   000050 4020 07	mpy  	40,dl
004245  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004246  aa  7 00051 3521 06	epp2 	pr7|41,ql		hmd.devx
004247  aa  6 01404 2521 00	spri2	pr6|772
004250  aa   773712 3520 04	epp2 	-2102,ic		000162 = 400000000000
004251  aa  6 01406 2521 00	spri2	pr6|774
004252  aa  6 01401 7271 00	lxl7 	pr6|769
004253  aa  6 00144 3521 77	epp2 	pr6|100,*7	msse.first_bufferp
004254  aa  6 01410 2521 00	spri2	pr6|776
004255  aa  6 01402 6211 00	eax1 	pr6|770
004256  aa   014000 4310 07	fld  	6144,dl
004257  aa  6 00044 3701 20	epp4 	pr6|36,*
004260  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
004261  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1083
		end;

004262  aa  6 00254 0541 00	aos  	pr6|172		idx
004263  aa   777747 7100 04	tra  	-25,ic		004232
						STATEMENT 1 ON LINE 1085
		previous_msse_ptr = msse.previous;

004264  aa  6 00144 3735 20	epp7 	pr6|100,*		msse.previous
004265  aa  7 00000 3735 20	epp7 	pr7|0,*		msse.previous
004266  aa  6 00252 6535 00	spri7	pr6|170		previous_msse_ptr
						STATEMENT 1 ON LINE 1087
		call tty_space_man$free_space (currentsize (msse), msse_ptr);

004267  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004270  aa  5 00113 2361 00	ldq  	pr5|75		hmd.n_subchannels
004271  aa   000006 4020 07	mpy  	6,dl
004272  aa   000004 0760 07	adq  	4,dl
004273  aa  6 01401 7561 00	stq  	pr6|769
004274  aa  6 01401 3521 00	epp2 	pr6|769
004275  aa  6 01350 2521 00	spri2	pr6|744
004276  aa  6 00144 3521 00	epp2 	pr6|100		msse_ptr
004277  aa  6 01352 2521 00	spri2	pr6|746
004300  aa  6 01346 6211 00	eax1 	pr6|742
004301  aa   010000 4310 07	fld  	4096,dl
004302  aa  6 00044 3701 20	epp4 	pr6|36,*
004303  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
004304  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1088
	     end;

004305  aa  6 00252 3735 20	epp7 	pr6|170,*		previous_msse_ptr
004306  aa  6 00144 6535 00	spri7	pr6|100		msse_ptr
004307  aa   777711 7100 04	tra  	-55,ic		004220
						STATEMENT 1 ON LINE 1090
	     hmd.minor_state_stack = null ();

004310  aa   773702 2370 04	ldaq 	-2110,ic		000212 = 077777000043 000001000000
004311  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004312  aa  7 00062 7571 00	staq 	pr7|50		hmd.minor_state_stack
						STATEMENT 1 ON LINE 1092
	     return;

004313  aa  6 00244 6101 00	rtcd 	pr6|164
						STATEMENT 1 ON LINE 1094
	end minor_state_stack_manager;

  END PROCEDURE minor_state_stack_manager
BEGIN PROCEDURE loopback_block_chain_stack_manag
ENTRY TO loopback_block_chain_stack_manag                   STATEMENT 1 ON LINE 1099
loopback_block_chain_stack_manager:
	procedure ();

004314  aa  6 00260 6501 00	spri4	pr6|176
						STATEMENT 1 ON LINE 1102
	     return;

004315  aa  6 00260 6101 00	rtcd 	pr6|176
ENTRY TO push_loopback_block_chain                          STATEMENT 1 ON LINE 1109
push_loopback_block_chain:
	entry ();

004316  aa  6 00260 6501 00	spri4	pr6|176
						STATEMENT 1 ON LINE 1112
	     call tty_space_man$get_space (size (lbcse), lbcse_ptr);

004317  aa   000006 2360 07	ldq  	6,dl
004320  aa  6 01424 7561 00	stq  	pr6|788
004321  aa  6 01424 3521 00	epp2 	pr6|788
004322  aa  6 01430 2521 00	spri2	pr6|792
004323  aa  6 00146 3521 00	epp2 	pr6|102		lbcse_ptr
004324  aa  6 01432 2521 00	spri2	pr6|794
004325  aa  6 01426 6211 00	eax1 	pr6|790
004326  aa   010000 4310 07	fld  	4096,dl
004327  aa  6 00044 3701 20	epp4 	pr6|36,*
004330  la  4 00104 3521 20	epp2 	pr4|68,*		tty_space_man$get_space
004331  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1113
		if lbcse_ptr = null () then do;

004332  aa  6 00146 2371 00	ldaq 	pr6|102		lbcse_ptr
004333  aa   773657 6770 04	eraq 	-2129,ic		000212 = 077777000043 000001000000
004334  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004335  aa   000060 6010 04	tnz  	48,ic		004415
						STATEMENT 1 ON LINE 1114
		     call syserr (LOG_AND_PRINT,
			        "hasp_mpx (line ^a): No space available to save loopback chain; line will be hungup.",
			        hmd.name);

004336  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004337  aa   774032 00 0124	desc9a	-2022,84		000370 = 150141163160
004340  aa  6 01434 00 0124	desc9a	pr6|796,84
004341  aa   773622 3520 04	epp2 	-2158,ic		000163 = 000000000000
004342  aa  6 01464 2521 00	spri2	pr6|820
004343  aa  6 01434 3521 00	epp2 	pr6|796
004344  aa  6 01466 2521 00	spri2	pr6|822
004345  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
004346  aa  6 01470 2521 00	spri2	pr6|824
004347  aa   773626 3520 04	epp2 	-2154,ic		000175 = 404000000021
004350  aa  6 01472 2521 00	spri2	pr6|826
004351  aa   773601 3520 04	epp2 	-2175,ic		000152 = 524000000123
004352  aa  6 01474 2521 00	spri2	pr6|828
004353  aa   773601 3520 04	epp2 	-2175,ic		000154 = 526000000040
004354  aa  6 01476 2521 00	spri2	pr6|830
004355  aa  6 01462 6211 00	eax1 	pr6|818
004356  aa   014000 4310 07	fld  	6144,dl
004357  aa  6 00044 3701 20	epp4 	pr6|36,*
004360  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
004361  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1117
		     call channel_manager$control (hmd.devx, "hangup", null (), code);

004362  aa   773622 2370 04	ldaq 	-2158,ic		000204 = 150141156147 165160000000
004363  aa  6 01500 7571 00	staq 	pr6|832
004364  aa   773626 3734 24	epp7 	-2154,ic*
004365  aa  6 01502 6535 00	spri7	pr6|834
004366  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004367  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
004370  aa  6 01436 2521 00	spri2	pr6|798
004371  aa  6 01500 3521 00	epp2 	pr6|832
004372  aa  6 01440 2521 00	spri2	pr6|800
004373  aa  6 01502 3521 00	epp2 	pr6|834
004374  aa  6 01442 2521 00	spri2	pr6|802
004375  aa  6 00101 3521 00	epp2 	pr6|65		code
004376  aa  6 01444 2521 00	spri2	pr6|804
004377  aa   773576 3520 04	epp2 	-2178,ic		000175 = 404000000021
004400  aa  6 01446 2521 00	spri2	pr6|806
004401  aa   773552 3520 04	epp2 	-2198,ic		000153 = 524000000006
004402  aa  6 01450 2521 00	spri2	pr6|808
004403  aa   773574 3520 04	epp2 	-2180,ic		000177 = 464000000000
004404  aa  6 01452 2521 00	spri2	pr6|810
004405  aa   773566 3520 04	epp2 	-2186,ic		000173 = 404000000043
004406  aa  6 01454 2521 00	spri2	pr6|812
004407  aa  6 01434 6211 00	eax1 	pr6|796
004410  aa   020000 4310 07	fld  	8192,dl
004411  aa  6 00044 3701 20	epp4 	pr6|36,*
004412  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
004413  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1118
		     return;

004414  aa  6 00260 6101 00	rtcd 	pr6|176
						STATEMENT 1 ON LINE 1119
		end;

						STATEMENT 1 ON LINE 1121
	     lbcse.loopback = hmd.loopback;

004415  aa  6 00146 3735 20	epp7 	pr6|102,*		lbcse_ptr
004416  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004417  aa  5 00046 2371 00	ldaq 	pr5|38		hmd.loopback
004420  aa  7 00002 7571 00	staq 	pr7|2		lbcse.loopback
004421  aa  5 00050 2371 00	ldaq 	pr5|40		hmd.loopback
004422  aa  7 00004 7571 00	staq 	pr7|4		lbcse.loopback
						STATEMENT 1 ON LINE 1122
	     hmd.loopback = null ();

004423  aa   773567 2370 04	ldaq 	-2185,ic		000212 = 077777000043 000001000000
004424  aa  5 00046 7571 00	staq 	pr5|38		hmd.first_bufferp
004425  aa  5 00050 7571 00	staq 	pr5|40		hmd.last_bufferp
						STATEMENT 1 ON LINE 1124
	     lbcse.previous = hmd.loopback_block_chain_stack;

004426  aa  5 00064 3735 20	epp7 	pr5|52,*		hmd.loopback_block_chain_stack
004427  aa  6 00146 6535 20	spri7	pr6|102,*		lbcse.previous
						STATEMENT 1 ON LINE 1125
	     hmd.loopback_block_chain_stack = lbcse_ptr;

004430  aa  6 00146 3535 20	epp3 	pr6|102,*		lbcse_ptr
004431  aa  5 00064 2535 00	spri3	pr5|52		hmd.loopback_block_chain_stack
						STATEMENT 1 ON LINE 1127
	     return;

004432  aa  6 00260 6101 00	rtcd 	pr6|176
ENTRY TO pop_loopback_block_chain                           STATEMENT 1 ON LINE 1133
pop_loopback_block_chain:
	entry ();

004433  aa  6 00260 6501 00	spri4	pr6|176
						STATEMENT 1 ON LINE 1136
	     if hmd.loopback_block_chain_stack = null () then
		return;

004434  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004435  aa  7 00064 2371 00	ldaq 	pr7|52		hmd.loopback_block_chain_stack
004436  aa   773554 6770 04	eraq 	-2196,ic		000212 = 077777000043 000001000000
004437  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004440  aa   000002 6010 04	tnz  	2,ic		004442
004441  aa  6 00260 6101 00	rtcd 	pr6|176
						STATEMENT 1 ON LINE 1139
	     lbcse_ptr = hmd.loopback_block_chain_stack;

004442  aa  7 00064 3715 20	epp5 	pr7|52,*		hmd.loopback_block_chain_stack
004443  aa  6 00146 6515 00	spri5	pr6|102		lbcse_ptr
						STATEMENT 1 ON LINE 1141
	     if lbcse.loopback.first_bufferp ^= null () then do;

004444  aa  5 00002 2371 00	ldaq 	pr5|2		lbcse.first_bufferp
004445  aa   773545 6770 04	eraq 	-2203,ic		000212 = 077777000043 000001000000
004446  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004447  aa   000020 6000 04	tze  	16,ic		004467
						STATEMENT 1 ON LINE 1142
		if hmd.loopback.last_bufferp = null () then  /* didn't pickup any data this time */
		     hmd.loopback.first_bufferp = lbcse.loopback.first_bufferp;

004450  aa  7 00050 2371 00	ldaq 	pr7|40		hmd.last_bufferp
004451  aa   773541 6770 04	eraq 	-2207,ic		000212 = 077777000043 000001000000
004452  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004453  aa   000004 6010 04	tnz  	4,ic		004457
004454  aa  5 00002 3535 20	epp3 	pr5|2,*		lbcse.first_bufferp
004455  aa  7 00046 2535 00	spri3	pr7|38		hmd.first_bufferp
004456  aa   000006 7100 04	tra  	6,ic		004464
						STATEMENT 1 ON LINE 1144
		else hmd.loopback.last_bufferp -> buffer.next = binary (rel (lbcse.loopback.first_bufferp), 18, 0);

004457  aa  5 00002 6351 20	eaa  	pr5|2,*		lbcse.first_bufferp
004460  aa   000066 7730 00	lrl  	54
004461  aa   000066 7370 00	lls  	54
004462  aa  7 00050 3535 20	epp3 	pr7|40,*		buffer.next
004463  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 1145
		hmd.loopback.last_bufferp = lbcse.loopback.last_bufferp;

004464  aa  6 00146 3715 20	epp5 	pr6|102,*		lbcse_ptr
004465  aa  5 00004 3715 20	epp5 	pr5|4,*		lbcse.last_bufferp
004466  aa  7 00050 6515 00	spri5	pr7|40		hmd.last_bufferp
						STATEMENT 1 ON LINE 1146
	     end;

						STATEMENT 1 ON LINE 1148
	     hmd.loopback_block_chain_stack = lbcse.previous;

004467  aa  6 00146 3715 20	epp5 	pr6|102,*		lbcse.previous
004470  aa  5 00000 3715 20	epp5 	pr5|0,*		lbcse.previous
004471  aa  7 00064 6515 00	spri5	pr7|52		hmd.loopback_block_chain_stack
						STATEMENT 1 ON LINE 1150
	     call tty_space_man$free_space (currentsize (lbcse), lbcse_ptr);

004472  aa   000006 2360 07	ldq  	6,dl
004473  aa  6 01461 7561 00	stq  	pr6|817
004474  aa  6 01461 3521 00	epp2 	pr6|817
004475  aa  6 01430 2521 00	spri2	pr6|792
004476  aa  6 00146 3521 00	epp2 	pr6|102		lbcse_ptr
004477  aa  6 01432 2521 00	spri2	pr6|794
004500  aa  6 01426 6211 00	eax1 	pr6|790
004501  aa   010000 4310 07	fld  	4096,dl
004502  aa  6 00044 3701 20	epp4 	pr6|36,*
004503  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
004504  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1152
	     return;

004505  aa  6 00260 6101 00	rtcd 	pr6|176
ENTRY TO empty_loopback_block_chain_stack                   STATEMENT 1 ON LINE 1158
empty_loopback_block_chain_stack:
	entry ();

004506  aa  6 00260 6501 00	spri4	pr6|176
						STATEMENT 1 ON LINE 1161
	     do lbcse_ptr = hmd.loopback_block_chain_stack
			repeat (previous_lbcse_ptr) while (lbcse_ptr ^= null ());

004507  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004510  aa  7 00064 3735 20	epp7 	pr7|52,*		hmd.loopback_block_chain_stack
004511  aa  6 00146 6535 00	spri7	pr6|102		lbcse_ptr
004512  aa  6 00146 2371 00	ldaq 	pr6|102		lbcse_ptr
004513  aa   773477 6770 04	eraq 	-2241,ic		000212 = 077777000043 000001000000
004514  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004515  aa   000043 6000 04	tze  	35,ic		004560
						STATEMENT 1 ON LINE 1164
		previous_lbcse_ptr = lbcse.previous;

004516  aa  6 00146 3735 20	epp7 	pr6|102,*		lbcse.previous
004517  aa  7 00000 3735 20	epp7 	pr7|0,*		lbcse.previous
004520  aa  6 00266 6535 00	spri7	pr6|182		previous_lbcse_ptr
						STATEMENT 1 ON LINE 1166
		if lbcse.loopback.first_bufferp ^= null () then
		     call tty_space_man$free_chain (hmd.devx, INPUT, lbcse.loopback.first_bufferp);

004521  aa  6 00146 3715 20	epp5 	pr6|102,*		lbcse_ptr
004522  aa  5 00002 2371 00	ldaq 	pr5|2		lbcse.first_bufferp
004523  aa   773467 6770 04	eraq 	-2249,ic		000212 = 077777000043 000001000000
004524  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004525  aa   000015 6000 04	tze  	13,ic		004542
004526  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
004527  aa  3 00010 3521 00	epp2 	pr3|8		hmd.devx
004530  aa  6 01464 2521 00	spri2	pr6|820
004531  aa   773361 3520 04	epp2 	-2319,ic		000112 = 000000000000
004532  aa  6 01466 2521 00	spri2	pr6|822
004533  aa  5 00002 3521 00	epp2 	pr5|2		lbcse.first_bufferp
004534  aa  6 01470 2521 00	spri2	pr6|824
004535  aa  6 01462 6211 00	eax1 	pr6|818
004536  aa   014000 4310 07	fld  	6144,dl
004537  aa  6 00044 3701 20	epp4 	pr6|36,*
004540  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
004541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1169
		call tty_space_man$free_space (currentsize (lbcse), lbcse_ptr);

004542  aa   000006 2360 07	ldq  	6,dl
004543  aa  6 01461 7561 00	stq  	pr6|817
004544  aa  6 01461 3521 00	epp2 	pr6|817
004545  aa  6 01430 2521 00	spri2	pr6|792
004546  aa  6 00146 3521 00	epp2 	pr6|102		lbcse_ptr
004547  aa  6 01432 2521 00	spri2	pr6|794
004550  aa  6 01426 6211 00	eax1 	pr6|790
004551  aa   010000 4310 07	fld  	4096,dl
004552  aa  6 00044 3701 20	epp4 	pr6|36,*
004553  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
004554  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1170
	     end;

004555  aa  6 00266 3735 20	epp7 	pr6|182,*		previous_lbcse_ptr
004556  aa  6 00146 6535 00	spri7	pr6|102		lbcse_ptr
004557  aa   777733 7100 04	tra  	-37,ic		004512
						STATEMENT 1 ON LINE 1172
	     hmd.loopback_block_chain_stack = null ();

004560  aa   773432 2370 04	ldaq 	-2278,ic		000212 = 077777000043 000001000000
004561  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004562  aa  7 00064 7571 00	staq 	pr7|52		hmd.loopback_block_chain_stack
						STATEMENT 1 ON LINE 1174
	     return;

004563  aa  6 00260 6101 00	rtcd 	pr6|176
						STATEMENT 1 ON LINE 1176
	end loopback_block_chain_stack_manager;

  END PROCEDURE loopback_block_chain_stack_manag
BEGIN PROCEDURE enqueue_subchannel_for_output
ENTRY TO enqueue_subchannel_for_output                      STATEMENT 1 ON LINE 1180
enqueue_subchannel_for_output:
	procedure ();

004564  aa  6 00270 6501 00	spri4	pr6|184
						STATEMENT 1 ON LINE 1185
	     do idx = hmd.subchannels_for_output.first
		    repeat (hmd.subchannels(idx).next_subchannel_for_output)
		     while (idx ^= 0);

004565  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004566  aa  7 00036 2361 00	ldq  	pr7|30		hmd.first
004567  aa  6 00276 7561 00	stq  	pr6|190		idx
004570  aa  6 00276 2361 00	ldq  	pr6|190		idx
004571  aa   000012 6000 04	tze  	10,ic		004603
						STATEMENT 1 ON LINE 1188
		if (idx = hste.subchannel_idx) then return;

004572  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004573  aa  7 00002 1161 00	cmpq 	pr7|2		hste.subchannel_idx
004574  aa   000002 6010 04	tnz  	2,ic		004576
004575  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1189
	     end;

004576  aa   000050 4020 07	mpy  	40,dl
004577  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004600  aa  5 00060 2361 06	ldq  	pr5|48,ql		hmd.next_subchannel_for_output
004601  aa  6 00276 7561 00	stq  	pr6|190		idx
004602  aa   777766 7100 04	tra  	-10,ic		004570
						STATEMENT 1 ON LINE 1191
	     hste.holding_output = "1"b;

004603  aa   100000 2350 03	lda  	32768,du
004604  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004605  aa  7 00036 2551 00	orsa 	pr7|30		hste.holding_output
						STATEMENT 1 ON LINE 1193
	     if (hmd.subchannels_for_output.first = 0) then    /* queue empty:  this will be first element in queue */
		hmd.subchannels_for_output.first = hste.subchannel_idx;

004606  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004607  aa  5 00036 2361 00	ldq  	pr5|30		hmd.first
004610  aa   000004 6010 04	tnz  	4,ic		004614
004611  aa  7 00002 2361 00	ldq  	pr7|2		hste.subchannel_idx
004612  aa  5 00036 7561 00	stq  	pr5|30		hmd.first
004613  aa   000006 7100 04	tra  	6,ic		004621
						STATEMENT 1 ON LINE 1196
	     else hmd.subchannels(hmd.subchannels_for_output.last).next_subchannel_for_output = hste.subchannel_idx;

004614  aa  5 00037 2361 00	ldq  	pr5|31		hmd.last
004615  aa   000050 4020 07	mpy  	40,dl
004616  aa   000000 6270 06	eax7 	0,ql
004617  aa  7 00002 2361 00	ldq  	pr7|2		hste.subchannel_idx
004620  aa  5 00060 7561 17	stq  	pr5|48,7		hmd.next_subchannel_for_output
						STATEMENT 1 ON LINE 1199
	     hmd.subchannels_for_output.last = hste.subchannel_idx;

004621  aa  7 00002 2361 00	ldq  	pr7|2		hste.subchannel_idx
004622  aa  5 00037 7561 00	stq  	pr5|31		hmd.last
						STATEMENT 1 ON LINE 1200
	     hste.next_subchannel_for_output = 0;

004623  aa  7 00014 4501 00	stz  	pr7|12		hste.next_subchannel_for_output
						STATEMENT 1 ON LINE 1202
	     return;

004624  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1204
	end enqueue_subchannel_for_output;

  END PROCEDURE enqueue_subchannel_for_output
BEGIN PROCEDURE dequeue_subchannel_for_output
ENTRY TO dequeue_subchannel_for_output                      STATEMENT 1 ON LINE 1208
dequeue_subchannel_for_output:
	procedure ();

004625  aa  6 00300 6501 00	spri4	pr6|192
						STATEMENT 1 ON LINE 1213
	     if hste.holding_output then do;

004626  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004627  aa  7 00036 2351 00	lda  	pr7|30		hste.holding_output
004630  aa   100000 3150 03	cana 	32768,du
004631  aa   000041 6000 04	tze  	33,ic		004672
						STATEMENT 1 ON LINE 1215
		previous_subchannel_idx = 0;

004632  aa  6 00306 4501 00	stz  	pr6|198		previous_subchannel_idx
						STATEMENT 1 ON LINE 1217
		if (hmd.subchannels_for_output.first = hste.subchannel_idx) then
		     hmd.subchannels_for_output.first = hste.next_subchannel_for_output;

004633  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004634  aa  5 00036 2361 00	ldq  	pr5|30		hmd.first
004635  aa  7 00002 1161 00	cmpq 	pr7|2		hste.subchannel_idx
004636  aa   000004 6010 04	tnz  	4,ic		004642
004637  aa  7 00014 2361 00	ldq  	pr7|12		hste.next_subchannel_for_output
004640  aa  5 00036 7561 00	stq  	pr5|30		hmd.first
004641  aa   000022 7100 04	tra  	18,ic		004663
						STATEMENT 1 ON LINE 1220
		else				/* not first in queue:  find predecessor */
		do previous_subchannel_idx = hmd.subchannels_for_output.first
				      repeat (hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output)
			while (previous_subchannel_idx ^= 0);

004642  aa  6 00306 7561 00	stq  	pr6|198		previous_subchannel_idx
004643  aa   000000 0110 03	nop  	0,du
004644  aa  6 00306 2361 00	ldq  	pr6|198		previous_subchannel_idx
004645  aa   000016 6000 04	tze  	14,ic		004663
						STATEMENT 1 ON LINE 1224
		     if (hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output = hste.subchannel_idx)
		     then do;

004646  aa   000050 4020 07	mpy  	40,dl
004647  aa  6 01505 7561 00	stq  	pr6|837
004650  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004651  aa  7 00060 2361 06	ldq  	pr7|48,ql		hmd.next_subchannel_for_output
004652  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
004653  aa  5 00002 1161 00	cmpq 	pr5|2		hste.subchannel_idx
004654  aa   000005 6010 04	tnz  	5,ic		004661
						STATEMENT 1 ON LINE 1226
			hmd.subchannels(previous_subchannel_idx).next_subchannel_for_output =
				hste.next_subchannel_for_output;

004655  aa  5 00014 2361 00	ldq  	pr5|12		hste.next_subchannel_for_output
004656  aa  6 01505 7271 00	lxl7 	pr6|837
004657  aa  7 00060 7561 17	stq  	pr7|48,7		hmd.next_subchannel_for_output
						STATEMENT 1 ON LINE 1228
			go to EXIT_SEARCH_FOR_PREVIOUS_LOOP;

004660  aa   000003 7100 04	tra  	3,ic		004663
						STATEMENT 1 ON LINE 1229
		     end;

						STATEMENT 1 ON LINE 1230
		end;

004661  aa  6 00306 7561 00	stq  	pr6|198		previous_subchannel_idx
004662  aa   777762 7100 04	tra  	-14,ic		004644
						STATEMENT 1 ON LINE 1232
EXIT_SEARCH_FOR_PREVIOUS_LOOP:
		if (hmd.subchannels_for_output.last = hste.subchannel_idx) then
		     hmd.subchannels_for_output.last = previous_subchannel_idx;

004663  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004664  aa  7 00037 2361 00	ldq  	pr7|31		hmd.last
004665  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
004666  aa  5 00002 1161 00	cmpq 	pr5|2		hste.subchannel_idx
004667  aa   000003 6010 04	tnz  	3,ic		004672
004670  aa  6 00306 2361 00	ldq  	pr6|198		previous_subchannel_idx
004671  aa  7 00037 7561 00	stq  	pr7|31		hmd.last
						STATEMENT 1 ON LINE 1235
	     end;

						STATEMENT 1 ON LINE 1237
	     hste.next_subchannel_for_output = 0;

004672  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004673  aa  7 00014 4501 00	stz  	pr7|12		hste.next_subchannel_for_output
						STATEMENT 1 ON LINE 1239
	     hste.holding_output = "0"b;

004674  aa   011061 2350 04	lda  	4657,ic		015755 = 677777777777
004675  aa  7 00036 3551 00	ansa 	pr7|30		hste.holding_output
						STATEMENT 1 ON LINE 1241
	     return;

004676  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 1243
	end dequeue_subchannel_for_output;

  END PROCEDURE dequeue_subchannel_for_output
BEGIN PROCEDURE interrupt_subchannels_with_outpu
ENTRY TO interrupt_subchannels_with_outpu                   STATEMENT 1 ON LINE 1247
interrupt_subchannels_with_output:
	procedure ();

004677  aa  6 00310 6501 00	spri4	pr6|200
						STATEMENT 1 ON LINE 1254
	     saved_hste_ptr = hste_ptr;

004700  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004701  aa  6 00316 6535 00	spri7	pr6|206		saved_hste_ptr
						STATEMENT 1 ON LINE 1256
	     n_entries = 0;

004702  aa  6 00341 4501 00	stz  	pr6|225		n_entries
						STATEMENT 1 ON LINE 1257
	     do idx = hmd.subchannels_for_output.first
		    repeat (hmd.subchannels(idx).next_subchannel_for_output) while (idx ^= 0);

004703  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
004704  aa  5 00036 2361 00	ldq  	pr5|30		hmd.first
004705  aa  6 00342 7561 00	stq  	pr6|226		idx
004706  aa  6 00342 2361 00	ldq  	pr6|226		idx
004707  aa   000013 6000 04	tze  	11,ic		004722
						STATEMENT 1 ON LINE 1259
		n_entries = n_entries + 1;

004710  aa  6 00341 0541 00	aos  	pr6|225		n_entries
						STATEMENT 1 ON LINE 1260
		queue (n_entries) = hmd.subchannels(idx).subchannel_idx;

004711  aa   000050 4020 07	mpy  	40,dl
004712  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004713  aa   000000 6260 06	eax6 	0,ql
004714  aa  7 00046 2361 06	ldq  	pr7|38,ql		hmd.subchannel_idx
004715  aa  6 00341 7271 00	lxl7 	pr6|225		n_entries
004716  aa  6 00317 7561 17	stq  	pr6|207,7		queue
						STATEMENT 1 ON LINE 1261
	     end;

004717  aa  7 00060 2361 16	ldq  	pr7|48,6		hmd.next_subchannel_for_output
004720  aa  6 00342 7561 00	stq  	pr6|226		idx
004721  aa   777765 7100 04	tra  	-11,ic		004706
						STATEMENT 1 ON LINE 1263
	     if (n_entries = 0) then return;

004722  aa  6 00341 2361 00	ldq  	pr6|225		n_entries
004723  aa   000002 6010 04	tnz  	2,ic		004725
004724  aa  6 00310 6101 00	rtcd 	pr6|200
						STATEMENT 1 ON LINE 1265
	     do idx = 1 to n_entries;

004725  aa  6 00343 7561 00	stq  	pr6|227
004726  aa   000001 2360 07	ldq  	1,dl
004727  aa  6 00342 7561 00	stq  	pr6|226		idx
004730  aa  6 00342 2361 00	ldq  	pr6|226		idx
004731  aa  6 00343 1161 00	cmpq 	pr6|227
004732  aa   000027 6054 04	tpnz 	23,ic		004761
						STATEMENT 1 ON LINE 1266
		hste_ptr = addr (hmd.subchannels (queue (idx)));

004733  aa  6 00317 2361 06	ldq  	pr6|207,ql	queue
004734  aa   000050 4020 07	mpy  	40,dl
004735  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004736  aa  7 00044 3735 06	epp7 	pr7|36,ql		hmd.subchannels
004737  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 1267
		call dequeue_subchannel_for_output ();

004740  aa   777665 6700 04	tsp4 	-75,ic		004625
						STATEMENT 1 ON LINE 1268
		call channel_manager$interrupt_later (hste.devx, SEND_OUTPUT, ""b);

004741  aa   773247 2370 04	ldaq 	-2393,ic		000210 = 000000000000 000000000000
004742  aa  6 01510 7571 00	staq 	pr6|840
004743  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
004744  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
004745  aa  6 01514 2521 00	spri2	pr6|844
004746  aa   773222 3520 04	epp2 	-2414,ic		000170 = 000000000004
004747  aa  6 01516 2521 00	spri2	pr6|846
004750  aa  6 01510 3521 00	epp2 	pr6|840
004751  aa  6 01520 2521 00	spri2	pr6|848
004752  aa  6 01512 6211 00	eax1 	pr6|842
004753  aa   014000 4310 07	fld  	6144,dl
004754  aa  6 00044 3701 20	epp4 	pr6|36,*
004755  la  4 00102 3521 20	epp2 	pr4|66,*		channel_manager$interrupt_later
004756  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1269
	     end;

004757  aa  6 00342 0541 00	aos  	pr6|226		idx
004760  aa   777750 7100 04	tra  	-24,ic		004730
						STATEMENT 1 ON LINE 1271
	     hste_ptr = saved_hste_ptr;

004761  aa  6 00316 3735 20	epp7 	pr6|206,*		saved_hste_ptr
004762  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 1273
	     return;

004763  aa  6 00310 6101 00	rtcd 	pr6|200
						STATEMENT 1 ON LINE 1275
	end interrupt_subchannels_with_output;

  END PROCEDURE interrupt_subchannels_with_outpu
BEGIN PROCEDURE interrupt_subchannels_with_input
ENTRY TO interrupt_subchannels_with_input                   STATEMENT 1 ON LINE 1281
interrupt_subchannels_with_input:
	procedure ();

004764  aa  6 00344 6501 00	spri4	pr6|228
						STATEMENT 1 ON LINE 1286
	     do idx = 1 to hmd.n_subchannels;

004765  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
004766  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
004767  aa  6 00353 7561 00	stq  	pr6|235
004770  aa   000001 2360 07	ldq  	1,dl
004771  aa  6 00352 7561 00	stq  	pr6|234		idx
004772  aa  6 00352 2361 00	ldq  	pr6|234		idx
004773  aa  6 00353 1161 00	cmpq 	pr6|235
004774  aa   000037 6054 04	tpnz 	31,ic		005033
						STATEMENT 1 ON LINE 1287
		if hmd.subchannels(idx).input_available | (hmd.subchannels(idx).input.first_bufferp ^= null ())
		then do;

004775  aa   000050 4020 07	mpy  	40,dl
004776  aa  6 01522 7561 00	stq  	pr6|850
004777  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005000  aa  7 00102 2351 06	lda  	pr7|66,ql		hmd.input_available
005001  aa   200000 3150 03	cana 	65536,du
005002  aa   000005 6010 04	tnz  	5,ic		005007
005003  aa  7 00064 2371 06	ldaq 	pr7|52,ql		hmd.first_bufferp
005004  aa   773206 6770 04	eraq 	-2426,ic		000212 = 077777000043 000001000000
005005  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005006  aa   000023 6000 04	tze  	19,ic		005031
						STATEMENT 1 ON LINE 1289
		     hmd.subchannels(idx).requested_input, hmd.subchannels(idx).input_available = "0"b;

005007  aa   010745 2350 04	lda  	4581,ic		015754 = 377777777777
005010  aa  6 01522 7271 00	lxl7 	pr6|850
005011  aa  7 00102 3551 17	ansa 	pr7|66,7		hmd.requested_input
005012  aa   010754 2350 04	lda  	4588,ic		015766 = 577777777777
005013  aa  7 00102 3551 17	ansa 	pr7|66,7		hmd.input_available
						STATEMENT 1 ON LINE 1290
		     call channel_manager$interrupt (hmd.subchannels(idx).devx, INPUT_AVAILABLE, ""b);

005014  aa   773174 2370 04	ldaq 	-2436,ic		000210 = 000000000000 000000000000
005015  aa  6 01524 7571 00	staq 	pr6|852
005016  aa  7 00051 3521 17	epp2 	pr7|41,7		hmd.devx
005017  aa  6 01530 2521 00	spri2	pr6|856
005020  aa   773144 3520 04	epp2 	-2460,ic		000164 = 000000000005
005021  aa  6 01532 2521 00	spri2	pr6|858
005022  aa  6 01524 3521 00	epp2 	pr6|852
005023  aa  6 01534 2521 00	spri2	pr6|860
005024  aa  6 01526 6211 00	eax1 	pr6|854
005025  aa   014000 4310 07	fld  	6144,dl
005026  aa  6 00044 3701 20	epp4 	pr6|36,*
005027  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
005030  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1291
		end;

						STATEMENT 1 ON LINE 1292
	     end;

005031  aa  6 00352 0541 00	aos  	pr6|234		idx
005032  aa   777740 7100 04	tra  	-32,ic		004772
						STATEMENT 1 ON LINE 1294
	     return;

005033  aa  6 00344 6101 00	rtcd 	pr6|228
						STATEMENT 1 ON LINE 1296
	end interrupt_subchannels_with_input;

  END PROCEDURE interrupt_subchannels_with_input
BEGIN PROCEDURE interrupt_subchannels_requesting
ENTRY TO interrupt_subchannels_requesting                   STATEMENT 1 ON LINE 1301
interrupt_subchannels_requesting_input:
	procedure ();

005034  aa  6 00354 6501 00	spri4	pr6|236
						STATEMENT 1 ON LINE 1307
	     sent_interrupt = "0"b;

005035  aa  6 00362 4501 00	stz  	pr6|242		sent_interrupt
						STATEMENT 1 ON LINE 1309
	     do idx = 1 to hmd.n_subchannels;

005036  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005037  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
005040  aa  6 00364 7561 00	stq  	pr6|244
005041  aa   000001 2360 07	ldq  	1,dl
005042  aa  6 00363 7561 00	stq  	pr6|243		idx
005043  aa   000000 0110 03	nop  	0,du
005044  aa  6 00363 2361 00	ldq  	pr6|243		idx
005045  aa  6 00364 1161 00	cmpq 	pr6|244
005046  aa   000035 6054 04	tpnz 	29,ic		005103
						STATEMENT 1 ON LINE 1310
		if hmd.subchannels(idx).requested_input then do;

005047  aa   000050 4020 07	mpy  	40,dl
005050  aa  6 01536 7561 00	stq  	pr6|862
005051  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005052  aa  7 00102 2351 06	lda  	pr7|66,ql		hmd.requested_input
005053  aa   400000 3150 03	cana 	131072,du
005054  aa   000025 6000 04	tze  	21,ic		005101
						STATEMENT 1 ON LINE 1311
		     hmd.subchannels(idx).requested_input, hmd.subchannels(idx).input_available = "0"b;

005055  aa   010677 2350 04	lda  	4543,ic		015754 = 377777777777
005056  aa  7 00102 3551 06	ansa 	pr7|66,ql		hmd.requested_input
005057  aa   010707 2350 04	lda  	4551,ic		015766 = 577777777777
005060  aa  7 00102 3551 06	ansa 	pr7|66,ql		hmd.input_available
						STATEMENT 1 ON LINE 1312
		     call channel_manager$interrupt (hmd.subchannels(idx).devx, INPUT_AVAILABLE, ""b);

005061  aa   773127 2370 04	ldaq 	-2473,ic		000210 = 000000000000 000000000000
005062  aa  6 01540 7571 00	staq 	pr6|864
005063  aa  6 01536 7271 00	lxl7 	pr6|862
005064  aa  7 00051 3521 17	epp2 	pr7|41,7		hmd.devx
005065  aa  6 01544 2521 00	spri2	pr6|868
005066  aa   773076 3520 04	epp2 	-2498,ic		000164 = 000000000005
005067  aa  6 01546 2521 00	spri2	pr6|870
005070  aa  6 01540 3521 00	epp2 	pr6|864
005071  aa  6 01550 2521 00	spri2	pr6|872
005072  aa  6 01542 6211 00	eax1 	pr6|866
005073  aa   014000 4310 07	fld  	6144,dl
005074  aa  6 00044 3701 20	epp4 	pr6|36,*
005075  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
005076  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1313
		     sent_interrupt = "1"b;

005077  aa   400000 2350 03	lda  	131072,du
005100  aa  6 00362 7551 00	sta  	pr6|242		sent_interrupt
						STATEMENT 1 ON LINE 1314
		end;

						STATEMENT 1 ON LINE 1315
	     end;

005101  aa  6 00363 0541 00	aos  	pr6|243		idx
005102  aa   777742 7100 04	tra  	-30,ic		005044
						STATEMENT 1 ON LINE 1317
	     if ^sent_interrupt then			/* insure that someone is interrupted */
		call channel_manager$interrupt (hmd.subchannels(hmd.console_hste_idx).devx, INPUT_AVAILABLE, ""b);

005103  aa  6 00362 2351 00	lda  	pr6|242		sent_interrupt
005104  aa   000022 6010 04	tnz  	18,ic		005126
005105  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005106  aa  7 00112 2361 00	ldq  	pr7|74		hmd.console_hste_idx
005107  aa   000050 4020 07	mpy  	40,dl
005110  aa   000000 6270 06	eax7 	0,ql
005111  aa   773077 2370 04	ldaq 	-2497,ic		000210 = 000000000000 000000000000
005112  aa  6 01540 7571 00	staq 	pr6|864
005113  aa  7 00051 3521 17	epp2 	pr7|41,7		hmd.devx
005114  aa  6 01544 2521 00	spri2	pr6|868
005115  aa   773047 3520 04	epp2 	-2521,ic		000164 = 000000000005
005116  aa  6 01546 2521 00	spri2	pr6|870
005117  aa  6 01540 3521 00	epp2 	pr6|864
005120  aa  6 01550 2521 00	spri2	pr6|872
005121  aa  6 01542 6211 00	eax1 	pr6|866
005122  aa   014000 4310 07	fld  	6144,dl
005123  aa  6 00044 3701 20	epp4 	pr6|36,*
005124  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
005125  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1320
	     return;

005126  aa  6 00354 6101 00	rtcd 	pr6|236
						STATEMENT 1 ON LINE 1322
	end interrupt_subchannels_requesting_input;

  END PROCEDURE interrupt_subchannels_requesting
BEGIN PROCEDURE process_available_input_blocks
ENTRY TO process_available_input_blocks                     STATEMENT 1 ON LINE 1329
process_available_input_blocks:
	procedure ();

005127  aa  6 00366 6501 00	spri4	pr6|246
						STATEMENT 1 ON LINE 1336
	     more_input = hmd.flags.input_available;

005130  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005131  aa  7 00070 2351 00	lda  	pr7|56		hmd.input_available
005132  aa   000003 7350 00	als  	3
005133  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
005134  aa  6 00376 7551 00	sta  	pr6|254		more_input
						STATEMENT 1 ON LINE 1338
	     do while (more_input);

005135  aa   000000 0110 03	nop  	0,du
005136  aa  6 00376 2351 00	lda  	pr6|254		more_input
005137  aa   400000 3150 03	cana 	131072,du
005140  aa   000036 6000 04	tze  	30,ic		005176
						STATEMENT 1 ON LINE 1339
		call channel_manager$read (hmd.devx, first_bufferp, more_input, code);

005141  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005142  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
005143  aa  6 01554 2521 00	spri2	pr6|876
005144  aa  6 00374 3521 00	epp2 	pr6|252		first_bufferp
005145  aa  6 01556 2521 00	spri2	pr6|878
005146  aa  6 00376 3521 00	epp2 	pr6|254		more_input
005147  aa  6 01560 2521 00	spri2	pr6|880
005150  aa  6 00101 3521 00	epp2 	pr6|65		code
005151  aa  6 01562 2521 00	spri2	pr6|882
005152  aa  6 01552 6211 00	eax1 	pr6|874
005153  aa   020000 4310 07	fld  	8192,dl
005154  aa  6 00044 3701 20	epp4 	pr6|36,*
005155  la  4 00072 3521 20	epp2 	pr4|58,*		channel_manager$read
005156  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1340
		     if code ^= 0 then go to ERROR_RETURN;

005157  aa  6 00101 2361 00	ldq  	pr6|65		code
005160  aa   773517 6010 04	tnz  	-2225,ic		000677
						STATEMENT 1 ON LINE 1341
		if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
		     call trace_block (first_bufferp, INPUT);

005161  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005162  aa  7 00021 2351 00	lda  	pr7|17		hmd.trace_mode
005163  aa   040000 3150 03	cana 	16384,du
005164  aa   000003 6000 04	tze  	3,ic		005167
005165  aa   010561 3520 04	epp2 	4465,ic		015746 = 000004000000
005166  aa   010071 6700 04	tsp4 	4153,ic		015257
						STATEMENT 1 ON LINE 1343
		if first_bufferp ^= null () then	/* got a block */
		     call process_input_block (first_bufferp);

005167  aa  6 00374 2371 00	ldaq 	pr6|252		first_bufferp
005170  aa   773022 6770 04	eraq 	-2542,ic		000212 = 077777000043 000001000000
005171  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005172  aa   777744 6000 04	tze  	-28,ic		005136
005173  aa   010547 3520 04	epp2 	4455,ic		015742 = 000002000000
005174  aa   000006 6700 04	tsp4 	6,ic		005202
						STATEMENT 1 ON LINE 1345
	     end;

005175  aa   777741 7100 04	tra  	-31,ic		005136
						STATEMENT 1 ON LINE 1347
	     hmd.flags.input_available = "0"b;

005176  aa   010610 2350 04	lda  	4488,ic		016006 = 737777777777
005177  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005200  aa  7 00070 3551 00	ansa 	pr7|56		hmd.input_available
						STATEMENT 1 ON LINE 1349
	     return;

005201  aa  6 00366 6101 00	rtcd 	pr6|246
						STATEMENT 1 ON LINE 1351
	end process_available_input_blocks;

  END PROCEDURE process_available_input_blocks
BEGIN PROCEDURE process_input_block
ENTRY TO process_input_block                                STATEMENT 1 ON LINE 1358
process_input_block:
	procedure (P_first_bufferp);

005202  aa  6 00400 6501 00	spri4	pr6|256
005203  aa  6 00402 2521 00	spri2	pr6|258
						STATEMENT 1 ON LINE 1374
	     first_bufferp = P_first_bufferp;

005204  aa  2 00002 3735 20	epp7 	pr2|2,*		P_first_bufferp
005205  aa  7 00000 3735 20	epp7 	pr7|0,*		P_first_bufferp
005206  aa  6 00410 6535 00	spri7	pr6|264		first_bufferp
						STATEMENT 1 ON LINE 1376
	     next_to_last_bufferp = null ();

005207  aa   773003 2370 04	ldaq 	-2557,ic		000212 = 077777000043 000001000000
005210  aa  6 00414 7571 00	staq 	pr6|268		next_to_last_bufferp
						STATEMENT 1 ON LINE 1377
	     do blockp = first_bufferp repeat (pointer (ttybp, buffer.next)) while (rel (blockp) ^= ""b);

005211  aa  6 00162 6535 00	spri7	pr6|114		blockp
005212  aa  6 00162 6351 20	eaa  	pr6|114,*		blockp
005213  aa   000016 6000 04	tze  	14,ic		005231
						STATEMENT 1 ON LINE 1378
		if buffer.next = 0 then		/* find the last buffer in the chain ... */
		     last_bufferp = blockp;

005214  aa  6 00162 2351 20	lda  	pr6|114,*		buffer.next
005215  aa   000066 7730 00	lrl  	54
005216  aa  6 01564 7561 00	stq  	pr6|884		buffer.next
005217  aa   000004 6010 04	tnz  	4,ic		005223
005220  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
005221  aa  6 00412 6535 00	spri7	pr6|266		last_bufferp
005222  aa   000003 7100 04	tra  	3,ic		005225
						STATEMENT 1 ON LINE 1380
		else next_to_last_bufferp = blockp;

005223  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
005224  aa  6 00414 6535 00	spri7	pr6|268		next_to_last_bufferp
						STATEMENT 1 ON LINE 1381
	     end;

005225  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
005226  aa   000000 3120 06	eawp2	0,ql
005227  aa  6 00162 2521 00	spri2	pr6|114		blockp
005230  aa   777762 7100 04	tra  	-14,ic		005212
						STATEMENT 1 ON LINE 1383
	     if last_bufferp -> buffer.tally > 2 then	/* strip DLE/SYN ETB from end */
		last_bufferp -> buffer.tally = last_bufferp -> buffer.tally - 2;

005231  aa  6 00412 2361 20	ldq  	pr6|266,*		buffer.tally
005232  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005233  aa  6 01564 7561 00	stq  	pr6|884		buffer.tally
005234  aa   000002 1160 07	cmpq 	2,dl
005235  aa   000005 6044 04	tmoz 	5,ic		005242
005236  aa   000002 1760 07	sbq  	2,dl
005237  aa  6 00412 3735 20	epp7 	pr6|266,*		buffer.tally
005240  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
005241  aa   000034 7100 04	tra  	28,ic		005275
						STATEMENT 1 ON LINE 1385
	     else do;

						STATEMENT 1 ON LINE 1386
		if next_to_last_bufferp = null () then go to BAD_INPUT_BLOCK;

005242  aa  6 00414 2371 00	ldaq 	pr6|268		next_to_last_bufferp
005243  aa   772747 6770 04	eraq 	-2585,ic		000212 = 077777000043 000001000000
005244  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005245  aa   000222 6000 04	tze  	146,ic		005467
						STATEMENT 1 ON LINE 1387
		next_to_last_bufferp -> buffer.tally =	/* adjust to flush DLE/SYN ETB sequence */
		     next_to_last_bufferp -> buffer.tally - 2 + last_bufferp -> buffer.tally;

005246  aa  6 00414 2361 20	ldq  	pr6|268,*		buffer.tally
005247  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005250  aa   000002 1760 07	sbq  	2,dl
005251  aa  6 01564 0761 00	adq  	pr6|884		buffer.tally
005252  aa  6 00414 3735 20	epp7 	pr6|268,*		buffer.tally
005253  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1389
		call tty_space_man$free_buffer (hmd.devx, INPUT, last_bufferp);

005254  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005255  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
005256  aa  6 01570 2521 00	spri2	pr6|888
005257  aa   772633 3520 04	epp2 	-2661,ic		000112 = 000000000000
005260  aa  6 01572 2521 00	spri2	pr6|890
005261  aa  6 00412 3521 00	epp2 	pr6|266		last_bufferp
005262  aa  6 01574 2521 00	spri2	pr6|892
005263  aa  6 01566 6211 00	eax1 	pr6|886
005264  aa   014000 4310 07	fld  	6144,dl
005265  aa  6 00044 3701 20	epp4 	pr6|36,*
005266  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
005267  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1390
		next_to_last_bufferp -> buffer.next = 0;

005270  aa   000000 2350 07	lda  	0,dl
005271  aa  6 00414 3735 20	epp7 	pr6|268,*		buffer.next
005272  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 1391
		last_bufferp = next_to_last_bufferp;

005273  aa  6 00414 3715 20	epp5 	pr6|268,*		next_to_last_bufferp
005274  aa  6 00412 6515 00	spri5	pr6|266		last_bufferp
						STATEMENT 1 ON LINE 1392
	     end;

						STATEMENT 1 ON LINE 1394
	     first_char = substr_of_chain (1, 1);

005275  aa   000001 2360 07	ldq  	1,dl
005276  aa  6 01565 7561 00	stq  	pr6|885
005277  aa  6 01564 7561 00	stq  	pr6|884
005300  aa   010432 3520 04	epp2 	4378,ic		015732 = 000006000000
005301  aa   000261 6700 04	tsp4 	177,ic		005562
005302  aa  6 00416 4501 00	stz  	pr6|270		first_char
005303  aa  6 01576 7271 00	lxl7 	pr6|894
005304  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
005305  aa  6 01577 00 0017	desc9a	pr6|895,x7
005306  aa  6 00416 00 0001	desc9a	pr6|270,1		first_char
						STATEMENT 1 ON LINE 1395
	     call delete_leading_text (2);

005307  aa   000002 2360 07	ldq  	2,dl
005310  aa  6 01564 7561 00	stq  	pr6|884
005311  aa   010415 3520 04	epp2 	4365,ic		015726 = 000002000000
005312  aa   000361 6700 04	tsp4 	241,ic		005673
						STATEMENT 1 ON LINE 1397
	     if first_char = DLE then			/* transparent block, remove transparency codes */
		call strip_dles ();

005313  aa  6 00416 2351 00	lda  	pr6|270		first_char
005314  aa   020000 1150 03	cmpa 	8192,du
005315  aa   000002 6010 04	tnz  	2,ic		005317
005316  aa   000430 6700 04	tsp4 	280,ic		005746
						STATEMENT 1 ON LINE 1400
	     foreign_bcb_char = substr_of_chain (1, 1);

005317  aa   000001 2360 07	ldq  	1,dl
005320  aa  6 01564 7561 00	stq  	pr6|884
005321  aa  6 01565 7561 00	stq  	pr6|885
005322  aa   010374 3520 04	epp2 	4348,ic		015716 = 000006000000
005323  aa   000237 6700 04	tsp4 	159,ic		005562
005324  aa  6 00406 4501 00	stz  	pr6|262		foreign_bcb_char
005325  aa  6 01576 7271 00	lxl7 	pr6|894
005326  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
005327  aa  6 01577 00 0017	desc9a	pr6|895,x7
005330  aa  6 00406 00 0001	desc9a	pr6|262,1		foreign_bcb_char
						STATEMENT 1 ON LINE 1401
	     foreign_fcs_chars = substr_of_chain (2, 2);

005331  aa   000002 2360 07	ldq  	2,dl
005332  aa  6 01565 7561 00	stq  	pr6|885
005333  aa  6 01564 7561 00	stq  	pr6|884
005334  aa   010376 3520 04	epp2 	4350,ic		015732 = 000006000000
005335  aa   000225 6700 04	tsp4 	149,ic		005562
005336  aa  6 00407 4501 00	stz  	pr6|263		foreign_fcs_chars
005337  aa  6 01576 7271 00	lxl7 	pr6|894
005340  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
005341  aa  6 01577 00 0017	desc9a	pr6|895,x7
005342  aa  6 00407 00 0002	desc9a	pr6|263,2		foreign_fcs_chars
						STATEMENT 1 ON LINE 1403
	     call delete_leading_text (3);

005343  aa   000003 2360 07	ldq  	3,dl
005344  aa  6 01564 7561 00	stq  	pr6|884
005345  aa   010361 3520 04	epp2 	4337,ic		015726 = 000002000000
005346  aa   000325 6700 04	tsp4 	213,ic		005673
						STATEMENT 1 ON LINE 1406
	     if ^foreign_fcs.returned_data then

		call process_real_input_block ();

005347  aa  6 00407 3735 00	epp7 	pr6|263		foreign_fcs_chars
005350  aa  6 01576 6535 00	spri7	pr6|894
005351  aa  7 00000 2351 00	lda  	pr7|0		foreign_fcs.returned_data
005352  aa   020000 3150 03	cana 	8192,du
005353  aa   000003 6010 04	tnz  	3,ic		005356
005354  aa   000521 6700 04	tsp4 	337,ic		006075
005355  aa   000111 7100 04	tra  	73,ic		005466
						STATEMENT 1 ON LINE 1411
	     else do;

						STATEMENT 1 ON LINE 1418
		if (foreign_fcs.block_type = HASP_FCS_SYNC_BLOCK) then
		     call process_sync_block ();

005356  aa  7 00000 2351 00	lda  	pr7|0		foreign_fcs.block_type
005357  aa   000014 7350 00	als  	12
005360  aa   000106 7730 00	lrl  	70
005361  aa   000003 1160 07	cmpq 	3,dl
005362  aa   000003 6010 04	tnz  	3,ic		005365
005363  aa   001304 6700 04	tsp4 	708,ic		006667
005364  aa   000102 7100 04	tra  	66,ic		005466
						STATEMENT 1 ON LINE 1421
		else if (foreign_bcb_char = hmd.last_loopback_bcb)
		then do;

005365  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
005366  aa  5 00066 2351 00	lda  	pr5|54		hmd.last_loopback_bcb
005367  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
005370  aa  6 00406 1151 00	cmpa 	pr6|262		foreign_bcb_char
005371  aa   000051 6010 04	tnz  	41,ic		005442
						STATEMENT 1 ON LINE 1423
		     call syserr (LOG_AND_PRINT,
			        "hasp_mpx (line ^a): Duplicate loopback block received: BCB = ^3.3b",
			        hmd.name, unspec (hmd.last_loopback_bcb));

005372  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005373  aa   772710 00 0104	desc9a	-2616,68		000302 = 150141163160
005374  aa  6 01600 00 0104	desc9a	pr6|896,68
005375  aa  5 00066 2351 00	lda  	pr5|54
005376  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
005377  aa  6 01564 7551 00	sta  	pr6|884
005400  aa   772563 3520 04	epp2 	-2701,ic		000163 = 000000000000
005401  aa  6 01624 2521 00	spri2	pr6|916
005402  aa  6 01600 3521 00	epp2 	pr6|896
005403  aa  6 01626 2521 00	spri2	pr6|918
005404  aa  5 00000 3521 00	epp2 	pr5|0		hmd.name
005405  aa  6 01630 2521 00	spri2	pr6|920
005406  aa  6 01564 3521 00	epp2 	pr6|884
005407  aa  6 01632 2521 00	spri2	pr6|922
005410  aa   772565 3520 04	epp2 	-2699,ic		000175 = 404000000021
005411  aa  6 01634 2521 00	spri2	pr6|924
005412  aa   772536 3520 04	epp2 	-2722,ic		000150 = 524000000102
005413  aa  6 01636 2521 00	spri2	pr6|926
005414  aa   772540 3520 04	epp2 	-2720,ic		000154 = 526000000040
005415  aa  6 01640 2521 00	spri2	pr6|928
005416  aa   772531 3520 04	epp2 	-2727,ic		000147 = 514000000011
005417  aa  6 01642 2521 00	spri2	pr6|930
005420  aa  6 01622 6211 00	eax1 	pr6|914
005421  aa   020000 4310 07	fld  	8192,dl
005422  aa  6 00044 3701 20	epp4 	pr6|36,*
005423  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
005424  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1426
		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

005425  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005426  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
005427  aa  6 01570 2521 00	spri2	pr6|888
005430  aa   772462 3520 04	epp2 	-2766,ic		000112 = 000000000000
005431  aa  6 01572 2521 00	spri2	pr6|890
005432  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
005433  aa  6 01574 2521 00	spri2	pr6|892
005434  aa  6 01566 6211 00	eax1 	pr6|886
005435  aa   014000 4310 07	fld  	6144,dl
005436  aa  6 00044 3701 20	epp4 	pr6|36,*
005437  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
005440  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1427
		end;

005441  aa   000025 7100 04	tra  	21,ic		005466
						STATEMENT 1 ON LINE 1429
		else do;

						STATEMENT 1 ON LINE 1430
		     hmd.meters.n_wraparound_blocks = hmd.meters.n_wraparound_blocks + 1;

005442  aa  5 00106 2351 00	lda  	pr5|70		hmd.n_wraparound_blocks
005443  aa   000044 7330 00	lrs  	36
005444  aa   000001 0330 07	adl  	1,dl
005445  aa  5 00106 7561 00	stq  	pr5|70		hmd.n_wraparound_blocks
						STATEMENT 1 ON LINE 1431
		     if hmd.loopback.first_bufferp = null () then
			hmd.loopback.first_bufferp = first_bufferp;

005446  aa  5 00046 2371 00	ldaq 	pr5|38		hmd.first_bufferp
005447  aa   772543 6770 04	eraq 	-2717,ic		000212 = 077777000043 000001000000
005450  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005451  aa   000004 6010 04	tnz  	4,ic		005455
005452  aa  6 00410 3535 20	epp3 	pr6|264,*		first_bufferp
005453  aa  5 00046 2535 00	spri3	pr5|38		hmd.first_bufferp
005454  aa   000006 7100 04	tra  	6,ic		005462
						STATEMENT 1 ON LINE 1433
		     else hmd.loopback.last_bufferp -> buffer.next = binary (rel (first_bufferp), 18, 0);

005455  aa  6 00410 6351 20	eaa  	pr6|264,*		first_bufferp
005456  aa   000066 7730 00	lrl  	54
005457  aa   000066 7370 00	lls  	54
005460  aa  5 00050 3535 20	epp3 	pr5|40,*		buffer.next
005461  aa  3 00000 5511 60	stba 	pr3|0,60		buffer.next
						STATEMENT 1 ON LINE 1434
		     hmd.loopback.last_bufferp = last_bufferp;

005462  aa  6 00412 3535 20	epp3 	pr6|266,*		last_bufferp
005463  aa  5 00050 2535 00	spri3	pr5|40		hmd.last_bufferp
						STATEMENT 1 ON LINE 1435
		     hmd.last_loopback_bcb = foreign_bcb_char;

005464  aa  6 00406 2351 00	lda  	pr6|262		foreign_bcb_char
005465  aa  5 00066 5511 40	stba 	pr5|54,40		hmd.last_loopback_bcb
						STATEMENT 1 ON LINE 1436
		end;

						STATEMENT 1 ON LINE 1437
	     end;

						STATEMENT 1 ON LINE 1439
	     return;

005466  aa  6 00400 6101 00	rtcd 	pr6|256
						STATEMENT 1 ON LINE 1445
BAD_INPUT_BLOCK:
	     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

005467  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005470  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
005471  aa  6 01570 2521 00	spri2	pr6|888
005472  aa   772420 3520 04	epp2 	-2800,ic		000112 = 000000000000
005473  aa  6 01572 2521 00	spri2	pr6|890
005474  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
005475  aa  6 01574 2521 00	spri2	pr6|892
005476  aa  6 01566 6211 00	eax1 	pr6|886
005477  aa   014000 4310 07	fld  	6144,dl
005500  aa  6 00044 3701 20	epp4 	pr6|36,*
005501  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
005502  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1448
	     call syserr (LOG_AND_PRINT, "hasp_mpx (line ^a): Invalid input block header/trailer; line will be hungup.", hmd.name);

005503  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
005504  aa   772642 00 0114	desc9a	-2654,76		000345 = 150141163160
005505  aa  6 01644 00 0114	desc9a	pr6|932,76
005506  aa   772455 3520 04	epp2 	-2771,ic		000163 = 000000000000
005507  aa  6 01602 2521 00	spri2	pr6|898
005510  aa  6 01644 3521 00	epp2 	pr6|932
005511  aa  6 01604 2521 00	spri2	pr6|900
005512  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
005513  aa  6 01606 2521 00	spri2	pr6|902
005514  aa   772461 3520 04	epp2 	-2767,ic		000175 = 404000000021
005515  aa  6 01610 2521 00	spri2	pr6|904
005516  aa   772430 3520 04	epp2 	-2792,ic		000146 = 524000000114
005517  aa  6 01612 2521 00	spri2	pr6|906
005520  aa   772434 3520 04	epp2 	-2788,ic		000154 = 526000000040
005521  aa  6 01614 2521 00	spri2	pr6|908
005522  aa  6 01600 6211 00	eax1 	pr6|896
005523  aa   014000 4310 07	fld  	6144,dl
005524  aa  6 00044 3701 20	epp4 	pr6|36,*
005525  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
005526  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1449
	     call channel_manager$control (hmd.devx, "hangup", null (), code);

005527  aa   772455 2370 04	ldaq 	-2771,ic		000204 = 150141156147 165160000000
005530  aa  6 01576 7571 00	staq 	pr6|894
005531  aa   772461 3734 24	epp7 	-2767,ic*
005532  aa  6 01670 6535 00	spri7	pr6|952
005533  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
005534  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
005535  aa  6 01624 2521 00	spri2	pr6|916
005536  aa  6 01576 3521 00	epp2 	pr6|894
005537  aa  6 01626 2521 00	spri2	pr6|918
005540  aa  6 01670 3521 00	epp2 	pr6|952
005541  aa  6 01630 2521 00	spri2	pr6|920
005542  aa  6 00101 3521 00	epp2 	pr6|65		code
005543  aa  6 01632 2521 00	spri2	pr6|922
005544  aa   772431 3520 04	epp2 	-2791,ic		000175 = 404000000021
005545  aa  6 01634 2521 00	spri2	pr6|924
005546  aa   772405 3520 04	epp2 	-2811,ic		000153 = 524000000006
005547  aa  6 01636 2521 00	spri2	pr6|926
005550  aa   772427 3520 04	epp2 	-2793,ic		000177 = 464000000000
005551  aa  6 01640 2521 00	spri2	pr6|928
005552  aa   772421 3520 04	epp2 	-2799,ic		000173 = 404000000043
005553  aa  6 01642 2521 00	spri2	pr6|930
005554  aa  6 01622 6211 00	eax1 	pr6|914
005555  aa   020000 4310 07	fld  	8192,dl
005556  aa  6 00044 3701 20	epp4 	pr6|36,*
005557  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
005560  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1451
	     return;

005561  aa  6 00400 6101 00	rtcd 	pr6|256
						STATEMENT 1 ON LINE 1751
	end process_input_block;

BEGIN PROCEDURE substr_of_chain
ENTRY TO substr_of_chain                                    STATEMENT 1 ON LINE 1455
substr_of_chain:
	     procedure (p_start_idx, p_length) returns (character (4) varying);

005562  aa  6 00420 6501 00	spri4	pr6|272
005563  aa  6 00422 2521 00	spri2	pr6|274
						STATEMENT 1 ON LINE 1462
		blockp = first_bufferp;

005564  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
005565  aa  6 00162 6535 00	spri7	pr6|114		blockp
						STATEMENT 1 ON LINE 1463
		the_text = "";

005566  aa  6 00426 4501 00	stz  	pr6|278		the_text
						STATEMENT 1 ON LINE 1466
		characters_to_skip = p_start_idx - 1;

005567  aa  2 00002 2361 20	ldq  	pr2|2,*		p_start_idx
005570  aa   000001 1760 07	sbq  	1,dl
005571  aa  6 00430 7561 00	stq  	pr6|280		characters_to_skip
						STATEMENT 1 ON LINE 1467
		do while (buffer.tally <= characters_to_skip);

005572  aa  6 00162 2361 20	ldq  	pr6|114,*		buffer.tally
005573  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005574  aa  6 01672 7561 00	stq  	pr6|954		buffer.tally
005575  aa  6 00430 1161 00	cmpq 	pr6|280		characters_to_skip
005576  aa   000014 6054 04	tpnz 	12,ic		005612
						STATEMENT 1 ON LINE 1468
		     if buffer.next = 0 then go to BAD_INPUT_BLOCK;

005577  aa  6 00162 2351 20	lda  	pr6|114,*		buffer.next
005600  aa   000066 7730 00	lrl  	54
005601  aa   777666 6000 04	tze  	-74,ic		005467
						STATEMENT 1 ON LINE 1469
		     characters_to_skip = characters_to_skip - buffer.tally;

005602  aa  6 01673 7561 00	stq  	pr6|955		buffer.next
005603  aa  6 01672 3361 00	lcq  	pr6|954		buffer.tally
005604  aa  6 00430 0561 00	asq  	pr6|280		characters_to_skip
						STATEMENT 1 ON LINE 1470
		     blockp = pointer (ttybp, buffer.next);

005605  aa  6 01673 2361 00	ldq  	pr6|955		buffer.next
005606  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
005607  aa   000000 3120 06	eawp2	0,ql
005610  aa  6 00162 2521 00	spri2	pr6|114		blockp
						STATEMENT 1 ON LINE 1471
		end;

005611  aa   777761 7100 04	tra  	-15,ic		005572
						STATEMENT 1 ON LINE 1474
		start = characters_to_skip;

005612  aa  6 00430 2361 00	ldq  	pr6|280		characters_to_skip
005613  aa  6 00433 7561 00	stq  	pr6|283		start
						STATEMENT 1 ON LINE 1475
		characters_to_pickup = p_length;

005614  aa  6 00422 3735 20	epp7 	pr6|274,*
005615  aa  7 00004 2361 20	ldq  	pr7|4,*		p_length
005616  aa  6 00431 7561 00	stq  	pr6|281		characters_to_pickup
						STATEMENT 1 ON LINE 1476
		do while (characters_to_pickup > 0);

005617  aa   000000 0110 03	nop  	0,du
005620  aa  6 00431 2361 00	ldq  	pr6|281		characters_to_pickup
005621  aa   000042 6044 04	tmoz 	34,ic		005663
						STATEMENT 1 ON LINE 1477
		     characters_in_buffer = min (characters_to_pickup, (buffer.tally - start));

005622  aa  6 00162 2361 20	ldq  	pr6|114,*		buffer.tally
005623  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005624  aa  6 00433 1761 00	sbq  	pr6|283		start
005625  aa  6 00431 1161 00	cmpq 	pr6|281		characters_to_pickup
005626  aa   000002 6040 04	tmi  	2,ic		005630
005627  aa  6 00431 2361 00	ldq  	pr6|281		characters_to_pickup
005630  aa  6 00432 7561 00	stq  	pr6|282		characters_in_buffer
						STATEMENT 1 ON LINE 1478
		     begin;

BEGIN BLOCK  1
PROLOGUE SEQUENCE                                           STATEMENT 1 ON LINE 1479
005631  aa  6 00432 2361 00	ldq  	pr6|282		characters_in_buffer
005632  aa  6 00434 7561 00	stq  	pr6|284
MAIN SEQUENCE                                               STATEMENT 1 ON LINE 1480
			the_text = the_text || text_in_buffer;

005633  aa  6 00433 2351 00	lda  	pr6|283		start
005634  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
005635  aa   000004 2360 07	ldq  	4,dl
005636  aa  6 00426 1761 00	sbq  	pr6|278		the_text
005637  aa  6 00434 1161 00	cmpq 	pr6|284
005640  aa   000002 6040 04	tmi  	2,ic		005642
005641  aa  6 00434 2361 00	ldq  	pr6|284
005642  aa  6 00426 7271 00	lxl7 	pr6|278		the_text
005643  aa  6 00426 0561 00	asq  	pr6|278		the_text
005644  aa  040 157 100 545	mlr  	(pr,rl,al),(pr,rl,x7),fill(040)
005645  aa  7 00001 00 0006	desc9a	pr7|1,ql		text_in_buffer
005646  aa  6 00427 00 0006	desc9a	pr6|279,ql	the_text
						STATEMENT 1 ON LINE 1481
		     end;

  END BLOCK  1
						STATEMENT 1 ON LINE 1482
		     characters_to_pickup = characters_to_pickup - characters_in_buffer;

005647  aa  6 00432 3361 00	lcq  	pr6|282		characters_in_buffer
005650  aa  6 00431 0561 00	asq  	pr6|281		characters_to_pickup
						STATEMENT 1 ON LINE 1483
		     if characters_to_pickup > 0 then do;

005651  aa  6 00431 2361 00	ldq  	pr6|281		characters_to_pickup
005652  aa   777746 6044 04	tmoz 	-26,ic		005620
						STATEMENT 1 ON LINE 1484
			if buffer.next = 0 then go to BAD_INPUT_BLOCK;

005653  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
005654  aa   000066 7730 00	lrl  	54
005655  aa   777612 6000 04	tze  	-118,ic		005467
						STATEMENT 1 ON LINE 1485
			blockp = pointer (ttybp, buffer.next);

005656  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
005657  aa   000000 3120 06	eawp2	0,ql
005660  aa  6 00162 2521 00	spri2	pr6|114		blockp
						STATEMENT 1 ON LINE 1486
			start = 0;

005661  aa  6 00433 4501 00	stz  	pr6|283		start
						STATEMENT 1 ON LINE 1487
		     end;

						STATEMENT 1 ON LINE 1488
		end;

005662  aa   777736 7100 04	tra  	-34,ic		005620
						STATEMENT 1 ON LINE 1490
		return (the_text);

005663  aa  6 00426 2361 00	ldq  	pr6|278		the_text
005664  aa  6 00422 3735 20	epp7 	pr6|274,*
005665  aa  7 00006 3715 20	epp5 	pr7|6,*
005666  aa  5 77777 7561 00	stq  	pr5|-1
005667  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
005670  aa  6 00427 00 0006	desc9a	pr6|279,ql	the_text
005671  aa  5 00000 00 0006	desc9a	pr5|0,ql
005672  aa  6 00420 6101 00	rtcd 	pr6|272
						STATEMENT 1 ON LINE 1492
	     end substr_of_chain;

  END PROCEDURE substr_of_chain
BEGIN PROCEDURE delete_leading_text
ENTRY TO delete_leading_text                                STATEMENT 1 ON LINE 1496
delete_leading_text:
	     procedure (p_n_characters);

005673  aa  6 00436 6501 00	spri4	pr6|286
005674  aa  6 00440 2521 00	spri2	pr6|288
						STATEMENT 1 ON LINE 1502
		blockp = first_bufferp;

005675  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
005676  aa  6 00162 6535 00	spri7	pr6|114		blockp
						STATEMENT 1 ON LINE 1503
		characters_left_to_delete = p_n_characters;

005677  aa  2 00002 2361 20	ldq  	pr2|2,*		p_n_characters
005700  aa  6 00444 7561 00	stq  	pr6|292		characters_left_to_delete
						STATEMENT 1 ON LINE 1506
		do while (buffer.tally <= characters_left_to_delete);

005701  aa   000000 0110 03	nop  	0,du
005702  aa  6 00162 2361 20	ldq  	pr6|114,*		buffer.tally
005703  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005704  aa  6 00444 1161 00	cmpq 	pr6|292		characters_left_to_delete
005705  aa   000033 6054 04	tpnz 	27,ic		005740
						STATEMENT 1 ON LINE 1507
		     if buffer.next ^= 0 then		/* ... there are more buffers */
			first_bufferp = pointer (ttybp, buffer.next);

005706  aa  6 00162 2351 20	lda  	pr6|114,*		buffer.next
005707  aa   000066 7730 00	lrl  	54
005710  aa   777557 6000 04	tze  	-145,ic		005467
005711  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
005712  aa   000000 3120 06	eawp2	0,ql
005713  aa  6 00410 2521 00	spri2	pr6|264		first_bufferp
						STATEMENT 1 ON LINE 1510
		     characters_left_to_delete = characters_left_to_delete - buffer.tally;

005714  aa  6 00162 2361 20	ldq  	pr6|114,*		buffer.tally
005715  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005716  aa  6 01674 7561 00	stq  	pr6|956		buffer.tally
005717  aa  6 01674 3361 00	lcq  	pr6|956		buffer.tally
005720  aa  6 00444 0561 00	asq  	pr6|292		characters_left_to_delete
						STATEMENT 1 ON LINE 1511
		     call tty_space_man$free_buffer (hmd.devx, INPUT, blockp);

005721  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
005722  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
005723  aa  6 01700 2521 00	spri2	pr6|960
005724  aa   772166 3520 04	epp2 	-2954,ic		000112 = 000000000000
005725  aa  6 01702 2521 00	spri2	pr6|962
005726  aa  6 00162 3521 00	epp2 	pr6|114		blockp
005727  aa  6 01704 2521 00	spri2	pr6|964
005730  aa  6 01676 6211 00	eax1 	pr6|958
005731  aa   014000 4310 07	fld  	6144,dl
005732  aa  6 00044 3701 20	epp4 	pr6|36,*
005733  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
005734  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1512
		     blockp = first_bufferp;

005735  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
005736  aa  6 00162 6535 00	spri7	pr6|114		blockp
						STATEMENT 1 ON LINE 1513
		end;

005737  aa   777743 7100 04	tra  	-29,ic		005702
						STATEMENT 1 ON LINE 1516
		if characters_left_to_delete > 0 then call delete_text (blockp, 0, characters_left_to_delete);

005740  aa  6 00444 2361 00	ldq  	pr6|292		characters_left_to_delete
005741  aa   000004 6044 04	tmoz 	4,ic		005745
005742  aa  6 01675 4501 00	stz  	pr6|957
005743  aa   007743 3520 04	epp2 	4067,ic		015706 = 000006000000
005744  aa   007266 6700 04	tsp4 	3766,ic		015232
						STATEMENT 1 ON LINE 1518
		return;

005745  aa  6 00436 6101 00	rtcd 	pr6|286
						STATEMENT 1 ON LINE 1520
	     end delete_leading_text;

  END PROCEDURE delete_leading_text
BEGIN PROCEDURE strip_dles
ENTRY TO strip_dles                                         STATEMENT 1 ON LINE 1524
strip_dles:    procedure ();

005746  aa  6 00446 6501 00	spri4	pr6|294
						STATEMENT 1 ON LINE 1533
		last_was_dle = "0"b;

005747  aa  6 00460 4501 00	stz  	pr6|304		last_was_dle
						STATEMENT 1 ON LINE 1535
		do bufferp = first_bufferp repeat (pointer (ttybp, bufferp -> buffer.next))
			while (rel (bufferp) ^= ""b);

005750  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
005751  aa  6 00454 6535 00	spri7	pr6|300		bufferp
005752  aa  6 00454 6351 20	eaa  	pr6|300,*		bufferp
005753  aa   000121 6000 04	tze  	81,ic		006074
						STATEMENT 1 ON LINE 1538
		     if last_was_dle then
			start = 2;

005754  aa  6 00460 2351 00	lda  	pr6|304		last_was_dle
005755  aa   000004 6000 04	tze  	4,ic		005761
005756  aa   000002 2360 07	ldq  	2,dl
005757  aa  6 00456 7561 00	stq  	pr6|302		start
005760  aa   000003 7100 04	tra  	3,ic		005763
						STATEMENT 1 ON LINE 1540
		     else start = 1;

005761  aa   000001 2360 07	ldq  	1,dl
005762  aa  6 00456 7561 00	stq  	pr6|302		start
						STATEMENT 1 ON LINE 1542
		     last_was_dle = "0"b;

005763  aa  6 00460 4501 00	stz  	pr6|304		last_was_dle
						STATEMENT 1 ON LINE 1544
		     dle_idx = index (substr (buffer_text, start), DLE);

005764  aa   000001 1760 07	sbq  	1,dl
005765  aa  6 01706 7561 00	stq  	pr6|966
005766  aa  6 00454 2361 20	ldq  	pr6|300,*		buffer.tally
005767  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005770  aa  6 01706 1761 00	sbq  	pr6|966
005771  aa  6 00456 7271 00	lxl7 	pr6|302		start
005772  aa  6 00454 3735 20	epp7 	pr6|300,*		bufferp
005773  aa  000 003 124 557	scm  	(pr,rl,x7),(du),mask(000)
005774  aa  7 00000 60 0006	desc9a	pr7|0(3),ql	buffer_text
005775  aa   020000 00 0001	desc9a	8192,1
005776  aa  6 00056 0001 00	arg  	pr6|46
005777  aa  6 00056 2361 00	ldq  	pr6|46
006000  aa   000002 6070 04	ttf  	2,ic		006002
006001  aa   000001 3360 07	lcq  	1,dl
006002  aa   000001 0760 07	adq  	1,dl
006003  aa  6 00457 7561 00	stq  	pr6|303		dle_idx
						STATEMENT 1 ON LINE 1546
		     do while (dle_idx ^= 0);

006004  aa  6 00457 2361 00	ldq  	pr6|303		dle_idx
006005  aa   000061 6000 04	tze  	49,ic		006066
						STATEMENT 1 ON LINE 1548
			dle_idx = dle_idx + start - 1;

006006  aa  6 00456 0761 00	adq  	pr6|302		start
006007  aa   000001 1760 07	sbq  	1,dl
006010  aa  6 00457 7561 00	stq  	pr6|303		dle_idx
						STATEMENT 1 ON LINE 1550
			if dle_idx < (bufferp -> buffer.tally) then
			     call delete_text (bufferp, (dle_idx - 1), 1);

006011  aa  6 00454 2361 20	ldq  	pr6|300,*		buffer.tally
006012  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
006013  aa  6 01706 7561 00	stq  	pr6|966		buffer.tally
006014  aa  6 00457 1161 00	cmpq 	pr6|303		dle_idx
006015  aa   000011 6044 04	tmoz 	9,ic		006026
006016  aa  6 00457 2361 00	ldq  	pr6|303		dle_idx
006017  aa   000001 1760 07	sbq  	1,dl
006020  aa  6 01707 7561 00	stq  	pr6|967
006021  aa   000001 2360 07	ldq  	1,dl
006022  aa  6 01710 7561 00	stq  	pr6|968
006023  aa   007653 3520 04	epp2 	4011,ic		015676 = 000006000000
006024  aa   007206 6700 04	tsp4 	3718,ic		015232
006025  aa   000006 7100 04	tra  	6,ic		006033
						STATEMENT 1 ON LINE 1552
			else do;

						STATEMENT 1 ON LINE 1553
			     bufferp -> buffer.tally = (bufferp -> buffer.tally) - 1;

006026  aa   000001 1760 07	sbq  	1,dl
006027  aa  6 00454 3735 20	epp7 	pr6|300,*		buffer.tally
006030  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1554
			     last_was_dle = "1"b;

006031  aa   400000 2350 03	lda  	131072,du
006032  aa  6 00460 7551 00	sta  	pr6|304		last_was_dle
						STATEMENT 1 ON LINE 1555
			end;

						STATEMENT 1 ON LINE 1557
			start = dle_idx + 1;

006033  aa  6 00457 2361 00	ldq  	pr6|303		dle_idx
006034  aa   000001 0760 07	adq  	1,dl
006035  aa  6 00456 7561 00	stq  	pr6|302		start
						STATEMENT 1 ON LINE 1559
			if start > (bufferp -> buffer.tally) then
			     dle_idx = 0;

006036  aa  6 00454 2361 20	ldq  	pr6|300,*		buffer.tally
006037  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
006040  aa  6 01706 7561 00	stq  	pr6|966		buffer.tally
006041  aa  6 00456 1161 00	cmpq 	pr6|302		start
006042  aa   000003 6050 04	tpl  	3,ic		006045
006043  aa  6 00457 4501 00	stz  	pr6|303		dle_idx
006044  aa   777740 7100 04	tra  	-32,ic		006004
						STATEMENT 1 ON LINE 1561
			else dle_idx = index (substr (buffer_text, start), DLE);

006045  aa  6 00456 2361 00	ldq  	pr6|302		start
006046  aa   000001 1760 07	sbq  	1,dl
006047  aa  6 01710 7561 00	stq  	pr6|968
006050  aa  6 01706 2361 00	ldq  	pr6|966		buffer.tally
006051  aa  6 01710 1761 00	sbq  	pr6|968
006052  aa  6 00456 7271 00	lxl7 	pr6|302		start
006053  aa  6 00454 3735 20	epp7 	pr6|300,*		bufferp
006054  aa  000 003 124 557	scm  	(pr,rl,x7),(du),mask(000)
006055  aa  7 00000 60 0006	desc9a	pr7|0(3),ql	buffer_text
006056  aa   020000 00 0001	desc9a	8192,1
006057  aa  6 00056 0001 00	arg  	pr6|46
006060  aa  6 00056 2361 00	ldq  	pr6|46
006061  aa   000002 6070 04	ttf  	2,ic		006063
006062  aa   000001 3360 07	lcq  	1,dl
006063  aa   000001 0760 07	adq  	1,dl
006064  aa  6 00457 7561 00	stq  	pr6|303		dle_idx
						STATEMENT 1 ON LINE 1562
		     end;

006065  aa   777717 7100 04	tra  	-49,ic		006004
						STATEMENT 1 ON LINE 1563
		end;

006066  aa  6 00454 2351 20	lda  	pr6|300,*		buffer.next
006067  aa   000066 7730 00	lrl  	54
006070  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
006071  aa   000000 3120 06	eawp2	0,ql
006072  aa  6 00454 2521 00	spri2	pr6|300		bufferp
006073  aa   777657 7100 04	tra  	-81,ic		005752
						STATEMENT 1 ON LINE 1565
		return;

006074  aa  6 00446 6101 00	rtcd 	pr6|294
						STATEMENT 1 ON LINE 1567
	     end strip_dles;

  END PROCEDURE strip_dles
BEGIN PROCEDURE process_real_input_block
ENTRY TO process_real_input_block                           STATEMENT 1 ON LINE 1573
process_real_input_block:
	     procedure ();

006075  aa  6 00462 6501 00	spri4	pr6|306
						STATEMENT 1 ON LINE 1584
		if foreign_fcs.device_not_ready then do;

006076  aa  6 00407 2351 00	lda  	pr6|263		foreign_fcs.device_not_ready
006077  aa   040000 3150 03	cana 	16384,du
006100  aa   000016 6000 04	tze  	14,ic		006116
						STATEMENT 1 ON LINE 1585
		     hmd.meters.n_wraparounds = hmd.meters.n_wraparounds + 1;

006101  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006102  aa  7 00105 2351 00	lda  	pr7|69		hmd.n_wraparounds
006103  aa   000044 7330 00	lrs  	36
006104  aa   000001 0330 07	adl  	1,dl
006105  aa  7 00105 7561 00	stq  	pr7|69		hmd.n_wraparounds
						STATEMENT 1 ON LINE 1586
		     unspec (hmd.last_loopback_bcb) = "777"b3;

006106  aa   777000 2350 03	lda  	261632,du
006107  aa  7 00066 5511 40	stba 	pr7|54,40
						STATEMENT 1 ON LINE 1587
		     if hmd.minor_state = HMD_REPROCESS then /* in middle of reprocessing loopback: FNP is ... */
			call push_loopback_block_chain ();

006110  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
006111  aa   000006 1160 07	cmpq 	6,dl
006112  aa   000002 6010 04	tnz  	2,ic		006114
006113  aa   776203 6700 04	tsp4 	-893,ic		004316
						STATEMENT 1 ON LINE 1589
		     call push_minor_state (HMD_SEND_SYNC_BLOCK);

006114  aa   007556 3520 04	epp2 	3950,ic		015672 = 000002000000
006115  aa   775617 6700 04	tsp4 	-1137,ic		003734
						STATEMENT 1 ON LINE 1590
		end;

						STATEMENT 1 ON LINE 1597
		expected_count = mod (hmd.foreign_block_count + 1, 16);

006116  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006117  aa  7 00032 2361 00	ldq  	pr7|26		hmd.foreign_block_count
006120  aa   000001 0760 07	adq  	1,dl
006121  aa   007740 3520 04	epp2 	4064,ic		016061 = 000000000020
006122  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
006123  aa  6 00472 7561 00	stq  	pr6|314		expected_count
						STATEMENT 1 ON LINE 1598
		received_count = foreign_bcb.count;

006124  aa  6 00406 2351 00	lda  	pr6|262		foreign_bcb.count
006125  aa   000005 7350 00	als  	5
006126  aa   000104 7730 00	lrl  	68
006127  aa  6 00473 7561 00	stq  	pr6|315		received_count
						STATEMENT 1 ON LINE 1600
		if foreign_bcb.type = HASP_BCB_NORMAL then
		     if hmd.first_foreign_block
		     then do;

006130  aa  6 00406 2351 00	lda  	pr6|262		foreign_bcb.type
006131  aa   000002 7350 00	als  	2
006132  aa   000105 7730 00	lrl  	69
006133  aa  6 01711 7561 00	stq  	pr6|969		foreign_bcb.type
006134  aa   000211 6010 04	tnz  	137,ic		006345
006135  aa  7 00070 2351 00	lda  	pr7|56		hmd.first_foreign_block
006136  aa   010000 3150 03	cana 	4096,du
006137  aa   000006 6000 04	tze  	6,ic		006145
						STATEMENT 1 ON LINE 1603
			hmd.first_foreign_block = "0"b;

006140  aa   007531 2350 04	lda  	3929,ic		015671 = 767777777777
006141  aa  7 00070 3551 00	ansa 	pr7|56		hmd.first_foreign_block
						STATEMENT 1 ON LINE 1604
			hmd.foreign_block_count = received_count;

006142  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006143  aa  7 00032 7561 00	stq  	pr7|26		hmd.foreign_block_count
						STATEMENT 1 ON LINE 1605
		     end;

006144  aa   000211 7100 04	tra  	137,ic		006355
						STATEMENT 1 ON LINE 1606
		     else if received_count = expected_count then /* correct value:  remember it */
			hmd.foreign_block_count = received_count;

006145  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006146  aa  6 00472 1161 00	cmpq 	pr6|314		expected_count
006147  aa   000003 6010 04	tnz  	3,ic		006152
006150  aa  7 00032 7561 00	stq  	pr7|26		hmd.foreign_block_count
006151  aa   000204 7100 04	tra  	132,ic		006355
						STATEMENT 1 ON LINE 1608
		     else				/* bad block count -- determine appropriate action */
		     if ((received_count < expected_count) & ((expected_count - received_count) <= 3)) |
		        ((received_count > expected_count) & ((expected_count - received_count + 16) <= 3))
		     then do;

006152  aa  6 00472 2361 00	ldq  	pr6|314		expected_count
006153  aa  6 00473 1761 00	sbq  	pr6|315		received_count
006154  aa  6 01712 7561 00	stq  	pr6|970
006155  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006156  aa  6 00472 1161 00	cmpq 	pr6|314		expected_count
006157  aa   000004 6050 04	tpl  	4,ic		006163
006160  aa  6 01712 2361 00	ldq  	pr6|970
006161  aa   000003 1160 07	cmpq 	3,dl
006162  aa   000010 6044 04	tmoz 	8,ic		006172
006163  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006164  aa  6 00472 1161 00	cmpq 	pr6|314		expected_count
006165  aa   000101 6044 04	tmoz 	65,ic		006266
006166  aa  6 01712 2361 00	ldq  	pr6|970
006167  aa  2 00000 0761 00	adq  	pr2|0
006170  aa   000003 1160 07	cmpq 	3,dl
006171  aa   000075 6054 04	tpnz 	61,ic		006266
						STATEMENT 1 ON LINE 1612
			hmd.meters.n_duplicate_input_blocks = hmd.meters.n_duplicate_input_blocks + 1;

006172  aa  7 00101 2351 00	lda  	pr7|65		hmd.n_duplicate_input_blocks
006173  aa   000044 7330 00	lrs  	36
006174  aa   000001 0330 07	adl  	1,dl
006175  aa  7 00101 7561 00	stq  	pr7|65		hmd.n_duplicate_input_blocks
						STATEMENT 1 ON LINE 1613
			call syserr (LOG_ONLY,
				   "hasp_mpx (line ^a): Block received out of sequence: expected = ^d, received = ^d; block ignored.",
				   hmd.name, expected_count, received_count);

006176  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006177  aa   772244 00 0140	desc9a	-2908,96		000442 = 150141163160
006200  aa  6 01714 00 0140	desc9a	pr6|972,96
006201  aa   771763 3520 04	epp2 	-3085,ic		000164 = 000000000005
006202  aa  6 01746 2521 00	spri2	pr6|998
006203  aa  6 01714 3521 00	epp2 	pr6|972
006204  aa  6 01750 2521 00	spri2	pr6|1000
006205  aa  7 00000 3521 00	epp2 	pr7|0		hmd.name
006206  aa  6 01752 2521 00	spri2	pr6|1002
006207  aa  6 00472 3521 00	epp2 	pr6|314		expected_count
006210  aa  6 01754 2521 00	spri2	pr6|1004
006211  aa  6 00473 3521 00	epp2 	pr6|315		received_count
006212  aa  6 01756 2521 00	spri2	pr6|1006
006213  aa   771762 3520 04	epp2 	-3086,ic		000175 = 404000000021
006214  aa  6 01760 2521 00	spri2	pr6|1008
006215  aa  6 01766 2521 00	spri2	pr6|1014
006216  aa  6 01770 2521 00	spri2	pr6|1016
006217  aa   771726 3520 04	epp2 	-3114,ic		000145 = 524000000140
006220  aa  6 01762 2521 00	spri2	pr6|1010
006221  aa   771733 3520 04	epp2 	-3109,ic		000154 = 526000000040
006222  aa  6 01764 2521 00	spri2	pr6|1012
006223  aa  6 01744 6211 00	eax1 	pr6|996
006224  aa   024000 4310 07	fld  	10240,dl
006225  aa  6 00044 3701 20	epp4 	pr6|36,*
006226  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
006227  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1616
			first_bufferp -> buffer.tally = 1;

006230  aa   000001 2350 07	lda  	1,dl
006231  aa  6 00410 3735 20	epp7 	pr6|264,*		buffer.tally
006232  aa  7 00000 5511 04	stba 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1617
			first_bufferp -> buffer.chars (0) = HASP_EOB_RCB;

006233  aa   771671 2350 04	lda  	-3143,ic		000124 = 000000000000
006234  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
006235  aa  7 00001 5511 40	stba 	pr7|1,40		buffer.chars
						STATEMENT 1 ON LINE 1618
			last_bufferp = first_bufferp;

006236  aa  6 00412 6535 00	spri7	pr6|266		last_bufferp
						STATEMENT 1 ON LINE 1619
			chain_to_release_ptr = pointer (ttybp, first_bufferp -> buffer.next);

006237  aa  6 00410 2351 20	lda  	pr6|264,*		buffer.next
006240  aa   000066 7730 00	lrl  	54
006241  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
006242  aa   000000 3120 06	eawp2	0,ql
006243  aa  6 00470 2521 00	spri2	pr6|312		chain_to_release_ptr
						STATEMENT 1 ON LINE 1620
			first_bufferp -> buffer.next = 0;

006244  aa   000000 2350 07	lda  	0,dl
006245  aa  6 00410 3735 20	epp7 	pr6|264,*		buffer.next
006246  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 1621
			if rel (chain_to_release_ptr) ^= ""b then    /* some data to be discarded */
			     call tty_space_man$free_chain (hmd.devx, INPUT, chain_to_release_ptr);

006247  aa  2 00000 6351 00	eaa  	pr2|0		chain_to_release_ptr
006250  aa   000105 6000 04	tze  	69,ic		006355
006251  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
006252  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
006253  aa  6 01746 2521 00	spri2	pr6|998
006254  aa   771636 3520 04	epp2 	-3170,ic		000112 = 000000000000
006255  aa  6 01750 2521 00	spri2	pr6|1000
006256  aa  6 00470 3521 00	epp2 	pr6|312		chain_to_release_ptr
006257  aa  6 01752 2521 00	spri2	pr6|1002
006260  aa  6 01744 6211 00	eax1 	pr6|996
006261  aa   014000 4310 07	fld  	6144,dl
006262  aa  6 00044 3701 20	epp4 	pr6|36,*
006263  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
006264  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1623
		     end;

006265  aa   000070 7100 04	tra  	56,ic		006355
						STATEMENT 1 ON LINE 1624
		     else do;

						STATEMENT 1 ON LINE 1625
			call syserr (LOG_AND_PRINT,
				   "hasp_mpx (line ^a): Block received out of sequence: expected = ^d, received = ^d; line will be hungup.",
				   hmd.name, expected_count, received_count);

006266  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006267  aa   772204 00 0150	desc9a	-2940,104		000472 = 150141163160
006270  aa  6 01772 00 0150	desc9a	pr6|1018,104
006271  aa   771672 3520 04	epp2 	-3142,ic		000163 = 000000000000
006272  aa  6 01746 2521 00	spri2	pr6|998
006273  aa  6 01772 3521 00	epp2 	pr6|1018
006274  aa  6 01750 2521 00	spri2	pr6|1000
006275  aa  7 00000 3521 00	epp2 	pr7|0		hmd.name
006276  aa  6 01752 2521 00	spri2	pr6|1002
006277  aa  6 00472 3521 00	epp2 	pr6|314		expected_count
006300  aa  6 01754 2521 00	spri2	pr6|1004
006301  aa  6 00473 3521 00	epp2 	pr6|315		received_count
006302  aa  6 01756 2521 00	spri2	pr6|1006
006303  aa   771672 3520 04	epp2 	-3142,ic		000175 = 404000000021
006304  aa  6 01760 2521 00	spri2	pr6|1008
006305  aa  6 01766 2521 00	spri2	pr6|1014
006306  aa  6 01770 2521 00	spri2	pr6|1016
006307  aa   771635 3520 04	epp2 	-3171,ic		000144 = 524000000146
006310  aa  6 01762 2521 00	spri2	pr6|1010
006311  aa   771643 3520 04	epp2 	-3165,ic		000154 = 526000000040
006312  aa  6 01764 2521 00	spri2	pr6|1012
006313  aa  6 01744 6211 00	eax1 	pr6|996
006314  aa   024000 4310 07	fld  	10240,dl
006315  aa  6 00044 3701 20	epp4 	pr6|36,*
006316  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
006317  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1628
			call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

006320  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006321  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
006322  aa  6 01746 2521 00	spri2	pr6|998
006323  aa   771567 3520 04	epp2 	-3209,ic		000112 = 000000000000
006324  aa  6 01750 2521 00	spri2	pr6|1000
006325  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
006326  aa  6 01752 2521 00	spri2	pr6|1002
006327  aa  6 01744 6211 00	eax1 	pr6|996
006330  aa   014000 4310 07	fld  	6144,dl
006331  aa  6 00044 3701 20	epp4 	pr6|36,*
006332  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
006333  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1629
			hmd.minor_state = HMD_SEND_BAD_BCB_BLOCK;

006334  aa   000007 2360 07	ldq  	7,dl
006335  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006336  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
						STATEMENT 1 ON LINE 1630
			hmd.foreign_block_count = received_count;

006337  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006340  aa  7 00032 7561 00	stq  	pr7|26		hmd.foreign_block_count
						STATEMENT 1 ON LINE 1631
			hmd.local_block_count = expected_count;

006341  aa  6 00472 2361 00	ldq  	pr6|314		expected_count
006342  aa  7 00034 7561 00	stq  	pr7|28		hmd.local_block_count
						STATEMENT 1 ON LINE 1632
			return;

006343  aa  6 00462 6101 00	rtcd 	pr6|306
						STATEMENT 1 ON LINE 1633
		     end;

006344  aa   000011 7100 04	tra  	9,ic		006355
						STATEMENT 1 ON LINE 1635
		else if foreign_bcb.type = HASP_BCB_IGNORE
		     then;

006345  aa   000001 1160 07	cmpq 	1,dl
006346  aa   000002 6010 04	tnz  	2,ic		006350
006347  aa   000006 7100 04	tra  	6,ic		006355
						STATEMENT 1 ON LINE 1638
		else if foreign_bcb.type = HASP_BCB_RESET then
		     hmd.foreign_block_count = received_count - 1;

006350  aa   000002 1160 07	cmpq 	2,dl
006351  aa   000004 6010 04	tnz  	4,ic		006355
006352  aa  6 00473 2361 00	ldq  	pr6|315		received_count
006353  aa   000001 1760 07	sbq  	1,dl
006354  aa  7 00032 7561 00	stq  	pr7|26		hmd.foreign_block_count
						STATEMENT 1 ON LINE 1645
		hmd.meters.n_input_blocks = hmd.meters.n_input_blocks + 1;

006355  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006356  aa  7 00077 2351 00	lda  	pr7|63		hmd.n_input_blocks
006357  aa   000044 7330 00	lrs  	36
006360  aa   000001 0330 07	adl  	1,dl
006361  aa  7 00077 7561 00	stq  	pr7|63		hmd.n_input_blocks
						STATEMENT 1 ON LINE 1647
		string (foreign_fcs.mcs1) = ""b;

006362  aa   007306 2350 04	lda  	3782,ic		015670 = 717777777777
006363  aa  6 00407 3551 00	ansa 	pr6|263
						STATEMENT 1 ON LINE 1648
		foreign_fcs.block_type = HASP_FCS_NORMAL_BLOCK;

006364  aa   000000 2350 03	lda  	0,du
006365  aa  6 00407 6751 00	era  	pr6|263		foreign_fcs.block_type
006366  aa   000060 3750 03	ana  	48,du
006367  aa  6 00407 6551 00	ersa 	pr6|263		foreign_fcs.block_type
						STATEMENT 1 ON LINE 1650
		if hmd.foreign_fcs_bytes ^= foreign_fcs_chars then do;

006370  aa  7 00033 2351 00	lda  	pr7|27		hmd.foreign_fcs_bytes
006371  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
006372  aa  6 00407 1151 00	cmpa 	pr6|263		foreign_fcs_chars
006373  aa   000105 6000 04	tze  	69,ic		006500
						STATEMENT 1 ON LINE 1652
		     hmd.foreign_fcs_bytes = foreign_fcs_chars;

006374  aa  6 00407 2351 00	lda  	pr6|263		foreign_fcs_chars
006375  aa  7 00033 7551 00	sta  	pr7|27		hmd.foreign_fcs_bytes
						STATEMENT 1 ON LINE 1654
		     if foreign_fcs.system_wab & ^hmd.suspend_all_output then
			hmd.meters.n_foreign_wab_set = hmd.meters.n_foreign_wab_set + 1;

006376  aa  6 00407 2351 00	lda  	pr6|263		foreign_fcs.system_wab
006377  aa   000002 7350 00	als  	2
006400  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
006401  aa  6 01711 7551 00	sta  	pr6|969		foreign_fcs.system_wab
006402  aa   000010 6000 04	tze  	8,ic		006412
006403  aa  7 00070 2351 00	lda  	pr7|56		hmd.suspend_all_output
006404  aa   400000 3150 03	cana 	131072,du
006405  aa   000005 6010 04	tnz  	5,ic		006412
006406  aa  7 00102 2351 00	lda  	pr7|66		hmd.n_foreign_wab_set
006407  aa   000044 7330 00	lrs  	36
006410  aa   000001 0330 07	adl  	1,dl
006411  aa  7 00102 7561 00	stq  	pr7|66		hmd.n_foreign_wab_set
						STATEMENT 1 ON LINE 1658
		     hmd.suspend_all_output = foreign_fcs.system_wab;

006412  aa  6 01711 2351 00	lda  	pr6|969		foreign_fcs.system_wab
006413  aa  7 00070 6751 00	era  	pr7|56		hmd.suspend_all_output
006414  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
006415  aa  7 00070 6551 00	ersa 	pr7|56		hmd.suspend_all_output
						STATEMENT 1 ON LINE 1660
		     do idx = 1 to hmd.n_subchannels;

006416  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
006417  aa  6 00477 7561 00	stq  	pr6|319
006420  aa   000001 2360 07	ldq  	1,dl
006421  aa  6 00475 7561 00	stq  	pr6|317		idx
006422  aa  6 00475 2361 00	ldq  	pr6|317		idx
006423  aa  6 00477 1161 00	cmpq 	pr6|319
006424  aa   000054 6054 04	tpnz 	44,ic		006500
						STATEMENT 1 ON LINE 1662
			if hmd.subchannels(idx).direction = HSTE_INPUT_ONLY
			     then;

006425  aa   000050 4020 07	mpy  	40,dl
006426  aa  6 01711 7561 00	stq  	pr6|969
006427  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006430  aa  7 00050 2361 06	ldq  	pr7|40,ql		hmd.direction
006431  aa   000001 1160 07	cmpq 	1,dl
006432  aa   000002 6010 04	tnz  	2,ic		006434
006433  aa   000043 7100 04	tra  	35,ic		006476
						STATEMENT 1 ON LINE 1665
			else do;

						STATEMENT 1 ON LINE 1666
			     if (hmd.subchannels(idx).device_wab_idx = 0) then
				new_wab_bit = foreign_fcs.console_wab;

006434  aa  6 01711 7271 00	lxl7 	pr6|969
006435  aa  7 00053 2361 17	ldq  	pr7|43,7		hmd.device_wab_idx
006436  aa   000006 6010 04	tnz  	6,ic		006444
006437  aa  6 00407 2351 00	lda  	pr6|263		foreign_fcs.console_wab
006440  aa   000013 7350 00	als  	11
006441  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
006442  aa  6 00476 7551 00	sta  	pr6|318		new_wab_bit
006443  aa   000014 7100 04	tra  	12,ic		006457
						STATEMENT 1 ON LINE 1668
			     else if (hmd.subchannels(idx).device_wab_idx <= 4) then
				new_wab_bit = foreign_fcs.wab_bits1 (hmd.subchannels(idx).device_wab_idx);

006444  aa   000004 1160 07	cmpq 	4,dl
006445  aa   000006 6054 04	tpnz 	6,ic		006453
006446  aa  6 00476 4501 00	stz  	pr6|318		new_wab_bit
006447  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
006450  aa  6 00407 04 0001	descb	pr6|263(4),1	foreign_fcs.wab_bits1
006451  aa  6 00476 00 0001	descb	pr6|318,1		new_wab_bit
006452  aa   000005 7100 04	tra  	5,ic		006457
						STATEMENT 1 ON LINE 1670
			     else new_wab_bit = foreign_fcs.wab_bits2 (hmd.subchannels(idx).device_wab_idx - 4);

006453  aa  6 00476 4501 00	stz  	pr6|318		new_wab_bit
006454  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
006455  aa  6 00407 20 0001	descb	pr6|263(9),1	foreign_fcs.wab_bits2
006456  aa  6 00476 00 0001	descb	pr6|318,1		new_wab_bit
						STATEMENT 1 ON LINE 1671
			     if ^new_wab_bit & hmd.output_wabs (hmd.subchannels(idx).device_wab_idx) then
				hmd.subchannels(idx).meters.device_n_foreign_wab_set =
				     hmd.subchannels(idx).meters.device_n_foreign_wab_set + 1;

006457  aa  6 00476 2351 00	lda  	pr6|318		new_wab_bit
006460  aa   000012 6010 04	tnz  	10,ic		006472
006461  aa  7 00053 7261 17	lxl6 	pr7|43,7		hmd.device_wab_idx
006462  aa  000 000 066 516	cmpb 	(pr,x6),(),fill(0)
006463  aa  7 00067 20 0001	descb	pr7|55(9),1	hmd.output_wabs
006464  aa   000000 00 0000	descb	0,0
006465  aa   000005 6000 04	tze  	5,ic		006472
006466  aa  7 00106 2351 17	lda  	pr7|70,7		hmd.device_n_foreign_wab_set
006467  aa   000044 7330 00	lrs  	36
006470  aa   000001 0330 07	adl  	1,dl
006471  aa  7 00106 7561 17	stq  	pr7|70,7		hmd.device_n_foreign_wab_set
						STATEMENT 1 ON LINE 1674
			     hmd.output_wabs (hmd.subchannels(idx).device_wab_idx) = new_wab_bit;

006472  aa  7 00053 7261 17	lxl6 	pr7|43,7		hmd.device_wab_idx
006473  aa  003 116 060 500	csl  	(pr),(pr,x6),fill(0),bool(move)
006474  aa  6 00476 00 0001	descb	pr6|318,1		new_wab_bit
006475  aa  7 00067 20 0001	descb	pr7|55(9),1	hmd.output_wabs
						STATEMENT 1 ON LINE 1675
			end;

						STATEMENT 1 ON LINE 1676
		     end;

006476  aa  6 00475 0541 00	aos  	pr6|317		idx
006477  aa   777723 7100 04	tra  	-45,ic		006422
						STATEMENT 1 ON LINE 1677
		end;

						STATEMENT 1 ON LINE 1684
		record_type = classify_record (first_bufferp, 0);

006500  aa  6 01711 4501 00	stz  	pr6|969
006501  aa   007157 3520 04	epp2 	3695,ic		015660 = 000006000000
006502  aa   006232 6700 04	tsp4 	3226,ic		014734
						STATEMENT 1 ON LINE 1686
		if record_type = HASP_EOB_RECORD
		then do;

006503  aa  6 00474 2361 00	ldq  	pr6|316		record_type
006504  aa   000001 1160 07	cmpq 	1,dl
006505  aa   000017 6010 04	tnz  	15,ic		006524
						STATEMENT 1 ON LINE 1689
		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

006506  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006507  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
006510  aa  6 01746 2521 00	spri2	pr6|998
006511  aa   771401 3520 04	epp2 	-3327,ic		000112 = 000000000000
006512  aa  6 01750 2521 00	spri2	pr6|1000
006513  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
006514  aa  6 01752 2521 00	spri2	pr6|1002
006515  aa  6 01744 6211 00	eax1 	pr6|996
006516  aa   014000 4310 07	fld  	6144,dl
006517  aa  6 00044 3701 20	epp4 	pr6|36,*
006520  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
006521  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1690
		     call interrupt_subchannels_with_output ();

006522  aa   776155 6700 04	tsp4 	-915,ic		004677
						STATEMENT 1 ON LINE 1691
		end;

006523  aa   000143 7100 04	tra  	99,ic		006666
						STATEMENT 1 ON LINE 1693
		else if record_type = HASP_BAD_BCB_RECORD
		then do;

006524  aa   000006 1160 07	cmpq 	6,dl
006525  aa   000121 6010 04	tnz  	81,ic		006646
						STATEMENT 1 ON LINE 1695
		     received_count = foreign_bcb.count;

006526  aa  6 00406 2351 00	lda  	pr6|262		foreign_bcb.count
006527  aa   000005 7350 00	als  	5
006530  aa   000104 7730 00	lrl  	68
006531  aa  6 00473 7561 00	stq  	pr6|315		received_count
						STATEMENT 1 ON LINE 1696
		     expected_count = addr (addr (first_bufferp -> buffer.chars (0)) -> based_bad_bcb_record.srcb) -> hasp_bcb_byte.count;

006532  aa   000001 7270 07	lxl7 	1,dl
006533  aa  6 00410 3735 20	epp7 	pr6|264,*		first_bufferp
006534  aa  7 00001 3735 00	epp7 	pr7|1		based_bad_bcb_record.srcb
006535  aa  7 00000 5005 17	a9bd 	pr7|0,7
006536  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
006537  aa  7 00000 05 0004	descb	pr7|0(5),4	hasp_bcb_byte.count
006540  aa  6 00056 00 0044	descb	pr6|46,36
006541  aa  6 00056 2351 00	lda  	pr6|46
006542  aa   000104 7730 00	lrl  	68
006543  aa  6 00472 7561 00	stq  	pr6|314		expected_count
						STATEMENT 1 ON LINE 1697
		     call syserr (LOG_AND_PRINT,
			        "hasp_mpx (line ^a): Block transmitted out of sequence: expected = ^d, received = ^d; line will be hungup.",
			        hmd.name, expected_count, received_count);

006544  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006545  aa   771760 00 0154	desc9a	-3088,108		000524 = 150141163160
006546  aa  6 02024 00 0154	desc9a	pr6|1044,108
006547  aa   771414 3520 04	epp2 	-3316,ic		000163 = 000000000000
006550  aa  6 01746 2521 00	spri2	pr6|998
006551  aa  6 02024 3521 00	epp2 	pr6|1044
006552  aa  6 01750 2521 00	spri2	pr6|1000
006553  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
006554  aa  6 01752 2521 00	spri2	pr6|1002
006555  aa  6 00472 3521 00	epp2 	pr6|314		expected_count
006556  aa  6 01754 2521 00	spri2	pr6|1004
006557  aa  6 00473 3521 00	epp2 	pr6|315		received_count
006560  aa  6 01756 2521 00	spri2	pr6|1006
006561  aa   771414 3520 04	epp2 	-3316,ic		000175 = 404000000021
006562  aa  6 01760 2521 00	spri2	pr6|1008
006563  aa  6 01766 2521 00	spri2	pr6|1014
006564  aa  6 01770 2521 00	spri2	pr6|1016
006565  aa   771355 3520 04	epp2 	-3347,ic		000142 = 524000000151
006566  aa  6 01762 2521 00	spri2	pr6|1010
006567  aa   771365 3520 04	epp2 	-3339,ic		000154 = 526000000040
006570  aa  6 01764 2521 00	spri2	pr6|1012
006571  aa  6 01744 6211 00	eax1 	pr6|996
006572  aa   024000 4310 07	fld  	10240,dl
006573  aa  6 00044 3701 20	epp4 	pr6|36,*
006574  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
006575  aa  6 02060 6535 00	spri7	pr6|1072
006576  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1700
		     call channel_manager$control (hmd.devx, "hangup", null (), code);

006577  aa   771405 2370 04	ldaq 	-3323,ic		000204 = 150141156147 165160000000
006600  aa  6 02062 7571 00	staq 	pr6|1074
006601  aa   771411 3734 24	epp7 	-3319,ic*
006602  aa  6 02064 6535 00	spri7	pr6|1076
006603  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
006604  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
006605  aa  6 01746 2521 00	spri2	pr6|998
006606  aa  6 02062 3521 00	epp2 	pr6|1074
006607  aa  6 01750 2521 00	spri2	pr6|1000
006610  aa  6 02064 3521 00	epp2 	pr6|1076
006611  aa  6 01752 2521 00	spri2	pr6|1002
006612  aa  6 00101 3521 00	epp2 	pr6|65		code
006613  aa  6 01754 2521 00	spri2	pr6|1004
006614  aa   771361 3520 04	epp2 	-3343,ic		000175 = 404000000021
006615  aa  6 01756 2521 00	spri2	pr6|1006
006616  aa   771335 3520 04	epp2 	-3363,ic		000153 = 524000000006
006617  aa  6 01760 2521 00	spri2	pr6|1008
006620  aa   771357 3520 04	epp2 	-3345,ic		000177 = 464000000000
006621  aa  6 01762 2521 00	spri2	pr6|1010
006622  aa   771351 3520 04	epp2 	-3351,ic		000173 = 404000000043
006623  aa  6 01764 2521 00	spri2	pr6|1012
006624  aa  6 01744 6211 00	eax1 	pr6|996
006625  aa   020000 4310 07	fld  	8192,dl
006626  aa  6 00044 3701 20	epp4 	pr6|36,*
006627  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
006630  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1701
		     call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

006631  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006632  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
006633  aa  6 01746 2521 00	spri2	pr6|998
006634  aa   771256 3520 04	epp2 	-3410,ic		000112 = 000000000000
006635  aa  6 01750 2521 00	spri2	pr6|1000
006636  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
006637  aa  6 01752 2521 00	spri2	pr6|1002
006640  aa  6 01744 6211 00	eax1 	pr6|996
006641  aa   014000 4310 07	fld  	6144,dl
006642  aa  6 00044 3701 20	epp4 	pr6|36,*
006643  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
006644  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1702
		end;

006645  aa   000021 7100 04	tra  	17,ic		006666
						STATEMENT 1 ON LINE 1704
		else do;

						STATEMENT 1 ON LINE 1705
		     if hmd.input.first_bufferp = null () then
			hmd.input.first_bufferp = first_bufferp;

006646  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006647  aa  7 00042 2371 00	ldaq 	pr7|34		hmd.first_bufferp
006650  aa   771342 6770 04	eraq 	-3358,ic		000212 = 077777000043 000001000000
006651  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006652  aa   000004 6010 04	tnz  	4,ic		006656
006653  aa  6 00410 3715 20	epp5 	pr6|264,*		first_bufferp
006654  aa  7 00042 6515 00	spri5	pr7|34		hmd.first_bufferp
006655  aa   000006 7100 04	tra  	6,ic		006663
						STATEMENT 1 ON LINE 1707
		     else hmd.input.last_bufferp -> buffer.next = binary (rel (first_bufferp), 18, 0);

006656  aa  6 00410 6351 20	eaa  	pr6|264,*		first_bufferp
006657  aa   000066 7730 00	lrl  	54
006660  aa   000066 7370 00	lls  	54
006661  aa  7 00044 3715 20	epp5 	pr7|36,*		buffer.next
006662  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 1708
		     hmd.input.last_bufferp = last_bufferp;

006663  aa  6 00412 3715 20	epp5 	pr6|266,*		last_bufferp
006664  aa  7 00044 6515 00	spri5	pr7|36		hmd.last_bufferp
						STATEMENT 1 ON LINE 1709
		     call interrupt_subchannels_with_output ();

006665  aa   776012 6700 04	tsp4 	-1014,ic		004677
						STATEMENT 1 ON LINE 1710
		end;

						STATEMENT 1 ON LINE 1712
		return;

006666  aa  6 00462 6101 00	rtcd 	pr6|306
						STATEMENT 1 ON LINE 1714
	     end process_real_input_block;

  END PROCEDURE process_real_input_block
BEGIN PROCEDURE process_sync_block
ENTRY TO process_sync_block                                 STATEMENT 1 ON LINE 1722
process_sync_block:
	     procedure ();

006667  aa  6 00500 6501 00	spri4	pr6|320
						STATEMENT 1 ON LINE 1727
		call tty_space_man$free_chain (hmd.devx, INPUT, first_bufferp);

006670  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006671  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
006672  aa  6 02070 2521 00	spri2	pr6|1080
006673  aa   771217 3520 04	epp2 	-3441,ic		000112 = 000000000000
006674  aa  6 02072 2521 00	spri2	pr6|1082
006675  aa  6 00410 3521 00	epp2 	pr6|264		first_bufferp
006676  aa  6 02074 2521 00	spri2	pr6|1084
006677  aa  6 02066 6211 00	eax1 	pr6|1078
006700  aa   014000 4310 07	fld  	6144,dl
006701  aa  6 00044 3701 20	epp4 	pr6|36,*
006702  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
006703  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1730
		if hmd.minor_state > HMD_REPROCESS then
		     return;

006704  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006705  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
006706  aa   000006 1160 07	cmpq 	6,dl
006707  aa   000002 6044 04	tmoz 	2,ic		006711
006710  aa  6 00500 6101 00	rtcd 	pr6|320
						STATEMENT 1 ON LINE 1733
		if hmd.minor_state_stack = null () then
		     previous_minor_state = HMD_NORMAL;

006711  aa  7 00062 2371 00	ldaq 	pr7|50		hmd.minor_state_stack
006712  aa   771300 6770 04	eraq 	-3392,ic		000212 = 077777000043 000001000000
006713  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006714  aa   000004 6010 04	tnz  	4,ic		006720
006715  aa   000003 2360 07	ldq  	3,dl
006716  aa  6 00506 7561 00	stq  	pr6|326		previous_minor_state
006717  aa   000004 7100 04	tra  	4,ic		006723
						STATEMENT 1 ON LINE 1735
		else previous_minor_state = hmd.minor_state_stack -> msse.minor_state;

006720  aa  7 00062 3715 20	epp5 	pr7|50,*		hmd.minor_state_stack
006721  aa  5 00002 2361 00	ldq  	pr5|2		msse.minor_state
006722  aa  6 00506 7561 00	stq  	pr6|326		previous_minor_state
						STATEMENT 1 ON LINE 1737
		if (previous_minor_state = HMD_SEND_SYNC_BLOCK) | (previous_minor_state = HMD_LOOPBACK) then
		     call pop_minor_state ();

006723  aa   000004 1160 07	cmpq 	4,dl
006724  aa   000003 6000 04	tze  	3,ic		006727
006725  aa   000005 1160 07	cmpq 	5,dl
006726  aa   000003 6010 04	tnz  	3,ic		006731
006727  aa   775157 6700 04	tsp4 	-1425,ic		004106
006730  aa   000011 7100 04	tra  	9,ic		006741
						STATEMENT 1 ON LINE 1740
		else do;

						STATEMENT 1 ON LINE 1741
		     if previous_minor_state = HMD_REPROCESS then
			call pop_loopback_block_chain ();

006731  aa   000006 1160 07	cmpq 	6,dl
006732  aa   000002 6010 04	tnz  	2,ic		006734
006733  aa   775500 6700 04	tsp4 	-1216,ic		004433
						STATEMENT 1 ON LINE 1743
		     hmd.reset_local_block_count = "1"b;

006734  aa   004000 2350 03	lda  	2048,du
006735  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
006736  aa  7 00070 2551 00	orsa 	pr7|56		hmd.reset_local_block_count
						STATEMENT 1 ON LINE 1744
		     hmd.minor_state = HMD_REPROCESS;

006737  aa   000006 2360 07	ldq  	6,dl
006740  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
						STATEMENT 1 ON LINE 1745
		end;

						STATEMENT 1 ON LINE 1747
		return;

006741  aa  6 00500 6101 00	rtcd 	pr6|320
						STATEMENT 1 ON LINE 1749
	     end process_sync_block;

  END PROCEDURE process_sync_block
  END PROCEDURE process_input_block
BEGIN PROCEDURE input_loopback_records_processor
ENTRY TO input_loopback_records_processor                   STATEMENT 1 ON LINE 1755
input_loopback_records_processor:
	procedure ();

006742  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 1758
	     return;

006743  aa  6 00510 6101 00	rtcd 	pr6|328
ENTRY TO process_input_records                              STATEMENT 1 ON LINE 1784
process_input_records:
	entry ();

006744  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 1787
	     input_entry = "1"b;

006745  aa   400000 2350 03	lda  	131072,du
006746  aa  6 00516 7551 00	sta  	pr6|334		input_entry
						STATEMENT 1 ON LINE 1788
	     needs_space = "0"b;

006747  aa  6 00124 4501 00	stz  	pr6|84		needs_space
						STATEMENT 1 ON LINE 1790
	     saved_hste_ptr = hste_ptr;

006750  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
006751  aa  6 00520 6535 00	spri7	pr6|336		saved_hste_ptr
						STATEMENT 1 ON LINE 1792
	     start_bufferp = hmd.input.first_bufferp;

006752  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
006753  aa  5 00042 3715 20	epp5 	pr5|34,*		hmd.first_bufferp
006754  aa  6 00522 6515 00	spri5	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 1793
	     start_record_idx = 0;

006755  aa  6 00526 4501 00	stz  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 1795
	     continue_scan = "1"b;

006756  aa  6 00532 7551 00	sta  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 1797
	     do while (continue_scan);

006757  aa   000000 0110 03	nop  	0,du
006760  aa  6 00532 2351 00	lda  	pr6|346		continue_scan
006761  aa   000362 6000 04	tze  	242,ic		007343
						STATEMENT 1 ON LINE 1799
		call find_next_record (start_bufferp, start_record_idx, "1"b, "0"b,
				   end_bufferp, end_record_idx, record_tally, (0));

006762  aa   400000 2350 03	lda  	131072,du
006763  aa  6 02076 7551 00	sta  	pr6|1086
006764  aa   000000 2350 07	lda  	0,dl
006765  aa  6 02077 7551 00	sta  	pr6|1087
006766  aa  6 02100 4501 00	stz  	pr6|1088
006767  aa   006647 3520 04	epp2 	3495,ic		015636 = 000020000000
006770  aa   005412 6700 04	tsp4 	2826,ic		014402
						STATEMENT 1 ON LINE 1802
		if end_bufferp ^= null ()
		then do;

006771  aa  6 00524 2371 00	ldaq 	pr6|340		end_bufferp
006772  aa   771220 6770 04	eraq 	-3440,ic		000212 = 077777000043 000001000000
006773  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006774  aa   000345 6000 04	tze  	229,ic		007341
						STATEMENT 1 ON LINE 1805
		     record_type = classify_record (start_bufferp, start_record_idx);

006775  aa   006631 3520 04	epp2 	3481,ic		015626 = 000006000000
006776  aa   005736 6700 04	tsp4 	3038,ic		014734
						STATEMENT 1 ON LINE 1810
		     record_tally = record_tally - 1;

006777  aa   000001 3360 07	lcq  	1,dl
007000  aa  6 00537 0561 00	asq  	pr6|351		record_tally
						STATEMENT 1 ON LINE 1812
		     rcb_char = start_bufferp -> buffer.chars (start_record_idx);

007001  aa  6 00530 4501 00	stz  	pr6|344		rcb_char
007002  aa  6 00526 7271 00	lxl7 	pr6|342		start_record_idx
007003  aa  6 00522 3735 20	epp7 	pr6|338,*		start_bufferp
007004  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
007005  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
007006  aa  6 00530 00 0001	desc9a	pr6|344,1		rcb_char
						STATEMENT 1 ON LINE 1814
		     if (start_record_idx < (start_bufferp -> buffer.tally - 1))
		     then				/* RCB is in middle of buffer */
			srcb_char = start_bufferp -> buffer.chars (start_record_idx + 1);

007007  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
007010  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
007011  aa   000001 1760 07	sbq  	1,dl
007012  aa  6 00526 1161 00	cmpq 	pr6|342		start_record_idx
007013  aa   000007 6044 04	tmoz 	7,ic		007022
007014  aa  6 00531 4501 00	stz  	pr6|345		srcb_char
007015  aa  6 00526 2351 00	lda  	pr6|342		start_record_idx
007016  aa  040 100 100 505	mlr  	(pr,al),(pr),fill(040)
007017  aa  7 00001 20 0001	desc9a	pr7|1(1),1	buffer.chars
007020  aa  6 00531 00 0001	desc9a	pr6|345,1		srcb_char
007021  aa   000022 7100 04	tra  	18,ic		007043
						STATEMENT 1 ON LINE 1818
		     else				/* RCB is last character in this buffer ... */
		     if ((start_bufferp -> buffer.next) ^= 0) & (record_tally ^= 0)
		     then do;

007022  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
007023  aa   000066 7730 00	lrl  	54
007024  aa  6 02100 7561 00	stq  	pr6|1088		buffer.next
007025  aa   000012 6000 04	tze  	10,ic		007037
007026  aa  6 00537 2361 00	ldq  	pr6|351		record_tally
007027  aa   000010 6000 04	tze  	8,ic		007037
						STATEMENT 1 ON LINE 1821
			bufferp = pointer (ttybp, start_bufferp -> buffer.next);

007030  aa  6 02100 2361 00	ldq  	pr6|1088		buffer.next
007031  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
007032  aa   000000 3120 06	eawp2	0,ql
007033  aa  6 00534 2521 00	spri2	pr6|348		bufferp
						STATEMENT 1 ON LINE 1822
			srcb_char = bufferp -> buffer.chars (0);

007034  aa  2 00001 2351 00	lda  	pr2|1		buffer.chars
007035  aa  6 00531 5511 40	stba 	pr6|345,40	srcb_char
						STATEMENT 1 ON LINE 1823
		     end;

007036  aa   000005 7100 04	tra  	5,ic		007043
						STATEMENT 1 ON LINE 1825
		     else do;

						STATEMENT 1 ON LINE 1826
			record_type = HASP_EOB_RECORD;

007037  aa   000001 2360 07	ldq  	1,dl
007040  aa  6 00536 7561 00	stq  	pr6|350		record_type
						STATEMENT 1 ON LINE 1827
			srcb_char = NUL;

007041  aa   000000 2350 07	lda  	0,dl
007042  aa  6 00531 5511 40	stba 	pr6|345,40	srcb_char
						STATEMENT 1 ON LINE 1828
		     end;

						STATEMENT 1 ON LINE 1833
		     if (record_type = HASP_DATA_RECORD) | (record_type = HASP_EOF_RECORD)
		     then do;

007043  aa  6 00536 2361 00	ldq  	pr6|350		record_type
007044  aa   000007 1160 07	cmpq 	7,dl
007045  aa   000003 6000 04	tze  	3,ic		007050
007046  aa   000002 1160 07	cmpq 	2,dl
007047  aa   000116 6010 04	tnz  	78,ic		007165
						STATEMENT 1 ON LINE 1839
			hste_ptr = find_subchannel (rcb_char);

007050  aa   006550 3520 04	epp2 	3432,ic		015620 = 000004000000
007051  aa   000733 6700 04	tsp4 	475,ic		010004
						STATEMENT 1 ON LINE 1841
			if hste_ptr ^= null () then

			     if (hste.direction = HSTE_OUTPUT_ONLY) then
						/* output only:  flush the record */
				call flush_record_buffers ();

007052  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007053  aa   771137 6770 04	eraq 	-3489,ic		000212 = 077777000043 000001000000
007054  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007055  aa   000050 6000 04	tze  	40,ic		007125
007056  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007057  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
007060  aa   000002 1160 07	cmpq 	2,dl
007061  aa   000003 6010 04	tnz  	3,ic		007064
007062  aa   001003 6700 04	tsp4 	515,ic		010065
007063  aa   000170 7100 04	tra  	120,ic		007253
						STATEMENT 1 ON LINE 1847
			     else do;

						STATEMENT 1 ON LINE 1848
				call move_record_to_device ();

007064  aa   001051 6700 04	tsp4 	553,ic		010135
						STATEMENT 1 ON LINE 1849
				hste.meters.device_n_input_records = hste.meters.device_n_input_records + 1;

007065  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007066  aa  7 00040 2351 00	lda  	pr7|32		hste.device_n_input_records
007067  aa   000044 7330 00	lrs  	36
007070  aa   000001 0330 07	adl  	1,dl
007071  aa  7 00040 7561 00	stq  	pr7|32		hste.device_n_input_records
						STATEMENT 1 ON LINE 1850
				if (record_type = HASP_EOF_RECORD) then
				     hste.meters.device_n_input_eof_records = hste.meters.device_n_input_eof_records + 1;

007072  aa  6 00536 2361 00	ldq  	pr6|350		record_type
007073  aa   000002 1160 07	cmpq 	2,dl
007074  aa   000005 6010 04	tnz  	5,ic		007101
007075  aa  7 00041 2351 00	lda  	pr7|33		hste.device_n_input_eof_records
007076  aa   000044 7330 00	lrs  	36
007077  aa   000001 0330 07	adl  	1,dl
007100  aa  7 00041 7561 00	stq  	pr7|33		hste.device_n_input_eof_records
						STATEMENT 1 ON LINE 1852
				if hste.input.n_records >= hmd.max_device_input_records then
				     if hste.device_type ^= HASP_CONSOLE
				     then do;

007101  aa  7 00016 2361 00	ldq  	pr7|14		hste.n_records
007102  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007103  aa  5 00013 1161 00	cmpq 	pr5|11		hmd.max_device_input_records
007104  aa   000147 6040 04	tmi  	103,ic		007253
007105  aa  7 00003 2361 00	ldq  	pr7|3		hste.device_type
007106  aa   000001 1160 07	cmpq 	1,dl
007107  aa   000144 6000 04	tze  	100,ic		007253
						STATEMENT 1 ON LINE 1855
					if hmd.input_wabs (hste.device_wab_idx) then
					     hste.meters.device_n_local_wab_set = hste.meters.device_n_local_wab_set + 1;

007110  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
007111  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
007112  aa  5 00067 00 0001	descb	pr5|55,1		hmd.input_wabs
007113  aa   000000 00 0000	descb	0,0
007114  aa   000005 6000 04	tze  	5,ic		007121
007115  aa  7 00037 2351 00	lda  	pr7|31		hste.device_n_local_wab_set
007116  aa   000044 7330 00	lrs  	36
007117  aa   000001 0330 07	adl  	1,dl
007120  aa  7 00037 7561 00	stq  	pr7|31		hste.device_n_local_wab_set
						STATEMENT 1 ON LINE 1857
					hmd.input_wabs (hste.device_wab_idx) = "0"b;

007121  aa  003 117 060 400	csl  	(),(pr,x7),fill(0),bool(move)
007122  aa   000000 00 0000	descb	0,0
007123  aa  5 00067 00 0001	descb	pr5|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 1858
				     end;

						STATEMENT 1 ON LINE 1859
			     end;

007124  aa   000127 7100 04	tra  	87,ic		007253
						STATEMENT 1 ON LINE 1861
			else do;

						STATEMENT 1 ON LINE 1862
			     call flush_record_buffers ();

007125  aa   000740 6700 04	tsp4 	480,ic		010065
						STATEMENT 1 ON LINE 1863
			     if (rcb.type = HASP_RCB_TYPE_READER_INPUT) | (rcb.type = HASP_RCB_TYPE_PRINT_OUTPUT) then
				hmd.input_wabs (rcb.stream) = "0"b;

007126  aa  6 00530 3735 00	epp7 	pr6|344		rcb_char
007127  aa  6 02102 6535 00	spri7	pr6|1090
007130  aa  7 00000 2351 00	lda  	pr7|0		rcb.type
007131  aa   000005 7350 00	als  	5
007132  aa   000104 7730 00	lrl  	68
007133  aa  6 02101 7561 00	stq  	pr6|1089		rcb.type
007134  aa   000003 1160 07	cmpq 	3,dl
007135  aa   000003 6000 04	tze  	3,ic		007140
007136  aa   000004 1160 07	cmpq 	4,dl
007137  aa   000011 6010 04	tnz  	9,ic		007150
007140  aa  7 00000 2351 00	lda  	pr7|0		rcb.stream
007141  aa   000002 7350 00	als  	2
007142  aa   000105 7730 00	lrl  	69
007143  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007144  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
007145  aa   000000 00 0000	descb	0,0
007146  aa  5 00067 00 0001	descb	pr5|55,1		hmd.input_wabs
007147  aa   000104 7100 04	tra  	68,ic		007253
						STATEMENT 1 ON LINE 1865
			     else if (rcb.type = HASP_RCB_TYPE_PUNCH_OUTPUT) then
				hmd.input_wabs (9 - rcb.stream) = "0"b;

007150  aa   000005 1160 07	cmpq 	5,dl
007151  aa   000102 6010 04	tnz  	66,ic		007253
007152  aa  7 00000 2351 00	lda  	pr7|0		rcb.stream
007153  aa   000002 7350 00	als  	2
007154  aa   000105 7730 00	lrl  	69
007155  aa  6 02101 7561 00	stq  	pr6|1089		rcb.stream
007156  aa   000011 2360 07	ldq  	9,dl
007157  aa  6 02101 1761 00	sbq  	pr6|1089		rcb.stream
007160  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007161  aa  003 106 060 400	csl  	(),(pr,ql),fill(0),bool(move)
007162  aa   000000 00 0000	descb	0,0
007163  aa  5 00067 00 0001	descb	pr5|55,1		hmd.input_wabs
						STATEMENT 1 ON LINE 1867
			end;

						STATEMENT 1 ON LINE 1868
		     end;

007164  aa   000067 7100 04	tra  	55,ic		007253
						STATEMENT 1 ON LINE 1871
		     else if (record_type = HASP_RTS_RECORD)
		     then do;

007165  aa   000004 1160 07	cmpq 	4,dl
007166  aa   000025 6010 04	tnz  	21,ic		007213
						STATEMENT 1 ON LINE 1878
			hste_ptr = find_subchannel (srcb_char);

007167  aa   006423 3520 04	epp2 	3347,ic		015612 = 000004000000
007170  aa   000614 6700 04	tsp4 	396,ic		010004
						STATEMENT 1 ON LINE 1880
			if hste_ptr ^= null () then
			     if (hste.direction ^= HSTE_OUTPUT_ONLY) & (hste.device_type ^= HASP_CONSOLE) then
				hmd.send_rts_ack (hste.device_wab_idx) = "1"b;

007171  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007172  aa   771020 6770 04	eraq 	-3568,ic		000212 = 077777000043 000001000000
007173  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007174  aa   000015 6000 04	tze  	13,ic		007211
007175  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007176  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
007177  aa   000002 1160 07	cmpq 	2,dl
007200  aa   000011 6000 04	tze  	9,ic		007211
007201  aa  7 00003 2361 00	ldq  	pr7|3		hste.device_type
007202  aa   000001 1160 07	cmpq 	1,dl
007203  aa   000006 6000 04	tze  	6,ic		007211
007204  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
007205  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007206  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
007207  aa   000000 00 0000	descb	0,0
007210  aa  5 00067 60 0001	descb	pr5|55(27),1	hmd.send_rts_ack
						STATEMENT 1 ON LINE 1884
			call flush_record_buffers ();

007211  aa   000654 6700 04	tsp4 	428,ic		010065
						STATEMENT 1 ON LINE 1885
		     end;

007212  aa   000041 7100 04	tra  	33,ic		007253
						STATEMENT 1 ON LINE 1888
		     else if (record_type = HASP_RTS_ACK_RECORD)
		     then do;

007213  aa   000005 1160 07	cmpq 	5,dl
007214  aa   000036 6010 04	tnz  	30,ic		007252
						STATEMENT 1 ON LINE 1894
			hste_ptr = find_subchannel (srcb_char);

007215  aa   006375 3520 04	epp2 	3325,ic		015612 = 000004000000
007216  aa   000566 6700 04	tsp4 	374,ic		010004
						STATEMENT 1 ON LINE 1896
			if hste_ptr ^= null () then do;

007217  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007220  aa   770772 6770 04	eraq 	-3590,ic		000212 = 077777000043 000001000000
007221  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007222  aa   000026 6000 04	tze  	22,ic		007250
						STATEMENT 1 ON LINE 1897
			     hste.minor_state = HSTE_NORMAL;

007223  aa   000001 2360 07	ldq  	1,dl
007224  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007225  aa  7 00013 7561 00	stq  	pr7|11		hste.minor_state
						STATEMENT 1 ON LINE 1898
			     if hste.holding_output then do;

007226  aa  7 00036 2351 00	lda  	pr7|30		hste.holding_output
007227  aa   100000 3150 03	cana 	32768,du
007230  aa   000020 6000 04	tze  	16,ic		007250
						STATEMENT 1 ON LINE 1899
				call dequeue_subchannel_for_output ();

007231  aa   775374 6700 04	tsp4 	-1284,ic		004625
						STATEMENT 1 ON LINE 1900
				call channel_manager$interrupt (hste.devx, SEND_OUTPUT, ""b);

007232  aa   770756 2370 04	ldaq 	-3602,ic		000210 = 000000000000 000000000000
007233  aa  6 02102 7571 00	staq 	pr6|1090
007234  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007235  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
007236  aa  6 02106 2521 00	spri2	pr6|1094
007237  aa   770731 3520 04	epp2 	-3623,ic		000170 = 000000000004
007240  aa  6 02110 2521 00	spri2	pr6|1096
007241  aa  6 02102 3521 00	epp2 	pr6|1090
007242  aa  6 02112 2521 00	spri2	pr6|1098
007243  aa  6 02104 6211 00	eax1 	pr6|1092
007244  aa   014000 4310 07	fld  	6144,dl
007245  aa  6 00044 3701 20	epp4 	pr6|36,*
007246  la  4 00100 3521 20	epp2 	pr4|64,*		channel_manager$interrupt
007247  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1901
			     end;

						STATEMENT 1 ON LINE 1902
			end;

						STATEMENT 1 ON LINE 1904
			call flush_record_buffers ();

007250  aa   000615 6700 04	tsp4 	397,ic		010065
						STATEMENT 1 ON LINE 1905
		     end;

007251  aa   000002 7100 04	tra  	2,ic		007253
						STATEMENT 1 ON LINE 1907
		     else call flush_record_buffers ();

007252  aa   000613 6700 04	tsp4 	395,ic		010065
						STATEMENT 1 ON LINE 1912
		     if end_bufferp = null () then
			start_bufferp = null ();

007253  aa  6 00524 2371 00	ldaq 	pr6|340		end_bufferp
007254  aa   770736 6770 04	eraq 	-3618,ic		000212 = 077777000043 000001000000
007255  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007256  aa   000004 6010 04	tnz  	4,ic		007262
007257  aa   770733 2370 04	ldaq 	-3621,ic		000212 = 077777000043 000001000000
007260  aa  6 00522 7571 00	staq 	pr6|338		start_bufferp
007261  aa   000045 7100 04	tra  	37,ic		007326
						STATEMENT 1 ON LINE 1915
		     else if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
		     then do;

007262  aa  6 00524 2361 20	ldq  	pr6|340,*		buffer.tally
007263  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
007264  aa  6 02101 7561 00	stq  	pr6|1089		buffer.tally
007265  aa  6 00527 2361 00	ldq  	pr6|343		end_record_idx
007266  aa   000001 0760 07	adq  	1,dl
007267  aa  6 02101 1161 00	cmpq 	pr6|1089		buffer.tally
007270  aa   000031 6010 04	tnz  	25,ic		007321
						STATEMENT 1 ON LINE 1917
			if end_bufferp -> buffer.next = 0 then
			     start_bufferp = null ();

007271  aa  6 00524 2351 20	lda  	pr6|340,*		buffer.next
007272  aa   000066 7730 00	lrl  	54
007273  aa  6 02101 7561 00	stq  	pr6|1089		buffer.next
007274  aa   000004 6010 04	tnz  	4,ic		007300
007275  aa   770715 2370 04	ldaq 	-3635,ic		000212 = 077777000043 000001000000
007276  aa  6 00522 7571 00	staq 	pr6|338		start_bufferp
007277  aa   000004 7100 04	tra  	4,ic		007303
						STATEMENT 1 ON LINE 1919
			else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);

007300  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
007301  aa   000000 3120 06	eawp2	0,ql
007302  aa  6 00522 2521 00	spri2	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 1920
			start_record_idx = 0;

007303  aa  6 00526 4501 00	stz  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 1921
			call tty_space_man$free_buffer (hmd.devx, INPUT, end_bufferp);

007304  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
007305  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
007306  aa  6 02106 2521 00	spri2	pr6|1094
007307  aa   770603 3520 04	epp2 	-3709,ic		000112 = 000000000000
007310  aa  6 02110 2521 00	spri2	pr6|1096
007311  aa  6 00524 3521 00	epp2 	pr6|340		end_bufferp
007312  aa  6 02112 2521 00	spri2	pr6|1098
007313  aa  6 02104 6211 00	eax1 	pr6|1092
007314  aa   014000 4310 07	fld  	6144,dl
007315  aa  6 00044 3701 20	epp4 	pr6|36,*
007316  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
007317  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1922
		     end;

007320  aa   000006 7100 04	tra  	6,ic		007326
						STATEMENT 1 ON LINE 1924
		     else do;

						STATEMENT 1 ON LINE 1925
			start_bufferp = end_bufferp;

007321  aa  6 00524 3735 20	epp7 	pr6|340,*		end_bufferp
007322  aa  6 00522 6535 00	spri7	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 1926
			start_record_idx = end_record_idx + 1;

007323  aa  6 00527 2361 00	ldq  	pr6|343		end_record_idx
007324  aa   000001 0760 07	adq  	1,dl
007325  aa  6 00526 7561 00	stq  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 1927
		     end;

						STATEMENT 1 ON LINE 1929
		     hmd.meters.n_input_records = hmd.meters.n_input_records + 1;

007326  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
007327  aa  7 00100 2351 00	lda  	pr7|64		hmd.n_input_records
007330  aa   000044 7330 00	lrs  	36
007331  aa   000001 0330 07	adl  	1,dl
007332  aa  7 00100 7561 00	stq  	pr7|64		hmd.n_input_records
						STATEMENT 1 ON LINE 1931
		     continue_scan = (start_bufferp ^= null ());

007333  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007334  aa   770656 6770 04	eraq 	-3666,ic		000212 = 077777000043 000001000000
007335  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007336  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
007337  aa  6 00532 7551 00	sta  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 1932
		end;

007340  aa   777420 7100 04	tra  	-240,ic		006760
						STATEMENT 1 ON LINE 1934
		else continue_scan = "0"b;

007341  aa  6 00532 4501 00	stz  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 1935
	     end;

007342  aa   777416 7100 04	tra  	-242,ic		006760
						STATEMENT 1 ON LINE 1938
RETURN_FROM_PROCESS_INPUT_RECORDS:
	     if start_bufferp ^= null () then		/* didn't process the entire chain:  return the rest */
		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
		     call delete_text (start_bufferp, 0, start_record_idx);

007343  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007344  aa   770646 6770 04	eraq 	-3674,ic		000212 = 077777000043 000001000000
007345  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007346  aa   000006 6000 04	tze  	6,ic		007354
007347  aa  6 00526 2361 00	ldq  	pr6|342		start_record_idx
007350  aa   000004 6000 04	tze  	4,ic		007354
007351  aa  6 02101 4501 00	stz  	pr6|1089
007352  aa   006230 3520 04	epp2 	3224,ic		015602 = 000006000000
007353  aa   005657 6700 04	tsp4 	2991,ic		015232
						STATEMENT 1 ON LINE 1943
	     hmd.input.first_bufferp = start_bufferp;

007354  aa  6 00522 3735 20	epp7 	pr6|338,*		start_bufferp
007355  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007356  aa  5 00042 6535 00	spri7	pr5|34		hmd.first_bufferp
						STATEMENT 1 ON LINE 1945
	     if start_bufferp = null () then		/* got all of it */
		hmd.input.last_bufferp = null ();

007357  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007360  aa   770632 6770 04	eraq 	-3686,ic		000212 = 077777000043 000001000000
007361  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007362  aa   000003 6010 04	tnz  	3,ic		007365
007363  aa   770627 2370 04	ldaq 	-3689,ic		000212 = 077777000043 000001000000
007364  aa  5 00044 7571 00	staq 	pr5|36		hmd.last_bufferp
						STATEMENT 1 ON LINE 1948
	     hmd.retry_process_input = needs_space;

007365  aa  6 00124 2351 00	lda  	pr6|84		needs_space
007366  aa   000012 7710 00	arl  	10
007367  aa  5 00070 6751 00	era  	pr5|56		hmd.retry_process_input
007370  aa   000200 3750 03	ana  	128,du
007371  aa  5 00070 6551 00	ersa 	pr5|56		hmd.retry_process_input
						STATEMENT 1 ON LINE 1949
	     if needs_space then			/* couldn't process it all right now */
		call tty_space_man$needs_space (hmd.devx);

007372  aa  6 00124 2351 00	lda  	pr6|84		needs_space
007373  aa   000010 6000 04	tze  	8,ic		007403
007374  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
007375  aa  6 02106 2521 00	spri2	pr6|1094
007376  aa  6 02104 6211 00	eax1 	pr6|1092
007377  aa   004000 4310 07	fld  	2048,dl
007400  aa  6 00044 3701 20	epp4 	pr6|36,*
007401  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$needs_space
007402  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1952
	     hste_ptr = saved_hste_ptr;

007403  aa  6 00520 3735 20	epp7 	pr6|336,*		saved_hste_ptr
007404  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 1954
	     return;

007405  aa  6 00510 6101 00	rtcd 	pr6|328
ENTRY TO process_loopback_records                           STATEMENT 1 ON LINE 1962
process_loopback_records:
	entry ();

007406  aa  6 00510 6501 00	spri4	pr6|328
						STATEMENT 1 ON LINE 1965
	     input_entry = "0"b;

007407  aa  6 00516 4501 00	stz  	pr6|334		input_entry
						STATEMENT 1 ON LINE 1966
	     needs_space = "0"b;

007410  aa  6 00124 4501 00	stz  	pr6|84		needs_space
						STATEMENT 1 ON LINE 1968
	     saved_hste_ptr = hste_ptr;

007411  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007412  aa  6 00520 6535 00	spri7	pr6|336		saved_hste_ptr
						STATEMENT 1 ON LINE 1970
	     start_bufferp = hmd.loopback.first_bufferp;

007413  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007414  aa  5 00046 3715 20	epp5 	pr5|38,*		hmd.first_bufferp
007415  aa  6 00522 6515 00	spri5	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 1971
	     start_record_idx = 0;

007416  aa  6 00526 4501 00	stz  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 1973
	     continue_scan = ^full_output_blockp () &	/* while there's some room in the output block ... */
			 (hmd.loopback.first_bufferp ^= null ());

007417  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
007420  aa  3 00046 2371 00	ldaq 	pr3|38		hmd.first_bufferp
007421  aa   770571 6770 04	eraq 	-3719,ic		000212 = 077777000043 000001000000
007422  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007423  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
007424  aa  6 02101 7551 00	sta  	pr6|1089
007425  aa   006151 3520 04	epp2 	3177,ic		015576 = 000002000000
007426  aa   005547 6700 04	tsp4 	2919,ic		015175
007427  aa  6 02100 2351 00	lda  	pr6|1088
007430  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
007431  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
007432  aa  6 02101 3751 00	ana  	pr6|1089
007433  aa  6 00532 7551 00	sta  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 1976
	     do while (continue_scan);

007434  aa  6 00532 2351 00	lda  	pr6|346		continue_scan
007435  aa   000267 6000 04	tze  	183,ic		007724
						STATEMENT 1 ON LINE 1978
		call find_next_record (start_bufferp, start_record_idx, "1"b, "1"b,
				   end_bufferp, end_record_idx, record_tally, dle_count);

007436  aa   400000 2350 03	lda  	131072,du
007437  aa  6 02101 7551 00	sta  	pr6|1089
007440  aa  6 02100 7551 00	sta  	pr6|1088
007441  aa   006113 3520 04	epp2 	3147,ic		015554 = 000020000000
007442  aa   004740 6700 04	tsp4 	2528,ic		014402
						STATEMENT 1 ON LINE 1981
		if end_bufferp ^= null ()
		then do;

007443  aa  6 00524 2371 00	ldaq 	pr6|340		end_bufferp
007444  aa   770546 6770 04	eraq 	-3738,ic		000212 = 077777000043 000001000000
007445  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007446  aa   000254 6000 04	tze  	172,ic		007722
						STATEMENT 1 ON LINE 1984
		     record_type = classify_record (start_bufferp, start_record_idx);

007447  aa   006157 3520 04	epp2 	3183,ic		015626 = 000006000000
007450  aa   005264 6700 04	tsp4 	2740,ic		014734
						STATEMENT 1 ON LINE 1989
		     record_tally = record_tally - 1;

007451  aa   000001 3360 07	lcq  	1,dl
007452  aa  6 00537 0561 00	asq  	pr6|351		record_tally
						STATEMENT 1 ON LINE 1991
		     rcb_char = start_bufferp -> buffer.chars (start_record_idx);

007453  aa  6 00526 7271 00	lxl7 	pr6|342		start_record_idx
007454  aa  6 00522 3735 20	epp7 	pr6|338,*		start_bufferp
007455  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
007456  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
007457  aa  6 00530 00 0001	desc9a	pr6|344,1		rcb_char
						STATEMENT 1 ON LINE 1993
		     if (start_record_idx < (start_bufferp -> buffer.tally - 1))
		     then				/* RCB is in middle of buffer */
			srcb_char = start_bufferp -> buffer.chars (start_record_idx + 1);

007460  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
007461  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
007462  aa   000001 1760 07	sbq  	1,dl
007463  aa  6 00526 1161 00	cmpq 	pr6|342		start_record_idx
007464  aa   000006 6044 04	tmoz 	6,ic		007472
007465  aa  6 00526 2351 00	lda  	pr6|342		start_record_idx
007466  aa  040 100 100 505	mlr  	(pr,al),(pr),fill(040)
007467  aa  7 00001 20 0001	desc9a	pr7|1(1),1	buffer.chars
007470  aa  6 00531 00 0001	desc9a	pr6|345,1		srcb_char
007471  aa   000022 7100 04	tra  	18,ic		007513
						STATEMENT 1 ON LINE 1997
		     else				/* RCB is last character in this buffer ... */
		     if ((start_bufferp -> buffer.next) ^= 0) & (record_tally ^= 0)
		     then do;

007472  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
007473  aa   000066 7730 00	lrl  	54
007474  aa  6 02100 7561 00	stq  	pr6|1088		buffer.next
007475  aa   000012 6000 04	tze  	10,ic		007507
007476  aa  6 00537 2361 00	ldq  	pr6|351		record_tally
007477  aa   000010 6000 04	tze  	8,ic		007507
						STATEMENT 1 ON LINE 2000
			bufferp = pointer (ttybp, start_bufferp -> buffer.next);

007500  aa  6 02100 2361 00	ldq  	pr6|1088		buffer.next
007501  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
007502  aa   000000 3120 06	eawp2	0,ql
007503  aa  6 00534 2521 00	spri2	pr6|348		bufferp
						STATEMENT 1 ON LINE 2001
			srcb_char = bufferp -> buffer.chars (0);

007504  aa  2 00001 2351 00	lda  	pr2|1		buffer.chars
007505  aa  6 00531 5511 40	stba 	pr6|345,40	srcb_char
						STATEMENT 1 ON LINE 2002
		     end;

007506  aa   000005 7100 04	tra  	5,ic		007513
						STATEMENT 1 ON LINE 2004
		     else do;

						STATEMENT 1 ON LINE 2005
			record_type = HASP_EOB_RECORD;

007507  aa   000001 2360 07	ldq  	1,dl
007510  aa  6 00536 7561 00	stq  	pr6|350		record_type
						STATEMENT 1 ON LINE 2006
			srcb_char = NUL;

007511  aa   000000 2350 07	lda  	0,dl
007512  aa  6 00531 5511 40	stba 	pr6|345,40	srcb_char
						STATEMENT 1 ON LINE 2007
		     end;

						STATEMENT 1 ON LINE 2012
		     if (record_type = HASP_DATA_RECORD) | (record_type = HASP_EOF_RECORD)
		     then do;

007513  aa  6 00536 2361 00	ldq  	pr6|350		record_type
007514  aa   000007 1160 07	cmpq 	7,dl
007515  aa   000003 6000 04	tze  	3,ic		007520
007516  aa   000002 1160 07	cmpq 	2,dl
007517  aa   000051 6010 04	tnz  	41,ic		007570
						STATEMENT 1 ON LINE 2018
			hste_ptr = find_subchannel (rcb_char);

007520  aa   006100 3520 04	epp2 	3136,ic		015620 = 000004000000
007521  aa   000263 6700 04	tsp4 	179,ic		010004
						STATEMENT 1 ON LINE 2020
			if hste_ptr ^= null () then

			     if hste.direction = HSTE_INPUT_ONLY then
				call flush_record_buffers ();

007522  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007523  aa   770467 6770 04	eraq 	-3785,ic		000212 = 077777000043 000001000000
007524  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007525  aa   000041 6000 04	tze  	33,ic		007566
007526  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007527  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
007530  aa   000001 1160 07	cmpq 	1,dl
007531  aa   000003 6010 04	tnz  	3,ic		007534
007532  aa   000333 6700 04	tsp4 	219,ic		010065
007533  aa   000077 7100 04	tra  	63,ic		007632
						STATEMENT 1 ON LINE 2025
			     else if hmd.output_wabs (hste.device_wab_idx) &
				   (hste.loopback.first_bufferp = null ())
			     then do;

007534  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
007535  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007536  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
007537  aa  5 00067 20 0001	descb	pr5|55(9),1	hmd.output_wabs
007540  aa   000000 00 0000	descb	0,0
007541  aa   000023 6000 04	tze  	19,ic		007564
007542  aa  7 00026 2371 00	ldaq 	pr7|22		hste.first_bufferp
007543  aa   770447 6770 04	eraq 	-3801,ic		000212 = 077777000043 000001000000
007544  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007545  aa   000017 6010 04	tnz  	15,ic		007564
						STATEMENT 1 ON LINE 2028
				call process_single_loopback_record (start_bufferp, (start_record_idx + 1),
							       end_bufferp, end_record_idx, record_tally,
							       dle_count, record_was_taken);

007546  aa  6 00526 2361 00	ldq  	pr6|342		start_record_idx
007547  aa   000001 0760 07	adq  	1,dl
007550  aa  6 02100 7561 00	stq  	pr6|1088
007551  aa   005763 3520 04	epp2 	3059,ic		015534 = 000016000000
007552  aa   002640 6700 04	tsp4 	1440,ic		012412
						STATEMENT 1 ON LINE 2031
				     if needs_space then /* can't do it now */
					go to RETURN_FROM_PROCESS_LOOPBACK_RECORDS;

007553  aa  6 00124 2351 00	lda  	pr6|84		needs_space
007554  aa   000150 6010 04	tnz  	104,ic		007724
						STATEMENT 1 ON LINE 2033
				if record_was_taken then /* in output block now */
				     call flush_record_buffers ();

007555  aa  6 00533 2351 00	lda  	pr6|347		record_was_taken
007556  aa   400000 3150 03	cana 	131072,du
007557  aa   000003 6000 04	tze  	3,ic		007562
007560  aa   000305 6700 04	tsp4 	197,ic		010065
007561  aa   000051 7100 04	tra  	41,ic		007632
						STATEMENT 1 ON LINE 2035
				else call move_record_to_device ();

007562  aa   000353 6700 04	tsp4 	235,ic		010135
						STATEMENT 1 ON LINE 2036
			     end;

007563  aa   000047 7100 04	tra  	39,ic		007632
						STATEMENT 1 ON LINE 2038
			     else call move_record_to_device ();

007564  aa   000351 6700 04	tsp4 	233,ic		010135
007565  aa   000045 7100 04	tra  	37,ic		007632
						STATEMENT 1 ON LINE 2040
			else call flush_record_buffers ();

007566  aa   000277 6700 04	tsp4 	191,ic		010065
						STATEMENT 1 ON LINE 2041
		     end;

007567  aa   000043 7100 04	tra  	35,ic		007632
						STATEMENT 1 ON LINE 2044
		     else if (record_type = HASP_RTS_RECORD)
		     then do;

007570  aa   000004 1160 07	cmpq 	4,dl
007571  aa   000020 6010 04	tnz  	16,ic		007611
						STATEMENT 1 ON LINE 2051
			hste_ptr = find_subchannel (srcb_char);

007572  aa   006020 3520 04	epp2 	3088,ic		015612 = 000004000000
007573  aa   000211 6700 04	tsp4 	137,ic		010004
						STATEMENT 1 ON LINE 2053
			if hste_ptr ^= null () then
			     if hste.loopback.first_bufferp = null () then
				hste.minor_state = HSTE_SEND_RTS;

007574  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007575  aa   770415 6770 04	eraq 	-3827,ic		000212 = 077777000043 000001000000
007576  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007577  aa   000010 6000 04	tze  	8,ic		007607
007600  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007601  aa  7 00026 2371 00	ldaq 	pr7|22		hste.first_bufferp
007602  aa   770410 6770 04	eraq 	-3832,ic		000212 = 077777000043 000001000000
007603  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007604  aa   000003 6010 04	tnz  	3,ic		007607
007605  aa   000002 2360 07	ldq  	2,dl
007606  aa  7 00013 7561 00	stq  	pr7|11		hste.minor_state
						STATEMENT 1 ON LINE 2057
			call flush_record_buffers ();

007607  aa   000256 6700 04	tsp4 	174,ic		010065
						STATEMENT 1 ON LINE 2058
		     end;

007610  aa   000022 7100 04	tra  	18,ic		007632
						STATEMENT 1 ON LINE 2061
		     else if (record_type = HASP_RTS_ACK_RECORD)
		     then do;

007611  aa   000005 1160 07	cmpq 	5,dl
007612  aa   000017 6010 04	tnz  	15,ic		007631
						STATEMENT 1 ON LINE 2067
			hste_ptr = find_subchannel (srcb_char);

007613  aa   005777 3520 04	epp2 	3071,ic		015612 = 000004000000
007614  aa   000170 6700 04	tsp4 	120,ic		010004
						STATEMENT 1 ON LINE 2069
			if hste_ptr ^= null () then
			     hmd.send_rts_ack (hste.device_wab_idx) = "1"b;

007615  aa  6 00140 2371 00	ldaq 	pr6|96		hste_ptr
007616  aa   770374 6770 04	eraq 	-3844,ic		000212 = 077777000043 000001000000
007617  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007620  aa   000007 6000 04	tze  	7,ic		007627
007621  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
007622  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
007623  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007624  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
007625  aa   000000 00 0000	descb	0,0
007626  aa  5 00067 60 0001	descb	pr5|55(27),1	hmd.send_rts_ack
						STATEMENT 1 ON LINE 2072
			call flush_record_buffers ();

007627  aa   000236 6700 04	tsp4 	158,ic		010065
						STATEMENT 1 ON LINE 2073
		     end;

007630  aa   000002 7100 04	tra  	2,ic		007632
						STATEMENT 1 ON LINE 2076
		     else call flush_record_buffers ();

007631  aa   000234 6700 04	tsp4 	156,ic		010065
						STATEMENT 1 ON LINE 2083
		     if end_bufferp = null () then
			start_bufferp = null ();

007632  aa  6 00524 2371 00	ldaq 	pr6|340		end_bufferp
007633  aa   770357 6770 04	eraq 	-3857,ic		000212 = 077777000043 000001000000
007634  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007635  aa   000004 6010 04	tnz  	4,ic		007641
007636  aa   770354 2370 04	ldaq 	-3860,ic		000212 = 077777000043 000001000000
007637  aa  6 00522 7571 00	staq 	pr6|338		start_bufferp
007640  aa   000045 7100 04	tra  	37,ic		007705
						STATEMENT 1 ON LINE 2086
		     else if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
		     then do;

007641  aa  6 00524 2361 20	ldq  	pr6|340,*		buffer.tally
007642  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
007643  aa  6 02100 7561 00	stq  	pr6|1088		buffer.tally
007644  aa  6 00527 2361 00	ldq  	pr6|343		end_record_idx
007645  aa   000001 0760 07	adq  	1,dl
007646  aa  6 02100 1161 00	cmpq 	pr6|1088		buffer.tally
007647  aa   000031 6010 04	tnz  	25,ic		007700
						STATEMENT 1 ON LINE 2088
			if end_bufferp -> buffer.next = 0 then
			     start_bufferp = null ();

007650  aa  6 00524 2351 20	lda  	pr6|340,*		buffer.next
007651  aa   000066 7730 00	lrl  	54
007652  aa  6 02100 7561 00	stq  	pr6|1088		buffer.next
007653  aa   000004 6010 04	tnz  	4,ic		007657
007654  aa   770336 2370 04	ldaq 	-3874,ic		000212 = 077777000043 000001000000
007655  aa  6 00522 7571 00	staq 	pr6|338		start_bufferp
007656  aa   000004 7100 04	tra  	4,ic		007662
						STATEMENT 1 ON LINE 2090
			else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);

007657  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
007660  aa   000000 3120 06	eawp2	0,ql
007661  aa  6 00522 2521 00	spri2	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 2091
			start_record_idx = 0;

007662  aa  6 00526 4501 00	stz  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 2092
			call tty_space_man$free_buffer (hmd.devx, INPUT, end_bufferp);

007663  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
007664  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
007665  aa  6 02106 2521 00	spri2	pr6|1094
007666  aa   770224 3520 04	epp2 	-3948,ic		000112 = 000000000000
007667  aa  6 02110 2521 00	spri2	pr6|1096
007670  aa  6 00524 3521 00	epp2 	pr6|340		end_bufferp
007671  aa  6 02112 2521 00	spri2	pr6|1098
007672  aa  6 02104 6211 00	eax1 	pr6|1092
007673  aa   014000 4310 07	fld  	6144,dl
007674  aa  6 00044 3701 20	epp4 	pr6|36,*
007675  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
007676  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2093
		     end;

007677  aa   000006 7100 04	tra  	6,ic		007705
						STATEMENT 1 ON LINE 2095
		     else do;

						STATEMENT 1 ON LINE 2096
			start_bufferp = end_bufferp;

007700  aa  6 00524 3735 20	epp7 	pr6|340,*		end_bufferp
007701  aa  6 00522 6535 00	spri7	pr6|338		start_bufferp
						STATEMENT 1 ON LINE 2097
			start_record_idx = end_record_idx + 1;

007702  aa  6 00527 2361 00	ldq  	pr6|343		end_record_idx
007703  aa   000001 0760 07	adq  	1,dl
007704  aa  6 00526 7561 00	stq  	pr6|342		start_record_idx
						STATEMENT 1 ON LINE 2098
		     end;

						STATEMENT 1 ON LINE 2100
		     continue_scan = (start_bufferp ^= null ()) & /* something left in loopback chain ... */
			           ^full_output_blockp ();

007705  aa   005671 3520 04	epp2 	3001,ic		015576 = 000002000000
007706  aa   005267 6700 04	tsp4 	2743,ic		015175
007707  aa  6 02100 2351 00	lda  	pr6|1088
007710  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
007711  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
007712  aa  6 02100 7551 00	sta  	pr6|1088
007713  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007714  aa   770276 6770 04	eraq 	-3906,ic		000212 = 077777000043 000001000000
007715  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007716  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
007717  aa  6 02100 3751 00	ana  	pr6|1088
007720  aa  6 00532 7551 00	sta  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 2102
		end;

007721  aa   777513 7100 04	tra  	-181,ic		007434
						STATEMENT 1 ON LINE 2104
		else continue_scan = "0"b;

007722  aa  6 00532 4501 00	stz  	pr6|346		continue_scan
						STATEMENT 1 ON LINE 2105
	     end;

007723  aa   777511 7100 04	tra  	-183,ic		007434
						STATEMENT 1 ON LINE 2111
RETURN_FROM_PROCESS_LOOPBACK_RECORDS:
	     if start_bufferp ^= null () then		/* didn't process the entire chain:  return the rest */
		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
		     call delete_text (start_bufferp, 0, start_record_idx);

007724  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007725  aa   770265 6770 04	eraq 	-3915,ic		000212 = 077777000043 000001000000
007726  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007727  aa   000006 6000 04	tze  	6,ic		007735
007730  aa  6 00526 2361 00	ldq  	pr6|342		start_record_idx
007731  aa   000004 6000 04	tze  	4,ic		007735
007732  aa  6 02100 4501 00	stz  	pr6|1088
007733  aa   005571 3520 04	epp2 	2937,ic		015524 = 000006000000
007734  aa   005276 6700 04	tsp4 	2750,ic		015232
						STATEMENT 1 ON LINE 2116
	     hmd.loopback.first_bufferp = start_bufferp;

007735  aa  6 00522 3735 20	epp7 	pr6|338,*		start_bufferp
007736  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
007737  aa  5 00046 6535 00	spri7	pr5|38		hmd.first_bufferp
						STATEMENT 1 ON LINE 2118
	     if start_bufferp = null () then		/* got all of it */
		hmd.loopback.last_bufferp = null ();

007740  aa  6 00522 2371 00	ldaq 	pr6|338		start_bufferp
007741  aa   770251 6770 04	eraq 	-3927,ic		000212 = 077777000043 000001000000
007742  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007743  aa   000003 6010 04	tnz  	3,ic		007746
007744  aa   770246 2370 04	ldaq 	-3930,ic		000212 = 077777000043 000001000000
007745  aa  5 00050 7571 00	staq 	pr5|40		hmd.last_bufferp
						STATEMENT 1 ON LINE 2121
	     hmd.retry_process_loopback_records = needs_space;

007746  aa  6 00124 2351 00	lda  	pr6|84		needs_space
007747  aa   000011 7710 00	arl  	9
007750  aa  5 00070 6751 00	era  	pr5|56		hmd.retry_process_loopback_records
007751  aa   000400 3750 03	ana  	256,du
007752  aa  5 00070 6551 00	ersa 	pr5|56		hmd.retry_process_loopback_records
						STATEMENT 1 ON LINE 2122
	     if needs_space then			/* couldn't reprocess it all now */
		call tty_space_man$needs_space (hmd.devx);

007753  aa  6 00124 2351 00	lda  	pr6|84		needs_space
007754  aa   000011 6000 04	tze  	9,ic		007765
007755  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
007756  aa  6 02106 2521 00	spri2	pr6|1094
007757  aa  6 02104 6211 00	eax1 	pr6|1092
007760  aa   004000 4310 07	fld  	2048,dl
007761  aa  6 00044 3701 20	epp4 	pr6|36,*
007762  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$needs_space
007763  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
007764  aa   000002 7100 04	tra  	2,ic		007766
						STATEMENT 1 ON LINE 2124
	     else call process_output_block ();

007765  aa   000613 6700 04	tsp4 	395,ic		010600
						STATEMENT 1 ON LINE 2126
	     if hmd.loopback.first_bufferp = null () then do;

007766  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
007767  aa  7 00046 2371 00	ldaq 	pr7|38		hmd.first_bufferp
007770  aa   770222 6770 04	eraq 	-3950,ic		000212 = 077777000043 000001000000
007771  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
007772  aa   000007 6010 04	tnz  	7,ic		010001
						STATEMENT 1 ON LINE 2127
		call pop_minor_state ();

007773  aa   774113 6700 04	tsp4 	-1973,ic		004106
						STATEMENT 1 ON LINE 2128
		if (hmd.minor_state = HMD_NORMAL) then	/* OK for subchannels to send output again */
		     call interrupt_subchannels_with_output ();

007774  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
007775  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
007776  aa   000003 1160 07	cmpq 	3,dl
007777  aa   000002 6010 04	tnz  	2,ic		010001
010000  aa   774677 6700 04	tsp4 	-1601,ic		004677
						STATEMENT 1 ON LINE 2130
	     end;

						STATEMENT 1 ON LINE 2132
	     hste_ptr = saved_hste_ptr;

010001  aa  6 00520 3735 20	epp7 	pr6|336,*		saved_hste_ptr
010002  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 2134
	     return;

010003  aa  6 00510 6101 00	rtcd 	pr6|328
						STATEMENT 1 ON LINE 2328
	end input_loopback_records_processor;

BEGIN PROCEDURE find_subchannel
ENTRY TO find_subchannel                                    STATEMENT 1 ON LINE 2138
find_subchannel: procedure (P_rcb_char) returns (pointer);

010004  aa  6 00542 6501 00	spri4	pr6|354
010005  aa  6 00544 2521 00	spri2	pr6|356
						STATEMENT 1 ON LINE 2145
		do idx = 1 to hmd.n_subchannels;

010006  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010007  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
010010  aa  6 00551 7561 00	stq  	pr6|361
010011  aa   000001 2360 07	ldq  	1,dl
010012  aa  6 00550 7561 00	stq  	pr6|360		idx
010013  aa   000000 0110 03	nop  	0,du
010014  aa  6 00550 2361 00	ldq  	pr6|360		idx
010015  aa  6 00551 1161 00	cmpq 	pr6|361
010016  aa   000043 6054 04	tpnz 	35,ic		010061
						STATEMENT 1 ON LINE 2147
		     if (hmd.subchannels(idx).device_type = HASP_CONSOLE) then   /* console is special case */
			if (P_rcb_char = HASP_CONSOLE_INPUT_RCB) | (P_rcb_char = HASP_CONSOLE_OUTPUT_RCB) then
			     return (addr (hmd.subchannels (idx)));

010017  aa   000050 4020 07	mpy  	40,dl
010020  aa  6 02114 7561 00	stq  	pr6|1100
010021  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010022  aa  7 00047 2361 06	ldq  	pr7|39,ql		hmd.device_type
010023  aa   000001 1160 07	cmpq 	1,dl
010024  aa   000020 6010 04	tnz  	16,ic		010044
010025  aa  6 00544 3715 20	epp5 	pr6|356,*
010026  aa  5 00002 3535 20	epp3 	pr5|2,*
010027  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
010030  aa  3 00000 00 0001	desc9a	pr3|0,1		P_rcb_char
010031  aa  6 02115 00 0004	desc9a	pr6|1101,4	P_rcb_char
010032  aa  6 02115 2351 00	lda  	pr6|1101		P_rcb_char
010033  aa   770066 1150 04	cmpa 	-4042,ic		000121 = 222000000000
010034  aa   000003 6000 04	tze  	3,ic		010037
010035  aa   770063 1150 04	cmpa 	-4045,ic		000120 = 221000000000
010036  aa   000021 6010 04	tnz  	17,ic		010057
010037  aa  6 02114 7271 00	lxl7 	pr6|1100
010040  aa  7 00044 3515 17	epp1 	pr7|36,7		hmd.subchannels
010041  aa  5 00004 2515 20	spri1	pr5|4,*
010042  aa  6 00542 6101 00	rtcd 	pr6|354
						STATEMENT 1 ON LINE 2150
			else;

010043  aa   000014 7100 04	tra  	12,ic		010057
						STATEMENT 1 ON LINE 2152
		     else if (hmd.subchannels(idx).rcb = P_rcb_char) then
			return (addr (hmd.subchannels (idx)));

010044  aa  6 02114 7271 00	lxl7 	pr6|1100
010045  aa  7 00052 3715 17	epp5 	pr7|42,7		hmd.rcb
010046  aa  6 00544 3535 20	epp3 	pr6|356,*
010047  aa  3 00002 3515 20	epp1 	pr3|2,*
010050  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
010051  aa  5 00000 00 0001	desc9a	pr5|0,1		hmd.rcb
010052  aa  1 00000 00 0001	desc9a	pr1|0,1		P_rcb_char
010053  aa   000004 6010 04	tnz  	4,ic		010057
010054  aa  7 00044 3715 17	epp5 	pr7|36,7		hmd.subchannels
010055  aa  3 00004 6515 20	spri5	pr3|4,*
010056  aa  6 00542 6101 00	rtcd 	pr6|354
						STATEMENT 1 ON LINE 2154
		end;

010057  aa  6 00550 0541 00	aos  	pr6|360		idx
010060  aa   777734 7100 04	tra  	-36,ic		010014
						STATEMENT 1 ON LINE 2156
		return (null ());

010061  aa   770131 2370 04	ldaq 	-4007,ic		000212 = 077777000043 000001000000
010062  aa  6 00544 3735 20	epp7 	pr6|356,*
010063  aa  7 00004 7571 20	staq 	pr7|4,*
010064  aa  6 00542 6101 00	rtcd 	pr6|354
						STATEMENT 1 ON LINE 2158
	     end find_subchannel;

  END PROCEDURE find_subchannel
BEGIN PROCEDURE flush_record_buffers
ENTRY TO flush_record_buffers                               STATEMENT 1 ON LINE 2163
flush_record_buffers:
	     procedure ();

010065  aa  6 00552 6501 00	spri4	pr6|362
						STATEMENT 1 ON LINE 2168
		bufferp = start_bufferp;

010066  aa  6 00522 3735 20	epp7 	pr6|338,*		start_bufferp
010067  aa  6 00560 6535 00	spri7	pr6|368		bufferp
						STATEMENT 1 ON LINE 2170
		do while (bufferp ^= null ());

010070  aa  6 00560 2371 00	ldaq 	pr6|368		bufferp
010071  aa   770121 6770 04	eraq 	-4015,ic		000212 = 077777000043 000001000000
010072  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010073  aa   000041 6000 04	tze  	33,ic		010134
						STATEMENT 1 ON LINE 2172
		     if bufferp = end_bufferp then	/* never free the last buffer of the record:  caller will */
			bufferp = null ();

010074  aa  6 00560 2371 00	ldaq 	pr6|368		bufferp
010075  aa  6 00524 6771 00	eraq 	pr6|340		end_bufferp
010076  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010077  aa   000004 6010 04	tnz  	4,ic		010103
010100  aa   770112 2370 04	ldaq 	-4022,ic		000212 = 077777000043 000001000000
010101  aa  6 00560 7571 00	staq 	pr6|368		bufferp
010102  aa   777766 7100 04	tra  	-10,ic		010070
						STATEMENT 1 ON LINE 2175
		     else do;

						STATEMENT 1 ON LINE 2176
			if (bufferp -> buffer.next) = 0 then
			     p = null ();

010103  aa  6 00560 2351 20	lda  	pr6|368,*		buffer.next
010104  aa   000066 7730 00	lrl  	54
010105  aa  6 02116 7561 00	stq  	pr6|1102		buffer.next
010106  aa   000004 6010 04	tnz  	4,ic		010112
010107  aa   770103 2370 04	ldaq 	-4029,ic		000212 = 077777000043 000001000000
010110  aa  6 00562 7571 00	staq 	pr6|370		p
010111  aa   000004 7100 04	tra  	4,ic		010115
						STATEMENT 1 ON LINE 2178
			else p = pointer (ttybp, bufferp -> buffer.next);

010112  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
010113  aa   000000 3120 06	eawp2	0,ql
010114  aa  6 00562 2521 00	spri2	pr6|370		p
						STATEMENT 1 ON LINE 2179
			call tty_space_man$free_buffer (hmd.devx, INPUT, bufferp);

010115  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010116  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
010117  aa  6 02122 2521 00	spri2	pr6|1106
010120  aa   767772 3520 04	epp2 	-4102,ic		000112 = 000000000000
010121  aa  6 02124 2521 00	spri2	pr6|1108
010122  aa  6 00560 3521 00	epp2 	pr6|368		bufferp
010123  aa  6 02126 2521 00	spri2	pr6|1110
010124  aa  6 02120 6211 00	eax1 	pr6|1104
010125  aa   014000 4310 07	fld  	6144,dl
010126  aa  6 00044 3701 20	epp4 	pr6|36,*
010127  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
010130  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2180
			bufferp = p;

010131  aa  6 00562 3735 20	epp7 	pr6|370,*		p
010132  aa  6 00560 6535 00	spri7	pr6|368		bufferp
						STATEMENT 1 ON LINE 2181
		     end;

						STATEMENT 1 ON LINE 2182
		end;

010133  aa   777735 7100 04	tra  	-35,ic		010070
						STATEMENT 1 ON LINE 2184
		return;

010134  aa  6 00552 6101 00	rtcd 	pr6|362
						STATEMENT 1 ON LINE 2186
	     end flush_record_buffers;

  END PROCEDURE flush_record_buffers
BEGIN PROCEDURE move_record_to_device
ENTRY TO move_record_to_device                              STATEMENT 1 ON LINE 2191
move_record_to_device:
	     procedure ();

010135  aa  6 00564 6501 00	spri4	pr6|372
						STATEMENT 1 ON LINE 2206
		if input_entry then
		     direction = INPUT;

010136  aa  6 00516 2351 00	lda  	pr6|334		input_entry
010137  aa   000003 6000 04	tze  	3,ic		010142
010140  aa  6 00620 4501 00	stz  	pr6|400		direction
010141  aa   000003 7100 04	tra  	3,ic		010144
						STATEMENT 1 ON LINE 2208
		else direction = OUTPUT;

010142  aa   400000 2350 03	lda  	131072,du
010143  aa  6 00620 2551 00	orsa 	pr6|400		direction
						STATEMENT 1 ON LINE 2210
		buffer_size_code = divide (hste.dialup_info.max_buf_size, 16, 17, 0) - 1;

010144  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010145  aa  7 00011 2351 00	lda  	pr7|9		hste.max_buf_size
010146  aa   000077 7730 00	lrl  	63
010147  aa  6 02130 7561 00	stq  	pr6|1112		hste.max_buf_size
010150  aa   000020 5060 07	div  	16,dl
010151  aa   000001 1760 07	sbq  	1,dl
010152  aa  6 00610 7561 00	stq  	pr6|392		buffer_size_code
						STATEMENT 1 ON LINE 2212
		n_buffers = divide ((record_tally + max_buffer_tally (buffer_size_code) - 1),
			          max_buffer_tally (buffer_size_code), 17, 0);

010153  aa  6 00537 2361 00	ldq  	pr6|351		record_tally
010154  aa  6 00610 7271 00	lxl7 	pr6|392		buffer_size_code
010155  ta   000102 0760 17	adq  	66,7
010156  aa   000001 1760 07	sbq  	1,dl
010157  ta   000102 5060 17	div  	66,7
010160  aa  6 00611 7561 00	stq  	pr6|393		n_buffers
						STATEMENT 1 ON LINE 2215
		if n_buffers = 1 then
		     first_output_bufferp = null ();

010161  aa   000001 1160 07	cmpq 	1,dl
010162  aa   000004 6010 04	tnz  	4,ic		010166
010163  aa   770027 2370 04	ldaq 	-4073,ic		000212 = 077777000043 000001000000
010164  aa  6 00576 7571 00	staq 	pr6|382		first_output_bufferp
010165  aa   000053 7100 04	tra  	43,ic		010240
						STATEMENT 1 ON LINE 2218
		else do;

						STATEMENT 1 ON LINE 2219
		     call tty_space_man$get_chain (hste.devx, (hste.dialup_info.max_buf_size), (n_buffers - 1),
					     direction, first_output_bufferp);

010166  aa  6 02130 2361 00	ldq  	pr6|1112		hste.max_buf_size
010167  aa  6 02131 7561 00	stq  	pr6|1113
010170  aa  6 00611 2361 00	ldq  	pr6|393		n_buffers
010171  aa   000001 1760 07	sbq  	1,dl
010172  aa  6 02130 7561 00	stq  	pr6|1112
010173  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
010174  aa  6 02134 2521 00	spri2	pr6|1116
010175  aa  6 02131 3521 00	epp2 	pr6|1113
010176  aa  6 02136 2521 00	spri2	pr6|1118
010177  aa  6 02130 3521 00	epp2 	pr6|1112
010200  aa  6 02140 2521 00	spri2	pr6|1120
010201  aa  6 00620 3521 00	epp2 	pr6|400		direction
010202  aa  6 02142 2521 00	spri2	pr6|1122
010203  aa  6 00576 3521 00	epp2 	pr6|382		first_output_bufferp
010204  aa  6 02144 2521 00	spri2	pr6|1124
010205  aa  6 02132 6211 00	eax1 	pr6|1114
010206  aa   024000 4310 07	fld  	10240,dl
010207  aa  6 00044 3701 20	epp4 	pr6|36,*
010210  la  4 00114 3521 20	epp2 	pr4|76,*		tty_space_man$get_chain
010211  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2221
			if first_output_bufferp = null () then go to CANT_MOVE_RECORD_TO_DEVICE;

010212  aa  6 00576 2371 00	ldaq 	pr6|382		first_output_bufferp
010213  aa   767777 6770 04	eraq 	-4097,ic		000212 = 077777000043 000001000000
010214  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010215  aa   000356 6000 04	tze  	238,ic		010573
						STATEMENT 1 ON LINE 2222
		     last_output_bufferp = first_output_bufferp;

010216  aa  6 00576 3735 20	epp7 	pr6|382,*		first_output_bufferp
010217  aa  6 00600 6535 00	spri7	pr6|384		last_output_bufferp
						STATEMENT 1 ON LINE 2223
		     do idx = 1 to (n_buffers - 2);

010220  aa  6 00611 2361 00	ldq  	pr6|393		n_buffers
010221  aa   000002 1760 07	sbq  	2,dl
010222  aa  6 00621 7561 00	stq  	pr6|401
010223  aa   000001 2360 07	ldq  	1,dl
010224  aa  6 00613 7561 00	stq  	pr6|395		idx
010225  aa   000000 0110 03	nop  	0,du
010226  aa  6 00613 2361 00	ldq  	pr6|395		idx
010227  aa  6 00621 1161 00	cmpq 	pr6|401
010230  aa   000010 6054 04	tpnz 	8,ic		010240
						STATEMENT 1 ON LINE 2224
			last_output_bufferp = pointer (ttybp, last_output_bufferp -> buffer.next);

010231  aa  6 00600 2351 20	lda  	pr6|384,*		buffer.next
010232  aa   000066 7730 00	lrl  	54
010233  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
010234  aa   000000 3120 06	eawp2	0,ql
010235  aa  6 00600 2521 00	spri2	pr6|384		last_output_bufferp
						STATEMENT 1 ON LINE 2225
		     end;

010236  aa  6 00613 0541 00	aos  	pr6|395		idx
010237  aa   777767 7100 04	tra  	-9,ic		010226
						STATEMENT 1 ON LINE 2226
		end;

						STATEMENT 1 ON LINE 2228
		n_words_in_last_buffer =		/* need a buffer big enough for remainder of record */
		     16 * divide ((record_tally - (n_buffers - 1) * max_buffer_tally (buffer_size_code)) + 67, 64, 17, 0);

010240  aa  6 00611 2361 00	ldq  	pr6|393		n_buffers
010241  aa   000001 1760 07	sbq  	1,dl
010242  aa  6 00610 7271 00	lxl7 	pr6|392		buffer_size_code
010243  ta   000102 4020 17	mpy  	66,7
010244  aa   000000 5330 00	negl 	0
010245  aa  6 00537 0331 00	adl  	pr6|351		record_tally
010246  aa   000103 0330 07	adl  	67,dl
010247  aa   005611 3520 04	epp2 	2953,ic		016060 = 000000000100
010250  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
010251  aa     000000000000
010252  aa   000004 7360 00	qls  	4
010253  aa  6 00612 7561 00	stq  	pr6|394		n_words_in_last_buffer
						STATEMENT 1 ON LINE 2231
		call tty_space_man$get_buffer (hste.devx, n_words_in_last_buffer, direction, current_output_bufferp);

010254  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010255  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
010256  aa  6 02134 2521 00	spri2	pr6|1116
010257  aa  6 00612 3521 00	epp2 	pr6|394		n_words_in_last_buffer
010260  aa  6 02136 2521 00	spri2	pr6|1118
010261  aa  6 00620 3521 00	epp2 	pr6|400		direction
010262  aa  6 02140 2521 00	spri2	pr6|1120
010263  aa  6 00602 3521 00	epp2 	pr6|386		current_output_bufferp
010264  aa  6 02142 2521 00	spri2	pr6|1122
010265  aa  6 02132 6211 00	eax1 	pr6|1114
010266  aa   020000 4310 07	fld  	8192,dl
010267  aa  6 00044 3701 20	epp4 	pr6|36,*
010270  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
010271  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2232
		     if current_output_bufferp = null () then do;

010272  aa  6 00602 2371 00	ldaq 	pr6|386		current_output_bufferp
010273  aa   767717 6770 04	eraq 	-4145,ic		000212 = 077777000043 000001000000
010274  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010275  aa   000022 6010 04	tnz  	18,ic		010317
						STATEMENT 1 ON LINE 2233
			if first_output_bufferp ^= null () then
			     call tty_space_man$free_chain (hste.devx, direction, first_output_bufferp);

010276  aa  6 00576 2371 00	ldaq 	pr6|382		first_output_bufferp
010277  aa   767713 6770 04	eraq 	-4149,ic		000212 = 077777000043 000001000000
010300  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010301  aa   000272 6000 04	tze  	186,ic		010573
010302  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010303  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
010304  aa  6 02134 2521 00	spri2	pr6|1116
010305  aa  6 00620 3521 00	epp2 	pr6|400		direction
010306  aa  6 02136 2521 00	spri2	pr6|1118
010307  aa  6 00576 3521 00	epp2 	pr6|382		first_output_bufferp
010310  aa  6 02140 2521 00	spri2	pr6|1120
010311  aa  6 02132 6211 00	eax1 	pr6|1114
010312  aa   014000 4310 07	fld  	6144,dl
010313  aa  6 00044 3701 20	epp4 	pr6|36,*
010314  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
010315  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2235
			go to CANT_MOVE_RECORD_TO_DEVICE;

010316  aa   000255 7100 04	tra  	173,ic		010573
						STATEMENT 1 ON LINE 2236
		     end;

						STATEMENT 1 ON LINE 2238
		if first_output_bufferp = null () then	/* only buffer needed */
		     first_output_bufferp = current_output_bufferp;

010317  aa  6 00576 2371 00	ldaq 	pr6|382		first_output_bufferp
010320  aa   767672 6770 04	eraq 	-4166,ic		000212 = 077777000043 000001000000
010321  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010322  aa   000004 6010 04	tnz  	4,ic		010326
010323  aa  6 00602 3735 20	epp7 	pr6|386,*		current_output_bufferp
010324  aa  6 00576 6535 00	spri7	pr6|382		first_output_bufferp
010325  aa   000006 7100 04	tra  	6,ic		010333
						STATEMENT 1 ON LINE 2240
		else last_output_bufferp -> buffer.next = binary (rel (current_output_bufferp), 18, 0);

010326  aa  6 00602 6351 20	eaa  	pr6|386,*		current_output_bufferp
010327  aa   000066 7730 00	lrl  	54
010330  aa   000066 7370 00	lls  	54
010331  aa  6 00600 3735 20	epp7 	pr6|384,*		buffer.next
010332  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 2242
		last_output_bufferp = current_output_bufferp;

010333  aa  6 00602 3735 20	epp7 	pr6|386,*		current_output_bufferp
010334  aa  6 00600 6535 00	spri7	pr6|384		last_output_bufferp
						STATEMENT 1 ON LINE 2244
		amount_to_copy = record_tally;

010335  aa  6 00537 2361 00	ldq  	pr6|351		record_tally
010336  aa  6 00614 7561 00	stq  	pr6|396		amount_to_copy
						STATEMENT 1 ON LINE 2246
		current_input_bufferp = start_bufferp;

010337  aa  6 00522 3715 20	epp5 	pr6|338,*		start_bufferp
010340  aa  6 00604 6515 00	spri5	pr6|388		current_input_bufferp
						STATEMENT 1 ON LINE 2247
		current_input_idx = start_record_idx + 1;

010341  aa  6 00526 2361 00	ldq  	pr6|342		start_record_idx
010342  aa   000001 0760 07	adq  	1,dl
010343  aa  6 00615 7561 00	stq  	pr6|397		current_input_idx
						STATEMENT 1 ON LINE 2249
		current_output_bufferp = first_output_bufferp;

010344  aa  6 00576 3535 20	epp3 	pr6|382,*		first_output_bufferp
010345  aa  6 00602 2535 00	spri3	pr6|386		current_output_bufferp
						STATEMENT 1 ON LINE 2251
		do while (amount_to_copy > 0);

010346  aa  6 00614 2361 00	ldq  	pr6|396		amount_to_copy
010347  aa   000137 6044 04	tmoz 	95,ic		010506
						STATEMENT 1 ON LINE 2253
		     space_left = max_buffer_tally (current_output_bufferp -> buffer.size_code) -
			           (current_output_bufferp -> buffer.tally);

010350  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.size_code
010351  aa   000030 7350 00	als  	24
010352  aa   000105 7730 00	lrl  	69
010353  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.tally
010354  aa   000033 7350 00	als  	27
010355  aa   000000 6270 06	eax7 	0,ql
010356  aa   000077 7730 00	lrl  	63
010357  aa  6 02131 7561 00	stq  	pr6|1113		buffer.tally
010360  ta   000102 2360 17	ldq  	66,7
010361  aa  6 02131 1761 00	sbq  	pr6|1113		buffer.tally
010362  aa  6 00617 7561 00	stq  	pr6|399		space_left
						STATEMENT 1 ON LINE 2255
		     space_needed = min ((current_input_bufferp -> buffer.tally - current_input_idx), amount_to_copy);

010363  aa  6 00604 2361 20	ldq  	pr6|388,*		buffer.tally
010364  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
010365  aa  6 00615 1761 00	sbq  	pr6|397		current_input_idx
010366  aa  6 00614 1161 00	cmpq 	pr6|396		amount_to_copy
010367  aa   000002 6040 04	tmi  	2,ic		010371
010370  aa  6 00614 2361 00	ldq  	pr6|396		amount_to_copy
010371  aa  6 00616 7561 00	stq  	pr6|398		space_needed
						STATEMENT 1 ON LINE 2257
		     if space_left >= space_needed then
			substr_lth = space_needed;

010372  aa  6 00617 1161 00	cmpq 	pr6|399		space_left
010373  aa   000003 6054 04	tpnz 	3,ic		010376
010374  aa  6 00574 7561 00	stq  	pr6|380		substr_lth
010375  aa   000003 7100 04	tra  	3,ic		010400
						STATEMENT 1 ON LINE 2259
		     else substr_lth = space_left;

010376  aa  6 00617 2361 00	ldq  	pr6|399		space_left
010377  aa  6 00574 7561 00	stq  	pr6|380		substr_lth
						STATEMENT 1 ON LINE 2261
		     addr (current_output_bufferp -> buffer.chars (current_output_bufferp -> buffer.tally)) -> substring
			= addr (current_input_bufferp -> buffer.chars (current_input_idx)) -> substring;

010400  aa  6 02131 7261 00	lxl6 	pr6|1113		buffer.tally
010401  aa  6 00602 3735 20	epp7 	pr6|386,*		current_output_bufferp
010402  aa  6 00615 7251 00	lxl5 	pr6|397		current_input_idx
010403  aa  6 00604 3715 20	epp5 	pr6|388,*		current_input_bufferp
010404  aa  040 156 100 555	mlr  	(pr,rl,x5),(pr,rl,x6),fill(040)
010405  aa  5 00001 00 0006	desc9a	pr5|1,ql		substring
010406  aa  7 00001 00 0006	desc9a	pr7|1,ql		substring
						STATEMENT 1 ON LINE 2264
		     current_output_bufferp -> buffer.tally = (current_output_bufferp -> buffer.tally) + substr_lth;

010407  aa  6 02131 0761 00	adq  	pr6|1113		buffer.tally
010410  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2265
		     current_input_idx = current_input_idx + substr_lth;

010411  aa  6 00574 2361 00	ldq  	pr6|380		substr_lth
010412  aa  6 00615 0561 00	asq  	pr6|397		current_input_idx
						STATEMENT 1 ON LINE 2266
		     amount_to_copy = amount_to_copy - substr_lth;

010413  aa  6 00574 3361 00	lcq  	pr6|380		substr_lth
010414  aa  6 00614 0561 00	asq  	pr6|396		amount_to_copy
						STATEMENT 1 ON LINE 2268
		     if (amount_to_copy > 0) & (current_input_idx = (current_input_bufferp -> buffer.tally))
		     then do;

010415  aa  6 00614 2361 00	ldq  	pr6|396		amount_to_copy
010416  aa   000043 6044 04	tmoz 	35,ic		010461
010417  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
010420  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
010421  aa  6 00615 1161 00	cmpq 	pr6|397		current_input_idx
010422  aa   000037 6010 04	tnz  	31,ic		010461
						STATEMENT 1 ON LINE 2270
			if (current_input_bufferp -> buffer.next) = 0
			then do;

010423  aa  5 00000 2351 00	lda  	pr5|0		buffer.next
010424  aa   000066 7730 00	lrl  	54
010425  aa  6 02131 7561 00	stq  	pr6|1113		buffer.next
010426  aa   000005 6010 04	tnz  	5,ic		010433
						STATEMENT 1 ON LINE 2272
			     p = null ();

010427  aa   767563 2370 04	ldaq 	-4237,ic		000212 = 077777000043 000001000000
010430  aa  6 00606 7571 00	staq 	pr6|390		p
						STATEMENT 1 ON LINE 2273
			     amount_to_copy = 0;

010431  aa  6 00614 4501 00	stz  	pr6|396		amount_to_copy
						STATEMENT 1 ON LINE 2274
			end;

010432  aa   000004 7100 04	tra  	4,ic		010436
						STATEMENT 1 ON LINE 2275
			else p = pointer (ttybp, current_input_bufferp -> buffer.next);

010433  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
010434  aa   000000 3120 06	eawp2	0,ql
010435  aa  6 00606 2521 00	spri2	pr6|390		p
						STATEMENT 1 ON LINE 2276
			if current_input_bufferp ^= end_bufferp then
			     call tty_space_man$free_buffer (hmd.devx, INPUT, current_input_bufferp);

010436  aa  6 00604 2371 00	ldaq 	pr6|388		current_input_bufferp
010437  aa  6 00524 6771 00	eraq 	pr6|340		end_bufferp
010440  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010441  aa   000015 6000 04	tze  	13,ic		010456
010442  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
010443  aa  3 00010 3521 00	epp2 	pr3|8		hmd.devx
010444  aa  6 02134 2521 00	spri2	pr6|1116
010445  aa   767445 3520 04	epp2 	-4315,ic		000112 = 000000000000
010446  aa  6 02136 2521 00	spri2	pr6|1118
010447  aa  6 00604 3521 00	epp2 	pr6|388		current_input_bufferp
010450  aa  6 02140 2521 00	spri2	pr6|1120
010451  aa  6 02132 6211 00	eax1 	pr6|1114
010452  aa   014000 4310 07	fld  	6144,dl
010453  aa  6 00044 3701 20	epp4 	pr6|36,*
010454  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
010455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2279
			current_input_bufferp = p;

010456  aa  6 00606 3735 20	epp7 	pr6|390,*		p
010457  aa  6 00604 6535 00	spri7	pr6|388		current_input_bufferp
						STATEMENT 1 ON LINE 2280
			current_input_idx = 0;

010460  aa  6 00615 4501 00	stz  	pr6|397		current_input_idx
						STATEMENT 1 ON LINE 2281
		     end;

						STATEMENT 1 ON LINE 2283
		     if (amount_to_copy > 0) &	/* if there is stuff left to copy ... */
		        ((current_output_bufferp -> buffer.tally) = 
		         max_buffer_tally (current_output_bufferp -> buffer.size_code))
		     then				/* ... and used up this output buffer:  grab next one */
		     if (current_output_bufferp -> buffer.next) = 0 then
			     amount_to_copy = 0;

010461  aa  6 00614 2361 00	ldq  	pr6|396		amount_to_copy
010462  aa   777664 6044 04	tmoz 	-76,ic		010346
010463  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.size_code
010464  aa   000030 7350 00	als  	24
010465  aa   000105 7730 00	lrl  	69
010466  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.tally
010467  aa   000033 7350 00	als  	27
010470  aa   000000 6270 06	eax7 	0,ql
010471  aa   000077 7730 00	lrl  	63
010472  ta   000102 1160 17	cmpq 	66,7
010473  aa   777653 6010 04	tnz  	-85,ic		010346
010474  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.next
010475  aa   000066 7730 00	lrl  	54
010476  aa  6 02131 7561 00	stq  	pr6|1113		buffer.next
010477  aa   000003 6010 04	tnz  	3,ic		010502
010500  aa  6 00614 4501 00	stz  	pr6|396		amount_to_copy
010501  aa   777645 7100 04	tra  	-91,ic		010346
						STATEMENT 1 ON LINE 2289
			else current_output_bufferp = pointer (ttybp, current_output_bufferp -> buffer.next);

010502  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
010503  aa   000000 3120 06	eawp2	0,ql
010504  aa  6 00602 2521 00	spri2	pr6|386		current_output_bufferp
						STATEMENT 1 ON LINE 2290
		end;

010505  aa   777641 7100 04	tra  	-95,ic		010346
						STATEMENT 1 ON LINE 2292
		if current_output_bufferp ^= last_output_bufferp then do;

010506  aa  6 00602 2371 00	ldaq 	pr6|386		current_output_bufferp
010507  aa  6 00600 6771 00	eraq 	pr6|384		last_output_bufferp
010510  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010511  aa   000027 6000 04	tze  	23,ic		010540
						STATEMENT 1 ON LINE 2294
		     p = pointer (ttybp, current_output_bufferp -> buffer.next);

010512  aa  6 00602 2351 20	lda  	pr6|386,*		buffer.next
010513  aa   000066 7730 00	lrl  	54
010514  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
010515  aa   000000 3120 06	eawp2	0,ql
010516  aa  6 00606 2521 00	spri2	pr6|390		p
						STATEMENT 1 ON LINE 2295
		     call tty_space_man$free_chain (hste.devx, direction, p);

010517  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010520  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
010521  aa  6 02134 2521 00	spri2	pr6|1116
010522  aa  6 00620 3521 00	epp2 	pr6|400		direction
010523  aa  6 02136 2521 00	spri2	pr6|1118
010524  aa  6 00606 3521 00	epp2 	pr6|390		p
010525  aa  6 02140 2521 00	spri2	pr6|1120
010526  aa  6 02132 6211 00	eax1 	pr6|1114
010527  aa   014000 4310 07	fld  	6144,dl
010530  aa  6 00044 3701 20	epp4 	pr6|36,*
010531  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
010532  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2296
		     current_output_bufferp -> buffer.next = 0;

010533  aa   000000 2350 07	lda  	0,dl
010534  aa  6 00602 3735 20	epp7 	pr6|386,*		buffer.next
010535  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 2297
		     last_output_bufferp = current_output_bufferp;

010536  aa  6 00602 3715 20	epp5 	pr6|386,*		current_output_bufferp
010537  aa  6 00600 6515 00	spri5	pr6|384		last_output_bufferp
						STATEMENT 1 ON LINE 2298
		end;

						STATEMENT 1 ON LINE 2300
		if input_entry then
		     record_data_ptr = addr (hste.input);

010540  aa  6 00516 2351 00	lda  	pr6|334		input_entry
010541  aa   000005 6000 04	tze  	5,ic		010546
010542  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010543  aa  7 00016 3735 00	epp7 	pr7|14		hste.input
010544  aa  6 00572 6535 00	spri7	pr6|378		record_data_ptr
010545  aa   000004 7100 04	tra  	4,ic		010551
						STATEMENT 1 ON LINE 2302
		else record_data_ptr = addr (hste.loopback);

010546  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
010547  aa  7 00024 3735 00	epp7 	pr7|20		hste.loopback
010550  aa  6 00572 6535 00	spri7	pr6|378		record_data_ptr
						STATEMENT 1 ON LINE 2304
		last_output_bufferp -> buffer.break = "1"b;

010551  aa   100000 2350 07	lda  	32768,dl
010552  aa  6 00600 2551 20	orsa 	pr6|384,*		buffer.break
						STATEMENT 1 ON LINE 2306
		if record_data.first_bufferp = null () then
		     record_data.first_bufferp = first_output_bufferp;

010553  aa  7 00002 2371 00	ldaq 	pr7|2		record_data.first_bufferp
010554  aa   767436 6770 04	eraq 	-4322,ic		000212 = 077777000043 000001000000
010555  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010556  aa   000004 6010 04	tnz  	4,ic		010562
010557  aa  6 00576 3715 20	epp5 	pr6|382,*		first_output_bufferp
010560  aa  7 00002 6515 00	spri5	pr7|2		record_data.first_bufferp
010561  aa   000006 7100 04	tra  	6,ic		010567
						STATEMENT 1 ON LINE 2308
		else record_data.last_bufferp -> buffer.next = binary (rel (first_output_bufferp), 18, 0);

010562  aa  6 00576 6351 20	eaa  	pr6|382,*		first_output_bufferp
010563  aa   000066 7730 00	lrl  	54
010564  aa   000066 7370 00	lls  	54
010565  aa  7 00004 3715 20	epp5 	pr7|4,*		buffer.next
010566  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 2310
		record_data.last_bufferp = last_output_bufferp;

010567  aa  6 00600 3715 20	epp5 	pr6|384,*		last_output_bufferp
010570  aa  7 00004 6515 00	spri5	pr7|4		record_data.last_bufferp
						STATEMENT 1 ON LINE 2312
		record_data.n_records = record_data.n_records + 1;

010571  aa  7 00000 0541 00	aos  	pr7|0		record_data.n_records
						STATEMENT 1 ON LINE 2314
		return;

010572  aa  6 00564 6101 00	rtcd 	pr6|372
						STATEMENT 1 ON LINE 2320
CANT_MOVE_RECORD_TO_DEVICE:
		needs_space = "1"b;

010573  aa   400000 2350 03	lda  	131072,du
010574  aa  6 00124 7551 00	sta  	pr6|84		needs_space
						STATEMENT 1 ON LINE 2322
		if input_entry then
		     go to RETURN_FROM_PROCESS_INPUT_RECORDS;

010575  aa  6 00516 2351 00	lda  	pr6|334		input_entry
010576  aa   776545 6010 04	tnz  	-667,ic		007343
						STATEMENT 1 ON LINE 2324
		else go to RETURN_FROM_PROCESS_LOOPBACK_RECORDS;

010577  aa   777125 7100 04	tra  	-427,ic		007724
						STATEMENT 1 ON LINE 2326
	     end move_record_to_device;

  END PROCEDURE move_record_to_device
  END PROCEDURE input_loopback_records_processor
BEGIN PROCEDURE process_output_block
ENTRY TO process_output_block                               STATEMENT 1 ON LINE 2334
process_output_block:
	procedure ();

010600  aa  6 00622 6501 00	spri4	pr6|402
						STATEMENT 1 ON LINE 2349
	     if hmd.output_in_progress then		/* finish what was already started */
		call transmit_output_block ();

010601  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010602  aa  7 00070 2351 00	lda  	pr7|56		hmd.output_in_progress
010603  aa   020000 3150 03	cana 	8192,du
010604  aa   000002 6000 04	tze  	2,ic		010606
010605  aa   003055 6700 04	tsp4 	1581,ic		013662
						STATEMENT 1 ON LINE 2352
	     if ^hmd.send_output then return;

010606  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010607  aa  7 00070 2351 00	lda  	pr7|56		hmd.send_output
010610  aa   100000 3150 03	cana 	32768,du
010611  aa   000002 6010 04	tnz  	2,ic		010613
010612  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2354
	     if hmd.suspend_all_output &		/* remote wants us not to send anything */
	        (hmd.minor_state ^= HMD_SEND_SYNC_BLOCK) &     /* and needn't send special sync-block for FNP */
	        (hmd.minor_state ^= HMD_SEND_BAD_BCB_BLOCK) &  /* and needn't send a bad BCB error block */
	        (hmd.minor_state ^= HMD_HANGUP_LINE)	/* and needn't hangup the line to punt after fatal error */
	     then
		return;

010613  aa  7 00070 2351 00	lda  	pr7|56		hmd.suspend_all_output
010614  aa   400000 3150 03	cana 	131072,du
010615  aa   000011 6000 04	tze  	9,ic		010626
010616  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
010617  aa   000004 1160 07	cmpq 	4,dl
010620  aa   000006 6000 04	tze  	6,ic		010626
010621  aa   000007 1160 07	cmpq 	7,dl
010622  aa   000004 6000 04	tze  	4,ic		010626
010623  aa   000010 1160 07	cmpq 	8,dl
010624  aa   000002 6000 04	tze  	2,ic		010626
010625  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2362
	     if (hmd.minor_state = HMD_HANGUP_LINE) then

/* Fatal error:  An error fatal to the operation of the multiplexer (eg: out of sequence input blocks) has occurred which
   needed to be acknowledged by a message from the multiplexer.  That message has been sent out to the FNP and the line
   should now be hungup which will crash the multiplexer */

		call channel_manager$control (hmd.devx, "hangup", null (), code);

010626  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
010627  aa   000010 1160 07	cmpq 	8,dl
010630  aa   000033 6010 04	tnz  	27,ic		010663
010631  aa   767353 2370 04	ldaq 	-4373,ic		000204 = 150141156147 165160000000
010632  aa  6 02146 7571 00	staq 	pr6|1126
010633  aa   767357 3714 24	epp5 	-4369,ic*
010634  aa  6 02150 6515 00	spri5	pr6|1128
010635  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
010636  aa  6 02154 2521 00	spri2	pr6|1132
010637  aa  6 02146 3521 00	epp2 	pr6|1126
010640  aa  6 02156 2521 00	spri2	pr6|1134
010641  aa  6 02150 3521 00	epp2 	pr6|1128
010642  aa  6 02160 2521 00	spri2	pr6|1136
010643  aa  6 00101 3521 00	epp2 	pr6|65		code
010644  aa  6 02162 2521 00	spri2	pr6|1138
010645  aa   767330 3520 04	epp2 	-4392,ic		000175 = 404000000021
010646  aa  6 02164 2521 00	spri2	pr6|1140
010647  aa   767304 3520 04	epp2 	-4412,ic		000153 = 524000000006
010650  aa  6 02166 2521 00	spri2	pr6|1142
010651  aa   767326 3520 04	epp2 	-4394,ic		000177 = 464000000000
010652  aa  6 02170 2521 00	spri2	pr6|1144
010653  aa   767320 3520 04	epp2 	-4400,ic		000173 = 404000000043
010654  aa  6 02172 2521 00	spri2	pr6|1146
010655  aa  6 02152 6211 00	eax1 	pr6|1130
010656  aa   020000 4310 07	fld  	8192,dl
010657  aa  6 00044 3701 20	epp4 	pr6|36,*
010660  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
010661  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
010662  aa   000537 7100 04	tra  	351,ic		011421
						STATEMENT 1 ON LINE 2371
	     else if (hmd.minor_state = HMD_SEND_BAD_BCB_BLOCK)
	     then do;

010663  aa   000007 1160 07	cmpq 	7,dl
010664  aa   000120 6010 04	tnz  	80,ic		011004
						STATEMENT 1 ON LINE 2377
		if hmd.output_block.first_bufferp ^= null ()
		then do;

010665  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
010666  aa   767324 6770 04	eraq 	-4396,ic		000212 = 077777000043 000001000000
010667  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010670  aa   000017 6000 04	tze  	15,ic		010707
						STATEMENT 1 ON LINE 2379
		     call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);

010671  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
010672  aa  6 02154 2521 00	spri2	pr6|1132
010673  aa   767267 3520 04	epp2 	-4425,ic		000162 = 400000000000
010674  aa  6 02156 2521 00	spri2	pr6|1134
010675  aa  7 00054 3521 00	epp2 	pr7|44		hmd.first_bufferp
010676  aa  6 02160 2521 00	spri2	pr6|1136
010677  aa  6 02152 6211 00	eax1 	pr6|1130
010700  aa   014000 4310 07	fld  	6144,dl
010701  aa  6 00044 3701 20	epp4 	pr6|36,*
010702  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
010703  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2380
		     hmd.output_block.first_bufferp = null ();

010704  aa   767306 2370 04	ldaq 	-4410,ic		000212 = 077777000043 000001000000
010705  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
010706  aa  7 00054 7571 00	staq 	pr7|44		hmd.first_bufferp
						STATEMENT 1 ON LINE 2381
		end;

						STATEMENT 1 ON LINE 2383
		call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);

010707  aa   000020 2360 07	ldq  	16,dl
010710  aa  6 02174 7561 00	stq  	pr6|1148
010711  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
010712  aa  6 02154 2521 00	spri2	pr6|1132
010713  aa  6 02174 3521 00	epp2 	pr6|1148
010714  aa  6 02156 2521 00	spri2	pr6|1134
010715  aa   767245 3520 04	epp2 	-4443,ic		000162 = 400000000000
010716  aa  6 02160 2521 00	spri2	pr6|1136
010717  aa  6 00162 3521 00	epp2 	pr6|114		blockp
010720  aa  6 02162 2521 00	spri2	pr6|1138
010721  aa  6 02152 6211 00	eax1 	pr6|1130
010722  aa   020000 4310 07	fld  	8192,dl
010723  aa  6 00044 3701 20	epp4 	pr6|36,*
010724  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
010725  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2384
		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

010726  aa  6 00162 2371 00	ldaq 	pr6|114		blockp
010727  aa   767263 6770 04	eraq 	-4429,ic		000212 = 077777000043 000001000000
010730  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
010731  aa   000535 6000 04	tze  	349,ic		011466
						STATEMENT 1 ON LINE 2386
		addr (buffer.chars (0)) -> based_bad_bcb_block = TEMPLATE_HASP_BAD_BCB_BLOCK;

010732  aa   767123 2350 04	lda  	-4525,ic		000055 = 020002220217
010733  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
010734  aa  7 00001 5511 60	stba 	pr7|1,60		based_bad_bcb_block.text1
010735  aa   767120 2350 04	lda  	-4528,ic		000055 = 020002220217
010736  aa  7 00001 5511 10	stba 	pr7|1,10		based_bad_bcb_block.bcb
010737  aa   767116 2350 04	lda  	-4530,ic		000055 = 020002220217
010740  aa   767116 2360 04	ldq  	-4530,ic		000056 = 317340200000
010741  aa  7 00001 5511 04	stba 	pr7|1,04		based_bad_bcb_block.text2
010742  aa  7 00002 5521 60	stbq 	pr7|2,60		based_bad_bcb_block.text2
010743  aa   767113 2350 04	lda  	-4533,ic		000056 = 317340200000
010744  aa  7 00002 5511 10	stba 	pr7|2,10		based_bad_bcb_block.srcb
010745  aa   767111 2370 04	ldaq 	-4535,ic		000056 = 317340200000 000020046000
010746  aa  7 00002 5511 04	stba 	pr7|2,04		based_bad_bcb_block.text3
010747  aa  7 00003 5521 70	stbq 	pr7|3,70		based_bad_bcb_block.text3
						STATEMENT 1 ON LINE 2387
		buffer.tally = length (string (TEMPLATE_HASP_BAD_BCB_BLOCK));

010750  aa   000013 2350 07	lda  	11,dl
010751  aa  7 00000 5511 04	stba 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2389
		addr (addr (buffer.chars (0)) -> based_bad_bcb_block.bcb) -> hasp_bcb_byte.count =
		     hmd.foreign_block_count;

010752  aa   000002 7270 07	lxl7 	2,dl
010753  aa  7 00001 3715 00	epp5 	pr7|1		based_bad_bcb_block.bcb
010754  aa  5 00000 5005 17	a9bd 	pr5|0,7
010755  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
010756  aa  3 00032 2361 00	ldq  	pr3|26		hmd.foreign_block_count
010757  aa   000104 7370 00	lls  	68
010760  aa  6 00056 7551 00	sta  	pr6|46
010761  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
010762  aa  6 00056 00 0004	descb	pr6|46,4
010763  aa  5 00000 05 0004	descb	pr5|0(5),4	hasp_bcb_byte.count
						STATEMENT 1 ON LINE 2392
		addr (addr (buffer.chars (0)) -> based_bad_bcb_block.srcb) -> hasp_bcb_byte.count =
		     hmd.local_block_count;

010764  aa  7 00002 3515 00	epp1 	pr7|2		based_bad_bcb_block.srcb
010765  aa  1 00000 5005 17	a9bd 	pr1|0,7
010766  aa  3 00034 2361 00	ldq  	pr3|28		hmd.local_block_count
010767  aa   000104 7370 00	lls  	68
010770  aa  6 00056 7551 00	sta  	pr6|46
010771  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
010772  aa  6 00056 00 0004	descb	pr6|46,4
010773  aa  1 00000 05 0004	descb	pr1|0(5),4	hasp_bcb_byte.count
						STATEMENT 1 ON LINE 2395
		hmd.output_block.tally = buffer.tally;

010774  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
010775  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
010776  aa  3 00053 7561 00	stq  	pr3|43		hmd.tally
						STATEMENT 1 ON LINE 2396
		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = blockp;

010777  aa  3 00054 6535 00	spri7	pr3|44		hmd.first_bufferp
011000  aa  3 00056 6535 00	spri7	pr3|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2398
		hmd.minor_state = HMD_HANGUP_LINE;

011001  aa   000010 2360 07	ldq  	8,dl
011002  aa  3 00031 7561 00	stq  	pr3|25		hmd.minor_state
						STATEMENT 1 ON LINE 2399
	     end;

011003  aa   000416 7100 04	tra  	270,ic		011421
						STATEMENT 1 ON LINE 2402
	     else if ^empty_output_blockp ()
	     then do;

011004  aa   004514 3520 04	epp2 	2380,ic		015520 = 000002000000
011005  aa   004137 6700 04	tsp4 	2143,ic		015144
011006  aa  6 02174 2351 00	lda  	pr6|1148
011007  aa   400000 3150 03	cana 	131072,du
011010  aa   000004 6010 04	tnz  	4,ic		011014
						STATEMENT 1 ON LINE 2407
		call compute_local_bcb_and_fcs ();

011011  aa   000470 6700 04	tsp4 	312,ic		011501
						STATEMENT 1 ON LINE 2408
		call finish_output_block ();

011012  aa   000626 6700 04	tsp4 	406,ic		011640
						STATEMENT 1 ON LINE 2409
	     end;

011013  aa   000406 7100 04	tra  	262,ic		011421
						STATEMENT 1 ON LINE 2412
	     else if ((hmd.minor_state = HMD_SEND_SIGNON) | (hmd.minor_state = HMD_REPROCESS)) &
		   (hmd.signon_data_ptr ^= null ())
	     then do;

011014  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011015  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
011016  aa   000006 1160 07	cmpq 	6,dl
011017  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
011020  aa  6 02174 7551 00	sta  	pr6|1148
011021  aa   000003 6010 04	tnz  	3,ic		011024
011022  aa   000001 1160 07	cmpq 	1,dl
011023  aa   000114 6010 04	tnz  	76,ic		011137
011024  aa  7 00060 2371 00	ldaq 	pr7|48		hmd.signon_data_ptr
011025  aa   767165 6770 04	eraq 	-4491,ic		000212 = 077777000043 000001000000
011026  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011027  aa   000110 6000 04	tze  	72,ic		011137
						STATEMENT 1 ON LINE 2422
		call compute_local_bcb_and_fcs ();

011030  aa   000451 6700 04	tsp4 	297,ic		011501
						STATEMENT 1 ON LINE 2424
		if hmd.output_block.first_bufferp ^= null () then /* we'll create our own buffers shortly */
		     call tty_space_man$free_chain (hmd.devx, OUTPUT, hmd.output_block.first_bufferp);

011031  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011032  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
011033  aa   767157 6770 04	eraq 	-4497,ic		000212 = 077777000043 000001000000
011034  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011035  aa   000014 6000 04	tze  	12,ic		011051
011036  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
011037  aa  6 02154 2521 00	spri2	pr6|1132
011040  aa   767122 3520 04	epp2 	-4526,ic		000162 = 400000000000
011041  aa  6 02156 2521 00	spri2	pr6|1134
011042  aa  7 00054 3521 00	epp2 	pr7|44		hmd.first_bufferp
011043  aa  6 02160 2521 00	spri2	pr6|1136
011044  aa  6 02152 6211 00	eax1 	pr6|1130
011045  aa   014000 4310 07	fld  	6144,dl
011046  aa  6 00044 3701 20	epp4 	pr6|36,*
011047  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
011050  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2427
		call tty_space_man$get_buffer (hmd.devx, 32, OUTPUT, blockp);

011051  aa   000040 2360 07	ldq  	32,dl
011052  aa  6 02175 7561 00	stq  	pr6|1149
011053  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011054  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
011055  aa  6 02154 2521 00	spri2	pr6|1132
011056  aa  6 02175 3521 00	epp2 	pr6|1149
011057  aa  6 02156 2521 00	spri2	pr6|1134
011060  aa   767102 3520 04	epp2 	-4542,ic		000162 = 400000000000
011061  aa  6 02160 2521 00	spri2	pr6|1136
011062  aa  6 00162 3521 00	epp2 	pr6|114		blockp
011063  aa  6 02162 2521 00	spri2	pr6|1138
011064  aa  6 02152 6211 00	eax1 	pr6|1130
011065  aa   020000 4310 07	fld  	8192,dl
011066  aa  6 00044 3701 20	epp4 	pr6|36,*
011067  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
011070  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2428
		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

011071  aa  6 00162 2371 00	ldaq 	pr6|114		blockp
011072  aa   767120 6770 04	eraq 	-4528,ic		000212 = 077777000043 000001000000
011073  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011074  aa   000372 6000 04	tze  	250,ic		011466
						STATEMENT 1 ON LINE 2430
		hmd.output_block.first_bufferp,	/* the only buffer in the block */
		     hmd.output_block.last_bufferp = blockp;

011075  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
011076  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011077  aa  5 00054 6535 00	spri7	pr5|44		hmd.first_bufferp
011100  aa  5 00056 6535 00	spri7	pr5|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2433
		addr (buffer.chars (0)) -> based_signon_block.header = TEMPLATE_HASP_SIGNON_BLOCK.header;

011101  aa   766725 2370 04	ldaq 	-4651,ic		000026 = 020002240217 317360301000
011102  aa  6 00162 3535 20	epp3 	pr6|114,*		blockp
011103  aa  3 00001 7551 00	sta  	pr3|1		based_signon_block.header
011104  aa  3 00002 5521 70	stbq 	pr3|2,70		based_signon_block.header
						STATEMENT 1 ON LINE 2434
		addr (buffer.chars (0)) -> based_signon_block.record = hmd.signon_data_ptr -> hmd_signon_data.record;

011105  aa  5 00060 3515 20	epp1 	pr5|48,*		hmd.signon_data_ptr
011106  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
011107  aa  1 00004 00 0120	desc9a	pr1|4,80		hmd_signon_data.record
011110  aa  3 00002 60 0120	desc9a	pr3|2(3),80	based_signon_block.record
						STATEMENT 1 ON LINE 2435
		hmd.output_block.tally,		/* how much just used */
		     buffer.tally = length (string (TEMPLATE_HASP_SIGNON_BLOCK.non_trailer));

011111  aa   000130 2360 07	ldq  	88,dl
011112  aa  5 00053 7561 00	stq  	pr5|43		hmd.tally
011113  aa  3 00000 5521 04	stbq 	pr3|0,04		buffer.tally
						STATEMENT 1 ON LINE 2437
		hmd.meters.n_output_records = hmd.meters.n_output_records + 1;

011114  aa  5 00104 2351 00	lda  	pr5|68		hmd.n_output_records
011115  aa   000044 7330 00	lrs  	36
011116  aa   000001 0330 07	adl  	1,dl
011117  aa  5 00104 7561 00	stq  	pr5|68		hmd.n_output_records
						STATEMENT 1 ON LINE 2439
		call finish_output_block ();

011120  aa   000520 6700 04	tsp4 	336,ic		011640
						STATEMENT 1 ON LINE 2440
		addr (addr (buffer.chars (0)) -> based_block_header.fcs) -> hasp_fcs_bytes.block_type =
		     HASP_FCS_ACKNOWLEDGE_BLOCK;

011121  aa   000003 7270 07	lxl7 	3,dl
011122  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
011123  aa  7 00001 3735 00	epp7 	pr7|1		based_block_header.fcs
011124  aa  7 00000 5005 17	a9bd 	pr7|0,7
011125  aa  003 100 060 404	csl  	(ic),(pr),fill(0),bool(move)
011126  aa   004371 00 0002	descb	2297,2		015516 = 200000000000
011127  aa  7 00000 23 0002	descb	pr7|0(12),2	hasp_fcs_bytes.block_type
						STATEMENT 1 ON LINE 2443
		if hmd.minor_state = HMD_SEND_SIGNON then    /* not in loopback processing */
		     hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE;

011130  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011131  aa  5 00031 2361 00	ldq  	pr5|25		hmd.minor_state
011132  aa   000001 1160 07	cmpq 	1,dl
011133  aa   000266 6010 04	tnz  	182,ic		011421
011134  aa   000002 2360 07	ldq  	2,dl
011135  aa  5 00031 7561 00	stq  	pr5|25		hmd.minor_state
						STATEMENT 1 ON LINE 2445
	     end;

011136  aa   000263 7100 04	tra  	179,ic		011421
						STATEMENT 1 ON LINE 2448
	     else if (hmd.minor_state = HMD_NORMAL)
	     then do;

011137  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
011140  aa   000003 1160 07	cmpq 	3,dl
011141  aa   000104 6010 04	tnz  	68,ic		011245
						STATEMENT 1 ON LINE 2454
		saved_hste_ptr = hste_ptr;

011142  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
011143  aa  6 00632 6515 00	spri5	pr6|410		saved_hste_ptr
						STATEMENT 1 ON LINE 2456
		do idx = 1 to hmd.n_subchannels	/* check them all ... */
			while (^full_output_blockp ());

011144  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
011145  aa  6 00635 7561 00	stq  	pr6|413
011146  aa   000001 2360 07	ldq  	1,dl
011147  aa  6 00634 7561 00	stq  	pr6|412		idx
011150  aa  6 00634 2361 00	ldq  	pr6|412		idx
011151  aa  6 00635 1161 00	cmpq 	pr6|413
011152  aa   000061 6054 04	tpnz 	49,ic		011233
011153  aa   004337 3520 04	epp2 	2271,ic		015512 = 000002000000
011154  aa   004021 6700 04	tsp4 	2065,ic		015175
011155  aa  6 02175 2351 00	lda  	pr6|1149
011156  aa   400000 3150 03	cana 	131072,du
011157  aa   000054 6010 04	tnz  	44,ic		011233
						STATEMENT 1 ON LINE 2458
		     hste_ptr = addr (hmd.subchannels (idx));

011160  aa  6 00634 2361 00	ldq  	pr6|412		idx
011161  aa   000050 4020 07	mpy  	40,dl
011162  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011163  aa  7 00044 3735 06	epp7 	pr7|36,ql		hmd.subchannels
011164  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 2460
		     if (hste.direction ^= HSTE_INPUT_ONLY) & hmd.output_wabs (hste.device_wab_idx) then
						/* it's a ready output device ... */
			if (hste.loopback.first_bufferp ^= null ())
			then do;

011165  aa  7 00004 2361 00	ldq  	pr7|4		hste.direction
011166  aa   000001 1160 07	cmpq 	1,dl
011167  aa   000042 6000 04	tze  	34,ic		011231
011170  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
011171  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011172  aa  000 000 066 517	cmpb 	(pr,x7),(),fill(0)
011173  aa  5 00067 20 0001	descb	pr5|55(9),1	hmd.output_wabs
011174  aa   000000 00 0000	descb	0,0
011175  aa   000034 6000 04	tze  	28,ic		011231
011176  aa  7 00026 2371 00	ldaq 	pr7|22		hste.first_bufferp
011177  aa   767013 6770 04	eraq 	-4597,ic		000212 = 077777000043 000001000000
011200  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011201  aa   000030 6000 04	tze  	24,ic		011231
						STATEMENT 1 ON LINE 2464
			     call process_subchannel_loopback_records ();

011202  aa   001275 6700 04	tsp4 	701,ic		012477
						STATEMENT 1 ON LINE 2465
				if needs_space then /* couldn't finish */
				     go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

011203  aa  6 00124 2351 00	lda  	pr6|84		needs_space
011204  aa   000262 6010 04	tnz  	178,ic		011466
						STATEMENT 1 ON LINE 2467
			     if (hste.loopback.first_bufferp = null ()) then do;

011205  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
011206  aa  7 00026 2371 00	ldaq 	pr7|22		hste.first_bufferp
011207  aa   767003 6770 04	eraq 	-4605,ic		000212 = 077777000043 000001000000
011210  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011211  aa   000020 6010 04	tnz  	16,ic		011231
						STATEMENT 1 ON LINE 2469
				call dequeue_subchannel_for_output ();

011212  aa   773413 6700 04	tsp4 	-2293,ic		004625
						STATEMENT 1 ON LINE 2470
				call channel_manager$interrupt_later (hste.devx, SEND_OUTPUT, ""b);

011213  aa   766775 2370 04	ldaq 	-4611,ic		000210 = 000000000000 000000000000
011214  aa  6 02150 7571 00	staq 	pr6|1128
011215  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
011216  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
011217  aa  6 02154 2521 00	spri2	pr6|1132
011220  aa   766750 3520 04	epp2 	-4632,ic		000170 = 000000000004
011221  aa  6 02156 2521 00	spri2	pr6|1134
011222  aa  6 02150 3521 00	epp2 	pr6|1128
011223  aa  6 02160 2521 00	spri2	pr6|1136
011224  aa  6 02152 6211 00	eax1 	pr6|1130
011225  aa   014000 4310 07	fld  	6144,dl
011226  aa  6 00044 3701 20	epp4 	pr6|36,*
011227  la  4 00102 3521 20	epp2 	pr4|66,*		channel_manager$interrupt_later
011230  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2471
			     end;

						STATEMENT 1 ON LINE 2472
			end;

						STATEMENT 1 ON LINE 2473
		end;

011231  aa  6 00634 0541 00	aos  	pr6|412		idx
011232  aa   777716 7100 04	tra  	-50,ic		011150
						STATEMENT 1 ON LINE 2475
		hste_ptr = saved_hste_ptr;

011233  aa  6 00632 3735 20	epp7 	pr6|410,*		saved_hste_ptr
011234  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 2477
		if empty_output_blockp () then
		     go to TRY_STATUS_OR_RTS_BLOCK;

011235  aa   004255 3520 04	epp2 	2221,ic		015512 = 000002000000
011236  aa   003706 6700 04	tsp4 	1990,ic		015144
011237  aa  6 02175 2351 00	lda  	pr6|1149
011240  aa   400000 3150 03	cana 	131072,du
011241  aa   000020 6010 04	tnz  	16,ic		011261
						STATEMENT 1 ON LINE 2479
		else do;

						STATEMENT 1 ON LINE 2480
		     call compute_local_bcb_and_fcs ();

011242  aa   000237 6700 04	tsp4 	159,ic		011501
						STATEMENT 1 ON LINE 2481
		     call finish_output_block ();

011243  aa   000375 6700 04	tsp4 	253,ic		011640
						STATEMENT 1 ON LINE 2482
		end;

						STATEMENT 1 ON LINE 2483
	     end;

011244  aa   000155 7100 04	tra  	109,ic		011421
						STATEMENT 1 ON LINE 2486
	     else if ((hmd.minor_state = HMD_NORMAL) | (hmd.minor_state = HMD_REPROCESS)) & empty_output_blockp ()
	     then do;

011245  aa   004245 3520 04	epp2 	2213,ic		015512 = 000002000000
011246  aa   003676 6700 04	tsp4 	1982,ic		015144
011247  aa  6 02175 2351 00	lda  	pr6|1149
011250  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
011251  aa  6 02175 7551 00	sta  	pr6|1149
011252  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011253  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
011254  aa   000003 1160 07	cmpq 	3,dl
011255  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
011256  aa  6 02174 2751 00	ora  	pr6|1148
011257  aa  6 02175 3151 00	cana 	pr6|1149
011260  aa   000066 6000 04	tze  	54,ic		011346
						STATEMENT 1 ON LINE 2492
TRY_STATUS_OR_RTS_BLOCK:
		call compute_local_bcb_and_fcs ();

011261  aa   000220 6700 04	tsp4 	144,ic		011501
						STATEMENT 1 ON LINE 2495
		if (hmd.local_fcs_bytes ^= local_fcs_chars) |
		   (string (hmd.send_rts) ^= ""b) | (string (hmd.send_rts_ack) ^= ""b)
		then do;

011262  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011263  aa  7 00035 2351 00	lda  	pr7|29		hmd.local_fcs_bytes
011264  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
011265  aa  6 00631 1151 00	cmpa 	pr6|409		local_fcs_chars
011266  aa   000007 6010 04	tnz  	7,ic		011275
011267  aa  7 00067 2351 00	lda  	pr7|55
011270  aa   777000 3150 07	cana 	261632,dl
011271  aa   000004 6010 04	tnz  	4,ic		011275
011272  aa  7 00067 2351 00	lda  	pr7|55
011273  aa   000777 3150 07	cana 	511,dl
011274  aa   000125 6000 04	tze  	85,ic		011421
						STATEMENT 1 ON LINE 2499
		     if (hmd.output_block.first_bufferp = null ())
		     then do;

011275  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
011276  aa   766714 6770 04	eraq 	-4660,ic		000212 = 077777000043 000001000000
011277  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011300  aa   000043 6010 04	tnz  	35,ic		011343
						STATEMENT 1 ON LINE 2502
			call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);

011301  aa   000020 2360 07	ldq  	16,dl
011302  aa  6 02175 7561 00	stq  	pr6|1149
011303  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
011304  aa  6 02154 2521 00	spri2	pr6|1132
011305  aa  6 02175 3521 00	epp2 	pr6|1149
011306  aa  6 02156 2521 00	spri2	pr6|1134
011307  aa   766653 3520 04	epp2 	-4693,ic		000162 = 400000000000
011310  aa  6 02160 2521 00	spri2	pr6|1136
011311  aa  6 00162 3521 00	epp2 	pr6|114		blockp
011312  aa  6 02162 2521 00	spri2	pr6|1138
011313  aa  6 02152 6211 00	eax1 	pr6|1130
011314  aa   020000 4310 07	fld  	8192,dl
011315  aa  6 00044 3701 20	epp4 	pr6|36,*
011316  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
011317  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2503
			     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

011320  aa  6 00162 2371 00	ldaq 	pr6|114		blockp
011321  aa   766671 6770 04	eraq 	-4679,ic		000212 = 077777000043 000001000000
011322  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011323  aa   000143 6000 04	tze  	99,ic		011466
						STATEMENT 1 ON LINE 2505
			hmd.output_block.first_bufferp,	/* the only buffer in the block */
			     hmd.output_block.last_bufferp = blockp;

011324  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
011325  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011326  aa  5 00054 6535 00	spri7	pr5|44		hmd.first_bufferp
011327  aa  5 00056 6535 00	spri7	pr5|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2508
			addr (buffer.chars (0)) -> based_block_header = TEMPLATE_HASP_BLOCK_HEADER;

011330  aa   766472 2350 04	lda  	-4806,ic		000022 = 020002000000
011331  aa  6 00162 3535 20	epp3 	pr6|114,*		blockp
011332  aa  3 00001 5511 60	stba 	pr3|1,60		based_block_header.text1
011333  aa   766467 2350 04	lda  	-4809,ic		000022 = 020002000000
011334  aa  3 00001 5511 10	stba 	pr3|1,10		based_block_header.bcb
011335  aa   766465 2370 04	ldaq 	-4811,ic		000022 = 020002000000 000000000000
011336  aa  3 00001 5511 04	stba 	pr3|1,04		based_block_header.fcs
011337  aa  3 00002 5521 40	stbq 	pr3|2,40		based_block_header.fcs
						STATEMENT 1 ON LINE 2509
			hmd.output_block.tally,
			     buffer.tally = length (string (TEMPLATE_HASP_BLOCK_HEADER));

011340  aa   000005 2360 07	ldq  	5,dl
011341  aa  5 00053 7561 00	stq  	pr5|43		hmd.tally
011342  aa  3 00000 5521 04	stbq 	pr3|0,04		buffer.tally
						STATEMENT 1 ON LINE 2511
		     end;

						STATEMENT 1 ON LINE 2513
		     call add_rts_or_rts_ack_record ();

011343  aa   000457 6700 04	tsp4 	303,ic		012022
						STATEMENT 1 ON LINE 2514
		     call finish_output_block ();

011344  aa   000274 6700 04	tsp4 	188,ic		011640
						STATEMENT 1 ON LINE 2515
		end;

						STATEMENT 1 ON LINE 2516
	     end;

011345  aa   000054 7100 04	tra  	44,ic		011421
						STATEMENT 1 ON LINE 2519
	     else if (hmd.minor_state = HMD_SEND_SYNC_BLOCK)
	     then do;

011346  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
011347  aa   000004 1160 07	cmpq 	4,dl
011350  aa   000043 6010 04	tnz  	35,ic		011413
						STATEMENT 1 ON LINE 2527
		call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, blockp);

011351  aa   000020 2360 07	ldq  	16,dl
011352  aa  6 02175 7561 00	stq  	pr6|1149
011353  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
011354  aa  6 02154 2521 00	spri2	pr6|1132
011355  aa  6 02175 3521 00	epp2 	pr6|1149
011356  aa  6 02156 2521 00	spri2	pr6|1134
011357  aa   766603 3520 04	epp2 	-4733,ic		000162 = 400000000000
011360  aa  6 02160 2521 00	spri2	pr6|1136
011361  aa  6 00162 3521 00	epp2 	pr6|114		blockp
011362  aa  6 02162 2521 00	spri2	pr6|1138
011363  aa  6 02152 6211 00	eax1 	pr6|1130
011364  aa   020000 4310 07	fld  	8192,dl
011365  aa  6 00044 3701 20	epp4 	pr6|36,*
011366  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
011367  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2528
		     if blockp = null () then go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

011370  aa  6 00162 2371 00	ldaq 	pr6|114		blockp
011371  aa   766621 6770 04	eraq 	-4719,ic		000212 = 077777000043 000001000000
011372  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011373  aa   000073 6000 04	tze  	59,ic		011466
						STATEMENT 1 ON LINE 2530
		addr (buffer.chars (0)) -> based_sync_block = TEMPLATE_HASP_SYNC_BLOCK;

011374  aa   766464 2370 04	ldaq 	-4812,ic		000060 = 020002000237 377000020046
011375  aa  6 00162 3735 20	epp7 	pr6|114,*		blockp
011376  aa  7 00001 7551 00	sta  	pr7|1		based_sync_block.text1
011377  aa  7 00002 7561 00	stq  	pr7|2		based_sync_block.text1
						STATEMENT 1 ON LINE 2531
		buffer.tally = length (string (TEMPLATE_HASP_SYNC_BLOCK));

011400  aa   000010 2350 07	lda  	8,dl
011401  aa  7 00000 5511 04	stba 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2533
		hmd.output_block.tally = buffer.tally;

011402  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
011403  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
011404  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011405  aa  5 00053 7561 00	stq  	pr5|43		hmd.tally
						STATEMENT 1 ON LINE 2534
		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = blockp;

011406  aa  5 00054 6535 00	spri7	pr5|44		hmd.first_bufferp
011407  aa  5 00056 6535 00	spri7	pr5|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2536
		hmd.minor_state = HMD_LOOPBACK;

011410  aa   000005 2360 07	ldq  	5,dl
011411  aa  5 00031 7561 00	stq  	pr5|25		hmd.minor_state
						STATEMENT 1 ON LINE 2537
	     end;

011412  aa   000007 7100 04	tra  	7,ic		011421
						STATEMENT 1 ON LINE 2540
	     else if (hmd.minor_state = HMD_LOOPBACK) then
		return;

011413  aa   000005 1160 07	cmpq 	5,dl
011414  aa   000002 6010 04	tnz  	2,ic		011416
011415  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2543
	     else if (hmd.minor_state = HMD_WAIT_SIGNON_RESPONSE) then
		return;

011416  aa   000002 1160 07	cmpq 	2,dl
011417  aa   000002 6010 04	tnz  	2,ic		011421
011420  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2550
	     if ^empty_output_blockp () then do;

011421  aa   004071 3520 04	epp2 	2105,ic		015512 = 000002000000
011422  aa   003522 6700 04	tsp4 	1874,ic		015144
011423  aa  6 02175 2351 00	lda  	pr6|1149
011424  aa   400000 3150 03	cana 	131072,du
011425  aa   000035 6010 04	tnz  	29,ic		011462
						STATEMENT 1 ON LINE 2551
		hmd.meters.n_output_blocks = hmd.meters.n_output_blocks + 1;

011426  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011427  aa  7 00103 2351 00	lda  	pr7|67		hmd.n_output_blocks
011430  aa   000044 7330 00	lrs  	36
011431  aa   000001 0330 07	adl  	1,dl
011432  aa  7 00103 7561 00	stq  	pr7|67		hmd.n_output_blocks
						STATEMENT 1 ON LINE 2552
		hmd.output_chain_ptr = hmd.output_block.first_bufferp;

011433  aa  7 00054 3715 20	epp5 	pr7|44,*		hmd.first_bufferp
011434  aa  7 00040 6515 00	spri5	pr7|32		hmd.output_chain_ptr
						STATEMENT 1 ON LINE 2554
		hmd.output_block.tally = 0;

011435  aa  7 00053 4501 00	stz  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 2555
		hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = null ();

011436  aa   766554 3534 24	epp3 	-4756,ic*
011437  aa  7 00054 2535 00	spri3	pr7|44		hmd.first_bufferp
011440  aa  7 00056 2535 00	spri3	pr7|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2557
		if hmd.trace_mode then		/* requested trace of all I/O with the FNP */
		     call trace_block (hmd.output_chain_ptr, OUTPUT);

011441  aa  7 00021 2351 00	lda  	pr7|17		hmd.trace_mode
011442  aa   040000 3150 03	cana 	16384,du
011443  aa   000011 6000 04	tze  	9,ic		011454
011444  aa  7 00040 3521 00	epp2 	pr7|32		hmd.output_chain_ptr
011445  aa  6 02154 2521 00	spri2	pr6|1132
011446  aa   766514 3520 04	epp2 	-4788,ic		000162 = 400000000000
011447  aa  6 02156 2521 00	spri2	pr6|1134
011450  aa  6 02152 3521 00	epp2 	pr6|1130
011451  aa   010000 4310 07	fld  	4096,dl
011452  aa  2 00000 7571 00	staq 	pr2|0
011453  aa   003604 6700 04	tsp4 	1924,ic		015257
						STATEMENT 1 ON LINE 2560
		call transmit_output_block ();

011454  aa   002206 6700 04	tsp4 	1158,ic		013662
						STATEMENT 1 ON LINE 2562
		if hmd.minor_state = HMD_NORMAL then	/* all is well:  can accept more output */
		     call interrupt_subchannels_with_output ();

011455  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011456  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
011457  aa   000003 1160 07	cmpq 	3,dl
011460  aa   000002 6010 04	tnz  	2,ic		011462
011461  aa   773216 6700 04	tsp4 	-2418,ic		004677
						STATEMENT 1 ON LINE 2564
	     end;

						STATEMENT 1 ON LINE 2566
	     hmd.retry_process_output = "0"b;

011462  aa   004026 2350 04	lda  	2070,ic		015510 = 776777777777
011463  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011464  aa  7 00070 3551 00	ansa 	pr7|56		hmd.retry_process_output
						STATEMENT 1 ON LINE 2568
	     return;

011465  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2573
CANT_FINISH_PROCESS_OUTPUT_BLOCK:
	     hmd.retry_process_output = "1"b;

011466  aa   001000 2350 03	lda  	512,du
011467  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011470  aa  7 00070 2551 00	orsa 	pr7|56		hmd.retry_process_output
						STATEMENT 1 ON LINE 2575
	     call tty_space_man$needs_space (hmd.devx);

011471  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
011472  aa  6 02154 2521 00	spri2	pr6|1132
011473  aa  6 02152 6211 00	eax1 	pr6|1130
011474  aa   004000 4310 07	fld  	2048,dl
011475  aa  6 00044 3701 20	epp4 	pr6|36,*
011476  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$needs_space
011477  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2576
	     return;

011500  aa  6 00622 6101 00	rtcd 	pr6|402
						STATEMENT 1 ON LINE 2785
	end process_output_block;

BEGIN PROCEDURE compute_local_bcb_and_fcs
ENTRY TO compute_local_bcb_and_fcs                          STATEMENT 1 ON LINE 2580
compute_local_bcb_and_fcs:
	     procedure ();

011501  aa  6 00636 6501 00	spri4	pr6|414
						STATEMENT 1 ON LINE 2588
		local_bcb_char = NUL;

011502  aa   000000 2350 07	lda  	0,dl
011503  aa  6 00630 7551 00	sta  	pr6|408		local_bcb_char
						STATEMENT 1 ON LINE 2589
		local_bcb.mbo1 = "1"b;

011504  aa   200000 2350 03	lda  	65536,du
011505  aa  6 00630 2551 00	orsa 	pr6|408		local_bcb.mbo1
						STATEMENT 1 ON LINE 2591
		if hmd.reset_local_block_count then	/* reset count to zero: local_bcb.count is already zero */
		     local_bcb.type = HASP_BCB_RESET;

011506  aa  6 00630 3735 00	epp7 	pr6|408		local_bcb_char
011507  aa  6 02176 6535 00	spri7	pr6|1150
011510  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011511  aa  5 00070 2351 00	lda  	pr5|56		hmd.reset_local_block_count
011512  aa   004000 3150 03	cana 	2048,du
011513  aa   000006 6000 04	tze  	6,ic		011521
011514  aa   040000 2350 03	lda  	16384,du
011515  aa  7 00000 6751 00	era  	pr7|0		local_bcb.type
011516  aa   160000 3750 03	ana  	57344,du
011517  aa  7 00000 6551 00	ersa 	pr7|0		local_bcb.type
011520  aa   000015 7100 04	tra  	13,ic		011535
						STATEMENT 1 ON LINE 2593
		else do;

						STATEMENT 1 ON LINE 2594
		     local_bcb.type = HASP_BCB_NORMAL;

011521  aa   000000 2350 03	lda  	0,du
011522  aa  7 00000 6751 00	era  	pr7|0		local_bcb.type
011523  aa   160000 3750 03	ana  	57344,du
011524  aa  7 00000 6551 00	ersa 	pr7|0		local_bcb.type
						STATEMENT 1 ON LINE 2595
		     local_bcb.count = mod (hmd.local_block_count + 1, 16);

011525  aa  5 00034 2361 00	ldq  	pr5|28		hmd.local_block_count
011526  aa   000001 0760 07	adq  	1,dl
011527  aa   004332 3520 04	epp2 	2266,ic		016061 = 000000000020
011530  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
011531  aa   000077 7370 00	lls  	63
011532  aa  7 00000 6751 00	era  	pr7|0		local_bcb.count
011533  aa   017000 3750 03	ana  	7680,du
011534  aa  7 00000 6551 00	ersa 	pr7|0		local_bcb.count
						STATEMENT 1 ON LINE 2596
		end;

						STATEMENT 1 ON LINE 2603
		local_fcs_chars = copy (NUL, 2);

011535  aa  6 00631 4501 00	stz  	pr6|409		local_fcs_chars
011536  aa  000 100 100 400	mlr  	(),(pr),fill(000)
011537  aa   000000 00 0000	desc9a	0,0
011540  aa  6 00631 00 0002	desc9a	pr6|409,2		local_fcs_chars
						STATEMENT 1 ON LINE 2604
		local_fcs.mbo1,
		     local_fcs.mbo2 = "1"b;

011541  aa   200000 2350 03	lda  	65536,du
011542  aa  6 00631 2551 00	orsa 	pr6|409		local_fcs.mbo1
011543  aa   000200 2350 03	lda  	128,du
011544  aa  6 00631 2551 00	orsa 	pr6|409		local_fcs.mbo2
						STATEMENT 1 ON LINE 2607
		if hmd.suspend_all_input then		/* if the multiplexer isn't ready yet:  indicate no input */
		     local_fcs.system_wab = "1"b;

011545  aa  6 00631 3535 00	epp3 	pr6|409		local_fcs_chars
011546  aa  6 02176 2535 00	spri3	pr6|1150
011547  aa  5 00070 2351 00	lda  	pr5|56		hmd.suspend_all_input
011550  aa   200000 3150 03	cana 	65536,du
011551  aa   000003 6000 04	tze  	3,ic		011554
011552  aa   100000 2350 03	lda  	32768,du
011553  aa  3 00000 2551 00	orsa 	pr3|0		local_fcs.system_wab
						STATEMENT 1 ON LINE 2610
		string (local_fcs.wab_bits1),		/* all devices not ready: insures that wait-a-bits for ... */
		     string (local_fcs.wab_bits2) = ""b;

011554  aa   003733 2350 04	lda  	2011,ic		015507 = 760777777777
011555  aa  3 00000 3551 00	ansa 	pr3|0
011556  aa   003730 2350 04	lda  	2008,ic		015506 = 777760777777
011557  aa  3 00000 3551 00	ansa 	pr3|0
						STATEMENT 1 ON LINE 2612
		local_fcs.console_wab = "0"b;

011560  aa   003725 2350 04	lda  	2005,ic		015505 = 777677777777
011561  aa  3 00000 3551 00	ansa 	pr3|0		local_fcs.console_wab
						STATEMENT 1 ON LINE 2614
		do idx = 1 to hmd.n_subchannels;

011562  aa  5 00113 2361 00	ldq  	pr5|75		hmd.n_subchannels
011563  aa  6 00645 7561 00	stq  	pr6|421
011564  aa   000001 2360 07	ldq  	1,dl
011565  aa  6 00644 7561 00	stq  	pr6|420		idx
011566  aa  6 00644 2361 00	ldq  	pr6|420		idx
011567  aa  6 00645 1161 00	cmpq 	pr6|421
011570  aa   000047 6054 04	tpnz 	39,ic		011637
						STATEMENT 1 ON LINE 2616
		     if (hmd.subchannels(idx).direction = HSTE_OUTPUT_ONLY)
			then;

011571  aa   000050 4020 07	mpy  	40,dl
011572  aa  6 02200 7561 00	stq  	pr6|1152
011573  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011574  aa  7 00050 2361 06	ldq  	pr7|40,ql		hmd.direction
011575  aa   000002 1160 07	cmpq 	2,dl
011576  aa   000002 6010 04	tnz  	2,ic		011600
011577  aa   000036 7100 04	tra  	30,ic		011635
						STATEMENT 1 ON LINE 2619
		     else if (hmd.subchannels(idx).state = HSTE_DIALED) then
						/* this device is dialed up:  set wait-a-bit as desired */
			if hmd.input_wabs (hmd.subchannels(idx).device_wab_idx) then
						/* device is ready:  set appropriate bit */
			     if (hmd.subchannels(idx).device_wab_idx = 0) then
				local_fcs.console_wab = "1"b;

011600  aa  6 02200 7271 00	lxl7 	pr6|1152
011601  aa  7 00056 2361 17	ldq  	pr7|46,7		hmd.state
011602  aa   000003 1160 07	cmpq 	3,dl
011603  aa   000032 6010 04	tnz  	26,ic		011635
011604  aa  7 00053 7261 17	lxl6 	pr7|43,7		hmd.device_wab_idx
011605  aa  000 000 066 516	cmpb 	(pr,x6),(),fill(0)
011606  aa  7 00067 00 0001	descb	pr7|55,1		hmd.input_wabs
011607  aa   000000 00 0000	descb	0,0
011610  aa   000020 6000 04	tze  	16,ic		011630
011611  aa  7 00053 2361 17	ldq  	pr7|43,7		hmd.device_wab_idx
011612  aa   000004 6010 04	tnz  	4,ic		011616
011613  aa   000100 2350 03	lda  	64,du
011614  aa  6 00631 2551 00	orsa 	pr6|409		local_fcs.console_wab
011615  aa   000020 7100 04	tra  	16,ic		011635
						STATEMENT 1 ON LINE 2625
			     else if (hmd.subchannels(idx).device_wab_idx <= 4) then
				local_fcs.wab_bits1 (hmd.subchannels(idx).device_wab_idx) = "1"b;

011616  aa   000004 1160 07	cmpq 	4,dl
011617  aa   000005 6054 04	tpnz 	5,ic		011624
011620  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
011621  aa   000000 00 0000	descb	0,0
011622  aa  6 00631 04 0001	descb	pr6|409(4),1	local_fcs.wab_bits1
011623  aa   000012 7100 04	tra  	10,ic		011635
						STATEMENT 1 ON LINE 2627
			     else local_fcs.wab_bits2 (hmd.subchannels(idx).device_wab_idx-4) = "1"b;

011624  aa  403 106 060 400	csl  	(),(pr,ql),fill(1),bool(move)
011625  aa   000000 00 0000	descb	0,0
011626  aa  6 00631 20 0001	descb	pr6|409(9),1	local_fcs.wab_bits2
011627  aa   000006 7100 04	tra  	6,ic		011635
						STATEMENT 1 ON LINE 2629
			else			/* device is not ready:  appropriate bit is already off ... */
			if hmd.suspend_all_mode then	/* ... but foreign side only interprets system wait-a-bit */
			     local_fcs.system_wab = "1"b;

011630  aa  7 00021 2351 00	lda  	pr7|17		hmd.suspend_all_mode
011631  aa   400000 3150 03	cana 	131072,du
011632  aa   000003 6000 04	tze  	3,ic		011635
011633  aa   100000 2350 03	lda  	32768,du
011634  aa  6 00631 2551 00	orsa 	pr6|409		local_fcs.system_wab
						STATEMENT 1 ON LINE 2632
		end;

011635  aa  6 00644 0541 00	aos  	pr6|420		idx
011636  aa   777730 7100 04	tra  	-40,ic		011566
						STATEMENT 1 ON LINE 2634
		return;

011637  aa  6 00636 6101 00	rtcd 	pr6|414
						STATEMENT 1 ON LINE 2636
	     end compute_local_bcb_and_fcs;

  END PROCEDURE compute_local_bcb_and_fcs
BEGIN PROCEDURE finish_output_block
ENTRY TO finish_output_block                                STATEMENT 1 ON LINE 2642
finish_output_block:
	     procedure ();

011640  aa  6 00646 6501 00	spri4	pr6|422
						STATEMENT 1 ON LINE 2658
		bufferp = hmd.output_block.last_bufferp;

011641  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011642  aa  7 00056 3735 20	epp7 	pr7|46,*		hmd.last_bufferp
011643  aa  6 00654 6535 00	spri7	pr6|428		bufferp
						STATEMENT 1 ON LINE 2660
		space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code) - (bufferp -> buffer.tally);

011644  aa  7 00000 2351 00	lda  	pr7|0		buffer.size_code
011645  aa   000030 7350 00	als  	24
011646  aa   000105 7730 00	lrl  	69
011647  aa  7 00000 2351 00	lda  	pr7|0		buffer.tally
011650  aa   000033 7350 00	als  	27
011651  aa   000000 6270 06	eax7 	0,ql
011652  aa   000077 7730 00	lrl  	63
011653  aa  6 02202 7561 00	stq  	pr6|1154		buffer.tally
011654  ta   000102 2360 17	ldq  	66,7
011655  aa  6 02202 1761 00	sbq  	pr6|1154		buffer.tally
011656  aa  6 00660 7561 00	stq  	pr6|432		space_left_in_buffer
						STATEMENT 1 ON LINE 2661
		amount_needed = length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));

011657  aa   000003 2360 07	ldq  	3,dl
011660  aa  6 00661 7561 00	stq  	pr6|433		amount_needed
						STATEMENT 1 ON LINE 2663
		if space_left_in_buffer >= amount_needed
		then do;

011661  aa  6 02201 7471 00	stx7 	pr6|1153
011662  aa  6 00660 1161 00	cmpq 	pr6|432		space_left_in_buffer
011663  aa   000010 6054 04	tpnz 	8,ic		011673
						STATEMENT 1 ON LINE 2665
		     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_block_trailer.non_crc =
			     TEMPLATE_HASP_BLOCK_TRAILER.non_crc;

011664  aa  6 02202 7261 00	lxl6 	pr6|1154		buffer.tally
011665  aa  040 116 100 404	mlr  	(ic),(pr,x6),fill(040)
011666  aa   766137 00 0003	desc9a	-5025,3		000024 = 000020046000
011667  aa  7 00001 00 0003	desc9a	pr7|1,3		based_block_trailer.non_crc
						STATEMENT 1 ON LINE 2667
		     bufferp -> buffer.tally = (bufferp -> buffer.tally) +
					  length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));

011670  aa  6 02202 0761 00	adq  	pr6|1154		buffer.tally
011671  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2669
		end;

011672  aa   000064 7100 04	tra  	52,ic		011756
						STATEMENT 1 ON LINE 2671
		else do;

						STATEMENT 1 ON LINE 2672
		     saved_tally = bufferp -> buffer.tally;

011673  aa  6 02202 2361 00	ldq  	pr6|1154		buffer.tally
011674  aa  6 00662 7561 00	stq  	pr6|434		saved_tally
						STATEMENT 1 ON LINE 2673
		     if space_left_in_buffer > 0 then do;

011675  aa  6 00660 2361 00	ldq  	pr6|432		space_left_in_buffer
011676  aa   000007 6044 04	tmoz 	7,ic		011705
						STATEMENT 1 ON LINE 2674
			addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_part1 =
				addr (TEMPLATE_HASP_BLOCK_TRAILER.non_crc) -> based_split_block_trailer.part1;

011677  aa  6 02202 7261 00	lxl6 	pr6|1154		buffer.tally
011700  aa  040 156 100 444	mlr  	(rl,ic),(pr,rl,x6),fill(040)
011701  aa   766124 00 0006	desc9a	-5036,ql		000024 = 000020046000
011702  aa  7 00001 00 0006	desc9a	pr7|1,ql		based_part1
						STATEMENT 1 ON LINE 2676
			bufferp -> buffer.tally = max_buffer_tally (bufferp -> buffer.size_code);

011703  ta   000102 2360 17	ldq  	66,7
011704  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2677
		     end;

						STATEMENT 1 ON LINE 2678
		     call tty_space_man$get_buffer (hmd.devx, 16, OUTPUT, new_bufferp);

011705  aa   000020 2360 07	ldq  	16,dl
011706  aa  6 02201 7561 00	stq  	pr6|1153
011707  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
011710  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
011711  aa  6 02206 2521 00	spri2	pr6|1158
011712  aa  6 02201 3521 00	epp2 	pr6|1153
011713  aa  6 02210 2521 00	spri2	pr6|1160
011714  aa   766246 3520 04	epp2 	-4954,ic		000162 = 400000000000
011715  aa  6 02212 2521 00	spri2	pr6|1162
011716  aa  6 00656 3521 00	epp2 	pr6|430		new_bufferp
011717  aa  6 02214 2521 00	spri2	pr6|1164
011720  aa  6 02204 6211 00	eax1 	pr6|1156
011721  aa   020000 4310 07	fld  	8192,dl
011722  aa  6 00044 3701 20	epp4 	pr6|36,*
011723  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
011724  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2679
			if new_bufferp = null () then do;

011725  aa  6 00656 2371 00	ldaq 	pr6|430		new_bufferp
011726  aa   766264 6770 04	eraq 	-4940,ic		000212 = 077777000043 000001000000
011727  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
011730  aa   000005 6010 04	tnz  	5,ic		011735
						STATEMENT 1 ON LINE 2680
			     bufferp -> buffer.tally = saved_tally;

011731  aa  6 00662 2361 00	ldq  	pr6|434		saved_tally
011732  aa  6 00654 3735 20	epp7 	pr6|428,*		buffer.tally
011733  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2681
			     go to CANT_FINISH_PROCESS_OUTPUT_BLOCK;

011734  aa   777532 7100 04	tra  	-166,ic		011466
						STATEMENT 1 ON LINE 2682
			end;

						STATEMENT 1 ON LINE 2683
		     addr (new_bufferp -> buffer.chars (0)) -> based_part2 =
			     addr (TEMPLATE_HASP_BLOCK_TRAILER.non_crc) -> based_split_block_trailer.part2;

011735  aa  6 00661 2361 00	ldq  	pr6|433		amount_needed
011736  aa  6 00660 1761 00	sbq  	pr6|432		space_left_in_buffer
011737  aa  6 00656 3735 20	epp7 	pr6|430,*		new_bufferp
011740  aa  6 00660 7271 00	lxl7 	pr6|432		space_left_in_buffer
011741  aa  040 140 100 457	mlr  	(rl,x7),(pr,rl),fill(040)
011742  ta   000024 00 0006	desc9a	20,ql
011743  aa  7 00001 00 0006	desc9a	pr7|1,ql		based_part2
						STATEMENT 1 ON LINE 2685
		     new_bufferp -> buffer.tally = amount_needed - space_left_in_buffer;

011744  aa  6 00661 2361 00	ldq  	pr6|433		amount_needed
011745  aa  6 00660 1761 00	sbq  	pr6|432		space_left_in_buffer
011746  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 2686
		     bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);

011747  aa  7 00000 6351 00	eaa  	pr7|0		new_bufferp
011750  aa   000066 7730 00	lrl  	54
011751  aa   000066 7370 00	lls  	54
011752  aa  6 00654 3715 20	epp5 	pr6|428,*		buffer.next
011753  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 2687
		     hmd.output_block.last_bufferp = new_bufferp;

011754  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
011755  aa  3 00056 6535 00	spri7	pr3|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 2688
		end;

						STATEMENT 1 ON LINE 2690
		hmd.output_block.tally = hmd.output_block.tally +
				      length (string (TEMPLATE_HASP_BLOCK_TRAILER.non_crc));

011756  aa   000003 2360 07	ldq  	3,dl
011757  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
011760  aa  7 00053 0561 00	asq  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 2693
		addr (hmd.output_block.first_bufferp -> buffer.chars (0)) -> based_block_header.bcb = local_bcb_char;

011761  aa  6 00630 2351 00	lda  	pr6|408		local_bcb_char
011762  aa   000022 7710 00	arl  	18
011763  aa  7 00054 3715 20	epp5 	pr7|44,*		hmd.first_bufferp
011764  aa  5 00001 5511 10	stba 	pr5|1,10		based_block_header.bcb
						STATEMENT 1 ON LINE 2694
		addr (hmd.output_block.first_bufferp -> buffer.chars (0)) -> based_block_header.fcs = local_fcs_chars;

011765  aa  6 00631 2351 00	lda  	pr6|409		local_fcs_chars
011766  aa   000033 7730 00	lrl  	27
011767  aa  5 00001 5511 04	stba 	pr5|1,04		based_block_header.fcs
011770  aa  5 00002 5521 40	stbq 	pr5|2,40		based_block_header.fcs
						STATEMENT 1 ON LINE 2696
		if hmd.reset_local_block_count
		then do;

011771  aa  7 00070 2351 00	lda  	pr7|56		hmd.reset_local_block_count
011772  aa   004000 3150 03	cana 	2048,du
011773  aa   000006 6000 04	tze  	6,ic		012001
						STATEMENT 1 ON LINE 2698
		     hmd.reset_local_block_count = "0"b;

011774  aa   003510 2350 04	lda  	1864,ic		015504 = 773777777777
011775  aa  7 00070 3551 00	ansa 	pr7|56		hmd.reset_local_block_count
						STATEMENT 1 ON LINE 2699
		     hmd.local_block_count = -1;

011776  aa   000001 3360 07	lcq  	1,dl
011777  aa  7 00034 7561 00	stq  	pr7|28		hmd.local_block_count
						STATEMENT 1 ON LINE 2700
		end;

012000  aa   000005 7100 04	tra  	5,ic		012005
						STATEMENT 1 ON LINE 2701
		else hmd.local_block_count = local_bcb.count;

012001  aa  6 00630 2351 00	lda  	pr6|408		local_bcb.count
012002  aa   000005 7350 00	als  	5
012003  aa   000104 7730 00	lrl  	68
012004  aa  7 00034 7561 00	stq  	pr7|28		hmd.local_block_count
						STATEMENT 1 ON LINE 2703
		if local_fcs.system_wab & ^hmd_local_fcs.system_wab then	/* stopped taking input */
		     hmd.meters.n_local_wab_set = hmd.meters.n_local_wab_set + 1;

012005  aa  6 00631 2351 00	lda  	pr6|409		local_fcs.system_wab
012006  aa   100000 3150 03	cana 	32768,du
012007  aa   000010 6000 04	tze  	8,ic		012017
012010  aa  7 00035 2351 00	lda  	pr7|29		hmd_local_fcs.system_wab
012011  aa   100000 3150 03	cana 	32768,du
012012  aa   000005 6010 04	tnz  	5,ic		012017
012013  aa  7 00076 2351 00	lda  	pr7|62		hmd.n_local_wab_set
012014  aa   000044 7330 00	lrs  	36
012015  aa   000001 0330 07	adl  	1,dl
012016  aa  7 00076 7561 00	stq  	pr7|62		hmd.n_local_wab_set
						STATEMENT 1 ON LINE 2706
		hmd.local_fcs_bytes = local_fcs_chars;

012017  aa  6 00631 2351 00	lda  	pr6|409		local_fcs_chars
012020  aa  7 00035 7551 00	sta  	pr7|29		hmd.local_fcs_bytes
						STATEMENT 1 ON LINE 2708
		return;

012021  aa  6 00646 6101 00	rtcd 	pr6|422
						STATEMENT 1 ON LINE 2710
	     end finish_output_block;

  END PROCEDURE finish_output_block
BEGIN PROCEDURE add_rts_or_rts_ack_record
ENTRY TO add_rts_or_rts_ack_record                          STATEMENT 1 ON LINE 2715
add_rts_or_rts_ack_record:
	     procedure ();

012022  aa  6 00664 6501 00	spri4	pr6|436
						STATEMENT 1 ON LINE 2722
		do idx = 1 to hmd.n_subchannels;

012023  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012024  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
012025  aa  6 00675 7561 00	stq  	pr6|445
012026  aa   000001 2360 07	ldq  	1,dl
012027  aa  6 00674 7561 00	stq  	pr6|444		idx
012030  aa  6 00674 2361 00	ldq  	pr6|444		idx
012031  aa  6 00675 1161 00	cmpq 	pr6|445
012032  aa   000136 6054 04	tpnz 	94,ic		012170
						STATEMENT 1 ON LINE 2724
		      if (hmd.subchannels(idx).direction ^= HSTE_INPUT_ONLY) & (idx ^= hmd.console_hste_idx)
			then if hmd.send_rts (hmd.subchannels(idx).device_wab_idx)
			     then do;

012033  aa   000050 4020 07	mpy  	40,dl
012034  aa  6 02216 7561 00	stq  	pr6|1166
012035  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012036  aa  7 00050 2361 06	ldq  	pr7|40,ql		hmd.direction
012037  aa   000001 1160 07	cmpq 	1,dl
012040  aa   000055 6000 04	tze  	45,ic		012115
012041  aa  6 00674 2361 00	ldq  	pr6|444		idx
012042  aa  7 00112 1161 00	cmpq 	pr7|74		hmd.console_hste_idx
012043  aa   000052 6000 04	tze  	42,ic		012115
012044  aa  6 02216 7271 00	lxl7 	pr6|1166
012045  aa  7 00053 7261 17	lxl6 	pr7|43,7		hmd.device_wab_idx
012046  aa  000 000 066 516	cmpb 	(pr,x6),(),fill(0)
012047  aa  7 00067 40 0001	descb	pr7|55(18),1	hmd.send_rts
012050  aa   000000 00 0000	descb	0,0
012051  aa   000115 6000 04	tze  	77,ic		012166
						STATEMENT 1 ON LINE 2730
				hmd.meters.n_output_records = hmd.meters.n_output_records + 1;

012052  aa  7 00104 2351 00	lda  	pr7|68		hmd.n_output_records
012053  aa   000044 7330 00	lrs  	36
012054  aa   000001 0330 07	adl  	1,dl
012055  aa  7 00104 7561 00	stq  	pr7|68		hmd.n_output_records
						STATEMENT 1 ON LINE 2732
				p = hmd.output_block.last_bufferp;

012056  aa  7 00056 3715 20	epp5 	pr7|46,*		hmd.last_bufferp
012057  aa  6 00672 6515 00	spri5	pr6|442		p
						STATEMENT 1 ON LINE 2734
				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_record =
					TEMPLATE_HASP_RTS_RECORD;

012060  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
012061  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
012062  aa  5 00001 3535 00	epp3 	pr5|1		buffer.chars
012063  aa  3 00000 5005 06	a9bd 	pr3|0,ql
012064  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012065  aa   765776 00 0001	desc9a	-5122,1		000062 = 220000000000
012066  aa  3 00000 00 0001	desc9a	pr3|0,1		based_rts_record.rcb
012067  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012070  aa   765773 20 0001	desc9a	-5125(1),1		000062 = 220000000000
012071  aa  3 00000 20 0001	desc9a	pr3|0(1),1	based_rts_record.srcb
012072  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012073  aa   765770 40 0001	desc9a	-5128(2),1		000062 = 220000000000
012074  aa  3 00000 40 0001	desc9a	pr3|0(2),1	based_rts_record.eor_scb
						STATEMENT 1 ON LINE 2737
				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_record.srcb =
					hmd.subchannels(idx).rcb;

012075  aa  7 00052 3515 17	epp1 	pr7|42,7		hmd.rcb
012076  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
012077  aa  1 00000 00 0001	desc9a	pr1|0,1		hmd.rcb
012100  aa  5 00001 20 0001	desc9a	pr5|1(1),1	based_rts_record.srcb
						STATEMENT 1 ON LINE 2740
				p -> buffer.tally = (p -> buffer.tally) +
						 length (string (TEMPLATE_HASP_RTS_RECORD));

012101  aa   000003 0760 07	adq  	3,dl
012102  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 2742
				hmd.output_block.tally = hmd.output_block.tally +
						      length (string (TEMPLATE_HASP_RTS_RECORD));

012103  aa   000003 2360 07	ldq  	3,dl
012104  aa  7 00053 0561 00	asq  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 2745
				hmd.send_rts (hmd.subchannels(idx).device_wab_idx) = "0"b;

012105  aa  7 00053 7251 17	lxl5 	pr7|43,7		hmd.device_wab_idx
012106  aa  003 115 060 400	csl  	(),(pr,x5),fill(0),bool(move)
012107  aa   000000 00 0000	descb	0,0
012110  aa  7 00067 40 0001	descb	pr7|55(18),1	hmd.send_rts
						STATEMENT 1 ON LINE 2746
				hmd.subchannels(idx).minor_state = HSTE_WAIT_RTS_ACK;

012111  aa   000003 2360 07	ldq  	3,dl
012112  aa  7 00057 7561 17	stq  	pr7|47,7		hmd.minor_state
						STATEMENT 1 ON LINE 2747
				go to NO_MORE_RECORDS;

012113  aa   000055 7100 04	tra  	45,ic		012170
						STATEMENT 1 ON LINE 2748
			     end;

						STATEMENT 1 ON LINE 2750
			     else;

012114  aa   000052 7100 04	tra  	42,ic		012166
						STATEMENT 1 ON LINE 2753
		     else if (hmd.subchannels(idx).direction ^= HSTE_OUTPUT_ONLY)
			then if hmd.send_rts_ack (hmd.subchannels(idx).device_wab_idx)
			     then do;

012115  aa  6 02216 7271 00	lxl7 	pr6|1166
012116  aa  7 00050 2361 17	ldq  	pr7|40,7		hmd.direction
012117  aa   000002 1160 07	cmpq 	2,dl
012120  aa   000046 6000 04	tze  	38,ic		012166
012121  aa  7 00053 7261 17	lxl6 	pr7|43,7		hmd.device_wab_idx
012122  aa  000 000 066 516	cmpb 	(pr,x6),(),fill(0)
012123  aa  7 00067 60 0001	descb	pr7|55(27),1	hmd.send_rts_ack
012124  aa   000000 00 0000	descb	0,0
012125  aa   000041 6000 04	tze  	33,ic		012166
						STATEMENT 1 ON LINE 2759
				hmd.meters.n_output_records = hmd.meters.n_output_records + 1;

012126  aa  7 00104 2351 00	lda  	pr7|68		hmd.n_output_records
012127  aa   000044 7330 00	lrs  	36
012130  aa   000001 0330 07	adl  	1,dl
012131  aa  7 00104 7561 00	stq  	pr7|68		hmd.n_output_records
						STATEMENT 1 ON LINE 2761
				p = hmd.output_block.last_bufferp;

012132  aa  7 00056 3715 20	epp5 	pr7|46,*		hmd.last_bufferp
012133  aa  6 00672 6515 00	spri5	pr6|442		p
						STATEMENT 1 ON LINE 2763
				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_ack_record =
					TEMPLATE_HASP_RTS_ACK_RECORD;

012134  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
012135  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
012136  aa  5 00001 3535 00	epp3 	pr5|1		buffer.chars
012137  aa  3 00000 5005 06	a9bd 	pr3|0,ql
012140  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012141  aa   765723 00 0001	desc9a	-5165,1		000063 = 240000000000
012142  aa  3 00000 00 0001	desc9a	pr3|0,1		based_rts_ack_record.rcb
012143  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012144  aa   765720 20 0001	desc9a	-5168(1),1		000063 = 240000000000
012145  aa  3 00000 20 0001	desc9a	pr3|0(1),1	based_rts_ack_record.srcb
012146  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
012147  aa   765715 40 0001	desc9a	-5171(2),1		000063 = 240000000000
012150  aa  3 00000 40 0001	desc9a	pr3|0(2),1	based_rts_ack_record.eor_scb
						STATEMENT 1 ON LINE 2766
				addr (p -> buffer.chars (p -> buffer.tally)) -> based_rts_ack_record.srcb =
					hmd.subchannels(idx).rcb;

012151  aa  7 00052 3515 17	epp1 	pr7|42,7		hmd.rcb
012152  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
012153  aa  1 00000 00 0001	desc9a	pr1|0,1		hmd.rcb
012154  aa  5 00001 20 0001	desc9a	pr5|1(1),1	based_rts_ack_record.srcb
						STATEMENT 1 ON LINE 2769
				p -> buffer.tally = (p -> buffer.tally) +
						 length (string (TEMPLATE_HASP_RTS_ACK_RECORD));

012155  aa   000003 0760 07	adq  	3,dl
012156  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 2771
				hmd.output_block.tally = hmd.output_block.tally +
						      length (string (TEMPLATE_HASP_RTS_ACK_RECORD));

012157  aa   000003 2360 07	ldq  	3,dl
012160  aa  7 00053 0561 00	asq  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 2774
				hmd.send_rts_ack (hmd.subchannels(idx).device_wab_idx) = "0"b;

012161  aa  7 00053 7251 17	lxl5 	pr7|43,7		hmd.device_wab_idx
012162  aa  003 115 060 400	csl  	(),(pr,x5),fill(0),bool(move)
012163  aa   000000 00 0000	descb	0,0
012164  aa  7 00067 60 0001	descb	pr7|55(27),1	hmd.send_rts_ack
						STATEMENT 1 ON LINE 2775
				go to NO_MORE_RECORDS;

012165  aa   000003 7100 04	tra  	3,ic		012170
						STATEMENT 1 ON LINE 2776
			     end;

						STATEMENT 1 ON LINE 2779
		end;

012166  aa  6 00674 0541 00	aos  	pr6|444		idx
012167  aa   777641 7100 04	tra  	-95,ic		012030
						STATEMENT 1 ON LINE 2781
NO_MORE_RECORDS:	return;

012170  aa  6 00664 6101 00	rtcd 	pr6|436
						STATEMENT 1 ON LINE 2783
	     end add_rts_or_rts_ack_record;

  END PROCEDURE add_rts_or_rts_ack_record
  END PROCEDURE process_output_block
BEGIN PROCEDURE output_records_processor
ENTRY TO output_records_processor                           STATEMENT 1 ON LINE 2789
output_records_processor:
	procedure ();

012171  aa  6 00676 6501 00	spri4	pr6|446
						STATEMENT 1 ON LINE 2792
RETURN_FROM_CALLER:					/* not an entry */
	     return;

012172  aa  6 00676 6101 00	rtcd 	pr6|446
ENTRY TO process_output_records                             STATEMENT 1 ON LINE 2828
process_output_records:
	entry ();

012173  aa  6 00676 6501 00	spri4	pr6|446
						STATEMENT 1 ON LINE 2831
	     loopback_entry = "0"b;

012174  aa  6 00704 4501 00	stz  	pr6|452		loopback_entry
						STATEMENT 1 ON LINE 2832
	     needs_space = "0"b;

012175  aa  6 00124 4501 00	stz  	pr6|84		needs_space
						STATEMENT 1 ON LINE 2834
	     if cant_accept_records_from_this_device () then
		return;

012176  aa   003302 3520 04	epp2 	1730,ic		015500 = 000002000000
012177  aa   000477 6700 04	tsp4 	319,ic		012676
012200  aa  6 02220 2351 00	lda  	pr6|1168
012201  aa   400000 3150 03	cana 	131072,du
012202  aa   000002 6000 04	tze  	2,ic		012204
012203  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2840
	     start_bufferp = chain_ptr;

012204  aa  6 00102 3735 20	epp7 	pr6|66,*		chain_ptr
012205  aa  6 00716 6535 00	spri7	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2841
	     start_record_idx = 0;

012206  aa  6 00722 4501 00	stz  	pr6|466		start_record_idx
						STATEMENT 1 ON LINE 2843
	     continue_scan = "1"b;

012207  aa   400000 2350 03	lda  	131072,du
012210  aa  6 00724 7551 00	sta  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2845
	     do while (continue_scan);

012211  aa   000000 0110 03	nop  	0,du
012212  aa  6 00724 2351 00	lda  	pr6|468		continue_scan
012213  aa   000163 6000 04	tze  	115,ic		012376
						STATEMENT 1 ON LINE 2847
		call find_next_record (start_bufferp, start_record_idx, "0"b, "1"b,
				   end_bufferp, end_record_idx, record_tally, dle_count);

012214  aa   000000 2350 07	lda  	0,dl
012215  aa  6 02220 7551 00	sta  	pr6|1168
012216  aa   400000 2350 03	lda  	131072,du
012217  aa  6 02221 7551 00	sta  	pr6|1169
012220  aa   003236 3520 04	epp2 	1694,ic		015456 = 000020000000
012221  aa   002161 6700 04	tsp4 	1137,ic		014402
						STATEMENT 1 ON LINE 2850
		if end_bufferp ^= null ()
		then do;

012222  aa  6 00720 2371 00	ldaq 	pr6|464		end_bufferp
012223  aa   765767 6770 04	eraq 	-5129,ic		000212 = 077777000043 000001000000
012224  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012225  aa   000131 6000 04	tze  	89,ic		012356
						STATEMENT 1 ON LINE 2853
		     record_tally = record_tally + dle_count + 1;

012226  aa  6 00733 2361 00	ldq  	pr6|475		record_tally
012227  aa  6 00734 0761 00	adq  	pr6|476		dle_count
012230  aa   000001 0760 07	adq  	1,dl
012231  aa  6 00733 7561 00	stq  	pr6|475		record_tally
						STATEMENT 1 ON LINE 2855
		     if ^space_in_empty_output_block_for_recordp (record_tally)
		     then do;

012232  aa   003216 3520 04	epp2 	1678,ic		015450 = 000004000000
012233  aa   002766 6700 04	tsp4 	1526,ic		015221
012234  aa  6 02221 2351 00	lda  	pr6|1169
012235  aa   400000 3150 03	cana 	131072,du
012236  aa   000005 6010 04	tnz  	5,ic		012243
						STATEMENT 1 ON LINE 2857
			continue_scan = "0"b;

012237  aa  6 00724 4501 00	stz  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2858
			long_record = "1"b;

012240  aa   400000 2350 03	lda  	131072,du
012241  aa  6 00126 7551 00	sta  	pr6|86		long_record
						STATEMENT 1 ON LINE 2859
		     end;

012242  aa   777750 7100 04	tra  	-24,ic		012212
						STATEMENT 1 ON LINE 2861
		     else if space_in_output_block_for_recordp (record_tally)
		     then do;

012243  aa   003205 3520 04	epp2 	1669,ic		015450 = 000004000000
012244  aa   002717 6700 04	tsp4 	1487,ic		015163
012245  aa  6 02221 2351 00	lda  	pr6|1169
012246  aa   400000 3150 03	cana 	131072,du
012247  aa   000105 6000 04	tze  	69,ic		012354
						STATEMENT 1 ON LINE 2863
			call move_record_to_output_block ("1"b);

012250  aa   400000 2350 03	lda  	131072,du
012251  aa  6 02221 7551 00	sta  	pr6|1169
012252  aa   003172 3520 04	epp2 	1658,ic		015444 = 000002000000
012253  aa   000562 6700 04	tsp4 	370,ic		013035
						STATEMENT 1 ON LINE 2864
			hmd.meters.n_output_records = hmd.meters.n_output_records + 1;

012254  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012255  aa  7 00104 2351 00	lda  	pr7|68		hmd.n_output_records
012256  aa   000044 7330 00	lrs  	36
012257  aa   000001 0330 07	adl  	1,dl
012260  aa  7 00104 7561 00	stq  	pr7|68		hmd.n_output_records
						STATEMENT 1 ON LINE 2865
			hste.meters.device_n_output_records = hste.meters.device_n_output_records + 1;

012261  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012262  aa  5 00043 2351 00	lda  	pr5|35		hste.device_n_output_records
012263  aa   000044 7330 00	lrs  	36
012264  aa   000001 0330 07	adl  	1,dl
012265  aa  5 00043 7561 00	stq  	pr5|35		hste.device_n_output_records
						STATEMENT 1 ON LINE 2866
			if record_type = HASP_EOF_RECORD then	/* set by move_record_to_output_block ... */
			     hste.meters.device_n_output_eof_records = hste.meters.device_n_output_eof_records + 1;

012266  aa  6 00732 2361 00	ldq  	pr6|474		record_type
012267  aa   000002 1160 07	cmpq 	2,dl
012270  aa   000005 6010 04	tnz  	5,ic		012275
012271  aa  5 00044 2351 00	lda  	pr5|36		hste.device_n_output_eof_records
012272  aa   000044 7330 00	lrs  	36
012273  aa   000001 0330 07	adl  	1,dl
012274  aa  5 00044 7561 00	stq  	pr5|36		hste.device_n_output_eof_records
						STATEMENT 1 ON LINE 2869
			if (end_record_idx + 1) = (end_bufferp -> buffer.tally)
			then do;

012275  aa  6 00720 2361 20	ldq  	pr6|464,*		buffer.tally
012276  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
012277  aa  6 02221 7561 00	stq  	pr6|1169		buffer.tally
012300  aa  6 00723 2361 00	ldq  	pr6|467		end_record_idx
012301  aa   000001 0760 07	adq  	1,dl
012302  aa  6 02221 1161 00	cmpq 	pr6|1169		buffer.tally
012303  aa   000030 6010 04	tnz  	24,ic		012333
						STATEMENT 1 ON LINE 2871
			     if end_bufferp -> buffer.next = 0 then
				start_bufferp = null ();

012304  aa  6 00720 2351 20	lda  	pr6|464,*		buffer.next
012305  aa   000066 7730 00	lrl  	54
012306  aa  6 02221 7561 00	stq  	pr6|1169		buffer.next
012307  aa   000004 6010 04	tnz  	4,ic		012313
012310  aa   765702 2370 04	ldaq 	-5182,ic		000212 = 077777000043 000001000000
012311  aa  6 00716 7571 00	staq 	pr6|462		start_bufferp
012312  aa   000004 7100 04	tra  	4,ic		012316
						STATEMENT 1 ON LINE 2873
			     else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);

012313  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
012314  aa   000000 3120 06	eawp2	0,ql
012315  aa  6 00716 2521 00	spri2	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2874
			     start_record_idx = 0;

012316  aa  6 00722 4501 00	stz  	pr6|466		start_record_idx
						STATEMENT 1 ON LINE 2875
			     call tty_space_man$free_buffer (hste.devx, OUTPUT, end_bufferp);

012317  aa  5 00005 3521 00	epp2 	pr5|5		hste.devx
012320  aa  6 02224 2521 00	spri2	pr6|1172
012321  aa   765641 3520 04	epp2 	-5215,ic		000162 = 400000000000
012322  aa  6 02226 2521 00	spri2	pr6|1174
012323  aa  6 00720 3521 00	epp2 	pr6|464		end_bufferp
012324  aa  6 02230 2521 00	spri2	pr6|1176
012325  aa  6 02222 6211 00	eax1 	pr6|1170
012326  aa   014000 4310 07	fld  	6144,dl
012327  aa  6 00044 3701 20	epp4 	pr6|36,*
012330  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
012331  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2876
			end;

012332  aa   000006 7100 04	tra  	6,ic		012340
						STATEMENT 1 ON LINE 2877
			else do;

						STATEMENT 1 ON LINE 2878
			     start_bufferp = end_bufferp;

012333  aa  6 00720 3535 20	epp3 	pr6|464,*		end_bufferp
012334  aa  6 00716 2535 00	spri3	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2879
			     start_record_idx = end_record_idx + 1;

012335  aa  6 00723 2361 00	ldq  	pr6|467		end_record_idx
012336  aa   000001 0760 07	adq  	1,dl
012337  aa  6 00722 7561 00	stq  	pr6|466		start_record_idx
						STATEMENT 1 ON LINE 2880
			end;

						STATEMENT 1 ON LINE 2882
			continue_scan = (start_bufferp ^= null ()) &	/* must be more data ... */
				      (hste.minor_state = HSTE_NORMAL);

012340  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
012341  aa  7 00013 2361 00	ldq  	pr7|11		hste.minor_state
012342  aa   000001 1160 07	cmpq 	1,dl
012343  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
012344  aa  6 02221 7551 00	sta  	pr6|1169
012345  aa  6 00716 2371 00	ldaq 	pr6|462		start_bufferp
012346  aa   765644 6770 04	eraq 	-5212,ic		000212 = 077777000043 000001000000
012347  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012350  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
012351  aa  6 02221 3751 00	ana  	pr6|1169
012352  aa  6 00724 7551 00	sta  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2884
		     end;

012353  aa   777637 7100 04	tra  	-97,ic		012212
						STATEMENT 1 ON LINE 2886
		     else continue_scan = "0"b;

012354  aa  6 00724 4501 00	stz  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2887
		end;

012355  aa   777635 7100 04	tra  	-99,ic		012212
						STATEMENT 1 ON LINE 2889
		else do;

						STATEMENT 1 ON LINE 2890
		     continue_scan = "0"b;

012356  aa  6 00724 4501 00	stz  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2891
		     if ^space_in_empty_output_block_for_recordp ((record_tally + dle_count + 1)) then
			long_record = "1"b;

012357  aa  6 00733 2361 00	ldq  	pr6|475		record_tally
012360  aa  6 00734 0761 00	adq  	pr6|476		dle_count
012361  aa   000001 0760 07	adq  	1,dl
012362  aa  6 02221 7561 00	stq  	pr6|1169
012363  aa   003053 3520 04	epp2 	1579,ic		015436 = 000004000000
012364  aa   002635 6700 04	tsp4 	1437,ic		015221
012365  aa  6 02220 2351 00	lda  	pr6|1168
012366  aa   400000 3150 03	cana 	131072,du
012367  aa   000004 6010 04	tnz  	4,ic		012373
012370  aa   400000 2350 03	lda  	131072,du
012371  aa  6 00126 7551 00	sta  	pr6|86		long_record
012372  aa   777620 7100 04	tra  	-112,ic		012212
						STATEMENT 1 ON LINE 2893
		     else partial_record = "1"b;

012373  aa   400000 2350 03	lda  	131072,du
012374  aa  6 00125 7551 00	sta  	pr6|85		partial_record
						STATEMENT 1 ON LINE 2894
		end;

						STATEMENT 1 ON LINE 2895
	     end;

012375  aa   777615 7100 04	tra  	-115,ic		012212
						STATEMENT 1 ON LINE 2898
RETURN_FROM_PROCESS_OUTPUT_RECORDS:
	     if start_bufferp ^= null () then		/* didn't process entire chain:  return the rest */
		if start_record_idx ^= 0 then		/* some processed stuff in this buffer should be flushed */
		     call delete_text (start_bufferp, 0, start_record_idx);

012376  aa  6 00716 2371 00	ldaq 	pr6|462		start_bufferp
012377  aa   765613 6770 04	eraq 	-5237,ic		000212 = 077777000043 000001000000
012400  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012401  aa   000006 6000 04	tze  	6,ic		012407
012402  aa  6 00722 2361 00	ldq  	pr6|466		start_record_idx
012403  aa   000004 6000 04	tze  	4,ic		012407
012404  aa  6 02220 4501 00	stz  	pr6|1168
012405  aa   003021 3520 04	epp2 	1553,ic		015426 = 000006000000
012406  aa   002624 6700 04	tsp4 	1428,ic		015232
						STATEMENT 1 ON LINE 2903
	     chain_ptr = start_bufferp;

012407  aa  6 00716 3735 20	epp7 	pr6|462,*		start_bufferp
012410  aa  6 00102 6535 00	spri7	pr6|66		chain_ptr
						STATEMENT 1 ON LINE 2905
	     return;

012411  aa  6 00676 6101 00	rtcd 	pr6|446
ENTRY TO process_single_loopback_record                     STATEMENT 1 ON LINE 2910
process_single_loopback_record:
	entry (P_start_bufferp, P_start_record_idx, P_end_bufferp, P_end_record_idx, P_record_tally, P_dle_count,
	       P_record_was_taken);

012412  aa  6 00676 6501 00	spri4	pr6|446
012413  aa  6 00700 2521 00	spri2	pr6|448
						STATEMENT 1 ON LINE 2914
	     start_bufferp = P_start_bufferp;

012414  aa  6 00700 3735 20	epp7 	pr6|448,*
012415  aa  7 00002 3715 20	epp5 	pr7|2,*		P_start_bufferp
012416  aa  5 00000 3715 20	epp5 	pr5|0,*		P_start_bufferp
012417  aa  6 00716 6515 00	spri5	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2915
	     start_record_idx = P_start_record_idx;

012420  aa  7 00004 2361 20	ldq  	pr7|4,*		P_start_record_idx
012421  aa  6 00722 7561 00	stq  	pr6|466		start_record_idx
						STATEMENT 1 ON LINE 2916
	     end_bufferp = P_end_bufferp;

012422  aa  7 00006 3535 20	epp3 	pr7|6,*		P_end_bufferp
012423  aa  3 00000 3535 20	epp3 	pr3|0,*		P_end_bufferp
012424  aa  6 00720 2535 00	spri3	pr6|464		end_bufferp
						STATEMENT 1 ON LINE 2917
	     end_record_idx = P_end_record_idx;

012425  aa  7 00010 2361 20	ldq  	pr7|8,*		P_end_record_idx
012426  aa  6 00723 7561 00	stq  	pr6|467		end_record_idx
						STATEMENT 1 ON LINE 2918
	     record_tally = P_record_tally + P_dle_count + 1;

012427  aa  7 00012 2361 20	ldq  	pr7|10,*		P_record_tally
012430  aa  7 00014 0761 20	adq  	pr7|12,*		P_dle_count
012431  aa   000001 0760 07	adq  	1,dl
012432  aa  6 00733 7561 00	stq  	pr6|475		record_tally
						STATEMENT 1 ON LINE 2920
	     P_record_was_taken = "0"b;

012433  aa  7 00016 4501 20	stz  	pr7|14,*		P_record_was_taken
						STATEMENT 1 ON LINE 2922
	     loopback_entry = "1"b;

012434  aa   400000 2350 03	lda  	131072,du
012435  aa  6 00704 7551 00	sta  	pr6|452		loopback_entry
						STATEMENT 1 ON LINE 2923
	     needs_space = "0"b;

012436  aa  6 00124 4501 00	stz  	pr6|84		needs_space
						STATEMENT 1 ON LINE 2925
	     if cant_accept_records_from_this_device () then
		return;

012437  aa   003041 3520 04	epp2 	1569,ic		015500 = 000002000000
012440  aa   000236 6700 04	tsp4 	158,ic		012676
012441  aa  6 02220 2351 00	lda  	pr6|1168
012442  aa   400000 3150 03	cana 	131072,du
012443  aa   000002 6000 04	tze  	2,ic		012445
012444  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2928
	     if (hste.minor_state ^= HSTE_NORMAL) then do;

012445  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
012446  aa  7 00013 2361 00	ldq  	pr7|11		hste.minor_state
012447  aa   000001 1160 07	cmpq 	1,dl
012450  aa   000011 6000 04	tze  	9,ic		012461
						STATEMENT 1 ON LINE 2929
		if (hste.minor_state = HSTE_SEND_RTS) then
		     hmd.send_rts (hste.device_wab_idx) = "1"b;

012451  aa   000002 1160 07	cmpq 	2,dl
012452  aa   000006 6010 04	tnz  	6,ic		012460
012453  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
012454  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
012455  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
012456  aa   000000 00 0000	descb	0,0
012457  aa  5 00067 40 0001	descb	pr5|55(18),1	hmd.send_rts
						STATEMENT 1 ON LINE 2931
		return;

012460  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2932
	     end;

						STATEMENT 1 ON LINE 2934
	     if ^space_in_output_block_for_recordp (record_tally) then
		return;

012461  aa   002737 3520 04	epp2 	1503,ic		015420 = 000004000000
012462  aa   002501 6700 04	tsp4 	1345,ic		015163
012463  aa  6 02220 2351 00	lda  	pr6|1168
012464  aa   400000 3150 03	cana 	131072,du
012465  aa   000002 6010 04	tnz  	2,ic		012467
012466  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2937
	     call move_record_to_output_block ("0"b);

012467  aa   000000 2350 07	lda  	0,dl
012470  aa  6 02220 7551 00	sta  	pr6|1168
012471  aa   003007 3520 04	epp2 	1543,ic		015500 = 000002000000
012472  aa   000343 6700 04	tsp4 	227,ic		013035
						STATEMENT 1 ON LINE 2938
	     P_record_was_taken = "1"b;

012473  aa   400000 2350 03	lda  	131072,du
012474  aa  6 00700 3735 20	epp7 	pr6|448,*
012475  aa  7 00016 7551 20	sta  	pr7|14,*		P_record_was_taken
						STATEMENT 1 ON LINE 2940
	     return;

012476  aa  6 00676 6101 00	rtcd 	pr6|446
ENTRY TO process_subchannel_loopback_reco                   STATEMENT 1 ON LINE 2946
process_subchannel_loopback_records:
	entry ();

012477  aa  6 00676 6501 00	spri4	pr6|446
						STATEMENT 1 ON LINE 2949
	     loopback_entry = "1"b;

012500  aa   400000 2350 03	lda  	131072,du
012501  aa  6 00704 7551 00	sta  	pr6|452		loopback_entry
						STATEMENT 1 ON LINE 2950
	     needs_space = "0"b;

012502  aa  6 00124 4501 00	stz  	pr6|84		needs_space
						STATEMENT 1 ON LINE 2952
	     if cant_accept_records_from_this_device () then
		return;

012503  aa   002775 3520 04	epp2 	1533,ic		015500 = 000002000000
012504  aa   000172 6700 04	tsp4 	122,ic		012676
012505  aa  6 02220 2351 00	lda  	pr6|1168
012506  aa   400000 3150 03	cana 	131072,du
012507  aa   000002 6000 04	tze  	2,ic		012511
012510  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2955
	     if (hste.minor_state ^= HSTE_NORMAL) then do;

012511  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
012512  aa  7 00013 2361 00	ldq  	pr7|11		hste.minor_state
012513  aa   000001 1160 07	cmpq 	1,dl
012514  aa   000011 6000 04	tze  	9,ic		012525
						STATEMENT 1 ON LINE 2956
		if (hste.minor_state = HSTE_SEND_RTS) then 
		     hmd.send_rts (hste.device_wab_idx) = "1"b;

012515  aa   000002 1160 07	cmpq 	2,dl
012516  aa   000006 6010 04	tnz  	6,ic		012524
012517  aa  7 00007 7271 00	lxl7 	pr7|7		hste.device_wab_idx
012520  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
012521  aa  403 117 060 400	csl  	(),(pr,x7),fill(1),bool(move)
012522  aa   000000 00 0000	descb	0,0
012523  aa  5 00067 40 0001	descb	pr5|55(18),1	hmd.send_rts
						STATEMENT 1 ON LINE 2958
		return;

012524  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 2959
	     end;

						STATEMENT 1 ON LINE 2965
	     start_bufferp = hste.loopback.first_bufferp;

012525  aa  7 00026 3715 20	epp5 	pr7|22,*		hste.first_bufferp
012526  aa  6 00716 6515 00	spri5	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2967
	     continue_scan = (start_bufferp ^= null ());

012527  aa  6 00716 2371 00	ldaq 	pr6|462		start_bufferp
012530  aa   765462 6770 04	eraq 	-5326,ic		000212 = 077777000043 000001000000
012531  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012532  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
012533  aa  6 00724 7551 00	sta  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2969
	     do while (continue_scan);

012534  aa  6 00724 2351 00	lda  	pr6|468		continue_scan
012535  aa   000126 6000 04	tze  	86,ic		012663
						STATEMENT 1 ON LINE 2971
		record_tally, dle_count = 0;

012536  aa  6 00733 4501 00	stz  	pr6|475		record_tally
012537  aa  6 00734 4501 00	stz  	pr6|476		dle_count
						STATEMENT 1 ON LINE 2972
		do bufferp = start_bufferp
			   repeat (bufferp) while (bufferp ^= null ());

012540  aa  6 00716 3735 20	epp7 	pr6|462,*		start_bufferp
012541  aa  6 00726 6535 00	spri7	pr6|470		bufferp
012542  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
012543  aa   765447 6770 04	eraq 	-5337,ic		000212 = 077777000043 000001000000
012544  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012545  aa   000032 6000 04	tze  	26,ic		012577
						STATEMENT 1 ON LINE 2974
		     record_tally = record_tally + (bufferp -> buffer.tally) + count_dles (bufferp);

012546  aa   002644 3520 04	epp2 	1444,ic		015412 = 000004000000
012547  aa   001027 6700 04	tsp4 	535,ic		013576
012550  aa  6 00726 2361 20	ldq  	pr6|470,*		buffer.tally
012551  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
012552  aa  6 00733 0761 00	adq  	pr6|475		record_tally
012553  aa  6 02220 0761 00	adq  	pr6|1168
012554  aa  6 00733 7561 00	stq  	pr6|475		record_tally
						STATEMENT 1 ON LINE 2975
		     if (bufferp -> buffer.next = 0) | (bufferp -> buffer.break)
		     then do;

012555  aa  6 00726 2351 20	lda  	pr6|470,*		buffer.next
012556  aa   000066 7730 00	lrl  	54
012557  aa  6 02220 7561 00	stq  	pr6|1168		buffer.next
012560  aa   000004 6000 04	tze  	4,ic		012564
012561  aa  6 00726 2351 20	lda  	pr6|470,*		buffer.break
012562  aa   100000 3150 07	cana 	32768,dl
012563  aa   000006 6000 04	tze  	6,ic		012571
						STATEMENT 1 ON LINE 2977
			end_bufferp = bufferp;

012564  aa  6 00726 3735 20	epp7 	pr6|470,*		bufferp
012565  aa  6 00720 6535 00	spri7	pr6|464		end_bufferp
						STATEMENT 1 ON LINE 2978
			bufferp = null ();

012566  aa   765424 2370 04	ldaq 	-5356,ic		000212 = 077777000043 000001000000
012567  aa  6 00726 7571 00	staq 	pr6|470		bufferp
						STATEMENT 1 ON LINE 2979
		     end;

012570  aa   000004 7100 04	tra  	4,ic		012574
						STATEMENT 1 ON LINE 2980
		     else bufferp = pointer (ttybp, bufferp -> buffer.next);

012571  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
012572  aa   000000 3120 06	eawp2	0,ql
012573  aa  6 00726 2521 00	spri2	pr6|470		bufferp
						STATEMENT 1 ON LINE 2981
		end;

012574  aa  6 00726 3735 20	epp7 	pr6|470,*		bufferp
012575  aa  6 00726 6535 00	spri7	pr6|470		bufferp
012576  aa   777744 7100 04	tra  	-28,ic		012542
						STATEMENT 1 ON LINE 2983
		start_record_idx = 0;

012577  aa  6 00722 4501 00	stz  	pr6|466		start_record_idx
						STATEMENT 1 ON LINE 2984
		end_record_idx = (end_bufferp -> buffer.tally) - 1;

012600  aa  6 00720 2361 20	ldq  	pr6|464,*		buffer.tally
012601  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
012602  aa   000001 1760 07	sbq  	1,dl
012603  aa  6 00723 7561 00	stq  	pr6|467		end_record_idx
						STATEMENT 1 ON LINE 2986
		if space_in_output_block_for_recordp (record_tally)
		then do;

012604  aa   002614 3520 04	epp2 	1420,ic		015420 = 000004000000
012605  aa   002356 6700 04	tsp4 	1262,ic		015163
012606  aa  6 02220 2351 00	lda  	pr6|1168
012607  aa   400000 3150 03	cana 	131072,du
012610  aa   000051 6000 04	tze  	41,ic		012661
						STATEMENT 1 ON LINE 2988
		     call move_record_to_output_block ("1"b);

012611  aa   400000 2350 03	lda  	131072,du
012612  aa  6 02220 7551 00	sta  	pr6|1168
012613  aa   002665 3520 04	epp2 	1461,ic		015500 = 000002000000
012614  aa   000221 6700 04	tsp4 	145,ic		013035
						STATEMENT 1 ON LINE 2989
		     hste.loopback.n_records = hste.loopback.n_records - 1;

012615  aa   000001 3360 07	lcq  	1,dl
012616  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
012617  aa  7 00024 0561 00	asq  	pr7|20		hste.n_records
						STATEMENT 1 ON LINE 2990
		     if (end_bufferp -> buffer.next = 0) then
			start_bufferp = null ();

012620  aa  6 00720 2351 20	lda  	pr6|464,*		buffer.next
012621  aa   000066 7730 00	lrl  	54
012622  aa  6 02220 7561 00	stq  	pr6|1168		buffer.next
012623  aa   000004 6010 04	tnz  	4,ic		012627
012624  aa   765366 2370 04	ldaq 	-5386,ic		000212 = 077777000043 000001000000
012625  aa  6 00716 7571 00	staq 	pr6|462		start_bufferp
012626  aa   000004 7100 04	tra  	4,ic		012632
						STATEMENT 1 ON LINE 2992
		     else start_bufferp = pointer (ttybp, end_bufferp -> buffer.next);

012627  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
012630  aa   000000 3120 06	eawp2	0,ql
012631  aa  6 00716 2521 00	spri2	pr6|462		start_bufferp
						STATEMENT 1 ON LINE 2993
		     call tty_space_man$free_buffer (hste.devx, OUTPUT, end_bufferp);

012632  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
012633  aa  6 02224 2521 00	spri2	pr6|1172
012634  aa   765326 3520 04	epp2 	-5418,ic		000162 = 400000000000
012635  aa  6 02226 2521 00	spri2	pr6|1174
012636  aa  6 00720 3521 00	epp2 	pr6|464		end_bufferp
012637  aa  6 02230 2521 00	spri2	pr6|1176
012640  aa  6 02222 6211 00	eax1 	pr6|1170
012641  aa   014000 4310 07	fld  	6144,dl
012642  aa  6 00044 3701 20	epp4 	pr6|36,*
012643  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
012644  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 2994
		     continue_scan = ((start_bufferp ^= null ()) &     /* still something there ... */
			           (hste.minor_state = HSTE_NORMAL));

012645  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
012646  aa  7 00013 2361 00	ldq  	pr7|11		hste.minor_state
012647  aa   000001 1160 07	cmpq 	1,dl
012650  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
012651  aa  6 02220 7551 00	sta  	pr6|1168
012652  aa  6 00716 2371 00	ldaq 	pr6|462		start_bufferp
012653  aa   765337 6770 04	eraq 	-5409,ic		000212 = 077777000043 000001000000
012654  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012655  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
012656  aa  6 02220 3751 00	ana  	pr6|1168
012657  aa  6 00724 7551 00	sta  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2996
		end;

012660  aa   777654 7100 04	tra  	-84,ic		012534
						STATEMENT 1 ON LINE 2998
		else continue_scan = "0"b;

012661  aa  6 00724 4501 00	stz  	pr6|468		continue_scan
						STATEMENT 1 ON LINE 2999
	     end;

012662  aa   777652 7100 04	tra  	-86,ic		012534
						STATEMENT 1 ON LINE 3004
	     hste.loopback.first_bufferp = start_bufferp;

012663  aa  6 00716 3735 20	epp7 	pr6|462,*		start_bufferp
012664  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012665  aa  5 00026 6535 00	spri7	pr5|22		hste.first_bufferp
						STATEMENT 1 ON LINE 3006
	     if (start_bufferp = null ()) then		/* none left */
		hste.loopback.last_bufferp = null ();

012666  aa  6 00716 2371 00	ldaq 	pr6|462		start_bufferp
012667  aa   765323 6770 04	eraq 	-5421,ic		000212 = 077777000043 000001000000
012670  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012671  aa   000004 6010 04	tnz  	4,ic		012675
012672  aa   765320 2370 04	ldaq 	-5424,ic		000212 = 077777000043 000001000000
012673  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012674  aa  5 00030 7571 00	staq 	pr5|24		hste.last_bufferp
						STATEMENT 1 ON LINE 3009
	     return;

012675  aa  6 00676 6101 00	rtcd 	pr6|446
						STATEMENT 1 ON LINE 3263
	end output_records_processor;

BEGIN PROCEDURE cant_accept_records_from_this_de
ENTRY TO cant_accept_records_from_this_de                   STATEMENT 1 ON LINE 3017
cant_accept_records_from_this_device:
	     procedure () returns (bit (1) aligned);

012676  aa  6 00740 6501 00	spri4	pr6|480
012677  aa  6 00742 2521 00	spri2	pr6|482
						STATEMENT 1 ON LINE 3022
		accept_records = "1"b;

012700  aa   400000 2350 03	lda  	131072,du
012701  aa  6 00746 7551 00	sta  	pr6|486		accept_records
						STATEMENT 1 ON LINE 3024
		if empty_output_blockp ()
		then do;

012702  aa   002504 3520 04	epp2 	1348,ic		015406 = 000002000000
012703  aa   002241 6700 04	tsp4 	1185,ic		015144
012704  aa  6 02232 2351 00	lda  	pr6|1178
012705  aa   400000 3150 03	cana 	131072,du
012706  aa   000026 6000 04	tze  	22,ic		012734
						STATEMENT 1 ON LINE 3026
		     if hmd.output_block.first_bufferp = null () then
			call start_new_output_block ();

012707  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012710  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
012711  aa   765301 6770 04	eraq 	-5439,ic		000212 = 077777000043 000001000000
012712  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
012713  aa   000002 6010 04	tnz  	2,ic		012715
012714  aa   000051 6700 04	tsp4 	41,ic		012765
						STATEMENT 1 ON LINE 3028
		     if hmd.multileave_mode & (hste.device_type ^= HASP_CONSOLE) then
			hmd.output_block.subchannel_idx = -1;

012715  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012716  aa  7 00021 2351 00	lda  	pr7|17		hmd.multileave_mode
012717  aa   100000 3150 03	cana 	32768,du
012720  aa   000010 6000 04	tze  	8,ic		012730
012721  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012722  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
012723  aa   000001 1160 07	cmpq 	1,dl
012724  aa   000004 6000 04	tze  	4,ic		012730
012725  aa   000001 3360 07	lcq  	1,dl
012726  aa  7 00052 7561 00	stq  	pr7|42		hmd.subchannel_idx
012727  aa   000031 7100 04	tra  	25,ic		012760
						STATEMENT 1 ON LINE 3030
		     else hmd.output_block.subchannel_idx = hste.subchannel_idx;

012730  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012731  aa  5 00002 2361 00	ldq  	pr5|2		hste.subchannel_idx
012732  aa  7 00052 7561 00	stq  	pr7|42		hmd.subchannel_idx
						STATEMENT 1 ON LINE 3031
		end;

012733  aa   000025 7100 04	tra  	21,ic		012760
						STATEMENT 1 ON LINE 3033
		else if hmd.multileave_mode & (hste.device_type ^= HASP_CONSOLE)
		     then if (hmd.output_block.subchannel_idx = -1)
			then;

012734  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012735  aa  7 00021 2351 00	lda  	pr7|17		hmd.multileave_mode
012736  aa   100000 3150 03	cana 	32768,du
012737  aa   000013 6000 04	tze  	11,ic		012752
012740  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012741  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
012742  aa   000001 1160 07	cmpq 	1,dl
012743  aa   000007 6000 04	tze  	7,ic		012752
012744  aa  7 00052 2361 00	ldq  	pr7|42		hmd.subchannel_idx
012745  aa   003115 1160 04	cmpq 	1613,ic		016062 = 777777777777
012746  aa   000002 6010 04	tnz  	2,ic		012750
012747  aa   000011 7100 04	tra  	9,ic		012760
						STATEMENT 1 ON LINE 3036
		     else accept_records = "0"b;

012750  aa  6 00746 4501 00	stz  	pr6|486		accept_records
012751  aa   000007 7100 04	tra  	7,ic		012760
						STATEMENT 1 ON LINE 3038
		else if (hmd.output_block.subchannel_idx = hste.subchannel_idx)
		     then;

012752  aa  7 00052 2361 00	ldq  	pr7|42		hmd.subchannel_idx
012753  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
012754  aa  5 00002 1161 00	cmpq 	pr5|2		hste.subchannel_idx
012755  aa   000002 6010 04	tnz  	2,ic		012757
012756  aa   000002 7100 04	tra  	2,ic		012760
						STATEMENT 1 ON LINE 3040
		else accept_records = "0"b;

012757  aa  6 00746 4501 00	stz  	pr6|486		accept_records
						STATEMENT 1 ON LINE 3042
		return (^accept_records);

012760  aa  6 00746 2351 00	lda  	pr6|486		accept_records
012761  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
012762  aa  6 00742 3535 20	epp3 	pr6|482,*
012763  aa  3 00002 7551 20	sta  	pr3|2,*
012764  aa  6 00740 6101 00	rtcd 	pr6|480
						STATEMENT 1 ON LINE 3069
	     end cant_accept_records_from_this_device;

BEGIN PROCEDURE start_new_output_block
ENTRY TO start_new_output_block                             STATEMENT 1 ON LINE 3048
start_new_output_block:
		procedure ();

012765  aa  6 00750 6501 00	spri4	pr6|488
						STATEMENT 1 ON LINE 3053
		     call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT, bufferp);

012766  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
012767  aa  7 00027 2351 00	lda  	pr7|23		hmd.max_buf_size
012770  aa   000077 7730 00	lrl  	63
012771  aa  6 02233 7561 00	stq  	pr6|1179
012772  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
012773  aa  6 02236 2521 00	spri2	pr6|1182
012774  aa  6 02233 3521 00	epp2 	pr6|1179
012775  aa  6 02240 2521 00	spri2	pr6|1184
012776  aa   765164 3520 04	epp2 	-5516,ic		000162 = 400000000000
012777  aa  6 02242 2521 00	spri2	pr6|1186
013000  aa  6 00756 3521 00	epp2 	pr6|494		bufferp
013001  aa  6 02244 2521 00	spri2	pr6|1188
013002  aa  6 02234 6211 00	eax1 	pr6|1180
013003  aa   020000 4310 07	fld  	8192,dl
013004  aa  6 00044 3701 20	epp4 	pr6|36,*
013005  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
013006  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3054
			if bufferp = null () then do;

013007  aa  6 00756 2371 00	ldaq 	pr6|494		bufferp
013010  aa   765202 6770 04	eraq 	-5502,ic		000212 = 077777000043 000001000000
013011  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013012  aa   000004 6010 04	tnz  	4,ic		013016
						STATEMENT 1 ON LINE 3055
			     needs_space = "1"b;

013013  aa   400000 2350 03	lda  	131072,du
013014  aa  6 00124 7551 00	sta  	pr6|84		needs_space
						STATEMENT 1 ON LINE 3056
			     go to RETURN_FROM_CALLER;

013015  aa   777155 7100 04	tra  	-403,ic		012172
						STATEMENT 1 ON LINE 3057
			end;

						STATEMENT 1 ON LINE 3059
		     addr (bufferp -> buffer.chars (0)) -> based_block_header = TEMPLATE_HASP_BLOCK_HEADER;

013016  aa   765004 2350 04	lda  	-5628,ic		000022 = 020002000000
013017  aa  6 00756 3735 20	epp7 	pr6|494,*		bufferp
013020  aa  7 00001 5511 60	stba 	pr7|1,60		based_block_header.text1
013021  aa   765001 2350 04	lda  	-5631,ic		000022 = 020002000000
013022  aa  7 00001 5511 10	stba 	pr7|1,10		based_block_header.bcb
013023  aa   764777 2370 04	ldaq 	-5633,ic		000022 = 020002000000 000000000000
013024  aa  7 00001 5511 04	stba 	pr7|1,04		based_block_header.fcs
013025  aa  7 00002 5521 40	stbq 	pr7|2,40		based_block_header.fcs
						STATEMENT 1 ON LINE 3061
		     hmd.output_block.tally,
			bufferp -> buffer.tally = length (string (TEMPLATE_HASP_BLOCK_HEADER));

013026  aa   000005 2360 07	ldq  	5,dl
013027  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
013030  aa  5 00053 7561 00	stq  	pr5|43		hmd.tally
013031  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 3063
		     hmd.output_block.first_bufferp, hmd.output_block.last_bufferp = bufferp;

013032  aa  5 00054 6535 00	spri7	pr5|44		hmd.first_bufferp
013033  aa  5 00056 6535 00	spri7	pr5|46		hmd.last_bufferp
						STATEMENT 1 ON LINE 3065
		     return;

013034  aa  6 00750 6101 00	rtcd 	pr6|488
						STATEMENT 1 ON LINE 3067
		end start_new_output_block;

  END PROCEDURE start_new_output_block
  END PROCEDURE cant_accept_records_from_this_de
BEGIN PROCEDURE move_record_to_output_block
ENTRY TO move_record_to_output_block                        STATEMENT 1 ON LINE 3073
move_record_to_output_block:
	     procedure (P_free_buffers);

013035  aa  6 00760 6501 00	spri4	pr6|496
013036  aa  6 00762 2521 00	spri2	pr6|498
						STATEMENT 1 ON LINE 3078
		saved_output_block = hmd.output_block;

013037  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013040  aa  7 00052 2371 00	ldaq 	pr7|42		hmd.output_block
013041  aa  6 00706 7571 00	staq 	pr6|454		saved_output_block
013042  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.output_block
013043  aa  6 00710 7571 00	staq 	pr6|456		saved_output_block
013044  aa  7 00056 2371 00	ldaq 	pr7|46		hmd.output_block
013045  aa  6 00712 7571 00	staq 	pr6|458		saved_output_block
						STATEMENT 1 ON LINE 3079
		saved_last_tally = hmd.output_block.last_bufferp -> buffer.tally;

013046  aa  7 00056 2361 20	ldq  	pr7|46,*		buffer.tally
013047  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013050  aa  6 00714 7561 00	stq  	pr6|460		saved_last_tally
						STATEMENT 1 ON LINE 3081
		if (hste.device_type = HASP_CONSOLE) then    /* console:  RCB is special cased */
		     if (hmd.type = HASP_HOST) then
			call add_to_output_block (addr (HASP_CONSOLE_OUTPUT_RCB), 1);

013051  aa  6 00140 3715 20	epp5 	pr6|96,*		hste_ptr
013052  aa  5 00003 2361 00	ldq  	pr5|3		hste.device_type
013053  aa   000001 1160 07	cmpq 	1,dl
013054  aa   000022 6010 04	tnz  	18,ic		013076
013055  aa  7 00011 2361 00	ldq  	pr7|9		hmd.type
013056  aa   000001 1160 07	cmpq 	1,dl
013057  aa   000010 6010 04	tnz  	8,ic		013067
013060  aa   765040 3534 04	epp3 	-5600,ic		000120 = 221000000000
013061  aa  6 02250 2535 00	spri3	pr6|1192
013062  aa   000001 2360 07	ldq  	1,dl
013063  aa  6 02252 7561 00	stq  	pr6|1194
013064  aa   002314 3520 04	epp2 	1228,ic		015400 = 000004000000
013065  aa   000156 6700 04	tsp4 	110,ic		013243
013066  aa   000016 7100 04	tra  	14,ic		013104
						STATEMENT 1 ON LINE 3084
		     else call add_to_output_block (addr (HASP_CONSOLE_INPUT_RCB), 1);

013067  aa   765032 3534 04	epp3 	-5606,ic		000121 = 222000000000
013070  aa  6 02250 2535 00	spri3	pr6|1192
013071  aa   000001 2360 07	ldq  	1,dl
013072  aa  6 02252 7561 00	stq  	pr6|1194
013073  aa   002305 3520 04	epp2 	1221,ic		015400 = 000004000000
013074  aa   000147 6700 04	tsp4 	103,ic		013243
013075  aa   000007 7100 04	tra  	7,ic		013104
						STATEMENT 1 ON LINE 3085
		else call add_to_output_block (addr (hste.rcb), 1);

013076  aa  5 00006 3535 00	epp3 	pr5|6		hste.rcb
013077  aa  6 02250 2535 00	spri3	pr6|1192
013100  aa   000001 2360 07	ldq  	1,dl
013101  aa  6 02252 7561 00	stq  	pr6|1194
013102  aa   002276 3520 04	epp2 	1214,ic		015400 = 000004000000
013103  aa   000140 6700 04	tsp4 	96,ic		013243
						STATEMENT 1 ON LINE 3087
		bufferp = start_bufferp;

013104  aa  6 00716 3735 20	epp7 	pr6|462,*		start_bufferp
013105  aa  6 00726 6535 00	spri7	pr6|470		bufferp
						STATEMENT 1 ON LINE 3089
		do while (bufferp ^= null ());

013106  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
013107  aa   765103 6770 04	eraq 	-5565,ic		000212 = 077777000043 000001000000
013110  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013111  aa   000053 6000 04	tze  	43,ic		013164
						STATEMENT 1 ON LINE 3091
		     if bufferp = start_bufferp then
			first_idx = start_record_idx;

013112  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
013113  aa  6 00716 6771 00	eraq 	pr6|462		start_bufferp
013114  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013115  aa   000004 6010 04	tnz  	4,ic		013121
013116  aa  6 00722 2361 00	ldq  	pr6|466		start_record_idx
013117  aa  6 00735 7561 00	stq  	pr6|477		first_idx
013120  aa   000002 7100 04	tra  	2,ic		013122
						STATEMENT 1 ON LINE 3093
		     else first_idx = 0;

013121  aa  6 00735 4501 00	stz  	pr6|477		first_idx
						STATEMENT 1 ON LINE 3094
		     if bufferp = end_bufferp then
			last_idx = end_record_idx;

013122  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
013123  aa  6 00720 6771 00	eraq 	pr6|464		end_bufferp
013124  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013125  aa   000004 6010 04	tnz  	4,ic		013131
013126  aa  6 00723 2361 00	ldq  	pr6|467		end_record_idx
013127  aa  6 00736 7561 00	stq  	pr6|478		last_idx
013130  aa   000005 7100 04	tra  	5,ic		013135
						STATEMENT 1 ON LINE 3096
		     else last_idx = bufferp -> buffer.tally - 1;

013131  aa  6 00726 2361 20	ldq  	pr6|470,*		buffer.tally
013132  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013133  aa   000001 1760 07	sbq  	1,dl
013134  aa  6 00736 7561 00	stq  	pr6|478		last_idx
						STATEMENT 1 ON LINE 3098
		     call add_to_output_block (addr (bufferp -> buffer.chars (first_idx)),
					 (last_idx - first_idx + 1));

013135  aa  6 00735 7271 00	lxl7 	pr6|477		first_idx
013136  aa  6 00726 3735 20	epp7 	pr6|470,*		bufferp
013137  aa  7 00001 3521 00	epp2 	pr7|1		buffer.chars
013140  aa  2 00000 5005 17	a9bd 	pr2|0,7
013141  aa  6 02250 2521 00	spri2	pr6|1192
013142  aa  6 00735 1761 00	sbq  	pr6|477		first_idx
013143  aa   000001 0760 07	adq  	1,dl
013144  aa  6 02252 7561 00	stq  	pr6|1194
013145  aa   002233 3520 04	epp2 	1179,ic		015400 = 000004000000
013146  aa   000075 6700 04	tsp4 	61,ic		013243
						STATEMENT 1 ON LINE 3101
		     if (bufferp = end_bufferp) then
			bufferp = null ();

013147  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
013150  aa  6 00720 6771 00	eraq 	pr6|464		end_bufferp
013151  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013152  aa   000004 6010 04	tnz  	4,ic		013156
013153  aa   765037 2370 04	ldaq 	-5601,ic		000212 = 077777000043 000001000000
013154  aa  6 00726 7571 00	staq 	pr6|470		bufferp
013155  aa   777731 7100 04	tra  	-39,ic		013106
						STATEMENT 1 ON LINE 3103
		     else bufferp = pointer (ttybp, bufferp -> buffer.next);

013156  aa  6 00726 2351 20	lda  	pr6|470,*		buffer.next
013157  aa   000066 7730 00	lrl  	54
013160  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
013161  aa   000000 3120 06	eawp2	0,ql
013162  aa  6 00726 2521 00	spri2	pr6|470		bufferp
						STATEMENT 1 ON LINE 3104
		end;

013163  aa   777723 7100 04	tra  	-45,ic		013106
						STATEMENT 1 ON LINE 3106
		record_type = classify_record (saved_output_block.last_bufferp, saved_last_tally);

013164  aa   002204 3520 04	epp2 	1156,ic		015370 = 000006000000
013165  aa   001547 6700 04	tsp4 	871,ic		014734
						STATEMENT 1 ON LINE 3108
		if (record_type = HASP_EOF_RECORD) &
		   (hste.device_type ^= HASP_CONSOLE) & hmd.rts_mode then
		     hste.minor_state = HSTE_SEND_RTS;

013166  aa  6 00732 2361 00	ldq  	pr6|474		record_type
013167  aa   000002 1160 07	cmpq 	2,dl
013170  aa   000013 6010 04	tnz  	11,ic		013203
013171  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
013172  aa  7 00003 2361 00	ldq  	pr7|3		hste.device_type
013173  aa   000001 1160 07	cmpq 	1,dl
013174  aa   000007 6000 04	tze  	7,ic		013203
013175  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
013176  aa  5 00021 2351 00	lda  	pr5|17		hmd.rts_mode
013177  aa   020000 3150 03	cana 	8192,du
013200  aa   000003 6000 04	tze  	3,ic		013203
013201  aa   000002 2360 07	ldq  	2,dl
013202  aa  7 00013 7561 00	stq  	pr7|11		hste.minor_state
						STATEMENT 1 ON LINE 3112
		if P_free_buffers then		/* caller asked us to free the record's buffers ... */
		     do bufferp = start_bufferp	/* ... but not the last buffer which the caller will handle */
			        repeat (p) while (bufferp ^= end_bufferp);

013203  aa  6 00762 3735 20	epp7 	pr6|498,*
013204  aa  7 00002 2351 20	lda  	pr7|2,*		P_free_buffers
013205  aa   400000 3150 03	cana 	131072,du
013206  aa   000034 6000 04	tze  	28,ic		013242
013207  aa  6 00716 3715 20	epp5 	pr6|462,*		start_bufferp
013210  aa  6 00726 6515 00	spri5	pr6|470		bufferp
013211  aa   000000 0110 03	nop  	0,du
013212  aa  6 00726 2371 00	ldaq 	pr6|470		bufferp
013213  aa  6 00720 6771 00	eraq 	pr6|464		end_bufferp
013214  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013215  aa   000025 6000 04	tze  	21,ic		013242
						STATEMENT 1 ON LINE 3115
			p = pointer (ttybp, bufferp -> buffer.next);

013216  aa  6 00726 2351 20	lda  	pr6|470,*		buffer.next
013217  aa   000066 7730 00	lrl  	54
013220  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
013221  aa   000000 3120 06	eawp2	0,ql
013222  aa  6 00730 2521 00	spri2	pr6|472		p
						STATEMENT 1 ON LINE 3116
			call tty_space_man$free_buffer (hste.devx, OUTPUT, bufferp);

013223  aa  6 00140 3735 20	epp7 	pr6|96,*		hste_ptr
013224  aa  7 00005 3521 00	epp2 	pr7|5		hste.devx
013225  aa  6 02256 2521 00	spri2	pr6|1198
013226  aa   764734 3520 04	epp2 	-5668,ic		000162 = 400000000000
013227  aa  6 02260 2521 00	spri2	pr6|1200
013230  aa  6 00726 3521 00	epp2 	pr6|470		bufferp
013231  aa  6 02262 2521 00	spri2	pr6|1202
013232  aa  6 02254 6211 00	eax1 	pr6|1196
013233  aa   014000 4310 07	fld  	6144,dl
013234  aa  6 00044 3701 20	epp4 	pr6|36,*
013235  la  4 00112 3521 20	epp2 	pr4|74,*		tty_space_man$free_buffer
013236  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3117
		     end;

013237  aa  6 00730 3735 20	epp7 	pr6|472,*		p
013240  aa  6 00726 6535 00	spri7	pr6|470		bufferp
013241  aa   777751 7100 04	tra  	-23,ic		013212
						STATEMENT 1 ON LINE 3119
		return;

013242  aa  6 00760 6101 00	rtcd 	pr6|496
						STATEMENT 1 ON LINE 3229
	     end move_record_to_output_block;

BEGIN PROCEDURE add_to_output_block
ENTRY TO add_to_output_block                                STATEMENT 1 ON LINE 3124
add_to_output_block:
		procedure (P_text_ptr, P_text_lth);

013243  aa  6 00766 6501 00	spri4	pr6|502
013244  aa  6 00770 2521 00	spri2	pr6|504
						STATEMENT 1 ON LINE 3143
		     text_ptr = P_text_ptr;

013245  aa  2 00002 3735 20	epp7 	pr2|2,*		P_text_ptr
013246  aa  7 00000 3735 20	epp7 	pr7|0,*		P_text_ptr
013247  aa  6 00774 6535 00	spri7	pr6|508		text_ptr
						STATEMENT 1 ON LINE 3144
		     text_lth = P_text_lth;

013250  aa  2 00004 2361 20	ldq  	pr2|4,*		P_text_lth
013251  aa  6 00776 7561 00	stq  	pr6|510		text_lth
						STATEMENT 1 ON LINE 3146
		     bufferp = hmd.output_block.last_bufferp;

013252  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
013253  aa  5 00056 3715 20	epp5 	pr5|46,*		hmd.last_bufferp
013254  aa  6 01000 6515 00	spri5	pr6|512		bufferp
						STATEMENT 1 ON LINE 3148
		     start = 1;

013255  aa   000001 2360 07	ldq  	1,dl
013256  aa  6 01004 7561 00	stq  	pr6|516		start
						STATEMENT 1 ON LINE 3150
		     do while (start <= text_lth);

013257  aa   000000 0110 03	nop  	0,du
013260  aa  6 01004 2361 00	ldq  	pr6|516		start
013261  aa  6 00776 1161 00	cmpq 	pr6|510		text_lth
013262  aa   000244 6054 04	tpnz 	164,ic		013526
						STATEMENT 1 ON LINE 3152
			space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code)
							  - (bufferp -> buffer.tally);

013263  aa  6 01000 2351 20	lda  	pr6|512,*		buffer.size_code
013264  aa   000030 7350 00	als  	24
013265  aa   000105 7730 00	lrl  	69
013266  aa  6 01000 2351 20	lda  	pr6|512,*		buffer.tally
013267  aa   000033 7350 00	als  	27
013270  aa   000000 6270 06	eax7 	0,ql
013271  aa   000077 7730 00	lrl  	63
013272  aa  6 02265 7561 00	stq  	pr6|1205		buffer.tally
013273  ta   000102 2360 17	ldq  	66,7
013274  aa  6 02265 1761 00	sbq  	pr6|1205		buffer.tally
013275  aa  6 01006 7561 00	stq  	pr6|518		space_left_in_buffer
						STATEMENT 1 ON LINE 3155
			substr_lth = index (substr (text, start), DLE);

013276  aa  6 01004 2361 00	ldq  	pr6|516		start
013277  aa   000001 1760 07	sbq  	1,dl
013300  aa  6 02265 7561 00	stq  	pr6|1205
013301  aa  6 00776 2361 00	ldq  	pr6|510		text_lth
013302  aa  6 02265 1761 00	sbq  	pr6|1205
013303  aa  6 01004 7261 00	lxl6 	pr6|516		start
013304  aa  6 00774 3735 20	epp7 	pr6|508,*		text_ptr
013305  aa  000 003 124 556	scm  	(pr,rl,x6),(du),mask(000)
013306  aa  7 77777 60 0006	desc9a	pr7|-1(3),ql	text
013307  aa   020000 00 0001	desc9a	8192,1
013310  aa  6 00056 0001 00	arg  	pr6|46
013311  aa  6 00056 2361 00	ldq  	pr6|46
013312  aa   000002 6070 04	ttf  	2,ic		013314
013313  aa   000001 3360 07	lcq  	1,dl
013314  aa   000001 0760 07	adq  	1,dl
013315  aa  6 01005 7561 00	stq  	pr6|517		substr_lth
						STATEMENT 1 ON LINE 3157
			if substr_lth ^= 0 then
			     add_dle = "1"b;

013316  aa   000004 6000 04	tze  	4,ic		013322
013317  aa   400000 2350 03	lda  	131072,du
013320  aa  6 01007 7551 00	sta  	pr6|519		add_dle
013321  aa   000006 7100 04	tra  	6,ic		013327
						STATEMENT 1 ON LINE 3159
			else do;

						STATEMENT 1 ON LINE 3160
			     substr_lth = text_lth - start + 1;

013322  aa  6 00776 2361 00	ldq  	pr6|510		text_lth
013323  aa  6 01004 1761 00	sbq  	pr6|516		start
013324  aa   000001 0760 07	adq  	1,dl
013325  aa  6 01005 7561 00	stq  	pr6|517		substr_lth
						STATEMENT 1 ON LINE 3161
			     add_dle = "0"b;

013326  aa  6 01007 4501 00	stz  	pr6|519		add_dle
						STATEMENT 1 ON LINE 3162
			end;

						STATEMENT 1 ON LINE 3164
			do while (space_left_in_buffer < substr_lth);

013327  aa   000000 0110 03	nop  	0,du
013330  aa  6 01006 2361 00	ldq  	pr6|518		space_left_in_buffer
013331  aa  6 01005 1161 00	cmpq 	pr6|517		substr_lth
013332  aa   000071 6050 04	tpl  	57,ic		013423
						STATEMENT 1 ON LINE 3165
			     if space_left_in_buffer > 0 then do;

013333  aa  6 01006 2361 00	ldq  	pr6|518		space_left_in_buffer
013334  aa   000023 6044 04	tmoz 	19,ic		013357
						STATEMENT 1 ON LINE 3166
				addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_buffer_remainder
				     = substr (text, start, space_left_in_buffer);

013335  aa  6 01000 2361 20	ldq  	pr6|512,*		buffer.tally
013336  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013337  aa  6 01000 3735 20	epp7 	pr6|512,*		bufferp
013340  aa  6 01004 7271 00	lxl7 	pr6|516		start
013341  aa  6 00774 3715 20	epp5 	pr6|508,*		text_ptr
013342  aa  6 01006 7261 00	lxl6 	pr6|518		space_left_in_buffer
013343  aa  040 146 100 557	mlr  	(pr,rl,x7),(pr,rl,ql),fill(040)
013344  aa  5 77777 60 0016	desc9a	pr5|-1(3),x6	text
013345  aa  7 00001 00 0016	desc9a	pr7|1,x6		based_buffer_remainder
						STATEMENT 1 ON LINE 3168
				bufferp -> buffer.tally = max_buffer_tally (bufferp -> buffer.size_code);

013346  aa  7 00000 2351 00	lda  	pr7|0		buffer.size_code
013347  aa   000030 7350 00	als  	24
013350  aa   000105 7730 00	lrl  	69
013351  ta   000102 2360 06	ldq  	66,ql
013352  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 3169
				start = start + space_left_in_buffer;

013353  aa  6 01006 2361 00	ldq  	pr6|518		space_left_in_buffer
013354  aa  6 01004 0561 00	asq  	pr6|516		start
						STATEMENT 1 ON LINE 3170
				substr_lth = substr_lth - space_left_in_buffer;

013355  aa  6 01006 3361 00	lcq  	pr6|518		space_left_in_buffer
013356  aa  6 01005 0561 00	asq  	pr6|517		substr_lth
						STATEMENT 1 ON LINE 3171
			     end;

						STATEMENT 1 ON LINE 3172
			     call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT,
						      new_bufferp);

013357  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013360  aa  7 00027 2351 00	lda  	pr7|23		hmd.max_buf_size
013361  aa   000077 7730 00	lrl  	63
013362  aa  6 02265 7561 00	stq  	pr6|1205
013363  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
013364  aa  6 02270 2521 00	spri2	pr6|1208
013365  aa  6 02265 3521 00	epp2 	pr6|1205
013366  aa  6 02272 2521 00	spri2	pr6|1210
013367  aa   764573 3520 04	epp2 	-5765,ic		000162 = 400000000000
013370  aa  6 02274 2521 00	spri2	pr6|1212
013371  aa  6 01002 3521 00	epp2 	pr6|514		new_bufferp
013372  aa  6 02276 2521 00	spri2	pr6|1214
013373  aa  6 02266 6211 00	eax1 	pr6|1206
013374  aa   020000 4310 07	fld  	8192,dl
013375  aa  6 00044 3701 20	epp4 	pr6|36,*
013376  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
013377  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3174
				if new_bufferp = null () then go to NO_MORE_ROOM;

013400  aa  6 01002 2371 00	ldaq 	pr6|514		new_bufferp
013401  aa   764611 6770 04	eraq 	-5751,ic		000212 = 077777000043 000001000000
013402  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013403  aa   000127 6000 04	tze  	87,ic		013532
						STATEMENT 1 ON LINE 3175
			     bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);

013404  aa  6 01002 6351 20	eaa  	pr6|514,*		new_bufferp
013405  aa   000066 7730 00	lrl  	54
013406  aa   000066 7370 00	lls  	54
013407  aa  6 01000 3735 20	epp7 	pr6|512,*		buffer.next
013410  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 3176
			     hmd.output_block.last_bufferp, bufferp = new_bufferp;

013411  aa  6 01002 3715 20	epp5 	pr6|514,*		new_bufferp
013412  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
013413  aa  3 00056 6515 00	spri5	pr3|46		hmd.last_bufferp
013414  aa  6 01000 6515 00	spri5	pr6|512		bufferp
						STATEMENT 1 ON LINE 3177
			     space_left_in_buffer = max_buffer_tally (bufferp -> buffer.size_code);

013415  aa  5 00000 2351 00	lda  	pr5|0		buffer.size_code
013416  aa   000030 7350 00	als  	24
013417  aa   000105 7730 00	lrl  	69
013420  ta   000102 2360 06	ldq  	66,ql
013421  aa  6 01006 7561 00	stq  	pr6|518		space_left_in_buffer
						STATEMENT 1 ON LINE 3178
			end;

013422  aa   777706 7100 04	tra  	-58,ic		013330
						STATEMENT 1 ON LINE 3180
			if substr_lth ^= 0 then do;

013423  aa  6 01005 2361 00	ldq  	pr6|517		substr_lth
013424  aa   000016 6000 04	tze  	14,ic		013442
						STATEMENT 1 ON LINE 3181
			     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_substring =
				     substr (text, start, substr_lth);

013425  aa  6 01000 2361 20	ldq  	pr6|512,*		buffer.tally
013426  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013427  aa  6 01000 3735 20	epp7 	pr6|512,*		bufferp
013430  aa  6 01004 7271 00	lxl7 	pr6|516		start
013431  aa  6 00774 3715 20	epp5 	pr6|508,*		text_ptr
013432  aa  6 01005 7261 00	lxl6 	pr6|517		substr_lth
013433  aa  040 146 100 557	mlr  	(pr,rl,x7),(pr,rl,ql),fill(040)
013434  aa  5 77777 60 0016	desc9a	pr5|-1(3),x6	text
013435  aa  7 00001 00 0016	desc9a	pr7|1,x6		based_substring
						STATEMENT 1 ON LINE 3183
			     bufferp -> buffer.tally = (bufferp -> buffer.tally) + substr_lth;

013436  aa  6 01005 0761 00	adq  	pr6|517		substr_lth
013437  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 3184
			     start = start + substr_lth;

013440  aa  6 01005 2361 00	ldq  	pr6|517		substr_lth
013441  aa  6 01004 0561 00	asq  	pr6|516		start
						STATEMENT 1 ON LINE 3185
			end;

						STATEMENT 1 ON LINE 3187
			if add_dle then do;

013442  aa  6 01007 2351 00	lda  	pr6|519		add_dle
013443  aa   777615 6000 04	tze  	-115,ic		013260
						STATEMENT 1 ON LINE 3188
			     if (bufferp -> buffer.tally) = max_buffer_tally (bufferp -> buffer.size_code)
			     then do;

013444  aa  6 01000 2351 20	lda  	pr6|512,*		buffer.size_code
013445  aa   000030 7350 00	als  	24
013446  aa   000105 7730 00	lrl  	69
013447  aa  6 01000 2351 20	lda  	pr6|512,*		buffer.tally
013450  aa   000033 7350 00	als  	27
013451  aa   000000 6270 06	eax7 	0,ql
013452  aa   000077 7730 00	lrl  	63
013453  ta   000102 1160 17	cmpq 	66,7
013454  aa   000037 6010 04	tnz  	31,ic		013513
						STATEMENT 1 ON LINE 3190
				call tty_space_man$get_buffer (hmd.devx, (hmd.dialup_info.max_buf_size), OUTPUT,
							 new_bufferp);

013455  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013456  aa  7 00027 2351 00	lda  	pr7|23		hmd.max_buf_size
013457  aa   000077 7730 00	lrl  	63
013460  aa  6 02265 7561 00	stq  	pr6|1205
013461  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
013462  aa  6 02270 2521 00	spri2	pr6|1208
013463  aa  6 02265 3521 00	epp2 	pr6|1205
013464  aa  6 02272 2521 00	spri2	pr6|1210
013465  aa   764475 3520 04	epp2 	-5827,ic		000162 = 400000000000
013466  aa  6 02274 2521 00	spri2	pr6|1212
013467  aa  6 01002 3521 00	epp2 	pr6|514		new_bufferp
013470  aa  6 02276 2521 00	spri2	pr6|1214
013471  aa  6 02266 6211 00	eax1 	pr6|1206
013472  aa   020000 4310 07	fld  	8192,dl
013473  aa  6 00044 3701 20	epp4 	pr6|36,*
013474  la  4 00110 3521 20	epp2 	pr4|72,*		tty_space_man$get_buffer
013475  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3192
				     if new_bufferp = null () then go to NO_MORE_ROOM;

013476  aa  6 01002 2371 00	ldaq 	pr6|514		new_bufferp
013477  aa   764513 6770 04	eraq 	-5813,ic		000212 = 077777000043 000001000000
013500  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013501  aa   000031 6000 04	tze  	25,ic		013532
						STATEMENT 1 ON LINE 3193
				bufferp -> buffer.next = binary (rel (new_bufferp), 18, 0);

013502  aa  6 01002 6351 20	eaa  	pr6|514,*		new_bufferp
013503  aa   000066 7730 00	lrl  	54
013504  aa   000066 7370 00	lls  	54
013505  aa  6 01000 3735 20	epp7 	pr6|512,*		buffer.next
013506  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 3194
				hmd.output_block.last_bufferp, bufferp = new_bufferp;

013507  aa  6 01002 3715 20	epp5 	pr6|514,*		new_bufferp
013510  aa  6 00136 3535 20	epp3 	pr6|94,*		hmd_ptr
013511  aa  3 00056 6515 00	spri5	pr3|46		hmd.last_bufferp
013512  aa  6 01000 6515 00	spri5	pr6|512		bufferp
						STATEMENT 1 ON LINE 3195
			     end;

						STATEMENT 1 ON LINE 3196
			     addr (bufferp -> buffer.chars (bufferp -> buffer.tally)) -> based_character = DLE;

013513  aa  6 01000 2361 20	ldq  	pr6|512,*		buffer.tally
013514  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013515  aa  6 01000 3735 20	epp7 	pr6|512,*		bufferp
013516  aa  020 106 100 400	mlr  	(),(pr,ql),fill(020)
013517  aa   000000 00 0000	desc9a	0,0
013520  aa  7 00001 00 0001	desc9a	pr7|1,1		based_character
						STATEMENT 1 ON LINE 3197
			     bufferp -> buffer.tally = (bufferp -> buffer.tally) + 1;

013521  aa   000001 0760 07	adq  	1,dl
013522  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 3198
			     hmd.output_block.tally = hmd.output_block.tally + 1;

013523  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
013524  aa  5 00053 0541 00	aos  	pr5|43		hmd.tally
						STATEMENT 1 ON LINE 3199
			end;

						STATEMENT 1 ON LINE 3200
		     end;

013525  aa   777533 7100 04	tra  	-165,ic		013260
						STATEMENT 1 ON LINE 3202
		     hmd.output_block.tally = hmd.output_block.tally + text_lth;

013526  aa  6 00776 2361 00	ldq  	pr6|510		text_lth
013527  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013530  aa  7 00053 0561 00	asq  	pr7|43		hmd.tally
						STATEMENT 1 ON LINE 3205
		     return;

013531  aa  6 00766 6101 00	rtcd 	pr6|502
						STATEMENT 1 ON LINE 3211
NO_MORE_ROOM:	     hmd.output_block = saved_output_block;

013532  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013533  aa  6 00706 2371 00	ldaq 	pr6|454		saved_output_block
013534  aa  7 00052 7571 00	staq 	pr7|42		hmd.output_block
013535  aa  6 00710 2371 00	ldaq 	pr6|456		saved_output_block
013536  aa  7 00054 7571 00	staq 	pr7|44		hmd.output_block
013537  aa  6 00712 2371 00	ldaq 	pr6|458		saved_output_block
013540  aa  7 00056 7571 00	staq 	pr7|46		hmd.output_block
						STATEMENT 1 ON LINE 3212
		     hmd.output_block.last_bufferp -> buffer.tally = saved_last_tally;

013541  aa  6 00714 2361 00	ldq  	pr6|460		saved_last_tally
013542  aa  7 00056 3715 20	epp5 	pr7|46,*		buffer.tally
013543  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 3214
		     if (hmd.output_block.last_bufferp -> buffer.next) ^= 0 
		     then do;

013544  aa  7 00056 2351 20	lda  	pr7|46,*		buffer.next
013545  aa   000066 7730 00	lrl  	54
013546  aa   000023 6000 04	tze  	19,ic		013571
						STATEMENT 1 ON LINE 3216
			bufferp = pointer (ttybp, hmd.output_block.last_bufferp -> buffer.next);

013547  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
013550  aa   000000 3120 06	eawp2	0,ql
013551  aa  6 01000 2521 00	spri2	pr6|512		bufferp
						STATEMENT 1 ON LINE 3217
			call tty_space_man$free_chain (hmd.devx, OUTPUT, bufferp);

013552  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
013553  aa  6 02270 2521 00	spri2	pr6|1208
013554  aa   764406 3520 04	epp2 	-5882,ic		000162 = 400000000000
013555  aa  6 02272 2521 00	spri2	pr6|1210
013556  aa  6 01000 3521 00	epp2 	pr6|512		bufferp
013557  aa  6 02274 2521 00	spri2	pr6|1212
013560  aa  6 02266 6211 00	eax1 	pr6|1206
013561  aa   014000 4310 07	fld  	6144,dl
013562  aa  6 00044 3701 20	epp4 	pr6|36,*
013563  la  4 00116 3521 20	epp2 	pr4|78,*		tty_space_man$free_chain
013564  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3218
			hmd.output_block.last_bufferp -> buffer.next = 0;

013565  aa   000000 2350 07	lda  	0,dl
013566  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013567  aa  7 00056 3715 20	epp5 	pr7|46,*		buffer.next
013570  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 3219
		     end;

						STATEMENT 1 ON LINE 3221
		     needs_space = "1"b;

013571  aa   400000 2350 03	lda  	131072,du
013572  aa  6 00124 7551 00	sta  	pr6|84		needs_space
						STATEMENT 1 ON LINE 3223
		     if loopback_entry then
			go to RETURN_FROM_CALLER;

013573  aa  6 00704 2351 00	lda  	pr6|452		loopback_entry
013574  aa   776376 6010 04	tnz  	-770,ic		012172
						STATEMENT 1 ON LINE 3225
		     else go to RETURN_FROM_PROCESS_OUTPUT_RECORDS;

013575  aa   776601 7100 04	tra  	-639,ic		012376
						STATEMENT 1 ON LINE 3227
		end add_to_output_block;

  END PROCEDURE add_to_output_block
  END PROCEDURE move_record_to_output_block
BEGIN PROCEDURE count_dles
ENTRY TO count_dles                                         STATEMENT 1 ON LINE 3234
count_dles:    procedure (P_bufferp) returns (fixed binary);

013576  aa  6 01010 6501 00	spri4	pr6|520
013577  aa  6 01012 2521 00	spri2	pr6|522
						STATEMENT 1 ON LINE 3244
		bufferp = P_bufferp;

013600  aa  2 00002 3735 20	epp7 	pr2|2,*		P_bufferp
013601  aa  7 00000 3735 20	epp7 	pr7|0,*		P_bufferp
013602  aa  6 01016 6535 00	spri7	pr6|526		bufferp
						STATEMENT 1 ON LINE 3246
		start = 1;

013603  aa   000001 2360 07	ldq  	1,dl
013604  aa  6 01020 7561 00	stq  	pr6|528		start
						STATEMENT 1 ON LINE 3247
		idx = index (buffer_text, DLE);

013605  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
013606  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013607  aa  000 003 124 540	scm  	(pr,rl),(du),mask(000)
013610  aa  7 00001 00 0006	desc9a	pr7|1,ql		buffer_text
013611  aa   020000 00 0001	desc9a	8192,1
013612  aa  6 00056 0001 00	arg  	pr6|46
013613  aa  6 00056 2361 00	ldq  	pr6|46
013614  aa   000002 6070 04	ttf  	2,ic		013616
013615  aa   000001 3360 07	lcq  	1,dl
013616  aa   000001 0760 07	adq  	1,dl
013617  aa  6 01021 7561 00	stq  	pr6|529		idx
						STATEMENT 1 ON LINE 3249
		dle_count = 0;

013620  aa  6 01022 4501 00	stz  	pr6|530		dle_count
						STATEMENT 1 ON LINE 3251
		do while (idx ^= 0);

013621  aa   000000 0110 03	nop  	0,du
013622  aa  6 01021 2361 00	ldq  	pr6|529		idx
013623  aa   000033 6000 04	tze  	27,ic		013656
						STATEMENT 1 ON LINE 3252
		     dle_count = dle_count + 1;

013624  aa  6 01022 0541 00	aos  	pr6|530		dle_count
						STATEMENT 1 ON LINE 3253
		     start = start + idx;

013625  aa  6 01020 0561 00	asq  	pr6|528		start
						STATEMENT 1 ON LINE 3254
		     if start > (bufferp -> buffer.tally) then
			idx = 0;

013626  aa  6 01016 2361 20	ldq  	pr6|526,*		buffer.tally
013627  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
013630  aa  6 02302 7561 00	stq  	pr6|1218		buffer.tally
013631  aa  6 01020 1161 00	cmpq 	pr6|528		start
013632  aa   000003 6050 04	tpl  	3,ic		013635
013633  aa  6 01021 4501 00	stz  	pr6|529		idx
013634  aa   777766 7100 04	tra  	-10,ic		013622
						STATEMENT 1 ON LINE 3256
		     else idx = index (substr (buffer_text, start), DLE);

013635  aa  6 01020 2361 00	ldq  	pr6|528		start
013636  aa   000001 1760 07	sbq  	1,dl
013637  aa  6 02303 7561 00	stq  	pr6|1219
013640  aa  6 02302 2361 00	ldq  	pr6|1218		buffer.tally
013641  aa  6 02303 1761 00	sbq  	pr6|1219
013642  aa  6 01020 7271 00	lxl7 	pr6|528		start
013643  aa  6 01016 3735 20	epp7 	pr6|526,*		bufferp
013644  aa  000 003 124 557	scm  	(pr,rl,x7),(du),mask(000)
013645  aa  7 00000 60 0006	desc9a	pr7|0(3),ql	buffer_text
013646  aa   020000 00 0001	desc9a	8192,1
013647  aa  6 00056 0001 00	arg  	pr6|46
013650  aa  6 00056 2361 00	ldq  	pr6|46
013651  aa   000002 6070 04	ttf  	2,ic		013653
013652  aa   000001 3360 07	lcq  	1,dl
013653  aa   000001 0760 07	adq  	1,dl
013654  aa  6 01021 7561 00	stq  	pr6|529		idx
						STATEMENT 1 ON LINE 3257
		end;

013655  aa   777745 7100 04	tra  	-27,ic		013622
						STATEMENT 1 ON LINE 3259
		return (dle_count);

013656  aa  6 01022 2361 00	ldq  	pr6|530		dle_count
013657  aa  6 01012 3735 20	epp7 	pr6|522,*
013660  aa  7 00004 7561 20	stq  	pr7|4,*
013661  aa  6 01010 6101 00	rtcd 	pr6|520
						STATEMENT 1 ON LINE 3261
	     end count_dles;

  END PROCEDURE count_dles
  END PROCEDURE output_records_processor
BEGIN PROCEDURE transmit_output_block
ENTRY TO transmit_output_block                              STATEMENT 1 ON LINE 3268
transmit_output_block:
	procedure ();

013662  aa  6 01024 6501 00	spri4	pr6|532
						STATEMENT 1 ON LINE 3274
	     if ^hmd.send_output then return;

013663  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013664  aa  7 00070 2351 00	lda  	pr7|56		hmd.send_output
013665  aa   100000 3150 03	cana 	32768,du
013666  aa   000002 6010 04	tnz  	2,ic		013670
013667  aa  6 01024 6101 00	rtcd 	pr6|532
						STATEMENT 1 ON LINE 3276
	     if hmd.output_chain_ptr ^= null () then do;

013670  aa  7 00040 2371 00	ldaq 	pr7|32		hmd.output_chain_ptr
013671  aa   764321 6770 04	eraq 	-5935,ic		000212 = 077777000043 000001000000
013672  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013673  aa   000047 6000 04	tze  	39,ic		013742
						STATEMENT 1 ON LINE 3277
		p = hmd.output_chain_ptr;

013674  aa  7 00040 3715 20	epp5 	pr7|32,*		hmd.output_chain_ptr
013675  aa  6 01032 6515 00	spri5	pr6|538		p
						STATEMENT 1 ON LINE 3279
		call channel_manager$write (hmd.devx, p, code);

013676  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
013677  aa  6 02306 2521 00	spri2	pr6|1222
013700  aa  6 01032 3521 00	epp2 	pr6|538		p
013701  aa  6 02310 2521 00	spri2	pr6|1224
013702  aa  6 00101 3521 00	epp2 	pr6|65		code
013703  aa  6 02312 2521 00	spri2	pr6|1226
013704  aa  6 02304 6211 00	eax1 	pr6|1220
013705  aa   014000 4310 07	fld  	6144,dl
013706  aa  6 00044 3701 20	epp4 	pr6|36,*
013707  la  4 00074 3521 20	epp2 	pr4|60,*		channel_manager$write
013710  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3280
		if code = 0 then
		     hmd.retry_transmit_output = "0"b;

013711  aa  6 00101 2361 00	ldq  	pr6|65		code
013712  aa   000005 6010 04	tnz  	5,ic		013717
013713  aa   001454 2350 04	lda  	812,ic		015367 = 775777777777
013714  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013715  aa  7 00070 3551 00	ansa 	pr7|56		hmd.retry_transmit_output
013716  aa   000017 7100 04	tra  	15,ic		013735
						STATEMENT 1 ON LINE 3282
		else if code = et_noalloc
		     then do;

013717  aa  6 00044 3701 20	epp4 	pr6|36,*
013720  ia  4 00017 1161 00	cmpq 	pr4|15		et_noalloc
013721  aa   000013 6010 04	tnz  	11,ic		013734
						STATEMENT 1 ON LINE 3284
			hmd.retry_transmit_output = "1"b;

013722  aa   002000 2350 03	lda  	1024,du
013723  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013724  aa  7 00070 2551 00	orsa 	pr7|56		hmd.retry_transmit_output
						STATEMENT 1 ON LINE 3285
			call tty_space_man$needs_space (hmd.devx);

013725  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
013726  aa  6 02306 2521 00	spri2	pr6|1222
013727  aa  6 02304 6211 00	eax1 	pr6|1220
013730  aa   004000 4310 07	fld  	2048,dl
013731  la  4 00120 3521 20	epp2 	pr4|80,*		tty_space_man$needs_space
013732  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3286
		     end;

013733  aa   000002 7100 04	tra  	2,ic		013735
						STATEMENT 1 ON LINE 3287
		     else return;

013734  aa  6 01024 6101 00	rtcd 	pr6|532
						STATEMENT 1 ON LINE 3289
		hmd.output_chain_ptr = p;

013735  aa  6 01032 3735 20	epp7 	pr6|538,*		p
013736  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
013737  aa  5 00040 6535 00	spri7	pr5|32		hmd.output_chain_ptr
						STATEMENT 1 ON LINE 3290
		hmd.send_output = "0"b;

013740  aa   002015 2350 04	lda  	1037,ic		015755 = 677777777777
013741  aa  5 00070 3551 00	ansa 	pr5|56		hmd.send_output
						STATEMENT 1 ON LINE 3291
	     end;

						STATEMENT 1 ON LINE 3293
	     if hmd.output_chain_ptr = null () then
		hmd.output_in_progress = "0"b;

013742  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
013743  aa  7 00040 2371 00	ldaq 	pr7|32		hmd.output_chain_ptr
013744  aa   764246 6770 04	eraq 	-5978,ic		000212 = 077777000043 000001000000
013745  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
013746  aa   000004 6010 04	tnz  	4,ic		013752
013747  aa   001417 2350 04	lda  	783,ic		015366 = 757777777777
013750  aa  7 00070 3551 00	ansa 	pr7|56		hmd.output_in_progress
013751  aa   000003 7100 04	tra  	3,ic		013754
						STATEMENT 1 ON LINE 3295
	     else hmd.output_in_progress = "1"b;

013752  aa   020000 2350 03	lda  	8192,du
013753  aa  7 00070 2551 00	orsa 	pr7|56		hmd.output_in_progress
						STATEMENT 1 ON LINE 3297
	     return;

013754  aa  6 01024 6101 00	rtcd 	pr6|532
						STATEMENT 1 ON LINE 3299
	end transmit_output_block;

  END PROCEDURE transmit_output_block
BEGIN PROCEDURE do_line_control
ENTRY TO do_line_control                                    STATEMENT 1 ON LINE 3303
do_line_control:
	procedure (P_line_ctl_opcode, P_line_ctl_val1, P_line_ctl_val2, P_line_ctl_val3);

013755  aa  6 01034 6501 00	spri4	pr6|540
013756  aa  6 01036 2521 00	spri2	pr6|542
						STATEMENT 1 ON LINE 3308
	     line_ctl.op = P_line_ctl_opcode;

013757  aa  2 00002 2361 20	ldq  	pr2|2,*		P_line_ctl_opcode
013760  aa   000066 7370 00	lls  	54
013761  aa  6 00152 5511 60	stba 	pr6|106,60	line_ctl.op
						STATEMENT 1 ON LINE 3310
	     line_ctl.val (1) = P_line_ctl_val1;

013762  aa  2 00004 2361 20	ldq  	pr2|4,*		P_line_ctl_val1
013763  aa  6 00152 5521 14	stbq 	pr6|106,14	line_ctl.val
						STATEMENT 1 ON LINE 3311
	     line_ctl.val (2) = P_line_ctl_val2;

013764  aa  2 00006 2361 20	ldq  	pr2|6,*		P_line_ctl_val2
013765  aa   000066 7370 00	lls  	54
013766  aa  6 00153 5511 60	stba 	pr6|107,60	line_ctl.val
						STATEMENT 1 ON LINE 3312
	     line_ctl.val (3) = P_line_ctl_val3;

013767  aa  2 00010 2361 20	ldq  	pr2|8,*		P_line_ctl_val3
013770  aa  6 00153 5521 14	stbq 	pr6|107,14	line_ctl.val
						STATEMENT 1 ON LINE 3314
	     call channel_manager$control (hmd.devx, "line_control", addr (line_ctl), code);

013771  aa   764223 2370 04	ldaq 	-5997,ic		000214 = 154151156145 137143157156
013772  aa  6 02314 7571 00	staq 	pr6|1228
013773  aa   764223 2350 04	lda  	-5997,ic		000216 = 164162157154
013774  aa  6 02316 7551 00	sta  	pr6|1230
013775  aa  6 00152 3735 00	epp7 	pr6|106		line_ctl
013776  aa  6 02320 6535 00	spri7	pr6|1232
013777  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
014000  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
014001  aa  6 02324 2521 00	spri2	pr6|1236
014002  aa  6 02314 3521 00	epp2 	pr6|1228
014003  aa  6 02326 2521 00	spri2	pr6|1238
014004  aa  6 02320 3521 00	epp2 	pr6|1232
014005  aa  6 02330 2521 00	spri2	pr6|1240
014006  aa  6 00101 3521 00	epp2 	pr6|65		code
014007  aa  6 02332 2521 00	spri2	pr6|1242
014010  aa   764165 3520 04	epp2 	-6027,ic		000175 = 404000000021
014011  aa  6 02334 2521 00	spri2	pr6|1244
014012  aa   764125 3520 04	epp2 	-6059,ic		000137 = 524000000014
014013  aa  6 02336 2521 00	spri2	pr6|1246
014014  aa   764163 3520 04	epp2 	-6029,ic		000177 = 464000000000
014015  aa  6 02340 2521 00	spri2	pr6|1248
014016  aa   764155 3520 04	epp2 	-6035,ic		000173 = 404000000043
014017  aa  6 02342 2521 00	spri2	pr6|1250
014020  aa  6 02322 6211 00	eax1 	pr6|1234
014021  aa   020000 4310 07	fld  	8192,dl
014022  aa  6 00044 3701 20	epp4 	pr6|36,*
014023  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
014024  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3316
	     if code = 0 then
		return;

014025  aa  6 00101 2361 00	ldq  	pr6|65		code
014026  aa   765551 6010 04	tnz  	-5271,ic		001577
014027  aa  6 01034 6101 00	rtcd 	pr6|540
						STATEMENT 1 ON LINE 3320
	end do_line_control;

  END PROCEDURE do_line_control
BEGIN PROCEDURE process_line_status
ENTRY TO process_line_status                                STATEMENT 1 ON LINE 3325
process_line_status:
	procedure ();

014030  aa  6 01042 6501 00	spri4	pr6|546
						STATEMENT 1 ON LINE 3328
	     if (line_stat.op < lbound (LINE_STATUS, 1)) | (line_stat.op > hbound (LINE_STATUS, 1)) then
		return;

014031  aa  6 00154 2351 00	lda  	pr6|108		line_stat.op
014032  aa   000066 7330 00	lrs  	54
014033  aa  6 02344 7561 00	stq  	pr6|1252		line_stat.op
014034  aa   000001 1160 07	cmpq 	1,dl
014035  aa   000005 6040 04	tmi  	5,ic		014042
014036  aa   000016 1160 07	cmpq 	14,dl
014037  aa   000003 6054 04	tpnz 	3,ic		014042
014040  aa   000000 6270 06	eax7 	0,ql
014041  ta   000063 7100 17	tra  	51,7
014042  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3334
LINE_STATUS (1):					/* BID FAILED -- could not complete HASP initialization */
	     if hmd.state = HMD_LOADING then do;

014043  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014044  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
014045  aa   000002 1160 07	cmpq 	2,dl
014046  aa   000020 6010 04	tnz  	16,ic		014066
						STATEMENT 1 ON LINE 3336
		call crash_mpx ();

014047  aa   767440 6700 04	tsp4 	-4320,ic		003507
						STATEMENT 1 ON LINE 3337
		call pxss$ring_0_wakeup (hmd.loader_process_id, hmd.loader_event_channel, HASP_MPX_DOWN, code);

014050  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014051  aa  7 00022 3521 00	epp2 	pr7|18		hmd.loader_process_id
014052  aa  6 02350 2521 00	spri2	pr6|1256
014053  aa  7 00024 3521 00	epp2 	pr7|20		hmd.loader_event_channel
014054  aa  6 02352 2521 00	spri2	pr6|1258
014055  aa   764051 3520 04	epp2 	-6103,ic		000126 = 000000000000
014056  aa  6 02354 2521 00	spri2	pr6|1260
014057  aa  6 00101 3521 00	epp2 	pr6|65		code
014060  aa  6 02356 2521 00	spri2	pr6|1262
014061  aa  6 02346 6211 00	eax1 	pr6|1254
014062  aa   020000 4310 07	fld  	8192,dl
014063  aa  6 00044 3701 20	epp4 	pr6|36,*
014064  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
014065  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3338
	     end;

						STATEMENT 1 ON LINE 3339
	     return;

014066  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3342
LINE_STATUS (2):					/* BAD BLOCK -- we sent badly formatted block */
	     call syserr (LOG_AND_PRINT,
		        "hasp_mpx (line ^a): Bad block line status from FNP; line will be hungup.", hmd.name);

014067  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
014070  aa   764234 00 0110	desc9a	-5988,72		000323 = 150141163160
014071  aa  6 02360 00 0110	desc9a	pr6|1264,72
014072  aa   764071 3520 04	epp2 	-6087,ic		000163 = 000000000000
014073  aa  6 02404 2521 00	spri2	pr6|1284
014074  aa  6 02360 3521 00	epp2 	pr6|1264
014075  aa  6 02406 2521 00	spri2	pr6|1286
014076  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
014077  aa  6 02410 2521 00	spri2	pr6|1288
014100  aa   764075 3520 04	epp2 	-6083,ic		000175 = 404000000021
014101  aa  6 02412 2521 00	spri2	pr6|1290
014102  aa   764033 3520 04	epp2 	-6117,ic		000135 = 524000000110
014103  aa  6 02414 2521 00	spri2	pr6|1292
014104  aa   764050 3520 04	epp2 	-6104,ic		000154 = 526000000040
014105  aa  6 02416 2521 00	spri2	pr6|1294
014106  aa  6 02402 6211 00	eax1 	pr6|1282
014107  aa   014000 4310 07	fld  	6144,dl
014110  aa  6 00044 3701 20	epp4 	pr6|36,*
014111  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
014112  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3345
	     call channel_manager$control (hmd.devx, "hangup", null (), code);

014113  aa   764071 2370 04	ldaq 	-6087,ic		000204 = 150141156147 165160000000
014114  aa  6 02420 7571 00	staq 	pr6|1296
014115  aa   764075 3734 24	epp7 	-6083,ic*
014116  aa  6 02422 6535 00	spri7	pr6|1298
014117  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
014120  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
014121  aa  6 02362 2521 00	spri2	pr6|1266
014122  aa  6 02420 3521 00	epp2 	pr6|1296
014123  aa  6 02364 2521 00	spri2	pr6|1268
014124  aa  6 02422 3521 00	epp2 	pr6|1298
014125  aa  6 02366 2521 00	spri2	pr6|1270
014126  aa  6 00101 3521 00	epp2 	pr6|65		code
014127  aa  6 02370 2521 00	spri2	pr6|1272
014130  aa   764045 3520 04	epp2 	-6107,ic		000175 = 404000000021
014131  aa  6 02372 2521 00	spri2	pr6|1274
014132  aa   764021 3520 04	epp2 	-6127,ic		000153 = 524000000006
014133  aa  6 02374 2521 00	spri2	pr6|1276
014134  aa   764043 3520 04	epp2 	-6109,ic		000177 = 464000000000
014135  aa  6 02376 2521 00	spri2	pr6|1278
014136  aa   764035 3520 04	epp2 	-6115,ic		000173 = 404000000043
014137  aa  6 02400 2521 00	spri2	pr6|1280
014140  aa  6 02360 6211 00	eax1 	pr6|1264
014141  aa   020000 4310 07	fld  	8192,dl
014142  aa  6 00044 3701 20	epp4 	pr6|36,*
014143  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
014144  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3346
	     return;

014145  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3349
LINE_STATUS (4):					/* TOO MANY NAKS -- line has gone bad */
	     call syserr (LOG_AND_PRINT, "hasp_mpx (line ^a): Too many NAKS; line will be hungup.", hmd.name);

014146  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
014147  aa   764116 00 0070	desc9a	-6066,56		000264 = 150141163160
014150  aa  6 02402 00 0070	desc9a	pr6|1282,56
014151  aa   764012 3520 04	epp2 	-6134,ic		000163 = 000000000000
014152  aa  6 02362 2521 00	spri2	pr6|1266
014153  aa  6 02402 3521 00	epp2 	pr6|1282
014154  aa  6 02364 2521 00	spri2	pr6|1268
014155  aa  6 00136 3521 20	epp2 	pr6|94,*		hmd.name
014156  aa  6 02366 2521 00	spri2	pr6|1270
014157  aa   764016 3520 04	epp2 	-6130,ic		000175 = 404000000021
014160  aa  6 02370 2521 00	spri2	pr6|1272
014161  aa   763753 3520 04	epp2 	-6165,ic		000134 = 524000000067
014162  aa  6 02372 2521 00	spri2	pr6|1274
014163  aa   763771 3520 04	epp2 	-6151,ic		000154 = 526000000040
014164  aa  6 02374 2521 00	spri2	pr6|1276
014165  aa  6 02360 6211 00	eax1 	pr6|1264
014166  aa   014000 4310 07	fld  	6144,dl
014167  aa  6 00044 3701 20	epp4 	pr6|36,*
014170  la  4 00066 3521 20	epp2 	pr4|54,*		syserr
014171  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3351
	     call channel_manager$control (hmd.devx, "hangup", null (), code);

014172  aa   764012 2370 04	ldaq 	-6134,ic		000204 = 150141156147 165160000000
014173  aa  6 02422 7571 00	staq 	pr6|1298
014174  aa   764016 3734 24	epp7 	-6130,ic*
014175  aa  6 02420 6535 00	spri7	pr6|1296
014176  aa  6 00136 3715 20	epp5 	pr6|94,*		hmd_ptr
014177  aa  5 00010 3521 00	epp2 	pr5|8		hmd.devx
014200  aa  6 02362 2521 00	spri2	pr6|1266
014201  aa  6 02422 3521 00	epp2 	pr6|1298
014202  aa  6 02364 2521 00	spri2	pr6|1268
014203  aa  6 02420 3521 00	epp2 	pr6|1296
014204  aa  6 02366 2521 00	spri2	pr6|1270
014205  aa  6 00101 3521 00	epp2 	pr6|65		code
014206  aa  6 02370 2521 00	spri2	pr6|1272
014207  aa   763766 3520 04	epp2 	-6154,ic		000175 = 404000000021
014210  aa  6 02372 2521 00	spri2	pr6|1274
014211  aa   763742 3520 04	epp2 	-6174,ic		000153 = 524000000006
014212  aa  6 02374 2521 00	spri2	pr6|1276
014213  aa   763764 3520 04	epp2 	-6156,ic		000177 = 464000000000
014214  aa  6 02376 2521 00	spri2	pr6|1278
014215  aa   763756 3520 04	epp2 	-6162,ic		000173 = 404000000043
014216  aa  6 02400 2521 00	spri2	pr6|1280
014217  aa  6 02360 6211 00	eax1 	pr6|1264
014220  aa   020000 4310 07	fld  	8192,dl
014221  aa  6 00044 3701 20	epp4 	pr6|36,*
014222  la  4 00076 3521 20	epp2 	pr4|62,*		channel_manager$control
014223  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3352
	     return;

014224  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3355
LINE_STATUS (6):					/* WRITE COMPLETE -- indicates a SIGNON record was sent OK */
	     if hmd.minor_state ^= HMD_WAIT_SIGNON_RESPONSE then
		return;

014225  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014226  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
014227  aa   000002 1160 07	cmpq 	2,dl
014230  aa   000002 6000 04	tze  	2,ic		014232
014231  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3358
	     if hmd.signon_data_ptr ^= null () then do;

014232  aa  7 00060 2371 00	ldaq 	pr7|48		hmd.signon_data_ptr
014233  aa   763757 6770 04	eraq 	-6161,ic		000212 = 077777000043 000001000000
014234  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
014235  aa   000036 6000 04	tze  	30,ic		014273
						STATEMENT 1 ON LINE 3359
		hsd_ptr = hmd.signon_data_ptr;

014236  aa  7 00060 3715 20	epp5 	pr7|48,*		hmd.signon_data_ptr
014237  aa  6 00142 6515 00	spri5	pr6|98		hsd_ptr
						STATEMENT 1 ON LINE 3360
		call pxss$ring_0_wakeup (hmd_signon_data.processid, hmd_signon_data.event_channel, HASP_SIGNON_OK,
				     code);

014240  aa  5 00000 3521 00	epp2 	pr5|0		hmd_signon_data.processid
014241  aa  6 02350 2521 00	spri2	pr6|1256
014242  aa  5 00002 3521 00	epp2 	pr5|2		hmd_signon_data.event_channel
014243  aa  6 02352 2521 00	spri2	pr6|1258
014244  aa   763650 3520 04	epp2 	-6232,ic		000114 = 000000000000
014245  aa  6 02354 2521 00	spri2	pr6|1260
014246  aa  6 00101 3521 00	epp2 	pr6|65		code
014247  aa  6 02356 2521 00	spri2	pr6|1262
014250  aa  6 02346 6211 00	eax1 	pr6|1254
014251  aa   020000 4310 07	fld  	8192,dl
014252  aa  6 00044 3701 20	epp4 	pr6|36,*
014253  la  4 00064 3521 20	epp2 	pr4|52,*		pxss$ring_0_wakeup
014254  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3362
		call tty_space_man$free_space (currentsize (hmd_signon_data), hsd_ptr);

014255  aa   000030 2360 07	ldq  	24,dl
014256  aa  6 02345 7561 00	stq  	pr6|1253
014257  aa  6 02345 3521 00	epp2 	pr6|1253
014260  aa  6 02350 2521 00	spri2	pr6|1256
014261  aa  6 00142 3521 00	epp2 	pr6|98		hsd_ptr
014262  aa  6 02352 2521 00	spri2	pr6|1258
014263  aa  6 02346 6211 00	eax1 	pr6|1254
014264  aa   010000 4310 07	fld  	4096,dl
014265  aa  6 00044 3701 20	epp4 	pr6|36,*
014266  la  4 00106 3521 20	epp2 	pr4|70,*		tty_space_man$free_space
014267  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3363
		hmd.signon_data_ptr = null ();

014270  aa   763722 2370 04	ldaq 	-6190,ic		000212 = 077777000043 000001000000
014271  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014272  aa  7 00060 7571 00	staq 	pr7|48		hmd.signon_data_ptr
						STATEMENT 1 ON LINE 3364
	     end;

						STATEMENT 1 ON LINE 3365
	     hmd.minor_state = HMD_NORMAL;

014273  aa   000003 2360 07	ldq  	3,dl
014274  aa  7 00031 7561 00	stq  	pr7|25		hmd.minor_state
						STATEMENT 1 ON LINE 3366
	     if (hmd.state = HMD_STARTED) then
		do idx = 1 to hmd.n_subchannels;

014275  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
014276  aa   000004 1160 07	cmpq 	4,dl
014277  aa   000022 6010 04	tnz  	18,ic		014321
014300  aa  7 00113 2361 00	ldq  	pr7|75		hmd.n_subchannels
014301  aa  6 01050 7561 00	stq  	pr6|552
014302  aa   000001 2360 07	ldq  	1,dl
014303  aa  6 00134 7561 00	stq  	pr6|92		idx
014304  aa  6 00134 2361 00	ldq  	pr6|92		idx
014305  aa  6 01050 1161 00	cmpq 	pr6|552
014306  aa   000013 6054 04	tpnz 	11,ic		014321
						STATEMENT 1 ON LINE 3368
		     hste_ptr = addr (hmd.subchannels (idx));

014307  aa   000050 4020 07	mpy  	40,dl
014310  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014311  aa  7 00044 3735 06	epp7 	pr7|36,ql		hmd.subchannels
014312  aa  6 00140 6535 00	spri7	pr6|96		hste_ptr
						STATEMENT 1 ON LINE 3369
		     if hste.state = HSTE_LISTENING then
			call signal_dialup ();

014313  aa  7 00012 2361 00	ldq  	pr7|10		hste.state
014314  aa   000002 1160 07	cmpq 	2,dl
014315  aa   000002 6010 04	tnz  	2,ic		014317
014316  aa   766505 6700 04	tsp4 	-4795,ic		003023
						STATEMENT 1 ON LINE 3371
		end;

014317  aa  6 00134 0541 00	aos  	pr6|92		idx
014320  aa   777764 7100 04	tra  	-12,ic		014304
						STATEMENT 1 ON LINE 3372
	     call interrupt_subchannels_with_output ();

014321  aa   770356 6700 04	tsp4 	-3858,ic		004677
						STATEMENT 1 ON LINE 3373
	     return;

014322  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3376
LINE_STATUS (13):					/* HASP INIT COMPLETE -- HASP handshake done; line is up */
	     if hmd.state = HMD_LOADING then
		call load_mpx ();

014323  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014324  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
014325  aa   000002 1160 07	cmpq 	2,dl
014326  aa   000002 6010 04	tnz  	2,ic		014330
014327  aa   767005 6700 04	tsp4 	-4603,ic		003334
						STATEMENT 1 ON LINE 3379
	     return;

014330  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3382
LINE_STATUS (14):					/* HASP FOREIGN READY -- other side reset its wait-a-bit */
	     hmd.suspend_all_output = "0"b;

014331  aa   001423 2350 04	lda  	787,ic		015754 = 377777777777
014332  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014333  aa  7 00070 3551 00	ansa 	pr7|56		hmd.suspend_all_output
						STATEMENT 1 ON LINE 3384
	     if hmd.state >= HMD_LOADED then		/* it's OK to send output blocks ... */
		if hmd.minor_state = HMD_REPROCESS then
		     call process_loopback_records ();

014334  aa  7 00030 2361 00	ldq  	pr7|24		hmd.state
014335  aa   000003 1160 07	cmpq 	3,dl
014336  aa   000007 6040 04	tmi  	7,ic		014345
014337  aa  7 00031 2361 00	ldq  	pr7|25		hmd.minor_state
014340  aa   000006 1160 07	cmpq 	6,dl
014341  aa   000003 6010 04	tnz  	3,ic		014344
014342  aa   773044 6700 04	tsp4 	-2524,ic		007406
014343  aa   000002 7100 04	tra  	2,ic		014345
						STATEMENT 1 ON LINE 3387
		else call process_output_block ();

014344  aa   774234 6700 04	tsp4 	-1892,ic		010600
						STATEMENT 1 ON LINE 3388
	     return;

014345  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3390
LINE_STATUS (3):					/* REVERSE INTERRUPT -- ignored */
LINE_STATUS (5):					/* FNP WRITE STATUS -- ignored */
LINE_STATUS (7):  LINE_STATUS (8):  LINE_STATUS (9):	/* IBM 3270 line status codes -- ignored */
LINE_STATUS (10):  LINE_STATUS (11): LINE_STATUS (12):
	     return;

014346  aa  6 01042 6101 00	rtcd 	pr6|546
						STATEMENT 1 ON LINE 3396
	end process_line_status;

  END PROCEDURE process_line_status
BEGIN PROCEDURE process_space_available
ENTRY TO process_space_available                            STATEMENT 1 ON LINE 3401
process_space_available:
	procedure ();

014347  aa  6 01052 6501 00	spri4	pr6|554
						STATEMENT 1 ON LINE 3404
	     if hmd.retry_transmit_output then do;

014350  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014351  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_transmit_output
014352  aa   002000 3150 03	cana 	1024,du
014353  aa   000007 6000 04	tze  	7,ic		014362
						STATEMENT 1 ON LINE 3405
		call transmit_output_block ();

014354  aa   777306 6700 04	tsp4 	-314,ic		013662
						STATEMENT 1 ON LINE 3406
		if hmd.retry_transmit_output then return;

014355  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014356  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_transmit_output
014357  aa   002000 3150 03	cana 	1024,du
014360  aa   000002 6000 04	tze  	2,ic		014362
014361  aa  6 01052 6101 00	rtcd 	pr6|554
						STATEMENT 1 ON LINE 3407
	     end;

						STATEMENT 1 ON LINE 3409
	     if hmd.retry_process_loopback_records then	/* wasn't enough room to process loopbacked data */
		call process_loopback_records ();

014362  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_process_loopback_records
014363  aa   000400 3150 03	cana 	256,du
014364  aa   000003 6000 04	tze  	3,ic		014367
014365  aa   773021 6700 04	tsp4 	-2543,ic		007406
014366  aa   000005 7100 04	tra  	5,ic		014373
						STATEMENT 1 ON LINE 3412
	     else if hmd.retry_process_output then	/* wasn't enough room to finish an output block */
		call process_output_block ();

014367  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_process_output
014370  aa   001000 3150 03	cana 	512,du
014371  aa   000002 6000 04	tze  	2,ic		014373
014372  aa   774206 6700 04	tsp4 	-1914,ic		010600
						STATEMENT 1 ON LINE 3415
	     if hmd.retry_process_input then		/* couldn't split up input block(s) */
		call process_input_records ();

014373  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
014374  aa  7 00070 2351 00	lda  	pr7|56		hmd.retry_process_input
014375  aa   000200 3150 03	cana 	128,du
014376  aa   000002 6000 04	tze  	2,ic		014400
014377  aa   772345 6700 04	tsp4 	-2843,ic		006744
						STATEMENT 1 ON LINE 3418
	     call interrupt_subchannels_with_output ();

014400  aa   770277 6700 04	tsp4 	-3905,ic		004677
						STATEMENT 1 ON LINE 3420
	     return;

014401  aa  6 01052 6101 00	rtcd 	pr6|554
						STATEMENT 1 ON LINE 3422
	end process_space_available;

  END PROCEDURE process_space_available
BEGIN PROCEDURE find_next_record
ENTRY TO find_next_record                                   STATEMENT 1 ON LINE 3426
find_next_record:
	procedure (P_start_bufferp, P_start_record_idx, P_rcb_included, P_count_dles,
		 P_end_bufferp, P_end_record_idx, P_record_tally, P_dle_count);

014402  aa  6 01060 6501 00	spri4	pr6|560
014403  aa  6 01062 2521 00	spri2	pr6|562
						STATEMENT 1 ON LINE 3452
	     P_end_bufferp = null ();

014404  aa   763606 2370 04	ldaq 	-6266,ic		000212 = 077777000043 000001000000
014405  aa  2 00012 7571 20	staq 	pr2|10,*		P_end_bufferp
						STATEMENT 1 ON LINE 3453
	     P_end_record_idx, P_record_tally, P_dle_count = 0;

014406  aa  2 00014 4501 20	stz  	pr2|12,*		P_end_record_idx
014407  aa  2 00016 4501 20	stz  	pr2|14,*		P_record_tally
014410  aa  2 00020 4501 20	stz  	pr2|16,*		P_dle_count
						STATEMENT 1 ON LINE 3455
	     bufferp = P_start_bufferp;

014411  aa  2 00002 3735 20	epp7 	pr2|2,*		P_start_bufferp
014412  aa  7 00000 3735 20	epp7 	pr7|0,*		P_start_bufferp
014413  aa  6 01066 6535 00	spri7	pr6|566		bufferp
						STATEMENT 1 ON LINE 3456
	     record_idx = P_start_record_idx;

014414  aa  2 00004 2361 20	ldq  	pr2|4,*		P_start_record_idx
014415  aa  6 01072 7561 00	stq  	pr6|570		record_idx
						STATEMENT 1 ON LINE 3457
	     count_dles_sw = P_count_dles;

014416  aa  2 00010 2351 20	lda  	pr2|8,*		P_count_dles
014417  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
014420  aa  6 01076 7551 00	sta  	pr6|574		count_dles_sw
						STATEMENT 1 ON LINE 3459
	     record_tally, dle_count = 0;

014421  aa  6 01074 4501 00	stz  	pr6|572		record_tally
014422  aa  6 01075 4501 00	stz  	pr6|573		dle_count
						STATEMENT 1 ON LINE 3461
	     end_of_data_is_special = "0"b;

014423  aa  6 01077 4501 00	stz  	pr6|575		end_of_data_is_special
						STATEMENT 1 ON LINE 3467
	     if P_rcb_included then

		if (bufferp -> buffer.chars (record_idx) = HASP_EOB_RCB) then
		     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;

014424  aa  2 00006 2351 20	lda  	pr2|6,*		P_rcb_included
014425  aa   400000 3150 03	cana 	131072,du
014426  aa   000054 6000 04	tze  	44,ic		014502
014427  aa  6 01072 7271 00	lxl7 	pr6|570		record_idx
014430  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
014431  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
014432  aa   763474 00 0001	desc9a	-6340,1		000124 = 000000000000
014433  aa   000116 6000 04	tze  	78,ic		014551
						STATEMENT 1 ON LINE 3472
		else if (bufferp -> buffer.chars (record_idx) = HASP_GENERAL_CONTROL_RCB)
		then do;

014434  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
014435  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
014436  aa   763466 00 0001	desc9a	-6346,1		000122 = 360000000000
014437  aa   000036 6010 04	tnz  	30,ic		014475
						STATEMENT 1 ON LINE 3475
		     call advance_pointer (1);

014440  aa   000001 2360 07	ldq  	1,dl
014441  aa  6 02424 7561 00	stq  	pr6|1300
014442  aa   000720 3520 04	epp2 	464,ic		015362 = 000002000000
014443  aa   000121 6700 04	tsp4 	81,ic		014564
						STATEMENT 1 ON LINE 3476
		     end_of_data_is_special = "1"b;

014444  aa   400000 2350 03	lda  	131072,du
014445  aa  6 01077 7551 00	sta  	pr6|575		end_of_data_is_special
						STATEMENT 1 ON LINE 3477
		     do while ("1"b);

						STATEMENT 1 ON LINE 3478
			previous_bufferp = bufferp;

014446  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014447  aa  6 01070 6535 00	spri7	pr6|568		previous_bufferp
						STATEMENT 1 ON LINE 3479
			previous_record_idx = record_idx;

014450  aa  6 01072 2361 00	ldq  	pr6|570		record_idx
014451  aa  6 01073 7561 00	stq  	pr6|571		previous_record_idx
						STATEMENT 1 ON LINE 3480
			call advance_pointer (1);

014452  aa   000001 2360 07	ldq  	1,dl
014453  aa  6 02424 7561 00	stq  	pr6|1300
014454  aa   000706 3520 04	epp2 	454,ic		015362 = 000002000000
014455  aa   000107 6700 04	tsp4 	71,ic		014564
						STATEMENT 1 ON LINE 3481
			if (bufferp -> buffer.chars (record_idx) = NUL) then do;

014456  aa  6 01072 7271 00	lxl7 	pr6|570		record_idx
014457  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014460  aa  040 004 106 517	cmpc 	(pr,x7),(ic),fill(040)
014461  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
014462  aa   763503 00 0001	desc9a	-6333,1		000163 = 000000000000
014463  aa   777763 6010 04	tnz  	-13,ic		014446
						STATEMENT 1 ON LINE 3482
END_OF_GENERAL_CONTROL_RECORD_SCAN: bufferp = previous_bufferp;

014464  aa  6 01070 3735 20	epp7 	pr6|568,*		previous_bufferp
014465  aa  6 01066 6535 00	spri7	pr6|566		bufferp
						STATEMENT 1 ON LINE 3483
			     record_idx = previous_record_idx;

014466  aa  6 01073 2361 00	ldq  	pr6|571		previous_record_idx
014467  aa  6 01072 7561 00	stq  	pr6|570		record_idx
						STATEMENT 1 ON LINE 3484
			     record_tally = record_tally - 1;

014470  aa   000001 3360 07	lcq  	1,dl
014471  aa  6 01074 0561 00	asq  	pr6|572		record_tally
						STATEMENT 1 ON LINE 3485
			     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;

014472  aa   000057 7100 04	tra  	47,ic		014551
						STATEMENT 1 ON LINE 3486
			end;

						STATEMENT 1 ON LINE 3487
		     end;

014473  aa   777753 7100 04	tra  	-21,ic		014446
						STATEMENT 1 ON LINE 3488
		end;

014474  aa   000012 7100 04	tra  	10,ic		014506
						STATEMENT 1 ON LINE 3490
		else call advance_pointer (2);

014475  aa   000002 2360 07	ldq  	2,dl
014476  aa  6 02424 7561 00	stq  	pr6|1300
014477  aa   000663 3520 04	epp2 	435,ic		015362 = 000002000000
014500  aa   000064 6700 04	tsp4 	52,ic		014564
014501  aa   000005 7100 04	tra  	5,ic		014506
						STATEMENT 1 ON LINE 3492
	     else call advance_pointer (1);

014502  aa   000001 2360 07	ldq  	1,dl
014503  aa  6 02424 7561 00	stq  	pr6|1300
014504  aa   000656 3520 04	epp2 	430,ic		015362 = 000002000000
014505  aa   000057 6700 04	tsp4 	47,ic		014564
						STATEMENT 1 ON LINE 3497
	     do while ("1"b);

						STATEMENT 1 ON LINE 3499
		scb_char = bufferp -> buffer.chars (record_idx);

014506  aa  6 01100 4501 00	stz  	pr6|576		scb_char
014507  aa  6 01072 7271 00	lxl7 	pr6|570		record_idx
014510  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014511  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
014512  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
014513  aa  6 01100 00 0001	desc9a	pr6|576,1		scb_char
						STATEMENT 1 ON LINE 3501
		if scb_char = HASP_EOR_SCB then	/* have reached the end-of-record */
		     go to SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD;

014514  aa  6 01100 2351 00	lda  	pr6|576		scb_char
014515  aa   763407 1150 04	cmpa 	-6393,ic		000124 = 000000000000
014516  aa   000033 6000 04	tze  	27,ic		014551
						STATEMENT 1 ON LINE 3504
		else 				/* an ordinary SCB */
		if scb.not_compressed then
		     call advance_pointer (not_compressed_scb.count + 1);

014517  aa  6 01100 3715 00	epp5 	pr6|576		scb_char
014520  aa  6 02426 6515 00	spri5	pr6|1302
014521  aa  5 00000 2351 00	lda  	pr5|0		scb.not_compressed
014522  aa   100000 3150 03	cana 	32768,du
014523  aa   000011 6000 04	tze  	9,ic		014534
014524  aa  5 00000 2351 00	lda  	pr5|0		not_compressed_scb.count
014525  aa   000003 7350 00	als  	3
014526  aa   000102 7730 00	lrl  	66
014527  aa   000001 0760 07	adq  	1,dl
014530  aa  6 02425 7561 00	stq  	pr6|1301
014531  aa   000625 3520 04	epp2 	405,ic		015356 = 000002000000
014532  aa   000032 6700 04	tsp4 	26,ic		014564
014533  aa   777753 7100 04	tra  	-21,ic		014506
						STATEMENT 1 ON LINE 3508
		else if compressed_scb.not_blank then
		     call advance_pointer (2);

014534  aa  5 00000 2351 00	lda  	pr5|0		compressed_scb.not_blank
014535  aa   040000 3150 03	cana 	16384,du
014536  aa   000006 6000 04	tze  	6,ic		014544
014537  aa   000002 2360 07	ldq  	2,dl
014540  aa  6 02425 7561 00	stq  	pr6|1301
014541  aa   000615 3520 04	epp2 	397,ic		015356 = 000002000000
014542  aa   000022 6700 04	tsp4 	18,ic		014564
014543  aa   777743 7100 04	tra  	-29,ic		014506
						STATEMENT 1 ON LINE 3510
		else call advance_pointer (1);

014544  aa   000001 2360 07	ldq  	1,dl
014545  aa  6 02425 7561 00	stq  	pr6|1301
014546  aa   000610 3520 04	epp2 	392,ic		015356 = 000002000000
014547  aa   000015 6700 04	tsp4 	13,ic		014564
						STATEMENT 1 ON LINE 3511
	     end;

014550  aa   777736 7100 04	tra  	-34,ic		014506
						STATEMENT 1 ON LINE 3517
SUCCESSFUL_RETURN_FROM_FIND_NEXT_RECORD:
	     P_end_bufferp = bufferp;

014551  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014552  aa  6 01062 3715 20	epp5 	pr6|562,*
014553  aa  5 00012 6535 20	spri7	pr5|10,*		P_end_bufferp
						STATEMENT 1 ON LINE 3519
	     P_end_record_idx = record_idx;

014554  aa  6 01072 2361 00	ldq  	pr6|570		record_idx
014555  aa  5 00014 7561 20	stq  	pr5|12,*		P_end_record_idx
						STATEMENT 1 ON LINE 3520
	     P_record_tally = record_tally + 1;

014556  aa  6 01074 2361 00	ldq  	pr6|572		record_tally
014557  aa   000001 0760 07	adq  	1,dl
014560  aa  5 00016 7561 20	stq  	pr5|14,*		P_record_tally
						STATEMENT 1 ON LINE 3521
	     P_dle_count = dle_count;

014561  aa  6 01075 2361 00	ldq  	pr6|573		dle_count
014562  aa  5 00020 7561 20	stq  	pr5|16,*		P_dle_count
						STATEMENT 1 ON LINE 3523
RETURN_FROM_FIND_NEXT_RECORD:
	     return;

014563  aa  6 01060 6101 00	rtcd 	pr6|560
						STATEMENT 1 ON LINE 3607
	end find_next_record;

BEGIN PROCEDURE advance_pointer
ENTRY TO advance_pointer                                    STATEMENT 1 ON LINE 3528
advance_pointer:
	     procedure (P_n_characters);

014564  aa  6 01102 6501 00	spri4	pr6|578
014565  aa  6 01104 2521 00	spri2	pr6|580
						STATEMENT 1 ON LINE 3536
		record_tally = record_tally + P_n_characters;

014566  aa  2 00002 2361 20	ldq  	pr2|2,*		P_n_characters
014567  aa  6 01074 0561 00	asq  	pr6|572		record_tally
						STATEMENT 1 ON LINE 3539
		amount_left = P_n_characters;

014570  aa  6 01110 7561 00	stq  	pr6|584		amount_left
						STATEMENT 1 ON LINE 3541
		do while (amount_left > 0);

014571  aa   000000 0110 03	nop  	0,du
014572  aa  6 01110 2361 00	ldq  	pr6|584		amount_left
014573  aa   000051 6044 04	tmoz 	41,ic		014644
						STATEMENT 1 ON LINE 3543
		     amount_in_buffer = (bufferp -> buffer.tally) - record_idx;

014574  aa  6 01066 2361 20	ldq  	pr6|566,*		buffer.tally
014575  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
014576  aa  6 01072 1761 00	sbq  	pr6|570		record_idx
014577  aa  6 01111 7561 00	stq  	pr6|585		amount_in_buffer
						STATEMENT 1 ON LINE 3545
		     if amount_in_buffer > amount_left
		     then do;

014600  aa  6 01110 1161 00	cmpq 	pr6|584		amount_left
014601  aa   000011 6044 04	tmoz 	9,ic		014612
						STATEMENT 1 ON LINE 3547
			dle_count = dle_count + count_dles (amount_left);

014602  aa   000546 3520 04	epp2 	358,ic		015350 = 000004000000
014603  aa   000042 6700 04	tsp4 	34,ic		014645
014604  aa  6 02430 2361 00	ldq  	pr6|1304
014605  aa  6 01075 0561 00	asq  	pr6|573		dle_count
						STATEMENT 1 ON LINE 3548
			record_idx = record_idx + amount_left;

014606  aa  6 01110 2361 00	ldq  	pr6|584		amount_left
014607  aa  6 01072 0561 00	asq  	pr6|570		record_idx
						STATEMENT 1 ON LINE 3549
			amount_left = 0;

014610  aa  6 01110 4501 00	stz  	pr6|584		amount_left
						STATEMENT 1 ON LINE 3550
		     end;

014611  aa   777761 7100 04	tra  	-15,ic		014572
						STATEMENT 1 ON LINE 3552
		     else do;

						STATEMENT 1 ON LINE 3553
			previously_scanned_bufferp = bufferp;

014612  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014613  aa  6 00130 6535 00	spri7	pr6|88		previously_scanned_bufferp
						STATEMENT 1 ON LINE 3554
			dle_count = dle_count + count_dles (amount_in_buffer);

014614  aa   000526 3520 04	epp2 	342,ic		015342 = 000004000000
014615  aa   000030 6700 04	tsp4 	24,ic		014645
014616  aa  6 02430 2361 00	ldq  	pr6|1304
014617  aa  6 01075 0561 00	asq  	pr6|573		dle_count
						STATEMENT 1 ON LINE 3555
			amount_left = amount_left - amount_in_buffer;

014620  aa  6 01111 3361 00	lcq  	pr6|585		amount_in_buffer
014621  aa  6 01110 0561 00	asq  	pr6|584		amount_left
						STATEMENT 1 ON LINE 3556
			if (bufferp -> buffer.next) = 0 then	/* no next buffer:  no complete record */
			     if end_of_data_is_special then
				go to END_OF_GENERAL_CONTROL_RECORD_SCAN;

014622  aa  6 01066 2351 20	lda  	pr6|566,*		buffer.next
014623  aa   000066 7730 00	lrl  	54
014624  aa  6 02430 7561 00	stq  	pr6|1304		buffer.next
014625  aa   000012 6010 04	tnz  	10,ic		014637
014626  aa  6 01077 2351 00	lda  	pr6|575		end_of_data_is_special
014627  aa   777635 6010 04	tnz  	-99,ic		014464
						STATEMENT 1 ON LINE 3559
			     else do;

						STATEMENT 1 ON LINE 3560
				P_record_tally = record_tally - amount_left;

014630  aa  6 01074 2361 00	ldq  	pr6|572		record_tally
014631  aa  6 01110 1761 00	sbq  	pr6|584		amount_left
014632  aa  6 01062 3735 20	epp7 	pr6|562,*
014633  aa  7 00016 7561 20	stq  	pr7|14,*		P_record_tally
						STATEMENT 1 ON LINE 3561
				P_dle_count = dle_count;

014634  aa  6 01075 2361 00	ldq  	pr6|573		dle_count
014635  aa  7 00020 7561 20	stq  	pr7|16,*		P_dle_count
						STATEMENT 1 ON LINE 3562
				go to RETURN_FROM_FIND_NEXT_RECORD;

014636  aa   777725 7100 04	tra  	-43,ic		014563
						STATEMENT 1 ON LINE 3563
			     end;

						STATEMENT 1 ON LINE 3564
			bufferp = pointer (ttybp, bufferp -> buffer.next);

014637  aa  6 00122 3521 20	epp2 	pr6|82,*		ttybp
014640  aa   000000 3120 06	eawp2	0,ql
014641  aa  6 01066 2521 00	spri2	pr6|566		bufferp
						STATEMENT 1 ON LINE 3565
			record_idx = 0;

014642  aa  6 01072 4501 00	stz  	pr6|570		record_idx
						STATEMENT 1 ON LINE 3566
		     end;

						STATEMENT 1 ON LINE 3567
		end;

014643  aa   777727 7100 04	tra  	-41,ic		014572
						STATEMENT 1 ON LINE 3569
		return;

014644  aa  6 01102 6101 00	rtcd 	pr6|578
						STATEMENT 1 ON LINE 3605
	     end advance_pointer;

BEGIN PROCEDURE count_dles
ENTRY TO count_dles                                         STATEMENT 1 ON LINE 3575
count_dles:	procedure (P_n_characters) returns (fixed binary);

014645  aa  6 01112 6501 00	spri4	pr6|586
014646  aa  6 01114 2521 00	spri2	pr6|588
						STATEMENT 1 ON LINE 3583
		     if ^count_dles_sw then		/* caller doesn't need a count */
			return (0);

014647  aa  6 01076 2351 00	lda  	pr6|574		count_dles_sw
014650  aa   000003 6010 04	tnz  	3,ic		014653
014651  aa  2 00004 4501 20	stz  	pr2|4,*
014652  aa  6 01112 6101 00	rtcd 	pr6|586
						STATEMENT 1 ON LINE 3586
		     n_characters = P_n_characters;

014653  aa  2 00002 2361 20	ldq  	pr2|2,*		P_n_characters
014654  aa  6 01120 7561 00	stq  	pr6|592		n_characters
						STATEMENT 1 ON LINE 3588
		     count = 0;

014655  aa  6 01121 4501 00	stz  	pr6|593		count
						STATEMENT 1 ON LINE 3590
		     start = 1;

014656  aa   000001 2360 07	ldq  	1,dl
014657  aa  6 01122 7561 00	stq  	pr6|594		start
						STATEMENT 1 ON LINE 3591
		     idx = index (text, DLE);

014660  aa  6 01072 7271 00	lxl7 	pr6|570		record_idx
014661  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014662  aa  6 01120 7261 00	lxl6 	pr6|592		n_characters
014663  aa  000 003 124 557	scm  	(pr,rl,x7),(du),mask(000)
014664  aa  7 00001 00 0016	desc9a	pr7|1,x6		text
014665  aa   020000 00 0001	desc9a	8192,1
014666  aa  6 00056 0001 00	arg  	pr6|46
014667  aa  6 00056 2361 00	ldq  	pr6|46
014670  aa   000002 6070 04	ttf  	2,ic		014672
014671  aa   000001 3360 07	lcq  	1,dl
014672  aa   000001 0760 07	adq  	1,dl
014673  aa  6 01123 7561 00	stq  	pr6|595		idx
						STATEMENT 1 ON LINE 3593
		     do while (idx ^= 0);

014674  aa  6 01123 2361 00	ldq  	pr6|595		idx
014675  aa   000033 6000 04	tze  	27,ic		014730
						STATEMENT 1 ON LINE 3594
			count = count + 1;

014676  aa  6 01121 0541 00	aos  	pr6|593		count
						STATEMENT 1 ON LINE 3595
			start = start + idx;

014677  aa  6 01122 0561 00	asq  	pr6|594		start
						STATEMENT 1 ON LINE 3596
			if start > n_characters then
			     idx = 0;

014700  aa  6 01122 2361 00	ldq  	pr6|594		start
014701  aa  6 01120 1161 00	cmpq 	pr6|592		n_characters
014702  aa   000003 6044 04	tmoz 	3,ic		014705
014703  aa  6 01123 4501 00	stz  	pr6|595		idx
014704  aa   777770 7100 04	tra  	-8,ic		014674
						STATEMENT 1 ON LINE 3598
			else idx = index (substr (text, start), DLE);

014705  aa   000001 1760 07	sbq  	1,dl
014706  aa  6 02431 7561 00	stq  	pr6|1305
014707  aa  6 01120 2361 00	ldq  	pr6|592		n_characters
014710  aa  6 02431 1761 00	sbq  	pr6|1305
014711  aa  6 02432 7561 00	stq  	pr6|1306
014712  aa  6 01072 2361 00	ldq  	pr6|570		record_idx
014713  aa  6 02431 0761 00	adq  	pr6|1305
014714  aa  6 01066 3735 20	epp7 	pr6|566,*		bufferp
014715  aa  6 02432 2351 00	lda  	pr6|1306
014716  aa  000 003 124 546	scm  	(pr,rl,ql),(du),mask(000)
014717  aa  7 00001 00 0005	desc9a	pr7|1,al		text
014720  aa   020000 00 0001	desc9a	8192,1
014721  aa  6 00056 0001 00	arg  	pr6|46
014722  aa  6 00056 2361 00	ldq  	pr6|46
014723  aa   000002 6070 04	ttf  	2,ic		014725
014724  aa   000001 3360 07	lcq  	1,dl
014725  aa   000001 0760 07	adq  	1,dl
014726  aa  6 01123 7561 00	stq  	pr6|595		idx
						STATEMENT 1 ON LINE 3599
		     end;

014727  aa   777745 7100 04	tra  	-27,ic		014674
						STATEMENT 1 ON LINE 3601
		     return (count);

014730  aa  6 01121 2361 00	ldq  	pr6|593		count
014731  aa  6 01114 3735 20	epp7 	pr6|588,*
014732  aa  7 00004 7561 20	stq  	pr7|4,*
014733  aa  6 01112 6101 00	rtcd 	pr6|586
						STATEMENT 1 ON LINE 3603
		end count_dles;

  END PROCEDURE count_dles
  END PROCEDURE advance_pointer
  END PROCEDURE find_next_record
BEGIN PROCEDURE classify_record
ENTRY TO classify_record                                    STATEMENT 1 ON LINE 3611
classify_record:
	procedure (P_bufferp, P_rcb_idx) returns (fixed binary);

014734  aa  6 01124 6501 00	spri4	pr6|596
014735  aa  6 01126 2521 00	spri2	pr6|598
						STATEMENT 1 ON LINE 3629
	     bufferp = P_bufferp;

014736  aa  2 00002 3735 20	epp7 	pr2|2,*		P_bufferp
014737  aa  7 00000 3735 20	epp7 	pr7|0,*		P_bufferp
014740  aa  6 01132 6535 00	spri7	pr6|602		bufferp
						STATEMENT 1 ON LINE 3630
	     rcb_idx = P_rcb_idx;

014741  aa  2 00004 2361 20	ldq  	pr2|4,*		P_rcb_idx
014742  aa  6 01134 7561 00	stq  	pr6|604		rcb_idx
						STATEMENT 1 ON LINE 3632
	     if rcb_idx < bufferp -> buffer.tally then
		rcb_char = bufferp -> buffer.chars (rcb_idx);

014743  aa  7 00000 2361 00	ldq  	pr7|0		buffer.tally
014744  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
014745  aa  6 01134 1161 00	cmpq 	pr6|604		rcb_idx
014746  aa   000007 6044 04	tmoz 	7,ic		014755
014747  aa  6 01135 4501 00	stz  	pr6|605		rcb_char
014750  aa  6 01134 7271 00	lxl7 	pr6|604		rcb_idx
014751  aa  040 100 100 517	mlr  	(pr,x7),(pr),fill(040)
014752  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
014753  aa  6 01135 00 0001	desc9a	pr6|605,1		rcb_char
014754  aa   000016 7100 04	tra  	14,ic		014772
						STATEMENT 1 ON LINE 3634
	     else					/* RCB is in next block (blame move_record_to_output_block) */
	     if bufferp -> buffer.next = 0 then
		return (0);

014755  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
014756  aa   000066 7730 00	lrl  	54
014757  aa  6 02433 7561 00	stq  	pr6|1307		buffer.next
014760  aa   000003 6010 04	tnz  	3,ic		014763
014761  aa  2 00006 4501 20	stz  	pr2|6,*
014762  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3637
	     else do;

						STATEMENT 1 ON LINE 3638
		bufferp = pointer (ttybp, bufferp -> buffer.next);

014763  aa  6 00122 3515 20	epp1 	pr6|82,*		ttybp
014764  aa   000000 3114 06	eawp1	0,ql
014765  aa  6 01132 2515 00	spri1	pr6|602		bufferp
						STATEMENT 1 ON LINE 3639
		rcb_idx = 0;

014766  aa  6 01134 4501 00	stz  	pr6|604		rcb_idx
						STATEMENT 1 ON LINE 3640
		rcb_char = bufferp -> buffer.chars (0);

014767  aa  1 00001 2351 00	lda  	pr1|1		buffer.chars
014770  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
014771  aa  6 01135 7551 00	sta  	pr6|605		rcb_char
						STATEMENT 1 ON LINE 3641
	     end;

						STATEMENT 1 ON LINE 3643
	     if rcb_idx < (bufferp -> buffer.tally - 1) then
		srcb_char = bufferp -> buffer.chars (rcb_idx+1);

014772  aa  6 01132 2361 20	ldq  	pr6|602,*		buffer.tally
014773  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
014774  aa   000001 1760 07	sbq  	1,dl
014775  aa  6 01134 1161 00	cmpq 	pr6|604		rcb_idx
014776  aa   000010 6044 04	tmoz 	8,ic		015006
014777  aa  6 01136 4501 00	stz  	pr6|606		srcb_char
015000  aa  6 01134 2351 00	lda  	pr6|604		rcb_idx
015001  aa  6 01132 3735 20	epp7 	pr6|602,*		bufferp
015002  aa  040 100 100 505	mlr  	(pr,al),(pr),fill(040)
015003  aa  7 00001 20 0001	desc9a	pr7|1(1),1	buffer.chars
015004  aa  6 01136 00 0001	desc9a	pr6|606,1		srcb_char
015005  aa   000020 7100 04	tra  	16,ic		015025
						STATEMENT 1 ON LINE 3645
	     else					/* SRCB not in this block, check the next one */
	     if bufferp -> buffer.next = 0 then
		srcb_char = NUL;

015006  aa  6 01132 2351 20	lda  	pr6|602,*		buffer.next
015007  aa   000066 7730 00	lrl  	54
015010  aa  6 02433 7561 00	stq  	pr6|1307		buffer.next
015011  aa   000004 6010 04	tnz  	4,ic		015015
015012  aa   000000 2350 07	lda  	0,dl
015013  aa  6 01136 7551 00	sta  	pr6|606		srcb_char
015014  aa   000011 7100 04	tra  	9,ic		015025
						STATEMENT 1 ON LINE 3648
	     else do;

						STATEMENT 1 ON LINE 3649
		bufferp = pointer (ttybp, bufferp -> buffer.next);

015015  aa  6 00122 3515 20	epp1 	pr6|82,*		ttybp
015016  aa   000000 3114 06	eawp1	0,ql
015017  aa  6 01132 2515 00	spri1	pr6|602		bufferp
						STATEMENT 1 ON LINE 3650
		rcb_idx = -1;

015020  aa   000001 3360 07	lcq  	1,dl
015021  aa  6 01134 7561 00	stq  	pr6|604		rcb_idx
						STATEMENT 1 ON LINE 3651
		srcb_char = bufferp -> buffer.chars (0);

015022  aa  1 00001 2351 00	lda  	pr1|1		buffer.chars
015023  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
015024  aa  6 01136 7551 00	sta  	pr6|606		srcb_char
						STATEMENT 1 ON LINE 3652
	     end;

						STATEMENT 1 ON LINE 3654
	     if rcb_idx < (bufferp -> buffer.tally - 2) then
		first_scb_char = bufferp -> buffer.chars (rcb_idx+2);

015025  aa  6 01132 2361 20	ldq  	pr6|602,*		buffer.tally
015026  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
015027  aa   000002 1760 07	sbq  	2,dl
015030  aa  6 01134 1161 00	cmpq 	pr6|604		rcb_idx
015031  aa   000010 6044 04	tmoz 	8,ic		015041
015032  aa  6 01137 4501 00	stz  	pr6|607		first_scb_char
015033  aa  6 01134 2351 00	lda  	pr6|604		rcb_idx
015034  aa  6 01132 3735 20	epp7 	pr6|602,*		bufferp
015035  aa  040 100 100 505	mlr  	(pr,al),(pr),fill(040)
015036  aa  7 00001 40 0001	desc9a	pr7|1(2),1	buffer.chars
015037  aa  6 01137 00 0001	desc9a	pr6|607,1		first_scb_char
015040  aa   000015 7100 04	tra  	13,ic		015055
						STATEMENT 1 ON LINE 3656
	     else					/* first SCB not in this block, check the next one */
	     if bufferp -> buffer.next = 0 then
		first_scb_char = NUL;

015041  aa  6 01132 2351 20	lda  	pr6|602,*		buffer.next
015042  aa   000066 7730 00	lrl  	54
015043  aa  6 02433 7561 00	stq  	pr6|1307		buffer.next
015044  aa   000004 6010 04	tnz  	4,ic		015050
015045  aa   000000 2350 07	lda  	0,dl
015046  aa  6 01137 7551 00	sta  	pr6|607		first_scb_char
015047  aa   000006 7100 04	tra  	6,ic		015055
						STATEMENT 1 ON LINE 3659
	     else first_scb_char = pointer (ttybp, bufferp -> buffer.next) -> buffer.chars (0);

015050  aa  6 00122 3515 20	epp1 	pr6|82,*		ttybp
015051  aa   000000 3114 06	eawp1	0,ql
015052  aa  1 00001 2351 00	lda  	pr1|1		buffer.chars
015053  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
015054  aa  6 01137 7551 00	sta  	pr6|607		first_scb_char
						STATEMENT 1 ON LINE 3664
	     if rcb.not_eob then			/* not an end-of-block */

		if rcb.type = HASP_RCB_TYPE_CONTROL then     /* some form of control record */

		     if rcb.stream = HASP_RCB_STREAM_RTS then
			return (HASP_RTS_RECORD);

015055  aa  6 01135 3735 00	epp7 	pr6|605		rcb_char
015056  aa  6 02434 6535 00	spri7	pr6|1308
015057  aa  7 00000 2351 00	lda  	pr7|0		rcb.not_eob
015060  aa   200000 3150 03	cana 	65536,du
015061  aa   000060 6000 04	tze  	48,ic		015141
015062  aa  7 00000 2351 00	lda  	pr7|0		rcb.type
015063  aa   000005 7350 00	als  	5
015064  aa   000104 7730 00	lrl  	68
015065  aa   000040 6010 04	tnz  	32,ic		015125
015066  aa  7 00000 2351 00	lda  	pr7|0		rcb.stream
015067  aa   000002 7350 00	als  	2
015070  aa   000105 7730 00	lrl  	69
015071  aa  6 02433 7561 00	stq  	pr6|1307		rcb.stream
015072  aa   000001 1160 07	cmpq 	1,dl
015073  aa   000004 6010 04	tnz  	4,ic		015077
015074  aa   000004 2360 07	ldq  	4,dl
015075  aa  2 00006 7561 20	stq  	pr2|6,*
015076  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3671
		     else if rcb.stream = HASP_RCB_STREAM_RTS_ACK then
			return (HASP_RTS_ACK_RECORD);

015077  aa   000002 1160 07	cmpq 	2,dl
015100  aa   000004 6010 04	tnz  	4,ic		015104
015101  aa   000005 2360 07	ldq  	5,dl
015102  aa  2 00006 7561 20	stq  	pr2|6,*
015103  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3674
		     else if rcb.stream = HASP_RCB_STREAM_BAD_BCB then
			return (HASP_BAD_BCB_RECORD);

015104  aa   000006 1160 07	cmpq 	6,dl
015105  aa   000004 6010 04	tnz  	4,ic		015111
015106  aa   000006 2360 07	ldq  	6,dl
015107  aa  2 00006 7561 20	stq  	pr2|6,*
015110  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3677
		     else if rcb.stream = HASP_RCB_STREAM_CONTROL then
			if srcb_char = HASP_SIGNON_SRCB then
			     return (HASP_SIGNON_RECORD);

015111  aa   000007 1160 07	cmpq 	7,dl
015112  aa   000011 6010 04	tnz  	9,ic		015123
015113  aa  6 01136 2351 00	lda  	pr6|606		srcb_char
015114  aa   763003 1150 04	cmpa 	-6653,ic		000117 = 301000000000
015115  aa   000004 6010 04	tnz  	4,ic		015121
015116  aa   000003 2360 07	ldq  	3,dl
015117  aa  2 00006 7561 20	stq  	pr2|6,*
015120  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3680
			else return (0);

015121  aa  2 00006 4501 20	stz  	pr2|6,*
015122  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3681
		     else return (0);

015123  aa  2 00006 4501 20	stz  	pr2|6,*
015124  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3683
		else if (srcb_char = HASP_EOF_SRCB) & (first_scb_char = HASP_EOF_FIRST_SCB) then
			return (HASP_EOF_RECORD);

015125  aa  6 01136 2351 00	lda  	pr6|606		srcb_char
015126  aa   762770 1150 04	cmpa 	-6664,ic		000116 = 200000000000
015127  aa   000007 6010 04	tnz  	7,ic		015136
015130  aa  6 01137 2351 00	lda  	pr6|607		first_scb_char
015131  aa   762773 1150 04	cmpa 	-6661,ic		000124 = 000000000000
015132  aa   000004 6010 04	tnz  	4,ic		015136
015133  aa   000002 2360 07	ldq  	2,dl
015134  aa  2 00006 7561 20	stq  	pr2|6,*
015135  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3686
		else return (HASP_DATA_RECORD);

015136  aa   000007 2360 07	ldq  	7,dl
015137  aa  2 00006 7561 20	stq  	pr2|6,*
015140  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3688
	     else return (HASP_EOB_RECORD);

015141  aa   000001 2360 07	ldq  	1,dl
015142  aa  2 00006 7561 20	stq  	pr2|6,*
015143  aa  6 01124 6101 00	rtcd 	pr6|596
						STATEMENT 1 ON LINE 3690
	end classify_record;

  END PROCEDURE classify_record
BEGIN PROCEDURE empty_output_blockp
ENTRY TO empty_output_blockp                                STATEMENT 1 ON LINE 3694
empty_output_blockp:
	procedure () returns (bit (1) aligned);

015144  aa  6 01140 6501 00	spri4	pr6|608
015145  aa  6 01142 2521 00	spri2	pr6|610
						STATEMENT 1 ON LINE 3697
	     if hmd.output_block.first_bufferp = null () then
		return ("1"b);

015146  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
015147  aa  7 00054 2371 00	ldaq 	pr7|44		hmd.first_bufferp
015150  aa   763042 6770 04	eraq 	-6622,ic		000212 = 077777000043 000001000000
015151  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
015152  aa   000004 6010 04	tnz  	4,ic		015156
015153  aa   400000 2350 03	lda  	131072,du
015154  aa  2 00002 7551 20	sta  	pr2|2,*
015155  aa  6 01140 6101 00	rtcd 	pr6|608
						STATEMENT 1 ON LINE 3700
	     else return (hmd.output_block.tally <= length (string (TEMPLATE_HASP_BLOCK_HEADER)));

015156  aa  7 00053 2361 00	ldq  	pr7|43		hmd.tally
015157  aa   000005 1160 07	cmpq 	5,dl
015160  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
015161  aa  2 00002 7551 20	sta  	pr2|2,*
015162  aa  6 01140 6101 00	rtcd 	pr6|608
						STATEMENT 1 ON LINE 3702
	end empty_output_blockp;

  END PROCEDURE empty_output_blockp
BEGIN PROCEDURE space_in_output_block_for_record
ENTRY TO space_in_output_block_for_record                   STATEMENT 1 ON LINE 3708
space_in_output_block_for_recordp:
	procedure (P_record_lth) returns (bit (1) aligned);

015163  aa  6 01146 6501 00	spri4	pr6|614
015164  aa  6 01150 2521 00	spri2	pr6|616
						STATEMENT 1 ON LINE 3713
	     return				/* check that record and trailer won't overflow the block */
	       (hmd.max_block_size >=
	        (hmd.output_block.tally + P_record_lth + length (string (TEMPLATE_HASP_BLOCK_TRAILER))));

015165  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
015166  aa  7 00053 2361 00	ldq  	pr7|43		hmd.tally
015167  aa  2 00002 0761 20	adq  	pr2|2,*		P_record_lth
015170  aa   000005 0760 07	adq  	5,dl
015171  aa  7 00012 1161 00	cmpq 	pr7|10		hmd.max_block_size
015172  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
015173  aa  2 00004 7551 20	sta  	pr2|4,*
015174  aa  6 01146 6101 00	rtcd 	pr6|614
						STATEMENT 1 ON LINE 3717
	end space_in_output_block_for_recordp;

  END PROCEDURE space_in_output_block_for_record
BEGIN PROCEDURE full_output_blockp
ENTRY TO full_output_blockp                                 STATEMENT 1 ON LINE 3723
full_output_blockp:
	procedure () returns (bit (1) aligned);

015175  aa  6 01154 6501 00	spri4	pr6|620
015176  aa  6 01156 2521 00	spri2	pr6|622
						STATEMENT 1 ON LINE 3726
	     if empty_output_blockp () then
		return ("0"b);

015177  aa   000137 3520 04	epp2 	95,ic		015336 = 000002000000
015200  aa   777744 6700 04	tsp4 	-28,ic		015144
015201  aa  6 02436 2351 00	lda  	pr6|1310
015202  aa   400000 3150 03	cana 	131072,du
015203  aa   000004 6000 04	tze  	4,ic		015207
015204  aa  6 01156 3735 20	epp7 	pr6|622,*
015205  aa  7 00002 4501 20	stz  	pr7|2,*
015206  aa  6 01154 6101 00	rtcd 	pr6|620
						STATEMENT 1 ON LINE 3728
	     else return (^space_in_output_block_for_recordp (length (string (TEMPLATE_HASP_RTS_RECORD))));

015207  aa   000003 2360 07	ldq  	3,dl
015210  aa  6 02436 7561 00	stq  	pr6|1310
015211  aa   000117 3520 04	epp2 	79,ic		015330 = 000004000000
015212  aa   777751 6700 04	tsp4 	-23,ic		015163
015213  aa  6 02437 2351 00	lda  	pr6|1311
015214  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
015215  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
015216  aa  6 01156 3735 20	epp7 	pr6|622,*
015217  aa  7 00002 7551 20	sta  	pr7|2,*
015220  aa  6 01154 6101 00	rtcd 	pr6|620
						STATEMENT 1 ON LINE 3731
	end full_output_blockp;

  END PROCEDURE full_output_blockp
BEGIN PROCEDURE space_in_empty_output_block_for_
ENTRY TO space_in_empty_output_block_for_                   STATEMENT 1 ON LINE 3737
space_in_empty_output_block_for_recordp:
	procedure (P_record_lth) returns (bit (1) aligned);

015221  aa  6 01162 6501 00	spri4	pr6|626
015222  aa  6 01164 2521 00	spri2	pr6|628
						STATEMENT 1 ON LINE 3742
	     return				/* check that header, record, and trailer fit into block */
	       (hmd.max_block_size >=
	        (P_record_lth + length (string (TEMPLATE_HASP_BLOCK_HEADER)) +
			    length (string (TEMPLATE_HASP_BLOCK_TRAILER))));

015223  aa  2 00002 2361 20	ldq  	pr2|2,*		P_record_lth
015224  aa   000012 0760 07	adq  	10,dl
015225  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
015226  aa  7 00012 1161 00	cmpq 	pr7|10		hmd.max_block_size
015227  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
015230  aa  2 00004 7551 20	sta  	pr2|4,*
015231  aa  6 01162 6101 00	rtcd 	pr6|626
						STATEMENT 1 ON LINE 3747
	end space_in_empty_output_block_for_recordp;

  END PROCEDURE space_in_empty_output_block_for_
BEGIN PROCEDURE delete_text
ENTRY TO delete_text                                        STATEMENT 1 ON LINE 3751
delete_text:
	procedure (P_bufferp, P_position, P_text_lth);

015232  aa  6 01170 6501 00	spri4	pr6|632
015233  aa  6 01172 2521 00	spri2	pr6|634
						STATEMENT 1 ON LINE 3762
	     remainder_lth = (P_bufferp -> buffer.tally) - P_text_lth - P_position;

015234  aa  2 00002 3735 20	epp7 	pr2|2,*		P_bufferp
015235  aa  7 00000 2361 20	ldq  	pr7|0,*		buffer.tally
015236  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
015237  aa  6 02440 7561 00	stq  	pr6|1312		buffer.tally
015240  aa  2 00006 1761 20	sbq  	pr2|6,*		P_text_lth
015241  aa  2 00004 1761 20	sbq  	pr2|4,*		P_position
015242  aa  6 01176 7561 00	stq  	pr6|638		remainder_lth
						STATEMENT 1 ON LINE 3764
	     addr (P_bufferp -> buffer.chars (P_position)) -> based_remainder =
		addr (P_bufferp -> buffer.chars (P_position+P_text_lth)) -> based_remainder;

015243  aa  2 00004 2361 20	ldq  	pr2|4,*		P_position
015244  aa  2 00006 0761 20	adq  	pr2|6,*		P_text_lth
015245  aa  2 00004 7271 20	lxl7 	pr2|4,*		P_position
015246  aa  7 00000 3715 20	epp5 	pr7|0,*		P_bufferp
015247  aa  6 01176 7261 00	lxl6 	pr6|638		remainder_lth
015250  aa  040 157 100 546	mlr  	(pr,rl,ql),(pr,rl,x7),fill(040)
015251  aa  5 00001 00 0016	desc9a	pr5|1,x6		based_remainder
015252  aa  5 00001 00 0016	desc9a	pr5|1,x6		based_remainder
						STATEMENT 1 ON LINE 3767
	     P_bufferp -> buffer.tally = (P_bufferp -> buffer.tally) - P_text_lth;

015253  aa  6 02440 2361 00	ldq  	pr6|1312		buffer.tally
015254  aa  2 00006 1761 20	sbq  	pr2|6,*		P_text_lth
015255  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 3769
	     return;

015256  aa  6 01170 6101 00	rtcd 	pr6|632
						STATEMENT 1 ON LINE 3771
	end delete_text;

  END PROCEDURE delete_text
BEGIN PROCEDURE trace_block
ENTRY TO trace_block                                        STATEMENT 1 ON LINE 3777
trace_block:
	procedure (P_first_bufferp, P_direction);

015257  aa  6 01200 6501 00	spri4	pr6|640
015260  aa  6 01202 2521 00	spri2	pr6|642
						STATEMENT 1 ON LINE 3783
	     call mcs_trace (hmd.devx, "^[Output^;Input^] chain starting at ^p:", P_direction, P_first_bufferp);

015261  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
015262  aa   762771 00 0050	desc9a	-6663,40		000252 = 136133117165
015263  aa  6 02442 00 0050	desc9a	pr6|1314,40
015264  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
015265  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
015266  aa  6 02456 2521 00	spri2	pr6|1326
015267  aa  6 02442 3521 00	epp2 	pr6|1314
015270  aa  6 02460 2521 00	spri2	pr6|1328
015271  aa  6 01202 3715 20	epp5 	pr6|642,*
015272  aa  5 00004 3521 20	epp2 	pr5|4,*		P_direction
015273  aa  6 02462 2521 00	spri2	pr6|1330
015274  aa  5 00002 3521 20	epp2 	pr5|2,*		P_first_bufferp
015275  aa  6 02464 2521 00	spri2	pr6|1332
015276  aa   762677 3520 04	epp2 	-6721,ic		000175 = 404000000021
015277  aa  6 02466 2521 00	spri2	pr6|1334
015300  aa   762632 3520 04	epp2 	-6758,ic		000132 = 524000000047
015301  aa  6 02470 2521 00	spri2	pr6|1336
015302  aa   762631 3520 04	epp2 	-6759,ic		000133 = 516000000001
015303  aa  6 02472 2521 00	spri2	pr6|1338
015304  aa   762673 3520 04	epp2 	-6725,ic		000177 = 464000000000
015305  aa  6 02474 2521 00	spri2	pr6|1340
015306  aa  6 02454 6211 00	eax1 	pr6|1324
015307  aa   020000 4310 07	fld  	8192,dl
015310  aa  6 00044 3701 20	epp4 	pr6|36,*
015311  la  4 00060 3521 20	epp2 	pr4|48,*		mcs_trace
015312  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 3785
	     call mcs_trace$buffer_chain (hmd.devx, P_first_bufferp);

015313  aa  6 00136 3735 20	epp7 	pr6|94,*		hmd_ptr
015314  aa  7 00010 3521 00	epp2 	pr7|8		hmd.devx
015315  aa  6 02444 2521 00	spri2	pr6|1316
015316  aa  6 01202 3715 20	epp5 	pr6|642,*
015317  aa  5 00002 3521 20	epp2 	pr5|2,*		P_first_bufferp
015320  aa  6 02446 2521 00	spri2	pr6|1318
015321  aa  6 02442 6211 00	eax1 	pr6|1314
015322  aa   010000 4310 07	fld  	4096,dl
015323  aa  6 00044 3701 20	epp4 	pr6|36,*
015324  la  4 00062 3521 20	epp2 	pr4|50,*		mcs_trace$buffer_chain
015325  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 3787
	     return;

015326  aa  6 01200 6101 00	rtcd 	pr6|640
						STATEMENT 1 ON LINE 3789
	end trace_block;

  END PROCEDURE trace_block
  END PROCEDURE hasp_mpx


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
