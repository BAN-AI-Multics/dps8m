	COMPILATION LISTING OF SEGMENT init_stack_0
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0939.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 init_stack_0:
       14      proc;
       15 
       16 /* Program to build stack 0 segs to be shared by users */
       17 /* Created May 79 by Mike Grady */
       18 /* Modified June 81 by J. Bongiovanni to call update_vtoce for each stack,
       19*     retry by deleting on error */
       20 /* Modified December 1981 by J. Bongiovanni to clear usage count in ASTE */
       21 /* Modified November 1984 by Keith Loepere to rename terminate to terminate_ */
       22 
       23 dcl  append$branchx entry (char (*), char (*), fixed bin (5), (*) fixed bin, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35));
       24 dcl  chname$cfile entry (char (*), char (*), char (*), char (*), fixed bin (35));
       25 dcl  delentry$dfile entry (char (*), char (*), fixed bin (35));
       26 dcl  initiate entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
       27 dcl  truncate$trseg entry (ptr, fixed bin, fixed bin (35));
       28 dcl  asd_$replace_sall entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
       29 dcl  terminate_$noname entry (ptr, fixed bin (35));
       30 dcl  grab_aste$prewithdraw entry (ptr, fixed bin, fixed bin (35)) returns (ptr);
       31 dcl  get_ptrs_$given_astep entry (ptr) returns (bit (72) aligned);
       32 dcl  syserr$error_code entry options (variable);
       33 dcl  syserr entry options (variable);
       34 dcl  unique_chars_ entry (bit(*)) returns(char(15));
       35 dcl  update_vtoce entry (ptr);
       36 
       37 dcl  error_table_$namedup fixed bin (35) ext;
       38 dcl  dseg$ fixed bin ext;
       39 dcl  active_all_rings_data$stack_base_segno fixed bin ext;
       40 dcl  pds$apt_ptr ptr aligned ext;
       41 dcl  pds$stack_0_sdwp ptr ext;
       42 dcl  pds$stack_0_ptr ptr ext;
       43 
       44 dcl  indx fixed bin;
       45 dcl  count fixed bin;
       46 dcl  stk_no fixed bin;
       47 dcl  stk_segp ptr;
       48 dcl  dirname char (20) int static options (constant) init (">system_library_1");
       49 dcl  stack_name char (32);
       50 dcl  pic picture "999";
       51 dcl  new_stkp ptr;
       52 dcl  code fixed bin (35);
       53 dcl 1 tsdw like sdw;
       54 dcl  seg_rb (3) fixed bin init (0, 0, 0) static options (constant);
       55 dcl  retry bit (1);
       56 
       57 dcl 1 acl (1) aligned,
       58     2 name char (32),
       59     2 mode bit (36),
       60     2 zp bit (36) init ("0"b),
       61     2 code fixed bin (35);
       62 
       63 dcl 1 stack aligned based (sb),
       64     2 header like stack_header,
       65     2 frame_start fixed bin;
       66 
       67 dcl  (addr, baseno, baseptr, fixed, null, ptr, rel, size, string) builtin;
       68 
       69 /*  */
       70 
       71 	new_stkp = baseptr (active_all_rings_data$stack_base_segno);
       72 	sdtp = addr (stack_0_data$);
       73 
       74 	count = sdt.num_stacks;
       75 	indx = 1;					/* setup count and index for stack creation */
       76 	stk_no = 1;
       77 	stk_segp = null ();
       78 
       79 	do while (count ^= 0);			/* build stack segs */
       80 	     sdtep = addr (sdt.stacks (indx));		/* ptr to this entry */
       81 	     retry = "1"b;				/* retry by deleting on error			*/
       82 
       83 	     pic = stk_no;
       84 	     stack_name = "stack_0." || pic;
       85 
       86 retry_stack:
       87 	     call append$branchx (dirname, stack_name, 01010b, seg_rb, "*.*.*", 0, 0, 0, code);
       88 	     if code ^= 0 then do;
       89 		if code = error_table_$namedup then;
       90 		else call error ("append", code);
       91 	     end;
       92 
       93 	     acl.name = "Initializer.SysDaemon.*";
       94 	     acl.mode = "101"b;
       95 	     call asd_$replace_sall (dirname, stack_name, addr (acl), 1, "1"b, code);
       96 	     if code ^= 0 then
       97 		call error ("asd_", code);
       98 
       99 	     call initiate (dirname, stack_name, "", 0, 0, stk_segp, code);
      100 	     if code ^= 0 then
      101 		call error ("initiate", code);
      102 
      103 	     call truncate$trseg (stk_segp, 0, code);
      104 	     if code ^= 0 then
      105 		call error ("truncate", code);
      106 
      107 	     astep = grab_aste$prewithdraw (stk_segp, 16*1024, code); /* get the correct aste */
      108 	     if code ^= 0 then
      109 		call error ("grab_aste", code);
      110 
      111 	     seg_aste.usage = 0;			/* counts only meaningful since bootload, anyway */
      112 
      113 	     call update_vtoce (astep);
      114 
      115 	     string (tsdw) = get_ptrs_$given_astep (astep); /* get a real SDW for the stack seg */
      116 	     tsdw.cache = "1"b;			/* stacks go in the cache */
      117 
      118 	     sdte.sdw = string (tsdw);		/* fill in the sdte */
      119 	     sdte.astep = rel (astep);
      120 	     sdte.nextp = sdt.freep;			/* thread this guy into list */
      121 	     sdt.freep = rel (sdtep);			/* and point free to this */
      122 
      123 	     stk_segp -> stack_header_overlay = pds$stack_0_ptr -> stack_header_overlay;
      124 	     sb = stk_segp;				/* for header re_build */
      125 	     stack_header.stack_begin_ptr,
      126 		stack_header.stack_end_ptr = ptr (new_stkp, rel (addr (stack.frame_start)));
      127 
      128 	     call terminate_$noname (stk_segp, code);	/* we don't need this anymore */
      129 	     stk_segp = null ();
      130 	     call asd_$replace_sall (dirname, stack_name, addr (acl), 0, "1"b, code); /* delete ACL */
      131 
      132 	     count = count - 1;
      133 	     indx = indx + 1;
      134 
      135 try_again:     stk_no = stk_no + 1;
      136 	end;
      137 
      138 
      139 	sdtep = ptr (sdtp, sdt.freep);		/* take first stack for Initializer */
      140 	sdt.freep = sdte.nextp;			/* re-thread free list */
      141 	sdte.nextp = "0"b;				/* claim this one */
      142 	sdte.aptep = rel (pds$apt_ptr);		/* Initializers APTE */
      143 	pds$apt_ptr -> apte.flags.shared_stack_0 = "1"b;	/* Has a shared ring-0 stack */
      144 
      145 	sdwp = addr (dseg$);
      146 	pds$stack_0_sdwp = addr (sdwa (fixed (baseno (new_stkp))));
      147 	pds$stack_0_ptr = new_stkp;
      148 
      149 	sdwp = pds$stack_0_sdwp;
      150 	string (sdw) = sdte.sdw;			/* fill in correct SDW for Initializer's stack 0 */
      151 	return;
      152 
      153 
      154 
      155 error:	proc (who, code);
      156 
      157 dcl  who char (*);
      158 dcl  code fixed bin (35);
      159 
      160 dcl  ecode fixed bin (35);
      161 dcl  temp_stack_name char (32);
      162 
      163 	if retry then do;
      164 	     retry = "0"b;
      165 	     call syserr (0, "init_stack_0: Error creating >sl1>^a from ^a. Retrying.",
      166 		stack_name, who);
      167 	     call syserr$error_code (0, code, "init_stack_0: ");
      168 	     if stk_segp ^= null () then do;
      169 		call terminate_$noname (stk_segp, ecode);
      170 		stk_segp = null ();
      171 	     end;
      172 	     temp_stack_name = "stack_0." || unique_chars_ (""b);
      173 	     call chname$cfile (dirname, stack_name, stack_name, temp_stack_name, ecode);
      174 	     if ecode ^= 0 then call error ("chname", ecode);
      175 	     call delentry$dfile (dirname, temp_stack_name, ecode);
      176 	     if ecode ^= 0 then call error ("delentry", ecode);
      177 	     goto retry_stack;
      178 	end;
      179 	else do;
      180 	     call syserr (3, "init_stack_0: Error creating >sl1>^a from ^a. Stack skipped.", stack_name, who);
      181 	     call syserr$error_code (0, code, "init_stack_0: ");
      182 	     go to try_again;
      183 	end;
      184 
      185 	end;
      186 
      187 
      188 
  1     1 /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  1     2 
  1     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  1     4 
  1     5 dcl  aptep pointer;
  1     6 
  1     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  1     8     2 thread unaligned,				/* List thread */
  1     9       3 fp bit (18),				/* Forward pointer */
  1    10       3 bp bit (18),				/* Backward pointer */
  1    11     2 flags unaligned,				/* Flags and miscellaneous */
  1    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  1    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  1    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  1    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  1    16       3 hproc bit (1),				/* ON if process is hardcore process */
  1    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  1    18       3 eligible bit (1),				/* ON if process is eligible */
  1    19       3 idle bit (1),				/* ON if  this is an idle process */
  1    20       3 interaction bit (1),				/* ON if process has interacted recently */
  1    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  1    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  1    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  1    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  1    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  1    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  1    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  1    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  1    29       3 firstsw bit (1),				/* OFF until process is intialized */
  1    30       3 state bit (18),				/* execution state */
  1    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  1    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  1    33 						/* bit 18-35: sequential number */
  1    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  1    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  1    36     2 ti fixed bin (35),				/* virtual time since interaction */
  1    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  1    38 
  1    39 /* * * * * * * * */
  1    40 
  1    41     2 ipc_pointers unaligned,
  1    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  1    43       3 pad3 bit (18),
  1    44     2 ips_message bit (36),				/* IPS signals pending */
  1    45     2 asteps unaligned,				/* relative ASTE pointers */
  1    46       3 pds bit (18),				/* PDS (per-process) */
  1    47       3 dseg bit (18),				/* DSEG (per-process) */
  1    48       3 prds bit (18),				/* PRDS (per-processor) */
  1    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  1    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  1    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  1    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  1    53 
  1    54 /* * * * * * * * */
  1    55 
  1    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  1    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  1    58     2 flags2 unaligned,
  1    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  1    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  1    61       3 pad7 bit (7),
  1    62       3 batch bit (1),				/* ON if absentee */
  1    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  1    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  1    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  1    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  1    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  1    68 
  1    69 /* * * * * * */
  1    70 
  1    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  1    72     2 ws_size fixed bin,				/* working set estimate for the process */
  1    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  1    74     2 deadline fixed bin (71),			/* time of next run */
  1    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  1    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  1    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  1    78*						/* reaches this (units = 1/1024 sec) */
  1    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  1    80     2 access_authorization bit (72),			/* authorization of this process */
  1    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  1    82 
  1    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  1    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  1    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  1    86 
  1    87 /*  Cells used to drive and instrument finite-state model for response time
  1    88*    measurement. Maintained by meter_response_time */
  1    89 
  1    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  1    91     2 pad18 bit (18) unaligned,
  1    92     2 number_processing fixed bin (35),			/* Number interactions */
  1    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  1    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  1    95 
  1    96 /* * * * * * */
  1    97 
  1    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  1    99 
  1   100 /*  End of cells for finite-state model */
  1   101 
  1   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  1   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  1   104     2 pad4 bit (28) unaligned,
  1   105     2 ipc_r_offset fixed bin (18) unsigned,
  1   106     2 ipc_r_factor fixed bin (35) unsigned,
  1   107     2 apad (10) fixed bin (35);
  1   108 
  1   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      189 
  2     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      190 
  3     1 /* BEGIN INCLUDE FILE ... stack_0_data.incl.pl1 */
  3     2 
  3     3 /* Created 790509 by Mike Grady */
  3     4 
  3     5 dcl  stack_0_data$ fixed bin ext;			/* shared stack 0 data base seg */
  3     6 dcl  stack_0_data_init_number_of_stacks fixed bin;	/* Make PL/I work */
  3     7 dcl  sdtp ptr;
  3     8 
  3     9 dcl 1 sdt aligned based (sdtp),			/* stack 0 database */
  3    10     2 lock bit (36),				/* lock before changing threads */
  3    11     2 num_stacks fixed bin,				/* number of stacks in pool */
  3    12     2 freep bit (18),				/* head of free thread, managed LIFO */
  3    13     2 pad fixed bin,
  3    14     2 stacks (stack_0_data_init_number_of_stacks
  3    15 	refer (sdt.num_stacks)) like sdte;
  3    16 
  3    17 dcl  sdtep ptr;
  3    18 
  3    19 dcl 1 sdte aligned based (sdtep),			/* stack data table entry */
  3    20     2 nextp bit (18) unal,				/* thread to next free entry (if free) */
  3    21     2 pad bit (18) unal,
  3    22     2 astep bit (18) unal,				/* ptr to ASTE for this stack seg */
  3    23     2 aptep bit (18) unal,				/* ptr to APTE of process using this stack, if not free */
  3    24     2 sdw bit (72);					/* SDW for this stack seg */
  3    25 
  3    26 /* END INCLUDE FILE ... stack_0_data.incl.pl1 */
      191 
  4     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  4     2 
  4     3 dcl  sdwp ptr;
  4     4 
  4     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  4     6 
  4     7    (2 add bit (24),					/* main memory address of page table */
  4     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  4     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  4    10     2 df_no bit (2),				/* directed fault number */
  4    11 
  4    12     2 pad1 bit (1),
  4    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  4    14     2 access,					/* access bits */
  4    15       3 read bit (1),				/* read permission bit */
  4    16       3 execute bit (1),				/* execute permission bit */
  4    17       3 write bit (1),				/* write permission bit */
  4    18       3 privileged bit (1),				/* privileged bit */
  4    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  4    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  4    21     2 cache bit (1),				/* cache enable bit */
  4    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  4    23 
  4    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  4    25 
  4    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      192 
  5     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  5     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  5     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  5     4 /*	Modified April 1983 by C. Hornig for tasking */
  5     5 
  5     6 /****^  HISTORY COMMENTS:
  5     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  5     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  5     9*     added the heap_header_ptr definition.
  5    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  5    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  5    12*     Modified to support control point management.  These changes were actually
  5    13*     made in February 1985 by G. Palter.
  5    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  5    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  5    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  5    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  5    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  5    19*     (ITS pair).
  5    20*                                                   END HISTORY COMMENTS */
  5    21 
  5    22 /* format: style2 */
  5    23 
  5    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  5    25 
  5    26      dcl	   1 stack_header	      based (sb) aligned,
  5    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  5    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  5    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  5    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  5    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  5    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  5    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  5    34 	     2 pad4	      bit (2) unal,
  5    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  5    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  5    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  5    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  5    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  5    40 	     2 null_ptr	      ptr,		/*  (16)  */
  5    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  5    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  5    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  5    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  5    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  5    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  5    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  5    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  5    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  5    50 	     2 return_no_pop_op_ptr
  5    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  5    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  5    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  5    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  5    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  5    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  5    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  5    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  5    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  5    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  5    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  5    62 	     2 trace,
  5    63 	       3 frames,
  5    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  5    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  5    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  5    67 	     2 pad2	      bit (36),		/*  (61) */
  5    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  5    69 
  5    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  5    71 
  5    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  5    73 						/* (551) octal */
  5    74 
  5    75 
  5    76 /*	The following constants are offsets within this transfer vector table.  */
  5    77 
  5    78      dcl	   (
  5    79 	   call_offset	      fixed bin init (271),
  5    80 	   push_offset	      fixed bin init (272),
  5    81 	   return_offset	      fixed bin init (273),
  5    82 	   return_no_pop_offset   fixed bin init (274),
  5    83 	   entry_offset	      fixed bin init (275)
  5    84 	   )		      internal static;
  5    85 
  5    86 
  5    87 
  5    88 
  5    89 
  5    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  5    91*	move the whole stack header should use this overlay.
  5    92**/
  5    93 
  5    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  5    95 
  5    96 
  5    97 
  5    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      193 
      194 
      195 
      196 /* BEGIN MESSAGE DOCUMENTATION
      197*
      198*   Message:
      199*   init_stack_0: Error creating >sl1>XXXXXX from YYYYY. Retrying.
      200*
      201*   S: $info
      202*
      203*   T: $init
      204*
      205*   M: An error was encountered in creating the stack_0 segment XXXXXX.  The 
      206*   error was returned by module YYYYYY, and is described in detail in the
      207*   following message.  init_stack_0 will attempt to correct the problem
      208*   by renaming the segment XXXXXX to stack_0.<unique name>, deleting it,
      209*   and retrying the creation of segment XXXXXX once.
      210*
      211*   A: No action is required if the above actions correct the problem.
      212*   If the message persists, it may be symptomatic of hardware or
      213*   software problems, and it should be brought to the attention of
      214*   the System Programming Staff.
      215*
      216*   Message:
      217*   init_stack_0: Error creating >sl1>XXXXXX from YYYYYY. Stack skipped.
      218*
      219*   S: $info
      220*
      221*   T: $init
      222*
      223*   M: An error was encountered in creating the stack_0 segment XXXXXX.
      224*   The error was returned by module YYYYYY, and is described in detail in the
      225*   following message.  This error could not be corrected by renaming 
      226*   the segment XXXXXX to stack_0.<unique name>, deleting it, and retrying
      227*   the creation of segment XXXXXX once.  The stack_0 represented by
      228*   segment XXXXXX is skipped, and there will be one fewer stack_0 than
      229*   specified by the max_max_eligible tuning parameter for each message of
      230*   this sort.
      231*
      232*   A: This message may be symptomatic of hardware or software problems.
      233*   It should be brought to the attention of the System Programming Staff.
      234*
      235*   END MESSAGE DOCUMENTATION */
      236 
      237      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.9  init_stack_0.pl1                  >spec>install>1112>init_stack_0.pl1
189          1    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
190          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
191          3    10/25/79  0712.2  stack_0_data.incl.pl1             >ldd>include>stack_0_data.incl.pl1
192          4    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
193          5    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acl                             000127 automatic       structure                array level 1 dcl 57 set ref 95 95 130 130
active_all_rings_data$stack_base_segno
                                000046 external static fixed bin(17,0)          dcl 39 ref 71
addr                                                   builtin function         dcl 67 ref 72 80 95 95 125 130 130 145 146
append$branchx                  000010 constant        entry                    external dcl 23 ref 86
apte                                   based           structure                level 1 dcl 1-7
aptep                     1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-19 set ref
                                                                                  142*
asd_$replace_sall               000022 constant        entry                    external dcl 28 ref 95 130
astep                           000142 automatic       pointer                  dcl 2-9 in procedure "init_stack_0" set ref 107* 111
                                                                                  113* 115* 119
astep                     1            based           bit(18)                  level 2 in structure "sdte" packed packed unaligned
                                                                                  dcl 3-19 in procedure "init_stack_0" set ref 119*
baseno                                                 builtin function         dcl 67 ref 146
baseptr                                                builtin function         dcl 67 ref 71
cache                     1(21) 000124 automatic       bit(1)                   level 2 packed packed unaligned dcl 53 set ref 116*
chname$cfile                    000012 constant        entry                    external dcl 24 ref 173
code                                   parameter       fixed bin(35,0)          dcl 158 in procedure "error" set ref 155 167* 181*
code                            000122 automatic       fixed bin(35,0)          dcl 52 in procedure "init_stack_0" set ref 86* 88 89
                                                                                  90* 95* 96 96* 99* 100 100* 103* 104 104* 107* 108
                                                                                  108* 128* 130*
count                           000101 automatic       fixed bin(17,0)          dcl 45 set ref 74* 79 132* 132
delentry$dfile                  000014 constant        entry                    external dcl 25 ref 175
dirname                         000003 constant        char(20)                 initial packed unaligned dcl 48 set ref 86* 95* 99*
                                                                                  130* 173* 175*
dseg$                           000044 external static fixed bin(17,0)          dcl 38 set ref 145
ecode                           000100 automatic       fixed bin(35,0)          dcl 160 set ref 169* 173* 174 174* 175* 176 176*
error_table_$namedup            000042 external static fixed bin(35,0)          dcl 37 ref 89
fixed                                                  builtin function         dcl 67 ref 146
flags                     1            based           structure                level 2 packed packed unaligned dcl 1-7
frame_start             100            based           fixed bin(17,0)          level 2 dcl 63 set ref 125
freep                     2            based           bit(18)                  level 2 dcl 3-9 set ref 120 121* 139 140*
get_ptrs_$given_astep           000030 constant        entry                    external dcl 31 ref 115
grab_aste$prewithdraw           000026 constant        entry                    external dcl 30 ref 107
indx                            000100 automatic       fixed bin(17,0)          dcl 44 set ref 75* 80 133* 133
initiate                        000016 constant        entry                    external dcl 26 ref 99
mode                     10     000127 automatic       bit(36)                  array level 2 dcl 57 set ref 94*
name                            000127 automatic       char(32)                 array level 2 dcl 57 set ref 93*
new_stkp                        000120 automatic       pointer                  dcl 51 set ref 71* 125 146 147
nextp                                  based           bit(18)                  level 2 packed packed unaligned dcl 3-19 set ref
                                                                                  120* 140 141*
null                                                   builtin function         dcl 67 ref 77 129 168 170
num_stacks                1            based           fixed bin(17,0)          level 2 dcl 3-9 ref 74
pds$apt_ptr                     000050 external static pointer                  dcl 40 ref 142 143
pds$stack_0_ptr                 000054 external static pointer                  dcl 42 set ref 123 147*
pds$stack_0_sdwp                000052 external static pointer                  dcl 41 set ref 146* 149
pic                             000116 automatic       picture(3)               packed unaligned dcl 50 set ref 83* 84
ptr                                                    builtin function         dcl 67 ref 125 139
rel                                                    builtin function         dcl 67 ref 119 121 125 142
retry                           000126 automatic       bit(1)                   packed unaligned dcl 55 set ref 81* 163 164*
sb                              000152 automatic       pointer                  dcl 5-24 set ref 123 124* 125 125 125
sdt                                    based           structure                level 1 dcl 3-9
sdte                                   based           structure                level 1 dcl 3-19
sdtep                           000146 automatic       pointer                  dcl 3-17 set ref 80* 118 119 120 121 139* 140 141
                                                                                  142 150
sdtp                            000144 automatic       pointer                  dcl 3-7 set ref 72* 74 80 120 121 139 139 140
sdw                                    based           structure                level 1 dcl 4-5 in procedure "init_stack_0" set ref
                                                                                  150*
sdw                       2            based           bit(72)                  level 2 in structure "sdte" dcl 3-19 in procedure
                                                                                  "init_stack_0" set ref 118* 150
sdwa                                   based           structure                array level 1 dcl 4-24 set ref 146
sdwp                            000150 automatic       pointer                  dcl 4-3 set ref 145* 146 149* 150
seg_aste                               based           structure                level 1 dcl 2-96
seg_rb                          000000 constant        fixed bin(17,0)          initial array dcl 54 set ref 86*
shared_stack_0            1(15)        based           bit(1)                   level 3 packed packed unaligned dcl 1-7 set ref 143*
size                                                   builtin function         dcl 67 ref 123
stack                                  based           structure                level 1 dcl 63
stack_0_data$                   000056 external static fixed bin(17,0)          dcl 3-5 set ref 72
stack_begin_ptr          22            based           pointer                  level 2 dcl 5-26 set ref 125*
stack_end_ptr            24            based           pointer                  level 2 dcl 5-26 set ref 125*
stack_header                           based           structure                level 1 dcl 5-26 set ref 123
stack_header_overlay                   based           fixed bin(17,0)          array dcl 5-94 set ref 123* 123
stack_name                      000106 automatic       char(32)                 packed unaligned dcl 49 set ref 84* 86* 95* 99* 130*
                                                                                  165* 173* 173* 180*
stacks                    4            based           structure                array level 2 dcl 3-9 set ref 80
stk_no                          000102 automatic       fixed bin(17,0)          dcl 46 set ref 76* 83 135* 135
stk_segp                        000104 automatic       pointer                  dcl 47 set ref 77* 99* 103* 107* 123 124 128* 129*
                                                                                  168 169* 170*
string                                                 builtin function         dcl 67 set ref 115* 118 150*
syserr                          000034 constant        entry                    external dcl 33 ref 165 180
syserr$error_code               000032 constant        entry                    external dcl 32 ref 167 181
temp_stack_name                 000101 automatic       char(32)                 packed unaligned dcl 161 set ref 172* 173* 175*
terminate_$noname               000024 constant        entry                    external dcl 29 ref 128 169
truncate$trseg                  000020 constant        entry                    external dcl 27 ref 103
tsdw                            000124 automatic       structure                level 1 packed packed unaligned dcl 53 set ref 115*
                                                                                  118
unique_chars_                   000036 constant        entry                    external dcl 34 ref 172
update_vtoce                    000040 constant        entry                    external dcl 35 ref 113
usage                    10            based           fixed bin(35,0)          level 2 dcl 2-96 set ref 111*
who                                    parameter       char                     packed unaligned dcl 157 set ref 155 165* 180*
zp                       11     000127 automatic       bit(36)                  initial array level 2 dcl 57 set ref 57*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
aptep                                  automatic       pointer                  dcl 1-5
asta                                   based           bit(432)                 array dcl 2-86
aste                                   based           structure                level 1 dcl 2-11
aste_part                              based           structure                level 1 dcl 2-89
call_offset                            internal static fixed bin(17,0)          initial dcl 5-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 5-78
push_offset                            internal static fixed bin(17,0)          initial dcl 5-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 5-78
return_offset                          internal static fixed bin(17,0)          initial dcl 5-78
stack_0_data_init_number_of_stacks     automatic       fixed bin(17,0)          dcl 3-6
tv_offset                              internal static fixed bin(17,0)          initial dcl 5-72

NAMES DECLARED BY EXPLICIT CONTEXT.
error                           001030 constant        entry                    internal dcl 155 ref 90 96 100 104 108 174 176
init_stack_0                    000135 constant        entry                    external dcl 13
retry_stack                     000217 constant        label                    dcl 86 ref 177
try_again                       000754 constant        label                    dcl 135 ref 182

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1670        1750    1407        1700
Length      2246    1407        60         262     260           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_stack_0                        168 external procedure  is an external procedure.  
error                               132 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
error                    000100 ecode                       error
                         000101 temp_stack_name             error
init_stack_0             000100 indx                        init_stack_0
                         000101 count                       init_stack_0
                         000102 stk_no                      init_stack_0
                         000104 stk_segp                    init_stack_0
                         000106 stack_name                  init_stack_0
                         000116 pic                         init_stack_0
                         000120 new_stkp                    init_stack_0
                         000122 code                        init_stack_0
                         000124 tsdw                        init_stack_0
                         000126 retry                       init_stack_0
                         000127 acl                         init_stack_0
                         000142 astep                       init_stack_0
                         000144 sdtp                        init_stack_0
                         000146 sdtep                       init_stack_0
                         000150 sdwp                        init_stack_0
                         000152 sb                          init_stack_0

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc return_mac
tra_ext_1           mpfx2               shorten_stack       ext_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
append$branchx                asd_$replace_sall             chname$cfile                  delentry$dfile
get_ptrs_$given_astep         grab_aste$prewithdraw         initiate                      syserr
syserr$error_code             terminate_$noname             truncate$trseg                unique_chars_
update_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data$stack_base_segno                      dseg$                         error_table_$namedup
pds$apt_ptr                   pds$stack_0_ptr               pds$stack_0_sdwp              stack_0_data$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000134        57 000142        71 000147        72 000153        74 000155        75 000157        76 000161
     77 000162        79 000164        80 000166        81 000172        83 000174        84 000204        86 000217
     88 000276        89 000300        90 000304        93 000322        94 000336        95 000350        96 000413
     99 000433       100 000475       103 000515       104 000531       107 000551       108 000570       111 000612
    113 000614       115 000623       116 000636       118 000640       119 000644       120 000646       121 000651
    123 000653       124 000662       125 000663       128 000674       129 000705       130 000707       132 000751
    133 000753       135 000754       136 000755       139 000756       140 000763       141 000766       142 000770
    143 000776       145 001000       146 001002       147 001013       149 001015       150 001020       151 001026
    155 001027       163 001043       164 001046       165 001047       167 001100       168 001131       169 001136
    170 001147       172 001152       173 001202       174 001232       175 001253       176 001274       177 001315
    180 001320       181 001352       182 001403


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
