	COMPILATION LISTING OF SEGMENT signal_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1000.8 mst Sat
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1987 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        * Copyright (c) 1972 by Massachusetts Institute of   *
        9*        * Technology and Honeywell Information Systems, Inc. *
       10*        *                                                    *
       11*        ****************************************************** */
       12 
       13 /* This procedure implements the Multics PL/1 condition handling mechanism.
       14*   This procedure is called with the name of a condition and searches back
       15*   up the condition stack which is embedded in the standard Multics stack until
       16*   a handler for the condition is found. This handler is then invoked.
       17*   If the beginning of the stack is reached, a new stack frame is built
       18*   at the end of the calling ring's stack and the unwinder is called
       19*   to repeat the above process.
       20*
       21*   Modified on November 14, 1971 by R. J. Feiertag to handle special conditions. 		 */
       22 /* 	Modified on January 13, 1972 by R. J. Feiertag					 */
       23 /*	Recoded on September 14, 1972 for the 645F by Noel I. Morris			*/
       24 /*	Modified July 1973 by M. Weaver for any_other, new stack frame flags,
       25*   and to use nonlocal_goto_ */
       26 /* 	Modified October 1973 by M. Weaver to re-separate the unwinder,
       27*   process pl1 snap and system, eliminate special handlers, make use of the new
       28*   pl1 info structure for I/O conditions and copy more stuff on crawlouts
       29*
       30*   Modified 4/75 by S. Webber to add static handler code
       31*   Emergency fix 760427 by PG to initialize continue flag before calling static handlers.
       32*   Modified 7/14/76 by Noel I. Morris for virtual time metering
       33*   Modified 6/76 by D. Vinograd to more correctly determine if fault occured in fim stack frame.
       34*   Modified 1/26/81 by J. A. Bush to set up any_other condition handler for stack access problems
       35*   Modified April 2 1981 Benson I. Margulies to special case null_pointer_ 
       36*	 versus simfault_nnnnnn. This code can be removed for MR10 or 11.
       37*	 The special case consists of the flag null_pointer_condition
       38*	 and code in the proc found_specific_condition.
       39*
       40*   Modified September 1981 by Benson I. Margulies for:
       41*     1) passing info_ptr to static handler
       42*     2) continue_to_signal_ for static handlers.
       43*   Modified '82 BIM for any_other handler while running.
       44**/
       45 
       46 
       47 /****^  HISTORY COMMENTS:
       48*  1) change(87-02-13,Farley), approve(87-04-15,MCR7665),
       49*     audit(87-04-20,Lippard), install(87-04-28,MR12.1-1028):
       50*     (phx20748) Changed to revert the any_other handler before calling
       51*     crawlout_default_handler_ so that any recursive calls that it makes back
       52*     to us will not invoke our any_other handler.
       53*  2) change(87-04-15,Farley), approve(87-04-15,MCR7665),
       54*     audit(87-04-20,Lippard), install(87-04-28,MR12.1-1028):
       55*     Changed to continue to the previous stack frame after handling a specific
       56*     condition and the handler wishes to continue to signal.  The any_other
       57*     condition handler, when defined, was being called erroneously.
       58*                                                   END HISTORY COMMENTS */
       59 
       60 
       61 /* format: style2 */
       62 signal:
       63 signal_:
       64      procedure (a_name, a_mcptr, a_info_ptr, a_wcptr);
       65 
       66 	static_okay = "1"b;
       67 	go to common;
       68 
       69 	dcl     a_name		 char (*),	/* condition being signalled */
       70 	        a_info_ptr		 ptr,		/* information about software signal */
       71 	        a_wcptr		 ptr,		/* info about wall crossing from this ring before crawlout */
       72 	        a_mcptr		 ptr;		/* optional machine conditions ptr */
       73 
       74 	dcl     mcptr		 ptr,		/* pointer to machine conditions */
       75 	        info_ptr		 ptr,		/* pointer to software signal info */
       76 	        wcptr		 ptr,		/* pointer to wall crossing mc */
       77 	        condition_name	 char (32),	/* local copy of condition being signalled */
       78 	        l_name		 fixed bin,	/* length of condition name */
       79 	        loops		 fixed bin init (0),/* count of separate stack frames found */
       80 	        ou_count		 fixed bin,	/* count of on units in thread */
       81 	        code		 fixed bin (35),	/* status code for unwind_stack_ */
       82 	        onlistp		 ptr,		/* pointer to on condition unit in stack frame */
       83 	        onlistrel		 bit (18),	/* offset within stack frame of on unit */
       84 	        oldp		 ptr,		/* pointer to previous on unit */
       85 	        prev_sp		 ptr,		/* used for threading new signal_ stack frame */
       86 	        next_sp		 ptr,		/* used in back-tracing the stack */
       87 	        my_sp		 ptr,		/* pointer to original signal_ stack frame */
       88 	        filep		 ptr,		/* pointer to pl1 file descriptor */
       89 	        arglistptr		 ptr,		/* pointer to fim or ii arglist */
       90 	        args		 fixed bin,	/* argument count to signal_ */
       91 	        unclp		 ptr,		/* pointer to unclaimed signal on unit */
       92 	        signal_caller_frame_size
       93 				 fixed bin (18) unsigned,
       94 						/* size of frame to call signal_ */
       95 	        io		 bit (1) aligned,	/* "1"b if I/O condition being signalled */
       96 	        retsw		 bit (1) aligned,	/* used by default handler before crawling out */
       97 	        continue		 bit (1) aligned;	/* "1"b after return from condition handler
       98*						   causes signal_ to continue searching for more. */
       99 	dcl     static_okay		 bit (1) aligned;	/* used to prevent infinite recursion with static handlers */
      100 
      101 	dcl     null_pointer_condition bit (1) aligned;	/* null_pointer_ */
      102 	dcl     any_other		 condition;
      103 
      104 	dcl     1 based_machine_conditions
      105 				 aligned based,	/* used to copy the machine conditions */
      106 		2 words		 (24) fixed bin (71);
      107 	dcl     based_ptr		 ptr based;	/* used in picking up ptr from arg list */
      108 
      109 	dcl     based_array		 (info_ptr -> condition_info_header.length) fixed bin (35) based;
      110 						/* used in copying info structures */
      111 
      112 	dcl     1 descriptor	 based aligned,	/* PL/1 argument descriptor */
      113 	        ( 2 flag		 bit (1),		/* non-zero for V2PL/1 */
      114 		2 type		 bit (6),		/* data type */
      115 		2 packed		 bit (1),		/* non-zero for packed data */
      116 		2 number_dims	 bit (4),		/* number of array dimensions */
      117 		2 size		 bit (24)
      118 		)		 unal;		/* size of data */
      119 
      120 	dcl     1 signal_caller_frame	 based (sp) aligned,/* stack frame for caller of signal_ */
      121 		2 frame_header	 like stack_frame,	/* stack frame header */
      122 		2 machine_conditions like based_machine_conditions,
      123 						/* machine conditions */
      124 		2 mcptr		 ptr,		/* pointer to machine conditions */
      125 		2 infoptr		 ptr,		/* pointer to info structure */
      126 		2 wcptr		 ptr,		/* pointer to wall crossing conditions */
      127 		2 condition_name	 char (32),	/* condition being signalled */
      128 		2 condition_name_desc
      129 				 like descriptor,	/* descriptor for condition name */
      130 		2 mcptr_desc	 like descriptor,	/* descriptor for pointer */
      131 		2 infoptr_desc	 like descriptor,	/* descriptor for pointer */
      132 		2 wcptr_desc	 like descriptor,	/* descriptor for pointer */
      133 		2 arglist,			/* argument list to signal_ */
      134 		  3 arg_count	 fixed bin (17) unal,
      135 						/* 2 * number of args */
      136 		  3 flag		 fixed bin (17) unal,
      137 						/* =4 for pl/1 call */
      138 		  3 desc_count	 fixed bin (17) unal,
      139 						/* 2 * number of descriptors */
      140 		  3 pad		 fixed bin (17) unal,
      141 		  3 condition_name_ptr
      142 				 ptr,
      143 		  3 mcptr_ptr	 ptr,
      144 		  3 infoptr_ptr	 ptr,
      145 		  3 wcptr_ptr	 ptr,
      146 		  3 condition_name_desc_ptr
      147 				 ptr,
      148 		  3 mcptr_desc_ptr	 ptr,
      149 		  3 infoptr_desc_ptr ptr,
      150 		  3 wcptr_desc_ptr	 ptr,
      151 		2 additions	 fixed bin;	/* info structure and/or wc will be copied here */
      152 
      153 	dcl     arg_count_		 external entry (fixed bin);
      154 	dcl     sct_manager_$call_handler
      155 				 entry (ptr, char (*), ptr, ptr, bit (1) aligned);
      156 	dcl     unwind_stack_	 entry (ptr, ptr, fixed bin (35));
      157 	dcl     nonlocal_goto_$different_ring
      158 				 entry (ptr, ptr);
      159 	dcl     crawlout_default_handler_
      160 				 entry (ptr, char (*), ptr, ptr, bit (1) aligned);
      161 	dcl     pl1_snap_		 entry (char (*));
      162 	dcl     default_error_handler_$wall_ignore_pi
      163 				 entry options (variable);
      164 	dcl     get_ring_		 entry () returns (fixed bin);
      165 	dcl     fim$		 ext fixed bin;
      166 	dcl     pds$vtime_count	 fixed bin ext;
      167 	dcl     verify_lock$condition	 entry (char (*), ptr);
      168 
      169 	dcl     (addr, addrel, baseno, bin, bit, divide, length, min, max, null, pointer, rtrim, size, stackframeptr,
      170 	        string, substr, unspec)
      171 				 builtin;
      172 
      173 
      174 
      175 
  1     1 /* BEGIN INCLUDE FILE ... on_unit.incl.pl1 */
  1     2 /* coded 31 October 1973 by M. Weaver to facilitate adding flags */
  1     3 
  1     4 dcl 1 on_unit based aligned,
  1     5     2 name ptr,					/* pointer to the condition name */
  1     6     2 body ptr,					/* pointer to procedure to handle condition */
  1     7     2 size fixed bin,				/* length of the condition name */
  1     8     2 next bit (18) unaligned,			/* rel pointer to next on unit */
  1     9     2 flags unaligned,
  1    10       3 pl1_snap bit (1) unaligned,			/* "1"b indicates to call snap procedure */
  1    11       3 pl1_system bit (1) unaligned,			/* "1"b indicates to use system condition handler */
  1    12       3 pad bit (16) unaligned,
  1    13     2 file ptr;					/* ptr to file descriptor for pl1 I/O condition */
  1    14 
  1    15 /* END INCLUDE FILE ... on_unit.incl.pl1 */
      176 
      177 
      178 	dcl     char_string		 char (onlistp -> on_unit.size) aligned based (onlistp -> on_unit.name),
      179 						/* used to reference condition name in stack */
      180 	        tpp		 (2) ptr based (onlistp -> on_unit.file);
      181 						/* part of file descriptor */
      182 
      183 
  2     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  2     2 /* format: style2 */
  2     3 
  2     4      declare condition_info_header_ptr
  2     5 			      pointer;
  2     6      declare 1 condition_info_header
  2     7 			      aligned based (condition_info_header_ptr),
  2     8 	     2 length	      fixed bin,		/* length in words of this structure */
  2     9 	     2 version	      fixed bin,		/* version number of this structure */
  2    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  2    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  2    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  2    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  2    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  2    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  2    16 	       3 pad	      bit (32) unaligned,
  2    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  2    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  2    19 
  2    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      184 
      185 	dcl     1 pl1_info_struc	 based (info_ptr) aligned like pl1_info;
      186 						/* info structure for pl1 conditions */
  3     1 /* BEGIN INCLUDE FILE ... pl1_info.incl.pl1 */
  3     2 /* This is intended to be used by all procedures raising pl1 conditions and by the default handler */
  3     3 /* Created June 1981 by Benson I. Margulies from pl1_info_struc.incl.pl1 */
  3     4 /* This include file must be used with condition_info_header.incl.pl1. Both must be %included */
  3     5 
  3     6 declare pl1_info_ptr pointer;
  3     7 declare 1 pl1_info aligned based (pl1_info_ptr),
  3     8             2 header aligned like condition_info_header,
  3     9 	  2 id char(8) aligned,		/* init "pliocond"; indicates pl1 structure */
  3    10 	  2 content_flags aligned,
  3    11 	   (3 v1_sw,			/* on if raised by version 1 */
  3    12 	    3 oncode_sw,			/* "1"b->valid oncode */
  3    13 	    3 onfile_sw,			/* "1"b->file name is in structure */
  3    14 	    3 file_ptr_sw,			/* "1"b->file is associated with this condition */
  3    15 	    3 onsource_sw,			/* "1"b->valid onsource string for this condition */
  3    16 	    3 onchar_sw,			/* "1"b->valid onchar index in this structure */
  3    17 	    3 onkey_sw,			/* "1"b->valid onkey string in this structure */
  3    18 	    3 onfield_sw) bit(1) unaligned,	/* "1"b->valid onfield string in this structure */
  3    19 	  2 oncode fixed bin(35),		/* oncode for condition */
  3    20 	  2 onfile char(32) aligned,		/* onfile string */
  3    21 	  2 file_ptr ptr,			/* pointer to file value */
  3    22 	  2 onsource char(256) var,		/* onsource string */
  3    23 	  2 oncharindex fixed bin,		/* char offset in onsource of offending char */
  3    24 	  2 onkey_onfield char(256) var;	/* either onkey string or onfield string */
  3    25 
  3    26 /* END INCLUDE FILE ... pl1_info.incl.pl1 */
      187 
      188 
  4     1 /* BEGIN INCLUDE FILE its.incl.pl1
  4     2*   modified 27 July 79 by JRDavis to add its_unsigned
  4     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  4     4 
  4     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  4     6     2 pad1 bit (3) unaligned,
  4     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  4     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  4     9     2 pad2 bit (9) unaligned,
  4    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  4    11 
  4    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  4    13     2 pad3 bit (3) unaligned,
  4    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  4    15     2 pad4 bit (3) unaligned,
  4    16     2 mod bit (6) unaligned;				/* further modification */
  4    17 
  4    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  4    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  4    20     2 pad1 bit (27) unaligned,
  4    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  4    22 
  4    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  4    24     2 pad2 bit (3) unaligned,
  4    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  4    26     2 pad3 bit (3) unaligned,
  4    27     2 mod bit (6) unaligned;				/* further modification */
  4    28 
  4    29 
  4    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  4    31     2 pad1 bit (3) unaligned,
  4    32     2 segno fixed bin (15) unsigned unaligned,
  4    33     2 ringno fixed bin (3) unsigned unaligned,
  4    34     2 pad2 bit (9) unaligned,
  4    35     2 its_mod bit (6) unaligned,
  4    36 
  4    37     2 offset fixed bin (18) unsigned unaligned,
  4    38     2 pad3 bit (3) unaligned,
  4    39     2 bit_offset fixed bin (6) unsigned unaligned,
  4    40     2 pad4 bit (3) unaligned,
  4    41     2 mod bit (6) unaligned;
  4    42 
  4    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  4    44     2 pr_no fixed bin (3) unsigned unaligned,
  4    45     2 pad1 bit (27) unaligned,
  4    46     2 itp_mod bit (6) unaligned,
  4    47 
  4    48     2 offset fixed bin (18) unsigned unaligned,
  4    49     2 pad2 bit (3) unaligned,
  4    50     2 bit_offset fixed bin (6) unsigned unaligned,
  4    51     2 pad3 bit (3) unaligned,
  4    52     2 mod bit (6) unaligned;
  4    53 
  4    54 
  4    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  4    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  4    57 
  4    58 /* END INCLUDE FILE   its.incl.pl1 */
      189 
      190 
      191 	dcl     1 fim_arglist	 based aligned,
      192 		2 arg_count	 fixed bin (17) unal,
      193 		2 flag		 fixed bin (17) unal,
      194 		2 desc_count	 fixed bin (17) unal,
      195 		2 pad		 fixed bin (17) unal,
      196 		2 first_arg	 ptr;		/* ptr to machine conditions */
      197 
      198 
      199 
  5     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  5     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  5     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  5     4 /*	Modified April 1983 by C. Hornig for tasking */
  5     5 
  5     6 /****^  HISTORY COMMENTS:
  5     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  5     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  5     9*     added the heap_header_ptr definition.
  5    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  5    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  5    12*     Modified to support control point management.  These changes were actually
  5    13*     made in February 1985 by G. Palter.
  5    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  5    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  5    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  5    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  5    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  5    19*     (ITS pair).
  5    20*                                                   END HISTORY COMMENTS */
  5    21 
  5    22 /* format: style2 */
  5    23 
  5    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  5    25 
  5    26      dcl	   1 stack_header	      based (sb) aligned,
  5    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  5    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  5    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  5    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  5    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  5    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  5    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  5    34 	     2 pad4	      bit (2) unal,
  5    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  5    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  5    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  5    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  5    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  5    40 	     2 null_ptr	      ptr,		/*  (16)  */
  5    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  5    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  5    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  5    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  5    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  5    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  5    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  5    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  5    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  5    50 	     2 return_no_pop_op_ptr
  5    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  5    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  5    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  5    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  5    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  5    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  5    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  5    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  5    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  5    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  5    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  5    62 	     2 trace,
  5    63 	       3 frames,
  5    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  5    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  5    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  5    67 	     2 pad2	      bit (36),		/*  (61) */
  5    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  5    69 
  5    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  5    71 
  5    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  5    73 						/* (551) octal */
  5    74 
  5    75 
  5    76 /*	The following constants are offsets within this transfer vector table.  */
  5    77 
  5    78      dcl	   (
  5    79 	   call_offset	      fixed bin init (271),
  5    80 	   push_offset	      fixed bin init (272),
  5    81 	   return_offset	      fixed bin init (273),
  5    82 	   return_no_pop_offset   fixed bin init (274),
  5    83 	   entry_offset	      fixed bin init (275)
  5    84 	   )		      internal static;
  5    85 
  5    86 
  5    87 
  5    88 
  5    89 
  5    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  5    91*	move the whole stack header should use this overlay.
  5    92**/
  5    93 
  5    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  5    95 
  5    96 
  5    97 
  5    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      200 
      201 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  6     2 
  6     3 /* format: off */
  6     4 
  6     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  6     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  6     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  6     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  6     9 
  6    10 
  6    11 /****^  HISTORY COMMENTS:
  6    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  6    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  6    14*     Modified to add constants for the translator_id field in the stack_frame
  6    15*     structure.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 
  6    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  6    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  6    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  6    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  6    23 
  6    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  6    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  6    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  6    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  6    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  6    29 
  6    30 
  6    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  6    32 
  6    33 dcl  stack_frame_min_length fixed bin static init(48);
  6    34 
  6    35 
  6    36 dcl 1 stack_frame based(sp) aligned,
  6    37     2 pointer_registers(0 : 7) ptr,
  6    38     2 prev_sp pointer,
  6    39     2 next_sp pointer,
  6    40     2 return_ptr pointer,
  6    41     2 entry_ptr pointer,
  6    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  6    43     2 arg_ptr pointer,
  6    44     2 static_ptr ptr unaligned,
  6    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  6    46     2 on_unit_relp1 bit(18) unaligned,
  6    47     2 on_unit_relp2 bit(18) unaligned,
  6    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  6    49*						   0 => PL/I version II
  6    50*						   1 => ALM
  6    51*						   2 => PL/I version I   
  6    52*						   3 => signal caller frame
  6    53*						   4 => signaller frame */
  6    54     2 operator_return_offset bit(18) unaligned,
  6    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  6    56     2 a bit(36),					/* accumulator */
  6    57     2 q bit(36),					/* q-register */
  6    58     2 e bit(36),					/* exponent */
  6    59     2 timer bit(27) unaligned,				/* timer */
  6    60     2 pad bit(6) unaligned,
  6    61     2 ring_alarm_reg bit(3) unaligned;
  6    62 
  6    63 
  6    64 dcl 1 stack_frame_flags based(sp) aligned,
  6    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  6    66     2 xx0 bit(22) unal,
  6    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  6    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  6    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  6    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  6    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  6    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  6    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  6    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  6    75     2 xx0a bit(6) unal,
  6    76     2 xx1 fixed bin,
  6    77     2 xx2 fixed bin,
  6    78     2 xx3 bit(25) unal,
  6    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  6    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  6    81     2 xx3a bit(9) unaligned,
  6    82     2 xx4(9) bit(72) aligned,
  6    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  6    84*						*  operator puts a pointer to the base of
  6    85*						*  the calling procedure here. (text base ptr)  */
  6    86     2 xx5 bit(72) aligned,
  6    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  6    88 
  6    89 /* format: on */
  6    90 
  6    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      202 
      203 
  7     1 /*  */
  7     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  7     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  7     4 /* Modified 07/07/76 by Morris for fault register data */
  7     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  7     6 /* Modified '82 to make values constant */
  7     7 
  7     8 /* words 0-15 pointer registers */
  7     9 
  7    10 dcl  mcp ptr;
  7    11 
  7    12 dcl 1 mc based (mcp) aligned,
  7    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  7    14    (2 regs,					/* registers */
  7    15       3 x (0:7) bit (18),				/* index registers */
  7    16       3 a bit (36),					/* accumulator */
  7    17       3 q bit (36),					/* q-register */
  7    18       3 e bit (8),					/* exponent */
  7    19       3 pad1 bit (28),
  7    20       3 t bit (27),					/* timer register */
  7    21       3 pad2 bit (6),
  7    22       3 ralr bit (3),				/* ring alarm register */
  7    23 
  7    24     2 scu (0:7) bit (36),
  7    25 
  7    26     2 mask bit (72),				/* mem controller mask at time of fault */
  7    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  7    28     2 errcode fixed bin (35),				/* fault handler's error code */
  7    29     2 fim_temp,
  7    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  7    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  7    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  7    33     2 fault_reg bit (36),				/* fault register */
  7    34     2 pad2 bit (1),
  7    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  7    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  7    37     2 fault_time bit (54),				/* time of fault */
  7    38 
  7    39     2 eis_info (0:7) bit (36)) unaligned;
  7    40 
  7    41 
  7    42 dcl (apx fixed bin init (0),
  7    43      abx fixed bin init (1),
  7    44      bpx fixed bin init (2),
  7    45      bbx fixed bin init (3),
  7    46      lpx fixed bin init (4),
  7    47      lbx fixed bin init (5),
  7    48      spx fixed bin init (6),
  7    49      sbx fixed bin init (7)) internal static options (constant);
  7    50 
  7    51 
  7    52 
  7    53 
  7    54 dcl  scup ptr;
  7    55 
  7    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  7    57 
  7    58 
  7    59 /*	WORD (0)		*/
  7    60 
  7    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  7    62       3 prr bit (3),				/* procedure ring register */
  7    63       3 psr bit (15),				/* procedure segment register */
  7    64       3 p bit (1),					/* procedure privileged bit */
  7    65 
  7    66     2 apu,					/* APPENDING UNIT STATUS */
  7    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  7    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  7    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  7    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  7    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  7    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  7    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  7    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  7    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  7    76       3 ptw bit (1),				/* Fetch of PTW */
  7    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  7    78       3 fap bit (1),				/* Fetch of final address paged */
  7    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  7    80       3 fabs bit (1),				/* Fetch of final address absolute */
  7    81 
  7    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  7    83 
  7    84 
  7    85 /*	WORD (1)		*/
  7    86 
  7    87     2 fd,						/* FAULT  DATA */
  7    88       3 iro bit (1),				/* illegal ring order */
  7    89       3 oeb bit (1),				/* out of execute bracket */
  7    90       3 e_off bit (1),				/* no execute */
  7    91       3 orb bit (1),				/* out of read bracket */
  7    92       3 r_off bit (1),				/* no read */
  7    93       3 owb bit (1),				/* out of write bracket */
  7    94       3 w_off bit (1),				/* no write */
  7    95       3 no_ga bit (1),				/* not a gate */
  7    96       3 ocb bit (1),				/* out of call bracket */
  7    97       3 ocall bit (1),				/* outward call */
  7    98       3 boc bit (1),				/* bad outward call */
  7    99       3 inret bit (1),				/* inward return */
  7   100       3 crt bit (1),				/* cross ring transfer */
  7   101       3 ralr bit (1),				/* ring alarm register */
  7   102       3 am_er bit (1),				/* associative memory fault */
  7   103       3 oosb bit (1),				/* out of segment bounds */
  7   104       3 paru bit (1),				/* processor parity upper */
  7   105       3 parl bit (1),				/* processor parity lower */
  7   106       3 onc_1 bit (1),				/* op not complete type 1 */
  7   107       3 onc_2 bit (1),				/* op not complete type 2 */
  7   108 
  7   109     2 port_stat,					/* PORT  STATUS */
  7   110       3 ial bit (4),				/* illegal action lines */
  7   111       3 iac bit (3),				/* illegal action channel */
  7   112       3 con_chan bit (3),				/* connect channel */
  7   113 
  7   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  7   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  7   116 
  7   117 
  7   118 /*	WORD (2)		*/
  7   119 
  7   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  7   121       3 trr bit (3),				/* temporary ring register */
  7   122       3 tsr bit (15),				/* temporary segment register */
  7   123 
  7   124     2 pad2 bit (9),
  7   125 
  7   126     2 cpu_no bit (3),				/* CPU number */
  7   127 
  7   128     2 delta bit (6),				/* tally modification DELTA */
  7   129 
  7   130 
  7   131 /*	WORD (3)		*/
  7   132 
  7   133     2 word3 bit (18),
  7   134 
  7   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  7   136       3 tsna,					/* Word 1 status */
  7   137         4 prn bit (3),				/* Word 1  PR  number */
  7   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  7   139       3 tsnb,					/* Word 2  status */
  7   140         4 prn bit (3),				/* Word 2  PR  number */
  7   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  7   142       3 tsnc,					/* Word 3  status */
  7   143         4 prn bit (3),				/* Word 3  PR  number */
  7   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  7   145 
  7   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  7   147 
  7   148 
  7   149 /* 	WORD (4)		*/
  7   150 
  7   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  7   152 
  7   153     2 ir,						/* INDICATOR  REGISTERS */
  7   154       3 zero bit (1),				/* zero indicator */
  7   155       3 neg bit (1),				/* negative indicator */
  7   156       3 carry bit (1),				/* carryry indicator */
  7   157       3 ovfl bit (1),				/* overflow indicator */
  7   158       3 eovf bit (1),				/* eponent overflow */
  7   159       3 eufl bit (1),				/* exponent underflow */
  7   160       3 oflm bit (1),				/* overflow mask */
  7   161       3 tro bit (1),				/* tally runout */
  7   162       3 par bit (1),				/* parity error */
  7   163       3 parm bit (1),				/* parity mask */
  7   164       3 bm bit (1),					/* ^bar mode */
  7   165       3 tru bit (1),				/* truncation mode */
  7   166       3 mif bit (1),				/* multi-word instruction mode */
  7   167       3 abs bit (1),				/* absolute mode */
  7   168       3 hex bit (1),				/* hexadecimal exponent mode */
  7   169       3 pad bit (3),
  7   170 
  7   171 
  7   172 /*	WORD (5)		*/
  7   173 
  7   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  7   175 
  7   176     2 cu,						/* CONTROL UNIT STATUS */
  7   177       3 rf bit (1),					/* on first cycle of repeat instr */
  7   178       3 rpt bit (1),				/* repeat instruction */
  7   179       3 rd bit (1),					/* repeat double instruction */
  7   180       3 rl bit (1),					/* repeat link instruciton */
  7   181       3 pot bit (1),				/* IT  modification */
  7   182       3 pon bit (1),				/* return type instruction */
  7   183       3 xde bit (1),				/* XDE from Even location */
  7   184       3 xdo bit (1),				/* XDE from Odd  location */
  7   185       3 poa bit (1),				/* operation preparation */
  7   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  7   187       3 its bit (1),				/* ITS modification */
  7   188       3 if bit (1),					/* fault occured during instruction fetch */
  7   189 
  7   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  7   191 
  7   192 
  7   193 /*	WORDS (6,7)	*/
  7   194 
  7   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  7   196 
  7   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  7   198 
  7   199 
  7   200 
  7   201 
  7   202 
  7   203 
  7   204 /*	ALTERNATE   SCU  DECLARATION		*/
  7   205 
  7   206 
  7   207 dcl 1 scux based (scup) aligned,
  7   208 
  7   209    (2 pad0 bit (36),
  7   210 
  7   211     2 fd,						/* GROUP II  FAULT DATA */
  7   212       3 isn bit (1),				/* illegal segment number */
  7   213       3 ioc bit (1),				/* illegal op  code  */
  7   214       3 ia_am bit (1),				/* illegal address - modifier */
  7   215       3 isp bit (1),				/* illegal slave  procedure */
  7   216       3 ipr bit (1),				/* illegal procedure */
  7   217       3 nea bit (1),				/* non existent address */
  7   218       3 oobb bit (1),				/* out of bounds */
  7   219       3 pad bit (29),
  7   220 
  7   221     2 pad2 bit (36),
  7   222 
  7   223     2 pad3a bit (18),
  7   224 
  7   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  7   226       3 prn bit (3),				/* PR  number */
  7   227       3 prv bit (1),				/* PR  valid bit */
  7   228 
  7   229     2 pad3b bit (6)) unaligned,
  7   230 
  7   231     2 pad45 (0:1) bit (36),
  7   232 
  7   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  7   234 
  7   235 
  7   236 
  7   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      204 
      205 
      206 
      207 common:						/* to all except io */
      208 	io = "0"b;				/* not i/o condition */
      209 
      210 	go to join;				/* join common code */
      211 
      212 /* This entry is called when signalling certain io conditions so that only the
      213*   handler pertaining to a certain file is invoked */
      214 
      215 io_signal:
      216      entry (a_name, a_mcptr, a_info_ptr);
      217 
      218 	io = "1"b;
      219 
      220 /* The arg count stuff below just happens to work for this entrypoint */
      221 
      222 
      223 /* Initialize variables.  Find out how many arguments were supplied in call
      224*   to signal_.  Copy the ones supplied and provide dummy values for the others.
      225**/
      226 join:
      227 	on any_other call terminate_minus_2 (-2);
      228 
      229 	call arg_count_ (args);			/* get number or arguments */
      230 
      231 	mcptr, info_ptr, wcptr = null;
      232 
      233 	args = max (min (args, 4), 0);		/* Force computed goto safety */
      234 
      235 	goto ARGS (args);
      236 
      237 ARGS (4):
      238 	wcptr = a_wcptr;
      239 
      240 ARGS (3):
      241 	info_ptr = a_info_ptr;
      242 ARGS (2):
      243 	mcptr = a_mcptr;
      244 ARGS (1):
      245 ARGS (0):
      246 /**** Find the point on the stack from which we will start to signal.
      247*      set the "signal" bit so that find_condition_info_ and continue_to_signal_
      248*      will work in static handlers. The rest of these variables
      249*      will be used after the static handler case is dealt with. */
      250 	next_sp, my_sp = stackframeptr ();		/* Extract our stack pointer */
      251 	sp = my_sp -> stack_frame.prev_sp;		/* Start from the previous stack frame. */
      252 
      253 	my_sp -> stack_frame_flags.signal = "1"b;	/* indicate this is signal frame */
      254 	my_sp -> stack_frame_flags.support = "1"b;	/* use option when available */
      255 
      256 	if mcptr ^= null & ^io & static_okay
      257 	then do;
      258 		continue = "0"b;			/* default is to not continue. */
      259 		revert any_other;			/* may resignal */
      260 		call sct_manager_$call_handler (mcptr, a_name, info_ptr, wcptr, continue);
      261 /**** Note that continue_to_signal_ will find this continue bit and set it 
      262*      for the handler. */
      263 
      264 		if ^continue
      265 		then return;
      266 
      267 		on any_other call terminate_minus_2 (-2);
      268 	     end;
      269 
      270 	l_name = length (rtrim (a_name));		/* Get true length of condition name. */
      271 	condition_name = substr (a_name, 1, l_name);	/* Copy the condition name into stack. */
      272 	null_pointer_condition = (condition_name = "null_pointer");
      273 
      274 	if io
      275 	then do;					/* used io_signal entry */
      276 		filep = info_ptr;			/* info_ptr points directly to file */
      277 		info_ptr = null;			/* dont dare crawl out with info_ptr set the way it was */
      278 	     end;
      279 	else if info_ptr ^= null
      280 	then if pl1_info_struc.id = "pliocond"
      281 	     then if pl1_info_struc.content_flags.file_ptr_sw
      282 		then do;
      283 			filep = pl1_info_struc.file_ptr;
      284 			io = "1"b;		/* have to look for file as well as condition */
      285 		     end;
      286 
      287 
      288 /* Search back down the stack, examining each frame. */
      289 
      290 stack_loop:
      291 /**** Search the condition stack.  When an on unit for this condition is found,
      292*   call the indicated handler.  Unless the variable "continue" is set
      293*   by the handler, signal_ will then return to its caller.  If "continue"
      294*   is set, signal_ will continue the search down the stack.			*/
      295 	if sp -> stack_frame_flags.condition
      296 	then do;					/* Has any condition been set in this frame? */
      297 		onlistrel = sp -> stack_frame.on_unit_relp1;
      298 						/* Get start of on list thread. */
      299 		unclp = null;			/* Initialize pointer to unclaimed_signal unit. */
      300 		oldp = null;			/* Initialize pointer to previous on unit. */
      301 		ou_count = 0;			/* initialize on unit count */
      302 
      303 		do while (onlistrel);		/* Search the on unit thread. */
      304 		     onlistp = addrel (sp, onlistrel);	/* Generate a pointer to the on unit. */
      305 
      306 		     if found_specific_condition (l_name, condition_name, onlistp)
      307 		     then do;
      308 			     if io
      309 			     then /* If an I/O condition ... */
      310 				if onlistp -> on_unit.file -> tpp (2) ^= filep -> tpp (2)
      311 				then go to skip_invoke;
      312 						/* Skip invocation if not the desired file. */
      313 
      314 			     revert any_other;
      315 			     call caller (onlistp);	/* Invoke the handler. */
      316 			     on any_other call terminate_minus_2 (-2);
      317 			     goto end_loop;		/* continue up the stack */
      318 			end;
      319 
      320 		     if onlistp -> on_unit.size = length ("any_other")
      321 		     then if onlistp -> on_unit.name -> char_string = "any_other"
      322 			then /* is this "any_other" */
      323 			     unclp = onlistp;	/* save loc'n of on unit for any_other */
      324 
      325 		     if onlistp -> on_unit.size = length ("unclaimed_signal")
      326 		     then /* Is this "unclaimed_signal"? */
      327 			if onlistp -> on_unit.name -> char_string = "unclaimed_signal"
      328 			then unclp = onlistp;	/* Save loc'n of on unit for unclaimed signal. */
      329 
      330 
      331 skip_invoke:
      332 		     oldp = onlistp;		/* Save pointer to previous on unit. */
      333 		     onlistrel = onlistp -> on_unit.next;
      334 						/* Step to next unit and continue. */
      335 		     ou_count = ou_count + 1;		/* increment count of on units */
      336 		     if ou_count > 200
      337 		     then call terminate_minus_2 (-2);
      338 
      339 /* term process if too many */
      340 		end;
      341 
      342 
      343 /* If the desired on unit was not found, check for an unclaimed_signal
      344*   handler or for a default handler.  If unwinding, check for a cleanup
      345*   handler.							*/
      346 
      347 		if unclp ^= null
      348 		then /* If there is an unclaimed_signal handler ... */
      349 		     do;
      350 			revert any_other;
      351 			call caller (unclp);	/* Invoke the unclaimed signal handler. */
      352 			on any_other call terminate_minus_2 (-2);
      353 		     end;
      354 	     end;
      355 
      356 
      357 /* Step back to the next stack frame.  Determine if the previous stack frame
      358*   is in another stack segment.  If not, continue looping.				*/
      359 
      360 end_loop:
      361 	next_sp = sp;				/* Save pointer to this stack frame. */
      362 	sp = sp -> stack_frame.prev_sp;		/* Step stack pointer back to previous frame. */
      363 	loops = loops + 1;				/* increment count of stack frames found */
      364 	if loops > 5000
      365 	then call terminate_minus_2 (-2);
      366 
      367 	if baseno (next_sp) = baseno (sp)
      368 	then goto stack_loop;			/* Continue search if on same stack. */
      369 
      370 
      371 /* The signal was unclaimed on this stack.  If possible, an attempt
      372*   will be made to signal this condition on the calling stack.
      373*   This will be done by simulating a call to signal_ on that stack.		*/
      374 
      375 end_scan:
      376 	if sp = null
      377 	then call terminate_minus_2 (-2);
      378 
      379 /* before we crawl out, see if the system default handling is nonfatal;
      380*   if so, do it and return */
      381 
      382 	retsw = "0"b;
      383 	revert any_other;
      384 	call crawlout_default_handler_ (mcptr, substr (condition_name, 1, l_name), wcptr, info_ptr, retsw);
      385 	if retsw
      386 	then go to return;				/* assume condition was handled adequately */
      387 	on any_other call terminate_minus_2 (-2);
      388 
      389 
      390 /* If signalling, we must unwind to get to the calling stack. */
      391 	call unwind_stack_ (my_sp, null, code);		/* code always 0 in this case */
      392 
      393 /* In case there are access/parity problems with stack, set up any_other handler to terminate process.
      394*   The any_other handler will be reverted  on call to non_local_goto_$different_ring */
      395 
      396 	on any_other call terminate_minus_2 (-5);	/* -5 will be translated to error_table_$bad_stack_access by terminate_proc */
      397 
      398 /* Construct a new stack frame on the calling stack.  This frame will contain
      399*   an argument list and arguments for a call to signal_. 			*/
      400 
      401 	sb = pointer (sp, "0"b);			/* Get pointer to base of outer ring stack. */
      402 	prev_sp = sp;				/* Save pointer to last frame on that stack. */
      403 	sp = sb -> stack_header.stack_end_ptr;		/* Get pointer to new frame. */
      404 	signal_caller_frame_size = size (signal_caller_frame) - 1;
      405 						/* Compute min length of signal_caller stack frame */
      406 
      407 	sp -> stack_frame.prev_sp = prev_sp;		/* Thread new frame in. */
      408 	sp -> stack_frame_flags.condition = "0"b;	/* "prev_sp" may have had condition bit set. */
      409 	sp -> stack_frame_flags.crawl_out = "1"b;	/* indicate we're doing a crawl out */
      410 	sp -> stack_frame_flags.support = "1"b;
      411 
      412 
      413 /* Set up stack variables in signal caller frame. */
      414 
      415 	if mcptr ^= null
      416 	then do;					/* If machine conditions were supplied ... */
      417 		signal_caller_frame.machine_conditions = mcptr -> based_machine_conditions;
      418 						/* Copy the machine conditions into our frame. */
      419 		signal_caller_frame.mcptr = addr (signal_caller_frame.machine_conditions);
      420 						/* Set pointer in caller frame. */
      421 	     end;
      422 	else /* Otherwise, set null ptr. */
      423 	     signal_caller_frame.mcptr = null;
      424 
      425 /* copy conditions from system fault in outer ring if available */
      426 
      427 	if get_ring_ () = 0
      428 	then do;					/* fim doesn't operate in other rings */
      429 
      430 		call verify_lock$condition (condition_name, mcptr);
      431 						/* Unlock all locks in Ring 0 */
      432 
      433 		pds$vtime_count = -1;		/* Reset virtual time counters. */
      434 
      435 		if ^next_sp -> stack_frame_flags.signaller
      436 		     & baseno (next_sp -> stack_frame.return_ptr) = baseno (addr (fim$))
      437 		then do;
      438 			arglistptr = next_sp -> stack_frame.next_sp -> stack_frame.arg_ptr;
      439 						/* get ptr to callee's arg list */
      440 			unclp = arglistptr -> fim_arglist.first_arg -> based_ptr;
      441 						/* first arg points to mc */
      442 
      443 /* be sure that wall crossing conditions are relevant for target ring */
      444 			if addr (unclp -> mc.scu (0)) -> scu.ppr.prr ^= addr (sp) -> its.ringno
      445 			then go to no_wc;		/* not for target ring */
      446 			signal_caller_frame.wcptr = addr (signal_caller_frame.additions);
      447 			signal_caller_frame.wcptr -> based_machine_conditions = unclp -> based_machine_conditions;
      448 			signal_caller_frame_size = signal_caller_frame_size + size (mc);
      449 						/* add length of wc */
      450 		     end;
      451 		else go to no_wc;
      452 
      453 	     end;					/* end of checks for ring 0 */
      454 
      455 	else
      456 no_wc:
      457 	     signal_caller_frame.wcptr = null;
      458 
      459 /* copy info structure into outer ring */
      460 	if info_ptr ^= null
      461 	then do;					/* there is a structure to copy */
      462 		signal_caller_frame.infoptr = addrel (sp, signal_caller_frame_size);
      463 		signal_caller_frame.infoptr -> based_array = info_ptr -> based_array;
      464 		signal_caller_frame_size = signal_caller_frame_size + info_ptr -> pl1_info_struc.length;
      465 						/* all info structures have length first */
      466 	     end;
      467 	else signal_caller_frame.infoptr = null;	/* indicate no structure */
      468 
      469 	signal_caller_frame_size = divide (signal_caller_frame_size + 15, 16, 18, 0) * 16;
      470 						/* round size up to nearest 16 */
      471 
      472 	next_sp,					/* Set new pointer to end of stack. */
      473 	     sb -> stack_header.stack_end_ptr, sp -> stack_frame.next_sp = addrel (sp, signal_caller_frame_size);
      474 
      475 	sp -> stack_frame_flags.old_crawl_out = "1"b;	/* must set after next_sp */
      476 
      477 	string (signal_caller_frame.mcptr_desc) = "0"b;	/* Set descriptor for mcptr. */
      478 	signal_caller_frame.mcptr_desc.flag = "1"b;
      479 	signal_caller_frame.mcptr_desc.type = bit (bin (13, 6), 6);
      480 
      481 	string (signal_caller_frame.infoptr_desc) = "0"b; /* Set descriptor for infoptr */
      482 	signal_caller_frame.infoptr_desc.flag = "1"b;
      483 	signal_caller_frame.infoptr_desc.type = bit (bin (13, 6), 6);
      484 
      485 	string (signal_caller_frame.wcptr_desc) = "0"b;	/* Set descriptor for wcptr */
      486 	signal_caller_frame.wcptr_desc.flag = "1"b;
      487 	signal_caller_frame.wcptr_desc.type = bit (bin (13, 6), 6);
      488 
      489 /* set translator id to special value (3) for debugging */
      490 	signal_caller_frame.translator_id = bit (bin (3, 18), 18);
      491 	signal_caller_frame.entry_ptr = null;		/* so won't be confused by garbage */
      492 	signal_caller_frame.condition_name = condition_name;
      493 						/* Place condition name in caller frame. */
      494 
      495 	string (signal_caller_frame.condition_name_desc) = "0"b;
      496 						/* Set descriptor for condition_name. */
      497 	signal_caller_frame.condition_name_desc.flag = "1"b;
      498 	signal_caller_frame.condition_name_desc.type = bit (bin (21, 6), 6);
      499 	signal_caller_frame.condition_name_desc.size = bit (bin (l_name, 24), 24);
      500 
      501 
      502 /* Set argument list to signal_. */
      503 
      504 	signal_caller_frame.arglist.arg_count = 8;	/* Four arguments. */
      505 	signal_caller_frame.arglist.flag = 4;		/* Indicate PL/1 call. */
      506 	signal_caller_frame.arglist.desc_count = 8;	/* Four descriptors. */
      507 	signal_caller_frame.arglist.pad = 0;
      508 
      509 	signal_caller_frame.arglist.condition_name_ptr = addr (signal_caller_frame.condition_name);
      510 	signal_caller_frame.arglist.mcptr_ptr = addr (signal_caller_frame.mcptr);
      511 	signal_caller_frame.arglist.infoptr_ptr = addr (signal_caller_frame.infoptr);
      512 	signal_caller_frame.arglist.wcptr_ptr = addr (signal_caller_frame.wcptr);
      513 	signal_caller_frame.arglist.condition_name_desc_ptr = addr (signal_caller_frame.condition_name_desc);
      514 	signal_caller_frame.arglist.mcptr_desc_ptr = addr (signal_caller_frame.mcptr_desc);
      515 	signal_caller_frame.arglist.infoptr_desc_ptr = addr (signal_caller_frame.infoptr_desc);
      516 	signal_caller_frame.arglist.wcptr_desc_ptr = addr (signal_caller_frame.wcptr_desc);
      517 
      518 
      519 /* Set operator pointer in caller frame to point to argument list.
      520*   The unwinder will place this value in ap when it performs the
      521*   non-local goto.  Beware --- THIS IS A KLUDGE.				*/
      522 
      523 	stack_frame.operator_and_lp_ptr = addr (signal_caller_frame.arglist);
      524 
      525 	sp -> stack_frame.return_ptr = sb -> stack_header.signal_ptr;
      526 						/* Set return pointer to enter signal_. */
      527 
      528 
      529 /* Perform a non-local goto be calling the unwinder_'s ALM utility routine. */
      530 
      531 	call nonlocal_goto_$different_ring (sp, sp -> stack_frame.return_ptr);
      532 						/* Call signal_ again on target stack */
      533 
      534 
      535 
      536 	return;
      537 
      538 
      539 /* CALLER - Internal procedure to call handler */
      540 
      541 caller:
      542      proc (p);
      543 
      544 	dcl     p			 ptr;
      545 	declare entry_variable	 entry variable options (variable);
      546 
      547 	declare 1 entry_overlay	 aligned,
      548 		2 codeptr		 pointer,
      549 		2 environmentptr	 pointer;
      550 
      551 	if p -> on_unit.flags.pl1_snap
      552 	then call pl1_snap_ (condition_name);		/* perform snap */
      553 
      554 	if p -> on_unit.flags.pl1_system
      555 	then /* use system's handler */
      556 	     entry_overlay.codeptr = addr (default_error_handler_$wall_ignore_pi);
      557 	else entry_overlay.codeptr = p -> on_unit.body;	/* otherwise use entry from on unit */
      558 
      559 	entry_overlay.environmentptr = sp;
      560 	unspec (entry_variable) = unspec (entry_overlay);
      561 
      562 	continue = "0"b;				/* clear the continue flag */
      563 	call entry_variable (mcptr, substr (condition_name, 1, l_name), wcptr, info_ptr, continue);
      564 						/* call the handler */
      565 /**** Note that continue_to_signal_ will reach into the arglist and
      566*      change the continue bit. */
      567 
      568 	if ^continue
      569 	then go to return;				/* if finished, then return from signal_ */
      570 
      571 	return;					/* return to caller for more searching */
      572 
      573      end caller;
      574 
      575 found_specific_condition:
      576      procedure (name_length, name, on_unit_ptr) returns (bit (1) aligned);
      577 
      578 	declare name_length		 fixed bin;	/* number of non-spaces leading in name */
      579 	declare name		 character (*);	/* name of condition sought */
      580 	declare on_unit_ptr		 pointer;		/* unit under scrutiny */
      581 
      582 	declare 1 OU		 aligned like on_unit based (on_unit_ptr);
      583 	declare on_unit_name	 character (OU.size) based (OU.name) aligned;
      584 
      585 	if name_length = length (on_unit_name)
      586 	then if condition_name = on_unit_name
      587 	     then return ("1"b);			/* really there */
      588 	if null_pointer_condition			/* global bit flag to avoid repeating this test */
      589 	then if length (on_unit_name) = length ("simfault_000000")
      590 	     then if substr (on_unit_name, 1, length ("simfault_")) = "simfault_"
      591 		then return ("1"b);
      592 	return ("0"b);				/* no such luck */
      593      end found_specific_condition;
      594 
      595 return:
      596 	return;					/* return to caller of signal_ */
      597 
      598 terminate_minus_2:
      599      procedure (offset);
      600 	declare offset		 fixed bin;
      601 	declare baseptr		 builtin;
      602 	declare killer_ptr		 pointer;
      603 	declare killer		 fixed bin (35) aligned based (killer_ptr);
      604 
      605 	killer_ptr = pointer (baseptr (-2), offset);
      606 	killer = 0;
      607      end terminate_minus_2;
      608      end signal_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.2  signal_.pl1                       >spec>install>1110>signal_.pl1
176          1    05/06/74  1742.5  on_unit.incl.pl1                  >ldd>include>on_unit.incl.pl1
184          2    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
187          3    07/18/81  1100.0  pl1_info.incl.pl1                 >ldd>include>pl1_info.incl.pl1
189          4    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
200          5    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
202          6    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
204          7    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
OU                                     based           structure                level 1 dcl 582
a_info_ptr                             parameter       pointer                  dcl 69 ref 62 62 215 240
a_mcptr                                parameter       pointer                  dcl 69 ref 62 62 215 242
a_name                                 parameter       char                     packed unaligned dcl 69 set ref 62 62 215 260* 270
                                                                                  271
a_wcptr                                parameter       pointer                  dcl 69 ref 62 62 237
additions               174            based           fixed bin(17,0)          level 2 dcl 120 set ref 446
addr                                                   builtin function         dcl 169 ref 419 435 444 444 446 509 510 511 512 513
                                                                                  514 515 516 523 554
addrel                                                 builtin function         dcl 169 ref 304 462 472
any_other                       000154 stack reference condition                dcl 102 ref 226 259 267 314 316 350 352 383 387 396
arg_count               152            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 120 set ref 504*
arg_count_                      000010 constant        entry                    external dcl 153 ref 229
arg_ptr                  32            based           pointer                  level 2 dcl 6-36 ref 438
arglist                 152            based           structure                level 2 dcl 120 set ref 523
arglistptr                      000140 automatic       pointer                  dcl 74 set ref 438* 440
args                            000142 automatic       fixed bin(17,0)          dcl 74 set ref 229* 233* 233 235
based_array                            based           fixed bin(35,0)          array dcl 109 set ref 463* 463
based_machine_conditions               based           structure                level 1 dcl 104 set ref 417 447* 447
based_ptr                              based           pointer                  dcl 107 ref 440
baseno                                                 builtin function         dcl 169 ref 367 367 435 435
baseptr                                                builtin function         dcl 601 ref 605
bin                                                    builtin function         dcl 169 ref 479 483 487 490 498 499
bit                                                    builtin function         dcl 169 ref 479 483 487 490 498 499
body                      2            based           pointer                  level 2 dcl 1-4 ref 557
char_string                            based           char                     dcl 178 ref 320 325
code                            000121 automatic       fixed bin(35,0)          dcl 74 set ref 391*
codeptr                         000200 automatic       pointer                  level 2 dcl 547 set ref 554* 557*
condition                20(29)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 set ref 290
                                                                                  408*
condition_info_header                  based           structure                level 1 dcl 2-6
condition_name                  000106 automatic       char(32)                 packed unaligned dcl 74 in procedure "signal_" set
                                                                                  ref 271* 272 306* 384 384 430* 492 551* 563 563
                                                                                  585
condition_name          136            based           char(32)                 level 2 in structure "signal_caller_frame" dcl 120
                                                                                  in procedure "signal_" set ref 492* 509
condition_name_desc     146            based           structure                level 2 dcl 120 set ref 495* 513
condition_name_desc_ptr
                        164            based           pointer                  level 3 dcl 120 set ref 513*
condition_name_ptr      154            based           pointer                  level 3 dcl 120 set ref 509*
content_flags           107            based           structure                level 2 dcl 185
continue                        000151 automatic       bit(1)                   dcl 74 set ref 258* 260* 264 562* 563* 568
crawl_out                20(25)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 set ref
                                                                                  409*
crawlout_default_handler_       000020 constant        entry                    external dcl 159 ref 384
default_error_handler_$wall_ignore_pi
                                000024 constant        entry                    external dcl 162 set ref 554
desc_count              153            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 120 set ref 506*
descriptor                             based           structure                level 1 dcl 112
divide                                                 builtin function         dcl 169 ref 469
entry_overlay                   000200 automatic       structure                level 1 dcl 547 set ref 560
entry_ptr                26            based           pointer                  level 3 dcl 120 set ref 491*
entry_variable                  000174 automatic       entry variable           dcl 545 set ref 560* 563
environmentptr            2     000200 automatic       pointer                  level 2 dcl 547 set ref 559*
file                      6            based           pointer                  level 2 dcl 1-4 ref 308
file_ptr                122            based           pointer                  level 2 dcl 185 ref 283
file_ptr_sw             107(03)        based           bit(1)                   level 3 packed packed unaligned dcl 185 ref 279
filep                           000136 automatic       pointer                  dcl 74 set ref 276* 283* 308
fim$                            000030 external static fixed bin(17,0)          dcl 165 set ref 435
fim_arglist                            based           structure                level 1 dcl 191
first_arg                 2            based           pointer                  level 2 dcl 191 ref 440
flag                    146            based           bit(1)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 497*
flag                    147            based           bit(1)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 478*
flag                    151            based           bit(1)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 486*
flag                    152(18)        based           fixed bin(17,0)          level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 505*
flag                    150            based           bit(1)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 482*
flags                     5(18)        based           structure                level 2 packed packed unaligned dcl 1-4
frame_header                           based           structure                level 2 dcl 120
get_ring_                       000026 constant        entry                    external dcl 164 ref 427
header                                 based           structure                level 2 dcl 185
id                      105            based           char(8)                  level 2 dcl 185 ref 279
info_ptr                        000102 automatic       pointer                  dcl 74 set ref 231* 240* 260* 276 277* 279 279 279
                                                                                  283 384* 460 463 463 464 563*
infoptr                 132            based           pointer                  level 2 dcl 120 set ref 462* 463 467* 511
infoptr_desc            150            based           structure                level 2 dcl 120 set ref 481* 515
infoptr_desc_ptr        170            based           pointer                  level 3 dcl 120 set ref 515*
infoptr_ptr             160            based           pointer                  level 3 dcl 120 set ref 511*
io                              000147 automatic       bit(1)                   dcl 74 set ref 207* 218* 256 274 284* 308
its                                    based           structure                level 1 dcl 4-5
killer                                 based           fixed bin(35,0)          dcl 603 set ref 606*
killer_ptr                      000100 automatic       pointer                  dcl 602 set ref 605* 606
l_name                          000116 automatic       fixed bin(17,0)          dcl 74 set ref 270* 271 306* 384 384 499 563 563
length                                 based           fixed bin(17,0)          level 2 in structure "condition_info_header" dcl 2-6
                                                                                  in procedure "signal_" ref 463
length                                 based           fixed bin(17,0)          level 3 in structure "pl1_info_struc" dcl 185
                                                                                  in procedure "signal_" ref 464
length                                                 builtin function         dcl 169 in procedure "signal_" ref 270 320 325 585
                                                                                  588 588 588
loops                           000117 automatic       fixed bin(17,0)          initial dcl 74 set ref 74* 363* 363 364
machine_conditions       50            based           structure                level 2 dcl 120 set ref 417* 419
max                                                    builtin function         dcl 169 ref 233
mc                                     based           structure                level 1 dcl 7-12 set ref 448
mcp                                    automatic       pointer                  dcl 7-10 ref 448
mcptr                   130            based           pointer                  level 2 in structure "signal_caller_frame" dcl 120
                                                                                  in procedure "signal_" set ref 419* 422* 510
mcptr                           000100 automatic       pointer                  dcl 74 in procedure "signal_" set ref 231* 242* 256
                                                                                  260* 384* 415 417 430* 563*
mcptr_desc              147            based           structure                level 2 dcl 120 set ref 477* 514
mcptr_desc_ptr          166            based           pointer                  level 3 dcl 120 set ref 514*
mcptr_ptr               156            based           pointer                  level 3 dcl 120 set ref 510*
min                                                    builtin function         dcl 169 ref 233
my_sp                           000134 automatic       pointer                  dcl 74 set ref 244* 251 253 254 391*
name                                   based           pointer                  level 2 in structure "OU" dcl 582 in procedure
                                                                                  "found_specific_condition" ref 585 585 588 588
name                                   based           pointer                  level 2 in structure "on_unit" dcl 1-4 in procedure
                                                                                  "signal_" ref 320 325
name                                   parameter       char                     packed unaligned dcl 579 in procedure
                                                                                  "found_specific_condition" ref 575
name_length                            parameter       fixed bin(17,0)          dcl 578 ref 575 585
next                      5            based           bit(18)                  level 2 packed packed unaligned dcl 1-4 ref 333
next_sp                         000132 automatic       pointer                  dcl 74 in procedure "signal_" set ref 244* 360* 367
                                                                                  435 435 438 472*
next_sp                  22            based           pointer                  level 2 in structure "stack_frame" dcl 6-36
                                                                                  in procedure "signal_" set ref 438 472*
nonlocal_goto_$different_ring   000016 constant        entry                    external dcl 157 ref 531
null                                                   builtin function         dcl 169 ref 231 256 277 279 299 300 347 375 391 391
                                                                                  415 422 455 460 467 491
null_pointer_condition          000153 automatic       bit(1)                   dcl 101 set ref 272* 588
offset                                 parameter       fixed bin(17,0)          dcl 600 ref 598 605
old_crawl_out            23(25)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 set ref
                                                                                  475*
oldp                            000126 automatic       pointer                  dcl 74 set ref 300* 331*
on_unit                                based           structure                level 1 dcl 1-4
on_unit_name                           based           char                     dcl 583 ref 585 585 588 588
on_unit_ptr                            parameter       pointer                  dcl 580 ref 575 585 585 585 585 588 588 588 588
on_unit_relp1            36            based           bit(18)                  level 2 packed packed unaligned dcl 6-36 ref 297
onlistp                         000122 automatic       pointer                  dcl 74 set ref 304* 306* 308 315* 320 320 320 320
                                                                                  325 325 325 325 331 333
onlistrel                       000124 automatic       bit(18)                  packed unaligned dcl 74 set ref 297* 303 304 333*
operator_and_lp_ptr      30            based           pointer                  level 2 dcl 6-36 set ref 523*
ou_count                        000120 automatic       fixed bin(17,0)          dcl 74 set ref 301* 335* 335 336
p                                      parameter       pointer                  dcl 544 ref 541 551 554 557
pad                     153(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 120 set ref 507*
pds$vtime_count                 000032 external static fixed bin(17,0)          dcl 166 set ref 433*
pl1_info                               based           structure                level 1 dcl 3-7
pl1_info_struc                         based           structure                level 1 dcl 185
pl1_snap                  5(18)        based           bit(1)                   level 3 packed packed unaligned dcl 1-4 ref 551
pl1_snap_                       000022 constant        entry                    external dcl 161 ref 551
pl1_system                5(19)        based           bit(1)                   level 3 packed packed unaligned dcl 1-4 ref 554
pointer                                                builtin function         dcl 169 ref 401 605
ppr                                    based           structure                level 2 packed packed unaligned dcl 7-56
prev_sp                         000130 automatic       pointer                  dcl 74 in procedure "signal_" set ref 402* 407
prev_sp                  20            based           pointer                  level 2 in structure "stack_frame" dcl 6-36
                                                                                  in procedure "signal_" set ref 251 362 407*
prr                                    based           bit(3)                   level 3 packed packed unaligned dcl 7-56 ref 444
retsw                           000150 automatic       bit(1)                   dcl 74 set ref 382* 384* 385
return_ptr               24            based           pointer                  level 2 dcl 6-36 set ref 435 525* 531*
ringno                    0(18)        based           bit(3)                   level 2 packed packed unaligned dcl 4-5 ref 444
rtrim                                                  builtin function         dcl 169 ref 270
sb                              000162 automatic       pointer                  dcl 5-24 set ref 401* 403 472 525
sct_manager_$call_handler       000012 constant        entry                    external dcl 154 ref 260
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 7-12 in procedure "signal_" set ref
                                                                                  444
scu                                    based           structure                level 1 dcl 7-56 in procedure "signal_"
signal                   20(24)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 set ref
                                                                                  253*
signal_caller_frame                    based           structure                level 1 dcl 120 set ref 404
signal_caller_frame_size        000146 automatic       fixed bin(18,0)          unsigned dcl 74 set ref 404* 448* 448 462 464* 464
                                                                                  469* 469 472
signal_ptr               30            based           pointer                  level 2 dcl 5-26 ref 525
signaller                20(26)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 ref 435
size                    146(12)        based           bit(24)                  level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 499*
size                      4            based           fixed bin(17,0)          level 2 in structure "OU" dcl 582 in procedure
                                                                                  "found_specific_condition" ref 585 585 588 588
size                      4            based           fixed bin(17,0)          level 2 in structure "on_unit" dcl 1-4 in procedure
                                                                                  "signal_" ref 320 320 325 325
size                                                   builtin function         dcl 169 in procedure "signal_" ref 404 448
sp                              000164 automatic       pointer                  dcl 6-31 set ref 251* 290 297 304 360 362* 362 367
                                                                                  375 401 402 403* 404 407 408 409 410 417 419 419
                                                                                  422 444 446 446 447 455 462 462 463 467 472 472
                                                                                  475 477 478 479 481 482 483 485 486 487 490 491
                                                                                  492 495 497 498 499 504 505 506 507 509 509 510
                                                                                  510 511 511 512 512 513 513 514 514 515 515 516
                                                                                  516 523 523 525 531* 531 559
stack_end_ptr            24            based           pointer                  level 2 dcl 5-26 set ref 403 472*
stack_frame                            based           structure                level 1 dcl 6-36
stack_frame_flags                      based           structure                level 1 dcl 6-64
stack_header                           based           structure                level 1 dcl 5-26
stackframeptr                                          builtin function         dcl 169 ref 244
static_okay                     000152 automatic       bit(1)                   dcl 99 set ref 66* 256
string                                                 builtin function         dcl 169 set ref 477* 481* 485* 495*
substr                                                 builtin function         dcl 169 ref 271 384 384 563 563 588
support                  20(28)        based           bit(1)                   level 2 packed packed unaligned dcl 6-64 set ref
                                                                                  254* 410*
tpp                                    based           pointer                  array dcl 178 ref 308 308
translator_id            37            based           bit(18)                  level 3 packed packed unaligned dcl 120 set ref 490*
type                    151(01)        based           bit(6)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 487*
type                    146(01)        based           bit(6)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 498*
type                    150(01)        based           bit(6)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 483*
type                    147(01)        based           bit(6)                   level 3 in structure "signal_caller_frame" packed
                                                                                  packed unaligned dcl 120 in procedure "signal_"
                                                                                  set ref 479*
unclp                           000144 automatic       pointer                  dcl 74 set ref 299* 320* 325* 347 351* 440* 444 447
unspec                                                 builtin function         dcl 169 set ref 560* 560
unwind_stack_                   000014 constant        entry                    external dcl 156 ref 391
verify_lock$condition           000034 constant        entry                    external dcl 167 ref 430
wcptr                           000104 automatic       pointer                  dcl 74 in procedure "signal_" set ref 231* 237* 260*
                                                                                  384* 563*
wcptr                   134            based           pointer                  level 2 in structure "signal_caller_frame" dcl 120
                                                                                  in procedure "signal_" set ref 446* 447 455* 512
wcptr_desc              151            based           structure                level 2 dcl 120 set ref 485* 516
wcptr_desc_ptr          172            based           pointer                  level 3 dcl 120 set ref 516*
wcptr_ptr               162            based           pointer                  level 3 dcl 120 set ref 512*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 4-56
ITS_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 4-55
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 6-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 6-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 6-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 6-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 6-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 6-27
abx                                    internal static fixed bin(17,0)          initial dcl 7-42
apx                                    internal static fixed bin(17,0)          initial dcl 7-42
bbx                                    internal static fixed bin(17,0)          initial dcl 7-42
bpx                                    internal static fixed bin(17,0)          initial dcl 7-42
call_offset                            internal static fixed bin(17,0)          initial dcl 5-78
condition_info_header_ptr              automatic       pointer                  dcl 2-4
entry_offset                           internal static fixed bin(17,0)          initial dcl 5-78
itp                                    based           structure                level 1 dcl 4-18
itp_unsigned                           based           structure                level 1 dcl 4-43
its_unsigned                           based           structure                level 1 dcl 4-30
lbx                                    internal static fixed bin(17,0)          initial dcl 7-42
lpx                                    internal static fixed bin(17,0)          initial dcl 7-42
pl1_info_ptr                           automatic       pointer                  dcl 3-6
push_offset                            internal static fixed bin(17,0)          initial dcl 5-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 5-78
return_offset                          internal static fixed bin(17,0)          initial dcl 5-78
sbx                                    internal static fixed bin(17,0)          initial dcl 7-42
scup                                   automatic       pointer                  dcl 7-54
scux                                   based           structure                level 1 dcl 7-207
spx                                    internal static fixed bin(17,0)          initial dcl 7-42
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 6-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 5-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 5-72

NAMES DECLARED BY EXPLICIT CONTEXT.
ARGS                            000000 constant        label                    array(0:4) dcl 237 ref 235
caller                          001370 constant        entry                    internal dcl 541 ref 315 351
common                          000110 constant        label                    dcl 207 ref 67
end_loop                        000600 constant        label                    dcl 360 ref 317
end_scan                        000627 constant        label                    dcl 375
found_specific_condition        001475 constant        entry                    internal dcl 575 ref 306
io_signal                       000116 constant        entry                    external dcl 215
join                            000134 constant        label                    dcl 226 ref 210
no_wc                           001133 constant        label                    dcl 455 ref 435 444
return                          001367 constant        label                    dcl 595 ref 385 568
signal                          000071 constant        entry                    external dcl 62
signal_                         000052 constant        entry                    external dcl 62
skip_invoke                     000522 constant        label                    dcl 331 ref 308
stack_loop                      000407 constant        label                    dcl 290 ref 367
terminate_minus_2               001545 constant        entry                    internal dcl 598 ref 226 267 316 336 352 364 375 387
                                                                                  396

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2064        2122    1620        2074
Length      2450    1620        36         311     244           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
signal_                             207 external procedure  is an external procedure.  
on unit on line 226                  72 on unit               
on unit on line 267                  72 on unit               
on unit on line 316                  72 on unit               
on unit on line 352                  72 on unit               
on unit on line 387                  72 on unit               
on unit on line 396                  72 on unit               
caller                                  internal procedure  shares stack frame of external procedure signal_.  
found_specific_condition                internal procedure  shares stack frame of external procedure signal_.  
terminate_minus_2                    66 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
signal_                  000100 mcptr                       signal_
                         000102 info_ptr                    signal_
                         000104 wcptr                       signal_
                         000106 condition_name              signal_
                         000116 l_name                      signal_
                         000117 loops                       signal_
                         000120 ou_count                    signal_
                         000121 code                        signal_
                         000122 onlistp                     signal_
                         000124 onlistrel                   signal_
                         000126 oldp                        signal_
                         000130 prev_sp                     signal_
                         000132 next_sp                     signal_
                         000134 my_sp                       signal_
                         000136 filep                       signal_
                         000140 arglistptr                  signal_
                         000142 args                        signal_
                         000144 unclp                       signal_
                         000146 signal_caller_frame_size    signal_
                         000147 io                          signal_
                         000150 retsw                       signal_
                         000151 continue                    signal_
                         000152 static_okay                 signal_
                         000153 null_pointer_condition      signal_
                         000162 sb                          signal_
                         000164 sp                          signal_
                         000174 entry_variable              caller
                         000200 entry_overlay               caller
terminate_minus_2        000100 killer_ptr                  terminate_minus_2

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
arg_count_                    crawlout_default_handler_     default_error_handler_$wall_ignore_pi
get_ring_                     nonlocal_goto_$different_ring pl1_snap_                     sct_manager_$call_handler
unwind_stack_                 verify_lock$condition

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
fim$                          pds$vtime_count




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000042        62 000045        66 000105        67 000107       207 000110       210 000111       215 000112
    218 000132       226 000134       229 000162       231 000171       233 000175       235 000205       237 000206
    240 000212       242 000216       244 000222       251 000226       253 000231       254 000234       256 000236
    258 000247       259 000250       260 000251       264 000302       267 000305       270 000333       271 000350
    272 000353       274 000360       276 000362       277 000364       278 000366       279 000367       283 000403
    284 000405       290 000407       297 000413       299 000416       300 000420       301 000421       303 000422
    304 000424       306 000427       308 000435       314 000446       315 000447       316 000451       317 000477
    320 000500       325 000512       331 000522       333 000523       335 000526       336 000527       340 000542
    347 000543       350 000547       351 000550       352 000552       360 000600       362 000602       363 000604
    364 000605       367 000620       375 000627       382 000643       383 000644       384 000645       385 000703
    387 000707       391 000735       396 000752       401 001000       402 001002       403 001004       404 001006
    407 001010       408 001012       409 001015       410 001017       415 001021       417 001025       419 001031
    421 001033       422 001034       427 001036       430 001047       433 001064       435 001067       438 001103
    440 001106       444 001111       446 001121       447 001125       448 001130       453 001132       455 001133
    460 001136       462 001142       463 001147       464 001155       466 001157       467 001160       469 001163
    472 001170       475 001200       477 001203       478 001204       479 001206       481 001216       482 001217
    483 001221       485 001231       486 001232       487 001234       490 001244       491 001251       492 001253
    495 001257       497 001260       498 001262       499 001272       504 001277       505 001301       506 001303
    507 001305       509 001307       510 001311       511 001315       512 001321       513 001325       514 001331
    515 001335       516 001341       523 001345       525 001351       531 001354       536 001366       595 001367
    541 001370       551 001372       554 001410       557 001422       559 001424       560 001426       562 001432
    563 001433       568 001470       571 001474       575 001475       585 001506       588 001525       592 001542
    598 001544       605 001552       606 001562       607 001563


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
