	COMPILATION LISTING OF SEGMENT ibm3270_mpx
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0940.3 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-09-01,Beattie), approve(86-09-01,MCR7528),
       16*     audit(86-09-11,Brunelle), install(86-09-16,MR12.0-1159):
       17*     Change name of the "raw3270" mode to "raw3270io".
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style4 */
       22 
       23 /* IBM3270_MPX - The active portion of the ibm3270 multiplexer */
       24 
       25 /* Written May 1979 by Larry Johnson */
       26 /* Modified August 1982 by Robert Coren to handle "MASKED" interrupt */
       27 /* Bug fixes from Ford adopted by Robert Coren, October 1983 */
       28 /* Modified 1985-02-21, EJ Sharpe: use syserr_binary_def.incl.pl1, add format */
       29 
       30 ibm3270_mpx: proc;
       31 
       32 /* Parameters */
       33 
       34 dcl  arg_mdp ptr;
       35 dcl  arg_int_type fixed bin;
       36 dcl  arg_int_data bit (72) aligned;
       37 dcl  arg_subchan fixed bin;
       38 dcl  arg_order char (*);
       39 dcl  arg_infop ptr;
       40 dcl  arg_code fixed bin (35);
       41 dcl  arg_chain_ptr ptr;
       42 dcl  arg_mclp ptr;
       43 dcl  arg_modes char (*);
       44 dcl  arg_more_input bit (1) aligned;
       45 
       46 /* Automatic */
       47 
       48 dcl  int_type fixed bin;
       49 dcl  code fixed bin (35);
       50 dcl  order char (32);
       51 dcl  infop ptr;
       52 dcl  chain_ptr ptr;
       53 dcl  textp ptr;
       54 dcl  textl fixed bin;
       55 dcl  i fixed bin;
       56 dcl  position fixed bin;
       57 dcl  (pos_char1, pos_char2) char (1);
       58 dcl  dev_addr fixed bin;
       59 dcl  status bit (12);
       60 dcl  subchan fixed bin;
       61 dcl  header_blockp ptr;
       62 dcl  chain_len fixed bin;
       63 dcl  rest_chain_ptr ptr;
       64 dcl  end_chain_ptr ptr;
       65 dcl  column fixed bin;
       66 dcl  c char (1);
       67 dcl  save_raw_in_effect bit (1);
       68 dcl  targetp ptr;
       69 dcl  targetl fixed bin;
       70 
       71 dcl  1 wcc unal,					/* Write control code in output messages */
       72        2 printer_format bit (2),
       73        2 start_printer bit (1),
       74        2 sound_alarm bit (1),
       75        2 keyboard_restore bit (1),
       76        2 reset_modify bit (1);
       77 
       78 /* Based */
       79 
       80 dcl  target char (targetl) based (targetp);
       81 dcl  text char (textl) based (textp);
       82 dcl  text_array (textl) char (1) unal based (textp);
       83 dcl  bit_text_array (textl) bit (9) unal based (textp);
       84 
       85 dcl  1 status_msg unal based (textp),			/* Format of status and test_req */
       86        2 soh char (1),
       87        2 percent char (1),				/* Should be "%", untranlated */
       88        2 type char (1),				/* "/" for test_req, "R" for status */
       89        2 stx char (1),
       90        2 controller_address char (1),
       91        2 device_address char (1),
       92        2 status1 char (1),
       93        2 status2 char (1),
       94        2 etx char (1);
       95 
       96 dcl  1 text_msg unal based (textp),			/* Format of normal text start */
       97        2 stx char (1),
       98        2 controller_address char (1),
       99        2 device_address char (1),
      100        2 aid char (1),				/* Reason for input (which key) */
      101        2 cursor1 char (1),
      102        2 cursor2 char (1);
      103 
      104 dcl  1 abort_info aligned based (infop),		/* Data for abort order */
      105        2 resetwrite bit (1) unal,
      106        2 resetread bit (1) unal,
      107        2 pad bit (34) unal;
      108 
      109 /* Constants */
      110 
      111 dcl  name char (11) int static options (constant) init ("ibm3270_mpx");
      112 dcl  max_chain_len fixed bin int static options (constant) init (1950);
      113 dcl  max_raw_chain_len fixed bin int static options (constant) init (4000);
      114 
      115 dcl  ascii_address_table (0:63) bit (9) unal int static options (constant) init (
      116 	"040"b3, "101"b3, "102"b3, "103"b3, "104"b3, "105"b3, "106"b3, "107"b3,
      117 	"110"b3, "111"b3, "133"b3, "056"b3, "074"b3, "050"b3, "053"b3, "041"b3,
      118 	"046"b3, "112"b3, "113"b3, "114"b3, "115"b3, "116"b3, "117"b3, "120"b3,
      119 	"121"b3, "122"b3, "135"b3, "044"b3, "052"b3, "051"b3, "073"b3, "136"b3,
      120 	"055"b3, "057"b3, "123"b3, "124"b3, "125"b3, "126"b3, "127"b3, "130"b3,
      121 	"131"b3, "132"b3, "174"b3, "054"b3, "045"b3, "137"b3, "076"b3, "077"b3,
      122 	"060"b3, "061"b3, "062"b3, "063"b3, "064"b3, "065"b3, "066"b3, "067"b3,
      123 	"070"b3, "071"b3, "072"b3, "043"b3, "100"b3, "047"b3, "075"b3, "042"b3);
      124 
      125 dcl  ebcdic_address_table (0:63) bit (9) unal int static options (constant) init (
      126 	"100"b3, "301"b3, "302"b3, "303"b3, "304"b3, "305"b3, "306"b3, "307"b3,
      127 	"310"b3, "311"b3, "112"b3, "113"b3, "114"b3, "115"b3, "116"b3, "117"b3,
      128 	"120"b3, "321"b3, "322"b3, "323"b3, "324"b3, "325"b3, "326"b3, "327"b3,
      129 	"330"b3, "331"b3, "132"b3, "133"b3, "134"b3, "135"b3, "136"b3, "137"b3,
      130 	"140"b3, "141"b3, "342"b3, "343"b3, "344"b3, "345"b3, "346"b3, "347"b3,
      131 	"350"b3, "351"b3, "152"b3, "153"b3, "154"b3, "155"b3, "156"b3, "157"b3,
      132 	"360"b3, "361"b3, "362"b3, "363"b3, "364"b3, "365"b3, "366"b3, "367"b3,
      133 	"370"b3, "371"b3, "172"b3, "173"b3, "174"b3, "175"b3, "176"b3, "177"b3);
      134 
      135 dcl  (
      136      SYSERR_CRASH_SYSTEM init (1),			/* Crash the system, and bleat plaintively. */
      137      BEEP init (3),					/* Beep and print the message on the console. */
      138      ANNOUNCE init (0),				/* Just print the message on the console. */
      139      JUST_LOG init (5)				/* Just try to log the message, and discard it if it can't be */
      140      ) fixed bin internal static options (constant);
      141 
      142 /* Interal static */
      143 
      144 dcl  et_undefined_order_request fixed bin (35) int static;
      145 dcl  et_improper_data_format fixed bin (35) int static;
      146 dcl  et_noalloc fixed bin (35) int static;
      147 dcl  et_bad_mode fixed bin (35) int static;
      148 
      149 /* External */
      150 
      151 dcl  pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
      152 dcl  syserr entry options (variable);
      153 dcl  syserr$binary entry options (variable);
      154 dcl  wire_proc$wire_me entry;
      155 
      156 dcl  error_table_$undefined_order_request ext fixed bin (35);
      157 dcl  error_table_$noalloc ext fixed bin (35);
      158 dcl  error_table_$improper_data_format ext fixed bin (35);
      159 dcl  error_table_$bad_mode ext fixed bin (35);
      160 
      161 dcl  (addr, bin, bit, hbound, index, lbound, low, min, max, mod, null, ptr, rel,
      162      string, substr, unspec, size) builtin;
      163 
      164 dcl  cleanup condition;
      165 
      166 /* Control entry point */
      167 
      168 control: entry (arg_mdp, arg_subchan, arg_order, arg_infop, arg_code);
      169 
      170 	mdp = arg_mdp;
      171 	subchan = arg_subchan;
      172 	mdep = addr (md.mde_entry (subchan));
      173 	order = arg_order;
      174 	infop = arg_infop;
      175 	ttybp = addr (tty_buf$);
      176 
      177 	if order = "enter_receive" then do;
      178 	     if ^mde.raw3270_in_effect then do;
      179 		mde.keyboard_restore = "1"b;
      180 		call queue_control;			/* Schedule the unlocking */
      181 		call process_write;			/* In case it can be done now */
      182 	     end;
      183 	     code = 0;
      184 	end;
      185 	else if order = "abort" then do;
      186 	     if abort_info.resetwrite then call reset_channel;
      187 	     code = 0;
      188 	end;
      189 	else if order = "listen" then do;
      190 	     mde.listen = "1"b;
      191 	     if mde.printer & ^mde.dialed & md.started then
      192 		call dialup_channel;
      193 	     code = 0;
      194 	end;
      195 	else if order = "hangup" then do;
      196 	     mde.listen, mde.dialed = "0"b;
      197 	     call reset_channel;
      198 	     mde.keyboard_restore = "1"b;
      199 	     call channel_manager$interrupt (mde.devx, HANGUP, "0"b);
      200 	     call queue_control;
      201 	     call process_write;
      202 	     code = 0;
      203 	end;
      204 	else if order = "wru" then do;
      205 	     call channel_manager$interrupt (mde.devx, WRU_TIMEOUT, "0"b);
      206 	     code = 0;
      207 	end;
      208 	else if order = "printer_off" then code = 0;
      209 	else if order = "printer_on" then code = 0;
      210 	else code = et_undefined_order_request;
      211 
      212 	arg_code = code;
      213 	return;
      214 
      215 /* Read entry. We have no data. */
      216 
      217 read: entry (arg_mdp, arg_subchan, arg_chain_ptr, arg_more_input, arg_code);
      218 
      219 	arg_chain_ptr = null ();
      220 	arg_more_input = "0"b;
      221 	arg_code = 0;
      222 
      223 	return;
      224 
      225 /* Entries that dial with modes. We only watch the setting of hndlquit */
      226 
      227 check_modes: entry (arg_mdp, arg_subchan, arg_mclp, arg_code);
      228 
      229 	mdp = arg_mdp;
      230 	subchan = arg_subchan;
      231 	mdep = addr (md.mde_entry (subchan));
      232 	mclp = arg_mclp;
      233 	ttybp = addr (tty_buf$);
      234 
      235 	do i = 1 to mcl.n_entries;
      236 	     mclep = addr (mcl.entries (i));
      237 	     mcle.mpx_mode = "0"b;
      238 	     if mcle.mode_name = "hndlquit" | mcle.mode_name = "rawi" | mcle.mode_name = "rawo" then
      239 		mcle.mpx_mode = "1"b;		/* Monitor changes to these modes */
      240 	     else if mcle.mode_name = "raw3270io" then
      241 		if (^md.allow_raw3270 & mcle.mode_switch) then mcle.error = "1"b;
      242 		else mcle.mpx_mode = "1"b;
      243 	end;
      244 
      245 	arg_code = 0;
      246 	return;
      247 
      248 set_modes: entry (arg_mdp, arg_subchan, arg_mclp, arg_code);
      249 
      250 	mdp = arg_mdp;
      251 	subchan = arg_subchan;
      252 	mdep = addr (md.mde_entry (subchan));
      253 	mclp = arg_mclp;
      254 	arg_code = 0;
      255 	ttybp = addr (tty_buf$);
      256 
      257 	save_raw_in_effect = mde.raw3270_in_effect;
      258 	if mcl.init then mde.hndlquit, mde.rawi, mde.rawo, mde.raw3270 = "0"b;
      259 
      260 	do i = 1 to mcl.n_entries;
      261 	     mclep = addr (mcl.entries (i));
      262 	     if mcle.mpx_mode then do;
      263 		if mcle.mode_name = "hndlquit" then mde.hndlquit = mcle.mode_switch;
      264 		else if mcle.mode_name = "rawi" then mde.rawi = mcle.mode_switch;
      265 		else if mcle.mode_name = "rawo" then mde.rawo = mcle.mode_switch;
      266 		else if mcle.mode_name = "raw3270io" then mde.raw3270 = mcle.mode_switch;
      267 		else do;
      268 		     mcle.error = "1"b;
      269 		     arg_code = et_bad_mode;
      270 		end;
      271 	     end;
      272 	end;
      273 
      274 	mde.raw3270_in_effect = mde.rawi & mde.rawo & mde.raw3270;
      275 	if save_raw_in_effect & ^mde.raw3270_in_effect & ^mde.write_queued & mde.write_chain_ptr ^= null () then
      276 	     call reset_channel;
      277 
      278 	return;
      279 
      280 get_modes: entry (arg_mdp, arg_subchan, arg_modes, arg_code);
      281 
      282 	mdp = arg_mdp;
      283 	subchan = arg_subchan;
      284 	mdep = addr (md.mde_entry (subchan));
      285 	ttybp = addr (tty_buf$);
      286 
      287 	if mde.raw3270 then arg_modes = "raw3270io";
      288 	else arg_modes = "^raw3270io";
      289 	arg_code = 0;
      290 	return;
      291 
      292 /* Write entry point */
      293 
      294 write: entry (arg_mdp, arg_subchan, arg_chain_ptr, arg_code);
      295 
      296 	mdp = arg_mdp;
      297 	subchan = arg_subchan;
      298 	mdep = addr (md.mde_entry (subchan));
      299 	chain_ptr = arg_chain_ptr;
      300 	end_chain_ptr, rest_chain_ptr, header_blockp = null ();
      301 	arg_code = 0;
      302 	ttybp = addr (tty_buf$);
      303 
      304 /* The following section handles writing in raw3270 mode */
      305 
      306 	if mde.raw3270_in_effect then do;
      307 	     if mde.write_chain_ptr ^= null () then do;	/* Must merge */
      308 		do blockp = mde.write_chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);
      309 		end;				/* Find end */
      310 		buffer.next = bin (rel (chain_ptr));
      311 		chain_ptr = mde.write_chain_ptr;
      312 		mde.write_chain_ptr = null ();
      313 	     end;
      314 
      315 /* Look for end of first command as signalled by ETX. */
      316 
      317 	     position = 0;
      318 	     blockp = chain_ptr;
      319 	     do while (position = 0 & (rel (blockp) ^= "0"b));
      320 		textp = addr (buffer.chars);
      321 		textl = buffer.tally;
      322 		position = index (text, md.etx);
      323 		end_chain_ptr = blockp;
      324 		if position = 0
      325 		then do;
      326 		     blockp = ptr (ttybp, buffer.next);
      327 		end;
      328 	     end;
      329 
      330 	     if position = -1			/* No ETX in message anywhere. */
      331 	     then do;
      332 		if ^end_chain_ptr -> buffer.break then do; /* Don't have complete message yet. */
      333 		     mde.write_chain_ptr = chain_ptr;
      334 		     arg_chain_ptr = null ();
      335 		     arg_code = 0;
      336 		     call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
      337 		     return;
      338 		end;
      339 		else do;
      340 		     goto write_format_error;
      341 		end;
      342 	     end;
      343 
      344 /* ETX is somewhere in message. */
      345 
      346 	     if position = buffer.tally		/* ETX is at end of buffer.  Don't need to split buffer. */
      347 	     then do;
      348 		if buffer.next = 0 then ;		/* ETX is at end of chain.  Don't need to split chain. */
      349 		else do;				/* Need to split chain, but not buffer. */
      350 		     rest_chain_ptr = ptr (ttybp, buffer.next);
      351 		     buffer.next = 0;
      352 		end;
      353 	     end;
      354 	     else do;				/* Need to split buffer and split chain. */
      355 		call tty_space_man$get_buffer (mde.devx,
      356 		     16 * (buffer.size_code + 1),
      357 		     OUTPUT,
      358 		     rest_chain_ptr);
      359 		if rest_chain_ptr = null ()
      360 		then do;
      361 		     arg_code = et_noalloc;
      362 		     return;
      363 		end;
      364 		rest_chain_ptr -> buffer.next = buffer.next;
      365 		rest_chain_ptr -> buffer.flags = buffer.flags;
      366 		rest_chain_ptr -> buffer.size_code = buffer.size_code;
      367 		rest_chain_ptr -> buffer.tally = (buffer.tally - position);
      368 		buffer.tally = position;
      369 		buffer.next = 0;
      370 		buffer.break = "1"b;
      371 		textp = addr (buffer.chars (position));
      372 		textl = rest_chain_ptr -> buffer.tally;
      373 		targetp = addr (rest_chain_ptr -> buffer.chars);
      374 		targetl = textl;
      375 		target = text;
      376 	     end;
      377 
      378 /* Check max chain length. */
      379 
      380 	     chain_len = 0;
      381 	     do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (rel (blockp) ^= "0"b);
      382 		chain_len = chain_len + buffer.tally;
      383 		end_chain_ptr = blockp;
      384 	     end;
      385 	     if chain_len > max_raw_chain_len
      386 	     then do;
      387 		go to write_format_error;
      388 	     end;
      389 
      390 /* Check for proper message header. */
      391 
      392 	     blockp = chain_ptr;
      393 	     if buffer.chars (0) ^= md.stx
      394 	     then do;
      395 		go to write_format_error;
      396 	     end;
      397 	     if buffer.chars (1) ^= md.esc
      398 	     then do;
      399 		go to write_format_error;
      400 	     end;
      401 	     if (buffer.chars (2) = md.write)
      402 		| (buffer.chars (2) = md.erase_write) then ; /* Ok */
      403 	     else do;
      404 		if buffer.chars (2) = md.copy
      405 		then do;
      406 		     if md.allow_copy then ;		/* Ok */
      407 		     else do;
      408 			go to write_format_error;
      409 		     end;
      410 		end;
      411 		else do;
      412 		     goto write_format_error;
      413 		end;
      414 	     end;
      415 
      416 /* Check for trailing ETX. */
      417 
      418 	     blockp = end_chain_ptr;
      419 	     if buffer.chars (buffer.tally - 1) ^= md.etx then go to write_format_error;
      420 
      421 /* Seem to have a good message; queue it up. */
      422 
      423 	     header_blockp = chain_ptr;
      424 	     go to queue_write_data;
      425 
      426 	end;
      427 
      428 /* Rest of code is for case of ^raw3270 mode */
      429 /* First, be sure a buffer is available for the header */
      430 
      431 	call tty_space_man$get_buffer (mde.devx, 16, OUTPUT, header_blockp);
      432 	if header_blockp = null () then do;
      433 	     arg_code = et_noalloc;			/* Give up if no space */
      434 	     return;
      435 	end;
      436 
      437 /* Take as much of the chain as can fit in a single bisync message.  We must
      438*   be careful not to split a NL-NUL-NUL sequence. */
      439 
      440 	chain_len = 0;
      441 	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (rel (blockp) ^= "0"b);
      442 	     chain_len = chain_len + buffer.tally;
      443 	     if chain_len > max_chain_len then do;
      444 		rest_chain_ptr = blockp;		/* First buffer of rest of chain */
      445 		blockp = end_chain_ptr;
      446 		buffer.next = 0;			/* Break chain */
      447 		if mde.printer then go to chain_split;
      448 		textp = addr (buffer.chars);
      449 		textl = buffer.tally;
      450 		do i = 2 to 1 by -1 while (textl > (2 - i)); /* Check last 2 characters */
      451 		     c = substr (text, textl - 2 + i, 1);
      452 		     if c = md.nl | c = md.cr | c = md.bs then do;
      453 			call check_buffer_tally (i);	/* This buffer must have room */
      454 			buffer.tally = buffer.tally + i;
      455 			textl = textl + i;
      456 			substr (text, textl - i + 1, i) = low (i);
      457 			blockp = rest_chain_ptr;
      458 			if buffer.tally > i then do;	/* Trim stuff from front */
      459 			     textp = addr (buffer.chars);
      460 			     textl = buffer.tally;
      461 			     text = substr (text, i + 1);
      462 			     buffer.tally = buffer.tally - i;
      463 			end;
      464 			go to chain_split;
      465 		     end;
      466 		end;
      467 		go to chain_split;
      468 	     end;
      469 	     end_chain_ptr = blockp;
      470 	end;
      471 chain_split:
      472 	if end_chain_ptr = null () then end_chain_ptr = chain_ptr;
      473 
      474 /* The output chain should have been formatted by tty_write so that each new_line is followed by two nulls.
      475*   Loop thru the chain replacing each such sequence by a cursor addressing sequence */
      476 
      477 	blockp = chain_ptr;
      478 	textp = addr (buffer.chars);
      479 	textl = buffer.tally;
      480 	if mde.printer then mde.erase_req = "1"b;
      481 	if mde.erase_req then mde.position = 0;
      482 	position = mde.position;
      483 
      484 	if ^mde.printer then do while (textp ^= null ()); /* Loop over entire message */
      485 	     i = 0;				/* Index to next interesting char */
      486 	     call find_next (i, md.nl);
      487 	     call find_next (i, md.cr);
      488 	     call find_next (i, md.bs);
      489 	     if i = 0 then do;
      490 		position = mod (position + textl, mde.screen_size);
      491 		call adv_text (textl);
      492 	     end;
      493 	     else do;
      494 		column = mod (position, mde.line_size);
      495 		position = position - column;
      496 		if i > 1 then do;			/* Data before new line */
      497 		     column = column + i - 1;
      498 		     call adv_text (i - 1);
      499 		end;
      500 		c = substr (text, 1, 1);
      501 		substr (text, 1, 1) = md.sba;		/* Replace nl by set-buffer-address */
      502 		call adv_text (1);
      503 		if textp = null () then go to write_format_error; /* Should be followed by 2 nulls */
      504 		if substr (text, 1, 1) ^= low (1) then go to write_format_error;
      505 		if c = md.nl then do;
      506 		     if (column = 0) | (mod (column, mde.line_size) ^= 0) then
      507 			column = column - mod (column, mde.line_size) + mde.line_size;
      508 		end;
      509 		else if c = md.cr then column = 0;
      510 		else if c = md.bs then column = max (column - 1, 0);
      511 		position = mod (position + column, mde.screen_size);
      512 		call get_position_chars (position);
      513 		substr (text, 1, 1) = pos_char1;	/* Replace first null () */
      514 		call adv_text (1);			/* To second null */
      515 		if textp = null then go to write_format_error;
      516 		if substr (text, 1, 1) ^= low (1) then go to write_format_error;
      517 		substr (text, 1, 1) = pos_char2;
      518 		call adv_text (1);
      519 	     end;
      520 	end;
      521 
      522 /* Format the header block with STX-ESC-WRITE-WCC-SBA-POS-POS */
      523 
      524 	blockp = header_blockp;
      525 	if ^mde.printer then mde.end_of_page = end_chain_ptr -> buffer.end_of_page;
      526 	end_chain_ptr -> buffer.end_of_page = "0"b;
      527 	if mde.end_of_page then mde.keyboard_restore = "1"b;
      528 	call build_header;
      529 	buffer.next = bin (rel (chain_ptr));		/* Thread to head of chain */
      530 
      531 /* Two characters must be added to end of last buffer, IC (insert cursor) and ETX */
      532 
      533 	blockp = end_chain_ptr;
      534 	call check_buffer_tally (2);			/* Need space for 2 chars */
      535 
      536 	textp = addr (buffer.chars);			/* Add necessary stuff to end of last buffer */
      537 	textl = buffer.tally;
      538 	textl = textl + 2;
      539 	if mde.printer then substr (text, textl - 1, 1) = md.em;
      540 	else substr (text, textl - 1, 1) = md.ic;	/* Insert cursor */
      541 	substr (text, textl, 1) = md.etx;
      542 	buffer.tally = textl;
      543 
      544 /* Data is now completely formated and ready to transmit */
      545 
      546 	mde.position = position;			/* Where we left the cursor */
      547 
      548 queue_write_data:
      549 	call queue_write;
      550 
      551 	call process_write;				/* Start this write if possible */
      552 
      553 	arg_chain_ptr = rest_chain_ptr;
      554 	return;
      555 
      556 write_format_error:
      557 	if header_blockp ^= null () then
      558 	     call tty_space_man$free_buffer (mde.devx, OUTPUT, header_blockp);
      559 	call tty_space_man$free_chain (mde.devx, OUTPUT, chain_ptr);
      560 	if rest_chain_ptr ^= null () then
      561 	     call tty_space_man$free_chain (mde.devx, OUTPUT, rest_chain_ptr);
      562 	md.write_format_error = md.write_format_error + 1;
      563 	arg_code = 0;				/* A code would be better, but users cant handle it */
      564 	arg_chain_ptr = null ();
      565 	return;
      566 
      567 /* Interrupt entry point */
      568 
      569 interrupt: entry (arg_mdp, arg_int_type, arg_int_data);
      570 
      571 	mdp = arg_mdp;
      572 	int_type = arg_int_type;
      573 	interrupt_info = arg_int_data;
      574 	ttybp = addr (tty_buf$);
      575 
      576 	if int_type < lbound (INTERRUPT, 1) | int_type > hbound (INTERRUPT, 1) then do;
      577 	     call syserr (ANNOUNCE, "^a: Unrecognized interrupt for ^a. ^d ^.3b",
      578 		name, md.name, int_type, interrupt_info);
      579 	     return;
      580 	end;
      581 
      582 	go to INTERRUPT (int_type);
      583 
      584 /* DIALUP interrupt - This means that the major channel has dialed up and the multiplexer is now loaded */
      585 
      586 INTERRUPT (1):
      587 	if ^md.loading then return;
      588 	md.loading = "0"b;
      589 	md.loaded = "1"b;
      590 	unspec (dialup_info) = interrupt_info;
      591 	md.line_type = dialup_info.line_type;
      592 	md.baud_rate = dialup_info.baud_rate;
      593 	md.max_buf_size = dialup_info.max_buf_size;
      594 	md.buffer_pad = dialup_info.buffer_pad;
      595 	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_UP, code);
      596 	return;
      597 
      598 /* HANGUP interrupt - This means that we have lost the phone and the multiplexer is considered crashed */
      599 
      600 INTERRUPT (2):
      601 	if ^md.loaded then return;
      602 	call crash_mpx;
      603 	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_DOWN, code);
      604 	return;
      605 
      606 /* CRASH interrupt - Parent multiplexer has crashed. We must propagate the information */
      607 
      608 INTERRUPT (3):
      609 	if ^md.loaded then return;
      610 	call crash_mpx;
      611 	return;
      612 
      613 /* SEND_OUTPUT interrupt - We are allowed to send more output */
      614 
      615 INTERRUPT (4):
      616 	if ^md.loaded then return;
      617 	md.send_output = "1"b;			/* Will save for later */
      618 	if md.message_in_progress then do;		/* Complete partially written msg */
      619 	     call send_more_message;
      620 	     return;
      621 	end;
      622 	if ^md.output_in_progress then call process_write;/* Just in case */
      623 	return;
      624 
      625 /* INPUT_AVAILABLE Interrupt - Not used */
      626 
      627 INTERRUPT (5):
      628 	return;
      629 
      630 /* ACCEPT_INPUT - Real data to processes */
      631 
      632 INTERRUPT (6):
      633 	if ^md.loaded then return;
      634 	md.poll_in_progress = "0"b;			/* Any input suspends polling */
      635 	unspec (rtx_info) = interrupt_info;
      636 	chain_ptr = ptr (ttybp, rtx_info.chain_head);	/* Start of input chain */
      637 	if ^md.loaded then go to discard_input;
      638 
      639 	blockp = chain_ptr;
      640 	textp = addr (buffer.chars);
      641 	textl = buffer.tally;			/* Set up to look at start */
      642 
      643 	if substr (text, 1, 1) = md.eot then do;	/* EOT means end of current poll operation */
      644 	     md.poll_in_progress = "0"b;
      645 	     call tty_space_man$free_chain (md.devx, INPUT, chain_ptr);
      646 	     call process_input;
      647 	     call process_polls;
      648 	     call process_write;
      649 	     return;
      650 	end;
      651 
      652 	if substr (text, 1, 1) = md.soh then do;	/* Status or test_req */
      653 	     if textl < 5 then go to bad_input;
      654 	     if status_msg.percent ^= md.percent then	/* Should start % */
      655 		go to bad_input;
      656 	     if status_msg.type = slash then go to discard_input; /* Ignore test_reqq */
      657 	     if status_msg.type ^= md.letter_R then	/* R means status */
      658 		go to bad_input;
      659 	     if textl < 9 then go to bad_input;
      660 	     if status_msg.stx ^= md.stx then go to bad_input;
      661 	     dev_addr = getbin (status_msg.device_address);
      662 	     if dev_addr < lbound (md.chan_map, 1) | dev_addr > hbound (md.chan_map, 1) then go to bad_dev_addr;
      663 	     subchan = md.chan_map (dev_addr);
      664 	     if subchan <= 0 then go to bad_device;
      665 	     mdep = addr (md.mde_entry (subchan));
      666 	     if ^mde.dialed then go to discard_input;	/* Dont care if hungup */
      667 	     if ^mde.printer then go to discard_input;	/* Dont care except for printers */
      668 	     if mde.waiting_for_ready then do;		/* Looking for printer to go ready */
      669 		substr (status, 1, 6) = getbit (status_msg.status1);
      670 		substr (status, 7, 6) = getbit (status_msg.status2);
      671 		if status = "0200"b3 then do;		/* Really ready status */
      672 		     mde.waiting_for_ready = "0"b;
      673 		     call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
      674 		end;
      675 	     end;
      676 	     go to discard_input;			/* Throw away status */
      677 	end;
      678 
      679 
      680 /* Accumulate this block onto the current input chain */
      681 
      682 	if text_msg.stx ^= md.stx then go to bad_input;
      683 	if textl < 2 then go to bad_input;
      684 	if md.input_chain_ptr ^= null () then do;	/* Trim etb off previous block */
      685 	     call trim_chain_end (md.input_chain_ptr, 1);
      686 	     md.input_count = md.input_count - 1;
      687 	end;
      688 	if md.input_chain_ptr ^= null () then do;	/* Thread blocks */
      689 	     call trim_chain_start (chain_ptr, 1);	/* Throw away new stx */
      690 	     do blockp = md.input_chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);
      691 	     end;
      692 	     buffer.next = bin (rel (chain_ptr));
      693 	     md.input_count = md.input_count + rtx_info.input_count - 1;
      694 	end;
      695 	else do;					/* First block */
      696 	     md.input_chain_ptr = chain_ptr;
      697 	     md.input_count = rtx_info.input_count;
      698 	end;
      699 	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);
      700 	end;					/* Find last block */
      701 	if buffer.chars (buffer.tally - 1) = md.etx then call process_input;
      702 	return;
      703 
      704 bad_input:
      705 	textl = min (textl, 8);
      706 	if md.debug then
      707 	     call syserr (ANNOUNCE, "^a: Unrecognized input for ^a:^( ^.3b^)", name, md.name, bit_text_array);
      708 	md.bad_input = md.bad_input + 1;
      709 	go to discard_input;
      710 
      711 bad_dev_addr:
      712 						/* This is so bad we cannot even mask it off, because its not in the table */
      713 	call syserr (ANNOUNCE, "^a: Input for illegal device address ^d on ^a", name, dev_addr, md.name);
      714 	md.bad_device = md.bad_device + 1;
      715 	go to discard_input;
      716 
      717 bad_device:
      718 	if subchan < 0 then go to discard_input;	/* Once per bootload */
      719 	call syserr (ANNOUNCE, "^a: Input for unconfigured device ^d on ^a", name, dev_addr, md.name);
      720 	md.bad_device = md.bad_device + 1;
      721 	md.chan_map (dev_addr) = -1;			/* So wont get printed again */
      722 
      723 discard_input:
      724 	call tty_space_man$free_chain (md.devx, INPUT, chain_ptr);
      725 	return;
      726 
      727 /* INPUT REJECTED interrupt - Ignore */
      728 
      729 INTERRUPT (7):
      730 	if ^md.loaded then return;
      731 	md.input_reject = md.input_reject + 1;
      732 	return;
      733 
      734 /* QUIT interrupt - Ignore */
      735 
      736 INTERRUPT (8):
      737 	return;
      738 
      739 /* DIAL STATUS interrupt - Ignore */
      740 
      741 INTERRUPT (10):
      742 	return;
      743 
      744 /* WRU TIMEOUT interrupt - Ignore */
      745 
      746 INTERRUPT (11):
      747 	return;
      748 
      749 /* SPACE AVAILABLE interrupt - Retry suspended write operation. */
      750 
      751 INTERRUPT (12):
      752 	if ^md.loaded then return;
      753 	md.space_available = md.space_available + 1;
      754 	if md.message_in_progress then call send_more_message;
      755 	else call process_write;
      756 	return;
      757 						/* various others - ignore */
      758 
      759 INTERRUPT (13):
      760 INTERRUPT (14):
      761 INTERRUPT (15):
      762 INTERRUPT (16):
      763 	return;
      764 
      765 /* MASKED interrupt - Treat like hangup but use different wakeup message */
      766 
      767 INTERRUPT (17):
      768 	if ^md.loaded then return;
      769 	call crash_mpx;
      770 	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_MASKED, code);
      771 	return;
      772 
      773 
      774 /* LINE STATUS interrupt - Decode and act upon in */
      775 
      776 INTERRUPT (9):
      777 	if ^md.loaded then return;
      778 	unspec (line_stat) = interrupt_info;
      779 	if line_stat.op < lbound (LINE_STAT, 1) | line_stat.op > hbound (LINE_STAT, 1) then return;
      780 	go to LINE_STAT (line_stat.op);
      781 
      782 LINE_STAT (1):					/* No response to poll */
      783 	md.poll_failed = md.poll_failed + 1;
      784 	md.poll_in_progress = "0"b;
      785 	call process_polls;
      786 	call process_write;
      787 	return;
      788 
      789 LINE_STAT (2):					/* Badly formated output block */
      790 	md.bad_output = md.bad_output + 1;
      791 	go to line_stat_output_complete;
      792 
      793 LINE_STAT (3):					/* Rvi - device has status */
      794 	if md.output_in_progress then do;
      795 	     subchan = md.cur_write_chan;
      796 	     mdep = addr (md.mde_entry (subchan));
      797 	     call queue_poll;
      798 	end;
      799 	go to line_stat_output_complete;
      800 
      801 LINE_STAT (4):					/* Too many naks */
      802 	return;
      803 
      804 LINE_STAT (5):					/* Write status - can't happen */
      805 	return;
      806 
      807 LINE_STAT (6):					/* 3270 write complete */
      808 line_stat_output_complete:
      809 	if md.output_in_progress then do;
      810 	     md.output_in_progress, md.message_in_progress = "0"b;
      811 	     mdep = addr (md.mde_entry (md.cur_write_chan));
      812 	     if ^mde.end_of_page then
      813 		call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
      814 	end;
      815 line_stat_continue:
      816 	call process_polls;
      817 	call process_write;
      818 	return;
      819 
      820 LINE_STAT (7):					/* 3270 wack msg - printer going busy */
      821 	if ^md.output_in_progress then go to line_stat_continue;
      822 	md.output_in_progress, md.message_in_progress = "0"b;
      823 	mdep = addr (md.mde_entry (md.cur_write_chan));
      824 	if mde.printer then mde.waiting_for_ready = "1"b;
      825 	else call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
      826 	go to line_stat_continue;
      827 
      828 LINE_STAT (8):					/* Ibm3270 write eot */
      829 	md.write_eot = md.write_eot + 1;
      830 	go to line_stat_output_complete;
      831 
      832 LINE_STAT (9):
      833 	md.write_abort = md.write_abort + 1;
      834 	go to line_stat_output_complete;
      835 
      836 LINE_STAT (10):
      837 	md.select_failed = md.select_failed + 1;
      838 	go to line_stat_output_complete;
      839 
      840 LINE_STAT (11):
      841 	md.wack_select = md.wack_select + 1;
      842 	go to line_stat_output_complete;
      843 
      844 LINE_STAT (12):
      845 	md.nak_output = md.nak_output + 1;
      846 	go to line_stat_output_complete;
      847 
      848 /* Internal procedure to adv pointer down a buffer chain. If the current buffer is exhausted, step to next */
      849 
      850 adv_text: proc (n);
      851 
      852 dcl  n fixed bin;
      853 
      854 	textp = addr (text_array (n + 1));		/* Bump pointer */
      855 	textl = textl - n;				/* Reduce tally */
      856 	if textl > 0 then return;			/* More in buffer */
      857 	if buffer.next = 0 then do;			/* End of chain */
      858 	     textp = null ();
      859 	     return;
      860 	end;
      861 	blockp = ptr (ttybp, buffer.next);		/* Next in chain */
      862 	textp = addr (buffer.chars);
      863 	textl = buffer.tally;
      864 	return;
      865 
      866      end adv_text;
      867 
      868 /* Procedure for finding next occurance of specified character */
      869 
      870 find_next: proc (ix, c);
      871 
      872 dcl  ix fixed bin;
      873 dcl  c char (1) unal;
      874 
      875 dcl  i fixed bin;
      876 
      877 	if ix = 0 then ix = index (text, c);		/* No interesting chars yet */
      878 	else if ix = 1 then ;			/* Nothing if another interesting char first */
      879 	else do;
      880 	     i = index (substr (text, 1, ix - 1), c);
      881 	     if i ^= 0 then ix = i;
      882 	end;
      883 
      884 	return;
      885 
      886      end find_next;
      887 
      888 /* This procedure computes a two character addressing sequence, given a position */
      889 
      890 get_position_chars: proc (pos);
      891 
      892 dcl  pos fixed bin;
      893 dcl  posbit bit (12);
      894 
      895 	posbit = bit (bin (pos, 12), 12);		/* Need two 6-but pieces */
      896 	pos_char1 = address_table (bin (substr (posbit, 1, 6)));
      897 	pos_char2 = address_table (bin (substr (posbit, 7, 6)));
      898 	return;
      899 
      900      end get_position_chars;
      901 
      902 /* Decode screen position from characters */
      903 
      904 get_position: proc (c1, c2) returns (fixed bin);
      905 
      906 dcl  (c1, c2) char (1);
      907 
      908 	return (bin (getbit (c1) || getbit (c2)));
      909 
      910      end get_position;
      911 
      912 /* Functions that map status chars back into usefull stuff */
      913 
      914 getbin: proc (c) returns (fixed bin (6));
      915 
      916 dcl  c char (1);
      917 
      918 	return (bin (substr (unspec (c), 4, 6), 6));
      919 
      920      end getbin;
      921 
      922 getbit: proc (c) returns (bit (6));
      923 
      924 dcl  c char (1);
      925 
      926 	return (substr (unspec (c), 4, 6));
      927 
      928      end getbit;
      929 
      930 /* Internal procedure to queue a channel with data to write on the mpx write queue */
      931 
      932 queue_write: proc;
      933 
      934 dcl  p ptr;
      935 
      936 	if mde.write_queued then do;
      937 	     call syserr$binary (
      938 		JUST_LOG,				/* Log, discard if not possible	*/
      939 		mdep,
      940 		SB_ibm3270_mde,
      941 		size (mde),			/* Size of an MDE			*/
      942 		"^a: Attempt to queue write while write queued ^a.^a",
      943 		name,
      944 		md.name,
      945 		mde.name
      946 		);
      947 
      948 	     mde.write_chain_ptr = header_blockp;
      949 	     return;
      950 	end;
      951 
      952 	if md.first_write_chan = 0 then do;
      953 	     md.first_write_chan = subchan;
      954 	     md.last_write_chan = subchan;
      955 	end;
      956 	else do;
      957 	     p = addr (md.mde_entry (md.last_write_chan));
      958 	     p -> mde.next_write_chan = subchan;
      959 	     md.last_write_chan = subchan;
      960 	end;
      961 	mde.next_write_chan = 0;
      962 	mde.write_chain_ptr = header_blockp;
      963 	mde.write_queued = "1"b;
      964 	return;
      965 
      966      end queue_write;
      967 
      968 /* Procedure to process the next piece of output */
      969 
      970 process_write: proc;
      971 
      972 	mdep = null ();
      973 	if md.output_in_progress then return;		/* Doing someone else */
      974 	if md.poll_in_progress then return;
      975 	if md.first_poll_chan ^= 0 then return;		/* Polling has priority */
      976 	if md.first_control_chan ^= 0 then do;
      977 	     call setup_control_chan;
      978 	     if mdep ^= null () then go to write_join;	/* Found one */
      979 	end;
      980 	if md.first_write_chan = 0 then return;		/* Nothing to do anyway */
      981 
      982 	subchan = md.first_write_chan;
      983 	mdep = addr (md.mde_entry (subchan));
      984 	md.first_write_chan = mde.next_write_chan;	/* Dequeue */
      985 	if md.first_write_chan = 0 then md.last_write_chan = 0;
      986 	mde.next_write_chan = 0;
      987 	mde.write_queued = "0"b;
      988 
      989 write_join: md.write_chain_ptr = mde.write_chain_ptr;	/* Pick up data from channel */
      990 	mde.write_chain_ptr = null ();
      991 	md.cur_write_chan = subchan;
      992 	md.eot_sent = "0"b;
      993 	md.output_in_progress = "1"b;
      994 	md.message_in_progress = "1"b;
      995 
      996 	call select;
      997 	call send_more_message;
      998 
      999 	mdep = null ();
     1000 	return;
     1001 
     1002      end process_write;
     1003 
     1004 /* Procedure to send the next piece of the current output chain down the pike */
     1005 
     1006 send_more_message: proc;
     1007 
     1008 dcl  p ptr;
     1009 
     1010 	if ^md.send_output then return;		/* Dont have permission */
     1011 	if md.write_chain_ptr ^= null () then do;	/* Have a chain */
     1012 	     p = md.write_chain_ptr;
     1013 send_chain:    call channel_manager$write (md.devx, p, code);
     1014 	     if code ^= 0 then do;
     1015 		if code ^= et_noalloc then go to write_fails;
     1016 		md.needs_space = md.needs_space + 1;
     1017 		call tty_space_man$needs_space (md.devx);
     1018 		return;
     1019 	     end;
     1020 	     md.send_output = "0"b;
     1021 	     md.write_chain_ptr = p;			/* Remember whats left */
     1022 	     return;
     1023 	end;
     1024 
     1025 	if ^md.eot_sent then do;			/* Still must send an eot */
     1026 	     call tty_space_man$get_buffer (md.devx, 16, OUTPUT, blockp);
     1027 	     if blockp = null () then do;
     1028 		md.needs_space = md.needs_space + 1;
     1029 		call tty_space_man$needs_space (md.devx);
     1030 		return;
     1031 	     end;
     1032 	     buffer.tally = 1;
     1033 	     buffer.chars (0) = md.eot;
     1034 	     p = blockp;
     1035 	     md.eot_sent = "1"b;
     1036 	     go to send_chain;
     1037 	end;
     1038 
     1039 	md.message_in_progress = "0"b;
     1040 	return;
     1041 
     1042 write_fails: return;				/* Probably a crash coming soon */
     1043 
     1044      end send_more_message;
     1045 
     1046 /* Build write header in current buffer */
     1047 
     1048 build_header: proc;
     1049 
     1050 	buffer.chars (0) = md.stx;
     1051 	buffer.chars (1) = md.esc;
     1052 	if mde.erase_req then buffer.chars (2) = md.erase_write;
     1053 	else buffer.chars (2) = md.write;		/* Write function */
     1054 	mde.erase_req = "0"b;
     1055 	string (wcc) = "0"b;			/* No special functions */
     1056 	wcc.keyboard_restore = mde.keyboard_restore;
     1057 	mde.keyboard_restore = "0"b;
     1058 	wcc.sound_alarm = mde.sound_alarm;
     1059 	mde.sound_alarm = "0"b;
     1060 	wcc.start_printer = mde.printer;
     1061 	buffer.chars (3) = address_table (bin (string (wcc)));
     1062 	buffer.chars (4) = md.sba;			/* Position cursor where I think i should be */
     1063 	call get_position_chars (mde.position);
     1064 	buffer.chars (5) = pos_char1;
     1065 	buffer.chars (6) = pos_char2;
     1066 	buffer.tally = 7;
     1067 
     1068 	return;
     1069 
     1070      end build_header;
     1071 
     1072 /* Procedure to process input once it has arrived in its entirity */
     1073 
     1074 process_input: proc;
     1075 
     1076 dcl  delta_position fixed bin;
     1077 dcl  save_bit bit (1);
     1078 
     1079 	if md.input_chain_ptr = null () then return;
     1080 	chain_ptr = md.input_chain_ptr;
     1081 	md.input_chain_ptr = null ();
     1082 	blockp = chain_ptr;
     1083 	textp = addr (buffer.chars);
     1084 	textl = buffer.tally;
     1085 
     1086 	dev_addr = getbin (text_msg.device_address);
     1087 	if dev_addr < lbound (md.chan_map, 1) | dev_addr > hbound (md.chan_map, 1) then go to bad_dev_addr;
     1088 	subchan = md.chan_map (dev_addr);
     1089 	if subchan <= 0 then go to bad_device;		/* Address wasn't configured */
     1090 	mdep = addr (md.mde_entry (subchan));
     1091 
     1092 	if ^mde.dialed then do;			/* Iirst input */
     1093 	     if mde.listen & md.started then do;	/* And we are accepting dials */
     1094 		mde.erase_req = "1"b;
     1095 		call dialup_channel;
     1096 	     end;
     1097 	     go to discard_input;
     1098 	end;
     1099 
     1100 	if textl < 5 then go to bad_input;
     1101 
     1102 	if text_msg.aid = md.quit_key then do;		/* Function code for quit */
     1103 	     if mde.raw3270_in_effect & ^mde.hndlquit then go to send_raw_input;
     1104 	     save_bit = mde.end_of_page;
     1105 	     mde.end_of_page = "0"b;
     1106 	     if save_bit then do;
     1107 		mde.position = 0;
     1108 		mde.erase_req = "1"b;
     1109 	     end;
     1110 	     call channel_manager$interrupt (mde.devx, QUIT, "0"b);
     1111 	     if mde.hndlquit then if mde.write_chain_ptr ^= null () then do;
     1112 		     call reset_channel;
     1113 		     save_bit = "0"b;
     1114 		end;
     1115 	     if save_bit then call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
     1116 	     go to discard_input;
     1117 	end;
     1118 
     1119 	if mde.raw3270_in_effect then go to send_raw_input;
     1120 	if text_msg.aid = md.formfeed_key then do;	/* Function for ff for new page */
     1121 	     mde.erase_req, mde.keyboard_restore = "1"b;
     1122 	     mde.position = 0;
     1123 	     call queue_control;
     1124 	     if mde.end_of_page then do;
     1125 		mde.end_of_page = "0"b;
     1126 		call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
     1127 	     end;
     1128 	     else do;
     1129 		unspec (rtx_info) = "0"b;
     1130 		rtx_info.formfeed_present = "1"b;
     1131 		call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));
     1132 	     end;
     1133 	     go to discard_input;
     1134 	end;
     1135 
     1136 	if text_msg.aid ^= md.enter then go to discard_input;
     1137 	if textl < 7 then go to bad_input;
     1138 	position = get_position (text_msg.cursor1, text_msg.cursor2);
     1139 
     1140 	delta_position = position - mde.position;	/* Amount cursor moved */
     1141 	if (delta_position > (md.input_count - 7)) | (delta_position < 0) then do; /* Cant parse it */
     1142 	     mde.position = position;
     1143 	     mde.sound_alarm = "1"b;
     1144 	     mde.keyboard_restore = "1"b;
     1145 	     call queue_control;
     1146 	     go to discard_input;
     1147 	end;
     1148 
     1149 	call trim_chain_start (chain_ptr, md.input_count - (delta_position + 1)); /* Throw away leading junk */
     1150 	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);
     1151 	end;					/* Find end */
     1152 	buffer.chars (buffer.tally - 1) = md.nl;	/* Put new-line at end */
     1153 
     1154 	unspec (rtx_info) = "0"b;
     1155 	rtx_info.chain_head = rel (chain_ptr);
     1156 	rtx_info.chain_tail = rel (blockp);
     1157 	rtx_info.input_count = delta_position + 1;
     1158 	rtx_info.break_char = "1"b;
     1159 	mde.position = mod (position - mod (position, mde.line_size) + mde.line_size, mde.screen_size);
     1160 	call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));
     1161 	return;
     1162 
     1163 /* Here in raw mode to foward stuff */
     1164 
     1165 send_raw_input:
     1166 	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);
     1167 	end;					/* Find end of chain */
     1168 	unspec (rtx_info) = "0"b;
     1169 	rtx_info.chain_head = rel (chain_ptr);
     1170 	rtx_info.chain_tail = rel (blockp);
     1171 	rtx_info.input_count = md.input_count;
     1172 	rtx_info.break_char = "1"b;
     1173 	call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));
     1174 	return;
     1175 
     1176      end process_input;
     1177 
     1178 /* Procedure to trim a specified number of characters off start of chain */
     1179 
     1180 trim_chain_start: proc (p, arg_n);
     1181 
     1182 dcl  p ptr;
     1183 dcl  arg_n fixed bin;
     1184 
     1185 dcl  q ptr;
     1186 dcl  n fixed bin;
     1187 dcl  textp ptr;
     1188 dcl  textl fixed bin;
     1189 dcl  text char (textl) based (textp);
     1190 
     1191 	n = arg_n;
     1192 	do while (n > 0);
     1193 	     if p -> buffer.tally <= n then do;
     1194 		q = p;
     1195 		n = n - p -> buffer.tally;
     1196 		if p -> buffer.next = 0 then if n > 0 then
     1197 			go to trim_failure;		/* More than in chain */
     1198 		     else p = null ();		/* Exactly size of chain */
     1199 		else p = ptr (ttybp, p -> buffer.next);
     1200 		call tty_space_man$free_buffer (md.devx, INPUT, q);
     1201 	     end;
     1202 	     else do;
     1203 		textp = addr (p -> buffer.chars);
     1204 		textl = p -> buffer.tally;
     1205 		text = substr (text, n + 1);
     1206 		p -> buffer.tally = p -> buffer.tally - n;
     1207 		n = 0;
     1208 	     end;
     1209 	end;
     1210 
     1211 	return;
     1212 
     1213      end trim_chain_start;
     1214 
     1215 /* Trim characters from end of buffer chain */
     1216 
     1217 trim_chain_end: proc (arg_p, arg_n);
     1218 
     1219 dcl  arg_p ptr;
     1220 dcl  arg_n fixed bin;
     1221 
     1222 dcl  p ptr;
     1223 dcl  n fixed bin;
     1224 dcl  q ptr;
     1225 
     1226 	n = arg_n;
     1227 	do while (n > 0);
     1228 	     q = null ();
     1229 	     p = arg_p;
     1230 	     do while (p -> buffer.next ^= 0);
     1231 		q = p;
     1232 		p = ptr (ttybp, p -> buffer.next);
     1233 	     end;
     1234 	     if n < p -> buffer.tally then do;
     1235 		p -> buffer.tally = p -> buffer.tally - n;
     1236 		n = 0;
     1237 	     end;
     1238 	     else do;
     1239 		n = n - p -> buffer.tally;
     1240 		if q ^= null () then q -> buffer.next = 0;
     1241 		else if n > 0 then go to trim_failure;
     1242 		else arg_p = null ();
     1243 		call tty_space_man$free_buffer (md.devx, INPUT, p);
     1244 	     end;
     1245 	end;
     1246 	return;
     1247 
     1248      end trim_chain_end;
     1249 
     1250 trim_failure:
     1251 	call syserr (SYSERR_CRASH_SYSTEM, "^a: Error trimming buffer chain for ^a", name, md.name);
     1252 	go to trim_failure;
     1253 
     1254 /* Queue a poll request */
     1255 
     1256 queue_poll: proc;
     1257 
     1258 dcl  p ptr;
     1259 
     1260 	if md.first_poll_chan = 0 then do;
     1261 	     md.first_poll_chan = subchan;
     1262 	     md.last_poll_chan = subchan;
     1263 	end;
     1264 	else do;
     1265 	     p = addr (md.mde_entry (md.last_poll_chan));
     1266 	     p -> mde.next_poll_chan = subchan;
     1267 	     md.last_poll_chan = subchan;
     1268 	end;
     1269 	mde.next_poll_chan = 0;
     1270 	return;
     1271 
     1272      end queue_poll;
     1273 
     1274 process_polls: proc;
     1275 
     1276 	if md.output_in_progress then return;
     1277 	if md.poll_in_progress then return;
     1278 	if md.first_poll_chan ^= 0 then do;
     1279 	     subchan = md.first_poll_chan;
     1280 	     mdep = addr (md.mde_entry (subchan));
     1281 	     md.first_poll_chan = mde.next_poll_chan;
     1282 	     if md.first_poll_chan = 0 then md.last_poll_chan = 0;
     1283 	     md.poll_in_progress = "1"b;
     1284 	     call poll;
     1285 	     return;
     1286 	end;
     1287 
     1288 	if md.first_write_chan = 0 then call general_poll;
     1289 	return;
     1290 
     1291      end process_polls;
     1292 
     1293 /* Internal procedure to handle poll/select addressing and initiation */
     1294 
     1295 poll: proc;
     1296 
     1297 dcl  auto_poll fixed bin init (0);
     1298 dcl  cont char (1);					/* Controller */
     1299 dcl  dev char (1);					/* The device */
     1300 
     1301 	dev = mde.device_address;
     1302 poll_join:
     1303 	line_ctl.op = SET_POLLING_ADDR;
     1304 	cont = md.controller_poll_address;
     1305 
     1306 	if dev ^= md.last_poll_address then do;
     1307 	     md.last_poll_address = dev;
     1308 select_join:   line_ctl.val = 0;
     1309 	     valchar.data_len = 4;
     1310 	     substr (valchar.data, 1, 1) = cont;
     1311 	     substr (valchar.data, 2, 1) = cont;
     1312 	     substr (valchar.data, 3, 1) = dev;
     1313 	     substr (valchar.data, 4, 1) = dev;
     1314 	     call channel_manager$control (md.devx, "line_control", addr (line_ctl), code);
     1315 	end;
     1316 
     1317 	if line_ctl.op = SET_POLLING_ADDR then do;
     1318 	     line_ctl.op = START_POLL;
     1319 	     line_ctl.val = 0;
     1320 	     line_ctl.val (1) = auto_poll;
     1321 	     call channel_manager$control (md.devx, "line_control", addr (line_ctl), code);
     1322 	end;
     1323 	return;
     1324 
     1325 general_poll: entry;
     1326 
     1327 	dev = md.general_poll_address;
     1328 	auto_poll = 1;
     1329 	go to poll_join;
     1330 
     1331 select: entry;
     1332 
     1333 	dev = mde.device_address;
     1334 	if dev = md.last_select_address then return;
     1335 	md.last_select_address = dev;
     1336 	cont = md.controller_select_address;
     1337 	line_ctl.op = SET_SELECT_ADDR;
     1338 	go to select_join;
     1339 
     1340      end poll;
     1341 
     1342 /* Handle control function queue */
     1343 
     1344 queue_control: proc;
     1345 
     1346 dcl  p ptr;
     1347 
     1348 	if mde.control_queued then return;
     1349 	if md.first_control_chan = 0 then do;
     1350 	     md.first_control_chan = subchan;
     1351 	     md.last_control_chan = subchan;
     1352 	end;
     1353 	else do;
     1354 	     p = addr (md.mde_entry (md.last_control_chan));
     1355 	     p -> mde.next_control_chan = subchan;
     1356 	     md.last_control_chan = subchan;
     1357 	end;
     1358 	mde.next_control_chan = 0;
     1359 	mde.control_queued = "1"b;
     1360 	return;
     1361 
     1362      end queue_control;
     1363 
     1364 /* Setup message to perform control operation on the next channel */
     1365 
     1366 setup_control_chan: proc;
     1367 
     1368 dcl  prev_subchan fixed bin;
     1369 dcl  p ptr;
     1370 
     1371 	prev_subchan = 0;
     1372 	subchan = md.first_control_chan;
     1373 search_control_queue:
     1374 	if subchan = 0 then do;
     1375 	     mdep = null ();
     1376 	     return;
     1377 	end;
     1378 	mdep = addr (md.mde_entry (subchan));
     1379 	if mde.write_chain_ptr ^= null () then do;	/* Must finish output first */
     1380 	     prev_subchan = subchan;
     1381 	     subchan = mde.next_control_chan;
     1382 	     go to search_control_queue;
     1383 	end;
     1384 
     1385 	call tty_space_man$get_buffer (mde.devx, 16, OUTPUT, blockp); /* To build msg */
     1386 	if blockp = null () then do;
     1387 	     md.needs_space = md.needs_space + 1;
     1388 	     call tty_space_man$needs_space (md.devx);
     1389 	     mdep = null ();
     1390 	     return;
     1391 	end;
     1392 
     1393 	if prev_subchan = 0 then do;			/* We were first in queue */
     1394 	     md.first_control_chan = mde.next_control_chan;
     1395 	     if md.first_control_chan = 0 then md.last_control_chan = 0;
     1396 	end;
     1397 	else do;
     1398 	     p = addr (md.mde_entry (prev_subchan));
     1399 	     p -> mde.next_control_chan = mde.next_control_chan;
     1400 	     if md.last_control_chan = subchan then md.last_control_chan = prev_subchan;
     1401 	end;
     1402 	mde.next_control_chan = 0;
     1403 	mde.control_queued = "0"b;
     1404 
     1405 	call build_header;				/* Build header with kybd restore */
     1406 	call check_buffer_tally (2);
     1407 	buffer.chars (buffer.tally) = md.ic;		/* Insert cursor */
     1408 	buffer.chars (buffer.tally + 1) = md.etx;	/* Finish msg */
     1409 	buffer.tally = buffer.tally + 2;
     1410 	mde.write_chain_ptr = blockp;			/* Write this chain */
     1411 	return;
     1412 
     1413      end setup_control_chan;
     1414 
     1415 /* Internal procedure to crash the multiplexer */
     1416 
     1417 crash_mpx: proc;
     1418 
     1419 dcl  loaded bit (1);
     1420 
     1421 	loaded = md.loaded;
     1422 	md.loaded, md.loading = "0"b;
     1423 
     1424 	if loaded then do subchan = 1 to md.nchan;	/* Was loaded at time of crash */
     1425 	     mdep = addr (md.mde_entry (subchan));
     1426 	     mde.listen, mde.dialed = "0"b;
     1427 	     call reset_channel;
     1428 	     call channel_manager$interrupt (mde.devx, CRASH, "0"b);
     1429 	end;
     1430 
     1431 	return;
     1432 
     1433      end crash_mpx;
     1434 
     1435 dialup_channel: proc;
     1436 
     1437 	mde.position = 0;
     1438 	if ^mde.printer then do;
     1439 	     mde.erase_req = "1"b;
     1440 	     call queue_control;
     1441 	end;
     1442 	unspec (dialup_info) = "0"b;
     1443 	dialup_info.line_type = md.line_type;
     1444 	dialup_info.baud_rate = md.baud_rate;
     1445 	dialup_info.max_buf_size = md.max_buf_size;
     1446 	dialup_info.buffer_pad = md.buffer_pad + 4;
     1447 	dialup_info.receive_mode_device = ^mde.printer;
     1448 	call channel_manager$interrupt (mde.devx, DIALUP, unspec (dialup_info));
     1449 	mde.dialed = "1"b;
     1450 	call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
     1451 	return;
     1452 
     1453      end dialup_channel;
     1454 
     1455 reset_channel: proc;
     1456 
     1457 dcl  (p, q) ptr;
     1458 dcl  loop_count fixed bin;
     1459 dcl  save_subchan fixed bin;
     1460 
     1461 	if mde.write_chain_ptr = null () then return;
     1462 	p = mde.write_chain_ptr;
     1463 	mde.write_chain_ptr = null ();
     1464 	call tty_space_man$free_chain (mde.devx, OUTPUT, p);
     1465 	if ^mde.write_queued then return;
     1466 	if md.first_write_chan = 0 then goto reset_channel_failed; /* Wonder where the write went */
     1467 	if md.first_write_chan = subchan then do;	/* First in chain */
     1468 	     md.first_write_chan = mde.next_write_chan;
     1469 	     if md.first_write_chan = 0 then md.last_write_chan = 0;
     1470 	end;
     1471 	else do;
     1472 	     loop_count = 0;
     1473 	     q = addr (md.mde_entry (md.first_write_chan)); /* Find channel before this one */
     1474 	     save_subchan = md.first_write_chan;
     1475 	     do while (q -> mde.next_write_chan ^= subchan);
     1476 		save_subchan = q -> mde.next_write_chan;
     1477 		q = addr (md.mde_entry (q -> mde.next_write_chan));
     1478 						/* Make sure we are not looping */
     1479 		if loop_count > md.nchan | save_subchan = 0 then goto reset_channel_failed;
     1480 		loop_count = loop_count + 1;
     1481 	     end;
     1482 	     q -> mde.next_write_chan = mde.next_write_chan;
     1483 	     if subchan = md.last_write_chan then md.last_write_chan = save_subchan;
     1484 	end;
     1485 reset_channel_restart:
     1486 	mde.next_write_chan = 0;
     1487 	mde.write_queued = "0"b;
     1488 	mde.end_of_page = "0"b;
     1489 	if ^md.loaded | ^mde.dialed then return;
     1490 	call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);
     1491 	return;
     1492 
     1493 reset_channel_failed:
     1494 
     1495 	call syserr (BEEP, "^a: Could not find queued write on ^a.", name, md.name);
     1496 	goto reset_channel_restart;
     1497 
     1498 
     1499      end reset_channel;
     1500 
     1501 /* Test the current buffer for room for additional characters */
     1502 
     1503 check_buffer_tally: proc (n);
     1504 
     1505 dcl  n fixed bin;
     1506 
     1507 	if (buffer.tally + n) > (max_buffer_tally (buffer.size_code) - md.buffer_pad) then
     1508 	     call syserr (SYSERR_CRASH_SYSTEM, "^a: Buffer tally error on ^a.", name, md.name);
     1509 	else return;
     1510 
     1511      end check_buffer_tally;
     1512 
     1513 /* This entry is called when mpx_data is being built to set the address of the translation table */
     1514 /* This is necessary because the actual data is in the text of this module, but is used by priv_ibm3270_mpx */
     1515 
     1516 set_address_table: entry (arg_mdp);
     1517 
     1518 	mdp = arg_mdp;
     1519 	if md.ascii then md.address_tablep = addr (ascii_address_table);
     1520 	else md.address_tablep = addr (ebcdic_address_table);
     1521 	return;
     1522 
     1523 /* Initialization entry. Called by priv_ibm3270_mpx once per Multics bootload
     1524*   the first time an ibm3270 multiplexer is initialized. */
     1525 
     1526 init: entry;
     1527 
     1528 	et_undefined_order_request = error_table_$undefined_order_request;
     1529 	et_improper_data_format = error_table_$improper_data_format;
     1530 	et_noalloc = error_table_$noalloc;
     1531 	et_bad_mode = error_table_$bad_mode;
     1532 
     1533 	call wire_proc$wire_me;
     1534 	return;
     1535 
     1536 /* Entry to dialup a subchannel */
     1537 
     1538 dialup: entry (arg_mdp, arg_subchan);
     1539 
     1540 	mdp = arg_mdp;
     1541 	subchan = arg_subchan;
     1542 	mdep = addr (md.mde_entry (subchan));
     1543 	call dialup_channel;
     1544 	return;
     1545 
     1546 /* Entry called at bootload time to kick off general polling */
     1547 
     1548 start_general_poll: entry (arg_mdp);
     1549 
     1550 	mdp = arg_mdp;
     1551 	mdep = null ();				/* A precaution */
     1552 	call general_poll;
     1553 	return;
     1554 
     1555 /* Entry to crash the multiplexer */
     1556 
     1557 crash: entry (arg_mdp);
     1558 
     1559 	mdp = arg_mdp;
     1560 	call crash_mpx;
     1561 	return;
     1562 
     1563 /* BEGIN MESSAGE DOCUMENTATION
     1564*
     1565*   Message:
     1566*   ibm3270_mpx: Unrecognized interrupt for CHANNEL. INT_TYPE INTERRUPT_INFO
     1567*
     1568*   S:	$info
     1569*
     1570*   T:	$run
     1571*
     1572*   M:	An interrupt was received from the FNP which does not have a defined
     1573*   action.  The type of interrupt received is INT_TYPE and the information
     1574*   supplied with the interrupt is INTERRUPT_INFO.
     1575*
     1576*   A:	$inform
     1577*
     1578*   Message:
     1579*   ibm3270_mpx: Unrecognized input for CHANNEL: DATA
     1580*
     1581*   S:	$info
     1582*
     1583*   T:	$run
     1584*
     1585*   M:	DATA received from CHANNEL does not meet certain format requirements.
     1586*   This message is only displayed if in debug mode.
     1587*
     1588*   A:	$inform
     1589*
     1590*   Message:
     1591*   ibm3270_mpx: Input for illegal device address DEV_ADDRESS on CHANNEL
     1592*
     1593*   S:	$info
     1594*
     1595*   T:	$run
     1596*
     1597*   M:	Received input for a device whose address (DEV_ADDRESS) is not in the
     1598*   channel map for CHANNEL.
     1599*
     1600*   A:	$inform
     1601*
     1602*   Message:
     1603*   ibm3270_mpx: Input for unconfigured device DEV_ADDRESS on CHANNEL
     1604*
     1605*   S:	$info
     1606*
     1607*   T:	$run
     1608*
     1609*   M:	Received input for a device (DEV_ADDRESS) whose subchannel was
     1610*   <= 0 in the channel map for CHANNEL.
     1611*
     1612*   A:	$inform
     1613*
     1614*   Message:
     1615*   ibm3270_mpx: Attempt to queue write while write queued CHANNEL.SUBCHANNEL
     1616*
     1617*   S:	$log
     1618*
     1619*   T:	$run
     1620*
     1621*   M:	An attempt was made to queue a write while a previous write was still
     1622*   queued.  A dump of the subchannel entry as defined by the mde structure in
     1623*   ibm3270_mpx_data.incl.pl1 is included with this message.
     1624*
     1625*   A:	$ignore
     1626*
     1627*   Message:
     1628*   ibm3270_mpx: Error trimming buffer chain for CHANNEL
     1629*
     1630*   S:	$crash
     1631*
     1632*   T:	$run
     1633*
     1634*   M:	An inconsistency was found while trimming the buffer chain for
     1635*   CHANNEL which is stored in tty_buf.
     1636*
     1637*   A:	$inform
     1638*
     1639*   Message:
     1640*   ibm3270_mpx: Could not find queued write on CHANNEL.
     1641*
     1642*   S:	$beep
     1643*
     1644*   T:	$run
     1645*
     1646*   M:	The reset_channel internal procedure could not find a queued write on
     1647*   CHANNEL or it detected itself looping in releasing queued writes for
     1648*   CHANNEL.  Will attempt to continue.
     1649*
     1650*   A:	$inform
     1651*
     1652*   Message:
     1653*   ibm3270_mpx: Buffer tally error on CHANNEL.
     1654*
     1655*   S:	$crash
     1656*
     1657*   T:	$run
     1658*
     1659*   M:	An attempt was made to add characters to a buffer which should have
     1660*   fit but couldn't.
     1661*
     1662*   A:	$inform
     1663*
     1664*   END MESSAGE DOCUMENTATION */
     1665 
     1666 
  1     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  1     2 
  1     3 /* Date Last Modified and Reason
  1     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  1     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  1     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  1     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  1     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  1     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  1    10*   Modified November 1979 by C. Hornig for MCS tracing.
  1    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  1    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  1    13*   Modified March 1980 by Robert Coren to reorganize metering information
  1    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  1    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  1    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  1    17**/
  1    18 
  1    19 dcl  ttybp ptr,
  1    20      tty_buf$ ext static,				/* tty buffer segment */
  1    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  1    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  1    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  1    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  1    25 
  1    26 
  1    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  1    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  1    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  1    30 
  1    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  1    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  1    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  1    34 
  1    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  1    36     2 slock bit (36),				/* per system lock */
  1    37     2 absorig fixed bin (24),				/* abs address of this seg */
  1    38     2 borig bit (18),				/* index of start of buffer area */
  1    39     2 bleft fixed bin (18),				/* words left in pool */
  1    40     2 free bit (18),				/* pointer to start of free pool */
  1    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  1    42     2 padb1 bit (28) unaligned,
  1    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  1    44 
  1    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  1    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  1    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  1    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  1    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  1    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  1    51     2 minbuf fixed bin (18),				/* min output buffer size */
  1    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  1    53 
  1    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  1    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  1    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  1    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  1    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  1    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  1    60 
  1    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  1    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  1    63     2 bfx fixed bin,				/* used in calls to iobm */
  1    64     2 nquits fixed bin (35),				/* number of quits */
  1    65     2 space_needed_data,
  1    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  1    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  1    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  1    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  1    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  1    71 
  1    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  1    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  1    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  1    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  1    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  1    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  1    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  1    79 
  1    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  1    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  1    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  1    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  1    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  1    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  1    86 
  1    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  1    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  1    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  1    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  1    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  1    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  1    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  1    94 
  1    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  1    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  1    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  1    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  1    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  1   100     2 echo_neg_mux_nonecho fixed bin (35),
  1   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  1   102 
  1   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  1   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  1   105     2 trace unaligned,				/* tracing information */
  1   106       3 flags,
  1   107       4 enable bit,					/* global tracing control */
  1   108       4 default_mode bit,				/* whether to trace channels by default */
  1   109       4 read bit,					/* read */
  1   110       4 write bit,					/* write */
  1   111       4 data bit,					/* buffers on reads and writes */
  1   112       4 control bit,				/* control, priv_control, and hpriv_control */
  1   113       4 modes bit,					/* (get set check)_modes */
  1   114       4 interrupt bit,				/* interrupt, interrupt_later */
  1   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  1   116       4 start bit,					/* start, stop */
  1   117       4 shutdown bit,				/* shutdown */
  1   118       4 space_man bit,				/* tty_space_man$* */
  1   119       4 pad_flags bit (6),
  1   120       3 data_offset bit (18),				/* offset of tracing data */
  1   121 
  1   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  1   123 
  1   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  1   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  1   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  1   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  1   128 
  1   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  1   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  1   131 
  1   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  1   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  1   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  1   135 
  1   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  1   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  1   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  1   139 
  1   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  1   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  1   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  1   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  1   144 
  1   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  1   146 
  1   147     2 pad2 (13) fixed bin (35),
  1   148 
  1   149     2 free_space fixed bin;				/* start of free space region */
  1   150 
  1   151 
  2     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2     2 
  2     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  2     4 
  2     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     6 
  2     7 /* format: style3 */
  2     8 
  2     9 declare	lock_ptr		pointer;
  2    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  2    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    13 	  2 flags		aligned,
  2    14 	    3 notify_sw	bit (1) unaligned,
  2    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    16 
  2    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  1   152 
  1   153 
  1   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
     1667 
     1668 
  3     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
  3     2 
  3     3 /* Defines constants and structures  used by MCS interrupt handlers */
  3     4 
  3     5 /* Created 08/21/78 by Robert Coren */
  3     6 /* Echo negotiation types added sometime by Bernie Greenberg */
  3     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
  3     8 /* MASKED type added June 23, 1982, by Robert Coren */
  3     9 
  3    10 dcl  DIALUP fixed bin int static options (constant) init (1);
  3    11 dcl  HANGUP fixed bin int static options (constant) init (2);
  3    12 dcl  CRASH fixed bin int static options (constant) init (3);
  3    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
  3    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
  3    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
  3    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
  3    17 dcl  QUIT fixed bin int static options (constant) init (8);
  3    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
  3    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
  3    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
  3    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
  3    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
  3    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
  3    24 dcl  TIMER fixed bin int static options (constant) init (15);
  3    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
  3    26 dcl  MASKED fixed bin int static options (constant) init (17);
  3    27 
  3    28 dcl  interrupt_info bit (72) aligned;
  3    29 
  3    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
  3    31     2 line_type fixed bin (9) unal uns,
  3    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
  3    33     2 baud_rate fixed bin (18) unal uns,
  3    34     2 max_buf_size fixed bin (9) unal uns,
  3    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
  3    36     2 pad bit (26) unal;
  3    37 
  3    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
  3    39     2 input_chain unaligned,
  3    40       3 chain_head bit (18) unaligned,
  3    41       3 chain_tail bit (18) unaligned,
  3    42     2 input_count fixed bin (18) unal uns,
  3    43     2 flags unaligned,
  3    44       3 break_char bit (1),				/* data contains a break character */
  3    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
  3    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
  3    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
  3    48       3 pad bit (14);
  3    49 
  3    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
  3    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
  3    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
  3    53 
  3    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
     1669 
     1670 
  4     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  4     2 
  4     3 /* Created 8/25/78 by J. Stern */
  4     4 
  4     5 
  4     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  4     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  4     8 
  4     9 /* call channel_manager$write (devx, output_ptr, code) */
  4    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  4    11 
  4    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  4    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  4    14 
  4    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  4    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  4    17 
  4    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  4    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  4    20 
  4    21 /* call channel_manager$get_modes (devx, modes, code) */
  4    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  4    23 
  4    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  4    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  4    26 
  4    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  4    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  4    29 
  4    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  4    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  4    32 
  4    33 
  4    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
     1671 
     1672 
  5     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  5     2 
  5     3 /* This include file declares all the entries in tty_space_man and defines the constants
  5     4**  to be used for the flags argument
  5     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  5     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  5     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  5     8**/
  5     9 
  5    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  5    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  5    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  5    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  5    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  5    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  5    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  5    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  5    18 dcl  tty_space_man$needs_space entry (fixed bin);
  5    19 
  5    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  5    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  5    22 
  5    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
     1673 
     1674 
  6     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  6     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  6     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  6     9*     implementation.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 
  6    13 /*
  6    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  6    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  6    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  6    17**/
  6    18 
  6    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  6    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  6    21 
  6    22 
  6    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  6    24     2 next bit (18),				/* foward pointer to next free block */
  6    25     2 size fixed bin;				/* number of words in this block */
  6    26 
  6    27 
  6    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  6    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  6    30     2 flags unaligned,
  6    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  6    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  6    33       3 break bit (1) unaligned,			/* buffer contains break character */
  6    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  6    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  6    36       3 pad bit (1) unaligned,
  6    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  6    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  6    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  6    40 
  6    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  6    42 
  6    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  6    44 
  6    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
     1675 
     1676 
  7     1 /* BEGIN INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
  7     2 
  7     3 /* Created 4/9/79 by J. Stern */
  7     4 /* Modified: 10 November 1980 by G. Palter to add can_type */
  7     5 
  7     6 
  7     7 dcl  mclp ptr;
  7     8 dcl  mcl_version_2 fixed bin int static options (constant) init (2);
  7     9 
  7    10 dcl 1 mcl aligned based (mclp),			/* modes change list */
  7    11       2 version fixed bin,				/* version number of this structure (Input) */
  7    12       2 n_entries fixed bin,				/* number of mode change entries (Input) */
  7    13       2 line_len fixed bin,				/* new line length (-1 => no change) (Input) */
  7    14       2 page_len fixed bin,				/* new page length (-1 => no change) (Input) */
  7    15       2 can_type fixed binary,			/* new canonicalization type (-1 => no change) (Input) */
  7    16       2 flags,
  7    17         3 init bit (1) unal,				/* ON if all modes to be reinitialized (Input) */
  7    18         3 ll_error bit (1) unal,			/* ON if line length error detected (Output) */
  7    19         3 pl_error bit (1) unal,			/* ON if page length error detected (Output) */
  7    20         3 can_type_error bit (1) unaligned,		/* ON if can_type error detected (Output) */
  7    21         3 mbz bit (32) unal,
  7    22       2 entries (36) like mcle;			 /* one entry per mode change */
  7    23 
  7    24 dcl  mclep ptr;
  7    25 
  7    26 dcl 1 mcle aligned based (mclep),			/* mode change list entry */
  7    27       2 mode_name char (16) unal,			/* name of mode to change (Input) */
  7    28       2 flags,
  7    29         3 mode_switch bit (1) unal,			/* ON to turn mode on, else OFF (Input) */
  7    30         3 force bit (1) unal,				/* ON to ignore errors for this mode change (Input) */
  7    31         3 mpx_mode bit (1) unal,			/* ON if mode recognized by multiplexer (Output) */
  7    32         3 error bit (1) unal,				/* ON if mode change is in error (Output) */
  7    33         3 mbz bit (32) unal;
  7    34 
  7    35 
  7    36 /* END INCLUDE FILE ... mcs_modes_change_list.incl.pl1 */
     1677 
     1678 
  8     1 /* BEGIN INCLUDE FILE .... bisync_line_data.incl.pl1 */
  8     2 /* Written:  October 1977 by Larry Johnson */
  8     3 /* Modified: November 1979 by Larry Johnson and Gary Palter for HASP */
  8     4 /* Modified: February 1984 by G. Palter for HASP system wait-a-bit changes */
  8     5 
  8     6 /* Structures and codes for doing line_control and line_status operations on bisync lines */
  8     7 
  8     8 /* For line_control order */
  8     9 
  8    10 dcl 1 line_ctl aligned,
  8    11     2 op fixed binary (17) unaligned,			/* indicates action being performed */
  8    12     2 val (3) fixed binary (17) unaligned;		/* optional arguments with some ops */
  8    13 
  8    14 dcl 1 valchar based (addr (line_ctl.val (1))),		/* character overlay of line_ctl.val */
  8    15     2 data_len fixed binary (9) unaligned unsigned,
  8    16     2 data character (5) unaligned;
  8    17 
  8    18 
  8    19 /* Values for line_ctl.op */
  8    20 
  8    21 dcl (SET_BID_LIMIT		     initial (1),
  8    22      ACCEPT_BID		     initial (2),
  8    23      CONFIGURE		     initial (3),		/* val(1): 0 = non-transparent ASCII, 1 = not-tranparent EBCDIC,
  8    24*							 2 = transparent ASCII, 3 = transparent EBCDIC */
  8    25      SET_TTD_PARAMS		     initial (4),		/* val(1): ttd_time;  val(2): ttd_limit */
  8    26      REPORT_WRITE_STATUS	     initial (5),		/* Request FNP to report on output buffers */
  8    27      SET_3270_MODE		     initial (6),
  8    28      SET_POLLING_ADDR	     initial (7),
  8    29      START_POLL		     initial (8),
  8    30      SET_SELECT_ADDR	     initial (9),
  8    31      STOP_AUTO_POLL		     initial (10),
  8    32      SET_MASTER_SLAVE_MODE	     initial (11),		/* val(1): 0 = slave (host), 1 = master (workstation) */
  8    33      SET_HASP_MODE		     initial (12),
  8    34      SET_NAK_LIMIT		     initial (13),		/* val(1): maximum # of NAKs allowed in a row */
  8    35      SET_HASP_TIMERS	     initial (14))		/* val(1): initial connect timeout;  val(2): receive timeout;
  8    36*						   val(3): transmit timeout */
  8    37 	fixed binary static options (constant);
  8    38 
  8    39 
  8    40 /* For line status order */
  8    41 
  8    42 dcl 1 line_stat aligned,
  8    43     2 op fixed binary (17) unaligned,			/* contains reason for status */
  8    44     2 val (3) fixed binary (17) unaligned;
  8    45 
  8    46 
  8    47 /* Values for line_stat.op */
  8    48 
  8    49 dcl (BID_FAILED		     initial (1),
  8    50      BAD_BLOCK		     initial (2),
  8    51      REVERSE_INTERRUPT	     initial (3),
  8    52      TOO_MANY_NAKS		     initial (4),
  8    53      FNP_WRITE_STATUS	     initial (5),
  8    54      IBM3270_WRITE_COMPLETE	     initial (6),
  8    55      IBM3270_WACK_MESSAGE	     initial (7),
  8    56      IBM3270_WRITE_EOT	     initial (8),
  8    57      IBM3270_WRITE_ABORT	     initial (9),
  8    58      IBM3270_SELECT_FAILED	     initial (10),
  8    59      IBM3270_WACK_SELECT	     initial (11),
  8    60      IBM3270_NAK_OUTPUT	     initial (12),
  8    61      HASP_INIT_COMPLETE	     initial (13),
  8    62      HASP_FOREIGN_SWAB_RESET	     initial (14))
  8    63 	fixed binary static options (constant);
  8    64 	
  8    65 /* END INCLUDE FILE ..... bisync_line_data.incl.pl1 */
     1679 
     1680 
  9     1 /* Begin include file ..... ibm3270_mpx_load_data.incl.pl1 */
  9     2 
  9     3 /* Defines data passed between as_ibm3270_mpx_ and priv_ibm3270_mpx when loading an ibm3270 multiplexer */
  9     4 
  9     5 /* Prepared May 1979 by Larry Johnson */
  9     6 
  9     7 dcl  load_infop ptr;
  9     8 dcl  load_info_nchan fixed bin;
  9     9 
  9    10 dcl 1 load_info aligned based (load_infop),
  9    11     2 event_channel fixed bin (71),
  9    12     2 flags unal,
  9    13       3 ascii bit (1),				/* Use ascii protocol */
  9    14       3 debug bit (1),				/* Print unusual stuff */
  9    15       3 allow_raw3270 bit (1),			/* Sub-channels may use raw3270 mode */
  9    16       3 allow_copy bit (1),				/* Sub-channels in raw3270 may do copies */
  9    17       3 pad bit (32) unal,
  9    18     2 controller_address fixed bin,			/* device address for controller */
  9    19     2 quit_key fixed bin,				/* code to indicate which key is quit */
  9    20     2 formfeed_key fixed bin,				/* code for formfeed key */
  9    21     2 nchan fixed bin,
  9    22     2 chan_info (load_info_nchan) like chan_load_info;
  9    23 
  9    24 dcl  chan_load_infop ptr;
  9    25 
  9    26 dcl 1 chan_load_info aligned based (chan_load_infop),	/* Per channel part of data */
  9    27     2 devx fixed bin,				/* Which channel */
  9    28     2 screen_size fixed bin,
  9    29     2 line_size fixed bin;
  9    30 
  9    31 dcl (IBM3270_MPX_UP init (1),
  9    32      IBM3270_MPX_DOWN init (2),
  9    33      IBM3270_MPX_MASKED init (3)) fixed bin (71) int static options (constant);
  9    34 
  9    35 /* codeing for quit and formfeed keys */
  9    36 
  9    37 dcl (PA1 init (1),
  9    38      PA2 init (2),
  9    39      PA3 init (3),
  9    40      CLEAR init (4)) fixed bin int static options (constant);
  9    41 
  9    42 /* End include file .....ibm3270_mpx_load_data.incl.pl1 */
     1681 
     1682 
 10     1 /* Begin include file ..... ibm3270_mpx_data.incl.pl1 */
 10     2 
 10     3 /* Describes ring-0 data bases used by the ibm3270 demultiplexer */
 10     4 /* Prepared May 1979 by Larry Johnson */
 10     5 
 10     6 dcl  mdp ptr;
 10     7 dcl  md_nchan fixed bin;
 10     8 
 10     9 dcl 1 md aligned based (mdp),				/* Global data */
 10    10 
 10    11 /* Static items */
 10    12 
 10    13     2 event_channel fixed bin (71),			/* Event channel to talk to AS over */
 10    14     2 processid bit (36),				/* AS processid */
 10    15     2 devx fixed bin,				/* Devx of major channel */
 10    16     2 name char (32),				/* Name of major channel */
 10    17     2 nchan fixed bin,				/* Count of subchannels */
 10    18     2 controller_address fixed bin,			/* Address of controler, defaults to 0 */
 10    19     2 controller_poll_address char (1),
 10    20     2 controller_select_address char (1),
 10    21     2 general_poll_address char (1),
 10    22     2 dialup_info,					/* Data saved from dialup interrupt */
 10    23       3 line_type fixed bin,
 10    24       3 baud_rate fixed bin,
 10    25       3 max_buf_size fixed bin,
 10    26       3 buffer_pad fixed bin,
 10    27     2 chars unal,					/* Various ascii/ebcdic dependent chars */
 10    28       3 nl char (1),				/* Newline character */
 10    29       3 sba char (1),				/* Set-buffer-address code */
 10    30       3 stx char (1),				/* Start of text code */
 10    31       3 esc char (1),				/* Escape code */
 10    32       3 write char (1),				/* Function code for write */
 10    33       3 erase_write char (1),				/* Function code for erase-write */
 10    34       3 ic char (1),				/* Insert cursor */
 10    35       3 etx char (1),				/* End of text */
 10    36       3 soh char (1),				/* Start of header */
 10    37       3 eot char (1),				/* End of transmission */
 10    38       3 percent char (1),				/* A "%" */
 10    39       3 slash char (1),				/* A "/" */
 10    40       3 letter_R char (1),				/* A "R" */
 10    41       3 etb char (1),				/* End of text block */
 10    42       3 enter char (1),				/* AID field for enter */
 10    43       3 clear char (1),				/* AID field for clear */
 10    44       3 pa1 char (1),				/* AID field for PA1 */
 10    45       3 pa2 char (1),				/* AID field for PA2 */
 10    46       3 pa3 char (1),				/* AID field for PA3 */
 10    47       3 bs char (1),				/* Backspace */
 10    48       3 cr char (1),				/* Carriage return */
 10    49       3 em char (1),				/* End of media */
 10    50       3 copy char (1),				/* Function code to copy a screen */
 10    51     2 action_chars unal,
 10    52       3 quit_key char (1),				/* Function code to interpret as quit */
 10    53       3 formfeed_key char (1),			/* Function code to interpret as formfeed */
 10    54     2 address_tablep ptr,				/* Pointer to ebcdic or ascii table */
 10    55     2 chan_map (0:31) fixed bin (8) unal,		/* Maps poll address into mde index */
 10    56 
 10    57 /* Dynamic items */
 10    58 
 10    59     2 last_poll_address char (1),			/* Last poll address sent to FNP */
 10    60     2 first_control_chan fixed bin,			/* First channal in control function queue */
 10    61     2 last_control_chan fixed bin,			/* The last */
 10    62     2 last_select_address char (1),			/* Likewise for select */
 10    63     2 first_write_chan fixed bin,			/* First channel in write queue */
 10    64     2 last_write_chan fixed bin,			/* Last channel in write queue */
 10    65     2 cur_write_chan fixed bin,			/* If output in progres */
 10    66     2 write_chain_ptr ptr unal,			/* For cur_write_chan */
 10    67     2 first_poll_chan fixed bin,			/* First channel in poll queue */
 10    68     2 last_poll_chan fixed bin,			/* Last channel in poll queue */
 10    69     2 input_chain_ptr ptr,				/* Currently accumulating input chain */
 10    70     2 input_count fixed bin,				/* Its length */
 10    71     2 error_stat like ibm3270_meters,			/* Error statstics */
 10    72     2 saved_meters_ptr ptr,				/* address of savedf copy of meters */
 10    73     2 flags,
 10    74       3 ascii bit (1) unal,				/* Use ascii protocol */
 10    75       3 debug bit (1) unal,
 10    76       3 loading bit (1) unal,				/* Load in progress */
 10    77       3 loaded bit (1) unal,				/* Load complete */
 10    78       3 started bit (1) unal,				/* In started state */
 10    79       3 poll_in_progress bit (1) unal,			/* FNP has device poll in progress */
 10    80       3 output_in_progress bit (1) unal,		/* Working on output, goes off with line status */
 10    81       3 message_in_progress bit (1) unal,		/* Working on output, goes off when data passed on */
 10    82       3 eot_sent bit (1) unal,			/* If eot has been entor current output */
 10    83       3 send_output bit (1) unal,			/* Mpx has been told send output */
 10    84       3 allow_raw3270 bit (1) unal,			/* Sub-channels may use raw3270 mode */
 10    85       3 allow_copy bit (1) unal,			/* Sub-channels may use copy feature */
 10    86       3 pad bit (24) unal,
 10    87     2 mde_entry (md_nchan refer (md.nchan)) like mde;	/* Per-channel data */
 10    88 
 10    89 dcl  address_table (0:63) char (1) unal based (md.address_tablep);
 10    90 
 10    91 dcl  mdep ptr;
 10    92 
 10    93 dcl 1 mde aligned based (mdep),			/* Per channel data */
 10    94     2 devx fixed bin,				/* Devx of sub-channel */
 10    95     2 name char (3),				/* Last component of name, {p|d}NN */
 10    96     2 device_address char (1),			/* Address for poll and selects */
 10    97     2 screen_size fixed bin,				/* Number of characters on screen, 480/1920 */
 10    98     2 line_size fixed bin,				/* Number of characters on line, 40/80 */
 10    99     2 position fixed bin,				/* Where cursor should be */
 10   100     2 next_write_chan fixed bin,			/* Next channel in the write queue */
 10   101     2 next_poll_chan fixed bin,			/* Next channel in the poll queue */
 10   102     2 next_control_chan fixed bin,			/* Next channel in control function queue */
 10   103     2 write_chain_ptr ptr unal,			/* Pointer to write chain for this device */
 10   104     2 flags,
 10   105       3 listen bit (1) unal,
 10   106       3 dialed bit (1) unal,
 10   107       3 printer bit (1) unal,
 10   108       3 hndlquit bit (1) unal,			/* Setting of the mode */
 10   109       3 waiting_for_ready bit (1) unal,			/* Waiting for prinnr to finish */
 10   110       3 erase_req bit (1) unal,			/* Erase screen on next write */
 10   111       3 sound_alarm bit (1) unal,			/* Turn on beeper on next chance */
 10   112       3 control_queued bit (1) unal,			/* Channel in unlock queue */
 10   113       3 end_of_page bit (1) unal,			/* Waiting for responce to start output */
 10   114       3 keyboard_restore bit (1) unal,			/* Must unlock keyboard */
 10   115       3 rawo bit (1) unal,				/* Current state of channels rawo mode */
 10   116       3 rawi bit (1) unal,				/* Current state of channels rawi mode */
 10   117       3 raw3270 bit (1) unal,				/* Special raw mode for 3270's */
 10   118       3 raw3270_in_effect bit (1) unal,			/* Equals rawi & rawo & raw3270 */
 10   119       3 write_queued bit (1) unal,
 10   120       3 pad bit (21) unal;
 10   121 
 10   122 /* End include file ..... ibm3270_mpx_data.incl.pl1 */
     1683 
     1684 
 11     1 /* BEGIN INCLUDE FILE ... ibm3270_meters.incl.pl1 */
 11     2 
 11     3 /* defines metering structures used for ibm3270 multiplexer channel */
 11     4 
 11     5 /* Written June 1981 by Robert Coren */
 11     6 
 11     7 dcl 1 ibm3270_meter_struc aligned based,
 11     8     2 version fixed bin,
 11     9     2 pad bit (36),
 11    10     2 current_meters like ibm3270_meters,
 11    11     2 saved_meters like ibm3270_meters;
 11    12 
 11    13 dcl 1 ibm3270_meters aligned based (meter_ptr),
 11    14     2 poll_failed fixed bin (35),			/* No response to poll */
 11    15     2 bad_output fixed bin (35),			/* Bsc control tables rejected output */
 11    16     2 write_eot fixed bin (35),			/* Got eot in responseto write */
 11    17     2 write_abort fixed bin (35),			/* FNP send eot because of nothing to write */
 11    18     2 select_failed fixed bin (35),			/* No response to select */
 11    19     2 wack_select fixed bin (35),			/* Wack in respnse to select */
 11    20     2 nak_output fixed bin (35),			/* Our output got nakked */
 11    21     2 input_reject fixed bin (35),			/* Count of input reject interrupts */
 11    22     2 needs_space fixed bin (35),			/* Count of times space available interrupt req */
 11    23     2 space_available fixed bin (35),			/* Count of space available interrupts */
 11    24     2 write_format_error fixed bin (35),		/* Count of bad calls to write entry */
 11    25     2 bad_input fixed bin (35),			/* Count of ill-formatted input messages */
 11    26     2 bad_device fixed bin (35);			/* Count of unrecognized device identifications */
 11    27 
 11    28 dcl  meter_ptr ptr;
 11    29 
 11    30 dcl  IBM3270_METERS_VERSION_1 internal static options (constant) init (1);
 11    31 
 11    32 /* END INCLUDE FILE ... ibm3270_meters.incl.pl1 */
     1685 
     1686 
 12     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
 12     2 
 12     3 /* This include file has an ALM version, keep 'em in sync. */
 12     4 
 12     5 /* format: off */
 12     6 
 12     7 /* Modified January 1984 by Paul Farley to add an array of entry values
 12     8*   to be examined by display_cpu_error. */
 12     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
 12    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
 12    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
 12    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
 12    13*		also changed some codes to "SB_unused_NN" - see line comments */
 12    14 
 12    15 /* In the future, these will be the only constants needed in this include
 12    16*file.  They are the binary data class strings for messages in the new format
 12    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
 12    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
 12    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
 12    20 
 12    21 dcl (						/* include file name */
 12    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
 12    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
 12    24 SB_mos_data_class		init ("mos"),		/* scr */
 12    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
 12    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
 12    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
 12    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
 12    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
 12    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
 12    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
 12    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
 12    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
 12    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
 12    35 ) static internal char (16) varying options (constant);
 12    36 
 12    37 
 12    38 /************************
 12    39*Once the syserr$binary is replaced with something that takes real data classes
 12    40*and all system modules and tools are upgraded to use the new interface, the
 12    41*rest of this include file may be discarded.
 12    42*************************/
 12    43 
 12    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
 12    45*   extended at any time. */
 12    46 
 12    47 dcl (
 12    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
 12    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
 12    50 SB_io_err		init (3),		SBL_io_err	init (5),
 12    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
 12    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
 12    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
 12    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
 12    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
 12    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
 12    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
 12    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
 12    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
 12    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
 12    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
 12    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
 12    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
 12    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
 12    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
 12    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
 12    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
 12    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
 12    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
 12    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
 12    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
 12    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
 12    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
 12    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
 12    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
 12    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
 12    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
 12    78   ) internal static options (constant) fixed bin;
 12    79 
 12    80 
 12    81 /* The following array is a mapping of the old syserr$binary codes into the
 12    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
 12    83*the binary data codes stored in the wired syserr log (see above) into the data
 12    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
 12    85*is also used by syserr_log_util_ to translate the data classes back into the
 12    86*corresponding binary code (for tools not yet upgraded to deal with the new
 12    87*format log messages). */
 12    88 
 12    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
 12    90 	init (	"io_status",		/* 1 */
 12    91 		"hwfault",		/* 2 */
 12    92 		"io_status",		/* 3 */
 12    93 		"unused_4",		/* 4 */
 12    94 		"mos",			/* 5 */
 12    95 
 12    96 		"unused_6",		/* 6 */
 12    97 		"unused_7",		/* 7 */
 12    98 		"unused_8",		/* 8 */
 12    99 		"unused_9",		/* 9 */ 
 12   100 		"unused_10",		/* 10 */
 12   101 
 12   102 		"segdamage",		/* 11 */
 12   103 		"unused_12",		/* 12 */
 12   104 		"segdamage",		/* 13 */
 12   105 		"unused_14",		/* 14 */
 12   106 		"unused_15",		/* 15 */
 12   107 
 12   108 		"segdamage",		/* 16 */
 12   109 		"voldamage",		/* 17 */
 12   110 		"unused_18",		/* 18 */
 12   111 		"mdc_del_uidpath",		/* 19 */
 12   112 		"io_status",		/* 20 */
 12   113 
 12   114 		"mmdam",			/* 21 */
 12   115 		"hwfault",		/* 22 */
 12   116 		"io_status",		/* 23 */
 12   117 		"mpc_poll",		/* 24 */
 12   118 		"fnp_poll",		/* 25 */
 12   119 
 12   120 		"config_deck",		/* 26 */
 12   121 		"vtoce",			/* 27 */
 12   122 		"access_audit",		/* 28 */
 12   123 		"unused_29",		/* 29 */
 12   124 		"unused_30",		/* 30 */
 12   125 		"unused_31",		/* 31 */
 12   126 		"unused_32",		/* 32 */
 12   127 		"unused_33",		/* 33 */
 12   128 		"unused_34",		/* 34 */
 12   129 		"ibm3270_mde",		/* 35 */
 12   130 		"unused_36"		/* 36 */
 12   131 	);
 12   132 
 12   133 
 12   134 /* format: on */
 12   135 
 12   136 /* These constants are used by various tools which analyze syserr messages and
 12   137*still call the old interface "syserr_log_util_". */
 12   138 
 12   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
 12   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
 12   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
 12   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
 12   143 
 12   144      dcl	   display_cpu_error_binary_defs (2) init (
 12   145 			      2,			/** SB_hw_fault */
 12   146 			      22			/** SB_verify_lock */
 12   147 			      ) internal static options (constant) fixed bin;
 12   148 
 12   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
     1687 
     1688 
     1689      end ibm3270_mpx;
     1690 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0901.0  ibm3270_mpx.pl1                   >spec>install>1115>ibm3270_mpx.pl1
1667         1    01/06/85  1422.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
1-152        2    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
1669         3    10/20/82  0938.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
1671         4    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
1673         5    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
1675         6    07/21/88  2036.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
1677         7    03/19/81  1131.8  mcs_modes_change_list.incl.pl1    >ldd>include>mcs_modes_change_list.incl.pl1
1679         8    04/23/84  0745.1  bisync_line_data.incl.pl1         >ldd>include>bisync_line_data.incl.pl1
1681         9    10/20/82  0938.6  ibm3270_mpx_load_data.incl.pl1    >ldd>include>ibm3270_mpx_load_data.incl.pl1
1683        10    08/10/81  1843.6  ibm3270_mpx_data.incl.pl1         >ldd>include>ibm3270_mpx_data.incl.pl1
1685        11    03/27/82  0430.3  ibm3270_meters.incl.pl1           >ldd>include>ibm3270_meters.incl.pl1
1687        12    03/15/85  0953.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACCEPT_INPUT                    000135 constant        fixed bin(17,0)          initial dcl 3-15 set ref 1131* 1160* 1173*
ANNOUNCE                        000141 constant        fixed bin(17,0)          initial dcl 135 set ref 577* 706* 711* 719*
BEEP                            000153 constant        fixed bin(17,0)          initial dcl 135 set ref 1493*
CRASH                           000153 constant        fixed bin(17,0)          initial dcl 3-12 set ref 1428*
DIALUP                          000157 constant        fixed bin(17,0)          initial dcl 3-10 set ref 1448*
HANGUP                          000155 constant        fixed bin(17,0)          initial dcl 3-11 set ref 199*
IBM3270_MPX_DOWN                000040 constant        fixed bin(71,0)          initial dcl 9-31 set ref 603*
IBM3270_MPX_MASKED              000036 constant        fixed bin(71,0)          initial dcl 9-31 set ref 770*
IBM3270_MPX_UP                  000042 constant        fixed bin(71,0)          initial dcl 9-31 set ref 595*
INPUT                           000141 constant        bit(1)                   initial packed unaligned dcl 5-20 set ref 645* 723*
                                                                                  1200* 1243*
JUST_LOG                        000144 constant        fixed bin(17,0)          initial dcl 135 set ref 937*
OUTPUT                          000142 constant        bit(1)                   initial packed unaligned dcl 5-21 set ref 355* 431*
                                                                                  556* 559* 560* 1026* 1385* 1464*
QUIT                            000131 constant        fixed bin(17,0)          initial dcl 3-17 set ref 1110*
SB_ibm3270_mde                  000035 constant        fixed bin(17,0)          initial dcl 12-47 set ref 937*
SEND_OUTPUT                     000151 constant        fixed bin(17,0)          initial dcl 3-13 set ref 336* 673* 812* 825* 1115*
                                                                                  1126* 1450* 1490*
SET_POLLING_ADDR                       constant        fixed bin(17,0)          initial dcl 8-21 ref 1302 1317
SET_SELECT_ADDR                        constant        fixed bin(17,0)          initial dcl 8-21 ref 1337
START_POLL                             constant        fixed bin(17,0)          initial dcl 8-21 ref 1318
SYSERR_CRASH_SYSTEM             000157 constant        fixed bin(17,0)          initial dcl 135 set ref 1250* 1507*
WRU_TIMEOUT                     000143 constant        fixed bin(17,0)          initial dcl 3-20 set ref 205*
abort_info                             based           structure                level 1 dcl 104
action_chars             32(27)        based           structure                level 2 packed packed unaligned dcl 10-9
addr                                                   builtin function         dcl 161 ref 172 175 231 233 236 252 255 261 284 285
                                                                                  298 302 320 371 373 448 459 478 536 574 640 665
                                                                                  796 811 823 854 862 957 983 1083 1090 1203 1265
                                                                                  1280 1309 1310 1311 1312 1313 1314 1314 1321 1321
                                                                                  1354 1378 1398 1425 1473 1477 1519 1520 1542
address_table                          based           char(1)                  array packed unaligned dcl 10-89 ref 896 897 1061
address_tablep           34            based           pointer                  level 2 dcl 10-9 set ref 896 897 1061 1519* 1520*
aid                       0(27)        based           char(1)                  level 2 packed packed unaligned dcl 96 ref 1102 1120
                                                                                  1136
allow_copy              102(11)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 ref 406
allow_raw3270           102(10)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 ref 240
arg_chain_ptr                          parameter       pointer                  dcl 41 set ref 217 219* 294 299 334* 553* 564*
arg_code                               parameter       fixed bin(35,0)          dcl 40 set ref 168 212* 217 221* 227 245* 248 254*
                                                                                  269* 280 289* 294 301* 335* 361* 433* 563*
arg_infop                              parameter       pointer                  dcl 39 ref 168 174
arg_int_data                           parameter       bit(72)                  dcl 36 ref 569 573
arg_int_type                           parameter       fixed bin(17,0)          dcl 35 ref 569 572
arg_mclp                               parameter       pointer                  dcl 42 ref 227 232 248 253
arg_mdp                                parameter       pointer                  dcl 34 ref 168 170 217 227 229 248 250 280 282 294
                                                                                  296 569 571 1516 1518 1538 1540 1548 1550 1557
                                                                                  1559
arg_modes                              parameter       char                     packed unaligned dcl 43 set ref 280 287* 288*
arg_more_input                         parameter       bit(1)                   dcl 44 set ref 217 220*
arg_n                                  parameter       fixed bin(17,0)          dcl 1183 in procedure "trim_chain_start" ref 1180
                                                                                  1191
arg_n                                  parameter       fixed bin(17,0)          dcl 1220 in procedure "trim_chain_end" ref 1217 1226
arg_order                              parameter       char                     packed unaligned dcl 38 ref 168 173
arg_p                                  parameter       pointer                  dcl 1219 set ref 1217 1229 1242*
arg_subchan                            parameter       fixed bin(17,0)          dcl 37 ref 168 171 217 227 230 248 251 280 283 294
                                                                                  297 1538 1541
ascii                   102            based           bit(1)                   level 3 packed packed unaligned dcl 10-9 ref 1519
ascii_address_table             000074 constant        bit(9)                   initial array packed unaligned dcl 115 set ref 1519
auto_poll                       000374 automatic       fixed bin(17,0)          initial dcl 1297 set ref 1297* 1320 1328*
bad_device               77            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 714* 714 720* 720
bad_input                76            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 708* 708
bad_output               64            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 789* 789
baud_rate                 0(18) 000154 automatic       fixed bin(18,0)          level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 3-30 in procedure
                                                                                  "ibm3270_mpx" set ref 592 1444*
baud_rate                22            based           fixed bin(17,0)          level 3 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 592* 1444
bin                                                    builtin function         dcl 161 ref 310 529 692 895 896 897 908 918 1061
bit                                                    builtin function         dcl 161 ref 895
bit_text_array                         based           bit(9)                   array packed unaligned dcl 83 set ref 706*
blockp                          000160 automatic       pointer                  dcl 6-19 set ref 308* 308* 309 310 318* 319 320 321
                                                                                  323 326* 326 346 348 350 351 355 364 365 366 367
                                                                                  368 369 370 371 381* 381* 382 383* 384 392* 393
                                                                                  397 401 401 404 418* 419 419 441* 441* 442 444
                                                                                  445* 446 448 449 454 454 457* 458 459 460 462 462
                                                                                  469* 470 477* 478 479 524* 529 533* 536 537 542
                                                                                  639* 640 641 690* 690* 691 692 699* 699* 700 701
                                                                                  701 857 861* 861 862 863 1026* 1027 1032 1033 1034
                                                                                  1050 1051 1052 1053 1061 1062 1064 1065 1066 1082*
                                                                                  1083 1084 1150* 1150* 1151 1152 1152 1156 1165*
                                                                                  1165* 1167 1170 1385* 1386 1407 1407 1408 1408
                                                                                  1409 1409 1410 1507 1507
break                     0(20)        based           bit(1)                   level 3 packed packed unaligned dcl 6-28 set ref 332
                                                                                  370*
break_char                1(18) 000156 automatic       bit(1)                   level 3 packed packed unaligned dcl 3-38 set ref
                                                                                  1158* 1172*
bs                       31(27)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 set ref 452
                                                                                  488* 510
buffer                                 based           structure                level 1 dcl 6-28
buffer_pad                0(09) 000154 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 3-30 in procedure
                                                                                  "ibm3270_mpx" set ref 594 1446*
buffer_pad               24            based           fixed bin(17,0)          level 3 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 594* 1446 1507
c                                      parameter       char(1)                  packed unaligned dcl 924 in procedure "getbit" ref
                                                                                  922 926
c                                      parameter       char(1)                  packed unaligned dcl 916 in procedure "getbin" ref
                                                                                  914 918
c                                      parameter       char(1)                  packed unaligned dcl 873 in procedure "find_next"
                                                                                  ref 870 877 880
c                               000141 automatic       char(1)                  packed unaligned dcl 66 in procedure "ibm3270_mpx"
                                                                                  set ref 451* 452 452 452 500* 505 509 510
c1                                     parameter       char(1)                  packed unaligned dcl 906 set ref 904 908*
c2                                     parameter       char(1)                  packed unaligned dcl 906 set ref 904 908*
chain_head                      000156 automatic       bit(18)                  level 3 packed packed unaligned dcl 3-38 set ref 636
                                                                                  1155* 1169*
chain_len                       000132 automatic       fixed bin(17,0)          dcl 62 set ref 380* 382* 382 385 440* 442* 442 443
chain_ptr                       000114 automatic       pointer                  dcl 52 set ref 299* 310 311* 318 333 381 392 423 441
                                                                                  471 477 529 559* 636* 639 645* 689* 692 696 699
                                                                                  723* 1080* 1082 1149* 1150 1155 1165 1169
chain_tail                0(18) 000156 automatic       bit(18)                  level 3 packed packed unaligned dcl 3-38 set ref
                                                                                  1156* 1170*
chan_load_info                         based           structure                level 1 dcl 9-26
chan_map                 36            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 10-9 set
                                                                                  ref 662 662 663 721* 1087 1087 1088
channel_manager$control         000040 constant        entry                    external dcl 4-13 ref 1314 1321
channel_manager$interrupt       000042 constant        entry                    external dcl 4-25 ref 199 205 336 673 812 825 1110
                                                                                  1115 1126 1131 1160 1173 1428 1448 1450 1490
channel_manager$write           000036 constant        entry                    external dcl 4-10 ref 1013
chars                     1            based           char(1)                  array level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 6-28 in procedure "ibm3270_mpx" set
                                                                                  ref 320 371 373 393 397 401 401 404 419 448 459
                                                                                  478 536 640 701 862 1033* 1050* 1051* 1052* 1053*
                                                                                  1061* 1062* 1064* 1065* 1083 1152* 1203 1407*
                                                                                  1408*
chars                    25            based           structure                level 2 in structure "md" packed packed unaligned
                                                                                  dcl 10-9 in procedure "ibm3270_mpx"
code                            000101 automatic       fixed bin(35,0)          dcl 49 set ref 183* 187* 193* 202* 206* 208* 209*
                                                                                  210* 212 595* 603* 770* 1013* 1014 1015 1314*
                                                                                  1321*
column                          000140 automatic       fixed bin(17,0)          dcl 65 set ref 494* 495 497* 497 506 506 506* 506
                                                                                  506 509* 510* 510 511
cont                            000375 automatic       char(1)                  packed unaligned dcl 1298 set ref 1304* 1310 1311
                                                                                  1336*
control_queued           12(07)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  1348 1359* 1403*
controller_poll_address
                         16            based           char(1)                  level 2 dcl 10-9 ref 1304
controller_select_address
                         17            based           char(1)                  level 2 dcl 10-9 ref 1336
copy                     32(18)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 404
cr                       32            based           char(1)                  level 3 packed packed unaligned dcl 10-9 set ref 452
                                                                                  487* 509
cur_write_chan           54            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 795 811 823 991*
cursor1                   1            based           char(1)                  level 2 packed packed unaligned dcl 96 set ref 1138*
cursor2                   1(09)        based           char(1)                  level 2 packed packed unaligned dcl 96 set ref 1138*
data                      0(09)        based           char(5)                  level 2 packed packed unaligned dcl 8-14 set ref
                                                                                  1310* 1311* 1312* 1313*
data_len                               based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 8-14
                                                                                  set ref 1309*
debug                   102(01)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 ref 706
delta_position                  000314 automatic       fixed bin(17,0)          dcl 1076 set ref 1140* 1141 1141 1149 1157
dev                             000376 automatic       char(1)                  packed unaligned dcl 1299 set ref 1301* 1306 1307
                                                                                  1312 1313 1327* 1333* 1334 1335
dev_addr                        000125 automatic       fixed bin(17,0)          dcl 58 set ref 661* 662 662 663 711* 719* 721 1086*
                                                                                  1087 1087 1088
device_address            1(09)        based           char(1)                  level 2 in structure "status_msg" packed packed
                                                                                  unaligned dcl 85 in procedure "ibm3270_mpx" set
                                                                                  ref 661*
device_address            2            based           char(1)                  level 2 in structure "mde" dcl 10-93 in procedure
                                                                                  "ibm3270_mpx" ref 1301 1333
device_address            0(18)        based           char(1)                  level 2 in structure "text_msg" packed packed
                                                                                  unaligned dcl 96 in procedure "ibm3270_mpx" set
                                                                                  ref 1086*
devx                                   based           fixed bin(17,0)          level 2 in structure "mde" dcl 10-93 in procedure
                                                                                  "ibm3270_mpx" set ref 199* 205* 336* 355* 431*
                                                                                  556* 559* 560* 673* 812* 825* 1110* 1115* 1126*
                                                                                  1131* 1160* 1173* 1385* 1428* 1448* 1450* 1464*
                                                                                  1490*
devx                      3            based           fixed bin(17,0)          level 2 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 645* 723* 1013* 1017* 1026*
                                                                                  1029* 1200* 1243* 1314* 1321* 1388*
dialed                   12(01)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  191 196* 666 1092 1426* 1449* 1489
dialup_info                     000154 automatic       structure                level 1 dcl 3-30 in procedure "ibm3270_mpx" set ref
                                                                                  590* 1442* 1448 1448
dialup_info              21            based           structure                level 2 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx"
ebcdic_address_table            000054 constant        bit(9)                   initial array packed unaligned dcl 125 set ref 1520
em                       32(09)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 539
end_chain_ptr                   000136 automatic       pointer                  dcl 64 set ref 300* 323* 332 383* 418 445 469* 471
                                                                                  471* 525 526 533
end_of_page              12(08)        based           bit(1)                   level 3 in structure "mde" packed packed unaligned
                                                                                  dcl 10-93 in procedure "ibm3270_mpx" set ref 525*
                                                                                  527 812 1104 1105* 1124 1125* 1488*
end_of_page               0(18)        based           bit(1)                   level 3 in structure "buffer" packed packed
                                                                                  unaligned dcl 6-28 in procedure "ibm3270_mpx" set
                                                                                  ref 525 526*
enter                    30(18)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 1136
entries                   6            based           structure                array level 2 dcl 7-10 set ref 236 261
eot                      27(09)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 643
                                                                                  1033
eot_sent                102(08)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref
                                                                                  992* 1025 1035*
erase_req                12(05)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  480* 481 1052 1054* 1094* 1108* 1121* 1439*
erase_write              26(09)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 401
                                                                                  1052
error                     4(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-26 set ref
                                                                                  240* 268*
error_stat               63            based           structure                level 2 dcl 10-9
error_table_$bad_mode           000032 external static fixed bin(35,0)          dcl 159 ref 1531
error_table_$improper_data_format
                                000030 external static fixed bin(35,0)          dcl 158 ref 1529
error_table_$noalloc            000026 external static fixed bin(35,0)          dcl 157 ref 1530
error_table_$undefined_order_request
                                000024 external static fixed bin(35,0)          dcl 156 ref 1528
esc                      25(27)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 397
                                                                                  1051
et_bad_mode                     000013 internal static fixed bin(35,0)          dcl 147 set ref 269 1531*
et_improper_data_format         000011 internal static fixed bin(35,0)          dcl 145 set ref 1529*
et_noalloc                      000012 internal static fixed bin(35,0)          dcl 146 set ref 361 433 1015 1530*
et_undefined_order_request      000010 internal static fixed bin(35,0)          dcl 144 set ref 210 1528*
etx                      26(27)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 322 419
                                                                                  541 701 1408
event_channel                          based           fixed bin(71,0)          level 2 dcl 10-9 set ref 595* 603* 770*
first_control_chan       47            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 976 1349 1350* 1372 1394*
                                                                                  1395
first_poll_chan          56            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 975 1260 1261* 1278 1279
                                                                                  1281* 1282
first_write_chan         52            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 952 953* 980 982 984* 985
                                                                                  1288 1466 1467 1468* 1469 1473 1474
flags                     0(18)        based           structure                level 2 in structure "buffer" packed packed
                                                                                  unaligned dcl 6-28 in procedure "ibm3270_mpx" set
                                                                                  ref 365* 365
flags                     1(18) 000156 automatic       structure                level 2 in structure "rtx_info" packed packed
                                                                                  unaligned dcl 3-38 in procedure "ibm3270_mpx"
flags                     5            based           structure                level 2 in structure "mcl" dcl 7-10 in procedure
                                                                                  "ibm3270_mpx"
flags                    12            based           structure                level 2 in structure "mde" dcl 10-93 in procedure
                                                                                  "ibm3270_mpx"
flags                     4            based           structure                level 2 in structure "mcle" dcl 7-26 in procedure
                                                                                  "ibm3270_mpx"
flags                   102            based           structure                level 2 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx"
formfeed_key             33            based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 1120
formfeed_present          1(21) 000156 automatic       bit(1)                   level 3 packed packed unaligned dcl 3-38 set ref
                                                                                  1130*
general_poll_address     20            based           char(1)                  level 2 dcl 10-9 ref 1327
hbound                                                 builtin function         dcl 161 ref 576 662 779 1087
hc_fast_lock                           based           structure                level 1 dcl 2-10
header_blockp                   000130 automatic       pointer                  dcl 61 set ref 300* 423* 431* 432 524 556 556* 948
                                                                                  962
hndlquit                 12(03)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  258* 263* 1103 1111
i                               000216 automatic       fixed bin(17,0)          dcl 875 in procedure "find_next" set ref 880* 881
                                                                                  881
i                               000121 automatic       fixed bin(17,0)          dcl 55 in procedure "ibm3270_mpx" set ref 235* 236*
                                                                                  260* 261* 450* 450* 451 453* 454 455 456 456 456
                                                                                  458 461 462* 485* 486* 487* 488* 489 496 497 498
ibm3270_meters                         based           structure                level 1 dcl 11-13
ic                       26(18)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 540
                                                                                  1407
index                                                  builtin function         dcl 161 ref 322 877 880
infop                           000112 automatic       pointer                  dcl 51 set ref 174* 186
init                      5            based           bit(1)                   level 3 packed packed unaligned dcl 7-10 ref 258
input_chain                     000156 automatic       structure                level 2 packed packed unaligned dcl 3-38
input_chain_ptr          60            based           pointer                  level 2 dcl 10-9 set ref 684 685* 688 690 696* 1079
                                                                                  1080 1081*
input_count              62            based           fixed bin(17,0)          level 2 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 686* 686 693* 693 697* 1141
                                                                                  1149 1171
input_count               1     000156 automatic       fixed bin(18,0)          level 2 in structure "rtx_info" packed packed
                                                                                  unsigned unaligned dcl 3-38 in procedure
                                                                                  "ibm3270_mpx" set ref 693 697 1157* 1171*
input_reject             72            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 731* 731
int_type                        000100 automatic       fixed bin(17,0)          dcl 48 set ref 572* 576 576 577* 582
interrupt_info                  000152 automatic       bit(72)                  dcl 3-28 set ref 573* 577* 590 635 778
ix                                     parameter       fixed bin(17,0)          dcl 872 set ref 870 877 877* 878 880 881*
keyboard_restore          0(04) 000147 automatic       bit(1)                   level 2 in structure "wcc" packed packed unaligned
                                                                                  dcl 71 in procedure "ibm3270_mpx" set ref 1056*
keyboard_restore         12(09)        based           bit(1)                   level 3 in structure "mde" packed packed unaligned
                                                                                  dcl 10-93 in procedure "ibm3270_mpx" set ref 179*
                                                                                  198* 527* 1056 1057* 1121* 1144*
last_control_chan        50            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 1351* 1354 1356* 1395* 1400
                                                                                  1400*
last_poll_address        46            based           char(1)                  level 2 dcl 10-9 set ref 1306 1307*
last_poll_chan           57            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 1262* 1265 1267* 1282*
last_select_address      51            based           char(1)                  level 2 dcl 10-9 set ref 1334 1335*
last_write_chan          53            based           fixed bin(17,0)          level 2 dcl 10-9 set ref 954* 957 959* 985* 1469*
                                                                                  1483 1483*
lbound                                                 builtin function         dcl 161 ref 576 662 779 1087
letter_R                 30            based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 657
line_ctl                        000166 automatic       structure                level 1 dcl 8-10 set ref 1314 1314 1321 1321
line_size                 4            based           fixed bin(17,0)          level 2 dcl 10-93 ref 494 506 506 506 1159 1159
line_stat                       000170 automatic       structure                level 1 dcl 8-42 set ref 778*
line_type                21            based           fixed bin(17,0)          level 3 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 591* 1443
line_type                       000154 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 3-30 in procedure
                                                                                  "ibm3270_mpx" set ref 591 1443*
listen                   12            based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  190* 196* 1093 1426*
loaded                          000430 automatic       bit(1)                   packed unaligned dcl 1419 in procedure "crash_mpx"
                                                                                  set ref 1421* 1424
loaded                  102(03)        based           bit(1)                   level 3 in structure "md" packed packed unaligned
                                                                                  dcl 10-9 in procedure "ibm3270_mpx" set ref 589*
                                                                                  600 608 615 632 637 729 751 767 776 1421 1422*
                                                                                  1489
loading                 102(02)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref 586
                                                                                  588* 1422*
loop_count                      000452 automatic       fixed bin(17,0)          dcl 1458 set ref 1472* 1479 1480* 1480
low                                                    builtin function         dcl 161 ref 456 504 516
max                                                    builtin function         dcl 161 ref 510
max_buf_size              1     000154 automatic       fixed bin(9,0)           level 2 in structure "dialup_info" packed packed
                                                                                  unsigned unaligned dcl 3-30 in procedure
                                                                                  "ibm3270_mpx" set ref 593 1445*
max_buf_size             23            based           fixed bin(17,0)          level 3 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 593* 1445
max_buffer_tally                000044 constant        fixed bin(17,0)          initial array dcl 6-43 ref 1507
max_chain_len                          constant        fixed bin(17,0)          initial dcl 112 ref 443
max_raw_chain_len                      constant        fixed bin(17,0)          initial dcl 113 ref 385
mcl                                    based           structure                level 1 dcl 7-10
mcle                                   based           structure                level 1 dcl 7-26
mclep                           000164 automatic       pointer                  dcl 7-24 set ref 236* 237 238 238 238 238 240 240
                                                                                  240 242 261* 262 263 263 264 264 265 265 266 266
                                                                                  268
mclp                            000162 automatic       pointer                  dcl 7-7 set ref 232* 235 236 253* 258 260 261
md                                     based           structure                level 1 dcl 10-9
mde                                    based           structure                level 1 dcl 10-93 set ref 937 937
mde_entry               103            based           structure                array level 2 dcl 10-9 set ref 172 231 252 284 298
                                                                                  665 796 811 823 957 983 1090 1265 1280 1354 1378
                                                                                  1398 1425 1473 1477 1542
mdep                            000174 automatic       pointer                  dcl 10-91 set ref 172* 178 179 190 191 191 196 196
                                                                                  198 199 205 231* 252* 257 258 258 258 258 263 264
                                                                                  265 266 274 274 274 274 275 275 275 284* 287 298*
                                                                                  306 307 308 311 312 333 336 355 431 447 480 480
                                                                                  481 481 482 484 490 494 506 506 506 511 525 525
                                                                                  527 527 539 546 556 559 560 665* 666 667 668 672
                                                                                  673 796* 811* 812 812 823* 824 824 825 936 937*
                                                                                  937 937 937 948 961 962 963 972* 978 983* 984 986
                                                                                  987 989 990 999* 1052 1054 1056 1057 1058 1059
                                                                                  1060 1063 1090* 1092 1093 1094 1103 1103 1104 1105
                                                                                  1107 1108 1110 1111 1111 1115 1119 1121 1121 1122
                                                                                  1124 1125 1126 1131 1140 1142 1143 1144 1159 1159
                                                                                  1159 1159 1160 1173 1269 1280* 1281 1301 1333 1348
                                                                                  1358 1359 1375* 1378* 1379 1381 1385 1389* 1394
                                                                                  1399 1402 1403 1410 1425* 1426 1426 1428 1437 1438
                                                                                  1439 1447 1448 1449 1450 1461 1462 1463 1464 1465
                                                                                  1468 1482 1485 1487 1488 1489 1490 1542* 1551*
mdp                             000172 automatic       pointer                  dcl 10-6 set ref 170* 172 191 229* 231 240 250* 252
                                                                                  282* 284 296* 298 322 393 397 401 401 404 406 419
                                                                                  452 452 452 486 487 488 501 505 509 510 539 540
                                                                                  541 562 562 571* 577 586 588 589 591 592 593 594
                                                                                  595 595 600 603 603 608 615 617 618 622 632 634
                                                                                  637 643 644 645 652 654 656 657 660 662 662 663
                                                                                  665 682 684 685 686 686 688 690 693 693 696 697
                                                                                  701 706 706 708 708 711 714 714 719 720 720 721
                                                                                  723 729 731 731 751 753 753 754 767 770 770 776
                                                                                  782 782 784 789 789 793 795 796 807 810 810 811
                                                                                  811 820 822 822 823 823 828 828 832 832 836 836
                                                                                  840 840 844 844 896 897 937 952 953 954 957 957
                                                                                  959 973 974 975 976 980 982 983 984 985 985 989
                                                                                  991 992 993 994 1010 1011 1012 1013 1016 1016 1017
                                                                                  1020 1021 1025 1026 1028 1028 1029 1033 1035 1039
                                                                                  1050 1051 1052 1053 1061 1062 1079 1080 1081 1087
                                                                                  1087 1088 1090 1093 1102 1120 1136 1141 1149 1152
                                                                                  1171 1200 1243 1250 1260 1261 1262 1265 1265 1267
                                                                                  1276 1277 1278 1279 1280 1281 1282 1282 1283 1288
                                                                                  1304 1306 1307 1314 1321 1327 1334 1335 1336 1349
                                                                                  1350 1351 1354 1354 1356 1372 1378 1387 1387 1388
                                                                                  1394 1395 1395 1398 1400 1400 1407 1408 1421 1422
                                                                                  1422 1424 1425 1443 1444 1445 1446 1466 1467 1468
                                                                                  1469 1469 1473 1473 1474 1477 1479 1483 1483 1489
                                                                                  1493 1507 1507 1518* 1519 1519 1520 1540* 1542
                                                                                  1550* 1559*
message_in_progress     102(07)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref 618
                                                                                  754 810* 822* 994* 1039*
min                                                    builtin function         dcl 161 ref 704
mod                                                    builtin function         dcl 161 ref 490 494 506 506 511 1159 1159
mode_name                              based           char(16)                 level 2 packed packed unaligned dcl 7-26 ref 238 238
                                                                                  238 240 263 264 265 266
mode_switch               4            based           bit(1)                   level 3 packed packed unaligned dcl 7-26 ref 240 263
                                                                                  264 265 266
mpx_mode                  4(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-26 set ref
                                                                                  237* 238* 242* 262
n                               000344 automatic       fixed bin(17,0)          dcl 1223 in procedure "trim_chain_end" set ref 1226*
                                                                                  1227 1234 1235 1236* 1239* 1239 1241
n                                      parameter       fixed bin(17,0)          dcl 1505 in procedure "check_buffer_tally" ref 1503
                                                                                  1507
n                               000326 automatic       fixed bin(17,0)          dcl 1186 in procedure "trim_chain_start" set ref
                                                                                  1191* 1192 1193 1195* 1195 1196 1205 1206 1207*
n                                      parameter       fixed bin(17,0)          dcl 852 in procedure "adv_text" ref 850 854 855
n_entries                 1            based           fixed bin(17,0)          level 2 dcl 7-10 ref 235 260
nak_output               71            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 844* 844
name                      1            based           char(3)                  level 2 in structure "mde" dcl 10-93 in procedure
                                                                                  "ibm3270_mpx" set ref 937*
name                      4            based           char(32)                 level 2 in structure "md" dcl 10-9 in procedure
                                                                                  "ibm3270_mpx" set ref 577* 706* 711* 719* 937*
                                                                                  1250* 1493* 1507*
name                            000114 constant        char(11)                 initial packed unaligned dcl 111 in procedure
                                                                                  "ibm3270_mpx" set ref 577* 706* 711* 719* 937*
                                                                                  1250* 1493* 1507*
nchan                    14            based           fixed bin(17,0)          level 2 dcl 10-9 ref 1424 1479
needs_space              73            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 1016* 1016 1028* 1028 1387*
                                                                                  1387
next                                   based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 6-28
                                                                                  set ref 308 309 310* 326 348 350 351* 364* 364
                                                                                  369* 384 446* 470 529* 690 691 692* 699 700 857
                                                                                  861 1150 1151 1165 1167 1196 1199 1230 1232 1240*
next_control_chan        10            based           fixed bin(17,0)          level 2 dcl 10-93 set ref 1355* 1358* 1381 1394
                                                                                  1399* 1399 1402*
next_poll_chan            7            based           fixed bin(17,0)          level 2 dcl 10-93 set ref 1266* 1269* 1281
next_write_chan           6            based           fixed bin(17,0)          level 2 dcl 10-93 set ref 958* 961* 984 986* 1468
                                                                                  1475 1476 1477 1482* 1482 1485*
nl                       25            based           char(1)                  level 3 packed packed unaligned dcl 10-9 set ref 452
                                                                                  486* 505 1152
null                                                   builtin function         dcl 161 ref 219 275 300 307 312 334 359 432 471 484
                                                                                  503 515 556 560 564 684 688 858 972 978 990 999
                                                                                  1011 1027 1079 1081 1111 1198 1228 1240 1242 1375
                                                                                  1379 1386 1389 1461 1463 1551
op                              000166 automatic       fixed bin(17,0)          level 2 in structure "line_ctl" packed packed
                                                                                  unaligned dcl 8-10 in procedure "ibm3270_mpx" set
                                                                                  ref 1302* 1317 1318* 1337*
op                              000170 automatic       fixed bin(17,0)          level 2 in structure "line_stat" packed packed
                                                                                  unaligned dcl 8-42 in procedure "ibm3270_mpx" set
                                                                                  ref 779 779 780
order                           000102 automatic       char(32)                 packed unaligned dcl 50 set ref 173* 177 185 189 195
                                                                                  204 208 209
output_in_progress      102(06)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref 622
                                                                                  793 807 810* 820 822* 973 993* 1276
p                               000276 automatic       pointer                  dcl 1008 in procedure "send_more_message" set ref
                                                                                  1012* 1013* 1021 1034*
p                               000260 automatic       pointer                  dcl 934 in procedure "queue_write" set ref 957* 958
p                               000420 automatic       pointer                  dcl 1369 in procedure "setup_control_chan" set ref
                                                                                  1398* 1399
p                               000342 automatic       pointer                  dcl 1222 in procedure "trim_chain_end" set ref 1229*
                                                                                  1230 1231 1232* 1232 1234 1235 1235 1239 1243*
p                                      parameter       pointer                  dcl 1182 in procedure "trim_chain_start" set ref
                                                                                  1180 1193 1194 1195 1196 1198* 1199* 1199 1203
                                                                                  1204 1206 1206
p                               000446 automatic       pointer                  dcl 1457 in procedure "reset_channel" set ref 1462*
                                                                                  1464*
p                               000356 automatic       pointer                  dcl 1258 in procedure "queue_poll" set ref 1265*
                                                                                  1266
p                               000406 automatic       pointer                  dcl 1346 in procedure "queue_control" set ref 1354*
                                                                                  1355
percent                  27(18)        based           char(1)                  level 3 in structure "md" packed packed unaligned
                                                                                  dcl 10-9 in procedure "ibm3270_mpx" ref 654
percent                   0(09)        based           char(1)                  level 2 in structure "status_msg" packed packed
                                                                                  unaligned dcl 85 in procedure "ibm3270_mpx" ref
                                                                                  654
poll_failed              63            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 782* 782
poll_in_progress        102(05)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref
                                                                                  634* 644* 784* 974 1277 1283*
pos                                    parameter       fixed bin(17,0)          dcl 892 ref 890 895
pos_char1                       000123 automatic       char(1)                  packed unaligned dcl 57 set ref 513 896* 1064
pos_char2                       000124 automatic       char(1)                  packed unaligned dcl 57 set ref 517 897* 1065
posbit                          000226 automatic       bit(12)                  packed unaligned dcl 893 set ref 895* 896 897
position                        000122 automatic       fixed bin(17,0)          dcl 56 in procedure "ibm3270_mpx" set ref 317* 319
                                                                                  322* 324 330 346 367 368 371 482* 490* 490 494
                                                                                  495* 495 511* 511 512* 546 1138* 1140 1142 1159
                                                                                  1159
position                  5            based           fixed bin(17,0)          level 2 in structure "mde" dcl 10-93 in procedure
                                                                                  "ibm3270_mpx" set ref 481* 482 546* 1063* 1107*
                                                                                  1122* 1140 1142* 1159* 1437*
prev_subchan                    000416 automatic       fixed bin(17,0)          dcl 1368 set ref 1371* 1380* 1393 1398 1400
printer                  12(02)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 ref 191
                                                                                  447 480 484 525 539 667 824 1060 1438 1447
processid                 2            based           bit(36)                  level 2 dcl 10-9 set ref 595* 603* 770*
ptr                                                    builtin function         dcl 161 ref 309 326 350 384 470 636 691 700 861 1151
                                                                                  1167 1199 1232
pxss$ring_0_wakeup              000014 constant        entry                    external dcl 151 ref 595 603 770
q                               000450 automatic       pointer                  dcl 1457 in procedure "reset_channel" set ref 1473*
                                                                                  1475 1476 1477* 1477 1482
q                               000346 automatic       pointer                  dcl 1224 in procedure "trim_chain_end" set ref 1228*
                                                                                  1231* 1240 1240
q                               000324 automatic       pointer                  dcl 1185 in procedure "trim_chain_start" set ref
                                                                                  1194* 1200*
quit_key                 32(27)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 1102
raw3270                  12(12)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  258* 266* 274 287
raw3270_in_effect        12(13)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  178 257 274* 275 306 1103 1119
rawi                     12(11)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  258* 264* 274
rawo                     12(10)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  258* 265* 274
receive_mode_device       1(09) 000154 automatic       bit(1)                   level 2 packed packed unaligned dcl 3-30 set ref
                                                                                  1447*
rel                                                    builtin function         dcl 161 ref 310 319 381 441 529 692 1155 1156 1169
                                                                                  1170
resetwrite                             based           bit(1)                   level 2 packed packed unaligned dcl 104 ref 186
rest_chain_ptr                  000134 automatic       pointer                  dcl 63 set ref 300* 350* 355* 359 364 365 366 367
                                                                                  372 373 444* 457 553 560 560*
rtx_info                        000156 automatic       structure                level 1 dcl 3-38 set ref 635* 1129* 1131 1131 1154*
                                                                                  1160 1160 1168* 1173 1173
save_bit                        000315 automatic       bit(1)                   packed unaligned dcl 1077 set ref 1104* 1106 1113*
                                                                                  1115
save_raw_in_effect              000142 automatic       bit(1)                   packed unaligned dcl 67 set ref 257* 275
save_subchan                    000453 automatic       fixed bin(17,0)          dcl 1459 set ref 1474* 1476* 1479 1483
sba                      25(09)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 501
                                                                                  1062
screen_size               3            based           fixed bin(17,0)          level 2 dcl 10-93 ref 490 511 1159
select_failed            67            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 836* 836
send_output             102(09)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 set ref
                                                                                  617* 1010 1020*
size                                                   builtin function         dcl 161 ref 937 937
size_code                 0(24)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 6-28
                                                                                  set ref 355 366* 366 1507
slash                    27(27)        based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 656
soh                      27            based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 652
sound_alarm              12(06)        based           bit(1)                   level 3 in structure "mde" packed packed unaligned
                                                                                  dcl 10-93 in procedure "ibm3270_mpx" set ref 1058
                                                                                  1059* 1143*
sound_alarm               0(03) 000147 automatic       bit(1)                   level 2 in structure "wcc" packed packed unaligned
                                                                                  dcl 71 in procedure "ibm3270_mpx" set ref 1058*
space_available          74            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 753* 753
start_printer             0(02) 000147 automatic       bit(1)                   level 2 packed packed unaligned dcl 71 set ref 1060*
started                 102(04)        based           bit(1)                   level 3 packed packed unaligned dcl 10-9 ref 191
                                                                                  1093
status                          000126 automatic       bit(12)                  packed unaligned dcl 59 set ref 669* 670* 671
status1                   1(18)        based           char(1)                  level 2 packed packed unaligned dcl 85 set ref 669*
status2                   1(27)        based           char(1)                  level 2 packed packed unaligned dcl 85 set ref 670*
status_msg                             based           structure                level 1 packed packed unaligned dcl 85
string                                                 builtin function         dcl 161 set ref 1055* 1061
stx                                    based           char(1)                  level 2 in structure "text_msg" packed packed
                                                                                  unaligned dcl 96 in procedure "ibm3270_mpx" ref
                                                                                  682
stx                       0(27)        based           char(1)                  level 2 in structure "status_msg" packed packed
                                                                                  unaligned dcl 85 in procedure "ibm3270_mpx" ref
                                                                                  660
stx                      25(18)        based           char(1)                  level 3 in structure "md" packed packed unaligned
                                                                                  dcl 10-9 in procedure "ibm3270_mpx" ref 393 660
                                                                                  682 1050
subchan                         000127 automatic       fixed bin(17,0)          dcl 60 set ref 171* 172 230* 231 251* 252 283* 284
                                                                                  297* 298 663* 664 665 717 795* 796 953 954 958 959
                                                                                  982* 983 991 1088* 1089 1090 1261 1262 1266 1267
                                                                                  1279* 1280 1350 1351 1355 1356 1372* 1373 1378
                                                                                  1380 1381* 1400 1424* 1425* 1467 1475 1483 1541*
                                                                                  1542
substr                                                 builtin function         dcl 161 set ref 451 456* 461 500 501* 504 513* 516
                                                                                  517* 539* 540* 541* 643 652 669* 670* 880 896 897
                                                                                  918 926 1205 1310* 1311* 1312* 1313*
syserr                          000016 constant        entry                    external dcl 152 ref 577 706 711 719 1250 1493 1507
syserr$binary                   000020 constant        entry                    external dcl 153 ref 937
tally                     0(27)        based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 6-28
                                                                                  set ref 321 346 367* 367 368* 372 382 419 442 449
                                                                                  454* 454 458 460 462* 462 479 537 542* 641 701 863
                                                                                  1032* 1066* 1084 1152 1193 1195 1204 1206* 1206
                                                                                  1234 1235* 1235 1239 1407 1408 1409* 1409 1507
target                                 based           char                     packed unaligned dcl 80 set ref 375*
targetl                         000146 automatic       fixed bin(17,0)          dcl 69 set ref 374* 375
targetp                         000144 automatic       pointer                  dcl 68 set ref 373* 375
text                                   based           char                     packed unaligned dcl 81 in procedure "ibm3270_mpx"
                                                                                  set ref 322 375 451 456* 461* 461 500 501* 504
                                                                                  513* 516 517* 539* 540* 541* 643 652 877 880
text                                   based           char                     packed unaligned dcl 1189 in procedure
                                                                                  "trim_chain_start" set ref 1205* 1205
text_array                             based           char(1)                  array packed unaligned dcl 82 set ref 854
text_msg                               based           structure                level 1 packed packed unaligned dcl 96
textl                           000120 automatic       fixed bin(17,0)          dcl 54 in procedure "ibm3270_mpx" set ref 321* 322
                                                                                  372* 374 375 449* 450 451 451 455* 455 456 456
                                                                                  460* 461 461 479* 490 491* 500 501 504 513 516 517
                                                                                  537* 538* 538 539 539 540 540 541 541 542 641* 643
                                                                                  652 653 659 683 704* 704 706 855* 855 856 863* 877
                                                                                  880 1084* 1100 1137
textl                           000332 automatic       fixed bin(17,0)          dcl 1188 in procedure "trim_chain_start" set ref
                                                                                  1204* 1205 1205
textp                           000330 automatic       pointer                  dcl 1187 in procedure "trim_chain_start" set ref
                                                                                  1203* 1205 1205
textp                           000116 automatic       pointer                  dcl 53 in procedure "ibm3270_mpx" set ref 320* 322
                                                                                  371* 375 448* 451 456 459* 461 461 478* 484 500
                                                                                  501 503 504 513 515 516 517 536* 539 540 541 640*
                                                                                  643 652 654 656 657 660 661 669 670 682 706 854*
                                                                                  854 858* 862* 877 880 1083* 1086 1102 1120 1136
                                                                                  1138 1138
tty_buf$                        000034 external static fixed bin(17,0)          dcl 1-19 set ref 175 233 255 285 302 574
tty_space_man$free_buffer       000046 constant        entry                    external dcl 5-14 ref 556 1200 1243
tty_space_man$free_chain        000050 constant        entry                    external dcl 5-16 ref 559 560 645 723 1464
tty_space_man$get_buffer        000044 constant        entry                    external dcl 5-13 ref 355 431 1026 1385
tty_space_man$needs_space       000052 constant        entry                    external dcl 5-18 ref 1017 1029 1388
ttybp                           000150 automatic       pointer                  dcl 1-19 set ref 175* 233* 255* 285* 302* 309 326
                                                                                  350 384 470 574* 636 691 700 861 1151 1167 1199
                                                                                  1232
type                      0(18)        based           char(1)                  level 2 packed packed unaligned dcl 85 ref 656 657
unspec                                                 builtin function         dcl 161 set ref 590* 635* 778* 918 926 1129* 1131
                                                                                  1131 1154* 1160 1160 1168* 1173 1173 1442* 1448
                                                                                  1448
val                       0(18) 000166 automatic       fixed bin(17,0)          array level 2 packed packed unaligned dcl 8-10 set
                                                                                  ref 1308* 1309 1310 1311 1312 1313 1319* 1320*
valchar                                based           structure                level 1 packed packed unaligned dcl 8-14
wack_select              70            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 840* 840
waiting_for_ready        12(04)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  668 672* 824*
wcc                             000147 automatic       structure                level 1 packed packed unaligned dcl 71 set ref 1055*
                                                                                  1061
wire_proc$wire_me               000022 constant        entry                    external dcl 154 ref 1533
write                    26            based           char(1)                  level 3 packed packed unaligned dcl 10-9 ref 401
                                                                                  1053
write_abort              66            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 832* 832
write_chain_ptr          11            based           pointer                  level 2 in structure "mde" packed packed unaligned
                                                                                  dcl 10-93 in procedure "ibm3270_mpx" set ref 275
                                                                                  307 308 311 312* 333* 948* 962* 989 990* 1111 1379
                                                                                  1410* 1461 1462 1463*
write_chain_ptr          55            based           pointer                  level 2 in structure "md" packed packed unaligned
                                                                                  dcl 10-9 in procedure "ibm3270_mpx" set ref 989*
                                                                                  1011 1012 1021*
write_eot                65            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 828* 828
write_format_error       75            based           fixed bin(35,0)          level 3 dcl 10-9 set ref 562* 562
write_queued             12(14)        based           bit(1)                   level 3 packed packed unaligned dcl 10-93 set ref
                                                                                  275 936 963* 987* 1465 1487*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_BID                             internal static fixed bin(17,0)          initial dcl 8-21
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 3-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 3-23
BAD_BLOCK                              internal static fixed bin(17,0)          initial dcl 8-49
BID_FAILED                             internal static fixed bin(17,0)          initial dcl 8-49
CLEAR                                  internal static fixed bin(17,0)          initial dcl 9-37
CONFIGURE                              internal static fixed bin(17,0)          initial dcl 8-21
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 3-19
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 1-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 1-32
FNP_WRITE_STATUS                       internal static fixed bin(17,0)          initial dcl 8-49
HASP_FOREIGN_SWAB_RESET                internal static fixed bin(17,0)          initial dcl 8-49
HASP_INIT_COMPLETE                     internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_METERS_VERSION_1               internal static fixed bin(17,0)          initial dcl 11-30
IBM3270_NAK_OUTPUT                     internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_SELECT_FAILED                  internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_WACK_MESSAGE                   internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_WACK_SELECT                    internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_WRITE_ABORT                    internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_WRITE_COMPLETE                 internal static fixed bin(17,0)          initial dcl 8-49
IBM3270_WRITE_EOT                      internal static fixed bin(17,0)          initial dcl 8-49
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 3-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 3-16
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 3-18
MASKED                                 internal static fixed bin(17,0)          initial dcl 3-26
PA1                                    internal static fixed bin(17,0)          initial dcl 9-37
PA2                                    internal static fixed bin(17,0)          initial dcl 9-37
PA3                                    internal static fixed bin(17,0)          initial dcl 9-37
REPORT_WRITE_STATUS                    internal static fixed bin(17,0)          initial dcl 8-21
REVERSE_INTERRUPT                      internal static fixed bin(17,0)          initial dcl 8-49
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 12-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 12-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 12-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 12-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 12-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 12-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 12-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 12-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 12-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 12-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 12-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 12-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 12-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 12-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 12-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 12-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 12-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 12-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 12-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 12-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 12-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 12-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 12-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 12-21
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 12-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 12-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 12-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 12-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 12-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 12-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 12-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 12-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 12-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 12-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 12-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 12-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 12-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 12-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 12-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 12-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 12-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 12-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 12-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 12-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 12-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 12-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 12-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 12-47
SET_3270_MODE                          internal static fixed bin(17,0)          initial dcl 8-21
SET_BID_LIMIT                          internal static fixed bin(17,0)          initial dcl 8-21
SET_HASP_MODE                          internal static fixed bin(17,0)          initial dcl 8-21
SET_HASP_TIMERS                        internal static fixed bin(17,0)          initial dcl 8-21
SET_MASTER_SLAVE_MODE                  internal static fixed bin(17,0)          initial dcl 8-21
SET_NAK_LIMIT                          internal static fixed bin(17,0)          initial dcl 8-21
SET_TTD_PARAMS                         internal static fixed bin(17,0)          initial dcl 8-21
SPACE_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 3-21
STOP_AUTO_POLL                         internal static fixed bin(17,0)          initial dcl 8-21
TIMER                                  internal static fixed bin(17,0)          initial dcl 3-24
TOO_MANY_NAKS                          internal static fixed bin(17,0)          initial dcl 8-49
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 1-33
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 3-25
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 1-19
bsizec                                 internal static fixed bin(17,0)          initial dcl 1-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 1-29
chan_load_infop                        automatic       pointer                  dcl 9-24
channel_manager$check_modes     000000 constant        entry                    external dcl 4-19
channel_manager$get_modes       000000 constant        entry                    external dcl 4-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 4-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 4-31
channel_manager$read            000000 constant        entry                    external dcl 4-7
channel_manager$set_modes       000000 constant        entry                    external dcl 4-16
cleanup                         000000 stack reference condition                dcl 164
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 12-144
free_block                             based           structure                level 1 dcl 6-23
free_blockp                            automatic       pointer                  dcl 6-20
ibm3270_meter_struc                    based           structure                level 1 dcl 11-7
input_bpart                            internal static fixed bin(18,0)          initial dcl 1-19
load_info                              based           structure                level 1 dcl 9-10
load_info_nchan                        automatic       fixed bin(17,0)          dcl 9-8
load_infop                             automatic       pointer                  dcl 9-7
lock_ptr                               automatic       pointer                  dcl 2-9
mcl_version_2                          internal static fixed bin(17,0)          initial dcl 7-8
md_nchan                               automatic       fixed bin(17,0)          dcl 10-7
meter_ptr                              automatic       pointer                  dcl 11-28
output_bpart                           internal static fixed bin(18,0)          initial dcl 1-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 1-27
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 12-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 12-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 12-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 12-141
timer_info                             automatic       structure                level 1 dcl 3-50
tty_buf                                based           structure                level 1 dcl 1-35
tty_ev                                 internal static fixed bin(17,0)          initial dcl 1-19
tty_space_man$free_space        000000 constant        entry                    external dcl 5-12
tty_space_man$get_chain         000000 constant        entry                    external dcl 5-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 5-11
tty_space_man$get_space         000000 constant        entry                    external dcl 5-10
tty_space_man$switch_chain      000000 constant        entry                    external dcl 5-17

NAMES DECLARED BY EXPLICIT CONTEXT.
INTERRUPT                       000000 constant        label                    array(17) dcl 586 ref 576 576 582
LINE_STAT                       000021 constant        label                    array(12) dcl 782 set ref 779 779 780
adv_text                        004211 constant        entry                    internal dcl 850 ref 491 498 502 514 518
bad_dev_addr                    003407 constant        label                    dcl 711 ref 662 1087
bad_device                      003451 constant        label                    dcl 717 ref 664 1089
bad_input                       003324 constant        label                    dcl 704 set ref 653 654 657 659 660 682 683 1100
                                                                                  1137
build_header                    004757 constant        entry                    internal dcl 1048 ref 528 1405
chain_split                     002063 constant        label                    dcl 471 ref 447 464 467
check_buffer_tally              007014 constant        entry                    internal dcl 1503 ref 453 534 1406
check_modes                     000632 constant        entry                    external dcl 227
control                         000364 constant        entry                    external dcl 168
crash                           004176 constant        entry                    external dcl 1557
crash_mpx                       006445 constant        entry                    internal dcl 1417 ref 602 610 769 1560
dialup                          004135 constant        entry                    external dcl 1538
dialup_channel                  006522 constant        entry                    internal dcl 1435 ref 191 1095 1543
discard_input                   003521 constant        label                    dcl 723 ref 637 656 666 667 676 709 715 717 1097
                                                                                  1116 1133 1136 1146
find_next                       004245 constant        entry                    internal dcl 870 ref 486 487 488
general_poll                    006220 constant        entry                    internal dcl 1325 ref 1288 1552
get_modes                       001156 constant        entry                    external dcl 280
get_position                    004337 constant        entry                    internal dcl 904 ref 1138
get_position_chars              004310 constant        entry                    internal dcl 890 ref 512 1063
getbin                          004375 constant        entry                    internal dcl 914 ref 661 1086
getbit                          004407 constant        entry                    internal dcl 922 ref 669 670 908 908
ibm3270_mpx                     000351 constant        entry                    external dcl 30
init                            004106 constant        entry                    external dcl 1526
interrupt                       002543 constant        entry                    external dcl 569
line_stat_continue              003725 constant        label                    dcl 815 ref 820 826
line_stat_output_complete       003671 constant        label                    dcl 807 ref 791 799 830 834 838 842 846
poll                            006027 constant        entry                    internal dcl 1295 ref 1284
poll_join                       006034 constant        label                    dcl 1302 set ref 1329
process_input                   005062 constant        entry                    internal dcl 1074 ref 646 701
process_polls                   005767 constant        entry                    internal dcl 1274 ref 647 785 815
process_write                   004526 constant        entry                    internal dcl 970 ref 181 201 551 622 648 755 786 817
queue_control                   006247 constant        entry                    internal dcl 1344 ref 180 200 1123 1145 1440
queue_poll                      005745 constant        entry                    internal dcl 1256 ref 797
queue_write                     004417 constant        entry                    internal dcl 932 ref 548
queue_write_data                002446 constant        label                    dcl 548 ref 424
read                            000607 constant        entry                    external dcl 217
reset_channel                   006621 constant        entry                    internal dcl 1455 ref 186 197 275 1112 1427
reset_channel_failed            006762 constant        label                    dcl 1493 ref 1466 1479
reset_channel_restart           006726 constant        label                    dcl 1485 ref 1496
search_control_queue            006304 constant        label                    dcl 1373 ref 1382
select                          006230 constant        entry                    internal dcl 1331 ref 996
select_join                     006045 constant        label                    dcl 1308 ref 1338
send_chain                      004631 constant        label                    dcl 1013 ref 1036
send_more_message               004616 constant        entry                    internal dcl 1006 ref 619 754 997
send_raw_input                  005507 constant        label                    dcl 1165 ref 1103 1119
set_address_table               004063 constant        entry                    external dcl 1516
set_modes                       000744 constant        entry                    external dcl 248
setup_control_chan              006277 constant        entry                    internal dcl 1366 ref 977
start_general_poll              004157 constant        entry                    external dcl 1548
trim_chain_end                  005650 constant        entry                    internal dcl 1217 ref 685
trim_chain_start                005555 constant        entry                    internal dcl 1180 ref 689 1149
trim_failure                    004026 constant        label                    dcl 1250 ref 1196 1241 1252
write                           001232 constant        entry                    external dcl 294
write_fails                     004756 constant        label                    dcl 1042 ref 1015
write_format_error              002454 constant        label                    dcl 556 ref 340 387 395 399 408 412 419 503 504 515
                                                                                  516
write_join                      004573 constant        label                    dcl 989 ref 978

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7456        7532    7152        7466
Length     10252    7152        54         504     304           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ibm3270_mpx                         650 external procedure  is an external procedure.  
adv_text                                internal procedure  shares stack frame of external procedure ibm3270_mpx.  
find_next                               internal procedure  shares stack frame of external procedure ibm3270_mpx.  
get_position_chars                      internal procedure  shares stack frame of external procedure ibm3270_mpx.  
get_position                            internal procedure  shares stack frame of external procedure ibm3270_mpx.  
getbin                                  internal procedure  shares stack frame of external procedure ibm3270_mpx.  
getbit                                  internal procedure  shares stack frame of external procedure ibm3270_mpx.  
queue_write                             internal procedure  shares stack frame of external procedure ibm3270_mpx.  
process_write                           internal procedure  shares stack frame of external procedure ibm3270_mpx.  
send_more_message                       internal procedure  shares stack frame of external procedure ibm3270_mpx.  
build_header                            internal procedure  shares stack frame of external procedure ibm3270_mpx.  
process_input                           internal procedure  shares stack frame of external procedure ibm3270_mpx.  
trim_chain_start                        internal procedure  shares stack frame of external procedure ibm3270_mpx.  
trim_chain_end                          internal procedure  shares stack frame of external procedure ibm3270_mpx.  
queue_poll                              internal procedure  shares stack frame of external procedure ibm3270_mpx.  
process_polls                           internal procedure  shares stack frame of external procedure ibm3270_mpx.  
poll                                    internal procedure  shares stack frame of external procedure ibm3270_mpx.  
queue_control                           internal procedure  shares stack frame of external procedure ibm3270_mpx.  
setup_control_chan                      internal procedure  shares stack frame of external procedure ibm3270_mpx.  
crash_mpx                               internal procedure  shares stack frame of external procedure ibm3270_mpx.  
dialup_channel                          internal procedure  shares stack frame of external procedure ibm3270_mpx.  
reset_channel                           internal procedure  shares stack frame of external procedure ibm3270_mpx.  
check_buffer_tally                      internal procedure  shares stack frame of external procedure ibm3270_mpx.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 et_undefined_order_request  ibm3270_mpx
000011 et_improper_data_format     ibm3270_mpx
000012 et_noalloc                  ibm3270_mpx
000013 et_bad_mode                 ibm3270_mpx

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ibm3270_mpx              000100 int_type                    ibm3270_mpx
                         000101 code                        ibm3270_mpx
                         000102 order                       ibm3270_mpx
                         000112 infop                       ibm3270_mpx
                         000114 chain_ptr                   ibm3270_mpx
                         000116 textp                       ibm3270_mpx
                         000120 textl                       ibm3270_mpx
                         000121 i                           ibm3270_mpx
                         000122 position                    ibm3270_mpx
                         000123 pos_char1                   ibm3270_mpx
                         000124 pos_char2                   ibm3270_mpx
                         000125 dev_addr                    ibm3270_mpx
                         000126 status                      ibm3270_mpx
                         000127 subchan                     ibm3270_mpx
                         000130 header_blockp               ibm3270_mpx
                         000132 chain_len                   ibm3270_mpx
                         000134 rest_chain_ptr              ibm3270_mpx
                         000136 end_chain_ptr               ibm3270_mpx
                         000140 column                      ibm3270_mpx
                         000141 c                           ibm3270_mpx
                         000142 save_raw_in_effect          ibm3270_mpx
                         000144 targetp                     ibm3270_mpx
                         000146 targetl                     ibm3270_mpx
                         000147 wcc                         ibm3270_mpx
                         000150 ttybp                       ibm3270_mpx
                         000152 interrupt_info              ibm3270_mpx
                         000154 dialup_info                 ibm3270_mpx
                         000156 rtx_info                    ibm3270_mpx
                         000160 blockp                      ibm3270_mpx
                         000162 mclp                        ibm3270_mpx
                         000164 mclep                       ibm3270_mpx
                         000166 line_ctl                    ibm3270_mpx
                         000170 line_stat                   ibm3270_mpx
                         000172 mdp                         ibm3270_mpx
                         000174 mdep                        ibm3270_mpx
                         000216 i                           find_next
                         000226 posbit                      get_position_chars
                         000260 p                           queue_write
                         000276 p                           send_more_message
                         000314 delta_position              process_input
                         000315 save_bit                    process_input
                         000324 q                           trim_chain_start
                         000326 n                           trim_chain_start
                         000330 textp                       trim_chain_start
                         000332 textl                       trim_chain_start
                         000342 p                           trim_chain_end
                         000344 n                           trim_chain_end
                         000346 q                           trim_chain_end
                         000356 p                           queue_poll
                         000374 auto_poll                   poll
                         000375 cont                        poll
                         000376 dev                         poll
                         000406 p                           queue_control
                         000416 prev_subchan                setup_control_chan
                         000420 p                           setup_control_chan
                         000430 loaded                      crash_mpx
                         000446 p                           reset_channel
                         000450 q                           reset_channel
                         000452 loop_count                  reset_channel
                         000453 save_subchan                reset_channel

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$control       channel_manager$interrupt     channel_manager$write         pxss$ring_0_wakeup
syserr                        syserr$binary                 tty_space_man$free_buffer     tty_space_man$free_chain
tty_space_man$get_buffer      tty_space_man$needs_space     wire_proc$wire_me

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode         error_table_$improper_data_format                           error_table_$noalloc
error_table_$undefined_order_request                        tty_buf$


CONSTANTS
007066  aa     000002000000
007067  aa     000000000000
007070  aa     600000000041
007071  aa     001050000000

007072  aa     000004000000
007073  aa     000000000000
007074  aa     600000000041
007075  aa     000114000000
007076  aa     600000000041
007077  aa     000742000000

007100  aa     007777777777

007101  aa     777377777777

007102  aa     776777777777

007103  aa     777767777777

007104  aa     775777777777

007105  aa     773777777777

007106  aa     000004000000
007107  aa     000000000000
007110  aa     600000000041
007111  aa     000114000000
007112  aa     600000000041
007113  aa     000525000000

007114  aa     757777777777

007115  aa     767777777777

007116  aa     777777377777

007120  aa     000002000000
007121  aa     000000000000
007122  aa     600000000041
007123  aa     000122000000

007124  aa     000002000000
007125  aa     000000000000
007126  aa     600000000041
007127  aa     000463000000

007130  aa     000002000000
007131  aa     000000000000
007132  aa     600000000041
007133  aa     000120000000

007134  aa     000002000000
007135  aa     000000000000
007136  aa     600000000041
007137  aa     000121000000

007140  aa     007777000001

007141  aa     777737777777

007142  aa     777577777777

007143  aa     777677777777

007144  aa     737777777777

007145  aa     677777777777

007146  aa     577777777777

007147  aa     377777777777

000035  aa     000000000043

000036  aa     000000000000
000037  aa     000000000003

000040  aa     000000000000
000041  aa     000000000002

000042  aa     000000000000
000043  aa     000000000001

000044  aa     000000000074
000045  aa     000000000174
000046  aa     000000000274
000047  aa     000000000374
000050  aa     000000000474
000051  aa     000000000574
000052  aa     000000000674
000053  aa     000000000774

000054  aa     100301302303
000055  aa     304305306307
000056  aa     310311112113
000057  aa     114115116117
000060  aa     120321322323
000061  aa     324325326327
000062  aa     330331132133
000063  aa     134135136137
000064  aa     140141342343
000065  aa     344345346347
000066  aa     350351152153
000067  aa     154155156157
000070  aa     360361362363
000071  aa     364365366367
000072  aa     370371172173
000073  aa     174175176177

000074  aa     040101102103
000075  aa     104105106107
000076  aa     110111133056
000077  aa     074050053041
000100  aa     046112113114
000101  aa     115116117120
000102  aa     121122135044
000103  aa     052051073136
000104  aa     055057123124
000105  aa     125126127130
000106  aa     131132174054
000107  aa     045137076077
000110  aa     060061062063
000111  aa     064065066067
000112  aa     070071072043
000113  aa     100047075042

000114  aa  151 142 155 063	ibm3
000115  aa  062 067 060 137	270_
000116  aa  155 160 170 000	mpx

000117  aa     524000000035

000120  aa     524000000014

000121  aa     524000000003

000122  aa     524000000063

000123  aa     404000000030

000124  aa     526000000001

000125  aa     524000000046

007150  aa     777000000000

000126  aa     524000000055

000127  aa     516100000011

000130  aa     524000000047

000131  aa     000000000010

000132  aa     524000000040

000133  aa     526000000013

000134  aa     524000000052

000135  aa     000000000006

007151  aa     777777777777

000136  aa  162 141 167 157	rawo

000137  aa  162 141 167 151	rawi

000140  aa  167 162 165 000	wru

000141  aa     000000000000

000142  aa     400000000000

000143  aa     000000000013

000144  aa     000000000005

000145  aa     516000000006

000146  aa     404000000006

000147  aa     514000000001

000150  aa     404000000043

000151  aa     000000000004

000152  aa     526077777777

000153  aa     000000000003

000154  aa     514000000110

000155  aa     000000000002

000156  aa     404000000021

000157  aa     000000000001

000160  aa     464000000000

000162  aa  150 156 144 154	hndl
000163  aa  161 165 151 164	quit

000164  aa     077777000043
000165  aa     000001000000

000166  aa     000000000000
000167  aa     000000000000

000170  aa  150 141 156 147	hang
000171  aa  165 160 000 000	up

000172  aa  154 151 163 164	list
000173  aa  145 156 000 000	en

000174  aa  141 142 157 162	abor
000175  aa  164 000 000 000	t

000176  aa  143 154 145 141	clea
000177  aa  156 165 160 000	nup

000200  aa  154 151 156 145	line
000201  aa  137 143 157 156	_con
000202  aa  164 162 157 154	trol

000203  aa  136 162 141 167	^raw
000204  aa  063 062 067 060	3270
000205  aa  151 157 000 000	io

000206  aa  162 141 167 063	raw3
000207  aa  062 067 060 151	270i
000210  aa  157 000 000 000	o

000211  aa  160 162 151 156	prin
000212  aa  164 145 162 137	ter_
000213  aa  157 156 000 000	on

000214  aa  160 162 151 156	prin
000215  aa  164 145 162 137	ter_
000216  aa  157 146 146 000	off

000217  aa  145 156 164 145	ente
000220  aa  162 137 162 145	r_re
000221  aa  143 145 151 166	ceiv
000222  aa  145 000 000 000	e

000223  aa  136 141 072 040	^a: 
000224  aa  102 165 146 146	Buff
000225  aa  145 162 040 164	er t
000226  aa  141 154 154 171	ally
000227  aa  040 145 162 162	 err
000230  aa  157 162 040 157	or o
000231  aa  156 040 136 141	n ^a
000232  aa  056 000 000 000	.

000233  aa  136 141 072 040	^a: 
000234  aa  103 157 165 154	Coul
000235  aa  144 040 156 157	d no
000236  aa  164 040 146 151	t fi
000237  aa  156 144 040 161	nd q
000240  aa  165 145 165 145	ueue
000241  aa  144 040 167 162	d wr
000242  aa  151 164 145 040	ite 
000243  aa  157 156 040 136	on ^
000244  aa  141 056 000 000	a.

000245  aa  136 141 072 040	^a: 
000246  aa  105 162 162 157	Erro
000247  aa  162 040 164 162	r tr
000250  aa  151 155 155 151	immi
000251  aa  156 147 040 142	ng b
000252  aa  165 146 146 145	uffe
000253  aa  162 040 143 150	r ch
000254  aa  141 151 156 040	ain 
000255  aa  146 157 162 040	for 
000256  aa  136 141 000 000	^a

000257  aa  136 141 072 040	^a: 
000260  aa  125 156 162 145	Unre
000261  aa  143 157 147 156	cogn
000262  aa  151 172 145 144	ized
000263  aa  040 151 156 160	 inp
000264  aa  165 164 040 146	ut f
000265  aa  157 162 040 136	or ^
000266  aa  141 072 136 050	a:^(
000267  aa  040 136 056 063	 ^.3
000270  aa  142 136 051 000	b^)

000271  aa  136 141 072 040	^a: 
000272  aa  111 156 160 165	Inpu
000273  aa  164 040 146 157	t fo
000274  aa  162 040 165 156	r un
000275  aa  143 157 156 146	conf
000276  aa  151 147 165 162	igur
000277  aa  145 144 040 144	ed d
000300  aa  145 166 151 143	evic
000301  aa  145 040 136 144	e ^d
000302  aa  040 157 156 040	 on 
000303  aa  136 141 000 000	^a

000304  aa  136 141 072 040	^a: 
000305  aa  125 156 162 145	Unre
000306  aa  143 157 147 156	cogn
000307  aa  151 172 145 144	ized
000310  aa  040 151 156 164	 int
000311  aa  145 162 162 165	erru
000312  aa  160 164 040 146	pt f
000313  aa  157 162 040 136	or ^
000314  aa  141 056 040 136	a. ^
000315  aa  144 040 136 056	d ^.
000316  aa  063 142 000 000	3b

000317  aa  136 141 072 040	^a: 
000320  aa  111 156 160 165	Inpu
000321  aa  164 040 146 157	t fo
000322  aa  162 040 151 154	r il
000323  aa  154 145 147 141	lega
000324  aa  154 040 144 145	l de
000325  aa  166 151 143 145	vice
000326  aa  040 141 144 144	 add
000327  aa  162 145 163 163	ress
000330  aa  040 136 144 040	 ^d 
000331  aa  157 156 040 136	on ^
000332  aa  141 000 000 000	a

000333  aa  136 141 072 040	^a: 
000334  aa  101 164 164 145	Atte
000335  aa  155 160 164 040	mpt 
000336  aa  164 157 040 161	to q
000337  aa  165 145 165 145	ueue
000340  aa  040 167 162 151	 wri
000341  aa  164 145 040 167	te w
000342  aa  150 151 154 145	hile
000343  aa  040 167 162 151	 wri
000344  aa  164 145 040 161	te q
000345  aa  165 145 165 145	ueue
000346  aa  144 040 136 141	d ^a
000347  aa  056 136 141 000	.^a

LABEL ARRAYS
000000  aa   002632 7100 04	tra  	1434,ic		002632
000001  aa   002676 7100 04	tra  	1470,ic		002677
000002  aa   002721 7100 04	tra  	1489,ic		002723
000003  aa   002726 7100 04	tra  	1494,ic		002731
000004  aa   002745 7100 04	tra  	1509,ic		002751
000005  aa   002745 7100 04	tra  	1509,ic		002752
000006  aa   003530 7100 04	tra  	1880,ic		003536
000007  aa   003540 7100 04	tra  	1888,ic		003547
000010  aa   003606 7100 04	tra  	1926,ic		003616
000011  aa   003537 7100 04	tra  	1887,ic		003550
000012  aa   003537 7100 04	tra  	1887,ic		003551
000013  aa   003537 7100 04	tra  	1887,ic		003552
000014  aa   003555 7100 04	tra  	1901,ic		003571
000015  aa   003554 7100 04	tra  	1900,ic		003571
000016  aa   003553 7100 04	tra  	1899,ic		003571
000017  aa   003552 7100 04	tra  	1898,ic		003571
000020  aa   003552 7100 04	tra  	1898,ic		003572

000021  aa   003613 7100 04	tra  	1931,ic		003634
000022  aa   003624 7100 04	tra  	1940,ic		003646
000023  aa   003631 7100 04	tra  	1945,ic		003654
000024  aa   003643 7100 04	tra  	1955,ic		003667
000025  aa   003643 7100 04	tra  	1955,ic		003670
000026  aa   003643 7100 04	tra  	1955,ic		003671
000027  aa   003701 7100 04	tra  	1985,ic		003730
000030  aa   003740 7100 04	tra  	2016,ic		003770
000031  aa   003745 7100 04	tra  	2021,ic		003776
000032  aa   003752 7100 04	tra  	2026,ic		004004
000033  aa   003757 7100 04	tra  	2031,ic		004012
000034  aa   003764 7100 04	tra  	2036,ic		004020

BEGIN PROCEDURE ibm3270_mpx
ENTRY TO ibm3270_mpx                                        STATEMENT 1 ON LINE 30
ibm3270_mpx: proc;

000350  da     000201200000
000351  aa   001220 6270 00	eax7 	656
000352  aa  7 00034 3521 20	epp2 	pr7|28,*
000353  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000354  aa     000000000000
000355  aa     000000000000
						STATEMENT 1 ON LINE 168
control: entry (arg_mdp, arg_subchan, arg_order, arg_infop, arg_code);

000356  aa   000024 7100 04	tra  	20,ic		000402
ENTRY TO control                                            STATEMENT 1 ON LINE 168
control: entry (arg_mdp, arg_subchan, arg_order, arg_infop, arg_code);

000357  at     000005000160
000360  tt     000156000152
000361  tt     000160000150
000362  ta     000357000000
000363  da     000204300000
000364  aa   001220 6270 00	eax7 	656
000365  aa  7 00034 3521 20	epp2 	pr7|28,*
000366  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000367  aa     000012000000
000370  aa     000000000000
000371  aa  6 00042 3735 20	epp7 	pr6|34,*
000372  aa  7 00004 2361 20	ldq  	pr7|4,*
000373  aa   000002 6040 04	tmi  	2,ic		000375
000374  aa   777777 3760 07	anq  	262143,dl
000375  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000376  aa  6 00462 7561 00	stq  	pr6|306
000377  aa  6 00032 3715 20	epp5 	pr6|26,*
000400  aa  5 00012 3535 20	epp3 	pr5|10,*
000401  aa  6 00176 2535 00	spri3	pr6|126
						STATEMENT 1 ON LINE 170
	mdp = arg_mdp;

000402  aa  6 00032 3735 20	epp7 	pr6|26,*
000403  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
000404  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
000405  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 171
	subchan = arg_subchan;

000406  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
000407  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 172
	mdep = addr (md.mde_entry (subchan));

000410  aa   000013 4020 07	mpy  	11,dl
000411  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
000412  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 173
	order = arg_order;

000413  aa  7 00006 3515 20	epp1 	pr7|6,*
000414  aa  6 00462 2351 00	lda  	pr6|306
000415  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000416  aa  1 00000 00 0005	desc9a	pr1|0,al		arg_order
000417  aa  6 00102 00 0040	desc9a	pr6|66,32		order
						STATEMENT 1 ON LINE 174
	infop = arg_infop;

000420  aa  7 00010 3715 20	epp5 	pr7|8,*		arg_infop
000421  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_infop
000422  aa  6 00112 6515 00	spri5	pr6|74		infop
						STATEMENT 1 ON LINE 175
	ttybp = addr (tty_buf$);

000423  la  4 00034 3535 20	epp3 	pr4|28,*		tty_buf$
000424  aa  6 00150 2535 00	spri3	pr6|104		ttybp
						STATEMENT 1 ON LINE 177
	if order = "enter_receive" then do;

000425  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000426  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000427  aa   777572 00 0015	desc9a	-134,13		000217 = 145156164145
000430  aa   000013 6010 04	tnz  	11,ic		000443
						STATEMENT 1 ON LINE 178
	     if ^mde.raw3270_in_effect then do;

000431  aa  6 00174 3515 20	epp1 	pr6|124,*		mdep
000432  aa  1 00012 2351 00	lda  	pr1|10		mde.raw3270_in_effect
000433  aa   000020 3150 03	cana 	16,du
000434  aa   000005 6010 04	tnz  	5,ic		000441
						STATEMENT 1 ON LINE 179
		mde.keyboard_restore = "1"b;

000435  aa   000400 2350 03	lda  	256,du
000436  aa  1 00012 2551 00	orsa 	pr1|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 180
		call queue_control;

000437  aa   005610 6700 04	tsp4 	2952,ic		006247
						STATEMENT 1 ON LINE 181
		call process_write;

000440  aa   004066 6700 04	tsp4 	2102,ic		004526
						STATEMENT 1 ON LINE 182
	     end;

						STATEMENT 1 ON LINE 183
	     code = 0;

000441  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 184
	end;

000442  aa   000135 7100 04	tra  	93,ic		000577
						STATEMENT 1 ON LINE 185
	else if order = "abort" then do;

000443  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000444  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000445  aa   777531 00 0005	desc9a	-167,5		000174 = 141142157162
000446  aa   000007 6010 04	tnz  	7,ic		000455
						STATEMENT 1 ON LINE 186
	     if abort_info.resetwrite then call reset_channel;

000447  aa  5 00000 2351 00	lda  	pr5|0		abort_info.resetwrite
000450  aa   400000 3150 03	cana 	131072,du
000451  aa   000002 6000 04	tze  	2,ic		000453
000452  aa   006147 6700 04	tsp4 	3175,ic		006621
						STATEMENT 1 ON LINE 187
	     code = 0;

000453  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 188
	end;

000454  aa   000123 7100 04	tra  	83,ic		000577
						STATEMENT 1 ON LINE 189
	else if order = "listen" then do;

000455  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000456  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000457  aa   777515 00 0006	desc9a	-179,6		000172 = 154151163164
000460  aa   000021 6010 04	tnz  	17,ic		000501
						STATEMENT 1 ON LINE 190
	     mde.listen = "1"b;

000461  aa   400000 2350 03	lda  	131072,du
000462  aa  6 00174 3515 20	epp1 	pr6|124,*		mdep
000463  aa  1 00012 2551 00	orsa 	pr1|10		mde.listen
						STATEMENT 1 ON LINE 191
	     if mde.printer & ^mde.dialed & md.started then
		call dialup_channel;

000464  aa  1 00012 2351 00	lda  	pr1|10		mde.printer
000465  aa   100000 3150 03	cana 	32768,du
000466  aa   000011 6000 04	tze  	9,ic		000477
000467  aa  1 00012 2351 00	lda  	pr1|10		mde.dialed
000470  aa   200000 3150 03	cana 	65536,du
000471  aa   000006 6010 04	tnz  	6,ic		000477
000472  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
000473  aa  5 00102 2351 00	lda  	pr5|66		md.started
000474  aa   020000 3150 03	cana 	8192,du
000475  aa   000002 6000 04	tze  	2,ic		000477
000476  aa   006024 6700 04	tsp4 	3092,ic		006522
						STATEMENT 1 ON LINE 193
	     code = 0;

000477  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 194
	end;

000500  aa   000077 7100 04	tra  	63,ic		000577
						STATEMENT 1 ON LINE 195
	else if order = "hangup" then do;

000501  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000502  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000503  aa   777467 00 0006	desc9a	-201,6		000170 = 150141156147
000504  aa   000033 6010 04	tnz  	27,ic		000537
						STATEMENT 1 ON LINE 196
	     mde.listen, mde.dialed = "0"b;

000505  aa   006442 2350 04	lda  	3362,ic		007147 = 377777777777
000506  aa  6 00174 3515 20	epp1 	pr6|124,*		mdep
000507  aa  1 00012 3551 00	ansa 	pr1|10		mde.listen
000510  aa   006436 2350 04	lda  	3358,ic		007146 = 577777777777
000511  aa  1 00012 3551 00	ansa 	pr1|10		mde.dialed
						STATEMENT 1 ON LINE 197
	     call reset_channel;

000512  aa   006107 6700 04	tsp4 	3143,ic		006621
						STATEMENT 1 ON LINE 198
	     mde.keyboard_restore = "1"b;

000513  aa   000400 2350 03	lda  	256,du
000514  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
000515  aa  7 00012 2551 00	orsa 	pr7|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 199
	     call channel_manager$interrupt (mde.devx, HANGUP, "0"b);

000516  aa   777450 2370 04	ldaq 	-216,ic		000166 = 000000000000 000000000000
000517  aa  6 00464 7571 00	staq 	pr6|308
000520  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
000521  aa  6 00470 2521 00	spri2	pr6|312
000522  aa   777433 3520 04	epp2 	-229,ic		000155 = 000000000002
000523  aa  6 00472 2521 00	spri2	pr6|314
000524  aa  6 00464 3521 00	epp2 	pr6|308
000525  aa  6 00474 2521 00	spri2	pr6|316
000526  aa  6 00466 6211 00	eax1 	pr6|310
000527  aa   014000 4310 07	fld  	6144,dl
000530  aa  6 00044 3701 20	epp4 	pr6|36,*
000531  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
000532  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 200
	     call queue_control;

000533  aa   005514 6700 04	tsp4 	2892,ic		006247
						STATEMENT 1 ON LINE 201
	     call process_write;

000534  aa   003772 6700 04	tsp4 	2042,ic		004526
						STATEMENT 1 ON LINE 202
	     code = 0;

000535  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 203
	end;

000536  aa   000041 7100 04	tra  	33,ic		000577
						STATEMENT 1 ON LINE 204
	else if order = "wru" then do;

000537  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000540  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000541  aa   777401 00 0003	desc9a	-255,3		000140 = 167162165000
000542  aa   000017 6010 04	tnz  	15,ic		000561
						STATEMENT 1 ON LINE 205
	     call channel_manager$interrupt (mde.devx, WRU_TIMEOUT, "0"b);

000543  aa   777423 2370 04	ldaq 	-237,ic		000166 = 000000000000 000000000000
000544  aa  6 00464 7571 00	staq 	pr6|308
000545  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
000546  aa  6 00470 2521 00	spri2	pr6|312
000547  aa   777374 3520 04	epp2 	-260,ic		000143 = 000000000013
000550  aa  6 00472 2521 00	spri2	pr6|314
000551  aa  6 00464 3521 00	epp2 	pr6|308
000552  aa  6 00474 2521 00	spri2	pr6|316
000553  aa  6 00466 6211 00	eax1 	pr6|310
000554  aa   014000 4310 07	fld  	6144,dl
000555  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
000556  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 206
	     code = 0;

000557  aa  6 00101 4501 00	stz  	pr6|65		code
						STATEMENT 1 ON LINE 207
	end;

000560  aa   000017 7100 04	tra  	15,ic		000577
						STATEMENT 1 ON LINE 208
	else if order = "printer_off" then code = 0;

000561  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000562  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000563  aa   777433 00 0013	desc9a	-229,11		000214 = 160162151156
000564  aa   000003 6010 04	tnz  	3,ic		000567
000565  aa  6 00101 4501 00	stz  	pr6|65		code
000566  aa   000011 7100 04	tra  	9,ic		000577
						STATEMENT 1 ON LINE 209
	else if order = "printer_on" then code = 0;

000567  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000570  aa  6 00102 00 0040	desc9a	pr6|66,32		order
000571  aa   777422 00 0012	desc9a	-238,10		000211 = 160162151156
000572  aa   000003 6010 04	tnz  	3,ic		000575
000573  aa  6 00101 4501 00	stz  	pr6|65		code
000574  aa   000003 7100 04	tra  	3,ic		000577
						STATEMENT 1 ON LINE 210
	else code = et_undefined_order_request;

000575  ia  4 00010 2361 00	ldq  	pr4|8		et_undefined_order_request
000576  aa  6 00101 7561 00	stq  	pr6|65		code
						STATEMENT 1 ON LINE 212
	arg_code = code;

000577  aa  6 00101 2361 00	ldq  	pr6|65		code
000600  aa  6 00176 7561 20	stq  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 213
	return;

000601  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read                                               STATEMENT 1 ON LINE 217
read: entry (arg_mdp, arg_subchan, arg_chain_ptr, arg_more_input, arg_code);

000602  at     000005000160
000603  tt     000156000160
000604  tt     000147000150
000605  ta     000602000000
000606  da     000211300000
000607  aa   001220 6270 00	eax7 	656
000610  aa  7 00034 3521 20	epp2 	pr7|28,*
000611  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000612  aa     000012000000
000613  aa     000000000000
000614  aa  6 00032 3735 20	epp7 	pr6|26,*
000615  aa  7 00012 3715 20	epp5 	pr7|10,*
000616  aa  6 00176 6515 00	spri5	pr6|126
						STATEMENT 1 ON LINE 219
	arg_chain_ptr = null ();

000617  aa   777345 2370 04	ldaq 	-283,ic		000164 = 077777000043 000001000000
000620  aa  6 00032 3735 20	epp7 	pr6|26,*
000621  aa  7 00006 7571 20	staq 	pr7|6,*		arg_chain_ptr
						STATEMENT 1 ON LINE 220
	arg_more_input = "0"b;

000622  aa  7 00010 4501 20	stz  	pr7|8,*		arg_more_input
						STATEMENT 1 ON LINE 221
	arg_code = 0;

000623  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 223
	return;

000624  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO check_modes                                        STATEMENT 1 ON LINE 227
check_modes: entry (arg_mdp, arg_subchan, arg_mclp, arg_code);

000625  at     000004000160
000626  tt     000156000160
000627  ta     000150000000
000630  ta     000625000000
000631  da     000217300000
000632  aa   001220 6270 00	eax7 	656
000633  aa  7 00034 3521 20	epp2 	pr7|28,*
000634  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000635  aa     000010000000
000636  aa     000000000000
000637  aa  6 00032 3735 20	epp7 	pr6|26,*
000640  aa  7 00010 3715 20	epp5 	pr7|8,*
000641  aa  6 00176 6515 00	spri5	pr6|126
						STATEMENT 1 ON LINE 229
	mdp = arg_mdp;

000642  aa  6 00032 3735 20	epp7 	pr6|26,*
000643  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
000644  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
000645  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 230
	subchan = arg_subchan;

000646  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
000647  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 231
	mdep = addr (md.mde_entry (subchan));

000650  aa   000013 4020 07	mpy  	11,dl
000651  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
000652  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 232
	mclp = arg_mclp;

000653  aa  7 00006 3515 20	epp1 	pr7|6,*		arg_mclp
000654  aa  1 00000 3515 20	epp1 	pr1|0,*		arg_mclp
000655  aa  6 00162 2515 00	spri1	pr6|114		mclp
						STATEMENT 1 ON LINE 233
	ttybp = addr (tty_buf$);

000656  aa  6 00044 3701 20	epp4 	pr6|36,*
000657  la  4 00034 3715 20	epp5 	pr4|28,*		tty_buf$
000660  aa  6 00150 6515 00	spri5	pr6|104		ttybp
						STATEMENT 1 ON LINE 235
	do i = 1 to mcl.n_entries;

000661  aa  1 00001 2361 00	ldq  	pr1|1		mcl.n_entries
000662  aa  6 00200 7561 00	stq  	pr6|128
000663  aa   000001 2360 07	ldq  	1,dl
000664  aa  6 00121 7561 00	stq  	pr6|81		i
000665  aa   000000 0110 03	nop  	0,du
000666  aa  6 00121 2361 00	ldq  	pr6|81		i
000667  aa  6 00200 1161 00	cmpq 	pr6|128
000670  aa   000050 6054 04	tpnz 	40,ic		000740
						STATEMENT 1 ON LINE 236
	     mclep = addr (mcl.entries (i));

000671  aa   000005 4020 07	mpy  	5,dl
000672  aa  6 00162 3735 20	epp7 	pr6|114,*		mclp
000673  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
000674  aa  6 00164 6535 00	spri7	pr6|116		mclep
						STATEMENT 1 ON LINE 237
	     mcle.mpx_mode = "0"b;

000675  aa   006250 2350 04	lda  	3240,ic		007145 = 677777777777
000676  aa  7 00004 3551 00	ansa 	pr7|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 238
	     if mcle.mode_name = "hndlquit" | mcle.mode_name = "rawi" | mcle.mode_name = "rawo" then
		mcle.mpx_mode = "1"b;

000677  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000700  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
000701  aa   777263 00 0010	desc9a	-333,8		000162 = 150156144154
000702  aa   000011 6000 04	tze  	9,ic		000713
000703  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000704  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
000705  aa   777234 00 0004	desc9a	-356,4		000137 = 162141167151
000706  aa   000005 6000 04	tze  	5,ic		000713
000707  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000710  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
000711  aa   777227 00 0004	desc9a	-361,4		000136 = 162141167157
000712  aa   000004 6010 04	tnz  	4,ic		000716
000713  aa   100000 2350 03	lda  	32768,du
000714  aa  7 00004 2551 00	orsa 	pr7|4		mcle.mpx_mode
000715  aa   000021 7100 04	tra  	17,ic		000736
						STATEMENT 1 ON LINE 240
	     else if mcle.mode_name = "raw3270io" then
		if (^md.allow_raw3270 & mcle.mode_switch) then mcle.error = "1"b;

000716  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000717  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
000720  aa   777270 00 0011	desc9a	-328,9		000206 = 162141167063
000721  aa   000015 6010 04	tnz  	13,ic		000736
000722  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
000723  aa  5 00102 2351 00	lda  	pr5|66		md.allow_raw3270
000724  aa   000200 3150 03	cana 	128,du
000725  aa   000007 6010 04	tnz  	7,ic		000734
000726  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
000727  aa   400000 3150 03	cana 	131072,du
000730  aa   000004 6000 04	tze  	4,ic		000734
000731  aa   040000 2350 03	lda  	16384,du
000732  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
000733  aa   000003 7100 04	tra  	3,ic		000736
						STATEMENT 1 ON LINE 242
		else mcle.mpx_mode = "1"b;

000734  aa   100000 2350 03	lda  	32768,du
000735  aa  7 00004 2551 00	orsa 	pr7|4		mcle.mpx_mode
						STATEMENT 1 ON LINE 243
	end;

000736  aa  6 00121 0541 00	aos  	pr6|81		i
000737  aa   777727 7100 04	tra  	-41,ic		000666
						STATEMENT 1 ON LINE 245
	arg_code = 0;

000740  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 246
	return;

000741  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO set_modes                                          STATEMENT 1 ON LINE 248
set_modes: entry (arg_mdp, arg_subchan, arg_mclp, arg_code);

000742  ta     000625000000
000743  da     000225300000
000744  aa   001220 6270 00	eax7 	656
000745  aa  7 00034 3521 20	epp2 	pr7|28,*
000746  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000747  aa     000010000000
000750  aa     000000000000
000751  aa  6 00032 3735 20	epp7 	pr6|26,*
000752  aa  7 00010 3715 20	epp5 	pr7|8,*
000753  aa  6 00176 6515 00	spri5	pr6|126
						STATEMENT 1 ON LINE 250
	mdp = arg_mdp;

000754  aa  6 00032 3735 20	epp7 	pr6|26,*
000755  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
000756  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
000757  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 251
	subchan = arg_subchan;

000760  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
000761  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 252
	mdep = addr (md.mde_entry (subchan));

000762  aa   000013 4020 07	mpy  	11,dl
000763  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
000764  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 253
	mclp = arg_mclp;

000765  aa  7 00006 3515 20	epp1 	pr7|6,*		arg_mclp
000766  aa  1 00000 3515 20	epp1 	pr1|0,*		arg_mclp
000767  aa  6 00162 2515 00	spri1	pr6|114		mclp
						STATEMENT 1 ON LINE 254
	arg_code = 0;

000770  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 255
	ttybp = addr (tty_buf$);

000771  aa  6 00044 3701 20	epp4 	pr6|36,*
000772  la  4 00034 3715 20	epp5 	pr4|28,*		tty_buf$
000773  aa  6 00150 6515 00	spri5	pr6|104		ttybp
						STATEMENT 1 ON LINE 257
	save_raw_in_effect = mde.raw3270_in_effect;

000774  aa  3 00012 2351 00	lda  	pr3|10		mde.raw3270_in_effect
000775  aa   000015 7350 00	als  	13
000776  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000777  aa  6 00142 7551 00	sta  	pr6|98		save_raw_in_effect
						STATEMENT 1 ON LINE 258
	if mcl.init then mde.hndlquit, mde.rawi, mde.rawo, mde.raw3270 = "0"b;

001000  aa  1 00005 2351 00	lda  	pr1|5		mcl.init
001001  aa   400000 3150 03	cana 	131072,du
001002  aa   000011 6000 04	tze  	9,ic		001013
001003  aa   006141 2350 04	lda  	3169,ic		007144 = 737777777777
001004  aa  3 00012 3551 00	ansa 	pr3|10		mde.hndlquit
001005  aa   006136 2350 04	lda  	3166,ic		007143 = 777677777777
001006  aa  3 00012 3551 00	ansa 	pr3|10		mde.rawi
001007  aa   006133 2350 04	lda  	3163,ic		007142 = 777577777777
001010  aa  3 00012 3551 00	ansa 	pr3|10		mde.rawo
001011  aa   006130 2350 04	lda  	3160,ic		007141 = 777737777777
001012  aa  3 00012 3551 00	ansa 	pr3|10		mde.raw3270
						STATEMENT 1 ON LINE 260
	do i = 1 to mcl.n_entries;

001013  aa  1 00001 2361 00	ldq  	pr1|1		mcl.n_entries
001014  aa  6 00201 7561 00	stq  	pr6|129
001015  aa   000001 2360 07	ldq  	1,dl
001016  aa  6 00121 7561 00	stq  	pr6|81		i
001017  aa   000000 0110 03	nop  	0,du
001020  aa  6 00121 2361 00	ldq  	pr6|81		i
001021  aa  6 00201 1161 00	cmpq 	pr6|129
001022  aa   000073 6054 04	tpnz 	59,ic		001115
						STATEMENT 1 ON LINE 261
	     mclep = addr (mcl.entries (i));

001023  aa   000005 4020 07	mpy  	5,dl
001024  aa  6 00162 3735 20	epp7 	pr6|114,*		mclp
001025  aa  7 00001 3735 06	epp7 	pr7|1,ql		mcl.entries
001026  aa  6 00164 6535 00	spri7	pr6|116		mclep
						STATEMENT 1 ON LINE 262
	     if mcle.mpx_mode then do;

001027  aa  7 00004 2351 00	lda  	pr7|4		mcle.mpx_mode
001030  aa   100000 3150 03	cana 	32768,du
001031  aa   000062 6000 04	tze  	50,ic		001113
						STATEMENT 1 ON LINE 263
		if mcle.mode_name = "hndlquit" then mde.hndlquit = mcle.mode_switch;

001032  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001033  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
001034  aa   777130 00 0010	desc9a	-424,8		000162 = 150156144154
001035  aa   000010 6010 04	tnz  	8,ic		001045
001036  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
001037  aa   000003 7710 00	arl  	3
001040  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001041  aa  5 00012 6751 00	era  	pr5|10		mde.hndlquit
001042  aa   040000 3750 03	ana  	16384,du
001043  aa  5 00012 6551 00	ersa 	pr5|10		mde.hndlquit
001044  aa   000047 7100 04	tra  	39,ic		001113
						STATEMENT 1 ON LINE 264
		else if mcle.mode_name = "rawi" then mde.rawi = mcle.mode_switch;

001045  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001046  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
001047  aa   777072 00 0004	desc9a	-454,4		000137 = 162141167151
001050  aa   000010 6010 04	tnz  	8,ic		001060
001051  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
001052  aa   000013 7710 00	arl  	11
001053  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001054  aa  5 00012 6751 00	era  	pr5|10		mde.rawi
001055  aa   000100 3750 03	ana  	64,du
001056  aa  5 00012 6551 00	ersa 	pr5|10		mde.rawi
001057  aa   000034 7100 04	tra  	28,ic		001113
						STATEMENT 1 ON LINE 265
		else if mcle.mode_name = "rawo" then mde.rawo = mcle.mode_switch;

001060  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001061  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
001062  aa   777056 00 0004	desc9a	-466,4		000136 = 162141167157
001063  aa   000010 6010 04	tnz  	8,ic		001073
001064  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
001065  aa   000012 7710 00	arl  	10
001066  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001067  aa  5 00012 6751 00	era  	pr5|10		mde.rawo
001070  aa   000200 3750 03	ana  	128,du
001071  aa  5 00012 6551 00	ersa 	pr5|10		mde.rawo
001072  aa   000021 7100 04	tra  	17,ic		001113
						STATEMENT 1 ON LINE 266
		else if mcle.mode_name = "raw3270io" then mde.raw3270 = mcle.mode_switch;

001073  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
001074  aa  7 00000 00 0020	desc9a	pr7|0,16		mcle.mode_name
001075  aa   777113 00 0011	desc9a	-437,9		000206 = 162141167063
001076  aa   000010 6010 04	tnz  	8,ic		001106
001077  aa  7 00004 2351 00	lda  	pr7|4		mcle.mode_switch
001100  aa   000014 7710 00	arl  	12
001101  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001102  aa  5 00012 6751 00	era  	pr5|10		mde.raw3270
001103  aa   000040 3750 03	ana  	32,du
001104  aa  5 00012 6551 00	ersa 	pr5|10		mde.raw3270
001105  aa   000006 7100 04	tra  	6,ic		001113
						STATEMENT 1 ON LINE 267
		else do;

						STATEMENT 1 ON LINE 268
		     mcle.error = "1"b;

001106  aa   040000 2350 03	lda  	16384,du
001107  aa  7 00004 2551 00	orsa 	pr7|4		mcle.error
						STATEMENT 1 ON LINE 269
		     arg_code = et_bad_mode;

001110  aa  6 00044 3701 20	epp4 	pr6|36,*
001111  ia  4 00013 2361 00	ldq  	pr4|11		et_bad_mode
001112  aa  6 00176 7561 20	stq  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 270
		end;

						STATEMENT 1 ON LINE 271
	     end;

						STATEMENT 1 ON LINE 272
	end;

001113  aa  6 00121 0541 00	aos  	pr6|81		i
001114  aa   777704 7100 04	tra  	-60,ic		001020
						STATEMENT 1 ON LINE 274
	mde.raw3270_in_effect = mde.rawi & mde.rawo & mde.raw3270;

001115  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
001116  aa  7 00012 2351 00	lda  	pr7|10		mde.raw3270
001117  aa   000014 7350 00	als  	12
001120  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001121  aa  6 00463 7551 00	sta  	pr6|307		mde.raw3270
001122  aa  7 00012 2351 00	lda  	pr7|10		mde.rawo
001123  aa   000012 7350 00	als  	10
001124  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001125  aa  6 00476 7551 00	sta  	pr6|318		mde.rawo
001126  aa  7 00012 2351 00	lda  	pr7|10		mde.rawi
001127  aa   000013 7350 00	als  	11
001130  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001131  aa  6 00476 3751 00	ana  	pr6|318		mde.rawo
001132  aa  6 00463 3751 00	ana  	pr6|307		mde.raw3270
001133  aa   000015 7710 00	arl  	13
001134  aa  7 00012 6751 00	era  	pr7|10		mde.raw3270_in_effect
001135  aa   000020 3750 03	ana  	16,du
001136  aa  7 00012 6551 00	ersa 	pr7|10		mde.raw3270_in_effect
						STATEMENT 1 ON LINE 275
	if save_raw_in_effect & ^mde.raw3270_in_effect & ^mde.write_queued & mde.write_chain_ptr ^= null () then
	     call reset_channel;

001137  aa  6 00142 2351 00	lda  	pr6|98		save_raw_in_effect
001140  aa   000010 6000 04	tze  	8,ic		001150
001141  aa  7 00012 2351 00	lda  	pr7|10		mde.write_queued
001142  aa   000030 3150 03	cana 	24,du
001143  aa   000005 6010 04	tnz  	5,ic		001150
001144  aa  7 00011 2361 00	ldq  	pr7|9		mde.write_chain_ptr
001145  aa   005773 1160 04	cmpq 	3067,ic		007140 = 007777000001
001146  aa   000002 6000 04	tze  	2,ic		001150
001147  aa   005452 6700 04	tsp4 	2858,ic		006621
						STATEMENT 1 ON LINE 278
	return;

001150  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_modes                                          STATEMENT 1 ON LINE 280
get_modes: entry (arg_mdp, arg_subchan, arg_modes, arg_code);

001151  at     000004000160
001152  tt     000156000152
001153  ta     000150000000
001154  ta     001151000000
001155  da     000233300000
001156  aa   001220 6270 00	eax7 	656
001157  aa  7 00034 3521 20	epp2 	pr7|28,*
001160  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001161  aa     000010000000
001162  aa     000000000000
001163  aa  6 00042 3735 20	epp7 	pr6|34,*
001164  aa  7 00004 2361 20	ldq  	pr7|4,*
001165  aa   000002 6040 04	tmi  	2,ic		001167
001166  aa   777777 3760 07	anq  	262143,dl
001167  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001170  aa  6 00462 7561 00	stq  	pr6|306
001171  aa  6 00032 3715 20	epp5 	pr6|26,*
001172  aa  5 00010 3535 20	epp3 	pr5|8,*
001173  aa  6 00176 2535 00	spri3	pr6|126
						STATEMENT 1 ON LINE 282
	mdp = arg_mdp;

001174  aa  6 00032 3735 20	epp7 	pr6|26,*
001175  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
001176  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
001177  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 283
	subchan = arg_subchan;

001200  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
001201  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 284
	mdep = addr (md.mde_entry (subchan));

001202  aa   000013 4020 07	mpy  	11,dl
001203  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
001204  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 285
	ttybp = addr (tty_buf$);

001205  aa  6 00044 3701 20	epp4 	pr6|36,*
001206  la  4 00034 3515 20	epp1 	pr4|28,*		tty_buf$
001207  aa  6 00150 2515 00	spri1	pr6|104		ttybp
						STATEMENT 1 ON LINE 287
	if mde.raw3270 then arg_modes = "raw3270io";

001210  aa  3 00012 2351 00	lda  	pr3|10		mde.raw3270
001211  aa   000040 3150 03	cana 	32,du
001212  aa   000007 6000 04	tze  	7,ic		001221
001213  aa  7 00006 3715 20	epp5 	pr7|6,*
001214  aa  6 00462 2361 00	ldq  	pr6|306
001215  aa  040 140 100 404	mlr  	(ic),(pr,rl),fill(040)
001216  aa   776771 00 0011	desc9a	-519,9		000206 = 162141167063
001217  aa  5 00000 00 0006	desc9a	pr5|0,ql		arg_modes
001220  aa   000006 7100 04	tra  	6,ic		001226
						STATEMENT 1 ON LINE 288
	else arg_modes = "^raw3270io";

001221  aa  7 00006 3715 20	epp5 	pr7|6,*
001222  aa  6 00462 2361 00	ldq  	pr6|306
001223  aa  040 140 100 404	mlr  	(ic),(pr,rl),fill(040)
001224  aa   776760 00 0012	desc9a	-528,10		000203 = 136162141167
001225  aa  5 00000 00 0006	desc9a	pr5|0,ql		arg_modes
						STATEMENT 1 ON LINE 289
	arg_code = 0;

001226  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 290
	return;

001227  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO write                                              STATEMENT 1 ON LINE 294
write: entry (arg_mdp, arg_subchan, arg_chain_ptr, arg_code);

001230  ta     000625000000
001231  da     000236300000
001232  aa   001220 6270 00	eax7 	656
001233  aa  7 00034 3521 20	epp2 	pr7|28,*
001234  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001235  aa     000010000000
001236  aa     000000000000
001237  aa  6 00032 3735 20	epp7 	pr6|26,*
001240  aa  7 00010 3715 20	epp5 	pr7|8,*
001241  aa  6 00176 6515 00	spri5	pr6|126
						STATEMENT 1 ON LINE 296
	mdp = arg_mdp;

001242  aa  6 00032 3735 20	epp7 	pr6|26,*
001243  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
001244  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
001245  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 297
	subchan = arg_subchan;

001246  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
001247  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 298
	mdep = addr (md.mde_entry (subchan));

001250  aa   000013 4020 07	mpy  	11,dl
001251  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
001252  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 299
	chain_ptr = arg_chain_ptr;

001253  aa  7 00006 3515 20	epp1 	pr7|6,*		arg_chain_ptr
001254  aa  1 00000 3515 20	epp1 	pr1|0,*		arg_chain_ptr
001255  aa  6 00114 2515 00	spri1	pr6|76		chain_ptr
						STATEMENT 1 ON LINE 300
	end_chain_ptr, rest_chain_ptr, header_blockp = null ();

001256  aa   776706 3714 24	epp5 	-570,ic*
001257  aa  6 00136 6515 00	spri5	pr6|94		end_chain_ptr
001260  aa  6 00134 6515 00	spri5	pr6|92		rest_chain_ptr
001261  aa  6 00130 6515 00	spri5	pr6|88		header_blockp
						STATEMENT 1 ON LINE 301
	arg_code = 0;

001262  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 302
	ttybp = addr (tty_buf$);

001263  aa  6 00044 3701 20	epp4 	pr6|36,*
001264  la  4 00034 3535 20	epp3 	pr4|28,*		tty_buf$
001265  aa  6 00150 2535 00	spri3	pr6|104		ttybp
						STATEMENT 1 ON LINE 306
	if mde.raw3270_in_effect then do;

001266  aa  6 00174 3515 20	epp1 	pr6|124,*		mdep
001267  aa  1 00012 2351 00	lda  	pr1|10		mde.raw3270_in_effect
001270  aa   000020 3150 03	cana 	16,du
001271  aa   000367 6000 04	tze  	247,ic		001660
						STATEMENT 1 ON LINE 307
	     if mde.write_chain_ptr ^= null () then do;

001272  aa  1 00011 2361 00	ldq  	pr1|9		mde.write_chain_ptr
001273  aa   005645 1160 04	cmpq 	2981,ic		007140 = 007777000001
001274  aa   000027 6000 04	tze  	23,ic		001323
						STATEMENT 1 ON LINE 308
		do blockp = mde.write_chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);

001275  aa  1 00011 7651 00	lprp5	pr1|9		mde.write_chain_ptr
001276  aa  6 00160 6515 00	spri5	pr6|112		blockp
001277  aa   000000 0110 03	nop  	0,du
001300  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
001301  aa   000066 7730 00	lrl  	54
001302  aa  6 00463 7561 00	stq  	pr6|307		buffer.next
001303  aa   000005 6000 04	tze  	5,ic		001310
						STATEMENT 1 ON LINE 309
		end;

001304  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
001305  aa   000000 3120 06	eawp2	0,ql
001306  aa  6 00160 2521 00	spri2	pr6|112		blockp
001307  aa   777771 7100 04	tra  	-7,ic		001300
						STATEMENT 1 ON LINE 310
		buffer.next = bin (rel (chain_ptr));

001310  aa  6 00114 6351 20	eaa  	pr6|76,*		chain_ptr
001311  aa   000066 7730 00	lrl  	54
001312  aa   000066 7370 00	lls  	54
001313  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.next
001314  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 311
		chain_ptr = mde.write_chain_ptr;

001315  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001316  aa  5 00011 7651 00	lprp5	pr5|9		mde.write_chain_ptr
001317  aa  6 00114 6515 00	spri5	pr6|76		chain_ptr
						STATEMENT 1 ON LINE 312
		mde.write_chain_ptr = null ();

001320  aa   005620 2360 04	ldq  	2960,ic		007140 = 007777000001
001321  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
001322  aa  3 00011 7561 00	stq  	pr3|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 313
	     end;

						STATEMENT 1 ON LINE 317
	     position = 0;

001323  aa  6 00122 4501 00	stz  	pr6|82		position
						STATEMENT 1 ON LINE 318
	     blockp = chain_ptr;

001324  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
001325  aa  6 00160 6535 00	spri7	pr6|112		blockp
						STATEMENT 1 ON LINE 319
	     do while (position = 0 & (rel (blockp) ^= "0"b));

001326  aa  6 00122 2361 00	ldq  	pr6|82		position
001327  aa   000034 6010 04	tnz  	28,ic		001363
001330  aa  6 00160 6351 20	eaa  	pr6|112,*		blockp
001331  aa   000032 6000 04	tze  	26,ic		001363
						STATEMENT 1 ON LINE 320
		textp = addr (buffer.chars);

001332  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
001333  aa  7 00001 3735 00	epp7 	pr7|1		buffer.chars
001334  aa  6 00116 6535 00	spri7	pr6|78		textp
						STATEMENT 1 ON LINE 321
		textl = buffer.tally;

001335  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001336  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001337  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 322
		position = index (text, md.etx);

001340  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
001341  aa  000 100 124 540	scm  	(pr,rl),(pr),mask(000)
001342  aa  7 00000 00 0006	desc9a	pr7|0,ql		text
001343  aa  5 00026 60 0001	desc9a	pr5|22(3),1	md.etx
001344  aa  6 00056 0001 00	arg  	pr6|46
001345  aa  6 00056 2361 00	ldq  	pr6|46
001346  aa   000002 6070 04	ttf  	2,ic		001350
001347  aa   000001 3360 07	lcq  	1,dl
001350  aa   000001 0760 07	adq  	1,dl
001351  aa  6 00122 7561 00	stq  	pr6|82		position
						STATEMENT 1 ON LINE 323
		end_chain_ptr = blockp;

001352  aa  6 00160 3535 20	epp3 	pr6|112,*		blockp
001353  aa  6 00136 2535 00	spri3	pr6|94		end_chain_ptr
						STATEMENT 1 ON LINE 324
		if position = 0
		then do;

001354  aa   777752 6010 04	tnz  	-22,ic		001326
						STATEMENT 1 ON LINE 326
		     blockp = ptr (ttybp, buffer.next);

001355  aa  3 00000 2351 00	lda  	pr3|0		buffer.next
001356  aa   000066 7730 00	lrl  	54
001357  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
001360  aa   000000 3120 06	eawp2	0,ql
001361  aa  6 00160 2521 00	spri2	pr6|112		blockp
						STATEMENT 1 ON LINE 327
		end;

						STATEMENT 1 ON LINE 328
	     end;

001362  aa   777744 7100 04	tra  	-28,ic		001326
						STATEMENT 1 ON LINE 330
	     if position = -1			/* No ETX in message anywhere. */
	     then do;

001363  aa   005566 1160 04	cmpq 	2934,ic		007151 = 777777777777
001364  aa   000032 6010 04	tnz  	26,ic		001416
						STATEMENT 1 ON LINE 332
		if ^end_chain_ptr -> buffer.break then do;

001365  aa  6 00136 2351 20	lda  	pr6|94,*		buffer.break
001366  aa   100000 3150 07	cana 	32768,dl
001367  aa   001065 6010 04	tnz  	565,ic		002454
						STATEMENT 1 ON LINE 333
		     mde.write_chain_ptr = chain_ptr;

001370  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
001371  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
001372  aa  5 00011 5471 00	sprp7	pr5|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 334
		     arg_chain_ptr = null ();

001373  aa   776571 2370 04	ldaq 	-647,ic		000164 = 077777000043 000001000000
001374  aa  6 00032 3535 20	epp3 	pr6|26,*
001375  aa  3 00006 7571 20	staq 	pr3|6,*		arg_chain_ptr
						STATEMENT 1 ON LINE 335
		     arg_code = 0;

001376  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 336
		     call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

001377  aa   776567 2370 04	ldaq 	-649,ic		000166 = 000000000000 000000000000
001400  aa  6 00464 7571 00	staq 	pr6|308
001401  aa  5 00000 3521 00	epp2 	pr5|0		mde.devx
001402  aa  6 00470 2521 00	spri2	pr6|312
001403  aa   776546 3520 04	epp2 	-666,ic		000151 = 000000000004
001404  aa  6 00472 2521 00	spri2	pr6|314
001405  aa  6 00464 3521 00	epp2 	pr6|308
001406  aa  6 00474 2521 00	spri2	pr6|316
001407  aa  6 00466 6211 00	eax1 	pr6|310
001410  aa   014000 4310 07	fld  	6144,dl
001411  aa  6 00044 3701 20	epp4 	pr6|36,*
001412  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
001413  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 337
		     return;

001414  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 338
		end;

						STATEMENT 1 ON LINE 339
		else do;

						STATEMENT 1 ON LINE 340
		     goto write_format_error;

001415  aa   001037 7100 04	tra  	543,ic		002454
						STATEMENT 1 ON LINE 341
		end;

						STATEMENT 1 ON LINE 342
	     end;

						STATEMENT 1 ON LINE 346
	     if position = buffer.tally		/* ETX is at end of buffer.  Don't need to split buffer. */
	     then do;

001416  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001417  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001420  aa  6 00122 1161 00	cmpq 	pr6|82		position
001421  aa   000015 6010 04	tnz  	13,ic		001436
						STATEMENT 1 ON LINE 348
		if buffer.next = 0 then ;

001422  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
001423  aa   000066 7730 00	lrl  	54
001424  aa  6 00463 7561 00	stq  	pr6|307		buffer.next
001425  aa   000002 6010 04	tnz  	2,ic		001427
001426  aa   000111 7100 04	tra  	73,ic		001537
						STATEMENT 1 ON LINE 349
		else do;

						STATEMENT 1 ON LINE 350
		     rest_chain_ptr = ptr (ttybp, buffer.next);

001427  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
001430  aa   000000 3120 06	eawp2	0,ql
001431  aa  6 00134 2521 00	spri2	pr6|92		rest_chain_ptr
						STATEMENT 1 ON LINE 351
		     buffer.next = 0;

001432  aa   000000 2350 07	lda  	0,dl
001433  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.next
001434  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 352
		end;

						STATEMENT 1 ON LINE 353
	     end;

001435  aa   000102 7100 04	tra  	66,ic		001537
						STATEMENT 1 ON LINE 354
	     else do;

						STATEMENT 1 ON LINE 355
		call tty_space_man$get_buffer (mde.devx,
		     16 * (buffer.size_code + 1),
		     OUTPUT,
		     rest_chain_ptr);

001436  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.size_code
001437  aa   000030 7350 00	als  	24
001440  aa   000105 7730 00	lrl  	69
001441  aa   000001 0760 07	adq  	1,dl
001442  aa   000004 7360 00	qls  	4
001443  aa  6 00463 7561 00	stq  	pr6|307
001444  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
001445  aa  6 00502 2521 00	spri2	pr6|322
001446  aa  6 00463 3521 00	epp2 	pr6|307
001447  aa  6 00504 2521 00	spri2	pr6|324
001450  aa   776472 3520 04	epp2 	-710,ic		000142 = 400000000000
001451  aa  6 00506 2521 00	spri2	pr6|326
001452  aa  6 00134 3521 00	epp2 	pr6|92		rest_chain_ptr
001453  aa  6 00510 2521 00	spri2	pr6|328
001454  aa  6 00500 6211 00	eax1 	pr6|320
001455  aa   020000 4310 07	fld  	8192,dl
001456  aa  6 00044 3701 20	epp4 	pr6|36,*
001457  la  4 00044 3521 20	epp2 	pr4|36,*		tty_space_man$get_buffer
001460  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 359
		if rest_chain_ptr = null ()
		then do;

001461  aa  6 00134 2371 00	ldaq 	pr6|92		rest_chain_ptr
001462  aa   776502 6770 04	eraq 	-702,ic		000164 = 077777000043 000001000000
001463  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001464  aa   000005 6010 04	tnz  	5,ic		001471
						STATEMENT 1 ON LINE 361
		     arg_code = et_noalloc;

001465  aa  6 00044 3701 20	epp4 	pr6|36,*
001466  ia  4 00012 2361 00	ldq  	pr4|10		et_noalloc
001467  aa  6 00176 7561 20	stq  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 362
		     return;

001470  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 363
		end;

						STATEMENT 1 ON LINE 364
		rest_chain_ptr -> buffer.next = buffer.next;

001471  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
001472  aa  6 00134 3735 20	epp7 	pr6|92,*		buffer.next
001473  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 365
		rest_chain_ptr -> buffer.flags = buffer.flags;

001474  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
001475  aa   000006 7270 07	lxl7 	6,dl
001476  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
001477  aa  5 00000 40 0017	descb	pr5|0(18),x7	buffer.flags
001500  aa  6 00463 00 0017	descb	pr6|307,x7
001501  aa  6 00134 3535 20	epp3 	pr6|92,*		rest_chain_ptr
001502  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
001503  aa  6 00463 00 0017	descb	pr6|307,x7
001504  aa  3 00000 40 0017	descb	pr3|0(18),x7	buffer.flags
						STATEMENT 1 ON LINE 366
		rest_chain_ptr -> buffer.size_code = buffer.size_code;

001505  aa  5 00000 2351 00	lda  	pr5|0		buffer.size_code
001506  aa  3 00000 6751 00	era  	pr3|0		buffer.size_code
001507  aa   007000 3750 07	ana  	3584,dl
001510  aa  3 00000 6551 00	ersa 	pr3|0		buffer.size_code
						STATEMENT 1 ON LINE 367
		rest_chain_ptr -> buffer.tally = (buffer.tally - position);

001511  aa  5 00000 2361 00	ldq  	pr5|0		buffer.tally
001512  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001513  aa  6 00122 1761 00	sbq  	pr6|82		position
001514  aa  3 00000 5521 04	stbq 	pr3|0,04		buffer.tally
						STATEMENT 1 ON LINE 368
		buffer.tally = position;

001515  aa  6 00122 2361 00	ldq  	pr6|82		position
001516  aa  5 00000 5521 04	stbq 	pr5|0,04		buffer.tally
						STATEMENT 1 ON LINE 369
		buffer.next = 0;

001517  aa   000000 2350 07	lda  	0,dl
001520  aa  5 00000 5511 60	stba 	pr5|0,60		buffer.next
						STATEMENT 1 ON LINE 370
		buffer.break = "1"b;

001521  aa   100000 2350 07	lda  	32768,dl
001522  aa  5 00000 2551 00	orsa 	pr5|0		buffer.break
						STATEMENT 1 ON LINE 371
		textp = addr (buffer.chars (position));

001523  aa  5 00001 3521 00	epp2 	pr5|1		buffer.chars
001524  aa  2 00000 5005 06	a9bd 	pr2|0,ql
001525  aa  6 00116 2521 00	spri2	pr6|78		textp
						STATEMENT 1 ON LINE 372
		textl = rest_chain_ptr -> buffer.tally;

001526  aa  3 00000 2361 00	ldq  	pr3|0		buffer.tally
001527  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001530  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 373
		targetp = addr (rest_chain_ptr -> buffer.chars);

001531  aa  3 00001 3515 00	epp1 	pr3|1		buffer.chars
001532  aa  6 00144 2515 00	spri1	pr6|100		targetp
						STATEMENT 1 ON LINE 374
		targetl = textl;

001533  aa  6 00146 7561 00	stq  	pr6|102		targetl
						STATEMENT 1 ON LINE 375
		target = text;

001534  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001535  aa  2 00000 00 0006	desc9a	pr2|0,ql		text
001536  aa  1 00000 00 0006	desc9a	pr1|0,ql		target
						STATEMENT 1 ON LINE 376
	     end;

						STATEMENT 1 ON LINE 380
	     chain_len = 0;

001537  aa  6 00132 4501 00	stz  	pr6|90		chain_len
						STATEMENT 1 ON LINE 381
	     do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (rel (blockp) ^= "0"b);

001540  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
001541  aa  6 00160 6535 00	spri7	pr6|112		blockp
001542  aa  6 00160 6351 20	eaa  	pr6|112,*		blockp
001543  aa   000014 6000 04	tze  	12,ic		001557
						STATEMENT 1 ON LINE 382
		chain_len = chain_len + buffer.tally;

001544  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001545  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001546  aa  6 00132 0561 00	asq  	pr6|90		chain_len
						STATEMENT 1 ON LINE 383
		end_chain_ptr = blockp;

001547  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
001550  aa  6 00136 6535 00	spri7	pr6|94		end_chain_ptr
						STATEMENT 1 ON LINE 384
	     end;

001551  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
001552  aa   000066 7730 00	lrl  	54
001553  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
001554  aa   000000 3120 06	eawp2	0,ql
001555  aa  6 00160 2521 00	spri2	pr6|112		blockp
001556  aa   777764 7100 04	tra  	-12,ic		001542
						STATEMENT 1 ON LINE 385
	     if chain_len > max_raw_chain_len
	     then do;

001557  aa  6 00132 2361 00	ldq  	pr6|90		chain_len
001560  aa   007640 1160 07	cmpq 	4000,dl
001561  aa   000002 6044 04	tmoz 	2,ic		001563
						STATEMENT 1 ON LINE 387
		go to write_format_error;

001562  aa   000672 7100 04	tra  	442,ic		002454
						STATEMENT 1 ON LINE 388
	     end;

						STATEMENT 1 ON LINE 392
	     blockp = chain_ptr;

001563  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
001564  aa  6 00160 6535 00	spri7	pr6|112		blockp
						STATEMENT 1 ON LINE 393
	     if buffer.chars (0) ^= md.stx
	     then do;

001565  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
001566  aa  5 00025 2351 00	lda  	pr5|21		md.stx
001567  aa   000022 7350 00	als  	18
001570  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001571  aa  6 00463 7551 00	sta  	pr6|307		md.stx
001572  aa  6 00160 3535 20	epp3 	pr6|112,*		blockp
001573  aa  3 00001 2351 00	lda  	pr3|1		buffer.chars
001574  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001575  aa  6 00463 1151 00	cmpa 	pr6|307		md.stx
001576  aa   000002 6000 04	tze  	2,ic		001600
						STATEMENT 1 ON LINE 395
		go to write_format_error;

001577  aa   000655 7100 04	tra  	429,ic		002454
						STATEMENT 1 ON LINE 396
	     end;

						STATEMENT 1 ON LINE 397
	     if buffer.chars (1) ^= md.esc
	     then do;

001600  aa  5 00025 2351 00	lda  	pr5|21		md.esc
001601  aa   000033 7350 00	als  	27
001602  aa  6 00463 7551 00	sta  	pr6|307		md.esc
001603  aa  3 00001 2351 00	lda  	pr3|1		buffer.chars
001604  aa   000011 7350 00	als  	9
001605  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001606  aa  6 00463 1151 00	cmpa 	pr6|307		md.esc
001607  aa   000002 6000 04	tze  	2,ic		001611
						STATEMENT 1 ON LINE 399
		go to write_format_error;

001610  aa   000644 7100 04	tra  	420,ic		002454
						STATEMENT 1 ON LINE 400
	     end;

						STATEMENT 1 ON LINE 401
	     if (buffer.chars (2) = md.write)
		| (buffer.chars (2) = md.erase_write) then ;

001611  aa  3 00001 2351 00	lda  	pr3|1		buffer.chars
001612  aa   000022 7350 00	als  	18
001613  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001614  aa  6 00463 7551 00	sta  	pr6|307		buffer.chars
001615  aa  5 00026 2351 00	lda  	pr5|22		md.write
001616  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001617  aa  6 00463 1151 00	cmpa 	pr6|307		buffer.chars
001620  aa   000023 6000 04	tze  	19,ic		001643
001621  aa  5 00026 2351 00	lda  	pr5|22		md.erase_write
001622  aa   000011 7350 00	als  	9
001623  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001624  aa  6 00463 1151 00	cmpa 	pr6|307		buffer.chars
001625  aa   000002 6010 04	tnz  	2,ic		001627
001626  aa   000015 7100 04	tra  	13,ic		001643
						STATEMENT 1 ON LINE 403
	     else do;

						STATEMENT 1 ON LINE 404
		if buffer.chars (2) = md.copy
		then do;

001627  aa  5 00032 2351 00	lda  	pr5|26		md.copy
001630  aa   000022 7350 00	als  	18
001631  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001632  aa  6 00463 1151 00	cmpa 	pr6|307		buffer.chars
001633  aa   000621 6010 04	tnz  	401,ic		002454
						STATEMENT 1 ON LINE 406
		     if md.allow_copy then ;

001634  aa  5 00102 2351 00	lda  	pr5|66		md.allow_copy
001635  aa   000100 3150 03	cana 	64,du
001636  aa   000616 6000 04	tze  	398,ic		002454
001637  aa   000004 7100 04	tra  	4,ic		001643
						STATEMENT 1 ON LINE 407
		     else do;

						STATEMENT 1 ON LINE 408
			go to write_format_error;

001640  aa   000614 7100 04	tra  	396,ic		002454
						STATEMENT 1 ON LINE 409
		     end;

						STATEMENT 1 ON LINE 410
		end;

001641  aa   000002 7100 04	tra  	2,ic		001643
						STATEMENT 1 ON LINE 411
		else do;

						STATEMENT 1 ON LINE 412
		     goto write_format_error;

001642  aa   000612 7100 04	tra  	394,ic		002454
						STATEMENT 1 ON LINE 413
		end;

						STATEMENT 1 ON LINE 414
	     end;

						STATEMENT 1 ON LINE 418
	     blockp = end_chain_ptr;

001643  aa  6 00136 3735 20	epp7 	pr6|94,*		end_chain_ptr
001644  aa  6 00160 6535 00	spri7	pr6|112		blockp
						STATEMENT 1 ON LINE 419
	     if buffer.chars (buffer.tally - 1) ^= md.etx then go to write_format_error;

001645  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001646  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001647  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
001650  aa  6 00160 3535 20	epp3 	pr6|112,*		blockp
001651  aa  040 106 106 500	cmpc 	(pr),(pr,ql),fill(040)
001652  aa  5 00026 60 0001	desc9a	pr5|22(3),1	md.etx
001653  aa  3 00000 60 0001	desc9a	pr3|0(3),1	buffer.chars
001654  aa   000600 6010 04	tnz  	384,ic		002454
						STATEMENT 1 ON LINE 423
	     header_blockp = chain_ptr;

001655  aa  6 00114 3515 20	epp1 	pr6|76,*		chain_ptr
001656  aa  6 00130 2515 00	spri1	pr6|88		header_blockp
						STATEMENT 1 ON LINE 424
	     go to queue_write_data;

001657  aa   000567 7100 04	tra  	375,ic		002446
						STATEMENT 1 ON LINE 426
	end;

						STATEMENT 1 ON LINE 431
	call tty_space_man$get_buffer (mde.devx, 16, OUTPUT, header_blockp);

001660  aa   000020 2360 07	ldq  	16,dl
001661  aa  6 00463 7561 00	stq  	pr6|307
001662  aa  1 00000 3521 00	epp2 	pr1|0		mde.devx
001663  aa  6 00502 2521 00	spri2	pr6|322
001664  aa  6 00463 3521 00	epp2 	pr6|307
001665  aa  6 00504 2521 00	spri2	pr6|324
001666  aa   776254 3520 04	epp2 	-852,ic		000142 = 400000000000
001667  aa  6 00506 2521 00	spri2	pr6|326
001670  aa  6 00130 3521 00	epp2 	pr6|88		header_blockp
001671  aa  6 00510 2521 00	spri2	pr6|328
001672  aa  6 00500 6211 00	eax1 	pr6|320
001673  aa   020000 4310 07	fld  	8192,dl
001674  la  4 00044 3521 20	epp2 	pr4|36,*		tty_space_man$get_buffer
001675  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 432
	if header_blockp = null () then do;

001676  aa  6 00130 2371 00	ldaq 	pr6|88		header_blockp
001677  aa   776265 6770 04	eraq 	-843,ic		000164 = 077777000043 000001000000
001700  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001701  aa   000005 6010 04	tnz  	5,ic		001706
						STATEMENT 1 ON LINE 433
	     arg_code = et_noalloc;

001702  aa  6 00044 3701 20	epp4 	pr6|36,*
001703  ia  4 00012 2361 00	ldq  	pr4|10		et_noalloc
001704  aa  6 00176 7561 20	stq  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 434
	     return;

001705  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 435
	end;

						STATEMENT 1 ON LINE 440
	chain_len = 0;

001706  aa  6 00132 4501 00	stz  	pr6|90		chain_len
						STATEMENT 1 ON LINE 441
	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (rel (blockp) ^= "0"b);

001707  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
001710  aa  6 00160 6535 00	spri7	pr6|112		blockp
001711  aa   000000 0110 03	nop  	0,du
001712  aa  6 00160 6351 20	eaa  	pr6|112,*		blockp
001713  aa   000150 6000 04	tze  	104,ic		002063
						STATEMENT 1 ON LINE 442
	     chain_len = chain_len + buffer.tally;

001714  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001715  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001716  aa  6 00132 0561 00	asq  	pr6|90		chain_len
						STATEMENT 1 ON LINE 443
	     if chain_len > max_chain_len then do;

001717  aa  6 00132 2361 00	ldq  	pr6|90		chain_len
001720  aa   003636 1160 07	cmpq 	1950,dl
001721  aa   000132 6044 04	tmoz 	90,ic		002053
						STATEMENT 1 ON LINE 444
		rest_chain_ptr = blockp;

001722  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
001723  aa  6 00134 6535 00	spri7	pr6|92		rest_chain_ptr
						STATEMENT 1 ON LINE 445
		blockp = end_chain_ptr;

001724  aa  6 00136 3715 20	epp5 	pr6|94,*		end_chain_ptr
001725  aa  6 00160 6515 00	spri5	pr6|112		blockp
						STATEMENT 1 ON LINE 446
		buffer.next = 0;

001726  aa   000000 2350 07	lda  	0,dl
001727  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.next
001730  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 447
		if mde.printer then go to chain_split;

001731  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
001732  aa  3 00012 2351 00	lda  	pr3|10		mde.printer
001733  aa   100000 3150 03	cana 	32768,du
001734  aa   000127 6010 04	tnz  	87,ic		002063
						STATEMENT 1 ON LINE 448
		textp = addr (buffer.chars);

001735  aa  6 00160 3515 20	epp1 	pr6|112,*		blockp
001736  aa  1 00001 3515 00	epp1 	pr1|1		buffer.chars
001737  aa  6 00116 2515 00	spri1	pr6|78		textp
						STATEMENT 1 ON LINE 449
		textl = buffer.tally;

001740  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
001741  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
001742  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 450
		do i = 2 to 1 by -1 while (textl > (2 - i));

001743  aa   000002 2360 07	ldq  	2,dl
001744  aa  6 00121 7561 00	stq  	pr6|81		i
001745  aa   000000 0110 03	nop  	0,du
001746  aa  6 00121 2361 00	ldq  	pr6|81		i
001747  aa   000001 1160 07	cmpq 	1,dl
001750  aa   000113 6040 04	tmi  	75,ic		002063
001751  aa   000002 2360 07	ldq  	2,dl
001752  aa  6 00121 1761 00	sbq  	pr6|81		i
001753  aa  6 00120 1161 00	cmpq 	pr6|80		textl
001754  aa   000107 6050 04	tpl  	71,ic		002063
						STATEMENT 1 ON LINE 451
		     c = substr (text, textl - 2 + i, 1);

001755  aa  6 00120 2361 00	ldq  	pr6|80		textl
001756  aa   000002 1760 07	sbq  	2,dl
001757  aa  6 00121 0761 00	adq  	pr6|81		i
001760  aa  6 00141 4501 00	stz  	pr6|97		c
001761  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
001762  aa  040 100 100 506	mlr  	(pr,ql),(pr),fill(040)
001763  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	text
001764  aa  6 00141 00 0001	desc9a	pr6|97,1		c
						STATEMENT 1 ON LINE 452
		     if c = md.nl | c = md.cr | c = md.bs then do;

001765  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
001766  aa  5 00025 2351 00	lda  	pr5|21		md.nl
001767  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001770  aa  6 00141 1151 00	cmpa 	pr6|97		c
001771  aa   000011 6000 04	tze  	9,ic		002002
001772  aa  5 00032 2351 00	lda  	pr5|26		md.cr
001773  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
001774  aa  6 00141 1151 00	cmpa 	pr6|97		c
001775  aa   000005 6000 04	tze  	5,ic		002002
001776  aa  5 00031 2351 00	lda  	pr5|25		md.bs
001777  aa   000033 7350 00	als  	27
002000  aa  6 00141 1151 00	cmpa 	pr6|97		c
002001  aa   000046 6010 04	tnz  	38,ic		002047
						STATEMENT 1 ON LINE 453
			call check_buffer_tally (i);

002002  aa   005132 3520 04	epp2 	2650,ic		007134 = 000002000000
002003  aa   005011 6700 04	tsp4 	2569,ic		007014
						STATEMENT 1 ON LINE 454
			buffer.tally = buffer.tally + i;

002004  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
002005  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002006  aa  6 00121 0761 00	adq  	pr6|81		i
002007  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.tally
002010  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 455
			textl = textl + i;

002011  aa  6 00121 2361 00	ldq  	pr6|81		i
002012  aa  6 00120 0561 00	asq  	pr6|80		textl
						STATEMENT 1 ON LINE 456
			substr (text, textl - i + 1, i) = low (i);

002013  aa  6 00120 2361 00	ldq  	pr6|80		textl
002014  aa  6 00121 1761 00	sbq  	pr6|81		i
002015  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
002016  aa  6 00121 7271 00	lxl7 	pr6|81		i
002017  aa  000 146 100 400	mlr  	(),(pr,rl,ql),fill(000)
002020  aa   000000 00 0000	desc9a	0,0
002021  aa  7 00000 00 0017	desc9a	pr7|0,x7		text
						STATEMENT 1 ON LINE 457
			blockp = rest_chain_ptr;

002022  aa  6 00134 3715 20	epp5 	pr6|92,*		rest_chain_ptr
002023  aa  6 00160 6515 00	spri5	pr6|112		blockp
						STATEMENT 1 ON LINE 458
			if buffer.tally > i then do;

002024  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
002025  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002026  aa  6 00121 1161 00	cmpq 	pr6|81		i
002027  aa   000034 6044 04	tmoz 	28,ic		002063
						STATEMENT 1 ON LINE 459
			     textp = addr (buffer.chars);

002030  aa  6 00160 3535 20	epp3 	pr6|112,*		blockp
002031  aa  3 00001 3535 00	epp3 	pr3|1		buffer.chars
002032  aa  6 00116 2535 00	spri3	pr6|78		textp
						STATEMENT 1 ON LINE 460
			     textl = buffer.tally;

002033  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 461
			     text = substr (text, i + 1);

002034  aa  6 00463 7561 00	stq  	pr6|307		buffer.tally
002035  aa  6 00121 1761 00	sbq  	pr6|81		i
002036  aa  6 00120 7261 00	lxl6 	pr6|80		textl
002037  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
002040  aa  3 00000 00 0006	desc9a	pr3|0,ql		text
002041  aa  3 00000 00 0016	desc9a	pr3|0,x6		text
						STATEMENT 1 ON LINE 462
			     buffer.tally = buffer.tally - i;

002042  aa  6 00463 2361 00	ldq  	pr6|307		buffer.tally
002043  aa  6 00121 1761 00	sbq  	pr6|81		i
002044  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.tally
002045  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 463
			end;

						STATEMENT 1 ON LINE 464
			go to chain_split;

002046  aa   000015 7100 04	tra  	13,ic		002063
						STATEMENT 1 ON LINE 465
		     end;

						STATEMENT 1 ON LINE 466
		end;

002047  aa   000001 3360 07	lcq  	1,dl
002050  aa  6 00121 0561 00	asq  	pr6|81		i
002051  aa   777675 7100 04	tra  	-67,ic		001746
						STATEMENT 1 ON LINE 467
		go to chain_split;

002052  aa   000011 7100 04	tra  	9,ic		002063
						STATEMENT 1 ON LINE 468
	     end;

						STATEMENT 1 ON LINE 469
	     end_chain_ptr = blockp;

002053  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
002054  aa  6 00136 6535 00	spri7	pr6|94		end_chain_ptr
						STATEMENT 1 ON LINE 470
	end;

002055  aa  7 00000 2351 00	lda  	pr7|0		buffer.next
002056  aa   000066 7730 00	lrl  	54
002057  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
002060  aa   000000 3120 06	eawp2	0,ql
002061  aa  6 00160 2521 00	spri2	pr6|112		blockp
002062  aa   777630 7100 04	tra  	-104,ic		001712
						STATEMENT 1 ON LINE 471
chain_split:
	if end_chain_ptr = null () then end_chain_ptr = chain_ptr;

002063  aa  6 00136 2371 00	ldaq 	pr6|94		end_chain_ptr
002064  aa   776100 6770 04	eraq 	-960,ic		000164 = 077777000043 000001000000
002065  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002066  aa   000003 6010 04	tnz  	3,ic		002071
002067  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
002070  aa  6 00136 6535 00	spri7	pr6|94		end_chain_ptr
						STATEMENT 1 ON LINE 477
	blockp = chain_ptr;

002071  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
002072  aa  6 00160 6535 00	spri7	pr6|112		blockp
						STATEMENT 1 ON LINE 478
	textp = addr (buffer.chars);

002073  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
002074  aa  5 00001 3715 00	epp5 	pr5|1		buffer.chars
002075  aa  6 00116 6515 00	spri5	pr6|78		textp
						STATEMENT 1 ON LINE 479
	textl = buffer.tally;

002076  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
002077  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002100  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 480
	if mde.printer then mde.erase_req = "1"b;

002101  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
002102  aa  3 00012 2351 00	lda  	pr3|10		mde.printer
002103  aa   100000 3150 03	cana 	32768,du
002104  aa   000003 6000 04	tze  	3,ic		002107
002105  aa   010000 2350 03	lda  	4096,du
002106  aa  3 00012 2551 00	orsa 	pr3|10		mde.erase_req
						STATEMENT 1 ON LINE 481
	if mde.erase_req then mde.position = 0;

002107  aa  3 00012 2351 00	lda  	pr3|10		mde.erase_req
002110  aa   010000 3150 03	cana 	4096,du
002111  aa   000002 6000 04	tze  	2,ic		002113
002112  aa  3 00005 4501 00	stz  	pr3|5		mde.position
						STATEMENT 1 ON LINE 482
	position = mde.position;

002113  aa  3 00005 2361 00	ldq  	pr3|5		mde.position
002114  aa  6 00122 7561 00	stq  	pr6|82		position
						STATEMENT 1 ON LINE 484
	if ^mde.printer then do while (textp ^= null ());

002115  aa  3 00012 2351 00	lda  	pr3|10		mde.printer
002116  aa   100000 3150 03	cana 	32768,du
002117  aa   000232 6010 04	tnz  	154,ic		002351
002120  aa  6 00116 2371 00	ldaq 	pr6|78		textp
002121  aa   776043 6770 04	eraq 	-989,ic		000164 = 077777000043 000001000000
002122  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002123  aa   000226 6000 04	tze  	150,ic		002351
						STATEMENT 1 ON LINE 485
	     i = 0;

002124  aa  6 00121 4501 00	stz  	pr6|81		i
						STATEMENT 1 ON LINE 486
	     call find_next (i, md.nl);

002125  aa  6 00121 3521 00	epp2 	pr6|81		i
002126  aa  6 00470 2521 00	spri2	pr6|312
002127  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002130  aa  7 00025 3521 00	epp2 	pr7|21		md.nl
002131  aa  6 00472 2521 00	spri2	pr6|314
002132  aa  6 00466 3521 00	epp2 	pr6|310
002133  aa   010000 4310 07	fld  	4096,dl
002134  aa  2 00000 7571 00	staq 	pr2|0
002135  aa   002110 6700 04	tsp4 	1096,ic		004245
						STATEMENT 1 ON LINE 487
	     call find_next (i, md.cr);

002136  aa  6 00121 3521 00	epp2 	pr6|81		i
002137  aa  6 00470 2521 00	spri2	pr6|312
002140  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002141  aa  7 00032 3521 00	epp2 	pr7|26		md.cr
002142  aa  6 00472 2521 00	spri2	pr6|314
002143  aa  6 00466 3521 00	epp2 	pr6|310
002144  aa   010000 4310 07	fld  	4096,dl
002145  aa  2 00000 7571 00	staq 	pr2|0
002146  aa   002077 6700 04	tsp4 	1087,ic		004245
						STATEMENT 1 ON LINE 488
	     call find_next (i, md.bs);

002147  aa  6 00121 3521 00	epp2 	pr6|81		i
002150  aa  6 00470 2521 00	spri2	pr6|312
002151  aa   000003 7270 07	lxl7 	3,dl
002152  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002153  aa  7 00031 3521 00	epp2 	pr7|25		md.bs
002154  aa  2 00000 5005 17	a9bd 	pr2|0,7
002155  aa  6 00472 2521 00	spri2	pr6|314
002156  aa  6 00466 3521 00	epp2 	pr6|310
002157  aa   010000 4310 07	fld  	4096,dl
002160  aa  2 00000 7571 00	staq 	pr2|0
002161  aa   002064 6700 04	tsp4 	1076,ic		004245
						STATEMENT 1 ON LINE 489
	     if i = 0 then do;

002162  aa  6 00121 2361 00	ldq  	pr6|81		i
002163  aa   000012 6010 04	tnz  	10,ic		002175
						STATEMENT 1 ON LINE 490
		position = mod (position + textl, mde.screen_size);

002164  aa  6 00122 2361 00	ldq  	pr6|82		position
002165  aa  6 00120 0761 00	adq  	pr6|80		textl
002166  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
002167  aa  7 00003 3521 00	epp2 	pr7|3		mde.screen_size
002170  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
002171  aa  6 00122 7561 00	stq  	pr6|82		position
						STATEMENT 1 ON LINE 491
		call adv_text (textl);

002172  aa   004736 3520 04	epp2 	2526,ic		007130 = 000002000000
002173  aa   002016 6700 04	tsp4 	1038,ic		004211
						STATEMENT 1 ON LINE 492
	     end;

002174  aa   777724 7100 04	tra  	-44,ic		002120
						STATEMENT 1 ON LINE 493
	     else do;

						STATEMENT 1 ON LINE 494
		column = mod (position, mde.line_size);

002175  aa  6 00122 2361 00	ldq  	pr6|82		position
002176  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
002177  aa  7 00004 3521 00	epp2 	pr7|4		mde.line_size
002200  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
002201  aa  6 00140 7561 00	stq  	pr6|96		column
						STATEMENT 1 ON LINE 495
		position = position - column;

002202  aa  6 00140 3361 00	lcq  	pr6|96		column
002203  aa  6 00122 0561 00	asq  	pr6|82		position
						STATEMENT 1 ON LINE 496
		if i > 1 then do;

002204  aa  6 00121 2361 00	ldq  	pr6|81		i
002205  aa   000001 1160 07	cmpq 	1,dl
002206  aa   000011 6044 04	tmoz 	9,ic		002217
						STATEMENT 1 ON LINE 497
		     column = column + i - 1;

002207  aa  6 00140 0761 00	adq  	pr6|96		column
002210  aa   000001 1760 07	sbq  	1,dl
002211  aa  6 00140 7561 00	stq  	pr6|96		column
						STATEMENT 1 ON LINE 498
		     call adv_text (i - 1);

002212  aa  6 00121 2361 00	ldq  	pr6|81		i
002213  aa   000001 1760 07	sbq  	1,dl
002214  aa  6 00463 7561 00	stq  	pr6|307
002215  aa   004707 3520 04	epp2 	2503,ic		007124 = 000002000000
002216  aa   001773 6700 04	tsp4 	1019,ic		004211
						STATEMENT 1 ON LINE 499
		end;

						STATEMENT 1 ON LINE 500
		c = substr (text, 1, 1);

002217  aa  6 00141 4501 00	stz  	pr6|97		c
002220  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
002221  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002222  aa  7 00000 00 0001	desc9a	pr7|0,1		text
002223  aa  6 00141 00 0001	desc9a	pr6|97,1		c
						STATEMENT 1 ON LINE 501
		substr (text, 1, 1) = md.sba;

002224  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
002225  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002226  aa  5 00025 20 0001	desc9a	pr5|21(1),1	md.sba
002227  aa  7 00000 00 0001	desc9a	pr7|0,1		text
						STATEMENT 1 ON LINE 502
		call adv_text (1);

002230  aa   000001 2360 07	ldq  	1,dl
002231  aa  6 00463 7561 00	stq  	pr6|307
002232  aa   004672 3520 04	epp2 	2490,ic		007124 = 000002000000
002233  aa   001756 6700 04	tsp4 	1006,ic		004211
						STATEMENT 1 ON LINE 503
		if textp = null () then go to write_format_error;

002234  aa  6 00116 2371 00	ldaq 	pr6|78		textp
002235  aa   775727 6770 04	eraq 	-1065,ic		000164 = 077777000043 000001000000
002236  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002237  aa   000215 6000 04	tze  	141,ic		002454
						STATEMENT 1 ON LINE 504
		if substr (text, 1, 1) ^= low (1) then go to write_format_error;

002240  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
002241  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002242  aa  7 00000 00 0001	desc9a	pr7|0,1		text
002243  aa   775700 00 0001	desc9a	-1088,1		000141 = 000000000000
002244  aa   000210 6010 04	tnz  	136,ic		002454
						STATEMENT 1 ON LINE 505
		if c = md.nl then do;

002245  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
002246  aa  5 00025 2351 00	lda  	pr5|21		md.nl
002247  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
002250  aa  6 00141 1151 00	cmpa 	pr6|97		c
002251  aa   000017 6010 04	tnz  	15,ic		002270
						STATEMENT 1 ON LINE 506
		     if (column = 0) | (mod (column, mde.line_size) ^= 0) then
			column = column - mod (column, mde.line_size) + mde.line_size;

002252  aa  6 00140 2361 00	ldq  	pr6|96		column
002253  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
002254  aa  3 00004 3521 00	epp2 	pr3|4		mde.line_size
002255  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
002256  aa  6 00463 7561 00	stq  	pr6|307
002257  aa  6 00140 2361 00	ldq  	pr6|96		column
002260  aa   000003 6000 04	tze  	3,ic		002263
002261  aa  6 00463 2361 00	ldq  	pr6|307
002262  aa   000026 6000 04	tze  	22,ic		002310
002263  aa  6 00140 2361 00	ldq  	pr6|96		column
002264  aa  6 00463 1761 00	sbq  	pr6|307
002265  aa  2 00000 0761 00	adq  	pr2|0		mde.line_size
002266  aa  6 00140 7561 00	stq  	pr6|96		column
						STATEMENT 1 ON LINE 508
		end;

002267  aa   000021 7100 04	tra  	17,ic		002310
						STATEMENT 1 ON LINE 509
		else if c = md.cr then column = 0;

002270  aa  5 00032 2351 00	lda  	pr5|26		md.cr
002271  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
002272  aa  6 00141 1151 00	cmpa 	pr6|97		c
002273  aa   000003 6010 04	tnz  	3,ic		002276
002274  aa  6 00140 4501 00	stz  	pr6|96		column
002275  aa   000013 7100 04	tra  	11,ic		002310
						STATEMENT 1 ON LINE 510
		else if c = md.bs then column = max (column - 1, 0);

002276  aa  5 00031 2351 00	lda  	pr5|25		md.bs
002277  aa   000033 7350 00	als  	27
002300  aa  6 00141 1151 00	cmpa 	pr6|97		c
002301  aa   000007 6010 04	tnz  	7,ic		002310
002302  aa  6 00140 2361 00	ldq  	pr6|96		column
002303  aa   000001 1760 07	sbq  	1,dl
002304  aa   000000 1160 07	cmpq 	0,dl
002305  aa   000002 6050 04	tpl  	2,ic		002307
002306  aa   000000 2360 07	ldq  	0,dl
002307  aa  6 00140 7561 00	stq  	pr6|96		column
						STATEMENT 1 ON LINE 511
		position = mod (position + column, mde.screen_size);

002310  aa  6 00122 2361 00	ldq  	pr6|82		position
002311  aa  6 00140 0761 00	adq  	pr6|96		column
002312  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
002313  aa  3 00003 3521 00	epp2 	pr3|3		mde.screen_size
002314  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
002315  aa  6 00122 7561 00	stq  	pr6|82		position
						STATEMENT 1 ON LINE 512
		call get_position_chars (position);

002316  aa   004602 3520 04	epp2 	2434,ic		007120 = 000002000000
002317  aa   001771 6700 04	tsp4 	1017,ic		004310
						STATEMENT 1 ON LINE 513
		substr (text, 1, 1) = pos_char1;

002320  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
002321  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002322  aa  6 00123 00 0001	desc9a	pr6|83,1		pos_char1
002323  aa  7 00000 00 0001	desc9a	pr7|0,1		text
						STATEMENT 1 ON LINE 514
		call adv_text (1);

002324  aa   000001 2360 07	ldq  	1,dl
002325  aa  6 00463 7561 00	stq  	pr6|307
002326  aa   004576 3520 04	epp2 	2430,ic		007124 = 000002000000
002327  aa   001662 6700 04	tsp4 	946,ic		004211
						STATEMENT 1 ON LINE 515
		if textp = null then go to write_format_error;

002330  aa  6 00116 2371 00	ldaq 	pr6|78		textp
002331  aa   775633 6770 04	eraq 	-1125,ic		000164 = 077777000043 000001000000
002332  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002333  aa   000121 6000 04	tze  	81,ic		002454
						STATEMENT 1 ON LINE 516
		if substr (text, 1, 1) ^= low (1) then go to write_format_error;

002334  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
002335  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
002336  aa  7 00000 00 0001	desc9a	pr7|0,1		text
002337  aa   775604 00 0001	desc9a	-1148,1		000141 = 000000000000
002340  aa   000114 6010 04	tnz  	76,ic		002454
						STATEMENT 1 ON LINE 517
		substr (text, 1, 1) = pos_char2;

002341  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
002342  aa  6 00124 00 0001	desc9a	pr6|84,1		pos_char2
002343  aa  7 00000 00 0001	desc9a	pr7|0,1		text
						STATEMENT 1 ON LINE 518
		call adv_text (1);

002344  aa   000001 2360 07	ldq  	1,dl
002345  aa  6 00463 7561 00	stq  	pr6|307
002346  aa   004556 3520 04	epp2 	2414,ic		007124 = 000002000000
002347  aa   001642 6700 04	tsp4 	930,ic		004211
						STATEMENT 1 ON LINE 519
	     end;

						STATEMENT 1 ON LINE 520
	end;

002350  aa   777550 7100 04	tra  	-152,ic		002120
						STATEMENT 1 ON LINE 524
	blockp = header_blockp;

002351  aa  6 00130 3735 20	epp7 	pr6|88,*		header_blockp
002352  aa  6 00160 6535 00	spri7	pr6|112		blockp
						STATEMENT 1 ON LINE 525
	if ^mde.printer then mde.end_of_page = end_chain_ptr -> buffer.end_of_page;

002353  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
002354  aa  5 00012 2351 00	lda  	pr5|10		mde.printer
002355  aa   100000 3150 03	cana 	32768,du
002356  aa   000006 6010 04	tnz  	6,ic		002364
002357  aa  6 00136 2351 20	lda  	pr6|94,*		buffer.end_of_page
002360  aa   000012 7350 00	als  	10
002361  aa  5 00012 6751 00	era  	pr5|10		mde.end_of_page
002362  aa   001000 3750 03	ana  	512,du
002363  aa  5 00012 6551 00	ersa 	pr5|10		mde.end_of_page
						STATEMENT 1 ON LINE 526
	end_chain_ptr -> buffer.end_of_page = "0"b;

002364  aa   004532 2350 04	lda  	2394,ic		007116 = 777777377777
002365  aa  6 00136 3551 20	ansa 	pr6|94,*		buffer.end_of_page
						STATEMENT 1 ON LINE 527
	if mde.end_of_page then mde.keyboard_restore = "1"b;

002366  aa  5 00012 2351 00	lda  	pr5|10		mde.end_of_page
002367  aa   001000 3150 03	cana 	512,du
002370  aa   000003 6000 04	tze  	3,ic		002373
002371  aa   000400 2350 03	lda  	256,du
002372  aa  5 00012 2551 00	orsa 	pr5|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 528
	call build_header;

002373  aa   002364 6700 04	tsp4 	1268,ic		004757
						STATEMENT 1 ON LINE 529
	buffer.next = bin (rel (chain_ptr));

002374  aa  6 00114 6351 20	eaa  	pr6|76,*		chain_ptr
002375  aa   000066 7730 00	lrl  	54
002376  aa   000066 7370 00	lls  	54
002377  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.next
002400  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 533
	blockp = end_chain_ptr;

002401  aa  6 00136 3715 20	epp5 	pr6|94,*		end_chain_ptr
002402  aa  6 00160 6515 00	spri5	pr6|112		blockp
						STATEMENT 1 ON LINE 534
	call check_buffer_tally (2);

002403  aa   000002 2360 07	ldq  	2,dl
002404  aa  6 00463 7561 00	stq  	pr6|307
002405  aa   004517 3520 04	epp2 	2383,ic		007124 = 000002000000
002406  aa   004406 6700 04	tsp4 	2310,ic		007014
						STATEMENT 1 ON LINE 536
	textp = addr (buffer.chars);

002407  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
002410  aa  7 00001 3735 00	epp7 	pr7|1		buffer.chars
002411  aa  6 00116 6535 00	spri7	pr6|78		textp
						STATEMENT 1 ON LINE 537
	textl = buffer.tally;

002412  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
002413  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
002414  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 538
	textl = textl + 2;

002415  aa   000002 2360 07	ldq  	2,dl
002416  aa  6 00120 0561 00	asq  	pr6|80		textl
						STATEMENT 1 ON LINE 539
	if mde.printer then substr (text, textl - 1, 1) = md.em;

002417  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
002420  aa  5 00012 2351 00	lda  	pr5|10		mde.printer
002421  aa   100000 3150 03	cana 	32768,du
002422  aa   000007 6000 04	tze  	7,ic		002431
002423  aa  6 00120 7271 00	lxl7 	pr6|80		textl
002424  aa  6 00172 3535 20	epp3 	pr6|122,*		mdp
002425  aa  040 117 100 500	mlr  	(pr),(pr,x7),fill(040)
002426  aa  3 00032 20 0001	desc9a	pr3|26(1),1	md.em
002427  aa  7 77777 40 0001	desc9a	pr7|-1(2),1	text
002430  aa   000006 7100 04	tra  	6,ic		002436
						STATEMENT 1 ON LINE 540
	else substr (text, textl - 1, 1) = md.ic;

002431  aa  6 00120 7271 00	lxl7 	pr6|80		textl
002432  aa  6 00172 3535 20	epp3 	pr6|122,*		mdp
002433  aa  040 117 100 500	mlr  	(pr),(pr,x7),fill(040)
002434  aa  3 00026 40 0001	desc9a	pr3|22(2),1	md.ic
002435  aa  7 77777 40 0001	desc9a	pr7|-1(2),1	text
						STATEMENT 1 ON LINE 541
	substr (text, textl, 1) = md.etx;

002436  aa  040 117 100 500	mlr  	(pr),(pr,x7),fill(040)
002437  aa  3 00026 60 0001	desc9a	pr3|22(3),1	md.etx
002440  aa  7 77777 60 0001	desc9a	pr7|-1(3),1	text
						STATEMENT 1 ON LINE 542
	buffer.tally = textl;

002441  aa  6 00120 2361 00	ldq  	pr6|80		textl
002442  aa  6 00160 3515 20	epp1 	pr6|112,*		buffer.tally
002443  aa  1 00000 5521 04	stbq 	pr1|0,04		buffer.tally
						STATEMENT 1 ON LINE 546
	mde.position = position;

002444  aa  6 00122 2361 00	ldq  	pr6|82		position
002445  aa  5 00005 7561 00	stq  	pr5|5		mde.position
						STATEMENT 1 ON LINE 548
queue_write_data:
	call queue_write;

002446  aa   001751 6700 04	tsp4 	1001,ic		004417
						STATEMENT 1 ON LINE 551
	call process_write;

002447  aa   002057 6700 04	tsp4 	1071,ic		004526
						STATEMENT 1 ON LINE 553
	arg_chain_ptr = rest_chain_ptr;

002450  aa  6 00134 3735 20	epp7 	pr6|92,*		rest_chain_ptr
002451  aa  6 00032 3715 20	epp5 	pr6|26,*
002452  aa  5 00006 6535 20	spri7	pr5|6,*		arg_chain_ptr
						STATEMENT 1 ON LINE 554
	return;

002453  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 556
write_format_error:
	if header_blockp ^= null () then
	     call tty_space_man$free_buffer (mde.devx, OUTPUT, header_blockp);

002454  aa  6 00130 2371 00	ldaq 	pr6|88		header_blockp
002455  aa   775507 6770 04	eraq 	-1209,ic		000164 = 077777000043 000001000000
002456  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002457  aa   000014 6000 04	tze  	12,ic		002473
002460  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
002461  aa  6 00470 2521 00	spri2	pr6|312
002462  aa   775460 3520 04	epp2 	-1232,ic		000142 = 400000000000
002463  aa  6 00472 2521 00	spri2	pr6|314
002464  aa  6 00130 3521 00	epp2 	pr6|88		header_blockp
002465  aa  6 00474 2521 00	spri2	pr6|316
002466  aa  6 00466 6211 00	eax1 	pr6|310
002467  aa   014000 4310 07	fld  	6144,dl
002470  aa  6 00044 3701 20	epp4 	pr6|36,*
002471  la  4 00046 3521 20	epp2 	pr4|38,*		tty_space_man$free_buffer
002472  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 559
	call tty_space_man$free_chain (mde.devx, OUTPUT, chain_ptr);

002473  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
002474  aa  6 00470 2521 00	spri2	pr6|312
002475  aa   775445 3520 04	epp2 	-1243,ic		000142 = 400000000000
002476  aa  6 00472 2521 00	spri2	pr6|314
002477  aa  6 00114 3521 00	epp2 	pr6|76		chain_ptr
002500  aa  6 00474 2521 00	spri2	pr6|316
002501  aa  6 00466 6211 00	eax1 	pr6|310
002502  aa   014000 4310 07	fld  	6144,dl
002503  aa  6 00044 3701 20	epp4 	pr6|36,*
002504  la  4 00050 3521 20	epp2 	pr4|40,*		tty_space_man$free_chain
002505  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 560
	if rest_chain_ptr ^= null () then
	     call tty_space_man$free_chain (mde.devx, OUTPUT, rest_chain_ptr);

002506  aa  6 00134 2371 00	ldaq 	pr6|92		rest_chain_ptr
002507  aa   775455 6770 04	eraq 	-1235,ic		000164 = 077777000043 000001000000
002510  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002511  aa   000014 6000 04	tze  	12,ic		002525
002512  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
002513  aa  6 00470 2521 00	spri2	pr6|312
002514  aa   775426 3520 04	epp2 	-1258,ic		000142 = 400000000000
002515  aa  6 00472 2521 00	spri2	pr6|314
002516  aa  6 00134 3521 00	epp2 	pr6|92		rest_chain_ptr
002517  aa  6 00474 2521 00	spri2	pr6|316
002520  aa  6 00466 6211 00	eax1 	pr6|310
002521  aa   014000 4310 07	fld  	6144,dl
002522  aa  6 00044 3701 20	epp4 	pr6|36,*
002523  la  4 00050 3521 20	epp2 	pr4|40,*		tty_space_man$free_chain
002524  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 562
	md.write_format_error = md.write_format_error + 1;

002525  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002526  aa  7 00075 2351 00	lda  	pr7|61		md.write_format_error
002527  aa   000044 7330 00	lrs  	36
002530  aa   000001 0330 07	adl  	1,dl
002531  aa  7 00075 7561 00	stq  	pr7|61		md.write_format_error
						STATEMENT 1 ON LINE 563
	arg_code = 0;

002532  aa  6 00176 4501 20	stz  	pr6|126,*		arg_code
						STATEMENT 1 ON LINE 564
	arg_chain_ptr = null ();

002533  aa   775431 2370 04	ldaq 	-1255,ic		000164 = 077777000043 000001000000
002534  aa  6 00032 3715 20	epp5 	pr6|26,*
002535  aa  5 00006 7571 20	staq 	pr5|6,*		arg_chain_ptr
						STATEMENT 1 ON LINE 565
	return;

002536  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO interrupt                                          STATEMENT 1 ON LINE 569
interrupt: entry (arg_mdp, arg_int_type, arg_int_data);

002537  at     000003000160
002540  tt     000156000154
002541  ta     002537000000
002542  da     000241300000
002543  aa   001220 6270 00	eax7 	656
002544  aa  7 00034 3521 20	epp2 	pr7|28,*
002545  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
002546  aa     000006000000
002547  aa     000000000000
						STATEMENT 1 ON LINE 571
	mdp = arg_mdp;

002550  aa  6 00032 3735 20	epp7 	pr6|26,*
002551  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
002552  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
002553  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 572
	int_type = arg_int_type;

002554  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_int_type
002555  aa  6 00100 7561 00	stq  	pr6|64		int_type
						STATEMENT 1 ON LINE 573
	interrupt_info = arg_int_data;

002556  aa  7 00006 3535 20	epp3 	pr7|6,*
002557  aa  3 00000 2351 00	lda  	pr3|0		arg_int_data
002560  aa  3 00001 2361 00	ldq  	pr3|1		arg_int_data
002561  aa  6 00152 7571 00	staq 	pr6|106		interrupt_info
						STATEMENT 1 ON LINE 574
	ttybp = addr (tty_buf$);

002562  aa  6 00044 3701 20	epp4 	pr6|36,*
002563  la  4 00034 3515 20	epp1 	pr4|28,*		tty_buf$
002564  aa  6 00150 2515 00	spri1	pr6|104		ttybp
						STATEMENT 1 ON LINE 576
	if int_type < lbound (INTERRUPT, 1) | int_type > hbound (INTERRUPT, 1) then do;

002565  aa  6 00100 2361 00	ldq  	pr6|64		int_type
002566  aa   000001 1160 07	cmpq 	1,dl
002567  aa   000003 6040 04	tmi  	3,ic		002572
002570  aa   000021 1160 07	cmpq 	17,dl
002571  aa   000040 6044 04	tmoz 	32,ic		002631
						STATEMENT 1 ON LINE 577
	     call syserr (ANNOUNCE, "^a: Unrecognized interrupt for ^a. ^d ^.3b",
		name, md.name, int_type, interrupt_info);

002572  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
002573  aa   775512 00 0054	desc9a	-1206,44		000304 = 136141072040
002574  aa  6 00512 00 0054	desc9a	pr6|330,44
002575  aa   775344 3520 04	epp2 	-1308,ic		000141 = 000000000000
002576  aa  6 00530 2521 00	spri2	pr6|344
002577  aa  6 00512 3521 00	epp2 	pr6|330
002600  aa  6 00532 2521 00	spri2	pr6|346
002601  aa   775313 3520 04	epp2 	-1333,ic		000114 = 151142155063
002602  aa  6 00534 2521 00	spri2	pr6|348
002603  aa  5 00004 3521 00	epp2 	pr5|4		md.name
002604  aa  6 00536 2521 00	spri2	pr6|350
002605  aa  6 00100 3521 00	epp2 	pr6|64		int_type
002606  aa  6 00540 2521 00	spri2	pr6|352
002607  aa  6 00152 3521 00	epp2 	pr6|106		interrupt_info
002610  aa  6 00542 2521 00	spri2	pr6|354
002611  aa   775345 3520 04	epp2 	-1307,ic		000156 = 404000000021
002612  aa  6 00544 2521 00	spri2	pr6|356
002613  aa  6 00554 2521 00	spri2	pr6|364
002614  aa   775320 3520 04	epp2 	-1328,ic		000134 = 524000000052
002615  aa  6 00546 2521 00	spri2	pr6|358
002616  aa   775315 3520 04	epp2 	-1331,ic		000133 = 526000000013
002617  aa  6 00550 2521 00	spri2	pr6|360
002620  aa   775312 3520 04	epp2 	-1334,ic		000132 = 524000000040
002621  aa  6 00552 2521 00	spri2	pr6|362
002622  aa   775332 3520 04	epp2 	-1318,ic		000154 = 514000000110
002623  aa  6 00556 2521 00	spri2	pr6|366
002624  aa  6 00526 6211 00	eax1 	pr6|342
002625  aa   030000 4310 07	fld  	12288,dl
002626  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
002627  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 579
	     return;

002630  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 580
	end;

						STATEMENT 1 ON LINE 582
	go to INTERRUPT (int_type);

002631  ta   777777 7100 06	tra  	-1,ql
						STATEMENT 1 ON LINE 586
INTERRUPT (1):
	if ^md.loading then return;

002632  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002633  aa  7 00102 2351 00	lda  	pr7|66		md.loading
002634  aa   100000 3150 03	cana 	32768,du
002635  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 588
	md.loading = "0"b;

002636  aa   004307 2350 04	lda  	2247,ic		007145 = 677777777777
002637  aa  7 00102 3551 00	ansa 	pr7|66		md.loading
						STATEMENT 1 ON LINE 589
	md.loaded = "1"b;

002640  aa   040000 2350 03	lda  	16384,du
002641  aa  7 00102 2551 00	orsa 	pr7|66		md.loaded
						STATEMENT 1 ON LINE 590
	unspec (dialup_info) = interrupt_info;

002642  aa  6 00152 2371 00	ldaq 	pr6|106		interrupt_info
002643  aa  6 00154 7571 00	staq 	pr6|108
						STATEMENT 1 ON LINE 591
	md.line_type = dialup_info.line_type;

002644  aa  6 00154 2351 00	lda  	pr6|108		dialup_info.line_type
002645  aa   000077 7730 00	lrl  	63
002646  aa  7 00021 7561 00	stq  	pr7|17		md.line_type
						STATEMENT 1 ON LINE 592
	md.baud_rate = dialup_info.baud_rate;

002647  aa  6 00154 2361 00	ldq  	pr6|108		dialup_info.baud_rate
002650  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
002651  aa  7 00022 7561 00	stq  	pr7|18		md.baud_rate
						STATEMENT 1 ON LINE 593
	md.max_buf_size = dialup_info.max_buf_size;

002652  aa  6 00155 2351 00	lda  	pr6|109		dialup_info.max_buf_size
002653  aa   000077 7730 00	lrl  	63
002654  aa  7 00023 7561 00	stq  	pr7|19		md.max_buf_size
						STATEMENT 1 ON LINE 594
	md.buffer_pad = dialup_info.buffer_pad;

002655  aa  6 00154 2351 00	lda  	pr6|108		dialup_info.buffer_pad
002656  aa   000011 7350 00	als  	9
002657  aa   000077 7730 00	lrl  	63
002660  aa  7 00024 7561 00	stq  	pr7|20		md.buffer_pad
						STATEMENT 1 ON LINE 595
	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_UP, code);

002661  aa  7 00002 3521 00	epp2 	pr7|2		md.processid
002662  aa  6 00502 2521 00	spri2	pr6|322
002663  aa  7 00000 3521 00	epp2 	pr7|0		md.event_channel
002664  aa  6 00504 2521 00	spri2	pr6|324
002665  aa   775155 3520 04	epp2 	-1427,ic		000042 = 000000000000
002666  aa  6 00506 2521 00	spri2	pr6|326
002667  aa  6 00101 3521 00	epp2 	pr6|65		code
002670  aa  6 00510 2521 00	spri2	pr6|328
002671  aa  6 00500 6211 00	eax1 	pr6|320
002672  aa   020000 4310 07	fld  	8192,dl
002673  aa  6 00044 3701 20	epp4 	pr6|36,*
002674  la  4 00014 3521 20	epp2 	pr4|12,*		pxss$ring_0_wakeup
002675  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 596
	return;

002676  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 600
INTERRUPT (2):
	if ^md.loaded then return;

002677  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002700  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
002701  aa   040000 3150 03	cana 	16384,du
002702  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 602
	call crash_mpx;

002703  aa   003542 6700 04	tsp4 	1890,ic		006445
						STATEMENT 1 ON LINE 603
	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_DOWN, code);

002704  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002705  aa  7 00002 3521 00	epp2 	pr7|2		md.processid
002706  aa  6 00502 2521 00	spri2	pr6|322
002707  aa  7 00000 3521 00	epp2 	pr7|0		md.event_channel
002710  aa  6 00504 2521 00	spri2	pr6|324
002711  aa   775127 3520 04	epp2 	-1449,ic		000040 = 000000000000
002712  aa  6 00506 2521 00	spri2	pr6|326
002713  aa  6 00101 3521 00	epp2 	pr6|65		code
002714  aa  6 00510 2521 00	spri2	pr6|328
002715  aa  6 00500 6211 00	eax1 	pr6|320
002716  aa   020000 4310 07	fld  	8192,dl
002717  aa  6 00044 3701 20	epp4 	pr6|36,*
002720  la  4 00014 3521 20	epp2 	pr4|12,*		pxss$ring_0_wakeup
002721  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 604
	return;

002722  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 608
INTERRUPT (3):
	if ^md.loaded then return;

002723  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002724  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
002725  aa   040000 3150 03	cana 	16384,du
002726  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 610
	call crash_mpx;

002727  aa   003516 6700 04	tsp4 	1870,ic		006445
						STATEMENT 1 ON LINE 611
	return;

002730  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 615
INTERRUPT (4):
	if ^md.loaded then return;

002731  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002732  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
002733  aa   040000 3150 03	cana 	16384,du
002734  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 617
	md.send_output = "1"b;

002735  aa   000400 2350 03	lda  	256,du
002736  aa  7 00102 2551 00	orsa 	pr7|66		md.send_output
						STATEMENT 1 ON LINE 618
	if md.message_in_progress then do;

002737  aa  7 00102 2351 00	lda  	pr7|66		md.message_in_progress
002740  aa   002000 3150 03	cana 	1024,du
002741  aa   000003 6000 04	tze  	3,ic		002744
						STATEMENT 1 ON LINE 619
	     call send_more_message;

002742  aa   001654 6700 04	tsp4 	940,ic		004616
						STATEMENT 1 ON LINE 620
	     return;

002743  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 621
	end;

						STATEMENT 1 ON LINE 622
	if ^md.output_in_progress then call process_write;

002744  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
002745  aa   004000 3150 03	cana 	2048,du
002746  aa   000002 6010 04	tnz  	2,ic		002750
002747  aa   001557 6700 04	tsp4 	879,ic		004526
						STATEMENT 1 ON LINE 623
	return;

002750  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 627
INTERRUPT (5):
	return;

002751  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 632
INTERRUPT (6):
	if ^md.loaded then return;

002752  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
002753  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
002754  aa   040000 3150 03	cana 	16384,du
002755  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 634
	md.poll_in_progress = "0"b;

002756  aa   004137 2350 04	lda  	2143,ic		007115 = 767777777777
002757  aa  7 00102 3551 00	ansa 	pr7|66		md.poll_in_progress
						STATEMENT 1 ON LINE 635
	unspec (rtx_info) = interrupt_info;

002760  aa  6 00152 2371 00	ldaq 	pr6|106		interrupt_info
002761  aa  6 00156 7571 00	staq 	pr6|110
						STATEMENT 1 ON LINE 636
	chain_ptr = ptr (ttybp, rtx_info.chain_head);

002762  aa  6 00156 2351 00	lda  	pr6|110		rtx_info.chain_head
002763  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
002764  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
002765  aa   000000 3120 01	eawp2	0,au
002766  aa  6 00114 2521 00	spri2	pr6|76		chain_ptr
						STATEMENT 1 ON LINE 637
	if ^md.loaded then go to discard_input;

002767  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
002770  aa   040000 3150 03	cana 	16384,du
002771  aa   000530 6000 04	tze  	344,ic		003521
						STATEMENT 1 ON LINE 639
	blockp = chain_ptr;

002772  aa  6 00160 2521 00	spri2	pr6|112		blockp
						STATEMENT 1 ON LINE 640
	textp = addr (buffer.chars);

002773  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
002774  aa  5 00001 3715 00	epp5 	pr5|1		buffer.chars
002775  aa  6 00116 6515 00	spri5	pr6|78		textp
						STATEMENT 1 ON LINE 641
	textl = buffer.tally;

002776  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
002777  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003000  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 643
	if substr (text, 1, 1) = md.eot then do;

003001  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
003002  aa  5 00000 00 0001	desc9a	pr5|0,1		text
003003  aa  6 00525 00 0004	desc9a	pr6|341,4		text
003004  aa  7 00027 2351 00	lda  	pr7|23		md.eot
003005  aa   000011 7350 00	als  	9
003006  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003007  aa  6 00525 1151 00	cmpa 	pr6|341		text
003010  aa   000020 6010 04	tnz  	16,ic		003030
						STATEMENT 1 ON LINE 645
	     call tty_space_man$free_chain (md.devx, INPUT, chain_ptr);

003011  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
003012  aa  6 00470 2521 00	spri2	pr6|312
003013  aa   775126 3520 04	epp2 	-1450,ic		000141 = 000000000000
003014  aa  6 00472 2521 00	spri2	pr6|314
003015  aa  6 00114 3521 00	epp2 	pr6|76		chain_ptr
003016  aa  6 00474 2521 00	spri2	pr6|316
003017  aa  6 00466 6211 00	eax1 	pr6|310
003020  aa   014000 4310 07	fld  	6144,dl
003021  aa  6 00044 3701 20	epp4 	pr6|36,*
003022  la  4 00050 3521 20	epp2 	pr4|40,*		tty_space_man$free_chain
003023  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 646
	     call process_input;

003024  aa   002036 6700 04	tsp4 	1054,ic		005062
						STATEMENT 1 ON LINE 647
	     call process_polls;

003025  aa   002742 6700 04	tsp4 	1506,ic		005767
						STATEMENT 1 ON LINE 648
	     call process_write;

003026  aa   001500 6700 04	tsp4 	832,ic		004526
						STATEMENT 1 ON LINE 649
	     return;

003027  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 650
	end;

						STATEMENT 1 ON LINE 652
	if substr (text, 1, 1) = md.soh then do;

003030  aa  7 00027 2351 00	lda  	pr7|23		md.soh
003031  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
003032  aa  6 00525 1151 00	cmpa 	pr6|341		text
003033  aa   000147 6010 04	tnz  	103,ic		003202
						STATEMENT 1 ON LINE 653
	     if textl < 5 then go to bad_input;

003034  aa  6 00120 2361 00	ldq  	pr6|80		textl
003035  aa   000005 1160 07	cmpq 	5,dl
003036  aa   000266 6040 04	tmi  	182,ic		003324
						STATEMENT 1 ON LINE 654
	     if status_msg.percent ^= md.percent then	/* Should start % */
		go to bad_input;

003037  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003040  aa  7 00027 40 0001	desc9a	pr7|23(2),1	md.percent
003041  aa  5 00000 20 0001	desc9a	pr5|0(1),1	status_msg.percent
003042  aa   000262 6010 04	tnz  	178,ic		003324
						STATEMENT 1 ON LINE 656
	     if status_msg.type = slash then go to discard_input;

003043  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003044  aa  7 00027 60 0001	desc9a	pr7|23(3),1	md.slash
003045  aa  5 00000 40 0001	desc9a	pr5|0(2),1	status_msg.type
003046  aa   000453 6000 04	tze  	299,ic		003521
						STATEMENT 1 ON LINE 657
	     if status_msg.type ^= md.letter_R then	/* R means status */
		go to bad_input;

003047  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003050  aa  7 00030 00 0001	desc9a	pr7|24,1		md.letter_R
003051  aa  5 00000 40 0001	desc9a	pr5|0(2),1	status_msg.type
003052  aa   000252 6010 04	tnz  	170,ic		003324
						STATEMENT 1 ON LINE 659
	     if textl < 9 then go to bad_input;

003053  aa   000011 1160 07	cmpq 	9,dl
003054  aa   000250 6040 04	tmi  	168,ic		003324
						STATEMENT 1 ON LINE 660
	     if status_msg.stx ^= md.stx then go to bad_input;

003055  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003056  aa  7 00025 40 0001	desc9a	pr7|21(2),1	md.stx
003057  aa  5 00000 60 0001	desc9a	pr5|0(3),1	status_msg.stx
003060  aa   000244 6010 04	tnz  	164,ic		003324
						STATEMENT 1 ON LINE 661
	     dev_addr = getbin (status_msg.device_address);

003061  aa   000001 7270 07	lxl7 	1,dl
003062  aa  5 00001 3521 00	epp2 	pr5|1		status_msg.device_address
003063  aa  2 00000 5005 17	a9bd 	pr2|0,7
003064  aa  6 00470 2521 00	spri2	pr6|312
003065  aa  6 00525 3521 00	epp2 	pr6|341
003066  aa  6 00472 2521 00	spri2	pr6|314
003067  aa  6 00466 3521 00	epp2 	pr6|310
003070  aa   010000 4310 07	fld  	4096,dl
003071  aa  2 00000 7571 00	staq 	pr2|0
003072  aa   001303 6700 04	tsp4 	707,ic		004375
003073  aa  6 00525 2361 00	ldq  	pr6|341
003074  aa  6 00125 7561 00	stq  	pr6|85		dev_addr
						STATEMENT 1 ON LINE 662
	     if dev_addr < lbound (md.chan_map, 1) | dev_addr > hbound (md.chan_map, 1) then go to bad_dev_addr;

003075  aa   000312 6040 04	tmi  	202,ic		003407
003076  aa   000037 1160 07	cmpq 	31,dl
003077  aa   000310 6054 04	tpnz 	200,ic		003407
						STATEMENT 1 ON LINE 663
	     subchan = md.chan_map (dev_addr);

003100  aa   000011 4020 07	mpy  	9,dl
003101  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003102  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
003103  aa  7 00036 00 0011	descb	pr7|30,9		md.chan_map
003104  aa  6 00056 00 0044	descb	pr6|46,36
003105  aa  6 00056 2351 00	lda  	pr6|46
003106  aa   000077 7330 00	lrs  	63
003107  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 664
	     if subchan <= 0 then go to bad_device;

003110  aa   000341 6044 04	tmoz 	225,ic		003451
						STATEMENT 1 ON LINE 665
	     mdep = addr (md.mde_entry (subchan));

003111  aa   000013 4020 07	mpy  	11,dl
003112  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
003113  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 666
	     if ^mde.dialed then go to discard_input;

003114  aa  5 00012 2351 00	lda  	pr5|10		mde.dialed
003115  aa   200000 3150 03	cana 	65536,du
003116  aa   000403 6000 04	tze  	259,ic		003521
						STATEMENT 1 ON LINE 667
	     if ^mde.printer then go to discard_input;

003117  aa  5 00012 2351 00	lda  	pr5|10		mde.printer
003120  aa   100000 3150 03	cana 	32768,du
003121  aa   000400 6000 04	tze  	256,ic		003521
						STATEMENT 1 ON LINE 668
	     if mde.waiting_for_ready then do;

003122  aa  5 00012 2351 00	lda  	pr5|10		mde.waiting_for_ready
003123  aa   020000 3150 03	cana 	8192,du
003124  aa   000375 6000 04	tze  	253,ic		003521
						STATEMENT 1 ON LINE 669
		substr (status, 1, 6) = getbit (status_msg.status1);

003125  aa   000002 7270 07	lxl7 	2,dl
003126  aa  6 00116 3535 20	epp3 	pr6|78,*		textp
003127  aa  3 00001 3521 00	epp2 	pr3|1		status_msg.status1
003130  aa  2 00000 5005 17	a9bd 	pr2|0,7
003131  aa  6 00470 2521 00	spri2	pr6|312
003132  aa  6 00126 3521 00	epp2 	pr6|86		status
003133  aa  6 00472 2521 00	spri2	pr6|314
003134  aa  6 00466 3521 00	epp2 	pr6|310
003135  aa   010000 4310 07	fld  	4096,dl
003136  aa  2 00000 7571 00	staq 	pr2|0
003137  aa   001250 6700 04	tsp4 	680,ic		004407
						STATEMENT 1 ON LINE 670
		substr (status, 7, 6) = getbit (status_msg.status2);

003140  aa   000003 7270 07	lxl7 	3,dl
003141  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
003142  aa  7 00001 3521 00	epp2 	pr7|1		status_msg.status2
003143  aa  2 00000 5005 17	a9bd 	pr2|0,7
003144  aa  6 00470 2521 00	spri2	pr6|312
003145  aa   000006 7260 07	lxl6 	6,dl
003146  aa  6 00126 3521 00	epp2 	pr6|86		status
003147  aa  2 00000 5035 16	abd  	pr2|0,6
003150  aa  6 00472 2521 00	spri2	pr6|314
003151  aa  6 00466 3521 00	epp2 	pr6|310
003152  aa   010000 4310 07	fld  	4096,dl
003153  aa  2 00000 7571 00	staq 	pr2|0
003154  aa   001233 6700 04	tsp4 	667,ic		004407
						STATEMENT 1 ON LINE 671
		if status = "0200"b3 then do;

003155  aa  6 00126 2351 00	lda  	pr6|86		status
003156  aa  0 00030 3771 00	anaq 	pr0|24		= 777700000000 000000000000
003157  aa   020000 1150 03	cmpa 	8192,du
003160  aa   000341 6010 04	tnz  	225,ic		003521
						STATEMENT 1 ON LINE 672
		     mde.waiting_for_ready = "0"b;

003161  aa   003733 2350 04	lda  	2011,ic		007114 = 757777777777
003162  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
003163  aa  7 00012 3551 00	ansa 	pr7|10		mde.waiting_for_ready
						STATEMENT 1 ON LINE 673
		     call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

003164  aa   775002 2370 04	ldaq 	-1534,ic		000166 = 000000000000 000000000000
003165  aa  6 00464 7571 00	staq 	pr6|308
003166  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
003167  aa  6 00470 2521 00	spri2	pr6|312
003170  aa   774761 3520 04	epp2 	-1551,ic		000151 = 000000000004
003171  aa  6 00472 2521 00	spri2	pr6|314
003172  aa  6 00464 3521 00	epp2 	pr6|308
003173  aa  6 00474 2521 00	spri2	pr6|316
003174  aa  6 00466 6211 00	eax1 	pr6|310
003175  aa   014000 4310 07	fld  	6144,dl
003176  aa  6 00044 3701 20	epp4 	pr6|36,*
003177  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
003200  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 674
		end;

						STATEMENT 1 ON LINE 675
	     end;

						STATEMENT 1 ON LINE 676
	     go to discard_input;

003201  aa   000320 7100 04	tra  	208,ic		003521
						STATEMENT 1 ON LINE 677
	end;

						STATEMENT 1 ON LINE 682
	if text_msg.stx ^= md.stx then go to bad_input;

003202  aa  040 100 106 500	cmpc 	(pr),(pr),fill(040)
003203  aa  7 00025 40 0001	desc9a	pr7|21(2),1	md.stx
003204  aa  5 00000 00 0001	desc9a	pr5|0,1		text_msg.stx
003205  aa   000117 6010 04	tnz  	79,ic		003324
						STATEMENT 1 ON LINE 683
	if textl < 2 then go to bad_input;

003206  aa  6 00120 2361 00	ldq  	pr6|80		textl
003207  aa   000002 1160 07	cmpq 	2,dl
003210  aa   000114 6040 04	tmi  	76,ic		003324
						STATEMENT 1 ON LINE 684
	if md.input_chain_ptr ^= null () then do;

003211  aa  7 00060 2371 00	ldaq 	pr7|48		md.input_chain_ptr
003212  aa   774752 6770 04	eraq 	-1558,ic		000164 = 077777000043 000001000000
003213  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003214  aa   000016 6000 04	tze  	14,ic		003232
						STATEMENT 1 ON LINE 685
	     call trim_chain_end (md.input_chain_ptr, 1);

003215  aa   000001 2360 07	ldq  	1,dl
003216  aa  6 00525 7561 00	stq  	pr6|341
003217  aa  7 00060 3521 00	epp2 	pr7|48		md.input_chain_ptr
003220  aa  6 00470 2521 00	spri2	pr6|312
003221  aa  6 00525 3521 00	epp2 	pr6|341
003222  aa  6 00472 2521 00	spri2	pr6|314
003223  aa  6 00466 3521 00	epp2 	pr6|310
003224  aa   010000 4310 07	fld  	4096,dl
003225  aa  2 00000 7571 00	staq 	pr2|0
003226  aa   002422 6700 04	tsp4 	1298,ic		005650
						STATEMENT 1 ON LINE 686
	     md.input_count = md.input_count - 1;

003227  aa   000001 3360 07	lcq  	1,dl
003230  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003231  aa  7 00062 0561 00	asq  	pr7|50		md.input_count
						STATEMENT 1 ON LINE 687
	end;

						STATEMENT 1 ON LINE 688
	if md.input_chain_ptr ^= null () then do;

003232  aa  7 00060 2371 00	ldaq 	pr7|48		md.input_chain_ptr
003233  aa   774731 6770 04	eraq 	-1575,ic		000164 = 077777000043 000001000000
003234  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
003235  aa   000035 6000 04	tze  	29,ic		003272
						STATEMENT 1 ON LINE 689
	     call trim_chain_start (chain_ptr, 1);

003236  aa   000001 2360 07	ldq  	1,dl
003237  aa  6 00525 7561 00	stq  	pr6|341
003240  aa   003646 3520 04	epp2 	1958,ic		007106 = 000004000000
003241  aa   002314 6700 04	tsp4 	1228,ic		005555
						STATEMENT 1 ON LINE 690
	     do blockp = md.input_chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);

003242  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003243  aa  7 00060 3735 20	epp7 	pr7|48,*		md.input_chain_ptr
003244  aa  6 00160 6535 00	spri7	pr6|112		blockp
003245  aa   000000 0110 03	nop  	0,du
003246  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
003247  aa   000066 7730 00	lrl  	54
003250  aa  6 00525 7561 00	stq  	pr6|341		buffer.next
003251  aa   000005 6000 04	tze  	5,ic		003256
						STATEMENT 1 ON LINE 691
	     end;

003252  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
003253  aa   000000 3120 06	eawp2	0,ql
003254  aa  6 00160 2521 00	spri2	pr6|112		blockp
003255  aa   777771 7100 04	tra  	-7,ic		003246
						STATEMENT 1 ON LINE 692
	     buffer.next = bin (rel (chain_ptr));

003256  aa  6 00114 6351 20	eaa  	pr6|76,*		chain_ptr
003257  aa   000066 7730 00	lrl  	54
003260  aa   000066 7370 00	lls  	54
003261  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.next
003262  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
						STATEMENT 1 ON LINE 693
	     md.input_count = md.input_count + rtx_info.input_count - 1;

003263  aa  6 00157 2351 00	lda  	pr6|111		rtx_info.input_count
003264  aa   000066 7730 00	lrl  	54
003265  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
003266  aa  5 00062 0761 00	adq  	pr5|50		md.input_count
003267  aa   000001 1760 07	sbq  	1,dl
003270  aa  5 00062 7561 00	stq  	pr5|50		md.input_count
						STATEMENT 1 ON LINE 694
	end;

003271  aa   000006 7100 04	tra  	6,ic		003277
						STATEMENT 1 ON LINE 695
	else do;

						STATEMENT 1 ON LINE 696
	     md.input_chain_ptr = chain_ptr;

003272  aa  6 00114 3715 20	epp5 	pr6|76,*		chain_ptr
003273  aa  7 00060 6515 00	spri5	pr7|48		md.input_chain_ptr
						STATEMENT 1 ON LINE 697
	     md.input_count = rtx_info.input_count;

003274  aa  6 00157 2351 00	lda  	pr6|111		rtx_info.input_count
003275  aa   000066 7730 00	lrl  	54
003276  aa  7 00062 7561 00	stq  	pr7|50		md.input_count
						STATEMENT 1 ON LINE 698
	end;

						STATEMENT 1 ON LINE 699
	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);

003277  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
003300  aa  6 00160 6535 00	spri7	pr6|112		blockp
003301  aa   000000 0110 03	nop  	0,du
003302  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
003303  aa   000066 7730 00	lrl  	54
003304  aa  6 00525 7561 00	stq  	pr6|341		buffer.next
003305  aa   000005 6000 04	tze  	5,ic		003312
						STATEMENT 1 ON LINE 700
	end;

003306  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
003307  aa   000000 3120 06	eawp2	0,ql
003310  aa  6 00160 2521 00	spri2	pr6|112		blockp
003311  aa   777771 7100 04	tra  	-7,ic		003302
						STATEMENT 1 ON LINE 701
	if buffer.chars (buffer.tally - 1) = md.etx then call process_input;

003312  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
003313  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
003314  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003315  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
003316  aa  040 106 106 500	cmpc 	(pr),(pr,ql),fill(040)
003317  aa  7 00026 60 0001	desc9a	pr7|22(3),1	md.etx
003320  aa  5 00000 60 0001	desc9a	pr5|0(3),1	buffer.chars
003321  aa   000002 6010 04	tnz  	2,ic		003323
003322  aa   001540 6700 04	tsp4 	864,ic		005062
						STATEMENT 1 ON LINE 702
	return;

003323  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 704
bad_input:
	textl = min (textl, 8);

003324  aa  6 00120 2361 00	ldq  	pr6|80		textl
003325  aa   000010 1160 07	cmpq 	8,dl
003326  aa   000002 6040 04	tmi  	2,ic		003330
003327  aa   000010 2360 07	ldq  	8,dl
003330  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 706
	if md.debug then
	     call syserr (ANNOUNCE, "^a: Unrecognized input for ^a:^( ^.3b^)", name, md.name, bit_text_array);

003331  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003332  aa  7 00102 2351 00	lda  	pr7|66		md.debug
003333  aa   200000 3150 03	cana 	65536,du
003334  aa   000045 6000 04	tze  	37,ic		003401
003335  aa   774572 2360 04	ldq  	-1670,ic		000127 = 516100000011
003336  aa  6 00466 7561 00	stq  	pr6|310
003337  aa   000001 2360 07	ldq  	1,dl
003340  aa  6 00467 7561 00	stq  	pr6|311
003341  aa  6 00120 2361 00	ldq  	pr6|80		textl
003342  aa  6 00470 7561 00	stq  	pr6|312
003343  aa   000011 2360 07	ldq  	9,dl
003344  aa  6 00471 7561 00	stq  	pr6|313
003345  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003346  aa   774712 00 0050	desc9a	-1590,40		000257 = 136141072040
003347  aa  6 00500 00 0050	desc9a	pr6|320,40
003350  aa   774571 3520 04	epp2 	-1671,ic		000141 = 000000000000
003351  aa  6 00530 2521 00	spri2	pr6|344
003352  aa  6 00500 3521 00	epp2 	pr6|320
003353  aa  6 00532 2521 00	spri2	pr6|346
003354  aa   774540 3520 04	epp2 	-1696,ic		000114 = 151142155063
003355  aa  6 00534 2521 00	spri2	pr6|348
003356  aa  7 00004 3521 00	epp2 	pr7|4		md.name
003357  aa  6 00536 2521 00	spri2	pr6|350
003360  aa  6 00116 3521 20	epp2 	pr6|78,*		bit_text_array
003361  aa  6 00540 2521 00	spri2	pr6|352
003362  aa   774574 3520 04	epp2 	-1668,ic		000156 = 404000000021
003363  aa  6 00542 2521 00	spri2	pr6|354
003364  aa   774544 3520 04	epp2 	-1692,ic		000130 = 524000000047
003365  aa  6 00544 2521 00	spri2	pr6|356
003366  aa   774545 3520 04	epp2 	-1691,ic		000133 = 526000000013
003367  aa  6 00546 2521 00	spri2	pr6|358
003370  aa   774542 3520 04	epp2 	-1694,ic		000132 = 524000000040
003371  aa  6 00550 2521 00	spri2	pr6|360
003372  aa  6 00466 3521 00	epp2 	pr6|310
003373  aa  6 00552 2521 00	spri2	pr6|362
003374  aa  6 00526 6211 00	eax1 	pr6|342
003375  aa   024000 4310 07	fld  	10240,dl
003376  aa  6 00044 3701 20	epp4 	pr6|36,*
003377  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
003400  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 708
	md.bad_input = md.bad_input + 1;

003401  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003402  aa  7 00076 2351 00	lda  	pr7|62		md.bad_input
003403  aa   000044 7330 00	lrs  	36
003404  aa   000001 0330 07	adl  	1,dl
003405  aa  7 00076 7561 00	stq  	pr7|62		md.bad_input
						STATEMENT 1 ON LINE 709
	go to discard_input;

003406  aa   000113 7100 04	tra  	75,ic		003521
						STATEMENT 1 ON LINE 711
bad_dev_addr:
						/* This is so bad we cannot even mask it off, because its not in the table */
	call syserr (ANNOUNCE, "^a: Input for illegal device address ^d on ^a", name, dev_addr, md.name);

003407  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003410  aa   774710 00 0060	desc9a	-1592,48		000317 = 136141072040
003411  aa  6 00526 00 0060	desc9a	pr6|342,48
003412  aa   774527 3520 04	epp2 	-1705,ic		000141 = 000000000000
003413  aa  6 00562 2521 00	spri2	pr6|370
003414  aa  6 00526 3521 00	epp2 	pr6|342
003415  aa  6 00564 2521 00	spri2	pr6|372
003416  aa   774476 3520 04	epp2 	-1730,ic		000114 = 151142155063
003417  aa  6 00566 2521 00	spri2	pr6|374
003420  aa  6 00125 3521 00	epp2 	pr6|85		dev_addr
003421  aa  6 00570 2521 00	spri2	pr6|376
003422  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003423  aa  7 00004 3521 00	epp2 	pr7|4		md.name
003424  aa  6 00572 2521 00	spri2	pr6|378
003425  aa   774531 3520 04	epp2 	-1703,ic		000156 = 404000000021
003426  aa  6 00574 2521 00	spri2	pr6|380
003427  aa  6 00602 2521 00	spri2	pr6|386
003430  aa   774476 3520 04	epp2 	-1730,ic		000126 = 524000000055
003431  aa  6 00576 2521 00	spri2	pr6|382
003432  aa   774501 3520 04	epp2 	-1727,ic		000133 = 526000000013
003433  aa  6 00600 2521 00	spri2	pr6|384
003434  aa   774476 3520 04	epp2 	-1730,ic		000132 = 524000000040
003435  aa  6 00604 2521 00	spri2	pr6|388
003436  aa  6 00560 6211 00	eax1 	pr6|368
003437  aa   024000 4310 07	fld  	10240,dl
003440  aa  6 00044 3701 20	epp4 	pr6|36,*
003441  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
003442  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 714
	md.bad_device = md.bad_device + 1;

003443  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003444  aa  7 00077 2351 00	lda  	pr7|63		md.bad_device
003445  aa   000044 7330 00	lrs  	36
003446  aa   000001 0330 07	adl  	1,dl
003447  aa  7 00077 7561 00	stq  	pr7|63		md.bad_device
						STATEMENT 1 ON LINE 715
	go to discard_input;

003450  aa   000051 7100 04	tra  	41,ic		003521
						STATEMENT 1 ON LINE 717
bad_device:
	if subchan < 0 then go to discard_input;

003451  aa  6 00127 2361 00	ldq  	pr6|87		subchan
003452  aa   000047 6040 04	tmi  	39,ic		003521
						STATEMENT 1 ON LINE 719
	call syserr (ANNOUNCE, "^a: Input for unconfigured device ^d on ^a", name, dev_addr, md.name);

003453  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
003454  aa   774616 00 0054	desc9a	-1650,44		000271 = 136141072040
003455  aa  6 00512 00 0054	desc9a	pr6|330,44
003456  aa   774463 3520 04	epp2 	-1741,ic		000141 = 000000000000
003457  aa  6 00562 2521 00	spri2	pr6|370
003460  aa  6 00512 3521 00	epp2 	pr6|330
003461  aa  6 00564 2521 00	spri2	pr6|372
003462  aa   774432 3520 04	epp2 	-1766,ic		000114 = 151142155063
003463  aa  6 00566 2521 00	spri2	pr6|374
003464  aa  6 00125 3521 00	epp2 	pr6|85		dev_addr
003465  aa  6 00570 2521 00	spri2	pr6|376
003466  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003467  aa  7 00004 3521 00	epp2 	pr7|4		md.name
003470  aa  6 00572 2521 00	spri2	pr6|378
003471  aa   774465 3520 04	epp2 	-1739,ic		000156 = 404000000021
003472  aa  6 00574 2521 00	spri2	pr6|380
003473  aa  6 00602 2521 00	spri2	pr6|386
003474  aa   774440 3520 04	epp2 	-1760,ic		000134 = 524000000052
003475  aa  6 00576 2521 00	spri2	pr6|382
003476  aa   774435 3520 04	epp2 	-1763,ic		000133 = 526000000013
003477  aa  6 00600 2521 00	spri2	pr6|384
003500  aa   774432 3520 04	epp2 	-1766,ic		000132 = 524000000040
003501  aa  6 00604 2521 00	spri2	pr6|388
003502  aa  6 00560 6211 00	eax1 	pr6|368
003503  aa   024000 4310 07	fld  	10240,dl
003504  aa  6 00044 3701 20	epp4 	pr6|36,*
003505  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
003506  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 720
	md.bad_device = md.bad_device + 1;

003507  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003510  aa  7 00077 2351 00	lda  	pr7|63		md.bad_device
003511  aa   000044 7330 00	lrs  	36
003512  aa   000001 0330 07	adl  	1,dl
003513  aa  7 00077 7561 00	stq  	pr7|63		md.bad_device
						STATEMENT 1 ON LINE 721
	md.chan_map (dev_addr) = -1;

003514  aa  6 00125 2361 00	ldq  	pr6|85		dev_addr
003515  aa   000011 4020 07	mpy  	9,dl
003516  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
003517  aa   003432 00 0011	descb	1818,9		007150 = 777000000000
003520  aa  7 00036 00 0011	descb	pr7|30,9		md.chan_map
						STATEMENT 1 ON LINE 723
discard_input:
	call tty_space_man$free_chain (md.devx, INPUT, chain_ptr);

003521  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003522  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
003523  aa  6 00470 2521 00	spri2	pr6|312
003524  aa   774415 3520 04	epp2 	-1779,ic		000141 = 000000000000
003525  aa  6 00472 2521 00	spri2	pr6|314
003526  aa  6 00114 3521 00	epp2 	pr6|76		chain_ptr
003527  aa  6 00474 2521 00	spri2	pr6|316
003530  aa  6 00466 6211 00	eax1 	pr6|310
003531  aa   014000 4310 07	fld  	6144,dl
003532  aa  6 00044 3701 20	epp4 	pr6|36,*
003533  la  4 00050 3521 20	epp2 	pr4|40,*		tty_space_man$free_chain
003534  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 725
	return;

003535  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 729
INTERRUPT (7):
	if ^md.loaded then return;

003536  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003537  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
003540  aa   040000 3150 03	cana 	16384,du
003541  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 731
	md.input_reject = md.input_reject + 1;

003542  aa  7 00072 2351 00	lda  	pr7|58		md.input_reject
003543  aa   000044 7330 00	lrs  	36
003544  aa   000001 0330 07	adl  	1,dl
003545  aa  7 00072 7561 00	stq  	pr7|58		md.input_reject
						STATEMENT 1 ON LINE 732
	return;

003546  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 736
INTERRUPT (8):
	return;

003547  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 741
INTERRUPT (10):
	return;

003550  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 746
INTERRUPT (11):
	return;

003551  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 751
INTERRUPT (12):
	if ^md.loaded then return;

003552  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003553  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
003554  aa   040000 3150 03	cana 	16384,du
003555  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 753
	md.space_available = md.space_available + 1;

003556  aa  7 00074 2351 00	lda  	pr7|60		md.space_available
003557  aa   000044 7330 00	lrs  	36
003560  aa   000001 0330 07	adl  	1,dl
003561  aa  7 00074 7561 00	stq  	pr7|60		md.space_available
						STATEMENT 1 ON LINE 754
	if md.message_in_progress then call send_more_message;

003562  aa  7 00102 2351 00	lda  	pr7|66		md.message_in_progress
003563  aa   002000 3150 03	cana 	1024,du
003564  aa   000003 6000 04	tze  	3,ic		003567
003565  aa   001031 6700 04	tsp4 	537,ic		004616
003566  aa   000002 7100 04	tra  	2,ic		003570
						STATEMENT 1 ON LINE 755
	else call process_write;

003567  aa   000737 6700 04	tsp4 	479,ic		004526
						STATEMENT 1 ON LINE 756
	return;

003570  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 759
INTERRUPT (13):
INTERRUPT (14):
INTERRUPT (15):
INTERRUPT (16):
	return;

003571  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 767
INTERRUPT (17):
	if ^md.loaded then return;

003572  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003573  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
003574  aa   040000 3150 03	cana 	16384,du
003575  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 769
	call crash_mpx;

003576  aa   002647 6700 04	tsp4 	1447,ic		006445
						STATEMENT 1 ON LINE 770
	call pxss$ring_0_wakeup (md.processid, md.event_channel, IBM3270_MPX_MASKED, code);

003577  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003600  aa  7 00002 3521 00	epp2 	pr7|2		md.processid
003601  aa  6 00502 2521 00	spri2	pr6|322
003602  aa  7 00000 3521 00	epp2 	pr7|0		md.event_channel
003603  aa  6 00504 2521 00	spri2	pr6|324
003604  aa   774232 3520 04	epp2 	-1894,ic		000036 = 000000000000
003605  aa  6 00506 2521 00	spri2	pr6|326
003606  aa  6 00101 3521 00	epp2 	pr6|65		code
003607  aa  6 00510 2521 00	spri2	pr6|328
003610  aa  6 00500 6211 00	eax1 	pr6|320
003611  aa   020000 4310 07	fld  	8192,dl
003612  aa  6 00044 3701 20	epp4 	pr6|36,*
003613  la  4 00014 3521 20	epp2 	pr4|12,*		pxss$ring_0_wakeup
003614  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 771
	return;

003615  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 776
INTERRUPT (9):
	if ^md.loaded then return;

003616  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003617  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
003620  aa   040000 3150 03	cana 	16384,du
003621  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 778
	unspec (line_stat) = interrupt_info;

003622  aa  6 00152 2371 00	ldaq 	pr6|106		interrupt_info
003623  aa  6 00170 7571 00	staq 	pr6|120
						STATEMENT 1 ON LINE 779
	if line_stat.op < lbound (LINE_STAT, 1) | line_stat.op > hbound (LINE_STAT, 1) then return;

003624  aa  6 00170 2351 00	lda  	pr6|120		line_stat.op
003625  aa   000066 7330 00	lrs  	54
003626  aa   000001 1160 07	cmpq 	1,dl
003627  aa  0 00631 6041 00	tmi  	pr0|409		return_mac
003630  aa   000014 1160 07	cmpq 	12,dl
003631  aa  0 00631 6055 00	tpnz 	pr0|409		return_mac
						STATEMENT 1 ON LINE 780
	go to LINE_STAT (line_stat.op);

003632  aa   000000 6270 06	eax7 	0,ql
003633  ta   000020 7100 17	tra  	16,7
						STATEMENT 1 ON LINE 782
LINE_STAT (1):					/* No response to poll */
	md.poll_failed = md.poll_failed + 1;

003634  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003635  aa  7 00063 2351 00	lda  	pr7|51		md.poll_failed
003636  aa   000044 7330 00	lrs  	36
003637  aa   000001 0330 07	adl  	1,dl
003640  aa  7 00063 7561 00	stq  	pr7|51		md.poll_failed
						STATEMENT 1 ON LINE 784
	md.poll_in_progress = "0"b;

003641  aa   003254 2350 04	lda  	1708,ic		007115 = 767777777777
003642  aa  7 00102 3551 00	ansa 	pr7|66		md.poll_in_progress
						STATEMENT 1 ON LINE 785
	call process_polls;

003643  aa   002124 6700 04	tsp4 	1108,ic		005767
						STATEMENT 1 ON LINE 786
	call process_write;

003644  aa   000662 6700 04	tsp4 	434,ic		004526
						STATEMENT 1 ON LINE 787
	return;

003645  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 789
LINE_STAT (2):					/* Badly formated output block */
	md.bad_output = md.bad_output + 1;

003646  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003647  aa  7 00064 2351 00	lda  	pr7|52		md.bad_output
003650  aa   000044 7330 00	lrs  	36
003651  aa   000001 0330 07	adl  	1,dl
003652  aa  7 00064 7561 00	stq  	pr7|52		md.bad_output
						STATEMENT 1 ON LINE 791
	go to line_stat_output_complete;

003653  aa   000016 7100 04	tra  	14,ic		003671
						STATEMENT 1 ON LINE 793
LINE_STAT (3):					/* Rvi - device has status */
	if md.output_in_progress then do;

003654  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003655  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
003656  aa   004000 3150 03	cana 	2048,du
003657  aa   000012 6000 04	tze  	10,ic		003671
						STATEMENT 1 ON LINE 795
	     subchan = md.cur_write_chan;

003660  aa  7 00054 2361 00	ldq  	pr7|44		md.cur_write_chan
003661  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 796
	     mdep = addr (md.mde_entry (subchan));

003662  aa   000013 4020 07	mpy  	11,dl
003663  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
003664  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 797
	     call queue_poll;

003665  aa   002060 6700 04	tsp4 	1072,ic		005745
						STATEMENT 1 ON LINE 798
	end;

						STATEMENT 1 ON LINE 799
	go to line_stat_output_complete;

003666  aa   000003 7100 04	tra  	3,ic		003671
						STATEMENT 1 ON LINE 801
LINE_STAT (4):					/* Too many naks */
	return;

003667  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 804
LINE_STAT (5):					/* Write status - can't happen */
	return;

003670  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 807
LINE_STAT (6):					/* 3270 write complete */
line_stat_output_complete:
	if md.output_in_progress then do;

003671  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003672  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
003673  aa   004000 3150 03	cana 	2048,du
003674  aa   000031 6000 04	tze  	25,ic		003725
						STATEMENT 1 ON LINE 810
	     md.output_in_progress, md.message_in_progress = "0"b;

003675  aa   003210 2350 04	lda  	1672,ic		007105 = 773777777777
003676  aa  7 00102 3551 00	ansa 	pr7|66		md.output_in_progress
003677  aa   003205 2350 04	lda  	1669,ic		007104 = 775777777777
003700  aa  7 00102 3551 00	ansa 	pr7|66		md.message_in_progress
						STATEMENT 1 ON LINE 811
	     mdep = addr (md.mde_entry (md.cur_write_chan));

003701  aa  7 00054 2361 00	ldq  	pr7|44		md.cur_write_chan
003702  aa   000013 4020 07	mpy  	11,dl
003703  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
003704  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 812
	     if ^mde.end_of_page then
		call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

003705  aa  5 00012 2351 00	lda  	pr5|10		mde.end_of_page
003706  aa   001000 3150 03	cana 	512,du
003707  aa   000016 6010 04	tnz  	14,ic		003725
003710  aa   774256 2370 04	ldaq 	-1874,ic		000166 = 000000000000 000000000000
003711  aa  6 00464 7571 00	staq 	pr6|308
003712  aa  5 00000 3521 00	epp2 	pr5|0		mde.devx
003713  aa  6 00470 2521 00	spri2	pr6|312
003714  aa   774235 3520 04	epp2 	-1891,ic		000151 = 000000000004
003715  aa  6 00472 2521 00	spri2	pr6|314
003716  aa  6 00464 3521 00	epp2 	pr6|308
003717  aa  6 00474 2521 00	spri2	pr6|316
003720  aa  6 00466 6211 00	eax1 	pr6|310
003721  aa   014000 4310 07	fld  	6144,dl
003722  aa  6 00044 3701 20	epp4 	pr6|36,*
003723  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
003724  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 814
	end;

						STATEMENT 1 ON LINE 815
line_stat_continue:
	call process_polls;

003725  aa   002042 6700 04	tsp4 	1058,ic		005767
						STATEMENT 1 ON LINE 817
	call process_write;

003726  aa   000600 6700 04	tsp4 	384,ic		004526
						STATEMENT 1 ON LINE 818
	return;

003727  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 820
LINE_STAT (7):					/* 3270 wack msg - printer going busy */
	if ^md.output_in_progress then go to line_stat_continue;

003730  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003731  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
003732  aa   004000 3150 03	cana 	2048,du
003733  aa   777772 6000 04	tze  	-6,ic		003725
						STATEMENT 1 ON LINE 822
	md.output_in_progress, md.message_in_progress = "0"b;

003734  aa   003151 2350 04	lda  	1641,ic		007105 = 773777777777
003735  aa  7 00102 3551 00	ansa 	pr7|66		md.output_in_progress
003736  aa   003146 2350 04	lda  	1638,ic		007104 = 775777777777
003737  aa  7 00102 3551 00	ansa 	pr7|66		md.message_in_progress
						STATEMENT 1 ON LINE 823
	mdep = addr (md.mde_entry (md.cur_write_chan));

003740  aa  7 00054 2361 00	ldq  	pr7|44		md.cur_write_chan
003741  aa   000013 4020 07	mpy  	11,dl
003742  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
003743  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 824
	if mde.printer then mde.waiting_for_ready = "1"b;

003744  aa  5 00012 2351 00	lda  	pr5|10		mde.printer
003745  aa   100000 3150 03	cana 	32768,du
003746  aa   000004 6000 04	tze  	4,ic		003752
003747  aa   020000 2350 03	lda  	8192,du
003750  aa  5 00012 2551 00	orsa 	pr5|10		mde.waiting_for_ready
003751  aa   777754 7100 04	tra  	-20,ic		003725
						STATEMENT 1 ON LINE 825
	else call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

003752  aa   774214 2370 04	ldaq 	-1908,ic		000166 = 000000000000 000000000000
003753  aa  6 00464 7571 00	staq 	pr6|308
003754  aa  5 00000 3521 00	epp2 	pr5|0		mde.devx
003755  aa  6 00470 2521 00	spri2	pr6|312
003756  aa   774173 3520 04	epp2 	-1925,ic		000151 = 000000000004
003757  aa  6 00472 2521 00	spri2	pr6|314
003760  aa  6 00464 3521 00	epp2 	pr6|308
003761  aa  6 00474 2521 00	spri2	pr6|316
003762  aa  6 00466 6211 00	eax1 	pr6|310
003763  aa   014000 4310 07	fld  	6144,dl
003764  aa  6 00044 3701 20	epp4 	pr6|36,*
003765  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
003766  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 826
	go to line_stat_continue;

003767  aa   777736 7100 04	tra  	-34,ic		003725
						STATEMENT 1 ON LINE 828
LINE_STAT (8):					/* Ibm3270 write eot */
	md.write_eot = md.write_eot + 1;

003770  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003771  aa  7 00065 2351 00	lda  	pr7|53		md.write_eot
003772  aa   000044 7330 00	lrs  	36
003773  aa   000001 0330 07	adl  	1,dl
003774  aa  7 00065 7561 00	stq  	pr7|53		md.write_eot
						STATEMENT 1 ON LINE 830
	go to line_stat_output_complete;

003775  aa   777674 7100 04	tra  	-68,ic		003671
						STATEMENT 1 ON LINE 832
LINE_STAT (9):
	md.write_abort = md.write_abort + 1;

003776  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
003777  aa  7 00066 2351 00	lda  	pr7|54		md.write_abort
004000  aa   000044 7330 00	lrs  	36
004001  aa   000001 0330 07	adl  	1,dl
004002  aa  7 00066 7561 00	stq  	pr7|54		md.write_abort
						STATEMENT 1 ON LINE 834
	go to line_stat_output_complete;

004003  aa   777666 7100 04	tra  	-74,ic		003671
						STATEMENT 1 ON LINE 836
LINE_STAT (10):
	md.select_failed = md.select_failed + 1;

004004  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004005  aa  7 00067 2351 00	lda  	pr7|55		md.select_failed
004006  aa   000044 7330 00	lrs  	36
004007  aa   000001 0330 07	adl  	1,dl
004010  aa  7 00067 7561 00	stq  	pr7|55		md.select_failed
						STATEMENT 1 ON LINE 838
	go to line_stat_output_complete;

004011  aa   777660 7100 04	tra  	-80,ic		003671
						STATEMENT 1 ON LINE 840
LINE_STAT (11):
	md.wack_select = md.wack_select + 1;

004012  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004013  aa  7 00070 2351 00	lda  	pr7|56		md.wack_select
004014  aa   000044 7330 00	lrs  	36
004015  aa   000001 0330 07	adl  	1,dl
004016  aa  7 00070 7561 00	stq  	pr7|56		md.wack_select
						STATEMENT 1 ON LINE 842
	go to line_stat_output_complete;

004017  aa   777652 7100 04	tra  	-86,ic		003671
						STATEMENT 1 ON LINE 844
LINE_STAT (12):
	md.nak_output = md.nak_output + 1;

004020  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004021  aa  7 00071 2351 00	lda  	pr7|57		md.nak_output
004022  aa   000044 7330 00	lrs  	36
004023  aa   000001 0330 07	adl  	1,dl
004024  aa  7 00071 7561 00	stq  	pr7|57		md.nak_output
						STATEMENT 1 ON LINE 846
	go to line_stat_output_complete;

004025  aa   777644 7100 04	tra  	-92,ic		003671
						STATEMENT 1 ON LINE 1250
trim_failure:
	call syserr (SYSERR_CRASH_SYSTEM, "^a: Error trimming buffer chain for ^a", name, md.name);

004026  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004027  aa   774217 00 0050	desc9a	-1905,40		000245 = 136141072040
004030  aa  6 00500 00 0050	desc9a	pr6|320,40
004031  aa   774126 3520 04	epp2 	-1962,ic		000157 = 000000000001
004032  aa  6 00562 2521 00	spri2	pr6|370
004033  aa  6 00500 3521 00	epp2 	pr6|320
004034  aa  6 00564 2521 00	spri2	pr6|372
004035  aa   774057 3520 04	epp2 	-2001,ic		000114 = 151142155063
004036  aa  6 00566 2521 00	spri2	pr6|374
004037  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004040  aa  7 00004 3521 00	epp2 	pr7|4		md.name
004041  aa  6 00570 2521 00	spri2	pr6|376
004042  aa   774114 3520 04	epp2 	-1972,ic		000156 = 404000000021
004043  aa  6 00572 2521 00	spri2	pr6|378
004044  aa   774061 3520 04	epp2 	-1999,ic		000125 = 524000000046
004045  aa  6 00574 2521 00	spri2	pr6|380
004046  aa   774065 3520 04	epp2 	-1995,ic		000133 = 526000000013
004047  aa  6 00576 2521 00	spri2	pr6|382
004050  aa   774062 3520 04	epp2 	-1998,ic		000132 = 524000000040
004051  aa  6 00600 2521 00	spri2	pr6|384
004052  aa  6 00560 6211 00	eax1 	pr6|368
004053  aa   020000 4310 07	fld  	8192,dl
004054  aa  6 00044 3701 20	epp4 	pr6|36,*
004055  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
004056  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1252
	go to trim_failure;

004057  aa   777747 7100 04	tra  	-25,ic		004026
ENTRY TO set_address_table                                  STATEMENT 1 ON LINE 1516
set_address_table: entry (arg_mdp);

004060  at     000001000160
004061  ta     004060000000
004062  da     000251300000
004063  aa   001220 6270 00	eax7 	656
004064  aa  7 00034 3521 20	epp2 	pr7|28,*
004065  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004066  aa     000002000000
004067  aa     000000000000
						STATEMENT 1 ON LINE 1518
	mdp = arg_mdp;

004070  aa  6 00032 3735 20	epp7 	pr6|26,*
004071  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
004072  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
004073  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 1519
	if md.ascii then md.address_tablep = addr (ascii_address_table);

004074  aa  5 00102 2351 00	lda  	pr5|66		md.ascii
004075  aa   400000 3150 03	cana 	131072,du
004076  aa   000004 6000 04	tze  	4,ic		004102
004077  aa   773775 3534 04	epp3 	-2051,ic		000074 = 040101102103
004100  aa  5 00034 2535 00	spri3	pr5|28		md.address_tablep
004101  aa   000003 7100 04	tra  	3,ic		004104
						STATEMENT 1 ON LINE 1520
	else md.address_tablep = addr (ebcdic_address_table);

004102  aa   773752 3534 04	epp3 	-2070,ic		000054 = 100301302303
004103  aa  5 00034 2535 00	spri3	pr5|28		md.address_tablep
						STATEMENT 1 ON LINE 1521
	return;

004104  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO init                                               STATEMENT 1 ON LINE 1526
init: entry;

004105  da     000256200000
004106  aa   001220 6270 00	eax7 	656
004107  aa  7 00034 3521 20	epp2 	pr7|28,*
004110  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004111  aa     000000000000
004112  aa     000000000000
						STATEMENT 1 ON LINE 1528
	et_undefined_order_request = error_table_$undefined_order_request;

004113  aa  6 00044 3701 20	epp4 	pr6|36,*
004114  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$undefined_order_request
004115  ia  4 00010 7561 00	stq  	pr4|8		et_undefined_order_request
						STATEMENT 1 ON LINE 1529
	et_improper_data_format = error_table_$improper_data_format;

004116  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$improper_data_format
004117  ia  4 00011 7561 00	stq  	pr4|9		et_improper_data_format
						STATEMENT 1 ON LINE 1530
	et_noalloc = error_table_$noalloc;

004120  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$noalloc
004121  ia  4 00012 7561 00	stq  	pr4|10		et_noalloc
						STATEMENT 1 ON LINE 1531
	et_bad_mode = error_table_$bad_mode;

004122  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$bad_mode
004123  ia  4 00013 7561 00	stq  	pr4|11		et_bad_mode
						STATEMENT 1 ON LINE 1533
	call wire_proc$wire_me;

004124  aa  6 00056 6211 00	eax1 	pr6|46
004125  aa   000000 4310 07	fld  	0,dl
004126  la  4 00022 3521 20	epp2 	pr4|18,*		wire_proc$wire_me
004127  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1534
	return;

004130  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO dialup                                             STATEMENT 1 ON LINE 1538
dialup: entry (arg_mdp, arg_subchan);

004131  at     000002000160
004132  ta     000156000000
004133  ta     004131000000
004134  da     000263300000
004135  aa   001220 6270 00	eax7 	656
004136  aa  7 00034 3521 20	epp2 	pr7|28,*
004137  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004140  aa     000004000000
004141  aa     000000000000
						STATEMENT 1 ON LINE 1540
	mdp = arg_mdp;

004142  aa  6 00032 3735 20	epp7 	pr6|26,*
004143  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
004144  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
004145  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 1541
	subchan = arg_subchan;

004146  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_subchan
004147  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 1542
	mdep = addr (md.mde_entry (subchan));

004150  aa   000013 4020 07	mpy  	11,dl
004151  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
004152  aa  6 00174 2535 00	spri3	pr6|124		mdep
						STATEMENT 1 ON LINE 1543
	call dialup_channel;

004153  aa   002347 6700 04	tsp4 	1255,ic		006522
						STATEMENT 1 ON LINE 1544
	return;

004154  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO start_general_poll                                 STATEMENT 1 ON LINE 1548
start_general_poll: entry (arg_mdp);

004155  ta     004060000000
004156  da     000273300000
004157  aa   001220 6270 00	eax7 	656
004160  aa  7 00034 3521 20	epp2 	pr7|28,*
004161  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004162  aa     000002000000
004163  aa     000000000000
						STATEMENT 1 ON LINE 1550
	mdp = arg_mdp;

004164  aa  6 00032 3735 20	epp7 	pr6|26,*
004165  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
004166  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
004167  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 1551
	mdep = null ();

004170  aa   773774 2370 04	ldaq 	-2052,ic		000164 = 077777000043 000001000000
004171  aa  6 00174 7571 00	staq 	pr6|124		mdep
						STATEMENT 1 ON LINE 1552
	call general_poll;

004172  aa   002026 6700 04	tsp4 	1046,ic		006220
						STATEMENT 1 ON LINE 1553
	return;

004173  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO crash                                              STATEMENT 1 ON LINE 1557
crash: entry (arg_mdp);

004174  ta     004060000000
004175  da     000300300000
004176  aa   001220 6270 00	eax7 	656
004177  aa  7 00034 3521 20	epp2 	pr7|28,*
004200  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
004201  aa     000002000000
004202  aa     000000000000
						STATEMENT 1 ON LINE 1559
	mdp = arg_mdp;

004203  aa  6 00032 3735 20	epp7 	pr6|26,*
004204  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_mdp
004205  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_mdp
004206  aa  6 00172 6515 00	spri5	pr6|122		mdp
						STATEMENT 1 ON LINE 1560
	call crash_mpx;

004207  aa   002236 6700 04	tsp4 	1182,ic		006445
						STATEMENT 1 ON LINE 1561
	return;

004210  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 1689
     end ibm3270_mpx;

BEGIN PROCEDURE adv_text
ENTRY TO adv_text                                           STATEMENT 1 ON LINE 850
adv_text: proc (n);

004211  aa  6 00202 6501 00	spri4	pr6|130
004212  aa  6 00204 2521 00	spri2	pr6|132
						STATEMENT 1 ON LINE 854
	textp = addr (text_array (n + 1));

004213  aa  2 00002 7271 20	lxl7 	pr2|2,*		n
004214  aa  6 00116 3521 20	epp2 	pr6|78,*		text_array
004215  aa  2 00000 5005 17	a9bd 	pr2|0,7
004216  aa  6 00116 2521 00	spri2	pr6|78		textp
						STATEMENT 1 ON LINE 855
	textl = textl - n;

004217  aa  6 00204 3735 20	epp7 	pr6|132,*
004220  aa  7 00002 3361 20	lcq  	pr7|2,*		n
004221  aa  6 00120 0561 00	asq  	pr6|80		textl
						STATEMENT 1 ON LINE 856
	if textl > 0 then return;

004222  aa  6 00120 2361 00	ldq  	pr6|80		textl
004223  aa   000002 6044 04	tmoz 	2,ic		004225
004224  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 857
	if buffer.next = 0 then do;

004225  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
004226  aa   000066 7730 00	lrl  	54
004227  aa  6 00606 7561 00	stq  	pr6|390		buffer.next
004230  aa   000004 6010 04	tnz  	4,ic		004234
						STATEMENT 1 ON LINE 858
	     textp = null ();

004231  aa   773733 2370 04	ldaq 	-2085,ic		000164 = 077777000043 000001000000
004232  aa  6 00116 7571 00	staq 	pr6|78		textp
						STATEMENT 1 ON LINE 859
	     return;

004233  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 860
	end;

						STATEMENT 1 ON LINE 861
	blockp = ptr (ttybp, buffer.next);

004234  aa  6 00150 3515 20	epp1 	pr6|104,*		ttybp
004235  aa   000000 3114 06	eawp1	0,ql
004236  aa  6 00160 2515 00	spri1	pr6|112		blockp
						STATEMENT 1 ON LINE 862
	textp = addr (buffer.chars);

004237  aa  1 00001 3715 00	epp5 	pr1|1		buffer.chars
004240  aa  6 00116 6515 00	spri5	pr6|78		textp
						STATEMENT 1 ON LINE 863
	textl = buffer.tally;

004241  aa  1 00000 2361 00	ldq  	pr1|0		buffer.tally
004242  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
004243  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 864
	return;

004244  aa  6 00202 6101 00	rtcd 	pr6|130
						STATEMENT 1 ON LINE 866
     end adv_text;

  END PROCEDURE adv_text
BEGIN PROCEDURE find_next
ENTRY TO find_next                                          STATEMENT 1 ON LINE 870
find_next: proc (ix, c);

004245  aa  6 00210 6501 00	spri4	pr6|136
004246  aa  6 00212 2521 00	spri2	pr6|138
						STATEMENT 1 ON LINE 877
	if ix = 0 then ix = index (text, c);

004247  aa  2 00002 2361 20	ldq  	pr2|2,*		ix
004250  aa   000016 6010 04	tnz  	14,ic		004266
004251  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
004252  aa  2 00004 3715 20	epp5 	pr2|4,*
004253  aa  6 00120 7271 00	lxl7 	pr6|80		textl
004254  aa  000 100 124 540	scm  	(pr,rl),(pr),mask(000)
004255  aa  7 00000 00 0017	desc9a	pr7|0,x7		text
004256  aa  5 00000 00 0001	desc9a	pr5|0,1		c
004257  aa  6 00056 0001 00	arg  	pr6|46
004260  aa  6 00056 2361 00	ldq  	pr6|46
004261  aa   000002 6070 04	ttf  	2,ic		004263
004262  aa   000001 3360 07	lcq  	1,dl
004263  aa   000001 0760 07	adq  	1,dl
004264  aa  2 00002 7561 20	stq  	pr2|2,*		ix
004265  aa   000022 7100 04	tra  	18,ic		004307
						STATEMENT 1 ON LINE 878
	else if ix = 1 then ;

004266  aa   000001 1160 07	cmpq 	1,dl
004267  aa   000002 6010 04	tnz  	2,ic		004271
004270  aa   000017 7100 04	tra  	15,ic		004307
						STATEMENT 1 ON LINE 879
	else do;

						STATEMENT 1 ON LINE 880
	     i = index (substr (text, 1, ix - 1), c);

004271  aa   000001 1760 07	sbq  	1,dl
004272  aa  6 00116 3735 20	epp7 	pr6|78,*		textp
004273  aa  2 00004 3715 20	epp5 	pr2|4,*
004274  aa  000 100 124 540	scm  	(pr,rl),(pr),mask(000)
004275  aa  7 00000 00 0006	desc9a	pr7|0,ql		text
004276  aa  5 00000 00 0001	desc9a	pr5|0,1		c
004277  aa  6 00056 0001 00	arg  	pr6|46
004300  aa  6 00056 2361 00	ldq  	pr6|46
004301  aa   000002 6070 04	ttf  	2,ic		004303
004302  aa   000001 3360 07	lcq  	1,dl
004303  aa   000001 0760 07	adq  	1,dl
004304  aa  6 00216 7561 00	stq  	pr6|142		i
						STATEMENT 1 ON LINE 881
	     if i ^= 0 then ix = i;

004305  aa   000002 6000 04	tze  	2,ic		004307
004306  aa  2 00002 7561 20	stq  	pr2|2,*		ix
						STATEMENT 1 ON LINE 882
	end;

						STATEMENT 1 ON LINE 884
	return;

004307  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 886
     end find_next;

  END PROCEDURE find_next
BEGIN PROCEDURE get_position_chars
ENTRY TO get_position_chars                                 STATEMENT 1 ON LINE 890
get_position_chars: proc (pos);

004310  aa  6 00220 6501 00	spri4	pr6|144
004311  aa  6 00222 2521 00	spri2	pr6|146
						STATEMENT 1 ON LINE 895
	posbit = bit (bin (pos, 12), 12);

004312  aa  2 00002 2351 20	lda  	pr2|2,*		pos
004313  aa   000002 6050 04	tpl  	2,ic		004315
004314  aa   000000 5310 00	neg  	0
004315  aa   000030 7350 00	als  	24
004316  aa  6 00226 7551 00	sta  	pr6|150		posbit
						STATEMENT 1 ON LINE 896
	pos_char1 = address_table (bin (substr (posbit, 1, 6)));

004317  aa  6 00226 2351 00	lda  	pr6|150		posbit
004320  aa   000102 7730 00	lrl  	66
004321  aa  6 00123 4501 00	stz  	pr6|83		pos_char1
004322  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004323  aa  7 00034 3715 20	epp5 	pr7|28,*		md.address_tablep
004324  aa  040 100 100 506	mlr  	(pr,ql),(pr),fill(040)
004325  aa  5 00000 00 0001	desc9a	pr5|0,1		address_table
004326  aa  6 00123 00 0001	desc9a	pr6|83,1		pos_char1
						STATEMENT 1 ON LINE 897
	pos_char2 = address_table (bin (substr (posbit, 7, 6)));

004327  aa  6 00226 2351 00	lda  	pr6|150		posbit
004330  aa   000006 7350 00	als  	6
004331  aa   000102 7730 00	lrl  	66
004332  aa  6 00124 4501 00	stz  	pr6|84		pos_char2
004333  aa  040 100 100 506	mlr  	(pr,ql),(pr),fill(040)
004334  aa  5 00000 00 0001	desc9a	pr5|0,1		address_table
004335  aa  6 00124 00 0001	desc9a	pr6|84,1		pos_char2
						STATEMENT 1 ON LINE 898
	return;

004336  aa  6 00220 6101 00	rtcd 	pr6|144
						STATEMENT 1 ON LINE 900
     end get_position_chars;

  END PROCEDURE get_position_chars
BEGIN PROCEDURE get_position
ENTRY TO get_position                                       STATEMENT 1 ON LINE 904
get_position: proc (c1, c2) returns (fixed bin);

004337  aa  6 00230 6501 00	spri4	pr6|152
004340  aa  6 00232 2521 00	spri2	pr6|154
						STATEMENT 1 ON LINE 908
	return (bin (getbit (c1) || getbit (c2)));

004341  aa  2 00004 3521 20	epp2 	pr2|4,*		c2
004342  aa  6 00616 2521 00	spri2	pr6|398
004343  aa  6 00612 3521 00	epp2 	pr6|394
004344  aa  6 00620 2521 00	spri2	pr6|400
004345  aa  6 00614 3521 00	epp2 	pr6|396
004346  aa   010000 4310 07	fld  	4096,dl
004347  aa  2 00000 7571 00	staq 	pr2|0
004350  aa   000037 6700 04	tsp4 	31,ic		004407
004351  aa  6 00232 3735 20	epp7 	pr6|154,*
004352  aa  7 00002 3521 20	epp2 	pr7|2,*		c1
004353  aa  6 00616 2521 00	spri2	pr6|398
004354  aa  6 00613 3521 00	epp2 	pr6|395
004355  aa  6 00620 2521 00	spri2	pr6|400
004356  aa  6 00614 3521 00	epp2 	pr6|396
004357  aa   010000 4310 07	fld  	4096,dl
004360  aa  2 00000 7571 00	staq 	pr2|0
004361  aa   000026 6700 04	tsp4 	22,ic		004407
004362  aa  6 00613 2351 00	lda  	pr6|395
004363  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004364  aa  6 00613 7551 00	sta  	pr6|395
004365  aa  6 00612 2351 00	lda  	pr6|394
004366  aa  0 00014 3771 00	anaq 	pr0|12		= 770000000000 000000000000
004367  aa   000006 7710 00	arl  	6
004370  aa  6 00613 2751 00	ora  	pr6|395
004371  aa   000074 7730 00	lrl  	60
004372  aa  6 00232 3735 20	epp7 	pr6|154,*
004373  aa  7 00006 7561 20	stq  	pr7|6,*
004374  aa  6 00230 6101 00	rtcd 	pr6|152
						STATEMENT 1 ON LINE 910
     end get_position;

  END PROCEDURE get_position
BEGIN PROCEDURE getbin
ENTRY TO getbin                                             STATEMENT 1 ON LINE 914
getbin: proc (c) returns (fixed bin (6));

004375  aa  6 00236 6501 00	spri4	pr6|158
004376  aa  6 00240 2521 00	spri2	pr6|160
						STATEMENT 1 ON LINE 918
	return (bin (substr (unspec (c), 4, 6), 6));

004377  aa  2 00002 3735 20	epp7 	pr2|2,*
004400  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004401  aa  7 00000 03 0006	descb	pr7|0(3),6
004402  aa  6 00056 00 0044	descb	pr6|46,36
004403  aa  6 00056 2351 00	lda  	pr6|46
004404  aa   000102 7730 00	lrl  	66
004405  aa  2 00004 7561 20	stq  	pr2|4,*
004406  aa  6 00236 6101 00	rtcd 	pr6|158
						STATEMENT 1 ON LINE 920
     end getbin;

  END PROCEDURE getbin
BEGIN PROCEDURE getbit
ENTRY TO getbit                                             STATEMENT 1 ON LINE 922
getbit: proc (c) returns (bit (6));

004407  aa  6 00244 6501 00	spri4	pr6|164
004410  aa  6 00246 2521 00	spri2	pr6|166
						STATEMENT 1 ON LINE 926
	return (substr (unspec (c), 4, 6));

004411  aa  2 00004 3735 20	epp7 	pr2|4,*
004412  aa  2 00002 3715 20	epp5 	pr2|2,*
004413  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
004414  aa  5 00000 03 0006	descb	pr5|0(3),6
004415  aa  7 00000 00 0006	descb	pr7|0,6
004416  aa  6 00244 6101 00	rtcd 	pr6|164
						STATEMENT 1 ON LINE 928
     end getbit;

  END PROCEDURE getbit
BEGIN PROCEDURE queue_write
ENTRY TO queue_write                                        STATEMENT 1 ON LINE 932
queue_write: proc;

004417  aa  6 00252 6501 00	spri4	pr6|170
						STATEMENT 1 ON LINE 936
	if mde.write_queued then do;

004420  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
004421  aa  7 00012 2351 00	lda  	pr7|10		mde.write_queued
004422  aa   000010 3150 03	cana 	8,du
004423  aa   000057 6000 04	tze  	47,ic		004502
						STATEMENT 1 ON LINE 937
	     call syserr$binary (
		JUST_LOG,				/* Log, discard if not possible	*/
		mdep,
		SB_ibm3270_mde,
		size (mde),			/* Size of an MDE			*/
		"^a: Attempt to queue write while write queued ^a.^a",
		name,
		md.name,
		mde.name
		);

004424  aa   000013 2360 07	ldq  	11,dl
004425  aa  6 00624 7561 00	stq  	pr6|404
004426  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
004427  aa   773705 00 0064	desc9a	-2107,52		000333 = 136141072040
004430  aa  6 00626 00 0064	desc9a	pr6|406,52
004431  aa   773513 3520 04	epp2 	-2229,ic		000144 = 000000000005
004432  aa  6 00646 2521 00	spri2	pr6|422
004433  aa  6 00174 3521 00	epp2 	pr6|124		mdep
004434  aa  6 00650 2521 00	spri2	pr6|424
004435  aa   773400 3520 04	epp2 	-2304,ic		000035 = 000000000043
004436  aa  6 00652 2521 00	spri2	pr6|426
004437  aa  6 00624 3521 00	epp2 	pr6|404
004440  aa  6 00654 2521 00	spri2	pr6|428
004441  aa  6 00626 3521 00	epp2 	pr6|406
004442  aa  6 00656 2521 00	spri2	pr6|430
004443  aa   773451 3520 04	epp2 	-2263,ic		000114 = 151142155063
004444  aa  6 00660 2521 00	spri2	pr6|432
004445  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
004446  aa  5 00004 3521 00	epp2 	pr5|4		md.name
004447  aa  6 00662 2521 00	spri2	pr6|434
004450  aa  7 00001 3521 00	epp2 	pr7|1		mde.name
004451  aa  6 00664 2521 00	spri2	pr6|436
004452  aa   773504 3520 04	epp2 	-2236,ic		000156 = 404000000021
004453  aa  6 00666 2521 00	spri2	pr6|438
004454  aa  6 00672 2521 00	spri2	pr6|442
004455  aa   773503 3520 04	epp2 	-2237,ic		000160 = 464000000000
004456  aa  6 00670 2521 00	spri2	pr6|440
004457  aa   773444 3520 04	epp2 	-2268,ic		000123 = 404000000030
004460  aa  6 00674 2521 00	spri2	pr6|444
004461  aa   773441 3520 04	epp2 	-2271,ic		000122 = 524000000063
004462  aa  6 00676 2521 00	spri2	pr6|446
004463  aa   773450 3520 04	epp2 	-2264,ic		000133 = 526000000013
004464  aa  6 00700 2521 00	spri2	pr6|448
004465  aa   773445 3520 04	epp2 	-2267,ic		000132 = 524000000040
004466  aa  6 00702 2521 00	spri2	pr6|450
004467  aa   773432 3520 04	epp2 	-2278,ic		000121 = 524000000003
004470  aa  6 00704 2521 00	spri2	pr6|452
004471  aa  6 00644 6211 00	eax1 	pr6|420
004472  aa   040000 4310 07	fld  	16384,dl
004473  aa  6 00044 3701 20	epp4 	pr6|36,*
004474  la  4 00020 3521 20	epp2 	pr4|16,*		syserr$binary
004475  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 948
	     mde.write_chain_ptr = header_blockp;

004476  aa  6 00130 3735 20	epp7 	pr6|88,*		header_blockp
004477  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
004500  aa  5 00011 5471 00	sprp7	pr5|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 949
	     return;

004501  aa  6 00252 6101 00	rtcd 	pr6|170
						STATEMENT 1 ON LINE 950
	end;

						STATEMENT 1 ON LINE 952
	if md.first_write_chan = 0 then do;

004502  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
004503  aa  5 00052 2361 00	ldq  	pr5|42		md.first_write_chan
004504  aa   000005 6010 04	tnz  	5,ic		004511
						STATEMENT 1 ON LINE 953
	     md.first_write_chan = subchan;

004505  aa  6 00127 2361 00	ldq  	pr6|87		subchan
004506  aa  5 00052 7561 00	stq  	pr5|42		md.first_write_chan
						STATEMENT 1 ON LINE 954
	     md.last_write_chan = subchan;

004507  aa  5 00053 7561 00	stq  	pr5|43		md.last_write_chan
						STATEMENT 1 ON LINE 955
	end;

004510  aa   000010 7100 04	tra  	8,ic		004520
						STATEMENT 1 ON LINE 956
	else do;

						STATEMENT 1 ON LINE 957
	     p = addr (md.mde_entry (md.last_write_chan));

004511  aa  5 00053 2361 00	ldq  	pr5|43		md.last_write_chan
004512  aa   000013 4020 07	mpy  	11,dl
004513  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
004514  aa  6 00260 2535 00	spri3	pr6|176		p
						STATEMENT 1 ON LINE 958
	     p -> mde.next_write_chan = subchan;

004515  aa  6 00127 2361 00	ldq  	pr6|87		subchan
004516  aa  3 00006 7561 00	stq  	pr3|6		mde.next_write_chan
						STATEMENT 1 ON LINE 959
	     md.last_write_chan = subchan;

004517  aa  5 00053 7561 00	stq  	pr5|43		md.last_write_chan
						STATEMENT 1 ON LINE 960
	end;

						STATEMENT 1 ON LINE 961
	mde.next_write_chan = 0;

004520  aa  7 00006 4501 00	stz  	pr7|6		mde.next_write_chan
						STATEMENT 1 ON LINE 962
	mde.write_chain_ptr = header_blockp;

004521  aa  6 00130 3535 20	epp3 	pr6|88,*		header_blockp
004522  aa  7 00011 5431 00	sprp3	pr7|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 963
	mde.write_queued = "1"b;

004523  aa   000010 2350 03	lda  	8,du
004524  aa  7 00012 2551 00	orsa 	pr7|10		mde.write_queued
						STATEMENT 1 ON LINE 964
	return;

004525  aa  6 00252 6101 00	rtcd 	pr6|170
						STATEMENT 1 ON LINE 966
     end queue_write;

  END PROCEDURE queue_write
BEGIN PROCEDURE process_write
ENTRY TO process_write                                      STATEMENT 1 ON LINE 970
process_write: proc;

004526  aa  6 00262 6501 00	spri4	pr6|178
						STATEMENT 1 ON LINE 972
	mdep = null ();

004527  aa   773435 2370 04	ldaq 	-2275,ic		000164 = 077777000043 000001000000
004530  aa  6 00174 7571 00	staq 	pr6|124		mdep
						STATEMENT 1 ON LINE 973
	if md.output_in_progress then return;

004531  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004532  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
004533  aa   004000 3150 03	cana 	2048,du
004534  aa   000002 6000 04	tze  	2,ic		004536
004535  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 974
	if md.poll_in_progress then return;

004536  aa  7 00102 2351 00	lda  	pr7|66		md.poll_in_progress
004537  aa   010000 3150 03	cana 	4096,du
004540  aa   000002 6000 04	tze  	2,ic		004542
004541  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 975
	if md.first_poll_chan ^= 0 then return;

004542  aa  7 00056 2361 00	ldq  	pr7|46		md.first_poll_chan
004543  aa   000002 6000 04	tze  	2,ic		004545
004544  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 976
	if md.first_control_chan ^= 0 then do;

004545  aa  7 00047 2361 00	ldq  	pr7|39		md.first_control_chan
004546  aa   000006 6000 04	tze  	6,ic		004554
						STATEMENT 1 ON LINE 977
	     call setup_control_chan;

004547  aa   001530 6700 04	tsp4 	856,ic		006277
						STATEMENT 1 ON LINE 978
	     if mdep ^= null () then go to write_join;

004550  aa  6 00174 2371 00	ldaq 	pr6|124		mdep
004551  aa   773413 6770 04	eraq 	-2293,ic		000164 = 077777000043 000001000000
004552  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004553  aa   000020 6010 04	tnz  	16,ic		004573
						STATEMENT 1 ON LINE 979
	end;

						STATEMENT 1 ON LINE 980
	if md.first_write_chan = 0 then return;

004554  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004555  aa  7 00052 2361 00	ldq  	pr7|42		md.first_write_chan
004556  aa   000002 6010 04	tnz  	2,ic		004560
004557  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 982
	subchan = md.first_write_chan;

004560  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 983
	mdep = addr (md.mde_entry (subchan));

004561  aa   000013 4020 07	mpy  	11,dl
004562  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
004563  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 984
	md.first_write_chan = mde.next_write_chan;

004564  aa  5 00006 2361 00	ldq  	pr5|6		mde.next_write_chan
004565  aa  7 00052 7561 00	stq  	pr7|42		md.first_write_chan
						STATEMENT 1 ON LINE 985
	if md.first_write_chan = 0 then md.last_write_chan = 0;

004566  aa   000002 6010 04	tnz  	2,ic		004570
004567  aa  7 00053 4501 00	stz  	pr7|43		md.last_write_chan
						STATEMENT 1 ON LINE 986
	mde.next_write_chan = 0;

004570  aa  5 00006 4501 00	stz  	pr5|6		mde.next_write_chan
						STATEMENT 1 ON LINE 987
	mde.write_queued = "0"b;

004571  aa   002312 2350 04	lda  	1226,ic		007103 = 777767777777
004572  aa  5 00012 3551 00	ansa 	pr5|10		mde.write_queued
						STATEMENT 1 ON LINE 989
write_join: md.write_chain_ptr = mde.write_chain_ptr;

004573  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
004574  aa  7 00011 2361 00	ldq  	pr7|9		mde.write_chain_ptr
004575  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
004576  aa  5 00055 7561 00	stq  	pr5|45		md.write_chain_ptr
						STATEMENT 1 ON LINE 990
	mde.write_chain_ptr = null ();

004577  aa   002341 2360 04	ldq  	1249,ic		007140 = 007777000001
004600  aa  7 00011 7561 00	stq  	pr7|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 991
	md.cur_write_chan = subchan;

004601  aa  6 00127 2361 00	ldq  	pr6|87		subchan
004602  aa  5 00054 7561 00	stq  	pr5|44		md.cur_write_chan
						STATEMENT 1 ON LINE 992
	md.eot_sent = "0"b;

004603  aa   002277 2350 04	lda  	1215,ic		007102 = 776777777777
004604  aa  5 00102 3551 00	ansa 	pr5|66		md.eot_sent
						STATEMENT 1 ON LINE 993
	md.output_in_progress = "1"b;

004605  aa   004000 2350 03	lda  	2048,du
004606  aa  5 00102 2551 00	orsa 	pr5|66		md.output_in_progress
						STATEMENT 1 ON LINE 994
	md.message_in_progress = "1"b;

004607  aa   002000 2350 03	lda  	1024,du
004610  aa  5 00102 2551 00	orsa 	pr5|66		md.message_in_progress
						STATEMENT 1 ON LINE 996
	call select;

004611  aa   001417 6700 04	tsp4 	783,ic		006230
						STATEMENT 1 ON LINE 997
	call send_more_message;

004612  aa   000004 6700 04	tsp4 	4,ic		004616
						STATEMENT 1 ON LINE 999
	mdep = null ();

004613  aa   773351 2370 04	ldaq 	-2327,ic		000164 = 077777000043 000001000000
004614  aa  6 00174 7571 00	staq 	pr6|124		mdep
						STATEMENT 1 ON LINE 1000
	return;

004615  aa  6 00262 6101 00	rtcd 	pr6|178
						STATEMENT 1 ON LINE 1002
     end process_write;

  END PROCEDURE process_write
BEGIN PROCEDURE send_more_message
ENTRY TO send_more_message                                  STATEMENT 1 ON LINE 1006
send_more_message: proc;

004616  aa  6 00270 6501 00	spri4	pr6|184
						STATEMENT 1 ON LINE 1010
	if ^md.send_output then return;

004617  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004620  aa  7 00102 2351 00	lda  	pr7|66		md.send_output
004621  aa   000400 3150 03	cana 	256,du
004622  aa   000002 6010 04	tnz  	2,ic		004624
004623  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1011
	if md.write_chain_ptr ^= null () then do;

004624  aa  7 00055 2361 00	ldq  	pr7|45		md.write_chain_ptr
004625  aa   002313 1160 04	cmpq 	1227,ic		007140 = 007777000001
004626  aa   000046 6000 04	tze  	38,ic		004674
						STATEMENT 1 ON LINE 1012
	     p = md.write_chain_ptr;

004627  aa  7 00055 7651 00	lprp5	pr7|45		md.write_chain_ptr
004630  aa  6 00276 6515 00	spri5	pr6|190		p
						STATEMENT 1 ON LINE 1013
send_chain:    call channel_manager$write (md.devx, p, code);

004631  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004632  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
004633  aa  6 00710 2521 00	spri2	pr6|456
004634  aa  6 00276 3521 00	epp2 	pr6|190		p
004635  aa  6 00712 2521 00	spri2	pr6|458
004636  aa  6 00101 3521 00	epp2 	pr6|65		code
004637  aa  6 00714 2521 00	spri2	pr6|460
004640  aa  6 00706 6211 00	eax1 	pr6|454
004641  aa   014000 4310 07	fld  	6144,dl
004642  aa  6 00044 3701 20	epp4 	pr6|36,*
004643  la  4 00036 3521 20	epp2 	pr4|30,*		channel_manager$write
004644  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1014
	     if code ^= 0 then do;

004645  aa  6 00101 2361 00	ldq  	pr6|65		code
004646  aa   000020 6000 04	tze  	16,ic		004666
						STATEMENT 1 ON LINE 1015
		if code ^= et_noalloc then go to write_fails;

004647  aa  6 00044 3701 20	epp4 	pr6|36,*
004650  ia  4 00012 1161 00	cmpq 	pr4|10		et_noalloc
004651  aa   000105 6010 04	tnz  	69,ic		004756
						STATEMENT 1 ON LINE 1016
		md.needs_space = md.needs_space + 1;

004652  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004653  aa  7 00073 2351 00	lda  	pr7|59		md.needs_space
004654  aa   000044 7330 00	lrs  	36
004655  aa   000001 0330 07	adl  	1,dl
004656  aa  7 00073 7561 00	stq  	pr7|59		md.needs_space
						STATEMENT 1 ON LINE 1017
		call tty_space_man$needs_space (md.devx);

004657  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
004660  aa  6 00710 2521 00	spri2	pr6|456
004661  aa  6 00706 6211 00	eax1 	pr6|454
004662  aa   004000 4310 07	fld  	2048,dl
004663  la  4 00052 3521 20	epp2 	pr4|42,*		tty_space_man$needs_space
004664  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1018
		return;

004665  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1019
	     end;

						STATEMENT 1 ON LINE 1020
	     md.send_output = "0"b;

004666  aa   002213 2350 04	lda  	1163,ic		007101 = 777377777777
004667  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004670  aa  7 00102 3551 00	ansa 	pr7|66		md.send_output
						STATEMENT 1 ON LINE 1021
	     md.write_chain_ptr = p;

004671  aa  6 00276 3715 20	epp5 	pr6|190,*		p
004672  aa  7 00055 5451 00	sprp5	pr7|45		md.write_chain_ptr
						STATEMENT 1 ON LINE 1022
	     return;

004673  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1023
	end;

						STATEMENT 1 ON LINE 1025
	if ^md.eot_sent then do;

004674  aa  7 00102 2351 00	lda  	pr7|66		md.eot_sent
004675  aa   001000 3150 03	cana 	512,du
004676  aa   000055 6010 04	tnz  	45,ic		004753
						STATEMENT 1 ON LINE 1026
	     call tty_space_man$get_buffer (md.devx, 16, OUTPUT, blockp);

004677  aa   000020 2360 07	ldq  	16,dl
004700  aa  6 00716 7561 00	stq  	pr6|462
004701  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
004702  aa  6 00722 2521 00	spri2	pr6|466
004703  aa  6 00716 3521 00	epp2 	pr6|462
004704  aa  6 00724 2521 00	spri2	pr6|468
004705  aa   773235 3520 04	epp2 	-2403,ic		000142 = 400000000000
004706  aa  6 00726 2521 00	spri2	pr6|470
004707  aa  6 00160 3521 00	epp2 	pr6|112		blockp
004710  aa  6 00730 2521 00	spri2	pr6|472
004711  aa  6 00720 6211 00	eax1 	pr6|464
004712  aa   020000 4310 07	fld  	8192,dl
004713  aa  6 00044 3701 20	epp4 	pr6|36,*
004714  la  4 00044 3521 20	epp2 	pr4|36,*		tty_space_man$get_buffer
004715  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1027
	     if blockp = null () then do;

004716  aa  6 00160 2371 00	ldaq 	pr6|112		blockp
004717  aa   773245 6770 04	eraq 	-2395,ic		000164 = 077777000043 000001000000
004720  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
004721  aa   000016 6010 04	tnz  	14,ic		004737
						STATEMENT 1 ON LINE 1028
		md.needs_space = md.needs_space + 1;

004722  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004723  aa  7 00073 2351 00	lda  	pr7|59		md.needs_space
004724  aa   000044 7330 00	lrs  	36
004725  aa   000001 0330 07	adl  	1,dl
004726  aa  7 00073 7561 00	stq  	pr7|59		md.needs_space
						STATEMENT 1 ON LINE 1029
		call tty_space_man$needs_space (md.devx);

004727  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
004730  aa  6 00710 2521 00	spri2	pr6|456
004731  aa  6 00706 6211 00	eax1 	pr6|454
004732  aa   004000 4310 07	fld  	2048,dl
004733  aa  6 00044 3701 20	epp4 	pr6|36,*
004734  la  4 00052 3521 20	epp2 	pr4|42,*		tty_space_man$needs_space
004735  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1030
		return;

004736  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1031
	     end;

						STATEMENT 1 ON LINE 1032
	     buffer.tally = 1;

004737  aa   000001 2350 07	lda  	1,dl
004740  aa  6 00160 3735 20	epp7 	pr6|112,*		buffer.tally
004741  aa  7 00000 5511 04	stba 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1033
	     buffer.chars (0) = md.eot;

004742  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004743  aa  7 00027 2351 00	lda  	pr7|23		md.eot
004744  aa   000011 7350 00	als  	9
004745  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
004746  aa  5 00001 5511 40	stba 	pr5|1,40		buffer.chars
						STATEMENT 1 ON LINE 1034
	     p = blockp;

004747  aa  6 00276 6515 00	spri5	pr6|190		p
						STATEMENT 1 ON LINE 1035
	     md.eot_sent = "1"b;

004750  aa   001000 2350 03	lda  	512,du
004751  aa  7 00102 2551 00	orsa 	pr7|66		md.eot_sent
						STATEMENT 1 ON LINE 1036
	     go to send_chain;

004752  aa   777657 7100 04	tra  	-81,ic		004631
						STATEMENT 1 ON LINE 1037
	end;

						STATEMENT 1 ON LINE 1039
	md.message_in_progress = "0"b;

004753  aa   002131 2350 04	lda  	1113,ic		007104 = 775777777777
004754  aa  7 00102 3551 00	ansa 	pr7|66		md.message_in_progress
						STATEMENT 1 ON LINE 1040
	return;

004755  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1042
write_fails: return;

004756  aa  6 00270 6101 00	rtcd 	pr6|184
						STATEMENT 1 ON LINE 1044
     end send_more_message;

  END PROCEDURE send_more_message
BEGIN PROCEDURE build_header
ENTRY TO build_header                                       STATEMENT 1 ON LINE 1048
build_header: proc;

004757  aa  6 00300 6501 00	spri4	pr6|192
						STATEMENT 1 ON LINE 1050
	buffer.chars (0) = md.stx;

004760  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
004761  aa  7 00025 2351 00	lda  	pr7|21		md.stx
004762  aa   000022 7350 00	als  	18
004763  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
004764  aa  5 00001 5511 40	stba 	pr5|1,40		buffer.chars
						STATEMENT 1 ON LINE 1051
	buffer.chars (1) = md.esc;

004765  aa  7 00025 2351 00	lda  	pr7|21		md.esc
004766  aa   000022 7350 00	als  	18
004767  aa  5 00001 5511 20	stba 	pr5|1,20		buffer.chars
						STATEMENT 1 ON LINE 1052
	if mde.erase_req then buffer.chars (2) = md.erase_write;

004770  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
004771  aa  3 00012 2351 00	lda  	pr3|10		mde.erase_req
004772  aa   010000 3150 03	cana 	4096,du
004773  aa   000005 6000 04	tze  	5,ic		005000
004774  aa  7 00026 2351 00	lda  	pr7|22		md.erase_write
004775  aa   000011 7710 00	arl  	9
004776  aa  5 00001 5511 10	stba 	pr5|1,10		buffer.chars
004777  aa   000004 7100 04	tra  	4,ic		005003
						STATEMENT 1 ON LINE 1053
	else buffer.chars (2) = md.write;

005000  aa  7 00026 2351 00	lda  	pr7|22		md.write
005001  aa   000022 7710 00	arl  	18
005002  aa  5 00001 5511 10	stba 	pr5|1,10		buffer.chars
						STATEMENT 1 ON LINE 1054
	mde.erase_req = "0"b;

005003  aa   002112 2350 04	lda  	1098,ic		007115 = 767777777777
005004  aa  3 00012 3551 00	ansa 	pr3|10		mde.erase_req
						STATEMENT 1 ON LINE 1055
	string (wcc) = "0"b;

005005  aa   002073 2350 04	lda  	1083,ic		007100 = 007777777777
005006  aa  6 00147 3551 00	ansa 	pr6|103
						STATEMENT 1 ON LINE 1056
	wcc.keyboard_restore = mde.keyboard_restore;

005007  aa  3 00012 2351 00	lda  	pr3|10		mde.keyboard_restore
005010  aa   000005 7350 00	als  	5
005011  aa  6 00147 6751 00	era  	pr6|103		wcc.keyboard_restore
005012  aa   020000 3750 03	ana  	8192,du
005013  aa  6 00147 6551 00	ersa 	pr6|103		wcc.keyboard_restore
						STATEMENT 1 ON LINE 1057
	mde.keyboard_restore = "0"b;

005014  aa   002065 2350 04	lda  	1077,ic		007101 = 777377777777
005015  aa  3 00012 3551 00	ansa 	pr3|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 1058
	wcc.sound_alarm = mde.sound_alarm;

005016  aa  3 00012 2351 00	lda  	pr3|10		mde.sound_alarm
005017  aa   000003 7350 00	als  	3
005020  aa  6 00147 6751 00	era  	pr6|103		wcc.sound_alarm
005021  aa   040000 3750 03	ana  	16384,du
005022  aa  6 00147 6551 00	ersa 	pr6|103		wcc.sound_alarm
						STATEMENT 1 ON LINE 1059
	mde.sound_alarm = "0"b;

005023  aa   002062 2350 04	lda  	1074,ic		007105 = 773777777777
005024  aa  3 00012 3551 00	ansa 	pr3|10		mde.sound_alarm
						STATEMENT 1 ON LINE 1060
	wcc.start_printer = mde.printer;

005025  aa  3 00012 2351 00	lda  	pr3|10		mde.printer
005026  aa  6 00147 6751 00	era  	pr6|103		wcc.start_printer
005027  aa   100000 3750 03	ana  	32768,du
005030  aa  6 00147 6551 00	ersa 	pr6|103		wcc.start_printer
						STATEMENT 1 ON LINE 1061
	buffer.chars (3) = address_table (bin (string (wcc)));

005031  aa  6 00147 2351 00	lda  	pr6|103
005032  aa   000102 7730 00	lrl  	66
005033  aa  7 00034 3515 20	epp1 	pr7|28,*		md.address_tablep
005034  aa  040 100 100 506	mlr  	(pr,ql),(pr),fill(040)
005035  aa  1 00000 00 0001	desc9a	pr1|0,1		address_table
005036  aa  5 00001 60 0001	desc9a	pr5|1(3),1	buffer.chars
						STATEMENT 1 ON LINE 1062
	buffer.chars (4) = md.sba;

005037  aa  7 00025 2351 00	lda  	pr7|21		md.sba
005040  aa   000011 7350 00	als  	9
005041  aa  5 00002 5511 40	stba 	pr5|2,40		buffer.chars
						STATEMENT 1 ON LINE 1063
	call get_position_chars (mde.position);

005042  aa  3 00005 3521 00	epp2 	pr3|5		mde.position
005043  aa  6 00736 2521 00	spri2	pr6|478
005044  aa  6 00734 3521 00	epp2 	pr6|476
005045  aa   004000 4310 07	fld  	2048,dl
005046  aa  2 00000 7571 00	staq 	pr2|0
005047  aa   777241 6700 04	tsp4 	-351,ic		004310
						STATEMENT 1 ON LINE 1064
	buffer.chars (5) = pos_char1;

005050  aa  6 00123 2351 00	lda  	pr6|83		pos_char1
005051  aa   000011 7710 00	arl  	9
005052  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
005053  aa  7 00002 5511 20	stba 	pr7|2,20		buffer.chars
						STATEMENT 1 ON LINE 1065
	buffer.chars (6) = pos_char2;

005054  aa  6 00124 2351 00	lda  	pr6|84		pos_char2
005055  aa   000022 7710 00	arl  	18
005056  aa  7 00002 5511 10	stba 	pr7|2,10		buffer.chars
						STATEMENT 1 ON LINE 1066
	buffer.tally = 7;

005057  aa   000007 2350 07	lda  	7,dl
005060  aa  7 00000 5511 04	stba 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1068
	return;

005061  aa  6 00300 6101 00	rtcd 	pr6|192
						STATEMENT 1 ON LINE 1070
     end build_header;

  END PROCEDURE build_header
BEGIN PROCEDURE process_input
ENTRY TO process_input                                      STATEMENT 1 ON LINE 1074
process_input: proc;

005062  aa  6 00306 6501 00	spri4	pr6|198
						STATEMENT 1 ON LINE 1079
	if md.input_chain_ptr = null () then return;

005063  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005064  aa  7 00060 2371 00	ldaq 	pr7|48		md.input_chain_ptr
005065  aa   773077 6770 04	eraq 	-2497,ic		000164 = 077777000043 000001000000
005066  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005067  aa   000002 6010 04	tnz  	2,ic		005071
005070  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1080
	chain_ptr = md.input_chain_ptr;

005071  aa  7 00060 3715 20	epp5 	pr7|48,*		md.input_chain_ptr
005072  aa  6 00114 6515 00	spri5	pr6|76		chain_ptr
						STATEMENT 1 ON LINE 1081
	md.input_chain_ptr = null ();

005073  aa   773071 2370 04	ldaq 	-2503,ic		000164 = 077777000043 000001000000
005074  aa  7 00060 7571 00	staq 	pr7|48		md.input_chain_ptr
						STATEMENT 1 ON LINE 1082
	blockp = chain_ptr;

005075  aa  6 00114 3715 20	epp5 	pr6|76,*		chain_ptr
005076  aa  6 00160 6515 00	spri5	pr6|112		blockp
						STATEMENT 1 ON LINE 1083
	textp = addr (buffer.chars);

005077  aa  6 00160 3715 20	epp5 	pr6|112,*		blockp
005100  aa  5 00001 3715 00	epp5 	pr5|1		buffer.chars
005101  aa  6 00116 6515 00	spri5	pr6|78		textp
						STATEMENT 1 ON LINE 1084
	textl = buffer.tally;

005102  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
005103  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005104  aa  6 00120 7561 00	stq  	pr6|80		textl
						STATEMENT 1 ON LINE 1086
	dev_addr = getbin (text_msg.device_address);

005105  aa   000002 7270 07	lxl7 	2,dl
005106  aa  5 00000 3521 00	epp2 	pr5|0		text_msg.device_address
005107  aa  2 00000 5005 17	a9bd 	pr2|0,7
005110  aa  6 00746 2521 00	spri2	pr6|486
005111  aa  6 00742 3521 00	epp2 	pr6|482
005112  aa  6 00750 2521 00	spri2	pr6|488
005113  aa  6 00744 3521 00	epp2 	pr6|484
005114  aa   010000 4310 07	fld  	4096,dl
005115  aa  2 00000 7571 00	staq 	pr2|0
005116  aa   777257 6700 04	tsp4 	-337,ic		004375
005117  aa  6 00742 2361 00	ldq  	pr6|482
005120  aa  6 00125 7561 00	stq  	pr6|85		dev_addr
						STATEMENT 1 ON LINE 1087
	if dev_addr < lbound (md.chan_map, 1) | dev_addr > hbound (md.chan_map, 1) then go to bad_dev_addr;

005121  aa   776266 6040 04	tmi  	-842,ic		003407
005122  aa   000037 1160 07	cmpq 	31,dl
005123  aa   776264 6054 04	tpnz 	-844,ic		003407
						STATEMENT 1 ON LINE 1088
	subchan = md.chan_map (dev_addr);

005124  aa   000011 4020 07	mpy  	9,dl
005125  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005126  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
005127  aa  7 00036 00 0011	descb	pr7|30,9		md.chan_map
005130  aa  6 00056 00 0044	descb	pr6|46,36
005131  aa  6 00056 2351 00	lda  	pr6|46
005132  aa   000077 7330 00	lrs  	63
005133  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 1089
	if subchan <= 0 then go to bad_device;

005134  aa   776315 6044 04	tmoz 	-819,ic		003451
						STATEMENT 1 ON LINE 1090
	mdep = addr (md.mde_entry (subchan));

005135  aa   000013 4020 07	mpy  	11,dl
005136  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
005137  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 1092
	if ^mde.dialed then do;

005140  aa  5 00012 2351 00	lda  	pr5|10		mde.dialed
005141  aa   200000 3150 03	cana 	65536,du
005142  aa   000013 6010 04	tnz  	11,ic		005155
						STATEMENT 1 ON LINE 1093
	     if mde.listen & md.started then do;

005143  aa  5 00012 2351 00	lda  	pr5|10		mde.listen
005144  aa   400000 3150 03	cana 	131072,du
005145  aa   000007 6000 04	tze  	7,ic		005154
005146  aa  7 00102 2351 00	lda  	pr7|66		md.started
005147  aa   020000 3150 03	cana 	8192,du
005150  aa   000004 6000 04	tze  	4,ic		005154
						STATEMENT 1 ON LINE 1094
		mde.erase_req = "1"b;

005151  aa   010000 2350 03	lda  	4096,du
005152  aa  5 00012 2551 00	orsa 	pr5|10		mde.erase_req
						STATEMENT 1 ON LINE 1095
		call dialup_channel;

005153  aa   001347 6700 04	tsp4 	743,ic		006522
						STATEMENT 1 ON LINE 1096
	     end;

						STATEMENT 1 ON LINE 1097
	     go to discard_input;

005154  aa   776345 7100 04	tra  	-795,ic		003521
						STATEMENT 1 ON LINE 1098
	end;

						STATEMENT 1 ON LINE 1100
	if textl < 5 then go to bad_input;

005155  aa  6 00120 2361 00	ldq  	pr6|80		textl
005156  aa   000005 1160 07	cmpq 	5,dl
005157  aa   776145 6040 04	tmi  	-923,ic		003324
						STATEMENT 1 ON LINE 1102
	if text_msg.aid = md.quit_key then do;

005160  aa  6 00116 3535 20	epp3 	pr6|78,*		textp
005161  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
005162  aa  3 00000 60 0001	desc9a	pr3|0(3),1	text_msg.aid
005163  aa  6 00742 00 0004	desc9a	pr6|482,4		text_msg.aid
005164  aa  7 00032 2351 00	lda  	pr7|26		md.quit_key
005165  aa   000033 7350 00	als  	27
005166  aa  6 00742 1151 00	cmpa 	pr6|482		text_msg.aid
005167  aa   000070 6010 04	tnz  	56,ic		005257
						STATEMENT 1 ON LINE 1103
	     if mde.raw3270_in_effect & ^mde.hndlquit then go to send_raw_input;

005170  aa  5 00012 2351 00	lda  	pr5|10		mde.raw3270_in_effect
005171  aa   000020 3150 03	cana 	16,du
005172  aa   000004 6000 04	tze  	4,ic		005176
005173  aa  5 00012 2351 00	lda  	pr5|10		mde.hndlquit
005174  aa   040000 3150 03	cana 	16384,du
005175  aa   000312 6000 04	tze  	202,ic		005507
						STATEMENT 1 ON LINE 1104
	     save_bit = mde.end_of_page;

005176  aa  5 00012 2351 00	lda  	pr5|10		mde.end_of_page
005177  aa   000010 7350 00	als  	8
005200  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
005201  aa  6 00315 7551 00	sta  	pr6|205		save_bit
						STATEMENT 1 ON LINE 1105
	     mde.end_of_page = "0"b;

005202  aa   001700 2350 04	lda  	960,ic		007102 = 776777777777
005203  aa  5 00012 3551 00	ansa 	pr5|10		mde.end_of_page
						STATEMENT 1 ON LINE 1106
	     if save_bit then do;

005204  aa  6 00315 2351 00	lda  	pr6|205		save_bit
005205  aa   000004 6000 04	tze  	4,ic		005211
						STATEMENT 1 ON LINE 1107
		mde.position = 0;

005206  aa  5 00005 4501 00	stz  	pr5|5		mde.position
						STATEMENT 1 ON LINE 1108
		mde.erase_req = "1"b;

005207  aa   010000 2350 03	lda  	4096,du
005210  aa  5 00012 2551 00	orsa 	pr5|10		mde.erase_req
						STATEMENT 1 ON LINE 1109
	     end;

						STATEMENT 1 ON LINE 1110
	     call channel_manager$interrupt (mde.devx, QUIT, "0"b);

005211  aa   772755 2370 04	ldaq 	-2579,ic		000166 = 000000000000 000000000000
005212  aa  6 00754 7571 00	staq 	pr6|492
005213  aa  5 00000 3521 00	epp2 	pr5|0		mde.devx
005214  aa  6 00746 2521 00	spri2	pr6|486
005215  aa   772714 3520 04	epp2 	-2612,ic		000131 = 000000000010
005216  aa  6 00750 2521 00	spri2	pr6|488
005217  aa  6 00754 3521 00	epp2 	pr6|492
005220  aa  6 00752 2521 00	spri2	pr6|490
005221  aa  6 00744 6211 00	eax1 	pr6|484
005222  aa   014000 4310 07	fld  	6144,dl
005223  aa  6 00044 3701 20	epp4 	pr6|36,*
005224  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005225  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1111
	     if mde.hndlquit then if mde.write_chain_ptr ^= null () then do;

005226  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
005227  aa  7 00012 2351 00	lda  	pr7|10		mde.hndlquit
005230  aa   040000 3150 03	cana 	16384,du
005231  aa   000006 6000 04	tze  	6,ic		005237
005232  aa  7 00011 2361 00	ldq  	pr7|9		mde.write_chain_ptr
005233  aa   001705 1160 04	cmpq 	965,ic		007140 = 007777000001
005234  aa   000003 6000 04	tze  	3,ic		005237
						STATEMENT 1 ON LINE 1112
		     call reset_channel;

005235  aa   001364 6700 04	tsp4 	756,ic		006621
						STATEMENT 1 ON LINE 1113
		     save_bit = "0"b;

005236  aa  6 00315 4501 00	stz  	pr6|205		save_bit
						STATEMENT 1 ON LINE 1114
		end;

						STATEMENT 1 ON LINE 1115
	     if save_bit then call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

005237  aa  6 00315 2351 00	lda  	pr6|205		save_bit
005240  aa   000016 6000 04	tze  	14,ic		005256
005241  aa   772725 2370 04	ldaq 	-2603,ic		000166 = 000000000000 000000000000
005242  aa  6 00754 7571 00	staq 	pr6|492
005243  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
005244  aa  6 00746 2521 00	spri2	pr6|486
005245  aa   772704 3520 04	epp2 	-2620,ic		000151 = 000000000004
005246  aa  6 00750 2521 00	spri2	pr6|488
005247  aa  6 00754 3521 00	epp2 	pr6|492
005250  aa  6 00752 2521 00	spri2	pr6|490
005251  aa  6 00744 6211 00	eax1 	pr6|484
005252  aa   014000 4310 07	fld  	6144,dl
005253  aa  6 00044 3701 20	epp4 	pr6|36,*
005254  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005255  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1116
	     go to discard_input;

005256  aa   776243 7100 04	tra  	-861,ic		003521
						STATEMENT 1 ON LINE 1117
	end;

						STATEMENT 1 ON LINE 1119
	if mde.raw3270_in_effect then go to send_raw_input;

005257  aa  5 00012 2351 00	lda  	pr5|10		mde.raw3270_in_effect
005260  aa   000020 3150 03	cana 	16,du
005261  aa   000226 6010 04	tnz  	150,ic		005507
						STATEMENT 1 ON LINE 1120
	if text_msg.aid = md.formfeed_key then do;

005262  aa  6 00742 2351 00	lda  	pr6|482		text_msg.aid
005263  aa  7 00033 1151 00	cmpa 	pr7|27		md.formfeed_key
005264  aa   000055 6010 04	tnz  	45,ic		005341
						STATEMENT 1 ON LINE 1121
	     mde.erase_req, mde.keyboard_restore = "1"b;

005265  aa   010000 2350 03	lda  	4096,du
005266  aa  5 00012 2551 00	orsa 	pr5|10		mde.erase_req
005267  aa   000400 2350 03	lda  	256,du
005270  aa  5 00012 2551 00	orsa 	pr5|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 1122
	     mde.position = 0;

005271  aa  5 00005 4501 00	stz  	pr5|5		mde.position
						STATEMENT 1 ON LINE 1123
	     call queue_control;

005272  aa   000755 6700 04	tsp4 	493,ic		006247
						STATEMENT 1 ON LINE 1124
	     if mde.end_of_page then do;

005273  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
005274  aa  7 00012 2351 00	lda  	pr7|10		mde.end_of_page
005275  aa   001000 3150 03	cana 	512,du
005276  aa   000021 6000 04	tze  	17,ic		005317
						STATEMENT 1 ON LINE 1125
		mde.end_of_page = "0"b;

005277  aa   001603 2350 04	lda  	899,ic		007102 = 776777777777
005300  aa  7 00012 3551 00	ansa 	pr7|10		mde.end_of_page
						STATEMENT 1 ON LINE 1126
		call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

005301  aa   772665 2370 04	ldaq 	-2635,ic		000166 = 000000000000 000000000000
005302  aa  6 00754 7571 00	staq 	pr6|492
005303  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
005304  aa  6 00746 2521 00	spri2	pr6|486
005305  aa   772644 3520 04	epp2 	-2652,ic		000151 = 000000000004
005306  aa  6 00750 2521 00	spri2	pr6|488
005307  aa  6 00754 3521 00	epp2 	pr6|492
005310  aa  6 00752 2521 00	spri2	pr6|490
005311  aa  6 00744 6211 00	eax1 	pr6|484
005312  aa   014000 4310 07	fld  	6144,dl
005313  aa  6 00044 3701 20	epp4 	pr6|36,*
005314  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005315  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1127
	     end;

005316  aa   000022 7100 04	tra  	18,ic		005340
						STATEMENT 1 ON LINE 1128
	     else do;

						STATEMENT 1 ON LINE 1129
		unspec (rtx_info) = "0"b;

005317  aa   772647 2370 04	ldaq 	-2649,ic		000166 = 000000000000 000000000000
005320  aa  6 00156 7571 00	staq 	pr6|110
						STATEMENT 1 ON LINE 1130
		rtx_info.formfeed_present = "1"b;

005321  aa   040000 2350 07	lda  	16384,dl
005322  aa  6 00157 2551 00	orsa 	pr6|111		rtx_info.formfeed_present
						STATEMENT 1 ON LINE 1131
		call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));

005323  aa  6 00156 2371 00	ldaq 	pr6|110
005324  aa  6 00754 7571 00	staq 	pr6|492
005325  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
005326  aa  6 00746 2521 00	spri2	pr6|486
005327  aa   772606 3520 04	epp2 	-2682,ic		000135 = 000000000006
005330  aa  6 00750 2521 00	spri2	pr6|488
005331  aa  6 00754 3521 00	epp2 	pr6|492
005332  aa  6 00752 2521 00	spri2	pr6|490
005333  aa  6 00744 6211 00	eax1 	pr6|484
005334  aa   014000 4310 07	fld  	6144,dl
005335  aa  6 00044 3701 20	epp4 	pr6|36,*
005336  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005337  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1132
	     end;

						STATEMENT 1 ON LINE 1133
	     go to discard_input;

005340  aa   776161 7100 04	tra  	-911,ic		003521
						STATEMENT 1 ON LINE 1134
	end;

						STATEMENT 1 ON LINE 1136
	if text_msg.aid ^= md.enter then go to discard_input;

005341  aa  7 00030 2351 00	lda  	pr7|24		md.enter
005342  aa   000022 7350 00	als  	18
005343  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
005344  aa  6 00742 1151 00	cmpa 	pr6|482		text_msg.aid
005345  aa   776154 6010 04	tnz  	-916,ic		003521
						STATEMENT 1 ON LINE 1137
	if textl < 7 then go to bad_input;

005346  aa  6 00120 2361 00	ldq  	pr6|80		textl
005347  aa   000007 1160 07	cmpq 	7,dl
005350  aa   775754 6040 04	tmi  	-1044,ic		003324
						STATEMENT 1 ON LINE 1138
	position = get_position (text_msg.cursor1, text_msg.cursor2);

005351  aa  3 00001 3521 00	epp2 	pr3|1		text_msg.cursor1
005352  aa  6 00760 2521 00	spri2	pr6|496
005353  aa   000001 7270 07	lxl7 	1,dl
005354  aa  3 00001 3521 00	epp2 	pr3|1		text_msg.cursor2
005355  aa  2 00000 5005 17	a9bd 	pr2|0,7
005356  aa  6 00762 2521 00	spri2	pr6|498
005357  aa  6 00122 3521 00	epp2 	pr6|82		position
005360  aa  6 00764 2521 00	spri2	pr6|500
005361  aa  6 00756 3521 00	epp2 	pr6|494
005362  aa   014000 4310 07	fld  	6144,dl
005363  aa  2 00000 7571 00	staq 	pr2|0
005364  aa   776753 6700 04	tsp4 	-533,ic		004337
						STATEMENT 1 ON LINE 1140
	delta_position = position - mde.position;

005365  aa  6 00122 2361 00	ldq  	pr6|82		position
005366  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
005367  aa  7 00005 1761 00	sbq  	pr7|5		mde.position
005370  aa  6 00314 7561 00	stq  	pr6|204		delta_position
						STATEMENT 1 ON LINE 1141
	if (delta_position > (md.input_count - 7)) | (delta_position < 0) then do;

005371  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
005372  aa  5 00062 2361 00	ldq  	pr5|50		md.input_count
005373  aa   000007 1760 07	sbq  	7,dl
005374  aa  6 00314 1161 00	cmpq 	pr6|204		delta_position
005375  aa   000003 6040 04	tmi  	3,ic		005400
005376  aa  6 00314 2361 00	ldq  	pr6|204		delta_position
005377  aa   000011 6050 04	tpl  	9,ic		005410
						STATEMENT 1 ON LINE 1142
	     mde.position = position;

005400  aa  6 00122 2361 00	ldq  	pr6|82		position
005401  aa  7 00005 7561 00	stq  	pr7|5		mde.position
						STATEMENT 1 ON LINE 1143
	     mde.sound_alarm = "1"b;

005402  aa   004000 2350 03	lda  	2048,du
005403  aa  7 00012 2551 00	orsa 	pr7|10		mde.sound_alarm
						STATEMENT 1 ON LINE 1144
	     mde.keyboard_restore = "1"b;

005404  aa   000400 2350 03	lda  	256,du
005405  aa  7 00012 2551 00	orsa 	pr7|10		mde.keyboard_restore
						STATEMENT 1 ON LINE 1145
	     call queue_control;

005406  aa   000641 6700 04	tsp4 	417,ic		006247
						STATEMENT 1 ON LINE 1146
	     go to discard_input;

005407  aa   776112 7100 04	tra  	-950,ic		003521
						STATEMENT 1 ON LINE 1147
	end;

						STATEMENT 1 ON LINE 1149
	call trim_chain_start (chain_ptr, md.input_count - (delta_position + 1));

005410  aa   000001 0760 07	adq  	1,dl
005411  aa  6 00742 7561 00	stq  	pr6|482
005412  aa  5 00062 2361 00	ldq  	pr5|50		md.input_count
005413  aa  6 00742 1761 00	sbq  	pr6|482
005414  aa  6 00742 7561 00	stq  	pr6|482
005415  aa   001455 3520 04	epp2 	813,ic		007072 = 000004000000
005416  aa   000137 6700 04	tsp4 	95,ic		005555
						STATEMENT 1 ON LINE 1150
	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);

005417  aa  6 00114 3735 20	epp7 	pr6|76,*		chain_ptr
005420  aa  6 00160 6535 00	spri7	pr6|112		blockp
005421  aa   000000 0110 03	nop  	0,du
005422  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
005423  aa   000066 7730 00	lrl  	54
005424  aa  6 00742 7561 00	stq  	pr6|482		buffer.next
005425  aa   000005 6000 04	tze  	5,ic		005432
						STATEMENT 1 ON LINE 1151
	end;

005426  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
005427  aa   000000 3120 06	eawp2	0,ql
005430  aa  6 00160 2521 00	spri2	pr6|112		blockp
005431  aa   777771 7100 04	tra  	-7,ic		005422
						STATEMENT 1 ON LINE 1152
	buffer.chars (buffer.tally - 1) = md.nl;

005432  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
005433  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005434  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
005435  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
005436  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
005437  aa  5 00025 00 0001	desc9a	pr5|21,1		md.nl
005440  aa  7 00000 60 0001	desc9a	pr7|0(3),1	buffer.chars
						STATEMENT 1 ON LINE 1154
	unspec (rtx_info) = "0"b;

005441  aa   772525 2370 04	ldaq 	-2731,ic		000166 = 000000000000 000000000000
005442  aa  6 00156 7571 00	staq 	pr6|110
						STATEMENT 1 ON LINE 1155
	rtx_info.chain_head = rel (chain_ptr);

005443  aa  6 00114 6351 20	eaa  	pr6|76,*		chain_ptr
005444  aa  6 00156 5511 60	stba 	pr6|110,60	rtx_info.chain_head
						STATEMENT 1 ON LINE 1156
	rtx_info.chain_tail = rel (blockp);

005445  aa  7 00000 6351 00	eaa  	pr7|0		blockp
005446  aa   000022 7710 00	arl  	18
005447  aa  6 00156 5511 14	stba 	pr6|110,14	rtx_info.chain_tail
						STATEMENT 1 ON LINE 1157
	rtx_info.input_count = delta_position + 1;

005450  aa  6 00314 2361 00	ldq  	pr6|204		delta_position
005451  aa   000001 0760 07	adq  	1,dl
005452  aa   000066 7370 00	lls  	54
005453  aa  6 00157 5511 60	stba 	pr6|111,60	rtx_info.input_count
						STATEMENT 1 ON LINE 1158
	rtx_info.break_char = "1"b;

005454  aa   400000 2350 07	lda  	131072,dl
005455  aa  6 00157 2551 00	orsa 	pr6|111		rtx_info.break_char
						STATEMENT 1 ON LINE 1159
	mde.position = mod (position - mod (position, mde.line_size) + mde.line_size, mde.screen_size);

005456  aa  6 00122 2361 00	ldq  	pr6|82		position
005457  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
005460  aa  3 00004 3521 00	epp2 	pr3|4		mde.line_size
005461  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005462  aa  6 00742 7561 00	stq  	pr6|482
005463  aa  6 00122 2361 00	ldq  	pr6|82		position
005464  aa  6 00742 1761 00	sbq  	pr6|482
005465  aa  2 00000 0761 00	adq  	pr2|0		mde.line_size
005466  aa  3 00003 3521 00	epp2 	pr3|3		mde.screen_size
005467  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
005470  aa  3 00005 7561 00	stq  	pr3|5		mde.position
						STATEMENT 1 ON LINE 1160
	call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));

005471  aa  6 00156 2371 00	ldaq 	pr6|110
005472  aa  6 00754 7571 00	staq 	pr6|492
005473  aa  3 00000 3521 00	epp2 	pr3|0		mde.devx
005474  aa  6 00746 2521 00	spri2	pr6|486
005475  aa   772440 3520 04	epp2 	-2784,ic		000135 = 000000000006
005476  aa  6 00750 2521 00	spri2	pr6|488
005477  aa  6 00754 3521 00	epp2 	pr6|492
005500  aa  6 00752 2521 00	spri2	pr6|490
005501  aa  6 00744 6211 00	eax1 	pr6|484
005502  aa   014000 4310 07	fld  	6144,dl
005503  aa  6 00044 3701 20	epp4 	pr6|36,*
005504  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005505  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1161
	return;

005506  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1165
send_raw_input:
	do blockp = chain_ptr repeat (ptr (ttybp, buffer.next)) while (buffer.next ^= 0);

005507  aa  6 00114 3515 20	epp1 	pr6|76,*		chain_ptr
005510  aa  6 00160 2515 00	spri1	pr6|112		blockp
005511  aa   000000 0110 03	nop  	0,du
005512  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.next
005513  aa   000066 7730 00	lrl  	54
005514  aa  6 00742 7561 00	stq  	pr6|482		buffer.next
005515  aa   000005 6000 04	tze  	5,ic		005522
						STATEMENT 1 ON LINE 1167
	end;

005516  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
005517  aa   000000 3120 06	eawp2	0,ql
005520  aa  6 00160 2521 00	spri2	pr6|112		blockp
005521  aa   777771 7100 04	tra  	-7,ic		005512
						STATEMENT 1 ON LINE 1168
	unspec (rtx_info) = "0"b;

005522  aa   772444 2370 04	ldaq 	-2780,ic		000166 = 000000000000 000000000000
005523  aa  6 00156 7571 00	staq 	pr6|110
						STATEMENT 1 ON LINE 1169
	rtx_info.chain_head = rel (chain_ptr);

005524  aa  6 00114 6351 20	eaa  	pr6|76,*		chain_ptr
005525  aa  6 00156 5511 60	stba 	pr6|110,60	rtx_info.chain_head
						STATEMENT 1 ON LINE 1170
	rtx_info.chain_tail = rel (blockp);

005526  aa  6 00160 6351 20	eaa  	pr6|112,*		blockp
005527  aa   000022 7710 00	arl  	18
005530  aa  6 00156 5511 14	stba 	pr6|110,14	rtx_info.chain_tail
						STATEMENT 1 ON LINE 1171
	rtx_info.input_count = md.input_count;

005531  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005532  aa  7 00062 2361 00	ldq  	pr7|50		md.input_count
005533  aa   000066 7370 00	lls  	54
005534  aa  6 00157 5511 60	stba 	pr6|111,60	rtx_info.input_count
						STATEMENT 1 ON LINE 1172
	rtx_info.break_char = "1"b;

005535  aa   400000 2350 07	lda  	131072,dl
005536  aa  6 00157 2551 00	orsa 	pr6|111		rtx_info.break_char
						STATEMENT 1 ON LINE 1173
	call channel_manager$interrupt (mde.devx, ACCEPT_INPUT, unspec (rtx_info));

005537  aa  6 00156 2371 00	ldaq 	pr6|110
005540  aa  6 00754 7571 00	staq 	pr6|492
005541  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
005542  aa  6 00746 2521 00	spri2	pr6|486
005543  aa   772372 3520 04	epp2 	-2822,ic		000135 = 000000000006
005544  aa  6 00750 2521 00	spri2	pr6|488
005545  aa  6 00754 3521 00	epp2 	pr6|492
005546  aa  6 00752 2521 00	spri2	pr6|490
005547  aa  6 00744 6211 00	eax1 	pr6|484
005550  aa   014000 4310 07	fld  	6144,dl
005551  aa  6 00044 3701 20	epp4 	pr6|36,*
005552  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
005553  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1174
	return;

005554  aa  6 00306 6101 00	rtcd 	pr6|198
						STATEMENT 1 ON LINE 1176
     end process_input;

  END PROCEDURE process_input
BEGIN PROCEDURE trim_chain_start
ENTRY TO trim_chain_start                                   STATEMENT 1 ON LINE 1180
trim_chain_start: proc (p, arg_n);

005555  aa  6 00316 6501 00	spri4	pr6|206
005556  aa  6 00320 2521 00	spri2	pr6|208
						STATEMENT 1 ON LINE 1191
	n = arg_n;

005557  aa  2 00004 2361 20	ldq  	pr2|4,*		arg_n
005560  aa  6 00326 7561 00	stq  	pr6|214		n
						STATEMENT 1 ON LINE 1192
	do while (n > 0);

005561  aa   000000 0110 03	nop  	0,du
005562  aa  6 00326 2361 00	ldq  	pr6|214		n
005563  aa   000064 6044 04	tmoz 	52,ic		005647
						STATEMENT 1 ON LINE 1193
	     if p -> buffer.tally <= n then do;

005564  aa  6 00320 3735 20	epp7 	pr6|208,*
005565  aa  7 00002 3715 20	epp5 	pr7|2,*		p
005566  aa  5 00000 2361 20	ldq  	pr5|0,*		buffer.tally
005567  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005570  aa  6 00770 7561 00	stq  	pr6|504		buffer.tally
005571  aa  6 00326 1161 00	cmpq 	pr6|214		n
005572  aa   000036 6054 04	tpnz 	30,ic		005630
						STATEMENT 1 ON LINE 1194
		q = p;

005573  aa  5 00000 3535 20	epp3 	pr5|0,*		p
005574  aa  6 00324 2535 00	spri3	pr6|212		q
						STATEMENT 1 ON LINE 1195
		n = n - p -> buffer.tally;

005575  aa  6 00770 3361 00	lcq  	pr6|504		buffer.tally
005576  aa  6 00326 0561 00	asq  	pr6|214		n
						STATEMENT 1 ON LINE 1196
		if p -> buffer.next = 0 then if n > 0 then
			go to trim_failure;

005577  aa  3 00000 2351 00	lda  	pr3|0		buffer.next
005600  aa   000066 7730 00	lrl  	54
005601  aa  6 00771 7561 00	stq  	pr6|505		buffer.next
005602  aa   000006 6010 04	tnz  	6,ic		005610
005603  aa  6 00326 2361 00	ldq  	pr6|214		n
005604  aa   776222 6054 04	tpnz 	-878,ic		004026
						STATEMENT 1 ON LINE 1198
		     else p = null ();

005605  aa   772357 2370 04	ldaq 	-2833,ic		000164 = 077777000043 000001000000
005606  aa  7 00002 7571 20	staq 	pr7|2,*		p
005607  aa   000004 7100 04	tra  	4,ic		005613
						STATEMENT 1 ON LINE 1199
		else p = ptr (ttybp, p -> buffer.next);

005610  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
005611  aa   000000 3120 06	eawp2	0,ql
005612  aa  7 00002 2521 20	spri2	pr7|2,*		p
						STATEMENT 1 ON LINE 1200
		call tty_space_man$free_buffer (md.devx, INPUT, q);

005613  aa  6 00172 3515 20	epp1 	pr6|122,*		mdp
005614  aa  1 00003 3521 00	epp2 	pr1|3		md.devx
005615  aa  6 00774 2521 00	spri2	pr6|508
005616  aa   772323 3520 04	epp2 	-2861,ic		000141 = 000000000000
005617  aa  6 00776 2521 00	spri2	pr6|510
005620  aa  6 00324 3521 00	epp2 	pr6|212		q
005621  aa  6 01000 2521 00	spri2	pr6|512
005622  aa  6 00772 6211 00	eax1 	pr6|506
005623  aa   014000 4310 07	fld  	6144,dl
005624  aa  6 00044 3701 20	epp4 	pr6|36,*
005625  la  4 00046 3521 20	epp2 	pr4|38,*		tty_space_man$free_buffer
005626  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1201
	     end;

005627  aa   777733 7100 04	tra  	-37,ic		005562
						STATEMENT 1 ON LINE 1202
	     else do;

						STATEMENT 1 ON LINE 1203
		textp = addr (p -> buffer.chars);

005630  aa  5 00000 3535 20	epp3 	pr5|0,*		p
005631  aa  3 00001 3515 00	epp1 	pr3|1		buffer.chars
005632  aa  6 00330 2515 00	spri1	pr6|216		textp
						STATEMENT 1 ON LINE 1204
		textl = p -> buffer.tally;

005633  aa  6 00332 7561 00	stq  	pr6|218		textl
						STATEMENT 1 ON LINE 1205
		text = substr (text, n + 1);

005634  aa  6 00326 1761 00	sbq  	pr6|214		n
005635  aa  6 00326 7271 00	lxl7 	pr6|214		n
005636  aa  6 00332 7261 00	lxl6 	pr6|218		textl
005637  aa  040 140 100 557	mlr  	(pr,rl,x7),(pr,rl),fill(040)
005640  aa  1 00000 00 0006	desc9a	pr1|0,ql		text
005641  aa  1 00000 00 0016	desc9a	pr1|0,x6		text
						STATEMENT 1 ON LINE 1206
		p -> buffer.tally = p -> buffer.tally - n;

005642  aa  6 00770 2361 00	ldq  	pr6|504		buffer.tally
005643  aa  6 00326 1761 00	sbq  	pr6|214		n
005644  aa  3 00000 5521 04	stbq 	pr3|0,04		buffer.tally
						STATEMENT 1 ON LINE 1207
		n = 0;

005645  aa  6 00326 4501 00	stz  	pr6|214		n
						STATEMENT 1 ON LINE 1208
	     end;

						STATEMENT 1 ON LINE 1209
	end;

005646  aa   777714 7100 04	tra  	-52,ic		005562
						STATEMENT 1 ON LINE 1211
	return;

005647  aa  6 00316 6101 00	rtcd 	pr6|206
						STATEMENT 1 ON LINE 1213
     end trim_chain_start;

  END PROCEDURE trim_chain_start
BEGIN PROCEDURE trim_chain_end
ENTRY TO trim_chain_end                                     STATEMENT 1 ON LINE 1217
trim_chain_end: proc (arg_p, arg_n);

005650  aa  6 00334 6501 00	spri4	pr6|220
005651  aa  6 00336 2521 00	spri2	pr6|222
						STATEMENT 1 ON LINE 1226
	n = arg_n;

005652  aa  2 00004 2361 20	ldq  	pr2|4,*		arg_n
005653  aa  6 00344 7561 00	stq  	pr6|228		n
						STATEMENT 1 ON LINE 1227
	do while (n > 0);

005654  aa  6 00344 2361 00	ldq  	pr6|228		n
005655  aa   000067 6044 04	tmoz 	55,ic		005744
						STATEMENT 1 ON LINE 1228
	     q = null ();

005656  aa   772306 2370 04	ldaq 	-2874,ic		000164 = 077777000043 000001000000
005657  aa  6 00346 7571 00	staq 	pr6|230		q
						STATEMENT 1 ON LINE 1229
	     p = arg_p;

005660  aa  6 00336 3735 20	epp7 	pr6|222,*
005661  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_p
005662  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_p
005663  aa  6 00342 6515 00	spri5	pr6|226		p
						STATEMENT 1 ON LINE 1230
	     do while (p -> buffer.next ^= 0);

005664  aa  6 00342 2351 20	lda  	pr6|226,*		buffer.next
005665  aa   000066 7730 00	lrl  	54
005666  aa  6 01002 7561 00	stq  	pr6|514		buffer.next
005667  aa   000007 6000 04	tze  	7,ic		005676
						STATEMENT 1 ON LINE 1231
		q = p;

005670  aa  6 00342 3735 20	epp7 	pr6|226,*		p
005671  aa  6 00346 6535 00	spri7	pr6|230		q
						STATEMENT 1 ON LINE 1232
		p = ptr (ttybp, p -> buffer.next);

005672  aa  6 00150 3521 20	epp2 	pr6|104,*		ttybp
005673  aa   000000 3120 06	eawp2	0,ql
005674  aa  6 00342 2521 00	spri2	pr6|226		p
						STATEMENT 1 ON LINE 1233
	     end;

005675  aa   777767 7100 04	tra  	-9,ic		005664
						STATEMENT 1 ON LINE 1234
	     if n < p -> buffer.tally then do;

005676  aa  6 00342 2361 20	ldq  	pr6|226,*		buffer.tally
005677  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
005700  aa  6 01002 7561 00	stq  	pr6|514		buffer.tally
005701  aa  6 00344 1161 00	cmpq 	pr6|228		n
005702  aa   000006 6044 04	tmoz 	6,ic		005710
						STATEMENT 1 ON LINE 1235
		p -> buffer.tally = p -> buffer.tally - n;

005703  aa  6 00344 1761 00	sbq  	pr6|228		n
005704  aa  6 00342 3735 20	epp7 	pr6|226,*		buffer.tally
005705  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1236
		n = 0;

005706  aa  6 00344 4501 00	stz  	pr6|228		n
						STATEMENT 1 ON LINE 1237
	     end;

005707  aa   777745 7100 04	tra  	-27,ic		005654
						STATEMENT 1 ON LINE 1238
	     else do;

						STATEMENT 1 ON LINE 1239
		n = n - p -> buffer.tally;

005710  aa  6 01002 3361 00	lcq  	pr6|514		buffer.tally
005711  aa  6 00344 0561 00	asq  	pr6|228		n
						STATEMENT 1 ON LINE 1240
		if q ^= null () then q -> buffer.next = 0;

005712  aa  6 00346 2371 00	ldaq 	pr6|230		q
005713  aa   772251 6770 04	eraq 	-2903,ic		000164 = 077777000043 000001000000
005714  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
005715  aa   000005 6000 04	tze  	5,ic		005722
005716  aa   000000 2350 07	lda  	0,dl
005717  aa  6 00346 3735 20	epp7 	pr6|230,*		buffer.next
005720  aa  7 00000 5511 60	stba 	pr7|0,60		buffer.next
005721  aa   000006 7100 04	tra  	6,ic		005727
						STATEMENT 1 ON LINE 1241
		else if n > 0 then go to trim_failure;

005722  aa  6 00344 2361 00	ldq  	pr6|228		n
005723  aa   776103 6054 04	tpnz 	-957,ic		004026
						STATEMENT 1 ON LINE 1242
		else arg_p = null ();

005724  aa   772240 2370 04	ldaq 	-2912,ic		000164 = 077777000043 000001000000
005725  aa  6 00336 3735 20	epp7 	pr6|222,*
005726  aa  7 00002 7571 20	staq 	pr7|2,*		arg_p
						STATEMENT 1 ON LINE 1243
		call tty_space_man$free_buffer (md.devx, INPUT, p);

005727  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005730  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
005731  aa  6 01006 2521 00	spri2	pr6|518
005732  aa   772207 3520 04	epp2 	-2937,ic		000141 = 000000000000
005733  aa  6 01010 2521 00	spri2	pr6|520
005734  aa  6 00342 3521 00	epp2 	pr6|226		p
005735  aa  6 01012 2521 00	spri2	pr6|522
005736  aa  6 01004 6211 00	eax1 	pr6|516
005737  aa   014000 4310 07	fld  	6144,dl
005740  aa  6 00044 3701 20	epp4 	pr6|36,*
005741  la  4 00046 3521 20	epp2 	pr4|38,*		tty_space_man$free_buffer
005742  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1244
	     end;

						STATEMENT 1 ON LINE 1245
	end;

005743  aa   777711 7100 04	tra  	-55,ic		005654
						STATEMENT 1 ON LINE 1246
	return;

005744  aa  6 00334 6101 00	rtcd 	pr6|220
						STATEMENT 1 ON LINE 1248
     end trim_chain_end;

  END PROCEDURE trim_chain_end
BEGIN PROCEDURE queue_poll
ENTRY TO queue_poll                                         STATEMENT 1 ON LINE 1256
queue_poll: proc;

005745  aa  6 00350 6501 00	spri4	pr6|232
						STATEMENT 1 ON LINE 1260
	if md.first_poll_chan = 0 then do;

005746  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005747  aa  7 00056 2361 00	ldq  	pr7|46		md.first_poll_chan
005750  aa   000005 6010 04	tnz  	5,ic		005755
						STATEMENT 1 ON LINE 1261
	     md.first_poll_chan = subchan;

005751  aa  6 00127 2361 00	ldq  	pr6|87		subchan
005752  aa  7 00056 7561 00	stq  	pr7|46		md.first_poll_chan
						STATEMENT 1 ON LINE 1262
	     md.last_poll_chan = subchan;

005753  aa  7 00057 7561 00	stq  	pr7|47		md.last_poll_chan
						STATEMENT 1 ON LINE 1263
	end;

005754  aa   000010 7100 04	tra  	8,ic		005764
						STATEMENT 1 ON LINE 1264
	else do;

						STATEMENT 1 ON LINE 1265
	     p = addr (md.mde_entry (md.last_poll_chan));

005755  aa  7 00057 2361 00	ldq  	pr7|47		md.last_poll_chan
005756  aa   000013 4020 07	mpy  	11,dl
005757  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
005760  aa  6 00356 6515 00	spri5	pr6|238		p
						STATEMENT 1 ON LINE 1266
	     p -> mde.next_poll_chan = subchan;

005761  aa  6 00127 2361 00	ldq  	pr6|87		subchan
005762  aa  5 00007 7561 00	stq  	pr5|7		mde.next_poll_chan
						STATEMENT 1 ON LINE 1267
	     md.last_poll_chan = subchan;

005763  aa  7 00057 7561 00	stq  	pr7|47		md.last_poll_chan
						STATEMENT 1 ON LINE 1268
	end;

						STATEMENT 1 ON LINE 1269
	mde.next_poll_chan = 0;

005764  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
005765  aa  5 00007 4501 00	stz  	pr5|7		mde.next_poll_chan
						STATEMENT 1 ON LINE 1270
	return;

005766  aa  6 00350 6101 00	rtcd 	pr6|232
						STATEMENT 1 ON LINE 1272
     end queue_poll;

  END PROCEDURE queue_poll
BEGIN PROCEDURE process_polls
ENTRY TO process_polls                                      STATEMENT 1 ON LINE 1274
process_polls: proc;

005767  aa  6 00360 6501 00	spri4	pr6|240
						STATEMENT 1 ON LINE 1276
	if md.output_in_progress then return;

005770  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
005771  aa  7 00102 2351 00	lda  	pr7|66		md.output_in_progress
005772  aa   004000 3150 03	cana 	2048,du
005773  aa   000002 6000 04	tze  	2,ic		005775
005774  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 1277
	if md.poll_in_progress then return;

005775  aa  7 00102 2351 00	lda  	pr7|66		md.poll_in_progress
005776  aa   010000 3150 03	cana 	4096,du
005777  aa   000002 6000 04	tze  	2,ic		006001
006000  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 1278
	if md.first_poll_chan ^= 0 then do;

006001  aa  7 00056 2361 00	ldq  	pr7|46		md.first_poll_chan
006002  aa   000015 6000 04	tze  	13,ic		006017
						STATEMENT 1 ON LINE 1279
	     subchan = md.first_poll_chan;

006003  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 1280
	     mdep = addr (md.mde_entry (subchan));

006004  aa   000013 4020 07	mpy  	11,dl
006005  aa  7 00070 3715 06	epp5 	pr7|56,ql		md.mde_entry
006006  aa  6 00174 6515 00	spri5	pr6|124		mdep
						STATEMENT 1 ON LINE 1281
	     md.first_poll_chan = mde.next_poll_chan;

006007  aa  5 00007 2361 00	ldq  	pr5|7		mde.next_poll_chan
006010  aa  7 00056 7561 00	stq  	pr7|46		md.first_poll_chan
						STATEMENT 1 ON LINE 1282
	     if md.first_poll_chan = 0 then md.last_poll_chan = 0;

006011  aa   000002 6010 04	tnz  	2,ic		006013
006012  aa  7 00057 4501 00	stz  	pr7|47		md.last_poll_chan
						STATEMENT 1 ON LINE 1283
	     md.poll_in_progress = "1"b;

006013  aa   010000 2350 03	lda  	4096,du
006014  aa  7 00102 2551 00	orsa 	pr7|66		md.poll_in_progress
						STATEMENT 1 ON LINE 1284
	     call poll;

006015  aa   000012 6700 04	tsp4 	10,ic		006027
						STATEMENT 1 ON LINE 1285
	     return;

006016  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 1286
	end;

						STATEMENT 1 ON LINE 1288
	if md.first_write_chan = 0 then call general_poll;

006017  aa  7 00052 2361 00	ldq  	pr7|42		md.first_write_chan
006020  aa   000002 6010 04	tnz  	2,ic		006022
006021  aa   000177 6700 04	tsp4 	127,ic		006220
						STATEMENT 1 ON LINE 1289
	return;

006022  aa  6 00360 6101 00	rtcd 	pr6|240
						STATEMENT 1 ON LINE 1291
     end process_polls;

  END PROCEDURE process_polls
BEGIN PROCEDURE poll
PROLOGUE SEQUENCE
006023  aa  6 01014 4401 00	sxl0 	pr6|524
						STATEMENT 1 ON LINE 1297
006024  aa  6 00374 4501 00	stz  	pr6|252		auto_poll
006025  aa  6 01014 7201 00	lxl0 	pr6|524
006026  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO poll                                               STATEMENT 1 ON LINE 1295
poll: proc;

006027  aa  6 00366 6501 00	spri4	pr6|246
006030  aa   777773 7000 04	tsx0 	-5,ic		006023
						STATEMENT 1 ON LINE 1301
	dev = mde.device_address;

006031  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006032  aa  7 00002 2351 00	lda  	pr7|2		mde.device_address
006033  aa  6 00376 7551 00	sta  	pr6|254		dev
						STATEMENT 1 ON LINE 1302
poll_join:
	line_ctl.op = SET_POLLING_ADDR;

006034  aa   000007 2350 03	lda  	7,du
006035  aa  6 00166 5511 60	stba 	pr6|118,60	line_ctl.op
						STATEMENT 1 ON LINE 1304
	cont = md.controller_poll_address;

006036  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006037  aa  7 00016 2351 00	lda  	pr7|14		md.controller_poll_address
006040  aa  6 00375 7551 00	sta  	pr6|253		cont
						STATEMENT 1 ON LINE 1306
	if dev ^= md.last_poll_address then do;

006041  aa  6 00376 2351 00	lda  	pr6|254		dev
006042  aa  7 00046 1151 00	cmpa 	pr7|38		md.last_poll_address
006043  aa   000074 6000 04	tze  	60,ic		006137
						STATEMENT 1 ON LINE 1307
	     md.last_poll_address = dev;

006044  aa  7 00046 7551 00	sta  	pr7|38		md.last_poll_address
						STATEMENT 1 ON LINE 1308
select_join:   line_ctl.val = 0;

006045  aa   000001 2360 07	ldq  	1,dl
006046  aa  6 00377 7561 00	stq  	pr6|255
006047  aa   000000 0110 03	nop  	0,du
006050  aa  6 00377 2361 00	ldq  	pr6|255
006051  aa   000022 4020 07	mpy  	18,dl
006052  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
006053  aa   772067 00 0022	descb	-3017,18		000141 = 000000000000
006054  aa  6 00166 00 0022	descb	pr6|118,18	line_ctl.val
006055  aa  6 00377 2361 00	ldq  	pr6|255
006056  aa  6 00377 0541 00	aos  	pr6|255
006057  aa   000003 1160 07	cmpq 	3,dl
006060  aa   777770 6040 04	tmi  	-8,ic		006050
						STATEMENT 1 ON LINE 1309
	     valchar.data_len = 4;

006061  aa   004000 2350 07	lda  	2048,dl
006062  aa  6 00166 5511 10	stba 	pr6|118,10	valchar.data_len
						STATEMENT 1 ON LINE 1310
	     substr (valchar.data, 1, 1) = cont;

006063  aa   000022 7270 07	lxl7 	18,dl
006064  aa  6 00166 3735 00	epp7 	pr6|118		line_ctl.val
006065  aa  7 00000 5035 17	abd  	pr7|0,7
006066  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006067  aa  6 00375 00 0001	desc9a	pr6|253,1		cont
006070  aa  7 00000 20 0001	desc9a	pr7|0(1),1	valchar.data
						STATEMENT 1 ON LINE 1311
	     substr (valchar.data, 2, 1) = cont;

006071  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006072  aa  6 00375 00 0001	desc9a	pr6|253,1		cont
006073  aa  7 00000 40 0001	desc9a	pr7|0(2),1	valchar.data
						STATEMENT 1 ON LINE 1312
	     substr (valchar.data, 3, 1) = dev;

006074  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006075  aa  6 00376 00 0001	desc9a	pr6|254,1		dev
006076  aa  7 00000 60 0001	desc9a	pr7|0(3),1	valchar.data
						STATEMENT 1 ON LINE 1313
	     substr (valchar.data, 4, 1) = dev;

006077  aa  040 100 100 500	mlr  	(pr),(pr),fill(040)
006100  aa  6 00376 00 0001	desc9a	pr6|254,1		dev
006101  aa  7 00001 00 0001	desc9a	pr7|1,1		valchar.data
						STATEMENT 1 ON LINE 1314
	     call channel_manager$control (md.devx, "line_control", addr (line_ctl), code);

006102  aa   772076 2370 04	ldaq 	-3010,ic		000200 = 154151156145 137143157156
006103  aa  6 01016 7571 00	staq 	pr6|526
006104  aa   772076 2350 04	lda  	-3010,ic		000202 = 164162157154
006105  aa  6 01020 7551 00	sta  	pr6|528
006106  aa  6 00166 3715 00	epp5 	pr6|118		line_ctl
006107  aa  6 01022 6515 00	spri5	pr6|530
006110  aa  6 00172 3535 20	epp3 	pr6|122,*		mdp
006111  aa  3 00003 3521 00	epp2 	pr3|3		md.devx
006112  aa  6 01026 2521 00	spri2	pr6|534
006113  aa  6 01016 3521 00	epp2 	pr6|526
006114  aa  6 01030 2521 00	spri2	pr6|536
006115  aa  6 01022 3521 00	epp2 	pr6|530
006116  aa  6 01032 2521 00	spri2	pr6|538
006117  aa  6 00101 3521 00	epp2 	pr6|65		code
006120  aa  6 01034 2521 00	spri2	pr6|540
006121  aa   772035 3520 04	epp2 	-3043,ic		000156 = 404000000021
006122  aa  6 01036 2521 00	spri2	pr6|542
006123  aa   771775 3520 04	epp2 	-3075,ic		000120 = 524000000014
006124  aa  6 01040 2521 00	spri2	pr6|544
006125  aa   772033 3520 04	epp2 	-3045,ic		000160 = 464000000000
006126  aa  6 01042 2521 00	spri2	pr6|546
006127  aa   772021 3520 04	epp2 	-3055,ic		000150 = 404000000043
006130  aa  6 01044 2521 00	spri2	pr6|548
006131  aa  6 01024 6211 00	eax1 	pr6|532
006132  aa   020000 4310 07	fld  	8192,dl
006133  aa  6 00044 3701 20	epp4 	pr6|36,*
006134  la  4 00040 3521 20	epp2 	pr4|32,*		channel_manager$control
006135  aa  6 01046 6535 00	spri7	pr6|550
006136  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1315
	end;

						STATEMENT 1 ON LINE 1317
	if line_ctl.op = SET_POLLING_ADDR then do;

006137  aa  6 00166 2351 00	lda  	pr6|118		line_ctl.op
006140  aa   000066 7330 00	lrs  	54
006141  aa   000007 1160 07	cmpq 	7,dl
006142  aa   000055 6010 04	tnz  	45,ic		006217
						STATEMENT 1 ON LINE 1318
	     line_ctl.op = START_POLL;

006143  aa   000010 2350 03	lda  	8,du
006144  aa  6 00166 5511 60	stba 	pr6|118,60	line_ctl.op
						STATEMENT 1 ON LINE 1319
	     line_ctl.val = 0;

006145  aa   000001 2360 07	ldq  	1,dl
006146  aa  6 00377 7561 00	stq  	pr6|255
006147  aa   000000 0110 03	nop  	0,du
006150  aa  6 00377 2361 00	ldq  	pr6|255
006151  aa   000022 4020 07	mpy  	18,dl
006152  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
006153  aa   771767 00 0022	descb	-3081,18		000141 = 000000000000
006154  aa  6 00166 00 0022	descb	pr6|118,18	line_ctl.val
006155  aa  6 00377 2361 00	ldq  	pr6|255
006156  aa  6 00377 0541 00	aos  	pr6|255
006157  aa   000003 1160 07	cmpq 	3,dl
006160  aa   777770 6040 04	tmi  	-8,ic		006150
						STATEMENT 1 ON LINE 1320
	     line_ctl.val (1) = auto_poll;

006161  aa  6 00374 2361 00	ldq  	pr6|252		auto_poll
006162  aa  6 00166 5521 14	stbq 	pr6|118,14	line_ctl.val
						STATEMENT 1 ON LINE 1321
	     call channel_manager$control (md.devx, "line_control", addr (line_ctl), code);

006163  aa   772015 2370 04	ldaq 	-3059,ic		000200 = 154151156145 137143157156
006164  aa  6 01016 7571 00	staq 	pr6|526
006165  aa   772015 2350 04	lda  	-3059,ic		000202 = 164162157154
006166  aa  6 01020 7551 00	sta  	pr6|528
006167  aa  6 00166 3735 00	epp7 	pr6|118		line_ctl
006170  aa  6 01022 6535 00	spri7	pr6|530
006171  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006172  aa  5 00003 3521 00	epp2 	pr5|3		md.devx
006173  aa  6 01026 2521 00	spri2	pr6|534
006174  aa  6 01016 3521 00	epp2 	pr6|526
006175  aa  6 01030 2521 00	spri2	pr6|536
006176  aa  6 01022 3521 00	epp2 	pr6|530
006177  aa  6 01032 2521 00	spri2	pr6|538
006200  aa  6 00101 3521 00	epp2 	pr6|65		code
006201  aa  6 01034 2521 00	spri2	pr6|540
006202  aa   771754 3520 04	epp2 	-3092,ic		000156 = 404000000021
006203  aa  6 01036 2521 00	spri2	pr6|542
006204  aa   771714 3520 04	epp2 	-3124,ic		000120 = 524000000014
006205  aa  6 01040 2521 00	spri2	pr6|544
006206  aa   771752 3520 04	epp2 	-3094,ic		000160 = 464000000000
006207  aa  6 01042 2521 00	spri2	pr6|546
006210  aa   771740 3520 04	epp2 	-3104,ic		000150 = 404000000043
006211  aa  6 01044 2521 00	spri2	pr6|548
006212  aa  6 01024 6211 00	eax1 	pr6|532
006213  aa   020000 4310 07	fld  	8192,dl
006214  aa  6 00044 3701 20	epp4 	pr6|36,*
006215  la  4 00040 3521 20	epp2 	pr4|32,*		channel_manager$control
006216  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1322
	end;

						STATEMENT 1 ON LINE 1323
	return;

006217  aa  6 00366 6101 00	rtcd 	pr6|246
ENTRY TO general_poll                                       STATEMENT 1 ON LINE 1325
general_poll: entry;

006220  aa  6 00366 6501 00	spri4	pr6|246
006221  aa   777602 7000 04	tsx0 	-126,ic		006023
						STATEMENT 1 ON LINE 1327
	dev = md.general_poll_address;

006222  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006223  aa  7 00020 2351 00	lda  	pr7|16		md.general_poll_address
006224  aa  6 00376 7551 00	sta  	pr6|254		dev
						STATEMENT 1 ON LINE 1328
	auto_poll = 1;

006225  aa   000001 2360 07	ldq  	1,dl
006226  aa  6 00374 7561 00	stq  	pr6|252		auto_poll
						STATEMENT 1 ON LINE 1329
	go to poll_join;

006227  aa   777605 7100 04	tra  	-123,ic		006034
ENTRY TO select                                             STATEMENT 1 ON LINE 1331
select: entry;

006230  aa  6 00366 6501 00	spri4	pr6|246
006231  aa   777572 7000 04	tsx0 	-134,ic		006023
						STATEMENT 1 ON LINE 1333
	dev = mde.device_address;

006232  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006233  aa  7 00002 2351 00	lda  	pr7|2		mde.device_address
006234  aa  6 00376 7551 00	sta  	pr6|254		dev
						STATEMENT 1 ON LINE 1334
	if dev = md.last_select_address then return;

006235  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006236  aa  5 00051 1151 00	cmpa 	pr5|41		md.last_select_address
006237  aa   000002 6010 04	tnz  	2,ic		006241
006240  aa  6 00366 6101 00	rtcd 	pr6|246
						STATEMENT 1 ON LINE 1335
	md.last_select_address = dev;

006241  aa  5 00051 7551 00	sta  	pr5|41		md.last_select_address
						STATEMENT 1 ON LINE 1336
	cont = md.controller_select_address;

006242  aa  5 00017 2351 00	lda  	pr5|15		md.controller_select_address
006243  aa  6 00375 7551 00	sta  	pr6|253		cont
						STATEMENT 1 ON LINE 1337
	line_ctl.op = SET_SELECT_ADDR;

006244  aa   000011 2350 03	lda  	9,du
006245  aa  6 00166 5511 60	stba 	pr6|118,60	line_ctl.op
						STATEMENT 1 ON LINE 1338
	go to select_join;

006246  aa   777577 7100 04	tra  	-129,ic		006045
						STATEMENT 1 ON LINE 1340
     end poll;

  END PROCEDURE poll
BEGIN PROCEDURE queue_control
ENTRY TO queue_control                                      STATEMENT 1 ON LINE 1344
queue_control: proc;

006247  aa  6 00400 6501 00	spri4	pr6|256
						STATEMENT 1 ON LINE 1348
	if mde.control_queued then return;

006250  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006251  aa  7 00012 2351 00	lda  	pr7|10		mde.control_queued
006252  aa   002000 3150 03	cana 	1024,du
006253  aa   000002 6000 04	tze  	2,ic		006255
006254  aa  6 00400 6101 00	rtcd 	pr6|256
						STATEMENT 1 ON LINE 1349
	if md.first_control_chan = 0 then do;

006255  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006256  aa  5 00047 2361 00	ldq  	pr5|39		md.first_control_chan
006257  aa   000005 6010 04	tnz  	5,ic		006264
						STATEMENT 1 ON LINE 1350
	     md.first_control_chan = subchan;

006260  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006261  aa  5 00047 7561 00	stq  	pr5|39		md.first_control_chan
						STATEMENT 1 ON LINE 1351
	     md.last_control_chan = subchan;

006262  aa  5 00050 7561 00	stq  	pr5|40		md.last_control_chan
						STATEMENT 1 ON LINE 1352
	end;

006263  aa   000010 7100 04	tra  	8,ic		006273
						STATEMENT 1 ON LINE 1353
	else do;

						STATEMENT 1 ON LINE 1354
	     p = addr (md.mde_entry (md.last_control_chan));

006264  aa  5 00050 2361 00	ldq  	pr5|40		md.last_control_chan
006265  aa   000013 4020 07	mpy  	11,dl
006266  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
006267  aa  6 00406 2535 00	spri3	pr6|262		p
						STATEMENT 1 ON LINE 1355
	     p -> mde.next_control_chan = subchan;

006270  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006271  aa  3 00010 7561 00	stq  	pr3|8		mde.next_control_chan
						STATEMENT 1 ON LINE 1356
	     md.last_control_chan = subchan;

006272  aa  5 00050 7561 00	stq  	pr5|40		md.last_control_chan
						STATEMENT 1 ON LINE 1357
	end;

						STATEMENT 1 ON LINE 1358
	mde.next_control_chan = 0;

006273  aa  7 00010 4501 00	stz  	pr7|8		mde.next_control_chan
						STATEMENT 1 ON LINE 1359
	mde.control_queued = "1"b;

006274  aa   002000 2350 03	lda  	1024,du
006275  aa  7 00012 2551 00	orsa 	pr7|10		mde.control_queued
						STATEMENT 1 ON LINE 1360
	return;

006276  aa  6 00400 6101 00	rtcd 	pr6|256
						STATEMENT 1 ON LINE 1362
     end queue_control;

  END PROCEDURE queue_control
BEGIN PROCEDURE setup_control_chan
ENTRY TO setup_control_chan                                 STATEMENT 1 ON LINE 1366
setup_control_chan: proc;

006277  aa  6 00410 6501 00	spri4	pr6|264
						STATEMENT 1 ON LINE 1371
	prev_subchan = 0;

006300  aa  6 00416 4501 00	stz  	pr6|270		prev_subchan
						STATEMENT 1 ON LINE 1372
	subchan = md.first_control_chan;

006301  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006302  aa  7 00047 2361 00	ldq  	pr7|39		md.first_control_chan
006303  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 1373
search_control_queue:
	if subchan = 0 then do;

006304  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006305  aa   000004 6010 04	tnz  	4,ic		006311
						STATEMENT 1 ON LINE 1375
	     mdep = null ();

006306  aa   771656 2370 04	ldaq 	-3154,ic		000164 = 077777000043 000001000000
006307  aa  6 00174 7571 00	staq 	pr6|124		mdep
						STATEMENT 1 ON LINE 1376
	     return;

006310  aa  6 00410 6101 00	rtcd 	pr6|264
						STATEMENT 1 ON LINE 1377
	end;

						STATEMENT 1 ON LINE 1378
	mdep = addr (md.mde_entry (subchan));

006311  aa   000013 4020 07	mpy  	11,dl
006312  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006313  aa  7 00070 3735 06	epp7 	pr7|56,ql		md.mde_entry
006314  aa  6 00174 6535 00	spri7	pr6|124		mdep
						STATEMENT 1 ON LINE 1379
	if mde.write_chain_ptr ^= null () then do;

006315  aa  7 00011 2361 00	ldq  	pr7|9		mde.write_chain_ptr
006316  aa   000622 1160 04	cmpq 	402,ic		007140 = 007777000001
006317  aa   000006 6000 04	tze  	6,ic		006325
						STATEMENT 1 ON LINE 1380
	     prev_subchan = subchan;

006320  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006321  aa  6 00416 7561 00	stq  	pr6|270		prev_subchan
						STATEMENT 1 ON LINE 1381
	     subchan = mde.next_control_chan;

006322  aa  7 00010 2361 00	ldq  	pr7|8		mde.next_control_chan
006323  aa  6 00127 7561 00	stq  	pr6|87		subchan
						STATEMENT 1 ON LINE 1382
	     go to search_control_queue;

006324  aa   777760 7100 04	tra  	-16,ic		006304
						STATEMENT 1 ON LINE 1383
	end;

						STATEMENT 1 ON LINE 1385
	call tty_space_man$get_buffer (mde.devx, 16, OUTPUT, blockp);

006325  aa   000020 2360 07	ldq  	16,dl
006326  aa  6 01050 7561 00	stq  	pr6|552
006327  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
006330  aa  6 01054 2521 00	spri2	pr6|556
006331  aa  6 01050 3521 00	epp2 	pr6|552
006332  aa  6 01056 2521 00	spri2	pr6|558
006333  aa   771607 3520 04	epp2 	-3193,ic		000142 = 400000000000
006334  aa  6 01060 2521 00	spri2	pr6|560
006335  aa  6 00160 3521 00	epp2 	pr6|112		blockp
006336  aa  6 01062 2521 00	spri2	pr6|562
006337  aa  6 01052 6211 00	eax1 	pr6|554
006340  aa   020000 4310 07	fld  	8192,dl
006341  aa  6 00044 3701 20	epp4 	pr6|36,*
006342  la  4 00044 3521 20	epp2 	pr4|36,*		tty_space_man$get_buffer
006343  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1386
	if blockp = null () then do;

006344  aa  6 00160 2371 00	ldaq 	pr6|112		blockp
006345  aa   771617 6770 04	eraq 	-3185,ic		000164 = 077777000043 000001000000
006346  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
006347  aa   000020 6010 04	tnz  	16,ic		006367
						STATEMENT 1 ON LINE 1387
	     md.needs_space = md.needs_space + 1;

006350  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006351  aa  7 00073 2351 00	lda  	pr7|59		md.needs_space
006352  aa   000044 7330 00	lrs  	36
006353  aa   000001 0330 07	adl  	1,dl
006354  aa  7 00073 7561 00	stq  	pr7|59		md.needs_space
						STATEMENT 1 ON LINE 1388
	     call tty_space_man$needs_space (md.devx);

006355  aa  7 00003 3521 00	epp2 	pr7|3		md.devx
006356  aa  6 01054 2521 00	spri2	pr6|556
006357  aa  6 01052 6211 00	eax1 	pr6|554
006360  aa   004000 4310 07	fld  	2048,dl
006361  aa  6 00044 3701 20	epp4 	pr6|36,*
006362  la  4 00052 3521 20	epp2 	pr4|42,*		tty_space_man$needs_space
006363  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1389
	     mdep = null ();

006364  aa   771600 2370 04	ldaq 	-3200,ic		000164 = 077777000043 000001000000
006365  aa  6 00174 7571 00	staq 	pr6|124		mdep
						STATEMENT 1 ON LINE 1390
	     return;

006366  aa  6 00410 6101 00	rtcd 	pr6|264
						STATEMENT 1 ON LINE 1391
	end;

						STATEMENT 1 ON LINE 1393
	if prev_subchan = 0 then do;

006367  aa  6 00416 2361 00	ldq  	pr6|270		prev_subchan
006370  aa   000010 6010 04	tnz  	8,ic		006400
						STATEMENT 1 ON LINE 1394
	     md.first_control_chan = mde.next_control_chan;

006371  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006372  aa  7 00010 2361 00	ldq  	pr7|8		mde.next_control_chan
006373  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006374  aa  5 00047 7561 00	stq  	pr5|39		md.first_control_chan
						STATEMENT 1 ON LINE 1395
	     if md.first_control_chan = 0 then md.last_control_chan = 0;

006375  aa   000020 6010 04	tnz  	16,ic		006415
006376  aa  5 00050 4501 00	stz  	pr5|40		md.last_control_chan
						STATEMENT 1 ON LINE 1396
	end;

006377  aa   000016 7100 04	tra  	14,ic		006415
						STATEMENT 1 ON LINE 1397
	else do;

						STATEMENT 1 ON LINE 1398
	     p = addr (md.mde_entry (prev_subchan));

006400  aa   000013 4020 07	mpy  	11,dl
006401  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006402  aa  7 00070 3735 06	epp7 	pr7|56,ql		md.mde_entry
006403  aa  6 00420 6535 00	spri7	pr6|272		p
						STATEMENT 1 ON LINE 1399
	     p -> mde.next_control_chan = mde.next_control_chan;

006404  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
006405  aa  5 00010 2361 00	ldq  	pr5|8		mde.next_control_chan
006406  aa  7 00010 7561 00	stq  	pr7|8		mde.next_control_chan
						STATEMENT 1 ON LINE 1400
	     if md.last_control_chan = subchan then md.last_control_chan = prev_subchan;

006407  aa  6 00172 3535 20	epp3 	pr6|122,*		mdp
006410  aa  3 00050 2361 00	ldq  	pr3|40		md.last_control_chan
006411  aa  6 00127 1161 00	cmpq 	pr6|87		subchan
006412  aa   000003 6010 04	tnz  	3,ic		006415
006413  aa  6 00416 2361 00	ldq  	pr6|270		prev_subchan
006414  aa  3 00050 7561 00	stq  	pr3|40		md.last_control_chan
						STATEMENT 1 ON LINE 1401
	end;

						STATEMENT 1 ON LINE 1402
	mde.next_control_chan = 0;

006415  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006416  aa  7 00010 4501 00	stz  	pr7|8		mde.next_control_chan
						STATEMENT 1 ON LINE 1403
	mde.control_queued = "0"b;

006417  aa   000465 2350 04	lda  	309,ic		007104 = 775777777777
006420  aa  7 00012 3551 00	ansa 	pr7|10		mde.control_queued
						STATEMENT 1 ON LINE 1405
	call build_header;

006421  aa   776336 6700 04	tsp4 	-802,ic		004757
						STATEMENT 1 ON LINE 1406
	call check_buffer_tally (2);

006422  aa   000002 2360 07	ldq  	2,dl
006423  aa  6 01050 7561 00	stq  	pr6|552
006424  aa   000442 3520 04	epp2 	290,ic		007066 = 000002000000
006425  aa   000367 6700 04	tsp4 	247,ic		007014
						STATEMENT 1 ON LINE 1407
	buffer.chars (buffer.tally) = md.ic;

006426  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
006427  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
006430  aa  6 00160 3735 20	epp7 	pr6|112,*		blockp
006431  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006432  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
006433  aa  5 00026 40 0001	desc9a	pr5|22(2),1	md.ic
006434  aa  7 00001 00 0001	desc9a	pr7|1,1		buffer.chars
						STATEMENT 1 ON LINE 1408
	buffer.chars (buffer.tally + 1) = md.etx;

006435  aa  040 106 100 500	mlr  	(pr),(pr,ql),fill(040)
006436  aa  5 00026 60 0001	desc9a	pr5|22(3),1	md.etx
006437  aa  7 00001 20 0001	desc9a	pr7|1(1),1	buffer.chars
						STATEMENT 1 ON LINE 1409
	buffer.tally = buffer.tally + 2;

006440  aa   000002 0760 07	adq  	2,dl
006441  aa  7 00000 5521 04	stbq 	pr7|0,04		buffer.tally
						STATEMENT 1 ON LINE 1410
	mde.write_chain_ptr = blockp;

006442  aa  6 00174 3535 20	epp3 	pr6|124,*		mdep
006443  aa  3 00011 5471 00	sprp7	pr3|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 1411
	return;

006444  aa  6 00410 6101 00	rtcd 	pr6|264
						STATEMENT 1 ON LINE 1413
     end setup_control_chan;

  END PROCEDURE setup_control_chan
BEGIN PROCEDURE crash_mpx
ENTRY TO crash_mpx                                          STATEMENT 1 ON LINE 1417
crash_mpx: proc;

006445  aa  6 00422 6501 00	spri4	pr6|274
						STATEMENT 1 ON LINE 1421
	loaded = md.loaded;

006446  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006447  aa  7 00102 2351 00	lda  	pr7|66		md.loaded
006450  aa   000003 7350 00	als  	3
006451  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
006452  aa  6 00430 7551 00	sta  	pr6|280		loaded
						STATEMENT 1 ON LINE 1422
	md.loaded, md.loading = "0"b;

006453  aa   000471 2350 04	lda  	313,ic		007144 = 737777777777
006454  aa  7 00102 3551 00	ansa 	pr7|66		md.loaded
006455  aa   000470 2350 04	lda  	312,ic		007145 = 677777777777
006456  aa  7 00102 3551 00	ansa 	pr7|66		md.loading
						STATEMENT 1 ON LINE 1424
	if loaded then do subchan = 1 to md.nchan;

006457  aa  6 00430 2351 00	lda  	pr6|280		loaded
006460  aa   000041 6000 04	tze  	33,ic		006521
006461  aa  7 00014 2361 00	ldq  	pr7|12		md.nchan
006462  aa  6 00431 7561 00	stq  	pr6|281
006463  aa   000001 2360 07	ldq  	1,dl
006464  aa  6 00127 7561 00	stq  	pr6|87		subchan
006465  aa   000000 0110 03	nop  	0,du
006466  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006467  aa  6 00431 1161 00	cmpq 	pr6|281
006470  aa   000031 6054 04	tpnz 	25,ic		006521
						STATEMENT 1 ON LINE 1425
	     mdep = addr (md.mde_entry (subchan));

006471  aa   000013 4020 07	mpy  	11,dl
006472  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006473  aa  7 00070 3735 06	epp7 	pr7|56,ql		md.mde_entry
006474  aa  6 00174 6535 00	spri7	pr6|124		mdep
						STATEMENT 1 ON LINE 1426
	     mde.listen, mde.dialed = "0"b;

006475  aa   000452 2350 04	lda  	298,ic		007147 = 377777777777
006476  aa  7 00012 3551 00	ansa 	pr7|10		mde.listen
006477  aa   000447 2350 04	lda  	295,ic		007146 = 577777777777
006500  aa  7 00012 3551 00	ansa 	pr7|10		mde.dialed
						STATEMENT 1 ON LINE 1427
	     call reset_channel;

006501  aa   000120 6700 04	tsp4 	80,ic		006621
						STATEMENT 1 ON LINE 1428
	     call channel_manager$interrupt (mde.devx, CRASH, "0"b);

006502  aa   771464 2370 04	ldaq 	-3276,ic		000166 = 000000000000 000000000000
006503  aa  6 01064 7571 00	staq 	pr6|564
006504  aa  6 00174 3521 20	epp2 	pr6|124,*		mde.devx
006505  aa  6 01070 2521 00	spri2	pr6|568
006506  aa   771445 3520 04	epp2 	-3291,ic		000153 = 000000000003
006507  aa  6 01072 2521 00	spri2	pr6|570
006510  aa  6 01064 3521 00	epp2 	pr6|564
006511  aa  6 01074 2521 00	spri2	pr6|572
006512  aa  6 01066 6211 00	eax1 	pr6|566
006513  aa   014000 4310 07	fld  	6144,dl
006514  aa  6 00044 3701 20	epp4 	pr6|36,*
006515  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
006516  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1429
	end;

006517  aa  6 00127 0541 00	aos  	pr6|87		subchan
006520  aa   777746 7100 04	tra  	-26,ic		006466
						STATEMENT 1 ON LINE 1431
	return;

006521  aa  6 00422 6101 00	rtcd 	pr6|274
						STATEMENT 1 ON LINE 1433
     end crash_mpx;

  END PROCEDURE crash_mpx
BEGIN PROCEDURE dialup_channel
ENTRY TO dialup_channel                                     STATEMENT 1 ON LINE 1435
dialup_channel: proc;

006522  aa  6 00432 6501 00	spri4	pr6|282
						STATEMENT 1 ON LINE 1437
	mde.position = 0;

006523  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006524  aa  7 00005 4501 00	stz  	pr7|5		mde.position
						STATEMENT 1 ON LINE 1438
	if ^mde.printer then do;

006525  aa  7 00012 2351 00	lda  	pr7|10		mde.printer
006526  aa   100000 3150 03	cana 	32768,du
006527  aa   000004 6010 04	tnz  	4,ic		006533
						STATEMENT 1 ON LINE 1439
	     mde.erase_req = "1"b;

006530  aa   010000 2350 03	lda  	4096,du
006531  aa  7 00012 2551 00	orsa 	pr7|10		mde.erase_req
						STATEMENT 1 ON LINE 1440
	     call queue_control;

006532  aa   777515 6700 04	tsp4 	-179,ic		006247
						STATEMENT 1 ON LINE 1441
	end;

						STATEMENT 1 ON LINE 1442
	unspec (dialup_info) = "0"b;

006533  aa   771433 2370 04	ldaq 	-3301,ic		000166 = 000000000000 000000000000
006534  aa  6 00154 7571 00	staq 	pr6|108
						STATEMENT 1 ON LINE 1443
	dialup_info.line_type = md.line_type;

006535  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006536  aa  7 00021 2361 00	ldq  	pr7|17		md.line_type
006537  aa   000077 7370 00	lls  	63
006540  aa  6 00154 5511 40	stba 	pr6|108,40	dialup_info.line_type
						STATEMENT 1 ON LINE 1444
	dialup_info.baud_rate = md.baud_rate;

006541  aa  7 00022 2361 00	ldq  	pr7|18		md.baud_rate
006542  aa  6 00154 5521 14	stbq 	pr6|108,14	dialup_info.baud_rate
						STATEMENT 1 ON LINE 1445
	dialup_info.max_buf_size = md.max_buf_size;

006543  aa  7 00023 2361 00	ldq  	pr7|19		md.max_buf_size
006544  aa   000077 7370 00	lls  	63
006545  aa  6 00155 5511 40	stba 	pr6|109,40	dialup_info.max_buf_size
						STATEMENT 1 ON LINE 1446
	dialup_info.buffer_pad = md.buffer_pad + 4;

006546  aa  7 00024 2361 00	ldq  	pr7|20		md.buffer_pad
006547  aa   000004 0760 07	adq  	4,dl
006550  aa   000066 7370 00	lls  	54
006551  aa  6 00154 5511 20	stba 	pr6|108,20	dialup_info.buffer_pad
						STATEMENT 1 ON LINE 1447
	dialup_info.receive_mode_device = ^mde.printer;

006552  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
006553  aa  5 00012 2351 00	lda  	pr5|10		mde.printer
006554  aa   000002 7350 00	als  	2
006555  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
006556  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
006557  aa   000011 7710 00	arl  	9
006560  aa  6 00155 6751 00	era  	pr6|109		dialup_info.receive_mode_device
006561  aa   000400 3750 03	ana  	256,du
006562  aa  6 00155 6551 00	ersa 	pr6|109		dialup_info.receive_mode_device
						STATEMENT 1 ON LINE 1448
	call channel_manager$interrupt (mde.devx, DIALUP, unspec (dialup_info));

006563  aa  6 00154 2371 00	ldaq 	pr6|108
006564  aa  6 01076 7571 00	staq 	pr6|574
006565  aa  5 00000 3521 00	epp2 	pr5|0		mde.devx
006566  aa  6 01102 2521 00	spri2	pr6|578
006567  aa   771370 3520 04	epp2 	-3336,ic		000157 = 000000000001
006570  aa  6 01104 2521 00	spri2	pr6|580
006571  aa  6 01076 3521 00	epp2 	pr6|574
006572  aa  6 01106 2521 00	spri2	pr6|582
006573  aa  6 01100 6211 00	eax1 	pr6|576
006574  aa   014000 4310 07	fld  	6144,dl
006575  aa  6 00044 3701 20	epp4 	pr6|36,*
006576  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
006577  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1449
	mde.dialed = "1"b;

006600  aa   200000 2350 03	lda  	65536,du
006601  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006602  aa  7 00012 2551 00	orsa 	pr7|10		mde.dialed
						STATEMENT 1 ON LINE 1450
	call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

006603  aa   771363 2370 04	ldaq 	-3341,ic		000166 = 000000000000 000000000000
006604  aa  6 01076 7571 00	staq 	pr6|574
006605  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
006606  aa  6 01102 2521 00	spri2	pr6|578
006607  aa   771342 3520 04	epp2 	-3358,ic		000151 = 000000000004
006610  aa  6 01104 2521 00	spri2	pr6|580
006611  aa  6 01076 3521 00	epp2 	pr6|574
006612  aa  6 01106 2521 00	spri2	pr6|582
006613  aa  6 01100 6211 00	eax1 	pr6|576
006614  aa   014000 4310 07	fld  	6144,dl
006615  aa  6 00044 3701 20	epp4 	pr6|36,*
006616  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
006617  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1451
	return;

006620  aa  6 00432 6101 00	rtcd 	pr6|282
						STATEMENT 1 ON LINE 1453
     end dialup_channel;

  END PROCEDURE dialup_channel
BEGIN PROCEDURE reset_channel
ENTRY TO reset_channel                                      STATEMENT 1 ON LINE 1455
reset_channel: proc;

006621  aa  6 00440 6501 00	spri4	pr6|288
						STATEMENT 1 ON LINE 1461
	if mde.write_chain_ptr = null () then return;

006622  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006623  aa  7 00011 2361 00	ldq  	pr7|9		mde.write_chain_ptr
006624  aa   000314 1160 04	cmpq 	204,ic		007140 = 007777000001
006625  aa   000002 6010 04	tnz  	2,ic		006627
006626  aa  6 00440 6101 00	rtcd 	pr6|288
						STATEMENT 1 ON LINE 1462
	p = mde.write_chain_ptr;

006627  aa  7 00011 7651 00	lprp5	pr7|9		mde.write_chain_ptr
006630  aa  6 00446 6515 00	spri5	pr6|294		p
						STATEMENT 1 ON LINE 1463
	mde.write_chain_ptr = null ();

006631  aa   000307 2360 04	ldq  	199,ic		007140 = 007777000001
006632  aa  7 00011 7561 00	stq  	pr7|9		mde.write_chain_ptr
						STATEMENT 1 ON LINE 1464
	call tty_space_man$free_chain (mde.devx, OUTPUT, p);

006633  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
006634  aa  6 01112 2521 00	spri2	pr6|586
006635  aa   771305 3520 04	epp2 	-3387,ic		000142 = 400000000000
006636  aa  6 01114 2521 00	spri2	pr6|588
006637  aa  6 00446 3521 00	epp2 	pr6|294		p
006640  aa  6 01116 2521 00	spri2	pr6|590
006641  aa  6 01110 6211 00	eax1 	pr6|584
006642  aa   014000 4310 07	fld  	6144,dl
006643  aa  6 00044 3701 20	epp4 	pr6|36,*
006644  la  4 00050 3521 20	epp2 	pr4|40,*		tty_space_man$free_chain
006645  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1465
	if ^mde.write_queued then return;

006646  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006647  aa  7 00012 2351 00	lda  	pr7|10		mde.write_queued
006650  aa   000010 3150 03	cana 	8,du
006651  aa   000002 6010 04	tnz  	2,ic		006653
006652  aa  6 00440 6101 00	rtcd 	pr6|288
						STATEMENT 1 ON LINE 1466
	if md.first_write_chan = 0 then goto reset_channel_failed;

006653  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006654  aa  5 00052 2361 00	ldq  	pr5|42		md.first_write_chan
006655  aa   000105 6000 04	tze  	69,ic		006762
						STATEMENT 1 ON LINE 1467
	if md.first_write_chan = subchan then do;

006656  aa  6 00127 1161 00	cmpq 	pr6|87		subchan
006657  aa   000006 6010 04	tnz  	6,ic		006665
						STATEMENT 1 ON LINE 1468
	     md.first_write_chan = mde.next_write_chan;

006660  aa  7 00006 2361 00	ldq  	pr7|6		mde.next_write_chan
006661  aa  5 00052 7561 00	stq  	pr5|42		md.first_write_chan
						STATEMENT 1 ON LINE 1469
	     if md.first_write_chan = 0 then md.last_write_chan = 0;

006662  aa   000044 6010 04	tnz  	36,ic		006726
006663  aa  5 00053 4501 00	stz  	pr5|43		md.last_write_chan
						STATEMENT 1 ON LINE 1470
	end;

006664  aa   000042 7100 04	tra  	34,ic		006726
						STATEMENT 1 ON LINE 1471
	else do;

						STATEMENT 1 ON LINE 1472
	     loop_count = 0;

006665  aa  6 00452 4501 00	stz  	pr6|298		loop_count
						STATEMENT 1 ON LINE 1473
	     q = addr (md.mde_entry (md.first_write_chan));

006666  aa   000013 4020 07	mpy  	11,dl
006667  aa  5 00070 3535 06	epp3 	pr5|56,ql		md.mde_entry
006670  aa  6 00450 2535 00	spri3	pr6|296		q
						STATEMENT 1 ON LINE 1474
	     save_subchan = md.first_write_chan;

006671  aa  5 00052 2361 00	ldq  	pr5|42		md.first_write_chan
006672  aa  6 00453 7561 00	stq  	pr6|299		save_subchan
						STATEMENT 1 ON LINE 1475
	     do while (q -> mde.next_write_chan ^= subchan);

006673  aa   000000 0110 03	nop  	0,du
006674  aa  6 00450 3735 20	epp7 	pr6|296,*		q
006675  aa  7 00006 2361 00	ldq  	pr7|6		mde.next_write_chan
006676  aa  6 00127 1161 00	cmpq 	pr6|87		subchan
006677  aa   000016 6000 04	tze  	14,ic		006715
						STATEMENT 1 ON LINE 1476
		save_subchan = q -> mde.next_write_chan;

006700  aa  6 00453 7561 00	stq  	pr6|299		save_subchan
						STATEMENT 1 ON LINE 1477
		q = addr (md.mde_entry (q -> mde.next_write_chan));

006701  aa   000013 4020 07	mpy  	11,dl
006702  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006703  aa  5 00070 3715 06	epp5 	pr5|56,ql		md.mde_entry
006704  aa  6 00450 6515 00	spri5	pr6|296		q
						STATEMENT 1 ON LINE 1479
		if loop_count > md.nchan | save_subchan = 0 then goto reset_channel_failed;

006705  aa  6 00452 2361 00	ldq  	pr6|298		loop_count
006706  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006707  aa  7 00014 1161 00	cmpq 	pr7|12		md.nchan
006710  aa   000052 6054 04	tpnz 	42,ic		006762
006711  aa  6 00453 2361 00	ldq  	pr6|299		save_subchan
006712  aa   000050 6000 04	tze  	40,ic		006762
						STATEMENT 1 ON LINE 1480
		loop_count = loop_count + 1;

006713  aa  6 00452 0541 00	aos  	pr6|298		loop_count
						STATEMENT 1 ON LINE 1481
	     end;

006714  aa   777760 7100 04	tra  	-16,ic		006674
						STATEMENT 1 ON LINE 1482
	     q -> mde.next_write_chan = mde.next_write_chan;

006715  aa  6 00174 3715 20	epp5 	pr6|124,*		mdep
006716  aa  5 00006 2361 00	ldq  	pr5|6		mde.next_write_chan
006717  aa  7 00006 7561 00	stq  	pr7|6		mde.next_write_chan
						STATEMENT 1 ON LINE 1483
	     if subchan = md.last_write_chan then md.last_write_chan = save_subchan;

006720  aa  6 00127 2361 00	ldq  	pr6|87		subchan
006721  aa  6 00172 3535 20	epp3 	pr6|122,*		mdp
006722  aa  3 00053 1161 00	cmpq 	pr3|43		md.last_write_chan
006723  aa   000003 6010 04	tnz  	3,ic		006726
006724  aa  6 00453 2361 00	ldq  	pr6|299		save_subchan
006725  aa  3 00053 7561 00	stq  	pr3|43		md.last_write_chan
						STATEMENT 1 ON LINE 1484
	end;

						STATEMENT 1 ON LINE 1485
reset_channel_restart:
	mde.next_write_chan = 0;

006726  aa  6 00174 3735 20	epp7 	pr6|124,*		mdep
006727  aa  7 00006 4501 00	stz  	pr7|6		mde.next_write_chan
						STATEMENT 1 ON LINE 1487
	mde.write_queued = "0"b;

006730  aa   000153 2350 04	lda  	107,ic		007103 = 777767777777
006731  aa  7 00012 3551 00	ansa 	pr7|10		mde.write_queued
						STATEMENT 1 ON LINE 1488
	mde.end_of_page = "0"b;

006732  aa   000150 2350 04	lda  	104,ic		007102 = 776777777777
006733  aa  7 00012 3551 00	ansa 	pr7|10		mde.end_of_page
						STATEMENT 1 ON LINE 1489
	if ^md.loaded | ^mde.dialed then return;

006734  aa  6 00172 3715 20	epp5 	pr6|122,*		mdp
006735  aa  5 00102 2351 00	lda  	pr5|66		md.loaded
006736  aa   040000 3150 03	cana 	16384,du
006737  aa   000004 6000 04	tze  	4,ic		006743
006740  aa  7 00012 2351 00	lda  	pr7|10		mde.dialed
006741  aa   200000 3150 03	cana 	65536,du
006742  aa   000002 6010 04	tnz  	2,ic		006744
006743  aa  6 00440 6101 00	rtcd 	pr6|288
						STATEMENT 1 ON LINE 1490
	call channel_manager$interrupt (mde.devx, SEND_OUTPUT, "0"b);

006744  aa   771222 2370 04	ldaq 	-3438,ic		000166 = 000000000000 000000000000
006745  aa  6 01120 7571 00	staq 	pr6|592
006746  aa  7 00000 3521 00	epp2 	pr7|0		mde.devx
006747  aa  6 01112 2521 00	spri2	pr6|586
006750  aa   771201 3520 04	epp2 	-3455,ic		000151 = 000000000004
006751  aa  6 01114 2521 00	spri2	pr6|588
006752  aa  6 01120 3521 00	epp2 	pr6|592
006753  aa  6 01116 2521 00	spri2	pr6|590
006754  aa  6 01110 6211 00	eax1 	pr6|584
006755  aa   014000 4310 07	fld  	6144,dl
006756  aa  6 00044 3701 20	epp4 	pr6|36,*
006757  la  4 00042 3521 20	epp2 	pr4|34,*		channel_manager$interrupt
006760  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 1491
	return;

006761  aa  6 00440 6101 00	rtcd 	pr6|288
						STATEMENT 1 ON LINE 1493
reset_channel_failed:

	call syserr (BEEP, "^a: Could not find queued write on ^a.", name, md.name);

006762  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
006763  aa   771251 00 0050	desc9a	-3415,40		000233 = 136141072040
006764  aa  6 01122 00 0050	desc9a	pr6|594,40
006765  aa   771166 3520 04	epp2 	-3466,ic		000153 = 000000000003
006766  aa  6 01136 2521 00	spri2	pr6|606
006767  aa  6 01122 3521 00	epp2 	pr6|594
006770  aa  6 01140 2521 00	spri2	pr6|608
006771  aa   771123 3520 04	epp2 	-3501,ic		000114 = 151142155063
006772  aa  6 01142 2521 00	spri2	pr6|610
006773  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
006774  aa  7 00004 3521 00	epp2 	pr7|4		md.name
006775  aa  6 01144 2521 00	spri2	pr6|612
006776  aa   771160 3520 04	epp2 	-3472,ic		000156 = 404000000021
006777  aa  6 01146 2521 00	spri2	pr6|614
007000  aa   771125 3520 04	epp2 	-3499,ic		000125 = 524000000046
007001  aa  6 01150 2521 00	spri2	pr6|616
007002  aa   771131 3520 04	epp2 	-3495,ic		000133 = 526000000013
007003  aa  6 01152 2521 00	spri2	pr6|618
007004  aa   771126 3520 04	epp2 	-3498,ic		000132 = 524000000040
007005  aa  6 01154 2521 00	spri2	pr6|620
007006  aa  6 01134 6211 00	eax1 	pr6|604
007007  aa   020000 4310 07	fld  	8192,dl
007010  aa  6 00044 3701 20	epp4 	pr6|36,*
007011  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
007012  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 1496
	goto reset_channel_restart;

007013  aa   777713 7100 04	tra  	-53,ic		006726
						STATEMENT 1 ON LINE 1499
     end reset_channel;

  END PROCEDURE reset_channel
BEGIN PROCEDURE check_buffer_tally
ENTRY TO check_buffer_tally                                 STATEMENT 1 ON LINE 1503
check_buffer_tally: proc (n);

007014  aa  6 00454 6501 00	spri4	pr6|300
007015  aa  6 00456 2521 00	spri2	pr6|302
						STATEMENT 1 ON LINE 1507
	if (buffer.tally + n) > (max_buffer_tally (buffer.size_code) - md.buffer_pad) then
	     call syserr (SYSERR_CRASH_SYSTEM, "^a: Buffer tally error on ^a.", name, md.name);

007016  aa  6 00160 2351 20	lda  	pr6|112,*		buffer.size_code
007017  aa   000030 7350 00	als  	24
007020  aa   000105 7730 00	lrl  	69
007021  ta   000044 2360 06	ldq  	36,ql
007022  aa  6 00172 3735 20	epp7 	pr6|122,*		mdp
007023  aa  7 00024 1761 00	sbq  	pr7|20		md.buffer_pad
007024  aa  6 01156 7561 00	stq  	pr6|622
007025  aa  6 00160 2361 20	ldq  	pr6|112,*		buffer.tally
007026  aa  0 00416 3771 00	anaq 	pr0|270		= 000000000000 000000000777
007027  aa  2 00002 0761 20	adq  	pr2|2,*		n
007030  aa  6 01156 1161 00	cmpq 	pr6|622
007031  aa   000032 6044 04	tmoz 	26,ic		007063
007032  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
007033  aa   771171 00 0040	desc9a	-3463,32		000223 = 136141072040
007034  aa  6 01160 00 0040	desc9a	pr6|624,32
007035  aa   771122 3520 04	epp2 	-3502,ic		000157 = 000000000001
007036  aa  6 01172 2521 00	spri2	pr6|634
007037  aa  6 01160 3521 00	epp2 	pr6|624
007040  aa  6 01174 2521 00	spri2	pr6|636
007041  aa   771053 3520 04	epp2 	-3541,ic		000114 = 151142155063
007042  aa  6 01176 2521 00	spri2	pr6|638
007043  aa  7 00004 3521 00	epp2 	pr7|4		md.name
007044  aa  6 01200 2521 00	spri2	pr6|640
007045  aa   771111 3520 04	epp2 	-3511,ic		000156 = 404000000021
007046  aa  6 01202 2521 00	spri2	pr6|642
007047  aa   771050 3520 04	epp2 	-3544,ic		000117 = 524000000035
007050  aa  6 01204 2521 00	spri2	pr6|644
007051  aa   771062 3520 04	epp2 	-3534,ic		000133 = 526000000013
007052  aa  6 01206 2521 00	spri2	pr6|646
007053  aa   771057 3520 04	epp2 	-3537,ic		000132 = 524000000040
007054  aa  6 01210 2521 00	spri2	pr6|648
007055  aa  6 01170 6211 00	eax1 	pr6|632
007056  aa   020000 4310 07	fld  	8192,dl
007057  aa  6 00044 3701 20	epp4 	pr6|36,*
007060  la  4 00016 3521 20	epp2 	pr4|14,*		syserr
007061  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
007062  aa   000002 7100 04	tra  	2,ic		007064
						STATEMENT 1 ON LINE 1509
	else return;

007063  aa  6 00454 6101 00	rtcd 	pr6|300
						STATEMENT 1 ON LINE 1511
     end check_buffer_tally;

007064  aa  6 00454 6101 00	rtcd 	pr6|300
  END PROCEDURE check_buffer_tally
  END PROCEDURE ibm3270_mpx


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
