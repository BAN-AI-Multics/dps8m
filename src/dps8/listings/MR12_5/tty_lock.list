	COMPILATION LISTING OF SEGMENT tty_lock
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1029.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style4,delnl,insnl,^ifthendo */
       14 tty_lock:
       15      proc;
       16 
       17 /* This procedure locks and unlocks channel locks.  Locking
       18*   performed at interrupt time differs from ordinary locking
       19*   in two ways:
       20*
       21*   1.  At interrupt time, one cannot wait for a channel that
       22*   is locked to be unlocked.  Therefore, failure to lock immediately
       23*   at interrupt time results in the interrupt operation being
       24*   queued (i.e., postponed) for later execution.  Queued
       25*   interrupts for a channel are processed the next time the
       26*   channel is unlocked.
       27*
       28*   2.  Ordinarily, it is considered an error when a process
       29*   attempts to lock a channel that it has already locked.
       30*   However, if the channel was previously locked for an
       31*   interrupt operation, then subsequent attempts by the same
       32*   process to lock and unlock for non-interrupt operations are
       33*   simply ignored.  This permits an interrupt handler executing
       34*   on behalf of some subchannel to perform an operation on its
       35*   major channel even though the major channel was previously
       36*   locked for the same interrupt.
       37**/
       38 
       39 /* Recoded by J. Stern 8/8/78 */
       40 /* lock_lcte entry added 12/12/79 by Robert Coren */
       41 /* Modified 6 Apr 82, W. Olin Sibert: check_for_interrupt, dequeue_interrupt entries added for mcs_timer */
       42 /* Modified 83-12-19 BIM to add pm_code to lock_lcte, which can set it! */
       43 /* Modified September 1984 by Robert Coren to make dequeue_*_interrupt entries
       44*   avoid calling tty_space_man$free_space while holding the queue lock  */
       45 /* Modified March 1985 by EJ Sharpe to return bit from $verify */
       46 
       47 /* Parameters */
       48 
       49 dcl  pm_lctep ptr;
       50 dcl  pm_devx fixed bin;
       51 dcl  pm_subchan_devx fixed bin;
       52 dcl  pm_int_type fixed bin;
       53 dcl  pm_int_data bit (72) aligned;
       54 dcl  pm_locked bit (1) aligned;
       55 dcl  pm_code fixed bin (35);
       56 
       57 
       58 /* Automatic */
       59 
       60 dcl  devx fixed bin;
       61 dcl  subchan_devx fixed bin;
       62 dcl  tried bit (1) aligned;
       63 dcl  locked bit (1) aligned;
       64 dcl  i fixed bin;
       65 dcl  wire_arg fixed bin (71);
       66 dcl  wire_ptr ptr;
       67 dcl  qep ptr;
       68 dcl  qtp ptr;
       69 dcl  (prev_qep, next_qep) ptr;
       70 dcl  (first_free_qep, last_free_qep) ptr;
       71 dcl  dequeue_all bit (1) aligned;
       72 dcl  int_type fixed bin;
       73 dcl  int_data bit (72) aligned;
       74 dcl  start_wait_time fixed bin (71);
       75 dcl  wait_time fixed bin (35);
       76 dcl  unlocked_something bit (1) aligned;
       77 
       78 /* Based */
       79 
       80 dcl  1 queue_entry aligned based (qep),
       81        2 next_entry bit (18) unal,
       82        2 subchan_devx fixed bin (18) unsigned unal,
       83        2 int_type fixed bin,
       84        2 int_data bit (72);
       85 
       86 
       87 /* External static */
       88 
       89 dcl  pds$process_id bit (36) ext;
       90 dcl  pds$process_group_id char (32) aligned ext;
       91 dcl  error_table_$io_no_permission fixed bin (35) ext;
       92 
       93 
       94 /* Builtins */
       95 
       96 dcl  (addr, clock, max, null, stac, stacq, size, rel, pointer, ptr) builtin;
       97 
       98 
       99 /* Entries */
      100 
      101 dcl  pxss$addevent entry (fixed bin);
      102 dcl  pxss$delevent entry (fixed bin);
      103 dcl  pxss$notify entry (fixed bin);
      104 dcl  pxss$wait entry;
      105 dcl  syserr entry options (variable);
      106 dcl  pmut$wire_and_mask entry (fixed bin (71), ptr);
      107 dcl  pmut$unwire_unmask entry (fixed bin (71), ptr);
      108 dcl  mcs_timer$verify_lock entry ();
      109 
      110 lock_lcte:
      111      entry (pm_lctep, pm_code);			/* locks a channel before a non-interrupt operation given an LCTE pointer */
      112 
      113 	ttybp = addr (tty_buf$);
      114 	lctp = tty_buf.lct_ptr;
      115 	lctep = pm_lctep;
      116 	go to lock_it;
      117 
      118 
      119 lock_channel:
      120      entry (pm_devx, pm_code);			/* locks a channel before a non-interrupt operation */
      121 
      122 	pm_code = 0;
      123 	call setup ();
      124 	if ^lcte.entry_in_use | lcte.special_lock
      125 	then go to no_permission;
      126 lock_it:
      127 	tty_buf.tty_lock_calls = tty_buf.tty_lock_calls + 1;
      128 	if lcte.lock = pds$process_id			/* we've already locked this channel */
      129 	then if lcte.locked_for_interrupt		/* ok, don't lock it again */
      130 	     then return;
      131 	     else call syserr (SYSERR_CRASH_SYSTEM, "tty_lock: attempt to lock channel already locked by same process.")
      132 		     ;
      133 
      134 	locked = "0"b;
      135 	tried = "0"b;
      136 	do while (^locked);
      137 	     if stac (addr (lcte.lock), pds$process_id)
      138 	     then locked = "1"b;			/* we locked it */
      139 	     else do;				/* must wait for lock to be unlocked */
      140 		if ^tried
      141 		then do;
      142 		     tty_buf.found_channel_locked = tty_buf.found_channel_locked + 1;
      143 		     start_wait_time = clock ();
      144 		     tried = "1"b;
      145 		end;
      146 
      147 		call pxss$addevent (tty_ev);		/* get ready to wait for this event */
      148 		lcte.notify_reqd = "1"b;		/* ask to be notified when lock is unlocked */
      149 		if stac (addr (lcte.lock), pds$process_id)
      150 						/* try once more to lock) it */
      151 		then do;				/* got it, no need to wait */
      152 		     call pxss$delevent (tty_ev);
      153 		     locked = "1"b;
      154 		end;
      155 		else call pxss$wait ();
      156 	     end;
      157 	end;
      158 
      159 	if tried
      160 	then do;					/* if we had to wait, meter */
      161 	     wait_time = clock () - start_wait_time;
      162 	     tty_buf.total_wait_time = tty_buf.total_wait_time + wait_time;
      163 	     tty_buf.max_wait_time = max (tty_buf.max_wait_time, wait_time);
      164 	end;
      165 
      166 	if lcte.initialized
      167 	then return;
      168 
      169 	call unlock ();				/* don't keep uninitialized channel locked */
      170 
      171 no_permission:
      172 	pm_code = error_table_$io_no_permission;
      173 
      174 	return;
      175 
      176 lock_channel_int:
      177      entry (pm_devx, pm_int_type, pm_int_data, pm_locked);	/* locks a channel before an interrupt operation */
      178 
      179 
      180 	int_type = pm_int_type;
      181 	int_data = pm_int_data;
      182 	subchan_devx = 0;
      183 	pm_locked = "0"b;
      184 	call setup ();
      185 	tty_buf.tty_lock_calls = tty_buf.tty_lock_calls + 1;
      186 	if ^lcte.entry_in_use
      187 	then call syserr (SYSERR_CRASH_SYSTEM, "tty_lock: attempt to lock unused channel for interrupt.");
      188 
      189 	call lock_queue;
      190 	if ^stac (addr (lcte.lock), pds$process_id)
      191 	then do;					/* cannot set lock, must queue the interrupt */
      192 	     call enqueue;
      193 	     call unlock_queue;
      194 	     return;
      195 	end;
      196 	call unlock_queue;
      197 
      198 	if ^lcte.initialized
      199 	then do;					/* ignore interrupts for uninitialized channels */
      200 	     call unlock ();
      201 	     return;
      202 	end;
      203 
      204 	lcte.locked_for_interrupt = "1"b;
      205 	pm_locked = "1"b;
      206 	return;
      207 
      208 queue_interrupt:
      209      entry (pm_devx, pm_int_type, pm_int_data, pm_subchan_devx);
      210 
      211 /* This entry adds an entry to the queue for a major channel on behalf of one of
      212*   its subchannels. it is used by channel_manager$interrupt_later
      213**/
      214 
      215 	int_type = pm_int_type;
      216 	int_data = pm_int_data;
      217 	subchan_devx = pm_subchan_devx;
      218 	call setup ();
      219 
      220 	call lock_queue;
      221 	call enqueue;
      222 	call unlock_queue;
      223 	return;
      224 
      225 unlock_channel:
      226      entry (pm_devx);				/* unlocks a channel after a non-interrupt operation */
      227 
      228 	call setup ();
      229 
      230 	if lcte.lock = pds$process_id			/* we have channel locked as expected */
      231 	then if lcte.locked_for_interrupt		/* but we don't really want to unlock it now */
      232 	     then return;
      233 
      234 	call unlock ();
      235 
      236 	return;
      237 
      238 
      239 
      240 unlock_channel_int:
      241      entry (pm_devx);				/* unlocks a channel after an interrupt operation */
      242 
      243 	call setup ();
      244 
      245 	lcte.locked_for_interrupt = "0"b;
      246 	call unlock ();
      247 	return;
      248 
      249 flush_queue:
      250      entry (pm_devx);				/* deletes all queue entries for a given channel */
      251 
      252 	call setup ();
      253 
      254 	do while (dequeue ());
      255 	end;
      256 	return;
      257 
      258 
      259 
      260 cleanup_locks:
      261      entry;					/* called only by terminate_proc */
      262 
      263 	call CLEANUP_LOCKS;
      264 	return;
      265 
      266 
      267 verify:
      268      entry () returns (bit (1) aligned);
      269 
      270 	call CLEANUP_LOCKS;
      271 	return (unlocked_something);
      272 
      273 
      274 CLEANUP_LOCKS:			/* internal procedure for $cleanup_locks and $verify entrypoints */
      275      procedure ();
      276 
      277 	unlocked_something = "0"b;
      278 	ttybp = addr (tty_buf$);
      279 	if tty_buf.slock = pds$process_id
      280 	then call syserr (SYSERR_CRASH_SYSTEM, "tty_lock$verify: attempted crawlout with tty_buf lock set.");
      281 
      282 	lctp = tty_buf.lct_ptr;
      283 	if lctp = null ()
      284 	then return;				/* MCS not started yet, never mind */
      285 	if lct.queue_lock = pds$process_id
      286 	then call syserr (SYSERR_CRASH_SYSTEM, "tty_lock$verify: attempted crawlout with queue lock set.");
      287 
      288 	call mcs_timer$verify_lock ();		/* will crash system if timer lock locked */
      289 
      290 	do i = 1 to lct.max_no_lctes;
      291 	     lctep = addr (lcte_array (i));
      292 	     if lcte.entry_in_use
      293 	     then if lcte.lock = pds$process_id
      294 		then if lcte.special_lock
      295 		     then call syserr (SYSERR_CRASH_SYSTEM,
      296 			     "tty_lock$verify: attempted crawlout with special channel lock set.");
      297 		     else do;
      298 			devx = i;
      299 			call force_unlock;		/* clear the lock so next caller won't hang */
      300 			unlocked_something = "1"b;
      301 		     end;
      302 	end;
      303 
      304 	return;
      305 
      306      end CLEANUP_LOCKS;
      307 
      308 check_for_interrupt:
      309      entry (pm_devx, pm_int_type, pm_int_data) returns (bit (1) aligned);
      310 
      311 	int_type = pm_int_type;
      312 	int_data = pm_int_data;
      313 	call setup ();
      314 
      315 	call lock_queue ();
      316 
      317 	do qep = pointer (ttybp, lcte.queue_head) repeat (pointer (ttybp, queue_entry.next_entry))
      318 	     while (rel (qep) ^= ""b);
      319 
      320 	     if (queue_entry.int_type = int_type) & (queue_entry.int_data = int_data)
      321 	     then do;
      322 		call unlock_queue ();
      323 		return ("1"b);			/* You're our boy */
      324 	     end;
      325 	end;
      326 
      327 	call unlock_queue ();
      328 
      329 	return ("0"b);				/* None found */
      330 
      331 dequeue_one_interrupt:
      332      entry (pm_devx, pm_int_type, pm_int_data);
      333 
      334 	dequeue_all = "0"b;
      335 	int_data = pm_int_data;
      336 	goto dequeue_common;
      337 
      338 
      339 dequeue_all_interrupts:
      340      entry (pm_devx, pm_int_type);
      341 
      342 	dequeue_all = "1"b;
      343 
      344 
      345 dequeue_common:
      346 	int_type = pm_int_type;
      347 	call setup ();
      348 
      349 	call lock_queue ();
      350 
      351 /* it's not safe to call tty_space_man with the queue lock locked, because it can
      352*   generate "space_available" interrupts; so we'll keep a list of entries to free
      353*   and free them all after we've unthreaded them and released the lock.
      354**/
      355 
      356 	prev_qep, first_free_qep = pointer (ttybp, 0);
      357 	do qep = pointer (ttybp, lcte.queue_head) repeat (next_qep) while (rel (qep) ^= ""b);
      358 	     next_qep = pointer (ttybp, queue_entry.next_entry);
      359 
      360 	     if (queue_entry.int_type = int_type) & (dequeue_all | (queue_entry.int_data = int_data))
      361 	     then do;
      362 		if (lcte.queue_head = rel (qep))
      363 		then lcte.queue_head = queue_entry.next_entry;
      364 
      365 		if (lcte.queue_tail = rel (qep))
      366 		then lcte.queue_tail = rel (prev_qep);
      367 
      368 		if (rel (prev_qep) ^= ""b)
      369 		then prev_qep -> queue_entry.next_entry = queue_entry.next_entry;
      370 
      371 /* put this one on the "to be freed" list */
      372 
      373 		queue_entry.next_entry = ""b;
      374 		if rel (first_free_qep) = ""b
      375 		then first_free_qep, last_free_qep = qep;
      376 		else do;
      377 		     last_free_qep -> queue_entry.next_entry = rel (qep);
      378 		     last_free_qep = qep;
      379 		end;
      380 	     end;
      381 	     else prev_qep = qep;
      382 	end;					/* Of loop through queue entries */
      383 
      384 	call unlock_queue ();
      385 
      386 /* now go through the free list (if any) and free the entries on it */
      387 
      388 	do qep = first_free_qep repeat (next_qep) while (rel (qep) ^= ""b);
      389 	     next_qep = pointer (ttybp, queue_entry.next_entry);
      390 	     call tty_space_man$free_space (size (queue_entry), qep);
      391 	end;
      392 
      393 	return;
      394 
      395 setup:
      396      proc;
      397 
      398 	ttybp = addr (tty_buf$);
      399 	lctp = tty_buf.lct_ptr;
      400 	devx = pm_devx;
      401 	lctep = addr (lct.lcte_array (devx));
      402 	return;
      403      end setup;
      404 
      405 
      406 
      407 unlock:
      408      proc;
      409 
      410 /* process all entries in the channel queue before unlocking */
      411 /* last call to dequeue will unlock the channel lock */
      412 
      413 	do while (dequeue ());
      414 	     lcte.locked_for_interrupt = "1"b;		/* make queued interrupt look real */
      415 	     if subchan_devx ^= 0			/* this is really for a subchannel */
      416 	     then call channel_manager$interrupt (subchan_devx, int_type, int_data);
      417 	     else call channel_manager$queued_interrupt (devx, int_type, int_data);
      418 	     lcte.locked_for_interrupt = "0"b;
      419 	end;
      420 
      421 	if lcte.notify_reqd				/* someone is waiting for this lock */
      422 	then do;					/* let everyone know it's available */
      423 	     lcte.notify_reqd = "0"b;
      424 	     call pxss$notify (tty_ev);
      425 	end;
      426 
      427      end;						/* unlock */
      428 
      429 
      430 
      431 force_unlock:
      432      procedure;
      433 
      434 /* lock is to be forced because process is crawling out. Send notify if necessary,
      435*   but flush queued interrupts rather than attempting to process them.
      436**/
      437 
      438 	call syserr (SYSERR_LOG_OR_PRINT, "tty_lock: forcing unlock of channel ^a from ^a",
      439 	     lct.lcnt_ptr -> lcnt.names (devx), pds$process_group_id);
      440 
      441 	lcte.locked_for_interrupt = "0"b;
      442 	do while (dequeue ());			/* this flushes the queue and unlocks the channel when it's done */
      443 	end;
      444 
      445 	if lcte.notify_reqd
      446 	then do;
      447 	     lcte.notify_reqd = "0"b;
      448 	     call pxss$notify (tty_ev);
      449 	end;
      450 
      451 	return;
      452      end force_unlock;
      453 
      454 lock_queue:
      455      proc;
      456 
      457 	call pmut$wire_and_mask (wire_arg, wire_ptr);
      458 
      459 	do while (^stac (addr (lct.queue_lock), pds$process_id));
      460 	end;
      461 
      462      end;						/* lock_queue */
      463 
      464 
      465 
      466 unlock_queue:
      467      proc;
      468 
      469 	if ^stacq (lct.queue_lock, "0"b, pds$process_id)
      470 	then call syserr (SYSERR_CRASH_SYSTEM, "tty_lock: attempt to unlock queue not locked by same process.");
      471 
      472 	call pmut$unwire_unmask (wire_arg, wire_ptr);
      473 
      474      end;						/* unlock_queue */
      475 
      476 enqueue:
      477      proc;					/* adds queue entry to head of channel queue */
      478 
      479 
      480 	if ^lcte.initialized			/* don't queue anything for an uninitialized channel */
      481 	then return;
      482 
      483 	call tty_space_man$get_space (size (queue_entry), qep);
      484 	if qep = null
      485 	then do;
      486 	     call syserr (SYSERR_PRINT_WITH_ALARM, "tty_lock: Cannot get space for queue entry. (devx = ^d)", devx);
      487 	     return;
      488 	end;
      489 
      490 	queue_entry.int_type = int_type;
      491 	queue_entry.int_data = int_data;
      492 	queue_entry.subchan_devx = subchan_devx;
      493 	if lcte.queue_tail = "0"b			/* queue is empty */
      494 	then lcte.queue_tail, lcte.queue_head = rel (qep);/* new entry is both first and last */
      495 	else do;
      496 	     qtp = ptr (ttybp, lcte.queue_tail);	/* get ptr to last entry */
      497 	     qtp -> queue_entry.next_entry = rel (qep);	/* put new entry after it */
      498 	     lcte.queue_tail = rel (qep);		/* new entry is now the last */
      499 	end;
      500 	queue_entry.next_entry = "0"b;		/* nothing follows last entry */
      501 	tty_buf.n_queued_interrupts = tty_buf.n_queued_interrupts + 1;
      502 
      503      end;
      504 
      505 
      506 
      507 dequeue:
      508      proc returns (bit (1));				/* removes entry from head of channel queue */
      509 
      510 	call lock_queue ();
      511 	if lcte.queue_head = "0"b			/* queue is empty */
      512 	then do;
      513 	     qep = null;
      514 	     if ^stacq (lcte.lock, "0"b, pds$process_id)
      515 	     then call syserr (SYSERR_CRASH_SYSTEM, "tty_lock: attempt to unlock channel not locked by same process.");
      516 	end;
      517 
      518 	else do;
      519 	     qep = ptr (ttybp, lcte.queue_head);	/* get ptr to first queue entry */
      520 	     lcte.queue_head = queue_entry.next_entry;	/* next entry is now first */
      521 	     if lcte.queue_head = "0"b		/* there was no next entry */
      522 	     then lcte.queue_tail = "0"b;
      523 	end;
      524 	call unlock_queue ();
      525 
      526 	if qep = null
      527 	then return ("0"b);				/* indicate empty queue */
      528 	else do;
      529 	     int_type = queue_entry.int_type;
      530 	     int_data = queue_entry.int_data;
      531 	     subchan_devx = queue_entry.subchan_devx;
      532 	     call tty_space_man$free_space (size (queue_entry), qep);
      533 	     return ("1"b);
      534 	end;
      535 
      536      end;
      537 
  1     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  1     2 
  1     3 /* Created by J. Stern 7/26/78 */
  1     4 /* Metering information added by C. Hornig, March 1980. */
  1     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  1     6 
  1     7 dcl  lctp ptr;					/* ptr to logical channel table */
  1     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  1     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  1    10 
  1    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  1    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  1    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  1    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  1    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  1    16     2 pad (11) fixed bin,
  1    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  1    18 
  1    19 
  1    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  1    21     2 lock bit (36),				/* channel lock */
  1    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  1    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  1    24     2 flags unal,
  1    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  1    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  1    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  1    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  1    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  1    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  1    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  1    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  1    33       3 trace bit (1) unal,				/* ON to trace this channel */
  1    34       3 unused bit (1) unal,
  1    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  1    36     2 major_channel_info,
  1    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  1    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  1    39     2 queue_entries,
  1    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  1    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  1    42     2 word_counts,
  1    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  1    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  1    45 
  1    46     2 meters,
  1    47       3 in_bytes fixed bin (35),
  1    48       3 out_bytes fixed bin (35),
  1    49       3 in,
  1    50         4 calls fixed bin (35),
  1    51         4 interrupts fixed bin (35),
  1    52         4 call_time fixed bin (71),
  1    53         4 interrupt_time fixed bin (71),
  1    54       3 out like lcte.meters.in,
  1    55       3 control like lcte.meters.in,
  1    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  1    57 
  1    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  1    59 
  1    60     2 pad (3) fixed bin (35);
  1    61 
  1    62 
  1    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  1    64 
  1    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  1    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  1    67 
  1    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  1    69 
  1    70 
  1    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      538 
  2     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  2     2 
  2     3 /* Date Last Modified and Reason
  2     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  2     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  2     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  2     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  2     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  2     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  2    10*   Modified November 1979 by C. Hornig for MCS tracing.
  2    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  2    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  2    13*   Modified March 1980 by Robert Coren to reorganize metering information
  2    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  2    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  2    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  2    17**/
  2    18 
  2    19 dcl  ttybp ptr,
  2    20      tty_buf$ ext static,				/* tty buffer segment */
  2    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  2    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  2    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  2    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  2    25 
  2    26 
  2    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  2    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  2    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  2    30 
  2    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  2    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  2    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  2    34 
  2    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  2    36     2 slock bit (36),				/* per system lock */
  2    37     2 absorig fixed bin (24),				/* abs address of this seg */
  2    38     2 borig bit (18),				/* index of start of buffer area */
  2    39     2 bleft fixed bin (18),				/* words left in pool */
  2    40     2 free bit (18),				/* pointer to start of free pool */
  2    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  2    42     2 padb1 bit (28) unaligned,
  2    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  2    44 
  2    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  2    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  2    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  2    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  2    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  2    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  2    51     2 minbuf fixed bin (18),				/* min output buffer size */
  2    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  2    53 
  2    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  2    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  2    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  2    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  2    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  2    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  2    60 
  2    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  2    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  2    63     2 bfx fixed bin,				/* used in calls to iobm */
  2    64     2 nquits fixed bin (35),				/* number of quits */
  2    65     2 space_needed_data,
  2    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  2    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  2    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  2    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  2    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  2    71 
  2    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  2    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  2    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  2    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  2    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  2    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  2    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  2    79 
  2    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  2    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  2    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  2    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  2    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  2    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  2    86 
  2    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  2    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  2    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  2    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  2    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  2    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  2    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  2    94 
  2    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  2    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  2    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  2    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  2    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  2   100     2 echo_neg_mux_nonecho fixed bin (35),
  2   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  2   102 
  2   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  2   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  2   105     2 trace unaligned,				/* tracing information */
  2   106       3 flags,
  2   107       4 enable bit,					/* global tracing control */
  2   108       4 default_mode bit,				/* whether to trace channels by default */
  2   109       4 read bit,					/* read */
  2   110       4 write bit,					/* write */
  2   111       4 data bit,					/* buffers on reads and writes */
  2   112       4 control bit,				/* control, priv_control, and hpriv_control */
  2   113       4 modes bit,					/* (get set check)_modes */
  2   114       4 interrupt bit,				/* interrupt, interrupt_later */
  2   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  2   116       4 start bit,					/* start, stop */
  2   117       4 shutdown bit,				/* shutdown */
  2   118       4 space_man bit,				/* tty_space_man$* */
  2   119       4 pad_flags bit (6),
  2   120       3 data_offset bit (18),				/* offset of tracing data */
  2   121 
  2   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  2   123 
  2   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  2   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  2   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  2   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  2   128 
  2   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  2   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  2   131 
  2   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  2   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  2   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  2   135 
  2   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  2   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  2   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  2   139 
  2   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  2   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  2   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  2   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  2   144 
  2   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  2   146 
  2   147     2 pad2 (13) fixed bin (35),
  2   148 
  2   149     2 free_space fixed bin;				/* start of free space region */
  2   150 
  2   151 
  3     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  3     2 
  3     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  3     4 
  3     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  3     6 
  3     7 /* format: style3 */
  3     8 
  3     9 declare	lock_ptr		pointer;
  3    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  3    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  3    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  3    13 	  2 flags		aligned,
  3    14 	    3 notify_sw	bit (1) unaligned,
  3    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  3    16 
  3    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2   152 
  2   153 
  2   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      539 
  4     1 /* BEGIN INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
  4     2 
  4     3 /* This include file declares all the entries in tty_space_man and defines the constants
  4     4**  to be used for the flags argument
  4     5**   Modified 08/21/78 by Robert Coren to eliminate "masked" flag
  4     6**   Modified March 1981 by Robert Coren to add get_perm_space entry
  4     7**   Modified April 1981 by Robert Coren to add switch_chain entry
  4     8**/
  4     9 
  4    10 dcl  tty_space_man$get_space entry (fixed bin, ptr);
  4    11 dcl  tty_space_man$get_perm_space entry (fixed bin, ptr);
  4    12 dcl  tty_space_man$free_space entry (fixed bin, ptr);
  4    13 dcl  tty_space_man$get_buffer entry (fixed bin, fixed bin, bit (1), ptr);
  4    14 dcl  tty_space_man$free_buffer entry (fixed bin, bit (1), ptr);
  4    15 dcl  tty_space_man$get_chain entry (fixed bin, fixed bin, fixed bin, bit (1), ptr);
  4    16 dcl  tty_space_man$free_chain entry (fixed bin, bit (1), ptr);
  4    17 dcl  tty_space_man$switch_chain entry (fixed bin, fixed bin, bit (1), bit (1), ptr);
  4    18 dcl  tty_space_man$needs_space entry (fixed bin);
  4    19 
  4    20 dcl  INPUT bit (1) int static options (constant) init ("0"b);
  4    21 dcl  OUTPUT bit (1) int static options (constant) init ("1"b);
  4    22 
  4    23 /* END INCLUDE FILE ... tty_space_man_dcls.incl.pl1 */
      540 
  5     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  5     2 
  5     3 /* Created 8/25/78 by J. Stern */
  5     4 
  5     5 
  5     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  5     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  5     8 
  5     9 /* call channel_manager$write (devx, output_ptr, code) */
  5    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  5    11 
  5    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  5    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  5    14 
  5    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  5    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  5    17 
  5    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  5    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  5    20 
  5    21 /* call channel_manager$get_modes (devx, modes, code) */
  5    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  5    23 
  5    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  5    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    26 
  5    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  5    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  5    29 
  5    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  5    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    32 
  5    33 
  5    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      541 
  6     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  6     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  6     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  6     4 
  6     5 /* This include file has an ALM version.  Keep 'em in sync! */
  6     6 
  6     7 dcl (
  6     8 
  6     9 /* The following constants define the message action codes.  This indicates
  6    10*how a message is to be handled.  */
  6    11 
  6    12      SYSERR_CRASH_SYSTEM	init (1),			
  6    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  6    14 
  6    15      SYSERR_TERMINATE_PROCESS	init (2),
  6    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  6    17 
  6    18      SYSERR_PRINT_WITH_ALARM	init (3),
  6    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  6    20 
  6    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  6    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  6    23 
  6    24      SYSERR_LOG_OR_PRINT	init (4),
  6    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  6    26 
  6    27      SYSERR_LOG_OR_DISCARD	init (5),
  6    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  6    29 
  6    30 
  6    31 /* The following constants are added to the normal severities to indicate
  6    32*different sorting classes of messages.  */
  6    33 
  6    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  6    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  6    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  6    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  6    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  6    39 	) fixed bin internal static options (constant);
  6    40 
  6    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      542 
      543 
      544 /* BEGIN MESSAGE DOCUMENTATION
      545*
      546*   Message:
      547*   tty_lock: attempt to lock channel already locked by same process.
      548*
      549*   S:	$crash
      550*
      551*   T:	$run
      552*
      553*   M:	A locking error was detected when a process tried to lock a
      554*   channel that it had already locked.
      555*
      556*   A:	$inform
      557*
      558*
      559*   Message:
      560*   tty_lock: attempt to lock unused channel for interrupt.
      561*
      562*   S:	$crash
      563*
      564*   T:	$run
      565*
      566*   M:	A locking error was detected when an interrupt handler
      567*   tried to lock an ununsed channel.
      568*
      569*   A:	$inform
      570*
      571*
      572*   Message:
      573*   tty_lock: attempt to unlock channel not locked by same process.
      574*
      575*   S:	$crash
      576*
      577*   T:	$run
      578*
      579*   M:	A locking error was detected when a process tried to unlock
      580*   a channel that was either not locked or locked by another process.
      581*
      582*   A:	$inform
      583*
      584*
      585*   Message:
      586*   tty_lock$verify: attempted crawlout with tty_buf lock set.
      587*
      588*   S:	$crash
      589*
      590*   T:	$run
      591*
      592*   M:	There was an attempt to crawl out while the tty_buf lock used
      593*   by tty_space_man was locked.
      594*
      595*   A:	$inform
      596*
      597*
      598*   Message:
      599*   tty_lock$verify: attempted crawlout with special channel lock set.
      600*
      601*   S:	$crash
      602*
      603*   T:	$run
      604*
      605*   M:	There was an attempt to crawl out while a channel lock that
      606*   is also a processor lock was locked.
      607*
      608*   A:	$inform
      609*
      610*   Message:
      611*   tty_lock$verify: attempted crawlout with queue lock set.
      612*
      613*   S:	$crash
      614*
      615*   T:	$run
      616*
      617*   M:	There was an attempt to crawl out while the tty queue
      618*   lock was locked.
      619*
      620*   A:	$inform
      621*
      622*   Message:
      623*   tty_lock: Cannot get space for queue entry. (devx = N)
      624*
      625*   S:	$beep
      626*
      627*   T:	$run
      628*
      629*   M:	An attempt to queue an interrupt for the channel with devx N
      630*   failed due to lack of space.  The interrupt was lost which may cause
      631*   loss of data or improper channel operation.
      632*
      633*   A:	$inform
      634*
      635*
      636*   Message:
      637*   tty_lock: attempt to unlock queue not locked by same process.
      638*
      639*   S:	$crash
      640*
      641*   T:	$run
      642*
      643*   M:	A locking error was detected when a process tried to unlock
      644*   the global queue lock which was either not locked or was locked by another
      645*   process.
      646*
      647*   END MESSAGE DOCUMENTATION */
      648 
      649      end tty_lock;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.4  tty_lock.pl1                      >special_ldd>install>MR12.3-1114>tty_lock.pl1
538          1    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
539          2    01/06/85  1422.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
2-152        3    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
540          4    06/18/81  0900.8  tty_space_man_dcls.incl.pl1       >ldd>include>tty_space_man_dcls.incl.pl1
541          5    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
542          6    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SYSERR_CRASH_SYSTEM             000021 constant        fixed bin(17,0)          initial dcl 6-7 set ref 131* 186* 279* 285* 292*
                                                                                  469* 514*
SYSERR_LOG_OR_PRINT             000017 constant        fixed bin(17,0)          initial dcl 6-7 set ref 438*
SYSERR_PRINT_WITH_ALARM         000015 constant        fixed bin(17,0)          initial dcl 6-7 set ref 486*
addr                                                   builtin function         dcl 96 ref 113 137 149 190 278 291 398 401 459
channel_manager$interrupt       000044 constant        entry                    external dcl 5-25 ref 415
channel_manager$queued_interrupt
                                000046 constant        entry                    external dcl 5-31 ref 417
clock                                                  builtin function         dcl 96 ref 143 161
dequeue_all                     000126 automatic       bit(1)                   dcl 71 set ref 334* 342* 360
devx                            000100 automatic       fixed bin(17,0)          dcl 60 set ref 298* 400* 401 417* 438 486*
entry_in_use              2(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1-20 ref 124 186
                                                                                  292
error_table_$io_no_permission   000014 external static fixed bin(35,0)          dcl 91 ref 171
first_free_qep                  000122 automatic       pointer                  dcl 70 set ref 356* 374 374* 388
flags                     2(09)        based           structure                level 2 packed packed unaligned dcl 1-20
found_channel_locked     64            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 142* 142
hc_fast_lock                           based           structure                level 1 dcl 3-10
i                               000104 automatic       fixed bin(17,0)          dcl 64 set ref 290* 291 298*
in                       10            based           structure                level 3 in structure "lcte" dcl 1-20 in procedure
                                                                                  "tty_lock"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 1-68
                                                                                  in procedure "tty_lock"
in                       30            based           structure                array level 4 in structure "lct" dcl 1-11
                                                                                  in procedure "tty_lock"
initialized               2(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-20 ref 166 198
                                                                                  480
int_data                  2            based           bit(72)                  level 2 in structure "queue_entry" dcl 80
                                                                                  in procedure "tty_lock" set ref 320 360 491* 530
int_data                        000130 automatic       bit(72)                  dcl 73 in procedure "tty_lock" set ref 181* 216*
                                                                                  312* 320 335* 360 415* 417* 491 530*
int_type                  1            based           fixed bin(17,0)          level 2 in structure "queue_entry" dcl 80
                                                                                  in procedure "tty_lock" set ref 320 360 490* 529
int_type                        000127 automatic       fixed bin(17,0)          dcl 72 in procedure "tty_lock" set ref 180* 215*
                                                                                  311* 320 345* 360 415* 417* 490 529*
last_free_qep                   000124 automatic       pointer                  dcl 70 set ref 374* 377 378*
lcnt                                   based           structure                level 1 dcl 1-65
lcnt_ptr                  2            based           pointer                  level 2 dcl 1-11 ref 438
lct                                    based           structure                level 1 dcl 1-11
lct_ptr                   6            based           pointer                  level 2 dcl 2-35 ref 114 282 399
lcte                                   based           structure                level 1 dcl 1-20
lcte_array               20            based           structure                array level 2 dcl 1-11 set ref 291 401
lctep                           000140 automatic       pointer                  dcl 1-8 set ref 115* 124 124 128 128 137 148 149 166
                                                                                  186 190 198 204 230 230 245 291* 292 292 292 317
                                                                                  357 362 362 365 365 401* 414 418 421 423 441 445
                                                                                  447 480 493 493 493 496 498 511 514 519 520 521
                                                                                  521
lctp                            000136 automatic       pointer                  dcl 1-7 set ref 114* 282* 283 285 290 291 399* 401
                                                                                  438 459 469
lock                                   based           bit(36)                  level 2 dcl 1-20 set ref 128 137 149 190 230 292 514
locked                          000103 automatic       bit(1)                   dcl 63 set ref 134* 136 137* 153*
locked_for_interrupt      2(12)        based           bit(1)                   level 3 packed packed unaligned dcl 1-20 set ref 128
                                                                                  204* 230 245* 414* 418* 441*
max                                                    builtin function         dcl 96 ref 163
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 1-11 ref 290
max_wait_time            65            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 163* 163
mcs_timer$verify_lock           000034 constant        entry                    external dcl 108 ref 288
meters                   26            based           structure                array level 3 in structure "lct" dcl 1-11
                                                                                  in procedure "tty_lock"
meters                    6            based           structure                level 2 in structure "lcte" dcl 1-20 in procedure
                                                                                  "tty_lock"
n_queued_interrupts     101            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 501* 501
names                                  based           char(32)                 array level 2 packed packed unaligned dcl 1-65 set
                                                                                  ref 438*
next_entry                             based           bit(18)                  level 2 packed packed unaligned dcl 80 set ref 325
                                                                                  358 362 368* 368 373* 377* 389 497* 500* 520
next_qep                        000120 automatic       pointer                  dcl 69 set ref 358* 382 389* 391
notify_reqd               2(11)        based           bit(1)                   level 3 packed packed unaligned dcl 1-20 set ref
                                                                                  148* 421 423* 445 447*
null                                                   builtin function         dcl 96 ref 283 484 513 526
pds$process_group_id            000012 external static char(32)                 dcl 90 set ref 438*
pds$process_id                  000010 external static bit(36)                  packed unaligned dcl 89 ref 128 137 149 190 230 279
                                                                                  285 292 459 469 514
pm_code                                parameter       fixed bin(35,0)          dcl 55 set ref 110 119 122* 171*
pm_devx                                parameter       fixed bin(17,0)          dcl 50 ref 119 176 208 225 240 249 308 331 339 400
pm_int_data                            parameter       bit(72)                  dcl 53 ref 176 181 208 216 308 312 331 335
pm_int_type                            parameter       fixed bin(17,0)          dcl 52 ref 176 180 208 215 308 311 331 339 345
pm_lctep                               parameter       pointer                  dcl 49 ref 110 115
pm_locked                              parameter       bit(1)                   dcl 54 set ref 176 183* 205*
pm_subchan_devx                        parameter       fixed bin(17,0)          dcl 51 ref 208 217
pmut$unwire_unmask              000032 constant        entry                    external dcl 107 ref 472
pmut$wire_and_mask              000030 constant        entry                    external dcl 106 ref 457
pointer                                                builtin function         dcl 96 ref 317 325 356 357 358 389
prev_qep                        000116 automatic       pointer                  dcl 69 set ref 356* 365 368 368 381*
ptr                                                    builtin function         dcl 96 ref 496 519
pxss$addevent                   000016 constant        entry                    external dcl 101 ref 147
pxss$delevent                   000020 constant        entry                    external dcl 102 ref 152
pxss$notify                     000022 constant        entry                    external dcl 103 ref 424 448
pxss$wait                       000024 constant        entry                    external dcl 104 ref 155
qep                             000112 automatic       pointer                  dcl 67 set ref 317* 317* 320 320* 325 357* 357* 358
                                                                                  360 360 362 362 365 368 373 374 377 378 381* 388*
                                                                                  388* 389 390 390 390* 483 483 483* 484 490 491 492
                                                                                  493 497 498 500 513* 519* 520 526 529 530 531 532
                                                                                  532 532*
qtp                             000114 automatic       pointer                  dcl 68 set ref 496* 497
queue_entries             4            based           structure                level 2 dcl 1-20
queue_entry                            based           structure                level 1 dcl 80 set ref 390 390 483 483 532 532
queue_head                4            based           bit(18)                  level 3 packed packed unaligned dcl 1-20 set ref 317
                                                                                  357 362 362* 493* 511 519 520* 521
queue_lock                4            based           bit(36)                  level 2 dcl 1-11 set ref 285 459 469
queue_tail                4(18)        based           bit(18)                  level 3 packed packed unaligned dcl 1-20 set ref 365
                                                                                  365* 493 493* 496 498* 521*
rel                                                    builtin function         dcl 96 ref 317 357 362 365 365 368 374 377 388 493
                                                                                  497 498
size                                                   builtin function         dcl 96 ref 390 390 483 483 532 532
slock                                  based           bit(36)                  level 2 dcl 2-35 ref 279
special_lock              2(14)        based           bit(1)                   level 3 packed packed unaligned dcl 1-20 ref 124 292
stac                                                   builtin function         dcl 96 ref 137 149 190 459
stacq                                                  builtin function         dcl 96 ref 469 514
start_wait_time                 000132 automatic       fixed bin(71,0)          dcl 74 set ref 143* 161
subchan_devx                    000101 automatic       fixed bin(17,0)          dcl 61 in procedure "tty_lock" set ref 182* 217* 415
                                                                                  415* 492 531*
subchan_devx              0(18)        based           fixed bin(18,0)          level 2 in structure "queue_entry" packed packed
                                                                                  unsigned unaligned dcl 80 in procedure "tty_lock"
                                                                                  set ref 492* 531
syserr                          000026 constant        entry                    external dcl 105 ref 131 186 279 285 292 438 469 486
                                                                                  514
total_wait_time          66            based           fixed bin(71,0)          level 2 dcl 2-35 set ref 162* 162
tried                           000102 automatic       bit(1)                   dcl 62 set ref 135* 140 144* 159
tty_buf                                based           structure                level 1 dcl 2-35
tty_buf$                        000036 external static fixed bin(17,0)          dcl 2-19 set ref 113 278 398
tty_ev                          000000 constant        fixed bin(17,0)          initial dcl 2-19 set ref 147* 152* 424* 448*
tty_lock_calls           63            based           fixed bin(35,0)          level 2 dcl 2-35 set ref 126* 126 185* 185
tty_space_man$free_space        000042 constant        entry                    external dcl 4-12 ref 390 532
tty_space_man$get_space         000040 constant        entry                    external dcl 4-10 ref 483
ttybp                           000142 automatic       pointer                  dcl 2-19 set ref 113* 114 126 126 142 142 162 162
                                                                                  163 163 185 185 278* 279 282 317 325 356 357 358
                                                                                  389 398* 399 496 501 501 519
unlocked_something              000135 automatic       bit(1)                   dcl 76 set ref 271 277* 300*
wait_time                       000134 automatic       fixed bin(35,0)          dcl 75 set ref 161* 162 163
wire_arg                        000106 automatic       fixed bin(71,0)          dcl 65 set ref 457* 472*
wire_ptr                        000110 automatic       pointer                  dcl 66 set ref 457* 472*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 6-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 6-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 6-7
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 2-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 2-32
INPUT                                  internal static bit(1)                   initial packed unaligned dcl 4-20
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 6-7
LOG                                    internal static fixed bin(17,0)          initial dcl 6-7
OUTPUT                                 internal static bit(1)                   initial packed unaligned dcl 4-21
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 6-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 6-7
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 2-33
abs_buf_limit                          internal static fixed bin(18,0)          initial dcl 2-19
bsizec                                 internal static fixed bin(17,0)          initial dcl 2-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 2-29
channel_manager$check_modes     000000 constant        entry                    external dcl 5-19
channel_manager$control         000000 constant        entry                    external dcl 5-13
channel_manager$get_modes       000000 constant        entry                    external dcl 5-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 5-28
channel_manager$read            000000 constant        entry                    external dcl 5-7
channel_manager$set_modes       000000 constant        entry                    external dcl 5-16
channel_manager$write           000000 constant        entry                    external dcl 5-10
input_bpart                            internal static fixed bin(18,0)          initial dcl 2-19
lcntp                                  automatic       pointer                  dcl 1-63
lct_size                               automatic       fixed bin(17,0)          dcl 1-9
lock_ptr                               automatic       pointer                  dcl 3-9
output_bpart                           internal static fixed bin(18,0)          initial dcl 2-19
qblock_size                            internal static fixed bin(17,0)          initial dcl 2-27
saved_meters                           based           structure                level 1 dcl 1-68
tty_space_man$free_buffer       000000 constant        entry                    external dcl 4-14
tty_space_man$free_chain        000000 constant        entry                    external dcl 4-16
tty_space_man$get_buffer        000000 constant        entry                    external dcl 4-13
tty_space_man$get_chain         000000 constant        entry                    external dcl 4-15
tty_space_man$get_perm_space    000000 constant        entry                    external dcl 4-11
tty_space_man$needs_space       000000 constant        entry                    external dcl 4-18
tty_space_man$switch_chain      000000 constant        entry                    external dcl 4-17

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP_LOCKS                   001404 constant        entry                    internal dcl 274 ref 263 270
check_for_interrupt             001105 constant        entry                    external dcl 308
cleanup_locks                   001036 constant        entry                    external dcl 260
dequeue                         002143 constant        entry                    internal dcl 507 ref 254 413 442
dequeue_all_interrupts          001227 constant        entry                    external dcl 339
dequeue_common                  001240 constant        label                    dcl 345 ref 336
dequeue_one_interrupt           001205 constant        entry                    external dcl 331
enqueue                         002027 constant        entry                    internal dcl 476 ref 192 221
flush_queue                     001007 constant        entry                    external dcl 249
force_unlock                    001653 constant        entry                    internal dcl 431 ref 299
lock_channel                    000304 constant        entry                    external dcl 119
lock_channel_int                000532 constant        entry                    external dcl 176
lock_it                         000325 constant        label                    dcl 126 ref 116
lock_lcte                       000260 constant        entry                    external dcl 110
lock_queue                      001742 constant        entry                    internal dcl 454 ref 189 220 315 349 510
no_permission                   000512 constant        label                    dcl 171 ref 124
queue_interrupt                 000663 constant        entry                    external dcl 208
setup                           001551 constant        entry                    internal dcl 395 ref 123 184 218 228 243 252 313 347
tty_lock                        000244 constant        entry                    external dcl 14
unlock                          001566 constant        entry                    internal dcl 407 ref 169 200 234 246
unlock_channel                  000721 constant        entry                    external dcl 225
unlock_channel_int              000762 constant        entry                    external dcl 240
unlock_queue                    001766 constant        entry                    internal dcl 466 ref 193 196 222 322 327 384 524
verify                          001060 constant        entry                    external dcl 267

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2644        2714    2301        2654
Length      3270    2301        50         340     343           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tty_lock                            374 external procedure  is an external procedure.  
CLEANUP_LOCKS                           internal procedure  shares stack frame of external procedure tty_lock.  
setup                                   internal procedure  shares stack frame of external procedure tty_lock.  
unlock                                  internal procedure  shares stack frame of external procedure tty_lock.  
force_unlock                            internal procedure  shares stack frame of external procedure tty_lock.  
lock_queue                              internal procedure  shares stack frame of external procedure tty_lock.  
unlock_queue                            internal procedure  shares stack frame of external procedure tty_lock.  
enqueue                                 internal procedure  shares stack frame of external procedure tty_lock.  
dequeue                                 internal procedure  shares stack frame of external procedure tty_lock.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tty_lock                 000100 devx                        tty_lock
                         000101 subchan_devx                tty_lock
                         000102 tried                       tty_lock
                         000103 locked                      tty_lock
                         000104 i                           tty_lock
                         000106 wire_arg                    tty_lock
                         000110 wire_ptr                    tty_lock
                         000112 qep                         tty_lock
                         000114 qtp                         tty_lock
                         000116 prev_qep                    tty_lock
                         000120 next_qep                    tty_lock
                         000122 first_free_qep              tty_lock
                         000124 last_free_qep               tty_lock
                         000126 dequeue_all                 tty_lock
                         000127 int_type                    tty_lock
                         000130 int_data                    tty_lock
                         000132 start_wait_time             tty_lock
                         000134 wait_time                   tty_lock
                         000135 unlocked_something          tty_lock
                         000136 lctp                        tty_lock
                         000140 lctep                       tty_lock
                         000142 ttybp                       tty_lock

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          stac_mac            signal_op           ext_entry
stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
channel_manager$interrupt     channel_manager$queued_interrupt                            mcs_timer$verify_lock
pmut$unwire_unmask            pmut$wire_and_mask            pxss$addevent                 pxss$delevent
pxss$notify                   pxss$wait                     syserr                        tty_space_man$free_space
tty_space_man$get_space

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$io_no_permission pds$process_group_id          pds$process_id                tty_buf$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000243       110 000253       113 000267       114 000271       115 000273       116 000277       119 000300
    122 000313       123 000315       124 000316       126 000325       128 000332       131 000351       134 000370
    135 000371       136 000372       137 000374       140 000406       142 000410       143 000415       144 000417
    147 000421       148 000430       149 000433       152 000442       153 000450       154 000452       155 000453
    157 000457       159 000460       161 000462       162 000465       163 000471       166 000476       169 000511
    171 000512       174 000516       176 000525       180 000541       181 000544       182 000550       183 000551
    184 000552       185 000553       186 000560       189 000604       190 000605       192 000614       193 000615
    194 000616       196 000625       198 000626       200 000632       201 000633       204 000642       205 000644
    206 000647       208 000656       215 000672       216 000675       217 000701       218 000703       220 000704
    221 000705       222 000706       223 000707       225 000716       228 000730       230 000731       234 000750
    236 000751       240 000760       243 000771       245 000772       246 000775       247 000776       249 001005
    252 001016       254 001017       255 001025       256 001026       260 001035       263 001045       264 001046
    267 001055       270 001071       271 001072       308 001103       311 001116       312 001121       313 001125
    315 001126       317 001127       320 001140       322 001150       323 001151       325 001162       327 001170
    329 001171       331 001201       334 001214       335 001215       336 001222       339 001223       342 001236
    345 001240       347 001243       349 001244       356 001245       357 001251       358 001263       360 001270
    362 001303       365 001312       368 001321       373 001326       374 001330       377 001335       378 001340
    380 001341       381 001342       382 001343       384 001345       388 001346       389 001352       390 001357
    391 001372       393 001375       274 001404       277 001405       278 001406       279 001411       282 001433
    283 001436       285 001443       288 001466       290 001473       291 001503       292 001507       298 001541
    299 001543       300 001544       302 001546       304 001550       395 001551       398 001552       399 001555
    400 001557       401 001562       402 001565       407 001566       413 001567       414 001575       415 001600
    417 001616       418 001631       419 001634       421 001635       423 001641       424 001643       427 001652
    431 001653       438 001654       441 001712       442 001715       443 001723       445 001724       447 001730
    448 001732       451 001741       454 001742       457 001743       459 001754       460 001764       462 001765
    466 001766       469 001767       472 002015       474 002026       476 002027       480 002030       483 002035
    484 002050       486 002054       487 002077       490 002100       491 002103       492 002106       493 002110
    496 002123       497 002126       498 002130       500 002133       501 002135       503 002142       507 002143
    510 002145       511 002146       513 002153       514 002155       516 002202       519 002203       520 002206
    521 002210       524 002214       526 002215       529 002227       530 002232       531 002235       532 002240
    533 002253


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
