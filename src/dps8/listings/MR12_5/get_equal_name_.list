	COMPILATION LISTING OF SEGMENT get_equal_name_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1005.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       14 	/*									*/
       15 	/* N__a_m_e:  get_equal_name_							*/
       16 	/*									*/
       17 	/*      This subroutine implements the Multics Storage System Equals Convention.	*/
       18 	/* A target name is constructed by combining components and subcomponents from an 	*/
       19 	/* entry name and an equal name which are supplied as arguments.  The construction	*/
       20 	/* follows the rules given under "Equal Names" in Section 3 of the MPM Reference Guide.	*/
       21 	/*									*/
       22 	/* U__s_a_g_e									*/
       23 	/*									*/
       24 	/*      dcl  get_equal_name_ entry (char(*), char(*), char(32), fixed bin(35));		*/
       25 	/*									*/
       26 	/*      call get_equal_name_ (entry, equal, target, code);				*/
       27 	/*									*/
       28 	/* 1) entry	is the entry name. (In)					*/
       29 	/*									*/
       30 	/* 2) equal	is the equal name. (In)					*/
       31 	/*									*/
       32 	/* 3) target	is the target name which is constructed. (Out)			*/
       33 	/*									*/
       34 	/* 4) code	is a status code, which may be one of the following. (Out)		*/
       35 	/*									*/
       36 	/*    0		the target name was constructed without error.			*/
       37 	/*									*/
       38 	/*    error_table_$bad_equal_name						*/
       39 	/*		the equal name has a bad format.				*/
       40 	/*									*/
       41 	/*    error_table_$badequal							*/
       42 	/*		there was no letter or component in the entry name which corresponds	*/
       43 	/*		to a % or = in the equal name.  A null string will be used for the	*/
       44 	/*		missing letter or component in the target name which is returned.	*/
       45 	/*									*/
       46 	/*    error_table_$longeql							*/
       47 	/*		the target name to be constructed is longer than 32 characters.	*/
       48 	/*		Only the first 32 characters are returned.			*/
       49 	/*									*/
       50 	/* S__t_a_t_u_s									*/
       51 	/*									*/
       52 	/* 0) Created:  July, 1973 by G. C. Dixon					*/
       53 	/*	a) This program replaces equal_, which is now obsolete.			*/
       54 	/* 1) Modified: June 15, 1979 by G. Palter					*/
       55 	/*	a) Added the triple equal component.					*/
       56 	/* 2) Modified: 3 April 1981 by G. Palter					*/
       57 	/*	a) Added the component entrypoint for the archive component equal name	*/
       58 	/*	   convention							*/
       59 	/*	b) Added the check_equal_name_ entrypoint which validates the syntax and	*/
       60 	/*	   of a supplied equal name						*/
       61 	/*									*/
       62 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       63 
       64 
       65 
       66 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       67 	/*									*/
       68 	/* A__l_g_o_r_i_t_h_m								*/
       69 	/*									*/
       70 	/*      The basic algorithm used to construct the target name is:			*/
       71 	/*									*/
       72 	/* 1) Parse the equal name into components and subcomponents.			*/
       73 	/*    a) each name component is classified into one of the following types:		*/
       74 	/*	         _t_y_p_e      _f_o_r_m_a_t	_d_e_s_c_r_i_p_t_i_o_n				*/
       75 	/*		13	===	a triple equal sign component			*/
       76 	/*		14	==	a double equal sign component			*/
       77 	/*		15	OO	a component of one or more other characters	*/
       78 	/*				(characters besides "=", "%", or ".")		*/
       79 	/*		16	O=%	a component containing %'s or ='s and other chars	*/
       80 	/*		17	=	a single equal sign component			*/
       81 	/*		18	BAD	a bad equal name component format.		*/
       82 	/*    b) each component is, in turn, divided into one or more subcomponents of the	*/
       83 	/*       following types:							*/
       84 	/*	         _t_y_p_e      _f_o_r_m_a_t	_d_e_s_c_r_i_p_t_i_o_n				*/
       85 	/*		1	O's	a string of one or more consecutive other chars.	*/
       86 	/*		2	%'s	a string of one or more consecutive %'s.	*/
       87 	/*		3	='s	a string of one, two, or three consecutive ='s.	*/
       88 	/*       Thus, component types === (13), == (14), OO (15), and = (17) are each composed	*/
       89 	/*       of a single subcomponent, and component type O=% (16) is composed of two	*/
       90 	/*       or more components.							*/
       91 	/*									*/
       92 	/* 2) Parse the entry name into components.					*/
       93 	/*									*/
       94 	/* 3) Construct the target name from the parsed equal and entry names.		*/
       95 	/*									*/
       96 	/*      The hardest part of this process is the parsing of the equal name into components	*/
       97 	/* and subcomponents, while at the same time checking for a bad equal name.  The 	*/
       98 	/* current restraints on the format of equal names are:				*/
       99 	/*									*/
      100 	/* 1) The equal name is an entry name composed of 32 or fewer ASCII characters		*/
      101 	/*    or spaces, excluding ">" and "<".  That is,					*/
      102 	/*	0 < length(equal) <= 32						*/
      103 	/*	E_i <= PAD								*/
      104 	/*	       E_i ^= ">"							*/
      105 	/*	       E_i ^= "<"							*/
      106 	/*    where E_i are the characters of the equal name.				*/
      107 	/*									*/
      108 	/* 2) The equal name is composed of from one to sixteen components, none of which may	*/
      109 	/*    be null.  That is, the equal name may not begin or end with a period ("."), and	*/
      110 	/*    may not contain two or more consecutive periods.				*/
      111 	/*									*/
      112 	/* 3) Each component of an equal name may contain one or more %'s, each of which	*/
      113 	/*    represents the corresponding letter in the corresponding component of the entry	*/
      114 	/*    name.								*/
      115 	/*									*/
      116 	/* 4) Each equal name component may contain one =, which represents the corresponding	*/
      117 	/*    component of the entry name.  An equal component which contains an = may not	*/
      118 	/*    contain %'s.								*/
      119 	/*									*/
      120 	/* 5) An equal name may contain, at most, one == (double equal sign) component in	*/
      121 	/*    any component position which represents all components of the entry name		*/
      122 	/*    which are not represented by other components of the equal name.		*/
      123 	/*									*/
      124 	/* 6) An equal name may contain one or more === (triple equal sign) components in any	*/
      125 	/*    component position which represents the original name.  If === is used, no	*/
      126 	/*    == component or component containing %'s or ='s may be used.			*/
      127 	/*									*/
      128 	/*									*/
      129 	/*									*/
      130 	/*      Each component of the equal name is parsed by a finite state machine, the diagram	*/
      131 	/* of which is shown below.  The process of parsing each component begins in state _s_t_a_r_t	*/
      132 	/* and it continues through the machine, according to the characters of the equal name	*/
      133 	/* component ("=", "%", ".", or another character) until a period ends the component, or	*/
      134 	/* until all of the characters of the equal name have been exhausted.  The parsing	*/
      135 	/* process identifies bad equal names (terminal state B_A_D_), and it also classifies each	*/
      136 	/* valid  component as being one of the component types mentioned above.  The type is	*/
      137 	/* defined to be the state value of the finite state machine when the component has been	*/
      138 	/* parsed.  During the parsing, information about the location and length of each	*/
      139 	/* component and subcomponent is gathered for later use during the construction of the	*/
      140 	/* target name.								*/
      141 
      142 	/*                                                 _________
      143*	                                                  |         |
      144*	                                ------------------|  start  |--------------
      145*	                                |                %|________0_|=            |
      146*	                                |                  .|     |O              |
      147*	                                |                   |     |               |
      148*	                                |                   V     |               |
      149*	                                |                18(BAD)  |               |
      150*	                                |                         |               |
      151*	                                |                  _______V__              |
      152*	                                |                 |         |             |
      153*	                                |     ------------|    O    |--------     |
      154*	                                |     |          %|________1_|=      |     |
      155*	                                |     |            .|     |O        |     |
      156*	                                |     |             |     |         |     |
      157*	       16(O%=)   18(BAD)        |     |             V     |         |     |
      158*	            A     A             |     |          15(OO)   |         |     |
      159*	            |     |             |     |                   |         |     |
      160*	           .__|_______|=_  %        _V______V__           _______V__ O      |     |
      161*	      --->|         |-------->|         |        %|         |----   |     |
      162*	      |   |   %OO   |  ------>|    %    |<--------|   OO    |   |   |     |
      163*	      ----|________7_|  | -----|________4_|         |________5_|<---   |     |
      164*	         O     A       | |   O .| %|  |=           .|     |=        |     |
      165*	               |       | |      |  |  |             |     |         |     |
      166*	               |       | |      V  |  V             V     |         |     |
      167*	               |       | | 16(O%=) | 18(BAD)    15(OO)    |         |     |
      168*	               |       | |         |                      |         |     |
      169*	           ___O__|____ % | |     ____V_____ %         _______V__        |     |
      170*	          |         |--- |    |         |----     |         |       |     |
      171*	          |   %O    |<----    |   %%    |   |     |   O=    |<-------     |
      172*	          |________3_|<--------|________8_|<---     |________9_|             |
      173*	           .|     |=         O .|     |=           .|     |O              |
      174*	            |     |             |     |             |     |               |
      175*	            V     V             V     V             V     |               |
      176*	       16(O%=)   18(BAD)   16(O%=)   18(BAD)   16(O%=)    |               |
      177*	                                                          |               |
      178*	                                                   _______V__           ___V______
      179*	                                                %=|         |        O|         |%
      180*	                                       18(BAD)<---|   =O    |<--------|    =    |--->18(BAD)
      181*	                                                  |________2_|         |_______1_0_|
      182*	                                                   .|     |O           .|     |=
      183*	                                                    |     |             |     |
      184*	                                                    V     |             V     |
      185*	                                               16(O%=)    |          17(=)    |
      186*	          -------|                                        |                   |
      187*	          |   ___V______                            _______V___ O         _______V___
      188*	          |  |         |O%=                     %=|         |----     |         |O%
      189*	          |  |    ==   |--->18(BAD)    18(BAD)<---|   =OO   |   |     |   ==    |--->18(BAD)
      190*	          |  |______1_2__|                          |________6_|<---     |_______1_1_|
      191*	          |      .|                                   .|               =|    .|
      192*	          |       |                                    |                |     |
      193*	          |       V                                    V                |     V
      194*	          |     13(===)                             16(O%=)             |   14(==)
      195*		|						  |
      196*                    ---------------------------------------------------------------		
      197*										*/
      198 	/* The finite state machine is defined by the variable, nstate, in the program below.	*/
      199 
      200 
      201 get_equal_name_:	procedure (Aentry, Aequal, Atarget, code);
      202 
      203      dcl	Aentry			char(*),		/* the entry name. (In)			*/
      204 	Aequal			char(*),		/* the equal name. (In)			*/
      205 	Atarget			char(32),		/* the target name. (Out)			*/
      206 	code			fixed bin(35);	/* the status code returned.(Out)		*/
      207 
      208      dcl	P_entryname		char(*) parameter,	/* archive/entry name. (In)			*/
      209 	P_component		char(*) parameter,	/* component name. (In)			*/
      210 	P_equal_entryname		char(*) parameter,	/* archive/entry equal name. (In)		*/
      211 	P_equal_component		char(*) parameter,	/* component equal name. (In)			*/
      212 	P_target_entryname		char(32) parameter, /* target archive/entry name. (Out)		*/
      213 	P_target_component		char(32) parameter; /* target component name. (Out)		*/
      214 
      215      dcl	P_equalname		char(*) parameter;	/* equal name to be validated. (In)		*/
      216 
      217      dcl	1 Cen (33)		aligned automatic,	/* array elements identify entry name components.	*/
      218 	  2 Ien			fixed bin,	/* index of component into entry name.		*/
      219 	  2 Len			fixed bin,	/* length of component.			*/
      220 	1 Ceq (17)		aligned automatic,	/* array elements identify equal name components.	*/
      221 	  2 Ieq			fixed bin,	/* index of component into equal name.		*/
      222 	  2 Leq			fixed bin,	/* length of component.			*/
      223 	  2 Teq			fixed bin,	/* type of component:			*/
      224 						/*   13 = === (triple equal sign component)	*/
      225 						/*   14 = == (double equal sign component)	*/
      226 						/*   15 = O or OO				*/
      227 						/*   16 = O=, =O, =OO, %, %%, %O, or %OO	*/
      228 						/*   17 = = (single equal sign component)	*/
      229 						/*   18 = bad equal name format		*/
      230 	  2 SCeq			fixed bin,	/* index into Csub of 1st subcomponent of this	*/
      231 						/* component.				*/
      232 	1 Csub (32)		aligned,		/* table of subcomoponents of the equal name.	*/
      233 	  2 Isub			fixed bin,	/* index into component of start of subcomponent.	*/
      234 	  2 Lsub			fixed bin,	/* length of subcomponent.		*/
      235 	  2 Tsub			fixed bin,	/* type of subcomponent:			*/
      236 						/*   1 = O's (other chars besides =, %, or .)	*/
      237 						/*   2 = %'s				*/
      238 						/*   3 = =				*/
      239 	Lentry			fixed bin,	/* real length of the entry name.		*/
      240 	Lequal			fixed bin,	/* real length of the equal name.		*/
      241 	Nen			fixed bin,	/* number of components in the entry name.	*/
      242 	Neq			fixed bin,	/* number of components in the equal name.	*/
      243 	Nequalequal		fixed bin,	/* number of any double equal sign component.	*/
      244 	Nsub			fixed bin,	/* number of subcomponents in the equal name.	*/
      245 	archive_equal_code		fixed bin(35),	/* status code for archive name's processing.	*/
      246 	char			char(1) aligned,	/* a character temp.			*/
      247 	double_equal		bit(1) aligned,	/* on if == component has already been parsed.	*/
      248 	triple_equal		bit(1) aligned,	/* on if one or more === components found.	*/
      249 	other_equal		bit(1) aligned,	/* on if components with %'s or ='s found.	*/
      250 	check_entry		bit(1) aligned,	/* on if check_equal_name_ called.		*/
      251 	original_archive		bit(1) aligned,	/* on if original name has archive & component.	*/
      252 	target_archive		bit(1) aligned,	/* on if target will have archive & component.	*/
      253 	entry			char(32) aligned,	/* aligned copy of entry name.		*/
      254 	equal			char(32) aligned,	/* aligned copy of equal name.		*/
      255 	entryname			char(32),		/* copy of input archive name w/o ".archive".	*/
      256 	equal_entryname		char(32),		/* copy of archive equal name w/o ".archive".	*/
      257 	i			fixed bin,	/* a do-group index.			*/
      258 	j			fixed bin,	/* a do-group index.			*/
      259 	state			fixed bin,	/* number of finite state machine's current state.*/
      260 	target			char(34) varying aligned;
      261 						/* target name being constructed.  Its 1st char	*/
      262 						/* is always a "." which is ignored.  After	*/
      263 						/* construction, if its length is greater than	*/
      264 						/* 33 (32 + 1st char), then it is too long.	*/
      265 
      266      dcl	1 Oentry			aligned based (addr (entry)),
      267 	  2 char (33)		char(1) unal,	/* overlay for entry name.			*/
      268 	1 Oequal			aligned based (addr (equal)),
      269 	  2 char (33)		char(1) unal;	/* overlay for equal name.			*/
      270 
      271      dcl (addr, length, rtrim, substr)	builtin;
      272 
      273      dcl	PAD			char(1) aligned static options (constant) initial (""),
      274 						/* An ASCII PAD character \177.		*/
      275 	Tbad			fixed binary static options (constant) initial (18),
      276 						/* type code used for bad star name.		*/
      277 	Tequal			fixed binary static options (constant) initial (17),
      278 						/* type code used for single equal name component	*/
      279 	Totherother		fixed binary static options (constant) initial (15),
      280 						/* type code used for simple component.		*/
      281 	Tequalequal		fixed binary static options (constant) initial (14),
      282 						/* type code used for double equal name component.*/
      283 	Tequalequalequal		fixed binary static options (constant) initial (13),
      284 						/* type code used for triple equal name component.*/
      285 
      286          (error_table_$bad_equal_name,
      287 	error_table_$badequal,
      288 	error_table_$entlong,
      289 	error_table_$longeql,
      290 	error_table_$no_archive_for_equal)
      291 				fixed binary (35) external,
      292 
      293 	nstate (0:12, 4)		fixed binary static options (constant) initial (
      294 				/*							*/
      295 				/*	TABLE OF NEXT STATES				*/
      296 				/*							*/
      297 				/* Current	 E q u a l   N a m e   C h a r a c t e r	*/
      298 				/* _S__t_a_t_e_	"_._"_	"_=_"_	"_%_"_     O__t_h_e_r		*/
      299 				/*							*/
      300 				/*    0	*/	18,	10,	 4,	 1,
      301 				/*    1	*/	15,	 9,	 4,	 5,
      302 				/*    2	*/	16,	18,	18,	 6,
      303 				/*    3	*/	16,	18,	 4,	 7,
      304 				/*    4	*/	16,	18,	 8,	 3,
      305 				/*    5	*/	15,	 9,	 4,	 5,
      306 				/*    6	*/	16,	18,	18,	 6,
      307 				/*    7	*/	16,	18,	 4,	 7,
      308 				/*    8	*/	16,	18,	 8,	 3,
      309 				/*    9	*/	16,	18,	18,	 2,
      310 				/*   10	*/	17,	11,	18,	 2,
      311 				/*   11	*/	14,	12,	18,	18,
      312 				/*   12   */	13,	18,	18,	18);
      313 
      314 /*  */
      315 
      316 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      317 
      318 
      319 
      320 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      321 	/*									*/
      322 	/*	1) compute and validate real length of equal name.			*/
      323 	/*	2) parse equal name into components and subcomponents.			*/
      324 	/*									*/
      325 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      326 
      327 	check_entry = "0"b;
      328 
      329 	Lequal = length (rtrim (Aequal));
      330 	if Lequal > 32 then				/* an equal name longer than 32 chars is bad.	*/
      331 	     go to bad_equal_name;
      332 	if Lequal = 0 then				/* a null equal name is bad.			*/
      333 	     go to bad_equal_name;
      334 
      335 	equal = Aequal;				/* copy equal name to aligned temp for efficiency.*/
      336 
      337 	call parse_equal_name;			/* parse it into components and subcomponents.	*/
      338 
      339 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      340 	/*									*/
      341 	/*	1) compute real length of entry name, making sure its not too long.		*/
      342 	/*	2) if equal name was "===",  "==", "==.=", or "=.==" then look no further.	*/
      343 	/*	   Target is a copy of the entry name.					*/
      344 	/*	3) else finish computing length of entry name.				*/
      345 	/*	4) parse entry name into components.					*/
      346 	/*									*/
      347 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      348 
      349 	Lentry = length (rtrim (Aentry));
      350 	if Lentry > 32 then				/* ignore any chars beyond the 32nd.		*/
      351 	     Lentry = 32;
      352 
      353 	if Neq = 1 then
      354 	     if (Teq(1) = Tequalequalequal) | (Teq(1) = Tequalequal) then
      355 		go to copy;			/* equal = "===" or "=="			*/
      356 	     else;
      357 	else if Neq = 2 then
      358 	     if Teq(1) = Tequalequal then
      359 		if Teq(2) = Tequal then
      360 		     go to copy;			/* equal = "==.="				*/
      361 		else;
      362 	     else if Teq(1) = Tequal then
      363 		if Teq(2) = Tequalequal then
      364 		     go to copy;			/* equal = "=.=="				*/
      365 
      366 	entry = Aentry;				/* copy entry name to aligned temp for efficiency.*/
      367 
      368 	Nen = 1;					/* parse entry name into components.		*/
      369 	Ien(1) = 1;
      370 	Len(1) = 0;
      371 	do i = 1 to Lentry;
      372 	     if Oentry.char(i) = "." then do;
      373 		Nen = Nen + 1;
      374 		Ien(Nen) = i + 1;
      375 		Len(Nen) = 0;
      376 		end;
      377 	     else
      378 		Len(Nen) = Len(Nen) + 1;
      379 	     end;
      380 
      381 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      382 	/*									*/
      383 	/*	Build target name from entry name and equal name by:			*/
      384 	/*	1) constructing target components corresponding to the equal name components 	*/
      385 	/*	   appearing before any double equal sign component.			*/
      386 	/*	2) constructing target components corresponding to the double equal sign.	*/
      387 	/*	3) constructing target components corresponding to the equal name components	*/
      388 	/*	   appearing after any double equal sign component.			*/
      389 	/*									*/
      390 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      391 
      392 	target = "";				/* initialize the target. So far, it has 0 length.*/
      393 	code = 0;					/* initialize return code, so that copy programs	*/
      394 						/* can fill in error code if they find one.	*/
      395 	if double_equal then do;			/* if a double equal sign component was found,	*/
      396 	     do i = 1 to Nequalequal - 1;		/* first process equal components up to ==.	*/
      397 		target = target || ".";		/* append "." to target ("." preceding 1st 	*/
      398 						/* component will be ignored when copying target	*/
      399 						/* into Atarget, below).			*/
      400 		call copy_ (i, i);
      401 		end;
      402 
      403 	     do i = Nequalequal to Nen - (Neq - Nequalequal);
      404 		target = target || ".";		/* then process components of entry name which	*/
      405 		call copy_ (Nequalequal, i);		/* correspond to the ==.			*/
      406 		end;
      407 
      408 	     Nequalequal = i - Nequalequal - 1;
      409 	     do i = i to Nen;			/* finally, process remaining components of 	*/
      410 		target = target || ".";		/* the equal name.				*/
      411 		call copy_ (i - Nequalequal, i);
      412 		end;
      413 
      414 	     do i = i + 1 to Neq;			/* if there were no components of entry name	*/
      415 		target = target || ".";		/* which correspond to the == component, then	*/
      416 		call copy_ (i, i);			/* copy any remaining components of equal name	*/
      417 		end;				/* into the target name.			*/
      418 	     end;
      419 
      420 	else 					/* if no double equal sign component was found,	*/
      421 	     do i = 1 to Neq;			/* then just process each equal name component.	*/
      422 		target = target || ".";
      423 		call copy_ (i, i);
      424 		end;
      425 
      426 	Atarget = substr (target, 2);			/* copy target into parm, ignoring 1st "."	*/
      427 	if length (target) > 33 then			/* if target (minus leading ".") was too long,	*/
      428 	     go to long;				/* then tell caller.			*/
      429 	return;
      430 
      431 
      432 copy:	Atarget = Aentry;				/* The target name is the same as the entry name.	*/
      433 	code = 0;
      434 	return;
      435 
      436 bad_equal_name:
      437 	code = error_table_$bad_equal_name;		/* The equal name has a bad format.		*/
      438 	if ^check_entry then
      439 	     Atarget = "";
      440 	return;
      441 
      442 long:	code = error_table_$longeql;			/* the target would be too long.		*/
      443 	return;
      444 
      445 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      446 /*  */
      447 
      448 /* Implement the archive component pathname equal convention:  See MPM Reference Guide for a description of this
      449*   convention */
      450 
      451 component:
      452      entry (P_entryname, P_component, P_equal_entryname, P_equal_component, P_target_entryname, P_target_component, code);
      453 
      454 	P_target_entryname, P_target_component = "";	/* initialize output parameters */
      455 	code = 0;
      456 
      457 	if (length (rtrim (P_entryname)) > 32) | (length (rtrim (P_component)) > 32)
      458 	then do;					/* original name is too long */
      459 	     code = error_table_$entlong;
      460 	     return;
      461 	end;
      462 
      463 	if (length (rtrim (P_equal_entryname)) > 32) | (length (rtrim (P_equal_component)) > 32)
      464 	then do;					/* equal name is too long */
      465 COMPONENT_BAD_EQUAL_NAMES:
      466 	     code = error_table_$bad_equal_name;
      467 	     return;
      468 	end;
      469 
      470 	if (P_equal_entryname = "") then		/* this one can not be a null string */
      471 	     go to COMPONENT_BAD_EQUAL_NAMES;
      472 
      473 
      474 /* Classify the original and target names with respect to archive components */
      475 
      476 	original_archive = (P_component ^= "");		/* original name uses archive components */
      477 
      478 	target_archive = (P_equal_component ^= "");	/* target name will use archive components */
      479 
      480 
      481 	if ^original_archive & ^target_archive
      482 	then do;
      483 
      484 /* Case 1: original and target names are not archive component names */
      485 
      486 	     call get_equal_name_ (P_entryname, P_equal_entryname, P_target_entryname, code);
      487 	end;					/* do the actual work */
      488 
      489 
      490 	else if original_archive & ^target_archive
      491 	then do;
      492 
      493 /* Case 2: original is archive component name and target is not an archive component name:  Apply the equal name specified
      494*	 for the target to the component name of the original */
      495 
      496 	     call get_equal_name_ (P_component, P_equal_entryname, P_target_entryname, code);
      497 	end;
      498 
      499 
      500 	else if ^original_archive & target_archive
      501 	then do;
      502 
      503 /* Case 3: original name is not an archive name and the target is an archive name:  Apply the equal name provided for the
      504*	 target component to the original entryname; if an equal name is specified for the target archive, this use of
      505*	 the archive component pathname equal name convention is in error */
      506 
      507 	     call check_equal_name_ (P_equal_entryname, archive_equal_code);
      508 
      509 	     if (archive_equal_code ^= 0) then		/* bad syntax or equal convention is used */
      510 		if (archive_equal_code = 1) | (archive_equal_code = 2) then
      511 		     code = error_table_$no_archive_for_equal;
      512 		else code = archive_equal_code;	/* bad syntax in equal name */
      513 
      514 	     else					/* archive name doesn't use equal convention: OK so far */
      515 	     if add_archive_suffix (P_equal_entryname, P_target_entryname) then
      516 		call get_equal_name_ (P_entryname, P_equal_component, P_target_component, code);
      517 
      518 	     else code = error_table_$entlong;		/* archive name too long for ".archive" suffix */
      519 	end;
      520 
      521 
      522 	else do;
      523 
      524 /* Case 4: both original and target are archive component pathnames:  Apply the equal name to each part; strip the
      525*	 ".archive" suffix from the archive names first, however */
      526 
      527 	     call check_equal_name_ (P_equal_entryname, code);
      528 		if (code > 2) then return;		/* illegal equal name */
      529 
      530 	     call check_equal_name_ (P_equal_component, code);
      531 		if (code > 2) then return;
      532 
      533 	     entryname = strip_archive_suffix (P_entryname);
      534 	     equal_entryname = strip_archive_suffix (P_equal_entryname);
      535 
      536 	     call get_equal_name_ (entryname, equal_entryname, P_target_entryname, archive_equal_code);
      537 
      538 	     if (archive_equal_code = 0) | (archive_equal_code = error_table_$longeql) then
      539 		call get_equal_name_ (P_component, P_equal_component, P_target_component, code);
      540 	     else do;				/* bad syntax or something */
      541 		code = archive_equal_code;
      542 		return;
      543 	     end;
      544 
      545 	     if add_archive_suffix (P_target_entryname, P_target_entryname)
      546 		then;				/* archive name is fine: use code from component */
      547 	     else code = error_table_$longeql;		/* couldn't form the archive name */
      548 	end;
      549 
      550 	return;
      551 
      552 /*  */
      553 
      554 /* Validates the syntax of a supplied equal name and whether the name actually employs the equal convention */
      555 
      556 check_equal_name_:
      557      entry (P_equalname, code);
      558 
      559 	check_entry = "1"b;
      560 
      561 	Lequal = length (rtrim (P_equalname));
      562 
      563 	if (Lequal = 0) | (Lequal > 32) then		/* too long or short */
      564 	     code = error_table_$bad_equal_name;
      565 
      566 	equal = P_equalname;			/* copy into area used for parsing */
      567 
      568 	call parse_equal_name ();			/* parse it as best you can */
      569 
      570 	if (other_equal | double_equal | triple_equal) then
      571 						/* some form of equal convention is used */
      572 	     if (Neq = 1) then			/* 1 component */
      573 		if (Teq(1) = Tequalequalequal) | (Teq(1) = Tequalequal) then
      574 		     code = 2;			/* "===" or "==": target will be same as original */
      575 		else code = 1;			/* target is some variant of original */
      576 
      577 	     else if (Neq = 2) then			/* 2 components */
      578 		if ((Teq(1) = Tequalequal) & (Teq(2) = Tequal)) | ((Teq(1) = Tequal) & (Teq(2) = Tequalequal)) then
      579 		     code = 2;			/* "==.=" or "=.==": target will be same as original */
      580 		else code = 1;			/* target is some variant of original */
      581 
      582 	     else code = 1;				/* > 2 components: target is some variant of original */
      583 
      584 	else code = 0;				/* equal convention not used: target bears no resemblence to
      585*						   the original name */
      586 	return;
      587 
      588 /*  */
      589 
      590 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      591 
      592 
      593 
      594 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      595 	/*									*/
      596 	/*	This internal procedure parses an equal name into classified components,	*/
      597 	/*	and further parses each component into classified subcomponents.  The 	*/
      598 	/*	equal name is assumed to reside in _e_q_u_a_l, and L__e_q_u_a_l is assumed to be		*/
      599 	/*	its length.							*/
      600 	/*									*/
      601 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      602 
      603 parse_equal_name:	procedure;
      604 
      605 
      606 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      607 	/*									*/
      608 	/*	1) Initialize variables used to parse the equal name.			*/
      609 	/*									*/
      610 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      611 
      612 	state = 0;				/* start parsing with finite state machine in	*/
      613 	double_equal = "0"b;			/* state zero.  No == components encountered yet.	*/
      614 	Nequalequal = 0;
      615 	triple_equal = "0"b;
      616 	other_equal = "0"b;
      617 
      618 	Neq = 1;					/* Start parsing 1st equal name component.	*/
      619 	Ieq(1) = 1;				/* 1st component starts with 1st char of equal	*/
      620 	Leq(1) = 0;				/* name, and has zero length so far.		*/
      621 	SCeq(1) = 1;				/* 1st subcomponent in 1st component		*/
      622 
      623 	Nsub = 0;					/* No subcomponents have been found so far.	*/
      624 						/* is subcomponent number 1.			*/
      625 
      626 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      627 	/*									*/
      628 	/* 	Use the finite state machine to parse the equal name, 1 char at a time.	*/
      629 	/*	1) validate each character (char ^= ">", ^= "<", <= PAD)			*/
      630 	/*	2) transfer to next parsing state, according to character value (".", "=", "%",	*/
      631 	/*	   or another char.							*/
      632 	/*	3) each non-terminal state updates the information in the component and	*/
      633 	/*	   subcomponent array tables which record the location and length of each	*/
      634 	/*	   component, and the location (relative to the start of the component), and	*/
      635 	/*	   length of each subcomponent.  Each terminal state updates the indices into	*/
      636 	/*	   these arrays, prior to starting to parse the next component and subcomponent.*/
      637 	/*									*/
      638 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      639 
      640 
      641 	do i = 1 to Lequal;
      642 	     char = Oequal.char(i);			/* copy char for efficiency.			*/
      643 	     if char = "." then
      644 		state = nstate (state, 1);
      645 	     else if char = "=" then
      646 		state = nstate (state, 2);
      647 	     else if char = "%" then
      648 		state = nstate (state, 3);
      649 	     else if char = ">" then
      650 		go to bad_equal_name;
      651 	     else if char = "<" then
      652 		go to bad_equal_name;
      653 	     else if char > PAD then
      654 		go to bad_equal_name;
      655 	     else
      656 		state = nstate (state, 4);
      657 	     go to parse (state);
      658 
      659 parse(1):						/* state = O; input char was another.		*/
      660 parse(2):						/* state = O=; input char was another.		*/
      661 parse(3):						/* state = %O; input char was another.		*/
      662 	     Nsub = Nsub + 1;			/* this char starts a new subcomponent.		*/
      663    	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
      664 	     Lsub(Nsub) = 1;			/* subcomponent, and start with length of 1.	*/
      665 	     Tsub(Nsub) = 1;			/* record subcomponent type of 1 (O's).		*/
      666 	     go to next_char;
      667 
      668 parse(4):						/* state = %; input char was %.		*/
      669 	     Nsub = Nsub + 1;			/* this char starts a new subcomponent.		*/
      670 	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
      671 	     Lsub(Nsub) = 1;			/* subcomponent, and start with length of 1.	*/
      672 	     Tsub(Nsub) = 2;			/* record subcomponent type of 2 (%'s).		*/
      673 	     go to next_char;
      674 
      675 parse(5):						/* state = OO; input char was another.		*/
      676 parse(6):						/* state = =OO; input char was another.		*/
      677 parse(7):						/* state = %OO; input char was another.		*/
      678 parse(8):						/* state = %%; input char was %.		*/
      679 	     Lsub(Nsub) = Lsub(Nsub) + 1;		/* add this char to length count of subcomponent.	*/
      680 	     go to next_char;
      681 
      682 parse(9):	     					/* state = O=; input char was =		*/
      683 parse(10):					/* state = =; input char was =		*/
      684 	     Nsub = Nsub + 1;			/* this char begins a new subcomponent.		*/
      685 	     Isub(Nsub) = Leq(Neq) + 1;		/* record index into component of start of	*/
      686 	     Lsub(Nsub) = 1;			/* subcomponent, and start with a length of 1.	*/
      687 	     Tsub(Nsub) = 3;			/* record subcomponent type of 3 (=).		*/
      688 	     go to next_char;
      689 
      690 parse(11):					/* state = ==; input char was =		*/
      691 parse(12):					/* state = ===; input char was =		*/
      692 	     go to next_char;			/* nothing req'd for == or === component.	*/
      693 
      694 
      695 
      696 parse(13):					/* terminal state = ===; input char was "."	*/
      697 	     triple_equal = "1"b;
      698 	     go to finish_component;
      699 
      700 parse(14):					/* terminal state = ==; input char was "."	*/
      701 	     if double_equal then			/* make sure there's only 1 double equal sign 	*/
      702 		go to bad_equal_name;		/* in the equal name.			*/
      703 	     double_equal = "1"b;
      704 	     Nequalequal = Neq;
      705 	     go to finish_component;
      706 
      707 parse(15):					/* terminal state = O or OO			*/
      708 parse(16):					/* terminal state = O=, =O, =OO, %, %%, %O or %OO	*/
      709 parse(17):					/* terminal state = =			*/
      710 						/* input char was "."			*/
      711 	     if state ^= Totherother then		/* have some use of equals convention.		*/
      712 		other_equal = "1"b;
      713 
      714 finish_component:
      715 	     Teq(Neq) = state;			/* type of this component is state number.	*/
      716 	     Neq = Neq + 1;				/* prepare to process the next component.	*/
      717 	     Ieq(Neq) = i+1;			/* next component begins with next character.	*/
      718 	     Leq(Neq) = -1;				/* it has 0 length so far.			*/
      719 						/* (This value will be 0 when it is updated to	*/
      720 						/*  reflect the "." we're processing now.)	*/
      721 	     SCeq(Neq) = Nsub + 1;			/* component begins with next subcomponent.	*/
      722 	     state = 0;				/* switch to the state used to begin parsing a	*/
      723 	     go to next_char;			/* component.				*/
      724 
      725 parse(18):     					/* terminal state = bad equal name format.	*/
      726 	     go to bad_equal_name;
      727 
      728 next_char:     Leq(Neq) = Leq(Neq) + 1;			/* update component's length to include current	*/
      729 	     end;					/* input char, then parse the next input char.	*/
      730 
      731 	state = nstate (state, 1);			/* fudge contents of component array to make it	*/
      732 	if state = Tbad then			/* look like equal name ended with a null	*/
      733 	     go to bad_equal_name;			/* component.  Fill in state of last component	*/
      734 	else if state = Tequalequal then do;		/* if state is valid (not bad equal name state,	*/
      735 	     if double_equal then			/* or 2nd double equal component).		*/
      736 		go to bad_equal_name;
      737 	     double_equal = "1"b;
      738 	     Nequalequal = Neq;
      739 	     end;
      740 	else if state = Tequalequalequal then
      741 	     triple_equal = "1"b;
      742 	else if state ^= Totherother then
      743 	     other_equal = "1"b;
      744 
      745 	Teq(Neq) = state;
      746 	SCeq(Neq + 1) = Nsub + 1;
      747 
      748 	if triple_equal & (other_equal | double_equal) then
      749 	     go to bad_equal_name;			/* may not have === with any other type.	*/
      750 
      751 	end parse_equal_name;
      752 
      753 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      754 
      755 
      756 /*  */
      757 
      758 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      759 
      760 
      761 
      762 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      763 	/*									*/
      764 	/*	This internal procedure constructs a target name component from an entry name	*/
      765 	/*	component and an equal name component.  A different type of construction is	*/
      766 	/*	used to each type of equal name component.				*/
      767 	/*									*/
      768 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      769 
      770 
      771 copy_:	procedure	(Xeq, Xen);
      772 
      773      dcl	Xeq			fixed bin,	/* number of equal name component.		*/
      774 	Xen			fixed bin;	/* number of entry name component.		*/
      775 
      776      dcl	Is			fixed bin,	/* index of subcomponent to be copied, relative to*/
      777 						/* start of component in entry name or equal name.*/
      778 	Leq			fixed bin,	/* length of equal name component.		*/
      779 	Len			fixed bin,	/* length of entry name component.		*/
      780 	Ls			fixed bin,	/* length of subcomponent.			*/
      781 	Peq			ptr,		/* ptr to equal name component.		*/
      782 	Pen			ptr,		/* ptr to entry name component.		*/
      783 	Ps			ptr;		/* ptr to subcomponent to be copied.		*/
      784 
      785      dcl	en			char(Len) based (Pen),
      786 						/* the entry name component.			*/
      787 	eq			char(Leq) based (Peq),
      788 						/* the equal name component.			*/
      789 	s			char(Ls) based (Ps);/* subcomponent to be copied.			*/
      790 
      791 	Peq = addr (Oequal.char(Ieq(Xeq)));		/* overlay the equal name component.		*/
      792 	Leq = Ceq(Xeq).Leq;
      793 	if Xen <= Nen then do;			/* if an entry component corresponding to the	*/
      794 						/* equal component exists, then		*/
      795 	     Pen = addr (Oentry.char(Ien(Xen)));	/* overlay the entry name component.		*/
      796 	     Len = Cen(Xen).Len;
      797 	     end;
      798 	else do;					/* otherwise, use a null entry component.	*/
      799 	     Pen = Peq;
      800 	     Len = 0;
      801 	     end;
      802 
      803 	go to copy (Teq(Xeq));			/* perform construction, according to type of	*/
      804 						/* equal name component.			*/
      805 
      806 copy(13):						/* equal component is ===			*/
      807 	target = target || substr (entry, 1, Lentry);	/* add original name to target.		*/
      808 	return;
      809 
      810 copy(14):						/* equal component is ==			*/
      811 	target = target || en;			/* add entry name component to target.		*/
      812 	return;
      813 
      814 copy(15):						/* equal component is O or OO			*/
      815 	target = target || eq;			/* add equal name component to the target.	*/
      816 	return;
      817 
      818 
      819 copy(16):						/* equal component is %, %%, %O, %OO, O=, =O, 	*/
      820 						/* or =OO					*/
      821 	if Xen > Nen then				/* an entry name component corresponding to the	*/
      822 	     code = error_table_$badequal;		/* equal name component must exist.  If it doesn't*/
      823 						/* report the error and assume a null entry name	*/
      824 						/* component exists.			*/
      825 	do j = SCeq(Xeq) to SCeq(Xeq+1) - 1;		/* process each subcomponent of equal name, 	*/
      826 	     go to sub_comp(Tsub(j));			/* where each subcomponent type is a special case	*/
      827 
      828 sub_comp(1):   					/* type 1: OO's				*/
      829 	     Ps = addr (substr (eq, Isub(j)));		/* overlay subcomponent of equal component.	*/
      830 	     Ls = Lsub(j);
      831 	     target = target || s;			/* add subcomponent to target.		*/
      832 	     go to end_sub_loop;
      833 
      834 sub_comp(2):					/* type 2: %%'s				*/
      835 	     Is = Isub(j);				/* get index and length of subcomponent.	*/
      836 	     Ls = Lsub(j);
      837 	     if Is+Ls-1 > Len then do;		/* if entry component isn't long enough to	*/
      838 		code = error_table_$badequal;		/* have characters corresponding to the %'s of the*/
      839 		if Is > Len then do;		/* equal component, then report error to caller,	*/
      840 		     Is = 1;			/* and adjust index and length of subcomponent to	*/
      841 		     Ls = 0;			/* use whatever corresponding characters are there*/
      842 		     end;
      843 		else
      844 		     Ls = Len - Is + 1;
      845 		end;
      846 	     Ps = addr (substr (en, Is));		/* get ptr to entry name subcomponent.		*/
      847 	     target = target || s;			/* add subcomponent to target name.		*/
      848 	     go to end_sub_loop;
      849 
      850 sub_comp(3):					/* type 3: =				*/
      851 	     target = target || en;			/* add entry name to target.			*/
      852 end_sub_loop:  end;
      853 	return;
      854 
      855 
      856 copy(17):						/* equal component is =			*/
      857 	if Xen > Nen then				/* if entry component corresponding to equal	*/
      858 	     code = error_table_$badequal;		/* component, tell caller and assume null entry	*/
      859 						/* component.				*/
      860 	else					/* otherwise, add entry component to target.	*/
      861 	     target = target || en;
      862 
      863 	end copy_;
      864 
      865 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      866 
      867 /*  */
      868 
      869 /* Adds the suffix ".archive" to the supplied name if not already present and returns "1"b if the resulting name is OK */
      870 
      871 add_archive_suffix:
      872 	procedure (p_input_name, p_output_name) returns (bit (1) aligned);
      873 
      874 dcl (p_input_name, p_output_name) character (*) parameter;
      875 dcl  temporary_name character (33) varying;
      876 
      877 	     temporary_name = rtrim (p_input_name);
      878 
      879 	     if (temporary_name = ".archive") then	/* bad format */
      880 		go to COMPONENT_BAD_EQUAL_NAMES;
      881 
      882 	     else if (length (temporary_name) < length ("X.archive")) then
      883 		temporary_name = temporary_name || ".archive";
      884 
      885 	     else if (substr (temporary_name, (length (temporary_name) - length (".archive") + 1)) ^= ".archive") then
      886 		temporary_name = temporary_name || ".archive";
      887 
      888 	     p_output_name = temporary_name;
      889 
      890 	     if length (temporary_name) > 32 then
      891 		return ("0"b);			/* adding the suffix made the name too long */ 
      892 	     else return ("1"b);
      893 
      894 	end add_archive_suffix;
      895 
      896 /*  */
      897 
      898 /* Strip the ".archive" suffix from the name, if present */
      899 
      900 strip_archive_suffix:
      901 	procedure (p_input_name) returns (character (32));
      902 
      903 dcl  p_input_name character (*) parameter;
      904 dcl  temporary_name character (32) varying;
      905 
      906 	     temporary_name = rtrim (p_input_name);
      907 
      908 	     if (temporary_name = ".archive") then
      909 		go to COMPONENT_BAD_EQUAL_NAMES;
      910 
      911 	     else if (length (temporary_name) < length ("X.archive")) then
      912 		return (temporary_name);
      913 
      914 	     else if (substr (temporary_name, (length (temporary_name) - length (".archive") + 1)) ^= ".archive") then
      915 		return (temporary_name);
      916 
      917 	     else return (substr (temporary_name, 1, (length (temporary_name) - length (".archive"))));
      918 
      919 	end strip_archive_suffix;
      920 
      921 	end get_equal_name_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.1  get_equal_name_.pl1               >spec>install>1110>get_equal_name_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Aentry                                 parameter       char                     packed unaligned dcl 203 ref 201 349 366 432
Aequal                                 parameter       char                     packed unaligned dcl 203 ref 201 329 335
Atarget                                parameter       char(32)                 packed unaligned dcl 203 set ref 201 426* 432* 438*
Cen                             000100 automatic       structure                array level 1 dcl 217
Ceq                             000202 automatic       structure                array level 1 dcl 217
Csub                            000306 automatic       structure                array level 1 dcl 217
Ien                             000100 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 369* 374* 795
Ieq                             000202 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 619* 717* 791
Is                              000570 automatic       fixed bin(17,0)          dcl 776 set ref 834* 837 839 840* 843 846
Isub                            000306 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 663* 670* 685* 828 834
Len                       1     000100 automatic       fixed bin(17,0)          array level 2 in structure "Cen" dcl 217
                                                                                  in procedure "get_equal_name_" set ref 370* 375*
                                                                                  377* 377 796
Len                             000572 automatic       fixed bin(17,0)          dcl 776 in procedure "copy_" set ref 796* 800* 810
                                                                                  837 839 843 846 850 860
Lentry                          000446 automatic       fixed bin(17,0)          dcl 217 set ref 349* 350 350* 371 806
Leq                             000571 automatic       fixed bin(17,0)          dcl 776 in procedure "copy_" set ref 792* 814 828
Leq                       1     000202 automatic       fixed bin(17,0)          array level 2 in structure "Ceq" dcl 217
                                                                                  in procedure "get_equal_name_" set ref 620* 663
                                                                                  670 685 718* 728* 728 792
Lequal                          000447 automatic       fixed bin(17,0)          dcl 217 set ref 329* 330 332 561* 563 563 641
Ls                              000573 automatic       fixed bin(17,0)          dcl 776 set ref 830* 831 836* 837 841* 843* 847
Lsub                      1     000306 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 664* 671* 675* 675
                                                                                  686* 830 836
Nen                             000450 automatic       fixed bin(17,0)          dcl 217 set ref 368* 373* 373 374 375 377 377 403
                                                                                  409 793 819 856
Neq                             000451 automatic       fixed bin(17,0)          dcl 217 set ref 353 357 403 414 420 570 577 618* 663
                                                                                  670 685 704 714 716* 716 717 718 721 728 728 738
                                                                                  745 746
Nequalequal                     000452 automatic       fixed bin(17,0)          dcl 217 set ref 396 403 403 405* 408* 408 411 614*
                                                                                  704* 738*
Nsub                            000453 automatic       fixed bin(17,0)          dcl 217 set ref 623* 659* 659 663 664 665 668* 668
                                                                                  670 671 672 675 675 682* 682 685 686 687 721 746
Oentry                                 based           structure                level 1 dcl 266
Oequal                                 based           structure                level 1 dcl 266
PAD                                    constant        char(1)                  initial dcl 273 ref 653
P_component                            parameter       char                     packed unaligned dcl 208 set ref 451 457 476 496*
                                                                                  538*
P_entryname                            parameter       char                     packed unaligned dcl 208 set ref 451 457 486* 514*
                                                                                  533*
P_equal_component                      parameter       char                     packed unaligned dcl 208 set ref 451 463 478 514*
                                                                                  530* 538*
P_equal_entryname                      parameter       char                     packed unaligned dcl 208 set ref 451 463 470 486*
                                                                                  496* 507* 514* 527* 534*
P_equalname                            parameter       char                     packed unaligned dcl 215 ref 556 561 566
P_target_component                     parameter       char(32)                 packed unaligned dcl 208 set ref 451 454* 514* 538*
P_target_entryname                     parameter       char(32)                 packed unaligned dcl 208 set ref 451 454* 486* 496*
                                                                                  514* 536* 545* 545*
Pen                             000576 automatic       pointer                  dcl 776 set ref 795* 799* 810 846 850 860
Peq                             000574 automatic       pointer                  dcl 776 set ref 791* 799 814 828
Ps                              000600 automatic       pointer                  dcl 776 set ref 828* 831 846* 847
SCeq                      3     000202 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 621* 721* 746* 825 825
Tbad                                   constant        fixed bin(17,0)          initial dcl 273 ref 732
Teq                       2     000202 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 353 353 357 357 362
                                                                                  362 570 570 577 577 577 577 714* 745* 803
Tequal                                 constant        fixed bin(17,0)          initial dcl 273 ref 357 362 577 577
Tequalequal                            constant        fixed bin(17,0)          initial dcl 273 ref 353 357 362 570 577 577 734
Tequalequalequal                       constant        fixed bin(17,0)          initial dcl 273 ref 353 570 740
Totherother                            constant        fixed bin(17,0)          initial dcl 273 ref 707 742
Tsub                      2     000306 automatic       fixed bin(17,0)          array level 2 dcl 217 set ref 665* 672* 687* 826
Xen                                    parameter       fixed bin(17,0)          dcl 773 ref 771 793 795 796 819 856
Xeq                                    parameter       fixed bin(17,0)          dcl 773 ref 771 791 792 803 825 825
addr                                                   builtin function         dcl 271 ref 372 642 791 791 795 795 828 846
archive_equal_code              000454 automatic       fixed bin(35,0)          dcl 217 set ref 507* 509 509 509 512 536* 538 538
                                                                                  541
char                                   based           char(1)                  array level 2 in structure "Oequal" packed packed
                                                                                  unaligned dcl 266 in procedure "get_equal_name_"
                                                                                  set ref 642 791
char                                   based           char(1)                  array level 2 in structure "Oentry" packed packed
                                                                                  unaligned dcl 266 in procedure "get_equal_name_"
                                                                                  set ref 372 795
char                            000455 automatic       char(1)                  dcl 217 in procedure "get_equal_name_" set ref 642*
                                                                                  643 645 647 649 651 653
check_entry                     000461 automatic       bit(1)                   dcl 217 set ref 327* 438 559*
code                                   parameter       fixed bin(35,0)          dcl 203 set ref 201 393* 433* 436* 442* 451 455*
                                                                                  459* 465* 486* 496* 509* 512* 514* 518* 527* 528
                                                                                  530* 531 538* 541* 547* 556 563* 570* 575* 577*
                                                                                  580* 582* 584* 819* 838* 856*
double_equal                    000456 automatic       bit(1)                   dcl 217 set ref 395 570 613* 700 703* 735 737* 748
en                                     based           char                     packed unaligned dcl 785 set ref 810 846 850 860
entry                           000464 automatic       char(32)                 dcl 217 set ref 366* 372 795 806
entryname                       000504 automatic       char(32)                 packed unaligned dcl 217 set ref 533* 536*
eq                                     based           char                     packed unaligned dcl 785 set ref 814 828
equal                           000474 automatic       char(32)                 dcl 217 set ref 335* 566* 642 791
equal_entryname                 000514 automatic       char(32)                 packed unaligned dcl 217 set ref 534* 536*
error_table_$bad_equal_name     000010 external static fixed bin(35,0)          dcl 273 ref 436 465 563
error_table_$badequal           000012 external static fixed bin(35,0)          dcl 273 ref 819 838 856
error_table_$entlong            000014 external static fixed bin(35,0)          dcl 273 ref 459 518
error_table_$longeql            000016 external static fixed bin(35,0)          dcl 273 ref 442 538 547
error_table_$no_archive_for_equal
                                000020 external static fixed bin(35,0)          dcl 273 ref 509
i                               000524 automatic       fixed bin(17,0)          dcl 217 set ref 371* 372 374* 396* 400* 400* 403*
                                                                                  405* 408 409* 409* 411 411* 414* 414* 416* 416*
                                                                                  420* 423* 423* 641* 642 717*
j                               000525 automatic       fixed bin(17,0)          dcl 217 set ref 825* 826 828 830 834 836*
length                                                 builtin function         dcl 271 ref 329 349 427 457 457 463 463 561 882 882
                                                                                  885 885 890 911 911 914 914 917 917
nstate                          000032 constant        fixed bin(17,0)          initial array dcl 273 ref 643 645 647 655 731
original_archive                000462 automatic       bit(1)                   dcl 217 set ref 476* 481 490 500
other_equal                     000460 automatic       bit(1)                   dcl 217 set ref 570 616* 707* 742* 748
p_input_name                           parameter       char                     packed unaligned dcl 903 in procedure
                                                                                  "strip_archive_suffix" ref 900 906
p_input_name                           parameter       char                     packed unaligned dcl 874 in procedure
                                                                                  "add_archive_suffix" ref 871 877
p_output_name                          parameter       char                     packed unaligned dcl 874 set ref 871 888*
rtrim                                                  builtin function         dcl 271 ref 329 349 457 457 463 463 561 877 906
s                                      based           char                     packed unaligned dcl 785 ref 831 847
state                           000526 automatic       fixed bin(17,0)          dcl 217 set ref 612* 643* 643 645* 645 647* 647 655*
                                                                                  655 657 707 714 722* 731* 731 732 734 740 742 745
substr                                                 builtin function         dcl 271 ref 426 806 828 846 885 914 917
target                          000527 automatic       varying char(34)         dcl 217 set ref 392* 397* 397 404* 404 410* 410 415*
                                                                                  415 422* 422 426 427 806* 806 810* 810 814* 814
                                                                                  831* 831 847* 847 850* 850 860* 860
target_archive                  000463 automatic       bit(1)                   dcl 217 set ref 478* 481 490 500
temporary_name                  000632 automatic       varying char(32)         dcl 904 in procedure "strip_archive_suffix" set ref
                                                                                  906* 908 911 911 914 914 914 917 917
temporary_name                  000612 automatic       varying char(33)         dcl 875 in procedure "add_archive_suffix" set ref
                                                                                  877* 879 882 882* 882 885 885 885* 885 888 890
triple_equal                    000457 automatic       bit(1)                   dcl 217 set ref 570 615* 696* 740* 748

NAMES DECLARED BY EXPLICIT CONTEXT.
COMPONENT_BAD_EQUAL_NAMES       000677 constant        label                    dcl 465 ref 470 879 908
add_archive_suffix              002237 constant        entry                    internal dcl 871 ref 514 545
bad_equal_name                  000513 constant        label                    dcl 436 ref 330 332 649 651 653 700 725 732 735 748
check_equal_name_               001343 constant        entry                    external dcl 556 ref 507 527 530
component                       000540 constant        entry                    external dcl 451
copy                            000022 constant        label                    array(13:17) dcl 806 in procedure "copy_" ref 803
copy                            000505 constant        label                    dcl 432 in procedure "get_equal_name_" ref 353 357
                                                                                  362
copy_                           001760 constant        entry                    internal dcl 771 ref 400 405 411 416 423
end_sub_loop                    002211 constant        label                    dcl 852 ref 832 848
finish_component                001660 constant        label                    dcl 714 ref 698 705
get_equal_name_                 000136 constant        entry                    external dcl 201 ref 486 496 514 536 538
long                            000526 constant        label                    dcl 442 ref 427
next_char                       001704 constant        label                    dcl 728 ref 666 673 680 688 690 723
parse                           000000 constant        label                    array(18) dcl 659 ref 657
parse_equal_name                001470 constant        entry                    internal dcl 603 ref 337 568
strip_archive_suffix            002364 constant        entry                    internal dcl 900 ref 533 534
sub_comp                        000027 constant        label                    array(3) dcl 828 ref 826

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2616        2640    2507        2626
Length      3026    2507        22         152     107           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_equal_name_                     451 external procedure  is an external procedure.  
parse_equal_name                        internal procedure  shares stack frame of external procedure get_equal_name_.  
copy_                                   internal procedure  shares stack frame of external procedure get_equal_name_.  
add_archive_suffix                      internal procedure  shares stack frame of external procedure get_equal_name_.  
strip_archive_suffix                    internal procedure  shares stack frame of external procedure get_equal_name_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_equal_name_          000100 Cen                         get_equal_name_
                         000202 Ceq                         get_equal_name_
                         000306 Csub                        get_equal_name_
                         000446 Lentry                      get_equal_name_
                         000447 Lequal                      get_equal_name_
                         000450 Nen                         get_equal_name_
                         000451 Neq                         get_equal_name_
                         000452 Nequalequal                 get_equal_name_
                         000453 Nsub                        get_equal_name_
                         000454 archive_equal_code          get_equal_name_
                         000455 char                        get_equal_name_
                         000456 double_equal                get_equal_name_
                         000457 triple_equal                get_equal_name_
                         000460 other_equal                 get_equal_name_
                         000461 check_entry                 get_equal_name_
                         000462 original_archive            get_equal_name_
                         000463 target_archive              get_equal_name_
                         000464 entry                       get_equal_name_
                         000474 equal                       get_equal_name_
                         000504 entryname                   get_equal_name_
                         000514 equal_entryname             get_equal_name_
                         000524 i                           get_equal_name_
                         000525 j                           get_equal_name_
                         000526 state                       get_equal_name_
                         000527 target                      get_equal_name_
                         000570 Is                          copy_
                         000571 Leq                         copy_
                         000572 Len                         copy_
                         000573 Ls                          copy_
                         000574 Peq                         copy_
                         000576 Pen                         copy_
                         000600 Ps                          copy_
                         000612 temporary_name              add_archive_suffix
                         000632 temporary_name              strip_archive_suffix

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_in_desc    return_mac          ext_entry_desc

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_equal_name   error_table_$badequal         error_table_$entlong          error_table_$longeql
error_table_$no_archive_for_equal




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    201 000131       327 000161       329 000162       330 000175       332 000177       335 000201       337 000205
    349 000206       350 000223       353 000227       356 000237       357 000240       361 000250       362 000251
    366 000256       368 000261       369 000263       370 000264       371 000265       372 000275       373 000301
    374 000302       375 000310       376 000311       377 000312       379 000315       392 000317       393 000320
    395 000321       396 000323       397 000333       400 000342       401 000344       403 000346       404 000361
    405 000370       406 000372       408 000374       409 000377       410 000407       411 000416       412 000423
    414 000425       415 000433       416 000442       417 000444       418 000446       420 000447       422 000457
    423 000466       424 000470       426 000472       427 000501       429 000504       432 000505       433 000511
    434 000512       436 000513       438 000516       440 000525       442 000526       443 000531       451 000532
    454 000575       455 000606       457 000607       459 000641       460 000644       463 000645       465 000677
    467 000702       470 000703       476 000710       478 000716       481 000724       486 000734       487 000761
    490 000762       496 000766       497 001013       500 001014       507 001020       509 001035       512 001047
    514 001051       518 001125       519 001130       527 001131       528 001146       530 001151       531 001167
    533 001172       534 001210       536 001226       538 001251       541 001305       542 001306       545 001307
    547 001333       550 001336       556 001337       559 001361       561 001363       563 001400       566 001406
    568 001412       570 001413       575 001434       577 001437       580 001460       582 001463       584 001466
    586 001467       603 001470       612 001471       613 001472       614 001473       615 001474       616 001475
    618 001476       619 001500       620 001501       621 001502       623 001503       641 001504       642 001513
    643 001517       645 001527       647 001536       649 001545       651 001547       653 001551       655 001554
    657 001560       659 001561       663 001562       664 001573       665 001575       666 001576       668 001577
    670 001600       671 001611       672 001613       673 001615       675 001616       680 001621       682 001622
    685 001623       686 001634       687 001636       688 001640       690 001641       696 001642       698 001644
    700 001645       703 001647       704 001651       705 001653       707 001654       714 001660       716 001665
    717 001666       718 001674       721 001676       722 001701       723 001702       725 001703       728 001704
    729 001707       731 001711       732 001715       734 001717       735 001721       737 001723       738 001725
    739 001727       740 001730       742 001735       745 001741       746 001746       748 001751       751 001757
    771 001760       791 001762       792 001771       793 001774       795 002000       796 002006       797 002010
    799 002011       800 002012       803 002013       806 002016       808 002030       810 002031       812 002044
    814 002045       816 002060       819 002061       825 002067       826 002077       828 002103       830 002111
    831 002113       832 002125       834 002126       836 002130       837 002133       838 002137       839 002142
    840 002145       841 002147       842 002150       843 002151       846 002155       847 002163       848 002175
    850 002176       852 002211       853 002213       856 002214       860 002223       863 002236       871 002237
    877 002255       879 002300       882 002305       885 002323       888 002346       890 002354       892 002361
    900 002364       906 002375       908 002417       911 002424       914 002435       917 002455


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
