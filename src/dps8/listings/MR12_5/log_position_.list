	COMPILATION LISTING OF SEGMENT log_position_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1025.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: style4 */
       10 
       11 log_position_:
       12      procedure ();
       13 
       14 /* *	LOG_POSITION_
       15*   *
       16*   *	Primitives for motion within a log segment.  This includes moving
       17*   *	forward and backward by a single message, and also positioning, by
       18*   *	time or sequence number, within a single log segment.
       19*   *
       20*   *	84-08-17, WOS: Initial coding.
       21*   *	85-03-25, EJ Sharpe: msgs with zero length text are now valid
       22**/
       23 
       24 declare  P_log_segment_ptr pointer parameter;		/* Input: Log segment being positioned within */
       25 declare  P_log_message_ptr pointer parameter;		/* Input/Output: Message in log */
       26 declare  P_log_damage bit (1) aligned parameter;		/* Output: Whether we had to search for message boundaries */
       27 declare  P_message_time fixed bin (71) parameter;		/* Input: Time to start searching for message */
       28 declare  P_message_sequence fixed bin (35) parameter;	/* Input: Sequence number to search for */
       29 declare  P_sequence_direction bit (1) aligned parameter;	/* Input: Sequence number to search for */
       30 
       31 declare  last_message_offset fixed bin (18);		/* Global variables, all initialized by the */
       32 declare  last_message_sequence fixed bin (35);		/* set_log_ptr internal procedure. */
       33 declare  time_now fixed bin (71);
       34 declare  log_damage bit (1) aligned;
       35 
       36 declare  log_segment_$last_message_info entry (pointer, fixed bin (35), fixed bin (18), fixed bin (35));
       37 
       38 declare  log_data_$complete_message_flag bit (36) aligned external static;
       39 
       40 declare  SEQUENCE_SLOP init (5) fixed bin (35) internal static options (constant);
       41 declare  TIME_SLOP init (15000) fixed bin (71) internal static options (constant);
       42 
       43 declare  OLDEST_TIME init (2015000000000000) fixed bin (71) internal static options (constant); /* 1965-01-01 */
       44 declare  ONE_MONTH init (2592000000000) fixed bin (71) internal static options (constant);
       45 
       46 declare  (addr, addrel, clock, currentsize, null, pointer, wordno) builtin;
       47 
       48 /**/
       49 
       50 /* NEXT_MESSAGE -- Move on to the next message in the log segment. If we're not
       51*   looking at a message already, find the first one. */
       52 
       53 log_position_$next_message:
       54      entry (P_log_segment_ptr, P_log_message_ptr, P_log_damage);
       55 
       56 	call set_log_ptr ();			/* Sets log_segment_ptr and log_damaged */
       57 	log_message_ptr = P_log_message_ptr;
       58 
       59 	if (log_message_ptr = null ()) then
       60 	     log_message_ptr = addr (log_segment.data);
       61 	else log_message_ptr = addrel (log_message_ptr, currentsize (log_message));
       62 
       63 	call find_next_valid_message ();
       64 
       65 	call set_message_ptr ();			/* Sets log_message_ptr and P_log_damage as needed */
       66 	return;
       67 
       68 /**/
       69 
       70 /* PREV_MESSAGE -- Move on to the previous message in the log segment. If we're not
       71*   looking at a message already, position to the last one in the segment. */
       72 
       73 log_position_$prev_message:
       74      entry (P_log_segment_ptr, P_log_message_ptr, P_log_damage);
       75 
       76 	call set_log_ptr ();			/* Sets log_segment_ptr and log_damaged */
       77 	log_message_ptr = P_log_message_ptr;
       78 
       79 	if (log_message_ptr = null ()) then
       80 	     log_message_ptr = pointer (log_segment_ptr, last_message_offset);
       81 	else log_message_ptr = addrel (log_message_ptr, -1);
       82 
       83 /* We can't detect damage while doing the search in this direction, unfortunately, since
       84*   we don't have sentinels at message ends. Instead, we just search backwards, hoping to
       85*   encounter a message start sentinel somewhere */
       86 
       87 	do while (^likely_message ());
       88 	     log_message_ptr = addrel (log_message_ptr, -1);
       89 	end;
       90 
       91 	call set_message_ptr ();			/* Sets log_message_ptr and P_log_damage as needed */
       92 	return;
       93 
       94 /**/
       95 
       96 /* All these searching entrypoints just do a linear search of the log segment,
       97*   which, while slow, is at least simple to understand. A binary search can be
       98*   added later. */
       99 
      100 
      101 
      102 log_position_$find_time:
      103      entry (P_log_segment_ptr, P_message_time, P_sequence_direction, P_log_message_ptr, P_log_damage);
      104 
      105 	call set_log_ptr ();			/* Sets log_segment_ptr and log_damaged */
      106 
      107 	call time_search (P_message_time, P_sequence_direction);
      108 
      109 	call set_message_ptr ();			/* Sets log_message_ptr and P_log_damage as needed */
      110 	return;
      111 
      112 
      113 
      114 log_position_$find_sequence:
      115      entry (P_log_segment_ptr, P_message_sequence, P_sequence_direction, P_log_message_ptr, P_log_damage);
      116 
      117 	call set_log_ptr ();			/* Sets log_segment_ptr and log_damaged */
      118 
      119 	call sequence_search (P_message_sequence, P_sequence_direction);
      120 
      121 	call set_message_ptr ();			/* Sets log_message_ptr and P_log_damage as needed */
      122 	return;
      123 
      124 /**/
      125 
      126 set_log_ptr:
      127      procedure ();
      128 
      129 /* This routine sets some global variables used for damage detection, and must
      130*   be called by all entrypoints before any work is done. */
      131 
      132 	log_segment_ptr = P_log_segment_ptr;
      133 	log_damage = "0"b;
      134 	time_now = clock ();
      135 	call log_segment_$last_message_info (log_segment_ptr, last_message_sequence, last_message_offset, (0));
      136 
      137 	return;
      138      end set_log_ptr;
      139 
      140 
      141 
      142 
      143 set_message_ptr:
      144      procedure ();
      145 
      146 /* This routine is used to set the output message pointer, and the damage flag
      147*   if necessary, and must be called by all entrypoints before returning. */
      148 
      149 	P_log_message_ptr = log_message_ptr;
      150 	if log_damage then				/* Set the output flag only if new damage found */
      151 	     P_log_damage = "1"b;
      152 
      153 	return;
      154      end set_message_ptr;
      155 
      156 /**/
      157 
      158 sequence_search:
      159      procedure (P_sequence, P_after_sw);
      160 
      161 /* This procedure searches for a message given its sequence number. It and time_search
      162*   are essentially identical, differing only in the declarations and names of variables.
      163*   They both perform a linear search of the log segment, stopping when an exact match,
      164*   or the closest "nearby" inexact match, is found. */
      165 
      166 
      167 declare  P_sequence fixed bin (35) parameter;
      168 declare  P_after_sw bit (1) aligned parameter;
      169 
      170 declare  wanted_sequence fixed bin (35);
      171 declare  after_sw bit (1) aligned;
      172 declare  closest_message pointer;
      173 declare  sequence_difference fixed bin (35);
      174 declare  sequence_delta fixed bin (35);
      175 declare  search_tries fixed bin;
      176 declare  this_sequence fixed bin (35);
      177 
      178 
      179 	wanted_sequence = P_sequence;
      180 	after_sw = P_after_sw;
      181 
      182 	if ^after_sw then				/* Return oldest message even if way later */
      183 	     if ((wanted_sequence + SEQUENCE_SLOP) < log_segment.first_sequence) then do;
      184 		log_message_ptr = null ();		/* for this_or_greater case */
      185 		return;				/* Otherwise, return null (as here) */
      186 	     end;
      187 
      188 	if after_sw then				/* Return latest message even if way before */
      189 	     if ((wanted_sequence - SEQUENCE_SLOP) > log_segment.last_sequence) then do;
      190 		log_message_ptr = null ();		/* for this_or_before case */
      191 		return;				/* Otherwise, return null (as here) */
      192 	     end;
      193 
      194 	log_message_ptr = addr (log_segment.data);	/* Note that a null return will cause the following */
      195 	call find_next_valid_message ();		/* loop to be ignored, as it should be. */
      196 
      197 	sequence_delta = 1f8;			/* Very large number */
      198 	closest_message = log_message_ptr;
      199 	if after_sw then				/* Number of extra messages we will check to find a close one */
      200 	     search_tries = SEQUENCE_SLOP;		/* Larger in "at or before" mode because the target is */
      201 	else search_tries = SEQUENCE_SLOP * 2;		/* approached from below (see explanation below) */
      202 
      203 	do while ((log_message_ptr ^= null ()) & (search_tries > 0));
      204 	     this_sequence = log_message.sequence;
      205 
      206 /* If an exact match is found, return immediately, regardless. */
      207 
      208 	     if (this_sequence = wanted_sequence) then return;
      209 
      210 	     if after_sw then
      211 		sequence_difference = this_sequence - wanted_sequence;
      212 	     else sequence_difference = wanted_sequence - this_sequence;
      213 
      214 /* If we are looking for "at or after", sequence_difference will be positive as soon as
      215*   we encounter a message after the desired number, and contrariwise in "at or before"
      216*   mode.	Once that happens, we start looking for the closest "nearby" message, but no
      217*   more that SEQUENCE_SLOP times.  In "at or before" mode, sequence_difference will be
      218*   positive at least until we find the desired message, and smaller than SEQUENCE_SLOP
      219*   all the while we're near but below, which is why we give it twice SEQUENCE_SLOP
      220*   chances to find the nearest.  */
      221 
      222 	     if (sequence_difference > 0) then
      223 		if (sequence_difference < sequence_delta) then do;
      224 		     closest_message = log_message_ptr;
      225 		     sequence_delta = sequence_difference;
      226 		end;
      227 
      228 	     if (sequence_delta < SEQUENCE_SLOP) then
      229 		search_tries = search_tries - 1;
      230 
      231 	     log_message_ptr = addrel (log_message_ptr, currentsize (log_message));
      232 	     call find_next_valid_message ();
      233 	end;
      234 
      235 	log_message_ptr = closest_message;
      236 	return;
      237 
      238      end sequence_search;
      239 
      240 /**/
      241 
      242 time_search:
      243      procedure (P_time, P_after_sw);
      244 
      245 declare  P_time fixed bin (71) parameter;
      246 declare  P_after_sw bit (1) aligned parameter;
      247 
      248 declare  wanted_time fixed bin (71);
      249 declare  after_sw bit (1) aligned;
      250 declare  closest_message pointer;
      251 declare  time_difference fixed bin (71);
      252 declare  time_delta fixed bin (71);
      253 declare  search_tries fixed bin;
      254 declare  this_time fixed bin (71);
      255 
      256 
      257 	wanted_time = P_time;
      258 	after_sw = P_after_sw;
      259 
      260 	if ^after_sw then				/* Return oldest message even if way later */
      261 	     if ((wanted_time + TIME_SLOP) < log_segment.first_time) then do;
      262 		log_message_ptr = null ();		/* for this_or_greater case */
      263 		return;				/* Otherwise, return null (as here) */
      264 	     end;
      265 
      266 	if after_sw then				/* Return latest message even if way before */
      267 	     if ((wanted_time - TIME_SLOP) > log_segment.last_time) then do;
      268 		log_message_ptr = null ();		/* for this_or_before case */
      269 		return;				/* Otherwise, return null (as here) */
      270 	     end;
      271 
      272 	log_message_ptr = addr (log_segment.data);	/* Note that a null return will cause the following */
      273 	call find_next_valid_message ();		/* loop to be ignored, as it should be. */
      274 
      275 	time_delta = 1f70b;				/* Very large number */
      276 	closest_message = log_message_ptr;
      277 	if after_sw then				/* Number of extra messages we check to find a close one */
      278 	     search_tries = SEQUENCE_SLOP;		/* Larger in "at or before" mode because the target is */
      279 	else search_tries = SEQUENCE_SLOP * 2;		/* approached from below (see explanation below) */
      280 
      281 	do while ((log_message_ptr ^= null ()) & (search_tries > 0));
      282 	     this_time = log_message.time;
      283 
      284 /* If an exact match is found, return immediately, regardless. */
      285 
      286 	     if (this_time = wanted_time) then return;
      287 
      288 	     if after_sw then
      289 		time_difference = this_time - wanted_time;
      290 	     else time_difference = wanted_time - this_time;
      291 
      292 /* If we are looking for "at or after", time_difference will be positive as soon as
      293*   we encounter a message after the desired number, and contrariwise in "at or before"
      294*   mode.	Once that happens, we start looking for the closest "nearby" message, but no
      295*   more that SEQUENCE_SLOP times.  In "at or before" mode, time_difference will be
      296*   positive at least until we find the desired message, and smaller than TIME_SLOP
      297*   all the while we're near but below, which is why we give it twice SEQUENCE_SLOP
      298*   chances to find the nearest.  */
      299 
      300 	     if (time_difference > 0) then
      301 		if (time_difference < time_delta) then do;
      302 		     closest_message = log_message_ptr;
      303 		     time_delta = time_difference;
      304 		end;
      305 
      306 	     if (time_delta < TIME_SLOP) then
      307 		search_tries = search_tries - 1;
      308 
      309 	     log_message_ptr = addrel (log_message_ptr, currentsize (log_message));
      310 	     call find_next_valid_message ();
      311 	end;
      312 
      313 	log_message_ptr = closest_message;
      314 	return;
      315 
      316      end time_search;
      317 
      318 /**/
      319 
      320 find_next_valid_message:
      321      procedure ();
      322 
      323 /* This procedure simply sets log_message_ptr to a valid message. If it
      324*   already points to a valid message, it remains unchanged; otherwise, it is
      325*   advanced, one word at a time, until it either points to a valid message,
      326*   or is set to null, indicating that there are no valid messages.  The global
      327*   log_damage flag is set to indicate that log_message_ptr started out
      328*   pointing to an invalid message.
      329*
      330*   If this program (log_position_) ever learns to do searches by a binary
      331*   positioning mechanism, another version of find_next_valid message will be
      332*   required, since the first attempt to find a message after a binary probe
      333*   will likely not find a valid message, and a search will almost always be
      334*   necessary. */
      335 
      336 
      337 	do while (^likely_message ());
      338 	     log_damage = "1"b;			/* Let our caller know that we had to search */
      339 	     log_message_ptr = addrel (log_message_ptr, 1);
      340 	end;
      341 
      342 	return;
      343      end find_next_valid_message;
      344 
      345 /**/
      346 
      347 likely_message:
      348      procedure () returns (bit (1) aligned);
      349 
      350 declare  message_offset fixed bin (18);
      351 declare  message_time fixed bin (71);
      352 
      353 /* This procedure inspects a possible log message to see whether it appears
      354*   to be a completed message. If any of the tests fail, it will return "0"b. */
      355 
      356 /* Null pointer is a flag meaning "log contents exhausted"; it's checked here
      357*   to make the do while (likely_message) loops easier to code */
      358 
      359 	if (log_message_ptr = null ()) then return ("1"b);
      360 
      361 /* We have to detect running over the bounds first, before checking the message
      362*   contents, in order to avoid running outside the bounds of the data area.
      363*   Fortunately, these checks should be reasonably quick. */
      364 
      365 	message_offset = wordno (log_message_ptr);
      366 	if (message_offset < wordno (addr (log_segment.data))) then do;
      367 	     log_message_ptr = null ();		/* Can only happen searching backwards (or from caller's */
      368 	     return ("1"b);				/* error)-- means we've run out going back, which is */
      369 	end;					/* signalled by the null message pointer */
      370 
      371 	if (message_offset > last_message_offset) then do;
      372 	     log_message_ptr = null ();		/* Similarly, we've run out looking forward. Give up */
      373 	     return ("1"b);
      374 	end;
      375 
      376 	if (log_message.sentinel ^= log_data_$complete_message_flag) then /* Bad sentinel, means not a message or an */
      377 	     return ("0"b);				/* unfinished message. Try again. */
      378 
      379 	message_time = log_message.time;
      380 	if (message_time < OLDEST_TIME) then		/* No messages from before 1965, thank you */
      381 	     return ("0"b);
      382 	if (message_time > (time_now + ONE_MONTH)) then	/* Allow some slop for jumping clocks */
      383 	     return ("0"b);
      384 
      385 	if (log_message.text_lth < 0) then		/* Must at least have *some* text, */
      386 	     return ("0"b);
      387 	if (log_message.data_lth < 0) then		/* but not necessarily any data */
      388 	     return ("0"b);
      389 	if (log_message.data_class_lth < 0) then
      390 	     return ("0"b);
      391 
      392 	if ((currentsize (log_message) + message_offset - 1) > last_message_offset) then
      393 	     return ("0"b);				/* Bogus lengths in message, it would appear */
      394 
      395 	return ("1"b);				/* It's passed all the syntactic tests */
      396      end likely_message;
      397 
      398  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  1     2 
  1     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  1     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  1     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  1     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  1     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  1     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  1     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  1    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  1    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  1    12 
  1    13 declare 1 log_message         aligned based (log_message_ptr),
  1    14           2 header            aligned like log_message_header,
  1    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  1    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  1    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  1    18 
  1    19 declare   log_message_ptr pointer;
  1    20 declare   log_message_text_lth fixed bin;
  1    21 declare   log_message_data_class_lth fixed bin;
  1    22 declare   log_message_data_lth fixed bin;
  1    23 
  1    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      398 
      399  /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  2     2 
  2     3 declare   log_segment_ptr               pointer;
  2     4 declare   log_segment_max_size          fixed bin (18);
  2     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  2     6 
  2     7 
  2     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  2     9           2 header                      aligned like log_segment_header,
  2    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  2    11 
  2    12 
  2    13 declare 1 log_segment_header            aligned based,
  2    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  2    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  2    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  2    17 
  2    18           2 limits,
  2    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  2    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  2    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  2    22             3 last_time                 fixed bin (71),
  2    23 
  2    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  2    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  2    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  2    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  2    28 
  2    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  2    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  2    31                                                             /* detect all the dead listeners after a reboot */
  2    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  2    33             3 process_id                bit (36) aligned,
  2    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  2    35 
  2    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  2    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  2    38 
  2    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  2    40 
  2    41 
  2    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  2    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  2    44 
  2    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      399 
      400 
      401      end log_position_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.9  log_position_.pl1                 >spec>install>1111>log_position_.pl1
398          1    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
399          2    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
OLDEST_TIME                     000002 constant        fixed bin(71,0)          initial dcl 43 ref 380
ONE_MONTH                       000000 constant        fixed bin(71,0)          initial dcl 44 ref 382
P_after_sw                             parameter       bit(1)                   dcl 168 in procedure "sequence_search" ref 158 180
P_after_sw                             parameter       bit(1)                   dcl 246 in procedure "time_search" ref 242 258
P_log_damage                           parameter       bit(1)                   dcl 26 set ref 53 73 102 114 150*
P_log_message_ptr                      parameter       pointer                  dcl 25 set ref 53 57 73 77 102 114 149*
P_log_segment_ptr                      parameter       pointer                  dcl 24 ref 53 73 102 114 132
P_message_sequence                     parameter       fixed bin(35,0)          dcl 28 set ref 114 119*
P_message_time                         parameter       fixed bin(71,0)          dcl 27 set ref 102 107*
P_sequence                             parameter       fixed bin(35,0)          dcl 167 ref 158 179
P_sequence_direction                   parameter       bit(1)                   dcl 29 set ref 102 107* 114 119*
P_time                                 parameter       fixed bin(71,0)          dcl 245 ref 242 257
SEQUENCE_SLOP                          constant        fixed bin(35,0)          initial dcl 40 ref 182 188 199 201 228 277 279
TIME_SLOP                       000004 constant        fixed bin(71,0)          initial dcl 41 ref 260 266 306
addr                                                   builtin function         dcl 46 ref 59 194 272 366
addrel                                                 builtin function         dcl 46 ref 61 81 88 231 309 339
after_sw                        000141 automatic       bit(1)                   dcl 171 in procedure "sequence_search" set ref 180*
                                                                                  182 188 199 210
after_sw                        000160 automatic       bit(1)                   dcl 249 in procedure "time_search" set ref 258* 260
                                                                                  266 277 288
clock                                                  builtin function         dcl 46 ref 134
closest_message                 000142 automatic       pointer                  dcl 172 in procedure "sequence_search" set ref 198*
                                                                                  224* 235
closest_message                 000162 automatic       pointer                  dcl 250 in procedure "time_search" set ref 276* 302*
                                                                                  313
currentsize                                            builtin function         dcl 46 ref 61 231 309 392
data                    226            based           bit(36)                  array level 2 dcl 2-8 set ref 59 194 272 366
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 1-13
                                                                                  ref 61 231 309 389 392
data_lth                  4(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 1-13 ref 61 231
                                                                                  309 387 392
first_sequence           56            based           fixed bin(35,0)          level 4 dcl 2-8 ref 182
first_time               60            based           fixed bin(71,0)          level 4 dcl 2-8 ref 260
header                                 based           structure                level 2 in structure "log_segment" dcl 2-8
                                                                                  in procedure "log_position_"
header                                 based           structure                level 2 in structure "log_message" dcl 1-13
                                                                                  in procedure "log_position_"
last_message_offset             000100 automatic       fixed bin(18,0)          dcl 31 set ref 79 135* 371 392
last_message_sequence           000101 automatic       fixed bin(35,0)          dcl 32 set ref 135*
last_sequence            57            based           fixed bin(35,0)          level 4 dcl 2-8 ref 188
last_time                62            based           fixed bin(71,0)          level 4 dcl 2-8 ref 266
limits                   56            based           structure                level 3 dcl 2-8
log_damage                      000104 automatic       bit(1)                   dcl 34 set ref 133* 150 338*
log_data_$complete_message_flag 000012 external static bit(36)                  dcl 38 ref 376
log_message                            based           structure                level 1 dcl 1-13 ref 61 231 309 392
log_message_header                     based           structure                level 1 dcl 1-3
log_message_ptr                 000106 automatic       pointer                  dcl 1-19 set ref 57* 59 59* 61* 61 61 77* 79 79* 81*
                                                                                  81 88* 88 149 184* 190* 194* 198 203 204 224 231*
                                                                                  231 231 235* 262* 268* 272* 276 281 282 302 309*
                                                                                  309 309 313* 339* 339 359 365 367* 372* 376 379
                                                                                  385 387 389 392
log_segment                            based           structure                level 1 dcl 2-8
log_segment_$last_message_info  000010 constant        entry                    external dcl 36 ref 135
log_segment_header                     based           structure                level 1 dcl 2-13
log_segment_ptr                 000110 automatic       pointer                  dcl 2-3 set ref 59 79 132* 135* 182 188 194 260 266
                                                                                  272 366
message_offset                  000210 automatic       fixed bin(18,0)          dcl 350 set ref 365* 366 371 392
message_time                    000212 automatic       fixed bin(71,0)          dcl 351 set ref 379* 380 382
null                                                   builtin function         dcl 46 ref 59 79 184 190 203 262 268 281 359 367 372
pointer                                                builtin function         dcl 46 ref 79
search_tries                    000170 automatic       fixed bin(17,0)          dcl 253 in procedure "time_search" set ref 277* 279*
                                                                                  281 306* 306
search_tries                    000146 automatic       fixed bin(17,0)          dcl 175 in procedure "sequence_search" set ref 199*
                                                                                  201* 203 228* 228
sentinel                               based           bit(36)                  level 3 dcl 1-13 ref 376
sequence                  1            based           fixed bin(35,0)          level 3 dcl 1-13 ref 204
sequence_delta                  000145 automatic       fixed bin(35,0)          dcl 174 set ref 197* 222 225* 228
sequence_difference             000144 automatic       fixed bin(35,0)          dcl 173 set ref 210* 212* 222 222 225
text_lth                  4            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 1-13 ref 61 231
                                                                                  309 385 392
this_sequence                   000147 automatic       fixed bin(35,0)          dcl 176 set ref 204* 208 210 212
this_time                       000172 automatic       fixed bin(71,0)          dcl 254 set ref 282* 286 288 290
time                      2(18)        based           fixed bin(53,0)          level 3 packed packed unaligned dcl 1-13 ref 282 379
time_delta                      000166 automatic       fixed bin(71,0)          dcl 252 set ref 275* 300 303* 306
time_difference                 000164 automatic       fixed bin(71,0)          dcl 251 set ref 288* 290* 300 300 303
time_now                        000102 automatic       fixed bin(71,0)          dcl 33 set ref 134* 382
wanted_sequence                 000140 automatic       fixed bin(35,0)          dcl 170 set ref 179* 182 188 208 210 212
wanted_time                     000156 automatic       fixed bin(71,0)          dcl 248 set ref 257* 260 266 286 288 290
wordno                                                 builtin function         dcl 46 ref 365 366

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 2-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 2-42
LOG_SEGMENT_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 2-5
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 1-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 1-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 1-20
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 2-4

NAMES DECLARED BY EXPLICIT CONTEXT.
find_next_valid_message         000622 constant        entry                    internal dcl 320 ref 63 195 232 273 310
likely_message                  000640 constant        entry                    internal dcl 347 ref 87 337
log_position_                   000021 constant        entry                    external dcl 11
log_position_$find_sequence     000213 constant        entry                    external dcl 114
log_position_$find_time         000160 constant        entry                    external dcl 102
log_position_$next_message      000033 constant        entry                    external dcl 53
log_position_$prev_message      000107 constant        entry                    external dcl 73
sequence_search                 000300 constant        entry                    internal dcl 158 ref 119
set_log_ptr                     000241 constant        entry                    internal dcl 126 ref 56 76 105 117
set_message_ptr                 000270 constant        entry                    internal dcl 143 ref 65 91 109 121
time_search                     000457 constant        entry                    internal dcl 242 ref 107

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1162        1176    1002        1172
Length      1410    1002        14         176     157           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_position_                       174 external procedure  is an external procedure.  
set_log_ptr                             internal procedure  shares stack frame of external procedure log_position_.  
set_message_ptr                         internal procedure  shares stack frame of external procedure log_position_.  
sequence_search                         internal procedure  shares stack frame of external procedure log_position_.  
time_search                             internal procedure  shares stack frame of external procedure log_position_.  
find_next_valid_message                 internal procedure  shares stack frame of external procedure log_position_.  
likely_message                          internal procedure  shares stack frame of external procedure log_position_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
log_position_            000100 last_message_offset         log_position_
                         000101 last_message_sequence       log_position_
                         000102 time_now                    log_position_
                         000104 log_damage                  log_position_
                         000106 log_message_ptr             log_position_
                         000110 log_segment_ptr             log_position_
                         000140 wanted_sequence             sequence_search
                         000141 after_sw                    sequence_search
                         000142 closest_message             sequence_search
                         000144 sequence_difference         sequence_search
                         000145 sequence_delta              sequence_search
                         000146 search_tries                sequence_search
                         000147 this_sequence               sequence_search
                         000156 wanted_time                 time_search
                         000160 after_sw                    time_search
                         000162 closest_message             time_search
                         000164 time_difference             time_search
                         000166 time_delta                  time_search
                         000170 search_tries                time_search
                         000172 this_time                   time_search
                         000210 message_offset              likely_message
                         000212 message_time                likely_message

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
log_segment_$last_message_info

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
log_data_$complete_message_flag




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000020        53 000026        56 000045        57 000046        59 000051        61 000061        63 000102
     65 000103        66 000104        73 000105        76 000121        77 000122        79 000125        81 000136
     87 000140        88 000145        89 000150        91 000151        92 000152       102 000153       105 000172
    107 000173       109 000204       110 000205       114 000206       117 000225       119 000226       121 000237
    122 000240       126 000241       132 000242       133 000246       134 000247       135 000251       137 000267
    143 000270       149 000271       150 000273       153 000277       158 000300       179 000302       180 000304
    182 000307       184 000321       185 000323       188 000324       190 000341       191 000343       194 000344
    195 000347       197 000350       198 000352       199 000354       201 000361       203 000364       204 000372
    208 000375       210 000400       212 000411       222 000417       224 000422       225 000423       228 000424
    231 000431       232 000452       233 000453       235 000454       236 000456       242 000457       257 000461
    258 000463       260 000466       262 000474       263 000476       266 000477       268 000506       269 000510
    272 000511       273 000514       275 000515       276 000517       277 000521       279 000526       281 000531
    282 000540       286 000546       288 000551       290 000557       300 000562       302 000565       303 000566
    306 000567       309 000574       310 000615       311 000616       313 000617       314 000621       320 000622
    337 000623       338 000631       339 000633       340 000636       342 000637       347 000640       359 000642
    365 000651       366 000654       367 000663       368 000665       371 000670       372 000673       373 000675
    376 000700       379 000706       380 000714       382 000720       385 000726       387 000734       389 000743
    392 000752       395 000766


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
