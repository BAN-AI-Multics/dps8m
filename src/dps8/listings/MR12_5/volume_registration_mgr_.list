	COMPILATION LISTING OF SEGMENT volume_registration_mgr_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1015.4 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-07-10,EJSharpe), approve(86-02-20,MCR7304),
       16*     audit(86-03-27,CLJones), install(86-04-23,MR12.0-1044):
       17*     added get_access_for_attach entrypoint in order for
       18*     rcp_attach_lv_ to perform security auditing
       19*     The two "get_access" entries should be merged into
       20*     an access kernel for MDC and LV mgmt.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* format: style1,insnl,linecom,indcomtxt,^inddcls,^indnoniterdo */
       25 
       26 volume_registration_mgr_:
       27 vrm_:
       28      proc;
       29 
       30 /* Logical Volume Registration Guts.
       31*
       32*   This program knows where the volume registration data for
       33*   logical volumes is kept.
       34*
       35*   It contain entries called by the volume_registration_cmds_
       36*   and service entries called by many other programs.
       37*
       38*   The whole program runs in ring 1.
       39*
       40*   Written by T. H. VanVleck
       41*   Modified July 1981 by J. Bongiovanni to validate lvx.
       42*   Modified 83-12-06 BIM to use RCP privilege to circumvent AIM.
       43*   Modified 83-12-07 BIM to update disk table from vol registration.
       44*   Modified 84-08-21 by EJ Sharpe
       45*   This module used to be named "hdx".
       46*   removed entries: read_hv, read_pv, write_hv, delete_hv, make_link,
       47*   and chname_hv.  Replaced with add_lvr, add_pvr, read_lvr, read_pvr,
       48*   change_lvr, change_pvr, delete_lvr, and delete_pvr.  These entries
       49*   do their own work (don't rely on ring 4 caller) and now set a lock
       50*   while changing the database.  Also, added auditing of database
       51*   changes, removed ACS link hack, changed module name to
       52*   volume_registration_mgr_, and generally improved the code.  (This
       53*   was all in order to move the registration commands from the operator
       54*   interface to the system administrator's - for B2.)
       55*   One more thing - fixed hardcore error #643 - LV access now not
       56*   dependant on AIM and ring brackets of ACS.
       57*   Modified 84-10-31 by EJ Sharpe for some misc upgrades and change get_access
       58*   entry to return bit (36) modes instead of fixed bin (5).
       59*   Modified 84-12-17 by EJ Sharpe for fixes:
       60*   1) use currentsize instead of size in reference to volume_registration
       61*   2) attempt delete of MDCS before deleting registration data file
       62*   3) use hcs_$get_user_raw_mode for LV access computation
       63*   Modified 84-12-27 by Keith Loepere for version 2 create_branch_info.
       64*   Modified 85-01-18 by EJ Sharpe for handling unexpected conditions properly
       65*   in a ring 1 process (e.g. Dumper)
       66**/
       67 
       68 /* PARAMETERS */
       69 
       70 dcl     a_lvname		 char (*);		/* Logical Volume name */
       71 dcl     a_lv_access_class_range
       72 			 (2) bit (72) aligned;	/* returned from get_access_for_attach */
       73 dcl     a_dtp		 ptr;			/* disk_table ptr */
       74 dcl     a_ptr		 ptr;			/* ptr to volume_registration or pv_registration */
       75 dcl     a_ec		 fixed bin (35);		/* error code */
       76 dcl     a_pvname		 char (*);		/* Physical Volume name */
       77 dcl     a_device_type	 fixed bin;		/* model of disk drive */
       78 dcl     a_lvid		 bit (36);		/* Logical volume uid */
       79 dcl     a_pvid		 bit (36);		/* Physical volume ID (input) */
       80 dcl     a_level		 fixed bin (3);		/* validation level (input) */
       81 dcl     a_mode		 bit (36) aligned;		/* effective mode (output) */
       82 dcl     a_pub_bit		 bit (1) aligned;		/* volume is public (output) */
       83 dcl     a_pvap		 ptr;			/* ptr to pva (input) */
       84 dcl     a_npv		 fixed bin;		/* number returned (output) */
       85 dcl     a_lvx		 fixed bin;		/* logical volume index (in disk_table) */
       86 dcl     a_dtep		 ptr;			/* disk_table entry ptr */
       87 dcl     a_dn		 char (*);		/* dir name */
       88 dcl     a_dn2		 char (*);		/* dir name */
       89 
       90 
       91 /* AUTOMATIC */
       92 
       93 dcl     MYNAME		 char (65) init ("");	/* first thing set by each entry */
       94 dcl     lvid_changed	 bit (1);			/* flag used by change-lvr */
       95 dcl     pvid_changed	 bit (1);			/* flag used by change_pvr */
       96 dcl     lvid		 bit (36) aligned;		/* temp */
       97 dcl     old_lvid		 bit (36) aligned;		/* used by change_lvr */
       98 dcl     new_lvid		 bit (36) aligned;		/* used by change_lvr */
       99 dcl     pvid		 bit (36) aligned;		/* temp */
      100 dcl     old_pvid		 bit (36) aligned;		/* used by change_pvr */
      101 dcl     new_pvid		 bit (36) aligned;		/* used by change_pvr */
      102 dcl     uname		 char (32);		/* unique name temp */
      103 dcl     uname2		 char (32);		/* unique name temp */
      104 dcl     old_uname		 char (32);		/* used by change_(lvr pvr) */
      105 dcl     new_uname		 char (32);		/* used by change_(lvr pvr) */
      106 dcl     pvname		 char (32);		/* temp */
      107 dcl     old_pvname		 char (32);		/* used by change_pvr */
      108 dcl     new_pvname		 char (32);		/* used by change_pvr */
      109 dcl     lvname		 char (32);		/* temp */
      110 dcl     old_lvname		 char (32);		/* used by change_lvr */
      111 dcl     new_lvname		 char (32);		/* used by change_lvr */
      112 dcl     old_aa_str		 char (168);		/* access auth string used by change_lvr */
      113 dcl     new_aa_str		 char (168);		/* access auth string used by change_lvr */
      114 dcl     old_dt_reg		 char (24);		/* date-time string used by change_pvr */
      115 dcl     new_dt_reg		 char (24);		/* date-time string used by change_pvr */
      116 dcl     level		 fixed bin;
      117 dcl     npvrp		 ptr;			/* pointer to new pv_reg struct */
      118 dcl     nvrp		 ptr;			/* pointer to new vol_reg struct */
      119 dcl     upvrp		 ptr;			/* pointer to user's pv_reg struct */
      120 dcl     uvrp		 ptr;			/* pointer to user's vol_reg struct */
      121 dcl     tsegp		 ptr init (null);		/* pointer to temporary seg */
      122 dcl     databasep		 ptr init (null);		/* pointer to volume registration database */
      123 dcl     dn		 char (168);		/* Volume registration DB dir */
      124 dcl     en		 char (32);		/* Volume registration DB entry */
      125 dcl     mode		 bit (36) aligned;		/* access mode */
      126 dcl     type		 fixed bin (2);		/* entry type */
      127 dcl     bc		 fixed bin (24);		/* bit count */
      128 dcl     (i, j)		 fixed bin;		/* index vars */
      129 dcl     owner		 char (32);		/* Person.Project of vol owner */
      130 dcl     (proj, oproj)	 char (9);		/* temps for access check */
      131 dcl     (pers, opers)	 char (22);		/* temps for access check */
      132 dcl     old_level		 fixed bin init (-1);
      133 dcl     ec		 fixed bin (35);		/* error code */
      134 dcl     ec2		 fixed bin (35);		/* error code */
      135 dcl     make_lve		 bit (1);			/* flag for lvname_info/ get_lv_pvinfo */
      136 dcl     auth_mnemonics	 char (172);		/* string to hold human readable form of AIM stuff */
      137 dcl     temp_str		 char (512);		/* temp area for formatting strings */
      138 dcl     tstr_len		 fixed bin (21);		/* length of formatted strings */
      139 dcl     pub_bit		 bit (1) aligned;		/* used in get_access */
      140 dcl     set_access_range	 bit (1) aligned;		/* indicator for get_access/get_access_for_attach entries */
      141 
      142 dcl     access_class_range	 (2) bit (72) aligned init ("0"b, sys_info$access_class_ceiling);
      143 
      144 dcl     1 aa		 aligned,			/* access for lv.** segs */
      145 	2 name		 char (32) init ("*.*.*"),
      146 	2 mode		 bit (36) init ("101"b),
      147 	2 mbz		 bit (36) init ((36)"0"b),
      148 	2 code		 fixed bin (35);
      149 
      150 dcl     1 dacl		 aligned,			/* access for >lv */
      151 	2 name		 char (32) init ("*.SysAdmin.*"),
      152 	2 mode		 bit (36) init ("111"b),
      153 	2 code		 fixed bin (35);
      154 
      155 dcl     1 CBI		 aligned like create_branch_info;
      156 
      157 
      158 /* STATIC */
      159 
      160 dcl     testing		 bit (1) static init ("0"b);
      161 
      162 dcl     sdtp		 ptr static init (null);
      163 dcl     first		 bit (1) static init ("1"b);
      164 
      165 dcl     PRIV		 (0:1) char (8) static options (constant) init ("private", "public");
      166 dcl     LVNAME_LEGAL	 char (76) int static options (constant) init
      167 						/* Valid characters for LV names. */
      168 			 (" '_`~^+-.{}:!0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
      169 dcl     PVNAME_LEGAL	 char (37) int static options (constant) init
      170 			 ("0123456789abcdefghijklmnopqrstuvwxyz_");
      171 dcl     PV		 bit (1) static init ("0"b) options (constant);
      172 dcl     LV		 bit (1) static init ("1"b) options (constant);
      173 dcl     INIT		 bit (1) static init ("0"b) options (constant);
      174 dcl     DONT_INIT		 bit (1) static init ("1"b) options (constant);
      175 dcl     SMALL_DT		 fixed bin (71) static options (constant) init (2019686401000000);
      176 						/* 01/01/65 00:00:01 */
      177 
      178 dcl     ROOT		 char (168) static init (">lv");
      179 						/* may be changed by "test" entrypoint */
      180 dcl     LV_DIR		 char (168) static init (">lv");
      181 						/* may be changed by "test" entrypoint */
      182 
      183 dcl     (REAL_LV_DIR)	 char (168) static init (">lv") options (constant);
      184 
      185 
      186 /* MISC */
      187 
      188 dcl     sys_info$access_class_ceiling
      189 			 bit (72) aligned external;
      190 
      191 dcl     (cleanup, any_other)	 condition;
      192 
      193 dcl     (addr, baseno, clock, currentsize, fixed, hbound, index, lbound, length, null, rtrim, string, substr, unspec,
      194         verify)		 builtin;
      195 
      196 
      197 /* ERROR CODES */
      198 
      199 dcl     error_table_$improper_data_format
      200 			 fixed bin (35) ext;
      201 dcl     error_table_$unimplemented_version
      202 			 fixed bin (35) ext;
      203 dcl     error_table_$action_not_performed
      204 			 fixed bin (35) ext;
      205 dcl     error_table_$argerr	 fixed bin (35) ext;
      206 dcl     error_table_$bad_segment
      207 			 fixed bin (35) ext;
      208 dcl     error_table_$unregistered_volume
      209 			 fixed bin (35) ext;
      210 dcl     error_table_$fatal_error
      211 			 fixed bin (35) ext;
      212 dcl     error_table_$bad_volid fixed bin (35) ext;
      213 dcl     error_table_$incorrect_device_type
      214 			 fixed bin (35) ext;
      215 dcl     error_table_$segknown	 fixed bin (35) ext;
      216 dcl     error_table_$segnamedup
      217 			 fixed bin (35) ext;
      218 dcl     error_table_$namedup	 fixed bin (35) ext;
      219 dcl     error_table_$bad_arg	 fixed bin (35) ext;
      220 dcl     error_table_$unexpected_condition
      221 			 fixed bin (35) ext;
      222 
      223 
      224 /* ENTRIES */
      225 
      226 dcl     aim_check_$in_range	 entry (bit (72) aligned, (2) bit (72) aligned) returns (bit (1));
      227 dcl     aim_check_$greater_or_equal
      228 			 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      229 dcl     ioa_$general_rs	 entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
      230 			 bit (1) aligned);
      231 dcl     admin_gate_$syserr	 entry () options (variable);
      232 dcl     admin_gate_$syserr_error_code
      233 			 entry () options (variable);
      234 dcl     admin_gate_$reclassify_sys_seg
      235 			 entry (char (*), char (*), bit (72) aligned, fixed bin (35));
      236 dcl     display_access_class_	 entry (bit (72) aligned) returns (char (32) aligned);
      237 dcl     date_time_$format	 entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
      238 dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      239 dcl     get_ring_		 entry () returns (fixed bin (3));
      240 dcl     get_initial_ring_	 entry () returns (fixed bin);
      241 dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      242 dcl     vrm_lock_$vrm_data_init
      243 			 entry ();
      244 dcl     vrm_lock_$lock	 entry (fixed bin (35));
      245 dcl     vrm_lock_$cleanup	 entry ();
      246 dcl     cu_$arg_list_ptr	 entry (ptr);
      247 dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      248 dcl     cu_$level_get	 entry (fixed bin);
      249 dcl     cu_$level_set	 entry (fixed bin);
      250 dcl     com_err_		 entry () options (variable);
      251 dcl     continue_to_signal_	 entry (fixed bin (35));
      252 dcl     expand_path_	 entry (ptr, fixed bin (21), ptr, ptr, fixed bin (35));
      253 dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      254 dcl     pathname_		 entry (char (*), char (*)) returns (char (168));
      255 dcl     mdc_repair_$make_mdcs	 entry (char (*), bit (36) aligned, fixed bin (35));
      256 dcl     mdc_repair_$update_lvid
      257 			 entry (char (*), bit (36) aligned, bit (36) aligned, fixed bin (35));
      258 dcl     mdc_repair_$rename_mdcs
      259 			 entry (char (*), bit (36) aligned, char (*), fixed bin (35));
      260 dcl     mdc_repair_$delete_mdcs
      261 			 entry (char (*), bit (36) aligned, fixed bin (35));
      262 dcl     mdc_repair_$recreate_mdcs
      263 			 entry (char (*), bit (36) aligned, fixed bin (35));
      264 dcl     mdc_init_		 entry ();
      265 dcl     get_authorization_	 entry () returns (bit (72) aligned);
      266 dcl     get_privileges_	 entry () returns (bit (36) aligned);
      267 dcl     get_group_id_	 entry () returns (char (32));
      268 dcl     hcs_$replace_acl	 entry (char (*), char (*), ptr, fixed bin, bit (1), fixed bin (35));
      269 dcl     hcs_$append_link	 entry (char (*), char (*), char (*), fixed bin (35));
      270 dcl     hcs_$chname_seg	 entry (ptr, char (*), char (*), fixed bin (35));
      271 dcl     hcs_$create_branch_	 entry (char (*), char (*), ptr, fixed bin (35));
      272 dcl     hcs_$get_user_raw_mode entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
      273 dcl     delete_$path	 entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
      274 dcl     delete_$ptr		 entry (ptr, bit (36) aligned, char (*), fixed bin (35));
      275 dcl     hcs_$add_dir_acl_entries
      276 			 entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
      277 dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      278 dcl     hcs_$make_seg	 entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      279 dcl     hcs_$set_bc_seg	 entry (ptr, fixed bin (24), fixed bin (35));
      280 dcl     hcs_$set_damaged_sw	 entry (char (*), char (*), bit (1), fixed bin (35));
      281 dcl     hcs_$set_damaged_sw_seg
      282 			 entry (ptr, bit (1), fixed bin (35));
      283 dcl     hphcs_$set_rpv	 entry (char (*), char (*), fixed bin (35));
      284 dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24), fixed bin (35));
      285 dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
      286 dcl     hcs_$truncate_seg	 entry (ptr, fixed bin (19), fixed bin (35));
      287 dcl     read_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      288 dcl     write_allowed_	 entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      289 dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      290 dcl     convert_access_class_$to_string_short
      291 			 entry (bit (72) aligned, char (*), fixed bin (35));
      292 
      293 /* ===================================================== */
      294 
      295 /* INIT - Entry called during system initialization to get set up. */
      296 /*          Salvaging, if necessary, is done later by mdx$init. */
      297 
      298 init:
      299      entry (a_dtp);					/* Called from mdx */
      300 
      301 /**** **************************************************************************
      302*
      303*      This entry is called at system initialization time by mdx$init (which is
      304*      invoked by disk_table_$init just prior to ring-1 initializer command level).
      305*      This "init" entry simply saves a copy of the disk_table points for later
      306*      use, sets up its lock segment >sl1>vrm_data, and calls mdc_init_ (which
      307*      simply sets up the lock segment for Master Directory Control).
      308*
      309*      ************************************************************************** ****/
      310 
      311 	MYNAME = "volume_registration_mgr_$init";
      312 
      313 	sdtp = a_dtp;				/* Save ptr to disk_table */
      314 	call hcs_$set_damaged_sw_seg (sdtp, "0"b, (0));	/* We will salvage */
      315 	call vrm_lock_$vrm_data_init ();		/* set up lock seg */
      316 	call mdc_init_;				/* get master directory control going */
      317 
      318 	return;
      319 
      320 
      321 /* ===================================================== */
      322 /* Primitive entry points to read and write volume registration segments.
      323*
      324*   read_lvr
      325*   read_pvr
      326*   add_lvr
      327*   add_pvr
      328*   delete_lvr
      329*   delete_pvr
      330*   change_lvr
      331*   change_pvr
      332*
      333*   These entries are called through mdc_priv_ from volume_registration_cmds_ */
      334 /* ===================================================== */
      335 
      336 
      337 
      338 /* READ_LVR - Entry to return registration database for given LV */
      339 
      340 read_lvr:
      341      entry (a_lvname, a_ptr, a_ec);
      342 
      343 /**** **************************************************************************
      344*
      345*      Reads the LV registration data, including the data for all
      346*      PVs belonging to that LV, into a place provided by the caller.
      347*      The caller supplies the PV name.
      348*
      349*      ************************************************************************** ****/
      350 
      351 	MYNAME = "volume_registration_mgr_$read_lvr";
      352 
      353 	on any_other call emergency_exit;
      354 	on cleanup call clean_up;
      355 
      356 /* COPY ARGS */
      357 	lvname = a_lvname;
      358 	uvrp = a_ptr;
      359 
      360 	call locate_ (lvname, LV, INIT);		/* Parse name */
      361 
      362 	uvrp -> volume_registration = volume_registration;/* Copy whole seg to user ring */
      363 
      364 	ec = 0;
      365 	goto EXIT;
      366 
      367 
      368 
      369 /* READ_PVR - Entry to return data structure for given PV */
      370 
      371 read_pvr:
      372      entry (a_pvname, a_ptr, a_ec);			/* Same thing given pvname */
      373 
      374 /**** **************************************************************************
      375*
      376*      Reads the PV registration data for a single PV into a place provided by the
      377*      caller.  The caller supplies the PV name.
      378*
      379*      ************************************************************************** ****/
      380 
      381 	MYNAME = "volume_registration_mgr_$read_pvr";
      382 
      383 	on any_other call emergency_exit;
      384 	on cleanup call clean_up;
      385 
      386 /* COPY ARGS */
      387 	pvname = a_pvname;
      388 	upvrp = a_ptr;
      389 
      390 	call locate_ (pvname, PV, INIT);		/* Parse name */
      391 
      392 	do i = 1 to volume_registration.npv;
      393 	     if volume_registration.pv (i).pvname = pvname
      394 	     then do;
      395 		ec = 0;
      396 						/* copy PV entry into user ring structure */
      397 		upvrp -> pv_registration = volume_registration.pv (i);
      398 		goto EXIT;
      399 	     end;
      400 	end;
      401 
      402 	ec = error_table_$bad_segment;
      403 	call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);
      404 
      405 	goto EXIT;
      406 
      407 
      408 
      409 /* ADD_LVR - Entry to create a registration database for a new LV */
      410 
      411 add_lvr:
      412      entry (a_lvname, a_ptr, a_ec);
      413 
      414 /**** **************************************************************************
      415*
      416*      Adds a new registration data segment to the volume registration database.  The
      417*      caller provides a volume_registration structure containing the LV attributes
      418*      and the attributes for a single PV.  The structure is the same as that used
      419*      for the ring-1 data segment.  If all validation passes, the caller's structure
      420*      is copied into a new segment names "lv.LVNAME".  Three addnames are added to
      421*      the segment corresponding to the LVID, PVNAME, and PVID.  This entry is not
      422*      used for creating the RLV registration.  RLV registration is done during
      423*      system initialization by the entry "check_volume_registration".  The Master
      424*      Directory Control entry "create_mdcs" is called to create its data segment
      425*      which corresponds to the LV registratoin data segment.
      426*
      427*      The code is implemented like:
      428*
      429*      entry
      430*      setup
      431*      copy args
      432*      lock database
      433*      check caller's LV and PV registration data
      434*      check existance of LV and PV already in database
      435*      make a new segment in database for this LV
      436*      {if anything goes wrong after this, delete the new segment}
      437*      copy caller's data into database
      438*      add proper names to new segment
      439*      call MDC to create its database for the new LV
      440*      create proper database links if necessary
      441*      cleanup
      442*      exit
      443*
      444*      ************************************************************************** ****/
      445 
      446 	MYNAME = "volume_registration_mgr_$add_lvr";
      447 
      448 	on any_other call emergency_exit;
      449 	on cleanup call clean_up;
      450 
      451 /* COPY ARGS */
      452 	lvname = a_lvname;
      453 	uvrp = a_ptr;
      454 	call get_tseg;				/* place to copy user structure */
      455 	vrp = tsegp;
      456 						/* we'll check to make sure number of entries is correct
      457*						   before attempting to copy the beast into our ring.
      458*						   It'll be checked again after copying the structure
      459*						   by "check_new_lv" */
      460 	if uvrp -> volume_registration.npv ^= 1
      461 	then do;
      462 	     ec = error_table_$bad_arg;
      463 	     goto EXIT;
      464 	end;
      465 	volume_registration = uvrp -> volume_registration;
      466 
      467 /* Verify consistancy of arguments */
      468 	if verify (lvname, LVNAME_LEGAL) ^= 0 | volume_registration.lvname ^= lvname
      469 	then do;
      470 	     ec = error_table_$argerr;
      471 	     goto EXIT;
      472 	end;
      473 
      474 	call vrm_lock_$lock (ec);
      475 	if ec ^= 0
      476 	then goto EXIT;
      477 
      478 	call check_new_lv (vrp);
      479 	call check_new_pv (addr (volume_registration.pv (1)));
      480 
      481 	if name_exists (LV_DIR, "lv." || lvname) |
      482 	     name_exists (LV_DIR, "lvid." || unique_chars_ ((volume_registration.lvid))) |
      483 	     name_exists (LV_DIR, "pv." || volume_registration.pv (1).pvname) |
      484 	     name_exists (LV_DIR, "pvid." || unique_chars_ ((volume_registration.pv (1).pvid)))
      485 	then do;
      486 	     ec = error_table_$namedup;
      487 	     goto EXIT;
      488 	end;
      489 
      490 	call locate_ (lvname, LV, DONT_INIT);		/* Just parse th name */
      491 	call hcs_$make_seg (dn, en, "", 1010b, databasep, ec);
      492 						/* Create new lv seg */
      493 	if ec ^= 0
      494 	then goto EXIT;
      495 	nvrp = databasep;
      496 
      497 	call hcs_$replace_acl (dn, en, addr (aa), 1, "0"b /* SysDaemon OK */, ec);
      498 	if ec ^= 0
      499 	then goto REMOVE_NEW_LV;
      500 
      501 	call admin_gate_$reclassify_sys_seg (dn, en, sys_info$access_class_ceiling, ec);
      502 	if ec ^= 0
      503 	then goto REMOVE_NEW_LV;
      504 
      505 	nvrp -> volume_registration = volume_registration;/* Copy whole structure */
      506 	vrp = nvrp;				/* Now refer to the new copy */
      507 	pvrp = addr (volume_registration.pv (1));	/* ... and to the only PV */
      508 
      509 /* If any of the following operations fail we'll back out
      510*   the new LV simply by deleting its database */
      511 
      512 	uname = "lvid." || unique_chars_ ((volume_registration.lvid));
      513 	call hcs_$chname_seg (vrp, "", uname, ec);
      514 	if ec ^= 0
      515 	then goto REMOVE_NEW_LV;
      516 	call hcs_$chname_seg (vrp, "", "pv." || pv_registration.pvname, ec);
      517 	if ec ^= 0
      518 	then goto REMOVE_NEW_LV;
      519 	uname2 = "pvid." || unique_chars_ ((pv_registration.pvid));
      520 	call hcs_$chname_seg (vrp, "", uname2, ec);
      521 	if ec ^= 0
      522 	then goto REMOVE_NEW_LV;
      523 
      524 	call mdc_repair_$make_mdcs (lvname, volume_registration.lvid, ec);
      525 	if ec ^= 0
      526 	then goto REMOVE_NEW_LV;
      527 
      528 	call log_it ("Added new LV ""^a"".", lvname);
      529 	call log_it ("Added new PV ""^a"" to LV ""^a"".", volume_registration.pv (1).pvname, lvname);
      530 
      531 	if dn ^= LV_DIR
      532 	then do;
      533 						/* add links */
      534 	     call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);
      535 	     if ec ^= 0
      536 	     then call announce_syserr_code (ec, "Could not append link for LV name.");
      537 	     call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
      538 	     if ec ^= 0
      539 	     then call announce_syserr_code (ec, "Could not append link for LVID.");
      540 	     call hcs_$append_link (LV_DIR, "pv." || pv_registration.pvname,
      541 		pathname_ (dn, "pv." || pv_registration.pvname), ec);
      542 	     if ec ^= 0
      543 	     then call announce_syserr_code (ec, "Could not append link for PV name.");
      544 	     call hcs_$append_link (LV_DIR, uname2, pathname_ (dn, uname2), ec);
      545 	     if ec ^= 0
      546 	     then call announce_syserr_code (ec, "Could not append link for PVID.");
      547 	end;
      548 
      549 	ec = 0;					/* success! */
      550 
      551 	goto EXIT;
      552 
      553 
      554 REMOVE_NEW_LV:					/* come to this point if something went wrong
      555*						   in the middle of new database creation.  */
      556 
      557 	string (delete_options) = ""b;
      558 	delete_options.force = "1"b;
      559 	delete_options.segment = "1"b;
      560 	delete_options.raw = "1"b;
      561 	call delete_$ptr (nvrp, string (delete_options), "", ec2);
      562 	if ec2 ^= 0
      563 	then
      564 	     call announce_syserr_code (ec2, "Unable to back out database ""lv.^a"".", lvname);
      565 	else databasep = null ();			/* be nice to our clean_up handler */
      566 	goto EXIT;
      567 
      568 
      569 
      570 /* ADD_PVR - Entry to add a new PV entry to an existing LV */
      571 
      572 add_pvr:
      573      entry (a_lvname, a_ptr, a_ec);
      574 
      575 /**** **************************************************************************
      576*
      577*      This entry adds the registration data for a single PV to an existing LV
      578*      registration data segment.  If all attributes in the given pv_registration
      579*      structure are valid, it is added to the end of the "pv" array in the LV data
      580*      segment.  Two addnames are appended to the LV registration data segment entry
      581*      corresponding to the PV name and PVID.  If the LV registration data segment is
      582*      in ">", two links are created in ">lv" corresponding to these two new
      583*      addnames.
      584*
      585*      The code is implemented like:
      586*
      587*      entry
      588*      setup
      589*      copy args
      590*      check caller's registration data for new PV
      591*      lock database
      592*      check existance of PV already in database
      593*      find proper LV data segment for this new PV
      594*      search LV data for PV already exists (DB consistancy check)
      595*      copy caller's PV data into database
      596*      add proper names to LV data segment
      597*      bump LV's number of PV's (to include new PV data)
      598*      add proper database links if necessary
      599*      cleanup
      600*      exit
      601*
      602*      ************************************************************************** ****/
      603 
      604 	MYNAME = "volume_registration_mgr_$add_pvr";
      605 
      606 	on any_other call emergency_exit;
      607 	on cleanup call clean_up;
      608 
      609 /* COPY ARGS */
      610 	lvname = a_lvname;
      611 	upvrp = a_ptr;
      612 	call get_tseg;				/* place to copy user's structure */
      613 	pvrp = tsegp;
      614 	pv_registration = upvrp -> pv_registration;
      615 
      616 	call check_new_pv (pvrp);
      617 
      618 	call vrm_lock_$lock (ec);
      619 	if ec ^= 0
      620 	then goto EXIT;
      621 
      622 /* Check to see if there's already a database with this name */
      623 	uname = "pvid." || unique_chars_ ((pv_registration.pvid));
      624 	if name_exists (LV_DIR, "pv." || pv_registration.pvname) | name_exists (LV_DIR, uname)
      625 	then do;
      626 	     ec = error_table_$namedup;
      627 	     goto EXIT;
      628 	end;
      629 
      630 	call locate_ (lvname, LV, INIT);
      631 
      632 /* we've already checked for its existance above, here we'll
      633*   double check to make sure there's no record with the pvname
      634*   already in the file.	*/
      635 	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pv_registration.pvname);
      636 	end;
      637 	if i <= volume_registration.npv
      638 	then do;
      639 	     call announce_syserr ("Extra PV entry ""^a"" in database ""lv.^a"".", pvname, lvname);
      640 	     ec = error_table_$bad_segment;
      641 	     goto EXIT;
      642 	end;
      643 
      644 	volume_registration.pv (i) = pv_registration;	/* OOB ref */
      645 	pvrp = addr (volume_registration.pv (i));	/* start using DB */
      646 
      647 	pvname = pv_registration.pvname;
      648 	call hcs_$chname_seg (vrp, "", "pv." || pvname, ec);
      649 	if ec ^= 0
      650 	then goto EXIT;
      651 	call hcs_$chname_seg (vrp, "", uname, ec);
      652 	if ec ^= 0
      653 	then do;
      654 						/* must remove other name we just put on */
      655 	     call hcs_$chname_seg (vrp, "pv." || pvname, "", ec2);
      656 	     if ec2 ^= 0
      657 	     then call announce_syserr_code (ec2, "Unable to back out database addname ""pv.^a"".", pvname);
      658 	     goto EXIT;
      659 	end;
      660 
      661 	volume_registration.npv = i;			/* now, let it be legally in the array */
      662 
      663 	call log_it ("Added new PV ""^a"" to LV ""^a"".", pvname, lvname);
      664 
      665 	if dn ^= LV_DIR
      666 	then do;
      667 						/* add links */
      668 	     call hcs_$append_link (LV_DIR, "pv." || pvname, pathname_ (dn, "pv." || pvname), ec);
      669 	     if ec ^= 0
      670 	     then call announce_syserr_code (ec, "Could not append link for PV name.");
      671 	     call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
      672 	     if ec ^= 0
      673 	     then call announce_syserr_code (ec, "Could not append link for PVID.");
      674 	end;
      675 
      676 	ec = 0;
      677 
      678 	goto EXIT;
      679 
      680 
      681 
      682 /* DELETE_LVR - Entry to remove a volume registration database. */
      683 
      684 delete_lvr:
      685      entry (a_lvname, a_ec);
      686 
      687 /**** **************************************************************************
      688*
      689*      This entry deletes the registration data segment for the given LV.  If the
      690*      segment was in ">", the links corresponding to the LV and all the PVs are
      691*      removed from ">lv".  The Master Directory Control entry "delete_mdcs" is
      692*      called to delete its data segment which corresponds to the deleted LV
      693*      registration data segment.
      694*
      695*      The code is implemented like:
      696*
      697*      entry
      698*      setup
      699*      copy args
      700*      lock database
      701*      locate LV registration data segment
      702*      copy data to temporary
      703*      delete the segment
      704*      log deletion of each PV
      705*      delete associated database links if necessary
      706*      call MDC to delete its database for the LV
      707*      cleanup
      708*      exit
      709*
      710*      ************************************************************************** ****/
      711 
      712 	MYNAME = "volume_registration_mgr_$delete_lvr";
      713 
      714 	on any_other call emergency_exit;
      715 	on cleanup call clean_up;
      716 
      717 /* COPY ARGS */
      718 	lvname = a_lvname;
      719 
      720 	call get_tseg;
      721 
      722 	call vrm_lock_$lock (ec);
      723 	if ec ^= 0
      724 	then goto EXIT;
      725 
      726 	call locate_ (lvname, LV, INIT);
      727 	lvid = volume_registration.lvid;		/* save this for later... */
      728 
      729 	call mdc_repair_$delete_mdcs (lvname, lvid, ec);
      730 	if ec ^= 0
      731 	then goto EXIT;
      732 
      733 	tsegp -> volume_registration = volume_registration;
      734 						/* make copy so we can log individual PV deletions later. */
      735 
      736 	string (delete_options) = ""b;
      737 	delete_options.force = "1"b;
      738 	delete_options.segment = "1"b;
      739 	delete_options.raw = "1"b;
      740 	call delete_$ptr (vrp, string (delete_options), "", ec);
      741 						/* this removes the LV (and all its PVs) */
      742 	if ec ^= 0
      743 	then goto EXIT;
      744 	databasep = null ();			/* be nice to our clean_up handler */
      745 
      746 	vrp = null;				/* so we dont ref deleted seg */
      747 
      748 	do i = 1 to tsegp -> volume_registration.npv;
      749 	     pvname = tsegp -> volume_registration.pv (i).pvname;
      750 	     pvid = tsegp -> volume_registration.pv (i).pvid;
      751 	     call log_it ("Deleted PV ""^a"" from LV ""^a"".", pvname, lvname);
      752 	     if dn ^= LV_DIR
      753 	     then do;
      754 						/* remove links */
      755 		string (delete_options) = ""b;
      756 		delete_options.force = "1"b;
      757 		delete_options.link = "1"b;
      758 		delete_options.raw = "1"b;
      759 		call delete_$path (LV_DIR, "pv." || pvname, string (delete_options), "", ec);
      760 		if ec ^= 0
      761 		then call announce_syserr_code (ec, "Could not remove PV name database link.");
      762 		call delete_$path (LV_DIR, "pvid." || unique_chars_ ((pvid)), string (delete_options), "", ec);
      763 		if ec ^= 0
      764 		then call announce_syserr_code (ec, "Could not remove PVID database link.");
      765 	     end;
      766 	end;
      767 	call log_it ("Deleted LV ""^a"".", lvname);
      768 
      769 	if dn ^= LV_DIR
      770 	then do;
      771 						/* remove links for LV */
      772 	     string (delete_options) = ""b;
      773 	     delete_options.force = "1"b;
      774 	     delete_options.link = "1"b;
      775 	     delete_options.raw = "1"b;
      776 	     call delete_$path (LV_DIR, "lv." || lvname, string (delete_options), "", ec);
      777 	     if ec ^= 0
      778 	     then call announce_syserr_code (ec, "Could not remove LV name database link.");
      779 	     call delete_$path (LV_DIR, "lvid." || unique_chars_ ((lvid)), string (delete_options), "", ec);
      780 	     if ec ^= 0
      781 	     then call announce_syserr_code (ec, "Could not remove LVID database link.");
      782 	end;
      783 
      784 	go to EXIT;
      785 
      786 
      787 
      788 /* DELETE_PVR - Entry to remove a single PV entry from an LV database. */
      789 
      790 delete_pvr:
      791      entry (a_pvname, a_ec);
      792 
      793 /**** **************************************************************************
      794*
      795*      This entry deletes the registration data for a single PV.  The two addnames
      796*      corresponding to the PV are removed from the LV registration data segment.
      797*      The "pv" array is compressed so that the remaining active entries are
      798*      contiguous.  If the registration data segment is in ">", the two links
      799*      corresponding to the PV are removed from ">lv".
      800*
      801*      The code is implemented like:
      802*
      803*      entry
      804*      setup
      805*      copy args
      806*      lock database
      807*      locate database segment containing the PV
      808*      find the PV entry
      809*      remove the entry
      810*      adjust "number of PVs" in the header
      811*      delete associated database links if necessary
      812*      cleanup
      813*      logout
      814*
      815*      ************************************************************************** ****/
      816 
      817 	MYNAME = "volume_registration_mgr_$delete_pvr";
      818 
      819 	on any_other call emergency_exit;
      820 	on cleanup call clean_up;
      821 
      822 /* COPY ARGS */
      823 	pvname = a_pvname;
      824 
      825 	call vrm_lock_$lock (ec);
      826 	if ec ^= 0
      827 	then goto EXIT;
      828 
      829 	call locate_ (pvname, PV, INIT);		/* get volume registration database containing the PV */
      830 
      831 	if volume_registration.npv = 1
      832 	then do;					/* we won't delete the last PV */
      833 	     ec = error_table_$action_not_performed;
      834 	     goto EXIT;
      835 	end;
      836 
      837 	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pvname);
      838 	end;
      839 
      840 	if i > volume_registration.npv
      841 	then do;
      842 	     ec = error_table_$bad_segment;
      843 	     call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);
      844 	     goto EXIT;
      845 	end;
      846 
      847 /* get rid of the names */
      848 	call hcs_$chname_seg (vrp, "pv." || pvname, "", ec);
      849 	if ec ^= 0
      850 	then goto EXIT;
      851 	uname = "pvid." || unique_chars_ ((volume_registration.pv (i).pvid));
      852 	call hcs_$chname_seg (vrp, uname, "", ec);
      853 	if ec ^= 0
      854 	then do;
      855 						/* put other name back on to retain consistancy */
      856 	     call hcs_$chname_seg (vrp, "", "pv." || pvname, ec2);
      857 	     if ec2 ^= 0
      858 	     then call announce_syserr_code (ec2, "Unable to replace database name ""pv.^a"".", pvname);
      859 	     goto EXIT;
      860 	end;
      861 
      862 /* squash the database */
      863 	do j = i + 1 to volume_registration.npv;
      864 	     volume_registration.pv (j - 1) = volume_registration.pv (j);
      865 	end;
      866 	volume_registration.npv = volume_registration.npv - 1;
      867 
      868 	call hcs_$truncate_seg (vrp, currentsize (volume_registration), ec);
      869 	if ec ^= 0
      870 	then call announce_syserr_code (ec, "Trimming registration.");
      871 
      872 	call log_it ("Deleted PV ""^a"" from LV ""^a"".", pvname, volume_registration.lvname);
      873 
      874 	call locate_ ((volume_registration.lvname), LV, DONT_INIT);
      875 						/* find out real location of segment */
      876 	if dn ^= LV_DIR
      877 	then do;
      878 						/* remove links */
      879 	     string (delete_options) = ""b;
      880 	     delete_options.force = "1"b;
      881 	     delete_options.link = "1"b;
      882 	     delete_options.raw = "1"b;
      883 	     call delete_$path (LV_DIR, "pv." || pvname, string (delete_options), "", ec);
      884 	     if ec ^= 0
      885 	     then call announce_syserr_code (ec, "Could not remove PV name database link.");
      886 	     call delete_$path (LV_DIR, uname, string (delete_options), "", ec);
      887 	     if ec ^= 0
      888 	     then call announce_syserr_code (ec, "Could not remove PVID database link.");
      889 	end;
      890 
      891 	ec = 0;
      892 
      893 	goto EXIT;				/* all done */
      894 
      895 
      896 
      897 /* CHANGE_LVR - Entry to change logical volume data. */
      898 
      899 change_lvr:
      900      entry (a_lvname, a_ptr, a_ec);
      901 
      902 /**** **************************************************************************
      903*
      904*      This entry changes selected attributes of an LV.  The caller supplies a
      905*      volume_registration structure with no "pv" array entries.  All attributes are
      906*      validated before any changes are made.  Changes to the LV name or LVID are
      907*      propagated to Master Directory Control through a call to its entry
      908*      "update_lvid" and "rename_mdcs".  Also, changes to the LV name or LVID make it
      909*      necessary to change the LV registration data segment names (and possibly the
      910*      names of links in ">lv").
      911*
      912*      The code is implemented like:
      913*
      914*      entry
      915*      setup
      916*      copy args
      917*      check caller's registration data structure
      918*      lock the database
      919*      locate LV data segment
      920*      make LVID change if requested
      921*      make NAME change if requested (back out LVID change if unable to make NAME change)
      922*      make other changes as requested
      923*      cleanup
      924*      exit
      925*
      926*      ************************************************************************** ****/
      927 
      928 /* a_lvname is the current name of the volume, it may change
      929*   depending upon the incoming value of volume_registration.lvname */
      930 
      931 	MYNAME = "volume_registration_mgr_$change_lvr";
      932 
      933 	on any_other call emergency_exit;
      934 	on cleanup call clean_up;
      935 
      936 /* COPY ARGS */
      937 	lvname = a_lvname;
      938 	uvrp = a_ptr;
      939 	call get_tseg;				/* space for copy of user's structure */
      940 	nvrp = tsegp;
      941 						/* let's make sure it isn't just garbage */
      942 						/* we'll check again after the copy */
      943 	if uvrp -> volume_registration.npv ^= 0
      944 	then do;
      945 	     ec = error_table_$bad_arg;
      946 	     goto EXIT;
      947 	end;
      948 	nvrp -> volume_registration = uvrp -> volume_registration;
      949 	if nvrp -> volume_registration.npv ^= 0
      950 	then do;
      951 	     ec = error_table_$bad_arg;
      952 	     goto EXIT;
      953 	end;
      954 
      955 	call check_lv (nvrp);
      956 
      957 	call vrm_lock_$lock (ec);
      958 	if ec ^= 0
      959 	then goto EXIT;
      960 
      961 	call locate_ (lvname, LV, INIT);
      962 
      963 
      964 /* The next bit of code is a touch hairy.  We need to add (potentially)
      965*   2 names in two places each.  Should anything go wrong, we need to undo
      966*   names already in place.  Thus, there's a slightly complicated mechanism
      967*   for backing out partial changes.		*/
      968 
      969 	lvid_changed = "0"b;
      970 	if volume_registration.lvid ^= nvrp -> volume_registration.lvid
      971 	then do;
      972 	     new_lvid = nvrp -> volume_registration.lvid;
      973 	     old_lvid = volume_registration.lvid;
      974 
      975 	     old_uname = "lvid." || unique_chars_ ((old_lvid));
      976 	     new_uname = "lvid." || unique_chars_ ((new_lvid));
      977 
      978 	     call hcs_$chname_seg (vrp, old_uname, new_uname, ec);
      979 	     if ec ^= 0
      980 	     then do;
      981 		if ec ^= error_table_$namedup &
      982 		     ec ^= error_table_$segnamedup	/* if not normal error... */
      983 		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_uname);
      984 		goto EXIT;
      985 	     end;
      986 	     volume_registration.lvid = new_lvid;	/* whew */
      987 	     lvid_changed = "1"b;
      988 
      989 	     call mdc_repair_$update_lvid (lvname, old_lvid, new_lvid, ec);
      990 	     if ec ^= 0
      991 	     then do;
      992 						/* must back out the change... */
      993 		call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
      994 		if ec2 ^= 0
      995 		then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
      996 			new_uname, old_uname);
      997 		else volume_registration.lvid = old_lvid;
      998 		goto EXIT;
      999 	     end;
     1000 
     1001 /* we won't log change yet - first see if name change goes OK */
     1002 	end;
     1003 
     1004 	if volume_registration.lvname ^= nvrp -> volume_registration.lvname
     1005 	then do;
     1006 	     new_lvname = nvrp -> volume_registration.lvname;
     1007 	     old_lvname = volume_registration.lvname;
     1008 
     1009 	     if old_lvname = "root"
     1010 	     then do;
     1011 						/* can't let this happen */
     1012 		ec = error_table_$bad_arg;
     1013 		go to back_out_lvid_change;		/* and exit */
     1014 	     end;
     1015 
     1016 	     call hcs_$chname_seg (vrp, "lv." || old_lvname, "lv." || new_lvname, ec);
     1017 	     if ec ^= 0
     1018 	     then do;
     1019 						/* ugh! now we have to back out preceeding lvid changes. */
     1020 		if ec ^= error_table_$namedup &
     1021 		     ec ^= error_table_$segnamedup	/* if not normal error... */
     1022 		then call announce_syserr_code (ec, "Unexpected error changing name on ""lv.^a"".", old_lvname);
     1023 back_out_lvid_change:
     1024 		if lvid_changed
     1025 		then do;
     1026 		     call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
     1027 		     if ec2 ^= 0
     1028 		     then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
     1029 			     new_uname, old_uname);
     1030 		     else do;
     1031 			volume_registration.lvid = old_lvid;
     1032 			call mdc_repair_$update_lvid (lvname, new_lvid, old_lvid, ec2);
     1033 			if ec2 ^= 0
     1034 			then call announce_syserr_code (ec2, "Unable to back out LVID change to ""^a.mdcs"".",
     1035 				lvname);
     1036 		     end;
     1037 		end /* back_out_lvid_change */;
     1038 
     1039 		goto EXIT;
     1040 	     end;
     1041 
     1042 /* update the internal name */
     1043 	     volume_registration.lvname = new_lvname;
     1044 
     1045 /* now make sure MDC keeps up */
     1046 	     call mdc_repair_$rename_mdcs (old_lvname, volume_registration.lvid, new_lvname, ec);
     1047 	     if ec ^= 0
     1048 	     then do;
     1049 						/* now we need to back out lvname change AND lvid change */
     1050 		call hcs_$chname_seg (vrp, "lv." || new_lvname, "lv." || old_lvname, ec2);
     1051 		if ec2 ^= 0
     1052 		then call announce_syserr_code (ec2, "Unable to change name ""^a"" back to ""^a"".",
     1053 			new_lvname, old_lvname);
     1054 		else do;
     1055 		     volume_registration.lvname = old_lvname;
     1056 		     goto back_out_lvid_change;
     1057 		end;
     1058 
     1059 		goto EXIT;
     1060 	     end;
     1061 
     1062 	     call log_it ("Changed name of LV ""^a"" to ""^a"".", lvname, new_lvname);
     1063 
     1064 	     if dn ^= LV_DIR
     1065 	     then do;
     1066 						/* adjust link */
     1067 		string (delete_options) = ""b;
     1068 		delete_options.force = "1"b;
     1069 		delete_options.link = "1"b;
     1070 		delete_options.raw = "1"b;
     1071 		call delete_$path (LV_DIR, "lv." || old_lvname, string (delete_options), "", ec);
     1072 		if ec ^= 0
     1073 		then call announce_syserr_code (ec, "Couldn't delete link for old LV name.");
     1074 		call hcs_$append_link (LV_DIR, "lv." || new_lvname, pathname_ (dn, "lv." || new_lvname), ec);
     1075 		if ec ^= 0
     1076 		then call announce_syserr_code (ec, "Couldn't create link for new LV name.");
     1077 	     end;
     1078 	end;
     1079 
     1080 	if lvid_changed
     1081 	then do;					/* now we can log the LVID change - we wont be backing it out */
     1082 	     call log_it ("Changed LVID of LV ""^a"" from ""^w"" to ""^w"".", lvname, old_lvid, new_lvid);
     1083 
     1084 	     if dn ^= LV_DIR
     1085 	     then do;
     1086 						/* adjust link */
     1087 		string (delete_options) = ""b;
     1088 		delete_options.force = "1"b;
     1089 		delete_options.link = "1"b;
     1090 		delete_options.raw = "1"b;
     1091 		call delete_$path (LV_DIR, old_uname, string (delete_options), "", ec);
     1092 		if ec ^= 0
     1093 		then call announce_syserr_code (ec, "Couldn't delete link for old LVID.");
     1094 		call hcs_$append_link (LV_DIR, new_uname, pathname_ (dn, new_uname), ec);
     1095 		if ec ^= 0
     1096 		then call announce_syserr_code (ec, "Couldn't create link for new LVID.");
     1097 	     end;
     1098 	end;
     1099 
     1100 /* the rest of the changes are easy... */
     1101 
     1102 	if volume_registration.access_class_range (2) ^= nvrp -> volume_registration.access_class_range (2)
     1103 	then do;
     1104 	     old_aa_str = display_access_class_ (volume_registration.access_class_range (2));
     1105 	     new_aa_str = display_access_class_ (nvrp -> volume_registration.access_class_range (2));
     1106 	     call convert_access_class_$to_string_short (nvrp -> volume_registration.access_class_range (2),
     1107 		auth_mnemonics, ec);
     1108 	     if ec ^= 0
     1109 	     then do;
     1110 		call announce_syserr_code (ec, "Unable to convert max auth to name_string.");
     1111 		auth_mnemonics = "can't convert";
     1112 	     end;
     1113 	     volume_registration.access_class_range (2) = nvrp -> volume_registration.access_class_range (2);
     1114 	     call log_it ("Changed max access class of LV ""^a"" from ""^a"" to ""^a"". (^a)",
     1115 		lvname, old_aa_str, new_aa_str, auth_mnemonics);
     1116 	end;
     1117 
     1118 	if volume_registration.access_class_range (1) ^= nvrp -> volume_registration.access_class_range (1)
     1119 	then do;
     1120 	     old_aa_str = display_access_class_ (volume_registration.access_class_range (1));
     1121 	     new_aa_str = display_access_class_ (nvrp -> volume_registration.access_class_range (1));
     1122 	     call convert_access_class_$to_string_short (nvrp -> volume_registration.access_class_range (1),
     1123 		auth_mnemonics, ec);
     1124 	     if ec ^= 0
     1125 	     then do;
     1126 		call announce_syserr_code (ec, "Unable to convert min auth to name_string.");
     1127 		auth_mnemonics = "can't convert";
     1128 	     end;
     1129 	     volume_registration.access_class_range (1) = nvrp -> volume_registration.access_class_range (1);
     1130 	     call log_it ("Changed min access class of LV ""^a"" from ""^a"" to ""^a"" (^a).",
     1131 		lvname, old_aa_str, new_aa_str, auth_mnemonics);
     1132 	end;
     1133 
     1134 	if volume_registration.volume_owner ^= nvrp -> volume_registration.volume_owner
     1135 	then do;
     1136 	     call log_it ("Changed owner of LV ""^a"" from ""^a"" to ""^a"".", lvname,
     1137 		volume_registration.volume_owner, nvrp -> volume_registration.volume_owner);
     1138 	     volume_registration.volume_owner = nvrp -> volume_registration.volume_owner;
     1139 	end;
     1140 
     1141 	if volume_registration.public ^= nvrp -> volume_registration.public
     1142 	then do;
     1143 	     call log_it ("Changed LV ""^a"" to ^[PUBLIC^;PRIVATE^].", lvname, volume_registration.public);
     1144 	     volume_registration.public = nvrp -> volume_registration.public;
     1145 	end;
     1146 
     1147 	if volume_registration.acs_path ^= nvrp -> volume_registration.acs_path
     1148 	then do;
     1149 	     volume_registration.acs_path = nvrp -> volume_registration.acs_path;
     1150 	     call log_it ("Changed ACS pathname for LV ""^a"" to ""^a"".", lvname, volume_registration.acs_path);
     1151 	end;
     1152 
     1153 	ec = 0;					/* to be sure */
     1154 
     1155 	goto EXIT;
     1156 
     1157 
     1158 
     1159 /* CHANGE_PVR - Entry to change information about a particular PV */
     1160 
     1161 change_pvr:
     1162      entry (a_pvname, a_ptr, a_ec);
     1163 
     1164 /**** **************************************************************************
     1165*
     1166*      This entry changes selected attributes of a PV.  The caller supplies a
     1167*      pv_registration structure with all members initialized.  All attributes are
     1168*      validated before any changes are made.  If the LV name or LVID changes it is
     1169*      necessary to also change the corresponding names on the LV registration data
     1170*      segment (and possibly the names of links in ">lv").
     1171*
     1172*      The code is implemented like:
     1173*
     1174*      entry
     1175*      setup
     1176*      copy_args
     1177*      check caller's registration data structure
     1178*      lock database
     1179*      locate registration data segment
     1180*      find PV entry in data segment
     1181*      make PVID change if requested
     1182*      make NAME change if requested (back out PVID change if error is encountered)
     1183*      make other changes as requested
     1184*      cleanup
     1185*      exit
     1186*
     1187*      ************************************************************************** ****/
     1188 
     1189 	MYNAME = "volume_registration_mgr_$change_pvr";
     1190 
     1191 	on any_other call emergency_exit;
     1192 	on cleanup call clean_up;
     1193 
     1194 /* COPY ARGS */
     1195 	pvname = a_pvname;
     1196 	upvrp = a_ptr;
     1197 	call get_tseg;				/* place to make copy of user's structure */
     1198 	npvrp = tsegp;
     1199 	npvrp -> pv_registration = upvrp -> pv_registration;
     1200 						/* copy the structure */
     1201 
     1202 	call check_pv (npvrp);
     1203 
     1204 	call vrm_lock_$lock (ec);
     1205 	if ec ^= 0
     1206 	then goto EXIT;
     1207 
     1208 	call locate_ (pvname, PV, INIT);
     1209 
     1210 	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= pvname);
     1211 	end;
     1212 
     1213 	if i > volume_registration.npv
     1214 	then do;
     1215 	     call announce_syserr ("PV entry missing from database ""pv.^a"".", pvname);
     1216 	     ec = error_table_$bad_segment;
     1217 	     goto EXIT;
     1218 	end;
     1219 
     1220 	pvrp = addr (volume_registration.pv (i));
     1221 
     1222 /* now - make the changes */
     1223 
     1224 /* as in "change_lvr" we have to make potentially two name changes
     1225*   but only to the volume registration database (i.e. not any MDCS) */
     1226 
     1227 	pvid_changed = "0"b;
     1228 	if pv_registration.pvid ^= npvrp -> pv_registration.pvid
     1229 	then do;
     1230 	     old_pvid = pv_registration.pvid;
     1231 	     new_pvid = npvrp -> pv_registration.pvid;
     1232 	     old_uname = "pvid." || unique_chars_ ((old_pvid));
     1233 	     new_uname = "pvid." || unique_chars_ ((new_pvid));
     1234 
     1235 	     call hcs_$chname_seg (vrp, old_uname, new_uname, ec);
     1236 	     if ec ^= 0
     1237 	     then do;
     1238 		if ec ^= error_table_$namedup &
     1239 		     ec ^= error_table_$segnamedup	/* check for unusual errors... */
     1240 		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_uname);
     1241 		goto EXIT;
     1242 	     end;
     1243 
     1244 	     pv_registration.pvid = new_pvid;
     1245 	     pvid_changed = "1"b;
     1246 	end;
     1247 
     1248 	if pv_registration.pvname ^= npvrp -> pv_registration.pvname
     1249 	then do;
     1250 	     old_pvname = pv_registration.pvname;
     1251 	     new_pvname = npvrp -> pv_registration.pvname;
     1252 
     1253 	     if old_pvname = "rpv"
     1254 	     then do;
     1255 		ec = error_table_$bad_arg;		/* can't let 'em do this */
     1256 		goto back_out_pvid_change;		/* and exit */
     1257 	     end;
     1258 
     1259 	     call hcs_$chname_seg (vrp, "pv." || old_pvname, "pv." || new_pvname, ec);
     1260 	     if ec ^= 0
     1261 	     then do;
     1262 		if ec ^= error_table_$namedup &
     1263 		     ec ^= error_table_$segnamedup	/* check for unusual errors... */
     1264 		then call announce_syserr_code (ec, "Unexpected trouble changing name ""^a"".", old_pvname);
     1265 
     1266 back_out_pvid_change:
     1267 		if pvid_changed
     1268 		then do;				/* must back out other name change */
     1269 		     call hcs_$chname_seg (vrp, new_uname, old_uname, ec2);
     1270 		     if ec2 ^= 0
     1271 		     then call announce_syserr_code (ec2, "Unable to back out PVID change to ""^a.mdcs"".", pvname);
     1272 		     else pv_registration.pvid = old_pvid;
     1273 		end;
     1274 		goto EXIT;
     1275 	     end;
     1276 	     pv_registration.pvname = new_pvname;
     1277 	     call log_it ("Changed name of PV ""^a"" to ""^a"".", old_pvname, new_pvname);
     1278 	     call locate_ ((volume_registration.lvname), LV, DONT_INIT);
     1279 						/* find out real location of segment */
     1280 	     if dn ^= LV_DIR
     1281 	     then do;
     1282 						/* adjust link */
     1283 		string (delete_options) = ""b;
     1284 		delete_options.force = "1"b;
     1285 		delete_options.link = "1"b;
     1286 		delete_options.raw = "1"b;
     1287 		call delete_$path (LV_DIR, "pv." || old_pvname, string (delete_options), "", ec);
     1288 		if ec ^= 0
     1289 		then call announce_syserr_code (ec, "Couldn't delete link for old PV name.");
     1290 		call hcs_$append_link (LV_DIR, "pv." || new_pvname, pathname_ (dn, "pv." || new_pvname), ec);
     1291 		if ec ^= 0
     1292 		then call announce_syserr_code (ec, "Couldn't create link for new PV name.");
     1293 	     end;
     1294 	end;
     1295 
     1296 	if pvid_changed
     1297 	then do;
     1298 						/* now we can log that fact - since it ain't gonna be backed out */
     1299 	     call log_it ("Changed PVID of PV ""^a"" from ""^w"" to ""^w"".", pvname, old_pvid, new_pvid);
     1300 	     call locate_ ((volume_registration.lvname), LV, DONT_INIT);
     1301 						/* find out real location of segment */
     1302 	     if dn ^= LV_DIR
     1303 	     then do;
     1304 						/* adjust link */
     1305 		string (delete_options) = ""b;
     1306 		delete_options.force = "1"b;
     1307 		delete_options.link = "1"b;
     1308 		delete_options.raw = "1"b;
     1309 		call delete_$path (LV_DIR, old_uname, string (delete_options), "", ec);
     1310 		if ec ^= 0
     1311 		then call announce_syserr_code (ec, "Couldn't delete link for old PVID.");
     1312 		call hcs_$append_link (LV_DIR, new_uname, pathname_ (dn, new_uname), ec);
     1313 		if ec ^= 0
     1314 		then call announce_syserr_code (ec, "Couldn't create link for new PVID.");
     1315 	     end;
     1316 	end;
     1317 
     1318 	if pv_registration.model ^= npvrp -> pv_registration.model
     1319 	then do;
     1320 	     call log_it ("Changed model of PV ""^a"" from ""^d"" to ""^d"".", pvname,
     1321 		MODELN (pv_registration.model), MODELN (npvrp -> pv_registration.model));
     1322 	     pv_registration.model = npvrp -> pv_registration.model;
     1323 	end;
     1324 
     1325 	if pv_registration.location ^= npvrp -> pv_registration.location
     1326 	then do;
     1327 	     call log_it ("Changed location of PV ""^a"" from ""^a"" to ""^a"".", pvname, pv_registration.location,
     1328 		npvrp -> pv_registration.location);
     1329 	     pv_registration.location = npvrp -> pv_registration.location;
     1330 	end;
     1331 
     1332 	if pv_registration.mfg_serial ^= npvrp -> pv_registration.mfg_serial
     1333 	then do;
     1334 	     call log_it ("Changed mfg_serial of PV ""^a"" from ""^a"" to ""^a"".", pvname, pv_registration.mfg_serial,
     1335 		npvrp -> pv_registration.mfg_serial);
     1336 	     pv_registration.mfg_serial = npvrp -> pv_registration.mfg_serial;
     1337 	end;
     1338 
     1339 	if pv_registration.date_registered ^= npvrp -> pv_registration.date_registered
     1340 	then do;
     1341 	     old_dt_reg = date_time_$format ("date_time", pv_registration.date_registered, "", "");
     1342 	     new_dt_reg = date_time_$format ("date_time", npvrp -> pv_registration.date_registered, "", "");
     1343 	     call log_it ("Changed date_registered of PV ""^a"" from ""^a"" to ""^a"".",
     1344 		pvname, old_dt_reg, new_dt_reg);
     1345 	     pv_registration.date_registered = npvrp -> pv_registration.date_registered;
     1346 	end;
     1347 
     1348 	if pv_registration.password ^= npvrp -> pv_registration.password
     1349 	then do;
     1350 	     call log_it ("Changed password of PV ""^a"".", pvname);
     1351 						/* don't tell what it was or now is... */
     1352 	     pv_registration.password = npvrp -> pv_registration.password;
     1353 	end;
     1354 
     1355 	goto EXIT;
     1356 
     1357 
     1358 /* ------------------------------------------------------- */
     1359 
     1360 /* Service entries called by various other programs which need to know about
     1361*   volume registration information. Status, dumper, master dir control, mount */
     1362 
     1363 /* ------------------------------------------------------- */
     1364 
     1365 
     1366 
     1367 /* PVNAME_INFO - Entry to return information about a given PV */
     1368 
     1369 pvname_info:
     1370      entry (a_pvname, a_pvid, a_lvname, a_lvid, a_device_type, a_ec);
     1371 
     1372 /**** **************************************************************************
     1373*
     1374*      This entry returns the PVID, LV name, LVID, and device type (model index)
     1375*      for a given PV name.
     1376*
     1377*      ************************************************************************** ****/
     1378 
     1379 	MYNAME = "volume_registration_mgr_$pvname_info";
     1380 
     1381 	on any_other call emergency_exit;
     1382 	on cleanup call clean_up;
     1383 
     1384 	pvname = a_pvname;
     1385 
     1386 	call vrm_lock_$lock (ec);
     1387 	if ec ^= 0
     1388 	then goto EXIT;
     1389 
     1390 	call locate_ (pvname, PV, INIT);
     1391 	do i = 1 to volume_registration.npv while (pvname ^= volume_registration.pv (i).pvname);
     1392 	end;
     1393 	if i > volume_registration.npv
     1394 	then do;
     1395 	     ec = error_table_$unregistered_volume;
     1396 	     call announce_syserr ("PV entry not found in database ""pv.^a"".", pvname);
     1397 	     goto EXIT;
     1398 	end;
     1399 
     1400 	ec = 0;
     1401 	a_pvid = volume_registration.pv (i).pvid;
     1402 	a_device_type = volume_registration.pv (i).model;
     1403 	a_lvname = volume_registration.lvname;
     1404 	a_lvid = volume_registration.lvid;
     1405 
     1406 	goto EXIT;
     1407 
     1408 
     1409 /* FIND_LVID - Entry to return LVID given LV name */
     1410 
     1411 find_lvid:
     1412      entry (a_lvname, a_lvid, a_ec);			/* Translate name to uid */
     1413 
     1414 /**** **************************************************************************
     1415*
     1416*      This entry returns the LVID for a given LV name.
     1417*
     1418*      ************************************************************************** ****/
     1419 
     1420 	MYNAME = "volume_registration_mgr_$find_lvid";
     1421 
     1422 	on any_other call emergency_exit;
     1423 	on cleanup call clean_up;
     1424 
     1425 	lvname = a_lvname;
     1426 
     1427 	call vrm_lock_$lock (ec);
     1428 	if ec ^= 0
     1429 	then goto EXIT;
     1430 
     1431 	call locate_ (lvname, LV, INIT);
     1432 
     1433 	a_lvid = volume_registration.lvid;		/* Return the value */
     1434 	ec = 0;
     1435 
     1436 	go to EXIT;
     1437 
     1438 
     1439 /* FIND_VOLNAME - Entry to return LV and PV names given PVID */
     1440 
     1441 find_volname:
     1442      entry (a_pvid, a_pvname, a_lvname, a_ec);		/* pvid -> pvname, lvname (dumper) */
     1443 
     1444 /**** **************************************************************************
     1445*
     1446*      This entry returns the PV name and LV name for a given PVID.
     1447*
     1448*      ************************************************************************** ****/
     1449 
     1450 	MYNAME = "volume_registration_mgr_$find_volname";
     1451 
     1452 	on any_other call emergency_exit;
     1453 	on cleanup call clean_up;
     1454 
     1455 	pvid = a_pvid;				/* copy input arg */
     1456 						/* init return values */
     1457 	a_pvname, a_lvname = "";
     1458 
     1459 	uname = "pvid." || unique_chars_ ((pvid));	/* Use name on segment */
     1460 
     1461 	call vrm_lock_$lock (ec);
     1462 	if ec ^= 0
     1463 	then goto EXIT;
     1464 
     1465 	call locate_uid_ (pvid, PV, INIT);
     1466 
     1467 	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvid ^= pvid);
     1468 	end;
     1469 	if i > volume_registration.npv
     1470 	then do;
     1471 	     call announce_syserr ("PV entry not found in database ""^a"".", uname);
     1472 	     ec = error_table_$bad_volid;
     1473 	     goto EXIT;
     1474 	end;
     1475 
     1476 	a_pvname = volume_registration.pv (i).pvname;	/* Rah. Divulge volume name */
     1477 	a_lvname = volume_registration.lvname;		/* Hand back volume name */
     1478 	ec = 0;
     1479 
     1480 	go to EXIT;
     1481 
     1482 
     1483 /* FIND_LVNAME - Entry to return LV name given the LVID */
     1484 
     1485 find_lvname:
     1486      entry (a_lvid, a_lvname, a_ec);			/* lvid -> lvname */
     1487 
     1488 /**** **************************************************************************
     1489*
     1490*      This entry returns the LV name for a given LVID.
     1491*
     1492*      ************************************************************************** ****/
     1493 
     1494 	MYNAME = "volume_registration_mgr_$find_lvname";
     1495 
     1496 	on any_other call emergency_exit;
     1497 	on cleanup call clean_up;
     1498 
     1499 	lvid = a_lvid;
     1500 	a_lvname = "";				/* init return value */
     1501 
     1502 	uname = "lvid." || unique_chars_ ((lvid));	/* Use the trick names */
     1503 
     1504 	call vrm_lock_$lock (ec);
     1505 	if ec ^= 0
     1506 	then goto EXIT;
     1507 
     1508 	call locate_uid_ (lvid, LV, INIT);
     1509 
     1510 	a_lvname = volume_registration.lvname;
     1511 	ec = 0;
     1512 
     1513 	go to EXIT;
     1514 
     1515 
     1516 /* GET_ACCESS - Entry to return callers' access to given LV */
     1517 
     1518 get_access:
     1519      entry (a_lvname, a_level, a_mode, a_pub_bit, a_ec);	/* Effective mode to lv (mount, mdc) */
     1520 
     1521 	set_access_range = "0"b;
     1522 	goto GET_ACCESS_JOIN;
     1523 
     1524 get_access_for_attach:
     1525      entry (a_lvname, a_level, a_mode, a_pub_bit, a_lv_access_class_range, a_ec);
     1526 						/* special entry for rcp_attach_lv_ */
     1527 
     1528 	a_lv_access_class_range = sys_info$access_class_ceiling;
     1529 						/* initial value */
     1530 	set_access_range = "1"b;
     1531 
     1532 GET_ACCESS_JOIN:
     1533 
     1534 
     1535 /**** **************************************************************************
     1536*
     1537*      This entry computes the callers access mode to a given LV.  The code first
     1538*      checks the AIM access range and RCP_PRIVILEGE.  If neither of these are
     1539*      acceptable, the mode returned is "null".  Otherwise, the access will be
     1540*      computed from the ACS.  If no acs_path is registered, or if the ACS itself is
     1541*      missing, the access returned is "REW" for the owner, "null" for all others.
     1542*
     1543*      NOTE: NOTE: this code should really be removed and made into "lv_access_kernel_"
     1544*
     1545*      The code is implemented like:
     1546*
     1547*      entry
     1548*      setup
     1549*      copy args
     1550*      lock database
     1551*      locate registration data segment for LV
     1552*      if process access class out of range or process not privileged
     1553*      then return NULL mode
     1554*      else if ACS exists for LV
     1555*      then return process's raw mode to ACS
     1556*      else if process is LV owner
     1557*      then return REW mode
     1558*      else return NULL mode
     1559*      cleanup
     1560*      exit
     1561*
     1562*      ************************************************************************** ****/
     1563 
     1564 
     1565 	MYNAME = "volume_registration_mgr_$get_access";
     1566 
     1567 	on any_other call emergency_exit;
     1568 	on cleanup call clean_up;
     1569 
     1570 	lvname = a_lvname;				/* copy input args */
     1571 	level = a_level;
     1572 
     1573 	call vrm_lock_$lock (ec);
     1574 	if ec ^= 0
     1575 	then goto EXIT;
     1576 
     1577 	call locate_ (lvname, LV, INIT);
     1578 
     1579 	if ^((read_allowed_ (get_authorization_ (), volume_registration.access_class_range (1))
     1580 	     & write_allowed_ (get_authorization_ (), volume_registration.access_class_range (2)))
     1581 	     | ((get_privileges_ () & RCP_PRIVILEGE) ^= ""b))
     1582 	then do;
     1583 	     mode = N_ACCESS;			/* if vol off aim limits, n.g. */
     1584 	     pub_bit = "0"b;
     1585 	end;
     1586 	else do;
     1587 	     if volume_registration.acs_path ^= ""
     1588 	     then do;
     1589 		call expand_pathname_ ((volume_registration.acs_path), dn, en, ec);
     1590 		if ec ^= 0
     1591 		then do;
     1592 		     call announce_syserr_code (ec, "Bad ACS path in database ""lv.^a"".", lvname);
     1593 		     goto NO_ACS;			/* check for owner mode */
     1594 		end;
     1595 
     1596 		call hcs_$get_user_raw_mode (dn, en, "", mode, ec);
     1597 						/* ignores ring brackets and AIM */
     1598 		if ec ^= 0
     1599 		then goto NO_ACS;			/* check for owner mode */
     1600 		pub_bit = volume_registration.public;
     1601 	     end;
     1602 	     else do;
     1603 NO_ACS:						/* ACS need not exist */
     1604 		uname = get_group_id_ ();
     1605 		j = length (rtrim (uname));
     1606 		substr (uname, j - 1) = "";		/* Blank instance tag */
     1607 		j = index (uname, ".");
     1608 		pers = substr (uname, 1, j - 1);
     1609 		proj = substr (uname, j + 1);
     1610 		j = index (volume_registration.volume_owner, ".");
     1611 		opers = substr (volume_registration.volume_owner, 1, j - 1);
     1612 		oproj = substr (volume_registration.volume_owner, j + 1);
     1613 
     1614 		if (pers = opers | opers = "*") & (proj = oproj | oproj = "*")
     1615 		then mode = REW_ACCESS;		/* Volume owner always REW */
     1616 		else if volume_registration.public
     1617 		then mode = RW_ACCESS;		/* Everybody has RW to public vols */
     1618 		else mode = N_ACCESS;		/* Private vol, no ACS */
     1619 		pub_bit = volume_registration.public;
     1620 	     end;
     1621 
     1622 	end;
     1623 
     1624 	a_mode = mode;				/* Tell user */
     1625 	a_pub_bit = pub_bit;
     1626 	if set_access_range
     1627 	then a_lv_access_class_range = volume_registration.access_class_range;
     1628 
     1629 	ec = 0;
     1630 	go to EXIT;
     1631 
     1632 
     1633 /* LVNAME_INFO - Entry to return information about PVs given an LV name */
     1634 
     1635 lvname_info:
     1636      entry (a_lvname, a_pvap, a_npv, a_ec);
     1637 
     1638 /**** **************************************************************************
     1639*
     1640*      This entry returns a specialized structure of information on
     1641*      all PVs belonging to a given LV name.
     1642*
     1643*      The code is implemented like:
     1644*
     1645*      entry
     1646*      setup
     1647*      copy args
     1648*      lock database
     1649*      locate registration data segment for LV
     1650*      fill in caller's structure with info on all PVs in the LV
     1651*      cleanup
     1652*      exit
     1653*
     1654*      ************************************************************************** ****/
     1655 
     1656 dcl     pvap		 ptr;
     1657 
     1658 dcl     1 pva		 (100) based (pvap) aligned,	/* This entrypoint fills in a struc */
     1659 	2 pvname		 char (32),		/* .. listing all volumes */
     1660 	2 device_type	 fixed bin,		/* .. and their model numbers */
     1661 	2 pvid		 bit (36);		/* and pvid */
     1662 
     1663 	MYNAME = "volume_registration_mgr_$lvname_info";
     1664 
     1665 	make_lve = "0"b;				/* dont fiddle with disk table */
     1666 	goto lv_pvinfo_common;
     1667 
     1668 
     1669 /* GET_LV_PVINFO - Entry to do same as LVNAME_INFO plus make LVE in disk table */
     1670 /*	This entry is called by disk_table_ (via initializer_mdc_) and by mdx */
     1671 
     1672 get_lv_pvinfo:
     1673      entry (a_lvname, a_pvap, a_npv, a_lvx, a_ec);	/* Get lv pv list, make lve */
     1674 
     1675 /**** **************************************************************************
     1676*
     1677*      This entry has the same function as "lvname_info".  In addition
     1678*      it will return the index of the corresponding LV disk_table entry.
     1679*      If there is no corresponding disk table LV entry, it will be created.
     1680*
     1681*      The code is implemented like:
     1682*
     1683*      entry
     1684*      setup
     1685*      copy args
     1686*      lock database
     1687*      locate registration data segment for LV
     1688*      locate disk table LV entry or make one if not already existing
     1689*      fill in caller's structure with info on all PVs in the LV
     1690*      cleanup
     1691*      exit
     1692*
     1693*      ************************************************************************** ****/
     1694 
     1695 	MYNAME = "volume_registration_mgr_$get_lv_pvinfo";
     1696 
     1697 	make_lve = "1"b;				/* update disk table */
     1698 
     1699 
     1700 lv_pvinfo_common:
     1701 
     1702 	on any_other call emergency_exit;
     1703 	on cleanup call clean_up;
     1704 
     1705 	dtp = sdtp;
     1706 	dtep = null;				/* not needed at this entry */
     1707 	lvname = a_lvname;
     1708 	pvap = a_pvap;
     1709 
     1710 	call vrm_lock_$lock (ec);
     1711 	if ec ^= 0
     1712 	then goto EXIT;
     1713 
     1714 	call locate_ (lvname, LV, INIT);
     1715 	if make_lve
     1716 	then a_lvx = get_lve ();
     1717 
     1718 	do i = 1 to volume_registration.npv;
     1719 	     pva (i).pvname = volume_registration.pv (i).pvname;
     1720 	     pva (i).device_type = volume_registration.pv (i).model;
     1721 	     pva (i).pvid = volume_registration.pv (i).pvid;
     1722 	end;
     1723 	a_npv = volume_registration.npv;
     1724 	ec = 0;
     1725 	go to EXIT;
     1726 
     1727 
     1728 /* FIND - Entry to fill in disk table from volume registration data */
     1729 /* 	This entry is called by mdx 		*/
     1730 
     1731 find:
     1732      entry (a_dtep, a_ec);
     1733 
     1734 /**** **************************************************************************
     1735*
     1736*      This entry will create an LV disk table entry given an index
     1737*      to a disk table PV entry.  The LV entry will correspond to the
     1738*      LV of the given PV.
     1739*
     1740*      The code is implemented like:
     1741*
     1742*      entry
     1743*      setup
     1744*      copy args
     1745*      lock database
     1746*      locate registration data segment containing PV
     1747*      locate disk table LV entry or create one if it doesnt exist
     1748*      locate PV entry in the data segment
     1749*      if model in registration data and disk table are the same
     1750*      then copy to registered PVID into the disk table
     1751*      else there's an error
     1752*      cleanup
     1753*      exit
     1754*
     1755*      ************************************************************************** ****/
     1756 
     1757 	MYNAME = "volume_registration_mgr_$find";
     1758 
     1759 	on any_other call emergency_exit;
     1760 	on cleanup call clean_up;
     1761 
     1762 	dtp = sdtp;
     1763 	dtep = a_dtep;
     1764 	pvname = dte.pvname;			/* dte.pvname is input */
     1765 
     1766 	call vrm_lock_$lock (ec);
     1767 	if ec ^= 0
     1768 	then goto EXIT;
     1769 
     1770 	call locate_ (pvname, PV, INIT);
     1771 	dte.lvx = get_lve ();
     1772 
     1773 	do i = 1 to volume_registration.npv while (volume_registration.pv (i).pvname ^= dte.pvname);
     1774 	end;
     1775 	if i <= volume_registration.npv
     1776 	then do;
     1777 	     if dte.device_type = volume_registration.pv (i).model
     1778 	     then do;
     1779 		dte.pvid = volume_registration.pv (i).pvid;
     1780 						/* Found stuff. Get pvid */
     1781 		ec = 0;
     1782 	     end;
     1783 	     else ec = error_table_$incorrect_device_type;
     1784 	end;
     1785 	else do;
     1786 	     call announce_syserr ("PV entry missing from ""pv.^a"".", pvname);
     1787 	     ec = error_table_$bad_volid;
     1788 	end;
     1789 
     1790 	go to EXIT;
     1791 
     1792 
     1793 /* CHECK_VOLUME_REGISTRATION -  Salvage the registration database. */
     1794 
     1795 check_volume_registration:
     1796      entry (a_dtep, a_ec);				/* salvager module */
     1797 
     1798 /**** **************************************************************************
     1799*
     1800*      This entry is called during system initialization to validate/re-create the
     1801*      volume registration database.  "mdx$init" (which had previously called our
     1802*      "init" entry) scans the old disk table and calls here for each entry that had
     1803*      a valid drive mounted in the previous session.  This is evidence that the PV
     1804*      should have a valid registration.
     1805*
     1806*      On the first call this entry will create ">lv" if necessary (i.e.  if its a
     1807*      new system or was booted with NOLV).
     1808*
     1809*      The disk table PV entry is checked to determine that it points to a valid disk
     1810*      table LV entry.  If not, the disk table LV entry is recreated from the PV's LV
     1811*      registration data.  If the LV registration can't be determined, nothing more
     1812*      can be done but issue a console message.
     1813*
     1814*      If the disk table does contain a valid LV entry for the PV in question it is
     1815*      compared to the LV registration data.  If the LV registration disagrees with
     1816*      the disk table entry, or can't be found, it is recreated.  (Thus, the disk
     1817*      table is the more trusted database.)
     1818*
     1819*      If the PV registration data disagrees with the disk table PV entry, the
     1820*      registration data is "fixed" to be the same.  If the PV registration doesn't
     1821*      exist in the LV registration data segment, it is recreated there.
     1822*
     1823*      This entry also ensures that all proper addnames and links are in place.
     1824*
     1825*      The code is implemented like:
     1826*
     1827*      entry
     1828*      setup
     1829*      (no need to copy args or lock database)
     1830*      if first call then create ">lv" if it doesn't exist
     1831*      validate PV name in disk table entry
     1832*
     1833*      if disk table LV entry invalid
     1834*      then if PV is registered
     1835*      then recreate disk table LV entry
     1836*      else return to caller as failure
     1837*
     1838*      validate LV name in disk table entry
     1839*      if LV registration data segment non existant
     1840*      then create new one and fill in header
     1841*      else validate existing header information - recreate if anything in error
     1842*
     1843*      create proper database link for LV name if necessary
     1844*      create proper data seg addname for LVID
     1845*      create proper database link for LVID if necessary
     1846*
     1847*      create proper database link for MDC data seg if necessary
     1848*      call MDC to recreate its data seg for the LV as it sees fit
     1849*
     1850*      create proper data seg addname for PV name
     1851*      create proper database link for PV name if necessary
     1852*
     1853*      if PV entry does not exist in data seg
     1854*      then create it
     1855*      else validate PVID and device type against disk table entry
     1856*      - update registration entry with disk table info if in error
     1857*
     1858*      create proper data seg addname for PVID
     1859*      create proper database link for PVID if necessary
     1860*
     1861*      cleanup
     1862*      exit
     1863*
     1864*      ************************************************************************** ****/
     1865 
     1866 	MYNAME = "volume_registration_mgr_$check_volume_registration";
     1867 
     1868 	on any_other
     1869 	     begin;
     1870 		a_ec = error_table_$unexpected_condition;
     1871 		goto CK_VREG_EXIT;
     1872 	     end;
     1873 	on cleanup ;
     1874 
     1875 /* No locking is needed at this entrypoint since
     1876*   only the Initializer exists */
     1877 
     1878 	a_ec = 0;
     1879 	if first
     1880 	then do;					/* We are always called at least once (for the root) */
     1881 	     first = "0"b;
     1882 	     i = length (rtrim (LV_DIR));
     1883 	     call expand_path_ (addr (LV_DIR), (i), addr (dn), addr (en), ec);
     1884 	     call hcs_$status_minf (dn, en, 0, type, bc, ec);
     1885 	     if ec ^= 0 | type ^= 2
     1886 	     then do;
     1887 		unspec (CBI) = ""b;
     1888 		CBI.version = create_branch_version_2;
     1889 		CBI.dir_sw = "1"b;
     1890 		CBI.parent_ac_sw = "1"b;
     1891 		CBI.mode = "111"b;
     1892 		CBI.rings (1) = 7;
     1893 		CBI.rings (2) = 7;
     1894 		CBI.rings (3) = 7;
     1895 		CBI.userid = get_group_id_ ();
     1896 		call hcs_$create_branch_ (dn, en, addr (CBI), ec);
     1897 		if ec ^= 0
     1898 		then call announce_syserr_code (ec, "Cannot re-create ^a.", LV_DIR);
     1899 		else do;
     1900 		     call hcs_$add_dir_acl_entries (dn, en, addr (dacl), 1, ec);
     1901 		     if ec ^= 0
     1902 		     then call announce_syserr_code (ec, "Cannot add SysAdmin access to ^a.", LV_DIR);
     1903 		end;
     1904 	     end;
     1905 	     if LV_DIR = REAL_LV_DIR
     1906 	     then do;				/* Make LV dir be on RPV */
     1907 		call hphcs_$set_rpv (dn, en, ec);
     1908 		if ec ^= 0
     1909 		then call announce_syserr_code (ec, "Putting LV dir on RPV");
     1910 	     end;
     1911 	end;
     1912 
     1913 	dtp = sdtp;
     1914 	dtep = a_dtep;
     1915 	if verify (rtrim (dte.pvname), PVNAME_LEGAL) ^= 0
     1916 	then return;				/* Dont reregister crap */
     1917 	if dte.lvx <= 0 | dte.lvx > dt.n_lv_entries
     1918 	then go to lvfail;
     1919 	lvep = addr (dt.lv_array (dte.lvx));
     1920 	if ^lve.used
     1921 	then do;
     1922 lvfail:
     1923 	     pvname = dte.pvname;			/* Invalid lve. Try to recover */
     1924 	     call locate_ (pvname, PV, DONT_INIT);
     1925 	     call hcs_$initiate (dn, en, "", 0, 0, vrp, ec);
     1926 						/* look in pv seg for lvname */
     1927 	     if vrp = null
     1928 	     then do;				/* Cannot find pv */
     1929 		call announce_syserr_code (ec, "Cannot reregister PV ""^a"".", pvname);
     1930 		a_ec = ec;			/* unable to proceed */
     1931 		return;				/* .. because i dont know what lv */
     1932 	     end;
     1933 	     dte.lvx = get_lve ();
     1934 	     call hcs_$terminate_noname (vrp, (0));
     1935 	end;
     1936 	lvname = lve.lvname;
     1937 	if verify (lvname, LVNAME_LEGAL) ^= 0
     1938 	then return;
     1939 	call locate_ (lvname, LV, DONT_INIT);
     1940 	call hcs_$initiate (dn, en, "", 0, 0, vrp, ec);	/* LV should be registered */
     1941 	if vrp = null
     1942 	then do;
     1943 	     call hcs_$make_seg (dn, en, "", 1010b, vrp, ec);
     1944 						/* Wasn't. Make new */
     1945 	     if vrp = null
     1946 	     then do;
     1947 		call announce_syserr_code (ec, "Cannot reregister LV ""^a"".", lvname);
     1948 		a_ec = ec;
     1949 		return;
     1950 	     end;
     1951 	     call admin_gate_$reclassify_sys_seg (dn, en, sys_info$access_class_ceiling, ec);
     1952 	     if ec ^= 0
     1953 	     then call announce_syserr_code (ec, pathname_ (dn, en));
     1954 remake_lv:
     1955 	     volume_registration.version = Volume_Registration_Version_2;
     1956 	     volume_registration.lvid = lve.lvid;
     1957 	     volume_registration.lvname = lvname;
     1958 	     owner = get_group_id_ ();
     1959 	     i = length (rtrim (owner));
     1960 	     volume_registration.volume_owner = substr (owner, 1, i - 2);
     1961 	     volume_registration.public = lve.public;
     1962 	     volume_registration.access_class_range (1) = lve.min_access_class;
     1963 	     volume_registration.access_class_range (2) = lve.max_access_class;
     1964 	     volume_registration.acs_path = "";
     1965 	     call announce_syserr ("Reregistered ^a LV ^a LVID ^w", PRIV (fixed (lve.public, 1)), lvname, lve.lvid);
     1966 	     call hcs_$replace_acl (dn, en, addr (aa), 1, "0"b /* SysDaemon OK */, ec);
     1967 	end;
     1968 	else do;
     1969 	     call hcs_$set_damaged_sw_seg (vrp, "0"b, ec);/* Salvaging ourself */
     1970 	     ec = 0;
     1971 	     if volume_registration.lvname ^= lvname
     1972 	     then ec = 2;
     1973 	     if volume_registration.lvid ^= lve.lvid
     1974 	     then ec = 3;
     1975 	     if volume_registration.public ^= lve.public
     1976 	     then ec = 4;
     1977 	     if volume_registration.access_class_range (1) ^= lve.min_access_class
     1978 	     then ec = 5;
     1979 	     if volume_registration.access_class_range (2) ^= lve.max_access_class
     1980 	     then ec = 6;
     1981 	     if volume_registration.version ^= Volume_Registration_Version_2
     1982 	     then call convert_database (ec);		/* to new version */
     1983 	     if ec ^= 0
     1984 	     then do;
     1985 		call announce_syserr_code (ec, "lv.^a disagreed with disk_table. It was rebuilt.", lvname);
     1986 		go to remake_lv;
     1987 	     end;
     1988 	end;
     1989 	if dn ^= LV_DIR				/* The ROOT lv must be linked to special */
     1990 	then call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);
     1991 	uname = "lvid." || unique_chars_ ((volume_registration.lvid));
     1992 						/* Force unique name back on */
     1993 	call hcs_$chname_seg (vrp, "", uname, ec);
     1994 	if ec ^= 0
     1995 	then if ec ^= error_table_$segnamedup
     1996 	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", uname, en);
     1997 	if dn ^= LV_DIR
     1998 	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
     1999 						/* ACS linking code was removed from this point - ejs */
     2000 	uname = rtrim (lvname) || ".mdcs";
     2001 	if dn ^= LV_DIR
     2002 	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), (0));
     2003 	call hcs_$set_damaged_sw (LV_DIR, uname, "0"b, (0));
     2004 						/* Don't fault */
     2005 	call mdc_repair_$recreate_mdcs (lvname, (volume_registration.lvid), ec);
     2006 	if ec ^= 0
     2007 	then if ec ^= error_table_$namedup
     2008 	     then call announce_syserr_code (ec, "Cannot make mdcs for LV ^a", lvname);
     2009 
     2010 	pvname = dte.pvname;
     2011 	en = "pv." || pvname;
     2012 	call hcs_$chname_seg (vrp, "", en, ec);		/* Put pv name back on */
     2013 	if ec ^= 0
     2014 	then if ec ^= error_table_$segnamedup
     2015 	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", en, lvname);
     2016 	if dn ^= LV_DIR
     2017 	then call hcs_$append_link (LV_DIR, en, pathname_ (dn, en), ec);
     2018 
     2019 	do i = 1 to volume_registration.npv while (volume_registration.pvname (i) ^= pvname);
     2020 	end;
     2021 	if i > volume_registration.npv
     2022 	then do;
     2023 	     volume_registration.pv (i).pvid = dte.pvid;	/* Vol was not in lv */
     2024 	     volume_registration.pv (i).pvname = pvname;
     2025 	     volume_registration.pv (i).model = dte.device_type;
     2026 	     volume_registration.pv (i).location = "online";
     2027 	     volume_registration.pv (i).mfg_serial = "registered by crash recovery";
     2028 	     volume_registration.pv (i).password = "0"b;
     2029 	     volume_registration.pv (i).date_registered = clock ();
     2030 	     volume_registration.npv = volume_registration.npv + 1;
     2031 	     call announce_syserr ("Reregistered PV ^a PVID ^w in LV ^a",
     2032 		volume_registration.pv (i).pvname, volume_registration.pv (i).pvid, lvname);
     2033 	     call hcs_$set_bc_seg (vrp, 36 * currentsize (volume_registration), ec);
     2034 	end;
     2035 	else do;
     2036 	     if volume_registration.pv (i).pvid ^= dte.pvid
     2037 		| volume_registration.pv (i).model ^= dte.device_type
     2038 	     then call announce_syserr ("Registration for PV ^a was different from disk_table.", pvname);
     2039 	     volume_registration.pv (i).pvid = dte.pvid;
     2040 	     volume_registration.pv (i).model = dte.device_type;
     2041 	end;
     2042 	uname = "pvid." || unique_chars_ ((volume_registration.pv (i).pvid));
     2043 	call hcs_$chname_seg (vrp, "", uname, ec);	/* Put name back on */
     2044 	if ec ^= 0
     2045 	then if ec ^= error_table_$segnamedup
     2046 	     then call announce_syserr_code (ec, "Cant add name ""^a"" to ""^a"".", uname, lvname);
     2047 	if dn ^= LV_DIR				/* Hard case */
     2048 	then call hcs_$append_link (LV_DIR, uname, pathname_ (dn, uname), ec);
     2049 
     2050 	call hcs_$terminate_noname (vrp, ec);
     2051 
     2052 CK_VREG_EXIT:
     2053 	return;
     2054 
     2055 /* -------------------------------------------------- */
     2056 /* INTERNAL SUPPORT ROUTINES                          */
     2057 /* -------------------------------------------------- */
     2058 
     2059 
     2060 log_it:						/* log changes to databases */
     2061      proc options (variable);
     2062 
     2063 dcl     severity		 fixed bin;
     2064 dcl     based_msg		 char (tstr_len) based (addr (temp_str));
     2065 dcl     alp		 pointer;
     2066 
     2067 	severity = LOG;
     2068 	goto log_it_join;
     2069 
     2070 announce_syserr:
     2071      entry options (variable);
     2072 
     2073 	severity = ANNOUNCE;
     2074 
     2075 log_it_join:
     2076 	on any_other ;
     2077 
     2078 	call cu_$arg_list_ptr (alp);
     2079 	call ioa_$general_rs (alp, 1, 2, temp_str, tstr_len, "0"b /* no pad */, "0"b /* nnl */);
     2080 
     2081 	if testing
     2082 	then call com_err_ (0, MYNAME, "(^[SYSERR^;SYSLOG^]) ^a (^a)", (severity = ANNOUNCE), based_msg,
     2083 		get_group_id_ ());
     2084 	else call admin_gate_$syserr (severity, "^a: ^a (^a)", MYNAME, based_msg, get_group_id_ ());
     2085 
     2086 	return;
     2087 
     2088      end log_it;
     2089 
     2090 /* -------------------------------------------------- */
     2091 
     2092 announce_syserr_code:				/* console msg about something awful */
     2093      proc options (variable);
     2094 
     2095 dcl     ecode		 fixed bin (35) based (ecode_p);
     2096 dcl     ecode_p		 pointer;
     2097 dcl     ecode_len		 fixed bin (21);		/* ignored */
     2098 dcl     based_msg		 char (tstr_len) based (addr (temp_str));
     2099 dcl     severity		 fixed bin;
     2100 dcl     based_packed_ptr	 ptr unal based;
     2101 dcl     alp		 pointer;
     2102 
     2103 
     2104 	severity = ANNOUNCE;
     2105 
     2106 	on any_other ;
     2107 
     2108 	call cu_$arg_list_ptr (alp);
     2109 	call ioa_$general_rs (alp, 2, 3, temp_str, tstr_len, "0"b /* no pad */, "0"b /* nnl */);
     2110 	call cu_$arg_ptr (1, ecode_p, ecode_len, ec2);
     2111 
     2112 	if testing
     2113 	then call com_err_ (ecode, MYNAME, "(^[SYSERR^;SYSLOG^]) ^a (^a)", (severity = ANNOUNCE), based_msg,
     2114 		get_group_id_ ());
     2115 	else call admin_gate_$syserr_error_code
     2116 		(ANNOUNCE, ecode, "^a:^[ Code=^d.^;^s^] ^a (^a)", MYNAME,
     2117 		(baseno (addr (ecode) -> based_packed_ptr) = "0"b), ecode, based_msg, get_group_id_ ());
     2118 
     2119 	return;
     2120 
     2121      end announce_syserr_code;
     2122 
     2123 /* -------------------------------------------------- */
     2124 
     2125 clean_up:						/* tidy the place before we leave */
     2126      proc;
     2127 
     2128 dcl     tptr		 ptr;
     2129 
     2130 	if tsegp ^= null
     2131 	then do;
     2132 	     tptr = tsegp;
     2133 	     tsegp = null;				/* so we don't try to do it again... */
     2134 	     call release_temp_segment_ ((MYNAME), tptr, ec2);
     2135 	     if ec2 ^= 0
     2136 	     then call announce_syserr_code (ec2, "Unable to release temp segment.");
     2137 	end;
     2138 
     2139 	if databasep ^= null
     2140 	then do;
     2141 	     tptr = databasep;
     2142 	     databasep = null;
     2143 	     call hcs_$terminate_noname (tptr, ec2);
     2144 	     if ec2 ^= 0
     2145 	     then call announce_syserr_code (ec2, "Unable to terminate database reference.");
     2146 	end;
     2147 
     2148 	call vrm_lock_$cleanup ();
     2149 
     2150 	if old_level ^= -1
     2151 	then call cu_$level_set (old_level);
     2152 
     2153 	a_ec = ec;				/* tell caller our final status */
     2154 
     2155      end clean_up;
     2156 
     2157 /* -------------------------------------------------- */
     2158 
     2159 emergency_exit:					/* just in case ... */
     2160      proc;
     2161 
     2162 	if get_ring_ () = get_initial_ring_ ()		/* inner ring process? */
     2163 	then do;
     2164 	     call continue_to_signal_ (ec);		/* behave like user ring subroutine */
     2165 	     if ec ^= 0
     2166 	     then goto EXIT;
     2167 	end;
     2168 	else do;					/* throw fit if inner ring */
     2169 	     call announce_syserr ("Unexpected error occurred.  Database may be in an inconsistant state.");
     2170 	     ec = error_table_$unexpected_condition;
     2171 	     goto EXIT;				/* "clean_up" called from there... */
     2172 	end;
     2173 
     2174 
     2175      end emergency_exit;
     2176 
     2177 /* -------------------------------------------------- */
     2178 
     2179 get_tseg:						/* get temporary for caller */
     2180      proc;
     2181 
     2182 	if tsegp ^= null ()
     2183 	then do;
     2184 						/* should only need one temporary per invocation */
     2185 	     ec = error_table_$fatal_error;
     2186 	     call announce_syserr (ec, "Attempting to get second temp segment.");
     2187 	     goto EXIT;
     2188 	end;
     2189 	else do;
     2190 	     call get_temp_segment_ ((MYNAME), tsegp, ec);
     2191 	     if ec ^= 0
     2192 	     then goto EXIT;
     2193 	end;
     2194 
     2195      end get_tseg;
     2196 
     2197 /* -------------------------------------------------- */
     2198 
     2199 check_lv:						/* procedure to validate data for LV registration */
     2200      proc (p);
     2201 
     2202 dcl     p			 ptr;
     2203 
     2204 	ec = error_table_$bad_arg;			/* guilty 'til proven innocent */
     2205 
     2206 	if p -> volume_registration.version ^= Volume_Registration_Version_2
     2207 	then do;
     2208 	     ec = error_table_$unimplemented_version;	/* we'll be a little more specific here */
     2209 	     goto EXIT;
     2210 	end;
     2211 	if p -> volume_registration.lvid = "0"b
     2212 	then goto EXIT;
     2213 	if p -> volume_registration.lvname = ""
     2214 	then goto EXIT;
     2215 	if verify (rtrim (p -> volume_registration.lvname), LVNAME_LEGAL) ^= 0
     2216 	then goto EXIT;
     2217 	if ^aim_check_$in_range (p -> volume_registration.access_class_range (2), access_class_range)
     2218 	then goto EXIT;
     2219 	if ^aim_check_$in_range (p -> volume_registration.access_class_range (1), access_class_range)
     2220 	then goto EXIT;
     2221 	if ^aim_check_$greater_or_equal (p -> volume_registration.access_class_range (2),
     2222 	     p -> volume_registration.access_class_range (1))
     2223 	then goto EXIT;
     2224 	if p -> volume_registration.volume_owner = ""
     2225 	then goto EXIT;
     2226 	if p -> volume_registration.acs_path ^= ""
     2227 	then do;
     2228 	     call expand_pathname_ ((p -> volume_registration.acs_path), dn, en, ec2);
     2229 	     if ec2 ^= 0
     2230 	     then do;
     2231 		ec = ec2;
     2232 		goto EXIT;
     2233 	     end;
     2234 	     j = length (rtrim (en));
     2235 	     if substr (en, j - 3, 4) ^= ".acs"
     2236 	     then goto EXIT;
     2237 	end;
     2238 
     2239 /* we'll leave validation of "npv" up to our caller */
     2240 
     2241 /* passed all tests */
     2242 	ec = 0;
     2243 	return;
     2244 
     2245      end check_lv;
     2246 
     2247 /* -------------------------------------------------- */
     2248 
     2249 check_new_lv:					/* validate NEW LV registration data */
     2250      proc (p);
     2251 
     2252 dcl     p			 ptr;
     2253 
     2254 	call check_lv (p);				/* will return if all OK */
     2255 
     2256 	if p -> volume_registration.npv ^= 1
     2257 	then do;
     2258 	     ec = error_table_$bad_arg;
     2259 	     goto EXIT;
     2260 	end;
     2261 
     2262 	ec = 0;
     2263 	return;
     2264 
     2265      end check_new_lv;
     2266 
     2267 /* -------------------------------------------------- */
     2268 
     2269 check_pv:						/* validate PV registration data */
     2270      proc (p);
     2271 
     2272 dcl     p			 ptr;			/* points to pv_registration structure */
     2273 
     2274 	ec = error_table_$bad_arg;
     2275 	if p -> pv_registration.pvid = "0"b
     2276 	then goto EXIT;
     2277 	if p -> pv_registration.model > hbound (MODELN, 1) |
     2278 	     p -> pv_registration.model < lbound (MODELN, 1)
     2279 	then goto EXIT;
     2280 	if verify (rtrim (p -> pv_registration.pvname), PVNAME_LEGAL) ^= 0
     2281 	then goto EXIT;
     2282 	if p -> pv_registration.location = ""
     2283 	then p -> pv_registration.location = "uninitialized";
     2284 	if p -> pv_registration.mfg_serial = ""
     2285 	then p -> pv_registration.mfg_serial = "uninitialized";
     2286 	if p -> pv_registration.date_registered > clock () | p -> pv_registration.date_registered < SMALL_DT
     2287 	then goto EXIT;
     2288 						/* the two bits of "password" may be anything */
     2289 
     2290 	ec = 0;
     2291 	return;
     2292 
     2293      end check_pv;
     2294 
     2295 /* -------------------------------------------------- */
     2296 
     2297 check_new_pv:					/* validate registration data for NEW PV */
     2298      proc (p);
     2299 
     2300 dcl     p			 ptr;
     2301 
     2302 	call check_pv (p);
     2303 						/* no special data checks for new PVs at this time */
     2304 	return;
     2305 
     2306      end check_new_pv;
     2307 
     2308 /* -------------------------------------------------- */
     2309 
     2310 name_exists:					/* see if name exists in given directory */
     2311      proc (dname, ename) returns (bit (1));
     2312 
     2313 dcl     dname		 char (*);
     2314 dcl     ename		 char (*);
     2315 
     2316 	call hcs_$status_minf (dname, ename, 0, type, bc, ec2);
     2317 	if ec2 ^= 0
     2318 	then return ("0"b);
     2319 	else return ("1"b);
     2320 
     2321      end name_exists;
     2322 
     2323 /* -------------------------------------------------- */
     2324 
     2325 locate_:						/* find and set pointer to registration database */
     2326      proc (name, lvflag, dont_init_it);
     2327 
     2328 dcl     name		 char (*);
     2329 dcl     (lvflag, dont_init_it) bit (1);
     2330 
     2331 
     2332 	if lvflag
     2333 	then do;
     2334 	     if name = "root"
     2335 	     then
     2336 		dn = ROOT;
     2337 	     else dn = LV_DIR;
     2338 	     en = "lv." || name;
     2339 	end;
     2340 	else do;
     2341 	     if name = "rpv"
     2342 	     then
     2343 		dn = ROOT;
     2344 	     else dn = LV_DIR;
     2345 	     en = "pv." || name;
     2346 	end;
     2347 
     2348 	call cu_$level_get (old_level);
     2349 	call cu_$level_set (get_ring_ ());		/* SET LEVEL FOR OUR CALLER */
     2350 
     2351 	if ^dont_init_it
     2352 	then do;
     2353 	     call hcs_$initiate (dn, en, "", 0, 0, databasep, ec);
     2354 						/* Locate volume registration for p|lv */
     2355 	     if ec = error_table_$segknown
     2356 	     then do;
     2357 						/* program error */
     2358 		call announce_syserr_code (ec, "Database - ""^a"".", en);
     2359 		ec = 0;
     2360 	     end;
     2361 	     else if ec ^= 0
     2362 	     then do;
     2363 		ec = error_table_$unregistered_volume;
     2364 		goto EXIT;
     2365 	     end;
     2366 
     2367 	     vrp = databasep;			/* this database is "volume_registration" */
     2368 	     if volume_registration.version ^= Volume_Registration_Version_2
     2369 	     then do;
     2370 		call convert_database (ec);
     2371 		if ec ^= 0
     2372 		then goto EXIT;
     2373 	     end;
     2374 	end;
     2375 
     2376      end locate_;
     2377 
     2378 /* -------------------------------------------------- */
     2379 
     2380 locate_uid_:					/* find registration and set pointer based on LVID or PVID */
     2381      proc (uid, lvflag, dont_init_it);
     2382 
     2383 dcl     uid		 bit (36) aligned;
     2384 dcl     (lvflag, dont_init_it) bit (1);
     2385 
     2386 	dn = LV_DIR;				/* we don't know whether it's a root volume
     2387*						   or not.  However, the LV_DIR contains links
     2388*						   for all the unique names ... */
     2389 
     2390 	if lvflag
     2391 	then en = "lvid." || unique_chars_ ((uid));
     2392 	else en = "pvid." || unique_chars_ ((uid));
     2393 
     2394 	call cu_$level_get (old_level);
     2395 	call cu_$level_set (get_ring_ ());		/* SET LEVEL FOR OUR CALLER */
     2396 
     2397 	if ^dont_init_it
     2398 	then do;
     2399 	     call hcs_$initiate (dn, en, "", 0, 0, databasep, ec);
     2400 						/* Locate volume registration for p|lv */
     2401 	     if ec = error_table_$segknown
     2402 	     then do;
     2403 						/* program error */
     2404 		call announce_syserr_code (ec, "Database - ""^a"".", en);
     2405 		ec = 0;
     2406 	     end;
     2407 	     else if ec ^= 0
     2408 	     then do;
     2409 		ec = error_table_$unregistered_volume;
     2410 		goto EXIT;
     2411 	     end;
     2412 
     2413 	     vrp = databasep;			/* this database is "volume_registration" */
     2414 	     if volume_registration.version ^= Volume_Registration_Version_2
     2415 	     then do;
     2416 		call convert_database (ec);
     2417 		if ec ^= 0
     2418 		then goto EXIT;
     2419 	     end;
     2420 	end;
     2421 
     2422      end locate_uid_;
     2423 
     2424 /* -------------------------------------------------- */
     2425 
     2426 get_lve:						/* routine to update Logical Volume entry in disk_table */
     2427      proc () returns (fixed bin);
     2428 
     2429 /* This entry modifies "disk_table" on behalf of the following entries:
     2430*
     2431*   check_volume_registration
     2432*   find
     2433*   get_lv_pvinfo
     2434*   lvname_info
     2435*
     2436**/
     2437 
     2438 dcl     (freex, j)		 fixed bin init (0);
     2439 dcl     found		 bit (1) init ("0"b);
     2440 dcl     lvx		 fixed bin;
     2441 
     2442 	do j = 1 to dt.n_lv_entries while (^found);
     2443 	     lvep = addr (dt.lv_array (j));
     2444 	     if ^lve.used
     2445 	     then if freex = 0
     2446 		then freex = j;
     2447 		else ;
     2448 	     else if lve.lvname = volume_registration.lvname
     2449 	     then do;
     2450 		lvx = j;
     2451 		found = "1"b;
     2452 	     end;
     2453 	end;
     2454 	if ^found
     2455 	then do;
     2456 	     if freex = 0
     2457 	     then freex, dt.n_lv_entries = dt.n_lv_entries + 1;
     2458 	     lvx = freex;
     2459 	     lvep = addr (dt.lv_array (freex));
     2460 	     unspec (lve) = ""b;
     2461 	     lve.used = "1"b;
     2462 	end;
     2463 	else lvep = addr (dt.lv_array (lvx));
     2464 
     2465 /* Always make sure disk table is up to date with our manipulations */
     2466 
     2467 	lve.public = volume_registration.public;
     2468 	lve.lvid = volume_registration.lvid;
     2469 	lve.lvname = volume_registration.lvname;
     2470 	lve.min_access_class = volume_registration.access_class_range (1);
     2471 	lve.max_access_class = volume_registration.access_class_range (2);
     2472 
     2473 	return (lvx);
     2474 
     2475      end get_lve;
     2476 
     2477 /* -------------------------------------------------- */
     2478 
     2479 convert_database:					/* routine to convert from version 1 to version 2 database */
     2480      procedure (a_ec);
     2481 
     2482 dcl     a_ec		 parameter fixed bin (35);
     2483 dcl     temp_class		 bit (72) aligned;
     2484 
     2485 	if volume_registration.version ^= 1
     2486 	then a_ec = error_table_$improper_data_format;
     2487 	else do;
     2488 						/* switch access class values */
     2489 	     temp_class = volume_registration.access_class_range (1);
     2490 	     volume_registration.access_class_range (1) = volume_registration.access_class_range (2);
     2491 	     volume_registration.access_class_range (2) = temp_class;
     2492 	     volume_registration.version = Volume_Registration_Version_2;
     2493 	     call announce_syserr ("Converted "">lv>lv.^a"" to version 2.", volume_registration.lvname);
     2494 	     a_ec = 0;
     2495 	end;
     2496 
     2497 	return;
     2498 
     2499      end convert_database;
     2500 
     2501 /* -------------------------------------------------- */
     2502 
     2503 
     2504 /* ************************************************** */
     2505 /* This is the main exit for all entries              */
     2506 /* ************************************************** */
     2507 
     2508 EXIT:
     2509 	call clean_up;
     2510 	return;
     2511 
     2512 /* -------------------------------------------------- */
     2513 
     2514 test:
     2515      entry (a_dn);
     2516 
     2517 /* PUT US IN TEST MODE - i.e. don't use the real databases */
     2518 
     2519 	ROOT, LV_DIR = a_dn;
     2520 	testing = "1"b;
     2521 
     2522 	return;
     2523 
     2524 /* ------------------------------ */
     2525 
     2526 test2:
     2527      entry (a_dn, a_dn2);
     2528 
     2529 /* same as above entry, except ROOT and LV_DIR may be specified differently */
     2530 
     2531 	ROOT = a_dn;
     2532 	LV_DIR = a_dn2;
     2533 	testing = "1"b;
     2534 
     2535 	return;
     2536 
  1     1 /* Begin include file aim_privileges.incl.pl1  BIM 831206 */
  1     2 /* format: style3 */
  1     3 
  1     4 declare	aim_privileges_ptr	pointer;
  1     5 declare	1 aim_privileges	unaligned based (aim_privileges_ptr),
  1     6 	( 2 ipc,					/** interprocess communication privilege */
  1     7 	  2 dir,					/** directory privilege */
  1     8 	  2 seg,					/** segment privilege */
  1     9 	  2 soos,					/** security out-of-service privilege */
  1    10 	  2 ring1,				/** ring 1 access privilege */
  1    11 	  2 rcp,					/** RCP resource access privilege */
  1    12 	  2 comm					/** communications cross-AIM privilege */
  1    13 	  )		bit (1),
  1    14 	  2 pad		bit (29);
  1    15 
  1    16 declare	(
  1    17 	IPC_PRIVILEGE	init ("1"b),
  1    18 	DIR_PRIVILEGE	init ("01"b),
  1    19 	SEG_PRIVILEGE	init ("001"b),
  1    20 	SOOS_PRIVILEGE	init ("0001"b),
  1    21 	RING1_PRIVILEGE	init ("00001"b),
  1    22 	RCP_PRIVILEGE	init ("000001"b),
  1    23 	COMM_PRIVILEGE	init ("0000001"b),
  1    24 	ALL_PRIVILEGES	init ("1111111"b)
  1    25 	)		bit (36) int static aligned options (constant);
  1    26 
  1    27 
  1    28 /* End include file aim_privileges.incl.pl1 */
     2537 
     2538 
  2     1 /* BEGIN INCLUDE FILE  ...  volume_registration.incl.pl1 */
  2     2 
  2     3 /* Modified 07/27/84 by EJ Sharpe to make pv_registration a
  2     4*		separate structure.  Also renamed "hvid" to "lvid"
  2     5*		and "hvname" to "lvname".
  2     6*   Modified 84-11-06 by EJ Sharpe to combine (max min)_access_class into
  2     7*		access_class_range (2) bit (72) and add version constant
  2     8*		Also changed version constant from 1 to 2.
  2     9**/
  2    10 
  2    11 dcl  vrp ptr;
  2    12 dcl  pvrp ptr;
  2    13 
  2    14 dcl 1 volume_registration aligned based (vrp),
  2    15     2 version fixed bin,				/* Version number of this dcl */
  2    16     2 lvid bit (36),				/* Logical volume unique ID */
  2    17     2 lvname char (32),				/* Logical volume name */
  2    18     2 access_class_range (2) bit (72),			/* Range of authorizations that may use the vol */
  2    19     2 volume_owner char (32),				/* Person.Project */
  2    20     2 acs_path char (168),				/* Path name of ACS */
  2    21     2 flags,
  2    22       3 public bit (1) unal,				/* TRUE if public volume */
  2    23       3 pad bit (35) unal,
  2    24     2 npv fixed bin,				/* Number of physical volumes */
  2    25     2 pv (0 refer (volume_registration.npv)) like pv_registration;
  2    26 
  2    27 
  2    28 dcl 1 pv_registration aligned based (pvrp),
  2    29       2 pvid bit (36),				/* Physical volume unique ID */
  2    30       2 model fixed bin,				/* Model number */
  2    31       2 pvname char (32),				/* Physical volume name */
  2    32       2 location char (32),				/* Where to find volume */
  2    33       2 mfg_serial char (32),				/* Manufacturer's serial no, etc */
  2    34       2 date_registered fixed bin (71),			/* Date and time registered */
  2    35       2 password bit (2);
  2    36 
  2    37 dcl Volume_Registration_Version_2	fixed bin init (2) static options (constant);
  2    38 
  2    39 /* END INCLUDE FILE    ...  volume_registration.incl.pl1 */
     2539 
     2540 
  3     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  3     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  3     7*     Add support for subvolumes.
  3     8*                                                   END HISTORY COMMENTS */
  3     9 
  3    10 
  3    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  3    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  3    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  3    14 
  3    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  3    16 
  3    17 dcl  dtp ptr,
  3    18      dtep ptr,
  3    19      lvep ptr;
  3    20 
  3    21      
  3    22 
  3    23 dcl 1 dt based (dtp) aligned,
  3    24 
  3    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  3    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  3    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  3    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  3    29     2 version fixed bin init (1),
  3    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  3    31     2 pad (2) bit (36),
  3    32     2 array (0 refer (dt.max_n_entries)) like dte,
  3    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  3    34 
  3    35 dcl 1 dte based (dtep) aligned,
  3    36     2 drive_name char (8),				/* device name */
  3    37     (2 device_type fixed bin (8),			/* device type */
  3    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  3    39     2 known bit (1),				/* TRUE if label has been read and checked */
  3    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  3    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  3    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  3    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  3    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  3    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  3    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  3    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  3    48     2 is_sub_vol bit (1),
  3    49     2 pad bit (3),
  3    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  3    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  3    52     2 sv_num  fixed bin unal,				/* this sv number */
  3    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  3    54     2 sv_name   char (2) aligned,
  3    55     2 pvid bit (36),				/* physical volume ID */
  3    56     2 pvname char (32);				/* Physical volume name. */
  3    57 
  3    58 dcl 1 lve based (lvep) aligned,
  3    59     2 lvid bit (36),				/* logical volume ID */
  3    60     (2 used bit (1),				/* TRUE if entry used */
  3    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  3    62     2 public bit (1),				/* TRUE for public vol */
  3    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  3    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  3    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  3    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  3    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  3    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  3    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  3    70     2 pad bit (26)) unal,
  3    71     2 lvname char (32),				/* Logical volume name */
  3    72     2 min_access_class bit (72),			/* Security stuff */
  3    73     2 max_access_class bit (72);			/* .. */
  3    74 
  3    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
     2541 
     2542 
  4     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  4     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  4     7*       1. Declare version constant properly.
  4     8*       2. Remove version 1 since it was never referenced and to force
  4     9*          callers to upgrade their programs.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  4    14 
  4    15 /* this include files gives the argument structure for create_branch_ */
  4    16 
  4    17 dcl 1 create_branch_info aligned based,
  4    18     2 version fixed bin,				/* set this to the largest value given below */
  4    19     2 switches unaligned,
  4    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  4    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  4    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  4    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  4    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  4    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  4    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  4    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  4    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  4    29     2 userid char (32),				/* user's access control name */
  4    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  4    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  4    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  4    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  4    34 
  4    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  4    36 
  4    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  4    38 
     2543 
     2544 
  5     1 /* Begin include file ...... fs_dev_types.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  5     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  5     6*     Add support for FIPS
  5     7*     3380.
  5     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  5     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  5    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  5    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  5    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  5    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  5    14*                                                   END HISTORY COMMENTS */
  5    15 
  5    16 /* Modified 5/19/76 by N. I. Morris */
  5    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  5    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  5    19 /* Modified '82 by BIM for needs_alt_part */
  5    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  5    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  5    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  5    23*   volmap and record stock can be expanded. */
  5    24 
  5    25 /*
  5    26********************************************************************************
  5    27**							        *
  5    28**                           WARNING:                                          *
  5    29**							        *
  5    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  5    31**   type is added.						        *
  5    32**							        *
  5    33**   There are other include files that contain arrays indexed by the device   *
  5    34**   index obtained by references to MODELX or MODELN in this include file.    *
  5    35**   These must be modified when a new device type is added:		        *
  5    36**   disk_pack.incl.pl1					        *
  5    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  5    38**							        *
  5    39********************************************************************************
  5    40**/
  5    41 
  5    42 
  5    43 dcl (maxdevt init (9),				/* maximum legal devt */
  5    44      bulkdevt init (1),				/* bulk store devt */
  5    45      msu0500devt init (2),				/* MSU0500 device type */
  5    46      msu0451devt init (3),				/* MSU0451 device type */
  5    47      msu0450devt init (3),				/* MSU0450 device type */
  5    48      msu0400devt init (4),				/* MSU0400 device type */
  5    49      dsu191devt init (4),				/* DSU191 device type */
  5    50      dsu190devt init (5),				/* DSU190 device type */
  5    51      dsu181devt init (6),				/* DSU181 device type */
  5    52      msu0501devt init (7),				/* MSU0501 device type */
  5    53      fips3380devt init (8),				/* 3380D FIPS device type */
  5    54      fips3381devt init (9)				/* 3380E FIPS device type */
  5    55      ) fixed bin (4) static options (constant);
  5    56 
  5    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  5    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  5    59 
  5    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  5    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  5    62 
  5    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  5    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  5    65 
  5    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  5    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  5    68 
  5    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  5    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  5    71 
  5    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  5    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  5    74 
  5    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  5    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  5    77 
  5    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  5    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  5    80 
  5    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  5    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  5    83 
  5    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  5    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  5    86 
  5    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  5    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  5    89 
  5    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  5    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  5    92 
  5    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  5    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  5    95 
  5    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  5    97      ("abc");
  5    98 
  5    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  5   100      init ("a","b","c");
  5   101 
  5   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  5   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  5   104 
  5   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  5   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  5   107 
  5   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  5   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  5   110 
  5   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  5   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  5   113 
  5   114 
  5   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  5   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  5   117 
  5   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  5   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  5   120 
  5   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  5   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  5   123 
  5   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  5   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  5   126 
  5   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  5   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  5   129 
  5   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  5   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  5   132 
  5   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  5   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  5   135 
  5   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  5   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  5   138 
  5   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  5   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  5   141 
  6     1 /* Begin fs_dev_types_sector.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  6     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  6     7*     Add the sector differance for devices that do 64 word IO and devices that
  6     8*     do 512 word IO.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  6    12*	 need all the data in fs_dev_types. This is also included in
  6    13*	 fs_dev_types.incl.pl1  */
  6    14 
  6    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  6    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  6    17 
  6    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  6    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  6    20 
  6    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  6    22  /* table of # of sectors per record on each device */
  6    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  6    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  6    25 
  6    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  6    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  6    28 	
  6    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  6    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  6    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  6    32 
  6    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  6    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  6    35 
  6    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  6    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  6    38 
  6    39 /* End fs_dev_types_sector.incl.pl1 */
  6    40 
  5   142 
  5   143 
  5   144 /* End of include file ...... fs_dev_types.incl.pl1 */
     2545 
     2546 
  7     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  7     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  7     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  7     4 
  7     5 /* This include file has an ALM version.  Keep 'em in sync! */
  7     6 
  7     7 dcl (
  7     8 
  7     9 /* The following constants define the message action codes.  This indicates
  7    10*how a message is to be handled.  */
  7    11 
  7    12      SYSERR_CRASH_SYSTEM	init (1),			
  7    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  7    14 
  7    15      SYSERR_TERMINATE_PROCESS	init (2),
  7    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  7    17 
  7    18      SYSERR_PRINT_WITH_ALARM	init (3),
  7    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  7    20 
  7    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  7    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  7    23 
  7    24      SYSERR_LOG_OR_PRINT	init (4),
  7    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  7    26 
  7    27      SYSERR_LOG_OR_DISCARD	init (5),
  7    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  7    29 
  7    30 
  7    31 /* The following constants are added to the normal severities to indicate
  7    32*different sorting classes of messages.  */
  7    33 
  7    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  7    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  7    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  7    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  7    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  7    39 	) fixed bin internal static options (constant);
  7    40 
  7    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
     2547 
     2548 
  8     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  8     2*
  8     3*   Values for the "access mode" argument so often used in hardcore
  8     4*   James R. Davis 26 Jan 81  MCR 4844
  8     5*   Added constants for SM access 4/28/82 Jay Pattin
  8     6*   Added text strings 03/19/85 Chris Jones
  8     7**/
  8     8 
  8     9 
  8    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8    11 dcl	(
  8    12 	N_ACCESS		   init ("000"b),
  8    13 	R_ACCESS		   init ("100"b),
  8    14 	E_ACCESS		   init ("010"b),
  8    15 	W_ACCESS		   init ("001"b),
  8    16 	RE_ACCESS		   init ("110"b),
  8    17 	REW_ACCESS	   init ("111"b),
  8    18 	RW_ACCESS		   init ("101"b),
  8    19 	S_ACCESS		   init ("100"b),
  8    20 	M_ACCESS		   init ("010"b),
  8    21 	A_ACCESS		   init ("001"b),
  8    22 	SA_ACCESS		   init ("101"b),
  8    23 	SM_ACCESS		   init ("110"b),
  8    24 	SMA_ACCESS	   init ("111"b)
  8    25 	)		   bit (3) internal static options (constant);
  8    26 
  8    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  8    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  8    29 
  8    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  8    31 			   static options (constant);
  8    32 
  8    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  8    34 			   static options (constant);
  8    35 
  8    36 dcl	(
  8    37 	N_ACCESS_BIN	   init (00000b),
  8    38 	R_ACCESS_BIN	   init (01000b),
  8    39 	E_ACCESS_BIN	   init (00100b),
  8    40 	W_ACCESS_BIN	   init (00010b),
  8    41 	RW_ACCESS_BIN	   init (01010b),
  8    42 	RE_ACCESS_BIN	   init (01100b),
  8    43 	REW_ACCESS_BIN	   init (01110b),
  8    44 	S_ACCESS_BIN	   init (01000b),
  8    45 	M_ACCESS_BIN	   init (00010b),
  8    46 	A_ACCESS_BIN	   init (00001b),
  8    47 	SA_ACCESS_BIN	   init (01001b),
  8    48 	SM_ACCESS_BIN	   init (01010b),
  8    49 	SMA_ACCESS_BIN	   init (01011b)
  8    50 	)		   fixed bin (5) internal static options (constant);
  8    51 
  8    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     2549 
     2550 
  9     1 /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  9     2 
  9     3 /* control flag bit string passed to delete_$path and delete_$ptr
  9     4*
  9     5*   Jay Pattin 6/6/83 */
  9     6 
  9     7 declare   1 delete_options,
  9     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  9     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  9    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  9    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  9    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  9    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  9    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  9    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  9    16           2 mbz                         bit (28) unaligned;
  9    17 
  9    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
     2551 
     2552 
     2553 /* BEGIN MESSAGE DOCUMENTATION
     2554*
     2555*   Message:
     2556*   volume_registration_mgr_$ENTRY: Attempting to get second temp segment. (GROUP_ID)
     2557*
     2558*   S:	$info
     2559*
     2560*   T:	$run
     2561*
     2562*   M:	$err
     2563*   All entrypoints to volume_registration_mgr_ require at most one
     2564*   temporary segment.
     2565*
     2566*   A:	$contact
     2567*
     2568*
     2569*   Message:
     2570*   volume_registration_mgr_$ENTRY: Database - {lvid.UNIQUE | lv.LVNAME | pvid.UNIQUE | pv.PVNAME}. (GROUP_ID) Segment already known to process.
     2571*
     2572*   S:	$info
     2573*
     2574*   T:	$run
     2575*
     2576*   M:	$err
     2577*   The inner ring module always trerminates references to the database segments
     2578*   upon return to its caller.  It found the specified segment already initiated
     2579*   upon entry to the specified routine.
     2580*
     2581*   A:	$contact
     2582*
     2583*
     2584*   Message:
     2585*   volume_registration_mgr_$ENTRY: Unable to release temp segment. (GROUP_ID) ERROR_MESSAGE
     2586*
     2587*   S:	$info
     2588*
     2589*   T:	$run
     2590*
     2591*   M:	$err
     2592*   Some unexpected state is preventing the module from releasing its temporary
     2593*   segment.
     2594*
     2595*   A:	$contact
     2596*
     2597*
     2598*   Message:
     2599*   volume_registration_mgr_$ENTRY: Unable to terminate database reference. (GROUP_ID) ERROR_MESSAGE
     2600*
     2601*   S:	$info
     2602*
     2603*   T:	$run
     2604*
     2605*   M:	$err
     2606*   Some unexpected state is preventing the module from terminating reference
     2607*   to a database segment.
     2608*
     2609*   A:	$contact
     2610*
     2611*
     2612*   Message:
     2613*   volume_registration_mgr_$ENTRY: Unexpected error occurred.  Database may be in an inconsistant state. (GROUP_ID)
     2614*
     2615*   S:	$info
     2616*
     2617*   T:	$run
     2618*
     2619*   M:	$err
     2620*   Some unexpected condition was signalled while the module was executing.
     2621*
     2622*   A:	$contact
     2623*
     2624*
     2625*   Message:
     2626*   volume_registration_mgr_$add_lvr: Added new LV "LVNAME". (GROUP_ID)
     2627*
     2628*   S:	$log
     2629*
     2630*   T:	$run
     2631*
     2632*   M:	A new storage system logical volume has been registered on the system.
     2633*
     2634*   A:	$ignore
     2635*
     2636*
     2637*   Message:
     2638*   volume_registration_mgr_$add_lvr: Added new PV "PVNAME" to LV "LVNAME". (GROUP_ID)
     2639*
     2640*   S:	$log
     2641*
     2642*   T:	$run
     2643*
     2644*   M:	A new storage system physical volume has been registered on the system.
     2645*
     2646*   A:	$ignore
     2647*
     2648*
     2649*   Message:
     2650*   volume_registration_mgr_$add_lvr: Could not append link for {LV name | LVID | PV name | PVID}. (GROUP_ID) ERROR_MESSAGE
     2651*
     2652*   S:	$info
     2653*
     2654*   T:	$run
     2655*
     2656*   M:	A link could not be added into >lv whose target is a database segment
     2657*   located under the root directory.  Future database references may not be
     2658*   possible.
     2659*
     2660*   A:	$contact
     2661*
     2662*
     2663*   Message:
     2664*   volume_registration_mgr_$add_lvr: Unable to back out database "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE
     2665*
     2666*   S:	$info
     2667*
     2668*   T:	$run
     2669*
     2670*   M:	When attempting to register a new logical volume, some error occurred.
     2671*   The entry then attempted to remove the database segment just created.  This
     2672*   removal failed.
     2673*
     2674*   A:	$contact
     2675*
     2676*
     2677*   Message:
     2678*   volume_registration_mgr_$add_pvr: Added new PV "PVNAME" to LV "LVNAME". (GROUP_ID) -log-
     2679*
     2680*   S:	$log
     2681*
     2682*   T:	$run
     2683*
     2684*   M:	A new storage system physical volume has been registered on the system.
     2685*
     2686*   A:	$ignore
     2687*
     2688*
     2689*   Message:
     2690*   volume_registration_mgr_$add_pvr: Could not append link for {PV name| PVID}. (GROUP_ID) ERROR_MESSAGE
     2691*
     2692*   S:	$info
     2693*
     2694*   T:	$run
     2695*
     2696*   M:	A link could not be added into >lv whose target is a database segment
     2697*   located under the root directory.  Future database references may not be
     2698*   possible.
     2699*
     2700*   A:	$contact
     2701*
     2702*
     2703*   Message:
     2704*   volume_registration_mgr_$add_pvr: Extra PV entry "PVNAME" in database "lv.LVNAME". (GROUP_ID)
     2705*
     2706*   S:	$info
     2707*
     2708*   T:	$run
     2709*
     2710*   M:	$err
     2711*   An entry for the specified PV was found in the database segment for
     2712*   the specified LV where no segment addname indicated its existance.
     2713*
     2714*   A:	$contact
     2715*
     2716*
     2717*   Message:
     2718*   volume_registration_mgr_$add_pvr: Unable to back out database addname "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE
     2719*
     2720*   S:	$info
     2721*
     2722*   T:	$run
     2723*
     2724*   M:	An error occurred while registering a new PV.  The entry attmpts to
     2725*   undo all work up to the point of the error.  In this case, it was unable to
     2726*   undo its manipulations and left a spurious addname "pv.PVNAME" on the
     2727*   database segment.
     2728*
     2729*   A:	$contact
     2730*
     2731*
     2732*   Message:
     2733*   volume_registration_mgr_$change_lvr: Changed ACS pathname for LV "LVNAME" to "PATH". (GROUP_ID)
     2734*
     2735*   S:	$log
     2736*
     2737*   T:	$run
     2738*
     2739*   M:	The registered ACS pathname of a storage system logical volume has been
     2740*   changed as indicated.
     2741*
     2742*   A:	$ignore
     2743*
     2744*
     2745*   Message:
     2746*   volume_registration_mgr_$change_lvr: Changed LV "LVNAME" to {PRIVATE | PUBLIC}. (GROUP_ID)
     2747*
     2748*   S:	$log
     2749*
     2750*   T:	$run
     2751*
     2752*   M:	The access type of the specified logical volume has been changed.
     2753*
     2754*   A:	$ignore
     2755*
     2756*
     2757*   Message:
     2758*   volume_registration_mgr_$change_lvr: Changed LVID of LV "LVNAME" from "LVID1" to "LVID2". (GROUP_ID)
     2759*
     2760*   S:	$log
     2761*
     2762*   T:	$run
     2763*
     2764*   M:	The registered logical volume unique ID has been changed for the
     2765*   specified LV.
     2766*
     2767*   A:	$ignore
     2768*
     2769*
     2770*   Message:
     2771*   volume_registration_mgr_$change_lvr: Changed name of LV "LVNAME1" to "LVNAME2". (GROUP_ID)
     2772*
     2773*   S:	$log
     2774*
     2775*   T:	$run
     2776*
     2777*   M:	The registered name of a storage system logical volume has been
     2778*   changed as indicated.
     2779*
     2780*   A:	$ignore
     2781*
     2782*
     2783*   Message:
     2784*   volume_registration_mgr_$change_lvr: Changed owner of LV "LVNAME" from "Person1.Project1" to "Person2.Project2". (GROUP_ID)
     2785*
     2786*   S:	$log
     2787*
     2788*   T:	$run
     2789*
     2790*   M:	The owner of a storage system logical volume has been changed as indicated.
     2791*
     2792*   A:	$ignore
     2793*
     2794*
     2795*   Message:
     2796*   volume_registration_mgr_$change_lvr: Changed {max | min} access class of LV "LVNAME" from "AUTH_STR1" to "AUTH_STR2". (GROUP_ID)
     2797*
     2798*   S:	$log
     2799*
     2800*   T:	$run
     2801*
     2802*   M:	The access class of a storage system logical volume has been changed as indicated.
     2803*
     2804*   A:	$ignore
     2805*
     2806*
     2807*   Message:
     2808*   volume_registration_mgr_$change_lvr: Couldn't {delete | create} link for {old | new} {LV name | LVID}. (GROUP_ID) ERROR_MESSAGE
     2809*
     2810*   S:	$info
     2811*
     2812*   T:	$run
     2813*
     2814*   M:	A link for the specified database segment residing under the root
     2815*   directory could not be created in >lv.
     2816*
     2817*   A:	$contact
     2818*
     2819*
     2820*   Message:
     2821*   volume_registration_mgr_$change_lvr: Unable to back out LVID change to "LVNAME.mdcs". (GROUP_ID) ERROR_MESSAGE
     2822*
     2823*   S:	$info
     2824*
     2825*   T:	$run
     2826*
     2827*   M:	$err
     2828*   While changing attributes of the logical volume LVNAME, an error was
     2829*   encountered.  The entry then attempted to remove some changes already
     2830*   made to the registration database.  In this case, it could not remove
     2831*   the LVID change to the master directory control database LVNAME.mdcs.
     2832*
     2833*   A:	$contact
     2834*
     2835*
     2836*   Message:
     2837*   volume_registration_mgr_$change_lvr: Unable to change name "lv.LVNAME1" back to "lv.LVNAME2" (GROUP_ID) ERROR_MESSAGE
     2838*
     2839*   S:	$info
     2840*
     2841*   T:	$run
     2842*
     2843*   M:	$err
     2844*   While changing attributes ot the logical volume LVNAME, an error was
     2845*   encountered.  The entry then attempted to remove some changes already
     2846*   made to the registration database.  In this case, it could not remove
     2847*   theLV name change.
     2848*
     2849*   A:	$contact
     2850*
     2851*
     2852*   Message:
     2853*   volume_registration_mgr_$change_lvr: Unable to change name "lvid.UNIQUE1" back to "lvid.UNIQUE2". (GROUP_ID) ERROR_MESSAGE
     2854*
     2855*   S:	$info
     2856*
     2857*   T:	$run
     2858*
     2859*   M:	$err
     2860*   While changing attributes ot the logical volume LVNAME, an error was
     2861*   encountered.  The entry then attempted to remove some changes already
     2862*   made to the registration database.  In this case, it could not remove
     2863*   LVID name change.
     2864*
     2865*   A:	$contact
     2866*
     2867*
     2868*   Message:
     2869*   volume_registration_mgr_$change_lvr: Unable to convert {max | min} auth to name_string. (GROUP_ID) ERROR_MESSAGE
     2870*
     2871*   S:	$info
     2872*
     2873*   T:	$run
     2874*
     2875*   M:	$err
     2876*   A binary authorization string could not be converted to its readable
     2877*   representation.
     2878*
     2879*   A:	$contact
     2880*
     2881*
     2882*   Message:
     2883*   volume_registration_mgr_$change_lvr: Unexpected error changing name on "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE
     2884*
     2885*   S:	$info
     2886*
     2887*   T:	$run
     2888*
     2889*   M:	$err
     2890*   An unexpected error occured while changing the name on an LV registration
     2891*   data segment.  The message explains the trouble.
     2892*
     2893*   A:	$contact
     2894*
     2895*
     2896*   Message:
     2897*   volume_registration_mgr_$change_lvr: Unexpected trouble changing name "lvid.UNIQUE". (GROUP_ID) ERROR_MESSAGE
     2898*
     2899*   S:	$info
     2900*
     2901*   T:	$run
     2902*
     2903*   M:	$err
     2904*   An unexpected error occured while changing the name on an LV registration
     2905*   data segment.  The message explains the trouble.
     2906*
     2907*   A:	$contact
     2908*
     2909*
     2910*   Message:
     2911*   volume_registration_mgr_$change_pvr: Changed PVID of PV "PVNAME" from "PVID1" to "PVID2" (GROUP_ID)
     2912*
     2913*   S:	$log
     2914*
     2915*   T:	$run
     2916*
     2917*   M:	The registered physical volume unique IFD has been changed as indicated.
     2918*
     2919*   A:	$ignore
     2920*
     2921*
     2922*   Message:
     2923*   volume_registration_mgr_$change_pvr: Changed date_registered of PV "PVNAME" from "DT1" to "DT2". (GROUP_ID)
     2924*
     2925*   S:	$log
     2926*
     2927*   T:	$run
     2928*
     2929*   M:	The registered date for the specified PV has been changed as indicated.
     2930*
     2931*   A:	$ignore
     2932*
     2933*
     2934*   Message:
     2935*   volume_registration_mgr_$change_pvr: Changed location of PV "PVNAME" from "LOC1" to "LOC2". (GROUP_ID)
     2936*
     2937*   S:	$log
     2938*
     2939*   T:	$run
     2940*
     2941*   M:	The registered location of the specified PV has been changed as indicated.
     2942*
     2943*   A:	$ignore
     2944*
     2945*
     2946*   Message:
     2947*   volume_registration_mgr_$change_pvr: Changed mfg_serial of PV "PVNAME" from "STR1" to "STR2". (GROUP_ID)
     2948*
     2949*   S:	$log
     2950*
     2951*   T:	$run
     2952*
     2953*   M:	The registered serial of the specified PV has been changed as indicated.
     2954*
     2955*   A:	$ignore
     2956*
     2957*
     2958*   Message:
     2959*   volume_registration_mgr_$change_pvr: Changed model of PV "PVNAME" from "TYPE1" to "TYPE2". (GROUP_ID)
     2960*
     2961*   S:	$log
     2962*
     2963*   T:	$run
     2964*
     2965*   M:	The registered model number of the specified PV has been changed as indicated.
     2966*
     2967*   A:	$ignore
     2968*
     2969*
     2970*   Message:
     2971*   volume_registration_mgr_$change_pvr: Changed name of PV "PVNAME1" to "PVNAME2". (GROUP_ID)
     2972*
     2973*   S:	$log
     2974*
     2975*   T:	$run
     2976*
     2977*   M:	The registered name of the specified PV has been changed as indicated.
     2978*
     2979*   A:	$ignore
     2980*
     2981*
     2982*   Message:
     2983*   volume_registration_mgr_$change_pvr: Changed password of PV "PVNAME". (GROUP_ID)
     2984*
     2985*   S:	$log
     2986*
     2987*   T:	$run
     2988*
     2989*   M:	The registered password of the specified PV has been changed as indicated.
     2990*
     2991*   A:	$ignore
     2992*
     2993*
     2994*   Message:
     2995*   volume_registration_mgr_$change_pvr: Couldn't {delete | create} link for {old | new} {PV name | PVID}. (GROUP_ID) ERROR_MESSAGE
     2996*
     2997*   S:	$info
     2998*
     2999*   T:	$run
     3000*
     3001*   M:	A link for a database segment residing in the root directory could
     3002*   not be created in >lv.  This may make some registration data inaccessible.
     3003*
     3004*   A:	$contact
     3005*
     3006*
     3007*   Message:
     3008*   volume_registration_mgr_$change_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)
     3009*
     3010*   S:	$info
     3011*
     3012*   T:	$run
     3013*
     3014*   M:	$err
     3015*   An entry for the specified PV could not be found in the data segment although
     3016*   an addname for that PV exists on the segment entry.
     3017*
     3018*   A:	$contact
     3019*
     3020*
     3021*   Message:
     3022*   volume_registration_mgr_$change_pvr: Unable to back out PVID change. (GROUP_ID) ERROR_MESSAGE
     3023*
     3024*   S:	$info
     3025*
     3026*   T:	$run
     3027*
     3028*   M:	While making changes to the registered PV attributes an error was encountered.
     3029*   The module attempts to remove any work already done on other attributes.
     3030*   For reasons given in ERROR_MESSAGE the PVID change could not be removed.
     3031*
     3032*   A:	$contact
     3033*
     3034*
     3035*   Message:
     3036*   volume_registration_mgr_$change_pvr: Unexpected trouble changing name "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE
     3037*
     3038*   S:	$info
     3039*
     3040*   T:	$run
     3041*
     3042*   M:	While making changes to the registered PV attributes an error was encountered.
     3043*   The module attempts to remove any work already done on other attributes.
     3044*   For reasons given in ERROR_MESSAGE the PV name change could not be removed.
     3045*
     3046*   A:	$contact
     3047*
     3048*
     3049*   Message:
     3050*   volume_registration_mgr_$change_pvr: Unexpected trouble changing name "pvid.UNIQUE". (GROUP_ID) ERROR_MESSAGE
     3051*
     3052*   S:	$info
     3053*
     3054*   T:	$run
     3055*
     3056*   M:	An unexpected state made the program unable to change the database
     3057*   name associated with the PV unique ID.
     3058*
     3059*   A:	$contact
     3060*
     3061*
     3062*   Message:
     3063*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. cannot re-create >lv
     3064*
     3065*   S:	$info
     3066*
     3067*   T:	$init
     3068*
     3069*   M:	When the system is bootloaded, it checks
     3070*   the list of packs which were mounted during the last bootload
     3071*   to make sure that each one has a valid logical and physical volume registration.
     3072*   If the registration does not exist, the registration files are reconstructed.
     3073*   These registration files reside in the directory >lv,
     3074*   which is also remade if it was lost or did not exist.
     3075*   .sp
     3076*   This message indicates that there is a problem in re-creating >lv.
     3077*   Other error messages will follow and reregistration will fail.
     3078*
     3079*   A:	$inform
     3080*
     3081*
     3082*   Message:
     3083*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Putting LV dir on RPV
     3084*
     3085*   S:	$info
     3086*
     3087*   T:	$init
     3088*
     3089*   M:	When the system is bootloaded, it checks
     3090*   the list of packs which were mounted during the last bootload
     3091*   to make sure that each one has a valid logical and physical volume registration.
     3092*   While re-creating >lv, the system attempted to
     3093*   set the directory flag which means "RPV only"
     3094*   and failed to do so.
     3095*
     3096*   A:	$inform
     3097*
     3098*
     3099*   Message:
     3100*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE.  Cannot add SysAdmin access to >lv.
     3101*
     3102*   S:	$info
     3103*
     3104*   T:	$init
     3105*
     3106*   M:	After creating a new >lv directory, an attempt is made to add
     3107*   "sma" access for *.SysAdmin.*.  This failed.
     3108*
     3109*   A:	$inform
     3110*
     3111*
     3112*   Message:
     3113*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot reregister pv PVNAME
     3114*
     3115*   S:	$info
     3116*
     3117*   T:	$init
     3118*
     3119*   M:	When the system is bootloaded, it checks
     3120*   the list of packs which were mounted during the last bootload
     3121*   to make sure that each one has a valid logical and physical volume registration.
     3122*   .sp
     3123*   The system was unable to re-register the physical volume PVNAME
     3124*   because its logical volume entry could not be located in the old disk_table
     3125*   and its physical volume registration file could not be found.
     3126*   The volume will have to be re-registered manually.
     3127*
     3128*   A:	If PVNAME is garbage, ignore this message.
     3129*   Otherwise, use add_vol_registration to re-register the volume.
     3130*
     3131*
     3132*   Message:
     3133*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot reregister lv LVNAME
     3134*
     3135*   S:	$info
     3136*
     3137*   T:	$init
     3138*
     3139*   M:	When the system is bootloaded, it checks
     3140*   the list of packs which were mounted during the last bootload
     3141*   to make sure that each one has a valid logical and physical volume registration.
     3142*   .sp
     3143*   The system was unable to append a branch for
     3144*   >lv>lv.LVNAME.
     3145*   The logical volume will have to be re-registered manually.
     3146*
     3147*   A:	Use the add_vol_registration command
     3148*   to re-register the volume manually.
     3149*
     3150*
     3151*   Message:
     3152*   volume_registration_mgr_$check_volume_registration:  ERROR_MESSAGE.  PATH
     3153*
     3154*   S:	$info
     3155*
     3156*   T:	$init
     3157*
     3158*   M:	An error occurred when trying to reclassify a new lv.** seg
     3159*   as a multi-class system segment.
     3160*
     3161*   A:	$inform
     3162*
     3163*
     3164*   Message:
     3165*   volume_registration_mgr_$check_volume_registration: Reregistered TYPE lv LVNAME lvid WWWW
     3166*
     3167*   S:	$info
     3168*
     3169*   T:	$init
     3170*
     3171*   M:	When the system is bootloaded, it checks
     3172*   the list of packs which were mounted during the last bootload
     3173*   to make sure that each one has a valid logical and physical volume registration.
     3174*   The registration file for LVNAME
     3175*   did not exist and was reconstructed.
     3176*   .sp
     3177*   This message is always produced for the root logical volume during a cold boot of the Multics hierarchy.
     3178*
     3179*   A:	Use the list_vol_registration command
     3180*   to list the registration and check it against the
     3181*   re-created copy.
     3182*   Correct it with change_vol_registration if necessary.
     3183*
     3184*
     3185*   Message:
     3186*   volume_registration_mgr_$check_volume_registration: Code N. lv.LVNAME disagreed with disk_table. It was rebuilt.
     3187*
     3188*   S:	$info
     3189*
     3190*   T:	$init
     3191*
     3192*   M:	When the system is bootloaded, it checks
     3193*   the list of packs which were mounted during the last bootload
     3194*   to make sure that each one has a valid logical and physical volume registration.
     3195*   The registration file lv.LVNAME was found
     3196*   but disagreed with the disk_table_, and so it was corrected.
     3197*   The meaning of the codes can be determined from the
     3198*   listing of volume_registration_mgr_; it is rarely important.
     3199*
     3200*   A:	Use list_vol_registration to examine the remade
     3201*   registration, and correct it with change_vol_registration if necessary.
     3202*
     3203*
     3204*   Message:
     3205*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name lvid.UNIQUE to lv.LVNAME
     3206*
     3207*   S:	$info
     3208*
     3209*   T:	$init
     3210*
     3211*   M:	When the system is bootloaded, it checks
     3212*   the list of packs which were mounted during the last bootload
     3213*   to make sure that each one has a valid logical and physical volume registration.
     3214*   The registration file for LVNAME did not have the additional name
     3215*   constructed from the volume unique ID,
     3216*   and an error was discovered trying to add it.
     3217*   If this name is on another segment, confusion will result.
     3218*
     3219*   A:	$inform
     3220*   Enter admin mode and
     3221*   do a "list >lv>**"
     3222*   command.
     3223*
     3224*
     3225*   Message:
     3226*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cannot make mdcs for LVNAME
     3227*
     3228*   S:	$info
     3229*
     3230*   T:	$init
     3231*
     3232*   M:	When the system is bootloaded, it checks
     3233*   the list of packs which were mounted during the last bootload
     3234*   to make sure that each one has a valid logical and physical volume registration.
     3235*   An error occurred while reconstructing
     3236*   LVNAME.mdcs.
     3237*   Operation on master directories for LVNAME may encounter problems.
     3238*
     3239*   A:	$inform_sa
     3240*
     3241*
     3242*   Message:
     3243*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name pv.PVNAME to LVNAME
     3244*
     3245*   S:	$info
     3246*
     3247*   T:	$init
     3248*
     3249*   M:	When the system is bootloaded, it checks
     3250*   the list of packs which were mounted during the last bootload
     3251*   to make sure that each one has a valid logical and physical volume registration.
     3252*   .sp
     3253*   An error occurred adding the name pv.PVNAME to >lv>lv.LVNAME.
     3254*   If this name is missing or on another segment, confusion will result.
     3255*
     3256*   A:	$inform
     3257*   Enter admin mode and do a
     3258*   "list >lv>**"
     3259*   command.
     3260*
     3261*
     3262*   Message:
     3263*   volume_registration_mgr_$check_volume_registration: Reregistered pv PVNAME pvid WWWW in lv LVNAME
     3264*
     3265*   S:	$info
     3266*
     3267*   T:	$init
     3268*
     3269*   M:	When the system is bootloaded, it checks
     3270*   the list of packs which were mounted during the last bootload
     3271*   to make sure that each one has a valid logical and physical volume registration.
     3272*   Registration for PVNAME was added to
     3273*   the registration file for LVNAME.
     3274*   .sp
     3275*   This message is always produced for the root physical volume, rpv, during a cold boot of the Multics hierarchy.
     3276*
     3277*   A:	Use the list_vol_registration command
     3278*   to check the registration.
     3279*   If necessary, correct it with change_vol_registration.
     3280*
     3281*
     3282*   Message:
     3283*   volume_registration_mgr_$check_volume_registration: Registration for PVNAME was different from disk_table
     3284*
     3285*   S:	$info
     3286*
     3287*   T:	$init
     3288*
     3289*   M:	When the system is bootloaded, it checks
     3290*   the list of packs which were mounted during the last bootload
     3291*   to make sure that each one has a valid logical and physical volume registration.
     3292*   The physical volume ID or model number of PVNAME
     3293*   was wrong in the registration files and was corrected.
     3294*
     3295*   A:	$inform_sa
     3296*
     3297*
     3298*   Message:
     3299*   volume_registration_mgr_$check_volume_registration: ERROR_MESSAGE. Cant add name pvid.UNIQUE to LVNAME
     3300*
     3301*   S:	$info
     3302*
     3303*   T:	$init
     3304*
     3305*   M:	When the system is bootloaded, it checks
     3306*   the list of packs which were mounted during the last bootload
     3307*   to make sure that each one has a valid logical and physical volume registration.
     3308*   An error occurred adding the name pvid.UNIQUE to >lv>lv.LVNAME.
     3309*   If this name is missing or is on another segment, confusion will result.
     3310*
     3311*   A:	$inform
     3312*   Enter admin mode and do a
     3313*   "list >lv>**"
     3314*   command.
     3315*
     3316*
     3317*   Message:
     3318*   volume_registration_mgr_$delete_lvr: Could not remove {PV name | PVID | LV name | LVID} database link. (GROUP_ID) ERROR_MESSAGE
     3319*
     3320*   S:	$info
     3321*
     3322*   T:	$run
     3323*
     3324*   M:	An unexpected state prevented the program from removing the database
     3325*   links associated with an LV just deleted.  The links (in >lv) should be
     3326*   removed by hand using Ring_1_Repair.
     3327*
     3328*   A:	$contact
     3329*
     3330*
     3331*   Message:
     3332*   volume_registration_mgr_$delete_lvr: Deleted LV "LVNAME". (GROUP_ID)
     3333*
     3334*   S:	$log
     3335*
     3336*   T:	$run
     3337*
     3338*   M:	The registration for the spcified logical volume has been removed.
     3339*
     3340*   A:	$ignore
     3341*
     3342*
     3343*   Message:
     3344*   volume_registration_mgr_$delete_lvr: Deleted PV "PVNAME" from LV "LVNAME". (GROUP_ID)
     3345*
     3346*   S:	$log
     3347*
     3348*   T:	$run
     3349*
     3350*   M:	The registration for the specified physical volume was removed while
     3351*   removing the entire logical volume registration.
     3352*
     3353*   A:	$ignore
     3354*
     3355*
     3356*   Message:
     3357*   volume_registration_mgr_$delete_lvr: Unable to delete MDCS "LVNAME.mdcs". (GROUP_ID) ERROR_MESSAGE
     3358*
     3359*   S:	$info
     3360*
     3361*   T:	$run
     3362*
     3363*   M:	After deleting the registration for a logical volume the module was
     3364*   unable to delete the corresponding master directory control database indicated
     3365*   in the message.
     3366*
     3367*   A:	$contact
     3368*
     3369*
     3370*   Message:
     3371*   volume_registration_mgr_$delete_pvr: Could not remove {PV name | PVID} database link. (GROUP_ID) ERROR_MESSAGE
     3372*
     3373*   S:	$info
     3374*
     3375*   T:	$run
     3376*
     3377*   M:	An unexpected state prevented the removal of database links associated
     3378*   with a PV registration that was just deleted.  The links should be deleted
     3379*   by hand using Ring_1_Repair.
     3380*
     3381*   A:	$contact
     3382*
     3383*
     3384*   Message:
     3385*   volume_registration_mgr_$delete_pvr: Deleted PV "PVNAME" from LV "LVNAME". (GROUP_ID)
     3386*
     3387*   S:	$log
     3388*
     3389*   T:	$run
     3390*
     3391*   M:	The registration fo the specified PV has been deleted.
     3392*
     3393*   A:	$ignore
     3394*
     3395*
     3396*   Message:
     3397*   volume_registration_mgr_$delete_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)
     3398*
     3399*   S:	$info
     3400*
     3401*   T:	$run
     3402*
     3403*   M:	$err
     3404*   The entry for the specified PV could not be located in the database
     3405*   segment although its name appears on the segment entry.
     3406*
     3407*   A:	$contact
     3408*
     3409*
     3410*   Message:
     3411*   volume_registration_mgr_$delete_pvr: Trimming registration. (GROUP_ID) ERROR_MESSAGE
     3412*
     3413*   S:	$info
     3414*
     3415*   T:	$run
     3416*
     3417*   M:	An unexpected state prevented the trimming of a registration database
     3418*   segment.  This will not hinder subsystem performance.
     3419*
     3420*   A:	$contact
     3421*
     3422*
     3423*   Message:
     3424*   volume_registration_mgr_$delete_pvr: Unable to replace database name "pv.PVNAME". (GROUP_ID) ERROR_MESSAGE
     3425*
     3426*   S:	$info
     3427*
     3428*   T:	$run
     3429*
     3430*   M:	$err
     3431*   While deleting the registration for the specified PV an error occurred.
     3432*   The program attempts to undo any changes to "leave things as they were."
     3433*   The attempt to put back the database segment name (as indicated) failed.
     3434*
     3435*   A:	$contact
     3436*
     3437*
     3438*   Message:
     3439*   volume_registration_mgr_$find: PV entry missing from "pv.PVNAME". (GROUP_ID)
     3440*
     3441*   S:	$info
     3442*
     3443*   T:	$run
     3444*
     3445*   M:	$err
     3446*   The entry for the specified PV could not be found in the registration database
     3447*   segment although the name appears on the segment's entry.
     3448*
     3449*   A:	$contact
     3450*
     3451*
     3452*   Message:
     3453*   volume_registration_mgr_$find_volname: PV entry not found in database "pvid.UNIQUE". (GROUP_ID)
     3454*
     3455*   S:	$info
     3456*
     3457*   T:	$run
     3458*
     3459*   M:	$err
     3460*   The entry for the specified PV could not be found in the registration database
     3461*   segment although the name appears on the segment's entry.
     3462*
     3463*   A:	$contact
     3464*
     3465*
     3466*   Message:
     3467*   volume_registration_mgr_$get_access: ACS not segment - "PATH". (GROUP_ID)
     3468*
     3469*   S:	$info
     3470*
     3471*   T:	$run
     3472*
     3473*   M:	The ACS indicated in the logical volume registration database is
     3474*   not a segment.  The database entry should be corrected using "change_volume_registration".
     3475*
     3476*   A:	$contact_sa
     3477*
     3478*
     3479*   Message:
     3480*   volume_registration_mgr_$get_access: Bad ACS path in database "lv.LVNAME". (GROUP_ID) ERROR_MESSAGE
     3481*
     3482*   S:	$info
     3483*
     3484*   T:	$run
     3485*
     3486*   M:	$err
     3487*   The ACS pathname entry in the LVNAME database is illegal.  This should not
     3488*   happen normally because the ring-1 primitives check all paths before
     3489*   entering them into the database.
     3490*
     3491*   A:	$contact
     3492*
     3493*
     3494*   Message:
     3495*   volume_registration_mgr_$pvname_info: PV entry not found in database "pv.PVNAME". (GROUP_ID)
     3496*
     3497*   S:	$info
     3498*
     3499*   T:	$run
     3500*
     3501*   M:	$err
     3502*   The entry for the specified PV could not be found in the registration database
     3503*   segment although the name appears on the segment's entry.
     3504*
     3505*   A:	$contact
     3506*
     3507*
     3508*   Message:
     3509*   volume_registration_mgr_$read_pvr: PV entry missing from database "pv.PVNAME". (GROUP_ID)
     3510*
     3511*   S:	$info
     3512*
     3513*   T:	$run
     3514*
     3515*   M:	$err
     3516*   The entry for the specified PV could not be found in the registration database
     3517*   segment although the name appears on the segment's entry.
     3518*
     3519*   A:	$contact
     3520*
     3521*
     3522*   END MESSAGE DOCUMENTATION */
     3523 
     3524      end volume_registration_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0803.3  volume_registration_mgr_.pl1      >spec>install>1111>volume_registration_mgr_.pl1
2537         1    08/19/84  1445.6  aim_privileges.incl.pl1           >ldd>include>aim_privileges.incl.pl1
2539         2    11/20/84  1944.9  volume_registration.incl.pl1      >ldd>include>volume_registration.incl.pl1
2541         3    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
2543         4    03/16/89  2012.8  create_branch_info.incl.pl1       >ldd>include>create_branch_info.incl.pl1
2545         5    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
5-142        6    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
2547         7    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
2549         8    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
2551         9    10/14/83  1606.7  delete_options.incl.pl1           >ldd>include>delete_options.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000000 constant        fixed bin(17,0)          initial dcl 7-7 set ref 2073 2081 2104 2112 2115*
CBI                             001062 automatic       structure                level 1 dcl 155 set ref 1887* 1896 1896
DONT_INIT                              constant        bit(1)                   initial packed unaligned dcl 174 set ref 490* 874*
                                                                                  1278* 1300* 1924* 1939*
INIT                                   constant        bit(1)                   initial packed unaligned dcl 173 set ref 360* 390*
                                                                                  630* 726* 829* 961* 1208* 1390* 1431* 1465* 1508*
                                                                                  1577* 1714* 1770*
LOG                                    constant        fixed bin(17,0)          initial dcl 7-7 ref 2067
LV                                     constant        bit(1)                   initial packed unaligned dcl 172 set ref 360* 490*
                                                                                  630* 726* 874* 961* 1278* 1300* 1431* 1508* 1577*
                                                                                  1714* 1939*
LVNAME_LEGAL                    000100 constant        char(76)                 initial packed unaligned dcl 166 ref 468 1937 2215
LV_DIR                          000067 internal static char(168)                initial packed unaligned dcl 180 set ref 481* 481*
                                                                                  481* 481* 531 534* 537* 540* 544* 624* 624* 665
                                                                                  668* 671* 752 759* 762* 769 776* 779* 876 883*
                                                                                  886* 1064 1071* 1074* 1084 1091* 1094* 1280 1287*
                                                                                  1290* 1302 1309* 1312* 1882 1883 1883 1897* 1901*
                                                                                  1905 1989 1989* 1997 1997* 2001 2001* 2003* 2016
                                                                                  2016* 2047 2047* 2337 2344 2386 2519* 2532*
MODELN                          000000 constant        fixed bin(17,0)          initial array dcl 5-63 set ref 1320* 1320* 2277 2277
MYNAME                          000100 automatic       char(65)                 initial packed unaligned dcl 93 set ref 93* 311*
                                                                                  351* 381* 446* 604* 712* 817* 931* 1189* 1379*
                                                                                  1420* 1450* 1494* 1532* 1663* 1695* 1757* 1866*
                                                                                  2081* 2084* 2112* 2115* 2134 2190
N_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 8-11 ref 1583 1618
PRIV                            000123 constant        char(8)                  initial array packed unaligned dcl 165 set ref 1965*
PV                                     constant        bit(1)                   initial packed unaligned dcl 171 set ref 390* 829*
                                                                                  1208* 1390* 1465* 1770* 1924*
PVNAME_LEGAL                    000066 constant        char(37)                 initial packed unaligned dcl 169 ref 1915 2280
RCP_PRIVILEGE                          constant        bit(36)                  initial dcl 1-16 ref 1579
REAL_LV_DIR                     000011 constant        char(168)                initial packed unaligned dcl 183 ref 1905
REW_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 8-11 ref 1614
ROOT                            000015 internal static char(168)                initial packed unaligned dcl 178 set ref 2334 2341
                                                                                  2519* 2531*
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 8-11 ref 1616
SMALL_DT                        000064 constant        fixed bin(71,0)          initial dcl 175 ref 2286
Volume_Registration_Version_2          constant        fixed bin(17,0)          initial dcl 2-37 ref 1954 1981 2206 2368 2414 2492
a_device_type                          parameter       fixed bin(17,0)          dcl 77 set ref 1369 1402*
a_dn                                   parameter       char                     packed unaligned dcl 87 ref 2514 2519 2526 2531
a_dn2                                  parameter       char                     packed unaligned dcl 88 ref 2526 2532
a_dtep                                 parameter       pointer                  dcl 86 ref 1731 1763 1795 1914
a_dtp                                  parameter       pointer                  dcl 73 ref 298 313
a_ec                                   parameter       fixed bin(35,0)          dcl 2482 in procedure "convert_database" set ref
                                                                                  2479 2485* 2494*
a_ec                                   parameter       fixed bin(35,0)          dcl 75 in procedure "vrm_" set ref 340 371 411 572
                                                                                  684 790 899 1161 1369 1411 1441 1485 1518 1524
                                                                                  1635 1672 1731 1795 1870* 1878* 1930* 1948* 2153*
a_level                                parameter       fixed bin(3,0)           dcl 80 ref 1518 1524 1571
a_lv_access_class_range                parameter       bit(72)                  array dcl 71 set ref 1524 1528* 1626*
a_lvid                                 parameter       bit(36)                  packed unaligned dcl 78 set ref 1369 1404* 1411
                                                                                  1433* 1485 1499
a_lvname                               parameter       char                     packed unaligned dcl 70 set ref 340 357 411 452 572
                                                                                  610 684 718 899 937 1369 1403* 1411 1425 1441
                                                                                  1457* 1477* 1485 1500* 1510* 1518 1524 1570 1635
                                                                                  1672 1707
a_lvx                                  parameter       fixed bin(17,0)          dcl 85 set ref 1672 1715*
a_mode                                 parameter       bit(36)                  dcl 81 set ref 1518 1524 1624*
a_npv                                  parameter       fixed bin(17,0)          dcl 84 set ref 1635 1672 1723*
a_ptr                                  parameter       pointer                  dcl 74 ref 340 358 371 388 411 453 572 611 899 938
                                                                                  1161 1196
a_pub_bit                              parameter       bit(1)                   dcl 82 set ref 1518 1524 1625*
a_pvap                                 parameter       pointer                  dcl 83 ref 1635 1672 1708
a_pvid                                 parameter       bit(36)                  packed unaligned dcl 79 set ref 1369 1401* 1441 1455
a_pvname                               parameter       char                     packed unaligned dcl 76 set ref 371 387 790 823 1161
                                                                                  1195 1369 1384 1441 1457* 1476*
aa                              001035 automatic       structure                level 1 dcl 144 set ref 497 497 1966 1966
access_class_range              001031 automatic       bit(72)                  initial array dcl 142 in procedure "vrm_" set ref
                                                                                  142* 142* 2217* 2219*
access_class_range       12            based           bit(72)                  array level 2 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 1102 1102
                                                                                  1104* 1105* 1106* 1113* 1113 1118 1118 1120* 1121*
                                                                                  1122* 1129* 1129 1579* 1579* 1626 1962* 1963* 1977
                                                                                  1979 2217* 2219* 2221* 2221* 2470 2471 2489 2490*
                                                                                  2490 2491*
acs_path                 26            based           char(168)                level 2 dcl 2-14 set ref 1147 1147 1149* 1149 1150*
                                                                                  1587 1589 1964* 2226 2228
addr                                                   builtin function         dcl 193 ref 479 479 497 497 507 645 1220 1883 1883
                                                                                  1883 1883 1883 1883 1896 1896 1900 1900 1919 1966
                                                                                  1966 2081 2084 2112 2115 2115 2443 2459 2463
admin_gate_$reclassify_sys_seg  000212 constant        entry                    external dcl 234 ref 501 1951
admin_gate_$syserr              000206 constant        entry                    external dcl 231 ref 2084
admin_gate_$syserr_error_code   000210 constant        entry                    external dcl 232 ref 2115
aim_check_$greater_or_equal     000202 constant        entry                    external dcl 227 ref 2221
aim_check_$in_range             000200 constant        entry                    external dcl 226 ref 2217 2219
alp                             000104 automatic       pointer                  dcl 2101 in procedure "announce_syserr_code" set ref
                                                                                  2108* 2109*
alp                             000102 automatic       pointer                  dcl 2065 in procedure "log_it" set ref 2078* 2079*
any_other                       001114 stack reference condition                dcl 191 ref 353 383 448 606 714 819 933 1191 1381
                                                                                  1422 1452 1496 1567 1700 1759 1868 2075 2106
auth_mnemonics                  000553 automatic       char(172)                packed unaligned dcl 136 set ref 1106* 1111* 1114*
                                                                                  1122* 1127* 1130*
based_msg                              based           char                     packed unaligned dcl 2064 in procedure "log_it" set
                                                                                  ref 2081* 2084*
based_msg                              based           char                     packed unaligned dcl 2098 in procedure
                                                                                  "announce_syserr_code" set ref 2112* 2115*
based_packed_ptr                       based           pointer                  packed unaligned dcl 2100 ref 2115
baseno                                                 builtin function         dcl 193 ref 2115
bc                              000512 automatic       fixed bin(24,0)          dcl 127 set ref 1884* 2316*
cleanup                         001106 stack reference condition                dcl 191 ref 354 384 449 607 715 820 934 1192 1382
                                                                                  1423 1453 1497 1568 1703 1760 1873
clock                                                  builtin function         dcl 193 ref 2029 2286
com_err_                        000246 constant        entry                    external dcl 250 ref 2081 2112
continue_to_signal_             000250 constant        entry                    external dcl 251 ref 2164
convert_access_class_$to_string_short
                                000352 constant        entry                    external dcl 290 ref 1106 1122
create_branch_info                     based           structure                level 1 dcl 4-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 4-35 ref 1888
cu_$arg_list_ptr                000236 constant        entry                    external dcl 246 ref 2078 2108
cu_$arg_ptr                     000240 constant        entry                    external dcl 247 ref 2110
cu_$level_get                   000242 constant        entry                    external dcl 248 ref 2348 2394
cu_$level_set                   000244 constant        entry                    external dcl 249 ref 2150 2349 2395
currentsize                                            builtin function         dcl 193 ref 868 868 2033
dacl                            001050 automatic       structure                level 1 dcl 150 set ref 1900 1900
databasep                       000424 automatic       pointer                  initial dcl 122 set ref 122* 491* 495 565* 744* 2139
                                                                                  2141 2142* 2353* 2367 2399* 2413
date_registered          32            based           fixed bin(71,0)          level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 1339 1339 1341* 1342*
                                                                                  1345* 1345 2286 2286
date_registered         134            based           fixed bin(71,0)          array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 2029*
date_time_$format               000216 constant        entry                    external dcl 237 ref 1341 1342
delete_$path                    000314 constant        entry                    external dcl 273 ref 759 762 776 779 883 886 1071
                                                                                  1091 1287 1309
delete_$ptr                     000316 constant        entry                    external dcl 274 ref 561 740
delete_options                  001140 automatic       structure                level 1 packed packed unaligned dcl 9-7 set ref 554*
                                                                                  561 561 736* 740 740 755* 759 759 762 762 772* 776
                                                                                  776 779 779 879* 883 883 886 886 1067* 1071 1071
                                                                                  1087* 1091 1091 1283* 1287 1287 1305* 1309 1309
device_type               2            based           fixed bin(8,0)           level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 3-35 in procedure "vrm_" ref 1777 2025 2036
                                                                                  2040
device_type              10            based           fixed bin(17,0)          array level 2 in structure "pva" dcl 1658
                                                                                  in procedure "vrm_" set ref 1720*
dir_sw                    1     001062 automatic       bit(1)                   level 3 packed packed unaligned dcl 155 set ref
                                                                                  1889*
display_access_class_           000214 constant        entry                    external dcl 236 ref 1104 1105 1120 1121
dn                              000426 automatic       char(168)                packed unaligned dcl 123 set ref 491* 497* 501* 531
                                                                                  534* 534* 537* 537* 540* 540* 544* 544* 665 668*
                                                                                  668* 671* 671* 752 769 876 1064 1074* 1074* 1084
                                                                                  1094* 1094* 1280 1290* 1290* 1302 1312* 1312*
                                                                                  1589* 1596* 1883 1883 1884* 1896* 1900* 1907*
                                                                                  1925* 1940* 1943* 1951* 1952* 1952* 1966* 1989
                                                                                  1989* 1989* 1997 1997* 1997* 2001 2001* 2001* 2016
                                                                                  2016* 2016* 2047 2047* 2047* 2228* 2334* 2337*
                                                                                  2341* 2344* 2353* 2386* 2399*
dname                                  parameter       char                     packed unaligned dcl 2313 set ref 2310 2316*
dont_init_it                           parameter       bit(1)                   packed unaligned dcl 2329 in procedure "locate_" ref
                                                                                  2325 2351
dont_init_it                           parameter       bit(1)                   packed unaligned dcl 2384 in procedure "locate_uid_"
                                                                                  ref 2380 2397
dt                                     based           structure                level 1 dcl 3-23
dte                                    based           structure                level 1 dcl 3-35
dtep                            001132 automatic       pointer                  dcl 3-17 set ref 1706* 1763* 1764 1771 1773 1777
                                                                                  1779 1914* 1915 1917 1917 1919 1922 1933 2010 2023
                                                                                  2025 2036 2036 2039 2040
dtp                             001130 automatic       pointer                  dcl 3-17 set ref 1705* 1762* 1913* 1917 1919 2442
                                                                                  2443 2456 2456 2459 2463
ec                              000550 automatic       fixed bin(35,0)          dcl 133 set ref 364* 395* 402* 462* 470* 474* 475
                                                                                  486* 491* 493 497* 498 501* 502 513* 514 516* 517
                                                                                  520* 521 524* 525 534* 535 535* 537* 538 538* 540*
                                                                                  542 542* 544* 545 545* 549* 618* 619 626* 640*
                                                                                  648* 649 651* 652 668* 669 669* 671* 672 672* 676*
                                                                                  722* 723 729* 730 740* 742 759* 760 760* 762* 763
                                                                                  763* 776* 777 777* 779* 780 780* 825* 826 833*
                                                                                  842* 848* 849 852* 853 868* 869 869* 883* 884 884*
                                                                                  886* 887 887* 891* 945* 951* 957* 958 978* 979 981
                                                                                  981 981* 989* 990 1012* 1016* 1017 1020 1020 1020*
                                                                                  1046* 1047 1071* 1072 1072* 1074* 1075 1075* 1091*
                                                                                  1092 1092* 1094* 1095 1095* 1106* 1108 1110* 1122*
                                                                                  1124 1126* 1153* 1204* 1205 1216* 1235* 1236 1238
                                                                                  1238 1238* 1255* 1259* 1260 1262 1262 1262* 1287*
                                                                                  1288 1288* 1290* 1291 1291* 1309* 1310 1310* 1312*
                                                                                  1313 1313* 1386* 1387 1395* 1400* 1427* 1428 1434*
                                                                                  1461* 1462 1472* 1478* 1504* 1505 1511* 1573* 1574
                                                                                  1589* 1590 1592* 1596* 1598 1629* 1710* 1711 1724*
                                                                                  1766* 1767 1781* 1783* 1787* 1883* 1884* 1885
                                                                                  1896* 1897 1897* 1900* 1901 1901* 1907* 1908 1908*
                                                                                  1925* 1929* 1930 1940* 1943* 1947* 1948 1951* 1952
                                                                                  1952* 1966* 1969* 1970* 1971* 1973* 1975* 1977*
                                                                                  1979* 1981* 1983 1985* 1989* 1993* 1994 1994 1994*
                                                                                  1997* 2005* 2006 2006 2006* 2012* 2013 2013 2013*
                                                                                  2016* 2033* 2043* 2044 2044 2044* 2047* 2050* 2153
                                                                                  2164* 2165 2170* 2185* 2186* 2190* 2191 2204*
                                                                                  2208* 2231* 2242* 2258* 2262* 2274* 2290* 2353*
                                                                                  2355 2358* 2359* 2361 2363* 2370* 2371 2399* 2401
                                                                                  2404* 2405* 2407 2409* 2416* 2417
ec2                             000551 automatic       fixed bin(35,0)          dcl 134 set ref 561* 562 562* 655* 656 656* 856* 857
                                                                                  857* 993* 994 994* 1026* 1027 1027* 1032* 1033
                                                                                  1033* 1050* 1051 1051* 1269* 1270 1270* 2110*
                                                                                  2134* 2135 2135* 2143* 2144 2144* 2228* 2229 2231
                                                                                  2316* 2317
ecode                                  based           fixed bin(35,0)          dcl 2095 set ref 2112* 2115* 2115 2115*
ecode_len                       000102 automatic       fixed bin(21,0)          dcl 2097 set ref 2110*
ecode_p                         000100 automatic       pointer                  dcl 2096 set ref 2110* 2112 2115 2115 2115
en                              000500 automatic       char(32)                 packed unaligned dcl 124 set ref 491* 497* 501* 534*
                                                                                  534* 534* 1589* 1596* 1883 1883 1884* 1896* 1900*
                                                                                  1907* 1925* 1940* 1943* 1951* 1952* 1952* 1966*
                                                                                  1989* 1989* 1989* 1994* 2011* 2012* 2013* 2016*
                                                                                  2016* 2016* 2228* 2234 2235 2338* 2345* 2353*
                                                                                  2358* 2390* 2392* 2399* 2404*
ename                                  parameter       char                     packed unaligned dcl 2314 set ref 2310 2316*
error_table_$action_not_performed
                                000150 external static fixed bin(35,0)          dcl 203 ref 833
error_table_$argerr             000152 external static fixed bin(35,0)          dcl 205 ref 470
error_table_$bad_arg            000174 external static fixed bin(35,0)          dcl 219 ref 462 945 951 1012 1255 2204 2258 2274
error_table_$bad_segment        000154 external static fixed bin(35,0)          dcl 206 ref 402 640 842 1216
error_table_$bad_volid          000162 external static fixed bin(35,0)          dcl 212 ref 1472 1787
error_table_$fatal_error        000160 external static fixed bin(35,0)          dcl 210 ref 2185
error_table_$improper_data_format
                                000144 external static fixed bin(35,0)          dcl 199 ref 2485
error_table_$incorrect_device_type
                                000164 external static fixed bin(35,0)          dcl 213 ref 1783
error_table_$namedup            000172 external static fixed bin(35,0)          dcl 218 ref 486 626 981 1020 1238 1262 2006
error_table_$segknown           000166 external static fixed bin(35,0)          dcl 215 ref 2355 2401
error_table_$segnamedup         000170 external static fixed bin(35,0)          dcl 216 ref 981 1020 1238 1262 1994 2013 2044
error_table_$unexpected_condition
                                000176 external static fixed bin(35,0)          dcl 220 ref 1870 2170
error_table_$unimplemented_version
                                000146 external static fixed bin(35,0)          dcl 201 ref 2208
error_table_$unregistered_volume
                                000156 external static fixed bin(35,0)          dcl 208 ref 1395 2363 2409
expand_path_                    000252 constant        entry                    external dcl 252 ref 1883
expand_pathname_                000254 constant        entry                    external dcl 253 ref 1589 2228
first                           000014 internal static bit(1)                   initial packed unaligned dcl 163 set ref 1879 1881*
fixed                                                  builtin function         dcl 193 ref 1965
flags                   100            based           structure                level 2 dcl 2-14
force                           001140 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-7 set ref 558*
                                                                                  737* 756* 773* 880* 1068* 1088* 1284* 1306*
found                           001266 automatic       bit(1)                   initial packed unaligned dcl 2439 set ref 2439* 2442
                                                                                  2451* 2454
freex                           001264 automatic       fixed bin(17,0)          initial dcl 2438 set ref 2438* 2444 2444* 2456 2456*
                                                                                  2458 2459
get_authorization_              000274 constant        entry                    external dcl 265 ref 1579 1579 1579 1579
get_group_id_                   000300 constant        entry                    external dcl 267 ref 1603 1895 1958 2081 2081 2084
                                                                                  2084 2112 2112 2115 2115
get_initial_ring_               000224 constant        entry                    external dcl 240 ref 2162
get_privileges_                 000276 constant        entry                    external dcl 266 ref 1579
get_ring_                       000222 constant        entry                    external dcl 239 ref 2162 2349 2349 2395 2395
get_temp_segment_               000220 constant        entry                    external dcl 238 ref 2190
hbound                                                 builtin function         dcl 193 ref 2277
hcs_$add_dir_acl_entries        000320 constant        entry                    external dcl 275 ref 1900
hcs_$append_link                000304 constant        entry                    external dcl 269 ref 534 537 540 544 668 671 1074
                                                                                  1094 1290 1312 1989 1997 2001 2016 2047
hcs_$chname_seg                 000306 constant        entry                    external dcl 270 ref 513 516 520 648 651 655 848 852
                                                                                  856 978 993 1016 1026 1050 1235 1259 1269 1993
                                                                                  2012 2043
hcs_$create_branch_             000310 constant        entry                    external dcl 271 ref 1896
hcs_$get_user_raw_mode          000312 constant        entry                    external dcl 272 ref 1596
hcs_$initiate                   000322 constant        entry                    external dcl 277 ref 1925 1940 2353 2399
hcs_$make_seg                   000324 constant        entry                    external dcl 278 ref 491 1943
hcs_$replace_acl                000302 constant        entry                    external dcl 268 ref 497 1966
hcs_$set_bc_seg                 000326 constant        entry                    external dcl 279 ref 2033
hcs_$set_damaged_sw             000330 constant        entry                    external dcl 280 ref 2003
hcs_$set_damaged_sw_seg         000332 constant        entry                    external dcl 281 ref 314 1969
hcs_$status_minf                000336 constant        entry                    external dcl 284 ref 1884 2316
hcs_$terminate_noname           000340 constant        entry                    external dcl 285 ref 1934 2050 2143
hcs_$truncate_seg               000342 constant        entry                    external dcl 286 ref 868
hphcs_$set_rpv                  000334 constant        entry                    external dcl 283 ref 1907
i                               000513 automatic       fixed bin(17,0)          dcl 128 set ref 392* 393 397* 635* 635* 637 644 645
                                                                                  661 748* 749 750* 837* 837* 840 851 863 1210*
                                                                                  1210* 1213 1220 1391* 1391* 1393 1401 1402 1467*
                                                                                  1467* 1469 1476 1718* 1719 1719 1720 1720 1721
                                                                                  1721* 1773* 1773* 1775 1777 1779 1882* 1883 1959*
                                                                                  1960 2019* 2019* 2021 2023 2024 2025 2026 2027
                                                                                  2028 2029 2031 2031 2036 2036 2039 2040 2042
index                                                  builtin function         dcl 193 ref 1607 1610
ioa_$general_rs                 000204 constant        entry                    external dcl 229 ref 2079 2109
j                               000514 automatic       fixed bin(17,0)          dcl 128 in procedure "vrm_" set ref 863* 864 864*
                                                                                  1605* 1606 1607* 1608 1609 1610* 1611 1612 2234*
                                                                                  2235
j                               001265 automatic       fixed bin(17,0)          initial dcl 2438 in procedure "get_lve" set ref
                                                                                  2438* 2442* 2443 2444 2450*
lbound                                                 builtin function         dcl 193 ref 2277
length                                                 builtin function         dcl 193 ref 1605 1882 1959 2234
level                           000411 automatic       fixed bin(17,0)          dcl 116 set ref 1571*
link                      0(04) 001140 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-7 set ref 757*
                                                                                  774* 881* 1069* 1089* 1285* 1307*
location                114            based           char(32)                 array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 2026*
location                 12            based           char(32)                 level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 1325 1325 1327* 1327*
                                                                                  1329* 1329 2282 2282*
lv_array                               based           structure                array level 2 dcl 3-23 set ref 1919 2443 2459 2463
lve                                    based           structure                level 1 dcl 3-58 set ref 2460*
lvep                            001134 automatic       pointer                  dcl 3-17 set ref 1919* 1920 1936 1956 1961 1962 1963
                                                                                  1965 1965 1973 1975 1977 1979 2443* 2444 2448
                                                                                  2459* 2460 2461 2463* 2467 2468 2469 2470 2471
lvflag                                 parameter       bit(1)                   packed unaligned dcl 2329 in procedure "locate_" ref
                                                                                  2325 2332
lvflag                                 parameter       bit(1)                   packed unaligned dcl 2384 in procedure "locate_uid_"
                                                                                  ref 2380 2390
lvid                                   based           bit(36)                  level 2 in structure "lve" dcl 3-58 in procedure
                                                                                  "vrm_" set ref 1956 1965* 1973 2468*
lvid                            000123 automatic       bit(36)                  dcl 96 in procedure "vrm_" set ref 727* 729* 779
                                                                                  1499* 1502 1508*
lvid                      1            based           bit(36)                  level 2 in structure "volume_registration" dcl 2-14
                                                                                  in procedure "vrm_" set ref 481 512 524* 727 970
                                                                                  970 972 973 986* 997* 1031* 1046* 1404 1433 1956*
                                                                                  1973 1991 2005 2211 2468
lvid_changed                    000121 automatic       bit(1)                   packed unaligned dcl 94 set ref 969* 987* 1023 1080
lvname                          000221 automatic       char(32)                 packed unaligned dcl 109 in procedure "vrm_" set ref
                                                                                  357* 360* 452* 468 468 481 490* 524* 528* 529*
                                                                                  562* 610* 630* 639* 663* 718* 726* 729* 751* 767*
                                                                                  776 937* 961* 989* 1032* 1033* 1062* 1082* 1114*
                                                                                  1130* 1136* 1143* 1150* 1425* 1431* 1570* 1577*
                                                                                  1592* 1707* 1714* 1936* 1937 1939* 1947* 1957
                                                                                  1965* 1971 1985* 2000 2005* 2006* 2013* 2031*
                                                                                  2044*
lvname                    2            based           char(32)                 level 2 in structure "lve" dcl 3-58 in procedure
                                                                                  "vrm_" set ref 1936 2448 2469*
lvname                    2            based           char(32)                 level 2 in structure "volume_registration" dcl 2-14
                                                                                  in procedure "vrm_" set ref 468 872* 874 1004 1004
                                                                                  1006 1007 1043* 1055* 1278 1300 1403 1477 1510
                                                                                  1957* 1971 2213 2215 2448 2469 2493*
lvx                       2(23)        based           fixed bin(11,0)          level 2 in structure "dte" packed packed unaligned
                                                                                  dcl 3-35 in procedure "vrm_" set ref 1771* 1917
                                                                                  1917 1919 1933*
lvx                             001267 automatic       fixed bin(17,0)          dcl 2440 in procedure "get_lve" set ref 2450* 2458*
                                                                                  2463 2473
make_lve                        000552 automatic       bit(1)                   packed unaligned dcl 135 set ref 1665* 1697* 1715
max_access_class         14            based           bit(72)                  level 2 dcl 3-58 set ref 1963 1979 2471*
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 3-23 ref 1919 2443 2459 2463
mbz                      11     001035 automatic       bit(36)                  initial level 2 dcl 144 set ref 144*
mdc_init_                       000272 constant        entry                    external dcl 264 ref 316
mdc_repair_$delete_mdcs         000266 constant        entry                    external dcl 260 ref 729
mdc_repair_$make_mdcs           000260 constant        entry                    external dcl 255 ref 524
mdc_repair_$recreate_mdcs       000270 constant        entry                    external dcl 262 ref 2005
mdc_repair_$rename_mdcs         000264 constant        entry                    external dcl 258 ref 1046
mdc_repair_$update_lvid         000262 constant        entry                    external dcl 256 ref 989 1032
mfg_serial               22            based           char(32)                 level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 1332 1332 1334* 1334*
                                                                                  1336* 1336 2284 2284*
mfg_serial              124            based           char(32)                 array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 2027*
min_access_class         12            based           bit(72)                  level 2 dcl 3-58 set ref 1962 1977 2470*
mode                      2     001062 automatic       bit(3)                   level 2 in structure "CBI" packed packed unaligned
                                                                                  dcl 155 in procedure "vrm_" set ref 1891*
mode                     10     001050 automatic       bit(36)                  initial level 2 in structure "dacl" dcl 150
                                                                                  in procedure "vrm_" set ref 150*
mode                            000510 automatic       bit(36)                  dcl 125 in procedure "vrm_" set ref 1583* 1596*
                                                                                  1614* 1616* 1618* 1624
mode                     10     001035 automatic       bit(36)                  initial level 2 in structure "aa" dcl 144
                                                                                  in procedure "vrm_" set ref 144*
model                     1            based           fixed bin(17,0)          level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 1318 1318 1320 1320
                                                                                  1322* 1322 2277 2277
model                   103            based           fixed bin(17,0)          array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 1402 1720
                                                                                  1777 2025* 2036 2040*
n_lv_entries              5            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 1917 2442 2456 2456*
name                                   parameter       char                     packed unaligned dcl 2328 in procedure "locate_" ref
                                                                                  2325 2334 2338 2341 2345
name                            001035 automatic       char(32)                 initial level 2 in structure "aa" dcl 144
                                                                                  in procedure "vrm_" set ref 144*
name                            001050 automatic       char(32)                 initial level 2 in structure "dacl" dcl 150
                                                                                  in procedure "vrm_" set ref 150*
new_aa_str                      000323 automatic       char(168)                packed unaligned dcl 113 set ref 1105* 1114* 1121*
                                                                                  1130*
new_dt_reg                      000403 automatic       char(24)                 packed unaligned dcl 115 set ref 1342* 1343*
new_lvid                        000125 automatic       bit(36)                  dcl 98 set ref 972* 976 986 989* 1032* 1082*
new_lvname                      000241 automatic       char(32)                 packed unaligned dcl 111 set ref 1006* 1016 1043
                                                                                  1046* 1050 1051* 1062* 1074 1074 1074
new_pvid                        000130 automatic       bit(36)                  dcl 101 set ref 1231* 1233 1244 1299*
new_pvname                      000211 automatic       char(32)                 packed unaligned dcl 108 set ref 1251* 1259 1276
                                                                                  1277* 1290 1290 1290
new_uname                       000161 automatic       char(32)                 packed unaligned dcl 105 set ref 976* 978* 993* 994*
                                                                                  1026* 1027* 1094* 1094* 1094* 1233* 1235* 1269*
                                                                                  1312* 1312* 1312*
npv                     101            based           fixed bin(17,0)          level 2 dcl 2-14 set ref 362 392 460 465 505 635 637
                                                                                  661* 733 748 831 837 840 863 866* 866 868 868 943
                                                                                  948 949 1210 1213 1391 1393 1467 1469 1718 1723
                                                                                  1773 1775 2019 2021 2030* 2030 2033 2256
npvrp                           000412 automatic       pointer                  dcl 117 set ref 1198* 1199 1202* 1228 1231 1248 1251
                                                                                  1318 1320 1322 1325 1327 1329 1332 1334 1336 1339
                                                                                  1342 1345 1348 1352
null                                                   builtin function         dcl 193 ref 121 122 565 744 746 1706 1927 1941 1945
                                                                                  2130 2133 2139 2142 2182
nvrp                            000414 automatic       pointer                  dcl 118 set ref 495* 505 506 561* 940* 948 949 955*
                                                                                  970 972 1004 1006 1102 1105 1106 1113 1118 1121
                                                                                  1122 1129 1134 1136 1138 1141 1144 1147 1149
old_aa_str                      000251 automatic       char(168)                packed unaligned dcl 112 set ref 1104* 1114* 1120*
                                                                                  1130*
old_dt_reg                      000375 automatic       char(24)                 packed unaligned dcl 114 set ref 1341* 1343*
old_level                       000547 automatic       fixed bin(17,0)          initial dcl 132 set ref 132* 2150 2150* 2348* 2394*
old_lvid                        000124 automatic       bit(36)                  dcl 97 set ref 973* 975 989* 997 1031 1032* 1082*
old_lvname                      000231 automatic       char(32)                 packed unaligned dcl 110 set ref 1007* 1009 1016
                                                                                  1020* 1046* 1050 1051* 1055 1071
old_pvid                        000127 automatic       bit(36)                  dcl 100 set ref 1230* 1232 1272 1299*
old_pvname                      000201 automatic       char(32)                 packed unaligned dcl 107 set ref 1250* 1253 1259
                                                                                  1262* 1277* 1287
old_uname                       000151 automatic       char(32)                 packed unaligned dcl 104 set ref 975* 978* 981* 993*
                                                                                  994* 1026* 1027* 1091* 1232* 1235* 1238* 1269*
                                                                                  1309*
opers                           000541 automatic       char(22)                 packed unaligned dcl 131 set ref 1611* 1614 1614
oproj                           000530 automatic       char(9)                  packed unaligned dcl 130 set ref 1612* 1614 1614
owner                           000515 automatic       char(32)                 packed unaligned dcl 129 set ref 1958* 1959 1960
p                                      parameter       pointer                  dcl 2202 in procedure "check_lv" ref 2199 2206 2211
                                                                                  2213 2215 2217 2219 2221 2221 2224 2226 2228
p                                      parameter       pointer                  dcl 2252 in procedure "check_new_lv" set ref 2249
                                                                                  2254* 2256
p                                      parameter       pointer                  dcl 2272 in procedure "check_pv" ref 2269 2275 2277
                                                                                  2277 2280 2282 2282 2284 2284 2286 2286
p                                      parameter       pointer                  dcl 2300 in procedure "check_new_pv" set ref 2297
                                                                                  2302*
parent_ac_sw              1(04) 001062 automatic       bit(1)                   level 3 packed packed unaligned dcl 155 set ref
                                                                                  1890*
password                 34            based           bit(2)                   level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 1348 1348 1352* 1352
password                136            based           bit(2)                   array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 2028*
pathname_                       000256 constant        entry                    external dcl 254 ref 534 534 537 537 540 540 544 544
                                                                                  668 668 671 671 1074 1074 1094 1094 1290 1290 1312
                                                                                  1312 1952 1952 1989 1989 1997 1997 2001 2001 2016
                                                                                  2016 2047 2047
pers                            000533 automatic       char(22)                 packed unaligned dcl 131 set ref 1608* 1614
proj                            000525 automatic       char(9)                  packed unaligned dcl 130 set ref 1609* 1614
pub_bit                         001027 automatic       bit(1)                   dcl 139 set ref 1584* 1600* 1619* 1625
public                    1(02)        based           bit(1)                   level 2 in structure "lve" packed packed unaligned
                                                                                  dcl 3-58 in procedure "vrm_" set ref 1961 1965
                                                                                  1975 2467*
public                  100            based           bit(1)                   level 3 in structure "volume_registration" packed
                                                                                  packed unaligned dcl 2-14 in procedure "vrm_" set
                                                                                  ref 1141 1141 1143* 1144* 1144 1600 1616 1619
                                                                                  1961* 1975 2467
pv                      102            based           structure                array level 2 dcl 2-14 set ref 397 479 479 507 644*
                                                                                  645 864* 864 1220
pv_registration                        based           structure                level 1 dcl 2-28 set ref 397* 614* 614 644 1199*
                                                                                  1199
pva                                    based           structure                array level 1 dcl 1658
pvap                            001122 automatic       pointer                  dcl 1656 set ref 1708* 1719 1720 1721
pvid                                   based           bit(36)                  level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 519 623 1228 1228 1230
                                                                                  1231 1244* 1272* 2275
pvid                            000126 automatic       bit(36)                  dcl 99 in procedure "vrm_" set ref 750* 762 1455*
                                                                                  1459 1465* 1467
pvid                      5            based           bit(36)                  level 2 in structure "dte" dcl 3-35 in procedure
                                                                                  "vrm_" set ref 1779* 2023 2036 2039
pvid                    102            based           bit(36)                  array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 481 750 851
                                                                                  1401 1467 1721 1779 2023* 2031* 2036 2039* 2042
pvid                     11            based           bit(36)                  array level 2 in structure "pva" dcl 1658
                                                                                  in procedure "vrm_" set ref 1721*
pvid_changed                    000122 automatic       bit(1)                   packed unaligned dcl 95 set ref 1227* 1245* 1266
                                                                                  1296
pvname                          000171 automatic       char(32)                 packed unaligned dcl 106 in procedure "vrm_" set ref
                                                                                  387* 390* 393 403* 639* 647* 648 655 656* 663* 668
                                                                                  668 668 749* 751* 759 823* 829* 837 843* 848 856
                                                                                  857* 872* 883 1195* 1208* 1210 1215* 1270* 1299*
                                                                                  1320* 1327* 1334* 1343* 1350* 1384* 1390* 1391
                                                                                  1396* 1764* 1770* 1786* 1922* 1924* 1929* 2010*
                                                                                  2011 2019 2024 2036*
pvname                                 based           char(32)                 array level 2 in structure "pva" dcl 1658
                                                                                  in procedure "vrm_" set ref 1719*
pvname                    6            based           char(32)                 level 2 in structure "dte" dcl 3-35 in procedure
                                                                                  "vrm_" ref 1764 1773 1915 1922 2010
pvname                    2            based           char(32)                 level 2 in structure "pv_registration" dcl 2-28
                                                                                  in procedure "vrm_" set ref 516 540 540 540 624
                                                                                  635 647 1248 1248 1250 1251 1276* 2280
pvname                  104            based           char(32)                 array level 3 in structure "volume_registration"
                                                                                  dcl 2-14 in procedure "vrm_" set ref 393 481 529*
                                                                                  635 749 837 1210 1391 1476 1719 1773 2019 2024*
                                                                                  2031*
pvrp                            001126 automatic       pointer                  dcl 2-12 set ref 507* 516 519 540 540 540 613* 614
                                                                                  616* 623 624 635 644 645* 647 1220* 1228 1230 1244
                                                                                  1248 1250 1272 1276 1318 1320 1322 1325 1327 1329
                                                                                  1332 1334 1336 1339 1341 1345 1348 1352
raw                       0(07) 001140 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-7 set ref 560*
                                                                                  739* 758* 775* 882* 1070* 1090* 1286* 1308*
read_allowed_                   000344 constant        entry                    external dcl 287 ref 1579
release_temp_segment_           000226 constant        entry                    external dcl 241 ref 2134
rings                     3     001062 automatic       fixed bin(3,0)           array level 2 dcl 155 set ref 1892* 1893* 1894*
rtrim                                                  builtin function         dcl 193 ref 1605 1882 1915 1959 2000 2215 2234 2280
sdtp                            000012 internal static pointer                  initial dcl 162 set ref 313* 314* 1705 1762 1913
seek_command                    001136 automatic       bit(6)                   initial array packed unaligned dcl 5-84 set ref
                                                                                  5-84* 5-84* 5-84* 5-84* 5-84* 5-84* 5-84* 5-84*
                                                                                  5-84*
segment                   0(03) 001140 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-7 set ref 559*
                                                                                  738*
set_access_range                001030 automatic       bit(1)                   dcl 140 set ref 1521* 1530* 1626
severity                        000103 automatic       fixed bin(17,0)          dcl 2099 in procedure "announce_syserr_code" set ref
                                                                                  2104* 2112
severity                        000100 automatic       fixed bin(17,0)          dcl 2063 in procedure "log_it" set ref 2067* 2073*
                                                                                  2081 2084*
string                                                 builtin function         dcl 193 set ref 554* 561 561 736* 740 740 755* 759
                                                                                  759 762 762 772* 776 776 779 779 879* 883 883 886
                                                                                  886 1067* 1071 1071 1087* 1091 1091 1283* 1287
                                                                                  1287 1305* 1309 1309
substr                                                 builtin function         dcl 193 set ref 1606* 1608 1609 1611 1612 1960 2235
switches                  1     001062 automatic       structure                level 2 packed packed unaligned dcl 155
sys_info$access_class_ceiling   000142 external static bit(72)                  dcl 188 set ref 142 501* 1528 1951*
temp_class                      001300 automatic       bit(72)                  dcl 2483 set ref 2489* 2491
temp_str                        000626 automatic       char(512)                packed unaligned dcl 137 set ref 2079* 2081 2084
                                                                                  2109* 2112 2115
testing                         000010 internal static bit(1)                   initial packed unaligned dcl 160 set ref 2081 2112
                                                                                  2520* 2533*
tptr                            000100 automatic       pointer                  dcl 2128 set ref 2132* 2134* 2141* 2143*
tsegp                           000422 automatic       pointer                  initial dcl 121 set ref 121* 455 613 733 748 749 750
                                                                                  940 1198 2130 2132 2133* 2182 2190*
tstr_len                        001026 automatic       fixed bin(21,0)          dcl 138 set ref 2079* 2081 2081 2084 2084 2109* 2112
                                                                                  2112 2115 2115
type                            000511 automatic       fixed bin(2,0)           dcl 126 set ref 1884* 1885 2316*
uid                                    parameter       bit(36)                  dcl 2383 ref 2380 2390 2392
uname                           000131 automatic       char(32)                 packed unaligned dcl 102 set ref 512* 513* 537* 537*
                                                                                  537* 623* 624* 651* 671* 671* 671* 851* 852* 886*
                                                                                  1459* 1471* 1502* 1603* 1605 1606* 1607 1608 1609
                                                                                  1991* 1993* 1994* 1997* 1997* 1997* 2000* 2001*
                                                                                  2001* 2001* 2003* 2042* 2043* 2044* 2047* 2047*
                                                                                  2047*
uname2                          000141 automatic       char(32)                 packed unaligned dcl 103 set ref 519* 520* 544* 544*
                                                                                  544*
unique_chars_                   000350 constant        entry                    external dcl 289 ref 481 481 512 519 623 762 779 851
                                                                                  975 976 1232 1233 1459 1502 1991 2042 2390 2392
unspec                                                 builtin function         dcl 193 set ref 1887* 2460*
upvrp                           000416 automatic       pointer                  dcl 119 set ref 388* 397 611* 614 1196* 1199
used                      1            based           bit(1)                   level 2 packed packed unaligned dcl 3-58 set ref
                                                                                  1920 2444 2461*
userid                    6     001062 automatic       char(32)                 level 2 dcl 155 set ref 1895*
uvrp                            000420 automatic       pointer                  dcl 120 set ref 358* 362 453* 460 465 938* 943 948
verify                                                 builtin function         dcl 193 ref 468 1915 1937 2215 2280
version                                based           fixed bin(17,0)          level 2 in structure "volume_registration" dcl 2-14
                                                                                  in procedure "vrm_" set ref 1954* 1981 2206 2368
                                                                                  2414 2485 2492*
version                         001062 automatic       fixed bin(17,0)          level 2 in structure "CBI" dcl 155 in procedure
                                                                                  "vrm_" set ref 1888*
volume_owner             16            based           char(32)                 level 2 dcl 2-14 set ref 1134 1134 1136* 1136* 1138*
                                                                                  1138 1610 1611 1612 1960* 2224
volume_registration                    based           structure                level 1 dcl 2-14 set ref 362* 362 465* 465 505* 505
                                                                                  733* 733 868 868 948* 948 2033
vrm_lock_$cleanup               000234 constant        entry                    external dcl 245 ref 2148
vrm_lock_$lock                  000232 constant        entry                    external dcl 244 ref 474 618 722 825 957 1204 1386
                                                                                  1427 1461 1504 1573 1710 1766
vrm_lock_$vrm_data_init         000230 constant        entry                    external dcl 242 ref 315
vrp                             001124 automatic       pointer                  dcl 2-11 set ref 362 392 393 397 455* 465 468 478*
                                                                                  479 479 481 481 481 505 506* 507 512 513* 516*
                                                                                  520* 524 529 635 635 637 644 645 648* 651* 655*
                                                                                  661 727 733 740* 746* 831 837 837 840 848* 851
                                                                                  852* 856* 863 864 864 866 866 868* 868 868 872 874
                                                                                  970 973 978* 986 993* 997 1004 1007 1016* 1026*
                                                                                  1031 1043 1046 1050* 1055 1102 1104 1113 1118 1120
                                                                                  1129 1134 1136 1138 1141 1143 1144 1147 1149 1150
                                                                                  1210 1210 1213 1220 1235* 1259* 1269* 1278 1300
                                                                                  1391 1391 1393 1401 1402 1403 1404 1433 1467 1467
                                                                                  1469 1476 1477 1510 1579 1579 1587 1589 1600 1610
                                                                                  1611 1612 1616 1619 1626 1718 1719 1720 1721 1723
                                                                                  1773 1773 1775 1777 1779 1925* 1927 1934* 1940*
                                                                                  1941 1943* 1945 1954 1956 1957 1960 1961 1962 1963
                                                                                  1964 1969* 1971 1973 1975 1977 1979 1981 1991
                                                                                  1993* 2005 2012* 2019 2019 2021 2023 2024 2025
                                                                                  2026 2027 2028 2029 2030 2030 2031 2031 2033* 2033
                                                                                  2036 2036 2039 2040 2042 2043* 2050* 2367* 2368
                                                                                  2413* 2414 2448 2467 2468 2469 2470 2471 2485 2489
                                                                                  2490 2490 2491 2492 2493
write_allowed_                  000346 constant        entry                    external dcl 288 ref 1579

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_PRIVILEGES                         internal static bit(36)                  initial dcl 1-16
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
BEEP                                   internal static fixed bin(17,0)          initial dcl 7-7
COMM_PRIVILEGE                         internal static bit(36)                  initial dcl 1-16
CRASH                                  internal static fixed bin(17,0)          initial dcl 7-7
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 8-33
DIR_PRIVILEGE                          internal static bit(36)                  initial dcl 1-16
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
IPC_PRIVILEGE                          internal static bit(36)                  initial dcl 1-16
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 7-7
MODEL                                  internal static fixed bin(17,0)          initial array dcl 5-57
MODELX                                 internal static fixed bin(17,0)          initial array dcl 5-60
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 8-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
RING1_PRIVILEGE                        internal static bit(36)                  initial dcl 1-16
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 8-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 8-30
SEG_PRIVILEGE                          internal static bit(36)                  initial dcl 1-16
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 8-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 8-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SOOS_PRIVILEGE                         internal static bit(36)                  initial dcl 1-16
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 7-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 7-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 7-7
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 8-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
aim_privileges                         based           structure                level 1 packed packed unaligned dcl 1-5
aim_privileges_ptr                     automatic       pointer                  dcl 1-4
bulkdevt                               internal static fixed bin(4,0)           initial dcl 5-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 5-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 5-105
dev_time                               internal static float bin(27)            initial array dcl 5-139
device_names                           internal static char(4)                  initial array dcl 5-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 5-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 5-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 5-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 5-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 5-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 5-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 5-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 5-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 5-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 5-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 5-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 5-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 5-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 5-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 5-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 5-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 5-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 5-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 5-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 5-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 5-93
rec_per_cyl                            internal static fixed bin(17,0)          initial array dcl 5-108
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 5-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 5-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 6-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 6-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 6-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 6-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 6-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 5-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 5-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 5-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 5-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 6-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 6-36

NAMES DECLARED BY EXPLICIT CONTEXT.
CK_VREG_EXIT                    020050 constant        label                    dcl 2052 ref 1871
EXIT                            020051 constant        label                    dcl 2508 ref 365 398 405 463 471 475 487 493 551 566
                                                                                  619 627 641 649 658 678 723 730 742 784 826 834
                                                                                  844 849 859 893 946 952 958 984 998 1039 1059 1155
                                                                                  1205 1217 1241 1274 1355 1387 1397 1406 1428 1436
                                                                                  1462 1473 1480 1505 1513 1574 1630 1711 1725 1767
                                                                                  1790 2165 2171 2187 2191 2209 2211 2213 2215 2217
                                                                                  2219 2221 2224 2232 2235 2259 2275 2277 2280 2286
                                                                                  2364 2371 2410 2417
GET_ACCESS_JOIN                 014100 constant        label                    dcl 1532 ref 1522
NO_ACS                          014415 constant        label                    dcl 1603 ref 1593 1598
REMOVE_NEW_LV                   004175 constant        label                    dcl 554 ref 498 502 514 517 521 525
add_lvr                         002542 constant        entry                    external dcl 411
add_pvr                         004266 constant        entry                    external dcl 572
announce_syserr                 020175 constant        entry                    internal dcl 2070 ref 403 639 843 1215 1396 1471
                                                                                  1786 1965 2031 2036 2169 2186 2493
announce_syserr_code            020434 constant        entry                    internal dcl 2092 ref 535 538 542 545 562 656 669
                                                                                  672 760 763 777 780 857 869 884 887 981 994 1020
                                                                                  1027 1033 1051 1072 1075 1092 1095 1110 1126 1238
                                                                                  1262 1270 1288 1291 1310 1313 1592 1897 1901 1908
                                                                                  1929 1947 1952 1985 1994 2006 2013 2044 2135 2144
                                                                                  2358 2404
back_out_lvid_change            007573 constant        label                    dcl 1023 ref 1013 1056
back_out_pvid_change            011666 constant        label                    dcl 1266 ref 1256
change_lvr                      007015 constant        entry                    external dcl 899
change_pvr                      011165 constant        entry                    external dcl 1161
check_lv                        021255 constant        entry                    internal dcl 2199 ref 955 2254
check_new_lv                    021471 constant        entry                    internal dcl 2249 ref 478
check_new_pv                    021607 constant        entry                    internal dcl 2297 ref 479 616
check_pv                        021515 constant        entry                    internal dcl 2269 ref 1202 2302
check_volume_registration       015240 constant        entry                    external dcl 1795
clean_up                        020730 constant        entry                    internal dcl 2125 ref 354 384 449 607 715 820 934
                                                                                  1192 1382 1423 1453 1497 1568 1703 1760 2508
convert_database                022611 constant        entry                    internal dcl 2479 ref 1981 2370 2416
delete_lvr                      005220 constant        entry                    external dcl 684
delete_pvr                      006121 constant        entry                    external dcl 790
emergency_exit                  021106 constant        entry                    internal dcl 2159 ref 353 383 448 606 714 819 933
                                                                                  1191 1381 1422 1452 1496 1567 1700 1759
find                            015027 constant        entry                    external dcl 1731
find_lvid                       013200 constant        entry                    external dcl 1411
find_lvname                     013616 constant        entry                    external dcl 1485
find_volname                    013327 constant        entry                    external dcl 1441
get_access                      014007 constant        entry                    external dcl 1518
get_access_for_attach           014035 constant        entry                    external dcl 1524
get_lv_pvinfo                   014625 constant        entry                    external dcl 1672
get_lve                         022443 constant        entry                    internal dcl 2426 ref 1715 1771 1933
get_tseg                        021176 constant        entry                    internal dcl 2179 ref 454 612 720 939 1197
init                            002163 constant        entry                    external dcl 298
locate_                         021714 constant        entry                    internal dcl 2325 ref 360 390 490 630 726 829 874
                                                                                  961 1208 1278 1300 1390 1431 1577 1714 1770 1924
                                                                                  1939
locate_uid_                     022172 constant        entry                    internal dcl 2380 ref 1465 1508
log_it                          020164 constant        entry                    internal dcl 2060 ref 528 529 663 751 767 872 1062
                                                                                  1082 1114 1130 1136 1143 1150 1277 1299 1320 1327
                                                                                  1334 1343 1350
log_it_join                     020204 constant        label                    dcl 2075 ref 2068
lv_pvinfo_common                014650 constant        label                    dcl 1700 ref 1666
lvfail                          015745 constant        label                    dcl 1922 ref 1917
lvname_info                     014575 constant        entry                    external dcl 1635
name_exists                     021620 constant        entry                    internal dcl 2310 ref 481 481 481 481 624 624
pvname_info                     012753 constant        entry                    external dcl 1369
read_lvr                        002235 constant        entry                    external dcl 340
read_pvr                        002356 constant        entry                    external dcl 371
remake_lv                       016336 constant        label                    dcl 1954 ref 1986
test                            020061 constant        entry                    external dcl 2514
test2                           020123 constant        entry                    external dcl 2526
volume_registration_mgr_        002151 constant        entry                    external dcl 26
vrm_                            002141 constant        entry                    external dcl 26

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     25274       25650   23454       25304
Length     26724   23454       354        1040    1617         132

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrm_                               1176 external procedure  is an external procedure.  
on unit on line 353                  64 on unit               
on unit on line 354                  64 on unit               
on unit on line 383                  64 on unit               
on unit on line 384                  64 on unit               
on unit on line 448                  64 on unit               
on unit on line 449                  64 on unit               
on unit on line 606                  64 on unit               
on unit on line 607                  64 on unit               
on unit on line 714                  64 on unit               
on unit on line 715                  64 on unit               
on unit on line 819                  64 on unit               
on unit on line 820                  64 on unit               
on unit on line 933                  64 on unit               
on unit on line 934                  64 on unit               
on unit on line 1191                 64 on unit               
on unit on line 1192                 64 on unit               
on unit on line 1381                 64 on unit               
on unit on line 1382                 64 on unit               
on unit on line 1422                 64 on unit               
on unit on line 1423                 64 on unit               
on unit on line 1452                 64 on unit               
on unit on line 1453                 64 on unit               
on unit on line 1496                 64 on unit               
on unit on line 1497                 64 on unit               
on unit on line 1567                 64 on unit               
on unit on line 1568                 64 on unit               
on unit on line 1700                 64 on unit               
on unit on line 1703                 64 on unit               
on unit on line 1759                 64 on unit               
on unit on line 1760                 64 on unit               
on unit on line 1868                 64 on unit               
on unit on line 1873                 64 on unit               
log_it                              146 internal procedure  enables or reverts conditions, and is declared options(variable).  
on unit on line 2075                 64 on unit               
announce_syserr_code                182 internal procedure  enables or reverts conditions, and is declared options(variable).  
on unit on line 2106                 64 on unit               
clean_up                             98 internal procedure  is called by several nonquick procedures.  
emergency_exit                       96 internal procedure  is called by several nonquick procedures.  
get_tseg                                internal procedure  shares stack frame of external procedure vrm_.  
check_lv                                internal procedure  shares stack frame of external procedure vrm_.  
check_new_lv                            internal procedure  shares stack frame of external procedure vrm_.  
check_pv                                internal procedure  shares stack frame of external procedure vrm_.  
check_new_pv                            internal procedure  shares stack frame of external procedure vrm_.  
name_exists                             internal procedure  shares stack frame of external procedure vrm_.  
locate_                                 internal procedure  shares stack frame of external procedure vrm_.  
locate_uid_                             internal procedure  shares stack frame of external procedure vrm_.  
get_lve                                 internal procedure  shares stack frame of external procedure vrm_.  
convert_database                        internal procedure  shares stack frame of external procedure vrm_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 testing                     vrm_
000012 sdtp                        vrm_
000014 first                       vrm_
000015 ROOT                        vrm_
000067 LV_DIR                      vrm_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
announce_syserr_code     000100 ecode_p                     announce_syserr_code
                         000102 ecode_len                   announce_syserr_code
                         000103 severity                    announce_syserr_code
                         000104 alp                         announce_syserr_code
clean_up                 000100 tptr                        clean_up
log_it                   000100 severity                    log_it
                         000102 alp                         log_it
vrm_                     000100 MYNAME                      vrm_
                         000121 lvid_changed                vrm_
                         000122 pvid_changed                vrm_
                         000123 lvid                        vrm_
                         000124 old_lvid                    vrm_
                         000125 new_lvid                    vrm_
                         000126 pvid                        vrm_
                         000127 old_pvid                    vrm_
                         000130 new_pvid                    vrm_
                         000131 uname                       vrm_
                         000141 uname2                      vrm_
                         000151 old_uname                   vrm_
                         000161 new_uname                   vrm_
                         000171 pvname                      vrm_
                         000201 old_pvname                  vrm_
                         000211 new_pvname                  vrm_
                         000221 lvname                      vrm_
                         000231 old_lvname                  vrm_
                         000241 new_lvname                  vrm_
                         000251 old_aa_str                  vrm_
                         000323 new_aa_str                  vrm_
                         000375 old_dt_reg                  vrm_
                         000403 new_dt_reg                  vrm_
                         000411 level                       vrm_
                         000412 npvrp                       vrm_
                         000414 nvrp                        vrm_
                         000416 upvrp                       vrm_
                         000420 uvrp                        vrm_
                         000422 tsegp                       vrm_
                         000424 databasep                   vrm_
                         000426 dn                          vrm_
                         000500 en                          vrm_
                         000510 mode                        vrm_
                         000511 type                        vrm_
                         000512 bc                          vrm_
                         000513 i                           vrm_
                         000514 j                           vrm_
                         000515 owner                       vrm_
                         000525 proj                        vrm_
                         000530 oproj                       vrm_
                         000533 pers                        vrm_
                         000541 opers                       vrm_
                         000547 old_level                   vrm_
                         000550 ec                          vrm_
                         000551 ec2                         vrm_
                         000552 make_lve                    vrm_
                         000553 auth_mnemonics              vrm_
                         000626 temp_str                    vrm_
                         001026 tstr_len                    vrm_
                         001027 pub_bit                     vrm_
                         001030 set_access_range            vrm_
                         001031 access_class_range          vrm_
                         001035 aa                          vrm_
                         001050 dacl                        vrm_
                         001062 CBI                         vrm_
                         001122 pvap                        vrm_
                         001124 vrp                         vrm_
                         001126 pvrp                        vrm_
                         001130 dtp                         vrm_
                         001132 dtep                        vrm_
                         001134 lvep                        vrm_
                         001136 seek_command                vrm_
                         001140 delete_options              vrm_
                         001264 freex                       get_lve
                         001265 j                           get_lve
                         001266 found                       get_lve
                         001267 lvx                         get_lve
                         001300 temp_class                  convert_database

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
admin_gate_$reclassify_sys_seg                              admin_gate_$syserr            admin_gate_$syserr_error_code
aim_check_$greater_or_equal   aim_check_$in_range           com_err_                      continue_to_signal_
convert_access_class_$to_string_short                       cu_$arg_list_ptr              cu_$arg_ptr
cu_$level_get                 cu_$level_set                 date_time_$format             delete_$path
delete_$ptr                   display_access_class_         expand_path_                  expand_pathname_
get_authorization_            get_group_id_                 get_initial_ring_             get_privileges_
get_ring_                     get_temp_segment_             hcs_$add_dir_acl_entries      hcs_$append_link
hcs_$chname_seg               hcs_$create_branch_           hcs_$get_user_raw_mode        hcs_$initiate
hcs_$make_seg                 hcs_$replace_acl              hcs_$set_bc_seg               hcs_$set_damaged_sw
hcs_$set_damaged_sw_seg       hcs_$status_minf              hcs_$terminate_noname         hcs_$truncate_seg
hphcs_$set_rpv                ioa_$general_rs               mdc_init_                     mdc_repair_$delete_mdcs
mdc_repair_$make_mdcs         mdc_repair_$recreate_mdcs     mdc_repair_$rename_mdcs       mdc_repair_$update_lvid
pathname_                     read_allowed_                 release_temp_segment_         unique_chars_
vrm_lock_$cleanup             vrm_lock_$lock                vrm_lock_$vrm_data_init       write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$argerr           error_table_$bad_arg
error_table_$bad_segment      error_table_$bad_volid        error_table_$fatal_error
error_table_$improper_data_format                           error_table_$incorrect_device_type
error_table_$namedup          error_table_$segknown         error_table_$segnamedup
error_table_$unexpected_condition                           error_table_$unimplemented_version
error_table_$unregistered_volume                            sys_info$access_class_ceiling




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     93 002002       121 002005       122 002007       132 002010       142 002012       144 002034       150 002042
 5   84 002047        26 002140       298 002157       311 002171       313 002174       314 002201       315 002216
    316 002223       318 002230       340 002231       351 002253       353 002256       354 002300       357 002322
    358 002332       360 002336       362 002341       364 002352       365 002353       371 002354       381 002374
    383 002377       384 002421       387 002443       388 002453       390 002457       392 002462       393 002473
    395 002503       397 002504       398 002512       400 002513       402 002515       403 002520       405 002537
    411 002540       446 002560       448 002563       449 002605       452 002627       453 002637       454 002643
    455 002644       460 002646       462 002652       463 002655       465 002656       468 002665       470 002703
    471 002706       474 002707       475 002716       478 002720       479 002722       481 002727       486 003143
    487 003146       490 003147       491 003152       493 003211       495 003213       497 003215       498 003260
    501 003262       502 003307       505 003311       506 003322       507 003323       512 003326       513 003361
    514 003407       516 003411       517 003445       519 003447       520 003501       521 003527       524 003531
    525 003553       528 003555       529 003574       531 003622       534 003627       535 003673       537 003714
    538 003761       540 004002       542 004064       544 004105       545 004152       549 004173       551 004174
    554 004175       558 004176       559 004200       560 004202       561 004204       562 004233       565 004261
    566 004263       572 004264       604 004304       606 004307       607 004331       610 004353       611 004363
    612 004367       613 004370       614 004372       616 004377       618 004401       619 004410       623 004412
    624 004444       626 004525       627 004530       630 004531       635 004534       636 004555       637 004557
    639 004563       640 004605       641 004610       644 004611       645 004617       647 004621       648 004624
    649 004657       651 004661       652 004706       655 004710       656 004743       658 004770       661 004771
    663 004774       665 005016       668 005023       669 005103       671 005124       672 005171       676 005212
    678 005213       684 005214       712 005236       714 005241       715 005263       718 005305       720 005315
    722 005316       723 005325       726 005327       727 005332       729 005335       730 005356       733 005360
    736 005371       737 005372       738 005374       739 005376       740 005400       742 005427       744 005431
    746 005433       748 005434       749 005445       750 005453       751 005456       752 005500       755 005505
    756 005506       757 005510       758 005512       759 005514       760 005554       762 005575       763 005655
    766 005676       767 005700       769 005720       772 005725       773 005726       774 005730       775 005732
    776 005734       777 005774       779 006015       780 006075       784 006116       790 006117       817 006137
    819 006142       820 006164       823 006206       825 006216       826 006225       829 006227       831 006232
    833 006236       834 006241       837 006242       838 006260       840 006262       842 006266       843 006271
    844 006310       848 006311       849 006344       851 006346       852 006403       853 006431       856 006433
    857 006466       859 006513       863 006514       864 006525       865 006535       866 006537       868 006542
    869 006561       872 006605       874 006631       876 006640       879 006645       880 006646       881 006650
    882 006652       883 006654       884 006714       886 006735       887 006770       891 007011       893 007012
    899 007013       931 007033       933 007036       934 007060       937 007102       938 007112       939 007116
    940 007117       943 007121       945 007124       946 007127       948 007130       949 007137       951 007141
    952 007144       955 007145       957 007147       958 007156       961 007160       969 007163       970 007164
    972 007171       973 007173       975 007175       976 007226       978 007261       979 007306       981 007310
    984 007340       986 007341       987 007344       989 007346       990 007372       993 007374       994 007420
    997 007451       998 007454      1004 007455      1006 007463      1007 007466      1009 007471      1012 007475
   1013 007500      1016 007501      1017 007541      1020 007543      1023 007573      1026 007575      1027 007621
   1031 007652      1032 007655      1033 007701      1039 007726      1043 007727      1046 007733      1047 007757
   1050 007761      1051 010021      1055 010052      1056 010056      1059 010057      1062 010060      1064 010102
   1067 010107      1068 010110      1069 010112      1070 010114      1071 010116      1072 010156      1074 010177
   1075 010260      1080 010301      1082 010303      1084 010331      1087 010336      1088 010337      1089 010341
   1090 010343      1091 010345      1092 010377      1094 010420      1095 010465      1102 010506      1104 010516
   1105 010532      1106 010547      1108 010571      1110 010573      1111 010612      1113 010615      1114 010623
   1118 010655      1120 010665      1121 010701      1122 010716      1124 010740      1126 010742      1127 010761
   1129 010764      1130 010772      1134 011024      1136 011032      1138 011060      1141 011065      1143 011074
   1144 011117      1147 011125      1149 011133      1150 011136      1153 011161      1155 011162      1161 011163
   1189 011203      1191 011206      1192 011230      1195 011252      1196 011262      1197 011266      1198 011267
   1199 011271      1202 011276      1204 011300      1205 011307      1208 011311      1210 011314      1211 011334
   1213 011336      1215 011342      1216 011361      1217 011364      1220 011365      1227 011370      1228 011371
   1230 011374      1231 011375      1232 011377      1233 011431      1235 011464      1236 011511      1238 011513
   1241 011543      1244 011544      1245 011546      1248 011550      1250 011556      1251 011561      1253 011564
   1255 011570      1256 011573      1259 011574      1260 011634      1262 011636      1266 011666      1269 011670
   1270 011714      1272 011742      1274 011744      1276 011745      1277 011751      1278 011773      1280 012002
   1283 012007      1284 012010      1285 012012      1286 012014      1287 012016      1288 012056      1290 012077
   1291 012160      1296 012201      1299 012203      1300 012231      1302 012240      1305 012245      1306 012246
   1307 012250      1308 012252      1309 012254      1310 012306      1312 012327      1313 012374      1318 012415
   1320 012422      1322 012452      1325 012456      1327 012464      1329 012512      1332 012517      1334 012523
   1336 012551      1339 012556      1341 012561      1342 012621      1343 012662      1345 012710      1348 012714
   1350 012721      1352 012740      1355 012744      1369 012745      1379 013002      1381 013005      1382 013027
   1384 013051      1386 013061      1387 013070      1390 013072      1391 013075      1392 013114      1393 013116
   1395 013122      1396 013125      1397 013144      1400 013145      1401 013146      1402 013154      1403 013157
   1404 013167      1406 013173      1411 013174      1420 013220      1422 013223      1423 013245      1425 013267
   1427 013277      1428 013306      1431 013310      1433 013313      1434 013320      1436 013321      1441 013322
   1450 013353      1452 013356      1453 013400      1455 013422      1457 013426      1459 013446      1461 013500
   1462 013510      1465 013512      1467 013514      1468 013532      1469 013534      1471 013540      1472 013557
   1473 013562      1476 013563      1477 013600      1478 013610      1480 013611      1485 013612      1494 013636
   1496 013641      1497 013663      1499 013705      1500 013711      1502 013721      1504 013753      1505 013763
   1508 013765      1510 013767      1511 014000      1513 014001      1518 014002      1521 014025      1522 014026
   1524 014027      1528 014053      1530 014076      1532 014100      1567 014103      1568 014125      1570 014147
   1571 014157      1573 014162      1574 014171      1577 014173      1579 014176      1583 014267      1584 014270
   1585 014271      1587 014272      1589 014277      1590 014327      1592 014331      1593 014354      1596 014355
   1598 014406      1600 014410      1601 014414      1603 014415      1605 014424      1606 014436      1607 014446
   1608 014457      1609 014463      1610 014471      1611 014503      1612 014507      1614 014515      1616 014540
   1618 014546      1619 014547      1624 014552      1625 014555      1626 014557      1629 014566      1630 014567
   1635 014570      1663 014613      1665 014616      1666 014617      1672 014620      1695 014643      1697 014646
   1700 014650      1703 014672      1705 014714      1706 014717      1707 014721      1708 014731      1710 014735
   1711 014743      1714 014745      1715 014750      1718 014761      1719 014771      1720 015004      1721 015011
   1722 015013      1723 015015      1724 015021      1725 015022      1731 015023      1757 015040      1759 015043
   1760 015065      1762 015107      1763 015112      1764 015116      1766 015121      1767 015127      1770 015131
   1771 015134      1773 015144      1774 015165      1775 015167      1777 015173      1779 015203      1781 015205
   1782 015206      1783 015207      1784 015212      1786 015213      1787 015232      1790 015235      1795 015236
   1866 015251      1868 015254      1870 015270      1871 015273      1873 015276      1878 015313      1879 015314
   1881 015317      1882 015320      1883 015332      1884 015357      1885 015415      1887 015422      1888 015425
   1889 015427      1890 015431      1891 015433      1892 015435      1893 015437      1894 015440      1895 015441
   1896 015453      1897 015502      1900 015534      1901 015571      1905 015617      1907 015624      1908 015644
   1913 015670      1914 015673      1915 015677      1917 015722      1919 015732      1920 015742      1922 015745
   1924 015750      1925 015753      1927 016016      1929 016022      1930 016045      1931 016047      1933 016050
   1934 016060      1936 016072      1937 016076      1939 016110      1940 016113      1941 016156      1943 016162
   1945 016221      1947 016225      1948 016250      1949 016252      1951 016253      1952 016300      1954 016336
   1956 016340      1957 016343      1958 016346      1959 016355      1960 016367      1961 016374      1962 016402
   1963 016406      1964 016412      1965 016415      1966 016450      1967 016513      1969 016514      1970 016531
   1971 016532      1973 016541      1975 016546      1977 016561      1979 016571      1981 016601      1983 016606
   1985 016610      1986 016633      1989 016634      1991 016705      1993 016740      1994 016766      1997 017021
   2000 017072      2001 017120      2003 017173      2005 017223      2006 017247      2010 017277      2011 017303
   2012 017316      2013 017344      2016 017377      2019 017450      2020 017470      2021 017472      2023 017476
   2024 017502      2025 017506      2026 017512      2027 017516      2028 017522      2029 017523      2030 017526
   2031 017527      2033 017562      2034 017603      2036 017604      2039 017636      2040 017644      2042 017650
   2043 017705      2044 017733      2047 017766      2050 020037      2052 020050      2508 020051      2510 020055
   2514 020056      2519 020075      2520 020113      2522 020116      2526 020117      2531 020144      2532 020153
   2533 020160      2535 020162      2060 020163      2067 020171      2068 020173      2070 020174      2073 020202
   2075 020204      2078 020221      2079 020230      2081 020277      2084 020362      2086 020432      2092 020433
   2104 020441      2106 020443      2108 020460      2109 020467      2110 020536      2112 020556      2115 020640
   2119 020726      2125 020727      2130 020735      2132 020742      2133 020744      2134 020746      2135 020771
   2139 021014      2141 021021      2142 021023      2143 021025      2144 021036      2148 021061      2150 021066
   2153 021101      2155 021104      2159 021105      2162 021113      2164 021133      2165 021143      2167 021151
   2169 021152      2170 021166      2171 021172      2175 021175      2179 021176      2182 021177      2185 021203
   2186 021206      2187 021225      2190 021226      2191 021252      2195 021254      2199 021255      2204 021257
   2206 021262      2208 021266      2209 021270      2211 021271      2213 021274      2215 021300      2217 021323
   2219 021340      2221 021361      2224 021402      2226 021411      2228 021415      2229 021445      2231 021447
   2232 021450      2234 021451      2235 021463      2242 021467      2243 021470      2249 021471      2254 021473
   2256 021501      2258 021507      2259 021512      2262 021513      2263 021514      2269 021515      2274 021517
   2275 021522      2277 021525      2280 021533      2282 021556      2284 021565      2286 021574      2290 021605
   2291 021606      2297 021607      2302 021611      2304 021617      2310 021620      2316 021636      2317 021676
   2319 021706      2325 021714      2332 021725      2334 021733      2337 021745      2338 021751      2339 021765
   2341 021767      2344 022001      2345 022005      2346 022021      2348 022022      2349 022030      2351 022050
   2353 022056      2355 022121      2358 022125      2359 022151      2360 022152      2361 022153      2363 022155
   2364 022157      2367 022160      2368 022162      2370 022165      2371 022167      2376 022171      2380 022172
   2386 022174      2390 022200      2392 022237      2394 022271      2395 022301      2397 022321      2399 022327
   2401 022372      2404 022376      2405 022422      2406 022423      2407 022424      2409 022426      2410 022430
   2413 022431      2414 022433      2416 022436      2417 022440      2422 022442      2426 022443      2438 022445
   2439 022447      2442 022450      2443 022463      2444 022474      2447 022503      2448 022504      2450 022511
   2451 022513      2453 022515      2454 022517      2456 022521      2458 022530      2459 022531      2460 022542
   2461 022545      2462 022547      2463 022550      2467 022562      2468 022570      2469 022572      2470 022575
   2471 022601      2473 022605      2479 022611      2485 022613      2489 022622      2490 022626      2491 022632
   2492 022635      2493 022637      2494 022656      2497 022660


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
