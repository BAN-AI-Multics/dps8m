	COMPILATION LISTING OF SEGMENT log_wakeup_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1025.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-12-20,EJSharpe), approve(86-02-20,MCR7334),
       13*     audit(86-02-26,Kissel), install(86-04-23,MR12.0-1044):
       14*     set bootload time, ignore duplicate entries
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 /* format: off */
       19 
       20 log_wakeup_:
       21      procedure ();
       22 
       23 /* *	LOG_WAKEUP_
       24*   *
       25*   *	This procedure manages the sending of wakeups when messages are
       26*   *	placed in a log. There is a table of listening processes in the
       27*   *	header of each log segment, and these processes are all sent
       28*   *	wakeups when this procedure is called. The table of processes
       29*   *	is limited in size; there may only be 25 (or some such small
       30*   *	number (see log_segment_info.incl.pl1 for the exact count) processes
       31*   *	listening at a time, but this hardly seems like an unreasonable
       32*   *	limitation.
       33*   *
       34*   *	If a process is found to have expired when an attempt is made
       35*   *	to awaken it, it is automatically removed from the list.
       36*   *	Entries in the list are made by STACQ'ing process IDs into
       37*   *	apparently empty slots, making the mechanism lockless.
       38*   *
       39*   *	This program assumes that the segment it is adding entries to
       40*   *	is the one currently in use for writing.  It checks the in_service
       41*   *	flag explicitly when registering and de-registering listeners,
       42*   *	but NOT when sending wakeups, the assumption being that if a
       43*   *	message was added to the segment, the processes listed in that
       44*   *	segment should be the ones notified.
       45*   *
       46*   *	Written 84-05-04, W. Olin Sibert
       47*   */
       48 
       49 declare	P_log_segment_ptr pointer parameter;
       50 declare	P_log_message_ptr pointer parameter;
       51 declare	P_process_id bit (36) aligned parameter;
       52 declare	P_event_channel fixed bin (71) parameter;
       53 declare	P_code fixed bin (35) parameter;
       54 
       55 declare	code fixed bin (35);
       56 
       57 declare	error_table_$itt_overflow fixed bin (35) external static;
       58 declare	error_table_$log_out_of_service fixed bin (35) external static;
       59 declare	error_table_$log_segment_damaged fixed bin (35) external static;
       60 declare	error_table_$log_wakeup_table_full fixed bin (35) external static;
       61 declare	error_table_$wakeup_denied fixed bin (35) external static;
       62 
       63 declare	sys_info$time_of_bootload fixed bin (71) external static;
       64 
       65 declare	get_ring_ entry () returns (fixed bin (3));
       66 declare	hcs_$validate_processid entry (bit (36) aligned, fixed bin (35));
       67 declare	hcs_$wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       68 declare	log_segment_$get_service_bit entry (pointer, bit (1) aligned, fixed bin (35));
       69 declare	pxss$ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       70 declare	tc_util$validate_processid entry (bit (36) aligned, fixed bin (35));
       71 
       72 declare	PROCESS_ID_FLAG bit (36) aligned internal static options (constant) init ("400000000000"b3);
       73 declare	PROCESS_ID_MASK bit (36) aligned internal static options (constant) init ("377777777777"b3);
       74 
       75 declare  (binary, bit, hbound, rel, stacq, substr, unspec) builtin;
       76 
       77 /* */
       78 
       79 finished:						/* All-purpose exitl we always leave through here */
       80      procedure (P_status_code);
       81 
       82 declare	P_status_code fixed bin (35) parameter;
       83 
       84 
       85 	P_code = P_status_code;
       86 	goto MAIN_RETURN;
       87 
       88 	end finished;
       89 
       90 
       91 
       92 MAIN_RETURN:					/* This is the only return statement in the main procedure */
       93 	return;
       94 
       95 
       96 
       97 log_wakeup_$send_wakeups:
       98      entry (P_log_segment_ptr, P_log_message_ptr, P_code);
       99 
      100 	call copy_log_segment_ptr ();			/* DON'T call check_in_service for this; the caller has */
      101 	call send_wakeups ();			/* (presumably) already dealt with that possibility */
      102 	call finished (0);
      103 
      104 /* */
      105 
      106 log_wakeup_$register:
      107      entry (P_log_segment_ptr, P_process_id, P_event_channel, P_code);
      108 
      109 	call copy_log_segment_ptr ();
      110 	call check_in_service ();
      111 	call register_listener ();
      112 	call check_in_service ();
      113 	call finished (0);
      114 
      115 
      116 
      117 log_wakeup_$deregister:
      118      entry (P_log_segment_ptr, P_process_id, P_event_channel, P_code);
      119 
      120 	call copy_log_segment_ptr ();
      121 	call check_in_service ();
      122 	call deregister_listener ();
      123 	call check_in_service ();
      124 	call finished (0);
      125 
      126 
      127 
      128 log_wakeup_$discard_all:
      129      entry (P_log_segment_ptr, P_code);
      130 
      131 	call copy_log_segment_ptr ();
      132 	call check_in_service ();
      133 	call clear_listener_info ();
      134 	call check_in_service ();
      135 	call finished (0);
      136 
      137 /* */
      138 send_wakeups:
      139      procedure ();
      140 
      141 /* This procedure delivers the wakeups to every listening process. If a process
      142*   turns out to be defunct, it is removed from the list, but no error is indicated
      143*   to anyone. */
      144 
      145 declare	slot_idx fixed bin;
      146 declare	process_id bit (36) aligned;
      147 declare	event_channel fixed bin (71);
      148 declare	ring_zero bit (1) aligned;
      149 declare	event_message fixed bin (71);
      150 
      151 
      152 	if ^log_segment.listeners_registered then		/* A flag kept for efficiency reasons */
      153 	     return;
      154 
      155 	log_message_ptr = P_log_message_ptr;	/* Parameter imported from external procedure */
      156 	unspec (event_message) = bit (binary (log_message.sequence, 36)) || "000000"b3 || rel (log_message_ptr);
      157 						/* Message is sequence number and location */
      158 	ring_zero = (get_ring_ () = 0);		/* If we can, call pxss directly */
      159 
      160 	do slot_idx = 1 to hbound (log_segment.listener, 1);
      161 	     process_id = log_segment.listener.process_id (slot_idx);
      162 	     event_channel = log_segment.listener.event_channel (slot_idx);
      163 	     if (process_id = ""b) then		/* See that somebody's there, and that the slot is */
      164 		goto WAKEUP_NEXT_CUSTOMER;		/* properly filled in (filling flag is off) */
      165 	     if (substr (process_id, 1, 1)) then
      166 		goto WAKEUP_NEXT_CUSTOMER;
      167 
      168 	     if ring_zero then
      169 		call pxss$ring_0_wakeup (process_id, event_channel, event_message, code);
      170 	     else call hcs_$wakeup (process_id, event_channel, event_message, code);
      171 
      172 	     if (code = 0) then ;			/* Success, or some error codes, leave the target there */
      173 	     else if (code = error_table_$itt_overflow) then ; /* for others to try awakening. */
      174 	     else if (code = error_table_$wakeup_denied) then ; /* Remaining codes (indicating failure) are: */
      175 	     else call clear_slot (slot_idx);		/* process_stopped, process_unknown, bad_arg */
      176 
      177 WAKEUP_NEXT_CUSTOMER:
      178 	     end;
      179 
      180 	return;
      181 	end send_wakeups;
      182 
      183 /* */
      184 
      185 register_listener:
      186      procedure ();
      187 
      188 
      189 	if (try_to_register ()) then			/* Try it outright the first time. */
      190 	     return;				/* Just return if it works */
      191 
      192 	call reclaim_dead_listeners ();		/* If that fails, pick out any losers and try again */
      193 
      194 	if (try_to_register ()) then			/* If it works a second time, we must have picked */
      195 	     return;				/* up after some deaders */
      196 
      197 	call finished (error_table_$log_wakeup_table_full);    /* Otherwise, give up (do a goto out of here) */
      198 
      199 	end register_listener;
      200 
      201 /* */
      202 
      203 try_to_register:
      204      procedure () returns (bit (1) aligned);
      205 
      206 declare	event_channel fixed bin (71);
      207 declare	process_id bit (36) aligned;
      208 declare	flagged_process_id bit (36) aligned;
      209 declare	slot_idx fixed bin;
      210 declare	ignore_bit bit (1) aligned;
      211 
      212 
      213 /* This procedure returns "1"b if it successfully registered a process, and
      214*   "0"b if it finds the table is full.	The algorithm works as follows:
      215*
      216*   The process table is searched for a presently empty slot (process_id is
      217*   zero when empty). Once one is found, the target process_id is installed,
      218*   but with the upper bit set to tell the wakeup procedure, ignore this
      219*   entry until it's properly filled in. Once it's properly filled in, that
      220*   upper bit is turned off.
      221*   */
      222 
      223 	process_id = P_process_id;			/* P_process_id and P_event_channel parameters are */
      224 	event_channel = P_event_channel;		/* imported from the external procedure */
      225 	flagged_process_id = process_id | PROCESS_ID_FLAG;
      226 
      227 	log_segment.listeners_registered = "1"b;		/* Flag it as having listeners (flag is for efficiency) */
      228 
      229 RETRY_REGISTER:
      230 	do slot_idx = 1 to hbound (log_segment.listener, 1);
      231 	     if (log_segment.listener.process_id (slot_idx) = process_id) then
      232 		if (log_segment.listener.event_channel (slot_idx) = event_channel) then
      233 		     return ("1"b);			/* procID/ev_chn should only appear once */
      234 
      235 	     if (log_segment.listener.process_id (slot_idx) = ""b) then do; /* A candidate */
      236 		if ^stacq (log_segment.listener.process_id (slot_idx), flagged_process_id, ""b) then
      237 		     goto RETRY_REGISTER;		/* But someone else got him first */
      238 
      239 		log_segment.listener.event_channel (slot_idx) = event_channel;
      240 
      241 		ignore_bit = stacq (log_segment.listener.process_id (slot_idx), process_id, flagged_process_id);
      242 		return ("1"b);			/* Flag it as valid, and return, successful */
      243 		end;
      244 	     end;
      245 
      246 	return ("0"b);
      247 
      248 	end try_to_register;
      249 
      250 /* */
      251 
      252 reclaim_dead_listeners:
      253      procedure ();
      254 
      255 declare	slot_idx fixed bin;
      256 declare	process_id bit (36) aligned;
      257 declare	ring_zero bit (1) aligned;
      258 
      259 /* This procedure attempts to reclaim slots in use by expired processes.
      260*   It just goes through and checks all the process-ids in the slots, reclaiming
      261*   dead ones. It is only used when a new listener is being added and there are
      262*   no slots already available; normally, dead processes will be detected in the
      263*   course of sending wakeups, and their slots reclaimed automatically. */
      264 
      265 /* Note that listeners from the previous bootload (by definition dead) have
      266*   already been "reclaimed" by the check in copy_log_segment_ptr, which cleans
      267*   them all out the first time it runs in a different bootload. */
      268 
      269 
      270 	ring_zero = (get_ring_ () = 0);
      271 
      272 	do slot_idx = 1 to hbound (log_segment.listener, 1);
      273 	     process_id = log_segment.listener.process_id (slot_idx) & PROCESS_ID_MASK;
      274 	     if (process_id ^= ""b) then do;		/* A possibly valid process-id is here */
      275 		if ring_zero then
      276 		     call tc_util$validate_processid (process_id, code);
      277 		else call hcs_$validate_processid (process_id, code);
      278 
      279 		if (code ^= 0) then			/* Not one of ours, Jack */
      280 		     call clear_slot (slot_idx);
      281 		end;
      282 	     end;
      283 
      284 	return;
      285 	end reclaim_dead_listeners;
      286 
      287 /* */
      288 
      289 deregister_listener:
      290      procedure ();
      291 
      292 declare	slot_idx fixed bin;
      293 declare	process_id bit (36) aligned;
      294 declare	test_process_id bit (36) aligned;
      295 declare	event_channel fixed bin (71);
      296 
      297 
      298 	process_id = P_process_id;			/* P_process_id and P_event_channel parameters are */
      299 	event_channel = P_event_channel;		/* imported from the external procedure */
      300 
      301 	do slot_idx = 1 to hbound (log_segment.listener, 1);
      302 	     test_process_id = log_segment.listener.process_id (slot_idx) & PROCESS_ID_MASK;
      303 	     if (process_id = test_process_id) then
      304 		if (log_segment.listener.event_channel (slot_idx) = event_channel) then
      305 		     call clear_slot (slot_idx);
      306 	     end;
      307 
      308 	return;
      309 	end deregister_listener;
      310 
      311 /* */
      312 
      313 clear_slot:
      314      procedure (P_slot_idx);
      315 
      316 declare	P_slot_idx fixed bin parameter;
      317 
      318 declare	process_id bit (36) aligned;
      319 
      320 
      321 /* Shouldn't need this silly loop, but may as well have it anyway */
      322 
      323 	process_id = log_segment.listener.process_id (P_slot_idx);
      324 	do while (^stacq (log_segment.listener.process_id (P_slot_idx), ""b, process_id));
      325 	     process_id = log_segment.listener.process_id (P_slot_idx);
      326 	     end;
      327 
      328 	return;
      329 	end clear_slot;
      330 
      331 
      332 
      333 clear_listener_info:
      334      procedure ();
      335 
      336 /* This procedure clears out all the wakeup info in the log, wholesale */
      337 
      338 	log_segment.listeners_registered = "0"b;		/* Turn off wakeups first */
      339 
      340 	unspec (log_segment.listener) = ""b;		/* Then just clear them all out */
      341 
      342 	log_segment.listener_bootload_time = sys_info$time_of_bootload;
      343 						/* and set the bootload time */
      344 
      345 	return;
      346 	end clear_listener_info;
      347 
      348 /* */
      349 
      350 copy_log_segment_ptr:
      351      procedure ();
      352 
      353 	log_segment_ptr = P_log_segment_ptr;
      354 
      355 	if (log_segment.version ^= LOG_SEGMENT_VERSION_1) then
      356 	     call finished (error_table_$log_segment_damaged);
      357 
      358 /* NOTE: This check for listeners belonging to the current bootload imposes the
      359*   requirement that a process calling ANY log_wakeup_ entrypoint must have write
      360*   access to the log segment, because it might make this check and want to clear
      361*   out the old listener info.	 This is not an onerous requirement, because only
      362*   the wakeup entrypoint could conceivably work without write access, but it
      363*   is only called if the process has already just written a message (for which,
      364*   of course, write access was already required). */
      365 
      366 	if (log_segment.listener_bootload_time ^= sys_info$time_of_bootload) then /* bootload; if not, they're all */
      367 	     call clear_listener_info ();		/* dead, and we should dispose of them before doing anything */
      368 						/* else with the listener info. */
      369 	return;
      370 	end copy_log_segment_ptr;
      371 
      372 
      373 
      374 check_in_service:
      375      procedure ();
      376 
      377 declare	service_bit bit (1) aligned;
      378 
      379 
      380 	call log_segment_$get_service_bit (log_segment_ptr, service_bit, code);
      381 	if (code ^= 0) then
      382 	     call finished (code);
      383 	if ^service_bit then
      384 	     call finished (error_table_$log_out_of_service);
      385 
      386 	return;
      387 	end check_in_service;
      388 
      389  /* BEGIN INCLUDE FILE ... log_segment.incl.pl1 ... 84-05-03 ... W. Olin Sibert */
  1     2 
  1     3 declare   log_segment_ptr               pointer;
  1     4 declare   log_segment_max_size          fixed bin (18);
  1     5 declare   LOG_SEGMENT_VERSION_1         char (8) internal static options (constant) init ("SysLog01");
  1     6 
  1     7 
  1     8 declare 1 log_segment                   aligned based (log_segment_ptr),
  1     9           2 header                      aligned like log_segment_header,
  1    10           2 data                        dim (log_segment_max_size refer (log_segment.max_size)) bit (36) aligned;
  1    11 
  1    12 
  1    13 declare 1 log_segment_header            aligned based,
  1    14           2 version                     char (8) unaligned, /* LOG_SEGMENT_VERSION_1 */
  1    15           2 time_created                fixed bin (71),     /* When the segment header was initialized */
  1    16           2 previous_log_dir            char (168) unaligned, /* Directory containing previous log segment */
  1    17 
  1    18           2 limits,
  1    19             3 first_sequence            fixed bin (35),     /* First and last sequence numbers / time stamps */
  1    20             3 last_sequence             fixed bin (35),     /* of messages in the log. These may be slightly */
  1    21             3 first_time                fixed bin (71),     /* incorrect due to lockless updating strategy */
  1    22             3 last_time                 fixed bin (71),
  1    23 
  1    24           2 alloc_info,                                     /* Complex STACQ hack for allocating and assigning */
  1    25             3 word_1                    fixed bin (18),     /* sequence numbers locklessly. See log_segment_ */
  1    26             3 word_2                    bit (36) aligned,   /* for details of strategy */
  1    27           2 max_size                    fixed bin (18),     /* Total words in data area */
  1    28 
  1    29           2 listeners_registered        bit (1) aligned,    /* Set if ANY processes were ever registered-- it's only */
  1    30           2 listener_bootload_time      fixed bin (71),     /* kept here for efficiency. The bootload time is used to */
  1    31                                                             /* detect all the dead listeners after a reboot */
  1    32           2 listener (25),                                  /* Processes waiting for messages in the log */
  1    33             3 process_id                bit (36) aligned,
  1    34             3 event_channel             fixed bin (71) unaligned, /* Saves space-- allows 3-word entries */
  1    35 
  1    36           2 last_wakeup_time            fixed bin (71),     /* When last wakeup was sent */
  1    37           2 wakeup_delta                fixed bin (71),     /* Wakeups sent no more than once per this interval */
  1    38 
  1    39           2 pad (6)                     fixed bin (71);     /* Pad header to 150 words */
  1    40 
  1    41 
  1    42 declare   LOG_SEGMENT_NEW_MESSAGE           init ("777111555333"b3) bit (36) aligned internal static options (constant);
  1    43 declare   LOG_SEGMENT_COMPLETE_MESSAGE      init ("666000444222"b3) bit (36) aligned internal static options (constant);
  1    44 
  1    45 /* END INCLUDE FILE ... log_segment.incl.pl1 */
      389 
      390  /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  2     2 
  2     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  2     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  2     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  2     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  2     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  2     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  2     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  2    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  2    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  2    12 
  2    13 declare 1 log_message         aligned based (log_message_ptr),
  2    14           2 header            aligned like log_message_header,
  2    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  2    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  2    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  2    18 
  2    19 declare   log_message_ptr pointer;
  2    20 declare   log_message_text_lth fixed bin;
  2    21 declare   log_message_data_class_lth fixed bin;
  2    22 declare   log_message_data_lth fixed bin;
  2    23 
  2    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      390 
      391 
      392 	end log_wakeup_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.9  log_wakeup_.pl1                   >spec>install>1111>log_wakeup_.pl1
389          1    12/04/84  2124.9  log_segment.incl.pl1              >ldd>include>log_segment.incl.pl1
390          2    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LOG_SEGMENT_VERSION_1           000000 constant        char(8)                  initial packed unaligned dcl 1-5 ref 355
PROCESS_ID_FLAG                        constant        bit(36)                  initial dcl 72 ref 225
PROCESS_ID_MASK                 000002 constant        bit(36)                  initial dcl 73 ref 273 302
P_code                                 parameter       fixed bin(35,0)          dcl 53 set ref 85* 97 106 117 128
P_event_channel                        parameter       fixed bin(71,0)          dcl 52 ref 106 117 224 299
P_log_message_ptr                      parameter       pointer                  dcl 50 ref 97 155
P_log_segment_ptr                      parameter       pointer                  dcl 49 ref 97 106 117 128 353
P_process_id                           parameter       bit(36)                  dcl 51 ref 106 117 223 298
P_slot_idx                             parameter       fixed bin(17,0)          dcl 316 ref 313 323 324 325
P_status_code                          parameter       fixed bin(35,0)          dcl 82 ref 79 85
binary                                                 builtin function         dcl 75 ref 156
bit                                                    builtin function         dcl 75 ref 156
code                            000100 automatic       fixed bin(35,0)          dcl 55 set ref 168* 170* 172 173 174 275* 277* 279
                                                                                  380* 381 381*
error_table_$itt_overflow       000010 external static fixed bin(35,0)          dcl 57 ref 173
error_table_$log_out_of_service 000012 external static fixed bin(35,0)          dcl 58 set ref 383*
error_table_$log_segment_damaged
                                000014 external static fixed bin(35,0)          dcl 59 set ref 355*
error_table_$log_wakeup_table_full
                                000016 external static fixed bin(35,0)          dcl 60 set ref 197*
error_table_$wakeup_denied      000020 external static fixed bin(35,0)          dcl 61 ref 174
event_channel                   000202 automatic       fixed bin(71,0)          dcl 295 in procedure "deregister_listener" set ref
                                                                                  299* 303
event_channel                   000150 automatic       fixed bin(71,0)          dcl 206 in procedure "try_to_register" set ref 224*
                                                                                  231 239
event_channel            73            based           fixed bin(71,0)          array level 4 in structure "log_segment" packed
                                                                                  packed unaligned dcl 1-8 in procedure
                                                                                  "log_wakeup_" set ref 162 231 239* 303
event_channel                   000126 automatic       fixed bin(71,0)          dcl 147 in procedure "send_wakeups" set ref 162*
                                                                                  168* 170*
event_message                   000132 automatic       fixed bin(71,0)          dcl 149 set ref 156* 168* 170*
flagged_process_id              000153 automatic       bit(36)                  dcl 208 set ref 225* 236 241
get_ring_                       000024 constant        entry                    external dcl 65 ref 158 270
hbound                                                 builtin function         dcl 75 ref 160 229 272 301
hcs_$validate_processid         000026 constant        entry                    external dcl 66 ref 277
hcs_$wakeup                     000030 constant        entry                    external dcl 67 ref 170
header                                 based           structure                level 2 in structure "log_message" dcl 2-13
                                                                                  in procedure "log_wakeup_"
header                                 based           structure                level 2 in structure "log_segment" dcl 1-8
                                                                                  in procedure "log_wakeup_"
ignore_bit                      000155 automatic       bit(1)                   dcl 210 set ref 241*
listener                 72            based           structure                array level 3 dcl 1-8 set ref 160 229 272 301 340*
listener_bootload_time
                         70            based           fixed bin(71,0)          level 3 dcl 1-8 set ref 342* 366
listeners_registered     67            based           bit(1)                   level 3 dcl 1-8 set ref 152 227* 338*
log_message                            based           structure                level 1 dcl 2-13
log_message_header                     based           structure                level 1 dcl 2-3
log_message_ptr                 000104 automatic       pointer                  dcl 2-19 set ref 155* 156 156
log_segment                            based           structure                level 1 dcl 1-8
log_segment_$get_service_bit    000032 constant        entry                    external dcl 68 ref 380
log_segment_header                     based           structure                level 1 dcl 1-13
log_segment_ptr                 000102 automatic       pointer                  dcl 1-3 set ref 152 160 161 162 227 229 231 231 235
                                                                                  236 239 241 272 273 301 302 303 323 324 325 338
                                                                                  340 342 353* 355 366 380*
process_id                      000125 automatic       bit(36)                  dcl 146 in procedure "send_wakeups" set ref 161* 163
                                                                                  165 168* 170*
process_id                      000177 automatic       bit(36)                  dcl 293 in procedure "deregister_listener" set ref
                                                                                  298* 303
process_id               72            based           bit(36)                  array level 4 in structure "log_segment" dcl 1-8
                                                                                  in procedure "log_wakeup_" set ref 161 231 235 236
                                                                                  241 273 302 323 324 325
process_id                      000212 automatic       bit(36)                  dcl 318 in procedure "clear_slot" set ref 323* 324
                                                                                  325*
process_id                      000152 automatic       bit(36)                  dcl 207 in procedure "try_to_register" set ref 223*
                                                                                  225 231 241
process_id                      000165 automatic       bit(36)                  dcl 256 in procedure "reclaim_dead_listeners" set
                                                                                  ref 273* 274 275* 277*
pxss$ring_0_wakeup              000034 constant        entry                    external dcl 69 ref 168
rel                                                    builtin function         dcl 75 ref 156
ring_zero                       000166 automatic       bit(1)                   dcl 257 in procedure "reclaim_dead_listeners" set
                                                                                  ref 270* 275
ring_zero                       000130 automatic       bit(1)                   dcl 148 in procedure "send_wakeups" set ref 158* 168
sequence                  1            based           fixed bin(35,0)          level 3 dcl 2-13 ref 156
service_bit                     000236 automatic       bit(1)                   dcl 377 set ref 380* 383
slot_idx                        000176 automatic       fixed bin(17,0)          dcl 292 in procedure "deregister_listener" set ref
                                                                                  301* 302 303 303*
slot_idx                        000154 automatic       fixed bin(17,0)          dcl 209 in procedure "try_to_register" set ref 229*
                                                                                  231 231 235 236 239 241*
slot_idx                        000124 automatic       fixed bin(17,0)          dcl 145 in procedure "send_wakeups" set ref 160* 161
                                                                                  162 175*
slot_idx                        000164 automatic       fixed bin(17,0)          dcl 255 in procedure "reclaim_dead_listeners" set
                                                                                  ref 272* 273 279*
stacq                                                  builtin function         dcl 75 ref 236 241 324
substr                                                 builtin function         dcl 75 ref 165
sys_info$time_of_bootload       000022 external static fixed bin(71,0)          dcl 63 ref 342 366
tc_util$validate_processid      000036 constant        entry                    external dcl 70 ref 275
test_process_id                 000200 automatic       bit(36)                  dcl 294 set ref 302* 303
unspec                                                 builtin function         dcl 75 set ref 156* 340*
version                                based           char(8)                  level 3 packed packed unaligned dcl 1-8 ref 355

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
LOG_SEGMENT_COMPLETE_MESSAGE           internal static bit(36)                  initial dcl 1-43
LOG_SEGMENT_NEW_MESSAGE                internal static bit(36)                  initial dcl 1-42
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 2-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 2-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 2-20
log_segment_max_size                   automatic       fixed bin(18,0)          dcl 1-4

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000020 constant        label                    dcl 92 ref 86
RETRY_REGISTER                  000343 constant        label                    dcl 229 ref 236
WAKEUP_NEXT_CUSTOMER            000275 constant        label                    dcl 177 ref 163 165
check_in_service                000630 constant        entry                    internal dcl 374 ref 110 112 121 123 132 134
clear_listener_info             000567 constant        entry                    internal dcl 333 ref 133 366
clear_slot                      000540 constant        entry                    internal dcl 313 ref 175 279 303
copy_log_segment_ptr            000601 constant        entry                    internal dcl 350 ref 100 109 120 131
deregister_listener             000503 constant        entry                    internal dcl 289 ref 122
finished                        000136 constant        entry                    internal dcl 79 ref 102 113 124 135 197 355 381 383
log_wakeup_                     000013 constant        entry                    external dcl 20
log_wakeup_$deregister          000072 constant        entry                    external dcl 117
log_wakeup_$discard_all         000116 constant        entry                    external dcl 128
log_wakeup_$register            000050 constant        entry                    external dcl 106
log_wakeup_$send_wakeups        000025 constant        entry                    external dcl 97
reclaim_dead_listeners          000421 constant        entry                    internal dcl 252 ref 192
register_listener               000300 constant        entry                    internal dcl 185 ref 111
send_wakeups                    000143 constant        entry                    internal dcl 138 ref 101
try_to_register                 000326 constant        entry                    internal dcl 203 ref 189 194

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1202        1242     714        1212
Length      1474     714        40         215     266           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
log_wakeup_                         214 external procedure  is an external procedure.  
finished                                internal procedure  shares stack frame of external procedure log_wakeup_.  
send_wakeups                            internal procedure  shares stack frame of external procedure log_wakeup_.  
register_listener                       internal procedure  shares stack frame of external procedure log_wakeup_.  
try_to_register                         internal procedure  shares stack frame of external procedure log_wakeup_.  
reclaim_dead_listeners                  internal procedure  shares stack frame of external procedure log_wakeup_.  
deregister_listener                     internal procedure  shares stack frame of external procedure log_wakeup_.  
clear_slot                              internal procedure  shares stack frame of external procedure log_wakeup_.  
clear_listener_info                     internal procedure  shares stack frame of external procedure log_wakeup_.  
copy_log_segment_ptr                    internal procedure  shares stack frame of external procedure log_wakeup_.  
check_in_service                        internal procedure  shares stack frame of external procedure log_wakeup_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
log_wakeup_              000100 code                        log_wakeup_
                         000102 log_segment_ptr             log_wakeup_
                         000104 log_message_ptr             log_wakeup_
                         000124 slot_idx                    send_wakeups
                         000125 process_id                  send_wakeups
                         000126 event_channel               send_wakeups
                         000130 ring_zero                   send_wakeups
                         000132 event_message               send_wakeups
                         000150 event_channel               try_to_register
                         000152 process_id                  try_to_register
                         000153 flagged_process_id          try_to_register
                         000154 slot_idx                    try_to_register
                         000155 ignore_bit                  try_to_register
                         000164 slot_idx                    reclaim_dead_listeners
                         000165 process_id                  reclaim_dead_listeners
                         000166 ring_zero                   reclaim_dead_listeners
                         000176 slot_idx                    deregister_listener
                         000177 process_id                  deregister_listener
                         000200 test_process_id             deregister_listener
                         000202 event_channel               deregister_listener
                         000212 process_id                  clear_slot
                         000236 service_bit                 check_in_service

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out        return_mac          ext_entry           stacq_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_ring_                     hcs_$validate_processid       hcs_$wakeup                   log_segment_$get_service_bit
pxss$ring_0_wakeup            tc_util$validate_processid

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$itt_overflow     error_table_$log_out_of_service
error_table_$log_segment_damaged                            error_table_$log_wakeup_table_full
error_table_$wakeup_denied    sys_info$time_of_bootload




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000012        92 000020        97 000021       100 000035       101 000036       102 000037       106 000042
    109 000060       110 000061       111 000062       112 000063       113 000064       117 000067       120 000102
    121 000103       122 000104       123 000105       124 000106       128 000111       131 000126       132 000127
    133 000130       134 000131       135 000132       392 000135        79 000136        85 000140        86 000142
    138 000143       152 000144       155 000150       156 000154       158 000170       160 000202       161 000207
    162 000213       163 000217       165 000221       168 000224       170 000244       172 000261       173 000264
    174 000270       175 000273       177 000275       180 000277       185 000300       189 000301       192 000307
    194 000310       197 000316       199 000325       203 000326       223 000330       224 000333       225 000335
    227 000340       229 000343       231 000351       235 000370       236 000373       239 000400       241 000403
    242 000410       244 000414       246 000416       252 000421       270 000422       272 000434       273 000441
    274 000446       275 000447       277 000463       279 000474       282 000500       284 000502       289 000503
    298 000504       299 000507       301 000511       302 000517       303 000524       306 000535       308 000537
    313 000540       323 000542       324 000547       325 000563       326 000565       328 000566       333 000567
    338 000570       340 000572       342 000575       345 000600       350 000601       353 000602       355 000606
    366 000621       369 000627       374 000630       380 000631       381 000644       383 000650       386 000662


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
