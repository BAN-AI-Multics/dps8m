	COMPILATION LISTING OF SEGMENT tape_mult_open_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-06-29_1715.46_Thu_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-10-13,GWMay), approve(86-10-13,MCR7552),
       17*     audit(86-10-13,Martinson), install(86-10-20,MR12.0-1189):
       18*     Added support for the use of rcp_ in  determining the density and format
       19*     type of a tape.  Changes mounted tape message to include the format type
       20*     and recording density of the mounted tape as determined by rcp_.
       21*  2) change(86-10-23,GWMay), approve(86-10-23,PBF7552),
       22*     audit(86-11-11,Martinson), install(86-11-21,MR12.0-1223):
       23*     History comment correction.   Please disregard the previous comment.  The
       24*     rcp_ density determining support was added to tape_mult_.pl1.  This module
       25*     was modified to remove the density determining read loop which was moved
       26*     to tape_mult_read_$label.  Howwever, the initial value returned by rcp_ is
       27*     assigned within this routine.
       28*                                                   END HISTORY COMMENTS */
       29 
       30 
       31 /* format: style4,delnl,insnl,ifthen */
       32 tape_mult_open_:
       33      procedure;
       34 
       35 /*	This program is part of the Multics standard tape I/O module, tape_mult_.
       36*   *
       37*   *	Created on 10/28/74 by Bill Silver.
       38*   *	Modified 4/79 by R.J.C. Kissel to handle 6250 bpi.
       39*   *	Modified 1/12/81 by J. A. Bush for bootable tape labels
       40*   *      Modified 8/82 by S. Krupp for change from tdcm_ to tape_ioi_ interface.
       41*   *	This program implements the iox_$open entry point.
       42**/
       43 
       44 
       45 /*			ARGUMENT  DATA	*/
       46 
       47 dcl  arg_error_code fixed bin (35),			/* (O) Standard error code. */
       48      arg_extend_flag bit (1),				/* (I) ON => extend file - illegal for tape_mult_ */
       49      arg_iocb_ptr ptr,				/* (I) Pointer to I/O control block. */
       50      arg_open_mode fixed bin;				/* (I) Index that => opening mode. */
       51 
       52 
       53 /*			AUTOMATIC  DATA	*/
       54 
       55 dcl  density fixed bin,				/* Density of tape: 800, 1600, or 6250. */
       56      error_code fixed bin (35),			/* Standard system error code. */
       57      iocb_ptr ptr,					/* Pointer to I/O control block. */
       58      open_mode fixed bin,				/* Index that => opening mode. */
       59      rdy_status bit (36) aligned,			/* Rdy status returned here. */
       60      tioi_id bit (36) aligned,			/* Id for this tape_ioi_ activation. */
       61      volid char (16);				/* Tape reel ID. */
       62 
       63 
       64 /*		INTERNAL STATIC DATA	*/
       65 
       66 dcl  stream_input_mode fixed bin init (1) internal static,
       67      stream_output_mode fixed bin init (2) internal static;
       68 
       69 
       70 /*		EXTERNAL  ENTRIES		*/
       71 
       72 dcl  (addr, null) builtin;
       73 
       74 dcl  (
       75      error_table_$bad_arg,
       76      error_table_$bad_mode
       77      ) external fixed bin (35);
       78 
       79 dcl  iox_$err_not_closed entry options (variable),
       80      iox_$propagate entry (ptr),
       81      tape_mult_close_$close entry options (variable),
       82      tape_mult_labeler_$read entry (ptr, char (*), fixed bin (35)),
       83      tape_mult_labeler_$write entry (ptr, fixed bin (35)),
       84      tape_mult_read_$get_chars entry options (variable),
       85      tape_mult_read_$position entry options (variable),
       86      tape_mult_write_$put_chars entry options (variable);
       87 
  1     1 /*	Begin  include file ... tmdb.incl.pl1
  1     2*   *
  1     3*   *	Created by  Bill Silver  on 10/20/74
  1     4*   *	Modified by J. A. Bush 12/30/80 for bootable tape labels
  1     5*   *	Modified by J. A. Bush 12/15/81 for re-write of read error recovery
  1     6*   *      Modified 8/82 by S.Krupp for change from tdcm_ to tape_ioi_
  1     7*   *	This include file describes the work variables used by the Multics standard
  1     8*   *	tape I/O module, tape_mult_.  This include file must be used with the include
  1     9*   *	file:  mstr.incl.pl1
  1    10**/
  1    11 
  1    12 
  1    13 /****^  HISTORY COMMENTS:
  1    14*  1) change(86-10-13,GWMay), approve(86-10-13,MCR7552),
  1    15*     audit(86-10-13,Martinson), install(86-10-20,MR12.0-1189):
  1    16*     added fields to the tmdb structure that will add support for the use of
  1    17*     rcp in determining the density and format of a tape.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  1    22 dcl	tmdb_ptr		   ptr;			/* Pointer to tape_mult_ data block. */
  1    23 
  1    24 dcl	1 tmdb		   based (tmdb_ptr) aligned,	/* tape_mult_ data block. */
  1    25 	  2 attach,				/* Attach description. */
  1    26 	    3 length	   fixed bin,		/* Actual length of attach description. */
  1    27 	    3 description	   char (64),		/* Attach description string. */
  1    28 	  2 open,					/* Open description. */
  1    29 	    3 length	   fixed bin,		/* Actual length of open description. */
  1    30 	    3 description	   char (32),		/* Open description string. */
  1    31 	  2 opt,					/* Attach options. */
  1    32 	    3 flags,				/* Flags set from user input and options. */
  1    33 	    ( 4 com_err	   bit (1),		/* ON => call com_err_ if there is an error. */
  1    34 	      4 ring	   bit (1),		/* ON => use writ ring,  OFF => no write ring. */
  1    35 	      4 system	   bit (1),		/* ON => user wants to be a system process. */
  1    36 	      4 err_tal	   bit (1),		/* ON => user wants error report */
  1    37 	      4 begin	   bit (1),		/* ON => begin processing tape */
  1    38 	      4 write_sw	   bit (1),		/* ON => write allowed */
  1    39 	      4 async_sw	   bit (1)		/* ON => user is prepared for errors to imply that previous put_chars failed. */
  1    40 	      )		   unaligned,		/* ON => user wants error tally displayed on closing */
  1    41 	    3 reel_name	   char (32) unal,		/* Tape reel slot ID. */
  1    42 	    3 volume_set_id	   char (32) unal,		/* volume set name */
  1    43 	    3 mount_mode	   char (7),		/* Mount mode: "writing" or "reading". */
  1    44 	    3 tracks	   fixed bin,		/* Either 9 or 7. */
  1    45 	    3 density	   fixed bin,		/* Either 1600 or 800. */
  1    46 	    3 tbpp	   ptr,			/* If not null, ptr to temp seg containing boot program */
  1    47 	    3 blp		   ptr,			/* Ptr to buffer containing boot label record (READ ONLY) */
  1    48 	    3 speed	   bit (36),		/* bits are 75, 125, 200 ips */
  1    49 	    3 comment	   char (64),		/* User comment to operator. */
  1    50 	  2 head		   like mstr_header,	/* Dummy tape record header. */
  1    51 	  2 trail		   like mstr_trailer,	/* Dummy tape record trailer. */
  1    52 	  2 work,					/* Work variables used. */
  1    53 	    3 flags,				/* Flags we need that aren't in head.flags. */
  1    54 	    ( 4 eod	   bit (1),		/* ON => end of good data. */
  1    55 	      4 eof	   bit (1),		/* ON => End of File. */
  1    56 	      4 bot	   bit (1),		/* ON => beginning of tape */
  1    57 	      4 retry_read	   bit (1),		/* ON => try reread recovery */
  1    58 	      4 read_fwd	   bit (1),		/* ON => want to read forward (recovery) */
  1    59                 4 fatal_read_error bit (1),                 /* ON => read error recovery failed. */
  1    60 	      4 data_loss  bit (1)			/* ON => read something, but with evidence that we lost something */
  1    61 	      )		   unaligned,
  1    62 	    3 rcp_id	   bit (36),		/* Id of current tape drive attachment */
  1    63 	    3 tioi_id	   bit (36),		/* Id of current tape_ioi_ activation */
  1    64 	    3 label_uid	   bit (72),		/* Unique ID of label record. */
  1    65 	    3 label_version	   fixed bin,		/* version of label, returned on read */
  1    66 	    3 output_mode	   fixed bin,		/* output mode tape was written with */
  1    67 	    3 buf_pos	   fixed bin,		/* Current position within current bufffer. */
  1    68 	    3 curr_buf	   ptr,			/* Current buffer being processed. */
  1    69 	    3 next_buf	   ptr,			/* Next buffer to be processed. */
  1    70 	    3 rec_length	   fixed bin (21),		/* Length of data record in characters. */
  1    71 	    3 n_full	   fixed bin,		/* Number of buffers ready to write. */
  1    72 	    3 n_recs_to_eof	   fixed bin,		/* Num recs to write pre eof mark. */
  1    73 	    3 n_bufs	   fixed bin,		/* Total number of buffers. */
  1    74 	    3 bufs_per_subset  fixed bin,		/* Number of buffers per subset. */
  1    75 	    3 buf_len	   fixed bin (21),		/* Length of a buffer. */
  1    76 	    3 buffer	   (8) ptr,		/* Pointers to a subset of I/O buffers. */
  1    77 	  2 meters,
  1    78 	    3 fwd_rd_recovery  fixed bin,
  1    79 	    3 reposition_recovery
  1    80 			   fixed bin,
  1    81             2 channels,
  1    82 	    3 rcp              fixed bin(71),		/* Regular, used by rcp. */
  1    83 	    3 ioi		   fixed bin(71),		/* Fast, used by ioi. */
  1    84 	  2 buffer	   (1040) fixed bin (35),	/* Work buffer (currently used for label I/O). */
  1    85 	  2 volume_density     fixed bin,                 /* either the input from -den or the value     */
  1    86 	    
  1    87 						/* returned by rcp_$check_attach in tape_info  */
  1    88             2 volume_format      char (16);		/* determined by rcp_		       */
  1    89 /*	End of include file ... tmdb.incl.pl1	*/
       88 
       89 
  2     1 
  2     2 /* Begin include file ...... mstr.incl.pl1 */
  2     3 /* Modified 2/11/74 by N. I. Morris */
  2     4 /* Modified 12/30/80 by J. A. Bush for bootable tape labels */
  2     5 /* Modified 12/14/82 by J. A. Bush to add version number to the record header */
  2     6 
  2     7 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  2     8 dcl	mstrp		   ptr;			/* pointer to MST record */
  2     9 
  2    10 dcl	1 mstr		   based (mstrp) aligned,	/* Multics standard tape mstr */
  2    11 	  2 head		   like mstr_header,	/* tape record header */
  2    12 	  2 data		   bit (36864 refer (mstr.head.data_bit_len)),
  2    13 						/* record body */
  2    14 	  2 trail		   like mstr_trailer;	/* record trailer */
  2    15 
  2    16 dcl	1 mst_label	   based (mstrp) aligned,	/* bootable label structure */
  2    17 	  2 xfer_vector	   (4),			/* bootload interrupt transfer vector */
  2    18 	    3 lda_instr	   bit (36),		/* this will be a "LDA 4" instruction */
  2    19 	    3 tra_instr	   bit (36),		/* a "TRA" instruction to start of boot pgm */
  2    20 	  2 head		   like mstr_header,	/* standard record header */
  2    21 	  2 vid		   like volume_identifier,	/* tape volume info */
  2    22 	  2 fv_overlay	   (0:31),		/* overlay for fault vectors  when tape booted */
  2    23 	    3 scu_instr	   bit (36),		/* an "SCU" instruction to address of fault_data */
  2    24 	    3 dis_instr	   bit (36),		/* a "DIS" instruction, with Y field = to its own addr */
  2    25 	  2 fault_data	   (8) bit (36),		/* SCU data for unexpected faults goes here */
  2    26 	  2 boot_pgm_path	   char (168) unaligned,	/* path name of boot program */
  2    27 	  2 userid	   char (32) unaligned,	/* Storage for Person.Project.Instance of creator of tape */
  2    28 	  2 label_version	   fixed bin,		/* defined by LABEL_VERSION constant below */
  2    29 	  2 output_mode	   fixed bin,		/* mode in which tape was written with */
  2    30 	  2 boot_pgm_len	   fixed bin,		/* length in words of boot program */
  2    31 	  2 copyright	   char (56),		/* Protection notice goes here if boot pgm is written */
  2    32 	  2 pad		   (13) bit (36),		/* pad out to 192 (300 octal) */
  2    33 	  2 boot_pgm	   (0 refer (mst_label.boot_pgm_len)) bit (36),
  2    34 						/* boot program */
  2    35 	  2 trail		   like mstr_trailer;	/* standard record trailer */
  2    36 
  2    37 dcl	1 mstr_header	   based aligned,		/* Multics standard tape record header */
  2    38 	( 2 c1		   bit (36),		/* constant = 670314355245(8) */
  2    39 	  2 uid		   bit (72),		/* unique ID */
  2    40 	  2 rec_within_file	   fixed bin (17),		/* phys. rec. # within phys. file */
  2    41 	  2 phy_file	   fixed bin (17),		/* phys. file # on phys. tape */
  2    42 	  2 data_bits_used	   fixed bin (17),		/* # of bits of data in record */
  2    43 	  2 data_bit_len	   fixed bin (17),		/* bit length of data space */
  2    44 	  2 flags,				/* record flags */
  2    45 	    3 admin	   bit (1),		/* admin record flag */
  2    46 	    3 label	   bit (1),		/* label record flag */
  2    47 	    3 eor		   bit (1),		/* end-of-reel record flag */
  2    48 	    3 pad1	   bit (11),
  2    49 	    3 set		   bit (1),		/* ON if any of following items set */
  2    50 	    3 repeat	   bit (1),		/* repeated record flag */
  2    51 	    3 padded	   bit (1),		/* record contains padding flag */
  2    52 	    3 eot		   bit (1),		/* EOT reflector encountered flag */
  2    53 	    3 drain	   bit (1),		/* synchronous write flag */
  2    54 	    3 continue	   bit (1),		/* continue on next reel flag */
  2    55 	    3 pad2	   bit (4),
  2    56 	  2 header_version	   fixed bin (3) unsigned,	/* current header version number */
  2    57 	  2 repeat_count	   fixed bin (8),		/* repetition count */
  2    58 	  2 checksum	   bit (36),		/* checksum of header and trailer */
  2    59 	  2 c2		   bit (36)
  2    60 	  )		   unal;			/* constant = 512556146073(8) */
  2    61 
  2    62 dcl	1 mstr_trailer	   based aligned,		/* Multics standard tape record trailer */
  2    63 	( 2 c1		   bit (36),		/* constant = 107463422532(8) */
  2    64 	  2 uid		   bit (72),		/* unique ID (matches header) */
  2    65 	  2 tot_data_bits	   fixed bin (35),		/* total data bits written on logical tape */
  2    66 	  2 pad_pattern	   bit (36),		/* padding pattern */
  2    67 	  2 reel_num	   fixed bin (11),		/* reel sequence # */
  2    68 	  2 tot_file	   fixed bin (23),		/* phys. file number */
  2    69 	  2 tot_rec	   fixed bin (35),		/* phys. record # for logical tape */
  2    70 	  2 c2		   bit (36)
  2    71 	  )		   unal;			/* constant = 265221631704(8) */
  2    72 
  2    73 dcl	1 volume_identifier	   based aligned,		/* tape volume info */
  2    74 	( 2 installation_id	   char (32),		/* installation that created tape */
  2    75 	  2 tape_reel_id	   char (32),		/* tape reel name */
  2    76 	  2 volume_set_id	   char (32)
  2    77 	  )		   unaligned;		/* name of the volume set */
  2    78 
  2    79 dcl	(
  2    80 	header_c1		   init ("670314355245"b3),
  2    81 	header_c2		   init ("512556146073"b3),
  2    82 	trailer_c1	   init ("107463422532"b3),
  2    83 	trailer_c2	   init ("265221631704"b3),
  2    84 	label_c1		   init ("000004235000"b3)
  2    85 	)		   bit (36) static;
  2    86 
  2    87 dcl	LABEL_VERSION	   fixed bin static options (constant) init (3);
  2    88 						/* current label version */
  2    89 dcl	HEADER_VERSION	   fixed bin static options (constant) init (1);
  2    90 						/* current header version */
  2    91 
  2    92 /* End of include file ...... mstr.incl.pl1 */
  2    93 
       90 
       91 
  3     1 /*  START OF:	tape_ioi_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Written 22 April 1982 by Chris Jones */
  3     4 /* Modified September 1983 by Chris Jones for reserve_buffer and release_buffer */
  3     5 /* format: style4,delnl,insnl,indattr,ifthen,declareind10,dclind10 */
  3     6 
  3     7 /* call   tape_ioi_$activate     (rsc_ptr, tioi_info_ptr, tioi_id, code); */
  3     8 dcl	tape_ioi_$activate	   entry (ptr, ptr, bit (36) aligned, fixed bin (35));
  3     9 
  3    10 /* call   tape_ioi_$allocate_buffers (tioi_id, req_length, req_number, act_length, act_number, buffer_ptrs, code); */
  3    11 dcl	tape_ioi_$allocate_buffers
  3    12 			   entry (bit (36) aligned, fixed bin (21), fixed bin, fixed bin (21), fixed bin,
  3    13 			   dim (*) ptr, fixed bin (35));
  3    14 
  3    15 /* call   tape_ioi_$allocate_work_area (tioi_id, req_size, act_size, work_area_ptr, code); */
  3    16 dcl	tape_ioi_$allocate_work_area
  3    17 			   entry (bit (36) aligned, fixed bin (19), fixed bin (19), ptr, fixed bin (35));
  3    18 
  3    19 /* call   tape_ioi_$buffer_status (tioi_id, buffer_ptr, tbs_ptr, code); */
  3    20 dcl	tape_ioi_$buffer_status
  3    21 			   entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  3    22 
  3    23 /* call   tape_ioi_$check_order  (tioi_id, ocount, rx, code); */
  3    24 dcl	tape_ioi_$check_order  entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
  3    25 
  3    26 /* call   tape_ioi_$check_read   (tioi_id, buffer_ptr, data_len, rx, code); */
  3    27 dcl	tape_ioi_$check_read   entry (bit (36) aligned, ptr, fixed bin (21), fixed bin, fixed bin (35));
  3    28 
  3    29 /* call   tape_ioi_$check_write  (tioi_id, buffer_ptr, rx, code); */
  3    30 dcl	tape_ioi_$check_write  entry (bit (36) aligned, ptr, fixed bin, fixed bin (35));
  3    31 
  3    32 /* call   tape_ioi_$deactivate   (tioi_id, error_ptr, code); */
  3    33 dcl	tape_ioi_$deactivate   entry (bit (36) aligned, ptr, fixed bin (35));
  3    34 
  3    35 /* call   tape_ioi_$deallocate   (tioi_id, code); */
  3    36 dcl	tape_ioi_$deallocate   entry (bit (36) aligned, fixed bin (35));
  3    37 
  3    38 /* call   tape_ioi_$deallocate_buffers   (tioi_id, code); */
  3    39 dcl	tape_ioi_$deallocate_buffers
  3    40 			   entry (bit (36) aligned, fixed bin (35));
  3    41 
  3    42 /* call   tape_ioi_$get_mode     (tioi_id, mode, data_ptr, code); */
  3    43 dcl	tape_ioi_$get_mode	   entry (bit (36) aligned, char (*), ptr, fixed bin (35));
  3    44 
  3    45 /* call	tape_ioi_$get_statistics (tioi_id, tec_ptr, code); */
  3    46 dcl	tape_ioi_$get_statistics
  3    47 			   entry (bit (36) aligned, ptr, fixed bin (35));
  3    48 
  3    49 /* call   tape_ioi_$hardware_status (tioi_id, ths_ptr, code); */
  3    50 dcl	tape_ioi_$hardware_status
  3    51 			   entry (bit (36) aligned, ptr, fixed bin (35));
  3    52 
  3    53 /* call   tape_ioi_$list_buffers (tioi_id, state, buffer_ptrs, num_buffers, code); */
  3    54 dcl	tape_ioi_$list_buffers entry (bit (36) aligned, fixed bin, dim (*) ptr, fixed bin, fixed bin (35));
  3    55 
  3    56 /* call   tape_ioi_$order        (tioi_id, order, count, data_ptr, ocount, rx, code); */
  3    57 dcl	tape_ioi_$order	   entry (bit (36) aligned, char (4), fixed bin, ptr, fixed bin, fixed bin, fixed bin (35));
  3    58 
  3    59 /* call   tape_ioi_$queue_order  (tioi_id, order, count, data_ptr, code); */
  3    60 dcl	tape_ioi_$queue_order  entry (bit (36) aligned, char (4), fixed bin, ptr, fixed bin (35));
  3    61 
  3    62 /* call   tape_ioi_$queue_read   (tioi_id, buffer_ptr, code); */
  3    63 dcl	tape_ioi_$queue_read   entry (bit (36) aligned, ptr, fixed bin (35));
  3    64 
  3    65 /* call   tape_ioi_$queue_write  (tioi_id, buffer_ptr, data_len, code); */
  3    66 dcl	tape_ioi_$queue_write  entry (bit (36) aligned, ptr, fixed bin (21), fixed bin (35));
  3    67 
  3    68 /* call   tape_ioi_$read         (tioi_id, buffer_ptr, data_len, rx, code); */
  3    69 dcl	tape_ioi_$read	   entry (bit (36) aligned, ptr, fixed bin (21), fixed bin, fixed bin (35));
  3    70 
  3    71 /* call	tape_ioi_$release_buffer (tioi_id, buffer_ptr, code); */
  3    72 dcl	tape_ioi_$release_buffer
  3    73 			   entry (bit (36) aligned, ptr, fixed bin (35));
  3    74 
  3    75 /* call	tape_ioi_$reserve_buffer (tioi_id, buffer_ptr, code); */
  3    76 dcl	tape_ioi_$reserve_buffer
  3    77 			   entry (bit (36) aligned, ptr, fixed bin (35));
  3    78 
  3    79 /* call	tape_ioi_$reset_statistics (tioi_id, code); */
  3    80 dcl	tape_ioi_$reset_statistics
  3    81 			   entry (bit (36) aligned, fixed bin (35));
  3    82 
  3    83 /* call   tape_ioi_$set_buffer_ready (tioi_id, buffer_ptr, code); */
  3    84 dcl	tape_ioi_$set_buffer_ready
  3    85 			   entry (bit (36) aligned, ptr, fixed bin (35));
  3    86 
  3    87 /* call   tape_ioi_$set_mode     (tioi_id, mode, data_ptr, code); */
  3    88 dcl	tape_ioi_$set_mode	   entry (bit (36) aligned, char (*), ptr, fixed bin (35));
  3    89 
  3    90 /* call   tape_ioi_$stop_tape    (tioi_id, count, rx, code); */
  3    91 dcl	tape_ioi_$stop_tape	   entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
  3    92 
  3    93 /* call   tape_ioi_$write        (tioi_id, write_buffer_ptrs, data_len, buffer_ptr, rx, code); */
  3    94 dcl	tape_ioi_$write	   entry (bit (36) aligned, (*) ptr, fixed bin (21), ptr, fixed bin, fixed bin (35));
  3    95 
  3    96 /*  END OF:	tape_ioi_dcls.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       92 
       93 
  4     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  4     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  4     3*      version number to IOX2. */
  4     4 /* format: style2 */
  4     5 
  4     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  4     7 	     2 version	      character (4) aligned,	/* IOX2 */
  4     8 	     2 name	      char (32),		/* I/O name of this block. */
  4     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  4    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  4    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  4    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  4    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  4    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  4    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  4    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  4    17 						/* open(p,mode,not_used,s) */
  4    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  4    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  4    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  4    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  4    24 						/* put_chars(p,bufptr,buflen,s) */
  4    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  4    26 						/* modes(p,newmode,oldmode,s) */
  4    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  4    28 						/* position(p,u1,u2,s) */
  4    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  4    30 						/* control(p,order,infptr,s) */
  4    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  4    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  4    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  4    34 						/* write_record(p,bufptr,buflen,s) */
  4    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  4    36 						/* rewrite_record(p,bufptr,buflen,s) */
  4    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  4    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  4    39 						/* seek_key(p,key,len,s) */
  4    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  4    41 						/* read_key(p,key,len,s) */
  4    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  4    43 						/* read_length(p,len,s) */
  4    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  4    45 						/* open_file(p,mode,desc,not_used,s) */
  4    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  4    47 						/* close_file(p,desc,s) */
  4    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  4    49 						/* detach(p,desc,s) */
  4    50 
  4    51      declare iox_$iocb_version_sentinel
  4    52 			      character (4) aligned external static;
  4    53 
  4    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
       94 
       95 
       96 open:
       97      entry (arg_iocb_ptr, arg_open_mode, arg_extend_flag, arg_error_code);
       98 
       99 	iocb_ptr = arg_iocb_ptr;			/* Copy arguments. */
      100 	open_mode = arg_open_mode;
      101 
      102 	iocb_ptr = iocb_ptr -> iocb.actual_iocb_ptr;	/* Initialize pointers and work variables. */
      103 	tmdb_ptr = iocb_ptr -> iocb.attach_data_ptr;
      104 	tioi_id = tmdb.work.tioi_id;
      105 
      106 	tmdb.open.length = 18;			/* Set up default open mode. */
      107 	tmdb.open.description = "uninitialized_mode";
      108 
      109 	if arg_extend_flag				/* tape_mult_ does not support extend. */
      110 	then do;					/* We will not allow it to be specified. */
      111 	     error_code = error_table_$bad_arg;
      112 	     goto OPEN_ERROR;
      113 	end;
      114 
      115 	if open_mode = stream_input_mode		/* Are we opening for input or output? */
      116 	then do;					/* Input. */
      117 	     tmdb.open.length = 12;
      118 	     tmdb.open.description = "stream_input";
      119 	     goto SETUP_REEL;
      120 	end;
      121 
      122 	if open_mode = stream_output_mode		/* If not input it must be output. */
      123 	then do;
      124 	     if ^tmdb.opt.flags.ring			/* Is write ring in? */
      125 		then
      126 		goto BAD_MODE;			/* No, we must abort the open. */
      127 	     tmdb.open.length = 13;
      128 	     tmdb.open.description = "stream_output";
      129 	     goto SETUP_REEL;
      130 	end;
      131 
      132 BAD_MODE:						/* We cannot open with this mode. */
      133 	error_code = error_table_$bad_mode;
      134 	goto OPEN_ERROR;
      135 
      136 /*	Now we must get the tape reel ready for I/O processing.  We must set
      137*   *	the density and process the tape label.
      138**/
      139 SETUP_REEL:
      140 
      141 
      142 	if open_mode = stream_output_mode		/* Are we writing or reading? */
      143 	then do;					/* Writing. */
      144  	     density = tmdb.opt.density;		/* Get user specified density. */
      145 	     call REWIND (error_code);		/* rewind before setting density */
      146 	     if error_code ^= 0 then
      147 		goto OPEN_ERROR;
      148 	     call tape_ioi_$order (tioi_id, "den", 1, addr (density), (0), (0), error_code);
      149 	     if error_code ^= 0 then
      150 		goto OPEN_ERROR;
      151 	     tmdb.opt.write_sw = "1"b;
      152 	     call tape_mult_labeler_$write (tmdb_ptr, error_code);
      153 	end;
      154 	else do;					/* Reading. */
      155 	     density = tmdb.volume_density;		/* use rcp determined density */
      156 	     tmdb.opt.write_sw = "0"b;
      157 	     call tape_mult_labeler_$read (tmdb_ptr, volid, error_code);
      158 	end;
      159 	if error_code ^= 0 then
      160 	     goto OPEN_ERROR;
      161 
      162 /*	Now we must fill in the iocb.  It will be set up so an error will occur
      163*   *	if any attempt is made to open the switch again or to detach it before
      164*   *	it is closed.  Depending upon the opening mode we will set up the
      165*   *	put_chars or get_chars entry point.
      166**/
      167 	iocb_ptr -> iocb.open_descrip_ptr = addr (tmdb.open);
      168 	iocb_ptr -> iocb.open = iox_$err_not_closed;
      169 	iocb_ptr -> iocb.close = tape_mult_close_$close;
      170 	iocb_ptr -> iocb.detach_iocb = iox_$err_not_closed;
      171 
      172 /*	The I/O operations supported by tape_mult_ depends upon the opening mode.
      173*   *	     stream_input:
      174*   *		get_chars
      175*   *		position
      176*   *	     stream_output:
      177*   *		put_chars
      178*   *		control (error_count order)
      179**/
      180 	if open_mode = stream_output_mode		/* Set up I/O entry and tseg write switch. */
      181 	     then
      182 	     iocb_ptr -> iocb.put_chars = tape_mult_write_$put_chars;
      183 						/* Writing. */
      184 	else do;					/* Reading. */
      185 	     iocb_ptr -> iocb.get_chars = tape_mult_read_$get_chars;
      186 	     iocb_ptr -> iocb.position = tape_mult_read_$position;
      187 	end;
      188 
      189 	call iox_$propagate (iocb_ptr);
      190 
      191 	arg_error_code = 0;				/* Open completed successfully. */
      192 	return;
      193 
      194 OPEN_ERROR:					/* Fatal error during opening. */
      195 	arg_error_code = error_code;
      196 	return;
      197 
      198 REWIND:
      199      proc (code);
      200 
      201 /*        This procedure signals the tape rewind order and the waits until
      202*   *      the tape is actually rewound (device is ready for processing).
      203**/
      204 
      205 dcl  code fixed bin (35);
      206 
      207 	call tape_ioi_$order (tioi_id, "rdy", 1, addr (rdy_status), (0), (0), code);
      208 						/* Wait til device is ready. */
      209 	if code ^= 0 then
      210 	     return;
      211 	call tape_ioi_$order (tioi_id, "rew", 1, (null), (0), (0), code);
      212 						/* Rewind tape. */
      213 	if code ^= 0 then
      214 	     return;
      215 	call tape_ioi_$order (tioi_id, "rdy", 1, addr (rdy_status), (0), (0), code);
      216 						/* Wait til rewound. */
      217 
      218      end REWIND;
      219 
      220      end tape_mult_open_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/29/00  1715.4  tape_mult_open_.pl1               >udd>sm>ds>w>ml>tape_mult_open_.pl1
88           1    10/21/86  1351.7  tmdb.incl.pl1                     >ldd>incl>tmdb.incl.pl1
90           2    12/20/82  1213.8  mstr.incl.pl1                     >ldd>incl>mstr.incl.pl1
92           3    09/16/83  1210.4  tape_ioi_dcls.incl.pl1            >ldd>incl>tape_ioi_dcls.incl.pl1
94           4    05/20/83  1946.4  iocb.incl.pl1                     >ldd>incl>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actual_iocb_ptr          12            based           pointer                  level 2 dcl 4-6 ref 102
addr                                                   builtin function         dcl 72 ref 148 148 167 207 207 215 215
arg_error_code                         parameter       fixed bin(35,0)          dcl 47 set ref 96 191* 194*
arg_extend_flag                        parameter       bit(1)                   packed unaligned dcl 47 ref 96 109
arg_iocb_ptr                           parameter       pointer                  dcl 47 ref 96 99
arg_open_mode                          parameter       fixed bin(17,0)          dcl 47 ref 96 100
attach_data_ptr          16            based           pointer                  level 2 dcl 4-6 ref 103
close                    36            based           entry variable           level 2 dcl 4-6 set ref 169*
code                                   parameter       fixed bin(35,0)          dcl 205 set ref 198 207* 209 211* 213 215*
density                  56            based           fixed bin(17,0)          level 3 in structure "tmdb" dcl 1-24 in procedure
                                                                                  "tape_mult_open_" ref 144
density                         000100 automatic       fixed bin(17,0)          dcl 55 in procedure "tape_mult_open_" set ref 144*
                                                                                  148 148 155*
description              22            based           char(32)                 level 3 dcl 1-24 set ref 107* 118* 128*
detach_iocb              26            based           entry variable           level 2 dcl 4-6 set ref 170*
error_code                      000101 automatic       fixed bin(35,0)          dcl 55 set ref 111* 132* 145* 146 148* 149 152* 157*
                                                                                  159 194
error_table_$bad_arg            000010 external static fixed bin(35,0)          dcl 74 ref 111
error_table_$bad_mode           000012 external static fixed bin(35,0)          dcl 74 ref 132
flags                    32            based           structure                level 3 dcl 1-24
get_chars                46            based           entry variable           level 2 dcl 4-6 set ref 185*
iocb                                   based           structure                level 1 dcl 4-6
iocb_ptr                        000102 automatic       pointer                  dcl 55 set ref 99* 102* 102 103 167 168 169 170 180
                                                                                  185 186 189*
iox_$err_not_closed             000014 constant        entry                    external dcl 79 ref 168 170
iox_$propagate                  000016 constant        entry                    external dcl 79 ref 189
length                   21            based           fixed bin(17,0)          level 3 dcl 1-24 set ref 106* 117* 127*
mstr_header                            based           structure                level 1 dcl 2-37
mstr_trailer                           based           structure                level 1 dcl 2-62
null                                                   builtin function         dcl 72 ref 211
open                     21            based           structure                level 2 in structure "tmdb" dcl 1-24 in procedure
                                                                                  "tape_mult_open_" set ref 167
open                     32            based           entry variable           level 2 in structure "iocb" dcl 4-6 in procedure
                                                                                  "tape_mult_open_" set ref 168*
open_descrip_ptr         20            based           pointer                  level 2 dcl 4-6 set ref 167*
open_mode                       000104 automatic       fixed bin(17,0)          dcl 55 set ref 100* 115 122 139 180
opt                      32            based           structure                level 2 dcl 1-24
position                 62            based           entry variable           level 2 dcl 4-6 set ref 186*
put_chars                52            based           entry variable           level 2 dcl 4-6 set ref 180*
rdy_status                      000105 automatic       bit(36)                  dcl 55 set ref 207 207 215 215
ring                     32(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-24 ref 124
stream_input_mode                      constant        fixed bin(17,0)          initial dcl 66 ref 115
stream_output_mode                     constant        fixed bin(17,0)          initial dcl 66 ref 122 139 180
tape_ioi_$order                 000034 constant        entry                    external dcl 3-57 ref 148 207 211 215
tape_mult_close_$close          000020 constant        entry                    external dcl 79 ref 169
tape_mult_labeler_$read         000022 constant        entry                    external dcl 79 ref 157
tape_mult_labeler_$write        000024 constant        entry                    external dcl 79 ref 152
tape_mult_read_$get_chars       000026 constant        entry                    external dcl 79 ref 185
tape_mult_read_$position        000030 constant        entry                    external dcl 79 ref 186
tape_mult_write_$put_chars      000032 constant        entry                    external dcl 79 ref 180
tioi_id                 130            based           bit(36)                  level 3 in structure "tmdb" dcl 1-24 in procedure
                                                                                  "tape_mult_open_" ref 104
tioi_id                         000106 automatic       bit(36)                  dcl 55 in procedure "tape_mult_open_" set ref 104*
                                                                                  148* 207* 211* 215*
tmdb                                   based           structure                level 1 dcl 1-24
tmdb_ptr                        000114 automatic       pointer                  dcl 1-22 set ref 103* 104 106 107 117 118 124 127
                                                                                  128 144 151 152* 155 156 157* 167
volid                           000107 automatic       char(16)                 packed unaligned dcl 55 set ref 157*
volume_density         2216            based           fixed bin(17,0)          level 2 dcl 1-24 ref 155
volume_identifier                      based           structure                level 1 dcl 2-73
work                    126            based           structure                level 2 dcl 1-24
write_sw                 32(05)        based           bit(1)                   level 4 packed packed unaligned dcl 1-24 set ref
                                                                                  151* 156*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HEADER_VERSION                         internal static fixed bin(17,0)          initial dcl 2-89
LABEL_VERSION                          internal static fixed bin(17,0)          initial dcl 2-87
header_c1                              internal static bit(36)                  initial packed unaligned dcl 2-79
header_c2                              internal static bit(36)                  initial packed unaligned dcl 2-79
iox_$iocb_version_sentinel             external static char(4)                  dcl 4-51
label_c1                               internal static bit(36)                  initial packed unaligned dcl 2-79
mst_label                              based           structure                level 1 dcl 2-16
mstr                                   based           structure                level 1 dcl 2-10
mstrp                                  automatic       pointer                  dcl 2-8
tape_ioi_$activate              000000 constant        entry                    external dcl 3-8
tape_ioi_$allocate_buffers      000000 constant        entry                    external dcl 3-11
tape_ioi_$allocate_work_area    000000 constant        entry                    external dcl 3-16
tape_ioi_$buffer_status         000000 constant        entry                    external dcl 3-20
tape_ioi_$check_order           000000 constant        entry                    external dcl 3-24
tape_ioi_$check_read            000000 constant        entry                    external dcl 3-27
tape_ioi_$check_write           000000 constant        entry                    external dcl 3-30
tape_ioi_$deactivate            000000 constant        entry                    external dcl 3-33
tape_ioi_$deallocate            000000 constant        entry                    external dcl 3-36
tape_ioi_$deallocate_buffers    000000 constant        entry                    external dcl 3-39
tape_ioi_$get_mode              000000 constant        entry                    external dcl 3-43
tape_ioi_$get_statistics        000000 constant        entry                    external dcl 3-46
tape_ioi_$hardware_status       000000 constant        entry                    external dcl 3-50
tape_ioi_$list_buffers          000000 constant        entry                    external dcl 3-54
tape_ioi_$queue_order           000000 constant        entry                    external dcl 3-60
tape_ioi_$queue_read            000000 constant        entry                    external dcl 3-63
tape_ioi_$queue_write           000000 constant        entry                    external dcl 3-66
tape_ioi_$read                  000000 constant        entry                    external dcl 3-69
tape_ioi_$release_buffer        000000 constant        entry                    external dcl 3-72
tape_ioi_$reserve_buffer        000000 constant        entry                    external dcl 3-76
tape_ioi_$reset_statistics      000000 constant        entry                    external dcl 3-80
tape_ioi_$set_buffer_ready      000000 constant        entry                    external dcl 3-84
tape_ioi_$set_mode              000000 constant        entry                    external dcl 3-88
tape_ioi_$stop_tape             000000 constant        entry                    external dcl 3-91
tape_ioi_$write                 000000 constant        entry                    external dcl 3-94
trailer_c1                             internal static bit(36)                  initial packed unaligned dcl 2-79
trailer_c2                             internal static bit(36)                  initial packed unaligned dcl 2-79

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_MODE                        000124 constant        label                    dcl 132 ref 124
OPEN_ERROR                      000307 constant        label                    dcl 194 ref 112 134 146 149 159
REWIND                          000312 constant        entry                    internal dcl 198 ref 145
SETUP_REEL                      000127 constant        label                    dcl 139 ref 119 129
open                            000042 constant        entry                    external dcl 96
tape_mult_open_                 000027 constant        entry                    external dcl 32

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       644         702     460         654
Length      1144     460        36         226     164           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_mult_open_                     128 external procedure  is an external procedure.  
REWIND                                  internal procedure  shares stack frame of external procedure tape_mult_open_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tape_mult_open_          000100 density                     tape_mult_open_
                         000101 error_code                  tape_mult_open_
                         000102 iocb_ptr                    tape_mult_open_
                         000104 open_mode                   tape_mult_open_
                         000105 rdy_status                  tape_mult_open_
                         000106 tioi_id                     tape_mult_open_
                         000107 volid                       tape_mult_open_
                         000114 tmdb_ptr                    tape_mult_open_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$err_not_closed           iox_$propagate                tape_ioi_$order               tape_mult_close_$close
tape_mult_labeler_$read       tape_mult_labeler_$write      tape_mult_read_$get_chars     tape_mult_read_$position
tape_mult_write_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_mode


CONSTANTS
000450  aa     077777000043
000451  aa     000001000000

000452  aa     767777777777

000454  aa     000002000000
000455  aa     000000000000
000456  aa     600000000041
000457  aa     000101000000

000000  aa  162 145 167 040	rew 

000001  aa  162 144 171 040	rdy 

000002  aa     526000000020

000003  aa  144 145 156 040	den 

000004  aa     404000000021

000005  aa     464000000000

000006  aa     516000000001

000007  aa     404000000043

000010  aa     077777000043
000011  aa     000001000000

000012  aa  163 164 162 145	stre
000013  aa  141 155 137 151	am_i
000014  aa  156 160 165 164	nput

000015  aa  163 164 162 145	stre
000016  aa  141 155 137 157	am_o
000017  aa  165 164 160 165	utpu
000020  aa  164 000 000 000	t

000021  aa  165 156 151 156	unin
000022  aa  151 164 151 141	itia
000023  aa  154 151 172 145	lize
000024  aa  144 137 155 157	d_mo
000025  aa  144 145 000 000	de

BEGIN PROCEDURE tape_mult_open_
ENTRY TO tape_mult_open_                                    STATEMENT 1 ON LINE 32
tape_mult_open_:
     procedure;

000026  da     000153200000
000027  aa   000200 6270 00	eax7 	128
000030  aa  7 00034 3521 20	epp2 	pr7|28,*
000031  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000032  aa     000000000000
000033  aa     000000000000
						STATEMENT 1 ON LINE 96
open:
     entry (arg_iocb_ptr, arg_open_mode, arg_extend_flag, arg_error_code);

000034  aa   000013 7100 04	tra  	11,ic		000047
ENTRY TO open                                               STATEMENT 1 ON LINE 96
open:
     entry (arg_iocb_ptr, arg_open_mode, arg_extend_flag, arg_error_code);

000035  at     000004000005
000036  tt     000004000006
000037  ta     000007000000
000040  ta     000035000000
000041  da     000160300000
000042  aa   000200 6270 00	eax7 	128
000043  aa  7 00034 3521 20	epp2 	pr7|28,*
000044  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000045  aa     000010000000
000046  aa     000000000000
						STATEMENT 1 ON LINE 99
	iocb_ptr = arg_iocb_ptr;

000047  aa  6 00032 3735 20	epp7 	pr6|26,*
000050  aa  7 00002 3715 20	epp5 	pr7|2,*		arg_iocb_ptr
000051  aa  5 00000 3715 20	epp5 	pr5|0,*		arg_iocb_ptr
000052  aa  6 00102 6515 00	spri5	pr6|66		iocb_ptr
						STATEMENT 1 ON LINE 100
	open_mode = arg_open_mode;

000053  aa  7 00004 2361 20	ldq  	pr7|4,*		arg_open_mode
000054  aa  6 00104 7561 00	stq  	pr6|68		open_mode
						STATEMENT 1 ON LINE 102
	iocb_ptr = iocb_ptr -> iocb.actual_iocb_ptr;

000055  aa  5 00012 3535 20	epp3 	pr5|10,*		iocb.actual_iocb_ptr
000056  aa  6 00102 2535 00	spri3	pr6|66		iocb_ptr
						STATEMENT 1 ON LINE 103
	tmdb_ptr = iocb_ptr -> iocb.attach_data_ptr;

000057  aa  3 00016 3715 20	epp5 	pr3|14,*		iocb.attach_data_ptr
000060  aa  6 00114 6515 00	spri5	pr6|76		tmdb_ptr
						STATEMENT 1 ON LINE 104
	tioi_id = tmdb.work.tioi_id;

000061  aa  5 00130 2351 00	lda  	pr5|88		tmdb.tioi_id
000062  aa  6 00106 7551 00	sta  	pr6|70		tioi_id
						STATEMENT 1 ON LINE 106
	tmdb.open.length = 18;

000063  aa   000022 2360 07	ldq  	18,dl
000064  aa  5 00021 7561 00	stq  	pr5|17		tmdb.length
						STATEMENT 1 ON LINE 107
	tmdb.open.description = "uninitialized_mode";

000065  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000066  aa   777734 00 0022	desc9a	-36,18		000021 = 165156151156
000067  aa  5 00022 00 0040	desc9a	pr5|18,32		tmdb.description
						STATEMENT 1 ON LINE 109
	if arg_extend_flag				/* tape_mult_ does not support extend. */
	then do;

000070  aa  7 00006 3515 20	epp1 	pr7|6,*
000071  aa  000 000 066 500	cmpb 	(pr),(),fill(0)
000072  aa  1 00000 00 0001	descb	pr1|0,1		arg_extend_flag
000073  aa   000000 00 0000	descb	0,0
000074  aa   000004 6000 04	tze  	4,ic		000100
						STATEMENT 1 ON LINE 111
	     error_code = error_table_$bad_arg;

000075  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$bad_arg
000076  aa  6 00101 7561 00	stq  	pr6|65		error_code
						STATEMENT 1 ON LINE 112
	     goto OPEN_ERROR;

000077  aa   000210 7100 04	tra  	136,ic		000307
						STATEMENT 1 ON LINE 113
	end;

						STATEMENT 1 ON LINE 115
	if open_mode = stream_input_mode		/* Are we opening for input or output? */
	then do;

000100  aa  6 00104 2361 00	ldq  	pr6|68		open_mode
000101  aa   000001 1160 07	cmpq 	1,dl
000102  aa   000007 6010 04	tnz  	7,ic		000111
						STATEMENT 1 ON LINE 117
	     tmdb.open.length = 12;

000103  aa   000014 2360 07	ldq  	12,dl
000104  aa  5 00021 7561 00	stq  	pr5|17		tmdb.length
						STATEMENT 1 ON LINE 118
	     tmdb.open.description = "stream_input";

000105  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000106  aa   777705 00 0014	desc9a	-59,12		000012 = 163164162145
000107  aa  5 00022 00 0040	desc9a	pr5|18,32		tmdb.description
						STATEMENT 1 ON LINE 119
	     goto SETUP_REEL;

000110  aa   000017 7100 04	tra  	15,ic		000127
						STATEMENT 1 ON LINE 120
	end;

						STATEMENT 1 ON LINE 122
	if open_mode = stream_output_mode		/* If not input it must be output. */
	then do;

000111  aa   000002 1160 07	cmpq 	2,dl
000112  aa   000012 6010 04	tnz  	10,ic		000124
						STATEMENT 1 ON LINE 124
	     if ^tmdb.opt.flags.ring			/* Is write ring in? */
		then
		goto BAD_MODE;

000113  aa  5 00032 2351 00	lda  	pr5|26		tmdb.ring
000114  aa   200000 3150 03	cana 	65536,du
000115  aa   000007 6000 04	tze  	7,ic		000124
						STATEMENT 1 ON LINE 127
	     tmdb.open.length = 13;

000116  aa   000015 2360 07	ldq  	13,dl
000117  aa  5 00021 7561 00	stq  	pr5|17		tmdb.length
						STATEMENT 1 ON LINE 128
	     tmdb.open.description = "stream_output";

000120  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000121  aa   777675 00 0015	desc9a	-67,13		000015 = 163164162145
000122  aa  5 00022 00 0040	desc9a	pr5|18,32		tmdb.description
						STATEMENT 1 ON LINE 129
	     goto SETUP_REEL;

000123  aa   000004 7100 04	tra  	4,ic		000127
						STATEMENT 1 ON LINE 130
	end;

						STATEMENT 1 ON LINE 132
BAD_MODE:						/* We cannot open with this mode. */
	error_code = error_table_$bad_mode;

000124  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$bad_mode
000125  aa  6 00101 7561 00	stq  	pr6|65		error_code
						STATEMENT 1 ON LINE 134
	goto OPEN_ERROR;

000126  aa   000161 7100 04	tra  	113,ic		000307
						STATEMENT 1 ON LINE 139
SETUP_REEL:


	if open_mode = stream_output_mode		/* Are we writing or reading? */
	then do;

000127  aa  6 00104 2361 00	ldq  	pr6|68		open_mode
000130  aa   000002 1160 07	cmpq 	2,dl
000131  aa   000061 6010 04	tnz  	49,ic		000212
						STATEMENT 1 ON LINE 144
 	     density = tmdb.opt.density;

000132  aa  5 00056 2361 00	ldq  	pr5|46		tmdb.density
000133  aa  6 00100 7561 00	stq  	pr6|64		density
						STATEMENT 1 ON LINE 145
	     call REWIND (error_code);

000134  aa   000320 3520 04	epp2 	208,ic		000454 = 000002000000
000135  aa   000155 6700 04	tsp4 	109,ic		000312
						STATEMENT 1 ON LINE 146
	     if error_code ^= 0 then
		goto OPEN_ERROR;

000136  aa  6 00101 2361 00	ldq  	pr6|65		error_code
000137  aa   000150 6010 04	tnz  	104,ic		000307
						STATEMENT 1 ON LINE 148
	     call tape_ioi_$order (tioi_id, "den", 1, addr (density), (0), (0), error_code);

000140  aa   777643 2350 04	lda  	-93,ic		000003 = 144145156040
000141  aa  6 00124 7551 00	sta  	pr6|84
000142  aa   000001 2360 07	ldq  	1,dl
000143  aa  6 00125 7561 00	stq  	pr6|85
000144  aa  6 00100 3735 00	epp7 	pr6|64		density
000145  aa  6 00126 6535 00	spri7	pr6|86
000146  aa  6 00130 4501 00	stz  	pr6|88
000147  aa  6 00131 4501 00	stz  	pr6|89
000150  aa  6 00106 3521 00	epp2 	pr6|70		tioi_id
000151  aa  6 00134 2521 00	spri2	pr6|92
000152  aa  6 00124 3521 00	epp2 	pr6|84
000153  aa  6 00136 2521 00	spri2	pr6|94
000154  aa  6 00125 3521 00	epp2 	pr6|85
000155  aa  6 00140 2521 00	spri2	pr6|96
000156  aa  6 00126 3521 00	epp2 	pr6|86
000157  aa  6 00142 2521 00	spri2	pr6|98
000160  aa  6 00130 3521 00	epp2 	pr6|88
000161  aa  6 00144 2521 00	spri2	pr6|100
000162  aa  6 00131 3521 00	epp2 	pr6|89
000163  aa  6 00146 2521 00	spri2	pr6|102
000164  aa  6 00101 3521 00	epp2 	pr6|65		error_code
000165  aa  6 00150 2521 00	spri2	pr6|104
000166  aa  6 00132 6211 00	eax1 	pr6|90
000167  aa   034000 4310 07	fld  	14336,dl
000170  aa  6 00044 3701 20	epp4 	pr6|36,*
000171  la  4 00034 3521 20	epp2 	pr4|28,*		tape_ioi_$order
000172  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 149
	     if error_code ^= 0 then
		goto OPEN_ERROR;

000173  aa  6 00101 2361 00	ldq  	pr6|65		error_code
000174  aa   000113 6010 04	tnz  	75,ic		000307
						STATEMENT 1 ON LINE 151
	     tmdb.opt.write_sw = "1"b;

000175  aa   010000 2350 03	lda  	4096,du
000176  aa  6 00114 3735 20	epp7 	pr6|76,*		tmdb_ptr
000177  aa  7 00032 2551 00	orsa 	pr7|26		tmdb.write_sw
						STATEMENT 1 ON LINE 152
	     call tape_mult_labeler_$write (tmdb_ptr, error_code);

000200  aa  6 00114 3521 00	epp2 	pr6|76		tmdb_ptr
000201  aa  6 00134 2521 00	spri2	pr6|92
000202  aa  6 00101 3521 00	epp2 	pr6|65		error_code
000203  aa  6 00136 2521 00	spri2	pr6|94
000204  aa  6 00132 6211 00	eax1 	pr6|90
000205  aa   010000 4310 07	fld  	4096,dl
000206  aa  6 00044 3701 20	epp4 	pr6|36,*
000207  la  4 00024 3521 20	epp2 	pr4|20,*		tape_mult_labeler_$write
000210  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 153
	end;

000211  aa   000025 7100 04	tra  	21,ic		000236
						STATEMENT 1 ON LINE 154
	else do;

						STATEMENT 1 ON LINE 155
	     density = tmdb.volume_density;

000212  aa  5 02216 2361 00	ldq  	pr5|1166		tmdb.volume_density
000213  aa  6 00100 7561 00	stq  	pr6|64		density
						STATEMENT 1 ON LINE 156
	     tmdb.opt.write_sw = "0"b;

000214  aa   000236 2350 04	lda  	158,ic		000452 = 767777777777
000215  aa  5 00032 3551 00	ansa 	pr5|26		tmdb.write_sw
						STATEMENT 1 ON LINE 157
	     call tape_mult_labeler_$read (tmdb_ptr, volid, error_code);

000216  aa  6 00114 3521 00	epp2 	pr6|76		tmdb_ptr
000217  aa  6 00134 2521 00	spri2	pr6|92
000220  aa  6 00107 3521 00	epp2 	pr6|71		volid
000221  aa  6 00136 2521 00	spri2	pr6|94
000222  aa  6 00101 3521 00	epp2 	pr6|65		error_code
000223  aa  6 00140 2521 00	spri2	pr6|96
000224  aa   777561 3520 04	epp2 	-143,ic		000005 = 464000000000
000225  aa  6 00142 2521 00	spri2	pr6|98
000226  aa   777554 3520 04	epp2 	-148,ic		000002 = 526000000020
000227  aa  6 00144 2521 00	spri2	pr6|100
000230  aa   777557 3520 04	epp2 	-145,ic		000007 = 404000000043
000231  aa  6 00146 2521 00	spri2	pr6|102
000232  aa  6 00132 6211 00	eax1 	pr6|90
000233  aa   014000 4310 07	fld  	6144,dl
000234  la  4 00022 3521 20	epp2 	pr4|18,*		tape_mult_labeler_$read
000235  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 158
	end;

						STATEMENT 1 ON LINE 159
	if error_code ^= 0 then
	     goto OPEN_ERROR;

000236  aa  6 00101 2361 00	ldq  	pr6|65		error_code
000237  aa   000050 6010 04	tnz  	40,ic		000307
						STATEMENT 1 ON LINE 167
	iocb_ptr -> iocb.open_descrip_ptr = addr (tmdb.open);

000240  aa  6 00114 3735 20	epp7 	pr6|76,*		tmdb_ptr
000241  aa  7 00021 3735 00	epp7 	pr7|17		tmdb.open
000242  aa  6 00102 3715 20	epp5 	pr6|66,*		iocb_ptr
000243  aa  5 00020 6535 00	spri7	pr5|16		iocb.open_descrip_ptr
						STATEMENT 1 ON LINE 168
	iocb_ptr -> iocb.open = iox_$err_not_closed;

000244  aa  6 00044 3701 20	epp4 	pr6|36,*
000245  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$err_not_closed
000246  aa  5 00032 2521 00	spri2	pr5|26		iocb.open
000247  aa   000201 2370 04	ldaq 	129,ic		000450 = 077777000043 000001000000
000250  aa  5 00034 7571 00	staq 	pr5|28		iocb.open
						STATEMENT 1 ON LINE 169
	iocb_ptr -> iocb.close = tape_mult_close_$close;

000251  la  4 00020 3521 20	epp2 	pr4|16,*		tape_mult_close_$close
000252  aa  5 00036 2521 00	spri2	pr5|30		iocb.close
000253  aa  5 00040 7571 00	staq 	pr5|32		iocb.close
						STATEMENT 1 ON LINE 170
	iocb_ptr -> iocb.detach_iocb = iox_$err_not_closed;

000254  la  4 00014 3521 20	epp2 	pr4|12,*		iox_$err_not_closed
000255  aa  5 00026 2521 00	spri2	pr5|22		iocb.detach_iocb
000256  aa  5 00030 7571 00	staq 	pr5|24		iocb.detach_iocb
						STATEMENT 1 ON LINE 180
	if open_mode = stream_output_mode		/* Set up I/O entry and tseg write switch. */
	     then
	     iocb_ptr -> iocb.put_chars = tape_mult_write_$put_chars;

000257  aa  6 00104 2361 00	ldq  	pr6|68		open_mode
000260  aa   000002 1160 07	cmpq 	2,dl
000261  aa   000006 6010 04	tnz  	6,ic		000267
000262  la  4 00032 3521 20	epp2 	pr4|26,*		tape_mult_write_$put_chars
000263  aa  5 00052 2521 00	spri2	pr5|42		iocb.put_chars
000264  aa   000164 2370 04	ldaq 	116,ic		000450 = 077777000043 000001000000
000265  aa  5 00054 7571 00	staq 	pr5|44		iocb.put_chars
000266  aa   000010 7100 04	tra  	8,ic		000276
						STATEMENT 1 ON LINE 184
	else do;

						STATEMENT 1 ON LINE 185
	     iocb_ptr -> iocb.get_chars = tape_mult_read_$get_chars;

000267  la  4 00026 3521 20	epp2 	pr4|22,*		tape_mult_read_$get_chars
000270  aa  5 00046 2521 00	spri2	pr5|38		iocb.get_chars
000271  aa   000157 2370 04	ldaq 	111,ic		000450 = 077777000043 000001000000
000272  aa  5 00050 7571 00	staq 	pr5|40		iocb.get_chars
						STATEMENT 1 ON LINE 186
	     iocb_ptr -> iocb.position = tape_mult_read_$position;

000273  la  4 00030 3521 20	epp2 	pr4|24,*		tape_mult_read_$position
000274  aa  5 00062 2521 00	spri2	pr5|50		iocb.position
000275  aa  5 00064 7571 00	staq 	pr5|52		iocb.position
						STATEMENT 1 ON LINE 187
	end;

						STATEMENT 1 ON LINE 189
	call iox_$propagate (iocb_ptr);

000276  aa  6 00102 3521 00	epp2 	pr6|66		iocb_ptr
000277  aa  6 00134 2521 00	spri2	pr6|92
000300  aa  6 00132 6211 00	eax1 	pr6|90
000301  aa   004000 4310 07	fld  	2048,dl
000302  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$propagate
000303  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 191
	arg_error_code = 0;

000304  aa  6 00032 3735 20	epp7 	pr6|26,*
000305  aa  7 00010 4501 20	stz  	pr7|8,*		arg_error_code
						STATEMENT 1 ON LINE 192
	return;

000306  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 194
OPEN_ERROR:					/* Fatal error during opening. */
	arg_error_code = error_code;

000307  aa  6 00032 3735 20	epp7 	pr6|26,*
000310  aa  7 00010 7561 20	stq  	pr7|8,*		arg_error_code
						STATEMENT 1 ON LINE 196
	return;

000311  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 220
     end tape_mult_open_;

BEGIN PROCEDURE REWIND
ENTRY TO REWIND                                             STATEMENT 1 ON LINE 198
REWIND:
     proc (code);

000312  aa  6 00116 6501 00	spri4	pr6|78
000313  aa  6 00120 2521 00	spri2	pr6|80
						STATEMENT 1 ON LINE 207
	call tape_ioi_$order (tioi_id, "rdy", 1, addr (rdy_status), (0), (0), code);

000314  aa   777465 2350 04	lda  	-203,ic		000001 = 162144171040
000315  aa  6 00152 7551 00	sta  	pr6|106
000316  aa   000001 2360 07	ldq  	1,dl
000317  aa  6 00153 7561 00	stq  	pr6|107
000320  aa  6 00105 3735 00	epp7 	pr6|69		rdy_status
000321  aa  6 00154 6535 00	spri7	pr6|108
000322  aa  6 00156 4501 00	stz  	pr6|110
000323  aa  6 00157 4501 00	stz  	pr6|111
000324  aa  6 00106 3521 00	epp2 	pr6|70		tioi_id
000325  aa  6 00162 2521 00	spri2	pr6|114
000326  aa  6 00152 3521 00	epp2 	pr6|106
000327  aa  6 00164 2521 00	spri2	pr6|116
000330  aa  6 00153 3521 00	epp2 	pr6|107
000331  aa  6 00166 2521 00	spri2	pr6|118
000332  aa  6 00154 3521 00	epp2 	pr6|108
000333  aa  6 00170 2521 00	spri2	pr6|120
000334  aa  6 00156 3521 00	epp2 	pr6|110
000335  aa  6 00172 2521 00	spri2	pr6|122
000336  aa  6 00157 3521 00	epp2 	pr6|111
000337  aa  6 00174 2521 00	spri2	pr6|124
000340  aa  6 00120 3715 20	epp5 	pr6|80,*
000341  aa  5 00002 3521 20	epp2 	pr5|2,*		code
000342  aa  6 00176 2521 00	spri2	pr6|126
000343  aa  6 00160 6211 00	eax1 	pr6|112
000344  aa   034000 4310 07	fld  	14336,dl
000345  aa  6 00044 3701 20	epp4 	pr6|36,*
000346  la  4 00034 3521 20	epp2 	pr4|28,*		tape_ioi_$order
000347  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 209
	if code ^= 0 then
	     return;

000350  aa  6 00120 3735 20	epp7 	pr6|80,*
000351  aa  7 00002 2361 20	ldq  	pr7|2,*		code
000352  aa   000002 6000 04	tze  	2,ic		000354
000353  aa  6 00116 6101 00	rtcd 	pr6|78
						STATEMENT 1 ON LINE 211
	call tape_ioi_$order (tioi_id, "rew", 1, (null), (0), (0), code);

000354  aa   777424 2350 04	lda  	-236,ic		000000 = 162145167040
000355  aa  6 00157 7551 00	sta  	pr6|111
000356  aa   000001 2360 07	ldq  	1,dl
000357  aa  6 00156 7561 00	stq  	pr6|110
000360  aa   777430 3714 24	epp5 	-232,ic*
000361  aa  6 00154 6515 00	spri5	pr6|108
000362  aa  6 00153 4501 00	stz  	pr6|107
000363  aa  6 00152 4501 00	stz  	pr6|106
000364  aa  6 00106 3521 00	epp2 	pr6|70		tioi_id
000365  aa  6 00162 2521 00	spri2	pr6|114
000366  aa  6 00157 3521 00	epp2 	pr6|111
000367  aa  6 00164 2521 00	spri2	pr6|116
000370  aa  6 00156 3521 00	epp2 	pr6|110
000371  aa  6 00166 2521 00	spri2	pr6|118
000372  aa  6 00154 3521 00	epp2 	pr6|108
000373  aa  6 00170 2521 00	spri2	pr6|120
000374  aa  6 00153 3521 00	epp2 	pr6|107
000375  aa  6 00172 2521 00	spri2	pr6|122
000376  aa  6 00152 3521 00	epp2 	pr6|106
000377  aa  6 00174 2521 00	spri2	pr6|124
000400  aa  7 00002 3521 20	epp2 	pr7|2,*		code
000401  aa  6 00176 2521 00	spri2	pr6|126
000402  aa  6 00160 6211 00	eax1 	pr6|112
000403  aa   034000 4310 07	fld  	14336,dl
000404  aa  6 00044 3701 20	epp4 	pr6|36,*
000405  la  4 00034 3521 20	epp2 	pr4|28,*		tape_ioi_$order
000406  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 213
	if code ^= 0 then
	     return;

000407  aa  6 00120 3735 20	epp7 	pr6|80,*
000410  aa  7 00002 2361 20	ldq  	pr7|2,*		code
000411  aa   000002 6000 04	tze  	2,ic		000413
000412  aa  6 00116 6101 00	rtcd 	pr6|78
						STATEMENT 1 ON LINE 215
	call tape_ioi_$order (tioi_id, "rdy", 1, addr (rdy_status), (0), (0), code);

000413  aa   777366 2350 04	lda  	-266,ic		000001 = 162144171040
000414  aa  6 00152 7551 00	sta  	pr6|106
000415  aa   000001 2360 07	ldq  	1,dl
000416  aa  6 00153 7561 00	stq  	pr6|107
000417  aa  6 00105 3715 00	epp5 	pr6|69		rdy_status
000420  aa  6 00154 6515 00	spri5	pr6|108
000421  aa  6 00156 4501 00	stz  	pr6|110
000422  aa  6 00157 4501 00	stz  	pr6|111
000423  aa  6 00106 3521 00	epp2 	pr6|70		tioi_id
000424  aa  6 00162 2521 00	spri2	pr6|114
000425  aa  6 00152 3521 00	epp2 	pr6|106
000426  aa  6 00164 2521 00	spri2	pr6|116
000427  aa  6 00153 3521 00	epp2 	pr6|107
000430  aa  6 00166 2521 00	spri2	pr6|118
000431  aa  6 00154 3521 00	epp2 	pr6|108
000432  aa  6 00170 2521 00	spri2	pr6|120
000433  aa  6 00156 3521 00	epp2 	pr6|110
000434  aa  6 00172 2521 00	spri2	pr6|122
000435  aa  6 00157 3521 00	epp2 	pr6|111
000436  aa  6 00174 2521 00	spri2	pr6|124
000437  aa  7 00002 3521 20	epp2 	pr7|2,*		code
000440  aa  6 00176 2521 00	spri2	pr6|126
000441  aa  6 00160 6211 00	eax1 	pr6|112
000442  aa   034000 4310 07	fld  	14336,dl
000443  aa  6 00044 3701 20	epp4 	pr6|36,*
000444  la  4 00034 3521 20	epp2 	pr4|28,*		tape_ioi_$order
000445  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 218
     end REWIND;

000446  aa  6 00116 6101 00	rtcd 	pr6|78
  END PROCEDURE REWIND
  END PROCEDURE tape_mult_open_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
