	COMPILATION LISTING OF SEGMENT template_address_space
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1120.69_Tue_mdt
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 template_address_space: proc ();
       14 
       15 /*
       16*
       17*   Written October 31, 1975 by R. Bratt
       18*
       19*   Last Modified:
       20*   October 1984, Keith Loepere even though this is no longer called, to use 
       21*      fs_modes.  Also removed use of hdr.  Also for terminate_.
       22*
       23*   template_address_space provides functions for creating and deleting a template address space.
       24*   A template address space is stored in a directory and is defined by two ring zero
       25*   segments named "template_kst" and "template_dseg".
       26*
       27*   ---> call template_address_space$create (dirname, access_calculated, code)
       28*
       29*   create initiates the segment "kst_seg" in the given directory. It assumes
       30*   that this segment has the format of a kst. create makes the following demands
       31*   of its environment and the given segment:
       32*
       33*   * kst.lowseg = active_all_rings_data$stack_base_segno
       34*   * kst.highseg < active_all_rings_data$max_segno
       35*   * kst.highest_used_segno > kst.lowseg+7
       36*   * kst.time_of_bootload = sys_info$time_of_bootload
       37*   * kst.highest_used_segno is consistent with bitcount
       38*   * caller has read access to kst_seg
       39*   * each kst entry from lowseg to highest_used_segno contains:
       40*   *  a valid uid or a uid of "0"b
       41*   *  baseno (kste.entryp) is valid w.r.t. this kst
       42*   *  usage counts
       43*   * the caller's address space contains every object in the kst to be built
       44*   * no segment named "template_dseg" or "template_kst" exists in the given directory
       45*
       46*   create makes two ring zero segments named "template_kst" and
       47*   "template_dseg" with r *.*.* access. create then uses the information in
       48*   kst_seg and its callers's address space to transform kst_seg into a secure, valid
       49*   address space template. If an object in the new address space has a single acl
       50*   term of *.*.* then access is precalculated in the template address space.
       51*   If any inconsistancies are found in template_kst or if any of the assertion above
       52*   are found to be violated then "template_kst" and "template_dseg" are deleted and an error
       53*   is returned. If the address space template is sucessfully built then kst.template
       54*   is set to help template_address_space$delete validate its right to delete
       55*   this template address space and the count of segments which had access precalculated
       56*   is returned.
       57*
       58*   ---> call template_address_space$delete (dirname,code)
       59*
       60*   delete is called to delete the template address space (template_kst, template_dseg) stored
       61*   in a given directory. delete requires that the given directory contain
       62*   two segments named "template_kst" and "template_dseg". These segments must have ring brackets
       63*   of 0, 0, 0 and the caller must have modify permission to the containing directory.
       64*   delete validates that the kst is marked as a template kst. Unfortunately,
       65*   since we don't have property lists, delete cannot be absolutely certain that it is deleting
       66*   a (template_kst, template_dseg) pair created by template_address_space$create.
       67*   We assume, somewhat nervously, that the checks made by delete are
       68*   sufficiently safe to prevent users from destroying ring zero segments not created
       69*   by template_address_space$create.
       70*
       71**/
       72 
       73 
       74 
       75 dcl  a_dirname char (*),
       76      a_access_calculated fixed bin (17),
       77      a_code fixed bin (35);
       78 dcl  access_calculated fixed bin (17),
       79     (created_kst, created_dseg) bit (1) aligned,
       80      dirname char (168),
       81     (mode, exmode) bit (36) aligned,
       82      ring fixed bin (3),
       83      rings (3) fixed bin (3),
       84      level fixed bin (3),
       85     (my_kstp, my_kstep, my_dsegp, his_dsegp, his_kstp, his_kstep, input_kstp) ptr,
       86      bc fixed bin (24),
       87      hash_class fixed bin (17),
       88      code fixed bin (35),
       89     (slotx, parent_slotx, segno) fixed bin (17);
       90 dcl  copy_kst bit (bc) aligned based;
       91 dcl 1 star_dot_star_dot_star aligned,
       92     2 pers_name char (32) initial ("*"),
       93     2 proj_name char (32) initial ("*"),
       94     2 tag char (1) initial ("*"),
       95     2 modes bit (72);
       96 dcl 1 all_access aligned,
       97     2 name char (32) initial ("*.*.*"),
       98     2 modes bit (36) initial ("01000"b),
       99     2 mbz bit (36) initial ("0"b),
      100     2 code fixed bin (35);
      101 dcl  error_table_$action_not_performed ext fixed bin (35),
      102      sys_info$time_of_bootload ext fixed bin (71),
      103      active_all_rings_data$max_segno ext fixed bin (17),
      104      dseg$ ext fixed bin;
      105 dcl  acc_list_$match entry (fixed bin, bit (36) aligned, ptr, ptr, ptr, fixed bin, fixed bin (35)),
      106      acl$areplace entry (char (*), char (*), ptr, fixed bin (17), bit (1), fixed bin (35)),
      107      append$branch entry (char (*), char (*), fixed bin (5), fixed bin (35)),
      108      delentry$dfile entry (char (*), char (*), fixed bin (35)),
      109      delentry$dseg entry (ptr, fixed bin (35)),
      110      fs_modes entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35)),
      111      initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      112      initiate$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35)),
      113      kstsrch entry (bit (36) aligned, fixed bin (17), ptr),
      114      level$get entry returns (fixed bin (3)),
      115      level$set entry (fixed bin (3)),
      116      lock$dir_unlock entry (ptr),
      117      set$bc_seg entry (ptr, fixed bin (24), fixed bin (35)),
      118      set$safety_sw_path entry (char (*), char (*), bit (1), fixed bin (35)),
      119      set$copysw entry (char (*), char (*), fixed bin (1), fixed bin (35)),
      120      sum$getbranch entry (ptr, bit (36) aligned, ptr, fixed bin (35)),
      121      terminate_$noname entry (ptr, fixed bin (35));
      122 
      123 dcl  (addr, baseno, baseptr, bin, fixed, null, ptr, rel, string, substr, unspec) builtin;
      124 
      125 create:	entry (a_dirname, a_access_calculated, a_code);
      126 
      127 	dirname = a_dirname;
      128 	a_access_calculated = 0;
      129 	a_code = 0;
      130 
      131 	access_calculated = 0;
      132 	created_kst, created_dseg = "0"b;
      133 	his_kstp, his_dsegp = null ();
      134 	my_dsegp = addr (dseg$);
      135 	my_kstp = pds$kstp;
      136 	level = level$get ();
      137 	call level$set (0);
      138 
      139 /* verify that kst_seg exists, is a segment and is readable by caller */
      140 
      141 	call initiate$initiate_count (dirname, "kst_seg", "", bc, 0, input_kstp, code);
      142 	if input_kstp = null () then call abort_create (code);
      143 	if my_kstp -> kst.kst_entry (fixed (baseno (input_kstp))).dirsw
      144 	then call abort_create (0);			/* nice try fella */
      145 	call fs_modes (input_kstp, mode, exmode, rings, code);
      146 	if code ^= 0 then call abort_create (code);
      147 	if (mode & R_ACCESS) ^= R_ACCESS | level > rings (2)
      148 	then call abort_create (0);			/* nasty, nasty */
      149 
      150 /* create template_kst */
      151 
      152 	call append$branch (dirname, "template_kst", 01010b, code);
      153 	if code ^= 0 then call abort_create (code);
      154 	created_kst = "1"b;
      155 	call initiate (dirname, "template_kst", "", 0, 0, his_kstp, code);
      156 	if code ^= 0 then call abort_create (code);
      157 
      158 /* create dseg */
      159 
      160 	call append$branch (dirname, "template_dseg", 01010b, code);
      161 	if code ^= 0 then call abort_create (code);
      162 	created_dseg = "1"b;
      163 	call initiate (dirname, "template_dseg", "", 0, 0, his_dsegp, code);
      164 	if his_dsegp = null () then call abort_create (code);
      165 
      166 /* copy kst_seg into template_kst */
      167 
      168 	his_kstp -> copy_kst = input_kstp -> copy_kst;
      169 	his_kstp -> kst.template = "0"b;
      170 	call terminate_$noname (input_kstp, (0));
      171 
      172 /* validate kst header */
      173 
      174 	if his_kstp -> kst.time_of_bootload ^= sys_info$time_of_bootload
      175 	then call abort_create (0);			/* must be made this bootload */
      176 	if his_kstp -> kst.lowseg ^= my_kstp -> kst.lowseg
      177 	then call abort_create (0);			/* the fool */
      178 	if his_kstp -> kst.highseg > active_all_rings_data$max_segno
      179 	then call abort_create (0);
      180 	if his_kstp -> kst.highest_used_segno < his_kstp -> kst.lowseg + 7
      181 	then call abort_create (0);
      182 	if bin (rel (addr (his_kstp -> kst_entry (his_kstp -> kst.highest_used_segno + 1)))) * 36 ^= bc
      183 	then call abort_create (0);
      184 	if substr (string (his_kstp -> kst.prelinked_ring), 1, level - 1) ^= ""b
      185 	then call abort_create (0);
      186 
      187 /* clean out stuff we won't look at */
      188 
      189 	his_kstp -> kst.free_list = "0"b;
      190 	unspec (his_kstp -> kst.uid_hash_bucket) = "0"b;
      191 	do slotx = his_kstp -> kst.lowseg to his_kstp -> kst.highest_used_segno;
      192 	     his_kstep = addr (his_kstp -> kst.kst_entry (slotx));
      193 	     his_kstep -> kste.segno = slotx;
      194 	     his_kstep -> kste.fp = "0"b;
      195 	     unspec (his_kstep -> kste.access_information) = "0"b;
      196 	     unspec (his_kstep -> kste.flags) = "0"b;
      197 	     his_kstep -> kste.infcount = 0;
      198 	     his_kstep -> kste.dtbm = (36) "1"b;
      199 	end;
      200 
      201 /* verify and build kstes */
      202 
      203 	do slotx = his_kstp -> kst.lowseg to his_kstp -> kst.highest_used_segno;
      204 	     his_kstep = addr (his_kstp -> kst.kst_entry (slotx));
      205 	     if his_kstep -> kste.uid = "0"b
      206 	     then do;
      207 		his_kstep -> kste.usage_count = 0;
      208 		unspec (his_kstep -> kste.entryp) = "0"b;
      209 		if slotx ^> his_kstp -> kst.lowseg + 7
      210 		then his_kstep -> kste.fp = (18)"1"b;	/* reserve stack */
      211 		else do;
      212 		     his_kstep -> kste.fp = his_kstp -> kst.free_list;
      213 		     his_kstp -> kst.free_list = rel (his_kstep);
      214 		end;
      215 	     end;
      216 	     else do;
      217 		call kstsrch (his_kstep -> kste.uid, hash_class, my_kstep);
      218 		if my_kstep = null () then call abort_create (0);
      219 		his_kstep -> kste.fp = his_kstp -> kst.uid_hash_bucket (hash_class);
      220 		his_kstp -> kst.uid_hash_bucket (hash_class) = rel (his_kstep);
      221 		segno = my_kstep -> kste.segno;
      222 		if his_kstep -> kste.entryp ^= null ()
      223 		then do;
      224 		     parent_slotx = bin (baseno (his_kstep -> kste.entryp));
      225 		     if his_kstp -> kst.kst_entry (parent_slotx).uid ^= my_kstp -> kst.kst_entry (bin (baseno (my_kstep -> kste.entryp))).uid
      226 		     then call abort_create (0);
      227 		     his_kstep -> kste.entryp = ptr (his_kstep -> kste.entryp, rel (my_kstep -> kste.entryp));
      228 		     his_kstp -> kst.kst_entry (parent_slotx).infcount = his_kstp -> kst.kst_entry (parent_slotx).infcount + 1;
      229 		end;
      230 		else if my_kstep -> kste.entryp ^= null ()
      231 		then call abort_create (0);
      232 		call set_access ();
      233 		his_kstep -> kste.dirsw, his_kstep -> kste.tms = my_kstep -> kste.dirsw;
      234 		his_kstep -> kste.allow_write = "1"b;
      235 		do ring = 7 to level + 1 while (his_kstep -> kste.usage_count (ring) = 0);
      236 		end;
      237 	     end;
      238 	end;
      239 
      240 /* mark it as a valid template_kst */
      241 
      242 	his_kstp -> kst.template = "1"b;
      243 
      244 /* fix access on template_dseg */
      245 
      246 	call set$bc_seg (his_dsegp, (his_kstp -> kst.highest_used_segno + 1) * 72, code);
      247 	if code ^= 0 then call abort_create (code);
      248 	call acl$areplace (dirname, "template_dseg", addr (all_access), 1, "0"b, code);
      249 	if code ^= 0 then call abort_create (code);
      250 
      251 /* fix access on template_kst */
      252 
      253 	call set$bc_seg (his_kstp, bc, code);
      254 	if code ^= 0 then call abort_create (code);
      255 	call acl$areplace (dirname, "template_kst", addr (all_access), 1, "0"b, code);
      256 	if code ^= 0 then call abort_create (code);
      257 
      258 /* cleanup */
      259 
      260 	call terminate_$noname (his_kstp, (0));
      261 	call terminate_$noname (his_dsegp, (0));
      262 	call level$set (level);
      263 	a_access_calculated = access_calculated;
      264 	return;
      265 
      266 set_access: proc ();
      267 
      268 dcl dummy_rings (3) fixed bin (3);
      269 
      270 	     call sum$getbranch (baseptr (segno), "0"b, ep, code);
      271 	     if code ^= 0 then return;
      272 	     if ep -> entry.acle_count = 1
      273 	     then do;
      274 		call acc_list_$match ((entry.acle_count), entry.uid, addr (entry.acl_frp),
      275 		addr (star_dot_star_dot_star), (null ()), (0), code);
      276 		if code = 0
      277 		then do;
      278 		     call fs_modes (baseptr (segno), ("0"b), ("0"b), dummy_rings, code);
      279 		     if code = 0
      280 		     then do;
      281 			access_calculated = access_calculated + 1;
      282 			his_kstep -> kste.access_information = my_kstep -> kste.access_information;
      283 			his_dsegp -> sdwa (slotx).r1 = my_dsegp -> sdwa (segno).r1;
      284 			his_dsegp -> sdwa (slotx).r2 = my_dsegp -> sdwa (segno).r2;
      285 			his_dsegp -> sdwa (slotx).r3 = my_dsegp -> sdwa (segno).r3;
      286 			his_dsegp -> sdwa (slotx).read = my_dsegp -> sdwa (segno).read;
      287 			his_dsegp -> sdwa (slotx).write = my_dsegp -> sdwa (segno).write;
      288 			his_dsegp -> sdwa (slotx).execute = my_dsegp -> sdwa (segno).execute;
      289 		     end;
      290 		end;
      291 	     end;
      292 	     call lock$dir_unlock (ptr (ep, 0));
      293 	     return;
      294 	end set_access;
      295 
      296 abort_create: proc (code);
      297 dcl  code fixed bin (35);
      298 	     if created_dseg
      299 	     then call delentry$dfile (dirname, "template_dseg", (0));
      300 	     if created_kst
      301 	     then call delentry$dfile (dirname, "template_kst", (0));
      302 	     call level$set (level);
      303 	     if code = 0
      304 	     then a_code = error_table_$action_not_performed;
      305 	     else a_code = code;
      306 	     go to return_to_caller;
      307 	end abort_create;
      308 
      309 /*
      310*   
      311**/
      312 
      313 delete:	entry (a_dirname, a_code);
      314 
      315 	dirname = a_dirname;
      316 	a_code = 0;
      317 
      318 	my_kstp = pds$kstp;
      319 	his_kstp, his_dsegp = null ();
      320 	level = level$get ();
      321 	call level$set (0);
      322 
      323 /* verify kst_seg exists, is a segment, and has brackets 0, 0, 0 */
      324 
      325 	call initiate_r0_seg ("template_kst", his_kstp);
      326 
      327 /* verify dseg exists, is a segment, and has brackets 0, 0, 0 */
      328 
      329 	call initiate_r0_seg ("template_dseg", his_dsegp);
      330 
      331 /* verify modify permission on containing directory */
      332 
      333 	call fs_modes ((my_kstp -> kst.kst_entry (bin (baseno (his_kstp))).entryp), mode, exmode, rings, code);
      334 	if code ^= 0 then call abort_delete (code);
      335 						/* UNCOMMENT WHEN FS_GET FIXED
      336*						   if level > rings (2) then call abort_delete (0);
      337*						   */
      338 	if (mode & M_ACCESS) ^= M_ACCESS then call abort_delete (0);
      339 
      340 /* validate that this is a template kst */
      341 
      342 	if ^his_kstp -> kst.template then call abort_delete (0);
      343 
      344 /* okay lets do it */
      345 
      346 	call delete_r0_seg (his_kstp, "template_kst");
      347 	call delete_r0_seg (his_dsegp, "template_dseg");
      348 	call level$set (level);
      349 	return;
      350 
      351 initiate_r0_seg: proc (ename, segptr);
      352 dcl  ename char (*),
      353      segptr ptr;
      354 	     call initiate (dirname, ename, "", 0, 0, segptr, code);
      355 	     if segptr = null () then call abort_delete (code);
      356 	     if my_kstp -> kst.kst_entry (bin (baseno (segptr))).dirsw
      357 	     then call abort_delete (0);
      358 	     call fs_modes (segptr, mode, exmode, rings, code);
      359 	     if code ^= 0 then call abort_delete (code);
      360 	     if rings (1) ^= 0 | rings (2) ^= 0 | rings (3) ^= 0
      361 	     then call abort_delete (0);		/* tut, tut */
      362 	     return;
      363 	end initiate_r0_seg;
      364 
      365 delete_r0_seg: proc (segptr, ename);
      366 dcl  segptr ptr,
      367      ename char (*);
      368 	     call delentry$dseg (segptr, code);
      369 	     if code ^= 0
      370 	     then do;
      371 		call set$safety_sw_path (dirname, ename, "0"b, (0));
      372 		call set$copysw (dirname, ename, 0, (0));
      373 		call delentry$dseg (segptr, code);
      374 		if code ^= 0 then call abort_delete (code);
      375 	     end;
      376 	     segptr = null ();
      377 	     return;
      378 	end delete_r0_seg;
      379 
      380 abort_delete: proc (code);
      381 dcl  code fixed bin (35);
      382 	     if his_kstp ^= null () then call terminate_$noname (his_kstp, (0));
      383 	     if his_dsegp ^= null () then call terminate_$noname (his_dsegp, (0));
      384 	     call level$set (level);
      385 	     if code = 0
      386 	     then a_code = error_table_$action_not_performed;
      387 	     else a_code = code;
      388 	     go to return_to_caller;
      389 	end abort_delete;
      390 
      391 return_to_caller:
      392 	return;
      393 /*
      394*   
      395**/
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      396 
      397 /*
      398*   
      399**/
  2     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      400 
      401 /*
      402*   
      403**/
  3     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  3     2 
  3     3 /*
  3     4*Modified March 1976 by R. Bratt 
  3     5*Modified November 1984 to remove hdr, Keith Loepere. */
  3     6 
  3     7 
  3     8 /****^  HISTORY COMMENTS:
  3     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  3    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  3    11*     Add warning on use of kste.entryp.
  3    12*                                                   END HISTORY COMMENTS */
  3    13 
  3    14 
  3    15 dcl  pds$kstp ext ptr,
  3    16     (kstp, kstep) ptr;
  3    17 
  3    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  3    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  3    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  3    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  3    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  3    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  3    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  3    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  3    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  3    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  3    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  3    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  3    30     2 unused_2 bit (9) unaligned,
  3    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  3    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  3    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  3    34     2 end_of_kst bit (36);
  3    35 
  3    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  3    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  3    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  3    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  3    40     2 entryp ptr unaligned,				/* branch pointer */
  3    41 						/* See WARNING below for requirements to use entryp. */
  3    42     2 uid bit (36) aligned,				/* unique identifier */
  3    43     2 access_information unaligned,
  3    44       3 dtbm bit (36),				/* date time branch modified */
  3    45       3 extended_access bit (33),			/* extended access from the branch */
  3    46       3 access bit (3),				/* rew */
  3    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  3    48     2 pad1 bit (3) unaligned,
  3    49     2 flags unaligned,
  3    50       3 dirsw bit (1),				/* directory switch */
  3    51       3 allow_write bit (1),				/* set if initiated with write permission */
  3    52       3 priv_init bit (1),				/* privileged initiation */
  3    53       3 tms bit (1),				/* transparent modification switch */
  3    54       3 tus bit (1),				/* transparent usage switch */
  3    55       3 tpd bit (1),				/* transparent paging device switch */
  3    56       3 audit bit (1),				/* audit switch */
  3    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  3    58       3 pad bit (3),
  3    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  3    60 
  3    61 
  3    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    63 /*							       */
  3    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  3    65 /* entry associated with the kst entry, you must first validate its value    */
  3    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  3    67 /* the containing directory.  The containing directory must remain locked    */
  3    68 /* during the entire period when kste.entryp and the directory entry are     */
  3    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  3    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  3    71 /* directory since the dir entry could have been moved within the directory  */
  3    72 /* by another processor.					       */
  3    73 /*							       */
  3    74 /* If you only need a pointer to the directory containing the associated     */
  3    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  3    76 /*    pointer (kste.entryp, 0)				       */
  3    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  3    78 /*							       */
  3    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    80 
  3    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      404 
      405 /*
      406*   
      407**/
  4     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  4     2 
  4     3 dcl  sdwp ptr;
  4     4 
  4     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  4     6 
  4     7    (2 add bit (24),					/* main memory address of page table */
  4     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  4     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  4    10     2 df_no bit (2),				/* directed fault number */
  4    11 
  4    12     2 pad1 bit (1),
  4    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  4    14     2 access,					/* access bits */
  4    15       3 read bit (1),				/* read permission bit */
  4    16       3 execute bit (1),				/* execute permission bit */
  4    17       3 write bit (1),				/* write permission bit */
  4    18       3 privileged bit (1),				/* privileged bit */
  4    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  4    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  4    21     2 cache bit (1),				/* cache enable bit */
  4    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  4    23 
  4    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  4    25 
  4    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      408 
      409 
      410      end template_address_space;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1120.7  template_address_space.pl1        >udd>sm>ds>w>ml>template_address_space.pl1
396          1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
400          2    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>incl>dir_entry.incl.pl1
404          3    09/18/86  1408.1  kst.incl.pl1                      >ldd>incl>kst.incl.pl1
408          4    09/14/76  0859.8  sdw.incl.pl1                      >ldd>incl>sdw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
M_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 338 338
R_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 147 147
a_access_calculated                    parameter       fixed bin(17,0)          dcl 75 set ref 125 128* 263*
a_code                                 parameter       fixed bin(35,0)          dcl 75 set ref 125 129* 303* 305* 313 316* 385* 387*
a_dirname                              parameter       char                     packed unaligned dcl 75 ref 125 127 313 315
acc_list_$match                 000020 constant        entry                    external dcl 105 ref 274
access_calculated               000100 automatic       fixed bin(17,0)          dcl 78 set ref 131* 263 281* 281
access_information        5            based           structure                level 2 packed packed unaligned dcl 3-36 set ref
                                                                                  195* 282* 282
acl$areplace                    000022 constant        entry                    external dcl 105 ref 248 255
acl_frp                  36            based           bit(18)                  level 2 packed packed unaligned dcl 2-8 set ref 274
                                                                                  274
acle_count               35(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-8 ref 272 274
active_all_rings_data$max_segno 000014 external static fixed bin(17,0)          dcl 101 ref 178
addr                                                   builtin function         dcl 123 ref 134 182 192 204 248 248 255 255 274 274
                                                                                  274 274
all_access                      000233 automatic       structure                level 1 dcl 96 set ref 248 248 255 255
allow_write               7(13)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  234*
append$branch                   000024 constant        entry                    external dcl 105 ref 152 160
baseno                                                 builtin function         dcl 123 ref 143 224 225 333 356
baseptr                                                builtin function         dcl 123 ref 270 270 278 278
bc                              000202 automatic       fixed bin(24,0)          dcl 78 set ref 141* 168 168 182 253*
bin                                                    builtin function         dcl 123 ref 182 224 225 333 356
code                                   parameter       fixed bin(35,0)          dcl 297 in procedure "abort_create" ref 296 303 305
code                            000204 automatic       fixed bin(35,0)          dcl 78 in procedure "template_address_space" set ref
                                                                                  141* 142* 145* 146 146* 152* 153 153* 155* 156
                                                                                  156* 160* 161 161* 163* 164* 246* 247 247* 248*
                                                                                  249 249* 253* 254 254* 255* 256 256* 270* 271 274*
                                                                                  276 278* 279 333* 334 334* 354* 355* 358* 359 359*
                                                                                  368* 369 373* 374 374*
code                                   parameter       fixed bin(35,0)          dcl 381 in procedure "abort_delete" ref 380 385 387
copy_kst                               based           bit                      dcl 90 set ref 168* 168
created_dseg                    000102 automatic       bit(1)                   dcl 78 set ref 132* 162* 298
created_kst                     000101 automatic       bit(1)                   dcl 78 set ref 132* 154* 300
delentry$dfile                  000026 constant        entry                    external dcl 105 ref 298 300
delentry$dseg                   000030 constant        entry                    external dcl 105 ref 368 373
dirname                         000103 automatic       char(168)                packed unaligned dcl 78 set ref 127* 141* 152* 155*
                                                                                  160* 163* 248* 255* 298* 300* 315* 354* 371* 372*
dirsw                   117(12)        based           bit(1)                   array level 4 in structure "kst" packed packed
                                                                                  unaligned dcl 3-18 in procedure
                                                                                  "template_address_space" set ref 143 356
dirsw                     7(12)        based           bit(1)                   level 3 in structure "kste" packed packed unaligned
                                                                                  dcl 3-36 in procedure "template_address_space" set
                                                                                  ref 233 233*
dseg$                           000016 external static fixed bin(17,0)          dcl 101 set ref 134
dtbm                      5            based           bit(36)                  level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  198*
dummy_rings                     000264 automatic       fixed bin(3,0)           array dcl 268 set ref 278*
ename                                  parameter       char                     packed unaligned dcl 352 in procedure
                                                                                  "initiate_r0_seg" set ref 351 354*
ename                                  parameter       char                     packed unaligned dcl 366 in procedure
                                                                                  "delete_r0_seg" set ref 365 371* 372*
entry                                  based           structure                level 1 dcl 2-8
entryp                  113            based           pointer                  array level 3 in structure "kst" packed packed
                                                                                  unaligned dcl 3-18 in procedure
                                                                                  "template_address_space" set ref 333
entryp                    3            based           pointer                  level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 3-36 in procedure "template_address_space" set
                                                                                  ref 208* 222 224 225 227* 227 227 230
ep                              000246 automatic       pointer                  dcl 2-6 set ref 270* 272 274 274 274 274 292 292
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 101 ref 303 385
exmode                          000156 automatic       bit(36)                  dcl 78 set ref 145* 333* 358*
fixed                                                  builtin function         dcl 123 ref 143
flags                   117(12)        based           structure                array level 3 in structure "kst" packed packed
                                                                                  unaligned dcl 3-18 in procedure
                                                                                  "template_address_space"
flags                     7(12)        based           structure                level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 3-36 in procedure "template_address_space" set
                                                                                  ref 196*
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 3-36 set ref
                                                                                  194* 209* 212* 219*
free_list                 7            based           bit(18)                  level 2 packed packed unaligned dcl 3-18 set ref
                                                                                  189* 212 213*
fs_modes                        000032 constant        entry                    external dcl 105 ref 145 278 333 358
hash_class                      000203 automatic       fixed bin(17,0)          dcl 78 set ref 217* 219 220
highest_used_segno        2            based           fixed bin(17,0)          level 2 dcl 3-18 ref 180 182 191 203 246
highseg                   1            based           fixed bin(17,0)          level 2 dcl 3-18 ref 178
his_dsegp                       000172 automatic       pointer                  dcl 78 set ref 133* 163* 164 246* 261* 283 284 285
                                                                                  286 287 288 319* 329* 347* 383 383*
his_kstep                       000176 automatic       pointer                  dcl 78 set ref 192* 193 194 195 196 197 198 204* 205
                                                                                  207 208 209 212 213 217 219 220 222 224 227 227
                                                                                  233 233 234 235 282
his_kstp                        000174 automatic       pointer                  dcl 78 set ref 133* 155* 168 169 174 176 178 180 180
                                                                                  182 182 184 189 190 191 191 192 203 203 204 209
                                                                                  212 213 219 220 225 228 228 242 246 253* 260* 319*
                                                                                  325* 333 342 346* 382 382*
infcount                117(23)        based           fixed bin(12,0)          array level 3 in structure "kst" packed packed
                                                                                  unaligned dcl 3-18 in procedure
                                                                                  "template_address_space" set ref 228* 228
infcount                  7(23)        based           fixed bin(12,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 3-36 in procedure "template_address_space" set
                                                                                  ref 197*
initiate                        000034 constant        entry                    external dcl 105 ref 155 163 354
initiate$initiate_count         000036 constant        entry                    external dcl 105 ref 141
input_kstp                      000200 automatic       pointer                  dcl 78 set ref 141* 142 143 145* 168 170*
kst                                    based           structure                level 1 dcl 3-18
kst_entry               110            based           structure                array level 2 dcl 3-18 set ref 182 192 204
kste                                   based           structure                level 1 dcl 3-36
kstsrch                         000040 constant        entry                    external dcl 105 ref 217
level                           000163 automatic       fixed bin(3,0)           dcl 78 set ref 136* 147 184 235 262* 302* 320* 348*
                                                                                  384*
level$get                       000042 constant        entry                    external dcl 105 ref 136 320
level$set                       000044 constant        entry                    external dcl 105 ref 137 262 302 321 348 384
lock$dir_unlock                 000046 constant        entry                    external dcl 105 ref 292
lowseg                                 based           fixed bin(17,0)          level 2 dcl 3-18 ref 143 176 176 180 182 191 192 203
                                                                                  204 209 225 225 228 228 333 356
mbz                      11     000233 automatic       bit(36)                  initial level 2 dcl 96 set ref 96*
mode                            000155 automatic       bit(36)                  dcl 78 set ref 145* 147 333* 338 358*
modes                    10     000233 automatic       bit(36)                  initial level 2 dcl 96 set ref 96*
my_dsegp                        000170 automatic       pointer                  dcl 78 set ref 134* 283 284 285 286 287 288
my_kstep                        000166 automatic       pointer                  dcl 78 set ref 217* 218 221 225 227 230 233 282
my_kstp                         000164 automatic       pointer                  dcl 78 set ref 135* 143 176 225 318* 333 356
name                            000233 automatic       char(32)                 initial level 2 dcl 96 set ref 96*
null                                                   builtin function         dcl 123 ref 133 142 164 218 222 230 274 319 355 376
                                                                                  382 383
parent_slotx                    000206 automatic       fixed bin(17,0)          dcl 78 set ref 224* 225 228 228
pds$kstp                        000062 external static pointer                  dcl 3-15 ref 135 318
pers_name                       000210 automatic       char(32)                 initial level 2 dcl 91 set ref 91*
prelinked_ring            7(18)        based           bit(1)                   array level 2 packed packed unaligned dcl 3-18 ref
                                                                                  184
proj_name                10     000210 automatic       char(32)                 initial level 2 dcl 91 set ref 91*
ptr                                                    builtin function         dcl 123 ref 227 292 292
rel                                                    builtin function         dcl 123 ref 182 213 220 227
ring                            000157 automatic       fixed bin(3,0)           dcl 78 set ref 235* 235*
rings                           000160 automatic       fixed bin(3,0)           array dcl 78 set ref 145* 147 333* 358* 360 360 360
sdw                                    based           structure                level 1 dcl 4-5
sdwa                                   based           structure                array level 1 dcl 4-24
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 3-36 in procedure "template_address_space" set
                                                                                  ref 193* 221
segno                           000207 automatic       fixed bin(17,0)          dcl 78 in procedure "template_address_space" set ref
                                                                                  221* 270 270 278 278 283 284 285 286 287 288
segptr                                 parameter       pointer                  dcl 366 in procedure "delete_r0_seg" set ref 365
                                                                                  368* 373* 376*
segptr                                 parameter       pointer                  dcl 352 in procedure "initiate_r0_seg" set ref 351
                                                                                  354* 355 356 358*
set$bc_seg                      000050 constant        entry                    external dcl 105 ref 246 253
set$copysw                      000054 constant        entry                    external dcl 105 ref 372
set$safety_sw_path              000052 constant        entry                    external dcl 105 ref 371
slotx                           000205 automatic       fixed bin(17,0)          dcl 78 set ref 191* 192 193* 203* 204 209* 283 284
                                                                                  285 286 287 288
star_dot_star_dot_star          000210 automatic       structure                level 1 dcl 91 set ref 274 274
string                                                 builtin function         dcl 123 ref 184
substr                                                 builtin function         dcl 123 ref 184
sum$getbranch                   000056 constant        entry                    external dcl 105 ref 270
sys_info$time_of_bootload       000012 external static fixed bin(71,0)          dcl 101 ref 174
tag                      20     000210 automatic       char(1)                  initial level 2 dcl 91 set ref 91*
template                  7(25)        based           bit(1)                   level 2 packed packed unaligned dcl 3-18 set ref
                                                                                  169* 242* 342
terminate_$noname               000060 constant        entry                    external dcl 105 ref 170 260 261 382 383
time_of_bootload          4            based           fixed bin(71,0)          level 2 dcl 3-18 ref 174
tms                       7(15)        based           bit(1)                   level 3 packed packed unaligned dcl 3-36 set ref
                                                                                  233*
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 3-36 in procedure
                                                                                  "template_address_space" set ref 205 217*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "template_address_space" set ref 274*
uid                     114            based           bit(36)                  array level 3 in structure "kst" dcl 3-18
                                                                                  in procedure "template_address_space" set ref 225
                                                                                  225
uid_hash_bucket          10            based           bit(18)                  array level 2 packed packed unaligned dcl 3-18 set
                                                                                  ref 190* 219 220*
unspec                                                 builtin function         dcl 123 set ref 190* 195* 196* 208*
usage_count               1            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 3-36 set
                                                                                  ref 207* 235

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
kstep                                  automatic       pointer                  dcl 3-15
kstp                                   automatic       pointer                  dcl 3-15
sdwp                                   automatic       pointer                  dcl 4-3

NAMES DECLARED BY EXPLICIT CONTEXT.
abort_create                    002101 constant        entry                    internal dcl 296 ref 142 143 146 147 153 156 161 164
                                                                                  174 176 178 180 182 184 218 225 230 247 249 254
                                                                                  256
abort_delete                    002511 constant        entry                    internal dcl 380 ref 334 338 342 355 356 359 360 374
create                          000072 constant        entry                    external dcl 125
delete                          001467 constant        entry                    external dcl 313
delete_r0_seg                   002357 constant        entry                    internal dcl 365 ref 346 347
initiate_r0_seg                 002205 constant        entry                    internal dcl 351 ref 325 329
return_to_caller                001673 constant        label                    dcl 391 ref 306 388
set_access                      001674 constant        entry                    internal dcl 266 ref 232
template_address_space          000057 constant        entry                    external dcl 13

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3156        3242    2663        3166
Length      3552    2663        64         274     273           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
template_address_space              380 external procedure  is an external procedure.  
set_access                              internal procedure  shares stack frame of external procedure template_address_space.  
abort_create                            internal procedure  shares stack frame of external procedure template_address_space.  
initiate_r0_seg                         internal procedure  shares stack frame of external procedure template_address_space.  
delete_r0_seg                           internal procedure  shares stack frame of external procedure template_address_space.  
abort_delete                            internal procedure  shares stack frame of external procedure template_address_space.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
template_address_space   000100 access_calculated           template_address_space
                         000101 created_kst                 template_address_space
                         000102 created_dseg                template_address_space
                         000103 dirname                     template_address_space
                         000155 mode                        template_address_space
                         000156 exmode                      template_address_space
                         000157 ring                        template_address_space
                         000160 rings                       template_address_space
                         000163 level                       template_address_space
                         000164 my_kstp                     template_address_space
                         000166 my_kstep                    template_address_space
                         000170 my_dsegp                    template_address_space
                         000172 his_dsegp                   template_address_space
                         000174 his_kstp                    template_address_space
                         000176 his_kstep                   template_address_space
                         000200 input_kstp                  template_address_space
                         000202 bc                          template_address_space
                         000203 hash_class                  template_address_space
                         000204 code                        template_address_space
                         000205 slotx                       template_address_space
                         000206 parent_slotx                template_address_space
                         000207 segno                       template_address_space
                         000210 star_dot_star_dot_star      template_address_space
                         000233 all_access                  template_address_space
                         000246 ep                          template_address_space
                         000264 dummy_rings                 set_access

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mpfx2               ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_list_$match               acl$areplace                  append$branch                 delentry$dfile
delentry$dseg                 fs_modes                      initiate                      initiate$initiate_count
kstsrch                       level$get                     level$set                     lock$dir_unlock
set$bc_seg                    set$copysw                    set$safety_sw_path            sum$getbranch
terminate_$noname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data$max_segno                             dseg$
error_table_$action_not_performed                           pds$kstp                      sys_info$time_of_bootload


CONSTANTS
002570  aa     000002000000
002571  aa     000000000000
002572  aa     600000000041
002573  aa     000467000000

002574  aa     000004000000
002575  aa     000004000000
002576  aa     600000000041
002577  aa     000172000000
002600  aa     600000000041
002601  aa     000324000000
002602  ta     000005000000
002603  aa     000000000000
002604  ta     000001000000
002605  aa     000000000000

002606  aa     000004000000
002607  aa     000004000000
002610  aa     600000000041
002611  aa     000174000000
002612  aa     600000000041
002613  aa     000324000000
002614  ta     000005000000
002615  aa     000000000000
002616  ta     000004000000
002617  aa     000000000000

002620  aa     000004000000
002621  aa     000004000000
002622  aa     600000000041
002623  aa     000324000000
002624  aa     600000000041
002625  aa     000172000000
002626  ta     000001000000
002627  aa     000000000000
002630  ta     000005000000
002631  aa     000000000000

002632  aa     000004000000
002633  aa     000004000000
002634  aa     600000000041
002635  aa     000324000000
002636  aa     600000000041
002637  aa     000174000000
002640  ta     000004000000
002641  aa     000000000000
002642  ta     000005000000
002643  aa     000000000000

002644  aa     007777000001

002645  aa     777700017777

002646  aa     777777775777

002650  aa     000002000000
002651  aa     000000000000
002652  aa     600000000041
002653  aa     000331000000

002654  aa     000002000000
002655  aa     000000000000
002656  aa     600000000041
002657  aa     000204000000

002660  aa  052 000 000 000	*

000000  aa     514000000001

002662  aa     777777777777

000001  aa     524000000015

000002  aa     404000000001

000003  aa     404000000005

000004  aa     524000000014

000005  aa     464000000000

000006  aa     404000000002

000007  aa     404000000030

000010  aa     524000000000

000011  aa     524000000007

000012  aa     526000000250

002661  aa     000000000000

000013  aa     404000000003

000014  aa     404000000043

000015  aa     404000000021

000016  aa     526077777777

000020  aa  052 056 052 056	*.*.
000021  aa  052 000 000 000	*

000022  aa  153 163 164 137	kst_
000023  aa  163 145 147 000	seg

000024  aa     077777000043
000025  aa     000001000000

000026  aa  164 145 155 160	temp
000027  aa  154 141 164 145	late
000030  aa  137 153 163 164	_kst

000031  aa  164 145 155 160	temp
000032  aa  154 141 164 145	late
000033  aa  137 144 163 145	_dse
000034  aa  147 000 000 000	g

BEGIN PROCEDURE template_address_space
PROLOGUE SEQUENCE
000035  aa  6 00320 4401 00	sxl0 	pr6|208
						STATEMENT 1 ON LINE 91
000036  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000037  aa   002622 00 0001	desc9a	1426,1		002660 = 052000000000
000040  aa  6 00210 00 0040	desc9a	pr6|136,32	star_dot_star_dot_star.pers_name
000041  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000042  aa   002617 00 0001	desc9a	1423,1		002660 = 052000000000
000043  aa  6 00220 00 0040	desc9a	pr6|144,32	star_dot_star_dot_star.proj_name
000044  aa   052000 2350 03	lda  	21504,du
000045  aa  6 00230 7551 00	sta  	pr6|152		star_dot_star_dot_star.tag
						STATEMENT 1 ON LINE 96
000046  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000047  aa   777752 00 0005	desc9a	-22,5		000020 = 052056052056
000050  aa  6 00233 00 0040	desc9a	pr6|155,32	all_access.name
000051  aa   200000 2350 03	lda  	65536,du
000052  aa  6 00243 7551 00	sta  	pr6|163		all_access.modes
000053  aa  6 00244 4501 00	stz  	pr6|164		all_access.mbz
000054  aa  6 00320 7201 00	lxl0 	pr6|208
000055  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO template_address_space                             STATEMENT 1 ON LINE 13
template_address_space: proc ();

000056  da     000255200000
000057  aa   000600 6270 00	eax7 	384
000060  aa  7 00034 3521 20	epp2 	pr7|28,*
000061  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000062  aa     000000000000
000063  aa     000000000000
000064  aa   777751 7000 04	tsx0 	-23,ic		000035
						STATEMENT 1 ON LINE 125
create:	entry (a_dirname, a_access_calculated, a_code);

000065  aa   000024 7100 04	tra  	20,ic		000111
ENTRY TO create                                             STATEMENT 1 ON LINE 125
create:	entry (a_dirname, a_access_calculated, a_code);

000066  at     000003000016
000067  tt     000015000014
000070  ta     000066000000
000071  da     000262300000
000072  aa   000600 6270 00	eax7 	384
000073  aa  7 00034 3521 20	epp2 	pr7|28,*
000074  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000075  aa     000006000000
000076  aa     000000000000
000077  aa  6 00042 3735 20	epp7 	pr6|34,*
000100  aa  7 00000 2361 20	ldq  	pr7|0,*
000101  aa   000002 6040 04	tmi  	2,ic		000103
000102  aa   777777 3760 07	anq  	262143,dl
000103  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000104  aa  6 00321 7561 00	stq  	pr6|209
000105  aa  6 00032 3715 20	epp5 	pr6|26,*
000106  aa  5 00006 3535 20	epp3 	pr5|6,*
000107  aa  6 00250 2535 00	spri3	pr6|168
000110  aa   777725 7000 04	tsx0 	-43,ic		000035
						STATEMENT 1 ON LINE 127
	dirname = a_dirname;

000111  aa  6 00032 3735 20	epp7 	pr6|26,*
000112  aa  7 00002 3715 20	epp5 	pr7|2,*
000113  aa  6 00321 2351 00	lda  	pr6|209
000114  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000115  aa  5 00000 00 0005	desc9a	pr5|0,al		a_dirname
000116  aa  6 00103 00 0250	desc9a	pr6|67,168	dirname
						STATEMENT 1 ON LINE 128
	a_access_calculated = 0;

000117  aa  7 00004 4501 20	stz  	pr7|4,*		a_access_calculated
						STATEMENT 1 ON LINE 129
	a_code = 0;

000120  aa  6 00250 4501 20	stz  	pr6|168,*		a_code
						STATEMENT 1 ON LINE 131
	access_calculated = 0;

000121  aa  6 00100 4501 00	stz  	pr6|64		access_calculated
						STATEMENT 1 ON LINE 132
	created_kst, created_dseg = "0"b;

000122  aa  6 00101 4501 00	stz  	pr6|65		created_kst
000123  aa  6 00102 4501 00	stz  	pr6|66		created_dseg
						STATEMENT 1 ON LINE 133
	his_kstp, his_dsegp = null ();

000124  aa   777700 3534 24	epp3 	-64,ic*
000125  aa  6 00174 2535 00	spri3	pr6|124		his_kstp
000126  aa  6 00172 2535 00	spri3	pr6|122		his_dsegp
						STATEMENT 1 ON LINE 134
	my_dsegp = addr (dseg$);

000127  aa  6 00044 3701 20	epp4 	pr6|36,*
000130  la  4 00016 3515 20	epp1 	pr4|14,*		dseg$
000131  aa  6 00170 2515 00	spri1	pr6|120		my_dsegp
						STATEMENT 1 ON LINE 135
	my_kstp = pds$kstp;

000132  la  4 00062 3715 20	epp5 	pr4|50,*		pds$kstp
000133  aa  5 00000 3715 20	epp5 	pr5|0,*		pds$kstp
000134  aa  6 00164 6515 00	spri5	pr6|116		my_kstp
						STATEMENT 1 ON LINE 136
	level = level$get ();

000135  aa  6 00163 3521 00	epp2 	pr6|115		level
000136  aa  6 00326 2521 00	spri2	pr6|214
000137  aa  6 00324 6211 00	eax1 	pr6|212
000140  aa   004000 4310 07	fld  	2048,dl
000141  la  4 00042 3521 20	epp2 	pr4|34,*		level$get
000142  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 137
	call level$set (0);

000143  aa  6 00330 4501 00	stz  	pr6|216
000144  aa  6 00330 3521 00	epp2 	pr6|216
000145  aa  6 00326 2521 00	spri2	pr6|214
000146  aa  6 00324 6211 00	eax1 	pr6|212
000147  aa   004000 4310 07	fld  	2048,dl
000150  aa  6 00044 3701 20	epp4 	pr6|36,*
000151  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
000152  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 141
	call initiate$initiate_count (dirname, "kst_seg", "", bc, 0, input_kstp, code);

000153  aa   777647 2370 04	ldaq 	-89,ic		000022 = 153163164137 163145147000
000154  aa  6 00322 7571 00	staq 	pr6|210
000155  aa  6 00331 4501 00	stz  	pr6|217
000156  aa  6 00103 3521 00	epp2 	pr6|67		dirname
000157  aa  6 00334 2521 00	spri2	pr6|220
000160  aa  6 00322 3521 00	epp2 	pr6|210
000161  aa  6 00336 2521 00	spri2	pr6|222
000162  aa  6 00330 3521 00	epp2 	pr6|216
000163  aa  6 00340 2521 00	spri2	pr6|224
000164  aa  6 00202 3521 00	epp2 	pr6|130		bc
000165  aa  6 00342 2521 00	spri2	pr6|226
000166  aa  6 00331 3521 00	epp2 	pr6|217
000167  aa  6 00344 2521 00	spri2	pr6|228
000170  aa  6 00200 3521 00	epp2 	pr6|128		input_kstp
000171  aa  6 00346 2521 00	spri2	pr6|230
000172  aa  6 00204 3521 00	epp2 	pr6|132		code
000173  aa  6 00350 2521 00	spri2	pr6|232
000174  aa   777616 3520 04	epp2 	-114,ic		000012 = 526000000250
000175  aa  6 00352 2521 00	spri2	pr6|234
000176  aa   777613 3520 04	epp2 	-117,ic		000011 = 524000000007
000177  aa  6 00354 2521 00	spri2	pr6|236
000200  aa   777610 3520 04	epp2 	-120,ic		000010 = 524000000000
000201  aa  6 00356 2521 00	spri2	pr6|238
000202  aa   777605 3520 04	epp2 	-123,ic		000007 = 404000000030
000203  aa  6 00360 2521 00	spri2	pr6|240
000204  aa   777602 3520 04	epp2 	-126,ic		000006 = 404000000002
000205  aa  6 00362 2521 00	spri2	pr6|242
000206  aa   777577 3520 04	epp2 	-129,ic		000005 = 464000000000
000207  aa  6 00364 2521 00	spri2	pr6|244
000210  aa   777604 3520 04	epp2 	-124,ic		000014 = 404000000043
000211  aa  6 00366 2521 00	spri2	pr6|246
000212  aa  6 00332 6211 00	eax1 	pr6|218
000213  aa   034000 4310 07	fld  	14336,dl
000214  aa  6 00044 3701 20	epp4 	pr6|36,*
000215  la  4 00036 3521 20	epp2 	pr4|30,*		initiate$initiate_count
000216  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 142
	if input_kstp = null () then call abort_create (code);

000217  aa  6 00200 2371 00	ldaq 	pr6|128		input_kstp
000220  aa   777604 6770 04	eraq 	-124,ic		000024 = 077777000043 000001000000
000221  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000222  aa   000003 6010 04	tnz  	3,ic		000225
000223  aa   002431 3520 04	epp2 	1305,ic		002654 = 000002000000
000224  aa   001655 6700 04	tsp4 	941,ic		002101
						STATEMENT 1 ON LINE 143
	if my_kstp -> kst.kst_entry (fixed (baseno (input_kstp))).dirsw
	then call abort_create (0);

000225  aa  6 00164 2361 20	ldq  	pr6|116,*		kst.lowseg
000226  aa   000003 7360 00	qls  	3
000227  aa  6 00331 7561 00	stq  	pr6|217
000230  aa  6 00200 2131 20	epaq 	pr6|128,*		input_kstp
000231  aa   077777 3750 03	ana  	32767,du
000232  aa   000066 7730 00	lrl  	54
000233  aa  6 00322 7571 00	staq 	pr6|210
000234  aa   000010 2360 07	ldq  	8,dl
000235  aa  6 00322 3521 00	epp2 	pr6|210
000236  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
000237  aa   000000 5330 00	negl 	0
000240  aa  6 00331 0331 00	adl  	pr6|217
000241  aa   000000 5330 00	negl 	0
000242  aa  6 00164 3735 20	epp7 	pr6|116,*		my_kstp
000243  aa  7 00117 2351 06	lda  	pr7|79,ql		kst.dirsw
000244  aa   000040 3150 03	cana 	32,du
000245  aa   000004 6000 04	tze  	4,ic		000251
000246  aa  6 00331 4501 00	stz  	pr6|217
000247  aa   002401 3520 04	epp2 	1281,ic		002650 = 000002000000
000250  aa   001631 6700 04	tsp4 	921,ic		002101
						STATEMENT 1 ON LINE 145
	call fs_modes (input_kstp, mode, exmode, rings, code);

000251  aa  6 00200 3521 00	epp2 	pr6|128		input_kstp
000252  aa  6 00334 2521 00	spri2	pr6|220
000253  aa  6 00155 3521 00	epp2 	pr6|109		mode
000254  aa  6 00336 2521 00	spri2	pr6|222
000255  aa  6 00156 3521 00	epp2 	pr6|110		exmode
000256  aa  6 00340 2521 00	spri2	pr6|224
000257  aa  6 00160 3521 00	epp2 	pr6|112		rings
000260  aa  6 00342 2521 00	spri2	pr6|226
000261  aa  6 00204 3521 00	epp2 	pr6|132		code
000262  aa  6 00344 2521 00	spri2	pr6|228
000263  aa  6 00332 6211 00	eax1 	pr6|218
000264  aa   024000 4310 07	fld  	10240,dl
000265  aa  6 00044 3701 20	epp4 	pr6|36,*
000266  la  4 00032 3521 20	epp2 	pr4|26,*		fs_modes
000267  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 146
	if code ^= 0 then call abort_create (code);

000270  aa  6 00204 2361 00	ldq  	pr6|132		code
000271  aa   000003 6000 04	tze  	3,ic		000274
000272  aa   002362 3520 04	epp2 	1266,ic		002654 = 000002000000
000273  aa   001606 6700 04	tsp4 	902,ic		002101
						STATEMENT 1 ON LINE 147
	if (mode & R_ACCESS) ^= R_ACCESS | level > rings (2)
	then call abort_create (0);

000274  aa  6 00155 2351 00	lda  	pr6|109		mode
000275  aa   400000 3750 03	ana  	131072,du
000276  aa   400000 1150 03	cmpa 	131072,du
000277  aa   000004 6010 04	tnz  	4,ic		000303
000300  aa  6 00163 2361 00	ldq  	pr6|115		level
000301  aa  6 00161 1161 00	cmpq 	pr6|113		rings
000302  aa   000004 6044 04	tmoz 	4,ic		000306
000303  aa  6 00331 4501 00	stz  	pr6|217
000304  aa   002344 3520 04	epp2 	1252,ic		002650 = 000002000000
000305  aa   001574 6700 04	tsp4 	892,ic		002101
						STATEMENT 1 ON LINE 152
	call append$branch (dirname, "template_kst", 01010b, code);

000306  aa   777520 2370 04	ldaq 	-176,ic		000026 = 164145155160 154141164145
000307  aa  6 00324 7571 00	staq 	pr6|212
000310  aa   777520 2350 04	lda  	-176,ic		000030 = 137153163164
000311  aa  6 00326 7551 00	sta  	pr6|214
000312  aa   000012 2360 07	ldq  	10,dl
000313  aa  6 00331 7561 00	stq  	pr6|217
000314  aa  6 00103 3521 00	epp2 	pr6|67		dirname
000315  aa  6 00334 2521 00	spri2	pr6|220
000316  aa  6 00324 3521 00	epp2 	pr6|212
000317  aa  6 00336 2521 00	spri2	pr6|222
000320  aa  6 00331 3521 00	epp2 	pr6|217
000321  aa  6 00340 2521 00	spri2	pr6|224
000322  aa  6 00204 3521 00	epp2 	pr6|132		code
000323  aa  6 00342 2521 00	spri2	pr6|226
000324  aa   777466 3520 04	epp2 	-202,ic		000012 = 526000000250
000325  aa  6 00344 2521 00	spri2	pr6|228
000326  aa   777456 3520 04	epp2 	-210,ic		000004 = 524000000014
000327  aa  6 00346 2521 00	spri2	pr6|230
000330  aa   777453 3520 04	epp2 	-213,ic		000003 = 404000000005
000331  aa  6 00350 2521 00	spri2	pr6|232
000332  aa   777462 3520 04	epp2 	-206,ic		000014 = 404000000043
000333  aa  6 00352 2521 00	spri2	pr6|234
000334  aa  6 00332 6211 00	eax1 	pr6|218
000335  aa   020000 4310 07	fld  	8192,dl
000336  aa  6 00044 3701 20	epp4 	pr6|36,*
000337  la  4 00024 3521 20	epp2 	pr4|20,*		append$branch
000340  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 153
	if code ^= 0 then call abort_create (code);

000341  aa  6 00204 2361 00	ldq  	pr6|132		code
000342  aa   000003 6000 04	tze  	3,ic		000345
000343  aa   002311 3520 04	epp2 	1225,ic		002654 = 000002000000
000344  aa   001535 6700 04	tsp4 	861,ic		002101
						STATEMENT 1 ON LINE 154
	created_kst = "1"b;

000345  aa   400000 2350 03	lda  	131072,du
000346  aa  6 00101 7551 00	sta  	pr6|65		created_kst
						STATEMENT 1 ON LINE 155
	call initiate (dirname, "template_kst", "", 0, 0, his_kstp, code);

000347  aa   777457 2370 04	ldaq 	-209,ic		000026 = 164145155160 154141164145
000350  aa  6 00324 7571 00	staq 	pr6|212
000351  aa   777457 2350 04	lda  	-209,ic		000030 = 137153163164
000352  aa  6 00326 7551 00	sta  	pr6|214
000353  aa  6 00330 4501 00	stz  	pr6|216
000354  aa  6 00370 4501 00	stz  	pr6|248
000355  aa  6 00103 3521 00	epp2 	pr6|67		dirname
000356  aa  6 00334 2521 00	spri2	pr6|220
000357  aa  6 00324 3521 00	epp2 	pr6|212
000360  aa  6 00336 2521 00	spri2	pr6|222
000361  aa  6 00331 3521 00	epp2 	pr6|217
000362  aa  6 00340 2521 00	spri2	pr6|224
000363  aa  6 00330 3521 00	epp2 	pr6|216
000364  aa  6 00342 2521 00	spri2	pr6|226
000365  aa  6 00370 3521 00	epp2 	pr6|248
000366  aa  6 00344 2521 00	spri2	pr6|228
000367  aa  6 00174 3521 00	epp2 	pr6|124		his_kstp
000370  aa  6 00346 2521 00	spri2	pr6|230
000371  aa  6 00204 3521 00	epp2 	pr6|132		code
000372  aa  6 00350 2521 00	spri2	pr6|232
000373  aa   777417 3520 04	epp2 	-241,ic		000012 = 526000000250
000374  aa  6 00352 2521 00	spri2	pr6|234
000375  aa   777407 3520 04	epp2 	-249,ic		000004 = 524000000014
000376  aa  6 00354 2521 00	spri2	pr6|236
000377  aa   777411 3520 04	epp2 	-247,ic		000010 = 524000000000
000400  aa  6 00356 2521 00	spri2	pr6|238
000401  aa   777401 3520 04	epp2 	-255,ic		000002 = 404000000001
000402  aa  6 00360 2521 00	spri2	pr6|240
000403  aa   777403 3520 04	epp2 	-253,ic		000006 = 404000000002
000404  aa  6 00362 2521 00	spri2	pr6|242
000405  aa   777400 3520 04	epp2 	-256,ic		000005 = 464000000000
000406  aa  6 00364 2521 00	spri2	pr6|244
000407  aa   777405 3520 04	epp2 	-251,ic		000014 = 404000000043
000410  aa  6 00366 2521 00	spri2	pr6|246
000411  aa  6 00332 6211 00	eax1 	pr6|218
000412  aa   034000 4310 07	fld  	14336,dl
000413  aa  6 00044 3701 20	epp4 	pr6|36,*
000414  la  4 00034 3521 20	epp2 	pr4|28,*		initiate
000415  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 156
	if code ^= 0 then call abort_create (code);

000416  aa  6 00204 2361 00	ldq  	pr6|132		code
000417  aa   000003 6000 04	tze  	3,ic		000422
000420  aa   002234 3520 04	epp2 	1180,ic		002654 = 000002000000
000421  aa   001460 6700 04	tsp4 	816,ic		002101
						STATEMENT 1 ON LINE 160
	call append$branch (dirname, "template_dseg", 01010b, code);

000422  aa   777407 2350 04	lda  	-249,ic		000031 = 164145155160
000423  aa   777407 2360 04	ldq  	-249,ic		000032 = 154141164145
000424  aa  6 00324 7571 00	staq 	pr6|212
000425  aa   777406 2350 04	lda  	-250,ic		000033 = 137144163145
000426  aa   147000 2360 03	ldq  	52736,du
000427  aa  6 00326 7571 00	staq 	pr6|214
000430  aa   000012 2360 07	ldq  	10,dl
000431  aa  6 00370 7561 00	stq  	pr6|248
000432  aa  6 00103 3521 00	epp2 	pr6|67		dirname
000433  aa  6 00334 2521 00	spri2	pr6|220
000434  aa  6 00324 3521 00	epp2 	pr6|212
000435  aa  6 00336 2521 00	spri2	pr6|222
000436  aa  6 00370 3521 00	epp2 	pr6|248
000437  aa  6 00340 2521 00	spri2	pr6|224
000440  aa  6 00204 3521 00	epp2 	pr6|132		code
000441  aa  6 00342 2521 00	spri2	pr6|226
000442  aa   777350 3520 04	epp2 	-280,ic		000012 = 526000000250
000443  aa  6 00344 2521 00	spri2	pr6|228
000444  aa   777335 3520 04	epp2 	-291,ic		000001 = 524000000015
000445  aa  6 00346 2521 00	spri2	pr6|230
000446  aa   777335 3520 04	epp2 	-291,ic		000003 = 404000000005
000447  aa  6 00350 2521 00	spri2	pr6|232
000450  aa   777344 3520 04	epp2 	-284,ic		000014 = 404000000043
000451  aa  6 00352 2521 00	spri2	pr6|234
000452  aa  6 00332 6211 00	eax1 	pr6|218
000453  aa   020000 4310 07	fld  	8192,dl
000454  aa  6 00044 3701 20	epp4 	pr6|36,*
000455  la  4 00024 3521 20	epp2 	pr4|20,*		append$branch
000456  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 161
	if code ^= 0 then call abort_create (code);

000457  aa  6 00204 2361 00	ldq  	pr6|132		code
000460  aa   000003 6000 04	tze  	3,ic		000463
000461  aa   002173 3520 04	epp2 	1147,ic		002654 = 000002000000
000462  aa   001417 6700 04	tsp4 	783,ic		002101
						STATEMENT 1 ON LINE 162
	created_dseg = "1"b;

000463  aa   400000 2350 03	lda  	131072,du
000464  aa  6 00102 7551 00	sta  	pr6|66		created_dseg
						STATEMENT 1 ON LINE 163
	call initiate (dirname, "template_dseg", "", 0, 0, his_dsegp, code);

000465  aa   777344 2350 04	lda  	-284,ic		000031 = 164145155160
000466  aa   777344 2360 04	ldq  	-284,ic		000032 = 154141164145
000467  aa  6 00324 7571 00	staq 	pr6|212
000470  aa   777343 2350 04	lda  	-285,ic		000033 = 137144163145
000471  aa   147000 2360 03	ldq  	52736,du
000472  aa  6 00326 7571 00	staq 	pr6|214
000473  aa  6 00330 4501 00	stz  	pr6|216
000474  aa  6 00331 4501 00	stz  	pr6|217
000475  aa  6 00103 3521 00	epp2 	pr6|67		dirname
000476  aa  6 00334 2521 00	spri2	pr6|220
000477  aa  6 00324 3521 00	epp2 	pr6|212
000500  aa  6 00336 2521 00	spri2	pr6|222
000501  aa  6 00370 3521 00	epp2 	pr6|248
000502  aa  6 00340 2521 00	spri2	pr6|224
000503  aa  6 00330 3521 00	epp2 	pr6|216
000504  aa  6 00342 2521 00	spri2	pr6|226
000505  aa  6 00331 3521 00	epp2 	pr6|217
000506  aa  6 00344 2521 00	spri2	pr6|228
000507  aa  6 00172 3521 00	epp2 	pr6|122		his_dsegp
000510  aa  6 00346 2521 00	spri2	pr6|230
000511  aa  6 00204 3521 00	epp2 	pr6|132		code
000512  aa  6 00350 2521 00	spri2	pr6|232
000513  aa   777277 3520 04	epp2 	-321,ic		000012 = 526000000250
000514  aa  6 00352 2521 00	spri2	pr6|234
000515  aa   777264 3520 04	epp2 	-332,ic		000001 = 524000000015
000516  aa  6 00354 2521 00	spri2	pr6|236
000517  aa   777271 3520 04	epp2 	-327,ic		000010 = 524000000000
000520  aa  6 00356 2521 00	spri2	pr6|238
000521  aa   777261 3520 04	epp2 	-335,ic		000002 = 404000000001
000522  aa  6 00360 2521 00	spri2	pr6|240
000523  aa   777263 3520 04	epp2 	-333,ic		000006 = 404000000002
000524  aa  6 00362 2521 00	spri2	pr6|242
000525  aa   777260 3520 04	epp2 	-336,ic		000005 = 464000000000
000526  aa  6 00364 2521 00	spri2	pr6|244
000527  aa   777265 3520 04	epp2 	-331,ic		000014 = 404000000043
000530  aa  6 00366 2521 00	spri2	pr6|246
000531  aa  6 00332 6211 00	eax1 	pr6|218
000532  aa   034000 4310 07	fld  	14336,dl
000533  aa  6 00044 3701 20	epp4 	pr6|36,*
000534  la  4 00034 3521 20	epp2 	pr4|28,*		initiate
000535  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 164
	if his_dsegp = null () then call abort_create (code);

000536  aa  6 00172 2371 00	ldaq 	pr6|122		his_dsegp
000537  aa   777265 6770 04	eraq 	-331,ic		000024 = 077777000043 000001000000
000540  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000541  aa   000003 6010 04	tnz  	3,ic		000544
000542  aa   002112 3520 04	epp2 	1098,ic		002654 = 000002000000
000543  aa   001336 6700 04	tsp4 	734,ic		002101
						STATEMENT 1 ON LINE 168
	his_kstp -> copy_kst = input_kstp -> copy_kst;

000544  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000545  aa  6 00200 3715 20	epp5 	pr6|128,*		input_kstp
000546  aa  6 00202 2351 00	lda  	pr6|130		bc
000547  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
000550  aa  5 00000 00 0005	descb	pr5|0,al		copy_kst
000551  aa  7 00000 00 0005	descb	pr7|0,al		copy_kst
						STATEMENT 1 ON LINE 169
	his_kstp -> kst.template = "0"b;

000552  aa   002074 2350 04	lda  	1084,ic		002646 = 777777775777
000553  aa  7 00007 3551 00	ansa 	pr7|7		kst.template
						STATEMENT 1 ON LINE 170
	call terminate_$noname (input_kstp, (0));

000554  aa  6 00331 4501 00	stz  	pr6|217
000555  aa  6 00200 3521 00	epp2 	pr6|128		input_kstp
000556  aa  6 00334 2521 00	spri2	pr6|220
000557  aa  6 00331 3521 00	epp2 	pr6|217
000560  aa  6 00336 2521 00	spri2	pr6|222
000561  aa  6 00332 6211 00	eax1 	pr6|218
000562  aa   010000 4310 07	fld  	4096,dl
000563  aa  6 00044 3701 20	epp4 	pr6|36,*
000564  la  4 00060 3521 20	epp2 	pr4|48,*		terminate_$noname
000565  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 174
	if his_kstp -> kst.time_of_bootload ^= sys_info$time_of_bootload
	then call abort_create (0);

000566  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000567  aa  7 00004 2371 00	ldaq 	pr7|4		kst.time_of_bootload
000570  aa  6 00044 3701 20	epp4 	pr6|36,*
000571  la  4 00012 1171 20	cmpaq	pr4|10,*		sys_info$time_of_bootload
000572  aa   000004 6000 04	tze  	4,ic		000576
000573  aa  6 00331 4501 00	stz  	pr6|217
000574  aa   002054 3520 04	epp2 	1068,ic		002650 = 000002000000
000575  aa   001304 6700 04	tsp4 	708,ic		002101
						STATEMENT 1 ON LINE 176
	if his_kstp -> kst.lowseg ^= my_kstp -> kst.lowseg
	then call abort_create (0);

000576  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000577  aa  6 00164 1161 20	cmpq 	pr6|116,*		kst.lowseg
000600  aa   000004 6000 04	tze  	4,ic		000604
000601  aa  6 00331 4501 00	stz  	pr6|217
000602  aa   002046 3520 04	epp2 	1062,ic		002650 = 000002000000
000603  aa   001276 6700 04	tsp4 	702,ic		002101
						STATEMENT 1 ON LINE 178
	if his_kstp -> kst.highseg > active_all_rings_data$max_segno
	then call abort_create (0);

000604  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000605  aa  7 00001 2361 00	ldq  	pr7|1		kst.highseg
000606  aa  6 00044 3701 20	epp4 	pr6|36,*
000607  la  4 00014 1161 20	cmpq 	pr4|12,*		active_all_rings_data$max_segno
000610  aa   000004 6044 04	tmoz 	4,ic		000614
000611  aa  6 00331 4501 00	stz  	pr6|217
000612  aa   002036 3520 04	epp2 	1054,ic		002650 = 000002000000
000613  aa   001266 6700 04	tsp4 	694,ic		002101
						STATEMENT 1 ON LINE 180
	if his_kstp -> kst.highest_used_segno < his_kstp -> kst.lowseg + 7
	then call abort_create (0);

000614  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000615  aa   000007 0760 07	adq  	7,dl
000616  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000617  aa  7 00002 1161 00	cmpq 	pr7|2		kst.highest_used_segno
000620  aa   000004 6044 04	tmoz 	4,ic		000624
000621  aa  6 00331 4501 00	stz  	pr6|217
000622  aa   002026 3520 04	epp2 	1046,ic		002650 = 000002000000
000623  aa   001256 6700 04	tsp4 	686,ic		002101
						STATEMENT 1 ON LINE 182
	if bin (rel (addr (his_kstp -> kst_entry (his_kstp -> kst.highest_used_segno + 1)))) * 36 ^= bc
	then call abort_create (0);

000624  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000625  aa   000003 7360 00	qls  	3
000626  aa  6 00331 7561 00	stq  	pr6|217
000627  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000630  aa  7 00002 2361 00	ldq  	pr7|2		kst.highest_used_segno
000631  aa   000001 0760 07	adq  	1,dl
000632  aa   000003 7360 00	qls  	3
000633  aa  6 00331 1761 00	sbq  	pr6|217
000634  aa  7 00110 3715 06	epp5 	pr7|72,ql		kst.kst_entry
000635  aa  5 00000 6351 00	eaa  	pr5|0
000636  aa   000066 7730 00	lrl  	54
000637  aa  6 00322 7571 00	staq 	pr6|210
000640  aa   000044 2360 07	ldq  	36,dl
000641  aa  6 00322 3521 00	epp2 	pr6|210
000642  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
000643  aa  6 00322 7571 00	staq 	pr6|210
000644  aa  6 00202 2351 00	lda  	pr6|130		bc
000645  aa   000044 7330 00	lrs  	36
000646  aa  6 00322 1171 00	cmpaq	pr6|210
000647  aa   000005 6000 04	tze  	5,ic		000654
000650  aa  6 00331 4501 00	stz  	pr6|217
000651  aa   001777 3520 04	epp2 	1023,ic		002650 = 000002000000
000652  aa  6 00322 6515 00	spri5	pr6|210
000653  aa   001226 6700 04	tsp4 	662,ic		002101
						STATEMENT 1 ON LINE 184
	if substr (string (his_kstp -> kst.prelinked_ring), 1, level - 1) ^= ""b
	then call abort_create (0);

000654  aa  6 00163 2361 00	ldq  	pr6|115		level
000655  aa   000001 1760 07	sbq  	1,dl
000656  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000657  aa  000 000 066 540	cmpb 	(pr,rl),(),fill(0)
000660  aa  7 00007 40 0006	descb	pr7|7(18),ql
000661  aa   000000 00 0000	descb	0,0
000662  aa   000004 6000 04	tze  	4,ic		000666
000663  aa  6 00331 4501 00	stz  	pr6|217
000664  aa   001764 3520 04	epp2 	1012,ic		002650 = 000002000000
000665  aa   001214 6700 04	tsp4 	652,ic		002101
						STATEMENT 1 ON LINE 189
	his_kstp -> kst.free_list = "0"b;

000666  aa   777777 2350 07	lda  	262143,dl
000667  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000670  aa  7 00007 3551 00	ansa 	pr7|7		kst.free_list
						STATEMENT 1 ON LINE 190
	unspec (his_kstp -> kst.uid_hash_bucket) = "0"b;

000671  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000672  aa   000000 00 0000	desc9a	0,0
000673  aa  7 00010 00 0400	desc9a	pr7|8,256
						STATEMENT 1 ON LINE 191
	do slotx = his_kstp -> kst.lowseg to his_kstp -> kst.highest_used_segno;

000674  aa  7 00002 2361 00	ldq  	pr7|2		kst.highest_used_segno
000675  aa  6 00252 7561 00	stq  	pr6|170
000676  aa  7 00000 2361 00	ldq  	pr7|0		kst.lowseg
000677  aa  6 00205 7561 00	stq  	pr6|133		slotx
000700  aa  6 00205 2361 00	ldq  	pr6|133		slotx
000701  aa  6 00252 1161 00	cmpq 	pr6|170
000702  aa   000033 6054 04	tpnz 	27,ic		000735
						STATEMENT 1 ON LINE 192
	     his_kstep = addr (his_kstp -> kst.kst_entry (slotx));

000703  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000704  aa   000003 7360 00	qls  	3
000705  aa  6 00331 7561 00	stq  	pr6|217
000706  aa  6 00205 2361 00	ldq  	pr6|133		slotx
000707  aa   000003 7360 00	qls  	3
000710  aa  6 00331 1761 00	sbq  	pr6|217
000711  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000712  aa  7 00110 3735 06	epp7 	pr7|72,ql		kst.kst_entry
000713  aa  6 00176 6535 00	spri7	pr6|126		his_kstep
						STATEMENT 1 ON LINE 193
	     his_kstep -> kste.segno = slotx;

000714  aa  6 00205 2361 00	ldq  	pr6|133		slotx
000715  aa  7 00000 5521 14	stbq 	pr7|0,14		kste.segno
						STATEMENT 1 ON LINE 194
	     his_kstep -> kste.fp = "0"b;

000716  aa   777777 2350 07	lda  	262143,dl
000717  aa  7 00000 3551 00	ansa 	pr7|0		kste.fp
						STATEMENT 1 ON LINE 195
	     unspec (his_kstep -> kste.access_information) = "0"b;

000720  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000721  aa   000000 00 0000	desc9a	0,0
000722  aa  7 00005 00 0011	desc9a	pr7|5,9
						STATEMENT 1 ON LINE 196
	     unspec (his_kstep -> kste.flags) = "0"b;

000723  aa   001722 2350 04	lda  	978,ic		002645 = 777700017777
000724  aa  7 00007 3551 00	ansa 	pr7|7
						STATEMENT 1 ON LINE 197
	     his_kstep -> kste.infcount = 0;

000725  aa   000000 2350 03	lda  	0,du
000726  aa  7 00007 6751 00	era  	pr7|7		kste.infcount
000727  aa   017777 3750 07	ana  	8191,dl
000730  aa  7 00007 6551 00	ersa 	pr7|7		kste.infcount
						STATEMENT 1 ON LINE 198
	     his_kstep -> kste.dtbm = (36) "1"b;

000731  aa   001731 2350 04	lda  	985,ic		002662 = 777777777777
000732  aa  7 00005 7551 00	sta  	pr7|5		kste.dtbm
						STATEMENT 1 ON LINE 199
	end;

000733  aa  6 00205 0541 00	aos  	pr6|133		slotx
000734  aa   777744 7100 04	tra  	-28,ic		000700
						STATEMENT 1 ON LINE 203
	do slotx = his_kstp -> kst.lowseg to his_kstp -> kst.highest_used_segno;

000735  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000736  aa  7 00002 2361 00	ldq  	pr7|2		kst.highest_used_segno
000737  aa  6 00253 7561 00	stq  	pr6|171
000740  aa  7 00000 2361 00	ldq  	pr7|0		kst.lowseg
000741  aa  6 00205 7561 00	stq  	pr6|133		slotx
000742  aa  6 00205 2361 00	ldq  	pr6|133		slotx
000743  aa  6 00253 1161 00	cmpq 	pr6|171
000744  aa   000263 6054 04	tpnz 	179,ic		001227
						STATEMENT 1 ON LINE 204
	     his_kstep = addr (his_kstp -> kst.kst_entry (slotx));

000745  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000746  aa   000003 7360 00	qls  	3
000747  aa  6 00331 7561 00	stq  	pr6|217
000750  aa  6 00205 2361 00	ldq  	pr6|133		slotx
000751  aa   000003 7360 00	qls  	3
000752  aa  6 00331 1761 00	sbq  	pr6|217
000753  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
000754  aa  7 00110 3735 06	epp7 	pr7|72,ql		kst.kst_entry
000755  aa  6 00176 6535 00	spri7	pr6|126		his_kstep
						STATEMENT 1 ON LINE 205
	     if his_kstep -> kste.uid = "0"b
	     then do;

000756  aa  7 00004 2351 00	lda  	pr7|4		kste.uid
000757  aa   000033 6010 04	tnz  	27,ic		001012
						STATEMENT 1 ON LINE 207
		his_kstep -> kste.usage_count = 0;

000760  aa   000001 2360 07	ldq  	1,dl
000761  aa  6 00254 7561 00	stq  	pr6|172
000762  aa  6 00254 2361 00	ldq  	pr6|172
000763  aa   000011 4020 07	mpy  	9,dl
000764  aa  6 00176 3735 20	epp7 	pr6|126,*		his_kstep
000765  aa  003 106 060 404	csl  	(ic),(pr,ql),fill(0),bool(move)
000766  aa   001674 00 0011	descb	956,9		002661 = 000000000000
000767  aa  7 00000 60 0011	descb	pr7|0(27),9	kste.usage_count
000770  aa  6 00254 2361 00	ldq  	pr6|172
000771  aa  6 00254 0541 00	aos  	pr6|172
000772  aa   000010 1160 07	cmpq 	8,dl
000773  aa   777767 6040 04	tmi  	-9,ic		000762
						STATEMENT 1 ON LINE 208
		unspec (his_kstep -> kste.entryp) = "0"b;

000774  aa  7 00003 4501 00	stz  	pr7|3
						STATEMENT 1 ON LINE 209
		if slotx ^> his_kstp -> kst.lowseg + 7
		then his_kstep -> kste.fp = (18)"1"b;

000775  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
000776  aa   000007 0760 07	adq  	7,dl
000777  aa  6 00205 1161 00	cmpq 	pr6|133		slotx
001000  aa   000004 6040 04	tmi  	4,ic		001004
001001  aa   777777 2350 03	lda  	262143,du
001002  aa  7 00000 5511 60	stba 	pr7|0,60		kste.fp
001003  aa   000222 7100 04	tra  	146,ic		001225
						STATEMENT 1 ON LINE 211
		else do;

						STATEMENT 1 ON LINE 212
		     his_kstep -> kste.fp = his_kstp -> kst.free_list;

001004  aa  6 00174 3715 20	epp5 	pr6|124,*		his_kstp
001005  aa  5 00007 2351 00	lda  	pr5|7		kst.free_list
001006  aa  7 00000 5511 60	stba 	pr7|0,60		kste.fp
						STATEMENT 1 ON LINE 213
		     his_kstp -> kst.free_list = rel (his_kstep);

001007  aa  7 00000 6351 00	eaa  	pr7|0		his_kstep
001010  aa  5 00007 5511 60	stba 	pr5|7,60		kst.free_list
						STATEMENT 1 ON LINE 214
		end;

						STATEMENT 1 ON LINE 215
	     end;

001011  aa   000214 7100 04	tra  	140,ic		001225
						STATEMENT 1 ON LINE 216
	     else do;

						STATEMENT 1 ON LINE 217
		call kstsrch (his_kstep -> kste.uid, hash_class, my_kstep);

001012  aa  7 00004 3521 00	epp2 	pr7|4		kste.uid
001013  aa  6 00334 2521 00	spri2	pr6|220
001014  aa  6 00203 3521 00	epp2 	pr6|131		hash_class
001015  aa  6 00336 2521 00	spri2	pr6|222
001016  aa  6 00166 3521 00	epp2 	pr6|118		my_kstep
001017  aa  6 00340 2521 00	spri2	pr6|224
001020  aa  6 00332 6211 00	eax1 	pr6|218
001021  aa   014000 4310 07	fld  	6144,dl
001022  aa  6 00044 3701 20	epp4 	pr6|36,*
001023  la  4 00040 3521 20	epp2 	pr4|32,*		kstsrch
001024  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 218
		if my_kstep = null () then call abort_create (0);

001025  aa  6 00166 2371 00	ldaq 	pr6|118		my_kstep
001026  aa   776776 6770 04	eraq 	-514,ic		000024 = 077777000043 000001000000
001027  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001030  aa   000004 6010 04	tnz  	4,ic		001034
001031  aa  6 00331 4501 00	stz  	pr6|217
001032  aa   001616 3520 04	epp2 	910,ic		002650 = 000002000000
001033  aa   001046 6700 04	tsp4 	550,ic		002101
						STATEMENT 1 ON LINE 219
		his_kstep -> kste.fp = his_kstp -> kst.uid_hash_bucket (hash_class);

001034  aa  6 00203 2361 00	ldq  	pr6|131		hash_class
001035  aa   000022 4020 07	mpy  	18,dl
001036  aa  6 00176 3735 20	epp7 	pr6|126,*		his_kstep
001037  aa  6 00174 3715 20	epp5 	pr6|124,*		his_kstp
001040  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001041  aa  5 00010 00 0022	descb	pr5|8,18		kst.uid_hash_bucket
001042  aa  7 00000 00 0022	descb	pr7|0,18		kste.fp
						STATEMENT 1 ON LINE 220
		his_kstp -> kst.uid_hash_bucket (hash_class) = rel (his_kstep);

001043  aa  7 00000 6351 00	eaa  	pr7|0		his_kstep
001044  aa  6 00056 7551 00	sta  	pr6|46
001045  aa  003 106 060 500	csl  	(pr),(pr,ql),fill(0),bool(move)
001046  aa  6 00056 00 0022	descb	pr6|46,18
001047  aa  5 00010 00 0022	descb	pr5|8,18		kst.uid_hash_bucket
						STATEMENT 1 ON LINE 221
		segno = my_kstep -> kste.segno;

001050  aa  6 00166 2351 20	lda  	pr6|118,*		kste.segno
001051  aa   000022 7350 00	als  	18
001052  aa   000066 7330 00	lrs  	54
001053  aa  6 00207 7561 00	stq  	pr6|135		segno
						STATEMENT 1 ON LINE 222
		if his_kstep -> kste.entryp ^= null ()
		then do;

001054  aa  7 00003 2361 00	ldq  	pr7|3		kste.entryp
001055  aa   001567 1160 04	cmpq 	887,ic		002644 = 007777000001
001056  aa   000074 6000 04	tze  	60,ic		001152
						STATEMENT 1 ON LINE 224
		     parent_slotx = bin (baseno (his_kstep -> kste.entryp));

001057  aa   000044 7370 00	lls  	36
001060  aa   007777 3750 03	ana  	4095,du
001061  aa   000066 7730 00	lrl  	54
001062  aa  6 00206 7561 00	stq  	pr6|134		parent_slotx
						STATEMENT 1 ON LINE 225
		     if his_kstp -> kst.kst_entry (parent_slotx).uid ^= my_kstp -> kst.kst_entry (bin (baseno (my_kstep -> kste.entryp))).uid
		     then call abort_create (0);

001063  aa  5 00000 2361 00	ldq  	pr5|0		kst.lowseg
001064  aa   000003 7360 00	qls  	3
001065  aa  6 00331 7561 00	stq  	pr6|217
001066  aa  6 00206 2361 00	ldq  	pr6|134		parent_slotx
001067  aa   000003 7360 00	qls  	3
001070  aa  6 00331 1761 00	sbq  	pr6|217
001071  aa   000000 6270 06	eax7 	0,ql
001072  aa  6 00164 2361 20	ldq  	pr6|116,*		kst.lowseg
001073  aa   000003 7360 00	qls  	3
001074  aa  6 00330 7561 00	stq  	pr6|216
001075  aa  6 00166 3535 20	epp3 	pr6|118,*		my_kstep
001076  aa  3 00003 2351 00	lda  	pr3|3		kste.entryp
001077  aa   007777 3750 03	ana  	4095,du
001100  aa   000066 7730 00	lrl  	54
001101  aa  6 00372 7571 00	staq 	pr6|250
001102  aa   000010 2360 07	ldq  	8,dl
001103  aa  6 00372 3521 00	epp2 	pr6|250
001104  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
001105  aa   000000 5330 00	negl 	0
001106  aa  6 00330 0331 00	adl  	pr6|216
001107  aa   000000 5330 00	negl 	0
001110  aa  6 00372 7571 00	staq 	pr6|250
001111  aa  5 00114 2351 17	lda  	pr5|76,7		kst.uid
001112  aa  6 00373 7261 00	lxl6 	pr6|251
001113  aa  6 00164 3515 20	epp1 	pr6|116,*		my_kstp
001114  aa  1 00114 1151 16	cmpa 	pr1|76,6		kst.uid
001115  aa   000004 6000 04	tze  	4,ic		001121
001116  aa  6 00331 4501 00	stz  	pr6|217
001117  aa   001531 3520 04	epp2 	857,ic		002650 = 000002000000
001120  aa   000761 6700 04	tsp4 	497,ic		002101
						STATEMENT 1 ON LINE 227
		     his_kstep -> kste.entryp = ptr (his_kstep -> kste.entryp, rel (my_kstep -> kste.entryp));

001121  aa  6 00176 3735 20	epp7 	pr6|126,*		his_kstep
001122  aa  7 00003 7671 00	lprp7	pr7|3		kste.entryp
001123  aa  6 00166 3715 20	epp5 	pr6|118,*		my_kstep
001124  aa  5 00003 2351 00	lda  	pr5|3		kste.entryp
001125  aa   000022 7350 00	als  	18
001126  aa  7 00000 3521 00	epp2 	pr7|0
001127  aa   000000 3120 01	eawp2	0,au
001130  aa  6 00176 3535 20	epp3 	pr6|126,*		his_kstep
001131  aa  3 00003 5421 00	sprp2	pr3|3		kste.entryp
						STATEMENT 1 ON LINE 228
		     his_kstp -> kst.kst_entry (parent_slotx).infcount = his_kstp -> kst.kst_entry (parent_slotx).infcount + 1;

001132  aa  6 00174 2361 20	ldq  	pr6|124,*		kst.lowseg
001133  aa   000003 7360 00	qls  	3
001134  aa  6 00331 7561 00	stq  	pr6|217
001135  aa  6 00206 2361 00	ldq  	pr6|134		parent_slotx
001136  aa   000003 7360 00	qls  	3
001137  aa  6 00331 1761 00	sbq  	pr6|217
001140  aa  6 00174 3515 20	epp1 	pr6|124,*		his_kstp
001141  aa  1 00117 2351 06	lda  	pr1|79,ql		kst.infcount
001142  aa   000027 7350 00	als  	23
001143  aa   000000 6270 06	eax7 	0,ql
001144  aa   000073 7330 00	lrs  	59
001145  aa   000001 0760 07	adq  	1,dl
001146  aa  1 00117 6761 17	erq  	pr1|79,7		kst.infcount
001147  aa   017777 3760 07	anq  	8191,dl
001150  aa  1 00117 6561 17	ersq 	pr1|79,7		kst.infcount
						STATEMENT 1 ON LINE 229
		end;

001151  aa   000010 7100 04	tra  	8,ic		001161
						STATEMENT 1 ON LINE 230
		else if my_kstep -> kste.entryp ^= null ()
		then call abort_create (0);

001152  aa  6 00166 3535 20	epp3 	pr6|118,*		my_kstep
001153  aa  3 00003 2361 00	ldq  	pr3|3		kste.entryp
001154  aa   001470 1160 04	cmpq 	824,ic		002644 = 007777000001
001155  aa   000004 6000 04	tze  	4,ic		001161
001156  aa  6 00331 4501 00	stz  	pr6|217
001157  aa   001471 3520 04	epp2 	825,ic		002650 = 000002000000
001160  aa   000721 6700 04	tsp4 	465,ic		002101
						STATEMENT 1 ON LINE 232
		call set_access ();

001161  aa   000513 6700 04	tsp4 	331,ic		001674
						STATEMENT 1 ON LINE 233
		his_kstep -> kste.dirsw, his_kstep -> kste.tms = my_kstep -> kste.dirsw;

001162  aa  6 00166 3735 20	epp7 	pr6|118,*		my_kstep
001163  aa  7 00007 2351 00	lda  	pr7|7		kste.dirsw
001164  aa   000014 7350 00	als  	12
001165  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001166  aa   000014 7730 00	lrl  	12
001167  aa  6 00176 3715 20	epp5 	pr6|126,*		his_kstep
001170  aa  6 00331 7551 00	sta  	pr6|217
001171  aa  5 00007 6751 00	era  	pr5|7		kste.dirsw
001172  aa   000040 3750 03	ana  	32,du
001173  aa  5 00007 6551 00	ersa 	pr5|7		kste.dirsw
001174  aa  6 00331 2351 00	lda  	pr6|217
001175  aa   000003 7710 00	arl  	3
001176  aa  5 00007 6751 00	era  	pr5|7		kste.tms
001177  aa   000004 3750 03	ana  	4,du
001200  aa  5 00007 6551 00	ersa 	pr5|7		kste.tms
						STATEMENT 1 ON LINE 234
		his_kstep -> kste.allow_write = "1"b;

001201  aa   000020 2350 03	lda  	16,du
001202  aa  5 00007 2551 00	orsa 	pr5|7		kste.allow_write
						STATEMENT 1 ON LINE 235
		do ring = 7 to level + 1 while (his_kstep -> kste.usage_count (ring) = 0);

001203  aa  6 00163 2361 00	ldq  	pr6|115		level
001204  aa   000001 0760 07	adq  	1,dl
001205  aa  6 00255 7561 00	stq  	pr6|173
001206  aa   000007 2360 07	ldq  	7,dl
001207  aa  6 00157 7561 00	stq  	pr6|111		ring
001210  aa  6 00157 2361 00	ldq  	pr6|111		ring
001211  aa  6 00255 1161 00	cmpq 	pr6|173
001212  aa   000013 6054 04	tpnz 	11,ic		001225
001213  aa   000011 4020 07	mpy  	9,dl
001214  aa  6 00176 3735 20	epp7 	pr6|126,*		his_kstep
001215  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
001216  aa  7 00001 00 0011	descb	pr7|1,9		kste.usage_count
001217  aa  6 00056 00 0044	descb	pr6|46,36
001220  aa  6 00056 2351 00	lda  	pr6|46
001221  aa   000077 7330 00	lrs  	63
001222  aa   000003 6010 04	tnz  	3,ic		001225
						STATEMENT 1 ON LINE 236
		end;

001223  aa  6 00157 0541 00	aos  	pr6|111		ring
001224  aa   777764 7100 04	tra  	-12,ic		001210
						STATEMENT 1 ON LINE 237
	     end;

						STATEMENT 1 ON LINE 238
	end;

001225  aa  6 00205 0541 00	aos  	pr6|133		slotx
001226  aa   777514 7100 04	tra  	-180,ic		000742
						STATEMENT 1 ON LINE 242
	his_kstp -> kst.template = "1"b;

001227  aa   002000 2350 07	lda  	1024,dl
001230  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
001231  aa  7 00007 2551 00	orsa 	pr7|7		kst.template
						STATEMENT 1 ON LINE 246
	call set$bc_seg (his_dsegp, (his_kstp -> kst.highest_used_segno + 1) * 72, code);

001232  aa  7 00002 2361 00	ldq  	pr7|2		kst.highest_used_segno
001233  aa   000001 0760 07	adq  	1,dl
001234  aa   000110 4020 07	mpy  	72,dl
001235  aa  6 00331 7561 00	stq  	pr6|217
001236  aa  6 00172 3521 00	epp2 	pr6|122		his_dsegp
001237  aa  6 00334 2521 00	spri2	pr6|220
001240  aa  6 00331 3521 00	epp2 	pr6|217
001241  aa  6 00336 2521 00	spri2	pr6|222
001242  aa  6 00204 3521 00	epp2 	pr6|132		code
001243  aa  6 00340 2521 00	spri2	pr6|224
001244  aa  6 00332 6211 00	eax1 	pr6|218
001245  aa   014000 4310 07	fld  	6144,dl
001246  aa  6 00044 3701 20	epp4 	pr6|36,*
001247  la  4 00050 3521 20	epp2 	pr4|40,*		set$bc_seg
001250  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 247
	if code ^= 0 then call abort_create (code);

001251  aa  6 00204 2361 00	ldq  	pr6|132		code
001252  aa   000003 6000 04	tze  	3,ic		001255
001253  aa   001401 3520 04	epp2 	769,ic		002654 = 000002000000
001254  aa   000625 6700 04	tsp4 	405,ic		002101
						STATEMENT 1 ON LINE 248
	call acl$areplace (dirname, "template_dseg", addr (all_access), 1, "0"b, code);

001255  aa   776554 2350 04	lda  	-660,ic		000031 = 164145155160
001256  aa   776554 2360 04	ldq  	-660,ic		000032 = 154141164145
001257  aa  6 00324 7571 00	staq 	pr6|212
001260  aa   776553 2350 04	lda  	-661,ic		000033 = 137144163145
001261  aa   147000 2360 03	ldq  	52736,du
001262  aa  6 00326 7571 00	staq 	pr6|214
001263  aa  6 00233 3735 00	epp7 	pr6|155		all_access
001264  aa  6 00374 6535 00	spri7	pr6|252
001265  aa   000001 2360 07	ldq  	1,dl
001266  aa  6 00331 7561 00	stq  	pr6|217
001267  aa   000000 2350 07	lda  	0,dl
001270  aa  6 00330 7551 00	sta  	pr6|216
001271  aa  6 00103 3521 00	epp2 	pr6|67		dirname
001272  aa  6 00334 2521 00	spri2	pr6|220
001273  aa  6 00324 3521 00	epp2 	pr6|212
001274  aa  6 00336 2521 00	spri2	pr6|222
001275  aa  6 00374 3521 00	epp2 	pr6|252
001276  aa  6 00340 2521 00	spri2	pr6|224
001277  aa  6 00331 3521 00	epp2 	pr6|217
001300  aa  6 00342 2521 00	spri2	pr6|226
001301  aa  6 00330 3521 00	epp2 	pr6|216
001302  aa  6 00344 2521 00	spri2	pr6|228
001303  aa  6 00204 3521 00	epp2 	pr6|132		code
001304  aa  6 00346 2521 00	spri2	pr6|230
001305  aa   776505 3520 04	epp2 	-699,ic		000012 = 526000000250
001306  aa  6 00350 2521 00	spri2	pr6|232
001307  aa   776472 3520 04	epp2 	-710,ic		000001 = 524000000015
001310  aa  6 00352 2521 00	spri2	pr6|234
001311  aa   776474 3520 04	epp2 	-708,ic		000005 = 464000000000
001312  aa  6 00354 2521 00	spri2	pr6|236
001313  aa   776502 3520 04	epp2 	-702,ic		000015 = 404000000021
001314  aa  6 00356 2521 00	spri2	pr6|238
001315  aa   776463 3520 04	epp2 	-717,ic		000000 = 514000000001
001316  aa  6 00360 2521 00	spri2	pr6|240
001317  aa   776475 3520 04	epp2 	-707,ic		000014 = 404000000043
001320  aa  6 00362 2521 00	spri2	pr6|242
001321  aa  6 00332 6211 00	eax1 	pr6|218
001322  aa   030000 4310 07	fld  	12288,dl
001323  aa  6 00044 3701 20	epp4 	pr6|36,*
001324  la  4 00022 3521 20	epp2 	pr4|18,*		acl$areplace
001325  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 249
	if code ^= 0 then call abort_create (code);

001326  aa  6 00204 2361 00	ldq  	pr6|132		code
001327  aa   000003 6000 04	tze  	3,ic		001332
001330  aa   001324 3520 04	epp2 	724,ic		002654 = 000002000000
001331  aa   000550 6700 04	tsp4 	360,ic		002101
						STATEMENT 1 ON LINE 253
	call set$bc_seg (his_kstp, bc, code);

001332  aa  6 00174 3521 00	epp2 	pr6|124		his_kstp
001333  aa  6 00334 2521 00	spri2	pr6|220
001334  aa  6 00202 3521 00	epp2 	pr6|130		bc
001335  aa  6 00336 2521 00	spri2	pr6|222
001336  aa  6 00204 3521 00	epp2 	pr6|132		code
001337  aa  6 00340 2521 00	spri2	pr6|224
001340  aa  6 00332 6211 00	eax1 	pr6|218
001341  aa   014000 4310 07	fld  	6144,dl
001342  aa  6 00044 3701 20	epp4 	pr6|36,*
001343  la  4 00050 3521 20	epp2 	pr4|40,*		set$bc_seg
001344  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 254
	if code ^= 0 then call abort_create (code);

001345  aa  6 00204 2361 00	ldq  	pr6|132		code
001346  aa   000003 6000 04	tze  	3,ic		001351
001347  aa   001305 3520 04	epp2 	709,ic		002654 = 000002000000
001350  aa   000531 6700 04	tsp4 	345,ic		002101
						STATEMENT 1 ON LINE 255
	call acl$areplace (dirname, "template_kst", addr (all_access), 1, "0"b, code);

001351  aa   776455 2370 04	ldaq 	-723,ic		000026 = 164145155160 154141164145
001352  aa  6 00324 7571 00	staq 	pr6|212
001353  aa   776455 2350 04	lda  	-723,ic		000030 = 137153163164
001354  aa  6 00326 7551 00	sta  	pr6|214
001355  aa  6 00233 3735 00	epp7 	pr6|155		all_access
001356  aa  6 00374 6535 00	spri7	pr6|252
001357  aa   000001 2360 07	ldq  	1,dl
001360  aa  6 00330 7561 00	stq  	pr6|216
001361  aa   000000 2350 07	lda  	0,dl
001362  aa  6 00331 7551 00	sta  	pr6|217
001363  aa  6 00103 3521 00	epp2 	pr6|67		dirname
001364  aa  6 00334 2521 00	spri2	pr6|220
001365  aa  6 00324 3521 00	epp2 	pr6|212
001366  aa  6 00336 2521 00	spri2	pr6|222
001367  aa  6 00374 3521 00	epp2 	pr6|252
001370  aa  6 00340 2521 00	spri2	pr6|224
001371  aa  6 00330 3521 00	epp2 	pr6|216
001372  aa  6 00342 2521 00	spri2	pr6|226
001373  aa  6 00331 3521 00	epp2 	pr6|217
001374  aa  6 00344 2521 00	spri2	pr6|228
001375  aa  6 00204 3521 00	epp2 	pr6|132		code
001376  aa  6 00346 2521 00	spri2	pr6|230
001377  aa   776413 3520 04	epp2 	-757,ic		000012 = 526000000250
001400  aa  6 00350 2521 00	spri2	pr6|232
001401  aa   776403 3520 04	epp2 	-765,ic		000004 = 524000000014
001402  aa  6 00352 2521 00	spri2	pr6|234
001403  aa   776402 3520 04	epp2 	-766,ic		000005 = 464000000000
001404  aa  6 00354 2521 00	spri2	pr6|236
001405  aa   776410 3520 04	epp2 	-760,ic		000015 = 404000000021
001406  aa  6 00356 2521 00	spri2	pr6|238
001407  aa   776371 3520 04	epp2 	-775,ic		000000 = 514000000001
001410  aa  6 00360 2521 00	spri2	pr6|240
001411  aa   776403 3520 04	epp2 	-765,ic		000014 = 404000000043
001412  aa  6 00362 2521 00	spri2	pr6|242
001413  aa  6 00332 6211 00	eax1 	pr6|218
001414  aa   030000 4310 07	fld  	12288,dl
001415  aa  6 00044 3701 20	epp4 	pr6|36,*
001416  la  4 00022 3521 20	epp2 	pr4|18,*		acl$areplace
001417  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 256
	if code ^= 0 then call abort_create (code);

001420  aa  6 00204 2361 00	ldq  	pr6|132		code
001421  aa   000003 6000 04	tze  	3,ic		001424
001422  aa   001232 3520 04	epp2 	666,ic		002654 = 000002000000
001423  aa   000456 6700 04	tsp4 	302,ic		002101
						STATEMENT 1 ON LINE 260
	call terminate_$noname (his_kstp, (0));

001424  aa  6 00331 4501 00	stz  	pr6|217
001425  aa  6 00174 3521 00	epp2 	pr6|124		his_kstp
001426  aa  6 00334 2521 00	spri2	pr6|220
001427  aa  6 00331 3521 00	epp2 	pr6|217
001430  aa  6 00336 2521 00	spri2	pr6|222
001431  aa  6 00332 6211 00	eax1 	pr6|218
001432  aa   010000 4310 07	fld  	4096,dl
001433  aa  6 00044 3701 20	epp4 	pr6|36,*
001434  la  4 00060 3521 20	epp2 	pr4|48,*		terminate_$noname
001435  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 261
	call terminate_$noname (his_dsegp, (0));

001436  aa  6 00331 4501 00	stz  	pr6|217
001437  aa  6 00172 3521 00	epp2 	pr6|122		his_dsegp
001440  aa  6 00334 2521 00	spri2	pr6|220
001441  aa  6 00331 3521 00	epp2 	pr6|217
001442  aa  6 00336 2521 00	spri2	pr6|222
001443  aa  6 00332 6211 00	eax1 	pr6|218
001444  aa   010000 4310 07	fld  	4096,dl
001445  aa  6 00044 3701 20	epp4 	pr6|36,*
001446  la  4 00060 3521 20	epp2 	pr4|48,*		terminate_$noname
001447  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 262
	call level$set (level);

001450  aa  6 00163 3521 00	epp2 	pr6|115		level
001451  aa  6 00326 2521 00	spri2	pr6|214
001452  aa  6 00324 6211 00	eax1 	pr6|212
001453  aa   004000 4310 07	fld  	2048,dl
001454  aa  6 00044 3701 20	epp4 	pr6|36,*
001455  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
001456  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 263
	a_access_calculated = access_calculated;

001457  aa  6 00100 2361 00	ldq  	pr6|64		access_calculated
001460  aa  6 00032 3735 20	epp7 	pr6|26,*
001461  aa  7 00004 7561 20	stq  	pr7|4,*		a_access_calculated
						STATEMENT 1 ON LINE 264
	return;

001462  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO delete                                             STATEMENT 1 ON LINE 313
delete:	entry (a_dirname, a_code);

001463  at     000002000016
001464  ta     000014000000
001465  ta     001463000000
001466  da     000267300000
001467  aa   000600 6270 00	eax7 	384
001470  aa  7 00034 3521 20	epp2 	pr7|28,*
001471  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
001472  aa     000004000000
001473  aa     000000000000
001474  aa  6 00042 3735 20	epp7 	pr6|34,*
001475  aa  7 00000 2361 20	ldq  	pr7|0,*
001476  aa   000002 6040 04	tmi  	2,ic		001500
001477  aa   777777 3760 07	anq  	262143,dl
001500  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001501  aa  6 00321 7561 00	stq  	pr6|209
001502  aa  6 00032 3715 20	epp5 	pr6|26,*
001503  aa  5 00004 3535 20	epp3 	pr5|4,*
001504  aa  6 00250 2535 00	spri3	pr6|168
001505  aa   776330 7000 04	tsx0 	-808,ic		000035
						STATEMENT 1 ON LINE 315
	dirname = a_dirname;

001506  aa  6 00032 3735 20	epp7 	pr6|26,*
001507  aa  7 00002 3715 20	epp5 	pr7|2,*
001510  aa  6 00321 2351 00	lda  	pr6|209
001511  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001512  aa  5 00000 00 0005	desc9a	pr5|0,al		a_dirname
001513  aa  6 00103 00 0250	desc9a	pr6|67,168	dirname
						STATEMENT 1 ON LINE 316
	a_code = 0;

001514  aa  6 00250 4501 20	stz  	pr6|168,*		a_code
						STATEMENT 1 ON LINE 318
	my_kstp = pds$kstp;

001515  aa  6 00044 3701 20	epp4 	pr6|36,*
001516  la  4 00062 3535 20	epp3 	pr4|50,*		pds$kstp
001517  aa  3 00000 3535 20	epp3 	pr3|0,*		pds$kstp
001520  aa  6 00164 2535 00	spri3	pr6|116		my_kstp
						STATEMENT 1 ON LINE 319
	his_kstp, his_dsegp = null ();

001521  aa   776303 3514 24	epp1 	-829,ic*
001522  aa  6 00174 2515 00	spri1	pr6|124		his_kstp
001523  aa  6 00172 2515 00	spri1	pr6|122		his_dsegp
						STATEMENT 1 ON LINE 320
	level = level$get ();

001524  aa  6 00163 3521 00	epp2 	pr6|115		level
001525  aa  6 00326 2521 00	spri2	pr6|214
001526  aa  6 00324 6211 00	eax1 	pr6|212
001527  aa   004000 4310 07	fld  	2048,dl
001530  la  4 00042 3521 20	epp2 	pr4|34,*		level$get
001531  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 321
	call level$set (0);

001532  aa  6 00331 4501 00	stz  	pr6|217
001533  aa  6 00331 3521 00	epp2 	pr6|217
001534  aa  6 00326 2521 00	spri2	pr6|214
001535  aa  6 00324 6211 00	eax1 	pr6|212
001536  aa   004000 4310 07	fld  	2048,dl
001537  aa  6 00044 3701 20	epp4 	pr6|36,*
001540  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
001541  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 325
	call initiate_r0_seg ("template_kst", his_kstp);

001542  aa   776264 2370 04	ldaq 	-844,ic		000026 = 164145155160 154141164145
001543  aa  6 00324 7571 00	staq 	pr6|212
001544  aa   776264 2350 04	lda  	-844,ic		000030 = 137153163164
001545  aa  6 00326 7551 00	sta  	pr6|214
001546  aa   001064 3520 04	epp2 	564,ic		002632 = 000004000000
001547  aa  2 00000 2351 00	lda  	pr2|0
001550  aa   000435 6700 04	tsp4 	285,ic		002205
						STATEMENT 1 ON LINE 329
	call initiate_r0_seg ("template_dseg", his_dsegp);

001551  aa   776260 2350 04	lda  	-848,ic		000031 = 164145155160
001552  aa   776260 2360 04	ldq  	-848,ic		000032 = 154141164145
001553  aa  6 00324 7571 00	staq 	pr6|212
001554  aa   776257 2350 04	lda  	-849,ic		000033 = 137144163145
001555  aa   147000 2360 03	ldq  	52736,du
001556  aa  6 00326 7571 00	staq 	pr6|214
001557  aa   001041 3520 04	epp2 	545,ic		002620 = 000004000000
001560  aa  2 00000 2351 00	lda  	pr2|0
001561  aa   000424 6700 04	tsp4 	276,ic		002205
						STATEMENT 1 ON LINE 333
	call fs_modes ((my_kstp -> kst.kst_entry (bin (baseno (his_kstp))).entryp), mode, exmode, rings, code);

001562  aa  6 00164 2361 20	ldq  	pr6|116,*		kst.lowseg
001563  aa   000003 7360 00	qls  	3
001564  aa  6 00331 7561 00	stq  	pr6|217
001565  aa  6 00174 2131 20	epaq 	pr6|124,*		his_kstp
001566  aa   077777 3750 03	ana  	32767,du
001567  aa   000066 7730 00	lrl  	54
001570  aa  6 00374 7571 00	staq 	pr6|252
001571  aa   000010 2360 07	ldq  	8,dl
001572  aa  6 00374 3521 00	epp2 	pr6|252
001573  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
001574  aa   000000 5330 00	negl 	0
001575  aa  6 00331 0331 00	adl  	pr6|217
001576  aa   000000 5330 00	negl 	0
001577  aa  6 00164 3735 20	epp7 	pr6|116,*		my_kstp
001600  aa  7 00113 7671 06	lprp7	pr7|75,ql		kst.entryp
001601  aa  6 00374 6535 00	spri7	pr6|252
001602  aa  6 00374 3521 00	epp2 	pr6|252
001603  aa  6 00334 2521 00	spri2	pr6|220
001604  aa  6 00155 3521 00	epp2 	pr6|109		mode
001605  aa  6 00336 2521 00	spri2	pr6|222
001606  aa  6 00156 3521 00	epp2 	pr6|110		exmode
001607  aa  6 00340 2521 00	spri2	pr6|224
001610  aa  6 00160 3521 00	epp2 	pr6|112		rings
001611  aa  6 00342 2521 00	spri2	pr6|226
001612  aa  6 00204 3521 00	epp2 	pr6|132		code
001613  aa  6 00344 2521 00	spri2	pr6|228
001614  aa  6 00332 6211 00	eax1 	pr6|218
001615  aa   024000 4310 07	fld  	10240,dl
001616  aa  6 00044 3701 20	epp4 	pr6|36,*
001617  la  4 00032 3521 20	epp2 	pr4|26,*		fs_modes
001620  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 334
	if code ^= 0 then call abort_delete (code);

001621  aa  6 00204 2361 00	ldq  	pr6|132		code
001622  aa   000003 6000 04	tze  	3,ic		001625
001623  aa   001031 3520 04	epp2 	537,ic		002654 = 000002000000
001624  aa   000665 6700 04	tsp4 	437,ic		002511
						STATEMENT 1 ON LINE 338
	if (mode & M_ACCESS) ^= M_ACCESS then call abort_delete (0);

001625  aa  6 00155 2351 00	lda  	pr6|109		mode
001626  aa   200000 3750 03	ana  	65536,du
001627  aa   200000 1150 03	cmpa 	65536,du
001630  aa   000004 6000 04	tze  	4,ic		001634
001631  aa  6 00331 4501 00	stz  	pr6|217
001632  aa   001016 3520 04	epp2 	526,ic		002650 = 000002000000
001633  aa   000656 6700 04	tsp4 	430,ic		002511
						STATEMENT 1 ON LINE 342
	if ^his_kstp -> kst.template then call abort_delete (0);

001634  aa  6 00174 3735 20	epp7 	pr6|124,*		his_kstp
001635  aa  7 00007 2351 00	lda  	pr7|7		kst.template
001636  aa   002000 3150 07	cana 	1024,dl
001637  aa   000004 6010 04	tnz  	4,ic		001643
001640  aa  6 00331 4501 00	stz  	pr6|217
001641  aa   001007 3520 04	epp2 	519,ic		002650 = 000002000000
001642  aa   000647 6700 04	tsp4 	423,ic		002511
						STATEMENT 1 ON LINE 346
	call delete_r0_seg (his_kstp, "template_kst");

001643  aa   776163 2370 04	ldaq 	-909,ic		000026 = 164145155160 154141164145
001644  aa  6 00324 7571 00	staq 	pr6|212
001645  aa   776163 2350 04	lda  	-909,ic		000030 = 137153163164
001646  aa  6 00326 7551 00	sta  	pr6|214
001647  aa   000737 3520 04	epp2 	479,ic		002606 = 000004000000
001650  aa  2 00000 2351 00	lda  	pr2|0
001651  aa   000506 6700 04	tsp4 	326,ic		002357
						STATEMENT 1 ON LINE 347
	call delete_r0_seg (his_dsegp, "template_dseg");

001652  aa   776157 2350 04	lda  	-913,ic		000031 = 164145155160
001653  aa   776157 2360 04	ldq  	-913,ic		000032 = 154141164145
001654  aa  6 00324 7571 00	staq 	pr6|212
001655  aa   776156 2350 04	lda  	-914,ic		000033 = 137144163145
001656  aa   147000 2360 03	ldq  	52736,du
001657  aa  6 00326 7571 00	staq 	pr6|214
001660  aa   000714 3520 04	epp2 	460,ic		002574 = 000004000000
001661  aa  2 00000 2351 00	lda  	pr2|0
001662  aa   000475 6700 04	tsp4 	317,ic		002357
						STATEMENT 1 ON LINE 348
	call level$set (level);

001663  aa  6 00163 3521 00	epp2 	pr6|115		level
001664  aa  6 00326 2521 00	spri2	pr6|214
001665  aa  6 00324 6211 00	eax1 	pr6|212
001666  aa   004000 4310 07	fld  	2048,dl
001667  aa  6 00044 3701 20	epp4 	pr6|36,*
001670  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
001671  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 349
	return;

001672  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 391
return_to_caller:
	return;

001673  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 410
     end template_address_space;

BEGIN PROCEDURE set_access
ENTRY TO set_access                                         STATEMENT 1 ON LINE 266
set_access: proc ();

001674  aa  6 00256 6501 00	spri4	pr6|174
						STATEMENT 1 ON LINE 270
	     call sum$getbranch (baseptr (segno), "0"b, ep, code);

001675  aa  6 00207 2361 00	ldq  	pr6|135		segno
001676  aa  6 00000 3525 00	epbp2	pr6|0
001677  aa   000000 3130 06	easp2	0,ql
001700  aa  6 00376 2521 00	spri2	pr6|254
001701  aa   000000 2350 07	lda  	0,dl
001702  aa  6 00400 7551 00	sta  	pr6|256
001703  aa  6 00376 3521 00	epp2 	pr6|254
001704  aa  6 00404 2521 00	spri2	pr6|260
001705  aa  6 00400 3521 00	epp2 	pr6|256
001706  aa  6 00406 2521 00	spri2	pr6|262
001707  aa  6 00246 3521 00	epp2 	pr6|166		ep
001710  aa  6 00410 2521 00	spri2	pr6|264
001711  aa  6 00204 3521 00	epp2 	pr6|132		code
001712  aa  6 00412 2521 00	spri2	pr6|266
001713  aa  6 00402 6211 00	eax1 	pr6|258
001714  aa   020000 4310 07	fld  	8192,dl
001715  aa  6 00044 3701 20	epp4 	pr6|36,*
001716  la  4 00056 3521 20	epp2 	pr4|46,*		sum$getbranch
001717  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 271
	     if code ^= 0 then return;

001720  aa  6 00204 2361 00	ldq  	pr6|132		code
001721  aa   000002 6000 04	tze  	2,ic		001723
001722  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 272
	     if ep -> entry.acle_count = 1
	     then do;

001723  aa  6 00246 3735 20	epp7 	pr6|166,*		ep
001724  aa  7 00035 2351 00	lda  	pr7|29		entry.acle_count
001725  aa   000022 7350 00	als  	18
001726  aa   000066 7330 00	lrs  	54
001727  aa   000001 1160 07	cmpq 	1,dl
001730  aa   000137 6010 04	tnz  	95,ic		002067
						STATEMENT 1 ON LINE 274
		call acc_list_$match ((entry.acle_count), entry.uid, addr (entry.acl_frp),
		addr (star_dot_star_dot_star), (null ()), (0), code);

001731  aa  6 00400 7561 00	stq  	pr6|256
001732  aa  7 00036 3715 00	epp5 	pr7|30		entry.acl_frp
001733  aa  6 00376 6515 00	spri5	pr6|254
001734  aa  6 00210 3535 00	epp3 	pr6|136		star_dot_star_dot_star
001735  aa  6 00414 2535 00	spri3	pr6|268
001736  aa   776066 3514 24	epp1 	-970,ic*
001737  aa  6 00416 2515 00	spri1	pr6|270
001740  aa  6 00401 4501 00	stz  	pr6|257
001741  aa  6 00400 3521 00	epp2 	pr6|256
001742  aa  6 00422 2521 00	spri2	pr6|274
001743  aa  7 00002 3521 00	epp2 	pr7|2		entry.uid
001744  aa  6 00424 2521 00	spri2	pr6|276
001745  aa  6 00376 3521 00	epp2 	pr6|254
001746  aa  6 00426 2521 00	spri2	pr6|278
001747  aa  6 00414 3521 00	epp2 	pr6|268
001750  aa  6 00430 2521 00	spri2	pr6|280
001751  aa  6 00416 3521 00	epp2 	pr6|270
001752  aa  6 00432 2521 00	spri2	pr6|282
001753  aa  6 00401 3521 00	epp2 	pr6|257
001754  aa  6 00434 2521 00	spri2	pr6|284
001755  aa  6 00204 3521 00	epp2 	pr6|132		code
001756  aa  6 00436 2521 00	spri2	pr6|286
001757  aa  6 00420 6211 00	eax1 	pr6|272
001760  aa   034000 4310 07	fld  	14336,dl
001761  aa  6 00044 3701 20	epp4 	pr6|36,*
001762  la  4 00020 3521 20	epp2 	pr4|16,*		acc_list_$match
001763  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 276
		if code = 0
		then do;

001764  aa  6 00204 2361 00	ldq  	pr6|132		code
001765  aa   000102 6010 04	tnz  	66,ic		002067
						STATEMENT 1 ON LINE 278
		     call fs_modes (baseptr (segno), ("0"b), ("0"b), dummy_rings, code);

001766  aa  6 00207 2361 00	ldq  	pr6|135		segno
001767  aa  6 00000 3525 00	epbp2	pr6|0
001770  aa   000000 3130 06	easp2	0,ql
001771  aa  6 00416 2521 00	spri2	pr6|270
001772  aa   000000 2350 07	lda  	0,dl
001773  aa  6 00401 7551 00	sta  	pr6|257
001774  aa  6 00400 7551 00	sta  	pr6|256
001775  aa  6 00416 3521 00	epp2 	pr6|270
001776  aa  6 00422 2521 00	spri2	pr6|274
001777  aa  6 00401 3521 00	epp2 	pr6|257
002000  aa  6 00424 2521 00	spri2	pr6|276
002001  aa  6 00400 3521 00	epp2 	pr6|256
002002  aa  6 00426 2521 00	spri2	pr6|278
002003  aa  6 00264 3521 00	epp2 	pr6|180		dummy_rings
002004  aa  6 00430 2521 00	spri2	pr6|280
002005  aa  6 00204 3521 00	epp2 	pr6|132		code
002006  aa  6 00432 2521 00	spri2	pr6|282
002007  aa  6 00420 6211 00	eax1 	pr6|272
002010  aa   024000 4310 07	fld  	10240,dl
002011  aa  6 00044 3701 20	epp4 	pr6|36,*
002012  la  4 00032 3521 20	epp2 	pr4|26,*		fs_modes
002013  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 279
		     if code = 0
		     then do;

002014  aa  6 00204 2361 00	ldq  	pr6|132		code
002015  aa   000052 6010 04	tnz  	42,ic		002067
						STATEMENT 1 ON LINE 281
			access_calculated = access_calculated + 1;

002016  aa  6 00100 0541 00	aos  	pr6|64		access_calculated
						STATEMENT 1 ON LINE 282
			his_kstep -> kste.access_information = my_kstep -> kste.access_information;

002017  aa  6 00166 3735 20	epp7 	pr6|118,*		my_kstep
002020  aa   000121 7270 07	lxl7 	81,dl
002021  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
002022  aa  7 00005 00 0017	descb	pr7|5,x7		kste.access_information
002023  aa  6 00402 00 0017	descb	pr6|258,x7
002024  aa  6 00176 3715 20	epp5 	pr6|126,*		his_kstep
002025  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
002026  aa  6 00402 00 0017	descb	pr6|258,x7
002027  aa  5 00005 00 0017	descb	pr5|5,x7		kste.access_information
						STATEMENT 1 ON LINE 283
			his_dsegp -> sdwa (slotx).r1 = my_dsegp -> sdwa (segno).r1;

002030  aa  6 00205 2361 00	ldq  	pr6|133		slotx
002031  aa   000001 7360 00	qls  	1
002032  aa   000000 6260 06	eax6 	0,ql
002033  aa  6 00207 2361 00	ldq  	pr6|135		segno
002034  aa   000001 7360 00	qls  	1
002035  aa  6 00170 2351 66	lda  	pr6|120,*ql	sdwa.r1
002036  aa  6 00172 6751 76	era  	pr6|122,*6	sdwa.r1
002037  aa   007000 3750 07	ana  	3584,dl
002040  aa  6 00172 6551 76	ersa 	pr6|122,*6	sdwa.r1
						STATEMENT 1 ON LINE 284
			his_dsegp -> sdwa (slotx).r2 = my_dsegp -> sdwa (segno).r2;

002041  aa  6 00170 2351 66	lda  	pr6|120,*ql	sdwa.r2
002042  aa  6 00172 6751 76	era  	pr6|122,*6	sdwa.r2
002043  aa   000700 3750 07	ana  	448,dl
002044  aa  6 00172 6551 76	ersa 	pr6|122,*6	sdwa.r2
						STATEMENT 1 ON LINE 285
			his_dsegp -> sdwa (slotx).r3 = my_dsegp -> sdwa (segno).r3;

002045  aa  6 00170 2351 66	lda  	pr6|120,*ql	sdwa.r3
002046  aa  6 00172 6751 76	era  	pr6|122,*6	sdwa.r3
002047  aa   000070 3750 07	ana  	56,dl
002050  aa  6 00172 6551 76	ersa 	pr6|122,*6	sdwa.r3
						STATEMENT 1 ON LINE 286
			his_dsegp -> sdwa (slotx).read = my_dsegp -> sdwa (segno).read;

002051  aa  6 00170 3535 20	epp3 	pr6|120,*		my_dsegp
002052  aa  3 00001 2351 06	lda  	pr3|1,ql		sdwa.read
002053  aa  6 00172 3515 20	epp1 	pr6|122,*		his_dsegp
002054  aa  1 00001 6751 16	era  	pr1|1,6		sdwa.read
002055  aa   000004 3750 03	ana  	4,du
002056  aa  1 00001 6551 16	ersa 	pr1|1,6		sdwa.read
						STATEMENT 1 ON LINE 287
			his_dsegp -> sdwa (slotx).write = my_dsegp -> sdwa (segno).write;

002057  aa  3 00001 2351 06	lda  	pr3|1,ql		sdwa.write
002060  aa  1 00001 6751 16	era  	pr1|1,6		sdwa.write
002061  aa   000001 3750 03	ana  	1,du
002062  aa  1 00001 6551 16	ersa 	pr1|1,6		sdwa.write
						STATEMENT 1 ON LINE 288
			his_dsegp -> sdwa (slotx).execute = my_dsegp -> sdwa (segno).execute;

002063  aa  3 00001 2351 06	lda  	pr3|1,ql		sdwa.execute
002064  aa  1 00001 6751 16	era  	pr1|1,6		sdwa.execute
002065  aa   000002 3750 03	ana  	2,du
002066  aa  1 00001 6551 16	ersa 	pr1|1,6		sdwa.execute
						STATEMENT 1 ON LINE 289
		     end;

						STATEMENT 1 ON LINE 290
		end;

						STATEMENT 1 ON LINE 291
	     end;

						STATEMENT 1 ON LINE 292
	     call lock$dir_unlock (ptr (ep, 0));

002067  aa  6 00246 3525 20	epbp2	pr6|166,*		ep
002070  aa  6 00416 2521 00	spri2	pr6|270
002071  aa  6 00416 3521 00	epp2 	pr6|270
002072  aa  6 00404 2521 00	spri2	pr6|260
002073  aa  6 00402 6211 00	eax1 	pr6|258
002074  aa   004000 4310 07	fld  	2048,dl
002075  aa  6 00044 3701 20	epp4 	pr6|36,*
002076  la  4 00046 3521 20	epp2 	pr4|38,*		lock$dir_unlock
002077  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 293
	     return;

002100  aa  6 00256 6101 00	rtcd 	pr6|174
						STATEMENT 1 ON LINE 294
	end set_access;

  END PROCEDURE set_access
BEGIN PROCEDURE abort_create
ENTRY TO abort_create                                       STATEMENT 1 ON LINE 296
abort_create: proc (code);

002101  aa  6 00270 6501 00	spri4	pr6|184
002102  aa  6 00272 2521 00	spri2	pr6|186
						STATEMENT 1 ON LINE 298
	     if created_dseg
	     then call delentry$dfile (dirname, "template_dseg", (0));

002103  aa  6 00102 2351 00	lda  	pr6|66		created_dseg
002104  aa   000031 6000 04	tze  	25,ic		002135
002105  aa   775724 2350 04	lda  	-1068,ic		000031 = 164145155160
002106  aa   775724 2360 04	ldq  	-1068,ic		000032 = 154141164145
002107  aa  6 00440 7571 00	staq 	pr6|288
002110  aa   775723 2350 04	lda  	-1069,ic		000033 = 137144163145
002111  aa   147000 2360 03	ldq  	52736,du
002112  aa  6 00442 7571 00	staq 	pr6|290
002113  aa  6 00444 4501 00	stz  	pr6|292
002114  aa  6 00103 3521 00	epp2 	pr6|67		dirname
002115  aa  6 00450 2521 00	spri2	pr6|296
002116  aa  6 00440 3521 00	epp2 	pr6|288
002117  aa  6 00452 2521 00	spri2	pr6|298
002120  aa  6 00444 3521 00	epp2 	pr6|292
002121  aa  6 00454 2521 00	spri2	pr6|300
002122  aa   775670 3520 04	epp2 	-1096,ic		000012 = 526000000250
002123  aa  6 00456 2521 00	spri2	pr6|302
002124  aa   775655 3520 04	epp2 	-1107,ic		000001 = 524000000015
002125  aa  6 00460 2521 00	spri2	pr6|304
002126  aa   775666 3520 04	epp2 	-1098,ic		000014 = 404000000043
002127  aa  6 00462 2521 00	spri2	pr6|306
002130  aa  6 00446 6211 00	eax1 	pr6|294
002131  aa   014000 4310 07	fld  	6144,dl
002132  aa  6 00044 3701 20	epp4 	pr6|36,*
002133  la  4 00026 3521 20	epp2 	pr4|22,*		delentry$dfile
002134  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 300
	     if created_kst
	     then call delentry$dfile (dirname, "template_kst", (0));

002135  aa  6 00101 2351 00	lda  	pr6|65		created_kst
002136  aa   000027 6000 04	tze  	23,ic		002165
002137  aa   775667 2370 04	ldaq 	-1097,ic		000026 = 164145155160 154141164145
002140  aa  6 00440 7571 00	staq 	pr6|288
002141  aa   775667 2350 04	lda  	-1097,ic		000030 = 137153163164
002142  aa  6 00442 7551 00	sta  	pr6|290
002143  aa  6 00444 4501 00	stz  	pr6|292
002144  aa  6 00103 3521 00	epp2 	pr6|67		dirname
002145  aa  6 00450 2521 00	spri2	pr6|296
002146  aa  6 00440 3521 00	epp2 	pr6|288
002147  aa  6 00452 2521 00	spri2	pr6|298
002150  aa  6 00444 3521 00	epp2 	pr6|292
002151  aa  6 00454 2521 00	spri2	pr6|300
002152  aa   775640 3520 04	epp2 	-1120,ic		000012 = 526000000250
002153  aa  6 00456 2521 00	spri2	pr6|302
002154  aa   775630 3520 04	epp2 	-1128,ic		000004 = 524000000014
002155  aa  6 00460 2521 00	spri2	pr6|304
002156  aa   775636 3520 04	epp2 	-1122,ic		000014 = 404000000043
002157  aa  6 00462 2521 00	spri2	pr6|306
002160  aa  6 00446 6211 00	eax1 	pr6|294
002161  aa   014000 4310 07	fld  	6144,dl
002162  aa  6 00044 3701 20	epp4 	pr6|36,*
002163  la  4 00026 3521 20	epp2 	pr4|22,*		delentry$dfile
002164  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 302
	     call level$set (level);

002165  aa  6 00163 3521 00	epp2 	pr6|115		level
002166  aa  6 00442 2521 00	spri2	pr6|290
002167  aa  6 00440 6211 00	eax1 	pr6|288
002170  aa   004000 4310 07	fld  	2048,dl
002171  aa  6 00044 3701 20	epp4 	pr6|36,*
002172  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
002173  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 303
	     if code = 0
	     then a_code = error_table_$action_not_performed;

002174  aa  6 00272 3735 20	epp7 	pr6|186,*
002175  aa  7 00002 2361 20	ldq  	pr7|2,*		code
002176  aa   000005 6010 04	tnz  	5,ic		002203
002177  aa  6 00044 3701 20	epp4 	pr6|36,*
002200  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$action_not_performed
002201  aa  6 00250 7561 20	stq  	pr6|168,*		a_code
002202  aa   000002 7100 04	tra  	2,ic		002204
						STATEMENT 1 ON LINE 305
	     else a_code = code;

002203  aa  6 00250 7561 20	stq  	pr6|168,*		a_code
						STATEMENT 1 ON LINE 306
	     go to return_to_caller;

002204  aa   777467 7100 04	tra  	-201,ic		001673
						STATEMENT 1 ON LINE 307
	end abort_create;

  END PROCEDURE abort_create
BEGIN PROCEDURE initiate_r0_seg
ENTRY TO initiate_r0_seg                                    STATEMENT 1 ON LINE 351
initiate_r0_seg: proc (ename, segptr);

002205  aa  6 00276 6501 00	spri4	pr6|190
002206  aa  6 00300 2521 00	spri2	pr6|192
002207  aa  2 00002 3521 01	epp2 	pr2|2,au
002210  aa  6 00302 2521 00	spri2	pr6|194
002211  aa  2 00000 2361 20	ldq  	pr2|0,*
002212  aa   000002 6040 04	tmi  	2,ic		002214
002213  aa   777777 3760 07	anq  	262143,dl
002214  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002215  aa  6 00464 7561 00	stq  	pr6|308
						STATEMENT 1 ON LINE 354
	     call initiate (dirname, ename, "", 0, 0, segptr, code);

002216  aa  6 00466 4501 00	stz  	pr6|310
002217  aa  6 00467 4501 00	stz  	pr6|311
002220  aa  6 00103 3521 00	epp2 	pr6|67		dirname
002221  aa  6 00472 2521 00	spri2	pr6|314
002222  aa  6 00300 3735 20	epp7 	pr6|192,*
002223  aa  7 00002 3521 20	epp2 	pr7|2,*		ename
002224  aa  6 00474 2521 00	spri2	pr6|316
002225  aa  6 00465 3521 00	epp2 	pr6|309
002226  aa  6 00476 2521 00	spri2	pr6|318
002227  aa  6 00466 3521 00	epp2 	pr6|310
002230  aa  6 00500 2521 00	spri2	pr6|320
002231  aa  6 00467 3521 00	epp2 	pr6|311
002232  aa  6 00502 2521 00	spri2	pr6|322
002233  aa  7 00004 3521 20	epp2 	pr7|4,*		segptr
002234  aa  6 00504 2521 00	spri2	pr6|324
002235  aa  6 00204 3521 00	epp2 	pr6|132		code
002236  aa  6 00506 2521 00	spri2	pr6|326
002237  aa   775553 3520 04	epp2 	-1173,ic		000012 = 526000000250
002240  aa  6 00510 2521 00	spri2	pr6|328
002241  aa  6 00302 3715 20	epp5 	pr6|194,*
002242  aa  5 00000 3521 20	epp2 	pr5|0,*
002243  aa  6 00512 2521 00	spri2	pr6|330
002244  aa   775544 3520 04	epp2 	-1180,ic		000010 = 524000000000
002245  aa  6 00514 2521 00	spri2	pr6|332
002246  aa   775534 3520 04	epp2 	-1188,ic		000002 = 404000000001
002247  aa  6 00516 2521 00	spri2	pr6|334
002250  aa   775536 3520 04	epp2 	-1186,ic		000006 = 404000000002
002251  aa  6 00520 2521 00	spri2	pr6|336
002252  aa   775533 3520 04	epp2 	-1189,ic		000005 = 464000000000
002253  aa  6 00522 2521 00	spri2	pr6|338
002254  aa   775540 3520 04	epp2 	-1184,ic		000014 = 404000000043
002255  aa  6 00524 2521 00	spri2	pr6|340
002256  aa  6 00470 6211 00	eax1 	pr6|312
002257  aa   034000 4310 07	fld  	14336,dl
002260  aa  6 00044 3701 20	epp4 	pr6|36,*
002261  la  4 00034 3521 20	epp2 	pr4|28,*		initiate
002262  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 355
	     if segptr = null () then call abort_delete (code);

002263  aa  6 00300 3735 20	epp7 	pr6|192,*
002264  aa  7 00004 2371 20	ldaq 	pr7|4,*		segptr
002265  aa   775537 6770 04	eraq 	-1185,ic		000024 = 077777000043 000001000000
002266  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002267  aa   000003 6010 04	tnz  	3,ic		002272
002270  aa   000364 3520 04	epp2 	244,ic		002654 = 000002000000
002271  aa   000220 6700 04	tsp4 	144,ic		002511
						STATEMENT 1 ON LINE 356
	     if my_kstp -> kst.kst_entry (bin (baseno (segptr))).dirsw
	     then call abort_delete (0);

002272  aa  6 00164 2361 20	ldq  	pr6|116,*		kst.lowseg
002273  aa   000003 7360 00	qls  	3
002274  aa  6 00467 7561 00	stq  	pr6|311
002275  aa  6 00300 3735 20	epp7 	pr6|192,*
002276  aa  7 00004 3715 20	epp5 	pr7|4,*		segptr
002277  aa  5 00000 3715 20	epp5 	pr5|0,*		segptr
002300  aa  5 00000 2131 00	epaq 	pr5|0		segptr
002301  aa   077777 3750 03	ana  	32767,du
002302  aa   000066 7730 00	lrl  	54
002303  aa  6 00526 7571 00	staq 	pr6|342
002304  aa   000010 2360 07	ldq  	8,dl
002305  aa  6 00526 3521 00	epp2 	pr6|342
002306  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
002307  aa   000000 5330 00	negl 	0
002310  aa  6 00467 0331 00	adl  	pr6|311
002311  aa   000000 5330 00	negl 	0
002312  aa  6 00164 3535 20	epp3 	pr6|116,*		my_kstp
002313  aa  3 00117 2351 06	lda  	pr3|79,ql		kst.dirsw
002314  aa   000040 3150 03	cana 	32,du
002315  aa   000004 6000 04	tze  	4,ic		002321
002316  aa  6 00467 4501 00	stz  	pr6|311
002317  aa   000251 3520 04	epp2 	169,ic		002570 = 000002000000
002320  aa   000171 6700 04	tsp4 	121,ic		002511
						STATEMENT 1 ON LINE 358
	     call fs_modes (segptr, mode, exmode, rings, code);

002321  aa  6 00300 3735 20	epp7 	pr6|192,*
002322  aa  7 00004 3521 20	epp2 	pr7|4,*		segptr
002323  aa  6 00472 2521 00	spri2	pr6|314
002324  aa  6 00155 3521 00	epp2 	pr6|109		mode
002325  aa  6 00474 2521 00	spri2	pr6|316
002326  aa  6 00156 3521 00	epp2 	pr6|110		exmode
002327  aa  6 00476 2521 00	spri2	pr6|318
002330  aa  6 00160 3521 00	epp2 	pr6|112		rings
002331  aa  6 00500 2521 00	spri2	pr6|320
002332  aa  6 00204 3521 00	epp2 	pr6|132		code
002333  aa  6 00502 2521 00	spri2	pr6|322
002334  aa  6 00470 6211 00	eax1 	pr6|312
002335  aa   024000 4310 07	fld  	10240,dl
002336  aa  6 00044 3701 20	epp4 	pr6|36,*
002337  la  4 00032 3521 20	epp2 	pr4|26,*		fs_modes
002340  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 359
	     if code ^= 0 then call abort_delete (code);

002341  aa  6 00204 2361 00	ldq  	pr6|132		code
002342  aa   000003 6000 04	tze  	3,ic		002345
002343  aa   000311 3520 04	epp2 	201,ic		002654 = 000002000000
002344  aa   000145 6700 04	tsp4 	101,ic		002511
						STATEMENT 1 ON LINE 360
	     if rings (1) ^= 0 | rings (2) ^= 0 | rings (3) ^= 0
	     then call abort_delete (0);

002345  aa  6 00160 2361 00	ldq  	pr6|112		rings
002346  aa   000005 6010 04	tnz  	5,ic		002353
002347  aa  6 00161 2361 00	ldq  	pr6|113		rings
002350  aa   000003 6010 04	tnz  	3,ic		002353
002351  aa  6 00162 2361 00	ldq  	pr6|114		rings
002352  aa   000004 6000 04	tze  	4,ic		002356
002353  aa  6 00467 4501 00	stz  	pr6|311
002354  aa   000214 3520 04	epp2 	140,ic		002570 = 000002000000
002355  aa   000134 6700 04	tsp4 	92,ic		002511
						STATEMENT 1 ON LINE 362
	     return;

002356  aa  6 00276 6101 00	rtcd 	pr6|190
						STATEMENT 1 ON LINE 363
	end initiate_r0_seg;

  END PROCEDURE initiate_r0_seg
BEGIN PROCEDURE delete_r0_seg
ENTRY TO delete_r0_seg                                      STATEMENT 1 ON LINE 365
delete_r0_seg: proc (segptr, ename);

002357  aa  6 00304 6501 00	spri4	pr6|196
002360  aa  6 00306 2521 00	spri2	pr6|198
002361  aa  2 00002 3521 01	epp2 	pr2|2,au
002362  aa  6 00310 2521 00	spri2	pr6|200
002363  aa  2 00002 2361 20	ldq  	pr2|2,*
002364  aa   000002 6040 04	tmi  	2,ic		002366
002365  aa   777777 3760 07	anq  	262143,dl
002366  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
002367  aa  6 00530 7561 00	stq  	pr6|344
						STATEMENT 1 ON LINE 368
	     call delentry$dseg (segptr, code);

002370  aa  6 00306 3735 20	epp7 	pr6|198,*
002371  aa  7 00002 3521 20	epp2 	pr7|2,*		segptr
002372  aa  6 00534 2521 00	spri2	pr6|348
002373  aa  6 00204 3521 00	epp2 	pr6|132		code
002374  aa  6 00536 2521 00	spri2	pr6|350
002375  aa  6 00532 6211 00	eax1 	pr6|346
002376  aa   010000 4310 07	fld  	4096,dl
002377  aa  6 00044 3701 20	epp4 	pr6|36,*
002400  la  4 00030 3521 20	epp2 	pr4|24,*		delentry$dseg
002401  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 369
	     if code ^= 0
	     then do;

002402  aa  6 00204 2361 00	ldq  	pr6|132		code
002403  aa   000102 6000 04	tze  	66,ic		002505
						STATEMENT 1 ON LINE 371
		call set$safety_sw_path (dirname, ename, "0"b, (0));

002404  aa   000000 2350 07	lda  	0,dl
002405  aa  6 00531 7551 00	sta  	pr6|345
002406  aa  6 00540 4501 00	stz  	pr6|352
002407  aa  6 00103 3521 00	epp2 	pr6|67		dirname
002410  aa  6 00544 2521 00	spri2	pr6|356
002411  aa  6 00306 3735 20	epp7 	pr6|198,*
002412  aa  7 00004 3521 20	epp2 	pr7|4,*		ename
002413  aa  6 00546 2521 00	spri2	pr6|358
002414  aa  6 00531 3521 00	epp2 	pr6|345
002415  aa  6 00550 2521 00	spri2	pr6|360
002416  aa  6 00540 3521 00	epp2 	pr6|352
002417  aa  6 00552 2521 00	spri2	pr6|362
002420  aa   775372 3520 04	epp2 	-1286,ic		000012 = 526000000250
002421  aa  6 00554 2521 00	spri2	pr6|364
002422  aa  6 00310 3715 20	epp5 	pr6|200,*
002423  aa  5 00002 3521 20	epp2 	pr5|2,*
002424  aa  6 00556 2521 00	spri2	pr6|366
002425  aa   775353 3520 04	epp2 	-1301,ic		000000 = 514000000001
002426  aa  6 00560 2521 00	spri2	pr6|368
002427  aa   775365 3520 04	epp2 	-1291,ic		000014 = 404000000043
002430  aa  6 00562 2521 00	spri2	pr6|370
002431  aa  6 00542 6211 00	eax1 	pr6|354
002432  aa   020000 4310 07	fld  	8192,dl
002433  aa  6 00044 3701 20	epp4 	pr6|36,*
002434  la  4 00052 3521 20	epp2 	pr4|42,*		set$safety_sw_path
002435  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 372
		call set$copysw (dirname, ename, 0, (0));

002436  aa  6 00540 4501 00	stz  	pr6|352
002437  aa  6 00531 4501 00	stz  	pr6|345
002440  aa  6 00103 3521 00	epp2 	pr6|67		dirname
002441  aa  6 00544 2521 00	spri2	pr6|356
002442  aa  6 00306 3735 20	epp7 	pr6|198,*
002443  aa  7 00004 3521 20	epp2 	pr7|4,*		ename
002444  aa  6 00546 2521 00	spri2	pr6|358
002445  aa  6 00540 3521 00	epp2 	pr6|352
002446  aa  6 00550 2521 00	spri2	pr6|360
002447  aa  6 00531 3521 00	epp2 	pr6|345
002450  aa  6 00552 2521 00	spri2	pr6|362
002451  aa   775341 3520 04	epp2 	-1311,ic		000012 = 526000000250
002452  aa  6 00554 2521 00	spri2	pr6|364
002453  aa  6 00310 3715 20	epp5 	pr6|200,*
002454  aa  5 00002 3521 20	epp2 	pr5|2,*
002455  aa  6 00556 2521 00	spri2	pr6|366
002456  aa   775324 3520 04	epp2 	-1324,ic		000002 = 404000000001
002457  aa  6 00560 2521 00	spri2	pr6|368
002460  aa   775334 3520 04	epp2 	-1316,ic		000014 = 404000000043
002461  aa  6 00562 2521 00	spri2	pr6|370
002462  aa  6 00542 6211 00	eax1 	pr6|354
002463  aa   020000 4310 07	fld  	8192,dl
002464  aa  6 00044 3701 20	epp4 	pr6|36,*
002465  la  4 00054 3521 20	epp2 	pr4|44,*		set$copysw
002466  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 373
		call delentry$dseg (segptr, code);

002467  aa  6 00306 3735 20	epp7 	pr6|198,*
002470  aa  7 00002 3521 20	epp2 	pr7|2,*		segptr
002471  aa  6 00534 2521 00	spri2	pr6|348
002472  aa  6 00204 3521 00	epp2 	pr6|132		code
002473  aa  6 00536 2521 00	spri2	pr6|350
002474  aa  6 00532 6211 00	eax1 	pr6|346
002475  aa   010000 4310 07	fld  	4096,dl
002476  aa  6 00044 3701 20	epp4 	pr6|36,*
002477  la  4 00030 3521 20	epp2 	pr4|24,*		delentry$dseg
002500  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 374
		if code ^= 0 then call abort_delete (code);

002501  aa  6 00204 2361 00	ldq  	pr6|132		code
002502  aa   000003 6000 04	tze  	3,ic		002505
002503  aa   000151 3520 04	epp2 	105,ic		002654 = 000002000000
002504  aa   000005 6700 04	tsp4 	5,ic		002511
						STATEMENT 1 ON LINE 375
	     end;

						STATEMENT 1 ON LINE 376
	     segptr = null ();

002505  aa   775317 2370 04	ldaq 	-1329,ic		000024 = 077777000043 000001000000
002506  aa  6 00306 3735 20	epp7 	pr6|198,*
002507  aa  7 00002 7571 20	staq 	pr7|2,*		segptr
						STATEMENT 1 ON LINE 377
	     return;

002510  aa  6 00304 6101 00	rtcd 	pr6|196
						STATEMENT 1 ON LINE 378
	end delete_r0_seg;

  END PROCEDURE delete_r0_seg
BEGIN PROCEDURE abort_delete
ENTRY TO abort_delete                                       STATEMENT 1 ON LINE 380
abort_delete: proc (code);

002511  aa  6 00312 6501 00	spri4	pr6|202
002512  aa  6 00314 2521 00	spri2	pr6|204
						STATEMENT 1 ON LINE 382
	     if his_kstp ^= null () then call terminate_$noname (his_kstp, (0));

002513  aa  6 00174 2371 00	ldaq 	pr6|124		his_kstp
002514  aa   775310 6770 04	eraq 	-1336,ic		000024 = 077777000043 000001000000
002515  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002516  aa   000013 6000 04	tze  	11,ic		002531
002517  aa  6 00564 4501 00	stz  	pr6|372
002520  aa  6 00174 3521 00	epp2 	pr6|124		his_kstp
002521  aa  6 00570 2521 00	spri2	pr6|376
002522  aa  6 00564 3521 00	epp2 	pr6|372
002523  aa  6 00572 2521 00	spri2	pr6|378
002524  aa  6 00566 6211 00	eax1 	pr6|374
002525  aa   010000 4310 07	fld  	4096,dl
002526  aa  6 00044 3701 20	epp4 	pr6|36,*
002527  la  4 00060 3521 20	epp2 	pr4|48,*		terminate_$noname
002530  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 383
	     if his_dsegp ^= null () then call terminate_$noname (his_dsegp, (0));

002531  aa  6 00172 2371 00	ldaq 	pr6|122		his_dsegp
002532  aa   775272 6770 04	eraq 	-1350,ic		000024 = 077777000043 000001000000
002533  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
002534  aa   000013 6000 04	tze  	11,ic		002547
002535  aa  6 00564 4501 00	stz  	pr6|372
002536  aa  6 00172 3521 00	epp2 	pr6|122		his_dsegp
002537  aa  6 00570 2521 00	spri2	pr6|376
002540  aa  6 00564 3521 00	epp2 	pr6|372
002541  aa  6 00572 2521 00	spri2	pr6|378
002542  aa  6 00566 6211 00	eax1 	pr6|374
002543  aa   010000 4310 07	fld  	4096,dl
002544  aa  6 00044 3701 20	epp4 	pr6|36,*
002545  la  4 00060 3521 20	epp2 	pr4|48,*		terminate_$noname
002546  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 384
	     call level$set (level);

002547  aa  6 00163 3521 00	epp2 	pr6|115		level
002550  aa  6 00570 2521 00	spri2	pr6|376
002551  aa  6 00566 6211 00	eax1 	pr6|374
002552  aa   004000 4310 07	fld  	2048,dl
002553  aa  6 00044 3701 20	epp4 	pr6|36,*
002554  la  4 00044 3521 20	epp2 	pr4|36,*		level$set
002555  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 385
	     if code = 0
	     then a_code = error_table_$action_not_performed;

002556  aa  6 00314 3735 20	epp7 	pr6|204,*
002557  aa  7 00002 2361 20	ldq  	pr7|2,*		code
002560  aa   000005 6010 04	tnz  	5,ic		002565
002561  aa  6 00044 3701 20	epp4 	pr6|36,*
002562  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$action_not_performed
002563  aa  6 00250 7561 20	stq  	pr6|168,*		a_code
002564  aa   000002 7100 04	tra  	2,ic		002566
						STATEMENT 1 ON LINE 387
	     else a_code = code;

002565  aa  6 00250 7561 20	stq  	pr6|168,*		a_code
						STATEMENT 1 ON LINE 388
	     go to return_to_caller;

002566  aa   777105 7100 04	tra  	-443,ic		001673
						STATEMENT 1 ON LINE 389
	end abort_delete;

  END PROCEDURE abort_delete
  END PROCEDURE template_address_space


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
