	COMPILATION LISTING OF SEGMENT priv_delete_vtoce
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0954.2 mst Sat
	    Options: optimize list

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1987 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        * Copyright (c) 1972 by Massachusetts Institute of   *
        9*        * Technology and Honeywell Information Systems, Inc. *
       10*        *                                                    *
       11*        ****************************************************** */
       12 
       13 /* format: style4 */
       14 priv_delete_vtoce: procedure (a_uid, a_pvid, a_vtocx, a_code);
       15 
       16 /* priv_delete_vtoce: a program to quietly and mysteriously induce a connection
       17*   failure.  Intended to be used on a VTOCE for which it has been determined that
       18*   no branch exists.  Several gullibility checks are applied. The only case that
       19*   this program cannot protect itself against is the case of a wrong UID pathname
       20*   for an existant segment.
       21*
       22*   The priv_delete_vtoce$clear entry is used to get rid of a VTOCE completely--
       23*   it writes zeros into it. This is used when it is necessary to eliminate a damaged
       24*   VTOCE without regard to its possible contents.
       25*
       26*   In the normal priv_delete_vtoce case, pages are freed, but quotas are not updated.
       27*   In the $clear case, the vtoce is simply zeroed, without even freeing pages.
       28*   However, normal volume salvage can be expected to pick them up next time. Neither
       29*   of these entries will permit a VTOCE which appears to be active to be deleted.
       30*
       31*   Bernard Greenberg   06/02/74
       32*   Modified 06/02/81, W. Olin Sibert, to not lock directory for damaged VTOCE
       33*   Modified 9 August 1981 WOS, to add priv_delete_vtoce$clear
       34*   Modified January 82 BIM, for write lock for exclusive dir lock.
       35*   Modified March 1982, J. Bongiovanni, to fix bug in find_aste and to cleanup locks
       36*   Modified September 1982, J. Bongiovanni, to validate the moribund VTOCE before
       37*   deleting it
       38*   Modified August 1983, E. N. Kittlitz, set uid in clear case
       39**/
       40 
       41 dcl  a_uid bit (36) aligned parameter;
       42 dcl  a_pvid bit (36) aligned parameter;
       43 dcl  a_vtocx fixed bin parameter;
       44 dcl  a_code fixed bin parameter;
       45 
       46 dcl  uid bit (36) aligned;
       47 dcl  par_uid bit (36) aligned;
       48 dcl  pvid bit (36) aligned;
       49 dcl  code fixed bin (35);
       50 dcl  pvtx fixed bin;
       51 dcl  i fixed bin;
       52 dcl  vtocx fixed bin;
       53 dcl  clear_sw bit (1) aligned;
       54 
       55 dcl  1 local_entry like entry aligned automatic;
       56 dcl  1 local_dir like dir aligned automatic;
       57 dcl  1 local_vtoce like vtoce aligned automatic;
       58 
       59 dcl  sst$astap pointer external static;
       60 dcl  sst$astsize fixed bin external static;
       61 dcl  sst$pts (0:3) fixed bin external static;
       62 dcl  1 sst$level (0:3) external static aligned,
       63        2 ausedp bit (18) unaligned,
       64        2 no_aste fixed bin (18) unsigned unaligned;
       65 
       66 dcl  error_table_$vtoce_connection_fail fixed bin (35) external static;
       67 dcl  error_table_$illegal_deactivation fixed bin (35) external static;
       68 dcl  error_table_$invalid_vtoce fixed bin (35) external static;
       69 
       70 dcl  delete_vtoce entry (pointer, fixed bin (35));
       71 dcl  get_pvtx entry (bit (36) aligned, fixed bin (35)) returns (fixed bin);
       72 dcl  lock$dir_lock_write entry (pointer, fixed bin (35));
       73 dcl  lock$lock_ast entry ();
       74 dcl  lock$unlock_ast entry ();
       75 dcl  lock$dir_unlock_given_uid entry (bit (36) aligned);
       76 dcl  search_ast entry (bit (36) aligned) returns (ptr);
       77 dcl  syserr$error_code entry options (variable);
       78 dcl  vtoc_man$free_vtoce entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
       79 dcl  vtoc_man$get_vtoce entry (bit (36) aligned, fixed bin, fixed bin, bit (3), pointer, fixed bin (35));
       80 
       81 dcl  (addr, addrel, binary, dim, fixed, null, unspec) builtin;
       82 
       83 
       84 
       85 	clear_sw = "0"b;
       86 	uid = a_uid;
       87 	goto COMMON;
       88 
       89 
       90 priv_delete_vtoce$clear: entry (a_pvid, a_vtocx, a_code);
       91 
       92 	clear_sw = "1"b;
       93 	uid = ""b;				/* don't have a UID yet */
       94 	goto COMMON;
       95 
       96 
       97 COMMON:	pvid = a_pvid;				/* Copy parameters, zero code */
       98 	vtocx = a_vtocx;
       99 	code = 0;
      100 	par_uid = ""b;				/* Means parent not locked */
      101 
      102 	pvtx = get_pvtx (pvid, code);			/* Try to get the pvtx */
      103 	if code ^= 0 then go to finale;		/* Already off line. Lose */
      104 
      105 	vtocep = addr (local_vtoce);
      106 	dp = addr (local_dir);
      107 	ep = addr (local_entry);			/* Set up local copy and fraud branch. */
      108 
      109 	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "101"b, vtocep, code);
      110 	if code ^= 0 then go to finale;		/* Some other lossage, could be demount, i/o err. */
      111 
      112 	if (vtoce.uid ^= uid) & (^clear_sw) then do;	/* Only check if not simply clearing */
      113 	     code = error_table_$vtoce_connection_fail;	/* Gone already */
      114 	     go to finale;
      115 	end;
      116 	if clear_sw then uid = vtoce.uid;		/* why not use this? */
      117 
      118 
      119 
      120 	if clear_sw then goto BAD_PARENT;		/* Don't bother trying if just clearing */
      121 
      122 	if vtoce.uid_path (0) ^= "777777777777"b3 then goto BAD_PARENT; /* Can't be locked: UID path is bogus */
      123 
      124 	do i = 15 to 0 by -1 while (vtoce.uid_path (i) = "0"b);
      125 	end;					/* Get parent UID */
      126 
      127 	par_uid = vtoce.uid_path (i);
      128 	if par_uid = ""b then goto BAD_PARENT;		/* UID pathname is bad */
      129 
      130 	unspec (dir) = "0"b;			/* Clear the fraudulent dir */
      131 	dir.uid = par_uid;
      132 
      133 	call lock$dir_lock_write (dp, code);		/*  Lock the UID in the dirlock table */
      134 	if code ^= 0 then call syserr$error_code (CRASH, code, "priv_delete_vtoce: failed to lock ^w ", par_uid);
      135 
      136 BAD_PARENT:
      137 	call lock$lock_ast;				/* Check if active */
      138 
      139 	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "101"b, vtocep, code);
      140 	if code ^= 0 then go to unlock_ast_finale;	/* funny thing.. */
      141 
      142 	if (vtoce.uid ^= uid) & (^clear_sw) then do;	/* Again, skip check */
      143 	     code = error_table_$vtoce_connection_fail;
      144 	     go to unlock_ast_finale;			/* gone in window */
      145 	end;
      146 
      147 	if find_aste (pvtx, vtocx) ^= null () then do;	/* Active, refuse to do this. */
      148 	     code = error_table_$illegal_deactivation;
      149 	     go to unlock_ast_finale;
      150 	end;
      151 
      152 	if (search_ast (uid) ^= null ()) & (^clear_sw) then do; /* UID in VTOCE is bad for sure */
      153 	     code = error_table_$invalid_vtoce;
      154 	     goto unlock_ast_finale;
      155 	end;
      156 
      157 
      158 
      159 	if clear_sw then do;			/* If clearing, just write (and await) */
      160 
      161 	     call vtoc_man$free_vtoce (pvid, pvtx, vtocx, code); /* Let vtoc_man do the work */
      162 	     if code ^= 0 then go to unlock_ast_finale;	/* funny thing.. */
      163 
      164 	     call lock$unlock_ast ();			/* Unlock AST only after finished */
      165 	end;
      166 
      167 	else do;					/* In normal case, unlock AST immediately, since we have */
      168 	     call lock$unlock_ast ();			/* parent locked, and it can't be activated while that */
      169 						/* situation prevails */
      170 
      171 	     if fixed (vtoce.records) > fixed (vtoce.csl) /* Validate the VTOCE a bit */
      172 		| fixed (vtoce.csl) > fixed (vtoce.msl)
      173 		| fixed (vtoce.msl) > dim (vtoce.fm, 1)
      174 	     then do;
      175 		code = error_table_$invalid_vtoce;
      176 		goto finale;
      177 	     end;
      178 
      179 	     unspec (entry) = ""b;
      180 	     entry.owner = "777777777770"b3;		/* No owner, until this field set right */
      181 	     entry.pvid = pvid;			/* Inhibit quota grubbing-- */
      182 	     entry.uid = uid;			/* This UID is special-cased by delete_vtoce */
      183 	     entry.vtocx = vtocx;
      184 
      185 	     call delete_vtoce (ep, code);		/* Now delete the vtoce */
      186 	end;
      187 
      188 finale:	if par_uid ^= ""b then			/* If there was a parent, then */
      189 	     call lock$dir_unlock_given_uid (par_uid);	/* Unlock it */
      190 
      191 	a_code = code;
      192 	return;
      193 
      194 unlock_ast_finale:
      195 	call lock$unlock_ast;
      196 	goto finale;
      197 
      198 
      199 
      200 find_aste: proc (P_pvtx, P_vtocx) returns (pointer);
      201 
      202 /* This procedure is used to look for an ASTE which claims to own a particular VTOC entry.
      203*   It is used instead of search_ast because it is possible that there is some damage present,
      204*   which might cause the UID to be completely bogus, and not be properly picked up by
      205*   search_ast. It simply looks through all the pools looking for the proper pvtx/vtocx pair.
      206**/
      207 
      208 dcl  P_pvtx fixed bin parameter;
      209 dcl  P_vtocx fixed bin parameter;
      210 
      211 dcl  pool_idx fixed bin;
      212 dcl  aste_idx fixed bin;
      213 dcl  my_astep pointer;
      214 
      215 
      216 	my_astep = sst$astap;
      217 
      218 	do pool_idx = 0 to 3;			/* Walk through all pools, rather than trusting search_ast */
      219 	     do aste_idx = 1 to sst$level (pool_idx).no_aste;
      220 		if (my_astep -> aste.vtocx = P_vtocx) then
      221 		     if (my_astep -> aste.pvtx = P_pvtx) then
      222 			return (my_astep);		/* This is it */
      223 
      224 		my_astep = addrel (my_astep, binary (sst$pts (pool_idx) + sst$astsize, 18));
      225 	     end;
      226 	end;
      227 
      228 	return (null ());				/* Didn't find it */
      229 
      230      end find_aste;
      231 
      232 /* format: off */
      233 
      234  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      234 
      235  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      235 
      236  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      236 
      237  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      237 
      238  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  5     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  5     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  5     4 
  5     5 dcl  vtocep ptr;
  5     6 
  5     7 dcl 1 vtoce based (vtocep) aligned,
  5     8 
  5     9 
  5    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  5    11 
  5    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  5    13 
  5    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  5    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  5    16     2 records bit (9),				/* number of records used by the seg in second storage */
  5    17     2 pad2 bit (9),
  5    18 
  5    19     2 dtu bit (36),					/* date and time segment was last used */
  5    20 
  5    21     2 dtm bit (36),					/* date and time segment was last modified */
  5    22 
  5    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  5    24     2 deciduous bit (1),				/* true if hc_sdw */
  5    25     2 nid bit (1),					/* no incremental dump switch */
  5    26     2 dnzp bit (1),					/* Dont null zero pages */
  5    27     2 gtpd bit (1),					/* Global transparent paging device */
  5    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  5    29     2 damaged bit (1),				/* TRUE if contents damaged */
  5    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  5    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  5    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  5    33     2 pad3 bit (8),
  5    34     2 dirsw bit (1),				/* directory switch */
  5    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  5    36     2 pad4 bit (16)) unaligned,			/* not used */
  5    37 
  5    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  5    39 
  5    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  5    41 
  5    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  5    43 
  5    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  5    45 
  5    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  5    47 
  5    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  5    49 
  5    50 
  5    51 
  5    52 
  5    53 
  5    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  5    55 
  5    56     2 pad6 (10) bit (36),				/* not used */
  5    57 
  5    58     2 ncd bit (1),					/* no complete dump switch */
  5    59     2 pad7 bit (17),
  5    60     2 pad8 bit (18),
  5    61 
  5    62     2 dtd bit (36),					/* date-time-dumped */
  5    63 
  5    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  5    65 
  5    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  5    67 
  5    68 
  5    69 
  5    70 
  5    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  5    72 
  5    73     2 primary_name char (32),				/* primary name of the segment */
  5    74 
  5    75     2 time_created bit (36),				/* time the segment was created */
  5    76 
  5    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  5    78 
  5    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  5    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  5    81 
  5    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  5    83 
  5    84     2 access_class bit (72),				/* access class in branch */
  5    85     2 perm_flags aligned,
  5    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  5    87       3 pad9 bit (35) unal,
  5    88     2 owner bit (36);				/* pvid of this volume */
  5    89 
  5    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  5    91 
  5    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  5    93     2 pad1 bit (7*36),
  5    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  5    95     2 pad2 bit (184*36);
  5    96 
  5    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      238 
      239 
      240 /* format: on */
      241 
      242 /* BEGIN MESSAGE DOCUMENTATION
      243*
      244*   Message:
      245*   priv_delete_vtoce: failed to lock WWWWWW ERROR_MESSAGE
      246*
      247*   S: $crash
      248*
      249*   T: $run
      250*
      251*   M: An attempt to lock a directory has failed.
      252*   $err
      253*
      254*   A: $recover
      255*   $boot_tape
      256*
      257*   END MESSAGE DOCUMENTATION */
      258 
      259      end priv_delete_vtoce;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0851.5  priv_delete_vtoce.pl1             >spec>install>1115>priv_delete_vtoce.pl1
234          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
235          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
236          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
237          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
238          5    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000004 constant        fixed bin(17,0)          initial dcl 4-7 set ref 134*
P_pvtx                                 parameter       fixed bin(17,0)          dcl 208 ref 200 220
P_vtocx                                parameter       fixed bin(17,0)          dcl 209 ref 200 220
a_code                                 parameter       fixed bin(17,0)          dcl 44 set ref 14 90 191*
a_pvid                                 parameter       bit(36)                  dcl 42 ref 14 90 97
a_uid                                  parameter       bit(36)                  dcl 41 ref 14 86
a_vtocx                                parameter       fixed bin(17,0)          dcl 43 ref 14 90 98
addr                                                   builtin function         dcl 81 ref 105 106 107
addrel                                                 builtin function         dcl 81 ref 224
aste                                   based           structure                level 1 dcl 1-11
aste_idx                        000601 automatic       fixed bin(17,0)          dcl 212 set ref 219*
binary                                                 builtin function         dcl 81 ref 224
clear_sw                        000107 automatic       bit(1)                   dcl 53 set ref 85* 92* 112 116 120 142 152 159
code                            000103 automatic       fixed bin(35,0)          dcl 49 set ref 99* 102* 103 109* 110 113* 133* 134
                                                                                  134* 139* 140 143* 148* 153* 161* 162 175* 185*
                                                                                  191
csl                       2(09)        based           bit(9)                   level 2 packed packed unaligned dcl 5-7 ref 171 171
delete_vtoce                    000026 constant        entry                    external dcl 70 ref 185
dim                                                    builtin function         dcl 81 ref 171
dir                                    based           structure                level 1 dcl 3-11 set ref 130*
dp                              000560 automatic       pointer                  dcl 3-9 set ref 106* 130 131 133*
entry                                  based           structure                level 1 dcl 2-8 set ref 179*
ep                              000556 automatic       pointer                  dcl 2-6 set ref 107* 179 180 181 182 183 185*
error_table_$illegal_deactivation
                                000022 external static fixed bin(35,0)          dcl 67 ref 148
error_table_$invalid_vtoce      000024 external static fixed bin(35,0)          dcl 68 ref 153 175
error_table_$vtoce_connection_fail
                                000020 external static fixed bin(35,0)          dcl 66 ref 113 143
fixed                                                  builtin function         dcl 81 ref 171 171 171 171 171
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 5-7 ref
                                                                                  171
get_pvtx                        000030 constant        entry                    external dcl 71 ref 102
i                               000105 automatic       fixed bin(17,0)          dcl 51 set ref 124* 124* 127
local_dir                       000155 automatic       structure                level 1 dcl 56 set ref 106
local_entry                     000110 automatic       structure                level 1 dcl 55 set ref 107
local_vtoce                     000255 automatic       structure                level 1 dcl 57 set ref 105
lock$dir_lock_write             000032 constant        entry                    external dcl 72 ref 133
lock$dir_unlock_given_uid       000040 constant        entry                    external dcl 75 ref 188
lock$lock_ast                   000034 constant        entry                    external dcl 73 ref 136
lock$unlock_ast                 000036 constant        entry                    external dcl 74 ref 164 168 194
msl                       2            based           bit(9)                   level 2 packed packed unaligned dcl 5-7 ref 171 171
my_astep                        000602 automatic       pointer                  dcl 213 set ref 216* 220 220 220 224* 224
no_aste                   0(18) 000016 external static fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 62 ref 219
null                                                   builtin function         dcl 81 ref 147 152 228
owner                    44            based           bit(36)                  level 2 dcl 2-8 set ref 180*
par_uid                         000101 automatic       bit(36)                  dcl 47 set ref 100* 127* 128 131 134* 188 188*
pool_idx                        000600 automatic       fixed bin(17,0)          dcl 211 set ref 218* 219 224*
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "priv_delete_vtoce" set ref
                                                                                  181*
pvid                            000102 automatic       bit(36)                  dcl 48 in procedure "priv_delete_vtoce" set ref 97*
                                                                                  102* 109* 139* 161* 181
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "priv_delete_vtoce" ref 220
pvtx                            000104 automatic       fixed bin(17,0)          dcl 50 in procedure "priv_delete_vtoce" set ref 102*
                                                                                  109* 139* 147* 161*
records                   2(18)        based           bit(9)                   level 2 packed packed unaligned dcl 5-7 ref 171
search_ast                      000042 constant        entry                    external dcl 76 ref 152
sst$astap                       000010 external static pointer                  dcl 59 ref 216
sst$astsize                     000012 external static fixed bin(17,0)          dcl 60 ref 224
sst$level                       000016 external static structure                array level 1 dcl 62
sst$pts                         000014 external static fixed bin(17,0)          array dcl 61 ref 224
syserr$error_code               000044 constant        entry                    external dcl 77 ref 134
uid                             000100 automatic       bit(36)                  dcl 46 in procedure "priv_delete_vtoce" set ref 86*
                                                                                  93* 112 116* 142 152* 182
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 3-11 in procedure
                                                                                  "priv_delete_vtoce" set ref 131*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "priv_delete_vtoce" set ref 182*
uid                       1            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 5-7 in procedure "priv_delete_vtoce" ref 112
                                                                                  116 142
uid_path                240            based           bit(36)                  array level 2 packed packed unaligned dcl 5-7 ref
                                                                                  122 124 127
unspec                                                 builtin function         dcl 81 set ref 130* 179*
vtoc_man$free_vtoce             000046 constant        entry                    external dcl 78 ref 161
vtoc_man$get_vtoce              000050 constant        entry                    external dcl 79 ref 109 139
vtoce                                  based           structure                level 1 dcl 5-7
vtocep                          000562 automatic       pointer                  dcl 5-5 set ref 105* 109* 112 116 122 124 127 139*
                                                                                  142 171 171 171 171 171 171
vtocx                           000106 automatic       fixed bin(17,0)          dcl 52 in procedure "priv_delete_vtoce" set ref 98*
                                                                                  109* 139* 147* 161* 183
vtocx                     4(18)        based           fixed bin(17,0)          level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 1-11 in procedure "priv_delete_vtoce" ref 220
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "priv_delete_vtoce" set ref
                                                                                  183*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 4-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
astep                                  automatic       pointer                  dcl 1-9
seg_aste                               based           structure                level 1 dcl 1-96
seg_vtoce                              based           structure                level 1 dcl 5-92
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84
vtoce_parts                            based           bit(2304)                array dcl 5-90

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_PARENT                      000262 constant        label                    dcl 136 ref 120 122 128
COMMON                          000073 constant        label                    dcl 97 ref 87 94
finale                          000500 constant        label                    dcl 188 ref 103 110 114 176 196
find_aste                       000522 constant        entry                    internal dcl 200 ref 147
priv_delete_vtoce               000027 constant        entry                    external dcl 14
priv_delete_vtoce$clear         000053 constant        entry                    external dcl 90
unlock_ast_finale               000514 constant        label                    dcl 194 set ref 140 144 149 154 162

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1054        1126     616        1064
Length      1430     616        52         266     235           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
priv_delete_vtoce                   452 external procedure  is an external procedure.  
find_aste                               internal procedure  shares stack frame of external procedure priv_delete_vtoce.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
priv_delete_vtoce        000100 uid                         priv_delete_vtoce
                         000101 par_uid                     priv_delete_vtoce
                         000102 pvid                        priv_delete_vtoce
                         000103 code                        priv_delete_vtoce
                         000104 pvtx                        priv_delete_vtoce
                         000105 i                           priv_delete_vtoce
                         000106 vtocx                       priv_delete_vtoce
                         000107 clear_sw                    priv_delete_vtoce
                         000110 local_entry                 priv_delete_vtoce
                         000155 local_dir                   priv_delete_vtoce
                         000255 local_vtoce                 priv_delete_vtoce
                         000556 ep                          priv_delete_vtoce
                         000560 dp                          priv_delete_vtoce
                         000562 vtocep                      priv_delete_vtoce
                         000600 pool_idx                    find_aste
                         000601 aste_idx                    find_aste
                         000602 my_astep                    find_aste

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
delete_vtoce                  get_pvtx                      lock$dir_lock_write           lock$dir_unlock_given_uid
lock$lock_ast                 lock$unlock_ast               search_ast                    syserr$error_code
vtoc_man$free_vtoce           vtoc_man$get_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$illegal_deactivation                           error_table_$invalid_vtoce
error_table_$vtoce_connection_fail                          sst$astap                     sst$astsize
sst$level                     sst$pts


CONSTANTS
000604  aa     000006000000
000605  aa     000000000000
000606  aa     600000000041
000607  aa     000104000000
000610  aa     600000000041
000611  aa     000106000000
000612  aa     600000000041
000613  aa     000700000000

000614  aa     777777777770

000000  aa     524000000045

000001  aa     404000000043

000615  aa     777777777777

000002  aa     464000000000

000003  aa     404000000021

000004  aa     000000000001

000005  aa     514000000044

000006  aa     077777000043
000007  aa     000001000000

000010  aa  160 162 151 166	priv
000011  aa  137 144 145 154	_del
000012  aa  145 164 145 137	ete_
000013  aa  166 164 157 143	vtoc
000014  aa  145 072 040 146	e: f
000015  aa  141 151 154 145	aile
000016  aa  144 040 164 157	d to
000017  aa  040 154 157 143	 loc
000020  aa  153 040 136 167	k ^w
000021  aa  040 000 000 000	 

BEGIN PROCEDURE priv_delete_vtoce
ENTRY TO priv_delete_vtoce                                  STATEMENT 1 ON LINE 14
priv_delete_vtoce: procedure (a_uid, a_pvid, a_vtocx, a_code);

000022  at     000004000005
000023  tt     000005000003
000024  ta     000003000000
000025  ta     000022000000
000026  da     000213300000
000027  aa   000720 6270 00	eax7 	464
000030  aa  7 00034 3521 20	epp2 	pr7|28,*
000031  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000032  aa     000010000000
000033  aa     000000000000
000034  aa  6 00032 3735 20	epp7 	pr6|26,*
000035  aa  7 00004 3715 20	epp5 	pr7|4,*
000036  aa  6 00564 6515 00	spri5	pr6|372
000037  aa  7 00006 3535 20	epp3 	pr7|6,*
000040  aa  6 00566 2535 00	spri3	pr6|374
000041  aa  7 00010 3515 20	epp1 	pr7|8,*
000042  aa  6 00570 2515 00	spri1	pr6|376
						STATEMENT 1 ON LINE 85
	clear_sw = "0"b;

000043  aa  6 00107 4501 00	stz  	pr6|71		clear_sw
						STATEMENT 1 ON LINE 86
	uid = a_uid;

000044  aa  7 00002 2351 20	lda  	pr7|2,*		a_uid
000045  aa  6 00100 7551 00	sta  	pr6|64		uid
						STATEMENT 1 ON LINE 87
	goto COMMON;

000046  aa   000025 7100 04	tra  	21,ic		000073
ENTRY TO priv_delete_vtoce$clear                            STATEMENT 1 ON LINE 90
priv_delete_vtoce$clear: entry (a_pvid, a_vtocx, a_code);

000047  at     000003000005
000050  tt     000003000003
000051  ta     000047000000
000052  da     000231300000
000053  aa   000720 6270 00	eax7 	464
000054  aa  7 00034 3521 20	epp2 	pr7|28,*
000055  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000056  aa     000006000000
000057  aa     000000000000
000060  aa  6 00032 3735 20	epp7 	pr6|26,*
000061  aa  7 00002 3715 20	epp5 	pr7|2,*
000062  aa  6 00564 6515 00	spri5	pr6|372
000063  aa  7 00004 3535 20	epp3 	pr7|4,*
000064  aa  6 00566 2535 00	spri3	pr6|374
000065  aa  7 00006 3515 20	epp1 	pr7|6,*
000066  aa  6 00570 2515 00	spri1	pr6|376
						STATEMENT 1 ON LINE 92
	clear_sw = "1"b;

000067  aa   400000 2350 03	lda  	131072,du
000070  aa  6 00107 7551 00	sta  	pr6|71		clear_sw
						STATEMENT 1 ON LINE 93
	uid = ""b;

000071  aa  6 00100 4501 00	stz  	pr6|64		uid
						STATEMENT 1 ON LINE 94
	goto COMMON;

000072  aa   000001 7100 04	tra  	1,ic		000073
						STATEMENT 1 ON LINE 97
COMMON:	pvid = a_pvid;

000073  aa  6 00564 2351 20	lda  	pr6|372,*		a_pvid
000074  aa  6 00102 7551 00	sta  	pr6|66		pvid
						STATEMENT 1 ON LINE 98
	vtocx = a_vtocx;

000075  aa  6 00566 2361 20	ldq  	pr6|374,*		a_vtocx
000076  aa  6 00106 7561 00	stq  	pr6|70		vtocx
						STATEMENT 1 ON LINE 99
	code = 0;

000077  aa  6 00103 4501 00	stz  	pr6|67		code
						STATEMENT 1 ON LINE 100
	par_uid = ""b;

000100  aa  6 00101 4501 00	stz  	pr6|65		par_uid
						STATEMENT 1 ON LINE 102
	pvtx = get_pvtx (pvid, code);

000101  aa  6 00102 3521 00	epp2 	pr6|66		pvid
000102  aa  6 00630 2521 00	spri2	pr6|408
000103  aa  6 00103 3521 00	epp2 	pr6|67		code
000104  aa  6 00632 2521 00	spri2	pr6|410
000105  aa  6 00104 3521 00	epp2 	pr6|68		pvtx
000106  aa  6 00634 2521 00	spri2	pr6|412
000107  aa  6 00626 6211 00	eax1 	pr6|406
000110  aa   014000 4310 07	fld  	6144,dl
000111  aa  6 00044 3701 20	epp4 	pr6|36,*
000112  la  4 00030 3521 20	epp2 	pr4|24,*		get_pvtx
000113  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 103
	if code ^= 0 then go to finale;

000114  aa  6 00103 2361 00	ldq  	pr6|67		code
000115  aa   000363 6010 04	tnz  	243,ic		000500
						STATEMENT 1 ON LINE 105
	vtocep = addr (local_vtoce);

000116  aa  6 00255 3735 00	epp7 	pr6|173		local_vtoce
000117  aa  6 00562 6535 00	spri7	pr6|370		vtocep
						STATEMENT 1 ON LINE 106
	dp = addr (local_dir);

000120  aa  6 00155 3715 00	epp5 	pr6|109		local_dir
000121  aa  6 00560 6515 00	spri5	pr6|368		dp
						STATEMENT 1 ON LINE 107
	ep = addr (local_entry);

000122  aa  6 00110 3535 00	epp3 	pr6|72		local_entry
000123  aa  6 00556 2535 00	spri3	pr6|366		ep
						STATEMENT 1 ON LINE 109
	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "101"b, vtocep, code);

000124  aa   500000 2350 03	lda  	163840,du
000125  aa  6 00636 7551 00	sta  	pr6|414
000126  aa  6 00102 3521 00	epp2 	pr6|66		pvid
000127  aa  6 00642 2521 00	spri2	pr6|418
000130  aa  6 00104 3521 00	epp2 	pr6|68		pvtx
000131  aa  6 00644 2521 00	spri2	pr6|420
000132  aa  6 00106 3521 00	epp2 	pr6|70		vtocx
000133  aa  6 00646 2521 00	spri2	pr6|422
000134  aa  6 00636 3521 00	epp2 	pr6|414
000135  aa  6 00650 2521 00	spri2	pr6|424
000136  aa  6 00562 3521 00	epp2 	pr6|370		vtocep
000137  aa  6 00652 2521 00	spri2	pr6|426
000140  aa  6 00103 3521 00	epp2 	pr6|67		code
000141  aa  6 00654 2521 00	spri2	pr6|428
000142  aa  6 00640 6211 00	eax1 	pr6|416
000143  aa   030000 4310 07	fld  	12288,dl
000144  aa  6 00044 3701 20	epp4 	pr6|36,*
000145  la  4 00050 3521 20	epp2 	pr4|40,*		vtoc_man$get_vtoce
000146  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 110
	if code ^= 0 then go to finale;

000147  aa  6 00103 2361 00	ldq  	pr6|67		code
000150  aa   000330 6010 04	tnz  	216,ic		000500
						STATEMENT 1 ON LINE 112
	if (vtoce.uid ^= uid) & (^clear_sw) then do;

000151  aa  6 00562 3735 20	epp7 	pr6|370,*		vtocep
000152  aa  7 00001 2351 00	lda  	pr7|1		vtoce.uid
000153  aa  6 00100 1151 00	cmpa 	pr6|64		uid
000154  aa   000007 6000 04	tze  	7,ic		000163
000155  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000156  aa   000005 6010 04	tnz  	5,ic		000163
						STATEMENT 1 ON LINE 113
	     code = error_table_$vtoce_connection_fail;

000157  aa  6 00044 3701 20	epp4 	pr6|36,*
000160  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$vtoce_connection_fail
000161  aa  6 00103 7561 00	stq  	pr6|67		code
						STATEMENT 1 ON LINE 114
	     go to finale;

000162  aa   000316 7100 04	tra  	206,ic		000500
						STATEMENT 1 ON LINE 115
	end;

						STATEMENT 1 ON LINE 116
	if clear_sw then uid = vtoce.uid;

000163  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000164  aa   000003 6000 04	tze  	3,ic		000167
000165  aa  7 00001 2351 00	lda  	pr7|1		vtoce.uid
000166  aa  6 00100 7551 00	sta  	pr6|64		uid
						STATEMENT 1 ON LINE 120
	if clear_sw then goto BAD_PARENT;

000167  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000170  aa   000072 6010 04	tnz  	58,ic		000262
						STATEMENT 1 ON LINE 122
	if vtoce.uid_path (0) ^= "777777777777"b3 then goto BAD_PARENT;

000171  aa  7 00240 2351 00	lda  	pr7|160		vtoce.uid_path
000172  aa   000423 1150 04	cmpa 	275,ic		000615 = 777777777777
000173  aa   000067 6010 04	tnz  	55,ic		000262
						STATEMENT 1 ON LINE 124
	do i = 15 to 0 by -1 while (vtoce.uid_path (i) = "0"b);

000174  aa   000017 2360 07	ldq  	15,dl
000175  aa  6 00105 7561 00	stq  	pr6|69		i
000176  aa  6 00105 2361 00	ldq  	pr6|69		i
000177  aa   000007 6040 04	tmi  	7,ic		000206
000200  aa  6 00562 3735 20	epp7 	pr6|370,*		vtocep
000201  aa  7 00240 2351 06	lda  	pr7|160,ql	vtoce.uid_path
000202  aa   000004 6010 04	tnz  	4,ic		000206
						STATEMENT 1 ON LINE 125
	end;

000203  aa   000001 3360 07	lcq  	1,dl
000204  aa  6 00105 0561 00	asq  	pr6|69		i
000205  aa   777771 7100 04	tra  	-7,ic		000176
						STATEMENT 1 ON LINE 127
	par_uid = vtoce.uid_path (i);

000206  aa  6 00562 3735 20	epp7 	pr6|370,*		vtocep
000207  aa  7 00240 2351 06	lda  	pr7|160,ql	vtoce.uid_path
000210  aa  6 00101 7551 00	sta  	pr6|65		par_uid
						STATEMENT 1 ON LINE 128
	if par_uid = ""b then goto BAD_PARENT;

000211  aa   000051 6000 04	tze  	41,ic		000262
						STATEMENT 1 ON LINE 130
	unspec (dir) = "0"b;

000212  aa  6 00560 3715 20	epp5 	pr6|368,*		dp
000213  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000214  aa   000000 00 0000	desc9a	0,0
000215  aa  5 00000 00 0400	desc9a	pr5|0,256
						STATEMENT 1 ON LINE 131
	dir.uid = par_uid;

000216  aa  5 00010 7551 00	sta  	pr5|8		dir.uid
						STATEMENT 1 ON LINE 133
	call lock$dir_lock_write (dp, code);

000217  aa  6 00560 3521 00	epp2 	pr6|368		dp
000220  aa  6 00630 2521 00	spri2	pr6|408
000221  aa  6 00103 3521 00	epp2 	pr6|67		code
000222  aa  6 00632 2521 00	spri2	pr6|410
000223  aa  6 00626 6211 00	eax1 	pr6|406
000224  aa   010000 4310 07	fld  	4096,dl
000225  aa  6 00044 3701 20	epp4 	pr6|36,*
000226  la  4 00032 3521 20	epp2 	pr4|26,*		lock$dir_lock_write
000227  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 134
	if code ^= 0 then call syserr$error_code (CRASH, code, "priv_delete_vtoce: failed to lock ^w ", par_uid);

000230  aa  6 00103 2361 00	ldq  	pr6|67		code
000231  aa   000031 6000 04	tze  	25,ic		000262
000232  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000233  aa   777556 00 0050	desc9a	-146,40		000010 = 160162151166
000234  aa  6 00640 00 0050	desc9a	pr6|416,40
000235  aa   777547 3520 04	epp2 	-153,ic		000004 = 000000000001
000236  aa  6 00660 2521 00	spri2	pr6|432
000237  aa  6 00103 3521 00	epp2 	pr6|67		code
000240  aa  6 00662 2521 00	spri2	pr6|434
000241  aa  6 00640 3521 00	epp2 	pr6|416
000242  aa  6 00664 2521 00	spri2	pr6|436
000243  aa  6 00101 3521 00	epp2 	pr6|65		par_uid
000244  aa  6 00666 2521 00	spri2	pr6|438
000245  aa   777536 3520 04	epp2 	-162,ic		000003 = 404000000021
000246  aa  6 00670 2521 00	spri2	pr6|440
000247  aa   777532 3520 04	epp2 	-166,ic		000001 = 404000000043
000250  aa  6 00672 2521 00	spri2	pr6|442
000251  aa   777527 3520 04	epp2 	-169,ic		000000 = 524000000045
000252  aa  6 00674 2521 00	spri2	pr6|444
000253  aa   777532 3520 04	epp2 	-166,ic		000005 = 514000000044
000254  aa  6 00676 2521 00	spri2	pr6|446
000255  aa  6 00656 6211 00	eax1 	pr6|430
000256  aa   020000 4310 07	fld  	8192,dl
000257  aa  6 00044 3701 20	epp4 	pr6|36,*
000260  la  4 00044 3521 20	epp2 	pr4|36,*		syserr$error_code
000261  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 136
BAD_PARENT:
	call lock$lock_ast;

000262  aa  6 00056 6211 00	eax1 	pr6|46
000263  aa   000000 4310 07	fld  	0,dl
000264  aa  6 00044 3701 20	epp4 	pr6|36,*
000265  la  4 00034 3521 20	epp2 	pr4|28,*		lock$lock_ast
000266  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 139
	call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "101"b, vtocep, code);

000267  aa   500000 2350 03	lda  	163840,du
000270  aa  6 00636 7551 00	sta  	pr6|414
000271  aa  6 00102 3521 00	epp2 	pr6|66		pvid
000272  aa  6 00642 2521 00	spri2	pr6|418
000273  aa  6 00104 3521 00	epp2 	pr6|68		pvtx
000274  aa  6 00644 2521 00	spri2	pr6|420
000275  aa  6 00106 3521 00	epp2 	pr6|70		vtocx
000276  aa  6 00646 2521 00	spri2	pr6|422
000277  aa  6 00636 3521 00	epp2 	pr6|414
000300  aa  6 00650 2521 00	spri2	pr6|424
000301  aa  6 00562 3521 00	epp2 	pr6|370		vtocep
000302  aa  6 00652 2521 00	spri2	pr6|426
000303  aa  6 00103 3521 00	epp2 	pr6|67		code
000304  aa  6 00654 2521 00	spri2	pr6|428
000305  aa  6 00640 6211 00	eax1 	pr6|416
000306  aa   030000 4310 07	fld  	12288,dl
000307  aa  6 00044 3701 20	epp4 	pr6|36,*
000310  la  4 00050 3521 20	epp2 	pr4|40,*		vtoc_man$get_vtoce
000311  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 140
	if code ^= 0 then go to unlock_ast_finale;

000312  aa  6 00103 2361 00	ldq  	pr6|67		code
000313  aa   000201 6010 04	tnz  	129,ic		000514
						STATEMENT 1 ON LINE 142
	if (vtoce.uid ^= uid) & (^clear_sw) then do;

000314  aa  6 00562 3735 20	epp7 	pr6|370,*		vtocep
000315  aa  7 00001 2351 00	lda  	pr7|1		vtoce.uid
000316  aa  6 00100 1151 00	cmpa 	pr6|64		uid
000317  aa   000007 6000 04	tze  	7,ic		000326
000320  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000321  aa   000005 6010 04	tnz  	5,ic		000326
						STATEMENT 1 ON LINE 143
	     code = error_table_$vtoce_connection_fail;

000322  aa  6 00044 3701 20	epp4 	pr6|36,*
000323  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$vtoce_connection_fail
000324  aa  6 00103 7561 00	stq  	pr6|67		code
						STATEMENT 1 ON LINE 144
	     go to unlock_ast_finale;

000325  aa   000167 7100 04	tra  	119,ic		000514
						STATEMENT 1 ON LINE 145
	end;

						STATEMENT 1 ON LINE 147
	if find_aste (pvtx, vtocx) ^= null () then do;

000326  aa   000256 3520 04	epp2 	174,ic		000604 = 000006000000
000327  aa   000173 6700 04	tsp4 	123,ic		000522
000330  aa  6 00700 2371 00	ldaq 	pr6|448
000331  aa   777455 6770 04	eraq 	-211,ic		000006 = 077777000043 000001000000
000332  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000333  aa   000005 6000 04	tze  	5,ic		000340
						STATEMENT 1 ON LINE 148
	     code = error_table_$illegal_deactivation;

000334  aa  6 00044 3701 20	epp4 	pr6|36,*
000335  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$illegal_deactivation
000336  aa  6 00103 7561 00	stq  	pr6|67		code
						STATEMENT 1 ON LINE 149
	     go to unlock_ast_finale;

000337  aa   000155 7100 04	tra  	109,ic		000514
						STATEMENT 1 ON LINE 150
	end;

						STATEMENT 1 ON LINE 152
	if (search_ast (uid) ^= null ()) & (^clear_sw) then do;

000340  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000341  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000342  aa  6 00636 7551 00	sta  	pr6|414
000343  aa  6 00100 3521 00	epp2 	pr6|64		uid
000344  aa  6 00630 2521 00	spri2	pr6|408
000345  aa  6 00700 3521 00	epp2 	pr6|448
000346  aa  6 00632 2521 00	spri2	pr6|410
000347  aa  6 00626 6211 00	eax1 	pr6|406
000350  aa   010000 4310 07	fld  	4096,dl
000351  aa  6 00044 3701 20	epp4 	pr6|36,*
000352  la  4 00042 3521 20	epp2 	pr4|34,*		search_ast
000353  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000354  aa  6 00700 2371 00	ldaq 	pr6|448
000355  aa   777431 6770 04	eraq 	-231,ic		000006 = 077777000043 000001000000
000356  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000357  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
000360  aa  6 00636 3151 00	cana 	pr6|414
000361  aa   000005 6000 04	tze  	5,ic		000366
						STATEMENT 1 ON LINE 153
	     code = error_table_$invalid_vtoce;

000362  aa  6 00044 3701 20	epp4 	pr6|36,*
000363  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$invalid_vtoce
000364  aa  6 00103 7561 00	stq  	pr6|67		code
						STATEMENT 1 ON LINE 154
	     goto unlock_ast_finale;

000365  aa   000127 7100 04	tra  	87,ic		000514
						STATEMENT 1 ON LINE 155
	end;

						STATEMENT 1 ON LINE 159
	if clear_sw then do;

000366  aa  6 00107 2351 00	lda  	pr6|71		clear_sw
000367  aa   000026 6000 04	tze  	22,ic		000415
						STATEMENT 1 ON LINE 161
	     call vtoc_man$free_vtoce (pvid, pvtx, vtocx, code);

000370  aa  6 00102 3521 00	epp2 	pr6|66		pvid
000371  aa  6 00642 2521 00	spri2	pr6|418
000372  aa  6 00104 3521 00	epp2 	pr6|68		pvtx
000373  aa  6 00644 2521 00	spri2	pr6|420
000374  aa  6 00106 3521 00	epp2 	pr6|70		vtocx
000375  aa  6 00646 2521 00	spri2	pr6|422
000376  aa  6 00103 3521 00	epp2 	pr6|67		code
000377  aa  6 00650 2521 00	spri2	pr6|424
000400  aa  6 00640 6211 00	eax1 	pr6|416
000401  aa   020000 4310 07	fld  	8192,dl
000402  aa  6 00044 3701 20	epp4 	pr6|36,*
000403  la  4 00046 3521 20	epp2 	pr4|38,*		vtoc_man$free_vtoce
000404  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 162
	     if code ^= 0 then go to unlock_ast_finale;

000405  aa  6 00103 2361 00	ldq  	pr6|67		code
000406  aa   000106 6010 04	tnz  	70,ic		000514
						STATEMENT 1 ON LINE 164
	     call lock$unlock_ast ();

000407  aa  6 00056 6211 00	eax1 	pr6|46
000410  aa   000000 4310 07	fld  	0,dl
000411  aa  6 00044 3701 20	epp4 	pr6|36,*
000412  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_ast
000413  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 165
	end;

000414  aa   000064 7100 04	tra  	52,ic		000500
						STATEMENT 1 ON LINE 167
	else do;

						STATEMENT 1 ON LINE 168
	     call lock$unlock_ast ();

000415  aa  6 00056 6211 00	eax1 	pr6|46
000416  aa   000000 4310 07	fld  	0,dl
000417  aa  6 00044 3701 20	epp4 	pr6|36,*
000420  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_ast
000421  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 171
	     if fixed (vtoce.records) > fixed (vtoce.csl) /* Validate the VTOCE a bit */
		| fixed (vtoce.csl) > fixed (vtoce.msl)
		| fixed (vtoce.msl) > dim (vtoce.fm, 1)
	     then do;

000422  aa  6 00562 3735 20	epp7 	pr6|370,*		vtocep
000423  aa  7 00002 2351 00	lda  	pr7|2		vtoce.msl
000424  aa   000077 7730 00	lrl  	63
000425  aa  6 00700 7571 00	staq 	pr6|448
000426  aa  7 00002 2351 00	lda  	pr7|2		vtoce.csl
000427  aa   000011 7350 00	als  	9
000430  aa   000077 7730 00	lrl  	63
000431  aa  6 00702 7571 00	staq 	pr6|450
000432  aa  7 00002 2351 00	lda  	pr7|2		vtoce.records
000433  aa   000022 7350 00	als  	18
000434  aa   000077 7730 00	lrl  	63
000435  aa  6 00702 1171 00	cmpaq	pr6|450
000436  aa   000010 6054 04	tpnz 	8,ic		000446
000437  aa  6 00702 2371 00	ldaq 	pr6|450
000440  aa  6 00700 1171 00	cmpaq	pr6|448
000441  aa   000005 6054 04	tpnz 	5,ic		000446
000442  aa   000400 2350 07	lda  	256,dl
000443  aa   000044 7330 00	lrs  	36
000444  aa  6 00700 1171 00	cmpaq	pr6|448
000445  aa   000005 6050 04	tpl  	5,ic		000452
						STATEMENT 1 ON LINE 175
		code = error_table_$invalid_vtoce;

000446  aa  6 00044 3701 20	epp4 	pr6|36,*
000447  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$invalid_vtoce
000450  aa  6 00103 7561 00	stq  	pr6|67		code
						STATEMENT 1 ON LINE 176
		goto finale;

000451  aa   000027 7100 04	tra  	23,ic		000500
						STATEMENT 1 ON LINE 177
	     end;

						STATEMENT 1 ON LINE 179
	     unspec (entry) = ""b;

000452  aa  6 00556 3715 20	epp5 	pr6|366,*		ep
000453  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000454  aa   000000 00 0000	desc9a	0,0
000455  aa  5 00000 00 0224	desc9a	pr5|0,148
						STATEMENT 1 ON LINE 180
	     entry.owner = "777777777770"b3;

000456  aa   000136 2350 04	lda  	94,ic		000614 = 777777777770
000457  aa  5 00044 7551 00	sta  	pr5|36		entry.owner
						STATEMENT 1 ON LINE 181
	     entry.pvid = pvid;

000460  aa  6 00102 2351 00	lda  	pr6|66		pvid
000461  aa  5 00030 7551 00	sta  	pr5|24		entry.pvid
						STATEMENT 1 ON LINE 182
	     entry.uid = uid;

000462  aa  6 00100 2351 00	lda  	pr6|64		uid
000463  aa  5 00002 7551 00	sta  	pr5|2		entry.uid
						STATEMENT 1 ON LINE 183
	     entry.vtocx = vtocx;

000464  aa  6 00106 2361 00	ldq  	pr6|70		vtocx
000465  aa   000066 7370 00	lls  	54
000466  aa  5 00031 5511 60	stba 	pr5|25,60		entry.vtocx
						STATEMENT 1 ON LINE 185
	     call delete_vtoce (ep, code);

000467  aa  6 00556 3521 00	epp2 	pr6|366		ep
000470  aa  6 00630 2521 00	spri2	pr6|408
000471  aa  6 00103 3521 00	epp2 	pr6|67		code
000472  aa  6 00632 2521 00	spri2	pr6|410
000473  aa  6 00626 6211 00	eax1 	pr6|406
000474  aa   010000 4310 07	fld  	4096,dl
000475  aa  6 00044 3701 20	epp4 	pr6|36,*
000476  la  4 00026 3521 20	epp2 	pr4|22,*		delete_vtoce
000477  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 186
	end;

						STATEMENT 1 ON LINE 188
finale:	if par_uid ^= ""b then			/* If there was a parent, then */
	     call lock$dir_unlock_given_uid (par_uid);

000500  aa  6 00101 2351 00	lda  	pr6|65		par_uid
000501  aa   000010 6000 04	tze  	8,ic		000511
000502  aa  6 00101 3521 00	epp2 	pr6|65		par_uid
000503  aa  6 00630 2521 00	spri2	pr6|408
000504  aa  6 00626 6211 00	eax1 	pr6|406
000505  aa   004000 4310 07	fld  	2048,dl
000506  aa  6 00044 3701 20	epp4 	pr6|36,*
000507  la  4 00040 3521 20	epp2 	pr4|32,*		lock$dir_unlock_given_uid
000510  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 191
	a_code = code;

000511  aa  6 00103 2361 00	ldq  	pr6|67		code
000512  aa  6 00570 7561 20	stq  	pr6|376,*		a_code
						STATEMENT 1 ON LINE 192
	return;

000513  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 194
unlock_ast_finale:
	call lock$unlock_ast;

000514  aa  6 00056 6211 00	eax1 	pr6|46
000515  aa   000000 4310 07	fld  	0,dl
000516  aa  6 00044 3701 20	epp4 	pr6|36,*
000517  la  4 00036 3521 20	epp2 	pr4|30,*		lock$unlock_ast
000520  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 196
	goto finale;

000521  aa   777757 7100 04	tra  	-17,ic		000500
						STATEMENT 1 ON LINE 259
     end priv_delete_vtoce;

BEGIN PROCEDURE find_aste
ENTRY TO find_aste                                          STATEMENT 1 ON LINE 200
find_aste: proc (P_pvtx, P_vtocx) returns (pointer);

000522  aa  6 00572 6501 00	spri4	pr6|378
000523  aa  6 00574 2521 00	spri2	pr6|380
						STATEMENT 1 ON LINE 216
	my_astep = sst$astap;

000524  aa  6 00044 3701 20	epp4 	pr6|36,*
000525  la  4 00010 3735 20	epp7 	pr4|8,*		sst$astap
000526  aa  7 00000 3735 20	epp7 	pr7|0,*		sst$astap
000527  aa  6 00602 6535 00	spri7	pr6|386		my_astep
						STATEMENT 1 ON LINE 218
	do pool_idx = 0 to 3;

000530  aa  6 00600 4501 00	stz  	pr6|384		pool_idx
000531  aa   000000 0110 03	nop  	0,du
000532  aa  6 00600 2361 00	ldq  	pr6|384		pool_idx
000533  aa   000003 1160 07	cmpq 	3,dl
000534  aa   000043 6054 04	tpnz 	35,ic		000577
						STATEMENT 1 ON LINE 219
	     do aste_idx = 1 to sst$level (pool_idx).no_aste;

000535  aa  6 00044 3701 20	epp4 	pr6|36,*
000536  la  4 00016 2361 66	ldq  	pr4|14,*ql	sst$level.no_aste
000537  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000540  aa  6 00604 7561 00	stq  	pr6|388
000541  aa   000001 2360 07	ldq  	1,dl
000542  aa  6 00601 7561 00	stq  	pr6|385		aste_idx
000543  aa   000000 0110 03	nop  	0,du
000544  aa  6 00601 2361 00	ldq  	pr6|385		aste_idx
000545  aa  6 00604 1161 00	cmpq 	pr6|388
000546  aa   000027 6054 04	tpnz 	23,ic		000575
						STATEMENT 1 ON LINE 220
		if (my_astep -> aste.vtocx = P_vtocx) then
		     if (my_astep -> aste.pvtx = P_pvtx) then
			return (my_astep);

000547  aa  6 00602 3735 20	epp7 	pr6|386,*		my_astep
000550  aa  7 00004 2351 00	lda  	pr7|4		aste.vtocx
000551  aa   000022 7350 00	als  	18
000552  aa   000066 7330 00	lrs  	54
000553  aa  6 00574 3715 20	epp5 	pr6|380,*
000554  aa  5 00004 1161 20	cmpq 	pr5|4,*		P_vtocx
000555  aa   000010 6010 04	tnz  	8,ic		000565
000556  aa  7 00004 2351 00	lda  	pr7|4		aste.pvtx
000557  aa   000011 7350 00	als  	9
000560  aa   000077 7330 00	lrs  	63
000561  aa  5 00002 1161 20	cmpq 	pr5|2,*		P_pvtx
000562  aa   000003 6010 04	tnz  	3,ic		000565
000563  aa  5 00006 6535 20	spri7	pr5|6,*
000564  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 224
		my_astep = addrel (my_astep, binary (sst$pts (pool_idx) + sst$astsize, 18));

000565  aa  6 00600 7271 00	lxl7 	pr6|384		pool_idx
000566  aa  6 00044 3701 20	epp4 	pr6|36,*
000567  la  4 00014 2361 77	ldq  	pr4|12,*7		sst$pts
000570  la  4 00012 0761 20	adq  	pr4|10,*		sst$astsize
000571  aa  7 00000 5075 06	awd  	pr7|0,ql
000572  aa  6 00602 6535 00	spri7	pr6|386		my_astep
						STATEMENT 1 ON LINE 225
	     end;

000573  aa  6 00601 0541 00	aos  	pr6|385		aste_idx
000574  aa   777750 7100 04	tra  	-24,ic		000544
						STATEMENT 1 ON LINE 226
	end;

000575  aa  6 00600 0541 00	aos  	pr6|384		pool_idx
000576  aa   777734 7100 04	tra  	-36,ic		000532
						STATEMENT 1 ON LINE 228
	return (null ());

000577  aa   777207 2370 04	ldaq 	-377,ic		000006 = 077777000043 000001000000
000600  aa  6 00574 3735 20	epp7 	pr6|380,*
000601  aa  7 00006 7571 20	staq 	pr7|6,*
000602  aa  6 00572 6101 00	rtcd 	pr6|378
						STATEMENT 1 ON LINE 230
     end find_aste;

  END PROCEDURE find_aste
  END PROCEDURE priv_delete_vtoce


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
