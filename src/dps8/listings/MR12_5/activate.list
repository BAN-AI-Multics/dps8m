	COMPILATION LISTING OF SEGMENT activate
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1024.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       16*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       17*     Correct error message documentation.
       18*  2) change(86-05-28,Fawcett), approve(86-04-11,MCR7383),
       19*     audit(86-05-28,Coppola), install(86-07-17,MR12.0-1097):
       20*     Add support for subvolumes.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 /*
       24*   astep = activate (branchp, code)
       25*
       26*   FUNCTION -
       27*
       28*   This procedure activates the segment whose branch is pointed  to  by  the  input
       29*   argument  "branchp",  and it returns the aste pointer for that segment. In order
       30*   to activate the segment this procedure activates  any  superior  directory  that
       31*   happens  to  be inactive. If the operation is successful, the return occurs with
       32*   the following state: astep ^= null, code = 0  and  AST  is  locked.  It  is  the
       33*   responsability  of  the  caller to unlock the AST whenever it is appropriate. If
       34*   the operation fails, the return occurs with the following state: astep  =  null,
       35*   code ^= 0 and AST is unlocked.
       36*
       37*
       38*   MODIFICATIONS -
       39*
       40*   85-01-04 by Keith Loepere to set aste.multi_class.
       41*   84-01-31 by BIM. SST reformat. Close window due to extra AST unlock for
       42*   parent segfault that I missed the first time.
       43*   05/30/83 by E. N. Kittlitz for search_ast$check
       44*   10/26/82 by J. Bongiovanni for synchronized segments, filemap checksum
       45*   7/10/82 by J. Bongiovanni to read entire VTOCE
       46*   3/7/82 by J. Bongiovanni for new PVTE
       47*   12/25/81 by Benson I. Margulies to not depend on the directory read
       48*   lock as protection against activations.
       49*   5/31/81 by J. Bongiovanni to validate fields in VTOCE
       50*   03/21/81, W. Olin Sibert, for ADP PTWs and SDWs, and get_ptrs_$given_sdw
       51*   02/81 by E. N. Kittlitz for activate_long entry
       52*   04/77 by THVV for damaged sw and messages
       53*   8/76 by D. Vinograd to add entry for activating without parent being active.
       54*   This entry, backup_activate, is used only by the volume dumper.
       55*   09/13/76 by Greenberg to meter activations and fixe demount window error reporting
       56*   03/25/76 by R. Bratt to fix gtpd bug and add explicit user deactive capability
       57*   04/08/75 by Andre Bensoussan. This procedure has been completely rewritten for
       58*   the new storage system.
       59**/
       60 /* format: style4 */
       61 
       62 
       63 activate: proc (branchp, code) returns (ptr);
       64 
       65 
       66 dcl  branchp ptr,					/* Input  - branch pointer */
       67      a_vtocep ptr,
       68      a_pvtx fixed bin,
       69      a_vtocx fixed bin,
       70      a_activated_sw bit (1) aligned,
       71      code fixed bin (35);				/* Output - error code */
       72 
       73 
       74 dcl  ast_unlocked bit (1) aligned;
       75 dcl  (par_astep, par_sdwp) ptr;
       76 dcl  (pvtx, vtocx, esw) fixed bin (17);
       77 dcl  (uid, pvid, temp) bit (36) aligned;
       78 dcl  old_par_ehs bit (1);
       79 dcl  already_active_by_backup bit (1);
       80 dcl  dirsw bit (1);
       81 dcl  multi_class bit (1);
       82 
       83 dcl  long_sw bit (1) aligned;
       84 dcl  1 local_vtoce like vtoce aligned;
       85 dcl  1 par_aste like aste aligned based (par_astep);
       86 dcl  checksum bit (36) aligned;
       87 dcl  p99 pic "99";
       88 
       89 dcl  normal fixed bin internal static init (1);
       90 dcl  backup fixed bin internal static init (2);
       91 
       92 dcl  sst$checksum_filemap fixed bin (35) external static;
       93 dcl  sst$damaged_ct fixed bin (35) external static;
       94 dcl  sst$dm_enabled bit (1) aligned external static;
       95 dcl  sst$activations fixed bin (35) external static;
       96 dcl  sst$backup_activations fixed bin (35) external static;
       97 dcl  sst$dir_activations fixed bin (35) external static;
       98 dcl  dseg$ (0:1023) fixed bin (71) external static;
       99 dcl  error_table_$synch_seg_limit fixed bin (35) ext;
      100 dcl  error_table_$vtoce_connection_fail fixed bin (35) ext;
      101 dcl  error_table_$pvid_not_found ext fixed bin (35);
      102 dcl  error_table_$illegal_activation fixed bin (35) ext;
      103 dcl  error_table_$invalid_vtoce fixed bin (35) ext;
      104 dcl  error_table_$dm_not_enabled fixed bin (35) ext;
      105 
      106 dcl  pc$fill_page_table entry (ptr, ptr, fixed bin);
      107 dcl  get_aste entry (fixed bin) returns (ptr);
      108 dcl  get_aste$synchronized entry (fixed bin) returns (ptr);
      109 dcl  lock$lock_ast entry;
      110 dcl  lock$unlock_ast entry;
      111 dcl  search_ast$check entry (bit (36) aligned, bit (36) aligned, fixed bin, fixed bin (35)) returns (ptr);
      112 dcl  search_ast$hash_in entry (ptr);
      113 dcl  get_pvtx entry (bit (36) aligned, fixed bin (35)) returns (fixed bin);
      114 dcl  vtoc_man$get_vtoce entry (bit (36) aligned, fixed bin, fixed bin, bit (3), ptr, fixed bin (35));
      115 dcl  get_ptrs_$given_sdw entry (pointer) returns (pointer);
      116 dcl  filemap_checksum_ entry (ptr, fixed bin, bit (36) aligned);
      117 dcl  sdw_util_$get_valid entry (pointer) returns (bit (1) aligned);
      118 dcl  syserr entry options (variable);
      119 dcl  syserr$binary entry options (variable);
      120 
      121 dcl  (addr, baseno, bin, convert, dim, divide, fixed, null,
      122      ptr, rel, rtrim) builtin;
      123 
      124 	long_sw = "0"b;
      125 	goto START;
      126 
      127 
      128 /* activate_long is the same as activate, except that extra information
      129*   is returned to the caller. */
      130 
      131 activate_long: entry (branchp, a_activated_sw, code) returns (ptr);
      132 
      133 	long_sw = "1"b;
      134 	a_activated_sw = "0"b;
      135 
      136 START:
      137 	ep = branchp;
      138 	dp = ptr (ep, 0);
      139 	uid = entry.uid;
      140 	pvid = entry.pvid;
      141 	vtocx = entry.vtocx;
      142 	dirsw = entry.dirsw;
      143 	multi_class = entry.multiple_class;
      144 	temp_entry_name = addr (ep -> entry.primary_name) -> names.name;
      145 	pvtx = get_pvtx (pvid, code);
      146 	if code ^= 0 then return (null);
      147 	esw = normal;
      148 
      149 COMMON:
      150 	code = 0;
      151 	already_active_by_backup = "0"b;
      152 	pvt_arrayp = addr (pvt$array);
      153 	pvtep = addr (pvt_array (pvtx));
      154 	call lock$lock_ast;
      155 
      156 /**** before multi-read directory locks, the directory lock was
      157*      sufficient to protect against another processor making an activation.
      158*      Thus the code below could unlock the AST, do VTOC I/O, and lock
      159*      the AST, secure in the knowledge that nobody else was going
      160*      to do the same thing while it was waiting for the I/O. This
      161*      had the additional side effect of locking out any directory
      162*      accesses for the duration.
      163*
      164*      Now, the AST hash table is searched a second time after
      165*      the AST is relocked after the VTOC I/O. If the uid is found,
      166*      the code go-to's to ACTIVATED_BY_SOMEONE_ELSE to rejoin
      167*      the same sequence that it would have taken had the segment
      168*      been active to begin with.
      169*
      170*      Under the new locking strategy, a program that wishes to protect
      171*      against activations in a directory MUST HOLD A WRITE LOCK ON
      172*      THAT DIRECTORY, or some higher lock.
      173*****/
      174 
      175 	astep = search_ast$check (uid, pvid, vtocx, code);
      176 ACTIVATED_BY_SOMEONE_ELSE:
      177 	if code ^= 0 then				/* double uid */
      178 	     do;
      179 ret_ulast:     call lock$unlock_ast;
      180 	     return (null);
      181 	end;
      182 	ast_unlocked = "0"b;
      183 	if astep ^= null then
      184 	     do;
      185 	     if aste.par_astep ^= "0"b | aste.uid = (36)"1"b then do;
      186 		aste.multi_class = multi_class;	/* update after possible setfaults */
      187 		return (astep);			/* the normal case */
      188 	     end;
      189 	     already_active_by_backup = "1"b;		/* set switch */
      190 	end;
      191 	if esw = normal then do;
      192 	     if ^already_active_by_backup then do;
      193 		ast_unlocked = "1"b;
      194 		call lock$unlock_ast;
      195 		vtocep = addr (local_vtoce);
      196 		call vtoc_man$get_vtoce (pvid, pvtx, vtocx, "111"b, vtocep, code);
      197 		if code ^= 0 then return (null);
      198 		if vtoce.uid ^= uid then code = error_table_$vtoce_connection_fail;
      199 		else if vtoce.dirsw ^= dirsw | vtoce.deciduous then do;
      200 		     code = error_table_$vtoce_connection_fail;
      201 		     call syserr (LOG, "activate: error on ^[deciduous ^]^[dir ^]^a",
      202 			vtoce.deciduous, vtoce.dirsw, temp_entry_name);
      203 		end;
      204 		else code = 0;
      205 		if code ^= 0 then return (null);
      206 		call lock$lock_ast;
      207 	     end;
      208 
      209 	     par_sdwp = addr (dseg$ (fixed (baseno (dp), 18))); /* ptr to parent sdw */
      210 	     do while (sdw_util_$get_valid (par_sdwp) = "0"b); /* If parent active */
      211 		ast_unlocked = "1"b;
      212 		call lock$unlock_ast;		/* Unlock the global lock */
      213 		temp = dp -> dir.uid;		/* Cause a segfault on parent dir */
      214 		call lock$lock_ast;			/* relock */
      215 	     end;
      216 	     if (pvte.pvid ^= pvid) | pvte.being_demounted then do;
      217 		code = error_table_$pvid_not_found;	/* Check demount with AST locked */
      218 		go to ret_ulast;
      219 	     end;
      220 
      221 /**** now check to make sure it hasn't been activated
      222*      while we were not under the AST lock */
      223 
      224 	     if ast_unlocked & ^already_active_by_backup
      225 	     then do;
      226 		astep = search_ast$check (uid, pvid, vtocx, code);
      227 		if astep ^= null | code ^= 0
      228 		then go to ACTIVATED_BY_SOMEONE_ELSE;
      229 	     end;
      230 
      231 	     par_astep = get_ptrs_$given_sdw (par_sdwp);
      232 
      233 	     old_par_ehs = par_aste.ehs;		/* Save old ehs on parent */
      234 	     par_aste.ehs = "1"b;			/* Do not let son deactivate his father */
      235 
      236 	     if already_active_by_backup then do;
      237 		aste.par_astep = rel (par_astep);	/* set parent astep */
      238 		aste.infl = par_aste.infp;
      239 		par_aste.infp = rel (astep);
      240 		aste.per_process = par_aste.per_process;
      241 		aste.multi_class = multi_class;	/* fix this now that we know */
      242 		par_aste.ehs = old_par_ehs;
      243 		return (astep);			/* not that hard */
      244 	     end;
      245 	end;
      246 
      247 /* validate some fields in the VTOCE which could really kill us
      248*   if they're bogus										*/
      249 
      250 	if fixed (vtoce.records) > fixed (vtoce.csl)
      251 	     | fixed (vtoce.csl) > fixed (vtoce.msl)
      252 	     | fixed (vtoce.msl) > dim (vtoce.fm, 1)
      253 	then do;
      254 	     code = error_table_$invalid_vtoce;
      255 	     goto ret_ulast;
      256 	end;
      257 
      258 /*  checksum the file map  */
      259 
      260 	if vtoce.fm_checksum_valid & (sst$checksum_filemap ^= 0)
      261 	     & ^vtoce.fm_damaged then do;
      262 	     call filemap_checksum_ (addr (vtoce.fm), fixed (vtoce.csl, 9), checksum);
      263 	     if vtoce.fm_checksum ^= checksum then do;
      264 		segdamage.pvid = pvte.pvid;
      265 		segdamage.lvid = pvte.lvid;
      266 		segdamage.uid = vtoce.uid;
      267 		segdamage.vtocx = vtocx;
      268 		segdamage.pno = -1;
      269 		segdamage.uid_path = vtoce.uid_path;
      270 		call syserr$binary (LOG, addr (segdamage), SB_vtoc_salv_dam, SBL_vtoc_salv_dam,
      271 		     "activate: Setting damaged switch on ^a at ^o (^a^[^a^]). Filemap damaged.",
      272 		     vtoce.primary_name, vtocx, pvte.devname || "_" || convert (p99, pvte.logical_area_number),
      273 		     pvte.is_sv, pvte.sv_name);
      274 		vtoce.damaged = "1"b;
      275 		vtoce.fm_damaged = "1"b;
      276 		sst$damaged_ct = sst$damaged_ct + 1;
      277 		pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      278 	     end;
      279 	end;
      280 
      281 	if ^vtoce.synchronized then do;		/* Normal case */
      282 	     astep = get_aste (fixed (vtoce.csl));
      283 	     if astep = null () then do;
      284 		code = error_table_$illegal_activation;
      285 		goto ret_ulast;
      286 	     end;
      287 	end;
      288 	else do;					/* Synchronized segment */
      289 	     if ^sst$dm_enabled then do;		/* No journal */
      290 		code = error_table_$dm_not_enabled;
      291 		goto ret_ulast;
      292 	     end;
      293 	     astep = get_aste$synchronized (fixed (vtoce.csl));
      294 	     if astep = null () then do;
      295 		code = error_table_$synch_seg_limit;
      296 		goto ret_ulast;
      297 	     end;
      298 	end;
      299 
      300 
      301 	if esw = normal then do;
      302 	     if astep = par_astep then call syserr (CRASH, "activate: activating into father ^p", astep);
      303 	     par_aste.ehs = old_par_ehs;
      304 
      305 /*	aste.fp, aste.bp	= have been set by get_aste or deactivate  */
      306 	     aste.infl = par_aste.infp;
      307 	     par_aste.infp = rel (astep);
      308 	     aste.par_astep = rel (par_astep);
      309 	     aste.per_process = par_aste.per_process;	/* Inherit this one */
      310 	end;
      311 						/*	aste.uid = uid;	*/ /* dont fill in now -protect against shutdown */
      312 	aste.msl = vtoce.msl;
      313 	aste.pvtx = pvtx;
      314 	aste.vtocx = vtocx;
      315 	aste.usedf = "1"b;
      316 	aste.gtus = "1"b;
      317 	aste.gtms = "1"b;
      318 	aste.explicit_deact_ok = "1"b;
      319 	aste.dnzp = vtoce.dnzp;
      320 	aste.damaged = vtoce.damaged;
      321 	aste.fm_damaged = vtoce.fm_damaged;
      322 	aste.synchronized = vtoce.synchronized;
      323 	aste.nqsw = vtoce.nqsw;
      324 	aste.dirsw = vtoce.dirsw;
      325 	aste.dtu = vtoce.dtu;
      326 	aste.dtm = vtoce.dtm;
      327 	aste.csl = vtoce.csl;
      328 	aste.nid = vtoce.nid;
      329 	aste.records = vtoce.records;
      330 	aste.multi_class = multi_class;
      331 
      332 	sst$activations = sst$activations + 1;
      333 	if esw = backup then
      334 	     sst$backup_activations = sst$backup_activations + 1;
      335 	if long_sw then
      336 	     a_activated_sw = "1"b;			/* indicate activation occured */
      337 	if dirsw then do;
      338 	     aste.master_dir = vtoce.master_dir;
      339 	     aste.quota = vtoce.quota;
      340 	     aste.used = vtoce.used;
      341 	     aste.tqsw (0) = vtoce.received (0) ^= 0 | vtoce.master_dir;
      342 	     aste.tqsw (1) = vtoce.received (1) ^= 0;
      343 	     sst$dir_activations = sst$dir_activations + 1;
      344 	end;
      345 	else seg_aste.usage = seg_vtoce.usage;		/* Segments have no quota. keep pf count */
      346 
      347 	call pc$fill_page_table (astep, addr (vtoce.fm), fixed (vtoce.csl)); /* fill in page table */
      348 
      349 	aste.uid = uid;				/* aste is stable now */
      350 
      351 	call search_ast$hash_in (astep);
      352 
      353 	nm_astep = astep;
      354 
  1     1 /* Begin include file make_sstnt_entry.incl.pl1 Bernard Greenberg 2/18/75 */
  1     2 /* Modified 84-01-08 BIM for sst$ versus sst. */
  1     3 
  1     4 	/* If the SST name table is enabled, fill in the name table slot. */
  1     5 
  1     6     begin; /* quick */
  1     7        declare sst$ast_track bit (1) aligned external static;
  1     8       
  1     9 	if sst$ast_track then do;
  1    10 
  1    11 	     sstnp = addr (sst_names_$);		/* Establish name seg addressability */
  1    12 	     ptsi_a= bin (nm_astep -> aste.ptsi, 2);	/* Pick up PT size index */
  1    13 	     sstnmx = sstnt.ast_name_offsets (ptsi_a)
  1    14 			+ divide (bin (rel (nm_astep), 18)
  1    15 				- sstnt.ast_offsets (ptsi_a),
  1    16 				sstnt.ast_sizes (ptsi_a), 17, 0);
  1    17 
  1    18 	     sstnp -> sstnt.names (sstnmx) = rtrim (temp_entry_name);
  1    19 
  1    20 	end;
  1    21       end;
  1    22 
  1    23        declare temp_entry_name char (32) aligned;
  1    24 
  1    25 /* End of include file make_sstnt_entry.incl.pl1 */
      355 
      356 
      357 	return (astep);				/* return a pointer to the new AST entry */
      358 
      359 
      360 
      361 backup_activate: entry (a_vtocep, a_vtocx, a_pvtx, code) returns (ptr);
      362 
      363 	esw = backup;
      364 	long_sw = "0"b;
      365 	vtocep = a_vtocep;
      366 	pvtx = a_pvtx;
      367 	vtocx = a_vtocx;
      368 	uid = vtoce.uid;				/* set local variables */
      369 	dirsw = vtoce.dirsw;
      370 	multi_class = "0"b;				/* will get fixed up if someone else should activate this */
      371 	temp_entry_name = vtoce.primary_name;
      372 	goto COMMON;				/* with multiple entries you have to have one label */
      373 
      374 /* format: off */
      375  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  2     2 
  2     3 /* Template for an AST entry. Length = 12 words. */
  2     4 
  2     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  2     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  2     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  2     8 
  2     9 dcl  astep ptr;
  2    10 
  2    11 dcl 1 aste based (astep) aligned,
  2    12 
  2    13     (2 fp bit (18),					/* forward  used list rel pointer */
  2    14     2 bp bit (18),					/* backward used list rel pointer */
  2    15 
  2    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  2    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  2    18 
  2    19     2 strp bit (18),				/* rel pointer to process trailer */
  2    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  2    21 
  2    22     2 uid bit (36),					/* segment unique id */
  2    23 
  2    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  2    25     2 pvtx fixed bin (8),				/* physical volume table index */
  2    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    27 
  2    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  2    29     2 init bit (1),					/* used bit - insure 1 lap */
  2    30     2 gtus bit (1),					/* global transparent usage switch */
  2    31     2 gtms bit (1),					/* global transparent modified switch */
  2    32     2 hc bit (1),					/* hard core segment */
  2    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  2    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  2    35     2 write_access_on bit (1),			/* any sdw allows write access */
  2    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  2    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  2    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  2    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  2    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  2    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  2    42     2 pad1 bit (2),					/* OO */
  2    43     2 dius bit (1),					/* dumper in use switch */
  2    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  2    45     2 dmpr_pad bit (1),
  2    46     2 ehs bit (1),					/* entry hold switch */
  2    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  2    48     2 dirsw bit (1),				/* directory switch */
  2    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  2    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  2    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  2    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  2    53 
  2    54     2 dtu bit (36),					/* date and time segment last used */
  2    55 
  2    56     2 dtm bit (36),					/* date and time segment last modified */
  2    57 
  2    58 
  2    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  2    60 
  2    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  2    62 
  2    63     2 csl bit (9),					/* current segment length in 1024 words units */
  2    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  2    65     2 fms bit (1),					/* file modified switch */
  2    66     2 npfs bit (1),					/* no page fault switch */
  2    67     2 gtpd bit (1),					/* global transparent paging device switch */
  2    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  2    69     2 per_process bit (1),				/* use master quota for this entry */
  2    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  2    71     2 pad2 bit (2),
  2    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  2    73     2 np bit (9),					/* number of pages in core */
  2    74 
  2    75 
  2    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  2    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  2    78     2 damaged bit (1),				/* PC declared segment unusable */
  2    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  2    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  2    81     2 pad3 bit (6),					/* OOOOOOOOO */
  2    82     2 ptsi bit (2),					/* page table size index */
  2    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  2    84 
  2    85 
  2    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  2    87 
  2    88 
  2    89 dcl 1 aste_part aligned based (astep),
  2    90 
  2    91     2 one bit (36) unaligned,				/* fp and bp */
  2    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  2    93     2 three bit (8) unaligned;			/* ptsi and marker */
  2    94 
  2    95 
  2    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  2    97     2 pad1 bit (8*36),
  2    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  2    99     2 pad2 bit (3*36);
  2   100 
  2   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      375 
      376  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      376 
      377  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  4     2 /* Modified 8/74 for NSS */
  4     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  4     4 /* Modified 3/82 BIM for change pclock */
  4     5 /* format: style3 */
  4     6 
  4     7 /* Template for the directory header. Length = 64 words. */
  4     8 
  4     9 dcl  dp ptr;
  4    10 
  4    11 dcl 1 dir based (dp) aligned,
  4    12 
  4    13    2 modify bit (36),				/* Process ID of last modifier */
  4    14    2 type bit (18) unaligned,			/* type of object = dir header */
  4    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  4    16     2 dtc (3),					/* date-time checked by salvager array */
  4    17       3 date bit (36),				/* the date */
  4    18       3 error bit (36),				/* what errors were discovered */
  4    19 
  4    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  4    21 
  4    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  4    23 
  4    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  4    25 
  4    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  4    27 
  4    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  4    29     2 version_number fixed bin (17),			/* version number of header */
  4    30 
  4    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  4    32     2 pad2 bit (18),
  4    33 
  4    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  4    35     2 pad3 bit (18),
  4    36 
  4    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  4    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  4    39 
  4    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  4    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  4    42 
  4    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  4    44     2 dir_count fixed bin (17),			/* number of directory branches */
  4    45 
  4    46     2 lcount fixed bin (17),				/* number of links */
  4    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  4    48 
  4    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  4    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  4    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  4    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  4    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  4    54     2 pad4 bit (14),
  4    55 
  4    56     2 iacl_count (0:7),
  4    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  4    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  4    59 
  4    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  4    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  4    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  4    63 
  4    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  4    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  4    66 
  4    67     2 htsize fixed bin (17),				/* size of hash table */
  4    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  4    69 
  4    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  4    71     2 pad6 fixed bin (17),
  4    72 
  4    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  4    74     2 pad7 bit (18)) unaligned,
  4    75 
  4    76     2 dts bit (36),					/* date-time directory last salvaged */
  4    77 
  4    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  4    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  4    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  4    81     2 checksum bit (36),				/* checksummed from uid on */
  4    82     2 owner bit (36);				/* uid of parent dir */
  4    83 
  4    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  4    85 
  4    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      377 
      378  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      378 
      379  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  6     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6     8*     Add the support for subvolumes
  6     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  6    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  6    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6    14*     Added inconsistent_dbm bit for determining the status of volume
  6    15*     dumper bit maps.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18      dcl	   pvt$array	      aligned external;
  6    19      dcl	   pvt$max_n_entries      fixed bin external;
  6    20 
  6    21      dcl	   pvt_arrayp	      ptr;
  6    22      dcl	   pvtep		      ptr;
  6    23 
  6    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  6    25 
  6    26      dcl	   1 pvte		      based (pvtep) aligned,
  6    27 
  6    28 	     2 pvid	      bit (36),		/* physical volume ID */
  6    29 
  6    30 	     2 lvid	      bit (36),		/* logical volume ID */
  6    31 
  6    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  6    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  6    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  6    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  6    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  6    37 	     2 pad3	      bit (2) unaligned,
  6    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  6    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  6    40 
  6    41 
  6    42 
  6    43 	     2 devname	      char (4),		/* device name */
  6    44 
  6    45 	     (2 device_type	      fixed bin (8),	/* device type */
  6    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  6    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  6    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  6    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  6    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  6    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  6    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  6    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  6    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  6    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  6    56 	     2 scav_check_address
  6    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  6    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  6    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  6    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  6    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  6    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  6    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  6    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  6    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  6    66 
  6    67 
  6    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  6    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  6    70 
  6    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  6    72 
  6    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  6    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  6    75 
  6    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  6    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  6    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  6    79 	     2 records_per_cyl    fixed bin,
  6    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  6    81 	     2 sv_name            char (2) aligned,
  6    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  6    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  6    84 
  6    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  6    86 	     2 pad2	      bit (18) unaligned,
  6    87 
  6    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  6    89 
  6    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  6    91 
  6    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  6    93 
  6    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  6    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  6    96 
  6    97 
  6    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  6    99 
  6   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  6   101 
  6   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  6   103 
  6   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  6   105 
  6   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  6   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  6   108 
  6   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  6   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  6   111 
  6   112 
  6   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  6   114 	   VOLMAP_ASYNC_READ      init (1),
  6   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  6   116 
  6   117 
  6   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      379 
      380  /*	BEGIN INCLUDE FILE  segdamage_msg.incl.pl1 Bernard Greenberg 7/15/77 */
  7     2 
  7     3 /* This binary syserr message should be sent when the system damages a segment.
  7     4*   The value of sst$damaged_ct whould be incremented at this time. */
  7     5 
  7     6 dcl 1 segdamage aligned,
  7     7     2 pvid bit (36) aligned,			/* Volume PVID */
  7     8     2 lvid bit (36) aligned,			/* Volume LVID */
  7     9     2 pno fixed bin (17) unaligned,		/* Page number, -1 => don't know/care */
  7    10     2 vtocx fixed bin (17) unaligned,		/* VTOC index, -1 => none, -2 => don't know */
  7    11     2 uid bit (36) aligned,			/* Seg UID */
  7    12     2 uid_path (0:15) bit (36) aligned;	/* Parent dir uid path, zero padded on right */
  7    13 
  7    14 /* END INCLUDE FILE segdamage_msg.incl.pl1 */
      380 
      381  /* Begin include file sstnt.incl.pl1   */
  8     2 
  8     3 /* Created 10/03/74 by Bernard Greenberg */
  8     4 /* modified 08/24/79 by J. A. Bush  for easier calculation of size of sstnt */
  8     5 /* Modified 08/27/84 by Keith Loepere to purge BOS */
  8     6 
  8     7 dcl  sst_names_$ ext;				/* Segment containing sst name table */
  8     8 
  8     9 dcl  sstnp ptr;					/* Pointer to sst name segment */
  8    10 
  8    11 dcl 1 sstnt based (sstnp) aligned,			/* Major structure */
  8    12     2 valid bit (1) aligned,				/* 1 => structure filled by Multics */
  8    13     2 multics_or_bce char (4) aligned,			/* Origin of data in table */
  8    14     2 nentries fixed bin,				/* number of entries in the sstnt */
  8    15     2 pad1 (5) fixed bin,
  8    16 
  8    17     2 (ast_sizes,					/* Sizes of ASTE's at each level */
  8    18      ast_name_offsets,				/* Starting index for names at each level */
  8    19      ast_offsets,					/* Starting rel addr of each AST region */
  8    20      pad2) (0 : 3) fixed bin,
  8    21 
  8    22     2 names (0 : 0 refer (sstnt.nentries)) char (32) varying; /* Names of AST entries */
  8    23 
  8    24 dcl (sstnmx, ptsi_a) fixed bin (17);			/* Index into name table */
  8    25 
  8    26 dcl  nm_astep ptr;					/* astep to be used */
  8    27 
  8    28 /* End include file sstnt.incl.pl1 */
      381 
      382  /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  9     2 
  9     3 /* This include file has an ALM version, keep 'em in sync. */
  9     4 
  9     5 /* format: off */
  9     6 
  9     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  9     8*   to be examined by display_cpu_error. */
  9     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  9    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  9    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  9    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  9    13*		also changed some codes to "SB_unused_NN" - see line comments */
  9    14 
  9    15 /* In the future, these will be the only constants needed in this include
  9    16*file.  They are the binary data class strings for messages in the new format
  9    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  9    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  9    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  9    20 
  9    21 dcl (						/* include file name */
  9    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  9    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  9    24 SB_mos_data_class		init ("mos"),		/* scr */
  9    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  9    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  9    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  9    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  9    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  9    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  9    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  9    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  9    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  9    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  9    35 ) static internal char (16) varying options (constant);
  9    36 
  9    37 
  9    38 /************************
  9    39*Once the syserr$binary is replaced with something that takes real data classes
  9    40*and all system modules and tools are upgraded to use the new interface, the
  9    41*rest of this include file may be discarded.
  9    42*************************/
  9    43 
  9    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  9    45*   extended at any time. */
  9    46 
  9    47 dcl (
  9    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  9    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  9    50 SB_io_err		init (3),		SBL_io_err	init (5),
  9    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  9    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  9    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  9    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  9    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  9    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  9    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  9    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  9    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  9    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  9    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  9    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  9    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  9    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  9    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  9    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  9    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  9    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  9    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  9    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  9    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  9    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  9    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  9    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  9    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  9    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  9    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  9    78   ) internal static options (constant) fixed bin;
  9    79 
  9    80 
  9    81 /* The following array is a mapping of the old syserr$binary codes into the
  9    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  9    83*the binary data codes stored in the wired syserr log (see above) into the data
  9    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  9    85*is also used by syserr_log_util_ to translate the data classes back into the
  9    86*corresponding binary code (for tools not yet upgraded to deal with the new
  9    87*format log messages). */
  9    88 
  9    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  9    90 	init (	"io_status",		/* 1 */
  9    91 		"hwfault",		/* 2 */
  9    92 		"io_status",		/* 3 */
  9    93 		"unused_4",		/* 4 */
  9    94 		"mos",			/* 5 */
  9    95 
  9    96 		"unused_6",		/* 6 */
  9    97 		"unused_7",		/* 7 */
  9    98 		"unused_8",		/* 8 */
  9    99 		"unused_9",		/* 9 */ 
  9   100 		"unused_10",		/* 10 */
  9   101 
  9   102 		"segdamage",		/* 11 */
  9   103 		"unused_12",		/* 12 */
  9   104 		"segdamage",		/* 13 */
  9   105 		"unused_14",		/* 14 */
  9   106 		"unused_15",		/* 15 */
  9   107 
  9   108 		"segdamage",		/* 16 */
  9   109 		"voldamage",		/* 17 */
  9   110 		"unused_18",		/* 18 */
  9   111 		"mdc_del_uidpath",		/* 19 */
  9   112 		"io_status",		/* 20 */
  9   113 
  9   114 		"mmdam",			/* 21 */
  9   115 		"hwfault",		/* 22 */
  9   116 		"io_status",		/* 23 */
  9   117 		"mpc_poll",		/* 24 */
  9   118 		"fnp_poll",		/* 25 */
  9   119 
  9   120 		"config_deck",		/* 26 */
  9   121 		"vtoce",			/* 27 */
  9   122 		"access_audit",		/* 28 */
  9   123 		"unused_29",		/* 29 */
  9   124 		"unused_30",		/* 30 */
  9   125 		"unused_31",		/* 31 */
  9   126 		"unused_32",		/* 32 */
  9   127 		"unused_33",		/* 33 */
  9   128 		"unused_34",		/* 34 */
  9   129 		"ibm3270_mde",		/* 35 */
  9   130 		"unused_36"		/* 36 */
  9   131 	);
  9   132 
  9   133 
  9   134 /* format: on */
  9   135 
  9   136 /* These constants are used by various tools which analyze syserr messages and
  9   137*still call the old interface "syserr_log_util_". */
  9   138 
  9   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  9   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  9   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  9   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  9   143 
  9   144      dcl	   display_cpu_error_binary_defs (2) init (
  9   145 			      2,			/** SB_hw_fault */
  9   146 			      22			/** SB_verify_lock */
  9   147 			      ) internal static options (constant) fixed bin;
  9   148 
  9   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      382 
      383  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
 10     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
 10     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
 10     4 
 10     5 /* This include file has an ALM version.  Keep 'em in sync! */
 10     6 
 10     7 dcl (
 10     8 
 10     9 /* The following constants define the message action codes.  This indicates
 10    10*how a message is to be handled.  */
 10    11 
 10    12      SYSERR_CRASH_SYSTEM	init (1),			
 10    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
 10    14 
 10    15      SYSERR_TERMINATE_PROCESS	init (2),
 10    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
 10    17 
 10    18      SYSERR_PRINT_WITH_ALARM	init (3),
 10    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
 10    20 
 10    21      SYSERR_PRINT_ON_CONSOLE	init (0),
 10    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
 10    23 
 10    24      SYSERR_LOG_OR_PRINT	init (4),
 10    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
 10    26 
 10    27      SYSERR_LOG_OR_DISCARD	init (5),
 10    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
 10    29 
 10    30 
 10    31 /* The following constants are added to the normal severities to indicate
 10    32*different sorting classes of messages.  */
 10    33 
 10    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
 10    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
 10    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
 10    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
 10    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
 10    39 	) fixed bin internal static options (constant);
 10    40 
 10    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      383 
      384  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 11     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 11     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 11     4 
 11     5 dcl  vtocep ptr;
 11     6 
 11     7 dcl 1 vtoce based (vtocep) aligned,
 11     8 
 11     9 
 11    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 11    11 
 11    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 11    13 
 11    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 11    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 11    16     2 records bit (9),				/* number of records used by the seg in second storage */
 11    17     2 pad2 bit (9),
 11    18 
 11    19     2 dtu bit (36),					/* date and time segment was last used */
 11    20 
 11    21     2 dtm bit (36),					/* date and time segment was last modified */
 11    22 
 11    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 11    24     2 deciduous bit (1),				/* true if hc_sdw */
 11    25     2 nid bit (1),					/* no incremental dump switch */
 11    26     2 dnzp bit (1),					/* Dont null zero pages */
 11    27     2 gtpd bit (1),					/* Global transparent paging device */
 11    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 11    29     2 damaged bit (1),				/* TRUE if contents damaged */
 11    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 11    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 11    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 11    33     2 pad3 bit (8),
 11    34     2 dirsw bit (1),				/* directory switch */
 11    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 11    36     2 pad4 bit (16)) unaligned,			/* not used */
 11    37 
 11    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 11    39 
 11    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 11    41 
 11    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 11    43 
 11    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 11    45 
 11    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 11    47 
 11    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 11    49 
 11    50 
 11    51 
 11    52 
 11    53 
 11    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 11    55 
 11    56     2 pad6 (10) bit (36),				/* not used */
 11    57 
 11    58     2 ncd bit (1),					/* no complete dump switch */
 11    59     2 pad7 bit (17),
 11    60     2 pad8 bit (18),
 11    61 
 11    62     2 dtd bit (36),					/* date-time-dumped */
 11    63 
 11    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 11    65 
 11    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 11    67 
 11    68 
 11    69 
 11    70 
 11    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 11    72 
 11    73     2 primary_name char (32),				/* primary name of the segment */
 11    74 
 11    75     2 time_created bit (36),				/* time the segment was created */
 11    76 
 11    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 11    78 
 11    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 11    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 11    81 
 11    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 11    83 
 11    84     2 access_class bit (72),				/* access class in branch */
 11    85     2 perm_flags aligned,
 11    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 11    87       3 pad9 bit (35) unal,
 11    88     2 owner bit (36);				/* pvid of this volume */
 11    89 
 11    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 11    91 
 11    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 11    93     2 pad1 bit (7*36),
 11    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 11    95     2 pad2 bit (184*36);
 11    96 
 11    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      384 
      385 
      386 /* format: on */
      387 
      388 
      389 /* BEGIN MESSAGE DOCUMENTATION
      390*
      391*   Message:
      392*   activate: error on (deciduous) (dir) NAME
      393*
      394*   S:	$log
      395*
      396*   T:	$run
      397*
      398*   M:	An attempt has been made to activate a
      399*   deciduous segment,
      400*   or to activate a segment
      401*   when the VTOCE's directory switch did not match the branch.
      402*   A connection failure is returned to the user process.
      403*   This information is logged for the use of system programmers.
      404*
      405*   A:	$ignore
      406*
      407*
      408*   Message:
      409*   activate: activating into father PPPP
      410*
      411*   S:	$crash
      412*
      413*   T:	$run
      414*
      415*   M:	The AST entry pointer returned by get_aste
      416*   is identical to the AST entry pointer for the parent of the segment being activated.
      417*   $err
      418*   $crashes
      419*
      420*   A:	$recover
      421*
      422*
      423*   Message:
      424*   activate: Setting damaged switch on NAME at VTOCX (dskX_NN{s}). Filemap damaged.
      425*
      426*   S:     $log
      427*
      428*   T:	$run
      429*
      430*   M:	The segment's File Map in the VTOCE had an invalid checksum, which
      431*   indicates likely damage to the File Map. The segment is marked as damaged.
      432*   It is possible that there is other damage on the physical volume due
      433*   to invalid or reused disk addresses. The count of volume inconsistencies is
      434*   incremented by 1.
      435*
      436*   A:      Examine the VTOCE for damage using dump_vtoce. If other damage
      437*   is evident, delete it using hp_delete_vtoce -clear and recover the
      438*   segment. Run the physical volume scavenger as soon as possible to
      439*   detect and correct other damage on the physical volume.
      440*
      441*
      442*   END MESSAGE DOCUMENTATION */
      443 
      444      end activate;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0806.7  activate.pl1                      >spec>install>1112>activate.pl1
355          1    07/11/84  0937.3  make_sstnt_entry.incl.pl1         >ldd>include>make_sstnt_entry.incl.pl1
375          2    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
376          3    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
377          4    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
378          5    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
379          6    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
380          7    08/18/77  0954.0  segdamage_msg.incl.pl1            >ldd>include>segdamage_msg.incl.pl1
381          8    11/02/84  0912.2  sstnt.incl.pl1                    >ldd>include>sstnt.incl.pl1
382          9    03/15/85  0953.1  syserr_binary_def.incl.pl1        >ldd>include>syserr_binary_def.incl.pl1
383         10    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
384         11    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000016 constant        fixed bin(17,0)          initial dcl 10-7 set ref 302*
LOG                             000012 constant        fixed bin(17,0)          initial dcl 10-7 set ref 201* 270*
SBL_vtoc_salv_dam               000000 constant        fixed bin(17,0)          initial dcl 9-47 set ref 270*
SB_vtoc_salv_dam                000001 constant        fixed bin(17,0)          initial dcl 9-47 set ref 270*
a_activated_sw                         parameter       bit(1)                   dcl 66 set ref 131 134* 335*
a_pvtx                                 parameter       fixed bin(17,0)          dcl 66 ref 361 366
a_vtocep                               parameter       pointer                  dcl 66 ref 361 365
a_vtocx                                parameter       fixed bin(17,0)          dcl 66 ref 361 367
addr                                                   builtin function         dcl 121 ref 144 152 153 195 209 262 262 270 270 347
                                                                                  347 1-11
already_active_by_backup        000115 automatic       bit(1)                   packed unaligned dcl 79 set ref 151* 189* 192 224
                                                                                  236
ast_name_offsets         14            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 1-13
ast_offsets              20            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 1-13
ast_sizes                10            based           fixed bin(17,0)          array level 2 dcl 8-11 ref 1-13
ast_unlocked                    000100 automatic       bit(1)                   dcl 74 set ref 182* 193* 211* 224
aste                                   based           structure                level 1 dcl 2-11
astep                           000432 automatic       pointer                  dcl 2-9 set ref 175* 183 185 185 186 187 226* 227
                                                                                  237 238 239 240 241 243 282* 283 293* 294 302 302*
                                                                                  306 307 308 309 312 313 314 315 316 317 318 319
                                                                                  320 321 322 323 324 325 326 327 328 329 330 338
                                                                                  339 340 341 342 345 347* 349 351* 353 357
backup                                 constant        fixed bin(17,0)          initial dcl 90 ref 333 363
baseno                                                 builtin function         dcl 121 ref 209
being_demounted           4(23)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 ref 216
bin                                                    builtin function         dcl 121 ref 1-12 1-13
branchp                                parameter       pointer                  dcl 66 ref 63 131 136
checksum                        000421 automatic       bit(36)                  dcl 86 set ref 262* 263
code                                   parameter       fixed bin(35,0)          dcl 66 set ref 63 131 145* 146 149* 175* 176 196*
                                                                                  197 198* 200* 204* 205 217* 226* 227 254* 284*
                                                                                  290* 295* 361
convert                                                builtin function         dcl 121 ref 270
csl                       2(09)        based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 250 250 262
                                                                                  262 282 282 293 293 327 347 347
csl                      12            based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 327*
damaged                  13(19)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 320*
damaged                   5(06)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" set ref 274* 320
deciduous                 5(01)        based           bit(1)                   level 2 packed packed unaligned dcl 11-7 set ref 199
                                                                                  201*
devname                   3            based           char(4)                  level 2 dcl 6-26 ref 270
dim                                                    builtin function         dcl 121 ref 250
dir                                    based           structure                level 1 dcl 4-11
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "activate" ref 142
dirsw                     5(18)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" set ref 199 201*
                                                                                  324 369
dirsw                     5(21)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 324*
dirsw                           000116 automatic       bit(1)                   packed unaligned dcl 80 in procedure "activate" set
                                                                                  ref 142* 199 337 369*
divide                                                 builtin function         dcl 121 ref 1-13
dnzp                     12(13)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 319*
dnzp                      5(03)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 319
dp                              000436 automatic       pointer                  dcl 4-9 set ref 138* 209 213
dseg$                           000024 external static fixed bin(71,0)          array dcl 98 set ref 209
dtm                       7            based           bit(36)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 326*
dtm                       4            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 326
dtu                       6            based           bit(36)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 325*
dtu                       3            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 325
ehs                       5(19)        based           bit(1)                   level 2 packed packed unaligned dcl 85 set ref 233
                                                                                  234* 242* 303*
entry                                  based           structure                level 1 dcl 3-8
ep                              000434 automatic       pointer                  dcl 3-6 set ref 136* 138 139 140 141 142 143 144
error_table_$dm_not_enabled     000040 external static fixed bin(35,0)          dcl 104 ref 290
error_table_$illegal_activation 000034 external static fixed bin(35,0)          dcl 102 ref 284
error_table_$invalid_vtoce      000036 external static fixed bin(35,0)          dcl 103 ref 254
error_table_$pvid_not_found     000032 external static fixed bin(35,0)          dcl 101 ref 217
error_table_$synch_seg_limit    000026 external static fixed bin(35,0)          dcl 99 ref 295
error_table_$vtoce_connection_fail
                                000030 external static fixed bin(35,0)          dcl 100 ref 198 200
esw                             000110 automatic       fixed bin(17,0)          dcl 76 set ref 147* 191 301 333 363*
explicit_deact_ok         5(09)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  318*
filemap_checksum_               000066 constant        entry                    external dcl 116 ref 262
fixed                                                  builtin function         dcl 121 ref 209 250 250 250 250 250 262 262 282 282
                                                                                  293 293 347 347
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 11-7 set
                                                                                  ref 250 262 262 347 347
fm_checksum               6            based           bit(36)                  level 2 dcl 11-7 ref 263
fm_checksum_valid         5(08)        based           bit(1)                   level 2 packed packed unaligned dcl 11-7 ref 260
fm_damaged                5(07)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" set ref 260 275*
                                                                                  321
fm_damaged                5(12)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 321*
get_aste                        000044 constant        entry                    external dcl 107 ref 282
get_aste$synchronized           000046 constant        entry                    external dcl 108 ref 293
get_ptrs_$given_sdw             000064 constant        entry                    external dcl 115 ref 231
get_pvtx                        000060 constant        entry                    external dcl 113 ref 145
gtms                      5(03)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  317*
gtus                      5(02)        based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  316*
infl                      1            based           bit(18)                  level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  238* 306*
infp                      1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 85 set ref 238
                                                                                  239* 306 307*
is_sv                     2(03)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 set ref
                                                                                  270*
local_vtoce                     000121 automatic       structure                level 1 dcl 84 set ref 195
lock$lock_ast                   000050 constant        entry                    external dcl 109 ref 154 206 214
lock$unlock_ast                 000052 constant        entry                    external dcl 110 ref 179 194 212
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 6-26 ref 270
long_sw                         000120 automatic       bit(1)                   dcl 83 set ref 124* 133* 335 364*
lvid                      1     000444 automatic       bit(36)                  level 2 in structure "segdamage" dcl 7-6
                                                                                  in procedure "activate" set ref 265*
lvid                      1            based           bit(36)                  level 2 in structure "pvte" dcl 6-26 in procedure
                                                                                  "activate" ref 265
master_dir                5(22)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 338*
master_dir                5(19)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 338 341
msl                       4            based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 312*
msl                       2            based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 250 250 312
multi_class               5(13)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 186* 241*
                                                                                  330*
multi_class                     000117 automatic       bit(1)                   packed unaligned dcl 81 in procedure "activate" set
                                                                                  ref 143* 186 241 330 370*
multiple_class           32(05)        based           bit(1)                   level 2 packed packed unaligned dcl 3-8 ref 143
name                      4            based           char(32)                 level 2 dcl 5-7 ref 144
names                    30            based           varying char(32)         array level 2 in structure "sstnt" dcl 8-11
                                                                                  in procedure "activate" set ref 1-18*
names                                  based           structure                level 1 dcl 5-7 in procedure "activate"
nid                       5(02)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 328
nid                       5(17)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 328*
nm_astep                        000474 automatic       pointer                  dcl 8-26 set ref 353* 1-12 1-13
normal                                 constant        fixed bin(17,0)          initial dcl 89 ref 147 191 301
nqsw                      5(20)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 323*
nqsw                      5            based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 323
null                                                   builtin function         dcl 121 ref 146 180 183 197 205 227 283 294
old_par_ehs                     000114 automatic       bit(1)                   packed unaligned dcl 78 set ref 233* 242 303
p99                                    automatic       picture(2)               packed unaligned dcl 87 ref 270
par_aste                               based           structure                level 1 dcl 85
par_astep                       000102 automatic       pointer                  dcl 75 in procedure "activate" set ref 231* 233 234
                                                                                  237 238 239 240 242 302 303 306 307 308 309
par_astep                 2(18)        based           bit(18)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 185 237*
                                                                                  308*
par_sdwp                        000104 automatic       pointer                  dcl 75 set ref 209* 210* 231*
pc$fill_page_table              000042 constant        entry                    external dcl 106 ref 347
per_process              12(14)        based           bit(1)                   level 2 in structure "par_aste" packed packed
                                                                                  unaligned dcl 85 in procedure "activate" ref 240
                                                                                  309
per_process              12(14)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 240* 309*
pno                       2     000444 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 7-6 set ref 268*
primary_name             10            based           bit(504)                 level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "activate" set ref 144
primary_name            260            based           char(32)                 level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" set ref 270* 371
ptr                                                    builtin function         dcl 121 ref 138
ptsi                     13(28)        based           bit(2)                   level 2 packed packed unaligned dcl 2-11 ref 1-12
ptsi_a                          000473 automatic       fixed bin(17,0)          dcl 8-24 set ref 1-12* 1-13 1-13 1-13
pvid                     30            based           bit(36)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "activate" ref 140
pvid                                   based           bit(36)                  level 2 in structure "pvte" dcl 6-26 in procedure
                                                                                  "activate" ref 216 264
pvid                            000112 automatic       bit(36)                  dcl 77 in procedure "activate" set ref 140* 145*
                                                                                  175* 196* 216 226*
pvid                            000444 automatic       bit(36)                  level 2 in structure "segdamage" dcl 7-6
                                                                                  in procedure "activate" set ref 264*
pvt$array                       000076 external static fixed bin(17,0)          dcl 6-18 set ref 152
pvt_array                              based           structure                array level 1 dcl 6-24 set ref 153
pvt_arrayp                      000440 automatic       pointer                  dcl 6-21 set ref 152* 153
pvte                                   based           structure                level 1 dcl 6-26
pvtep                           000442 automatic       pointer                  dcl 6-22 set ref 153* 216 216 264 265 270 270 270
                                                                                  270 277 277
pvtx                            000106 automatic       fixed bin(17,0)          dcl 76 in procedure "activate" set ref 145* 153 196*
                                                                                  313 366*
pvtx                      4(09)        based           fixed bin(8,0)           level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 313*
quota                    10            based           fixed bin(18,0)          array level 2 in structure "aste" packed packed
                                                                                  unsigned unaligned dcl 2-11 in procedure
                                                                                  "activate" set ref 339*
quota                     7            based           fixed bin(18,0)          array level 2 in structure "vtoce" packed packed
                                                                                  unsigned unaligned dcl 11-7 in procedure
                                                                                  "activate" ref 339
received                 11            based           fixed bin(18,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 11-7 ref 341 342
records                  12(18)        based           bit(9)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 329*
records                   2(18)        based           bit(9)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 250 329
rel                                                    builtin function         dcl 121 ref 237 239 307 308 1-13
rtrim                                                  builtin function         dcl 121 ref 1-18
sdw_util_$get_valid             000070 constant        entry                    external dcl 117 ref 210
search_ast$check                000054 constant        entry                    external dcl 111 ref 175 226
search_ast$hash_in              000056 constant        entry                    external dcl 112 ref 351
seg_aste                               based           structure                level 1 dcl 2-96
seg_vtoce                              based           structure                level 1 dcl 11-92
segdamage                       000444 automatic       structure                level 1 dcl 7-6 set ref 270 270
sst$activations                 000016 external static fixed bin(35,0)          dcl 95 set ref 332* 332
sst$ast_track                   000102 external static bit(1)                   dcl 1-7 ref 1-9
sst$backup_activations          000020 external static fixed bin(35,0)          dcl 96 set ref 333* 333
sst$checksum_filemap            000010 external static fixed bin(35,0)          dcl 92 ref 260
sst$damaged_ct                  000012 external static fixed bin(35,0)          dcl 93 set ref 276* 276
sst$dir_activations             000022 external static fixed bin(35,0)          dcl 97 set ref 343* 343
sst$dm_enabled                  000014 external static bit(1)                   dcl 94 ref 289
sst_names_$                     000100 external static fixed bin(17,0)          dcl 8-7 set ref 1-11
sstnmx                          000472 automatic       fixed bin(17,0)          dcl 8-24 set ref 1-13* 1-18
sstnp                           000470 automatic       pointer                  dcl 8-9 set ref 1-11* 1-13 1-13 1-13 1-18
sstnt                                  based           structure                level 1 dcl 8-11
sv_name                  15            based           char(2)                  level 2 dcl 6-26 set ref 270*
synchronized              5(09)        based           bit(1)                   level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 281 322
synchronized             13(21)        based           bit(1)                   level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 322*
syserr                          000072 constant        entry                    external dcl 118 ref 201 302
syserr$binary                   000074 constant        entry                    external dcl 119 ref 270
temp                            000113 automatic       bit(36)                  dcl 77 set ref 213*
temp_entry_name                 000422 automatic       char(32)                 dcl 1-23 set ref 144* 201* 371* 1-18
tqsw                      5(24)        based           bit(1)                   array level 2 packed packed unaligned dcl 2-11 set
                                                                                  ref 341* 342*
uid                       3     000444 automatic       bit(36)                  level 2 in structure "segdamage" dcl 7-6
                                                                                  in procedure "activate" set ref 266*
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 4-11 in procedure
                                                                                  "activate" ref 213
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "activate" ref 139
uid                             000111 automatic       bit(36)                  dcl 77 in procedure "activate" set ref 139* 175* 198
                                                                                  226* 349 368*
uid                       1            based           bit(36)                  level 2 in structure "vtoce" packed packed unaligned
                                                                                  dcl 11-7 in procedure "activate" ref 198 266 368
uid                       3            based           bit(36)                  level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 185 349*
uid_path                  4     000444 automatic       bit(36)                  array level 2 in structure "segdamage" dcl 7-6
                                                                                  in procedure "activate" set ref 269*
uid_path                240            based           bit(36)                  array level 2 in structure "vtoce" packed packed
                                                                                  unaligned dcl 11-7 in procedure "activate" ref 269
usage                    10            based           fixed bin(35,0)          level 2 in structure "seg_aste" dcl 2-96
                                                                                  in procedure "activate" set ref 345*
usage                     7            based           fixed bin(35,0)          level 2 in structure "seg_vtoce" dcl 11-92
                                                                                  in procedure "activate" ref 345
used                     11            based           fixed bin(18,0)          array level 2 in structure "aste" packed packed
                                                                                  unsigned unaligned dcl 2-11 in procedure
                                                                                  "activate" set ref 340*
used                     10            based           fixed bin(18,0)          array level 2 in structure "vtoce" packed packed
                                                                                  unsigned unaligned dcl 11-7 in procedure
                                                                                  "activate" ref 340
usedf                     5            based           bit(1)                   level 2 packed packed unaligned dcl 2-11 set ref
                                                                                  315*
vol_trouble_count        33            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 6-26 set ref
                                                                                  277* 277
vtoc_man$get_vtoce              000062 constant        entry                    external dcl 114 ref 196
vtoce                                  based           structure                level 1 dcl 11-7
vtocep                          000476 automatic       pointer                  dcl 11-5 set ref 195* 196* 198 199 199 201 201 250
                                                                                  250 250 250 250 250 260 260 262 262 262 262 263
                                                                                  266 269 270 274 275 281 282 282 293 293 312 319
                                                                                  320 321 322 323 324 325 326 327 328 329 338 339
                                                                                  340 341 341 342 345 347 347 347 347 365* 368 369
                                                                                  371
vtocx                    31            based           fixed bin(17,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "activate" ref 141
vtocx                           000107 automatic       fixed bin(17,0)          dcl 76 in procedure "activate" set ref 141* 175*
                                                                                  196* 226* 267 270* 314 367*
vtocx                     2(18) 000444 automatic       fixed bin(17,0)          level 2 in structure "segdamage" packed packed
                                                                                  unaligned dcl 7-6 in procedure "activate" set ref
                                                                                  267*
vtocx                     4(18)        based           fixed bin(17,0)          level 2 in structure "aste" packed packed unaligned
                                                                                  dcl 2-11 in procedure "activate" set ref 314*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 10-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 10-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 10-7
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 9-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 9-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 9-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 9-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 9-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 9-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 9-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 9-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 9-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 9-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 9-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 9-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 9-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 9-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 9-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 9-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 9-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 9-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 9-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 9-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 9-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 9-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 9-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 9-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 9-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 9-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 9-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 9-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 9-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 9-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 9-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 9-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 9-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 9-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 9-21
SB_mos_err                             internal static fixed bin(17,0)          initial dcl 9-47
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 9-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 9-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 9-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 9-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 9-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 9-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 9-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 9-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 9-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 9-21
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 9-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 9-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 9-47
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 10-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 10-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 10-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 6-113
asta                                   based           bit(432)                 array dcl 2-86
aste_part                              based           structure                level 1 dcl 2-89
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 9-144
np                                     automatic       pointer                  dcl 5-5
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 6-19
syserr_binary_address_damage_mask      internal static bit(36)                  initial packed unaligned dcl 9-142
syserr_binary_mos_mask                 internal static bit(36)                  initial packed unaligned dcl 9-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial packed unaligned dcl 9-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial packed unaligned dcl 9-141
version_number_2                       internal static fixed bin(17,0)          initial dcl 4-84
vtoce_parts                            based           bit(2304)                array dcl 11-90

NAMES DECLARED BY EXPLICIT CONTEXT.
ACTIVATED_BY_SOMEONE_ELSE       000240 constant        label                    dcl 176 ref 227
COMMON                          000204 constant        label                    dcl 149 ref 372
START                           000134 constant        label                    dcl 136 ref 125
activate                        000075 constant        entry                    external dcl 63
activate_long                   000116 constant        entry                    external dcl 131
backup_activate                 001532 constant        entry                    external dcl 361
ret_ulast                       000242 constant        label                    dcl 179 ref 218 255 285 291 296

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2164        2270    1574        2174
Length      2726    1574       104         421     367           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
activate                            432 external procedure  is an external procedure.  
begin block on line 1-6                 begin block         shares stack frame of external procedure activate.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
activate                 000100 ast_unlocked                activate
                         000102 par_astep                   activate
                         000104 par_sdwp                    activate
                         000106 pvtx                        activate
                         000107 vtocx                       activate
                         000110 esw                         activate
                         000111 uid                         activate
                         000112 pvid                        activate
                         000113 temp                        activate
                         000114 old_par_ehs                 activate
                         000115 already_active_by_backup    activate
                         000116 dirsw                       activate
                         000117 multi_class                 activate
                         000120 long_sw                     activate
                         000121 local_vtoce                 activate
                         000421 checksum                    activate
                         000422 temp_entry_name             activate
                         000432 astep                       activate
                         000434 ep                          activate
                         000436 dp                          activate
                         000440 pvt_arrayp                  activate
                         000442 pvtep                       activate
                         000444 segdamage                   activate
                         000470 sstnp                       activate
                         000472 sstnmx                      activate
                         000473 ptsi_a                      activate
                         000474 nm_astep                    activate
                         000476 vtocep                      activate

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
filemap_checksum_             get_aste                      get_aste$synchronized         get_ptrs_$given_sdw
get_pvtx                      lock$lock_ast                 lock$unlock_ast               pc$fill_page_table
sdw_util_$get_valid           search_ast$check              search_ast$hash_in            syserr
syserr$binary                 vtoc_man$get_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dseg$                         error_table_$dm_not_enabled   error_table_$illegal_activation
error_table_$invalid_vtoce    error_table_$pvid_not_found   error_table_$synch_seg_limit
error_table_$vtoce_connection_fail                          pvt$array                     sst$activations
sst$ast_track                 sst$backup_activations        sst$checksum_filemap          sst$damaged_ct
sst$dir_activations           sst$dm_enabled                sst_names_$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     63 000071       124 000107       125 000110       131 000111       133 000130       134 000132       136 000134
    138 000137       139 000141       140 000143       141 000145       142 000150       143 000153       144 000157
    145 000162       146 000175       147 000202       149 000204       151 000205       152 000206       153 000211
    154 000215       175 000221       176 000240       179 000242       180 000247       182 000252       183 000253
    185 000257       186 000266       187 000273       189 000275       191 000277       192 000302       193 000304
    194 000306       195 000313       196 000315       197 000340       198 000345       199 000355       200 000365
    201 000370       203 000426       204 000427       205 000430       206 000435       209 000442       210 000451
    211 000466       212 000470       213 000475       214 000500       215 000505       216 000506       217 000515
    218 000520       224 000521       226 000525       227 000544       231 000552       233 000563       234 000570
    236 000572       237 000574       238 000600       239 000603       240 000606       241 000612       242 000617
    243 000624       250 000626       254 000655       255 000660       260 000661       262 000672       263 000711
    264 000715       265 000717       266 000722       267 000724       268 000726       269 000730       270 000742
    274 001050       275 001053       276 001055       277 001062       281 001070       282 001073       283 001110
    284 001114       285 001117       287 001120       289 001121       290 001124       291 001126       293 001127
    294 001143       295 001147       296 001152       301 001153       302 001156       303 001206       306 001214
    307 001220       308 001223       309 001226       312 001232       313 001236       314 001241       315 001243
    316 001245       317 001247       318 001251       319 001253       320 001260       321 001265       322 001272
    323 001277       324 001304       325 001311       326 001313       327 001315       328 001320       329 001325
    330 001327       332 001334       333 001341       335 001350       337 001355       338 001357       339 001364
    340 001366       341 001370       342 001404       343 001413       344 001417       345 001420       347 001422
    349 001442       351 001445       353 001454    1    9 001456    1   11 001461    1   12 001463    1   13 001470
 1   18 001477       357 001522       361 001525       363 001544       364 001546       365 001547       366 001553
    367 001555       368 001557       369 001561       370 001565       371 001566       372 001571


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
