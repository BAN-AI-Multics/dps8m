	COMPILATION LISTING OF SEGMENT ref_name_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 08/21/90  1449.0 mdt Tue
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(90-07-26,WAAnderson), approve(90-07-26,MCR8182),
       19*     audit(90-08-10,Schroth), install(90-08-21,MR12.4-1030):
       20*     Replaced the get_refnames entry with get_refname entry. The new entry
       21*     returns only the name specified by the supplied namecnt argument.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 ref_name_: proc ();
       26 
       27 /*
       28*   Written September 1974 by R. Bratt
       29*
       30*   ref_name_ manages the reference name table
       31*
       32*   ---> ref_name_$insert adds a reference name, segment number pair to the RNT
       33*   USAGE: call ref_name_$insert (rname, segno, code);
       34*
       35*   ---> ref_name_$delete removes a reference name from the RNT
       36*   USAGE: call ref_name_$delete (rname, segno,  code);
       37*
       38*   ---> ref_name_$delete_segno removes all names for a given segment number from the RNT
       39*   USAGE: call ref_name_$delete_segno (segno, code);
       40*
       41*   ---> ref_name_$get_segno maps a reference name into a segment number
       42*   USAGE: call ref_name_$get_segno (rname, segno, code);
       43*
       44*   ---> ref_name_$get_refname maps a segment number into a name
       45*   USAGE: call ref_name_$get_refname (segno, namecnt, rname, code);
       46*
       47*   rname char(32) varying --- reference name
       48*   segno fixed bin(17) --- segment number
       49*   namecnt --- the entry number in the list of reference names
       50*   code fixed bin(35) --- error code
       51*
       52*    --> ref_name_$get_count (segno, n_names)
       53*
       54*   Last Modified:
       55*
       56*   10/22/75 by R. Bratt to fix a stupid cross-ring bug
       57*   07/13/76 by R. Bratt to move rnt out of ring zero (major overhaul) and further updated 3/25/77 by M. Weaver
       58*   11/11/77 by M. Weaver to use PL/I offsets in rnt and to add area handler
       59*    May 1982 BIM for get_count.
       60*   12/22/83 by M. Weaver to fix bug in search_name that affects delete_segno
       61*
       62**/
       63 
       64 dcl  a_rname char (32) varying,
       65      a_namecnt fixed bin,
       66     (a_segno, segno, cnt) fixed bin (17),
       67      rname char (32) varying,
       68     (savep, save_rntep, last_np, last_sp) ptr,
       69      a_code fixed bin (35),
       70      ring fixed bin (3),
       71      rnt_size fixed bin,
       72     (new_rnt_areap, new_rntp) ptr,
       73      area condition,
       74      hash_offset offset (rnt.areap -> based_rnt_area) based,
       75      steps fixed bin (17),
       76      max_steps fixed bin (17) static init (1000) options (constant),
       77     (null, substr, length, rtrim, addrel, addr, rel, bin, empty, string) builtin;
       78 
       79 dcl a_count fixed bin;
       80 
       81 dcl (dimension, max, min, mod) builtin;
       82 dcl (error_table_$refname_count_too_big, error_table_$segknown, error_table_$namedup, error_table_$argerr) ext fixed bin (35);
       83 dcl (error_table_$name_not_found, error_table_$inconsistent_rnt) ext fixed bin (35);
       84 dcl  error_table_$r0_refname ext fixed bin (35);
       85 dcl  pds$stacks (0:7) ptr ext;
       86 dcl  level$get ext entry () returns (fixed bin (3));
       87 
       88 insert:
       89 	entry (a_rname, a_segno, a_code);
       90 	call setup ("11"b);
       91 
       92 	on area begin;				/* reallocate a larger rnt and copy */
       93 	     declare new_rnt_area area (rnt_size) based (new_rnt_areap);
       94 	     rnt_size = rnt.rnt_area_size * 2;		/* double the size */
       95 	     allocate new_rnt_area in (pds$stacks (ring) -> stack_header.clr_ptr -> based_rnt_area)
       96 		set (new_rnt_areap);
       97 
       98 	     new_rnt_areap -> new_rnt_area = rnt.areap -> based_rnt_area;
       99 	     new_rntp = addrel (new_rnt_areap, (bin (rel (rntp), 18) - bin (rel (rnt.areap), 18)));
      100 						/* locate copy of rnt within area */
      101 	     new_rntp -> rnt.areap = new_rnt_areap;
      102 	     new_rntp -> rnt.rnt_area_size = rnt_size;
      103 	     new_rntp -> rnt.srulep = addrel (new_rnt_areap, (bin (rel (rnt.srulep), 18) - bin (rel (rnt.areap), 18)));
      104 						/* must relocate search rule ptr in new area */
      105 	     pds$stacks (ring) -> stack_header.rnt_ptr = new_rntp;
      106 	     free rnt.areap -> based_rnt_area;
      107 	     rntp = new_rntp;
      108 	     goto reinsert;				/* start over to get correct pointers */
      109 	end;
      110 
      111 	rnt.insert.trys = rnt.insert.trys + 1;
      112 reinsert:
      113 	if search_name ()
      114 	then if rnte.segno = segno
      115 	     then call abort (error_table_$segknown);
      116 	     else call abort (error_table_$namedup);
      117 
      118           lth = length (rtrim (rname));
      119 	allocate rnte in (rnt.areap -> based_rnt_area) set (rntep);
      120 	rnte.name_fp = null ();
      121 	last_sp = segno_header ();
      122 	rnte.segno_fp = last_sp -> hash_offset;
      123 	last_sp -> hash_offset = rntep;
      124 	last_np -> rnte.name_fp = last_sp -> hash_offset;
      125 	rnte.segno = segno;
      126 	rnte.name = rname;
      127 	rnt.insert.wins = rnt.insert.wins + 1;
      128 	return;
      129 
      130 
      131 delete:
      132 	entry (a_rname, a_segno, a_code);
      133 	call setup ("10"b);
      134 	rnt.delete_name.trys = rnt.delete_name.trys + 1;
      135 	if ^search_name () then call abort (error_table_$name_not_found);
      136 	a_segno, segno = rnte.segno;
      137 	last_np -> rnte.name_fp = rnte.name_fp;
      138 	savep = rntep;
      139 	call search_segno ();
      140 	do while (savep ^= rntep);
      141 	     if rntep = null () then call abort (error_table_$inconsistent_rnt);
      142 	     call quick_next ();
      143 	end;
      144 	last_sp -> rnte.segno_fp = rnte.segno_fp;
      145 	free rnte in (rnt.areap -> based_rnt_area);
      146 	rnt.delete_name.wins = rnt.delete_name.wins +1;
      147 	return;
      148 
      149 
      150 
      151 delete_segno:
      152 	entry (a_segno, a_code);
      153 	call setup ("01"b);
      154 	rnt.delete_segno.trys = rnt.delete_segno.trys + 1;
      155 	call search_segno ();
      156 	do while (rntep ^= null ());
      157 	     savep = last_sp;
      158 	     save_rntep = rntep;
      159 	     rname = rnte.name;
      160 	     if ^search_name () then call abort (error_table_$inconsistent_rnt);
      161 	     if save_rntep ^= rntep then call abort (error_table_$inconsistent_rnt);
      162 	     last_sp -> rnte.segno_fp = rnte.segno_fp;
      163 	     last_np -> rnte.name_fp = rnte.name_fp;
      164 	     free rnte in (rnt.areap -> based_rnt_area);
      165 	     rntep = savep;
      166 	     call quick_next ();
      167 	end;
      168 	rnt.delete_segno.wins = rnt.delete_segno.wins + 1;
      169 	return;
      170 
      171 
      172 
      173 get_segno:
      174 	entry (a_rname, a_segno, a_code);
      175 	call setup ("10"b);
      176 	rnt.get_segno.trys = rnt.get_segno.trys + 1;
      177 	if ^search_name () then call abort (error_table_$name_not_found);
      178 	a_segno = rnte.segno;
      179 	rnt.get_segno.wins = rnt.get_segno.wins + 1;
      180 	return;
      181 
      182 
      183 get_refname:
      184 	entry (a_segno, a_namecnt, a_rname, a_code);
      185 	call setup ("01"b);
      186 	rnt.get_refnames.trys = rnt.get_refnames.trys + 1;
      187 	call search_segno ();
      188 	do cnt = 1 by 1 while (rntep ^= null ());
      189 	     if cnt = a_namecnt
      190 	     then do;
      191                     a_rname = rnte.name;
      192                     a_code = 0;
      193                     rnt.get_refnames.wins = rnt.get_refnames.wins + 1;
      194                     return;
      195 	     end;
      196 	     call quick_next ();
      197 	end;
      198 	a_code = error_table_$refname_count_too_big;
      199 	return;
      200 
      201 
      202 get_count:
      203 	entry (a_segno, a_count, a_code);
      204 	call setup ("01"b);
      205 	a_count = 0;
      206 	call search_segno ();
      207 	do while (rntep ^= null ());
      208 	     a_count = a_count + 1;
      209 	     call quick_next ();
      210 	end;
      211 	return;
      212 
      213 
      214 search_name:
      215 	proc () returns (bit (1));
      216 	     steps = 0;
      217 	     last_np, rntep = name_header ();
      218 	     do while (rnte.name_fp ^= null ());
      219 		steps = steps + 1;
      220 		if steps > max_steps then call abort (error_table_$inconsistent_rnt);
      221 		last_np = rntep;
      222 		rntep = rnte.name_fp;
      223 		if length (rname) = rnte.length
      224 		then if rnte.name = rname
      225 		     then return ("1"b);
      226 	     end;
      227 	     last_np = rntep;			/* in this case, last_np must point to most rcent node */
      228 	     return ("0"b);
      229 	end search_name;
      230 
      231 
      232 
      233 search_segno:
      234 	proc ();
      235 	     last_sp, rntep = addrel (segno_header (), -1);
      236 quick_next:
      237 	     entry ();
      238 	     do while (rnte.segno_fp ^= null ());
      239 		steps = steps+1;
      240 		if steps > max_steps then call abort (error_table_$inconsistent_rnt);
      241 		last_sp = rntep;
      242 		rntep = rnte.segno_fp;
      243 		if segno = rnte.segno
      244 		then return;
      245 	     end;
      246 	     rntep = null ();
      247 	     return;
      248 	end search_segno;
      249 
      250 segno_header: proc () returns (ptr);
      251 	     return (addr (rnt.segno_hash_table (mod (segno, dimension (rnt.segno_hash_table, 1) -1))));
      252 	end segno_header;
      253 
      254 name_header: proc () returns (ptr);
      255 dcl  chars char (4) aligned,
      256      bits fixed bin (35) based (addr (chars));
      257 	     substr (chars, 1, 2) = rname;
      258 	     substr (chars, 3, 2) = substr (rname, max (length (rname)-1, 1), min (length (rname), 2));
      259 	     return (addr (rnt.name_hash_table (mod (bits, dimension (rnt.name_hash_table, 1) -1))));
      260 	end name_header;
      261 
      262 setup:	proc (given_string);
      263 dcl  given_string bit (36) aligned;
      264 
      265 dcl  1 given aligned,
      266      2 name bit (1) unaligned,
      267      2 seg_no bit (1) unaligned;
      268 
      269      string (given) = given_string;
      270 
      271 	     a_code = 0;
      272 	     steps = 0;
      273 	     if given.name
      274 	     then rname = rtrim (a_rname);
      275 
      276 	     if given.seg_no
      277 	     then do;
      278 		segno = a_segno;
      279 		if segno < 0 then call abort (error_table_$argerr);
      280 	     end;
      281 	     ring = level$get ();
      282 	     if ring = 0 then call abort (error_table_$r0_refname);
      283 	     rntp = pds$stacks (ring) -> stack_header.rnt_ptr;
      284 	     return;
      285 	end setup;
      286 
      287 abort:
      288 	proc (code);
      289 dcl  code fixed bin (35);
      290 	     a_code = code;
      291 	     go to non_local_return;
      292 	end abort;
      293 
      294 non_local_return:
      295 	return;
      296 
      297 /*  */
      298 
      299 	/* BEGIN INCLUDE FILE RNT.INCL.PL1 - WRITTEN SEPTEMBER 1974 BY R. BRATT */
  1     2 /* modified July 1976 by R. Bratt; updated March 1977 by M. Weaver */
  1     3 /* modified November 1977 by M. Weaver to use PL/I offsets instead of pointers */
  1     4 
  1     5 dcl (rntp, rntep) ptr;
  1     6 dcl lth fixed bin (17);
  1     7 dcl based_rnt_area area based;
  1     8 
  1     9 dcl 1 rnt aligned based (rntp),
  1    10     2 areap ptr,					/* pointer to area for rnte allocations */
  1    11     2 meters,
  1    12       3 insert,
  1    13         4 trys fixed bin (17) unaligned,
  1    14         4 wins fixed bin (17) unaligned,
  1    15       3 get_segno like insert,
  1    16       3 get_refnames like insert,
  1    17       3 delete_segno like insert,
  1    18       3 delete_name like insert,
  1    19     2 rnt_area_size fixed bin,
  1    20     2 srulep ptr,
  1    21     2 name_hash_table (0:127) offset (rnt.areap -> based_rnt_area),
  1    22     2 segno_hash_table (0:127) offset (rnt.areap -> based_rnt_area);
  1    23 
  1    24 dcl 1 rnte aligned based (rntep),
  1    25     2 name_fp offset (rnt.areap -> based_rnt_area),
  1    26     2 segno_fp offset (rnt.areap -> based_rnt_area),
  1    27     (2 segno fixed bin (17),
  1    28     2 length fixed bin (17),
  1    29     2 name char (lth refer (rnte.length)))unaligned;
  1    30 
  1    31 /* --------------------END RNT.INCL.PL1--------------------- */
      299 
      300 
      301 
      302 /*  */
      303 
  2     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  2     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  2     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  2     4 /*	Modified April 1983 by C. Hornig for tasking */
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  2     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  2     9*     added the heap_header_ptr definition.
  2    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  2    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  2    12*     Modified to support control point management.  These changes were actually
  2    13*     made in February 1985 by G. Palter.
  2    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  2    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  2    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  2    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  2    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  2    19*     (ITS pair).
  2    20*                                                   END HISTORY COMMENTS */
  2    21 
  2    22 /* format: style2 */
  2    23 
  2    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  2    25 
  2    26      dcl	   1 stack_header	      based (sb) aligned,
  2    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  2    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  2    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  2    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  2    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  2    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  2    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  2    34 	     2 pad4	      bit (2) unal,
  2    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  2    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  2    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  2    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  2    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  2    40 	     2 null_ptr	      ptr,		/*  (16)  */
  2    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  2    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  2    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  2    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  2    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  2    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  2    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  2    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  2    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  2    50 	     2 return_no_pop_op_ptr
  2    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  2    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  2    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  2    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  2    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  2    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  2    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  2    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  2    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  2    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  2    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  2    62 	     2 trace,
  2    63 	       3 frames,
  2    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  2    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  2    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  2    67 	     2 pad2	      bit (36),		/*  (61) */
  2    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  2    69 
  2    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  2    71 
  2    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  2    73 						/* (551) octal */
  2    74 
  2    75 
  2    76 /*	The following constants are offsets within this transfer vector table.  */
  2    77 
  2    78      dcl	   (
  2    79 	   call_offset	      fixed bin init (271),
  2    80 	   push_offset	      fixed bin init (272),
  2    81 	   return_offset	      fixed bin init (273),
  2    82 	   return_no_pop_offset   fixed bin init (274),
  2    83 	   entry_offset	      fixed bin init (275)
  2    84 	   )		      internal static;
  2    85 
  2    86 
  2    87 
  2    88 
  2    89 
  2    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  2    91*	move the whole stack header should use this overlay.
  2    92**/
  2    93 
  2    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  2    95 
  2    96 
  2    97 
  2    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      304 
      305 
      306      end ref_name_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/21/90  1449.0  ref_name_.pl1                     >spec>install>1030>ref_name_.pl1
299          1    01/27/78  1811.4  rnt.incl.pl1                      >ldd>include>rnt.incl.pl1
304          2    11/07/86  1650.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 88 131 151 173 183 192* 198* 202 271*
                                                                                  290*
a_count                                parameter       fixed bin(17,0)          dcl 79 set ref 202 205* 208* 208
a_namecnt                              parameter       fixed bin(17,0)          dcl 64 ref 183 189
a_rname                                parameter       varying char(32)         dcl 64 set ref 88 131 173 183 191* 273
a_segno                                parameter       fixed bin(17,0)          dcl 64 set ref 88 131 136* 151 173 178* 183 202 278
addr                                                   builtin function         dcl 64 ref 251 259 259
addrel                                                 builtin function         dcl 64 ref 99 103 235
area                            000132 stack reference condition                dcl 64 ref 92
areap                                  based           pointer                  level 2 dcl 1-9 set ref 98 99 101* 103 106 119 123
                                                                                  145 164 222 242
based_rnt_area                         based           area(1024)               dcl 1-7 ref 95 98 106 119 123 145 164 222 242
bin                                                    builtin function         dcl 64 ref 99 99 103 103
bits                                   based           fixed bin(35,0)          dcl 255 ref 259
chars                           000206 automatic       char(4)                  dcl 255 set ref 257* 258* 259
clr_ptr                  10            based           pointer                  level 2 dcl 2-26 ref 95
cnt                             000101 automatic       fixed bin(17,0)          dcl 64 set ref 188* 189*
code                                   parameter       fixed bin(35,0)          dcl 289 ref 287 290
delete_name               6            based           structure                level 3 dcl 1-9
delete_segno              5            based           structure                level 3 dcl 1-9
dimension                                              builtin function         dcl 81 ref 251 259
empty                                                  builtin function         dcl 64 ref 95
error_table_$argerr             000020 external static fixed bin(35,0)          dcl 82 set ref 279*
error_table_$inconsistent_rnt   000024 external static fixed bin(35,0)          dcl 83 set ref 141* 160* 161* 220* 240*
error_table_$name_not_found     000022 external static fixed bin(35,0)          dcl 83 set ref 135* 177*
error_table_$namedup            000016 external static fixed bin(35,0)          dcl 82 set ref 116*
error_table_$r0_refname         000026 external static fixed bin(35,0)          dcl 84 set ref 282*
error_table_$refname_count_too_big
                                000012 external static fixed bin(35,0)          dcl 82 ref 198
error_table_$segknown           000014 external static fixed bin(35,0)          dcl 82 set ref 112*
get_refnames              4            based           structure                level 3 dcl 1-9
get_segno                 3            based           structure                level 3 dcl 1-9
given                           000216 automatic       structure                level 1 dcl 265 set ref 269*
given_string                           parameter       bit(36)                  dcl 263 ref 262 269
hash_offset                            based           offset                   dcl 64 set ref 122 123* 124
insert                    2            based           structure                level 3 dcl 1-9
last_np                         000120 automatic       pointer                  dcl 64 set ref 124 137 163 217* 221* 227*
last_sp                         000122 automatic       pointer                  dcl 64 set ref 121* 122 123 124 144 157 162 235*
                                                                                  241*
length                    2(18)        based           fixed bin(17,0)          level 2 in structure "rnte" packed packed unaligned
                                                                                  dcl 1-24 in procedure "ref_name_" set ref 119* 126
                                                                                  145 159 164 191 223 223
length                                                 builtin function         dcl 64 in procedure "ref_name_" ref 118 223 258 258
level$get                       000032 constant        entry                    external dcl 86 ref 281
lth                             000146 automatic       fixed bin(17,0)          dcl 1-6 set ref 118* 119 119
max                                                    builtin function         dcl 81 ref 258
max_steps                              constant        fixed bin(17,0)          initial dcl 64 ref 220 240
meters                    2            based           structure                level 2 dcl 1-9
min                                                    builtin function         dcl 81 ref 258
mod                                                    builtin function         dcl 81 ref 251 259
name                      3            based           char                     level 2 in structure "rnte" packed packed unaligned
                                                                                  dcl 1-24 in procedure "ref_name_" set ref 126* 159
                                                                                  191 223
name                            000216 automatic       bit(1)                   level 2 in structure "given" packed packed unaligned
                                                                                  dcl 265 in procedure "setup" set ref 273
name_fp                                based           offset                   level 2 dcl 1-24 set ref 120* 124* 137* 137 163* 163
                                                                                  218 222
name_hash_table          12            based           offset                   array level 2 dcl 1-9 set ref 259 259
new_rnt_area                           based           area                     dcl 93 set ref 95 95* 98*
new_rnt_areap                   000126 automatic       pointer                  dcl 64 set ref 95* 98 99 101 103
new_rntp                        000130 automatic       pointer                  dcl 64 set ref 99* 101 102 103 105 107
null                                                   builtin function         dcl 64 ref 120 141 156 188 207 218 238 246
pds$stacks                      000030 external static pointer                  array dcl 85 ref 95 105 283
rel                                                    builtin function         dcl 64 ref 99 99 103 103
ring                            000124 automatic       fixed bin(3,0)           dcl 64 set ref 95 105 281* 282 283
rname                           000102 automatic       varying char(32)         dcl 64 set ref 118 126 159* 223 223 257 258 258 258
                                                                                  273*
rnt                                    based           structure                level 1 dcl 1-9
rnt_area_size             7            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 94 102*
rnt_ptr                  62            based           pointer                  level 2 dcl 2-26 set ref 105* 283
rnt_size                        000125 automatic       fixed bin(17,0)          dcl 64 set ref 94* 95 95 102
rnte                                   based           structure                level 1 dcl 1-24 set ref 119 145 164
rntep                           000144 automatic       pointer                  dcl 1-5 set ref 112 119* 120 122 123 125 126 136 137
                                                                                  138 140 141 144 145 156 158 159 161 162 163 164
                                                                                  165* 178 188 191 207 217* 218 221 222* 222 223 223
                                                                                  227 235* 238 241 242* 242 243 246*
rntp                            000142 automatic       pointer                  dcl 1-5 set ref 94 98 99 99 103 103 106 107* 111 111
                                                                                  119 123 127 127 134 134 145 146 146 154 154 164
                                                                                  168 168 176 176 179 179 186 186 193 193 222 242
                                                                                  251 251 259 259 283*
rtrim                                                  builtin function         dcl 64 ref 118 273
save_rntep                      000116 automatic       pointer                  dcl 64 set ref 158* 161
savep                           000114 automatic       pointer                  dcl 64 set ref 138* 140 157* 165
seg_no                    0(01) 000216 automatic       bit(1)                   level 2 packed packed unaligned dcl 265 set ref 276
segno                           000100 automatic       fixed bin(17,0)          dcl 64 in procedure "ref_name_" set ref 112 125 136*
                                                                                  243 251 278* 279
segno                     2            based           fixed bin(17,0)          level 2 in structure "rnte" packed packed unaligned
                                                                                  dcl 1-24 in procedure "ref_name_" set ref 112 125*
                                                                                  136 178 243
segno_fp                  1            based           offset                   level 2 dcl 1-24 set ref 122* 144* 144 162* 162 238
                                                                                  242
segno_hash_table        212            based           offset                   array level 2 dcl 1-9 set ref 251 251
srulep                   10            based           pointer                  level 2 dcl 1-9 set ref 103* 103
stack_header                           based           structure                level 1 dcl 2-26
steps                           000140 automatic       fixed bin(17,0)          dcl 64 set ref 216* 219* 219 220 239* 239 240 272*
string                                                 builtin function         dcl 64 set ref 269*
substr                                                 builtin function         dcl 64 set ref 257* 258* 258
trys                      5            based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 154* 154
trys                      3            based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 176* 176
trys                      6            based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 134* 134
trys                      2            based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 111* 111
trys                      4            based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 186* 186
wins                      5(18)        based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 168* 168
wins                      2(18)        based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 127* 127
wins                      4(18)        based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 193* 193
wins                      6(18)        based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 146* 146
wins                      3(18)        based           fixed bin(17,0)          level 4 in structure "rnt" packed packed unaligned
                                                                                  dcl 1-9 in procedure "ref_name_" set ref 179* 179

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
call_offset                            internal static fixed bin(17,0)          initial dcl 2-78
entry_offset                           internal static fixed bin(17,0)          initial dcl 2-78
push_offset                            internal static fixed bin(17,0)          initial dcl 2-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 2-78
return_offset                          internal static fixed bin(17,0)          initial dcl 2-78
sb                                     automatic       pointer                  dcl 2-24
stack_header_overlay                   based           fixed bin(17,0)          array dcl 2-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 2-72

NAMES DECLARED BY EXPLICIT CONTEXT.
abort                           001332 constant        entry                    internal dcl 287 ref 112 116 135 141 160 161 177 220
                                                                                  240 279 282
delete                          000322 constant        entry                    external dcl 131
delete_segno                    000446 constant        entry                    external dcl 151
get_count                       000763 constant        entry                    external dcl 202
get_refname                     000662 constant        entry                    external dcl 183
get_segno                       000600 constant        entry                    external dcl 173
insert                          000025 constant        entry                    external dcl 88
name_header                     001173 constant        entry                    internal dcl 254 ref 217
non_local_return                001015 constant        label                    dcl 294 ref 291
quick_next                      001116 constant        entry                    internal dcl 236 ref 142 166 196 209
ref_name_                       000013 constant        entry                    external dcl 25
reinsert                        000205 constant        label                    dcl 112 ref 108
search_name                     001016 constant        entry                    internal dcl 214 ref 112 135 160 177
search_segno                    001105 constant        entry                    internal dcl 233 ref 139 155 187 206
segno_header                    001157 constant        entry                    internal dcl 250 ref 121 235
setup                           001231 constant        entry                    internal dcl 262 ref 90 133 153 175 185 204

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1566        1622    1365        1576
Length      2050    1365        34         211     201           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ref_name_                           202 external procedure  is an external procedure.  
on unit on line 92                   78 on unit               
search_name                             internal procedure  shares stack frame of external procedure ref_name_.  
search_segno                            internal procedure  shares stack frame of external procedure ref_name_.  
segno_header                            internal procedure  shares stack frame of external procedure ref_name_.  
name_header                             internal procedure  shares stack frame of external procedure ref_name_.  
setup                                   internal procedure  shares stack frame of external procedure ref_name_.  
abort                                   internal procedure  shares stack frame of external procedure ref_name_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ref_name_                000100 segno                       ref_name_
                         000101 cnt                         ref_name_
                         000102 rname                       ref_name_
                         000114 savep                       ref_name_
                         000116 save_rntep                  ref_name_
                         000120 last_np                     ref_name_
                         000122 last_sp                     ref_name_
                         000124 ring                        ref_name_
                         000125 rnt_size                    ref_name_
                         000126 new_rnt_areap               ref_name_
                         000130 new_rntp                    ref_name_
                         000140 steps                       ref_name_
                         000142 rntp                        ref_name_
                         000144 rntep                       ref_name_
                         000146 lth                         ref_name_
                         000206 chars                       name_header
                         000216 given                       setup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          tra_ext_1           mdfx1               enable_op           ext_entry
int_entry           pointer_hard        offset_hard         op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_assign_                  level$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$inconsistent_rnt error_table_$name_not_found   error_table_$namedup
error_table_$r0_refname       error_table_$refname_count_too_big                          error_table_$segknown
pds$stacks


CONSTANTS
001340  aa     000002000000
001341  aa     000000000000
001342  aa     600000000041
001343  aa     000270000000

001344  aa     000002000000
001345  aa     000000000000
001346  aa     600000000041
001347  aa     000260000000

001350  aa     000002000000
001351  aa     000000000000
001352  aa     600000000041
001353  aa     000227000000

001354  aa     000002000000
001355  aa     000000000000
001356  aa     600000000041
001357  aa     000122000000

001360  aa     000002000000
001361  aa     000000000000
001362  aa     600000000041
001363  aa     000226000000

000000  aa     514000000044

001364  aa     777777777777

000001  aa     464000000000

000002  aa     516000000001

000003  aa     404000000003

000004  aa  141 162 145 141	area

000005  aa     404000000043

000006  aa     404000000021

000007  aa     530000000040

000010  aa     077777000043
000011  aa     000001000000

BEGIN PROCEDURE ref_name_
ENTRY TO ref_name_                                          STATEMENT 1 ON LINE 25
ref_name_: proc ();

000012  da     000125200000
000013  aa   000320 6270 00	eax7 	208
000014  aa  7 00034 3521 20	epp2 	pr7|28,*
000015  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000016  aa     000000000000
000017  aa     000000000000
						STATEMENT 1 ON LINE 88
insert:
	entry (a_rname, a_segno, a_code);

000020  aa   000021 7100 04	tra  	17,ic		000041
ENTRY TO insert                                             STATEMENT 1 ON LINE 88
insert:
	entry (a_rname, a_segno, a_code);

000021  at     000003000007
000022  tt     000006000005
000023  ta     000021000000
000024  da     000132300000
000025  aa   000320 6270 00	eax7 	208
000026  aa  7 00034 3521 20	epp2 	pr7|28,*
000027  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000030  aa     000006000000
000031  aa     000000000000
000032  aa  6 00032 3735 20	epp7 	pr6|26,*
000033  aa  7 00002 3715 20	epp5 	pr7|2,*
000034  aa  6 00150 6515 00	spri5	pr6|104
000035  aa  7 00004 3535 20	epp3 	pr7|4,*
000036  aa  6 00152 2535 00	spri3	pr6|106
000037  aa  7 00006 3515 20	epp1 	pr7|6,*
000040  aa  6 00154 2515 00	spri1	pr6|108
						STATEMENT 1 ON LINE 90
	call setup ("11"b);

000041  aa   600000 2350 03	lda  	196608,du
000042  aa  6 00226 7551 00	sta  	pr6|150
000043  aa   001315 3520 04	epp2 	717,ic		001360 = 000002000000
000044  aa   001165 6700 04	tsp4 	629,ic		001231
						STATEMENT 1 ON LINE 92
	on area begin;

000045  aa   000004 7260 07	lxl6 	4,dl
000046  aa   777736 3520 04	epp2 	-34,ic		000004 = 141162145141
000047  aa  0 00717 7001 00	tsx0 	pr0|463		enable_op
000050  aa   000004 7100 04	tra  	4,ic		000054
000051  aa     000132000000
000052  aa   000125 7100 04	tra  	85,ic		000177
BEGIN CONDITION area.1
ENTRY TO area.1                                             STATEMENT 1 ON LINE 92
	on area begin;

000053  da     000137200000
000054  aa   000120 6270 00	eax7 	80
000055  aa  7 00034 3521 20	epp2 	pr7|28,*
000056  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000057  aa     000000000000
000060  aa     000000000000
						STATEMENT 1 ON LINE 94
	     rnt_size = rnt.rnt_area_size * 2;

000061  aa  6 00040 3735 20	epp7 	pr6|32,*
000062  aa  7 00142 3715 20	epp5 	pr7|98,*		rntp
000063  aa  5 00007 2361 00	ldq  	pr5|7		rnt.rnt_area_size
000064  aa   000001 7360 00	qls  	1
000065  aa  7 00125 7561 00	stq  	pr7|85		rnt_size
						STATEMENT 1 ON LINE 95
	     allocate new_rnt_area in (pds$stacks (ring) -> stack_header.clr_ptr -> based_rnt_area)
		set (new_rnt_areap);

000066  aa  6 00040 3735 20	epp7 	pr6|32,*
000067  aa  7 00124 2361 00	ldq  	pr7|84		ring
000070  aa   000001 7360 00	qls  	1
000071  aa   000000 6270 06	eax7 	0,ql
000072  aa  7 00125 2361 00	ldq  	pr7|85		rnt_size
000073  aa  6 00044 3701 20	epp4 	pr6|36,*
000074  la  4 00030 3715 77	epp5 	pr4|24,*7		pds$stacks
000075  aa  5 00000 3715 20	epp5 	pr5|0,*		pds$stacks
000076  aa  5 00010 3521 20	epp2 	pr5|8,*		based_rnt_area
000077  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000100  aa   777766 7100 04	tra  	-10,ic		000066
000101  aa  6 00040 3735 20	epp7 	pr6|32,*
000102  aa  7 00126 2521 00	spri2	pr7|86		new_rnt_areap
000103  aa  7 00125 2361 00	ldq  	pr7|85		rnt_size
000104  aa  0 01405 7001 00	tsx0 	pr0|773		op_empty_
						STATEMENT 1 ON LINE 98
	     new_rnt_areap -> new_rnt_area = rnt.areap -> based_rnt_area;

000105  aa  6 00040 3735 20	epp7 	pr6|32,*
000106  aa  7 00126 3735 20	epp7 	pr7|86,*		new_rnt_area
000107  aa  6 00102 6535 00	spri7	pr6|66
000110  aa  6 00040 3715 20	epp5 	pr6|32,*
000111  aa  5 00142 3535 20	epp3 	pr5|98,*		rnt.areap
000112  aa  3 00000 3715 20	epp5 	pr3|0,*		based_rnt_area
000113  aa  6 00104 6515 00	spri5	pr6|68
000114  aa  6 00102 3521 00	epp2 	pr6|66
000115  aa  6 00110 2521 00	spri2	pr6|72
000116  aa  6 00104 3521 00	epp2 	pr6|68
000117  aa  6 00112 2521 00	spri2	pr6|74
000120  aa  6 00106 6211 00	eax1 	pr6|70
000121  aa   010000 4310 07	fld  	4096,dl
000122  aa  6 00044 3701 20	epp4 	pr6|36,*
000123  la  4 00010 3521 20	epp2 	pr4|8,*		area_assign_
000124  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 99
	     new_rntp = addrel (new_rnt_areap, (bin (rel (rntp), 18) - bin (rel (rnt.areap), 18)));

000125  aa  6 00040 3735 20	epp7 	pr6|32,*
000126  aa  7 00142 3715 20	epp5 	pr7|98,*		rnt.areap
000127  aa  5 00000 3715 20	epp5 	pr5|0,*		rnt.areap
000130  aa  5 00000 6351 00	eaa  	pr5|0		rnt.areap
000131  aa   000066 7730 00	lrl  	54
000132  aa  6 00101 7561 00	stq  	pr6|65
000133  aa  7 00142 6351 20	eaa  	pr7|98,*		rntp
000134  aa   000066 7730 00	lrl  	54
000135  aa  6 00101 1761 00	sbq  	pr6|65
000136  aa  7 00126 3521 66	epp2 	pr7|86,*ql	new_rnt_areap
000137  aa   000000 0520 03	adwp2	0,du
000140  aa  7 00130 2521 00	spri2	pr7|88		new_rntp
						STATEMENT 1 ON LINE 101
	     new_rntp -> rnt.areap = new_rnt_areap;

000141  aa  7 00126 3535 20	epp3 	pr7|86,*		new_rnt_areap
000142  aa  2 00000 2535 00	spri3	pr2|0		rnt.areap
						STATEMENT 1 ON LINE 102
	     new_rntp -> rnt.rnt_area_size = rnt_size;

000143  aa  7 00125 2361 00	ldq  	pr7|85		rnt_size
000144  aa  2 00007 7561 00	stq  	pr2|7		rnt.rnt_area_size
						STATEMENT 1 ON LINE 103
	     new_rntp -> rnt.srulep = addrel (new_rnt_areap, (bin (rel (rnt.srulep), 18) - bin (rel (rnt.areap), 18)));

000145  aa  7 00142 3515 20	epp1 	pr7|98,*		rnt.areap
000146  aa  1 00000 3515 20	epp1 	pr1|0,*		rnt.areap
000147  aa  1 00000 6351 00	eaa  	pr1|0		rnt.areap
000150  aa   000066 7730 00	lrl  	54
000151  aa  6 00101 7561 00	stq  	pr6|65
000152  aa  7 00142 3715 20	epp5 	pr7|98,*		rntp
000153  aa  5 00010 6351 20	eaa  	pr5|8,*		rnt.srulep
000154  aa   000066 7730 00	lrl  	54
000155  aa  6 00101 1761 00	sbq  	pr6|65
000156  aa  3 00000 3515 06	epp1 	pr3|0,ql
000157  aa   000000 0510 03	adwp1	0,du
000160  aa  2 00010 2515 00	spri1	pr2|8		rnt.srulep
						STATEMENT 1 ON LINE 105
	     pds$stacks (ring) -> stack_header.rnt_ptr = new_rntp;

000161  aa  7 00124 2361 00	ldq  	pr7|84		ring
000162  aa   000001 7360 00	qls  	1
000163  aa  6 00044 3701 20	epp4 	pr6|36,*
000164  la  4 00030 3515 66	epp1 	pr4|24,*ql	pds$stacks
000165  aa  1 00000 3515 20	epp1 	pr1|0,*		pds$stacks
000166  aa  1 00062 2521 00	spri2	pr1|50		stack_header.rnt_ptr
						STATEMENT 1 ON LINE 106
	     free rnt.areap -> based_rnt_area;

000167  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 107
	     rntp = new_rntp;

000170  aa  6 00040 3735 20	epp7 	pr6|32,*
000171  aa  7 00130 3735 20	epp7 	pr7|88,*		new_rntp
000172  aa  6 00040 3715 20	epp5 	pr6|32,*
000173  aa  5 00142 6535 00	spri7	pr5|98		rntp
						STATEMENT 1 ON LINE 108
	     goto reinsert;

000174  aa   000011 3520 04	epp2 	9,ic		000205 = 001153352004
000175  aa   000001 7270 07	lxl7 	1,dl
000176  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 109
	end;

  END CONDITION area.1
						STATEMENT 1 ON LINE 111
	rnt.insert.trys = rnt.insert.trys + 1;

000177  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000200  aa  7 00002 2351 00	lda  	pr7|2		rnt.trys
000201  aa   000066 7330 00	lrs  	54
000202  aa   000001 0760 07	adq  	1,dl
000203  aa   000066 7370 00	lls  	54
000204  aa  7 00002 5511 60	stba 	pr7|2,60		rnt.trys
						STATEMENT 1 ON LINE 112
reinsert:
	if search_name ()
	then if rnte.segno = segno
	     then call abort (error_table_$segknown);

000205  aa   001153 3520 04	epp2 	619,ic		001360 = 000002000000
000206  aa   000610 6700 04	tsp4 	392,ic		001016
000207  aa  6 00226 2351 00	lda  	pr6|150
000210  aa   400000 3150 03	cana 	131072,du
000211  aa   000025 6000 04	tze  	21,ic		000236
000212  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000213  aa  7 00002 2351 00	lda  	pr7|2		rnte.segno
000214  aa   000066 7330 00	lrs  	54
000215  aa  6 00100 1161 00	cmpq 	pr6|64		segno
000216  aa   000011 6010 04	tnz  	9,ic		000227
000217  aa  6 00044 3701 20	epp4 	pr6|36,*
000220  la  4 00014 3521 20	epp2 	pr4|12,*		error_table_$segknown
000221  aa  6 00232 2521 00	spri2	pr6|154
000222  aa  6 00230 3521 00	epp2 	pr6|152
000223  aa   004000 4310 07	fld  	2048,dl
000224  aa  2 00000 7571 00	staq 	pr2|0
000225  aa   001105 6700 04	tsp4 	581,ic		001332
000226  aa   000010 7100 04	tra  	8,ic		000236
						STATEMENT 1 ON LINE 116
	     else call abort (error_table_$namedup);

000227  aa  6 00044 3701 20	epp4 	pr6|36,*
000230  la  4 00016 3521 20	epp2 	pr4|14,*		error_table_$namedup
000231  aa  6 00232 2521 00	spri2	pr6|154
000232  aa  6 00230 3521 00	epp2 	pr6|152
000233  aa   004000 4310 07	fld  	2048,dl
000234  aa  2 00000 7571 00	staq 	pr2|0
000235  aa   001075 6700 04	tsp4 	573,ic		001332
						STATEMENT 1 ON LINE 118
          lth = length (rtrim (rname));

000236  aa  6 00102 7271 00	lxl7 	pr6|66		rname
000237  aa  000 000 165 540	tctr 	(pr,rl)
000240  aa  6 00103 00 0017	desc9a	pr6|67,x7		rname
000241  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
000242  aa  6 00056 0001 00	arg  	pr6|46
000243  aa  6 00056 2361 00	ldq  	pr6|46
000244  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
000245  aa  6 00227 7561 00	stq  	pr6|151
000246  aa  6 00102 2361 00	ldq  	pr6|66		rname
000247  aa  6 00227 1761 00	sbq  	pr6|151
000250  aa  6 00146 7561 00	stq  	pr6|102		lth
						STATEMENT 1 ON LINE 119
	allocate rnte in (rnt.areap -> based_rnt_area) set (rntep);

000251  aa  6 00146 2361 00	ldq  	pr6|102		lth
000252  aa   000014 0760 07	adq  	12,dl
000253  aa   000003 0760 07	adq  	3,dl
000254  aa   000002 7320 00	qrs  	2
000255  aa  6 00142 3735 20	epp7 	pr6|98,*		rnt.areap
000256  aa  7 00000 3521 20	epp2 	pr7|0,*		based_rnt_area
000257  aa  0 01402 7001 00	tsx0 	pr0|770		op_alloc_
000260  aa   777771 7100 04	tra  	-7,ic		000251
000261  aa  6 00144 2521 00	spri2	pr6|100		rntep
000262  aa  6 00146 2361 00	ldq  	pr6|102		lth
000263  aa  2 00002 5521 14	stbq 	pr2|2,14		rnte.length
						STATEMENT 1 ON LINE 120
	rnte.name_fp = null ();

000264  aa   000001 3360 07	lcq  	1,dl
000265  aa  2 00000 7561 00	stq  	pr2|0		rnte.name_fp
						STATEMENT 1 ON LINE 121
	last_sp = segno_header ();

000266  aa   001066 3520 04	epp2 	566,ic		001354 = 000002000000
000267  aa   000670 6700 04	tsp4 	440,ic		001157
						STATEMENT 1 ON LINE 122
	rnte.segno_fp = last_sp -> hash_offset;

000270  aa  6 00122 2361 20	ldq  	pr6|82,*		hash_offset
000271  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000272  aa  7 00001 7561 00	stq  	pr7|1		rnte.segno_fp
						STATEMENT 1 ON LINE 123
	last_sp -> hash_offset = rntep;

000273  aa  6 00144 2371 00	ldaq 	pr6|100		rntep
000274  aa  6 00142 3715 20	epp5 	pr6|98,*		rnt.areap
000275  aa  5 00000 3521 20	epp2 	pr5|0,*		based_rnt_area
000276  aa  0 01210 7001 00	tsx0 	pr0|648		offset_hard
000277  aa  6 00122 7561 20	stq  	pr6|82,*		hash_offset
						STATEMENT 1 ON LINE 124
	last_np -> rnte.name_fp = last_sp -> hash_offset;

000300  aa  6 00120 7561 20	stq  	pr6|80,*		rnte.name_fp
						STATEMENT 1 ON LINE 125
	rnte.segno = segno;

000301  aa  6 00100 2361 00	ldq  	pr6|64		segno
000302  aa   000066 7370 00	lls  	54
000303  aa  7 00002 5511 60	stba 	pr7|2,60		rnte.segno
						STATEMENT 1 ON LINE 126
	rnte.name = rname;

000304  aa  7 00002 7271 00	lxl7 	pr7|2		rnte.length
000305  aa  6 00102 7261 00	lxl6 	pr6|66		rname
000306  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000307  aa  6 00103 00 0016	desc9a	pr6|67,x6		rname
000310  aa  7 00003 00 0017	desc9a	pr7|3,x7		rnte.name
						STATEMENT 1 ON LINE 127
	rnt.insert.wins = rnt.insert.wins + 1;

000311  aa  6 00142 3535 20	epp3 	pr6|98,*		rntp
000312  aa  3 00002 2351 00	lda  	pr3|2		rnt.wins
000313  aa   000022 7350 00	als  	18
000314  aa   000066 7330 00	lrs  	54
000315  aa   000001 0760 07	adq  	1,dl
000316  aa  3 00002 5521 14	stbq 	pr3|2,14		rnt.wins
						STATEMENT 1 ON LINE 128
	return;

000317  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO delete                                             STATEMENT 1 ON LINE 131
delete:
	entry (a_rname, a_segno, a_code);

000320  ta     000021000000
000321  da     000144300000
000322  aa   000320 6270 00	eax7 	208
000323  aa  7 00034 3521 20	epp2 	pr7|28,*
000324  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000325  aa     000006000000
000326  aa     000000000000
000327  aa  6 00032 3735 20	epp7 	pr6|26,*
000330  aa  7 00002 3715 20	epp5 	pr7|2,*
000331  aa  6 00150 6515 00	spri5	pr6|104
000332  aa  7 00004 3535 20	epp3 	pr7|4,*
000333  aa  6 00152 2535 00	spri3	pr6|106
000334  aa  7 00006 3515 20	epp1 	pr7|6,*
000335  aa  6 00154 2515 00	spri1	pr6|108
						STATEMENT 1 ON LINE 133
	call setup ("10"b);

000336  aa   400000 2350 03	lda  	131072,du
000337  aa  6 00227 7551 00	sta  	pr6|151
000340  aa   001010 3520 04	epp2 	520,ic		001350 = 000002000000
000341  aa   000670 6700 04	tsp4 	440,ic		001231
						STATEMENT 1 ON LINE 134
	rnt.delete_name.trys = rnt.delete_name.trys + 1;

000342  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000343  aa  7 00006 2351 00	lda  	pr7|6		rnt.trys
000344  aa   000066 7330 00	lrs  	54
000345  aa   000001 0760 07	adq  	1,dl
000346  aa   000066 7370 00	lls  	54
000347  aa  7 00006 5511 60	stba 	pr7|6,60		rnt.trys
						STATEMENT 1 ON LINE 135
	if ^search_name () then call abort (error_table_$name_not_found);

000350  aa   001000 3520 04	epp2 	512,ic		001350 = 000002000000
000351  aa   000445 6700 04	tsp4 	293,ic		001016
000352  aa  6 00227 2351 00	lda  	pr6|151
000353  aa   400000 3150 03	cana 	131072,du
000354  aa   000010 6010 04	tnz  	8,ic		000364
000355  aa  6 00044 3701 20	epp4 	pr6|36,*
000356  la  4 00022 3521 20	epp2 	pr4|18,*		error_table_$name_not_found
000357  aa  6 00232 2521 00	spri2	pr6|154
000360  aa  6 00230 3521 00	epp2 	pr6|152
000361  aa   004000 4310 07	fld  	2048,dl
000362  aa  2 00000 7571 00	staq 	pr2|0
000363  aa   000747 6700 04	tsp4 	487,ic		001332
						STATEMENT 1 ON LINE 136
	a_segno, segno = rnte.segno;

000364  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000365  aa  7 00002 2351 00	lda  	pr7|2		rnte.segno
000366  aa   000066 7330 00	lrs  	54
000367  aa  6 00152 7561 20	stq  	pr6|106,*		a_segno
000370  aa  6 00100 7561 00	stq  	pr6|64		segno
						STATEMENT 1 ON LINE 137
	last_np -> rnte.name_fp = rnte.name_fp;

000371  aa  7 00000 2361 00	ldq  	pr7|0		rnte.name_fp
000372  aa  6 00120 7561 20	stq  	pr6|80,*		rnte.name_fp
						STATEMENT 1 ON LINE 138
	savep = rntep;

000373  aa  6 00114 6535 00	spri7	pr6|76		savep
						STATEMENT 1 ON LINE 139
	call search_segno ();

000374  aa   000511 6700 04	tsp4 	329,ic		001105
						STATEMENT 1 ON LINE 140
	do while (savep ^= rntep);

000375  aa   000000 0110 03	nop  	0,du
000376  aa  6 00114 2371 00	ldaq 	pr6|76		savep
000377  aa  6 00144 6771 00	eraq 	pr6|100		rntep
000400  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000401  aa   000016 6000 04	tze  	14,ic		000417
						STATEMENT 1 ON LINE 141
	     if rntep = null () then call abort (error_table_$inconsistent_rnt);

000402  aa  6 00144 2371 00	ldaq 	pr6|100		rntep
000403  aa   777405 6770 04	eraq 	-251,ic		000010 = 077777000043 000001000000
000404  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000405  aa   000010 6010 04	tnz  	8,ic		000415
000406  aa  6 00044 3701 20	epp4 	pr6|36,*
000407  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$inconsistent_rnt
000410  aa  6 00232 2521 00	spri2	pr6|154
000411  aa  6 00230 3521 00	epp2 	pr6|152
000412  aa   004000 4310 07	fld  	2048,dl
000413  aa  2 00000 7571 00	staq 	pr2|0
000414  aa   000716 6700 04	tsp4 	462,ic		001332
						STATEMENT 1 ON LINE 142
	     call quick_next ();

000415  aa   000501 6700 04	tsp4 	321,ic		001116
						STATEMENT 1 ON LINE 143
	end;

000416  aa   777760 7100 04	tra  	-16,ic		000376
						STATEMENT 1 ON LINE 144
	last_sp -> rnte.segno_fp = rnte.segno_fp;

000417  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000420  aa  7 00001 2361 00	ldq  	pr7|1		rnte.segno_fp
000421  aa  6 00122 3715 20	epp5 	pr6|82,*		last_sp
000422  aa  5 00001 7561 00	stq  	pr5|1		rnte.segno_fp
						STATEMENT 1 ON LINE 145
	free rnte in (rnt.areap -> based_rnt_area);

000423  aa  7 00002 2351 00	lda  	pr7|2		rnte.length
000424  aa   000022 7350 00	als  	18
000425  aa   000066 7330 00	lrs  	54
000426  aa   000014 0760 07	adq  	12,dl
000427  aa   000003 0760 07	adq  	3,dl
000430  aa   000002 7320 00	qrs  	2
000431  aa  6 00144 3715 00	epp5 	pr6|100		rntep
000432  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 146
	rnt.delete_name.wins = rnt.delete_name.wins +1;

000433  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000434  aa  7 00006 2351 00	lda  	pr7|6		rnt.wins
000435  aa   000022 7350 00	als  	18
000436  aa   000066 7330 00	lrs  	54
000437  aa   000001 0760 07	adq  	1,dl
000440  aa  7 00006 5521 14	stbq 	pr7|6,14		rnt.wins
						STATEMENT 1 ON LINE 147
	return;

000441  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO delete_segno                                       STATEMENT 1 ON LINE 151
delete_segno:
	entry (a_segno, a_code);

000442  at     000002000006
000443  ta     000005000000
000444  ta     000442000000
000445  da     000153300000
000446  aa   000320 6270 00	eax7 	208
000447  aa  7 00034 3521 20	epp2 	pr7|28,*
000450  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000451  aa     000004000000
000452  aa     000000000000
000453  aa  6 00032 3735 20	epp7 	pr6|26,*
000454  aa  7 00002 3715 20	epp5 	pr7|2,*
000455  aa  6 00152 6515 00	spri5	pr6|106
000456  aa  7 00004 3535 20	epp3 	pr7|4,*
000457  aa  6 00154 2535 00	spri3	pr6|108
						STATEMENT 1 ON LINE 153
	call setup ("01"b);

000460  aa   200000 2350 03	lda  	65536,du
000461  aa  6 00227 7551 00	sta  	pr6|151
000462  aa   000666 3520 04	epp2 	438,ic		001350 = 000002000000
000463  aa   000546 6700 04	tsp4 	358,ic		001231
						STATEMENT 1 ON LINE 154
	rnt.delete_segno.trys = rnt.delete_segno.trys + 1;

000464  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000465  aa  7 00005 2351 00	lda  	pr7|5		rnt.trys
000466  aa   000066 7330 00	lrs  	54
000467  aa   000001 0760 07	adq  	1,dl
000470  aa   000066 7370 00	lls  	54
000471  aa  7 00005 5511 60	stba 	pr7|5,60		rnt.trys
						STATEMENT 1 ON LINE 155
	call search_segno ();

000472  aa   000413 6700 04	tsp4 	267,ic		001105
						STATEMENT 1 ON LINE 156
	do while (rntep ^= null ());

000473  aa   000000 0110 03	nop  	0,du
000474  aa  6 00144 2371 00	ldaq 	pr6|100		rntep
000475  aa   777313 6770 04	eraq 	-309,ic		000010 = 077777000043 000001000000
000476  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000477  aa   000070 6000 04	tze  	56,ic		000567
						STATEMENT 1 ON LINE 157
	     savep = last_sp;

000500  aa  6 00122 3735 20	epp7 	pr6|82,*		last_sp
000501  aa  6 00114 6535 00	spri7	pr6|76		savep
						STATEMENT 1 ON LINE 158
	     save_rntep = rntep;

000502  aa  6 00144 3715 20	epp5 	pr6|100,*		rntep
000503  aa  6 00116 6515 00	spri5	pr6|78		save_rntep
						STATEMENT 1 ON LINE 159
	     rname = rnte.name;

000504  aa  5 00002 7271 00	lxl7 	pr5|2		rnte.length
000505  aa   000000 6360 17	eaq  	0,7
000506  aa   000022 7320 00	qrs  	18
000507  aa   000040 1160 07	cmpq 	32,dl
000510  aa   000002 6040 04	tmi  	2,ic		000512
000511  aa   000040 2360 07	ldq  	32,dl
000512  aa  6 00102 7561 00	stq  	pr6|66		rname
000513  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000514  aa  5 00003 00 0006	desc9a	pr5|3,ql		rnte.name
000515  aa  6 00103 00 0006	desc9a	pr6|67,ql		rname
						STATEMENT 1 ON LINE 160
	     if ^search_name () then call abort (error_table_$inconsistent_rnt);

000516  aa   000632 3520 04	epp2 	410,ic		001350 = 000002000000
000517  aa   000277 6700 04	tsp4 	191,ic		001016
000520  aa  6 00227 2351 00	lda  	pr6|151
000521  aa   400000 3150 03	cana 	131072,du
000522  aa   000010 6010 04	tnz  	8,ic		000532
000523  aa  6 00044 3701 20	epp4 	pr6|36,*
000524  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$inconsistent_rnt
000525  aa  6 00232 2521 00	spri2	pr6|154
000526  aa  6 00230 3521 00	epp2 	pr6|152
000527  aa   004000 4310 07	fld  	2048,dl
000530  aa  2 00000 7571 00	staq 	pr2|0
000531  aa   000601 6700 04	tsp4 	385,ic		001332
						STATEMENT 1 ON LINE 161
	     if save_rntep ^= rntep then call abort (error_table_$inconsistent_rnt);

000532  aa  6 00116 2371 00	ldaq 	pr6|78		save_rntep
000533  aa  6 00144 6771 00	eraq 	pr6|100		rntep
000534  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000535  aa   000010 6000 04	tze  	8,ic		000545
000536  aa  6 00044 3701 20	epp4 	pr6|36,*
000537  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$inconsistent_rnt
000540  aa  6 00232 2521 00	spri2	pr6|154
000541  aa  6 00230 3521 00	epp2 	pr6|152
000542  aa   004000 4310 07	fld  	2048,dl
000543  aa  2 00000 7571 00	staq 	pr2|0
000544  aa   000566 6700 04	tsp4 	374,ic		001332
						STATEMENT 1 ON LINE 162
	     last_sp -> rnte.segno_fp = rnte.segno_fp;

000545  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000546  aa  7 00001 2361 00	ldq  	pr7|1		rnte.segno_fp
000547  aa  6 00122 3715 20	epp5 	pr6|82,*		last_sp
000550  aa  5 00001 7561 00	stq  	pr5|1		rnte.segno_fp
						STATEMENT 1 ON LINE 163
	     last_np -> rnte.name_fp = rnte.name_fp;

000551  aa  7 00000 2361 00	ldq  	pr7|0		rnte.name_fp
000552  aa  6 00120 7561 20	stq  	pr6|80,*		rnte.name_fp
						STATEMENT 1 ON LINE 164
	     free rnte in (rnt.areap -> based_rnt_area);

000553  aa  7 00002 2351 00	lda  	pr7|2		rnte.length
000554  aa   000022 7350 00	als  	18
000555  aa   000066 7330 00	lrs  	54
000556  aa   000014 0760 07	adq  	12,dl
000557  aa   000003 0760 07	adq  	3,dl
000560  aa   000002 7320 00	qrs  	2
000561  aa  6 00144 3715 00	epp5 	pr6|100		rntep
000562  aa  0 01404 7001 00	tsx0 	pr0|772		op_freen_
						STATEMENT 1 ON LINE 165
	     rntep = savep;

000563  aa  6 00114 3735 20	epp7 	pr6|76,*		savep
000564  aa  6 00144 6535 00	spri7	pr6|100		rntep
						STATEMENT 1 ON LINE 166
	     call quick_next ();

000565  aa   000331 6700 04	tsp4 	217,ic		001116
						STATEMENT 1 ON LINE 167
	end;

000566  aa   777706 7100 04	tra  	-58,ic		000474
						STATEMENT 1 ON LINE 168
	rnt.delete_segno.wins = rnt.delete_segno.wins + 1;

000567  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000570  aa  7 00005 2351 00	lda  	pr7|5		rnt.wins
000571  aa   000022 7350 00	als  	18
000572  aa   000066 7330 00	lrs  	54
000573  aa   000001 0760 07	adq  	1,dl
000574  aa  7 00005 5521 14	stbq 	pr7|5,14		rnt.wins
						STATEMENT 1 ON LINE 169
	return;

000575  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_segno                                          STATEMENT 1 ON LINE 173
get_segno:
	entry (a_rname, a_segno, a_code);

000576  ta     000021000000
000577  da     000161300000
000600  aa   000320 6270 00	eax7 	208
000601  aa  7 00034 3521 20	epp2 	pr7|28,*
000602  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000603  aa     000006000000
000604  aa     000000000000
000605  aa  6 00032 3735 20	epp7 	pr6|26,*
000606  aa  7 00002 3715 20	epp5 	pr7|2,*
000607  aa  6 00150 6515 00	spri5	pr6|104
000610  aa  7 00004 3535 20	epp3 	pr7|4,*
000611  aa  6 00152 2535 00	spri3	pr6|106
000612  aa  7 00006 3515 20	epp1 	pr7|6,*
000613  aa  6 00154 2515 00	spri1	pr6|108
						STATEMENT 1 ON LINE 175
	call setup ("10"b);

000614  aa   400000 2350 03	lda  	131072,du
000615  aa  6 00227 7551 00	sta  	pr6|151
000616  aa   000532 3520 04	epp2 	346,ic		001350 = 000002000000
000617  aa   000412 6700 04	tsp4 	266,ic		001231
						STATEMENT 1 ON LINE 176
	rnt.get_segno.trys = rnt.get_segno.trys + 1;

000620  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000621  aa  7 00003 2351 00	lda  	pr7|3		rnt.trys
000622  aa   000066 7330 00	lrs  	54
000623  aa   000001 0760 07	adq  	1,dl
000624  aa   000066 7370 00	lls  	54
000625  aa  7 00003 5511 60	stba 	pr7|3,60		rnt.trys
						STATEMENT 1 ON LINE 177
	if ^search_name () then call abort (error_table_$name_not_found);

000626  aa   000522 3520 04	epp2 	338,ic		001350 = 000002000000
000627  aa   000167 6700 04	tsp4 	119,ic		001016
000630  aa  6 00227 2351 00	lda  	pr6|151
000631  aa   400000 3150 03	cana 	131072,du
000632  aa   000010 6010 04	tnz  	8,ic		000642
000633  aa  6 00044 3701 20	epp4 	pr6|36,*
000634  la  4 00022 3521 20	epp2 	pr4|18,*		error_table_$name_not_found
000635  aa  6 00232 2521 00	spri2	pr6|154
000636  aa  6 00230 3521 00	epp2 	pr6|152
000637  aa   004000 4310 07	fld  	2048,dl
000640  aa  2 00000 7571 00	staq 	pr2|0
000641  aa   000471 6700 04	tsp4 	313,ic		001332
						STATEMENT 1 ON LINE 178
	a_segno = rnte.segno;

000642  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
000643  aa  7 00002 2351 00	lda  	pr7|2		rnte.segno
000644  aa   000066 7330 00	lrs  	54
000645  aa  6 00152 7561 20	stq  	pr6|106,*		a_segno
						STATEMENT 1 ON LINE 179
	rnt.get_segno.wins = rnt.get_segno.wins + 1;

000646  aa  6 00142 3715 20	epp5 	pr6|98,*		rntp
000647  aa  5 00003 2351 00	lda  	pr5|3		rnt.wins
000650  aa   000022 7350 00	als  	18
000651  aa   000066 7330 00	lrs  	54
000652  aa   000001 0760 07	adq  	1,dl
000653  aa  5 00003 5521 14	stbq 	pr5|3,14		rnt.wins
						STATEMENT 1 ON LINE 180
	return;

000654  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_refname                                        STATEMENT 1 ON LINE 183
get_refname:
	entry (a_segno, a_namecnt, a_rname, a_code);

000655  at     000004000006
000656  tt     000006000007
000657  ta     000005000000
000660  ta     000655000000
000661  da     000167300000
000662  aa   000320 6270 00	eax7 	208
000663  aa  7 00034 3521 20	epp2 	pr7|28,*
000664  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000665  aa     000010000000
000666  aa     000000000000
000667  aa  6 00032 3735 20	epp7 	pr6|26,*
000670  aa  7 00002 3715 20	epp5 	pr7|2,*
000671  aa  6 00152 6515 00	spri5	pr6|106
000672  aa  7 00006 3535 20	epp3 	pr7|6,*
000673  aa  6 00150 2535 00	spri3	pr6|104
000674  aa  7 00010 3515 20	epp1 	pr7|8,*
000675  aa  6 00154 2515 00	spri1	pr6|108
						STATEMENT 1 ON LINE 185
	call setup ("01"b);

000676  aa   200000 2350 03	lda  	65536,du
000677  aa  6 00227 7551 00	sta  	pr6|151
000700  aa   000450 3520 04	epp2 	296,ic		001350 = 000002000000
000701  aa   000330 6700 04	tsp4 	216,ic		001231
						STATEMENT 1 ON LINE 186
	rnt.get_refnames.trys = rnt.get_refnames.trys + 1;

000702  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
000703  aa  7 00004 2351 00	lda  	pr7|4		rnt.trys
000704  aa   000066 7330 00	lrs  	54
000705  aa   000001 0760 07	adq  	1,dl
000706  aa   000066 7370 00	lls  	54
000707  aa  7 00004 5511 60	stba 	pr7|4,60		rnt.trys
						STATEMENT 1 ON LINE 187
	call search_segno ();

000710  aa   000175 6700 04	tsp4 	125,ic		001105
						STATEMENT 1 ON LINE 188
	do cnt = 1 by 1 while (rntep ^= null ());

000711  aa   000001 2360 07	ldq  	1,dl
000712  aa  6 00101 7561 00	stq  	pr6|65		cnt
000713  aa   000000 0110 03	nop  	0,du
000714  aa  6 00144 2371 00	ldaq 	pr6|100		rntep
000715  aa   777073 6770 04	eraq 	-453,ic		000010 = 077777000043 000001000000
000716  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000717  aa   000034 6000 04	tze  	28,ic		000753
						STATEMENT 1 ON LINE 189
	     if cnt = a_namecnt
	     then do;

000720  aa  6 00101 2361 00	ldq  	pr6|65		cnt
000721  aa  6 00032 3735 20	epp7 	pr6|26,*
000722  aa  7 00004 1161 20	cmpq 	pr7|4,*		a_namecnt
000723  aa   000025 6010 04	tnz  	21,ic		000750
						STATEMENT 1 ON LINE 191
                    a_rname = rnte.name;

000724  aa  6 00144 3715 20	epp5 	pr6|100,*		rntep
000725  aa  5 00002 7271 00	lxl7 	pr5|2		rnte.length
000726  aa   000000 6360 17	eaq  	0,7
000727  aa   000022 7320 00	qrs  	18
000730  aa   000040 1160 07	cmpq 	32,dl
000731  aa   000002 6040 04	tmi  	2,ic		000733
000732  aa   000040 2360 07	ldq  	32,dl
000733  aa  6 00150 3535 20	epp3 	pr6|104,*
000734  aa  3 77777 7561 00	stq  	pr3|-1		a_rname
000735  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000736  aa  5 00003 00 0006	desc9a	pr5|3,ql		rnte.name
000737  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_rname
						STATEMENT 1 ON LINE 192
                    a_code = 0;

000740  aa  6 00154 4501 20	stz  	pr6|108,*		a_code
						STATEMENT 1 ON LINE 193
                    rnt.get_refnames.wins = rnt.get_refnames.wins + 1;

000741  aa  6 00142 3515 20	epp1 	pr6|98,*		rntp
000742  aa  1 00004 2351 00	lda  	pr1|4		rnt.wins
000743  aa   000022 7350 00	als  	18
000744  aa   000066 7330 00	lrs  	54
000745  aa   000001 0760 07	adq  	1,dl
000746  aa  1 00004 5521 14	stbq 	pr1|4,14		rnt.wins
						STATEMENT 1 ON LINE 194
                    return;

000747  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 195
	     end;

						STATEMENT 1 ON LINE 196
	     call quick_next ();

000750  aa   000146 6700 04	tsp4 	102,ic		001116
						STATEMENT 1 ON LINE 197
	end;

000751  aa  6 00101 0541 00	aos  	pr6|65		cnt
000752  aa   777742 7100 04	tra  	-30,ic		000714
						STATEMENT 1 ON LINE 198
	a_code = error_table_$refname_count_too_big;

000753  aa  6 00044 3701 20	epp4 	pr6|36,*
000754  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$refname_count_too_big
000755  aa  6 00154 7561 20	stq  	pr6|108,*		a_code
						STATEMENT 1 ON LINE 199
	return;

000756  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO get_count                                          STATEMENT 1 ON LINE 202
get_count:
	entry (a_segno, a_count, a_code);

000757  at     000003000006
000760  tt     000006000005
000761  ta     000757000000
000762  da     000175300000
000763  aa   000320 6270 00	eax7 	208
000764  aa  7 00034 3521 20	epp2 	pr7|28,*
000765  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000766  aa     000006000000
000767  aa     000000000000
000770  aa  6 00032 3735 20	epp7 	pr6|26,*
000771  aa  7 00002 3715 20	epp5 	pr7|2,*
000772  aa  6 00152 6515 00	spri5	pr6|106
000773  aa  7 00006 3535 20	epp3 	pr7|6,*
000774  aa  6 00154 2535 00	spri3	pr6|108
						STATEMENT 1 ON LINE 204
	call setup ("01"b);

000775  aa   200000 2350 03	lda  	65536,du
000776  aa  6 00227 7551 00	sta  	pr6|151
000777  aa   000351 3520 04	epp2 	233,ic		001350 = 000002000000
001000  aa   000231 6700 04	tsp4 	153,ic		001231
						STATEMENT 1 ON LINE 205
	a_count = 0;

001001  aa  6 00032 3735 20	epp7 	pr6|26,*
001002  aa  7 00004 4501 20	stz  	pr7|4,*		a_count
						STATEMENT 1 ON LINE 206
	call search_segno ();

001003  aa   000102 6700 04	tsp4 	66,ic		001105
						STATEMENT 1 ON LINE 207
	do while (rntep ^= null ());

001004  aa  6 00144 2371 00	ldaq 	pr6|100		rntep
001005  aa   777003 6770 04	eraq 	-509,ic		000010 = 077777000043 000001000000
001006  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001007  aa   000005 6000 04	tze  	5,ic		001014
						STATEMENT 1 ON LINE 208
	     a_count = a_count + 1;

001010  aa  6 00032 3735 20	epp7 	pr6|26,*
001011  aa  7 00004 0541 20	aos  	pr7|4,*		a_count
						STATEMENT 1 ON LINE 209
	     call quick_next ();

001012  aa   000104 6700 04	tsp4 	68,ic		001116
						STATEMENT 1 ON LINE 210
	end;

001013  aa   777771 7100 04	tra  	-7,ic		001004
						STATEMENT 1 ON LINE 211
	return;

001014  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 294
non_local_return:
	return;

001015  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 306
     end ref_name_;

BEGIN PROCEDURE search_name
ENTRY TO search_name                                        STATEMENT 1 ON LINE 214
search_name:
	proc () returns (bit (1));

001016  aa  6 00156 6501 00	spri4	pr6|110
001017  aa  6 00160 2521 00	spri2	pr6|112
						STATEMENT 1 ON LINE 216
	     steps = 0;

001020  aa  6 00140 4501 00	stz  	pr6|96		steps
						STATEMENT 1 ON LINE 217
	     last_np, rntep = name_header ();

001021  aa   000323 3520 04	epp2 	211,ic		001344 = 000002000000
001022  aa   000151 6700 04	tsp4 	105,ic		001173
001023  aa  6 00260 3735 20	epp7 	pr6|176,*
001024  aa  6 00120 6535 00	spri7	pr6|80		last_np
001025  aa  6 00144 6535 00	spri7	pr6|100		rntep
						STATEMENT 1 ON LINE 218
	     do while (rnte.name_fp ^= null ());

001026  aa  6 00144 2361 20	ldq  	pr6|100,*		rnte.name_fp
001027  aa   000335 1160 04	cmpq 	221,ic		001364 = 777777777777
001030  aa   000045 6000 04	tze  	37,ic		001075
						STATEMENT 1 ON LINE 219
		steps = steps + 1;

001031  aa  6 00140 0541 00	aos  	pr6|96		steps
						STATEMENT 1 ON LINE 220
		if steps > max_steps then call abort (error_table_$inconsistent_rnt);

001032  aa  6 00140 2361 00	ldq  	pr6|96		steps
001033  aa   001750 1160 07	cmpq 	1000,dl
001034  aa   000010 6044 04	tmoz 	8,ic		001044
001035  aa  6 00044 3701 20	epp4 	pr6|36,*
001036  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$inconsistent_rnt
001037  aa  6 00264 2521 00	spri2	pr6|180
001040  aa  6 00262 3521 00	epp2 	pr6|178
001041  aa   004000 4310 07	fld  	2048,dl
001042  aa  2 00000 7571 00	staq 	pr2|0
001043  aa   000267 6700 04	tsp4 	183,ic		001332
						STATEMENT 1 ON LINE 221
		last_np = rntep;

001044  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
001045  aa  6 00120 6535 00	spri7	pr6|80		last_np
						STATEMENT 1 ON LINE 222
		rntep = rnte.name_fp;

001046  aa  7 00000 2361 00	ldq  	pr7|0		rnte.name_fp
001047  aa  6 00142 3715 20	epp5 	pr6|98,*		rnt.areap
001050  aa  5 00000 3521 20	epp2 	pr5|0,*		based_rnt_area
001051  aa  0 01167 7001 00	tsx0 	pr0|631		pointer_hard
001052  aa  6 00144 7571 00	staq 	pr6|100		rntep
						STATEMENT 1 ON LINE 223
		if length (rname) = rnte.length
		then if rnte.name = rname
		     then return ("1"b);

001053  aa  2 00002 2351 00	lda  	pr2|2		rnte.length
001054  aa   000022 7350 00	als  	18
001055  aa   000066 7330 00	lrs  	54
001056  aa  6 00102 1161 00	cmpq 	pr6|66		rname
001057  aa   777747 6010 04	tnz  	-25,ic		001026
001060  aa   000000 6270 06	eax7 	0,ql
001061  aa  6 00102 7261 00	lxl6 	pr6|66		rname
001062  aa  040 140 106 540	cmpc 	(pr,rl),(pr,rl),fill(040)
001063  aa  2 00003 00 0017	desc9a	pr2|3,x7		rnte.name
001064  aa  6 00103 00 0016	desc9a	pr6|67,x6		rname
001065  aa   777741 6010 04	tnz  	-31,ic		001026
001066  aa  6 00160 3735 20	epp7 	pr6|112,*
001067  aa  7 00002 3535 20	epp3 	pr7|2,*
001070  aa  403 100 060 400	csl  	(),(pr),fill(1),bool(move)
001071  aa   000000 00 0000	descb	0,0
001072  aa  3 00000 00 0001	descb	pr3|0,1
001073  aa  6 00156 6101 00	rtcd 	pr6|110
						STATEMENT 1 ON LINE 226
	     end;

001074  aa   777732 7100 04	tra  	-38,ic		001026
						STATEMENT 1 ON LINE 227
	     last_np = rntep;

001075  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
001076  aa  6 00120 6535 00	spri7	pr6|80		last_np
						STATEMENT 1 ON LINE 228
	     return ("0"b);

001077  aa  6 00160 3715 20	epp5 	pr6|112,*
001100  aa  5 00002 3535 20	epp3 	pr5|2,*
001101  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001102  aa   000000 00 0000	descb	0,0
001103  aa  3 00000 00 0001	descb	pr3|0,1
001104  aa  6 00156 6101 00	rtcd 	pr6|110
						STATEMENT 1 ON LINE 229
	end search_name;

  END PROCEDURE search_name
BEGIN PROCEDURE search_segno
ENTRY TO search_segno                                       STATEMENT 1 ON LINE 233
search_segno:
	proc ();

001105  aa  6 00164 6501 00	spri4	pr6|116
						STATEMENT 1 ON LINE 235
	     last_sp, rntep = addrel (segno_header (), -1);

001106  aa   000232 3520 04	epp2 	154,ic		001340 = 000002000000
001107  aa   000050 6700 04	tsp4 	40,ic		001157
001110  aa  6 00270 3521 20	epp2 	pr6|184,*
001111  aa   777777 0520 03	adwp2	262143,du
001112  aa  6 00270 2521 00	spri2	pr6|184
001113  aa  6 00122 2521 00	spri2	pr6|82		last_sp
001114  aa  6 00144 2521 00	spri2	pr6|100		rntep
						STATEMENT 1 ON LINE 236
quick_next:
	     entry ();

001115  aa   000002 7100 04	tra  	2,ic		001117
ENTRY TO quick_next                                         STATEMENT 1 ON LINE 236
quick_next:
	     entry ();

001116  aa  6 00164 6501 00	spri4	pr6|116
						STATEMENT 1 ON LINE 238
	     do while (rnte.segno_fp ^= null ());

001117  aa   000000 0110 03	nop  	0,du
001120  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
001121  aa  7 00001 2361 00	ldq  	pr7|1		rnte.segno_fp
001122  aa   000242 1160 04	cmpq 	162,ic		001364 = 777777777777
001123  aa   000031 6000 04	tze  	25,ic		001154
						STATEMENT 1 ON LINE 239
		steps = steps+1;

001124  aa  6 00140 0541 00	aos  	pr6|96		steps
						STATEMENT 1 ON LINE 240
		if steps > max_steps then call abort (error_table_$inconsistent_rnt);

001125  aa  6 00140 2361 00	ldq  	pr6|96		steps
001126  aa   001750 1160 07	cmpq 	1000,dl
001127  aa   000010 6044 04	tmoz 	8,ic		001137
001130  aa  6 00044 3701 20	epp4 	pr6|36,*
001131  la  4 00024 3521 20	epp2 	pr4|20,*		error_table_$inconsistent_rnt
001132  aa  6 00274 2521 00	spri2	pr6|188
001133  aa  6 00272 3521 00	epp2 	pr6|186
001134  aa   004000 4310 07	fld  	2048,dl
001135  aa  2 00000 7571 00	staq 	pr2|0
001136  aa   000174 6700 04	tsp4 	124,ic		001332
						STATEMENT 1 ON LINE 241
		last_sp = rntep;

001137  aa  6 00144 3735 20	epp7 	pr6|100,*		rntep
001140  aa  6 00122 6535 00	spri7	pr6|82		last_sp
						STATEMENT 1 ON LINE 242
		rntep = rnte.segno_fp;

001141  aa  7 00001 2361 00	ldq  	pr7|1		rnte.segno_fp
001142  aa  6 00142 3715 20	epp5 	pr6|98,*		rnt.areap
001143  aa  5 00000 3521 20	epp2 	pr5|0,*		based_rnt_area
001144  aa  0 01167 7001 00	tsx0 	pr0|631		pointer_hard
001145  aa  6 00144 7571 00	staq 	pr6|100		rntep
						STATEMENT 1 ON LINE 243
		if segno = rnte.segno
		then return;

001146  aa  2 00002 2351 00	lda  	pr2|2		rnte.segno
001147  aa   000066 7330 00	lrs  	54
001150  aa  6 00100 1161 00	cmpq 	pr6|64		segno
001151  aa   777747 6010 04	tnz  	-25,ic		001120
001152  aa  6 00164 6101 00	rtcd 	pr6|116
						STATEMENT 1 ON LINE 245
	     end;

001153  aa   777745 7100 04	tra  	-27,ic		001120
						STATEMENT 1 ON LINE 246
	     rntep = null ();

001154  aa   776634 2370 04	ldaq 	-612,ic		000010 = 077777000043 000001000000
001155  aa  6 00144 7571 00	staq 	pr6|100		rntep
						STATEMENT 1 ON LINE 247
	     return;

001156  aa  6 00164 6101 00	rtcd 	pr6|116
						STATEMENT 1 ON LINE 248
	end search_segno;

  END PROCEDURE search_segno
BEGIN PROCEDURE segno_header
ENTRY TO segno_header                                       STATEMENT 1 ON LINE 250
segno_header: proc () returns (ptr);

001157  aa  6 00172 6501 00	spri4	pr6|122
001160  aa  6 00174 2521 00	spri2	pr6|124
						STATEMENT 1 ON LINE 251
	     return (addr (rnt.segno_hash_table (mod (segno, dimension (rnt.segno_hash_table, 1) -1))));

001161  aa   000177 2360 07	ldq  	127,dl
001162  aa  6 00300 7561 00	stq  	pr6|192
001163  aa  6 00100 2361 00	ldq  	pr6|64		segno
001164  aa  6 00300 3521 00	epp2 	pr6|192
001165  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001166  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
001167  aa  7 00212 3735 06	epp7 	pr7|138,ql	rnt.segno_hash_table
001170  aa  6 00174 3715 20	epp5 	pr6|124,*
001171  aa  5 00002 6535 20	spri7	pr5|2,*
001172  aa  6 00172 6101 00	rtcd 	pr6|122
						STATEMENT 1 ON LINE 252
	end segno_header;

  END PROCEDURE segno_header
BEGIN PROCEDURE name_header
ENTRY TO name_header                                        STATEMENT 1 ON LINE 254
name_header: proc () returns (ptr);

001173  aa  6 00200 6501 00	spri4	pr6|128
001174  aa  6 00202 2521 00	spri2	pr6|130
						STATEMENT 1 ON LINE 257
	     substr (chars, 1, 2) = rname;

001175  aa  6 00102 7271 00	lxl7 	pr6|66		rname
001176  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
001177  aa  6 00103 00 0017	desc9a	pr6|67,x7		rname
001200  aa  6 00206 00 0002	desc9a	pr6|134,2		chars
						STATEMENT 1 ON LINE 258
	     substr (chars, 3, 2) = substr (rname, max (length (rname)-1, 1), min (length (rname), 2));

001201  aa  6 00102 2361 00	ldq  	pr6|66		rname
001202  aa   000002 1160 07	cmpq 	2,dl
001203  aa   000002 6040 04	tmi  	2,ic		001205
001204  aa   000002 2360 07	ldq  	2,dl
001205  aa  6 00301 7561 00	stq  	pr6|193
001206  aa  6 00102 2361 00	ldq  	pr6|66		rname
001207  aa   000001 1760 07	sbq  	1,dl
001210  aa   000001 1160 07	cmpq 	1,dl
001211  aa   000002 6050 04	tpl  	2,ic		001213
001212  aa   000001 2360 07	ldq  	1,dl
001213  aa  6 00301 2351 00	lda  	pr6|193
001214  aa  040 100 100 546	mlr  	(pr,rl,ql),(pr),fill(040)
001215  aa  6 00102 60 0005	desc9a	pr6|66(3),al	rname
001216  aa  6 00206 40 0002	desc9a	pr6|134(2),2	chars
						STATEMENT 1 ON LINE 259
	     return (addr (rnt.name_hash_table (mod (bits, dimension (rnt.name_hash_table, 1) -1))));

001217  aa   000177 2360 07	ldq  	127,dl
001220  aa  6 00301 7561 00	stq  	pr6|193
001221  aa  6 00206 2361 00	ldq  	pr6|134		bits
001222  aa  6 00301 3521 00	epp2 	pr6|193
001223  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
001224  aa  6 00142 3735 20	epp7 	pr6|98,*		rntp
001225  aa  7 00012 3735 06	epp7 	pr7|10,ql		rnt.name_hash_table
001226  aa  6 00202 3715 20	epp5 	pr6|130,*
001227  aa  5 00002 6535 20	spri7	pr5|2,*
001230  aa  6 00200 6101 00	rtcd 	pr6|128
						STATEMENT 1 ON LINE 260
	end name_header;

  END PROCEDURE name_header
BEGIN PROCEDURE setup
ENTRY TO setup                                              STATEMENT 1 ON LINE 262
setup:	proc (given_string);

001231  aa  6 00210 6501 00	spri4	pr6|136
001232  aa  6 00212 2521 00	spri2	pr6|138
						STATEMENT 1 ON LINE 269
     string (given) = given_string;

001233  aa  2 00002 2351 20	lda  	pr2|2,*		given_string
001234  aa  0 00004 3771 00	anaq 	pr0|4		= 600000000000 000000000000
001235  aa  6 00216 7551 00	sta  	pr6|142
						STATEMENT 1 ON LINE 271
	     a_code = 0;

001236  aa  6 00154 4501 20	stz  	pr6|108,*		a_code
						STATEMENT 1 ON LINE 272
	     steps = 0;

001237  aa  6 00140 4501 00	stz  	pr6|96		steps
						STATEMENT 1 ON LINE 273
	     if given.name
	     then rname = rtrim (a_rname);

001240  aa  6 00216 2351 00	lda  	pr6|142		given.name
001241  aa   400000 3150 03	cana 	131072,du
001242  aa   000023 6000 04	tze  	19,ic		001265
001243  aa  6 00150 3735 20	epp7 	pr6|104,*
001244  aa  7 77777 7271 00	lxl7 	pr7|-1		a_rname
001245  aa  000 000 165 540	tctr 	(pr,rl)
001246  aa  7 00000 00 0017	desc9a	pr7|0,x7		a_rname
001247  aa  0 76605 0001 00	arg  	pr0|-635		= 777777777777
001250  aa  6 00056 0001 00	arg  	pr6|46
001251  aa  6 00056 2361 00	ldq  	pr6|46
001252  aa  0 00242 3761 00	anq  	pr0|162		= 000777777777
001253  aa  6 00302 7561 00	stq  	pr6|194
001254  aa  7 77777 2361 00	ldq  	pr7|-1		a_rname
001255  aa  6 00302 1761 00	sbq  	pr6|194
001256  aa   000040 1160 07	cmpq 	32,dl
001257  aa   000002 6040 04	tmi  	2,ic		001261
001260  aa   000040 2360 07	ldq  	32,dl
001261  aa  6 00102 7561 00	stq  	pr6|66		rname
001262  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001263  aa  7 00000 00 0006	desc9a	pr7|0,ql		a_rname
001264  aa  6 00103 00 0006	desc9a	pr6|67,ql		rname
						STATEMENT 1 ON LINE 276
	     if given.seg_no
	     then do;

001265  aa  6 00216 2351 00	lda  	pr6|142		given.seg_no
001266  aa   200000 3150 03	cana 	65536,du
001267  aa   000013 6000 04	tze  	11,ic		001302
						STATEMENT 1 ON LINE 278
		segno = a_segno;

001270  aa  6 00152 2361 20	ldq  	pr6|106,*		a_segno
001271  aa  6 00100 7561 00	stq  	pr6|64		segno
						STATEMENT 1 ON LINE 279
		if segno < 0 then call abort (error_table_$argerr);

001272  aa   000010 6050 04	tpl  	8,ic		001302
001273  aa  6 00044 3701 20	epp4 	pr6|36,*
001274  la  4 00020 3521 20	epp2 	pr4|16,*		error_table_$argerr
001275  aa  6 00306 2521 00	spri2	pr6|198
001276  aa  6 00304 3521 00	epp2 	pr6|196
001277  aa   004000 4310 07	fld  	2048,dl
001300  aa  2 00000 7571 00	staq 	pr2|0
001301  aa   000031 6700 04	tsp4 	25,ic		001332
						STATEMENT 1 ON LINE 280
	     end;

						STATEMENT 1 ON LINE 281
	     ring = level$get ();

001302  aa  6 00124 3521 00	epp2 	pr6|84		ring
001303  aa  6 00306 2521 00	spri2	pr6|198
001304  aa  6 00304 6211 00	eax1 	pr6|196
001305  aa   004000 4310 07	fld  	2048,dl
001306  aa  6 00044 3701 20	epp4 	pr6|36,*
001307  la  4 00032 3521 20	epp2 	pr4|26,*		level$get
001310  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 282
	     if ring = 0 then call abort (error_table_$r0_refname);

001311  aa  6 00124 2361 00	ldq  	pr6|84		ring
001312  aa   000010 6010 04	tnz  	8,ic		001322
001313  aa  6 00044 3701 20	epp4 	pr6|36,*
001314  la  4 00026 3521 20	epp2 	pr4|22,*		error_table_$r0_refname
001315  aa  6 00306 2521 00	spri2	pr6|198
001316  aa  6 00304 3521 00	epp2 	pr6|196
001317  aa   004000 4310 07	fld  	2048,dl
001320  aa  2 00000 7571 00	staq 	pr2|0
001321  aa   000011 6700 04	tsp4 	9,ic		001332
						STATEMENT 1 ON LINE 283
	     rntp = pds$stacks (ring) -> stack_header.rnt_ptr;

001322  aa  6 00124 2361 00	ldq  	pr6|84		ring
001323  aa   000001 7360 00	qls  	1
001324  aa  6 00044 3701 20	epp4 	pr6|36,*
001325  la  4 00030 3735 66	epp7 	pr4|24,*ql	pds$stacks
001326  aa  7 00000 3735 20	epp7 	pr7|0,*		pds$stacks
001327  aa  7 00062 3735 20	epp7 	pr7|50,*		stack_header.rnt_ptr
001330  aa  6 00142 6535 00	spri7	pr6|98		rntp
						STATEMENT 1 ON LINE 284
	     return;

001331  aa  6 00210 6101 00	rtcd 	pr6|136
						STATEMENT 1 ON LINE 285
	end setup;

  END PROCEDURE setup
BEGIN PROCEDURE abort
ENTRY TO abort                                              STATEMENT 1 ON LINE 287
abort:
	proc (code);

001332  aa  6 00220 6501 00	spri4	pr6|144
001333  aa  6 00222 2521 00	spri2	pr6|146
						STATEMENT 1 ON LINE 290
	     a_code = code;

001334  aa  2 00002 2361 20	ldq  	pr2|2,*		code
001335  aa  6 00154 7561 20	stq  	pr6|108,*		a_code
						STATEMENT 1 ON LINE 291
	     go to non_local_return;

001336  aa   777457 7100 04	tra  	-209,ic		001015
						STATEMENT 1 ON LINE 292
	end abort;

  END PROCEDURE abort
  END PROCEDURE ref_name_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
