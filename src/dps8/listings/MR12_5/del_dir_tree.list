	COMPILATION LISTING OF SEGMENT del_dir_tree
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1047.5 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 del_dir_tree: proc (a_dirname, a_ename, a_code);
       15 
       16 /*
       17*   Del_dir_tree is used to delete all branches, whether directory or
       18*   not with respect to some node. If the sub tree with respect to that
       19*   node has directories in it then the branches they contain must be deleted befor
       20*   the directory can be. Care is taken to protect against another user appending
       21*   a new branch while deletion is being done by always recycling over the
       22*   whole directory when we return from a lower node.
       23*
       24*   The basic operation of the program is to perform its own star_ list as it 
       25*   goes, calling delentry to delete each object.  It keeps rescanning the dir
       26*   (actually just looking at the first object which it then deletes) until the
       27*   dir is empty.
       28*
       29*   USAGE:	call del_dir_tree(parent_path_name, entry_dir_name, error_code);
       30*
       31*
       32*   1. parent_path_name char(*)		path name of the directory whose sub tree structure
       33*   is to be deleted.
       34*   2. entry_dir_name char(*)		entry name of the directory whose sub tree structure
       35*   is to be deleted.
       36*   3. error_code fixed bin(35)		file system error code (Output).
       37*
       38*
       39*   NOTES:	1. User must have status (to perform the star_ list we simulate
       40*      here) and modify (for later deltion) modes on directory structure.
       41*   2. The directory entry_dir_name is not deleted.
       42*
       43*   */
       44 
       45 /* Modified 2/85 by Keith Loepere to look for new error codes. */
       46 /* Modified 12/84 by Keith Loepere for relocking strategy. */
       47 /* Modified 6/84 by Keith Loepere to use the new dc_find. */
       48 /* Modified 1/80 by Mike Grady to fix bad error handling code in main loop */
       49 /* Modified 4/77 by M. Weaver to call makeknown_ instead of makeknown */
       50 /* Modified 11/76 by D.Vinograd to add entry retv for use by volume reloader */
       51 /* Modified June 1, 1976 by R. Bratt to call find_$finished when done with ep */
       52 /* Modified 760309 by L. Scheffler to use info-only entries in dire_control_error */
       53 /* Modified July 74 by Kobziar to call new entry in access_mode */
       54 /* Modified by E Stone to delete directories in the subtree without SM access 5/74 */
       55 
       56 /* Parameters */
       57 
       58 dcl  a_code			fixed bin (35) parameter;
       59 dcl  a_dirname			char (*) parameter;
       60 dcl  a_ename			char (*) parameter;
       61 dcl  a_retv			bit (1) parameter;
       62 
       63 /* External */
       64 
       65 dcl  error_table_$argerr		fixed bin (35) ext;
       66 dcl  error_table_$copy_sw_on		fixed bin (35) ext;
       67 dcl  error_table_$fulldir		fixed bin (35) ext;
       68 dcl  error_table_$incorrect_access	fixed bin (35) ext;
       69 dcl  error_table_$moderr		fixed bin (35) ext;
       70 dcl  error_table_$mylock		fixed bin (35) ext;
       71 dcl  error_table_$root		fixed bin (35) ext;
       72 dcl  error_table_$safety_sw_on	fixed bin (35) ext;
       73 dcl  error_table_$vtoce_connection_fail ext fixed bin (35);
       74 dcl  pds$process_group_id		char (32) aligned ext;
       75 
       76 /* Entries */
       77 
       78 dcl  asd_$add_dentries		entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       79 dcl  delentry$dfile			entry (char (*), char (*), fixed bin (35));
       80 dcl  delentry$retv			entry (char (*), char (*), fixed bin (35));
       81 dcl  lock$dir_unlock		external entry (pointer);
       82 dcl  set$copysw			entry (char (*), char (*), fixed bin (1), fixed bin (35));
       83 dcl  set$safety_sw_path		entry (char (*), char (*), bit (1) aligned, fixed bin (35));
       84 dcl  sum$getbranch_root_my		entry (ptr, bit (36) aligned, ptr, fixed bin (35));
       85 
       86 /* Misc */
       87 
       88 dcl  (addr, length, ptr, rel, rtrim)	builtin;
       89 
       90 dcl  bad_dir_			condition;
       91 dcl  seg_fault_error		condition;
       92 
       93 /* Variables */
       94 
       95 dcl  code				fixed bin (35);
       96 dcl  1 dir_acl			aligned,
       97        2 access_name		char (32),
       98        2 mode			bit (36),
       99        2 status_code		fixed bin (35);
      100 dcl  dirl				bit (1) aligned;
      101 dcl  dirname			char (168);
      102 dcl  ename			char (32);
      103 dcl  entries_in_dir			fixed bin;
      104 dcl  entries_seen			fixed bin;
      105 dcl  name				char (32);
      106 dcl  nnp				ptr;
      107 dcl  pname			char (168);
      108 dcl  rep				bit (18) aligned;
      109 dcl  retv				bit (1) init ("0"b);
      110 
      111 	goto join;
      112 
      113 retv: entry (a_dirname, a_ename, a_code);
      114 
      115 	retv = "1"b;
      116 	goto join;
      117 
      118 
      119 recurse: entry (a_dirname, a_ename, a_retv, a_code);
      120 
      121 	retv = a_retv;
      122 join:
      123 	dirl = "0"b;
      124 	code = 0;					/* clear status code */
      125 	dirname = a_dirname;			/* copy arguments */
      126 	ename = a_ename;
      127 
      128 	if dirname = ">" then pname = ">" || ename;
      129 	else if ename = "" then pname = dirname;
      130 	else if length (rtrim (dirname)) + 1 + length (rtrim (ename)) > length (pname) then do;
      131 	     code = error_table_$argerr;
      132 	     go to finale;
      133 	end;
      134 	else pname = rtrim (dirname) || ">" || ename;
      135 
      136 	if retv then call dc_find$dir_read_priv (pname, dp, code);
      137 	else call dc_find$dir_read (pname, dp, code);	/* get a pointer to dir, check for s (those requiring m check it itself) */
      138 	if code ^= 0 then go to finale;
      139 	dirl = "1"b;
      140 
      141 	if ^retv then do;				/* safety switch of directory must be off */
      142 	     call sum$getbranch_root_my (dp, "0"b, ep, code);
      143 	     if code = 0 then do;
      144 		if entry.safety_sw then code = error_table_$safety_sw_on;
      145 		call lock$dir_unlock (ptr (ep, 0));
      146 	     end;
      147 	     else if code = error_table_$mylock then
      148 		if entry.safety_sw then code = error_table_$safety_sw_on;
      149 		else code = 0;
      150 	     else if code = error_table_$root then code = 0;
      151 	     if code ^= 0 then go to finale;
      152 	end;
      153 
      154 	on seg_fault_error begin;
      155 		code = error_table_$vtoce_connection_fail;
      156 		goto finale;
      157 	     end;
      158 
      159 rescan_dir:
      160 	entries_in_dir = dp -> dir.seg_count + dp -> dir.dir_count + dp -> dir.lcount;
      161 	entries_seen = 0;
      162 	do rep = dp -> dir.entryfrp repeat entry.efrp while (rep);
      163 	     ep = ptr (dp, rep);			/* pick up pointer to entry */
      164 	     entries_seen = entries_seen + 1;
      165 	     if entries_seen > entries_in_dir then signal bad_dir_;
      166 	     if entry.uid = ""b then go to end_loop;
      167 	     if entry.bs then
      168 		if (entry.owner ^= dp -> dir.uid)
      169 		     | (entry.type ^= SEG_TYPE & entry.type ^= DIR_TYPE) then signal bad_dir_;
      170 		else ;
      171 	     else if (link.owner ^= dp -> dir.uid)
      172 		     | (link.type ^= LINK_TYPE) then signal bad_dir_;
      173 	     nnp = ptr (ep, entry.name_frp);
      174 	     if nnp -> names.type ^= NAME_TYPE
      175 		| nnp -> names.owner ^= entry.uid
      176 		| nnp -> names.entry_rp ^= rel (ep) then signal bad_dir_;
      177 	     name = nnp -> names.name;		/* get primary name of entry */
      178 	     if name = "" then signal bad_dir_;
      179 	     call dc_find$finished (dp, dirl);		/* unlock directory (delentry requires it) */
      180 	     dirl = "0"b;
      181 delent:	     if retv then call delentry$retv (pname, name, code);
      182 	     else call delentry$dfile (pname, name, code);/* try to delete this entry */
      183 
      184 	     if code = 0 then do;
      185 		if retv then call dc_find$dir_read_priv (pname, dp, code);
      186 		else call dc_find$dir_read (pname, dp, code);	/* get a pointer to dir, check for s (those requiring m check it itself) */
      187 		if code ^= 0 then go to finale;
      188 		dirl = "1"b;
      189 		go to rescan_dir;
      190 	     end;
      191 
      192 	     if code = error_table_$safety_sw_on & ^retv then do; /* turn safety switch off */
      193 		call set$safety_sw_path (pname, name, "0"b, code);
      194 		if code = 0 then go to delent;
      195 		else go to finale;			/* we can't continue */
      196 	     end;
      197 
      198 	     else if code = error_table_$copy_sw_on & ^retv then do; /* turn copy switch off */
      199 		call set$copysw (pname, name, 0, code);
      200 		if code = 0 then go to delent;
      201 		else go to finale;
      202 	     end;
      203 
      204 	     else if code = error_table_$fulldir then do; /* directory has entries */
      205 again:		call recurse (pname, name, retv, code); /* delete all entries in this dir */
      206 		if code = 0 then goto delent;
      207 		else if code = error_table_$incorrect_access | code = error_table_$moderr then do;
      208 						/* try to give user proper access to delete sub-tree */
      209 		     dir_acl.access_name = pds$process_group_id;
      210 		     dir_acl.mode = "111"b;
      211 		     call asd_$add_dentries (pname, name, addr (dir_acl), 1, code);
      212 		     if code = 0 then goto again;
      213 		     else goto finale;
      214 		end;
      215 		else go to finale;
      216 	     end;
      217 	     else go to finale;
      218 
      219 end_loop: end;
      220 
      221 finale:
      222 	if dirl then call dc_find$finished (dp, DC_FIND_UNLOCK_DIR);
      223 	a_code = code;
      224 	return;
      225  /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      225 
      226  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      226 
      227  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      227 
      228  /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  4     2 
  4     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  4     4 
  4     5 
  4     6 dcl 1 link based (ep) aligned,
  4     7 
  4     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  4    10 
  4    11     2 type bit (18),				/* type = dir link */
  4    12     2 size fixed bin (17),				/* size of link in words */
  4    13 
  4    14     2 uid bit (36),					/* unique id of entry */
  4    15 
  4    16     2 dtem bit (36),				/* date-time entry modified */
  4    17 
  4    18     2 bs bit (1),					/* entry switch = 1 if entry */
  4    19     2 pad0 bit (17),
  4    20     2 nnames fixed bin (17),				/* number of names for this entry */
  4    21 
  4    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    24 
  4    25     2 author,					/* user who created entry */
  4    26       3 pers_rp bit (18),				/* name of user who created entry */
  4    27       3 proj_rp bit (18),				/* project of user who created entry */
  4    28 
  4    29       3 tag char (1),				/* tag of user who created entry */
  4    30       3 pad1 char (3),
  4    31 
  4    32     2 primary_name bit (504),				/* first name on name list */
  4    33 
  4    34     2 dtd bit (36),					/* date time dumped */
  4    35 
  4    36     2 pad2 bit (36),
  4    37 
  4    38 
  4    39 /* the declarations below are only applicable to links */
  4    40 
  4    41     2 pad3 bit (18),
  4    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  4    43 
  4    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  4    45 
  4    46     2 checksum bit (36),				/* checksum from uid */
  4    47 
  4    48     2 owner bit (36);				/* uid of containing directory */
  4    49 
  4    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
      228 
      229  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  5     2 
  5     3 /* Template for names of branches or links. Length = 14 words. */
  5     4 
  5     5 dcl np ptr;
  5     6 
  5     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  5     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  5     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  5    10 
  5    11     2 type bit (18) unaligned,			/* type = dir name */
  5    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  5    13 
  5    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  5    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  5    16 
  5    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  5    18     2 pad3 bit (18) unal,
  5    19 
  5    20     2 name char(32) aligned,
  5    21 
  5    22     2 checksum bit (36),				/* checksum from entry_rp */
  5    23 
  5    24     2 owner bit (36);				/* uid of entry */
  5    25 
  5    26 
  5    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      229 
      230  /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  6     2 
  6     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  6     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  6     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  6     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  6     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  6     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  6     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  6    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  6    11 
  6    12 dcl  access_name_type fixed bin static options (constant) init (1);
  6    13 dcl  acle_type fixed bin static options (constant) init (2);
  6    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  6    15 dcl  dir_type fixed bin static options (constant) init (4);
  6    16 dcl  link_type fixed bin static options (constant) init (5);
  6    17 dcl  name_type fixed bin static options (constant) init (6);
  6    18 dcl  seg_type fixed bin static options (constant) init (7);
  6    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  6    20 
  6    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
      230 
      231      end del_dir_tree;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.4  del_dir_tree.pl1                  >spec>install>1110>del_dir_tree.pl1
225          1    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
226          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
227          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
228          4    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
229          5    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
230          6    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_UNLOCK_DIR              000006 constant        bit(1)                   initial dcl 1-13 set ref 221*
DIR_TYPE                               constant        bit(18)                  initial packed unaligned dcl 6-6 ref 167
LINK_TYPE                              constant        bit(18)                  initial packed unaligned dcl 6-7 ref 171
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 6-8 ref 174
SEG_TYPE                               constant        bit(18)                  initial packed unaligned dcl 6-9 ref 167
a_code                                 parameter       fixed bin(35,0)          dcl 58 set ref 14 113 119 223*
a_dirname                              parameter       char                     packed unaligned dcl 59 ref 14 113 119 125
a_ename                                parameter       char                     packed unaligned dcl 60 ref 14 113 119 126
a_retv                                 parameter       bit(1)                   packed unaligned dcl 61 ref 119 121
access_name                     000115 automatic       char(32)                 level 2 dcl 96 set ref 209*
addr                                                   builtin function         dcl 88 ref 211 211
asd_$add_dentries               000034 constant        entry                    external dcl 78 ref 211
bad_dir_                        000100 stack reference condition                dcl 90 ref 165 167 171 174 178
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 2-8 ref 167
code                            000114 automatic       fixed bin(35,0)          dcl 95 set ref 124* 131* 136* 137* 138 142* 143 144*
                                                                                  147 147* 149* 150 150* 151 155* 181* 182* 184 185*
                                                                                  186* 187 192 193* 194 198 199* 200 204 205* 206
                                                                                  207 207 211* 212 223
dc_find$dir_read                000052 constant        entry                    external dcl 1-23 ref 137 186
dc_find$dir_read_priv           000054 constant        entry                    external dcl 1-24 ref 136 185
dc_find$finished                000056 constant        entry                    external dcl 1-33 ref 179 221
delentry$dfile                  000036 constant        entry                    external dcl 79 ref 182
delentry$retv                   000040 constant        entry                    external dcl 80 ref 181
dir                                    based           structure                level 1 dcl 3-11
dir_acl                         000115 automatic       structure                level 1 dcl 96 set ref 211 211
dir_count                22(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 159
dirl                            000127 automatic       bit(1)                   dcl 100 set ref 122* 139* 179* 180* 188* 221
dirname                         000130 automatic       char(168)                packed unaligned dcl 101 set ref 125* 128 129 130
                                                                                  134
dp                              000304 automatic       pointer                  dcl 3-9 set ref 136* 137* 142* 159 159 159 162 163
                                                                                  167 171 179* 185* 186* 221*
efrp                                   based           bit(18)                  level 2 packed packed unaligned dcl 2-8 ref 219
ename                           000202 automatic       char(32)                 packed unaligned dcl 102 set ref 126* 128 129 130
                                                                                  134
entries_in_dir                  000212 automatic       fixed bin(17,0)          dcl 103 set ref 159* 165
entries_seen                    000213 automatic       fixed bin(17,0)          dcl 104 set ref 161* 164* 164 165
entry                                  based           structure                level 1 dcl 2-8
entry_rp                  2            based           bit(18)                  level 2 packed packed unaligned dcl 5-7 ref 174
entryfrp                 16            based           bit(18)                  level 2 packed packed unaligned dcl 3-11 ref 162
ep                              000302 automatic       pointer                  dcl 2-6 set ref 142* 144 145 145 147 163* 166 167
                                                                                  167 167 167 171 171 173 173 174 174 219
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 65 ref 131
error_table_$copy_sw_on         000012 external static fixed bin(35,0)          dcl 66 ref 198
error_table_$fulldir            000014 external static fixed bin(35,0)          dcl 67 ref 204
error_table_$incorrect_access   000016 external static fixed bin(35,0)          dcl 68 ref 207
error_table_$moderr             000020 external static fixed bin(35,0)          dcl 69 ref 207
error_table_$mylock             000022 external static fixed bin(35,0)          dcl 70 ref 147
error_table_$root               000024 external static fixed bin(35,0)          dcl 71 ref 150
error_table_$safety_sw_on       000026 external static fixed bin(35,0)          dcl 72 ref 144 147 192
error_table_$vtoce_connection_fail
                                000030 external static fixed bin(35,0)          dcl 73 ref 155
lcount                   23            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 159
length                                                 builtin function         dcl 88 ref 130 130 130
link                                   based           structure                level 1 dcl 4-6
lock$dir_unlock                 000042 constant        entry                    external dcl 81 ref 145
mode                     10     000115 automatic       bit(36)                  level 2 dcl 96 set ref 210*
name                      4            based           char(32)                 level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "del_dir_tree" ref 177
name                            000214 automatic       char(32)                 packed unaligned dcl 105 in procedure "del_dir_tree"
                                                                                  set ref 177* 178 181* 182* 193* 199* 205* 211*
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 2-8 ref 173
names                                  based           structure                level 1 dcl 5-7
nnp                             000224 automatic       pointer                  dcl 106 set ref 173* 174 174 174 177
owner                    15            based           bit(36)                  level 2 in structure "names" dcl 5-7 in procedure
                                                                                  "del_dir_tree" ref 174
owner                                  based           bit(36)                  level 2 in structure "link" dcl 4-6 in procedure
                                                                                  "del_dir_tree" ref 171
owner                    44            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "del_dir_tree" ref 167
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-6 ref 171
pds$process_group_id            000032 external static char(32)                 dcl 74 ref 209
pname                           000226 automatic       char(168)                packed unaligned dcl 107 set ref 128* 129* 130 134*
                                                                                  136* 137* 181* 182* 185* 186* 193* 199* 205* 211*
ptr                                                    builtin function         dcl 88 ref 145 145 163 173
rel                                                    builtin function         dcl 88 ref 174
rep                             000300 automatic       bit(18)                  dcl 108 set ref 162* 162* 163*
retv                            000301 automatic       bit(1)                   initial packed unaligned dcl 109 set ref 109* 115*
                                                                                  121* 136 141 181 185 192 198 205*
rtrim                                                  builtin function         dcl 88 ref 130 130 134
safety_sw                32(04)        based           bit(1)                   level 2 packed packed unaligned dcl 2-8 ref 144 147
seg_count                22            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 159
seg_fault_error                 000106 stack reference condition                dcl 91 ref 154
set$copysw                      000044 constant        entry                    external dcl 82 ref 199
set$safety_sw_path              000046 constant        entry                    external dcl 83 ref 193
sum$getbranch_root_my           000050 constant        entry                    external dcl 84 ref 142
type                      1            based           bit(18)                  level 2 in structure "names" packed packed unaligned
                                                                                  dcl 5-7 in procedure "del_dir_tree" ref 174
type                      1            based           bit(18)                  level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "del_dir_tree" ref 167 167
type                      1            based           bit(18)                  level 2 in structure "link" packed packed unaligned
                                                                                  dcl 4-6 in procedure "del_dir_tree" ref 171
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "del_dir_tree" ref 166 174
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 3-11 in procedure
                                                                                  "del_dir_tree" ref 167 171

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 6-3
ACLE_TYPE                              internal static bit(18)                  initial packed unaligned dcl 6-4
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 1-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 6-5
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 6-10
access_name_type                       internal static fixed bin(17,0)          initial dcl 6-12
acle_type                              internal static fixed bin(17,0)          initial dcl 6-13
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$link_target             000000 constant        entry                    external dcl 1-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 1-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 1-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 1-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 1-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 1-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 1-51
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 1-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 1-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 1-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 1-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 1-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 1-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 1-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 1-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 1-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 1-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 1-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 1-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 1-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 1-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 1-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 1-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
dir_header_type                        internal static fixed bin(17,0)          initial dcl 6-14
dir_type                               internal static fixed bin(17,0)          initial dcl 6-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 6-19
link_type                              internal static fixed bin(17,0)          initial dcl 6-16
name_type                              internal static fixed bin(17,0)          initial dcl 6-17
np                                     automatic       pointer                  dcl 5-5
seg_type                               internal static fixed bin(17,0)          initial dcl 6-18
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
again                           001034 constant        label                    dcl 205 ref 212
del_dir_tree                    000030 constant        entry                    external dcl 14
delent                          000623 constant        label                    dcl 181 ref 194 200 206
end_loop                        001134 constant        label                    dcl 219 ref 166
finale                          001140 constant        label                    dcl 221 ref 132 138 151 156 187 195 201 204 207 213
join                            000144 constant        label                    dcl 122 ref 111 116
recurse                         000113 constant        entry                    external dcl 119 ref 205
rescan_dir                      000442 constant        label                    dcl 159 ref 189
retv                            000057 constant        entry                    external dcl 113

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1442        1522    1160        1452
Length      2042    1160        60         303     262           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
del_dir_tree                        280 external procedure  is an external procedure.  
on unit on line 154                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
del_dir_tree             000114 code                        del_dir_tree
                         000115 dir_acl                     del_dir_tree
                         000127 dirl                        del_dir_tree
                         000130 dirname                     del_dir_tree
                         000202 ename                       del_dir_tree
                         000212 entries_in_dir              del_dir_tree
                         000213 entries_seen                del_dir_tree
                         000214 name                        del_dir_tree
                         000224 nnp                         del_dir_tree
                         000226 pname                       del_dir_tree
                         000300 rep                         del_dir_tree
                         000301 retv                        del_dir_tree
                         000302 ep                          del_dir_tree
                         000304 dp                          del_dir_tree

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_in_desc    call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           signal_op           enable_op           shorten_stack       ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
asd_$add_dentries             dc_find$dir_read              dc_find$dir_read_priv         dc_find$finished
delentry$dfile                delentry$retv                 lock$dir_unlock               set$copysw
set$safety_sw_path            sum$getbranch_root_my

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$copy_sw_on       error_table_$fulldir          error_table_$incorrect_access
error_table_$moderr           error_table_$mylock           error_table_$root             error_table_$safety_sw_on
error_table_$vtoce_connection_fail                          pds$process_group_id




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    109 000021        14 000024       111 000054       113 000055       115 000103       116 000105       119 000106
    121 000137       122 000144       124 000145       125 000146       126 000154       128 000161       129 000201
    130 000212       131 000243       132 000246       134 000247       136 000273       137 000313       138 000326
    139 000330       141 000332       142 000335       143 000354       144 000356       145 000365       146 000376
    147 000377       149 000411       150 000413       151 000416       154 000420       155 000434       156 000437
    159 000442       161 000457       162 000460       163 000466       164 000471       165 000472       166 000500
    167 000503       170 000525       171 000526       173 000550       174 000556       177 000576       178 000602
    179 000611       180 000622       181 000623       182 000650       184 000671       185 000673       186 000712
    187 000725       188 000727       189 000731       192 000732       193 000743       194 000771       195 000773
    198 000774       199 001002       200 001027       201 001031       204 001032       205 001034       206 001060
    207 001062       209 001067       210 001073       211 001075       212 001131       213 001133       219 001134
    221 001140       223 001154       224 001156


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
