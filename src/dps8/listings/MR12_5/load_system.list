	COMPILATION LISTING OF SEGMENT load_system
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1019.1 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-06-05,GJohnson), approve(86-06-05,MCR7387),
       16*     audit(86-06-10,Martinson), install(86-07-11,MR12.0-1091):
       17*     Correct error message documentation.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       22 
       23 /* LOAD_SYSTEM - Load Collection 3 from Multics System Tape. */
       24 /* to v2pl1, RE Mullen, Nov 73 */
       25 /* last modified 3/76 by N. I. Morris & S. H. Webber for new reconfig */
       26 /* broken acl manipulations fixed BIM 3/82 */
       27 /* Modified October 1983 by Keith Loepere for warm boot from disk. */
       28 /* Modified January 1985 by Keith Loepere to set entry bounds on gates. */
       29 
       30 load_system: procedure;
       31 
       32 /* Variables */
       33 
       34 dcl  access			bit (3);
       35 dcl  bitcount			fixed bin (24);
       36 dcl  count			fixed bin (18);
       37 dcl  cp				ptr;
       38 dcl  1 cw				aligned,		/* Control word. */
       39      ( 2 type			fixed bin (18) uns,
       40        2 count			fixed bin (18) uns) unaligned;
       41 dcl  1 del_acl			(1) aligned like delete_acl_entry;
       42 dcl  dir_name			char (168);
       43 dcl  entry_bound			fixed bin (14);
       44 dcl  entryname			char (32);
       45 dcl  ercode			fixed bin (35);
       46 dcl  header_area			(1000) fixed bin (35);
       47 dcl  hp				ptr;
       48 dcl  lastword			ptr;
       49 dcl  mapword			fixed bin (18);
       50 dcl  must_delete_acl		bit (1) aligned;
       51 dcl  must_set_acl			bit (1) aligned;
       52 dcl  object_map_ptr			ptr;
       53 dcl  old_mode			bit (36);
       54 dcl  1 seg_acl_struc		aligned,
       55        2 version			fixed bin,
       56        2 count			fixed bin,
       57        2 seg_acl			(1) aligned like segment_acl_entry;
       58 dcl  segp				ptr;
       59 dcl  wordcount			fixed bin (18);
       60 
       61 /* Based */
       62 
       63 dcl  just_reference			fixed bin (35) based;
       64 
       65 /* Misc */
       66 
       67 dcl  (addr, addrel, bit, divide, fixed, null, size, substr)	builtin;
       68 
       69 /* External */
       70 
       71 dcl  pds$process_group_id		ext static char (32) aligned;
       72 
       73 /* Entries */
       74 
       75 dcl  asd_$add_sentries		entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       76 dcl  asd_$del_sentries		entry (char (*), char (*), ptr, fixed bin, fixed bin (35));
       77 dcl  asd_$r_list_sall		entry (char (*), char (*), ptr, ptr, fixed bin (35));
       78 dcl  disk_reader			entry (ptr, fixed bin (18));
       79 dcl  init_branches$branch		entry (ptr, ptr, ptr, bit (3), ptr);
       80 dcl  set$entry_bound_ptr		entry (ptr, fixed bin (14), fixed bin (35));
       81 dcl  syserr			entry options (variable);
       82 dcl  syserr$error_code		entry options (variable);
       83 
       84 	hp = addr (header_area);			/* Pointer to header area in stack. */
       85 	cp = addr (cw);				/* Pointer to control word. */
       86 
       87 	seg_acl_struc.version = ACL_VERSION_1;
       88 	seg_acl_struc.count = 1;
       89 	seg_acl_struc.seg_acl (1).access_name = pds$process_group_id;
       90 
       91 loop:	call disk_reader (cp, 1);			/* Read in next control word from disk. */
       92 	if cw.type = 2 then do;			/* Check for collection mark. */
       93 	     call disk_reader (cp, 1);		/* It is, get it out of the way. */
       94 	     return;				/* End of collection..quit. */
       95 	end;
       96 	if cw.type ^= 0 then call syserr (CRASH, "load_system: illegal type in mst source");
       97 	count = cw.count;				/* Copy count of header. */
       98 	if count > 1000 then call syserr (CRASH, "load_system: illegal header length in mst source");
       99 
      100 	call disk_reader (hp, count);			/* Suck in the header. */
      101 	namep = addrel (hp, size (slte));		/* Set ptr to names */
      102 	pathp = addrel (namep, namep -> segnam.count * 9 + 1); /* ptr to path name */
      103 	access = bit (hp -> slte.access, 3);		/* Set access from header, mask off P bit */
      104 	bitcount = hp -> slte_uns.bit_count;
      105 
      106 	call init_branches$branch (pathp, namep, hp, access, segp); /* Go set up branch. */
      107 
      108 	dir_name = pathp -> path.name;
      109 	entryname = namep -> segnam.names (1).name;
      110 
      111 	must_set_acl, must_delete_acl = "0"b;
      112 	old_mode = ""b;
      113 
      114 	call asd_$r_list_sall (dir_name, entryname, null (), addr (seg_acl_struc), ercode);
      115 
      116 	if ercode ^= 0 then call syserr$error_code (CRASH, ercode, "load_system: error from asd_$r_list_sall on ^a>^a.", dir_name, entryname);
      117 
      118 	if seg_acl_struc.seg_acl (1).status_code = 0 then if ^substr (seg_acl_struc.seg_acl (1).mode, 3, 1) then do; /* no w */
      119 		must_set_acl = "1"b;
      120 		must_delete_acl = "0"b;
      121 		old_mode = seg_acl_struc.seg_acl (1).mode;
      122 	     end;
      123 	     else must_set_acl, must_delete_acl = "0"b;	/* already have w */
      124 	else must_set_acl, must_delete_acl = "1"b;
      125 
      126 	if must_set_acl then do;
      127 	     seg_acl_struc.seg_acl (1).mode = RW_ACCESS;
      128 	     call asd_$add_sentries (dir_name, entryname, addr (seg_acl_struc.seg_acl), 1, ercode);
      129 	     if ercode ^= 0 then
      130 asd_error:	call syserr$error_code (CRASH, ercode, "load_system: error from asd_$add_sentries on ^a>^a.", dir_name, entryname);
      131 	end;
      132 
      133 	call disk_reader (cp, 1);			/* Get next control word for seg. */
      134 	if cw.type ^= 1 then call syserr (CRASH, "load_system: illegal type in mst source");
      135 
      136 	call disk_reader (segp, (cw.count));		/* Suck in the segment. */
      137 
      138 /* Find entry bound in object map; see if entry bound should be set. */
      139 
      140 	if bitcount = 0 then go to no_entry_bound;
      141 	wordcount = divide (bitcount + 35, 36, 18, 0);
      142 	lastword = addrel (segp, wordcount - 1);
      143 	mapword = fixed (lastword -> map_ptr, 18);	/* will want to see if value is in reasonable range */
      144 
      145 	if mapword <= 0 then go to no_entry_bound;	/* last word won't point to new format map */
      146 	if mapword >= wordcount then go to no_entry_bound;
      147 	object_map_ptr = addrel (segp, lastword -> map_ptr); /* get ptr to map */
      148 	if object_map_ptr -> object_map.identifier ^= "obj_map " then goto no_entry_bound;
      149 	if object_map_ptr -> object_map.decl_vers ^= 2 then go to no_entry_bound;
      150 
      151 	entry_bound = fixed (object_map_ptr -> object_map.entry_bound, 18);
      152 	if entry_bound > 0 then do;
      153 	     call set$entry_bound_ptr (segp, entry_bound, ercode);
      154 	     if ercode ^= 0 then
      155 		call syserr$error_code (CRASH, ercode, "load_system: error from set$entry_bound_ptr for ^a>^a.", dir_name, entryname);
      156 	end;
      157 
      158 no_entry_bound:
      159 	if must_set_acl & ^must_delete_acl then do;	/* must_restore_acl ... */
      160 	     seg_acl_struc.seg_acl (1).mode = old_mode;
      161 	     call asd_$add_sentries (dir_name, entryname, addr (seg_acl_struc.seg_acl), 1, ercode);
      162 	     if ercode ^= 0 then go to asd_error;
      163 	end;
      164 
      165 	if must_delete_acl then do;
      166 	     del_acl (1).access_name = pds$process_group_id;
      167 	     call asd_$del_sentries (dir_name, entryname, addr (del_acl), 1, ercode);
      168 	     if ercode ^= 0 then
      169 		call syserr$error_code (CRASH, ercode, "load_system: error from asd_$delete_sentries for ^a>^a.", dir_name, entryname);
      170 	end;
      171 
      172 
      173 	ercode = segp -> just_reference;		/* make it active again */
      174 	ercode = 0;
      175 	go to loop;
      176  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      176 
      177  /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  2     2 /* format: style3,indcomtxt,idind30 */
  2     3 
  2     4 declare   acl_ptr                       pointer;
  2     5 declare   acl_count                     fixed bin;
  2     6 
  2     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  2     8           2 version                     char (8) aligned,
  2     9           2 count                       fixed bin,
  2    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  2    11 
  2    12 declare 1 general_acl_entry             based,
  2    13           2 access_name                 character (32) unaligned,
  2    14           2 mode                        bit (36) aligned,
  2    15           2 status_code                 fixed bin (35);
  2    16 
  2    17 
  2    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  2    19           2 version                     char (8) aligned,
  2    20           2 count                       fixed bin,
  2    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  2    22 
  2    23 declare 1 general_extended_acl_entry    aligned based,
  2    24           2 access_name                 character (32) unaligned,
  2    25           2 mode                        bit (36) aligned,
  2    26           2 extended_mode               bit (36) aligned,
  2    27           2 status_code                 fixed bin (35);
  2    28 
  2    29 
  2    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  2    31           2 version                     char (8) aligned,
  2    32           2 count                       fixed bin,
  2    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  2    34 
  2    35 declare 1 general_delete_acl_entry      aligned based,
  2    36           2 access_name                 character (32) unaligned,
  2    37           2 status_code                 fixed bin (35);
  2    38 
  2    39 
  2    40 declare 1 segment_acl                   aligned based (acl_ptr),
  2    41           2 version                     fixed bin,
  2    42           2 count                       fixed bin,
  2    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  2    44 
  2    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  2    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  2    47 
  2    48 
  2    49 declare 1 directory_acl                 aligned based (acl_ptr),
  2    50           2 version                     fixed bin,
  2    51           2 count                       fixed bin,
  2    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  2    53 
  2    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  2    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  2    56 
  2    57 
  2    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  2    59           2 version                     fixed bin,
  2    60           2 count                       fixed bin,
  2    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  2    62 
  2    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  2    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  2    65 
  2    66 
  2    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  2    68           DIR_ACL_VERSION_1             init ("dra1"),
  2    69           DELETE_ACL_VERSION_1          init ("dla1"))
  2    70                                         char (4) int static options (constant);
  2    71 
  2    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  2    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  2    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  2    75                                         char (8) internal static options (constant);
  2    76 
  2    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  2    78 
  2    79 /* End include file acl_structures.incl.pl1 */
      177 
      178  /* BEGIN INCLUDE FILE ... object_map.incl.pl1 */
  3     2 /* coded February 8, 1972 by Michael J. Spier */
  3     3 /* Last modified on 05/20/72 at 13:29:38 by R F Mabee. */
  3     4 /* Made to agree with Spier's document on 20 May 1972 by R F Mabee. */
  3     5 /* modified on 6 May 1972 by R F Mabee to add map_ptr at end of object map. */
  3     6 /* modified May, 1972 by M. Weaver */
  3     7 /* modified 5/75 by E. Wiatrowski and 6/75 by M. Weaver */
  3     8 /* modified 5/77 by M. Weaver to add perprocess_static bit */
  3     9 
  3    10  declare	1 object_map aligned based,		/* Structure describing standard object map */
  3    11 
  3    12 	  2 decl_vers fixed bin,		/* Version number of current structure format */
  3    13 	  2 identifier char (8) aligned,	/* Must be the constant "obj_map" */
  3    14 	  2 text_offset bit (18) unaligned,	/* Offset relative to base of object segment of base of text section */
  3    15 	  2 text_length bit (18) unaligned,	/* Length in words of text section */
  3    16 	  2 definition_offset bit (18) unaligned, /* Offset relative to base of object seg of base of definition section */
  3    17 	  2 definition_length bit (18) unaligned, /* Length in words of definition section */
  3    18 	  2 linkage_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of linkage section */
  3    19 	  2 linkage_length bit (18) unaligned,	/* Length in words of linkage section */
  3    20 	  2 static_offset bit (18) unaligned,   /* Offset relative to base of obj seg of static section */
  3    21 	  2 static_length bit (18) unaligned,   /* Length in words of static section */
  3    22 	  2 symbol_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of symbol section */
  3    23 	  2 symbol_length bit (18) unaligned,	/* Length in words of symbol section */
  3    24 	  2 break_map_offset bit (18) unaligned, /* Offset relative to base of object seg of base of break map */
  3    25 	  2 break_map_length bit (18) unaligned, /* Length in words of break map */
  3    26 	  2 entry_bound bit (18) unaligned,	/* Offset in text of last gate entry */
  3    27 	  2 text_link_offset bit (18) unaligned, /* Offset of first text-embedded link */
  3    28 	  2 format aligned,			/* Word containing bit flags about object type */
  3    29 	    3 bound bit (1) unaligned,	/* On if segment is bound */
  3    30 	    3 relocatable bit (1) unaligned,	/* On if segment has relocation info in its first symbol block */
  3    31 	    3 procedure bit (1) unaligned,	/* On if segment is an executable object program */
  3    32 	    3 standard bit (1) unaligned,	/* On if segment is in standard format (more than just standard map) */
  3    33 	    3 separate_static bit(1) unaligned, /* On if static is a separate section from linkage */
  3    34 	    3 links_in_text bit (1) unaligned,	/* On if there are text-embedded links */
  3    35 	    3 perprocess_static bit (1) unaligned, /* On if static is not to be per run unit */
  3    36 	    3 unused bit (29) unaligned;        /* Reserved */
  3    37 
  3    38 declare	map_ptr bit(18) aligned based;	/* Last word of the segment. It points to the base of the object map. */
  3    39 
  3    40 declare	object_map_version_2 fixed bin static init(2);
  3    41 
  3    42 /* END INCLUDE FILE ... object_map.incl.pl1 */
      178 
      179  /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  4     2 
  4     3 /* Declarations for Segment Loading Table header and array.
  4     4*
  4     5*   Used by Initialization and MST Checker subroutines */
  4     6 
  4     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  4     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  4     9     namep ptr,					/* pointer to segment name list block */
  4    10     pathp ptr,					/* pointer to segment's directory path name */
  4    11     aclp ptr;					/* pointer to acl structure */
  4    12 
  4    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  4    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  4    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  4    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  4    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  4    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  4    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  4    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  4    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  4    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  4    23 
  4    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  4    25 
  4    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  4    27 	2 pad bit (18) unal,
  4    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  4    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  4    30 
  4    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  4    32 	2 count fixed bin (17),			/* number of segment names in this block */
  4    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  4    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  4    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  4    36 	  3 pad bit (5) unal,
  4    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  4    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  4    39 
  4    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  4    41 	2 size fixed bin (17),			/* length of pathname */
  4    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  4    43 	2 acls fixed bin;				/* ACL list starts here */
  4    44 
  4    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  4    46 	2 count fixed bin,				/* number of entries in acl list */
  4    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  4    48 	  3 userid char (32),			/* user specification */
  4    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  4    50 	  3 pad bit (36) aligned,
  4    51 	  3 code fixed bin;
  4    52 
  4    53 
  4    54 /* END INCLUDE FILE slt.incl.pl1 */
      179 
      180  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  5     2 /* Declaration for Segment Loading Table Entry structure.
  5     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  5     4 /* modified 5/4/76 by Noel I. Morris	*/
  5     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  5     6 /* format: style3 */
  5     7 
  5     8 dcl	sltep		ptr;
  5     9 
  5    10 dcl	1 slte_uns	based (sltep) aligned,
  5    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  5    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  5    13 /**** End of word 1 */
  5    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  5    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  5    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  5    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  5    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  5    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  5    20 	  2 pad1		bit (3),			/* unused */
  5    21 	  2 wired		bit (1),			/* segment is wired if ON */
  5    22 	  2 paged		bit (1),			/* segment is paged if ON */
  5    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  5    24 	  2 pad3		bit (2),
  5    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  5    26 /**** End of 1st half of word 2 */
  5    27 	  2 pad4		bit (3),
  5    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  5    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  5    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  5    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  5    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  5    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  5    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  5    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  5    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  5    37 /***** End of word 2 */
  5    38 	  2 pad5		bit (6),
  5    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  5    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  5    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  5    42 /***** End of word 3 */
  5    43 	  2 pad7		bit (3),
  5    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  5    45 	  2 bit_count	fixed bin (24) uns
  5    46 	  )		unaligned;		/* bitcount of segment */
  5    47 
  5    48 dcl	1 slte		based (sltep) aligned,
  5    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  5    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  5    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  5    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  5    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  5    54 	  2 firmware_seg    bit (1),
  5    55 	  2 layout_seg      bit (1),
  5    56 	  2 breakpointable  bit (1),
  5    57 	  2 pad2		bit (3),
  5    58 	  2 wired		bit (1),			/* segment is wired if ON */
  5    59 	  2 paged		bit (1),			/* segment is paged if ON */
  5    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  5    61 	  2 pad3		bit (2),
  5    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  5    63 	  2 pad4		bit (3),
  5    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  5    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  5    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  5    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  5    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  5    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  5    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  5    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  5    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  5    73 	  2 pad5		bit (6),
  5    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  5    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  5    76 	  2 segno		bit (18),			/* text/link segment number */
  5    77 	  2 pad6		bit (3),
  5    78 	  2 max_length	bit (9),			/* maximum length for segment */
  5    79 	  2 bit_count	bit (24)
  5    80 	  )		unaligned;		/* bitcount of segment */
  5    81 
  5    82 /* END INCLUDE FILE slte.incl.pl1 */
      180 
      181  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  6     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  6     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  6     4 
  6     5 /* This include file has an ALM version.  Keep 'em in sync! */
  6     6 
  6     7 dcl (
  6     8 
  6     9 /* The following constants define the message action codes.  This indicates
  6    10*how a message is to be handled.  */
  6    11 
  6    12      SYSERR_CRASH_SYSTEM	init (1),			
  6    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  6    14 
  6    15      SYSERR_TERMINATE_PROCESS	init (2),
  6    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  6    17 
  6    18      SYSERR_PRINT_WITH_ALARM	init (3),
  6    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  6    20 
  6    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  6    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  6    23 
  6    24      SYSERR_LOG_OR_PRINT	init (4),
  6    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  6    26 
  6    27      SYSERR_LOG_OR_DISCARD	init (5),
  6    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  6    29 
  6    30 
  6    31 /* The following constants are added to the normal severities to indicate
  6    32*different sorting classes of messages.  */
  6    33 
  6    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  6    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  6    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  6    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  6    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  6    39 	) fixed bin internal static options (constant);
  6    40 
  6    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      181 
      182 
      183 
      184 /* BEGIN MESSAGE DOCUMENTATION
      185*
      186*   Message:
      187*   load_system: illegal type in mst source
      188*
      189*   S:	$crash
      190*
      191*   T:	$init
      192*
      193*   M:	$err
      194*
      195*   A:	$recover
      196*   $boot_tape
      197*
      198*
      199*   Message:
      200*   load_system: error from asd_$add_sentries
      201*   The system could not remove the write access it had set to load the
      202*   contents of a segment from the mst source.
      203*
      204*   S:	$crash
      205*
      206*   T:	$init
      207*
      208*   M:	$err
      209*
      210*   A:	$recover
      211*   $boot_tape
      212*
      213*
      214*   Message:
      215*   load_system: illegal header length in mst source
      216*
      217*   S:	$crash
      218*
      219*   T:	$init
      220*
      221*   M:	$err
      222*
      223*   A:	$recover
      224*   $boot_tape
      225*
      226*
      227*   Message:
      228*   load_system: illegal type in mst source
      229*
      230*   S:	$crash
      231*
      232*   T:	$init
      233*
      234*   M:	$err
      235*
      236*   A:	$recover
      237*   $boot_tape
      238*
      239*
      240*   Message:
      241*   load_system: error from set$entry_bound_ptr
      242*
      243*   S:	$crash
      244*
      245*   T:	$init
      246*
      247*   M:	$err
      248*
      249*   A:	$recover
      250*   $boot_tape
      251*
      252*   END MESSAGE DOCUMENTATION */
      253 
      254      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0801.1  load_system.pl1                   >spec>install>1110>load_system.pl1
176          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
177          2    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
178          3    08/05/77  1022.5  object_map.incl.pl1               >ldd>include>object_map.incl.pl1
179          4    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
180          5    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
181          6    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACL_VERSION_1                          constant        fixed bin(17,0)          initial dcl 2-77 ref 87
CRASH                           000013 constant        fixed bin(17,0)          initial dcl 6-7 set ref 96* 98* 116* 129* 134* 154*
                                                                                  168*
RW_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 1-11 ref 127
access                          000100 automatic       bit(3)                   packed unaligned dcl 34 in procedure "load_system"
                                                                                  set ref 103* 106*
access                    1            based           bit(4)                   level 2 in structure "slte" packed packed unaligned
                                                                                  dcl 5-48 in procedure "load_system" ref 103
access_name                     000107 automatic       char(32)                 array level 2 in structure "del_acl" packed packed
                                                                                  unaligned dcl 41 in procedure "load_system" set
                                                                                  ref 166*
access_name               2     002167 automatic       char(32)                 array level 3 in structure "seg_acl_struc" packed
                                                                                  packed unaligned dcl 54 in procedure "load_system"
                                                                                  set ref 89*
addr                                                   builtin function         dcl 67 ref 84 85 114 114 128 128 161 161 167 167
addrel                                                 builtin function         dcl 67 ref 101 102 142 147
asd_$add_sentries               000012 constant        entry                    external dcl 75 ref 128 161
asd_$del_sentries               000014 constant        entry                    external dcl 76 ref 167
asd_$r_list_sall                000016 constant        entry                    external dcl 77 ref 114
bit                                                    builtin function         dcl 67 ref 103
bit_count                 3(12)        based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 5-10
                                                                                  ref 104
bitcount                        000101 automatic       fixed bin(24,0)          dcl 35 set ref 104* 140 141
count                     1     002167 automatic       fixed bin(17,0)          level 2 in structure "seg_acl_struc" dcl 54
                                                                                  in procedure "load_system" set ref 88*
count                     0(18) 000106 automatic       fixed bin(18,0)          level 2 in structure "cw" packed packed unsigned
                                                                                  unaligned dcl 38 in procedure "load_system" set
                                                                                  ref 97 136
count                                  based           fixed bin(17,0)          level 2 in structure "segnam" dcl 4-31 in procedure
                                                                                  "load_system" ref 102
count                           000102 automatic       fixed bin(18,0)          dcl 36 in procedure "load_system" set ref 97* 98
                                                                                  100*
cp                              000104 automatic       pointer                  dcl 37 set ref 85* 91* 93* 133*
cw                              000106 automatic       structure                level 1 dcl 38 set ref 85
decl_vers                              based           fixed bin(17,0)          level 2 dcl 3-10 ref 149
del_acl                         000107 automatic       structure                array level 1 dcl 41 set ref 167 167
delete_acl_entry                       based           structure                level 1 dcl 2-63
dir_name                        000120 automatic       char(168)                packed unaligned dcl 42 set ref 108* 114* 116* 128*
                                                                                  129* 154* 161* 167* 168*
directory_acl_entry                    based           structure                level 1 dcl 2-54
disk_reader                     000020 constant        entry                    external dcl 78 ref 91 93 100 133 136
divide                                                 builtin function         dcl 67 ref 141
entry_bound              11            based           bit(18)                  level 2 in structure "object_map" packed packed
                                                                                  unaligned dcl 3-10 in procedure "load_system" ref
                                                                                  151
entry_bound                     000172 automatic       fixed bin(14,0)          dcl 43 in procedure "load_system" set ref 151* 152
                                                                                  153*
entryname                       000173 automatic       char(32)                 packed unaligned dcl 44 set ref 109* 114* 116* 128*
                                                                                  129* 154* 161* 167* 168*
ercode                          000203 automatic       fixed bin(35,0)          dcl 45 set ref 114* 116 116* 128* 129 129* 153* 154
                                                                                  154* 161* 162 167* 168 168* 173* 174*
fixed                                                  builtin function         dcl 67 ref 143 151
general_acl_entry                      based           structure                level 1 unaligned dcl 2-12
general_delete_acl_entry               based           structure                level 1 dcl 2-35
general_extended_acl_entry             based           structure                level 1 dcl 2-23
header_area                     000204 automatic       fixed bin(35,0)          array dcl 46 set ref 84
hp                              002154 automatic       pointer                  dcl 47 set ref 84* 100* 101 103 104 106*
identifier                1            based           char(8)                  level 2 dcl 3-10 ref 148
init_branches$branch            000022 constant        entry                    external dcl 79 ref 106
just_reference                         based           fixed bin(35,0)          dcl 63 ref 173
lastword                        002156 automatic       pointer                  dcl 48 set ref 142* 143 147
map_ptr                                based           bit(18)                  dcl 3-38 ref 143 147
mapword                         002160 automatic       fixed bin(18,0)          dcl 49 set ref 143* 145 146
mode                     12     002167 automatic       bit(36)                  array level 3 dcl 54 set ref 118 121 127* 160*
must_delete_acl                 002161 automatic       bit(1)                   dcl 50 set ref 111* 120* 123* 124* 158 165
must_set_acl                    002162 automatic       bit(1)                   dcl 51 set ref 111* 119* 123* 124* 126 158
name                      1            based           char                     level 2 in structure "path" packed packed unaligned
                                                                                  dcl 4-40 in procedure "load_system" ref 108
name                      2            based           char(32)                 array level 3 in structure "segnam" packed packed
                                                                                  unaligned dcl 4-31 in procedure "load_system" ref
                                                                                  109
namep                           002210 automatic       pointer                  dcl 4-7 set ref 101* 102 102 106* 109
names                     1            based           structure                array level 2 dcl 4-31
null                                                   builtin function         dcl 67 ref 114 114
object_map                             based           structure                level 1 dcl 3-10
object_map_ptr                  002164 automatic       pointer                  dcl 52 set ref 147* 148 149 151
old_mode                        002166 automatic       bit(36)                  packed unaligned dcl 53 set ref 112* 121* 160
path                                   based           structure                level 1 dcl 4-40
pathp                           002212 automatic       pointer                  dcl 4-7 set ref 102* 106* 108
pds$process_group_id            000010 external static char(32)                 dcl 71 ref 89 166
seg_acl                   2     002167 automatic       structure                array level 2 dcl 54 set ref 128 128 161 161
seg_acl_struc                   002167 automatic       structure                level 1 dcl 54 set ref 114 114
segment_acl_entry                      based           structure                level 1 dcl 2-45
segnam                                 based           structure                level 1 dcl 4-31
segp                            002204 automatic       pointer                  dcl 58 set ref 106* 136* 142 147 153* 173
set$entry_bound_ptr             000024 constant        entry                    external dcl 80 ref 153
size                                                   builtin function         dcl 67 in procedure "load_system" ref 101
size                                   based           fixed bin(17,0)          level 2 in structure "path" dcl 4-40 in procedure
                                                                                  "load_system" ref 108
slte                                   based           structure                level 1 dcl 5-48 ref 101
slte_uns                               based           structure                level 1 dcl 5-10
sltep                                  automatic       pointer                  dcl 5-8 ref 101
status_code              14     002167 automatic       fixed bin(35,0)          array level 3 dcl 54 set ref 118
substr                                                 builtin function         dcl 67 ref 118
syserr                          000026 constant        entry                    external dcl 81 ref 96 98 134
syserr$error_code               000030 constant        entry                    external dcl 82 ref 116 129 154 168
type                            000106 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 38 set
                                                                                  ref 92 96 134
version                         002167 automatic       fixed bin(17,0)          level 2 dcl 54 set ref 87*
wordcount                       002206 automatic       fixed bin(18,0)          dcl 59 set ref 141* 142 146

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 6-7
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
BEEP                                   internal static fixed bin(17,0)          initial dcl 6-7
DELETE_ACL_VERSION_1                   internal static char(4)                  initial packed unaligned dcl 2-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 2-67
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
GENERAL_ACL_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 2-72
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial packed unaligned dcl 2-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial packed unaligned dcl 2-72
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 6-7
LOG                                    internal static fixed bin(17,0)          initial dcl 6-7
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial packed unaligned dcl 2-67
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 6-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 6-7
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 6-7
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
acl_count                              automatic       fixed bin(17,0)          dcl 2-5
acl_ptr                                automatic       pointer                  dcl 2-4
aclp                                   automatic       pointer                  dcl 4-7
acls                                   based           structure                level 1 dcl 4-45
delete_acl                             based           structure                level 1 dcl 2-58
delete_acl_array                       based           structure                array level 1 dcl 2-64
directory_acl                          based           structure                level 1 dcl 2-49
directory_acl_array                    based           structure                array level 1 dcl 2-55
general_acl                            based           structure                level 1 dcl 2-7
general_delete_acl                     based           structure                level 1 dcl 2-30
general_extended_acl                   based           structure                level 1 dcl 2-18
name_seg                               based           structure                level 1 dcl 4-26
names_ptr                              automatic       pointer                  dcl 4-7
object_map_version_2                   internal static fixed bin(17,0)          initial dcl 3-40
segment_acl                            based           structure                level 1 dcl 2-40
segment_acl_array                      based           structure                array level 1 dcl 2-46
slt                                    based           structure                level 1 dcl 4-13
sltp                                   automatic       pointer                  dcl 4-7

NAMES DECLARED BY EXPLICIT CONTEXT.
asd_error                       000523 constant        label                    dcl 129 ref 162
load_system                     000135 constant        entry                    external dcl 30
loop                            000156 constant        label                    dcl 91 ref 175
no_entry_bound                  000743 constant        label                    dcl 158 ref 140 145 146 148 149

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1242        1274    1115        1252
Length      1572    1115        32         262     125           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
load_system                        1252 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
load_system              000100 access                      load_system
                         000101 bitcount                    load_system
                         000102 count                       load_system
                         000104 cp                          load_system
                         000106 cw                          load_system
                         000107 del_acl                     load_system
                         000120 dir_name                    load_system
                         000172 entry_bound                 load_system
                         000173 entryname                   load_system
                         000203 ercode                      load_system
                         000204 header_area                 load_system
                         002154 hp                          load_system
                         002156 lastword                    load_system
                         002160 mapword                     load_system
                         002161 must_delete_acl             load_system
                         002162 must_set_acl                load_system
                         002164 object_map_ptr              load_system
                         002166 old_mode                    load_system
                         002167 seg_acl_struc               load_system
                         002204 segp                        load_system
                         002206 wordcount                   load_system
                         002210 namep                       load_system
                         002212 pathp                       load_system

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
asd_$add_sentries             asd_$del_sentries             asd_$r_list_sall              disk_reader
init_branches$branch          set$entry_bound_ptr           syserr                        syserr$error_code

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pds$process_group_id




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000134        84 000142        85 000144        87 000146        88 000150        89 000152        91 000156
     92 000171        93 000176        94 000211        96 000212        97 000234        98 000237       100 000261
    101 000272       102 000275       103 000303       104 000307       106 000312       108 000331       109 000336
    111 000342       112 000344       114 000345       116 000401       118 000437       119 000444       120 000446
    121 000447       122 000451       123 000452       124 000455       126 000460       127 000462       128 000464
    129 000521       133 000557       134 000572       136 000616       140 000632       141 000634       142 000637
    143 000643       145 000646       146 000650       147 000652       148 000656       149 000662       151 000665
    152 000670       153 000672       154 000705       158 000743       160 000747       161 000751       162 001006
    165 001010       166 001012       167 001017       168 001053       173 001111       174 001113       175 001114


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
