	COMPILATION LISTING OF SEGMENT stock_man
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1003.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 stock_man$allocate_record_stock:
        9      proc (Pvtep, Record_stockp);
       10 
       11 /* Routine to manage the allocation and deletion of stocks.
       12*   Initially, only record stocks are supported. Later, VTOCE stocks
       13*   will also be supported.
       14*
       15*   This implementation of record stocks is fairly simple. All record stocks 
       16*   are the same size, and there is sufficient wired space in stock_seg
       17*   for all of them. The record stocks form an array, whose elements
       18*   parallel the PVTE array. The knowledge of the internal structure
       19*   of stock_seg is known only to this procedure, so the allocation
       20*   mechanism can be changed fairly simply. If it is get_io_segs must
       21*   also be changed to get sufficient space in stock_seg. Similarly, VTOCE
       22*   stocks form an array, whose elements parallel the PVTE array, and
       23*   are all of the same size.
       24*
       25*   Written March 1982 by J. Bongiovanni
       26*
       27**/
       28 
       29 /*  Parameter  */
       30 
       31 	dcl     Pvtep		 ptr;		/* Pointer to PVTE */
       32 	dcl     Record_stockp	 ptr;		/* Pointer to record stock */
       33 	dcl     Vtoce_stockp	 ptr;		/* Pointer to VTOCE stock */
       34 
       35 /*  Automatic  */
       36 
       37 	dcl     p99		 pic "99";
       38 	dcl     pvtx		 fixed bin;
       39 	dcl     stockx		 fixed bin;
       40 
       41 /*  Entry  */
       42 
       43 	dcl     syserr		 entry options (variable);
       44 
       45 /*  Builtin  */
       46 
       47 	dcl     addr		 builtin;
       48 	dcl     addrel		 builtin;
       49 	dcl     bin		 builtin;
       50 	dcl     bit		 builtin;
       51 	dcl     convert		 builtin;
       52 	dcl     divide		 builtin;
       53 	dcl     null		 builtin;
       54 	dcl     rel		 builtin;
       55 	dcl     size		 builtin;
       56 	dcl     unspec		 builtin;
       57 
       58 
       59 	pvtep = Pvtep;
       60 	pvtx = divide (bin (rel (pvtep)) - bin (rel (addr (pvt$array))), size (pvte), 17) + 1; /* PVTE index */
       61 
       62 	stock_segp = addr (stock_seg$);
       63 
       64 	n_in_record_stock = stock_seg.record_stock_entries;
       65 	n_volmap_pages = N_OLD_VOLMAP_PAGES;
       66 
       67 	record_stockp = addrel (stock_seg.record_stock_arrayp, (pvtx - 1) * stock_seg.record_stock_size);
       68 
       69 	record_stock.pvtep = pvtep;
       70 	record_stock.n_in_stock = n_in_record_stock;
       71 	record_stock.n_volmap_pages = N_OLD_VOLMAP_PAGES;
       72 	record_stock.n_free_in_stock = 0;
       73 	record_stock.n_os_in_stock = 0;
       74 	record_stock.low_threshold = divide (n_in_record_stock, 4, 18);
       75 	record_stock.high_threshold = n_in_record_stock - record_stock.low_threshold;
       76 	record_stock.target = divide (record_stock.high_threshold + record_stock.low_threshold, 2, 18);
       77 	record_stock.stock_offset = bit (bin (bin (rel (addr (record_stock.stock))) - bin (rel (record_stockp)), 18), 18);
       78 	record_stock.n_words_in_stock = divide (n_in_record_stock + 1, 2, 18);
       79 	record_stock.search_index = 0;
       80 
       81 	unspec (record_stock.old_volmap_page) = ""b;
       82 	unspec (record_stock.volmap_page) = ""b;
       83 	unspec (record_stock.stock) = ""b;
       84 
       85 	pvte.volmap_stock_ptr = record_stockp;
       86 
       87 	Record_stockp = record_stockp;
       88 
       89 	return;
       90 
       91 stock_man$free_record_stock:
       92      entry (Pvtep, Record_stockp);
       93 
       94 	pvtep = Pvtep;
       95 	record_stockp = Record_stockp;
       96 
       97 	if pvte.volmap_stock_ptr = null () then return;	/* For ESD, since may crump in the middle of demount */
       98 
       99 	if pvte.volmap_stock_ptr ^= record_stockp | record_stock.pvtep ^= pvtep
      100 	then do;
      101 		pvte.volmap_stock_ptr = null ();	/* Let ESD work next time */
      102 		call syserr (CRASH, "stock_man: PVTE out of synch with record stock on ^a_^a: pvtep=^p record_stockp=^p", pvte.devname, convert (p99, pvte.logical_area_number), pvtep, record_stockp);
      103 	     end;
      104 
      105 
      106 	if record_stock.n_free_in_stock ^= 0 | record_stock.n_os_in_stock ^= 0
      107 	     | unspec (record_stock.stock) ^= ""b
      108 	then do;
      109 		pvte.volmap_stock_ptr = null ();	/* Let ESD work next time */
      110 		call syserr (CRASH, "stock_man: Attempt to free non-empty stock on ^a_^a: pvtep=^p record_stockp = ^p", pvte.devname, convert (p99, pvte.logical_area_number), pvtep, record_stockp);
      111 	     end;
      112 
      113 	pvte.volmap_stock_ptr = null ();
      114 	unspec (record_stock) = ""b;
      115 
      116 	return;
      117 
      118 stock_man$allocate_vtoce_stock:
      119      entry (Pvtep, Vtoce_stockp);
      120 
      121 	pvtep = Pvtep;
      122 	pvtx = divide (bin (rel (pvtep)) - bin (rel (addr (pvt$array))), size (pvte), 17) + 1; /* PVTE index */
      123 
      124 
      125 	stock_segp = addr (stock_seg$);
      126 
      127 	n_in_vtoce_stock = stock_seg.vtoce_stock_entries;
      128 
      129 	vtoce_stockp = addrel (stock_seg.vtoce_stock_arrayp, (pvtx - 1) * stock_seg.vtoce_stock_size);
      130 
      131 	vtoce_stock.pvtep = pvtep;
      132 	vtoce_stock.n_in_stock = n_in_vtoce_stock;
      133 	vtoce_stock.n_free_in_stock = 0;
      134 	vtoce_stock.target = divide (n_in_vtoce_stock, 2, 18);
      135 	vtoce_stock.search_index = 0;
      136 
      137 	unspec (vtoce_stock.stock) = ""b;
      138 
      139 	do stockx = 1 to vtoce_stock.n_in_stock;
      140 	     vtoce_stock.stock (stockx) = -1;
      141 	end;
      142 
      143 	pvte.vtoc_map_stock_ptr = vtoce_stockp;
      144 	Vtoce_stockp = vtoce_stockp;
      145 
      146 	return;
      147 
      148 stock_man$free_vtoce_stock:
      149      entry (Pvtep, Vtoce_stockp);
      150 
      151 	pvtep = Pvtep;
      152 	vtoce_stockp = Vtoce_stockp;
      153 
      154 	if pvte.vtoc_map_stock_ptr = null () then return; /* For ESD, since may crump in the middle of a dismount */
      155 
      156 	if pvte.vtoc_map_stock_ptr ^= vtoce_stockp | vtoce_stock.pvtep ^= pvtep
      157 	then do;
      158 		pvte.vtoc_map_stock_ptr = null ();	/* Let ESD work */
      159 		call syserr (CRASH, "stock_man: PVTE out of synch with VTOCE stock on ^a_^a: pvtep=^p vtoce_stockp=^p",
      160 		     pvte.devname, convert (p99, pvte.logical_area_number), pvtep, vtoce_stockp);
      161 	     end;
      162 
      163 	if vtoce_stock.n_free_in_stock ^= 0
      164 	then do;
      165 NON_EMPTY_STOCK:
      166 		pvte.vtoc_map_stock_ptr = null ();	/* Let ESD work */
      167 		call syserr (CRASH, "stock_man: Attempt to free non-empty stock on ^a_^a: pvtep=^p vtoce_stockp=^p",
      168 		     pvte.devname, convert (p99, pvte.logical_area_number), pvtep, vtoce_stockp);
      169 	     end;
      170 
      171 	do stockx = 1 to vtoce_stock.n_in_stock;
      172 	     if vtoce_stock.stock (stockx) ^= -1
      173 	     then goto NON_EMPTY_STOCK;
      174 	end;
      175 
      176 	pvte.vtoc_map_stock_ptr = null ();
      177 	unspec (vtoce_stock) = ""b;
      178 
      179 	return;
      180 
      181 
      182  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  1     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1     8*     Add the support for subvolumes
  1     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  1    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  1    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  1    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  1    14*     Added inconsistent_dbm bit for determining the status of volume
  1    15*     dumper bit maps.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18      dcl	   pvt$array	      aligned external;
  1    19      dcl	   pvt$max_n_entries      fixed bin external;
  1    20 
  1    21      dcl	   pvt_arrayp	      ptr;
  1    22      dcl	   pvtep		      ptr;
  1    23 
  1    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  1    25 
  1    26      dcl	   1 pvte		      based (pvtep) aligned,
  1    27 
  1    28 	     2 pvid	      bit (36),		/* physical volume ID */
  1    29 
  1    30 	     2 lvid	      bit (36),		/* logical volume ID */
  1    31 
  1    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  1    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  1    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  1    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  1    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  1    37 	     2 pad3	      bit (2) unaligned,
  1    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  1    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  1    40 
  1    41 
  1    42 
  1    43 	     2 devname	      char (4),		/* device name */
  1    44 
  1    45 	     (2 device_type	      fixed bin (8),	/* device type */
  1    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  1    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  1    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  1    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  1    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  1    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  1    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  1    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  1    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  1    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  1    56 	     2 scav_check_address
  1    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  1    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  1    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  1    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  1    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  1    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  1    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  1    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  1    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  1    66 
  1    67 
  1    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  1    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  1    70 
  1    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  1    72 
  1    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  1    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  1    75 
  1    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  1    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  1    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  1    79 	     2 records_per_cyl    fixed bin,
  1    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  1    81 	     2 sv_name            char (2) aligned,
  1    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  1    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  1    84 
  1    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  1    86 	     2 pad2	      bit (18) unaligned,
  1    87 
  1    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  1    89 
  1    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  1    91 
  1    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  1    93 
  1    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  1    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  1    96 
  1    97 
  1    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  1    99 
  1   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  1   101 
  1   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  1   103 
  1   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  1   105 
  1   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  1   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  1   108 
  1   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  1   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  1   111 
  1   112 
  1   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  1   114 	   VOLMAP_ASYNC_READ      init (1),
  1   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  1   116 
  1   117 
  1   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      182 
      183  /*  START OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3      dcl	   stock_segp	      ptr;
  2     4      dcl	   record_stockp	      ptr;
  2     5      dcl	   vtoce_stockp	      ptr;
  2     6      dcl	   stock_seg$	      ext;
  2     7 
  2     8      dcl	   n_in_record_stock      fixed bin;
  2     9      dcl	   n_volmap_pages	      fixed bin;
  2    10      dcl	   n_in_vtoce_stock	      fixed bin;
  2    11 
  2    12 
  2    13      dcl	   1 stock_seg	      aligned based (stock_segp),
  2    14 
  2    15 	     2 meters	      aligned like rsmeters,
  2    16 
  2    17 	     2 record_stock_entries fixed bin,		/* Number of entries in a record stock */
  2    18 	     2 vtoce_stock_entries fixed bin,		/* Number of entries in a VTOCE stock */
  2    19 	     2 record_stock_size  fixed bin,		/* Size of a record stock in words */
  2    20 	     2 vtoce_stock_size   fixed bin,		/* Size of a VTOCE stock in words */
  2    21 	     2 n_stock_entries    fixed bin,		/* Number of stocks of each type */
  2    22 	     2 record_stock_arrayp ptr,		/* Record stock region */
  2    23 	     2 vtoce_stock_arrayp ptr;		/* VTOCE stock region */
  2    24 
  2    25 
  2    26      dcl	   1 record_stock	      aligned based (record_stockp),
  2    27 
  2    28 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  2    29 
  2    30 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number of addresses in stock */
  2    31 	     2 n_volmap_pages     fixed bin (18) uns unal,/* Number of pages in Volume Map */
  2    32 
  2    33 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number addresses currently free */
  2    34 	     2 n_os_in_stock      fixed bin (18) uns unal,/* Number addresses currently out-of-service */
  2    35 
  2    36 	     2 low_threshold      fixed bin (18) uns unal,/* Low threshold for withdrawing from volmap */
  2    37 	     2 high_threshold     fixed bin (18) uns unal,/* High threshold for depositing to volmap */
  2    38 
  2    39 	     2 target	      fixed bin (18) uns unal,/* Target for stock */
  2    40 	     2 stock_offset	      bit (18) unal,	/* Offset of stock in this structure */
  2    41 
  2    42 	     2 n_words_in_stock   fixed bin (18) uns unal,/* Number of words = Number of entries / 2 */
  2    43 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  2    44 
  2    45 	     2 old_volmap_page    (3) aligned,		/* N_OLD_VOLMAP_PAGES (cif) */
  2    46 	       3 last	      fixed bin (18) uns unal,/* Roving pointer */
  2    47 	       3 pad	      bit (18) unal,
  2    48 
  2    49 	     2 volmap_page	      (n_volmap_pages refer (record_stock.n_volmap_pages)) aligned,
  2    50 	       3 n_free	      fixed bin (18) uns unal,/* Number free records in this volmap page */
  2    51 	       3 baseadd	      fixed bin (17) unal,	/* First record address described by this page */
  2    52 
  2    53 	     2 stock	      (n_in_record_stock refer (record_stock.n_in_stock)) bit (18) unal; /* Stock array of addresses */
  2    54 						/* bit 0 ON => out-of-service */
  2    55 
  2    56 
  2    57      dcl	   1 vtoce_stock	      aligned based (vtoce_stockp),
  2    58 	     2 pvtep	      ptr unal,		/* PVTE for this stock */
  2    59 	     2 n_in_stock	      fixed bin (18) uns unal,/* Max number indices in stock */
  2    60 	     2 n_free_in_stock    fixed bin (18) uns unal,/* Number indices currently free */
  2    61 	     2 target	      fixed bin (18) uns unal,/* Target when withdrawing/depositing */
  2    62 	     2 search_index	      fixed bin (18) uns unal,/* Roving pointer */
  2    63 	     2 stock	      (n_in_vtoce_stock refer (vtoce_stock.n_in_stock)) fixed bin (17) unal; /* Stock array of VTOCE indices */
  2    64 
  2    65 
  2    66      dcl	   1 rsmeters	      aligned based,
  2    67 
  2    68 	     2 async_read_calls   fixed bin (35),	/* Number of asynchronous read attempts */
  2    69 	     2 async_page_reads   fixed bin (35),	/* Number of times page read was required */
  2    70 	     2 async_post_io_calls fixed bin (35),	/* Number of times read or write posted */
  2    71 	     2 deposit_calls      fixed bin (35),	/* Number of times deposit called */
  2    72 	     2 async_post_io_time fixed bin (71),	/* CPU time posting I/Os (interrupt side) */
  2    73 	     2 deposit_time	      fixed bin (71),	/* CPU time in deposit (call side) */
  2    74 	     2 low_thresh_detected fixed bin (35),	/* Number of times stock below low threshold */
  2    75 	     2 high_thresh_detected fixed bin (35),	/* Number of times stock above high threshold */
  2    76 	     2 low_thresh_fails   fixed bin (35),	/* Number of times no records in volmap */
  2    77 	     2 withdraw_stock_steps fixed bin (35),	/* Number steps thru stock in withdraw */
  2    78 	     2 withdraw_stock_losses fixed bin (35),	/* Number lockless losses */
  2    79 	     2 n_withdraw_attempt fixed bin (35),	/* Number attempts to withdraw a page */
  2    80 	     2 n_withdraw_range   fixed bin (35),	/* Number attempts to withdraw within range */
  2    81 	     2 n_pages_withdraw_stock fixed bin (35),	/* Number pages withdrawn from stock */
  2    82 	     2 n_pages_withdraw_async fixed bin (35),	/* Number pages withdrawn from volmap */
  2    83 	     2 n_v_withdraw_attempts fixed bin (35),	/* Number attempts to withdraw from volmap */
  2    84 	     2 withdraw_volmap_steps fixed bin (35),	/* Number steps thru volmap in withdraw */
  2    85 	     2 deposit_stock_steps fixed bin (35),	/* Number steps thru stock in deposit */
  2    86 	     2 deposit_stock_losses fixed bin (35),	/* Number lockless losses */
  2    87 	     2 n_deposit_attempt  fixed bin (35),	/* Number attempts to deposit a page */
  2    88 	     2 n_pages_deposit_stock fixed bin (35),	/* Number pages deposited to stock */
  2    89 	     2 n_pages_deposit_volmap fixed bin (35),	/* Number pages deposited to volmap */
  2    90 	     2 n_v_deposit_attempts fixed bin (35),	/* Number attempts to deposit to volmap */
  2    91 	     2 reset_os_calls     fixed bin (35),	/* Number calls to reset_os */
  2    92 	     2 reset_os_losses    fixed bin (35),	/* Number lockless losses */
  2    93 	     2 withdraw_calls     fixed bin (35),	/* Number calls to withdraw */
  2    94 	     2 withdraw_time      fixed bin (71),	/* CPU time in withdraw (page-fault) */
  2    95 	     2 pc_deposit_time    fixed bin (71),	/* CPU time in pc_deposit */
  2    96 	     2 pc_deposit_calls   fixed bin (35),	/* Number calls to pc_deposit */
  2    97 	     2 pc_deposit_pages   fixed bin (35),	/* Number pages deposited by pc_deposit */
  2    98 	     2 get_free_vtoce_calls fixed bin (35),	/* Number calls to get_free_vtoce */
  2    99 	     2 return_free_vtoce_call fixed bin (35),	/* Number calls to return_free_vtoce */
  2   100 	     2 deposit_vstock_calls fixed bin (35),	/* Number attempts to deposit to vtoce stock */
  2   101 	     2 deposit_vstock_fails fixed bin (35),	/* Number times deposit failed */
  2   102 	     2 withdraw_vstock_calls fixed bin (35),	/* Number attempts to withdraw from vtoce stock */
  2   103 	     2 withdraw_vstock_fails fixed bin (35),	/* Number times withdraw failed */
  2   104 	     2 deposit_vtoc_map fixed bin (35),		/* Number times vtoce deposited to map */
  2   105 	     2 withdraw_check_scav fixed bin (35),	/* Number times withdraw checked an address for scavenge */
  2   106 	     2 withdraw_conflict fixed bin (35),	/* Number times conflict found */
  2   107 	     2 pad (11)	      fixed bin (35);
  2   108 	
  2   109 
  2   110      dcl	   N_OLD_VOLMAP_PAGES     fixed bin init (3) int static options (constant);
  2   111      dcl	   DEFAULT_N_IN_RECORD_STOCK fixed bin init (104) int static options (constant);
  2   112      dcl	   DEFAULT_N_IN_VTOCE_STOCK fixed bin init (10) int static options (constant);
  2   113 
  2   114 
  2   115 /*  END OF:	stock_seg.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      183 
      184  /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  3     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  3     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  3     4 
  3     5 /* This include file has an ALM version.  Keep 'em in sync! */
  3     6 
  3     7 dcl (
  3     8 
  3     9 /* The following constants define the message action codes.  This indicates
  3    10*how a message is to be handled.  */
  3    11 
  3    12      SYSERR_CRASH_SYSTEM	init (1),			
  3    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  3    14 
  3    15      SYSERR_TERMINATE_PROCESS	init (2),
  3    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  3    17 
  3    18      SYSERR_PRINT_WITH_ALARM	init (3),
  3    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  3    20 
  3    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  3    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  3    23 
  3    24      SYSERR_LOG_OR_PRINT	init (4),
  3    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  3    26 
  3    27      SYSERR_LOG_OR_DISCARD	init (5),
  3    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  3    29 
  3    30 
  3    31 /* The following constants are added to the normal severities to indicate
  3    32*different sorting classes of messages.  */
  3    33 
  3    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  3    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  3    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  3    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  3    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  3    39 	) fixed bin internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      184 
      185 
      186 /* BEGIN MESSAGE DOCUMENTATION
      187*
      188*   Message:
      189*   stock_man: PVTE out of synch with record stock on dskX_NN: pvtep = XXX|XXXXXX record_stockp = YYY|YYYYYY
      190*
      191*   S:     $crash
      192*
      193*   T:	During initialization immediately before the File System is
      194*   activated, or when demounting a physical disk volume.
      195*
      196*   M:	The supervisor databases pvt and stock_seg are not in proper
      197*   synchronization. The pointers printed are the locations of the databasse
      198*   elements for which this condition has been detected. These pointers are
      199*   useful to the site system programmers for analyzing the problem, which is
      200*   probably a software malfunction. dskX_NN is the physical volume whose
      201*   tables are affected.
      202*
      203*   A:     $recover
      204*   The free addresses which are lost may be recovered by a physical volume salvage.
      205*
      206*
      207*   Message:
      208*   stock_man: Attempt to free non-empty stock on dskX_NN: pvtep=XXX|XXXXXX record_stockp=YYY|YYYYYY
      209*
      210*   S:     $crash
      211*
      212*   T:	During initialization immediately before the File System is
      213*   activated, or when demounting a physical disk volume.
      214*
      215*   M:     Not all free addresses have been deposited to the Volume Map
      216*   successfully for the disk volume indicated. This is indicative of a software
      217*   malfunction. The pointers printed are useful to site system programmers in 
      218*   analyzing the problem.
      219*
      220*   A:     $recover
      221*   The free addresses which are lost may be recovered by a physical volume salvage.
      222*
      223*   Message:
      224*   stock_man: PVTE out of synch with VTOCE stock on dskX_NN: pvtep = XXX|XXXXXX vtoce_stockp = YYY|YYYYYY
      225*
      226*   S:     $crash
      227*
      228*   T:     When demounting a physical disk volume.
      229*
      230*   M:	The supervisor databases pvt and stock_seg are not in proper
      231*   synchronization. The pointers printed are the locations of the databasse
      232*   elements for which this condition has been detected. These pointers are
      233*   useful to the site system programmers for analyzing the problem, which is
      234*   probably a software malfunction. dskX_NN is the physical volume whose
      235*   tables are affected. Some free VTOCEs may be lost.
      236*
      237*   A:     $recover
      238*   The lost VTOCEs can be recovered by a physical volume salvage.
      239*
      240*   Message:
      241*   stock_man: Attempt to free non-empty stock on dskX_NN: pvtep=XXX|XXXXXX vtoce_stockp=YYY|YYYYYY
      242*
      243*   S:     $crash
      244*
      245*   T:     When demounting a physical disk volume.
      246*
      247*   M:     Not all free VTOCEs have been deposited to the VTOC Map
      248*   successfully for the disk volume indicated. This is indicative of a software
      249*   malfunction. The pointers printed are useful to site system programmers in 
      250*   analyzing the problem.
      251*
      252*   A:     $recover
      253*   The free VTOCEs which are lost may be recovered by a physical volume salvage.
      254*
      255*
      256*   END MESSAGE DOCUMENTATION */
      257      end stock_man$allocate_record_stock;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.5  stock_man.pl1                     >special_ldd>install>MR12.3-1114>stock_man.pl1
182          1    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
183          2    10/25/82  1015.6  stock_seg.incl.pl1                >ldd>include>stock_seg.incl.pl1
184          3    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CRASH                           000006 constant        fixed bin(17,0)          initial dcl 3-7 set ref 102* 110* 159* 167*
N_OLD_VOLMAP_PAGES                     constant        fixed bin(17,0)          initial dcl 2-110 ref 65 71
Pvtep                                  parameter       pointer                  dcl 31 ref 8 59 91 94 118 121 148 151
Record_stockp                          parameter       pointer                  dcl 32 set ref 8 87* 91 95
Vtoce_stockp                           parameter       pointer                  dcl 33 set ref 118 144* 148 152
addr                                                   builtin function         dcl 47 ref 60 62 77 122 125
addrel                                                 builtin function         dcl 48 ref 67 129
bin                                                    builtin function         dcl 49 ref 60 60 77 77 77 122 122
bit                                                    builtin function         dcl 50 ref 77
convert                                                builtin function         dcl 51 ref 102 102 110 110 159 159 167 167
devname                   3            based           char(4)                  level 2 dcl 1-26 set ref 102* 110* 159* 167*
divide                                                 builtin function         dcl 52 ref 60 74 76 78 122 134
high_threshold            3(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2-26
                                                                                  set ref 75* 76
logical_area_number       4(09)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 1-26 ref 102 102
                                                                                  110 110 159 159 167 167
low_threshold             3            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2-26
                                                                                  set ref 74* 75 76
n_free_in_stock           2            based           fixed bin(18,0)          level 2 in structure "record_stock" packed packed
                                                                                  unsigned unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 72* 106
n_free_in_stock           1(18)        based           fixed bin(18,0)          level 2 in structure "vtoce_stock" packed packed
                                                                                  unsigned unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 133* 163
n_in_record_stock               000112 automatic       fixed bin(17,0)          dcl 2-8 set ref 64* 70 74 75 78
n_in_stock                1            based           fixed bin(18,0)          level 2 in structure "record_stock" packed packed
                                                                                  unsigned unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 70* 83
                                                                                  106 114
n_in_stock                1            based           fixed bin(18,0)          level 2 in structure "vtoce_stock" packed packed
                                                                                  unsigned unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 132* 137
                                                                                  139 171 177
n_in_vtoce_stock                000114 automatic       fixed bin(17,0)          dcl 2-10 set ref 127* 132 134
n_os_in_stock             2(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2-26
                                                                                  set ref 73* 106
n_volmap_pages                  000113 automatic       fixed bin(17,0)          dcl 2-9 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 65*
n_volmap_pages            1(18)        based           fixed bin(18,0)          level 2 in structure "record_stock" packed packed
                                                                                  unsigned unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 71* 77
                                                                                  82 83 106 114
n_words_in_stock          5            based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 2-26
                                                                                  set ref 78*
null                                                   builtin function         dcl 53 ref 97 101 109 113 154 158 165 176
old_volmap_page           6            based           structure                array level 2 dcl 2-26 set ref 81*
p99                                    automatic       picture(2)               packed unaligned dcl 37 ref 102 102 110 110 159 159
                                                                                  167 167
pvt$array                       000012 external static fixed bin(17,0)          dcl 1-18 set ref 60 122
pvte                                   based           structure                level 1 dcl 1-26 set ref 60 122
pvtep                           000102 automatic       pointer                  dcl 1-22 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 59* 60
                                                                                  60 69 85 94* 97 99 99 101 102 102 102 102* 109 110
                                                                                  110 110 110* 113 121* 122 122 131 143 151* 154 156
                                                                                  156 158 159 159 159 159* 165 167 167 167 167* 176
pvtep                                  based           pointer                  level 2 in structure "vtoce_stock" packed packed
                                                                                  unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 131* 156
pvtep                                  based           pointer                  level 2 in structure "record_stock" packed packed
                                                                                  unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 69* 99
pvtx                            000100 automatic       fixed bin(17,0)          dcl 38 set ref 60* 67 122* 129
record_stock                           based           structure                level 1 dcl 2-26 set ref 114*
record_stock_arrayp      74            based           pointer                  level 2 dcl 2-13 ref 67
record_stock_entries     66            based           fixed bin(17,0)          level 2 dcl 2-13 ref 64
record_stock_size        70            based           fixed bin(17,0)          level 2 dcl 2-13 ref 67
record_stockp                   000106 automatic       pointer                  dcl 2-4 set ref 67* 69 70 71 72 73 74 75 75 76 76 76
                                                                                  77 77 77 78 79 81 82 83 85 87 95* 99 99 102* 106
                                                                                  106 106 110* 114
rel                                                    builtin function         dcl 54 ref 60 60 77 77 122 122
rsmeters                               based           structure                level 1 dcl 2-66
search_index              2(18)        based           fixed bin(18,0)          level 2 in structure "vtoce_stock" packed packed
                                                                                  unsigned unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 135*
search_index              5(18)        based           fixed bin(18,0)          level 2 in structure "record_stock" packed packed
                                                                                  unsigned unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 79*
size                                                   builtin function         dcl 55 ref 60 122
stock                                  based           bit(18)                  array level 2 in structure "record_stock" packed
                                                                                  packed unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 77 83*
                                                                                  106
stock                     3            based           fixed bin(17,0)          array level 2 in structure "vtoce_stock" packed
                                                                                  packed unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 137*
                                                                                  140* 172
stock_offset              4(18)        based           bit(18)                  level 2 packed packed unaligned dcl 2-26 set ref 77*
stock_seg                              based           structure                level 1 dcl 2-13
stock_seg$                      000014 external static fixed bin(17,0)          dcl 2-6 set ref 62 125
stock_segp                      000104 automatic       pointer                  dcl 2-3 set ref 62* 64 67 67 125* 127 129 129
stockx                          000101 automatic       fixed bin(17,0)          dcl 39 set ref 139* 140* 171* 172*
syserr                          000010 constant        entry                    external dcl 43 ref 102 110 159 167
target                    2            based           fixed bin(18,0)          level 2 in structure "vtoce_stock" packed packed
                                                                                  unsigned unaligned dcl 2-57 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 134*
target                    4            based           fixed bin(18,0)          level 2 in structure "record_stock" packed packed
                                                                                  unsigned unaligned dcl 2-26 in procedure
                                                                                  "stock_man$allocate_record_stock" set ref 76*
unspec                                                 builtin function         dcl 56 set ref 81* 82* 83* 106 114* 137* 177*
volmap_page              11            based           structure                array level 2 dcl 2-26 set ref 82*
volmap_stock_ptr         30            based           pointer                  level 2 packed packed unaligned dcl 1-26 set ref 85*
                                                                                  97 99 101* 109* 113*
vtoc_map_stock_ptr       31            based           pointer                  level 2 packed packed unaligned dcl 1-26 set ref
                                                                                  143* 154 156 158* 165* 176*
vtoce_stock                            based           structure                level 1 dcl 2-57 set ref 177*
vtoce_stock_arrayp       76            based           pointer                  level 2 dcl 2-13 ref 129
vtoce_stock_entries      67            based           fixed bin(17,0)          level 2 dcl 2-13 ref 127
vtoce_stock_size         71            based           fixed bin(17,0)          level 2 dcl 2-13 ref 129
vtoce_stockp                    000110 automatic       pointer                  dcl 2-5 set ref 129* 131 132 133 134 135 137 139 140
                                                                                  143 144 152* 156 156 159* 163 167* 171 172 177

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 3-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 3-7
DEFAULT_N_IN_RECORD_STOCK              internal static fixed bin(17,0)          initial dcl 2-111
DEFAULT_N_IN_VTOCE_STOCK               internal static fixed bin(17,0)          initial dcl 2-112
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 3-7
LOG                                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 3-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 3-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 1-113
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 1-19
pvt_array                              based           structure                array level 1 dcl 1-24
pvt_arrayp                             automatic       pointer                  dcl 1-21

NAMES DECLARED BY EXPLICIT CONTEXT.
NON_EMPTY_STOCK                 000765 constant        label                    dcl 165 set ref 172
stock_man$allocate_record_stock 000137 constant        entry                    external dcl 8
stock_man$allocate_vtoce_stock  000543 constant        entry                    external dcl 118
stock_man$free_record_stock     000314 constant        entry                    external dcl 91
stock_man$free_vtoce_stock      000655 constant        entry                    external dcl 148

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1272        1310    1113        1302
Length      1542    1113        16         215     156           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
stock_man$allocate_record_stock
                                    166 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
stock_man$allocate_record_stock
                         000100 pvtx                        stock_man$allocate_record_stock
                         000101 stockx                      stock_man$allocate_record_stock
                         000102 pvtep                       stock_man$allocate_record_stock
                         000104 stock_segp                  stock_man$allocate_record_stock
                         000106 record_stockp               stock_man$allocate_record_stock
                         000110 vtoce_stockp                stock_man$allocate_record_stock
                         000112 n_in_record_stock           stock_man$allocate_record_stock
                         000113 n_volmap_pages              stock_man$allocate_record_stock
                         000114 n_in_vtoce_stock            stock_man$allocate_record_stock

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
unpk_to_pk          call_ext_out_desc   return_mac          ext_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pvt$array                     stock_seg$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      8 000133        59 000144        60 000150        62 000164        64 000166        65 000170        67 000172
     69 000200        70 000201        71 000204        72 000206        73 000210        74 000212        75 000216
     76 000224        77 000235        78 000253        79 000260        81 000262        82 000265        83 000276
     85 000306        87 000310        89 000311        91 000312        94 000321        95 000325        97 000330
     99 000333       101 000343       102 000345       106 000420       109 000440       110 000443       113 000516
    114 000521       116 000540       118 000541       121 000550       122 000554       125 000571       127 000573
    129 000575       131 000603       132 000604       133 000607       134 000611       135 000615       137 000617
    139 000626       140 000636       141 000643       143 000645       144 000650       146 000652       148 000653
    151 000662       152 000666       154 000671       156 000674       158 000704       159 000706       163 000761
    165 000765       167 000770       171 001043       172 001055       174 001066       176 001070       177 001073
    179 001105


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
