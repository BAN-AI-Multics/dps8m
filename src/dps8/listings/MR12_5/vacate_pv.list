	COMPILATION LISTING OF SEGMENT vacate_pv
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1032.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-05-01,Parisek), approve(88-05-27,MCR7907),
       16*     audit(88-06-02,Fawcett), install(88-09-27,MR12.2-1122):
       17*     Changed to NOT set pc_vacating in the pvte. This flag would inhibit any
       18*     new pages being withdrawed from this pv. The concept of inhibit is to
       19*     inhibit any new segments. If pc_vacating is set and a segment like the
       20*     kst needs one more page, the system loop trying to get a page on the pv.
       21*     The kst cannot be moved.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       26 
       27 vacate_pv: proc (a_pvtx, a_pvid, a_code);
       28 
       29 
       30 /* vacate_pv     Bernard Greenberg 05/24/76
       31*
       32*   Procedure to segmove all of the segments on a given physical volume.
       33*   Must be driven by pathname from outer ring. */
       34 
       35 /* modified 4/77 by M. Weaver to change calling sequences to makeknown_ and terminate_ */
       36 /* Modified March 1982, J. Bongiovanni, for new PVTE, demand_segmove */
       37 /* Modified 84-10-17, BIM, TEMPORARILY set pvte.pc_vacating */
       38 /* Modified July 1984 by Keith Loepere to use the new dc_find. */
       39 /* Modified November 1984 by Keith Loepere for auditing. */
       40 
       41 /* Parameters */
       42 
       43 dcl  a_code			fixed bin (35);
       44 dcl  a_dirname			char (*);
       45 dcl  a_ename			char (*);
       46 dcl  a_pvid			bit (36) aligned;
       47 dcl  a_pvtx			fixed bin;
       48 dcl  a_segptr			ptr;
       49 
       50 /* External */
       51 
       52 dcl  error_table_$argerr		fixed bin (35) ext;
       53 dcl  error_table_$bad_index		fixed bin (33) ext;
       54 dcl  error_table_$segknown		fixed bin (35) ext;
       55 dcl  pvt$n_entries			fixed bin ext;
       56 
       57 /* Variables */
       58 
       59 dcl  called_find			bit (1) aligned init ("0"b);
       60 dcl  code				fixed bin (35);
       61 dcl  dir				char (168);
       62 dcl  dp				ptr;
       63 dcl  ent				char (32);
       64 dcl  1 mkinf			aligned like makeknown_info;
       65 dcl  pvid				bit (36) aligned;
       66 dcl  pvtx				fixed bin;
       67 dcl  segno			fixed bin;
       68 dcl  segptr			ptr;
       69 
       70 /* Entries */
       71 
       72 dcl  activate			entry (ptr, fixed bin (35)) returns (ptr);
       73 dcl  lock$dir_unlock		entry (ptr);
       74 dcl  makeknown_			entry (ptr, fixed bin, fixed bin, fixed bin (35));
       75 dcl  makeunknown_			entry (fixed bin, bit (36) aligned, bit (1) aligned, fixed bin (35));
       76 dcl  segment_mover$demand_segmove	entry (ptr, ptr, fixed bin, fixed bin (35));
       77 
       78 /* Misc */
       79 
       80 dcl  (addr, ptr, unspec)		builtin;
       81 
       82 
       83 /* These entries are not protected by any form of lock. It is assumed that the
       84*   caller is cooperating with the demounter in the setting of these bits. */
       85 	pvtx = a_pvtx;
       86 	pvt_arrayp = addr (pvt$array);
       87 	pvid = a_pvid;
       88 	code = 0;
       89 	if pvtx <= 0 | pvtx > pvt$n_entries then do;
       90 	     a_code = error_table_$bad_index;
       91 	     return;
       92 	end;
       93 	pvtep = addr (pvt_array (pvtx));		/* Address pvte */
       94 
       95 	if pvte.being_demounted | (pvte.pvid ^= pvid) then
       96 	     code = error_table_$argerr;
       97 	else if pvte.storage_system & pvte.used & pvid = pvte.pvid then
       98 	     pvte.vacating = "1"b;
       99 	else code = error_table_$argerr;
      100 
      101 	a_code = code;
      102 	return;
      103 
      104 stop_vacate: entry (a_pvtx, a_pvid, a_code);
      105 
      106 	pvt_arrayp = addr (pvt$array);
      107 	pvid = a_pvid;
      108 	pvtx = a_pvtx;
      109 	code = 0;
      110 	if pvtx <= 0 | pvtx > pvt$n_entries then do;
      111 	     a_code = error_table_$bad_index;
      112 	     return;
      113 	end;
      114 	pvtep = addr (pvt_array (pvtx));
      115 	if pvte.used & pvte.storage_system & pvte.vacating & (pvte.pvid = pvid) then
      116 	     pvte.vacating = "0"b;
      117 	else code = error_table_$argerr;
      118 	a_code = code;
      119 	return;
      120 
      121 move_seg_file: entry (a_dirname, a_ename, a_code);
      122 
      123 /* This entry starts a segmove on a seg given the name */
      124 
      125 	dir = a_dirname;
      126 	ent = a_ename;
      127 	code = 0;
      128 
      129 	call dc_find$obj_status_write_priv (dir, ent, DC_FIND_CHASE, FS_OBJ_SEG_MOVE, ep, code);
      130 	if code ^= 0 then go to finale;
      131 	called_find = "1"b;
      132 	go to join;				/* Merge with seg entry */
      133 
      134 move_seg_seg: entry (a_segptr, a_code);
      135 
      136 	segptr = a_segptr;
      137 	code = 0;
      138 	call dc_find$obj_status_write_priv_ptr (segptr, FS_OBJ_SEG_MOVE, ep, code);
      139 	if code ^= 0 then go to finale;
      140 
      141 join:	dp = ptr (ep, 0);
      142 
      143 	makeknown_infop = addr (mkinf);		/* Get local makeknown info */
      144 	unspec (makeknown_info) = ""b;		/* Clear all things we don't know about */
      145 	makeknown_info.uid = entry.uid;
      146 	makeknown_info.dirsw = entry.dirsw;
      147 	makeknown_info.entryp = ep;			/* Set up for makeknown */
      148 	call makeknown_ (makeknown_infop, segno, (0), code);
      149 	if code = 0 | code = error_table_$segknown then do;
      150 	     astep = activate (ep, code);
      151 						/* Get AST entry */
      152 	     if code = 0 then do;
      153 		aste.pack_ovfl = "1"b;		/* Cause seg mover to do thing */
      154 		call segment_mover$demand_segmove (astep, ep, segno, code);
      155 	     end;
      156 	     call makeunknown_ (segno, "0"b, ("0"b), (0));
      157 	end;
      158 	if called_find then call dc_find$finished (dp, "1"b);
      159 	else call lock$dir_unlock (dp);
      160 finale:	a_code = code;
      161 	return;
      162  /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      162 
      163  /* BEGIN include file dc_find_dcls.incl.pl1 */
  2     2 
  2     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  2     4 /* Added a few more, October 1984. */
  2     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  2     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  2     7 
  2     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  2     9 
  2    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  2    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  2    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  2    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  2    14 
  2    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  2    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  2    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  2    18 
  2    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  2    20 
  2    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  2    22 
  2    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  2    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  2    25 
  2    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  2    27 
  2    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  2    29 
  2    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  2    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  2    32 
  2    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  2    34 
  2    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  2    36 
  2    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  2    38 
  2    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  2    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  2    41 
  2    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  2    44 
  2    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  2    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  2    47 
  2    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  2    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  2    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  2    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  2    52 
  2    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  2    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  2    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  2    58 
  2    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  2    60 
  2    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  2    62 
  2    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  2    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  2    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  2    66 
  2    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  2    68 
  2    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  2    70 
  2    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  2    72 
  2    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    74 
  2    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  2    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  2    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  2    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  2    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  2    82 
  2    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  2    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  2    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  2    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  2    87 
  2    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  2    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  2    90 
  2    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  2    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  2    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  2    94 
  2    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  2    96 
  2    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  2    98 
  2    99 /* END include file dc_find_dcls.incl.pl1 */
      163 
      164  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  3     2 
  3     3 
  3     4 /* Template for an entry. Length = 38 words */
  3     5 
  3     6 dcl  ep ptr;
  3     7 
  3     8 dcl 1 entry based (ep) aligned,
  3     9 
  3    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  3    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  3    12 
  3    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  3    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  3    15 
  3    16     2 uid bit (36),					/* unique id of entry */
  3    17 
  3    18     2 dtem bit (36),				/* date-time entry modified */
  3    19 
  3    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  3    21     2 pad0 bit (17),
  3    22     2 nnames fixed bin (17),				/* number of names for this entry */
  3    23 
  3    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  3    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  3    26 
  3    27     2 author,					/* user who created branch */
  3    28       3 pers_rp bit (18),				/* name of user who created branch */
  3    29       3 proj_rp bit (18),				/* project of user who created branch */
  3    30 
  3    31       3 tag char (1),				/* tag of user who created branch */
  3    32       3 pad1 char (3),
  3    33 
  3    34     2 primary_name bit (504),				/* first name on name list */
  3    35 
  3    36     2 dtd bit (36),					/* date time dumped */
  3    37 
  3    38     2 pad2 bit (36),
  3    39 
  3    40 
  3    41 /* the declarations below are for branch only */
  3    42 
  3    43 
  3    44     2 pvid bit (36),				/* physical volume id */
  3    45 
  3    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  3    47     2 pad3 bit (18),
  3    48 
  3    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  3    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  3    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  3    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  3    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  3    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  3    55     2 audit_flag bit (1),				/* segment must be audited for security */
  3    56     2 security_oosw bit (1),				/* security out of service switch */
  3    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  3    58     2 master_dir bit (1),				/* TRUE for master directory */
  3    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  3    60     2 pad4 bit (11),
  3    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  3    62 
  3    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  3    64 
  3    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  3    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  3    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  3    68 
  3    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  3    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  3    71 
  3    72     2 bc_author,					/* user who last set the bit count */
  3    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  3    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  3    75 
  3    76       3 tag char (1),				/* tag of user who set the bit count */
  3    77       3 pad5 bit (2),
  3    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  3    79 
  3    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  3    81 
  3    82     2 pad6 bit (36),
  3    83 
  3    84     2 checksum bit (36),				/* checksum from dtd */
  3    85 
  3    86     2 owner bit (36);				/* uid of containing directory */
  3    87 
  3    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      164 
      165  /* BEGIN include file fs_obj_access_codes.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(88-05-12,Lippard), approve(88-05-02,MCR7881),
  4     6*     audit(88-06-16,Fawcett), install(88-08-02,MR12.2-1074):
  4     7*     Changed to add the FS_OBJ_AUDIT_FLAG_MOD constant.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 
  4    11 /* The possible events within the file system; access codes and
  4    12*   detailed operation codes.  October 1984, Keith Loepere. */
  4    13 
  4    14 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  4    15 
  4    16 /* Major file system operations. */
  4    17 
  4    18 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
  4    19 dcl  access_operations_$fs_obj_delete bit (36) aligned ext;
  4    20 dcl  access_operations_$fs_obj_initiate bit (36) aligned ext;
  4    21 dcl  access_operations_$fs_obj_terminate bit (36) aligned ext;
  4    22 dcl  access_operations_$fs_obj_contents_read bit (36) aligned ext;
  4    23 dcl  access_operations_$fs_obj_contents_mod bit (36) aligned ext;
  4    24 dcl  access_operations_$fs_obj_prop_read bit (36) aligned ext;
  4    25 dcl  access_operations_$fs_obj_attr_mod bit (36) aligned ext;
  4    26 dcl  access_operations_$fs_obj_status_mod bit (36) aligned ext;
  4    27 dcl  access_operations_$fs_obj_access_mod bit (36) aligned ext;
  4    28 
  4    29 /* Detailed operations. */
  4    30 
  4    31 dcl  FS_OBJ_CONNECT fixed bin (18) uns init (1) static options (constant);
  4    32 dcl  FS_OBJ_BC_MOD fixed bin (18) uns init (2) static options (constant);
  4    33 dcl  FS_OBJ_TRUNCATE fixed bin (18) uns init (3) static options (constant);
  4    34 dcl  FS_OBJ_ACL_MOD fixed bin (18) uns init (4) static options (constant);
  4    35 dcl  FS_OBJ_RING_MOD fixed bin (18) uns init (5) static options (constant);
  4    36 dcl  FS_OBJ_ACL_RING_MOD fixed bin (18) uns init (6) static options (constant);
  4    37 dcl  FS_OBJ_RENAME fixed bin (18) uns init (7) static options (constant);
  4    38 dcl  FS_OBJ_COPY_SW_MOD fixed bin (18) uns init (8) static options (constant);
  4    39 dcl  FS_OBJ_DAMAGED_SW_MOD fixed bin (18) uns init (9) static options (constant);
  4    40 dcl  FS_OBJ_DNZP_MOD fixed bin (18) uns init (10) static options (constant);
  4    41 dcl  FS_OBJ_ENTRY_BOUND_MOD fixed bin (18) uns init (11) static options (constant);
  4    42 dcl  FS_OBJ_MAX_LEN_MOD fixed bin (18) uns init (12) static options (constant);
  4    43 dcl  FS_OBJ_SAFETY_SW_MOD fixed bin (18) uns init (13) static options (constant);
  4    44 dcl  FS_OBJ_SYNC_SW_MOD fixed bin (18) uns init (14) static options (constant);
  4    45 dcl  FS_OBJ_VOL_DUMP_SW_MOD fixed bin (18) uns init (15) static options (constant);
  4    46 dcl  FS_OBJ_AUTHOR_MOD fixed bin (18) uns init (16) static options (constant);
  4    47 dcl  FS_OBJ_BC_AUTHOR_MOD fixed bin (18) uns init (17) static options (constant);
  4    48 dcl  FS_OBJ_BACKUP_TIMES_MOD fixed bin (18) uns init (18) static options (constant);
  4    49 dcl  FS_OBJ_DATES_MOD fixed bin (18) uns init (19) static options (constant);
  4    50 dcl  FS_OBJ_DT_DUMPED_MOD fixed bin (18) uns init (20) static options (constant);
  4    51 dcl  FS_OBJ_FOR_RELOADER_MOD fixed bin (18) uns init (21) static options (constant);
  4    52 dcl  FS_OBJ_SONS_LVID_MOD fixed bin (18) uns init (22) static options (constant);
  4    53 dcl  FS_OBJ_SOOS_MOD fixed bin (18) uns init (23) static options (constant);
  4    54 dcl  FS_OBJ_MOVE_QUOTA fixed bin (18) uns init (24) static options (constant);
  4    55 dcl  FS_OBJ_CORRECT_QUSED fixed bin (18) uns init (25) static options (constant);
  4    56 dcl  FS_OBJ_DIR_SALVAGE fixed bin (18) uns init (26) static options (constant);
  4    57 dcl  FS_OBJ_MDIR_QUOTA_MOD fixed bin (18) uns init (27) static options (constant);
  4    58 dcl  FS_OBJ_QUOTA_MOD fixed bin (18) uns init (28) static options (constant);
  4    59 dcl  FS_OBJ_QUOTA_RELOAD fixed bin (18) uns init (29) static options (constant);
  4    60 dcl  FS_OBJ_RECLASSIFY fixed bin (18) uns init (30) static options (constant);
  4    61 dcl  FS_OBJ_RECLASSIFY_NODE fixed bin (18) uns init (31) static options (constant);
  4    62 dcl  FS_OBJ_SEG_MOVE fixed bin (18) uns init (32) static options (constant);
  4    63 dcl  FS_OBJ_TRP_MOD fixed bin (18) uns init (33) static options (constant);
  4    64 dcl  FS_OBJ_VOLUME_RETRIEVE fixed bin (18) uns init (34) static options (constant);
  4    65 dcl  FS_OBJ_IACL_MOD fixed bin (18) uns init (35) static options (constant);
  4    66 dcl  FS_OBJ_CREATE_BRANCH fixed bin (18) uns init (36) static options (constant);
  4    67 dcl  FS_OBJ_AUDIT_FLAG_MOD fixed bin (18) uns init (37) static options (constant);
  4    68 
  4    69 /* END include file fs_obj_access_codes.incl.pl1 */
      165 
      166  /*  BEGIN INCLUDE FILE - - - makeknown_info.incl.pl1 - - - last modified March 1975 by R. Bratt - - - */
  5     2 /* Modified October 1984 for explicit activate flag and to remove 
  5     3*   detectable flag, Keith Loepere. */
  5     4 
  5     5 dcl  makeknown_infop ptr;
  5     6 
  5     7 dcl 1 makeknown_info aligned based (makeknown_infop),
  5     8     2 uid bit (36) aligned,
  5     9     2 entryp ptr unaligned,
  5    10     2 flags unaligned,
  5    11       3 dirsw bit (1),
  5    12       3 rsw bit (1),
  5    13       3 allow_write bit (1),
  5    14       3 priv_init bit (1),
  5    15       3 audit bit (1),
  5    16       3 activate bit (1);			/* Use only for directory initiation within directory control */
  5    17 
  5    18 /*   END INCLUDE FILE makeknown_info.incl.pl1 - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      166 
      167  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  6     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6     8*     Add the support for subvolumes
  6     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  6    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  6    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  6    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  6    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  6    14*     Added inconsistent_dbm bit for determining the status of volume
  6    15*     dumper bit maps.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18      dcl	   pvt$array	      aligned external;
  6    19      dcl	   pvt$max_n_entries      fixed bin external;
  6    20 
  6    21      dcl	   pvt_arrayp	      ptr;
  6    22      dcl	   pvtep		      ptr;
  6    23 
  6    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  6    25 
  6    26      dcl	   1 pvte		      based (pvtep) aligned,
  6    27 
  6    28 	     2 pvid	      bit (36),		/* physical volume ID */
  6    29 
  6    30 	     2 lvid	      bit (36),		/* logical volume ID */
  6    31 
  6    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  6    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  6    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  6    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  6    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  6    37 	     2 pad3	      bit (2) unaligned,
  6    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  6    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  6    40 
  6    41 
  6    42 
  6    43 	     2 devname	      char (4),		/* device name */
  6    44 
  6    45 	     (2 device_type	      fixed bin (8),	/* device type */
  6    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  6    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  6    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  6    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  6    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  6    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  6    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  6    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  6    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  6    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  6    56 	     2 scav_check_address
  6    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  6    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  6    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  6    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  6    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  6    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  6    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  6    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  6    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  6    66 
  6    67 
  6    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  6    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  6    70 
  6    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  6    72 
  6    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  6    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  6    75 
  6    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  6    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  6    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  6    79 	     2 records_per_cyl    fixed bin,
  6    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  6    81 	     2 sv_name            char (2) aligned,
  6    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  6    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  6    84 
  6    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  6    86 	     2 pad2	      bit (18) unaligned,
  6    87 
  6    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  6    89 
  6    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  6    91 
  6    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  6    93 
  6    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  6    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  6    96 
  6    97 
  6    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  6    99 
  6   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  6   101 
  6   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  6   103 
  6   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  6   105 
  6   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  6   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  6   108 
  6   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  6   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  6   111 
  6   112 
  6   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  6   114 	   VOLMAP_ASYNC_READ      init (1),
  6   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  6   116 
  6   117 
  6   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      167 
      168      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.7  vacate_pv.pl1                     >spec>install>1110>vacate_pv.pl1
162          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
163          2    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
164          3    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
165          4    08/04/88  2054.1  fs_obj_access_codes.incl.pl1      >ldd>include>fs_obj_access_codes.incl.pl1
166          5    01/30/85  1523.9  makeknown_info.incl.pl1           >ldd>include>makeknown_info.incl.pl1
167          6    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_CHASE                   000005 constant        fixed bin(1,0)           initial dcl 2-10 set ref 129*
FS_OBJ_SEG_MOVE                 000000 constant        fixed bin(18,0)          initial unsigned dcl 4-62 set ref 129* 138*
a_code                                 parameter       fixed bin(35,0)          dcl 43 set ref 27 90* 101* 104 111* 118* 121 134
                                                                                  160*
a_dirname                              parameter       char                     packed unaligned dcl 44 ref 121 125
a_ename                                parameter       char                     packed unaligned dcl 45 ref 121 126
a_pvid                                 parameter       bit(36)                  dcl 46 ref 27 87 104 107
a_pvtx                                 parameter       fixed bin(17,0)          dcl 47 ref 27 85 104 108
a_segptr                               parameter       pointer                  dcl 48 ref 134 136
activate                        000020 constant        entry                    external dcl 72 ref 150
addr                                                   builtin function         dcl 80 ref 86 93 106 114 143
aste                                   based           structure                level 1 dcl 1-11
astep                           000176 automatic       pointer                  dcl 1-9 set ref 150* 153 154*
being_demounted           4(23)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 ref 95
called_find                     000100 automatic       bit(1)                   initial dcl 59 set ref 59* 131* 158
code                            000101 automatic       fixed bin(35,0)          dcl 60 set ref 88* 95* 99* 101 109* 117* 118 127*
                                                                                  129* 130 137* 138* 139 148* 149 149 150* 152 154*
                                                                                  160
dc_find$finished                000032 constant        entry                    external dcl 2-33 ref 158
dc_find$obj_status_write_priv   000034 constant        entry                    external dcl 2-84 ref 129
dc_find$obj_status_write_priv_ptr
                                000036 constant        entry                    external dcl 2-85 ref 138
dir                             000102 automatic       char(168)                packed unaligned dcl 61 set ref 125* 129*
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 3-8 in procedure "vacate_pv" ref 146
dirsw                     2            based           bit(1)                   level 3 in structure "makeknown_info" packed packed
                                                                                  unaligned dcl 5-7 in procedure "vacate_pv" set ref
                                                                                  146*
dp                              000154 automatic       pointer                  dcl 62 set ref 141* 158* 159*
ent                             000156 automatic       char(32)                 packed unaligned dcl 63 set ref 126* 129*
entry                                  based           structure                level 1 dcl 3-8
entryp                    1            based           pointer                  level 2 packed packed unaligned dcl 5-7 set ref 147*
ep                              000200 automatic       pointer                  dcl 3-6 set ref 129* 138* 141 145 146 147 150* 154*
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 52 ref 95 99 117
error_table_$bad_index          000012 external static fixed bin(33,0)          dcl 53 ref 90 111
error_table_$segknown           000014 external static fixed bin(35,0)          dcl 54 ref 149
flags                     2            based           structure                level 2 packed packed unaligned dcl 5-7
lock$dir_unlock                 000022 constant        entry                    external dcl 73 ref 159
makeknown_                      000024 constant        entry                    external dcl 74 ref 148
makeknown_info                         based           structure                level 1 dcl 5-7 set ref 144*
makeknown_infop                 000202 automatic       pointer                  dcl 5-5 set ref 143* 144 145 146 147 148*
makeunknown_                    000026 constant        entry                    external dcl 75 ref 156
mkinf                           000166 automatic       structure                level 1 dcl 64 set ref 143
pack_ovfl                13(20)        based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  153*
ptr                                                    builtin function         dcl 80 ref 141
pvid                            000171 automatic       bit(36)                  dcl 65 in procedure "vacate_pv" set ref 87* 95 97
                                                                                  107* 115
pvid                                   based           bit(36)                  level 2 in structure "pvte" dcl 6-26 in procedure
                                                                                  "vacate_pv" ref 95 97 115
pvt$array                       000040 external static fixed bin(17,0)          dcl 6-18 set ref 86 106
pvt$n_entries                   000016 external static fixed bin(17,0)          dcl 55 ref 89 110
pvt_array                              based           structure                array level 1 dcl 6-24 set ref 93 114
pvt_arrayp                      000204 automatic       pointer                  dcl 6-21 set ref 86* 93 106* 114
pvte                                   based           structure                level 1 dcl 6-26
pvtep                           000206 automatic       pointer                  dcl 6-22 set ref 93* 95 95 97 97 97 97 114* 115 115
                                                                                  115 115 115
pvtx                            000172 automatic       fixed bin(17,0)          dcl 66 set ref 85* 89 89 93 108* 110 110 114
segment_mover$demand_segmove    000030 constant        entry                    external dcl 76 ref 154
segno                           000173 automatic       fixed bin(17,0)          dcl 67 set ref 148* 154* 156*
segptr                          000174 automatic       pointer                  dcl 68 set ref 136* 138*
storage_system            4(19)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 ref 97 115
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 3-8 in procedure
                                                                                  "vacate_pv" ref 145
uid                                    based           bit(36)                  level 2 in structure "makeknown_info" dcl 5-7
                                                                                  in procedure "vacate_pv" set ref 145*
unspec                                                 builtin function         dcl 80 set ref 144*
used                      4(18)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 ref 97 115
vacating                  4(31)        based           bit(1)                   level 2 packed packed unaligned dcl 6-26 set ref 97*
                                                                                  115 115*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 2-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 2-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 2-13
FS_OBJ_ACL_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 4-34
FS_OBJ_ACL_RING_MOD                    internal static fixed bin(18,0)          initial unsigned dcl 4-36
FS_OBJ_AUDIT_FLAG_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 4-67
FS_OBJ_AUTHOR_MOD                      internal static fixed bin(18,0)          initial unsigned dcl 4-46
FS_OBJ_BACKUP_TIMES_MOD                internal static fixed bin(18,0)          initial unsigned dcl 4-48
FS_OBJ_BC_AUTHOR_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 4-47
FS_OBJ_BC_MOD                          internal static fixed bin(18,0)          initial unsigned dcl 4-32
FS_OBJ_CONNECT                         internal static fixed bin(18,0)          initial unsigned dcl 4-31
FS_OBJ_COPY_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 4-38
FS_OBJ_CORRECT_QUSED                   internal static fixed bin(18,0)          initial unsigned dcl 4-55
FS_OBJ_CREATE_BRANCH                   internal static fixed bin(18,0)          initial unsigned dcl 4-66
FS_OBJ_DAMAGED_SW_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 4-39
FS_OBJ_DATES_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 4-49
FS_OBJ_DIR_SALVAGE                     internal static fixed bin(18,0)          initial unsigned dcl 4-56
FS_OBJ_DNZP_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 4-40
FS_OBJ_DT_DUMPED_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 4-50
FS_OBJ_ENTRY_BOUND_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 4-41
FS_OBJ_FOR_RELOADER_MOD                internal static fixed bin(18,0)          initial unsigned dcl 4-51
FS_OBJ_IACL_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 4-65
FS_OBJ_MAX_LEN_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 4-42
FS_OBJ_MDIR_QUOTA_MOD                  internal static fixed bin(18,0)          initial unsigned dcl 4-57
FS_OBJ_MOVE_QUOTA                      internal static fixed bin(18,0)          initial unsigned dcl 4-54
FS_OBJ_QUOTA_MOD                       internal static fixed bin(18,0)          initial unsigned dcl 4-58
FS_OBJ_QUOTA_RELOAD                    internal static fixed bin(18,0)          initial unsigned dcl 4-59
FS_OBJ_RECLASSIFY                      internal static fixed bin(18,0)          initial unsigned dcl 4-60
FS_OBJ_RECLASSIFY_NODE                 internal static fixed bin(18,0)          initial unsigned dcl 4-61
FS_OBJ_RENAME                          internal static fixed bin(18,0)          initial unsigned dcl 4-37
FS_OBJ_RING_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 4-35
FS_OBJ_SAFETY_SW_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 4-43
FS_OBJ_SONS_LVID_MOD                   internal static fixed bin(18,0)          initial unsigned dcl 4-52
FS_OBJ_SOOS_MOD                        internal static fixed bin(18,0)          initial unsigned dcl 4-53
FS_OBJ_SYNC_SW_MOD                     internal static fixed bin(18,0)          initial unsigned dcl 4-44
FS_OBJ_TRP_MOD                         internal static fixed bin(18,0)          initial unsigned dcl 4-63
FS_OBJ_TRUNCATE                        internal static fixed bin(18,0)          initial unsigned dcl 4-33
FS_OBJ_VOLUME_RETRIEVE                 internal static fixed bin(18,0)          initial unsigned dcl 4-64
FS_OBJ_VOL_DUMP_SW_MOD                 internal static fixed bin(18,0)          initial unsigned dcl 4-45
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 6-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 6-113
access_operations_$fs_obj_access_mod   external static bit(36)                  dcl 4-27
access_operations_$fs_obj_attr_mod     external static bit(36)                  dcl 4-25
access_operations_$fs_obj_contents_mod external static bit(36)                  dcl 4-23
access_operations_$fs_obj_contents_read
                                       external static bit(36)                  dcl 4-22
access_operations_$fs_obj_create       external static bit(36)                  dcl 4-18
access_operations_$fs_obj_delete       external static bit(36)                  dcl 4-19
access_operations_$fs_obj_initiate     external static bit(36)                  dcl 4-20
access_operations_$fs_obj_prop_read    external static bit(36)                  dcl 4-24
access_operations_$fs_obj_status_mod   external static bit(36)                  dcl 4-26
access_operations_$fs_obj_terminate    external static bit(36)                  dcl 4-21
asta                                   based           bit(432)                 array dcl 1-86
aste_part                              based           structure                level 1 dcl 1-89
dc_find$dir_for_append          000000 constant        entry                    external dcl 2-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 2-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 2-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 2-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 2-21
dc_find$dir_read                000000 constant        entry                    external dcl 2-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 2-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 2-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 2-28
dc_find$dir_write               000000 constant        entry                    external dcl 2-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 2-31
dc_find$link_target             000000 constant        entry                    external dcl 2-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 2-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 2-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 2-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 2-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 2-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 2-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 2-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 2-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 2-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 2-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 2-51
dc_find$obj_delete              000000 constant        entry                    external dcl 2-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 2-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 2-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 2-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 2-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 2-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 2-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 2-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 2-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 2-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 2-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 2-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 2-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 2-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 2-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 2-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 2-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 2-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 2-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 2-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 2-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 2-83
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 2-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 2-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 2-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 2-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 2-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 2-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 2-95
dc_find$seg_fault               000000 constant        entry                    external dcl 2-97
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 6-19
seg_aste                               based           structure                level 1 dcl 1-96

NAMES DECLARED BY EXPLICIT CONTEXT.
finale                          000460 constant        label                    dcl 160 ref 130 139
join                            000312 constant        label                    dcl 141 ref 132
move_seg_file                   000163 constant        entry                    external dcl 121
move_seg_seg                    000255 constant        entry                    external dcl 134
stop_vacate                     000105 constant        entry                    external dcl 104
vacate_pv                       000017 constant        entry                    external dcl 27

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       676         740     464         706
Length      1246     464        42         272     212           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vacate_pv                           158 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vacate_pv                000100 called_find                 vacate_pv
                         000101 code                        vacate_pv
                         000102 dir                         vacate_pv
                         000154 dp                          vacate_pv
                         000156 ent                         vacate_pv
                         000166 mkinf                       vacate_pv
                         000171 pvid                        vacate_pv
                         000172 pvtx                        vacate_pv
                         000173 segno                       vacate_pv
                         000174 segptr                      vacate_pv
                         000176 astep                       vacate_pv
                         000200 ep                          vacate_pv
                         000202 makeknown_infop             vacate_pv
                         000204 pvt_arrayp                  vacate_pv
                         000206 pvtep                       vacate_pv

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
activate                      dc_find$finished              dc_find$obj_status_write_priv
dc_find$obj_status_write_priv_ptr                           lock$dir_unlock               makeknown_
makeunknown_                  segment_mover$demand_segmove

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$bad_index        error_table_$segknown         pvt$array
pvt$n_entries




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     59 000010        27 000013        85 000030        86 000033        87 000036        88 000040        89 000041
     90 000045        91 000047        93 000050        95 000053        97 000064        99 000076       101 000100
    102 000102       104 000103       106 000116       107 000121       108 000124       109 000126       110 000127
    111 000132       112 000134       114 000135       115 000140       117 000152       118 000154       119 000156
    121 000157       125 000207       126 000215       127 000222       129 000223       130 000244       131 000246
    132 000250       134 000251       136 000266       137 000272       138 000273       139 000310       141 000312
    143 000314       144 000316       145 000321       146 000324       147 000330       148 000331       149 000347
    150 000354       152 000367       153 000371       154 000374       156 000411       158 000433       159 000451
    160 000460       161 000462


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
