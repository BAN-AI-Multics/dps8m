	COMPILATION LISTING OF SEGMENT hc_dm_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1009.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-07-17,CLJones), approve(86-01-26,MCR7330),
       13*     audit(86-01-16,Tague), install(86-07-17,MR12.0-1097):
       14*     to perform security auditing.
       15*  2) change(86-07-10,Dupuis), approve(86-01-26,MCR7330),
       16*     audit(86-07-14,GDixon), install(86-07-17,MR12.0-1097):
       17*     Changed the 85-07-17 auditing code so that it wouldn't take a page fault
       18*     while it had the page table locked, and to audit the GRANT'ing in all
       19*     cases.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 /* format: style5,^indcomtxt */
       24 
       25 hc_dm_util$activate:
       26         proc (Ptsi);
       27 
       28 /* DESCRIPTION:
       29*Utility routines for Data Management Support
       30*
       31*activate - note activation of a synchronized segment of a given size.
       32*
       33*allocate_journal_index - get ring-2 Data Management a free journal index.
       34*
       35*check_activate - determine whether a synchronized segment of a given size
       36*	   can be activated.
       37*
       38*deactivate - note deactivation of a synchronized segment of a given size.
       39*
       40*free_journal_index - free a previously allocated journal index.
       41*
       42*get_journal_stamp - given a journal index, returns the current time stamp.
       43* 
       44*get_n_journals - return the number of journal slots allocated, i.e,
       45*	   dm_journal.n_journal.
       46*
       47*get_max_held_per_journal - returns the value of dm_journal.max_held_per_journal
       48*
       49*set_journal_stamp - set the time stamp of a journal for Page Control.
       50*
       51*validate_bj_uid - Checks the supplied uid against the uid in the 
       52*	   dm_journal_seg_.
       53**/
       54 
       55 /* HISTORY:
       56*Written October 1982 by J. Bongiovanni.
       57*Modified:
       58*May 1983 by E. N. Kittlitz to fix free to not write Journal_Idx.
       59*05/13/85 by R. Michael Tague to use limit_covert_channel on
       60*	   calls to $allocate_journal_index.  Upgraded access check in
       61*	   set_journal_stamp and free_journal_index to check for seg privs.
       62*	   Added dm_journal_seg_ locking in set_time_stamp.  Generally
       63*	   cleaned up dm_journal_seg_ locking for all entries.  Added the
       64*	   entries $validate_bj_uid, $get_journal_stamp, $get_n_journals,
       65*	   and $get_max_held_per_journal so that ring-2 DM would not need
       66*	   to read the dm_journal_seg_.  Reformatted.
       67*05/20/85 by R. Michael Tague to get the AIM checking on $free_journal, 
       68*             $get_journal_stamp, and $validate_journal_stamp right.
       69**/
       70 
       71 /*  Parameter  */
       72 
       73         dcl     Code		fixed bin (35) parameter;
       74 					      /* Standard Error Code */
       75         dcl     Journal_Idx		fixed bin parameter;
       76 					      /* Journal Index */
       77         dcl     Ptsi		fixed bin (3) parameter;
       78 					      /* Page Table Size index */
       79         dcl     Time_Stamp		fixed bin (71) parameter;
       80 					      /* New time stamp */
       81         dcl     Uid			bit (36) aligned;
       82 					      /* Ring-2 Unique ID for Journal */
       83 
       84 /*  Automatic  */
       85 
       86         dcl     code		fixed bin (35);
       87         dcl     journal_idx		fixed bin;
       88         dcl     jx			fixed bin;
       89         dcl     me			char (40);
       90         dcl     old_mask		fixed bin (71);
       91         dcl     ptwp		ptr;
       92         dcl     time_stamp		fixed bin (71);
       93         dcl     uid			bit (36) aligned;
       94         dcl     validated		bit (1) aligned;
       95 
       96 /*  External  */
       97 
       98         dcl     access_operations_$dm_journal_allocate
       99 				bit (36) aligned ext static;
      100         dcl     access_operations_$dm_journal_free
      101 				bit (36) aligned ext static;
      102         dcl     access_operations_$dm_journal_read_attr
      103 				bit (36) aligned ext static;
      104         dcl     access_operations_$dm_journal_write_attr
      105 				bit (36) aligned ext static;
      106 
      107         dcl     error_table_$bad_arg	fixed bin (35) external;
      108         dcl     error_table_$dm_journal_pages_held
      109 				fixed bin (35) external;
      110         dcl     error_table_$dm_not_enabled
      111 				fixed bin (35) external;
      112         dcl     error_table_$invalid_dm_journal_index
      113 				fixed bin (35) external;
      114         dcl     error_table_$no_journals_free
      115 				fixed bin (35) external;
      116         dcl     error_table_$synch_seg_limit
      117 				fixed bin (35) external;
      118         dcl     pds$access_authorization
      119 				bit (72) aligned external;
      120         dcl     pds$validation_level	fixed bin (3) external;
      121         dcl     sst$dm_enabled	bit (1) aligned external;
      122         dcl     tc_data$end_of_time	fixed bin (71) external;
      123 
      124 /*  Entry  */
      125 
      126         dcl     access_audit_$log_obj_class
      127 				entry options (variable);
      128         dcl     limit_covert_channel	entry (fixed bin);
      129         dcl     lock$lock_fast	entry (ptr);
      130         dcl     lock$unlock_fast	entry (ptr);
      131         dcl     page_synch$unlink_journal
      132 				entry (fixed bin);
      133         dcl     pmut$lock_ptl		entry (fixed bin (71), ptr);
      134         dcl     pmut$unlock_ptl	entry (fixed bin (71), ptr);
      135         dcl     (read_allowed_, write_allowed_, read_write_allowed_)
      136 				entry (bit (72) aligned,
      137 				bit (72) aligned)
      138 				returns (bit (1) aligned);
      139 
      140 /*  Builtin  */
      141 
      142         dcl     addr		builtin;
      143         dcl     char		builtin;
      144         dcl     clock		builtin;
      145         dcl     divide		builtin;
      146         dcl     ltrim		builtin;
      147 
      148 /*  Constants  */
      149 
      150         dcl     DENY		bit (1) aligned static
      151 				options (constant) init ("0"b);
      152         dcl     GRANT		bit (1) aligned static
      153 				options (constant) init ("1"b);
      154 
      155 /* ************************************************************************
      156*   * $activate - Notes activation of a synchronized segment. It is	    *
      157*   * assumed that that Global AST Lock is held by the process.	    *
      158*   ************************************************************************ */
      159 
      160         dm_journal_segp = addr (dm_journal_seg_$);
      161         dm_journal.per_aste_pool (Ptsi).n_active =
      162 	  dm_journal.per_aste_pool (Ptsi).n_active + 1;
      163         return;
      164 
      165 /* ************************************************************************
      166*   * $allocate_journal_index - give ring-2 an unused journal index.	    *
      167*   * Possible covert channel corrected by call to limit_covert_channel.   *
      168*   ************************************************************************ */
      169 
      170 allocate_journal_index:
      171         entry (Uid, Journal_Idx, Code);
      172 
      173         if ^sst$dm_enabled then
      174 	      do;
      175 	      Code = error_table_$dm_not_enabled;
      176 	      return;
      177 	      end;
      178 
      179         Journal_Idx = 0;
      180         uid = Uid;
      181         journal_idx = 0;
      182         me = "hc_dm_util$allocate_journal_index";
      183         code = 0;
      184 
      185         if uid = ""b then
      186 	      do;
      187 	      Code = error_table_$bad_arg;
      188 	      return;
      189 	      end;
      190 
      191         call limit_covert_channel (1);
      192         dm_journal_segp = addr (dm_journal_seg_$);
      193         call lock$lock_fast (addr (dm_journal.lock));
      194         dm_journal.allocate_calls = dm_journal.allocate_calls + 1;
      195         if dm_journal.n_journals <= dm_journal.n_journals_inuse then
      196 	      code = error_table_$no_journals_free;
      197         else
      198 	      do;
      199 	      do jx = 1 to dm_journal.n_journals
      200 		while (dm_journal.per_journal (jx).uid ^= ""b);
      201 	      end;
      202 	      if jx > dm_journal.n_journals then
      203 		    code = error_table_$no_journals_free;
      204 	      else
      205 		    do;
      206 		    dm_per_journalp = addr (dm_journal.per_journal (jx));
      207 		    dm_journal.n_journals_inuse =
      208 		        dm_journal.n_journals_inuse + 1;
      209 		    dm_per_journal.time_stamp = clock ();
      210 		    dm_per_journal.access_class = pds$access_authorization;
      211 		    dm_per_journal.uid = uid;
      212 		    call RECOMPUTE_THRESH;
      213 		    journal_idx = jx;
      214 		    call AUDIT (GRANT,
      215 		        access_operations_$dm_journal_allocate, journal_idx,
      216 		        dm_per_journal);
      217 		    end;
      218 	      end;
      219 
      220         call lock$unlock_fast (addr (dm_journal.lock));
      221         Journal_Idx = journal_idx;
      222         Code = code;
      223         return;
      224 
      225 /* ************************************************************************
      226*   * $check_activate - checks whether a synchronized segment of a given   *
      227*   * size may be activated.  It is assumed that the Global AST Lock is    *
      228*   * held.						    *
      229*   ************************************************************************ */
      230 
      231 check_activate:
      232         entry (Ptsi, Code);
      233 
      234         if ^sst$dm_enabled then
      235 	      do;
      236 	      Code = error_table_$dm_not_enabled;
      237 	      return;
      238 	      end;
      239 
      240         Code = 0;
      241 
      242         dm_journal_segp = addr (dm_journal_seg_$);
      243         dm_journal.activate_calls = dm_journal.activate_calls + 1;
      244         if dm_journal.per_aste_pool (Ptsi).n_active
      245 	  >= dm_journal.per_aste_pool (Ptsi).threshold then
      246 	      do;
      247 	      dm_journal.activate_denied = dm_journal.activate_denied + 1;
      248 	      Code = error_table_$synch_seg_limit;
      249 	      end;
      250         return;
      251 
      252 /* ************************************************************************
      253*   * $deactivate - Note deactivation of a synchronized segment.	    *
      254*   ************************************************************************ */
      255 
      256 deactivate:
      257         entry (Ptsi);
      258 
      259         dm_journal_segp = addr (dm_journal_seg_$);
      260         dm_journal.deactivate_calls = dm_journal.deactivate_calls + 1;
      261         dm_journal.per_aste_pool (Ptsi).n_active =
      262 	  dm_journal.per_aste_pool (Ptsi).n_active - 1;
      263         return;
      264 
      265 /* ************************************************************************
      266*   * $free_journal_index - frees a previously allocated journal index.    *
      267*   * Authorization check is performed.				    *
      268*   ************************************************************************ */
      269 
      270 free_journal_index:
      271         entry (Journal_Idx, Code);
      272 
      273         if ^sst$dm_enabled then
      274 	      do;
      275 	      Code = error_table_$dm_not_enabled;
      276 	      return;
      277 	      end;
      278 
      279         journal_idx = Journal_Idx;
      280         me = "hc_dm_util$free_journal_index";
      281         code = 0;
      282 
      283         dm_journal_segp = addr (dm_journal_seg_$);
      284         call lock$lock_fast (addr (dm_journal.lock));
      285         dm_journal.free_calls = dm_journal.free_calls + 1;
      286 
      287         if (journal_idx <= 0) | (journal_idx > dm_journal.n_journals) then
      288 	      code = error_table_$invalid_dm_journal_index;
      289         else
      290 	      do;
      291 	      dm_per_journalp = addr (dm_journal.per_journal (journal_idx));
      292 	      if dm_per_journal.uid = ""b then
      293 		    code = error_table_$invalid_dm_journal_index;
      294 	      else if
      295 		^(
      296 		read_write_allowed_ (pds$access_authorization,
      297 		dm_per_journal.access_class)
      298 		| (addr (pds$access_authorization) -> aim_template.seg))
      299 		then
      300 		    do;
      301 		    call AUDIT (DENY, access_operations_$dm_journal_free,
      302 		        journal_idx, dm_per_journal);
      303 		    code = error_table_$invalid_dm_journal_index;
      304 		    end;
      305 	      else
      306 		    do;
      307 		    call AUDIT (GRANT,
      308 		         access_operations_$dm_journal_free,
      309 		         journal_idx, dm_per_journal);
      310 		    code = error_table_$dm_journal_pages_held;
      311 		    call pmut$lock_ptl (old_mask, ptwp);
      312 		    if dm_per_journal.n_held = 0 then
      313 			  do;
      314 			  dm_per_journal.time_stamp = tc_data$end_of_time;
      315 			  dm_per_journal.uid = ""b;
      316 			  dm_per_journal.access_class = ""b;
      317 			  code = 0;
      318 			  end;
      319 		    call pmut$unlock_ptl (old_mask, ptwp);
      320 		    if code = 0 then
      321 			  do;
      322 			  dm_journal.n_journals_inuse =
      323 			      dm_journal.n_journals_inuse - 1;
      324 			  call RECOMPUTE_THRESH;
      325 			  end;
      326 		    end;
      327 	      end;
      328         call lock$unlock_fast (addr (dm_journal.lock));
      329         Code = code;
      330         return;
      331 
      332 /* ************************************************************************
      333*   * get_journal_stamp - Returns the value of the journal stamp for a     *
      334*   * given dm_journal_seg_ index.  An access class check is performed	    *
      335*   * before the information is returned.			    *
      336*   ************************************************************************ */
      337 
      338 get_journal_stamp:
      339         entry (Journal_Idx) returns (fixed bin (71));
      340 
      341         journal_idx = Journal_Idx;
      342         time_stamp = 0;
      343         me = "hc_dm_util$get_journal_stamp";
      344 
      345         if ^sst$dm_enabled then
      346 	      return (time_stamp);
      347 
      348         dm_journal_segp = addr (dm_journal_seg_$);
      349         call lock$lock_fast (addr (dm_journal.lock));
      350         if (journal_idx > 0) & (journal_idx <= dm_journal.n_journals) then
      351 	      do;
      352 	      dm_per_journalp = addr (dm_journal.per_journal (journal_idx));
      353 	      if dm_per_journal.uid ^= ""b then
      354 		    if read_allowed_ (pds$access_authorization,
      355 		        dm_per_journal.access_class)
      356 		        | (addr (pds$access_authorization)
      357 		        -> aim_template.seg) then
      358 			  do;
      359 
      360 /****			  call AUDIT (GRANT,
      361*			      access_operations_$dm_journal_read_attr,
      362*			      journal_idx, dm_per_journal);
      363*	We'd audit if the performance implications weren't horrendous. ****/
      364 
      365 			  time_stamp = dm_per_journal.time_stamp;
      366 			  end;
      367 		    else
      368 			  call AUDIT (DENY,
      369 			      access_operations_$dm_journal_read_attr,
      370 			      journal_idx, dm_per_journal);
      371 	      end;
      372         call lock$unlock_fast (addr (dm_journal.lock));
      373         return (time_stamp);
      374 
      375 /* ************************************************************************
      376*   * get_max_held_per_journal - Return the value of		    *
      377*   * dm_journal.max_held_per_journal from dm_journal_seg_.		    *
      378*   ************************************************************************ */
      379 
      380 get_max_held_per_journal:
      381         entry () returns (fixed bin);
      382 
      383         if ^sst$dm_enabled then
      384 	      return (0);
      385         else
      386 	      return (addr (dm_journal_seg_$)
      387 		-> dm_journal.max_held_per_journal);
      388 
      389 /* ************************************************************************
      390*   * get_n_journals - Return the value of dm_journal.get_n_journals from  *
      391*   * dm_journal_seg_.					    *
      392*   ************************************************************************ */
      393 
      394 get_n_journals:
      395         entry () returns (fixed bin);
      396 
      397         if ^sst$dm_enabled then
      398 	      return (0);
      399         else
      400 	      return (addr (dm_journal_seg_$) -> dm_journal.n_journals);
      401 
      402 /* ************************************************************************
      403*   * $set_journal_stamp - sets the time stamp for a specified journal.    *
      404*   ************************************************************************ */
      405 
      406 set_journal_stamp:
      407         entry (Journal_Idx, Time_Stamp, Code);
      408         journal_idx = Journal_Idx;
      409         time_stamp = Time_Stamp;
      410 
      411         if ^sst$dm_enabled then
      412 	      do;
      413 	      Code = error_table_$dm_not_enabled;
      414 	      return;
      415 	      end;
      416 
      417         me = "hc_dm_util$set_journal_stamp";
      418         code = 0;
      419         dm_journal_segp = addr (dm_journal_seg_$);
      420         call lock$lock_fast (addr (dm_journal.lock));
      421         dm_journal.set_stamp_calls = dm_journal.set_stamp_calls + 1;
      422         if (journal_idx <= 0) | (journal_idx > dm_journal.n_journals) then
      423 	      code = error_table_$invalid_dm_journal_index;
      424         else
      425 	      do;
      426 	      dm_per_journalp = addr (dm_journal.per_journal (journal_idx));
      427 	      if dm_per_journal.uid = ""b then
      428 		    code = error_table_$invalid_dm_journal_index;
      429 	      else if
      430 		^(
      431 		write_allowed_ (pds$access_authorization,
      432 		dm_per_journal.access_class)
      433 		| (addr (pds$access_authorization) -> aim_template.seg))
      434 		then
      435 		    do;
      436 		    call AUDIT (DENY,
      437 		        access_operations_$dm_journal_write_attr,
      438 		        journal_idx, dm_per_journal);
      439 		    code = error_table_$invalid_dm_journal_index;
      440 		    end;
      441 	      else
      442 		    do;
      443 
      444 /****		    call AUDIT (GRANT,
      445*		        access_operations_$dm_journal_write_attr,
      446*		        journal_idx, dm_per_journal);
      447*	We'd audit if the performance implications weren't horrendous. ****/
      448 
      449 		    dm_per_journal.time_stamp = time_stamp;
      450 
      451 		    call pmut$lock_ptl (old_mask, ptwp);
      452 		    call page_synch$unlink_journal (journal_idx);
      453 		    call pmut$unlock_ptl (old_mask, ptwp);
      454 		    end;
      455 	      end;
      456         call lock$unlock_fast (addr (dm_journal.lock));
      457         Code = code;
      458         return;
      459 
      460 /* ************************************************************************
      461*   * validate_bj_uid - Given a dm_journal_seg_ index and BJ uid, this	    *
      462*   * entry returns true if the supplied uid matches the uid indexed in    *
      463*   * the dm_journal_seg_ and the caller has authorization to know this.   *
      464*   ************************************************************************ */
      465 
      466 validate_bj_uid:
      467         entry (Uid, Journal_Idx) returns (bit (1) aligned);
      468 
      469         uid = Uid;
      470         journal_idx = Journal_Idx;
      471         validated = "0"b;
      472 
      473         if ^sst$dm_enabled then
      474 	      return ("0"b);
      475 
      476         me = "hc_dm_util$validate_bj_uid";
      477         dm_journal_segp = addr (dm_journal_seg_$);
      478         call lock$lock_fast (addr (dm_journal.lock));
      479         if (journal_idx > 0) & (journal_idx <= dm_journal.n_journals) then
      480 	      do;
      481 	      dm_per_journalp = addr (dm_journal.per_journal (journal_idx));
      482 	      if read_allowed_ (pds$access_authorization,
      483 		dm_per_journal.access_class)
      484 		| (addr (pds$access_authorization) -> aim_template.seg) then
      485 		    do;
      486 
      487 /****		    call AUDIT (GRANT,
      488*		        access_operations_$dm_journal_read_attr,
      489*		        journal_idx, dm_per_journal);
      490*	We'd audit if the performance implications weren't horrendous. ****/
      491 
      492 		    if uid ^= ""b & uid = dm_per_journal.uid then
      493 			  validated = "1"b;
      494 		    end;
      495 	      else
      496 		    call AUDIT (DENY,
      497 		        access_operations_$dm_journal_read_attr,
      498 		        journal_idx, dm_per_journal);
      499 	      end;
      500         call lock$unlock_fast (addr (dm_journal.lock));
      501         return (validated);
      502 
      503 /* ************************************************************************
      504*   * RECOMPUTE_THRESH - Internal Procedure to recompute max held pages    *
      505*   * per journal, which is used by ring-2 Data Management to prevent	    *
      506*   * flooding the system with held pages.			    *
      507*   ************************************************************************ */
      508 
      509 RECOMPUTE_THRESH:
      510         proc;
      511 
      512         if dm_journal.n_journals_inuse = 0 then
      513 	      dm_journal.max_held_per_journal = dm_journal.max_held_pages_mem;
      514         else
      515 	      dm_journal.max_held_per_journal =
      516 		divide (dm_journal.max_held_pages_mem,
      517 		dm_journal.n_journals_inuse, 17);
      518 
      519         end RECOMPUTE_THRESH;
      520 
      521 /* ************************************************************************
      522*   * AUDIT - Internal procedure to audit security-related events relating *
      523*   * to journals.						    *
      524*   ************************************************************************ */
      525 
      526 AUDIT:
      527         proc (outcome, operation, id, journal_entry);
      528 
      529         dcl     outcome		bit (1) aligned parameter;
      530 					      /* (I) signifies whether or not the operation was granted */
      531         dcl     operation		bit (36) aligned parameter;
      532 					      /* (I) the operation in question */
      533         dcl     id			fixed bin parameter;
      534 					      /* (I) the journal index */
      535         dcl     1 journal_entry	like dm_per_journal parameter aligned;
      536 					      /* (I) for auditing */
      537 
      538         dcl     event_flags		bit (36) aligned;
      539         dcl     object_name		char (32);
      540 
      541         event_flags = ""b;			      /* clear all flags */
      542         addr (event_flags) -> audit_event_flags.grant = (outcome = GRANT);
      543         object_name = "DM journal #" || ltrim (char (id));
      544 
      545         call access_audit_$log_obj_class (me, pds$validation_level, event_flags,
      546 	  operation, journal_entry.access_class, object_name, 0, null (), 0,
      547 	  "UID=^w", journal_entry.uid);
      548         return;
      549 
  1     1 /* begin include file - access_audit_eventflags.incl.pl1 */
  1     2 /* NOTE: This include file has an ALM counterpart made with cif.
  1     3*Keep it up to date. */
  1     4 
  1     5 dcl 1 audit_event_flags	based aligned,
  1     6       2 special_op	bit (1) unal,  /* special sys operation */
  1     7       2 grant	bit (1) unal,  /* operation was successful */
  1     8       2 admin_op	bit (1) unal,  /* administrative operation */
  1     9       2 priv_op	bit (1) unal,  /* privileged operation */
  1    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  1    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  1    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  1    13       2 pad	bit (29) unal;
  1    14 
  1    15 /* end include file - access_audit_eventflags.incl.pl1 */
      550 
      551 
      552         end AUDIT;
      553 
  2     1 /*  START OF:	dm_journal_seg_.incl.pl1	October 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 /*                                                modified June 1982 by M. Pandolf for more meters *  *  *  *  *  *  *  */
  2     3 
  2     4      dcl	   dm_journal_seg_$	      external;
  2     5 
  2     6      dcl	   dm_journal_segp	      ptr;
  2     7      dcl	   dm_per_journalp	      ptr;
  2     8      dcl	   dm_per_journal_arrayp  ptr;
  2     9      dcl	   dm_page_entryp	      ptr;
  2    10 
  2    11      dcl	   n_dm_journals	      fixed bin;
  2    12      dcl	   max_dm_pages	      fixed bin;
  2    13 
  2    14 
  2    15      dcl	   1 dm_journal	      aligned based (dm_journal_segp),
  2    16 
  2    17 	     2 lock	      bit (36) aligned,	/* Lock for manipulating journal entries */
  2    18 	     2 wait_event	      bit (36) aligned,	/* Wait Event for lock */
  2    19 	     2 notify_sw	      bit (1) aligned,
  2    20 
  2    21 	     2 n_journals	      fixed bin,		/* Number of journals */
  2    22 	     2 n_journals_inuse   fixed bin,		/* Number of journals in use now */
  2    23 	     2 max_held_pages_mem fixed bin,		/* Maximum number of pages held in memory */
  2    24 	     2 n_held_pages_mem   fixed bin,		/* Number of pages held in memory */
  2    25 	     2 max_held_per_journal fixed bin,		/* max_held_pages_mem / n_journals_inuse */
  2    26 	     2 per_aste_pool      (0:3) aligned,
  2    27 	       3 threshold	      fixed bin,		/* Maximum number of active segments */
  2    28 	       3 n_active	      fixed bin,		/* Number currently active */
  2    29 	     2 free_list_relp     bit (18) aligned,	/* Free entry list first ptr */
  2    30 	     2 synch_write_calls  fixed bin (35),	/* Number of calls to check write */
  2    31 	     2 synch_write_holds  fixed bin (35),	/* Number of times page held for call */
  2    32 	     2 synch_write_no_stamp
  2    33 			      fixed bin (35),	/* Number of times page had null DM stamp */
  2    34 	     2 synch_write_inv_vers
  2    35 			      fixed bin (35),	/* Number of times page had invalid DM stamp */
  2    36 	     2 synch_write_inv_ix
  2    37 			      fixed bin (35),	/* Number of times page had invalid BJ index */
  2    38 	     2 synch_write_inv_time
  2    39 			      fixed bin (35),	/* Number of times page had future time stamp */
  2    40 	     2 synch_write_tosses fixed bin (35),	/* Number of times page tossed because of threshold */
  2    41 	     2 unlink_calls	      fixed bin (35),	/* Number of calls to unlink all entries to a journal */
  2    42 	     2 unlink_steps	      fixed bin (35),	/* Number of CMEs unlinked */
  2    43 	     2 activate_calls     fixed bin (35),	/* Number of times synch segment activated */
  2    44 	     2 deactivate_calls   fixed bin (35),	/* Number of times synch segment deactivated */
  2    45 	     2 activate_denied    fixed bin (35),	/* Number of times activation threshold exceeded */
  2    46 	     2 set_stamp_calls    fixed bin (35),	/* Number of times called to set time stamp */
  2    47 	     2 allocate_calls     fixed bin (35),	/* Number of times called to allocate a journal */
  2    48 	     2 free_calls	      fixed bin (35),	/* Number of times called to free a journal */
  2    49 
  2    50 	     2 per_journal	      (n_dm_journals refer (dm_journal.n_journals)) aligned like dm_per_journal,
  2    51 	     2 page_entry	      (max_dm_pages refer (dm_journal.max_held_pages_mem)) aligned like dm_page_entry;
  2    52 
  2    53 
  2    54      dcl	   1 dm_per_journal_array (dm_journal.n_journals) aligned like dm_per_journal based (dm_per_journal_arrayp);
  2    55 
  2    56      dcl	   1 dm_per_journal	      aligned based (dm_per_journalp), /* One entry per DM journal */
  2    57 	     2 time_stamp	      fixed bin (71),	/* Pages before this time can be written */
  2    58 	     2 n_held	      fixed bin,		/* Number of pages held in memory */
  2    59 	     2 uid	      bit (36) aligned,	/* Unique ID for owner - ""b => not used */
  2    60 	     2 access_class	      bit (72) aligned,	/* Access Class of Owner */
  2    61 	     2 entry_relp	      bit (18) aligned,	/* Pointer to list of pages held for this journal */
  2    62 	     2 pad	      bit (36) aligned;
  2    63 
  2    64 
  2    65      dcl	   1 dm_page_entry	      aligned based (dm_page_entryp),
  2    66 	     2 fp		      bit (18) unal,	/* Forward pointer */
  2    67 	     2 bp		      bit (18) unal,	/* Backward pointer */
  2    68 	     2 cme_relp	      bit (18) unal,	/* Rel ptr -> CME */
  2    69 	     2 journal_relp	      bit (18) unal;	/* Rel ptr -> dm_per_journal */
  2    70 
  2    71 
  2    72 /*  END OF:	dm_journal_seg_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    73 
      554 
      555 
  3     1 /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  3     2 
  3     3 /* Created 740723 by PG */
  3     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  3     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  3     6 
  3     7 /* This structure defines the components of both an access
  3     8*   class and an access authorization as interpreted by the
  3     9*   Access Isolation Mechanism. */
  3    10 
  3    11 
  3    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  3    13        2 categories bit (36),				/* access categories */
  3    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  3    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  3    16         (3 ipc,					/* interprocess communication privilege */
  3    17          3 dir,					/* directory privilege */
  3    18          3 seg,					/* segment privilege */
  3    19          3 soos,					/* security out-of-service privilege */
  3    20          3 ring1,					/* ring 1 access privilege */
  3    21          3 rcp,					/* RCP resource access privilege */
  3    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  3    23          3 pad bit (11);
  3    24 
  3    25 
  3    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      556 
      557         end hc_dm_util$activate;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.2  hc_dm_util.pl1                    >spec>install>1111>hc_dm_util.pl1
550          1    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
554          2    09/07/83  1610.6  dm_journal_seg_.incl.pl1          >ldd>include>dm_journal_seg_.incl.pl1
556          3    09/07/83  1610.6  aim_template.incl.pl1             >ldd>include>aim_template.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Code                                   parameter       fixed bin(35,0)          dcl 73 set ref 170 175* 187* 222* 231 236* 240* 248*
                                                                                  270 275* 329* 406 413* 457*
DENY                            000006 constant        bit(1)                   initial dcl 150 set ref 301* 367* 436* 495*
GRANT                           000005 constant        bit(1)                   initial dcl 152 set ref 214* 307* 542
Journal_Idx                            parameter       fixed bin(17,0)          dcl 75 set ref 170 179* 221* 270 279 338 341 406 408
                                                                                  466 470
Ptsi                                   parameter       fixed bin(3,0)           dcl 77 ref 25 161 161 231 244 244 256 261 261
Time_Stamp                             parameter       fixed bin(71,0)          dcl 79 ref 406 409
Uid                                    parameter       bit(36)                  dcl 81 ref 170 180 466 469
access_audit_$log_obj_class     000044 constant        entry                    external dcl 126 ref 545
access_class              4            parameter       bit(72)                  level 2 in structure "journal_entry" dcl 535
                                                                                  in procedure "AUDIT" set ref 545*
access_class              4            based           bit(72)                  level 2 in structure "dm_per_journal" dcl 2-56
                                                                                  in procedure "hc_dm_util$activate" set ref 210*
                                                                                  294* 316* 353* 429* 482*
access_operations_$dm_journal_allocate
                                000010 external static bit(36)                  dcl 98 set ref 214*
access_operations_$dm_journal_free
                                000012 external static bit(36)                  dcl 100 set ref 301* 307*
access_operations_$dm_journal_read_attr
                                000014 external static bit(36)                  dcl 102 set ref 367* 495*
access_operations_$dm_journal_write_attr
                                000016 external static bit(36)                  dcl 104 set ref 436*
activate_calls           32            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 243* 243
activate_denied          34            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 247* 247
addr                                                   builtin function         dcl 142 ref 160 192 193 193 206 220 220 242 259 283
                                                                                  284 284 291 294 328 328 348 349 349 352 353 372
                                                                                  372 385 399 419 420 420 426 429 456 456 477 478
                                                                                  478 481 482 500 500 542
aim_template                           based           structure                level 1 dcl 3-12
allocate_calls           36            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 194* 194
audit_event_flags                      based           structure                level 1 dcl 1-5
char                                                   builtin function         dcl 143 ref 543
clock                                                  builtin function         dcl 144 ref 209
code                            000100 automatic       fixed bin(35,0)          dcl 86 set ref 183* 195* 202* 222 281* 287* 292*
                                                                                  303* 310* 317* 320 329 418* 422* 427* 439* 457
deactivate_calls         33            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 260* 260
divide                                                 builtin function         dcl 145 ref 514
dm_journal                             based           structure                level 1 dcl 2-15
dm_journal_seg_$                000070 external static fixed bin(17,0)          dcl 2-4 set ref 160 192 242 259 283 348 385 399 419
                                                                                  477
dm_journal_segp                 000126 automatic       pointer                  dcl 2-6 set ref 160* 161 161 192* 193 193 194 194
                                                                                  195 195 199 199 202 206 207 207 220 220 242* 243
                                                                                  243 244 244 247 247 259* 260 260 261 261 283* 284
                                                                                  284 285 285 287 291 322 322 328 328 348* 349 349
                                                                                  350 352 372 372 419* 420 420 421 421 422 426 456
                                                                                  456 477* 478 478 479 481 500 500 512 512 512 514
                                                                                  514 514
dm_page_entry                          based           structure                level 1 dcl 2-65
dm_per_journal                         based           structure                level 1 dcl 2-56 set ref 214* 301* 307* 367* 436*
                                                                                  495*
dm_per_journalp                 000130 automatic       pointer                  dcl 2-7 set ref 206* 209 210 211 214 291* 292 294
                                                                                  301 307 312 314 315 316 352* 353 353 365 367 426*
                                                                                  427 429 436 449 481* 482 492 495
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 107 ref 187
error_table_$dm_journal_pages_held
                                000022 external static fixed bin(35,0)          dcl 108 ref 310
error_table_$dm_not_enabled     000024 external static fixed bin(35,0)          dcl 110 ref 175 236 275 413
error_table_$invalid_dm_journal_index
                                000026 external static fixed bin(35,0)          dcl 112 ref 287 292 303 422 427 439
error_table_$no_journals_free   000030 external static fixed bin(35,0)          dcl 114 ref 195 202
error_table_$synch_seg_limit    000032 external static fixed bin(35,0)          dcl 116 ref 248
event_flags                     000156 automatic       bit(36)                  dcl 538 set ref 541* 542 545*
free_calls               37            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 285* 285
grant                     0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 1-5 set ref 542*
id                                     parameter       fixed bin(17,0)          dcl 533 ref 526 543
journal_entry                          parameter       structure                level 1 dcl 535 set ref 526
journal_idx                     000101 automatic       fixed bin(17,0)          dcl 87 set ref 181* 213* 214* 221 279* 287 287 291
                                                                                  301* 307* 341* 350 350 352 367* 408* 422 422 426
                                                                                  436* 452* 470* 479 479 481 495*
jx                              000102 automatic       fixed bin(17,0)          dcl 88 set ref 199* 199* 202 206 213
limit_covert_channel            000046 constant        entry                    external dcl 128 ref 191
lock                                   based           bit(36)                  level 2 dcl 2-15 set ref 193 193 220 220 284 284 328
                                                                                  328 349 349 372 372 420 420 456 456 478 478 500
                                                                                  500
lock$lock_fast                  000050 constant        entry                    external dcl 129 ref 193 284 349 420 478
lock$unlock_fast                000052 constant        entry                    external dcl 130 ref 220 328 372 456 500
ltrim                                                  builtin function         dcl 146 ref 543
max_held_pages_mem        5            based           fixed bin(17,0)          level 2 dcl 2-15 ref 512 514
max_held_per_journal      7            based           fixed bin(17,0)          level 2 dcl 2-15 set ref 385 512* 514*
me                              000103 automatic       char(40)                 packed unaligned dcl 89 set ref 182* 280* 343* 417*
                                                                                  476* 545*
n_active                 11            based           fixed bin(17,0)          array level 3 dcl 2-15 set ref 161* 161 244 261* 261
n_held                    2            based           fixed bin(17,0)          level 2 dcl 2-56 set ref 312
n_journals                3            based           fixed bin(17,0)          level 2 dcl 2-15 ref 195 199 202 287 350 399 422 479
n_journals_inuse          4            based           fixed bin(17,0)          level 2 dcl 2-15 set ref 195 207* 207 322* 322 512
                                                                                  514
object_name                     000157 automatic       char(32)                 packed unaligned dcl 539 set ref 543* 545*
old_mask                        000116 automatic       fixed bin(71,0)          dcl 90 set ref 311* 319* 451* 453*
operation                              parameter       bit(36)                  dcl 531 set ref 526 545*
outcome                                parameter       bit(1)                   dcl 529 ref 526 542
page_synch$unlink_journal       000054 constant        entry                    external dcl 131 ref 452
pds$access_authorization        000034 external static bit(72)                  dcl 118 set ref 210 294* 294 353* 353 429* 429 482*
                                                                                  482
pds$validation_level            000036 external static fixed bin(3,0)           dcl 120 set ref 545*
per_aste_pool            10            based           structure                array level 2 dcl 2-15
per_journal              40            based           structure                array level 2 dcl 2-15 set ref 206 291 352 426 481
pmut$lock_ptl                   000056 constant        entry                    external dcl 133 ref 311 451
pmut$unlock_ptl                 000060 constant        entry                    external dcl 134 ref 319 453
privileges                1(18)        based           structure                level 2 packed packed unaligned dcl 3-12
ptwp                            000120 automatic       pointer                  dcl 91 set ref 311* 319* 451* 453*
read_allowed_                   000062 constant        entry                    external dcl 135 ref 353 482
read_write_allowed_             000066 constant        entry                    external dcl 135 ref 294
seg                       1(20)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 294 353
                                                                                  429 482
set_stamp_calls          35            based           fixed bin(35,0)          level 2 dcl 2-15 set ref 421* 421
sst$dm_enabled                  000040 external static bit(1)                   dcl 121 ref 173 234 273 345 383 397 411 473
tc_data$end_of_time             000042 external static fixed bin(71,0)          dcl 122 ref 314
threshold                10            based           fixed bin(17,0)          array level 3 dcl 2-15 ref 244
time_stamp                             based           fixed bin(71,0)          level 2 in structure "dm_per_journal" dcl 2-56
                                                                                  in procedure "hc_dm_util$activate" set ref 209*
                                                                                  314* 365 449*
time_stamp                      000122 automatic       fixed bin(71,0)          dcl 92 in procedure "hc_dm_util$activate" set ref
                                                                                  342* 345 365* 373 409* 449
uid                       3            parameter       bit(36)                  level 2 in structure "journal_entry" dcl 535
                                                                                  in procedure "AUDIT" set ref 545*
uid                             000124 automatic       bit(36)                  dcl 93 in procedure "hc_dm_util$activate" set ref
                                                                                  180* 185 211 469* 492 492
uid                      43            based           bit(36)                  array level 3 in structure "dm_journal" dcl 2-15
                                                                                  in procedure "hc_dm_util$activate" set ref 199
uid                       3            based           bit(36)                  level 2 in structure "dm_per_journal" dcl 2-56
                                                                                  in procedure "hc_dm_util$activate" set ref 211*
                                                                                  292 315* 353 427 492
validated                       000125 automatic       bit(1)                   dcl 94 set ref 471* 492* 501
write_allowed_                  000064 constant        entry                    external dcl 135 ref 429

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
dm_page_entryp                         automatic       pointer                  dcl 2-9
dm_per_journal_array                   based           structure                array level 1 dcl 2-54
dm_per_journal_arrayp                  automatic       pointer                  dcl 2-8
max_dm_pages                           automatic       fixed bin(17,0)          dcl 2-12
n_dm_journals                          automatic       fixed bin(17,0)          dcl 2-11

NAMES DECLARED BY EXPLICIT CONTEXT.
AUDIT                           002142 constant        entry                    internal dcl 526 ref 214 301 307 367 436 495
RECOMPUTE_THRESH                002127 constant        entry                    internal dcl 509 ref 212 324
allocate_journal_index          000153 constant        entry                    external dcl 170
check_activate                  000421 constant        entry                    external dcl 231
deactivate                      000520 constant        entry                    external dcl 256
free_journal_index              000565 constant        entry                    external dcl 270
get_journal_stamp               001053 constant        entry                    external dcl 338
get_max_held_per_journal        001267 constant        entry                    external dcl 380
get_n_journals                  001364 constant        entry                    external dcl 394
hc_dm_util$activate             000115 constant        entry                    external dcl 25
set_journal_stamp               001463 constant        entry                    external dcl 406
validate_bj_uid                 001725 constant        entry                    external dcl 466

NAME DECLARED BY CONTEXT OR IMPLICATION.
null                                                   builtin function         ref 545 545

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3000        3072    2312        3010
Length      3426    2312        72         320     465           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hc_dm_util$activate                 196 external procedure  is an external procedure.  
RECOMPUTE_THRESH                        internal procedure  shares stack frame of external procedure hc_dm_util$activate.  
AUDIT                                   internal procedure  shares stack frame of external procedure hc_dm_util$activate.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hc_dm_util$activate      000100 code                        hc_dm_util$activate
                         000101 journal_idx                 hc_dm_util$activate
                         000102 jx                          hc_dm_util$activate
                         000103 me                          hc_dm_util$activate
                         000116 old_mask                    hc_dm_util$activate
                         000120 ptwp                        hc_dm_util$activate
                         000122 time_stamp                  hc_dm_util$activate
                         000124 uid                         hc_dm_util$activate
                         000125 validated                   hc_dm_util$activate
                         000126 dm_journal_segp             hc_dm_util$activate
                         000130 dm_per_journalp             hc_dm_util$activate
                         000156 event_flags                 AUDIT
                         000157 object_name                 AUDIT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          signal_op
shorten_stack       ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_$log_obj_class   limit_covert_channel          lock$lock_fast                lock$unlock_fast
page_synch$unlink_journal     pmut$lock_ptl                 pmut$unlock_ptl               read_allowed_
read_write_allowed_           write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$dm_journal_allocate                      access_operations_$dm_journal_free
access_operations_$dm_journal_read_attr                     access_operations_$dm_journal_write_attr
dm_journal_seg_$              error_table_$bad_arg          error_table_$dm_journal_pages_held
error_table_$dm_not_enabled   error_table_$invalid_dm_journal_index                       error_table_$no_journals_free
error_table_$synch_seg_limit  pds$access_authorization      pds$validation_level          sst$dm_enabled
tc_data$end_of_time




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000112       160 000124       161 000126       163 000132       170 000147       173 000167       175 000172
    176 000174       179 000211       180 000212       181 000215       182 000216       183 000221       185 000222
    187 000223       188 000225       191 000242       192 000252       193 000255       194 000265       195 000272
    199 000301       201 000313       202 000315       206 000325       207 000330       209 000331       210 000333
    211 000341       212 000343       213 000344       214 000346       220 000363       221 000374       222 000376
    223 000400       231 000415       234 000433       236 000436       237 000440       240 000455       242 000456
    243 000460       244 000464       247 000473       248 000477       250 000501       256 000516       259 000527
    260 000532       261 000536       263 000544       270 000561       273 000601       275 000604       276 000606
    279 000623       280 000625       281 000630       283 000631       284 000633       285 000643       287 000650
    291 000660       292 000663       294 000671       301 000716       303 000732       304 000735       307 000736
    310 000752       311 000755       312 000765       314 000770       315 000773       316 000774       317 000777
    319 001000       320 001011       322 001013       324 001016       328 001017       329 001030       330 001032
    338 001047       341 001065       342 001067       343 001071       345 001074       348 001131       349 001133
    350 001143       352 001150       353 001153       365 001202       366 001204       367 001205       372 001221
    373 001232       380 001264       383 001276       385 001325       394 001362       397 001373       399 001422
    406 001457       408 001477       409 001501       411 001504       413 001507       414 001511       417 001526
    418 001531       419 001532       420 001534       421 001544       422 001551       426 001561       427 001564
    429 001572       436 001617       439 001633       440 001636       449 001637       451 001641       452 001651
    453 001660       456 001671       457 001702       458 001704       466 001721       469 001736       470 001741
    471 001743       473 001744       476 001770       477 001773       478 001775       479 002005       481 002012
    482 002015       492 002042       494 002051       495 002052       500 002066       501 002077       509 002127
    512 002130       514 002136       519 002141       526 002142       541 002144       542 002145       543 002155
    545 002216       548 002306


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
