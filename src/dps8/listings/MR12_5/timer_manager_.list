	COMPILATION LISTING OF SEGMENT timer_manager_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1009.2 mst Sat
	    Options: optimize map

        1 /****^  **************************************************************
        2*        *                                                            *
        3*        * Copyright, (C) Massachusetts Institute of Technology, 1982 *
        4*        *                                                            *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982    *
        6*        *                                                            *
        7*        * Copyright (c) 1972 by Massachusetts Institute of           *
        8*        * Technology and Honeywell Information Systems, Inc.         *
        9*        *                                                            *
       10*        ************************************************************** */
       11 
       12 /* format: style4,insnl,delnl,ifthendo */
       13 
       14 timer_manager_:
       15      proc;
       16 	return;
       17 
       18 /* This procedure provides to a user process the ability to schedule timers as
       19*   if there were an infinite number of hardware timers available, by keeping a
       20*   list of scheduled timers and intercepting all timer wakeups and interrupts.
       21*
       22*   Dedicated to Peter Bishop, who did the best he could with the tools he had.
       23*
       24*   LINES MARKED "DEBUG" and commented out should REMAIN commented out
       25*   in the production version.  They are only decommented for debugging.
       26*
       27*   Entirely rewritten 12/03/79 by C. D. Tavares.
       28*   Also added ability to sleep in inner ring and examine list of timers
       29*   scheduled to occur in the process. */
       30 
       31 /* Changed by E. Donner Jan 1981 to change calls to full_ipc_$ to ipc_$ for new ipc changes */
       32 /* Modified by Benson I. Margulies, September 1981, for condition wall an alarm_call calls. */
       33 /* Modified September 8, 1982 by Richard Lamson to add data pointer argument	     */
       34 /* Modified by BIM, November 1982 to take condition wall back out. */
       35 
       36 
       37 /****^  HISTORY COMMENTS:
       38*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
       39*     audit(86-10-20,Fawcett), install(86-11-03,MR12.0-1206):
       40*     Changed to support control point management.  These changes were actually
       41*     done in February 1985 by G. Palter.
       42*  2) change(86-12-10,Fawcett), approve(86-12-17,MECR0003),
       43*     audit(86-12-15,GDixon), install(86-12-17,MR12.0-1250):
       44*     Changed to fix the problem in Initializer use of timer_manager_.
       45*     system_startup_ (Initializer ring 1 command level) calls
       46*     timer_manager_$sleep in ring 1, causing initial_ring (in timer_manager_'s
       47*     ring 1 internal static) to be set to 1 (since Initializer hasn't crossed
       48*     out into ring 4 yet).  After crossing to ring 4, when the Initializer
       49*     calls into ring_1 to a function that requires timer_manager_$sleep, ring 1
       50*     internal static still thinks initial_ring is 1, rather than 4.  It
       51*     therefore uses the login_ring sleep protocol rather than the inner ring
       52*     protocol, goes blocked in ring 1 and never awakens. The fix is to always
       53*     call the internal proc initialize. In this proc a check is made for
       54*     initial_ring = 1 and then if this is Initializer, then set the
       55*     initialized_mechanisum to Uninitialized (0) and reinit in this ring.
       56*  3) change(87-01-13,Fawcett), approve(87-01-13,MCR7601),
       57*     audit(87-01-13,GJohnson), install(87-01-13,MR12.0-1270):
       58*     This closes MECR0003.
       59*  4) change(87-01-13,Lippard), approve(86-11-24,MCR7577),
       60*     audit(87-01-14,Dickson), install(87-03-30,MR12.1-1018):
       61*     Change actually made 86-10-29, bogus date is to satisfy hcom.
       62*     Make timer_manager_$sleep unschedule timer in cleanup handler.
       63*                                                   END HISTORY COMMENTS */
       64 
       65 
       66 dcl  a_time fixed bin (71) parameter,			/* desired time of event */
       67      a_flags bit (2) parameter,			/* 0=abs/1=rel; 0=usec/1=sec */
       68      a_routine entry variable parameter,		/* routine to call when timer goes off */
       69      a_channel fixed bin (71) parameter;		/* channel to wakeup over when timer goes off */
       70 
       71 dcl  area_ptr pointer parameter,			/* get_schedule entry: pointer to user area */
       72      a_code fixed bin (35) parameter;
       73 
       74 dcl  a_mc_ptr pointer parameter,			/* interrupt entries: machine conditions ptr pointer */
       75      a_condition_name char (*) parameter,		/* alrm or cput */
       76      a_hc_mc_ptr pointer parameter,			/* hardcore machine conditions ptr */
       77      io_ptr pointer,				/* we don't use this */
       78      a_continue bit (1) aligned;			/* resignal condition if we turn it on */
       79 
       80 dcl  a_call_timer_info_ptr pointer parameter;		/* invoke_users_routine: data set by other control point */
       81 
       82 dcl  data_ptr pointer,
       83      data_ptr_provided bit (1) aligned;
       84 
       85 dcl  call_timer_info_ptr pointer,
       86      call_timer_info_condition_name_lth fixed binary (21);
       87 
       88 /* static */
       89 
       90 dcl  (
       91      allow_all_mask bit (36) aligned initial ((36)"1"b),
       92      alrm_cput_mask bit (36) aligned initial (""b),
       93      alrm_cput_quit_mask bit (36) aligned initial (""b),
       94      alrm_disabled_mask bit (36) aligned initial (""b),
       95      my_group_id char (32) initial (""),     
       96      initial_ring fixed bin initial (-2),
       97      initialized_mechanism fixed bin initial (0),
       98      my_processid bit (36) initial (""b),
       99      start_alarm_list_ptr pointer initial (null),
      100      start_cpu_list_ptr pointer initial (null),
      101      free_bead_list_ptr pointer initial (null),
      102      saved_channel_array (5) fixed binary (71) initial ((5) - 1),
      103      saved_channel_count fixed binary initial (0),
      104      sys_areap pointer initial (null),
      105      this_ring fixed bin initial (-1)
      106      ) static;
      107 
      108 /* external static */
      109 
      110 dcl  error_table_$invalid_channel fixed bin (35) external static,
      111      error_table_$noalloc fixed bin (35) external static,
      112      sys_info$max_seg_size fixed bin (35) ext static;
      113 
      114 /* constants */
      115 
      116 dcl  (
      117      Alarm bit (1) aligned initial ("1"b),
      118      CPU bit (1) aligned initial (""b),
      119      Initializer char (23) initial ("Initializer.SysDaemon.z"),
      120      Inhibit bit (1) aligned initial ("1"b),
      121      No_inhibit bit (1) aligned initial (""b),
      122      Call bit (1) aligned initial ("1"b),
      123      Wakeup bit (1) aligned initial (""b),
      124      Limited fixed bin initial (1),
      125      Full fixed bin initial (2),
      126      Uninitialized fixed bin initial (0),
      127      Absolute_setting fixed bin initial (2),
      128      Million fixed bin (35) initial (1f6),
      129      Forever fixed bin (71) initial (1f70b),
      130      All_IPS (1) char (32) aligned initial ("-all"),
      131      IPS_names (3) char (32) aligned initial ("alrm", "cput", "quit")
      132      ) static options (constant);
      133 
      134 /* entries */
      135 
      136 dcl  create_ips_mask_ entry (ptr, fixed bin, bit (36) aligned),
      137      cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      138      ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35)),
      139      ipc_$delete_ev_chn entry (fixed bin (71), fixed bin (35)),
      140      get_group_id_ entry () returns (char (32)),
      141      get_initial_ring_ entry returns (fixed bin),
      142      get_process_id_ entry returns (bit (36) aligned),
      143      get_ring_ entry returns (fixed bin),
      144      get_system_free_area_ entry returns (pointer),
      145      hcs_$assign_channel entry (fixed bin (71), fixed bin (35)),
      146      hcs_$reset_ips_mask entry (bit (36) aligned, bit (36) aligned),
      147      hcs_$get_alarm_timer entry (fixed bin (71), fixed bin (71)),
      148      hcs_$set_alarm_timer entry (fixed bin (71), fixed bin, fixed bin (71)),
      149      hcs_$set_automatic_ips_mask entry (bit (36) aligned, bit (36) aligned),
      150      hcs_$set_cpu_timer ext entry (fixed bin (71), fixed bin, fixed bin (71)),
      151      hcs_$get_ips_mask ext entry (bit (36) aligned),
      152      hcs_$set_ips_mask entry (bit (36) aligned, bit (36) aligned),
      153      hcs_$wakeup entry (bit (36), fixed bin (71), char (8) aligned, fixed bin (35)),
      154      ipc_$block entry (pointer, pointer, fixed bin (35));
      155 
      156 /* based */
      157 
      158 dcl  1 bead aligned based,
      159        2 next_ptr pointer,
      160        2 info like schedule.timer;
      161 
      162 dcl  1 call_timer_info aligned based (call_timer_info_ptr),
      163        2 routine entry (pointer, character (*), pointer, pointer) variable,
      164        2 condition_name_lth fixed binary (21),
      165        2 pad bit (36) aligned,
      166        2 mc_ptr pointer,
      167        2 hc_mc_ptr pointer,
      168        2 data_ptr pointer,
      169        2 condition_name
      170 	  character (call_timer_info_condition_name_lth refer (call_timer_info.condition_name_lth)) unaligned;
      171 
      172 dcl  sys_area area (sys_info$max_seg_size) based (sys_areap);
      173 
      174 /* builtins and conditions */
      175 
      176 dcl  (addr, bool, clock, hbound, length, null, stackbaseptr, substr, unspec, vclock) builtin;
      177 
      178 dcl  (area, cleanup) condition,
      179      timer_manager_err condition;
      180 
      181 /* format: off */
      182  /* --------------- BEGIN include file timer_manager_schedule.incl.pl1 --------------- */
  1     2 /*	Last modified 9 September 1982 to add timer_manager_ data pointers	      */
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  1     7*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  1     8*     Changed to support control point management.  These changes were actually
  1     9*     done in February 1985 by G. Palter.
  1    10*                                                   END HISTORY COMMENTS */
  1    11 
  1    12 
  1    13 dcl 1 schedule aligned based (schedule_ptr),
  1    14     2 version fixed bin,
  1    15     2 n_timers fixed bin,
  1    16     2 timer (N_Timers refer (schedule.n_timers)) aligned,
  1    17       3 time fixed bin (71),
  1    18       3 flags,
  1    19         4 inhibit bit (1) unaligned,
  1    20         4 alarm bit (1) unaligned,
  1    21         4 cpu bit (1) unaligned,
  1    22         4 call bit (1) unaligned,
  1    23         4 wakeup bit (1) unaligned,
  1    24         4 data_ptr_provided bit (1) unaligned,
  1    25         4 pad bit (30) unaligned,
  1    26       3 pad1 bit (36) aligned,
  1    27       3 channel fixed bin (71),
  1    28       3 routine entry variable options (variable),
  1    29       3 data_ptr pointer,
  1    30       3 control_point_id bit (36) aligned,
  1    31       3 pad (3) fixed bin (35);
  1    32 
  1    33 dcl  N_Timers fixed bin,
  1    34      schedule_ptr pointer,
  1    35 
  1    36      timer_manager_schedule_version_1 fixed bin static initial (1) options (constant),
  1    37      timer_manager_schedule_version_2 fixed bin static initial (2) options (constant),
  1    38      timer_manager_schedule_version_3 fixed bin static initial (3) options (constant);
  1    39      
  1    40 
  1    41 /* ---------------- END include file timer_manager_schedule.incl.pl1 ---------------- */
      182 
      183  /*  */
  2     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  2     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  2     4 /* Modified 07/07/76 by Morris for fault register data */
  2     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  2     6 /* Modified '82 to make values constant */
  2     7 
  2     8 /* words 0-15 pointer registers */
  2     9 
  2    10 dcl  mcp ptr;
  2    11 
  2    12 dcl 1 mc based (mcp) aligned,
  2    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  2    14    (2 regs,					/* registers */
  2    15       3 x (0:7) bit (18),				/* index registers */
  2    16       3 a bit (36),					/* accumulator */
  2    17       3 q bit (36),					/* q-register */
  2    18       3 e bit (8),					/* exponent */
  2    19       3 pad1 bit (28),
  2    20       3 t bit (27),					/* timer register */
  2    21       3 pad2 bit (6),
  2    22       3 ralr bit (3),				/* ring alarm register */
  2    23 
  2    24     2 scu (0:7) bit (36),
  2    25 
  2    26     2 mask bit (72),				/* mem controller mask at time of fault */
  2    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  2    28     2 errcode fixed bin (35),				/* fault handler's error code */
  2    29     2 fim_temp,
  2    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  2    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  2    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  2    33     2 fault_reg bit (36),				/* fault register */
  2    34     2 pad2 bit (1),
  2    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  2    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  2    37     2 fault_time bit (54),				/* time of fault */
  2    38 
  2    39     2 eis_info (0:7) bit (36)) unaligned;
  2    40 
  2    41 
  2    42 dcl (apx fixed bin init (0),
  2    43      abx fixed bin init (1),
  2    44      bpx fixed bin init (2),
  2    45      bbx fixed bin init (3),
  2    46      lpx fixed bin init (4),
  2    47      lbx fixed bin init (5),
  2    48      spx fixed bin init (6),
  2    49      sbx fixed bin init (7)) internal static options (constant);
  2    50 
  2    51 
  2    52 
  2    53 
  2    54 dcl  scup ptr;
  2    55 
  2    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  2    57 
  2    58 
  2    59 /*	WORD (0)		*/
  2    60 
  2    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  2    62       3 prr bit (3),				/* procedure ring register */
  2    63       3 psr bit (15),				/* procedure segment register */
  2    64       3 p bit (1),					/* procedure privileged bit */
  2    65 
  2    66     2 apu,					/* APPENDING UNIT STATUS */
  2    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  2    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  2    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  2    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  2    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  2    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  2    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  2    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  2    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  2    76       3 ptw bit (1),				/* Fetch of PTW */
  2    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  2    78       3 fap bit (1),				/* Fetch of final address paged */
  2    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  2    80       3 fabs bit (1),				/* Fetch of final address absolute */
  2    81 
  2    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  2    83 
  2    84 
  2    85 /*	WORD (1)		*/
  2    86 
  2    87     2 fd,						/* FAULT  DATA */
  2    88       3 iro bit (1),				/* illegal ring order */
  2    89       3 oeb bit (1),				/* out of execute bracket */
  2    90       3 e_off bit (1),				/* no execute */
  2    91       3 orb bit (1),				/* out of read bracket */
  2    92       3 r_off bit (1),				/* no read */
  2    93       3 owb bit (1),				/* out of write bracket */
  2    94       3 w_off bit (1),				/* no write */
  2    95       3 no_ga bit (1),				/* not a gate */
  2    96       3 ocb bit (1),				/* out of call bracket */
  2    97       3 ocall bit (1),				/* outward call */
  2    98       3 boc bit (1),				/* bad outward call */
  2    99       3 inret bit (1),				/* inward return */
  2   100       3 crt bit (1),				/* cross ring transfer */
  2   101       3 ralr bit (1),				/* ring alarm register */
  2   102       3 am_er bit (1),				/* associative memory fault */
  2   103       3 oosb bit (1),				/* out of segment bounds */
  2   104       3 paru bit (1),				/* processor parity upper */
  2   105       3 parl bit (1),				/* processor parity lower */
  2   106       3 onc_1 bit (1),				/* op not complete type 1 */
  2   107       3 onc_2 bit (1),				/* op not complete type 2 */
  2   108 
  2   109     2 port_stat,					/* PORT  STATUS */
  2   110       3 ial bit (4),				/* illegal action lines */
  2   111       3 iac bit (3),				/* illegal action channel */
  2   112       3 con_chan bit (3),				/* connect channel */
  2   113 
  2   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  2   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  2   116 
  2   117 
  2   118 /*	WORD (2)		*/
  2   119 
  2   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  2   121       3 trr bit (3),				/* temporary ring register */
  2   122       3 tsr bit (15),				/* temporary segment register */
  2   123 
  2   124     2 pad2 bit (9),
  2   125 
  2   126     2 cpu_no bit (3),				/* CPU number */
  2   127 
  2   128     2 delta bit (6),				/* tally modification DELTA */
  2   129 
  2   130 
  2   131 /*	WORD (3)		*/
  2   132 
  2   133     2 word3 bit (18),
  2   134 
  2   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  2   136       3 tsna,					/* Word 1 status */
  2   137         4 prn bit (3),				/* Word 1  PR  number */
  2   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  2   139       3 tsnb,					/* Word 2  status */
  2   140         4 prn bit (3),				/* Word 2  PR  number */
  2   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  2   142       3 tsnc,					/* Word 3  status */
  2   143         4 prn bit (3),				/* Word 3  PR  number */
  2   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  2   145 
  2   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  2   147 
  2   148 
  2   149 /* 	WORD (4)		*/
  2   150 
  2   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  2   152 
  2   153     2 ir,						/* INDICATOR  REGISTERS */
  2   154       3 zero bit (1),				/* zero indicator */
  2   155       3 neg bit (1),				/* negative indicator */
  2   156       3 carry bit (1),				/* carryry indicator */
  2   157       3 ovfl bit (1),				/* overflow indicator */
  2   158       3 eovf bit (1),				/* eponent overflow */
  2   159       3 eufl bit (1),				/* exponent underflow */
  2   160       3 oflm bit (1),				/* overflow mask */
  2   161       3 tro bit (1),				/* tally runout */
  2   162       3 par bit (1),				/* parity error */
  2   163       3 parm bit (1),				/* parity mask */
  2   164       3 bm bit (1),					/* ^bar mode */
  2   165       3 tru bit (1),				/* truncation mode */
  2   166       3 mif bit (1),				/* multi-word instruction mode */
  2   167       3 abs bit (1),				/* absolute mode */
  2   168       3 hex bit (1),				/* hexadecimal exponent mode */
  2   169       3 pad bit (3),
  2   170 
  2   171 
  2   172 /*	WORD (5)		*/
  2   173 
  2   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  2   175 
  2   176     2 cu,						/* CONTROL UNIT STATUS */
  2   177       3 rf bit (1),					/* on first cycle of repeat instr */
  2   178       3 rpt bit (1),				/* repeat instruction */
  2   179       3 rd bit (1),					/* repeat double instruction */
  2   180       3 rl bit (1),					/* repeat link instruciton */
  2   181       3 pot bit (1),				/* IT  modification */
  2   182       3 pon bit (1),				/* return type instruction */
  2   183       3 xde bit (1),				/* XDE from Even location */
  2   184       3 xdo bit (1),				/* XDE from Odd  location */
  2   185       3 poa bit (1),				/* operation preparation */
  2   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  2   187       3 its bit (1),				/* ITS modification */
  2   188       3 if bit (1),					/* fault occured during instruction fetch */
  2   189 
  2   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  2   191 
  2   192 
  2   193 /*	WORDS (6,7)	*/
  2   194 
  2   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  2   196 
  2   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  2   198 
  2   199 
  2   200 
  2   201 
  2   202 
  2   203 
  2   204 /*	ALTERNATE   SCU  DECLARATION		*/
  2   205 
  2   206 
  2   207 dcl 1 scux based (scup) aligned,
  2   208 
  2   209    (2 pad0 bit (36),
  2   210 
  2   211     2 fd,						/* GROUP II  FAULT DATA */
  2   212       3 isn bit (1),				/* illegal segment number */
  2   213       3 ioc bit (1),				/* illegal op  code  */
  2   214       3 ia_am bit (1),				/* illegal address - modifier */
  2   215       3 isp bit (1),				/* illegal slave  procedure */
  2   216       3 ipr bit (1),				/* illegal procedure */
  2   217       3 nea bit (1),				/* non existent address */
  2   218       3 oobb bit (1),				/* out of bounds */
  2   219       3 pad bit (29),
  2   220 
  2   221     2 pad2 bit (36),
  2   222 
  2   223     2 pad3a bit (18),
  2   224 
  2   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  2   226       3 prn bit (3),				/* PR  number */
  2   227       3 prv bit (1),				/* PR  valid bit */
  2   228 
  2   229     2 pad3b bit (6)) unaligned,
  2   230 
  2   231     2 pad45 (0:1) bit (36),
  2   232 
  2   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  2   234 
  2   235 
  2   236 
  2   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      183 
      184  /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  3     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  3     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  3     4 /*	Modified April 1983 by C. Hornig for tasking */
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  3     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  3     9*     added the heap_header_ptr definition.
  3    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  3    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  3    12*     Modified to support control point management.  These changes were actually
  3    13*     made in February 1985 by G. Palter.
  3    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  3    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  3    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  3    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  3    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  3    19*     (ITS pair).
  3    20*                                                   END HISTORY COMMENTS */
  3    21 
  3    22 /* format: style2 */
  3    23 
  3    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  3    25 
  3    26      dcl	   1 stack_header	      based (sb) aligned,
  3    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  3    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  3    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  3    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  3    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  3    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  3    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  3    34 	     2 pad4	      bit (2) unal,
  3    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  3    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  3    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  3    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  3    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  3    40 	     2 null_ptr	      ptr,		/*  (16)  */
  3    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  3    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  3    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  3    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  3    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  3    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  3    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  3    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  3    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  3    50 	     2 return_no_pop_op_ptr
  3    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  3    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  3    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  3    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  3    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  3    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  3    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  3    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  3    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  3    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  3    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  3    62 	     2 trace,
  3    63 	       3 frames,
  3    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  3    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  3    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  3    67 	     2 pad2	      bit (36),		/*  (61) */
  3    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  3    69 
  3    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  3    71 
  3    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  3    73 						/* (551) octal */
  3    74 
  3    75 
  3    76 /*	The following constants are offsets within this transfer vector table.  */
  3    77 
  3    78      dcl	   (
  3    79 	   call_offset	      fixed bin init (271),
  3    80 	   push_offset	      fixed bin init (272),
  3    81 	   return_offset	      fixed bin init (273),
  3    82 	   return_no_pop_offset   fixed bin init (274),
  3    83 	   entry_offset	      fixed bin init (275)
  3    84 	   )		      internal static;
  3    85 
  3    86 
  3    87 
  3    88 
  3    89 
  3    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  3    91*	move the whole stack header should use this overlay.
  3    92**/
  3    93 
  3    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  3    95 
  3    96 
  3    97 
  3    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      184 
      185  /* BEGIN INCLUDE FILE ... cpm_data_.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  4     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  4     6*     Written to support control point management in March 1985 by G. Palter.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 /* format: style3,linecom */
  4    10 
  4    11 /* Static data defined by the Control Point Manager for external use */
  4    12 
  4    13 dcl	cpm_data_$n_control_points			/* # of control points actually extant in the process */
  4    14 			fixed binary external;
  4    15 
  4    16 /* END INCLUDE FILE ... cpm_data_.incl.pl1 */
      185 
      186  /* BEGIN INCLUDE FILE ... cpm_entries.incl.pl1 */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  5     5*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  5     6*     Written to support control point management in March 1985 by G. Palter.
  5     7*                                                   END HISTORY COMMENTS */
  5     8 
  5     9 /* format: style3,linecom */
  5    10 
  5    11 /* Control Point Manager (cpm_) entrypoint definitions */
  5    12 
  5    13 dcl	get_control_point_id_			/* returns the ID of the currently running control point */
  5    14 			entry () returns (bit (36) aligned);
  5    15 
  5    16 dcl	cpm_$create				/* create a new control point */
  5    17 			entry (pointer, bit (36) aligned, fixed binary (35));
  5    18 
  5    19 dcl	(
  5    20 	cpm_$destroy,				/* destroy the specified control point */
  5    21 	cpm_$start,				/* start the specified control point if its stopped */
  5    22 	cpm_$wakeup,				/* make the specified control point ready if its blocked */
  5    23 	cpm_$stop					/* stop the specified control point if its ready or blocked */
  5    24 	)		entry (bit (36) aligned, fixed binary (35));
  5    25 
  5    26 dcl	cpm_$block	entry ();			/* block the current control point */
  5    27 
  5    28 dcl	cpm_$scheduler	entry ();			/* find a runnable control point and let it run */
  5    29 
  5    30 dcl	(
  5    31 	cpm_$get_user_cl_intermediary,		/* get the user supplied procedure to run during cu_$cl */
  5    32 	cpm_$set_user_cl_intermediary			/* set the user supplied procedure to run during cu_$cl */
  5    33 	)		entry (bit (36) aligned, entry (bit (1) aligned), fixed binary (35));
  5    34 
  5    35 dcl	(
  5    36 	cpm_$generate_call,				/* generate an immediate call */
  5    37 	cpm_$generate_call_preferred,			/* generate an immediate call and make it run preferred */
  5    38 	cpm_$generate_call_when_ready			/* generate a call when the control point is next ready */
  5    39 	)		entry (bit (36) aligned, entry (pointer), pointer, fixed binary (35));
  5    40 
  5    41 dcl	cpm_$get_preferred_control_point		/* return the ID of the preferred control point */
  5    42 			entry () returns (bit (36) aligned);
  5    43 dcl	cpm_$set_preferred_control_point		/* make the specified control point preferred */
  5    44 			entry (bit (36) aligned, fixed binary (35));
  5    45 dcl	cpm_$push_preferred_control_point		/* switch preferred control points */
  5    46 			entry (bit (36) aligned, bit (1) aligned, fixed binary (35));
  5    47 dcl	cpm_$pop_preferred_control_point		/* restore the previous preferred control point */
  5    48 			entry (bit (1) aligned);
  5    49 
  5    50 dcl	cpm_$get_control_point_meters			/* get the usage meters for a specific control point */
  5    51 			entry (bit (36) aligned, pointer, fixed binary (35));
  5    52 dcl	cpm_$get_scheduler_meters			/* get the usage meters for the control point scheduler */
  5    53 			entry (pointer, fixed binary (35));
  5    54 
  5    55 dcl	cpm_$nulle	entry () options (variable);	/* a "null" entry value which should never be called */
  5    56 
  5    57 /* END INCLUDE FILE ... cpm_entries.incl.pl1 */
      186 
      187 /* format: on */
      188 
      189 alarm_call:
      190      entry (a_time, a_flags, a_routine);
      191 
      192 	call set_data_ptr (4, data_ptr, data_ptr_provided);
      193 	call schedule_timer (abs_time (a_time, a_flags, Alarm), Alarm, No_inhibit, Call, 0, a_routine, data_ptr,
      194 	     data_ptr_provided);
      195 	return;


      196 
      197 alarm_call_inhibit:
      198      entry (a_time, a_flags, a_routine);
      199 
      200 	call set_data_ptr (4, data_ptr, data_ptr_provided);
      201 	call schedule_timer (abs_time (a_time, a_flags, Alarm), Alarm, Inhibit, Call, 0, a_routine, data_ptr,
      202 	     data_ptr_provided);
      203 	return;


      204 
      205 cpu_call:
      206      entry (a_time, a_flags, a_routine);
      207 
      208 	call set_data_ptr (4, data_ptr, data_ptr_provided);
      209 	call schedule_timer (abs_time (a_time, a_flags, CPU), CPU, No_inhibit, Call, 0, a_routine, data_ptr,
      210 	     data_ptr_provided);
      211 	return;


      212 
      213 cpu_call_inhibit:
      214      entry (a_time, a_flags, a_routine);
      215 
      216 	call set_data_ptr (4, data_ptr, data_ptr_provided);
      217 	call schedule_timer (abs_time (a_time, a_flags, CPU), CPU, Inhibit, Call, 0, a_routine, data_ptr,
      218 	     data_ptr_provided);
      219 	return;


      220 
      221 alarm_wakeup:
      222      entry (a_time, a_flags, a_channel);
      223 
      224 	call schedule_timer (abs_time (a_time, a_flags, Alarm), Alarm, No_inhibit, Wakeup, a_channel,
      225 	     signal_timer_manager_err, null, "0"b);
      226 	return;


      227 
      228 cpu_wakeup:
      229      entry (a_time, a_flags, a_channel);
      230 
      231 	call schedule_timer (abs_time (a_time, a_flags, CPU), CPU, No_inhibit, Wakeup, a_channel,
      232 	     signal_timer_manager_err, null, "0"b);
      233 	return;


      234 
      235 sleep:
      236      entry (a_time, a_flags);
      237 
      238 	call sleep (abs_time (a_time, a_flags, Alarm), "0"b);
      239 	return;


      240 
      241 sleep_lss:
      242      entry (a_time, a_flags);
      243 
      244 	call sleep (abs_time (a_time, a_flags, Alarm), "1"b);
      245 	return;


      246 
      247 reset_alarm_call:
      248      entry (a_routine);
      249 
      250 	call set_data_ptr (2, data_ptr, data_ptr_provided);
      251 	call unschedule_timer (Alarm, Call, 0, a_routine, data_ptr, data_ptr_provided);
      252 	return;


      253 
      254 reset_alarm_wakeup:
      255      entry (a_channel);
      256 
      257 	call unschedule_timer (Alarm, Wakeup, a_channel, signal_timer_manager_err, null, "0"b);
      258 	return;


      259 
      260 reset_cpu_call:
      261      entry (a_routine);
      262 
      263 	call set_data_ptr (2, data_ptr, data_ptr_provided);
      264 	call unschedule_timer (CPU, Call, 0, a_routine, data_ptr, data_ptr_provided);
      265 	return;


      266 
      267 reset_cpu_wakeup:
      268      entry (a_channel);
      269 
      270 	call unschedule_timer (CPU, Wakeup, a_channel, signal_timer_manager_err, null, "0"b);
      271 	return;


      272 
      273 get_schedule:
      274      entry (area_ptr, schedule_ptr, a_code);
      275 
      276 	call get_schedule (area_ptr, schedule_ptr, a_code);
      277 	return;


      278 
      279 
      280 /* The following two entries are entries called by the system when timers go off */
      281 
      282 alarm_interrupt:
      283      entry (a_mc_ptr, a_condition_name, a_hc_mc_ptr, io_ptr, a_continue);
      284 
      285 	call process_interrupt (Alarm, a_mc_ptr, a_condition_name, a_hc_mc_ptr, a_continue);
      286 	return;


      287 
      288 cpu_time_interrupt:
      289      entry (a_mc_ptr, a_condition_name, a_hc_mc_ptr, io_ptr, a_continue);
      290 
      291 	call process_interrupt (CPU, a_mc_ptr, a_condition_name, a_hc_mc_ptr, a_continue);
      292 	return;










      293 
      294 invoke_users_routine:
      295      entry (a_call_timer_info_ptr);
      296 
      297 	call_timer_info_ptr = a_call_timer_info_ptr;
      298 
      299 	on cleanup
      300 	     begin;
      301 	     if call_timer_info_ptr ^= null ()
      302 	     then free call_timer_info in (sys_area);
      303 	     call_timer_info_ptr = null ();
      304 	end;
      305 
      306 	call call_timer_info
      307 	     .
      308 	     routine (call_timer_info.mc_ptr, call_timer_info.condition_name, call_timer_info.hc_mc_ptr,
      309 	     call_timer_info.data_ptr);
      310 
      311 	free call_timer_info in (sys_area);
      312 	call_timer_info_ptr = null ();
      313 
      314 	return;










      315 
      316 set_data_ptr:
      317      proc (arg_number, a_data_ptr, a_data_ptr_provided);
      318 
      319 	call cu_$arg_ptr (arg_number, p_ptr, p_len, x_code);
      320 	if x_code = 0 then do;
      321 	     a_data_ptr = p_ptr -> based_ptr;
      322 	     a_data_ptr_provided = "1"b;
      323 	end;
      324 	else do;
      325 	     a_data_ptr = null ();
      326 	     a_data_ptr_provided = "0"b;
      327 	end;
      328 	return;
      329 
      330 declare  arg_number fixed binary parameter;
      331 declare  a_data_ptr pointer parameter;
      332 declare  a_data_ptr_provided bit (1) aligned;
      333 
      334 declare  p_ptr pointer;
      335 declare  p_len fixed binary (21);
      336 declare  x_code fixed binary (35);
      337 declare  based_ptr pointer based;
      338 
      339      end;
      340 
      341 schedule_timer:
      342      proc (time, type, inhibit, action, channel, routine, data_ptr, data_ptr_provided);
      343 
      344 dcl  (
      345      time fixed bin (71),
      346      type bit (1) aligned,
      347      inhibit bit (1) aligned,
      348      action bit (1) aligned,
      349      channel fixed bin (71),
      350      routine entry variable,
      351      data_ptr_provided bit (1) aligned,
      352      data_ptr pointer
      353      ) parameter;
      354 
      355 dcl  bead_ptr pointer,
      356      found bit (1) aligned,
      357      next_bead_ptr pointer,
      358      prev_bead_ptr pointer,
      359      saved_mask bit (36) aligned,
      360      start_list_ptr pointer;
      361 
      362 
      363 	call initialize (Full);
      364 
      365 /* Mask down so we won't be bothered by asynchronous processing or unexpected recursion */
      366 
      367 	saved_mask = "0"b;
      368 
      369 	on cleanup
      370 	     begin;
      371 	     if substr (saved_mask, 36, 1) = "1"b
      372 	     then call hcs_$reset_ips_mask (saved_mask, saved_mask);
      373 	end;
      374 
      375 	call hcs_$set_ips_mask (alrm_cput_quit_mask, saved_mask);
      376 						/* disable alrm, cput, quit */
      377 
      378 
      379 /* Search down appropriate list and sort in alarm by time */
      380 
      381 	found = "0"b;
      382 	prev_bead_ptr = null;
      383 	if type = Alarm
      384 	then start_list_ptr = start_alarm_list_ptr;
      385 	else start_list_ptr = start_cpu_list_ptr;
      386 
      387 	do bead_ptr = start_list_ptr repeat (bead_ptr -> bead.next_ptr) while (bead_ptr ^= null & ^found);
      388 	     if time < bead_ptr -> bead.time
      389 	     then found = "1"b;
      390 	     else prev_bead_ptr = bead_ptr;
      391 	end;
      392 
      393 /* At this point, prev_bead_ptr points to the bead after which we want to sort in the new timer */
      394 	if free_bead_list_ptr = null ()
      395 	then allocate bead in (sys_area) set (bead_ptr);
      396 	else do;
      397 	     bead_ptr = free_bead_list_ptr;
      398 	     free_bead_list_ptr = bead_ptr -> bead.next_ptr;
      399 	end;
      400 /**** DEBUG  	     if debugging then call ioa_ ("Allocated bead at ^p.", bead_ptr); /* DEBUG */
      401 
      402 	bead_ptr -> bead.time = time;
      403 	bead_ptr -> bead.alarm = (type = Alarm);
      404 	bead_ptr -> bead.cpu = (type = CPU);
      405 	bead_ptr -> bead.inhibit = (inhibit = Inhibit);
      406 	bead_ptr -> bead.call = (action = Call);
      407 	bead_ptr -> bead.wakeup = (action = Wakeup);
      408 	bead_ptr -> bead.data_ptr_provided = data_ptr_provided;
      409 	bead_ptr -> bead.channel = channel;
      410 	bead_ptr -> bead.routine = routine;
      411 	bead_ptr -> bead.data_ptr = data_ptr;
      412 	bead_ptr -> bead.control_point_id = get_control_point_id_ ();
      413 
      414 	if prev_bead_ptr = null then do;		/* The new bead was placed at the head of the list */
      415 	     bead_ptr -> bead.next_ptr = start_list_ptr;
      416 	     start_list_ptr = bead_ptr;
      417 	     if type = Alarm
      418 	     then start_alarm_list_ptr = start_list_ptr;
      419 	     else start_cpu_list_ptr = start_list_ptr;
      420 
      421 /* Since the new bead is now the first scheduled to occur, we must (re)set the appropriate timer to the new time. */
      422 
      423 	     call set_next_timer;
      424 	end;
      425 
      426 	else do;
      427 	     bead_ptr -> bead.next_ptr = prev_bead_ptr -> bead.next_ptr;
      428 	     prev_bead_ptr -> bead.next_ptr = bead_ptr;
      429 	end;
      430 
      431 /**** DEBUG  	     if debugging_chain then call display_chain (start_list_ptr); /* DEBUG */
      432 	call hcs_$reset_ips_mask (saved_mask, saved_mask);
      433 	return;





      434 
      435 unschedule_timer:
      436      entry (type, action, channel, routine, data_ptr, data_ptr_provided);
      437 
      438 dcl  removed_first bit (1) aligned;
      439 
      440 	call initialize (Full);
      441 
      442 /* Mask down so we won't be bothered by asynchronous processing or unexpected recursion */
      443 
      444 	saved_mask = "0"b;
      445 
      446 	on cleanup
      447 	     begin;
      448 	     if substr (saved_mask, 36, 1) = "1"b
      449 	     then call hcs_$reset_ips_mask (saved_mask, saved_mask);
      450 	end;
      451 
      452 	call hcs_$set_ips_mask (alrm_cput_quit_mask, saved_mask);
      453 						/* disable alrm, cput, quit */
      454 
      455 
      456 /* Search down appropriate list and get rid of matching entries */
      457 
      458 	if type = Alarm
      459 	then start_list_ptr = start_alarm_list_ptr;
      460 	else start_list_ptr = start_cpu_list_ptr;
      461 
      462 	removed_first = ""b;
      463 	prev_bead_ptr = null;
      464 
      465 	do bead_ptr = start_list_ptr repeat (next_bead_ptr) while (bead_ptr ^= null);
      466 	     next_bead_ptr = bead_ptr -> bead.next_ptr;
      467 
      468 	     if action = Wakeup
      469 	     then if bead_ptr -> bead.channel = channel
      470 		then call remove_bead (bead_ptr, prev_bead_ptr);
      471 		else prev_bead_ptr = bead_ptr;
      472 	     else if bead_ptr -> bead.routine = routine
      473 	     then if data_ptr_provided
      474 		then if data_ptr = bead_ptr -> bead.data_ptr
      475 		     then call remove_bead (bead_ptr, prev_bead_ptr);
      476 		     else prev_bead_ptr = bead_ptr;
      477 		else call remove_bead (bead_ptr, prev_bead_ptr);
      478 	     else prev_bead_ptr = bead_ptr;
      479 	end;
      480 
      481 	if removed_first
      482 	then call set_next_timer;
      483 
      484 	call hcs_$reset_ips_mask (saved_mask, saved_mask);
      485 	return;


      486 
      487 process_interrupt:
      488      entry (type, mc_ptr, condition_name, hc_mc_ptr, continue);
      489 
      490 dcl  (
      491      mc_ptr pointer,
      492      condition_name char (*),
      493      hc_mc_ptr pointer,
      494      continue bit (1) aligned
      495      ) parameter;
      496 
      497 dcl  code fixed bin (35),
      498      temp_mask bit (36) aligned,
      499      wakeup_message char (8) aligned;
      500 
      501 dcl  1 auto_bead automatic,
      502        2 next_ptr pointer,
      503        2 info like schedule.timer;
      504 
      505 /**** DEBUG  	     if debugging then do;			/* DEBUG */
      506 /**** DEBUG  		call ioa_ ("Processing interrupt for ^a", condition_name); /* DEBUG */
      507 /**** DEBUG  		call hcs_$set_ips_mask ((36)"1"b, ""b); /* DEBUG */
      508 /**** DEBUG  	     end;					/* DEBUG */
      509 
      510 	if type = Alarm
      511 	then start_list_ptr = start_alarm_list_ptr;
      512 	else start_list_ptr = start_cpu_list_ptr;
      513 
      514 /* First, check if the timer that went off was expected.  Unexpected timers can
      515*   occur in three ways.  One, somebody may be fiddling around with the hardcore
      516*   timers (naughty).  Two, a timer may have gone off right while we were masked
      517*   and busy removing the very same timer from the list (via the reset entries).
      518*   Three, there is presently a minor problem in hardcore that causes CPU timers
      519*   to go off a bit too early (the timer is rung with respect to a CPU time that
      520*   includes page fault time, whereas the real virtual CPU time doesn't).  Since
      521*   we can't tell the difference in order to slap anyone's wrists, if we get any
      522*   unscheduled timers, we just grin and swallow them.  In addition, we re-force
      523*   the correct (expected) timer back into hardcore. */
      524 
      525 	if start_list_ptr = null then do;		/* didn't expect ANY such timer */
      526 	     call set_next_timer;			/* turn off HC timer */
      527 	     return;
      528 	end;
      529 
      530 	if type = Alarm
      531 	then if start_list_ptr -> bead.time > clock () then do;
      532 /**** DEBUG  		     if debugging then call ioa_ ("Unexpected alrm, rescheduling."); /* DEBUG */
      533 		call set_next_timer;
      534 		return;
      535 	     end;
      536 	     else ;
      537 	else if start_list_ptr -> bead.time > vclock () then do;
      538 /**** DEBUG  		if debugging then call ioa_ ("Unexpected cput, rescheduling."); /* DEBUG */
      539 	     call set_next_timer;
      540 	     return;
      541 	end;
      542 
      543 	unspec (auto_bead) = unspec (start_list_ptr -> bead);
      544 
      545 	call remove_bead (start_list_ptr, null);
      546 	call set_next_timer;
      547 
      548 	if auto_bead.call then do;
      549 /**** DEBUG  		if debugging then call ioa_ ("Processing the call."); /* DEBUG */
      550 	     if ^auto_bead.inhibit
      551 	     then call hcs_$set_ips_mask (allow_all_mask, "0"b);
      552 
      553 	     else on cleanup
      554 		     begin;			/* restore mask if fault and release while inhibited */
      555 		     if mc_ptr ^= null then do;
      556 			temp_mask = mc_ptr -> mc.ips_temp;
      557 			if substr (temp_mask, 36, 1)
      558 			then call hcs_$reset_ips_mask (temp_mask, "0"b);
      559 		     end;
      560 		end;
      561 
      562 	     if have_multiple_control_points ()		/* must always use cpm_ to insure I/O switches are OK */
      563 	     then call call_routine_in_other_control_point ();
      564 	     else call auto_bead.routine (mc_ptr, condition_name, hc_mc_ptr, auto_bead.data_ptr);
      565 	end;
      566 
      567 	else if auto_bead.wakeup then do;
      568 /**** DEBUG  		if debugging then call ioa_ ("Processing the wakeup."); /* DEBUG */
      569 	     if type = Alarm
      570 	     then wakeup_message = "alarm___";
      571 	     else wakeup_message = "cpu_time";
      572 	     call hcs_$wakeup (my_processid, auto_bead.channel, wakeup_message, code);
      573 	     if code ^= 0
      574 	     then if code ^= error_table_$invalid_channel
      575 		then call signal_timer_manager_err;	/* only acceptable error is user destroyed his channel */
      576 	end;
      577 
      578 	return;





      579 
      580 have_multiple_control_points:
      581 	procedure () returns (bit (1) aligned);
      582 
      583 	     if stackbaseptr () -> stack_header.cpm_enabled
      584 	     then return (cpm_data_$n_control_points > 1);
      585 	     else return ("0"b);
      586 
      587 	end have_multiple_control_points;





      588 
      589 call_routine_in_other_control_point:
      590 	procedure ();
      591 
      592 	     call_timer_info_condition_name_lth = length (condition_name);
      593 	     allocate call_timer_info in (sys_area) set (call_timer_info_ptr);
      594 
      595 	     call_timer_info.routine = auto_bead.routine;
      596 	     call_timer_info.mc_ptr = mc_ptr;
      597 	     call_timer_info.hc_mc_ptr = hc_mc_ptr;
      598 	     call_timer_info.data_ptr = auto_bead.data_ptr;
      599 	     call_timer_info.condition_name = condition_name;
      600 
      601 	     call cpm_$generate_call_preferred (auto_bead.control_point_id, invoke_users_routine, call_timer_info_ptr,
      602 		code);
      603 
      604 	     return;
      605 
      606 	end call_routine_in_other_control_point;





      607 
      608 remove_bead:
      609 	proc (a_bead_ptr, prev_bead_ptr);
      610 
      611 dcl  (a_bead_ptr, prev_bead_ptr) pointer parameter;
      612 
      613 dcl  bead_ptr pointer,
      614      next_bead_ptr pointer;
      615 
      616 	     bead_ptr = a_bead_ptr;
      617 
      618 	     if prev_bead_ptr = null then do;
      619 
      620 		removed_first = "1"b;
      621 		start_list_ptr = bead_ptr -> bead.next_ptr;
      622 
      623 		if type = Alarm
      624 		then start_alarm_list_ptr = start_list_ptr;
      625 		else start_cpu_list_ptr = start_list_ptr;
      626 	     end;
      627 
      628 	     else prev_bead_ptr -> bead.next_ptr = bead_ptr -> bead.next_ptr;
      629 
      630 	     next_bead_ptr = bead_ptr -> bead.next_ptr;
      631 
      632 /**** DEBUG  		if debugging then			/* DEBUG */
      633 /**** DEBUG 		     call ioa_ ("Removed bead at ^p^[; was first bead^;^].", bead_ptr, removed_first); /* DEBUG */
      634 	     bead_ptr -> bead.next_ptr = free_bead_list_ptr;
      635 	     free_bead_list_ptr = bead_ptr;
      636 
      637 
      638 	     a_bead_ptr = next_bead_ptr;
      639 /**** DEBUG  		if debugging_chain then call display_chain (start_list_ptr); /* DEBUG */
      640 	     return;
      641 
      642 	end remove_bead;


      643 
      644 set_next_timer:
      645 	proc;
      646 
      647 	     if type = Alarm
      648 	     then if start_alarm_list_ptr ^= null then do;
      649 /**** DEBUG  			if debugging then do;	/* DEBUG */
      650 /**** DEBUG  			     call date_time_ (start_alarm_list_ptr -> bead.time, junk_string); /* DEBUG */
      651 /**** DEBUG  			     call ioa_ ("Setting HC alarm for ^a (^d) from ^p.", junk_string, /* DEBUG */
      652 /**** DEBUG  				start_alarm_list_ptr -> bead.time, start_alarm_list_ptr); /* DEBUG */
      653 /**** DEBUG  			end;			/* DEBUG */
      654 
      655 		     call hcs_$set_alarm_timer (start_alarm_list_ptr -> bead.time, Absolute_setting, 0);
      656 		end;
      657 		else do;
      658 /**** DEBUG  			if debugging then call ioa_ ("Turning HC alarm off."); /* DEBUG */
      659 		     call hcs_$set_alarm_timer (Forever, Absolute_setting, 0);
      660 						/* Hardcore interprets a number this big as "shut up" */
      661 		end;
      662 	     else if start_cpu_list_ptr ^= null then do;
      663 /**** DEBUG  		     if debugging then call ioa_ ("Setting HC CPU timer to ^6.3f from ^p.", /* DEBUG */
      664 /**** DEBUG 			start_cpu_list_ptr -> bead.time / 1e6, /* DEBUG */
      665 /**** DEBUG  			start_cpu_list_ptr);	/* DEBUG */
      666 		call hcs_$set_cpu_timer (start_cpu_list_ptr -> bead.time, Absolute_setting, 0);
      667 	     end;
      668 	     else do;
      669 /**** DEBUG  		     if debugging then call ioa_ ("Turning HC CPU timer off."); /* DEBUG */
      670 		call hcs_$set_cpu_timer (0, Absolute_setting, 0);
      671 						/* pxss, on the other hand, likes zeroes for that purpose */
      672 	     end;
      673 
      674 	     return;
      675 	end set_next_timer;
      676 
      677 get_schedule:
      678      entry (area_ptr, schedule_ptr, a_code);
      679 
      680 dcl  (
      681      area_ptr pointer,
      682      schedule_ptr pointer parameter,
      683      a_code fixed bin (35)
      684      ) parameter;
      685 
      686 dcl  timer_idx fixed bin;
      687 
      688 dcl  user_area area (sys_info$max_seg_size) based (area_ptr);
      689 
      690 	saved_mask = ""b;
      691 
      692 	on cleanup
      693 	     begin;
      694 	     if substr (saved_mask, 36, 1)
      695 	     then call hcs_$reset_ips_mask (saved_mask, saved_mask);
      696 	end;
      697 
      698 	schedule_ptr = null;
      699 
      700 	call hcs_$set_ips_mask (alrm_cput_mask, saved_mask);
      701 
      702 /* Count the outstanding scheduled timers */
      703 
      704 	N_Timers = 0;
      705 
      706 	do bead_ptr = start_alarm_list_ptr repeat (bead_ptr -> bead.next_ptr) while (bead_ptr ^= null),
      707 	     start_cpu_list_ptr repeat (bead_ptr -> bead.next_ptr) while (bead_ptr ^= null);
      708 	     N_Timers = N_Timers + 1;
      709 	end;
      710 
      711 	on area
      712 	     begin;
      713 	     a_code = error_table_$noalloc;
      714 	     goto return_hard;
      715 	end;
      716 
      717 	allocate schedule in (user_area) set (schedule_ptr);
      718 
      719 	revert area;
      720 
      721 	schedule_ptr -> schedule.version = timer_manager_schedule_version_3;
      722 
      723 	timer_idx = 0;
      724 	do bead_ptr = start_alarm_list_ptr repeat (bead_ptr -> bead.next_ptr) while (bead_ptr ^= null),
      725 	     start_cpu_list_ptr repeat (bead_ptr -> bead.next_ptr) while (bead_ptr ^= null);
      726 	     timer_idx = timer_idx + 1;
      727 	     call fill_slot (bead_ptr);
      728 	end;
      729 
      730 	a_code = 0;
      731 
      732 return_hard:
      733 	call hcs_$reset_ips_mask (saved_mask, saved_mask);
      734 
      735 	return;


      736 
      737 fill_slot:
      738 	proc (bead_ptr);
      739 
      740 dcl  bead_ptr pointer parameter;
      741 
      742 	     unspec (schedule_ptr -> schedule.timer (timer_idx)) = unspec (bead_ptr -> bead.info);
      743 	     return;
      744 	end fill_slot;
      745      end schedule_timer;
      746 
      747 sleep:
      748      proc (time, lss);
      749 
      750 dcl  time fixed bin (71) parameter,
      751      lss bit (1) aligned parameter;
      752 
      753 dcl  1 wait_list aligned,
      754        2 number_of_channels fixed bin,
      755        2 sleep_channel fixed bin (71);
      756 
      757 dcl  1 block_message aligned,
      758        2 channel_id fixed bin (71),
      759        2 message fixed bin (71),
      760        2 sender_processid bit (36),
      761        2 origin,
      762          3 device bit (18) unaligned,
      763          3 ring fixed bin (18) unaligned unsigned,
      764        2 channel_index fixed bin;
      765 
      766 dcl  code fixed bin (35),
      767      cur_mask bit (36) aligned,
      768      old_channel fixed bin (71),
      769      old_timer fixed bin (71);
      770 
      771 	call initialize (Limited);			/* if we need any more, someone else will do it */
      772 
      773 
      774 	wait_list.number_of_channels = 1;
      775 	sleep_channel = -1;
      776 
      777 	on cleanup
      778 	     begin;
      779 	     if sleep_channel ^= -1
      780 	     then do;
      781 		call ipc_$delete_ev_chn (sleep_channel, code);
      782 		call unschedule_timer (Alarm, Wakeup, sleep_channel, signal_timer_manager_err, null(), "0"b);
      783 		sleep_channel = -1;
      784 	     end;
      785 	end;
      786 
      787 /*	     call hcs_$assign_channel (sleep_channel, code); /* HC bug causes fast channels to fail right now. */
      788 /*	     if code ^= 0 then			/* maybe no fast channels left */
      789 	if saved_channel_count > 0 then do;
      790 	     saved_channel_count = saved_channel_count - 1;
      791 	     sleep_channel = saved_channel_array (saved_channel_count + 1);
      792 	end;
      793 	else do;
      794 	     call ipc_$create_ev_chn (sleep_channel, code);
      795 	     if code /* still */ ^= 0
      796 	     then call signal_timer_manager_err;
      797 	end;
      798 
      799 	call hcs_$get_ips_mask (cur_mask);
      800 
      801 /**** DEBUG  	     if debugging then do;			/* DEBUG */
      802 /**** DEBUG  		call date_time_ (time, junk_string);	/* DEBUG */
      803 /**** DEBUG  		call ioa_ ("Sleeping until ^a (^d).", junk_string, time); /* DEBUG */
      804 /**** DEBUG  	     end;					/* DEBUG */
      805 
      806 	if (lss | (this_ring ^= initial_ring) | (bool (cur_mask, alrm_disabled_mask, "1000"b) ^= ""b))
      807 	then begin;
      808 
      809 /* Here, we either want to or have to do the whole thing manually.  If this is
      810*   as LSS nap, we don't want any other interrupts to occur.  If alrms are
      811*   masked, they CAN'T occur-- and neither can our own.  If we are executing in
      812*   an inner ring (or other ring than initial ring) we can't take advantage of
      813*   the timer-queuing properties of schedule_timer anyway. */
      814 
      815 /**** DEBUG  		if debugging then call ioa_ ("Sleeping the hard way."); /* DEBUG */
      816 
      817 	     old_channel = -1;
      818 
      819 	     on cleanup
      820 		begin;
      821 		if old_channel ^= -1
      822 		then call hcs_$set_alarm_timer (old_timer, Absolute_setting, old_channel);
      823 	     end;
      824 
      825 	     call hcs_$get_alarm_timer (old_timer, old_channel);
      826 /**** DEBUG  		if debugging then call ioa_ ("Old timer was ^d on channel ^o.", old_timer, old_channel); /* DEBUG */
      827 
      828 	     call hcs_$set_alarm_timer (time, Absolute_setting, sleep_channel);
      829 /**** DEBUG  		if debugging then do;		/* DEBUG */
      830 /**** DEBUG  		     call hcs_$get_alarm_timer (junk_time, junk_channel); /* DEBUG */
      831 /**** DEBUG  		     call ioa_ ("HC verifies new timer as ^d on channel ^o.", junk_time, junk_channel); /* DEBUG */
      832 /**** DEBUG  		end;				/* DEBUG */
      833 
      834 	     call ipc_$block (addr (wait_list), addr (block_message), code);
      835 	     if code ^= 0
      836 	     then call signal_timer_manager_err;
      837 
      838 /**** DEBUG  		if debugging then call ioa_ ("Returned from block."); /* DEBUG */
      839 
      840 	     call hcs_$set_alarm_timer (old_timer, Absolute_setting, old_channel);
      841 	     old_channel = -1;
      842 	end;
      843 
      844 	else do;					/* normal case, use queuing mechanism */
      845 /**** DEBUG  		if debugging then call ioa_ ("Sleeping the easy way."); /* DEBUG */
      846 
      847 	     call schedule_timer (time, Alarm, No_inhibit, Wakeup, sleep_channel, signal_timer_manager_err, null (),
      848 		"0"b);
      849 
      850 	     call ipc_$block (addr (wait_list), addr (block_message), code);
      851 	     if code ^= 0
      852 	     then call signal_timer_manager_err;
      853 
      854 /**** DEBUG  		if debugging then call ioa_ ("Returned from block."); /* DEBUG */
      855 
      856 	end;
      857 
      858 	if saved_channel_count >= hbound (saved_channel_array, 1) then do;
      859 	     call ipc_$delete_ev_chn (sleep_channel, code);
      860 	     if code ^= 0
      861 	     then call signal_timer_manager_err;
      862 	     return;
      863 	end;
      864 	else do;
      865 	     saved_channel_array (saved_channel_count + 1) = sleep_channel;
      866 	     saved_channel_count = saved_channel_count + 1;
      867 	     return;
      868 	end;
      869 
      870      end sleep;
      871 
      872 abs_time:
      873      proc (time, flags, type) returns (fixed bin (71));
      874 dcl  time fixed bin (71) parameter,
      875      flags bit (2) parameter,
      876      type bit (1) aligned parameter;
      877 
      878 dcl  abstime fixed bin (71);
      879 
      880 /* Compute the absolute time from the given time according to the flags the user indicated */
      881 
      882 	abstime = time;
      883 
      884 	if substr (flags, 2, 1)
      885 	then abstime = abstime * Million;		/* change seconds to microseconds */
      886 
      887 	if substr (flags, 1, 1)
      888 	then if type = CPU
      889 	     then abstime = abstime + vclock ();
      890 	     else abstime = abstime + clock ();
      891 
      892 	if abstime <= 0
      893 	then abstime = 1;				/* go off right away */
      894 
      895 	return (abstime);
      896 
      897      end abs_time;
      898 
      899 initialize:
      900      proc (necessary_mechanism);
      901 
      902 dcl  necessary_mechanism fixed bin parameter;
      903 
      904 dcl  alrm_cput_auto_mask bit (36) aligned,
      905      old_auto_ips_mask bit (36) aligned,
      906      old_ips_mask bit (36) aligned;
      907 
      908 	if initial_ring = 1
      909 	then if my_group_id = Initializer
      910 	     then initialized_mechanism = Uninitialized;
      911 
      912 	goto step (initialized_mechanism);
      913 
      914 step (0):						/* initialize limited mechanism */
      915 /**** The limited mechanism suffices for timer_manager_$sleep in inner rings */
      916 	this_ring = get_ring_ ();
      917 	initial_ring = get_initial_ring_ ();
      918           my_group_id = get_group_id_ ();
      919 	my_processid = get_process_id_ ();
      920 	sys_areap = get_system_free_area_ ();
      921 
      922 	call create_ips_mask_ (addr (IPS_names), 1, alrm_disabled_mask);
      923 	substr (alrm_disabled_mask, 36, 1) = "1"b;
      924 
      925 	call create_ips_mask_ (addr (IPS_names), 3, alrm_cput_quit_mask);
      926 	call create_ips_mask_ (addr (All_IPS), 1, allow_all_mask);
      927 	allow_all_mask = ^allow_all_mask;
      928 
      929 	initialized_mechanism = Limited;
      930 
      931 step (1):
      932 	if initialized_mechanism >= necessary_mechanism
      933 	then return;
      934 
      935 
      936 /**** The mechanism set up by this section will only work in the process'
      937*      initial ring.  This is because the list of timers is kept in per-ring
      938*      static, and therefore, any given ring can not know what timers are
      939*      outstanding in other rings.  Since there is only one REAL timer, this
      940*      would be terminally confusing.  Therefore, we limit ourselves to
      941*      operation in the user ring. */
      942 	if this_ring ^= initial_ring
      943 	then call signal_timer_manager_err;
      944 
      945 
      946 /* Now we want to diddle the automatic IPS mask.  Not precisely a mask, this is
      947*   really a set of indicators corresponding to IPS interrupts.  Whenever an IPS
      948*   interrupt indicated in the mask occurs, hardcore automatically masks ALL IPS
      949*   interrupts off before handling it.  It is the job of the handler to remember
      950*   to reset the IPS mask back to what it was.  The old mask can be found in the
      951*   machine conditions. */
      952 
      953 
      954 	call create_ips_mask_ (addr (IPS_names), 2, alrm_cput_mask);
      955 	alrm_cput_auto_mask = ^alrm_cput_mask;
      956 
      957 	old_auto_ips_mask, old_ips_mask = ""b;
      958 
      959 	on cleanup
      960 	     begin;
      961 	     if substr (old_auto_ips_mask, 36, 1)
      962 	     then call hcs_$set_automatic_ips_mask (old_auto_ips_mask, old_auto_ips_mask);
      963 
      964 	     if substr (old_ips_mask, 36, 1)
      965 	     then call hcs_$set_ips_mask (old_ips_mask, old_ips_mask);
      966 	end;
      967 
      968 	call hcs_$set_ips_mask (""b, old_ips_mask);	/* mask down while diddling auto mask */
      969 
      970 	call hcs_$set_automatic_ips_mask (""b, old_auto_ips_mask);
      971 						/* get current auto mask */
      972 
      973 	old_auto_ips_mask = alrm_cput_auto_mask | old_auto_ips_mask;
      974 						/* carry forward any indicators anyone else might have set */
      975 
      976 	call hcs_$set_automatic_ips_mask (old_auto_ips_mask, ""b);
      977 
      978 	old_auto_ips_mask = ""b;
      979 
      980 	call hcs_$reset_ips_mask (old_ips_mask, old_ips_mask);
      981 
      982 	initialized_mechanism = Full;
      983 step (2):
      984 	return;
      985 
      986      end initialize;





      987 
      988 signal_timer_manager_err:
      989      proc;
      990 
      991 	do while ("1"b);
      992 	     signal timer_manager_err;
      993 	end;
      994      end signal_timer_manager_err;
      995 
      996 /**** DEBUG  display_chain: proc (lp);			/* DEBUG */
      997 /**** DEBUG  dcl (lp, bp) pointer;			/* DEBUG */
      998 /**** DEBUG 						/* DEBUG */
      999 /**** DEBUG  dcl 1 auto_bead automatic,			/* DEBUG */
     1000 /**** DEBUG      2 next_ptr pointer,			/* DEBUG */
     1001 /**** DEBUG      2 info like schedule.timer;		/* DEBUG */
     1002 /**** DEBUG 						/* DEBUG */
     1003 /**** DEBUG  dcl  sysprint stream;			/* DEBUG */
     1004 /**** DEBUG 						/* DEBUG */
     1005 /**** DEBUG  	     put data (lp); put skip (2);		/* DEBUG */
     1006 /**** DEBUG  	     do bp = lp repeat (bp -> bead.next_ptr) while (bp ^= null); /* DEBUG */
     1007 /**** DEBUG  		put data (bp); put skip;		/* DEBUG */
     1008 /**** DEBUG  		unspec (auto_bead) = unspec (bp -> bead); /* DEBUG */
     1009 /**** DEBUG  		put data (auto_bead); put skip (2);	/* DEBUG */
     1010 /**** DEBUG  	     end;					/* DEBUG */
     1011 /**** DEBUG 						/* DEBUG */
     1012 /**** DEBUG  	     return;				/* DEBUG */
     1013 /**** DEBUG  	end display_chain;				/* DEBUG */
     1014 /**** DEBUG 						/* DEBUG */
     1015 /**** DEBUG  debug:	entry;				/* DEBUG */
     1016 /**** DEBUG 						/* DEBUG */
     1017 /**** DEBUG  dcl (debugging, debugging_chain) bit (1) aligned static initial (""b); /* DEBUG */
     1018 /**** DEBUG 						/* DEBUG */
     1019 /**** DEBUG  dcl  ioa_ ext entry options (variable),		/* DEBUG */
     1020 /**** DEBUG       junk_time fixed bin (71),			/* DEBUG */
     1021 /**** DEBUG       junk_channel fixed bin (71),		/* DEBUG */
     1022 /**** DEBUG       junk_string char (24),			/* DEBUG */
     1023 /**** DEBUG       date_time_ ext entry (fixed bin (71), char (*)); /* DEBUG */
     1024 /**** DEBUG 						/* DEBUG */
     1025 /**** DEBUG  	debugging = "1"b;				/* DEBUG */
     1026 /**** DEBUG  	debugging_chain = ""b;			/* DEBUG */
     1027 /**** DEBUG  	return;					/* DEBUG */
     1028 /**** DEBUG 						/* DEBUG */
     1029 /**** DEBUG  nodebug:	entry;				/* DEBUG */
     1030 /**** DEBUG 						/* DEBUG */
     1031 /**** DEBUG  	debugging, debugging_chain = ""b;		/* DEBUG */
     1032 /**** DEBUG  	return;					/* DEBUG */
     1033 /**** DEBUG 						/* DEBUG */
     1034 /**** DEBUG  debug_chain: entry;				/* DEBUG */
     1035 /**** DEBUG 						/* DEBUG */
     1036 /**** DEBUG  	debugging, debugging_chain = "1"b;		/* DEBUG */
     1037 /**** DEBUG  	return;					/* DEBUG */
     1038 
     1039      end timer_manager_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0803.5  timer_manager_.pl1                >spec>install>1110>timer_manager_.pl1
182          1    11/07/86  1550.3  timer_manager_schedule.incl.pl1   >ldd>include>timer_manager_schedule.incl.pl1
183          2    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
184          3    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
185          4    11/07/86  1550.3  cpm_data_.incl.pl1                >ldd>include>cpm_data_.incl.pl1
186          5    11/07/86  1550.3  cpm_entries.incl.pl1              >ldd>include>cpm_entries.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Absolute_setting                000070 constant        fixed bin(17,0)          initial dcl 116 set ref 655* 659* 666* 670* 821*
                                                                                  828* 840*
Alarm                           000056 constant        bit(1)                   initial dcl 116 set ref 193* 193* 193* 201* 201*
                                                                                  201* 224* 224* 224* 238* 238* 244* 244* 251* 257*
                                                                                  285* 383 403 417 458 510 530 569 623 647 782* 847*
All_IPS                         000033 constant        char(32)                 initial array dcl 116 set ref 926 926
CPU                             000106 constant        bit(1)                   initial dcl 116 set ref 209* 209* 209* 217* 217*
                                                                                  217* 231* 231* 231* 264* 270* 291* 404 887
Call                            000056 constant        bit(1)                   initial dcl 116 set ref 193* 201* 209* 217* 251*
                                                                                  264* 406
Forever                         000044 constant        fixed bin(71,0)          initial dcl 116 set ref 659*
Full                            000070 constant        fixed bin(17,0)          initial dcl 116 set ref 363* 440* 982
IPS_names                       000003 constant        char(32)                 initial array dcl 116 set ref 922 922 925 925 954
                                                                                  954
Inhibit                         000056 constant        bit(1)                   initial dcl 116 set ref 201* 217* 405
Initializer                     000047 constant        char(23)                 initial packed unaligned dcl 116 ref 908
Limited                         000072 constant        fixed bin(17,0)          initial dcl 116 set ref 771* 929
Million                         000046 constant        fixed bin(35,0)          initial dcl 116 ref 884
N_Timers                        000116 automatic       fixed bin(17,0)          dcl 1-33 set ref 704* 708* 708 717 717
No_inhibit                      000106 constant        bit(1)                   initial dcl 116 set ref 193* 209* 224* 231* 847*
Uninitialized                          constant        fixed bin(17,0)          initial dcl 116 ref 908
Wakeup                          000106 constant        bit(1)                   initial dcl 116 set ref 224* 231* 257* 270* 407 468
                                                                                  782* 847*
a_bead_ptr                             parameter       pointer                  dcl 611 set ref 608 616 638*
a_call_timer_info_ptr                  parameter       pointer                  dcl 80 ref 294 297
a_channel                              parameter       fixed bin(71,0)          dcl 66 set ref 221 224* 228 231* 254 257* 267 270*
a_code                                 parameter       fixed bin(35,0)          dcl 680 in procedure "schedule_timer" set ref 677
                                                                                  713* 730*
a_code                                 parameter       fixed bin(35,0)          dcl 71 in procedure "timer_manager_" set ref 273
                                                                                  276*
a_condition_name                       parameter       char                     packed unaligned dcl 74 set ref 282 285* 288 291*
a_continue                             parameter       bit(1)                   dcl 74 set ref 282 285* 288 291*
a_data_ptr                             parameter       pointer                  dcl 331 set ref 316 321* 325*
a_data_ptr_provided                    parameter       bit(1)                   dcl 332 set ref 316 322* 326*
a_flags                                parameter       bit(2)                   packed unaligned dcl 66 set ref 189 193* 193* 197
                                                                                  201* 201* 205 209* 209* 213 217* 217* 221 224*
                                                                                  224* 228 231* 231* 235 238* 238* 241 244* 244*
a_hc_mc_ptr                            parameter       pointer                  dcl 74 set ref 282 285* 288 291*
a_mc_ptr                               parameter       pointer                  dcl 74 set ref 282 285* 288 291*
a_routine                              parameter       entry variable           dcl 66 set ref 189 193* 197 201* 205 209* 213 217*
                                                                                  247 251* 260 264*
a_time                                 parameter       fixed bin(71,0)          dcl 66 set ref 189 193* 193* 197 201* 201* 205 209*
                                                                                  209* 213 217* 217* 221 224* 224* 228 231* 231* 235
                                                                                  238* 238* 241 244* 244*
abstime                         000144 automatic       fixed bin(71,0)          dcl 878 set ref 882* 884* 884 887* 887 890* 890 892
                                                                                  892* 895
action                                 parameter       bit(1)                   dcl 344 ref 341 406 407 435 468
addr                                                   builtin function         dcl 176 ref 834 834 834 834 850 850 850 850 922 922
                                                                                  925 925 926 926 954 954
alarm                     4(01)        based           bit(1)                   level 4 packed packed unaligned dcl 158 set ref 403*
allow_all_mask                  000010 internal static bit(36)                  initial dcl 90 set ref 550* 926* 927* 927
alrm_cput_auto_mask             000100 automatic       bit(36)                  dcl 904 set ref 955* 973
alrm_cput_mask                  000011 internal static bit(36)                  initial dcl 90 set ref 700* 954* 955
alrm_cput_quit_mask             000012 internal static bit(36)                  initial dcl 90 set ref 375* 452* 925*
alrm_disabled_mask              000013 internal static bit(36)                  initial dcl 90 set ref 806 922* 923*
area                            000000 stack reference condition                dcl 178 ref 711 719
area_ptr                               parameter       pointer                  dcl 680 in procedure "schedule_timer" ref 677 717
area_ptr                               parameter       pointer                  dcl 71 in procedure "timer_manager_" set ref 273
                                                                                  276*
arg_number                             parameter       fixed bin(17,0)          dcl 330 set ref 316 319*
auto_bead                       000122 automatic       structure                level 1 unaligned dcl 501 set ref 543*
based_ptr                              based           pointer                  dcl 337 ref 321
bead                                   based           structure                level 1 dcl 158 set ref 394 543
bead_ptr                        000100 automatic       pointer                  dcl 355 in procedure "schedule_timer" set ref 387*
                                                                                  387* 388 390* 391 394* 397* 398 402 403 404 405
                                                                                  406 407 408 409 410 411 412 415 416 427 428 465*
                                                                                  465* 466 468 468* 471 472 472 472* 476 477* 478*
                                                                                  706* 706 709 709 709* 724* 724 727* 728 728 728*
bead_ptr                        000224 automatic       pointer                  dcl 613 in procedure "remove_bead" set ref 616* 621
                                                                                  628 630 634 635
bead_ptr                               parameter       pointer                  dcl 740 in procedure "fill_slot" ref 737 742
block_message                   000104 automatic       structure                level 1 dcl 757 set ref 834 834 850 850
bool                                                   builtin function         dcl 176 ref 806
call                      4(03) 000122 automatic       bit(1)                   level 4 in structure "auto_bead" packed packed
                                                                                  unaligned dcl 501 in procedure "schedule_timer"
                                                                                  set ref 548
call                      4(03)        based           bit(1)                   level 4 in structure "bead" packed packed unaligned
                                                                                  dcl 158 in procedure "timer_manager_" set ref 406*
call_timer_info                        based           structure                level 1 dcl 162 set ref 301 311 593
call_timer_info_condition_name_lth
                                000106 automatic       fixed bin(21,0)          dcl 85 set ref 592* 593 593
call_timer_info_ptr             000104 automatic       pointer                  dcl 85 set ref 297* 301 301 303* 306 306 306 306 306
                                                                                  311 312* 593* 595 596 597 598 599 601*
channel                   6     000122 automatic       fixed bin(71,0)          level 3 in structure "auto_bead" dcl 501
                                                                                  in procedure "schedule_timer" set ref 572*
channel                                parameter       fixed bin(71,0)          dcl 344 in procedure "schedule_timer" ref 341 409
                                                                                  435 468
channel                   6            based           fixed bin(71,0)          level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 409* 468
cleanup                         000110 stack reference condition                dcl 178 ref 299 369 446 553 692 777 819 959
clock                                                  builtin function         dcl 176 ref 530 890
code                            000115 automatic       fixed bin(35,0)          dcl 497 in procedure "schedule_timer" set ref 572*
                                                                                  573 573 601*
code                            000113 automatic       fixed bin(35,0)          dcl 766 in procedure "sleep" set ref 781* 794* 795
                                                                                  834* 835 850* 851 859* 860
condition_name                         parameter       char                     packed unaligned dcl 490 in procedure
                                                                                  "schedule_timer" set ref 487 564* 592 599
condition_name           14            based           char                     level 2 in structure "call_timer_info" packed packed
                                                                                  unaligned dcl 162 in procedure "timer_manager_"
                                                                                  set ref 306* 599*
condition_name_lth        4            based           fixed bin(21,0)          level 2 dcl 162 set ref 301 306 306 311 593* 599
continue                               parameter       bit(1)                   dcl 490 ref 487
control_point_id         16     000122 automatic       bit(36)                  level 3 in structure "auto_bead" dcl 501
                                                                                  in procedure "schedule_timer" set ref 601*
control_point_id         16            based           bit(36)                  level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 412*
cpm_$generate_call_preferred    000132 constant        entry                    external dcl 5-35 ref 601
cpm_data_$n_control_points      000126 external static fixed bin(17,0)          dcl 4-13 ref 583
cpm_enabled              13(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-26 ref 583
cpu                       4(02)        based           bit(1)                   level 4 packed packed unaligned dcl 158 set ref 404*
create_ips_mask_                000062 constant        entry                    external dcl 136 ref 922 925 926 954
cu_$arg_ptr                     000064 constant        entry                    external dcl 136 ref 319
cur_mask                        000114 automatic       bit(36)                  dcl 766 set ref 799* 806
data_ptr                        000100 automatic       pointer                  dcl 82 in procedure "timer_manager_" set ref 192*
                                                                                  193* 200* 201* 208* 209* 216* 217* 250* 251* 263*
                                                                                  264*
data_ptr                 12            based           pointer                  level 2 in structure "call_timer_info" dcl 162
                                                                                  in procedure "timer_manager_" set ref 306* 598*
data_ptr                               parameter       pointer                  dcl 344 in procedure "schedule_timer" ref 341 411
                                                                                  435 472
data_ptr                 14            based           pointer                  level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 411* 472
data_ptr                 14     000122 automatic       pointer                  level 3 in structure "auto_bead" dcl 501
                                                                                  in procedure "schedule_timer" set ref 564* 598
data_ptr_provided                      parameter       bit(1)                   dcl 344 in procedure "schedule_timer" ref 341 408
                                                                                  435 472
data_ptr_provided               000102 automatic       bit(1)                   dcl 82 in procedure "timer_manager_" set ref 192*
                                                                                  193* 200* 201* 208* 209* 216* 217* 250* 251* 263*
                                                                                  264*
data_ptr_provided         4(05)        based           bit(1)                   level 4 in structure "bead" packed packed unaligned
                                                                                  dcl 158 in procedure "timer_manager_" set ref 408*
error_table_$invalid_channel    000056 external static fixed bin(35,0)          dcl 110 ref 573
error_table_$noalloc            000060 external static fixed bin(35,0)          dcl 110 ref 713
flags                     4            based           structure                level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_"
flags                                  parameter       bit(2)                   packed unaligned dcl 874 in procedure "abs_time" ref
                                                                                  872 884 887
flags                     4     000122 automatic       structure                level 3 in structure "auto_bead" packed packed
                                                                                  unaligned dcl 501 in procedure "schedule_timer"
found                           000102 automatic       bit(1)                   dcl 355 set ref 381* 387 388*
free_bead_list_ptr              000034 internal static pointer                  initial dcl 90 set ref 394 397 398* 634 635*
get_control_point_id_           000130 constant        entry                    external dcl 5-13 ref 412
get_group_id_                   000072 constant        entry                    external dcl 136 ref 918
get_initial_ring_               000074 constant        entry                    external dcl 136 ref 917
get_process_id_                 000076 constant        entry                    external dcl 136 ref 919
get_ring_                       000100 constant        entry                    external dcl 136 ref 914
get_system_free_area_           000102 constant        entry                    external dcl 136 ref 920
hbound                                                 builtin function         dcl 176 ref 858
hc_mc_ptr                10            based           pointer                  level 2 in structure "call_timer_info" dcl 162
                                                                                  in procedure "timer_manager_" set ref 306* 597*
hc_mc_ptr                              parameter       pointer                  dcl 490 in procedure "schedule_timer" set ref 487
                                                                                  564* 597
hcs_$get_alarm_timer            000106 constant        entry                    external dcl 136 ref 825
hcs_$get_ips_mask               000116 constant        entry                    external dcl 136 ref 799
hcs_$reset_ips_mask             000104 constant        entry                    external dcl 136 ref 371 432 448 484 557 694 732 980
hcs_$set_alarm_timer            000110 constant        entry                    external dcl 136 ref 655 659 821 828 840
hcs_$set_automatic_ips_mask     000112 constant        entry                    external dcl 136 ref 961 970 976
hcs_$set_cpu_timer              000114 constant        entry                    external dcl 136 ref 666 670
hcs_$set_ips_mask               000120 constant        entry                    external dcl 136 ref 375 452 550 700 964 968
hcs_$wakeup                     000122 constant        entry                    external dcl 136 ref 572
info                      2            based           structure                level 2 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 742
info                      2     000122 automatic       structure                level 2 in structure "auto_bead" unaligned dcl 501
                                                                                  in procedure "schedule_timer"
inhibit                   4            based           bit(1)                   level 4 in structure "bead" packed packed unaligned
                                                                                  dcl 158 in procedure "timer_manager_" set ref 405*
inhibit                                parameter       bit(1)                   dcl 344 in procedure "schedule_timer" ref 341 405
inhibit                   4     000122 automatic       bit(1)                   level 4 in structure "auto_bead" packed packed
                                                                                  unaligned dcl 501 in procedure "schedule_timer"
                                                                                  set ref 550
initial_ring                    000024 internal static fixed bin(17,0)          initial dcl 90 set ref 806 908 917* 942
initialized_mechanism           000025 internal static fixed bin(17,0)          initial dcl 90 set ref 908* 912 929* 931 982*
io_ptr                                 parameter       pointer                  dcl 74 ref 282 288
ipc_$block                      000124 constant        entry                    external dcl 136 ref 834 850
ipc_$create_ev_chn              000066 constant        entry                    external dcl 136 ref 794
ipc_$delete_ev_chn              000070 constant        entry                    external dcl 136 ref 781 859
ips_temp                 42            based           bit(36)                  level 2 packed packed unaligned dcl 2-12 ref 556
length                                                 builtin function         dcl 176 ref 592
lss                                    parameter       bit(1)                   dcl 750 ref 747 806
mc                                     based           structure                level 1 dcl 2-12
mc_ptr                                 parameter       pointer                  dcl 490 in procedure "schedule_timer" set ref 487
                                                                                  555 556 564* 596
mc_ptr                    6            based           pointer                  level 2 in structure "call_timer_info" dcl 162
                                                                                  in procedure "timer_manager_" set ref 306* 596*
my_group_id                     000014 internal static char(32)                 initial packed unaligned dcl 90 set ref 908 918*
my_processid                    000026 internal static bit(36)                  initial packed unaligned dcl 90 set ref 572* 919*
n_timers                  1            based           fixed bin(17,0)          level 2 dcl 1-13 set ref 717*
necessary_mechanism                    parameter       fixed bin(17,0)          dcl 902 ref 899 931
next_bead_ptr                   000226 automatic       pointer                  dcl 613 in procedure "remove_bead" set ref 630* 638
next_bead_ptr                   000104 automatic       pointer                  dcl 355 in procedure "schedule_timer" set ref 466*
                                                                                  479
next_ptr                               based           pointer                  level 2 dcl 158 set ref 391 398 415* 427* 427 428*
                                                                                  466 621 628* 628 630 634* 709 709 728 728
null                                                   builtin function         dcl 176 ref 224 224 231 231 257 257 270 270 301 303
                                                                                  312 325 382 387 394 414 463 465 525 545 545 555
                                                                                  618 647 662 698 706 709 724 728 782 782 847 847
number_of_channels              000100 automatic       fixed bin(17,0)          level 2 dcl 753 set ref 774*
old_auto_ips_mask               000101 automatic       bit(36)                  dcl 904 set ref 957* 961 961* 961* 970* 973* 973
                                                                                  976* 978*
old_channel                     000116 automatic       fixed bin(71,0)          dcl 766 set ref 817* 821 821* 825* 840* 841*
old_ips_mask                    000102 automatic       bit(36)                  dcl 904 set ref 957* 964 964* 964* 968* 980* 980*
old_timer                       000120 automatic       fixed bin(71,0)          dcl 766 set ref 821* 825* 840*
p_len                           000134 automatic       fixed bin(21,0)          dcl 335 set ref 319*
p_ptr                           000132 automatic       pointer                  dcl 334 set ref 319* 321
prev_bead_ptr                   000106 automatic       pointer                  dcl 355 in procedure "schedule_timer" set ref 382*
                                                                                  390* 414 427 428 463* 468* 471* 472* 476* 477*
                                                                                  478*
prev_bead_ptr                          parameter       pointer                  dcl 611 in procedure "remove_bead" ref 608 618 628
removed_first                   000114 automatic       bit(1)                   dcl 438 set ref 462* 481 620*
routine                  10     000122 automatic       entry variable           level 3 in structure "auto_bead" dcl 501
                                                                                  in procedure "schedule_timer" set ref 564 595
routine                                parameter       entry variable           dcl 344 in procedure "schedule_timer" ref 341 410
                                                                                  435 472
routine                                based           entry variable           level 2 in structure "call_timer_info" dcl 162
                                                                                  in procedure "timer_manager_" set ref 306 595*
routine                  10            based           entry variable           level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 410* 472
saved_channel_array             000036 internal static fixed bin(71,0)          initial array dcl 90 set ref 791 858 865*
saved_channel_count             000050 internal static fixed bin(17,0)          initial dcl 90 set ref 789 790* 790 791 858 865 866*
                                                                                  866
saved_mask                      000110 automatic       bit(36)                  dcl 355 set ref 367* 371 371* 371* 375* 432* 432*
                                                                                  444* 448 448* 448* 452* 484* 484* 690* 694 694*
                                                                                  694* 700* 732* 732*
schedule                               based           structure                level 1 dcl 1-13 set ref 717
schedule_ptr                           parameter       pointer                  dcl 680 in procedure "schedule_timer" set ref 677
                                                                                  698* 717* 721 742
schedule_ptr                           parameter       pointer                  dcl 1-33 in procedure "timer_manager_" set ref 273
                                                                                  276*
sleep_channel             2     000100 automatic       fixed bin(71,0)          level 2 dcl 753 set ref 775* 779 781* 782* 783* 791*
                                                                                  794* 828* 847* 859* 865
stack_header                           based           structure                level 1 dcl 3-26
stackbaseptr                                           builtin function         dcl 176 ref 583
start_alarm_list_ptr            000030 internal static pointer                  initial dcl 90 set ref 383 417* 458 510 623* 647 655
                                                                                  706 724
start_cpu_list_ptr              000032 internal static pointer                  initial dcl 90 set ref 385 419* 460 512 625* 662 666
                                                                                  706 724
start_list_ptr                  000112 automatic       pointer                  dcl 355 set ref 383* 385* 387 415 416* 417 419 458*
                                                                                  460* 465 510* 512* 525 530 537 543 545* 621* 623
                                                                                  625
substr                                                 builtin function         dcl 176 set ref 371 448 557 694 884 887 923* 961 964
sys_area                               based           area                     dcl 172 ref 301 311 394 593
sys_areap                       000052 internal static pointer                  initial dcl 90 set ref 301 311 394 593 920*
temp_mask                       000116 automatic       bit(36)                  dcl 497 set ref 556* 557 557*
this_ring                       000054 internal static fixed bin(17,0)          initial dcl 90 set ref 806 914* 942
time                                   parameter       fixed bin(71,0)          dcl 874 in procedure "abs_time" ref 872 882
time                                   parameter       fixed bin(71,0)          dcl 750 in procedure "sleep" set ref 747 828* 847*
time                      2            based           fixed bin(71,0)          level 3 in structure "bead" dcl 158 in procedure
                                                                                  "timer_manager_" set ref 388 402* 530 537 655*
                                                                                  666*
time                                   parameter       fixed bin(71,0)          dcl 344 in procedure "schedule_timer" ref 341 388
                                                                                  402
timer                     2            based           structure                array level 2 dcl 1-13 set ref 742*
timer_idx                       000144 automatic       fixed bin(17,0)          dcl 686 set ref 723* 726* 726 742
timer_manager_err               000000 stack reference condition                dcl 178 ref 992
timer_manager_schedule_version_3       constant        fixed bin(17,0)          initial dcl 1-33 ref 721
type                                   parameter       bit(1)                   dcl 344 in procedure "schedule_timer" ref 341 383
                                                                                  403 404 417 435 458 487 510 530 569 623 647
type                                   parameter       bit(1)                   dcl 874 in procedure "abs_time" ref 872 887
unspec                                                 builtin function         dcl 176 set ref 543* 543 742* 742
user_area                              based           area                     dcl 688 ref 717
vclock                                                 builtin function         dcl 176 ref 537 887
version                                based           fixed bin(17,0)          level 2 dcl 1-13 set ref 721*
wait_list                       000100 automatic       structure                level 1 dcl 753 set ref 834 834 850 850
wakeup                    4(04)        based           bit(1)                   level 4 in structure "bead" packed packed unaligned
                                                                                  dcl 158 in procedure "timer_manager_" set ref 407*
wakeup                    4(04) 000122 automatic       bit(1)                   level 4 in structure "auto_bead" packed packed
                                                                                  unaligned dcl 501 in procedure "schedule_timer"
                                                                                  set ref 567
wakeup_message                  000120 automatic       char(8)                  dcl 497 set ref 569* 571* 572*
x_code                          000135 automatic       fixed bin(35,0)          dcl 336 set ref 319* 320

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abx                                    internal static fixed bin(17,0)          initial dcl 2-42
apx                                    internal static fixed bin(17,0)          initial dcl 2-42
bbx                                    internal static fixed bin(17,0)          initial dcl 2-42
bpx                                    internal static fixed bin(17,0)          initial dcl 2-42
call_offset                            internal static fixed bin(17,0)          initial dcl 3-78
cpm_$block                      000000 constant        entry                    external dcl 5-26
cpm_$create                     000000 constant        entry                    external dcl 5-16
cpm_$destroy                    000000 constant        entry                    external dcl 5-19
cpm_$generate_call              000000 constant        entry                    external dcl 5-35
cpm_$generate_call_when_ready   000000 constant        entry                    external dcl 5-35
cpm_$get_control_point_meters   000000 constant        entry                    external dcl 5-50
cpm_$get_preferred_control_point
                                000000 constant        entry                    external dcl 5-41
cpm_$get_scheduler_meters       000000 constant        entry                    external dcl 5-52
cpm_$get_user_cl_intermediary   000000 constant        entry                    external dcl 5-30
cpm_$nulle                      000000 constant        entry                    external dcl 5-55
cpm_$pop_preferred_control_point
                                000000 constant        entry                    external dcl 5-47
cpm_$push_preferred_control_point
                                000000 constant        entry                    external dcl 5-45
cpm_$scheduler                  000000 constant        entry                    external dcl 5-28
cpm_$set_preferred_control_point
                                000000 constant        entry                    external dcl 5-43
cpm_$set_user_cl_intermediary   000000 constant        entry                    external dcl 5-30
cpm_$start                      000000 constant        entry                    external dcl 5-19
cpm_$stop                       000000 constant        entry                    external dcl 5-19
cpm_$wakeup                     000000 constant        entry                    external dcl 5-19
entry_offset                           internal static fixed bin(17,0)          initial dcl 3-78
hcs_$assign_channel             000000 constant        entry                    external dcl 136
lbx                                    internal static fixed bin(17,0)          initial dcl 2-42
lpx                                    internal static fixed bin(17,0)          initial dcl 2-42
mcp                                    automatic       pointer                  dcl 2-10
push_offset                            internal static fixed bin(17,0)          initial dcl 3-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 3-78
return_offset                          internal static fixed bin(17,0)          initial dcl 3-78
sb                                     automatic       pointer                  dcl 3-24
sbx                                    internal static fixed bin(17,0)          initial dcl 2-42
scu                                    based           structure                level 1 dcl 2-56
scup                                   automatic       pointer                  dcl 2-54
scux                                   based           structure                level 1 dcl 2-207
spx                                    internal static fixed bin(17,0)          initial dcl 2-42
stack_header_overlay                   based           fixed bin(17,0)          array dcl 3-94
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 110
timer_manager_schedule_version_1       internal static fixed bin(17,0)          initial dcl 1-33
timer_manager_schedule_version_2       internal static fixed bin(17,0)          initial dcl 1-33
tv_offset                              internal static fixed bin(17,0)          initial dcl 3-72

NAMES DECLARED BY EXPLICIT CONTEXT.
abs_time                        003651 constant        entry                    internal dcl 872 ref 193 193 201 201 209 209 217 217
                                                                                  224 224 231 231 238 238 244 244
alarm_call                      000132 constant        entry                    external dcl 189
alarm_call_inhibit              000214 constant        entry                    external dcl 197
alarm_interrupt                 001152 constant        entry                    external dcl 282
alarm_wakeup                    000444 constant        entry                    external dcl 221
call_routine_in_other_control_point
                                002717 constant        entry                    internal dcl 589 ref 562
cpu_call                        000276 constant        entry                    external dcl 205
cpu_call_inhibit                000360 constant        entry                    external dcl 213
cpu_time_interrupt              001220 constant        entry                    external dcl 288
cpu_wakeup                      000527 constant        entry                    external dcl 228
fill_slot                       003161 constant        entry                    internal dcl 737 ref 727
get_schedule                    001124 constant        entry                    external dcl 273
get_schedule                    002445 constant        entry                    internal dcl 677 in procedure "timer_manager_" ref
                                                                                  276
have_multiple_control_points    002700 constant        entry                    internal dcl 580 ref 562
initialize                      003715 constant        entry                    internal dcl 899 ref 363 440 771
invoke_users_routine            001267 constant        entry                    external dcl 294 ref 601 601
process_interrupt               002165 constant        entry                    internal dcl 487 ref 285 291
remove_bead                     003011 constant        entry                    internal dcl 608 ref 468 472 477 545
reset_alarm_call                000713 constant        entry                    external dcl 247
reset_alarm_wakeup              000755 constant        entry                    external dcl 254
reset_cpu_call                  001017 constant        entry                    external dcl 260
reset_cpu_wakeup                001060 constant        entry                    external dcl 267
return_hard                     002667 constant        label                    dcl 732 ref 714
schedule_timer                  001432 constant        entry                    internal dcl 341 ref 193 201 209 217 224 231 847
set_data_ptr                    001374 constant        entry                    internal dcl 316 ref 192 200 208 216 250 263
set_next_timer                  003053 constant        entry                    internal dcl 644 ref 423 481 526 533 539 546
signal_timer_manager_err        004254 constant        entry                    internal dcl 988 ref 224 224 231 231 257 257 270 270
                                                                                  573 782 782 795 835 847 847 851 860 942
sleep                           003200 constant        entry                    internal dcl 747 in procedure "timer_manager_" ref
                                                                                  238 244
sleep                           000614 constant        entry                    external dcl 235
sleep_lss                       000653 constant        entry                    external dcl 241
step                            000000 constant        label                    array(0:2) dcl 914 ref 912
timer_manager_                  000120 constant        entry                    external dcl 14
unschedule_timer                001754 constant        entry                    internal dcl 435 ref 251 257 264 270 782

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5170        5324    4336        5200
Length      5760    4336       134         420     632          46

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
timer_manager_                      176 external procedure  is an external procedure.  
on unit on line 299                  64 on unit               
set_data_ptr                            internal procedure  shares stack frame of external procedure timer_manager_.  
schedule_timer                      222 internal procedure  enables or reverts conditions.  
on unit on line 369                  70 on unit               
on unit on line 446                  70 on unit               
on unit on line 553                  72 on unit               
have_multiple_control_points            internal procedure  shares stack frame of internal procedure schedule_timer.  
call_routine_in_other_control_point
                                        internal procedure  shares stack frame of internal procedure schedule_timer.  
remove_bead                             internal procedure  shares stack frame of internal procedure schedule_timer.  
set_next_timer                          internal procedure  shares stack frame of internal procedure schedule_timer.  
on unit on line 692                  70 on unit               
on unit on line 711                  64 on unit               
fill_slot                               internal procedure  shares stack frame of internal procedure schedule_timer.  
sleep                               120 internal procedure  enables or reverts conditions.  
on unit on line 777                  90 on unit               
begin block on line 806              88 begin block         enables or reverts conditions.  
on unit on line 819                  72 on unit               
abs_time                                internal procedure  shares stack frame of external procedure timer_manager_.  
initialize                           90 internal procedure  enables or reverts conditions.  
on unit on line 959                  70 on unit               
signal_timer_manager_err             70 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 allow_all_mask              timer_manager_
000011 alrm_cput_mask              timer_manager_
000012 alrm_cput_quit_mask         timer_manager_
000013 alrm_disabled_mask          timer_manager_
000014 my_group_id                 timer_manager_
000024 initial_ring                timer_manager_
000025 initialized_mechanism       timer_manager_
000026 my_processid                timer_manager_
000030 start_alarm_list_ptr        timer_manager_
000032 start_cpu_list_ptr          timer_manager_
000034 free_bead_list_ptr          timer_manager_
000036 saved_channel_array         timer_manager_
000050 saved_channel_count         timer_manager_
000052 sys_areap                   timer_manager_
000054 this_ring                   timer_manager_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
initialize               000100 alrm_cput_auto_mask         initialize
                         000101 old_auto_ips_mask           initialize
                         000102 old_ips_mask                initialize
schedule_timer           000100 bead_ptr                    schedule_timer
                         000102 found                       schedule_timer
                         000104 next_bead_ptr               schedule_timer
                         000106 prev_bead_ptr               schedule_timer
                         000110 saved_mask                  schedule_timer
                         000112 start_list_ptr              schedule_timer
                         000114 removed_first               schedule_timer
                         000115 code                        schedule_timer
                         000116 temp_mask                   schedule_timer
                         000120 wakeup_message              schedule_timer
                         000122 auto_bead                   schedule_timer
                         000144 timer_idx                   schedule_timer
                         000224 bead_ptr                    remove_bead
                         000226 next_bead_ptr               remove_bead
sleep                    000100 wait_list                   sleep
                         000104 block_message               sleep
                         000113 code                        sleep
                         000114 cur_mask                    sleep
                         000116 old_channel                 sleep
                         000120 old_timer                   sleep
timer_manager_           000100 data_ptr                    timer_manager_
                         000102 data_ptr_provided           timer_manager_
                         000104 call_timer_info_ptr         timer_manager_
                         000106 call_timer_info_condition_name_lth
                                                            timer_manager_
                         000116 N_Timers                    timer_manager_
                         000132 p_ptr                       set_data_ptr
                         000134 p_len                       set_data_ptr
                         000135 x_code                      set_data_ptr
                         000144 abstime                     abs_time

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              enter_begin_block   leave_begin_block   call_ent_var_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          move_label_var      make_label_var
tra_ext_1           mpfx2               signal_op           enable_op           ext_entry           ext_entry_desc
int_entry           int_entry_desc      op_alloc_           op_freen_           clock_mac           vclock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cpm_$generate_call_preferred  create_ips_mask_              cu_$arg_ptr                   get_control_point_id_
get_group_id_                 get_initial_ring_             get_process_id_               get_ring_
get_system_free_area_         hcs_$get_alarm_timer          hcs_$get_ips_mask             hcs_$reset_ips_mask
hcs_$set_alarm_timer          hcs_$set_automatic_ips_mask   hcs_$set_cpu_timer            hcs_$set_ips_mask
hcs_$wakeup                   ipc_$block                    ipc_$create_ev_chn            ipc_$delete_ev_chn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpm_data_$n_control_points    error_table_$invalid_channel  error_table_$noalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     14 000117        16 000125       189 000126       192 000142       193 000146       195 000211       197 000212
    200 000224       201 000230       203 000273       205 000274       208 000306       209 000312       211 000355
    213 000356       216 000370       217 000374       219 000437       221 000440       224 000454       226 000524
    228 000525       231 000537       233 000607       235 000610       238 000621       239 000650       241 000651
    244 000660       245 000707       247 000710       250 000723       251 000727       252 000751       254 000752
    257 000765       258 001014       260 001015       263 001027       264 001033       265 001055       267 001056
    270 001070       271 001117       273 001120       276 001131       277 001144       282 001145       285 001165
    286 001215       288 001216       291 001233       292 001263       294 001264       297 001274       299 001300
    301 001314       303 001330       304 001333       306 001334       311 001362       312 001371       314 001373
    316 001374       319 001376       320 001413       321 001415       322 001421       323 001423       325 001424
    326 001427       328 001430       341 001431       363 001454       367 001463       369 001464       371 001500
    373 001514       375 001515       381 001526       382 001527       383 001531       385 001541       387 001544
    388 001554       390 001564       391 001565       394 001570       397 001604       398 001606       402 001611
    403 001615       404 001626       405 001634       406 001643       407 001654       408 001662       409 001667
    410 001671       411 001676       412 001701       414 001710       415 001714       416 001716       417 001720
    419 001730       423 001733       424 001734       427 001735       428 001740       432 001742       433 001752
    435 001753       440 001776       444 002005       446 002006       448 002022       450 002036       452 002037
    458 002050       460 002060       462 002063       463 002064       465 002066       466 002074       468 002077
    471 002111       472 002113       476 002137       477 002141       478 002144       479 002145       481 002150
    484 002153       485 002163       487 002164       510 002203       512 002214       525 002217       526 002223
    527 002224       530 002225       533 002234       534 002235       536 002236       537 002237       539 002243
    540 002244       543 002245       545 002251       546 002255       548 002256       550 002261       553 002300
    555 002314       556 002322       557 002326       560 002343       562 002344       564 002353       565 002377
    567 002400       569 002403       571 002412       572 002414       573 002431       578 002443       677 002444
    690 002452       692 002453       694 002467       696 002502       698 002503       700 002506       704 002517
    706 002521       708 002532       709 002534       711 002557       713 002573       714 002577       717 002602
    719 002620       721 002621       723 002623       724 002624       726 002636       727 002637       728 002641
    730 002665       732 002667       735 002677       580 002700       583 002702       585 002715       589 002717
    592 002720       593 002723       595 002740       596 002745       597 002751       598 002755       599 002760
    601 002767       604 003010       608 003011       616 003013       618 003016       620 003022       621 003024
    623 003026       625 003035       626 003037       628 003040       630 003043       634 003045       635 003050
    638 003051       640 003052       644 003053       647 003054       655 003065       656 003102       659 003103
    661 003117       662 003120       666 003125       667 003142       670 003143       674 003160       737 003161
    742 003163       743 003176       747 003177       771 003205       774 003214       775 003216       777 003220
    779 003234       781 003242       782 003252       783 003305       785 003310       789 003311       790 003314
    791 003316       792 003322       794 003323       795 003333       799 003342       806 003351       817 003370
    819 003373       821 003407       823 003430       825 003431       828 003443       834 003460       835 003502
    840 003512       841 003526       842 003531       806 003532       847 003533       850 003571       851 003610
    858 003617       859 003623       860 003633       862 003642       865 003643       866 003647       867 003650
    872 003651       882 003653       884 003655       887 003666       890 003702       892 003705       895 003711
    899 003714       908 003722       912 003733       914 003735       917 003743       918 003752       919 003761
    920 003773       922 004001       923 004020       925 004023       926 004041       927 004060       929 004064
    931 004066       942 004072       954 004102       955 004121       957 004125       959 004127       961 004143
    964 004156       966 004172       968 004173       970 004206       973 004221       976 004223       978 004236
    980 004237       982 004247       983 004252       988 004253       991 004261       992 004262       993 004265
    994 004266


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
