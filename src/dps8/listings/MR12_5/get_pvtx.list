	COMPILATION LISTING OF SEGMENT get_pvtx
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1002.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 /* format: style2,indcomtxt */
       12 
       13 /**** *
       14*      get_pvtx$get_pvtx
       15*      $hold_pvtx
       16*      $release_pvtx
       17*      $drain_pvtx
       18*      $cleanup
       19*      $reset
       20*
       21*      04/25/75	Andre Bensoussan - Written for the new storage system.
       22*      Modified 03/06/82, J. Bongiovanni, for new PVTE
       23*      Modified 84-01-17, BIM, for $reset. */
       24 /*    Modified 85-03-28, EJ Sharpe, changed $cleanup to return bit(1) and
       25*   to log what happens. */
       26 
       27 get_pvtx:
       28      procedure (pvid, code) returns (fixed bin (17));
       29 
       30 
       31 	dcl     pvid		 bit (36) aligned,
       32 	        pvtx		 fixed bin,
       33 	        code		 fixed bin (35);
       34 
       35 	dcl     released_something	 bit (1) aligned;
       36 
       37 	dcl     (i, w)		 fixed bin (17);
       38 
       39 	dcl     word		 bit (36) aligned;
       40 	dcl     my_apterp		 bit (18);
       41 
       42 	dcl     error_table_$pvid_not_found
       43 				 fixed bin (35) ext;
       44 	dcl     tc_data$system_shutdown
       45 				 bit (1) aligned ext;
       46 
       47 	dcl     pds$apt_ptr		 ptr ext;
       48 	dcl     pds$process_group_id	 char (32) ext;
       49 
       50 	dcl     CST		 fixed bin (35) internal static
       51 				 init (011000001000000000000000000000000000b) options (constant);
       52 	dcl     PV_HOLDT		 (1:64) bit (36) aligned internal static init ((64) (36)"0"b);
       53 
       54 	dcl     pxss$addevent	 entry (fixed bin (35));
       55 	dcl     pxss$delevent	 entry (fixed bin (35));
       56 	dcl     pxss$notify		 entry (fixed bin (35));
       57 	dcl     pxss$wait		 entry;
       58 
       59 	dcl     stacq		 entry (ptr, bit (36) aligned, bit (36) aligned) returns (bit (1));
       60 	dcl     syserr		 entry options (variable);
       61 
       62 	dcl     pvt$n_entries	 fixed bin external;
       63 
       64 	dcl     (addr, bit, fixed, hbound, lbound, null, rel, stac, unspec)
       65 				 builtin;
       66 
       67 /*
       68*   get_pvtx : entry (pvid, code)  returns (fixed bin(17));
       69**/
       70 
       71 
       72 
       73 /* FUNCTION - This procedure returns the physical volume  table  index
       74*   associated with the physical volume id specified by the input argument
       75*   "pvid".  If  the  pvid  is found in a pvt entry in use, it returns its
       76*   pvtx and sets the code to  zero.   If  a  used  pvt  entry  holds  the
       77*   specified  pvid, then its index is returned with code=0 If no used pvt
       78*   entry holds the specified pvid,  the  value  zero  (invalid  pvtx)  is
       79*   returned, with code=error_table_$pvid_not_found. */
       80 
       81 
       82 	code = 0;
       83 	pvt_arrayp = addr (pvt$array);
       84 
       85 	do i = 1 to pvt$n_entries;
       86 	     pvtep = addr (pvt_array (i));
       87 
       88 	     if pvte.used
       89 	     then if pvte.pvid = pvid
       90 		then if ^pvte.being_demounted
       91 		     then if pvte.pvid = pvid
       92 			then return (i);
       93 	end;
       94 
       95 	code = error_table_$pvid_not_found;
       96 
       97 	return (0);
       98 
       99 hold_pvtx:
      100      entry (pvid, pvtx, code);
      101 
      102 
      103 
      104 /* FUNCTION - The procedure "hold_pvtx" causes the system to  remember
      105*   that  one more request has been issued to keep the binding between the
      106*   pvid and the pvtx specified as input arguments, and also  to  remember
      107*   the  name  of  the  process  who  is  issuing the request. The binding
      108*   between a pvid and a pvtx cannot change while the number  of  requests
      109*   to keep it is non-zero.  If the pvid and the pvtx are not bound at the
      110*   time this procedure is called, the ony effect of the call is to return
      111*   the code = error_table_$pvid_not_found. */
      112 
      113 
      114 
      115 	pv_holdtp = addr (PV_HOLDT);
      116 	pvt_arrayp = addr (pvt$array);
      117 	pvtep = addr (pvt_array (pvtx));
      118 
      119 	code = 0;
      120 
      121 	if pvte.pvid ^= pvid | pvte.being_demounted
      122 	then do;
      123 		code = error_table_$pvid_not_found;
      124 		return;
      125 	     end;
      126 
      127 	word = bit (fixed (pvtx, 18), 18) || rel (pds$apt_ptr);
      128 
      129 	do i = 1 to hbound (pv_holdt, 1) while (^stac (addr (pv_holdt (i)), word));
      130 	end;
      131 
      132 	if i > hbound (pv_holdt, 1)
      133 	then call syserr (SYSERR_CRASH_SYSTEM, "get_pvtx: hold_pvtx finds table full");
      134 
      135 	if pvte.pvid ^= pvid | pvte.being_demounted
      136 	then do;
      137 		call ZERO_ENTRY (i);
      138 		code = error_table_$pvid_not_found;
      139 		return;
      140 	     end;
      141 
      142 	return;
      143 
      144 release_pvtx:
      145      entry (pvid, pvtx);
      146 
      147 
      148 
      149 /* FUNCTION - The procedure  "release_pvtx"  is  the  inverse  of  the
      150*   hold_pvtx  procedure.  It  causes the system to forget whatever it was
      151*   caused to remember by the last call to hold_pvtx in this process  with
      152*   the  same  pvid  and  pvtx  arguments.  The  following sequence:  call
      153*   get_pvtx$hold_pvtx ( pvid, pvtx, code )  ;  if  code  =  0  then  call
      154*   get_pvtx$release_pvtx(pvid, pvtx) is equivalent to a null statement. */
      155 
      156 
      157 
      158 	pv_holdtp = addr (PV_HOLDT);
      159 	pvt_arrayp = addr (pvt$array);
      160 	pvtep = addr (pvt_array (pvtx));
      161 
      162 	my_apterp = rel (pds$apt_ptr);
      163 
      164 	do i = 1 to hbound (pv_holdt, 1) while (pv_holdt (i).apterp ^= my_apterp | pv_holdt (i).pvtx ^= pvtx);
      165 	end;
      166 
      167 	if i > hbound (pv_holdt, 1) | pvte.pvid ^= pvid
      168 	then call syserr (SYSERR_CRASH_SYSTEM, "get_pvtx: release_pvtx: mark not found");
      169 
      170 	call ZERO_ENTRY (i);
      171 
      172 	return;
      173 
      174 drain_pvtx:
      175      entry (pvtx);
      176 
      177 
      178 
      179 /* FUNCTION - The procedure "drain_pvtx" causes the system  to  refuse
      180*   any subsequent requests to hold the pvtx with the pvid it is now bound
      181*   to,  and  to wait until the number of hold requests that may have been
      182*   issued for this pvtx prior to this instant to drop to zero. */
      183 
      184 
      185 
      186 	pv_holdtp = addr (PV_HOLDT);
      187 	pvt_arrayp = addr (pvt$array);
      188 	pvtep = addr (pvt_array (pvtx));
      189 
      190 	if pvte.being_demounted = "0"b
      191 	then call syserr (SYSERR_CRASH_SYSTEM, "get_pvtx: drain_pvtx: pvte.being_demounted should be on");
      192 
      193 	w = -1;
      194 	do while (w ^= 0);
      195 
      196 	     w = 0;
      197 	     do i = 1 to hbound (pv_holdt, 1);
      198 		if pv_holdt (i).pvtx = pvtx
      199 		then if ^tc_data$system_shutdown
      200 		     then do;
      201 			     call pxss$addevent (CST + i);
      202 			     if pv_holdt (i).pvtx = pvtx
      203 			     then do;
      204 				     call pxss$wait;
      205 				     w = w + 1;
      206 				end;
      207 			     else call pxss$delevent (CST + i);
      208 			end;
      209 
      210 		     else pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      211 
      212 	     end;
      213 
      214 	end;
      215 
      216 	return;
      217 
      218 cleanup:
      219      entry () returns (bit (1) aligned);
      220 
      221 
      222 /* FUNCTION - The procedure "cleanup" is executed by a process  before
      223*   crawling  out  of  ring  zero. It causes the system to forget any hold
      224*   request that may have been issued by this process for any pvtx */
      225 
      226 
      227 
      228 	released_something = "0"b;
      229 	pv_holdtp = addr (PV_HOLDT);
      230 	pvt_arrayp = addr (pvt$array);
      231 	pvtep = null ();
      232 
      233 	do i = 1 to hbound (pv_holdt, 1);
      234 	     if pv_holdt (i).apterp = rel (pds$apt_ptr)
      235 	     then do;
      236 		     pvt_array (pv_holdt (i).pvtx).vol_trouble_count =
      237 			pvt_array (pv_holdt (i).pvtx).vol_trouble_count + 1;
      238 		     call ZERO_ENTRY (i);
      239 		     call syserr (SYSERR_LOG_OR_PRINT, "get_pvtx$cleanup: Force released hold on pvtx ^d for ^a.",
      240 			pv_holdt (i).pvtx, pds$process_group_id);
      241 		     released_something = "1"b;
      242 		end;
      243 	end;
      244 
      245 	return (released_something);
      246 
      247 
      248 
      249 reset:
      250      entry;
      251 
      252 /**** FUNCTION - at emergency_shutdown time, bump the inconsistency count
      253*      in the pvte for all held volumes, and release all of them.
      254*      Thus will produce some spurious scavenges, but will also tend to
      255*      detect a variety of interrupted operations. */
      256 
      257 
      258 	pv_holdtp = addr (PV_HOLDT);
      259 	pvt_arrayp = addr (pvt$array);
      260 	do i = lbound (pv_holdt, 1) to hbound (pv_holdt, 1);
      261 	     if pv_holdt (i).apterp ^= ""b
      262 	     then do;
      263 		     pvtep = addr (pvt_array (pv_holdt (i).pvtx));
      264 		     pvte.vol_trouble_count = pvte.vol_trouble_count + 1;
      265 		     call ZERO_ENTRY (i);
      266 		end;
      267 	end;
      268 	return;
      269 
      270 
      271 /**** FUNCTION -- return address of static table to be put in
      272*      easily readable spot in sst_seg. */
      273 
      274 
      275 ret_pvhtp:
      276      entry returns (ptr);
      277 
      278 	return (addr (PV_HOLDT));			/* For debugging */
      279 
      280 
      281 
      282 
      283 
      284 
      285 ZERO_ENTRY:
      286      proc (i);
      287 
      288 	dcl     (i, x)		 fixed bin;
      289 	dcl     word		 bit (36) aligned;
      290 
      291 	x = pv_holdt (i).pvtx;
      292 	word = unspec (pv_holdt (i));
      293 
      294 	if ^stacq (addr (pv_holdt (i)), word, (36)"0"b)
      295 	then call syserr (SYSERR_CRASH_SYSTEM, "get_pvtx: ZERO_ENTRY fails");
      296 
      297 	if pvt_array (x).being_demounted
      298 	then call pxss$notify (CST + i);
      299 
      300 	return;
      301 
      302      end;
      303 
  1     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  1     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1     8*     Add the support for subvolumes
  1     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  1    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  1    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  1    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  1    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  1    14*     Added inconsistent_dbm bit for determining the status of volume
  1    15*     dumper bit maps.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18      dcl	   pvt$array	      aligned external;
  1    19      dcl	   pvt$max_n_entries      fixed bin external;
  1    20 
  1    21      dcl	   pvt_arrayp	      ptr;
  1    22      dcl	   pvtep		      ptr;
  1    23 
  1    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  1    25 
  1    26      dcl	   1 pvte		      based (pvtep) aligned,
  1    27 
  1    28 	     2 pvid	      bit (36),		/* physical volume ID */
  1    29 
  1    30 	     2 lvid	      bit (36),		/* logical volume ID */
  1    31 
  1    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  1    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  1    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  1    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  1    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  1    37 	     2 pad3	      bit (2) unaligned,
  1    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  1    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  1    40 
  1    41 
  1    42 
  1    43 	     2 devname	      char (4),		/* device name */
  1    44 
  1    45 	     (2 device_type	      fixed bin (8),	/* device type */
  1    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  1    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  1    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  1    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  1    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  1    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  1    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  1    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  1    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  1    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  1    56 	     2 scav_check_address
  1    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  1    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  1    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  1    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  1    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  1    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  1    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  1    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  1    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  1    66 
  1    67 
  1    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  1    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  1    70 
  1    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  1    72 
  1    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  1    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  1    75 
  1    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  1    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  1    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  1    79 	     2 records_per_cyl    fixed bin,
  1    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  1    81 	     2 sv_name            char (2) aligned,
  1    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  1    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  1    84 
  1    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  1    86 	     2 pad2	      bit (18) unaligned,
  1    87 
  1    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  1    89 
  1    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  1    91 
  1    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  1    93 
  1    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  1    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  1    96 
  1    97 
  1    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  1    99 
  1   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  1   101 
  1   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  1   103 
  1   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  1   105 
  1   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  1   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  1   108 
  1   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  1   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  1   111 
  1   112 
  1   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  1   114 	   VOLMAP_ASYNC_READ      init (1),
  1   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  1   116 
  1   117 
  1   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      304 
      305 
  2     1 /*	BEGIN INCLUDE FILE ... pv_holdt.incl.pl1 ... */
  2     2 
  2     3 
  2     4 dcl pv_holdtp ptr;
  2     5 
  2     6 dcl 1 pv_holdt (1 : 64) based (pv_holdtp) aligned,
  2     7 
  2     8     2 pvtx   fixed bin(17) unaligned,
  2     9     2 apterp bit(18) unaligned;
  2    10 
  2    11 
  2    12 /*	END INCLUDE FILE ... pv_holdt.incl.pl1 ...*/
      306 
      307 
  3     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  3     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  3     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  3     4 
  3     5 /* This include file has an ALM version.  Keep 'em in sync! */
  3     6 
  3     7 dcl (
  3     8 
  3     9 /* The following constants define the message action codes.  This indicates
  3    10*how a message is to be handled.  */
  3    11 
  3    12      SYSERR_CRASH_SYSTEM	init (1),			
  3    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  3    14 
  3    15      SYSERR_TERMINATE_PROCESS	init (2),
  3    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  3    17 
  3    18      SYSERR_PRINT_WITH_ALARM	init (3),
  3    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  3    20 
  3    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  3    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  3    23 
  3    24      SYSERR_LOG_OR_PRINT	init (4),
  3    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  3    26 
  3    27      SYSERR_LOG_OR_DISCARD	init (5),
  3    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  3    29 
  3    30 
  3    31 /* The following constants are added to the normal severities to indicate
  3    32*different sorting classes of messages.  */
  3    33 
  3    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  3    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  3    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  3    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  3    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  3    39 	) fixed bin internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      308 
      309 
      310 /* BEGIN MESSAGE DOCUMENTATION
      311*
      312*   Message:
      313*   get_pvtx: hold_pvtx finds table full
      314*
      315*   S: $crash
      316*
      317*   T: $run
      318*
      319*   M: There are no free entries in the physical volume hold table.
      320*   There should never be more than twice the number of eligible
      321*   processes of used entries.
      322*   $err
      323*
      324*   A: $recover
      325*
      326*   Message:
      327*   get_pvtx: release_pvtx: mark not found
      328*
      329*   S: $crash
      330*
      331*   T: $run
      332*
      333*   M: While attempting to release a physical volume from demount protection,
      334*   the mark made by the protection could not be found in the physical volume
      335*   hold table.  This message can also occur if somehow the physical
      336*   volume was demounted in spite of this protection, or this entry
      337*   point is being used improperly.
      338*   $err
      339*
      340*   A: $recover
      341*
      342*   Message:
      343*   get_pvtx: drain_pvtx: pvte.being_demounted should be on.
      344*
      345*   S: $crash
      346*
      347*   T: $run
      348*
      349*   M: The entry to the physical volume demount protection mechanism
      350*   which awaits all use of the volume to cease is being called improperly.
      351*   A necessary precondition for its
      352*   proper operation (pvte.being_demounted) is not met.
      353*   $err
      354*
      355*   A: $recover
      356*
      357*   Message:
      358*   get_pvtx: ZERO_ENTRY fails
      359*
      360*   S: $crash
      361*
      362*   T: $run
      363*
      364*   M: The STACQ instruction has failed to clear an entry in the
      365*   physical volume hold table.
      366*   $err
      367*
      368*   A: $recover
      369*
      370*
      371*   Message:
      372*   get_pvtx$cleanup: Force released hold on pvtx ^d for USER_ID.
      373*
      374*   S:	$info
      375*
      376*   T:	$run
      377*
      378*   M:	$err
      379*   A condition was signalled in ring-0 which caused a crawlout.
      380*   get_pvtx$cleanup will release all PV holds for the process.
      381*
      382*   A:	$notify
      383*
      384*   END MESSAGE DOCUMENTATION */
      385 
      386      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0838.7  get_pvtx.pl1                      >special_ldd>install>MR12.3-1114>get_pvtx.pl1
304          1    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
306          2    05/20/76  0630.6  pv_holdt.incl.pl1                 >ldd>include>pv_holdt.incl.pl1
308          3    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CST                                    constant        fixed bin(35,0)          initial dcl 50 ref 201 207 297
PV_HOLDT                        000010 internal static bit(36)                  initial array dcl 52 set ref 115 158 186 229 258 278
SYSERR_CRASH_SYSTEM             000012 constant        fixed bin(17,0)          initial dcl 3-7 set ref 132* 167* 190* 294*
SYSERR_LOG_OR_PRINT             000000 constant        fixed bin(17,0)          initial dcl 3-7 set ref 239*
addr                                                   builtin function         dcl 64 ref 83 86 115 116 117 129 158 159 160 186 187
                                                                                  188 229 230 258 259 263 278 294 294
apterp                    0(18)        based           bit(18)                  array level 2 packed packed unaligned dcl 2-6 set
                                                                                  ref 164 234 261
being_demounted           4(23)        based           bit(1)                   array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 1-24 in procedure "get_pvtx" set ref
                                                                                  297
being_demounted           4(23)        based           bit(1)                   level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 1-26 in procedure "get_pvtx" ref 88 121 135
                                                                                  190
bit                                                    builtin function         dcl 64 ref 127
code                                   parameter       fixed bin(35,0)          dcl 31 set ref 27 82* 95* 99 119* 123* 138*
error_table_$pvid_not_found     000110 external static fixed bin(35,0)          dcl 42 ref 95 123 138
fixed                                                  builtin function         dcl 64 ref 127
hbound                                                 builtin function         dcl 64 ref 129 132 164 167 197 233 260
i                               000101 automatic       fixed bin(17,0)          dcl 37 in procedure "get_pvtx" set ref 85* 86 88*
                                                                                  129* 129* 132 137* 164* 164 164* 167 170* 197* 198
                                                                                  201 202 207* 233* 234 236 236 238* 239* 260* 261
                                                                                  263 265*
i                                      parameter       fixed bin(17,0)          dcl 288 in procedure "ZERO_ENTRY" ref 285 291 292
                                                                                  294 294 297
lbound                                                 builtin function         dcl 64 ref 260
my_apterp                       000104 automatic       bit(18)                  packed unaligned dcl 40 set ref 162* 164
null                                                   builtin function         dcl 64 ref 231
pds$apt_ptr                     000114 external static pointer                  dcl 47 ref 127 162 234
pds$process_group_id            000116 external static char(32)                 packed unaligned dcl 48 set ref 239*
pv_holdt                               based           structure                array level 1 dcl 2-6 set ref 129 129 132 164 167
                                                                                  197 233 260 260 292 294 294
pv_holdtp                       000112 automatic       pointer                  dcl 2-4 set ref 115* 129 129 132 158* 164 164 164
                                                                                  167 186* 197 198 202 229* 233 234 236 236 239 258*
                                                                                  260 260 261 263 291 292 294 294
pvid                                   based           bit(36)                  level 2 in structure "pvte" dcl 1-26 in procedure
                                                                                  "get_pvtx" ref 88 88 121 135 167
pvid                                   parameter       bit(36)                  dcl 31 in procedure "get_pvtx" ref 27 88 88 99 121
                                                                                  135 144 167
pvt$array                       000136 external static fixed bin(17,0)          dcl 1-18 set ref 83 116 159 187 230 259
pvt$n_entries                   000134 external static fixed bin(17,0)          dcl 62 ref 85
pvt_array                              based           structure                array level 1 dcl 1-24 set ref 86 117 160 188 263
pvt_arrayp                      000106 automatic       pointer                  dcl 1-21 set ref 83* 86 116* 117 159* 160 187* 188
                                                                                  230* 236 236 259* 263 297
pvte                                   based           structure                level 1 dcl 1-26
pvtep                           000110 automatic       pointer                  dcl 1-22 set ref 86* 88 88 88 88 117* 121 121 135
                                                                                  135 160* 167 188* 190 210 210 231* 263* 264 264
pvtx                                   parameter       fixed bin(17,0)          dcl 31 in procedure "get_pvtx" ref 99 117 127 144
                                                                                  160 164 174 188 198 202
pvtx                                   based           fixed bin(17,0)          array level 2 in structure "pv_holdt" packed packed
                                                                                  unaligned dcl 2-6 in procedure "get_pvtx" set ref
                                                                                  164 198 202 236 236 239* 263 291
pxss$addevent                   000120 constant        entry                    external dcl 54 ref 201
pxss$delevent                   000122 constant        entry                    external dcl 55 ref 207
pxss$notify                     000124 constant        entry                    external dcl 56 ref 297
pxss$wait                       000126 constant        entry                    external dcl 57 ref 204
rel                                                    builtin function         dcl 64 ref 127 162 234
released_something              000100 automatic       bit(1)                   dcl 35 set ref 228* 241* 245
stac                                                   builtin function         dcl 64 ref 129
stacq                           000130 constant        entry                    external dcl 59 ref 294
syserr                          000132 constant        entry                    external dcl 60 ref 132 167 190 239 294
tc_data$system_shutdown         000112 external static bit(1)                   dcl 44 ref 198
unspec                                                 builtin function         dcl 64 ref 292
used                      4(18)        based           bit(1)                   level 2 packed packed unaligned dcl 1-26 ref 88
vol_trouble_count        33            based           fixed bin(17,0)          array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 1-24 in procedure "get_pvtx" set ref
                                                                                  236* 236
vol_trouble_count        33            based           fixed bin(17,0)          level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 1-26 in procedure "get_pvtx" set ref 210* 210
                                                                                  264* 264
w                               000102 automatic       fixed bin(17,0)          dcl 37 set ref 193* 194 196* 205* 205
word                            000103 automatic       bit(36)                  dcl 39 in procedure "get_pvtx" set ref 127* 129
word                            000133 automatic       bit(36)                  dcl 289 in procedure "ZERO_ENTRY" set ref 292* 294*
x                               000132 automatic       fixed bin(17,0)          dcl 288 set ref 291* 297

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANNOUNCE                               internal static fixed bin(17,0)          initial dcl 3-7
BEEP                                   internal static fixed bin(17,0)          initial dcl 3-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 3-7
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 3-7
LOG                                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 3-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 3-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 3-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 1-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 1-113
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 1-19

NAMES DECLARED BY EXPLICIT CONTEXT.
ZERO_ENTRY                      001225 constant        entry                    internal dcl 285 ref 137 170 238 265
cleanup                         000754 constant        entry                    external dcl 218
drain_pvtx                      000571 constant        entry                    external dcl 174
get_pvtx                        000122 constant        entry                    external dcl 27
hold_pvtx                       000247 constant        entry                    external dcl 99
release_pvtx                    000451 constant        entry                    external dcl 144
reset                           001113 constant        entry                    external dcl 249
ret_pvhtp                       001200 constant        entry                    external dcl 275

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1542        1702    1332        1552
Length      2156    1332       140         240     207         100

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_pvtx                            184 external procedure  is an external procedure.  
ZERO_ENTRY                              internal procedure  shares stack frame of external procedure get_pvtx.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 PV_HOLDT                    get_pvtx

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_pvtx                 000100 released_something          get_pvtx
                         000101 i                           get_pvtx
                         000102 w                           get_pvtx
                         000103 word                        get_pvtx
                         000104 my_apterp                   get_pvtx
                         000106 pvt_arrayp                  get_pvtx
                         000110 pvtep                       get_pvtx
                         000112 pv_holdtp                   get_pvtx
                         000132 x                           ZERO_ENTRY
                         000133 word                        ZERO_ENTRY

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          stac_mac            signal_op           ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
pxss$addevent                 pxss$delevent                 pxss$notify                   pxss$wait
stacq                         syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$pvid_not_found   pds$apt_ptr                   pds$process_group_id          pvt$array
pvt$n_entries                 tc_data$system_shutdown




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000116        82 000134        83 000135        85 000137        86 000147        88 000153        93 000215
     95 000217        97 000222        99 000243       115 000263       116 000266       117 000270       119 000274
    121 000275       123 000304       124 000306       127 000322       129 000336       130 000352       132 000354
    135 000377       137 000407       138 000411       139 000414       142 000430       144 000444       158 000463
    159 000466       160 000470       162 000474       164 000500       165 000516       167 000520       170 000547
    172 000551       174 000565       186 000603       187 000606       188 000610       190 000614       193 000636
    194 000640       196 000642       197 000643       198 000651       201 000661       202 000674       204 000702
    205 000707       206 000710       207 000711       208 000722       210 000723       212 000731       214 000733
    216 000734       218 000750       228 000763       229 000764       230 000767       231 000771       233 000773
    234 001001       236 001013       238 001026       239 001030       241 001062       243 001064       245 001066
    249 001112       258 001122       259 001125       260 001127       261 001135       263 001141       264 001147
    265 001154       267 001156       268 001160       275 001174       278 001206       386 001224       285 001225
    291 001227       292 001234       294 001236       297 001302       300 001325


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
