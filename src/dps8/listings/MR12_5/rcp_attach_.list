	COMPILATION LISTING OF SEGMENT rcp_attach_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0953.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
       13 
       14 rcp_attach_:
       15      procedure;
       16 
       17 /*	This program is called to attach a device controlled by RCP.
       18*   *
       19*   *	This program has the following entry points:
       20*   *	  1.  priv_attach	-  Attach a device with privilege.
       21*   *	  2.  attach	-  Attach a device.
       22**/
       23 /*
       24*   *	Created on 11/21/74 by Bill Silver.
       25*   *      Modified 841009 to interface with rcp_control_ instead of
       26*   *         rcp_initializer_... - M. M. Pozzo
       27**/
       28 
       29 /****^  HISTORY COMMENTS:
       30*  1) change(85-06-27,Pozzo), approve(86-02-21,MCR7346),
       31*     audit(86-07-29,Farley), install(86-08-01,MR12.0-1108):
       32*     Modified to return a good error code when a garbage error code was input.
       33*  2) change(85-07-18,CLJones), approve(86-02-21,MCR7346),
       34*     audit(86-07-29,Farley), install(86-08-01,MR12.0-1108):
       35*     Modified to not return rcp_id when an error is encountered.
       36*  3) change(85-07-21,ABall), approve(86-02-21,MCR7346),
       37*     audit(86-07-29,Farley), install(86-08-01,MR12.0-1108):
       38*     Modified to check for null rcse_ptr and arcse_ptr before referencing
       39*     rcse_off.
       40*  4) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
       41*     audit(85-12-02,CLJones), install(86-03-21,MR12.0-1033):
       42*     Add MCA and FIPS support
       43*                                                   END HISTORY COMMENTS */
       44 
       45 /*		ARGUMENT  DATA		*/
       46 
       47 dcl	arg_comment	   char (*);		/* (I) Caller's comment. */
       48 dcl	arg_device_info_ptr	   ptr;			/* (I) Pointer to device info structure. */
       49 dcl	arg_device_type	   char (*);		/* (I) Device type name. */
       50 dcl	arg_ecode		   fixed bin (35);		/* (O) error_table_ code. */
       51 dcl	arg_event_id	   fixed bin (71);		/* (I) Caller's event channel ID. */
       52 dcl	arg_rcp_id	   bit (36) aligned;	/* (O) ID for this attachment request. */
       53 
       54 
       55 /*		AUTOMATIC  DATA		*/
       56 
       57 
       58 dcl	arcse_off		   bit (18);		/* Offset  of assignment RCS entry. */
       59 dcl	device_off	   bit (18) aligned;	/* Offset of RCS entry specifying device. */
       60 dcl	priv_flag		   bit (1);		/* ON => privileged attach. */
       61 dcl	process_id	   bit (36) aligned;	/* Needed by rcp_control_ */
       62 dcl	rcse_off		   bit (18);		/* Offset of RCS entry. */
       63 dcl	volume_off	   bit (18) aligned;	/* Offset of RCS entry specifying volume. */
       64 dcl	got_arcse		   bit (1) aligned;		/* whether we acquired an arcse */
       65 dcl	got_rcse		   bit (1) aligned;		/* whether we acquired an rcse */
       66 
       67 dcl	device_type	   char (32);		/* Device type name. */
       68 dcl	device_name	   char (32);		/* Needed by rcp_control_. */
       69 dcl	operation		   bit (36) aligned;	/* Operation being requested of rcp_control_. */
       70 
       71 dcl	caller_level	   fixed bin;		/* Caller's validation level. */
       72 dcl	ecode		   fixed bin (35);		/* error_table_ code. */
       73 dcl	error_count	   fixed bin (17);		/* Error count for device attachments */
       74 
       75 dcl	arcse_ptr		   ptr;			/* Pointer to assignment RCS entry. */
       76 dcl	callers_device_info_ptr
       77 			   ptr;
       78 dcl	device_info_buffer	   (RCP_MAX_DEVICE_INFO_SIZE) bit (36) aligned;
       79 dcl	1 rcse_buffer	   like rcse aligned;	/* Template RCSE. */
       80 
       81 /*		BASED  DATA		*/
       82 
       83 dcl	1 arcse		   based (arcse_ptr) like rcse aligned;
       84 						/* Used to reference assignment RCS entry. */
       85 
       86 
       87 /*		EXTERNAL ENTRIES CALLED	*/
       88 
       89 dcl	cleanup		   condition;		/* Used to establish cleanup handler. */
       90 
       91 dcl	(addr, null, ptr, rel) builtin;
       92 
       93 dcl	(
       94 	error_table_$bad_volid,
       95 	error_table_$no_operation,
       96 	error_table_$resource_attached
       97 	)		   fixed bin (35) external;
       98 
       99 dcl	access_operations_$rcp_assign_write
      100 			   bit (36) aligned ext static;
      101 dcl	access_operations_$rcp_assign_read
      102 			   bit (36) aligned ext static;
      103 
      104 dcl	cu_$level_get	   entry (fixed bin);
      105 dcl	cu_$level_set	   entry (fixed bin);
      106 dcl	get_ring_		   entry returns (fixed bin);
      107 dcl	rcp_find_$attached	   entry (ptr, bit (18));
      108 dcl	rcp_find_$unattached   entry (ptr, bit (18));
      109 dcl	rcp_control_	   entry (bit (36) aligned, bit (18) aligned, bit (18) aligned, char (*), fixed bin (17),
      110 			   bit (36) aligned, fixed bin (35));
      111 dcl	rcp_device_info_$copy  entry (char (*), ptr, ptr, fixed bin (35));
      112 dcl	rcp_device_info_$get   entry (char (*), ptr, ptr, fixed bin, fixed bin (35));
      113 dcl	rcp_device_info_$set   entry (pointer, pointer, fixed bin (35));
      114 dcl	rcp_rcse_$free	   entry (ptr, fixed bin (35));
      115 dcl	rcp_rcse_$get	   entry (ptr, fixed bin (35));
      116 
      117 priv_attach:
      118      entry (arg_device_type, arg_device_info_ptr, arg_event_id, arg_comment, arg_rcp_id, arg_ecode);
      119 
      120 
      121 	priv_flag = "1"b;
      122 	goto COMMON;
      123 
      124 
      125 attach:
      126      entry (arg_device_type, arg_device_info_ptr, arg_event_id, arg_comment, arg_rcp_id, arg_ecode);
      127 
      128 
      129 	priv_flag = "0"b;
      130 
      131 
      132 COMMON:
      133 	device_off = ""b;
      134 	process_id = ""b;
      135 	volume_off = ""b;
      136 	device_name = "";
      137 	error_count = 0;
      138 	rcse_ptr, arcse_ptr = null ();
      139 	got_arcse, got_rcse = "0"b;
      140 
      141 	call cu_$level_get (caller_level);		/* Save caller's validation level. */
      142 	on cleanup call CLEANUP (error_table_$no_operation);
      143 
      144 	call cu_$level_set (get_ring_ ());		/* Set validation level to RCP level. */
      145 
      146 	device_type = arg_device_type;		/* Get device type name. */
      147 	callers_device_info_ptr = arg_device_info_ptr;
      148 	device_info_ptr = addr (device_info_buffer);
      149 	call rcp_device_info_$copy (device_type, callers_device_info_ptr, device_info_ptr, ecode);
      150 	if ecode ^= 0 then
      151 	     goto RETURN;
      152 	rcse_ptr = addr (rcse_buffer);		/* Use temporary RCSE. */
      153 
      154 	call rcp_device_info_$get (device_type, device_info_ptr, rcse_ptr, caller_level, ecode);
      155 	if ecode ^= 0 then
      156 	     goto RETURN;
      157 
      158 /* Fill in the rest of the RCSE. */
      159 	rcse.kind = 1;				/* This is an attachment RCSE. */
      160 	rcse.flags.priv = priv_flag;			/* Remember if privileged attachment. */
      161 	rcse.event_id = arg_event_id;			/* Save argument data. */
      162 	rcse.caller_comment = arg_comment;
      163 
      164 	goto DEVICE_TYPE (rcse.dtypex);		/* Special tests based upon device type. */
      165 
      166 
      167 DEVICE_TYPE (1):					/* TAPE */
      168 DEVICE_TYPE (2):					/* DISK */
      169 	if ^rcse.flags.volume			/* Was a volume specified? */
      170 	then do;					/* No, but it is required. */
      171 	     ecode = error_table_$bad_volid;
      172 	     goto RETURN;
      173 	end;
      174 	if (rcse.flags.t_and_d) &			/* Is attachment for a T&D volume? */
      175 	     (^priv_flag)				/* Then is this a privileged attachment? */
      176 	then do;					/* No, T&D must use privileged entry. */
      177 	     ecode = error_table_$no_operation;
      178 	     goto RETURN;
      179 	end;
      180 
      181 
      182 DEVICE_TYPE (3):					/* CONSOLE */
      183 DEVICE_TYPE (4):					/* PRINTER */
      184 DEVICE_TYPE (5):					/* PUNCH */
      185 DEVICE_TYPE (6):					/* READER */
      186 DEVICE_TYPE (7):					/* SPECIAL */
      187 DEVICE_TYPE (8):					/* MCA */
      188 /****	If we are attaching a specific device or if we are attaching a volume
      189*      *	then we must check to see if that device or volume is already attached
      190*      *	to this process.
      191*****/
      192 	if (rcse.flags.device) |			/* Attaching a specific device? */
      193 	     (rcse.flags.volume)			/* Or attaching a volume. */
      194 	then do;					/* Yes. */
      195 	     call rcp_find_$attached (rcse_ptr, arcse_off);
      196 	     if arcse_off ^= "0"b			/* Already attached? */
      197 	     then do;				/* Yes. */
      198 		ecode = error_table_$resource_attached;
      199 		goto RETURN;
      200 	     end;
      201 	end;
      202 
      203 /*	Now get a real attachment RCSE.  All the data in our temporary RCSE will
      204*   *	be copied into the real RCSE.
      205**/
      206 	call rcp_rcse_$get (rcse_ptr, ecode);
      207 	if ecode ^= 0 then
      208 	     goto RETURN;
      209 	got_rcse = "1"b;
      210 	rcse_off = rel (rcse_ptr);
      211 
      212 /*	Now we must see if an appropriate (and unattached) device is already
      213*   *	assigned to this process.  If so we will use that device.  Otherwise
      214*   *	we will have to have rcp_control_ assign a device.
      215**/
      216 	call rcp_find_$unattached (rcse_ptr, arcse_off);
      217 	if arcse_off ^= "0"b			/* Did we find an assigned unattached device? */
      218 	then do;					/* Yes, use it. */
      219 	     device_off = "0"b;			/* We don't need to assign a device. */
      220 	     arcse_ptr = ptr (rcse_ptr, arcse_off);
      221 	end;
      222 	else do;					/* No, must assign a device. */
      223 	     arcse_ptr = addr (rcse_buffer);		/* Use attachment RCSE as template. */
      224 	     arcse.kind = 2;			/* Show that this is an assignment RCSE. */
      225 	     call rcp_rcse_$get (arcse_ptr, ecode);
      226 	     if ecode ^= 0 then			/* Any error getting assignment RCS entry? */
      227 		goto RETURN;			/* Yes, free attachment RCSE. */
      228 	     got_arcse = "1"b;
      229 	     arcse_off = rel (arcse_ptr);		/* Now we have an assignment RCS entry. */
      230 	     device_off = arcse_off;			/* Assign device through assignment RCS entry. */
      231 	end;
      232 
      233 	arcse.rcse_off = rcse_off;			/* Link the attach and assign RCSEs. */
      234 	rcse.rcse_off = arcse_off;
      235 
      236 	if rcse.flags.volume			/* Is there a volume? */
      237 	     then
      238 	     volume_off = rcse_off;			/* Yes, assign it using attachment RCSE. */
      239 	else do;					/* No volume to assign. */
      240 	     volume_off = "0"b;
      241 	     rcse.state = 2;			/* State => any volume assignment has been done. */
      242 	end;
      243 
      244 	if (device_off ^= "0"b) |			/* Do we have to assign a device? */
      245 	     (volume_off ^= "0"b)			/* Or a volume? */
      246 	then do;					/* Yes, something to assign. */
      247 	     if volume_off ^= "0"b & ^rcse.flags.writing then
      248 		operation = access_operations_$rcp_assign_read;
      249 	     else operation = access_operations_$rcp_assign_write;
      250 	     call rcp_control_ (operation, volume_off, device_off, device_name, error_count, process_id, ecode);
      251 	     if ecode = 0 then
      252 		call rcp_device_info_$set (callers_device_info_ptr, rcse_ptr, (0));
      253 	     /*** in case the name has changed (from "scratch") ***/
      254 	     /*** we ignore the code since it's the caller's problem,
      255*		and the attachment has been made in any case. ***/
      256 	end;
      257 
      258 RETURN:
      259 	call CLEANUP (ecode);
      260 	if ecode = 0 then
      261 	     arg_rcp_id = rcse.rcp_id;
      262 	arg_ecode = ecode;
      263 	return;
      264 
      265 CLEANUP:
      266      proc (code);
      267 
      268 dcl	code		   fixed bin (35);
      269 
      270 	if code ^= 0 then do;
      271 	     if rcse_ptr ^= null () then
      272 		rcse.rcse_off = ""b;
      273 	     if arcse_ptr ^= null () then
      274 		arcse.rcse_off = ""b;
      275 	     if got_arcse then
      276 		call rcp_rcse_$free (arcse_ptr, (0));
      277 	     if got_rcse then
      278 		call rcp_rcse_$free (rcse_ptr, (0));
      279 	end;
      280 	call cu_$level_set (caller_level);
      281 
      282      end CLEANUP;
      283 
  1     1 /*	Begin  include file ... rcp_com_seg.incl.pl1
  1     2*   *
  1     3*   *	Created on 11/20/74 by Bill Silver.
  1     4*   *	Modified on 09/19/77 by R.J.C. Kissel to add label authentication bits.
  1     5*   *	Modified on 12/09/78 by Michael R. Jordan to add removable media bit and label_type.
  1     6*   *	Modified 1/79 by R.J.C. Kissel to add disk label authentication bits.
  1     7*   *	Modified 2/79 by Michael R. Jordan to add volume_density.
  1     8*   *	Modified 11/84 by Paul Farley to add fips flag.
  1     9*   *      Modified 1/3/85 by Fawcett to allow room for mca device type
  1    10*   *	Modified 02/85 by Paul Farley to add no_protect and opr_int_available flags.
  1    11*   *	This include file defines the Resource Control Package communication segment.
  1    12*   *	This segment is used to communicate requests between the various internal
  1    13*   *	parts of RCP.
  1    14**/
  1    15 
  1    16 /****^  HISTORY COMMENTS:
  1    17*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  1    18*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  1    19*     Support MCA and FIPS.
  1    20*                                                   END HISTORY COMMENTS */
  1    21 
  1    22 dcl  lock_info_ptr ptr;				/* Pointer to lock info structure. */
  1    23 dcl  rcs_ptr ptr;					/* Pointer to base of RCS. */
  1    24 dcl  rcse_ptr ptr;					/* Pointer to an RCS entry. */
  1    25 
  1    26 dcl 1 based_rcp_id based aligned,			/* Overlay of an rcp_id. */
  1    27    (2 id_count fixed bin (17),			/* Unique count index. */
  1    28     2 rcse_off bit (18)) unaligned;			/* Offset of rcp_com_seg entry. */
  1    29 
  1    30 dcl 1 rcs based (rcs_ptr) aligned,			/* Begin at word zero of rcp_com_seg. */
  1    31     2 lock_info like lock_info,			/* Data used to lock this segment. */
  1    32     2 ws_maxs (8) fixed bin (19),			/* Max IOI workspace size in words. */
  1    33     2 ws_pmaxs (8) fixed bin (19),			/* Max IOI workspace size for priv attachments. */
  1    34     2 to_maxs (8) fixed bin (71),			/* Max IOI time-out intervals in microseconds. */
  1    35     2 sys_directory char (32),			/* Directory  used to define a system process. */
  1    36     2 sys_acs char (32),				/* Entry name used to define a system process. */
  1    37     2 acs_directory char (32),			/* Directory containing device ACSs. */
  1    38     2 id_count fixed bin (35),			/* Counter used to form rcp_id. */
  1    39     2 max_entries fixed bin,				/* Maximum number of entries allowed. */
  1    40     2 num_entries fixed bin,				/* Total number of entries. */
  1    41     2 first_free_off bit (18),			/* Offset of first free entry. */
  1    42     2 entry (0 refer (rcs.num_entries))			/* Array of request entries. */
  1    43      like rcse,					/* See structure below. */
  1    44     2 end bit (36);					/* End of rcp_com_seg. */
  1    45 
  1    46 dcl 1 lock_info based (lock_info_ptr) aligned,		/* Used to meter locking. */
  1    47     2 lock bit (36),				/* The lock itself. */
  1    48     2 num_locks fixed bin (35),			/* Number of times locked. */
  1    49     2 num_lock_waits fixed bin (35),			/* Number of lock waits. */
  1    50     2 time_of_lock fixed bin (71),			/* Time of last lock. */
  1    51     2 tot_lock_time fixed bin (71),			/* Total time locked. */
  1    52     2 tot_wait_time fixed bin (71),			/* Total time waiting for lock. */
  1    53     2 starting_time fixed bin (71);			/* Time metering started. */
  1    54 
  1    55 dcl 1 rcse based (rcse_ptr) aligned,			/* Up to state must = rcpd.device. */
  1    56     2 device_name char (8),				/* Name of device associated with this entry. */
  1    57     2 volume_name char (32),				/* Volume name.  Blank => no volume. */
  1    58     2 dtypex fixed bin,				/* Device type index. */
  1    59     2 model fixed bin,				/* Device model number. */
  1    60     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    61     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    62     2 state_time fixed bin (71),			/* Time device put into current state. */
  1    63     2 state fixed bin,				/* 0 - free       1 - assigning  2 - assigned */
  1    64 						/* 3 - attaching  4 - attached   5 - completed. */
  1    65 
  1    66 /*	*	*	*	*	** Following fields are unique to RCS entry. */
  1    67     2 kind fixed bin,				/* 1 => attach, 2 => assign */
  1    68     2 free_off bit (18),				/* Offset of next free entry.  0 => not free. */
  1    69     2 user_off bit (18),				/* Offset of next entry in user list. */
  1    70     2 device_off bit (18),				/* Offset of device entry in RCPD. */
  1    71     2 volume_off bit (18),				/* Offset of volume entry in RCPD. */
  1    72     2 rcse_off bit (18),				/* Offset of associated RCS entry. */
  1    73     2 caller_level fixed bin,				/* Caller's validation level. */
  1    74     2 disposition bit (1),				/* ON => retain, OFF => unassign. */
  1    75     2 flags,					/* Special info flags. */
  1    76      (3 device bit (1),				/* ON => assigning a specific device. */
  1    77       3 priv bit (1),				/* ON => attached with IOI privilege. */
  1    78       3 system bit (1),				/* ON => assigned to a system process. */
  1    79       3 t_and_d bit (1),				/* ON => T&D attachment. */
  1    80       3 volume bit (1),				/* ON => volume associated with this device. */
  1    81       3 writing bit (1),				/* ON => writing on volume. */
  1    82       3 have_auth bit (1),				/* ON => tape volume authenticated. */
  1    83       3 need_auth bit (1),				/* ON => tape volume needs authentication. */
  1    84       3 auth_set bit (1),				/* ON => "have_auth" has been set. */
  1    85       3 preload_allowed bit (1),			/* ON => preloading of volumes is allowed. */
  1    86       3 preloaded bit (1),				/* ON => volume may be loaded on device. */
  1    87       3 not_removable_media bit (1),			/* ON => cannot remove volume from device. */
  1    88       3 disk_ss_pack bit (1),				/* ON => disk is a storage system volume. */
  1    89       3 disk_copy_of_ss_pack bit (1),			/* ON => disk is a copy of a storage system volume. */
  1    90       3 disk_io_pack bit (1),				/* ON => disk has label but is not storage system. */
  1    91       3 disk_unregistered bit (1),			/* ON => disk is unregistered storage system volume. */
  1    92       3 disk_unreadable bit (1),			/* ON => io error reading disk label. */
  1    93       3 must_auto_register bit (1),			/* ON => unregistered volume requested */
  1    94       3 fips bit (1),				/* ON => FIPS device. */
  1    95       3 no_protect bit (1),				/* ON => device has no protect sw. */
  1    96       3 opr_int_available bit (1),			/* ON => device connected to MPC with OI button. */
  1    97       3 unused bit (6),
  1    98       3 volume_density_index fixed bin (3) unsigned,	/* Density of volume */
  1    99       3 label_type fixed bin (6) unsigned)unaligned,	/* Type of label read by RCP. */
  1   100     2 rcp_id bit (36),				/* ID of this entry. */
  1   101     2 event_id fixed bin (71),			/* Caller's event channel ID. */
  1   102     2 process_id bit (36),				/* ID of calling process. */
  1   103     2 group_id char (32),				/* Group ID of calling process. */
  1   104     2 ecode fixed bin (35),				/* Assignment error code. */
  1   105     2 version_num fixed bin,				/* Device info version number. */
  1   106     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  1   107     2 timeout_max fixed bin (71),			/* Max IOI time-out interval. */
  1   108     2 ioi_index fixed bin,				/* IOI device index. */
  1   109     2 workspace_ptr ptr,				/* Pointer to IOI workspace buffer. */
  1   110     2 caller_comment char (64);			/* Caller's comment. */
  1   111 
  1   112 /*	End of include file ... rcp_com_seg.incl.pl1	*/
      284 
      285 
  2     1 /*  START OF:	rcp_device_info_structs.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  2     5*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  2     6*     Support of MCA.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 /* Written 03/04/85 by Chris Jones. */
  2    10 
  2    11 /* This include file obsoletes the following include files:  rcp_device_info, rcp_disk_info,
  2    12*   rcp_printer_info, and rcp_tape_info. */
  2    13 /* Modified May 1985 by Rich Fawcett to add the 8th device MCA */
  2    14 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    15 
  2    16 dcl	device_info_ptr	   ptr;
  2    17 
  2    18 dcl	1 device_info	   aligned based (device_info_ptr),
  2    19 	  2 common	   like device_info_common,
  2    20 	  2 qualifiers	   (4) fixed bin (35);	/* per device type info */
  2    21 
  2    22 dcl	1 device_info_common   aligned based,
  2    23 	  2 version_num	   fixed bin,		/* Version number of this structure. */
  2    24 	  2 usage_time	   fixed bin,		/* Number of minutes device will/may be used. */
  2    25 	  2 wait_time	   fixed bin,		/* Number of minutes user will/must wait. */
  2    26 	  2 system_flag	   bit (1),		/* ON => user wants to be a system process. */
  2    27 	  2 device_name	   char (8),		/* Device name. */
  2    28 	  2 model		   fixed bin;		/* Device model number. */
  2    29 
  2    30 dcl	1 tape_info	   based (device_info_ptr) aligned,
  2    31 	  2 common	   like device_info_common,
  2    32 	  2 tracks	   fixed bin,		/* 7 or 9 track */
  2    33 	  2 density	   bit (36),		/* density capabilities: 200, 556, 800, 1600, 6250 */
  2    34 	  2 speed		   bit (36),		/* speed: 75, 125, 200 */
  2    35 	  2 pad		   bit (36),
  2    36 	  2 volume_name	   char (32),		/* Tape reel name. */
  2    37 	  2 write_flag	   bit (1),		/* ON => writing on tape reel. */
  2    38 	  2 position_index	   fixed bin (35),		/* Counter used to determine tape reel position. */
  2    39 						/* Limit of version 2 structure, info below returned if version 3 or greater */
  2    40 	  2 volume_type	   fixed bin,		/* Use rcp_volume_formats.incl.pl1 for decodes */
  2    41 	  2 volume_density	   fixed bin,		/* 1 - 5 = 200, 556, 800, 1600, or 6250 BPI */
  2    42 	  2 opr_auth	   bit (1);		/* "1"b => Operator Authentication was required */
  2    43 
  2    44 dcl  tape_info_version_2 fixed bin internal static options (constant) init (2);
  2    45 dcl  tape_info_version_3 fixed bin internal static options (constant) init (3);
  2    46 
  2    47 dcl	1 disk_info	   based (device_info_ptr) aligned,
  2    48 	  2 common	   like device_info_common,
  2    49 	  2 volume_name	   char (32),		/* disk volume name */
  2    50 	  2 write_flag	   bit (1);		/* on => write_allowed */
  2    51 
  2    52 dcl	1 printer_info	   based (device_info_ptr) aligned,
  2    53 	  2 common	   like device_info_common,
  2    54 	  2 print_train	   fixed bin,		/* print train type */
  2    55 	  2 line_length	   fixed bin;		/* line length (-1 => not specified */
  2    56 
  2    57 dcl device_info_size (8) fixed bin static options (constant) init
  2    58    (24, 16, 7, 9, 7, 7, 7, 7);
  2    59 
  2    60 dcl	RCP_MAX_DEVICE_INFO_SIZE
  2    61 			   fixed bin static options (constant) init (24);
  2    62 
  2    63 /*  END OF:	rcp_device_info_structs.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      286 
      287 
      288      end rcp_attach_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.3  rcp_attach_.pl1                   >spec>install>1111>rcp_attach_.pl1
284          1    03/27/86  1120.0  rcp_com_seg.incl.pl1              >ldd>include>rcp_com_seg.incl.pl1
286          2    03/27/86  1120.0  rcp_device_info_structs.incl.pl1  >ldd>include>rcp_device_info_structs.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RCP_MAX_DEVICE_INFO_SIZE               constant        fixed bin(17,0)          initial dcl 2-60 ref 78
access_operations_$rcp_assign_read
                                000020 external static bit(36)                  dcl 101 ref 247
access_operations_$rcp_assign_write
                                000016 external static bit(36)                  dcl 99 ref 249
addr                                                   builtin function         dcl 91 ref 148 152 223
arcse                                  based           structure                level 1 dcl 83
arcse_off                       000100 automatic       bit(18)                  packed unaligned dcl 58 set ref 195* 196 216* 217
                                                                                  220 229* 230 234
arcse_ptr                       000134 automatic       pointer                  dcl 75 set ref 138* 220* 223* 224 225* 229 233 273
                                                                                  273 275*
arg_comment                            parameter       char                     packed unaligned dcl 47 ref 117 125 162
arg_device_info_ptr                    parameter       pointer                  dcl 48 ref 117 125 147
arg_device_type                        parameter       char                     packed unaligned dcl 49 ref 117 125 146
arg_ecode                              parameter       fixed bin(35,0)          dcl 50 set ref 117 125 262*
arg_event_id                           parameter       fixed bin(71,0)          dcl 51 ref 117 125 161
arg_rcp_id                             parameter       bit(36)                  dcl 52 set ref 117 125 260*
caller_comment           64            based           char(64)                 level 2 dcl 1-55 set ref 162*
caller_level                    000131 automatic       fixed bin(17,0)          dcl 71 set ref 141* 154* 280*
callers_device_info_ptr         000136 automatic       pointer                  dcl 76 set ref 147* 149* 251*
cleanup                         000244 stack reference condition                dcl 89 ref 142
code                                   parameter       fixed bin(35,0)          dcl 268 ref 265 270
cu_$level_get                   000022 constant        entry                    external dcl 104 ref 141
cu_$level_set                   000024 constant        entry                    external dcl 105 ref 144 280
device                   35            based           bit(1)                   level 3 packed packed unaligned dcl 1-55 ref 182
device_info_buffer              000140 automatic       bit(36)                  array dcl 78 set ref 148
device_info_common                     based           structure                level 1 dcl 2-22
device_info_ptr                 000254 automatic       pointer                  dcl 2-16 set ref 148* 149* 154*
device_name                     000120 automatic       char(32)                 packed unaligned dcl 68 set ref 136* 250*
device_off                      000101 automatic       bit(18)                  dcl 59 set ref 132* 219* 230* 244 250*
device_type                     000110 automatic       char(32)                 packed unaligned dcl 67 set ref 146* 149* 154*
dtypex                   12            based           fixed bin(17,0)          level 2 dcl 1-55 ref 164
ecode                           000132 automatic       fixed bin(35,0)          dcl 72 set ref 149* 150 154* 155 171* 177* 198* 206*
                                                                                  207 225* 226 250* 251 258* 260 262
error_count                     000133 automatic       fixed bin(17,0)          dcl 73 set ref 137* 250*
error_table_$bad_volid          000010 external static fixed bin(35,0)          dcl 93 ref 171
error_table_$no_operation       000012 external static fixed bin(35,0)          dcl 93 set ref 142* 177
error_table_$resource_attached  000014 external static fixed bin(35,0)          dcl 93 ref 198
event_id                 40            based           fixed bin(71,0)          level 2 dcl 1-55 set ref 161*
flags                    35            based           structure                level 2 dcl 1-55
get_ring_                       000026 constant        entry                    external dcl 106 ref 144 144
got_arcse                       000106 automatic       bit(1)                   dcl 64 set ref 139* 228* 275
got_rcse                        000107 automatic       bit(1)                   dcl 65 set ref 139* 209* 277
kind                     25            based           fixed bin(17,0)          level 2 in structure "rcse" dcl 1-55 in procedure
                                                                                  "rcp_attach_" set ref 159*
kind                     25            based           fixed bin(17,0)          level 2 in structure "arcse" dcl 83 in procedure
                                                                                  "rcp_attach_" set ref 224*
lock_info                              based           structure                level 1 dcl 1-46
null                                                   builtin function         dcl 91 ref 138 271 273
operation                       000130 automatic       bit(36)                  dcl 69 set ref 247* 249* 250*
priv                     35(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-55 set ref
                                                                                  160*
priv_flag                       000102 automatic       bit(1)                   packed unaligned dcl 60 set ref 121* 129* 160 174
process_id                      000103 automatic       bit(36)                  dcl 61 set ref 134* 250*
ptr                                                    builtin function         dcl 91 ref 220
rcp_control_                    000034 constant        entry                    external dcl 109 ref 250
rcp_device_info_$copy           000036 constant        entry                    external dcl 111 ref 149
rcp_device_info_$get            000040 constant        entry                    external dcl 112 ref 154
rcp_device_info_$set            000042 constant        entry                    external dcl 113 ref 251
rcp_find_$attached              000030 constant        entry                    external dcl 107 ref 195
rcp_find_$unattached            000032 constant        entry                    external dcl 108 ref 216
rcp_id                   36            based           bit(36)                  level 2 dcl 1-55 ref 260
rcp_rcse_$free                  000044 constant        entry                    external dcl 114 ref 275 277
rcp_rcse_$get                   000046 constant        entry                    external dcl 115 ref 206 225
rcse                                   based           structure                level 1 dcl 1-55
rcse_buffer                     000140 automatic       structure                level 1 dcl 79 set ref 152 223
rcse_off                        000104 automatic       bit(18)                  packed unaligned dcl 62 in procedure "rcp_attach_"
                                                                                  set ref 210* 233 236
rcse_off                 32            based           bit(18)                  level 2 in structure "arcse" dcl 83 in procedure
                                                                                  "rcp_attach_" set ref 233* 273*
rcse_off                 32            based           bit(18)                  level 2 in structure "rcse" dcl 1-55 in procedure
                                                                                  "rcp_attach_" set ref 234* 271*
rcse_ptr                        000252 automatic       pointer                  dcl 1-24 set ref 138* 152* 154* 159 160 161 162 164
                                                                                  167 174 182 182 195* 206* 210 216* 220 234 236 241
                                                                                  247 251* 260 271 271 277*
rel                                                    builtin function         dcl 91 ref 210 229
state                    24            based           fixed bin(17,0)          level 2 dcl 1-55 set ref 241*
t_and_d                  35(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-55 ref 174
volume                   35(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-55 ref 167 182
                                                                                  236
volume_off                      000105 automatic       bit(18)                  dcl 63 set ref 135* 236* 240* 244 247 250*
writing                  35(05)        based           bit(1)                   level 3 packed packed unaligned dcl 1-55 ref 247

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
based_rcp_id                           based           structure                level 1 dcl 1-26
device_info                            based           structure                level 1 dcl 2-18
device_info_size                       internal static fixed bin(17,0)          initial array dcl 2-57
disk_info                              based           structure                level 1 dcl 2-47
lock_info_ptr                          automatic       pointer                  dcl 1-22
printer_info                           based           structure                level 1 dcl 2-52
rcs                                    based           structure                level 1 dcl 1-30
rcs_ptr                                automatic       pointer                  dcl 1-23
tape_info                              based           structure                level 1 dcl 2-30
tape_info_version_2                    internal static fixed bin(17,0)          initial dcl 2-44
tape_info_version_3                    internal static fixed bin(17,0)          initial dcl 2-45

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP                         000615 constant        entry                    internal dcl 265 ref 142 258
COMMON                          000121 constant        label                    dcl 132 ref 122
DEVICE_TYPE                     000000 constant        label                    array(8) dcl 167 ref 164
RETURN                          000575 constant        label                    dcl 258 ref 150 155 172 178 199 207 226
attach                          000077 constant        entry                    external dcl 125
priv_attach                     000051 constant        entry                    external dcl 117
rcp_attach_                     000034 constant        entry                    external dcl 14

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1140        1210     703        1150
Length      1446     703        50         222     235           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rcp_attach_                         258 external procedure  is an external procedure.  
on unit on line 142                  70 on unit               
CLEANUP                              72 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rcp_attach_              000100 arcse_off                   rcp_attach_
                         000101 device_off                  rcp_attach_
                         000102 priv_flag                   rcp_attach_
                         000103 process_id                  rcp_attach_
                         000104 rcse_off                    rcp_attach_
                         000105 volume_off                  rcp_attach_
                         000106 got_arcse                   rcp_attach_
                         000107 got_rcse                    rcp_attach_
                         000110 device_type                 rcp_attach_
                         000120 device_name                 rcp_attach_
                         000130 operation                   rcp_attach_
                         000131 caller_level                rcp_attach_
                         000132 ecode                       rcp_attach_
                         000133 error_count                 rcp_attach_
                         000134 arcse_ptr                   rcp_attach_
                         000136 callers_device_info_ptr     rcp_attach_
                         000140 device_info_buffer          rcp_attach_
                         000140 rcse_buffer                 rcp_attach_
                         000252 rcse_ptr                    rcp_attach_
                         000254 device_info_ptr             rcp_attach_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
alloc_auto_adj      enable_op           ext_entry           ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cu_$level_set                 get_ring_                     rcp_control_
rcp_device_info_$copy         rcp_device_info_$get          rcp_device_info_$set          rcp_find_$attached
rcp_find_$unattached          rcp_rcse_$free                rcp_rcse_$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$rcp_assign_read                          access_operations_$rcp_assign_write
error_table_$bad_volid        error_table_$no_operation     error_table_$resource_attached




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     78 000025        14 000033       117 000042       121 000072       122 000074       125 000075       129 000120
    132 000121       134 000122       135 000123       136 000124       137 000127       138 000130       139 000133
    141 000135       142 000144       144 000170       146 000206       147 000214       148 000217       149 000221
    150 000245       152 000247       154 000251       155 000301       159 000303       160 000306       161 000313
    162 000316       164 000323       167 000325       171 000330       172 000333       174 000334       177 000341
    178 000344       182 000345       195 000350       196 000361       198 000364       199 000367       206 000370
    207 000401       209 000403       210 000405       216 000407       217 000420       219 000423       220 000424
    221 000430       223 000431       224 000433       225 000435       226 000446       228 000450       229 000452
    230 000454       233 000455       234 000460       236 000464       240 000472       241 000473       244 000475
    247 000505       249 000516       250 000521       251 000557       258 000575       260 000603       262 000611
    263 000613       265 000614       270 000622       271 000625       273 000634       275 000642       277 000655
    280 000672       282 000702


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
