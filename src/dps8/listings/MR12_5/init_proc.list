	COMPILATION LISTING OF SEGMENT init_proc
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1002.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4 */
       13 init_proc: proc;
       14 
       15 /* This program is the first program executed (in ring 0) in a user, absentee, or
       16*   daemon process. It is entered from special code in pxss via a return pointer
       17*   left in the stack by build_template_pds. It is also called explicitly during
       18*   initialization to get the initializer process into the user ring.
       19*
       20*   Last modified (date and reason):
       21*   8/15/74  by S.Webber --  completely recoded to make references to the pit.
       22*
       23*   76/04/29 by T. Casey to fix bug in implementation of "-initproc path,direct",
       24*   *		allow path to be relative to homedir,
       25*   *		and to replace all instances of call syserr (2,...) (print with alarm and terminate process) by
       26*   *		call syserr (4,...) or (3,...) (log, or print with alarm), followed by
       27*   *		direct calls to terminate_proc$init_failure with a relevant error_table_ code.
       28*   77/03/29 by M. Weaver to call makestack explicitly because of moving search rules to user ring
       29*   79/03/01 by B. Margulies to set the working dir BEFORE calling makestack
       30*   79/03/05 by B. Margulies to never set the working directory for users without
       31*   v_init_proc.
       32*   79/17/06 by B. Margulies to fix uninitialized variable bug introduced by
       33*   above.
       34*   79/07/14 by Mike Grady for ring 0 stack sharing
       35*   81/10/05 by B. Margulies for new call_out mechanism.
       36*   81/11/23 by B. Margulies for new initial procedure.
       37*   84/11/05 by K. Loepere to rename terminate to terminate_.
       38*   Modified 1984-11-11 by E. Swenson for IPC event channel validation.
       39*   Here we set the value of apte.ipc_r_factor.
       40**/
       41 
       42 /* Automatic */
       43 
       44 dcl  (pp, caller_ptr) ptr;
       45 dcl  (i, j) fixed bin;
       46 dcl  (d_len, e_len, hd_len, less_thans, po_len) fixed bin;
       47 dcl  code fixed bin (35);
       48 dcl  dirname char (168);
       49 dcl  initial_proc char (32);
       50 dcl  temp fixed bin (71);
       51 
       52 /* Entries */
       53 
       54 dcl  makestack entry (fixed bin);
       55 dcl  fs_search$set_wdir entry (char (*), fixed bin (35));
       56 dcl  terminate_$noname entry (ptr, fixed bin (35));
       57 dcl  pmut$set_mask entry (fixed bin (71), fixed bin (71));
       58 dcl  level$set entry (fixed bin);
       59 dcl  (syserr, syserr$error_code) entry options (variable);
       60 dcl  terminate_proc$init_failure entry (fixed bin (35));
       61 dcl  initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       62 dcl  initialize_kst entry;
       63 dcl  pathname_am$initialize ext entry;
       64 dcl  call_outer_ring_ entry (ptr, char (*), char (*), fixed bin (3), fixed bin (35));
       65 
       66 /* External */
       67 
       68 dcl  scs$open_level fixed bin (71) ext;
       69 dcl  pds$stack_0_ptr ptr ext;
       70 dcl  pds$stacks (0:7) ptr ext;
       71 dcl  pds$process_dir_name char (32) aligned ext;
       72 dcl  pds$process_group_id char (32) aligned ext;
       73 dcl  pds$initial_ring fixed bin ext;
       74 dcl  pds$apt_ptr pointer external;
       75 dcl  error_table_$badpath ext fixed bin (35);
       76 dcl  error_table_$bad_process_type ext fixed bin (35);
       77 
       78 /* Constants */
       79 
       80 dcl  (addr, index, length, null, reverse, rtrim, search, substr, verify) builtin;
       81 
       82 /* First get a pointer to the PIT. Do this with a call to initiate since we know our process directory name */
       83 
       84 	call pathname_am$initialize ();		/* initialize associative memory before doing anything */
       85 	call initialize_kst;			/* before initiate can be called we must have a KST */
       86 
       87 	pds$stacks (0) = pds$stack_0_ptr;
       88 
       89 	call level$set (pds$initial_ring);		/* set user ring validation level before initiating */
       90 	call pmut$set_mask (scs$open_level, temp);
       91 						/* Now dispatch on the process type */
       92 
       93 /* our goal is to establish wdir before calling makestack, so as to allow
       94*   the user to substitute a signal_ or unwinder_ if she has v_init_proc.
       95*   In order to do this we must initiate pit to check attribute.
       96*   Luckily, if you call initiate without a refname it doesnt attempt to
       97*   use the rnt, which isnt there yet. We would like to call initiate with
       98*   the refname of "pit_", but as it is we will have to leave that for the
       99*   user ring to do. */
      100 
      101 	call initiate ((pds$process_dir_name), "pit", "", (0), (0), pp, code);
      102 	if pp = null then do;
      103 	     call syserr$error_code (3, code, "init_proc: could not get pointer to pit for ^a", pds$process_group_id);
      104 	     call terminate_proc$init_failure (code);
      105 	end;
      106 
      107 	if pp -> pit.process_type = 0 then		/* initializer */
      108 	     initial_proc = "system_startup_";
      109 
      110 	else if pp -> pit.process_type < 4 then		/* interactive, absentee, or daemon */
      111 	     initial_proc = "initialize_process_";
      112 
      113 	else do;
      114 	     call syserr$error_code (3, "init_proc: bad process type (^d) given for ^a",
      115 		pp -> pit.process_type, pds$process_group_id);
      116 	     call terminate_proc$init_failure (error_table_$bad_process_type);
      117 	end;
      118 
      119 	if initial_proc ^= "system_startup_" then	/* skip this setting for initializer as vol may not be there */
      120 	     if pp -> pit.at.vinitproc then		/* if user is allowed to have his own process overseer */
      121 		call fs_search$set_wdir (pp -> pit.homedir, (0)); /* set initial working dir to homedir */
      122 						/* Otherwise avoid
      123*						   * setting wdir, so user can't violate vinitproc restriction
      124*						   * by putting a copy of xxxx_init_admin_ in his homedir */
      125 
      126 /* The error code from fs_search is ignored; if we can't
      127*   * set a working dir we do the best we can without one */
      128 
      129 	call makestack (pds$initial_ring);		/* create stack, RNT and search rules */
      130 
      131 
      132 /* Now initialize more of the process */
      133 
      134 /* * Now get a pointer to the initial procedure - the first one to be executed in the user's initial ring.
      135*   *
      136*   * The default initial procedure for a user is user_init_admin_ for an interactive process, or absentee_init_admin_
      137*   * for an absentee process. The proper one was selected above (its name being stored in initial_proc) as a function
      138*   * of the process type. The initial procedure calls the login responder (also known as the process overseer).
      139*   *
      140*   * The default process overseer for a user is process_overseer_.
      141*   *
      142*   * It is possible for a procedure to be specified, either in the user's pdt entry, or by the user on the login line,
      143*   * to be called instead of one of these two default procedures. The keyword "initproc" is used to identify this
      144*   * procedure in both cases, and the keyword "direct" is used to indicate that the procedure is to be called directly,
      145*   * in place of the default initial procedure, rather than being called by the default initial procedure
      146*   * in place of the default process overseer. It is the "direct" case which we must check for here.
      147*   *
      148*   * By default, we do not use the referencing_dir search rule when searching for the initial procedure. This
      149*   * allows a user to have an initial procedure of the same name as the default, in his home directory, and have
      150*   * it used instead of the installed one. This will only happen if the user has the vinitproc attribute,
      151*   * since, to enforce vinitproc, we put off setting his working directory to his home directory until
      152*   * after we get the pointer to the initial procedure, if he does not have that attribute.
      153**/
      154 
      155 	caller_ptr = null;				/* caller_ptr points to something in the referencing directory */
      156 
      157 /* * The implementation of the "direct" feature is being changed, in stages.
      158*   * Originally, this procedure was to scan for the string ",direct" at the end of the process overseer name,
      159*   * and upon finding it, eliminate that string, and call the procedure specified by the remainder of the pathname, directly.
      160*   * Then, the switch, pit.dont_call_init_admin was defined, and parts of the answering service were changed to
      161*   * check for the string ",direct", and upon finding it, eliminate it from the pathname and turn on that switch.
      162*   * However, some parts of the answering service do not check for the string or set the switch, so for now,
      163*   * this procedure must check for both indications, and must be sure to eliminate the string ",direct" from the pathname
      164*   * before attempting to get a pointer to the segment, even when the switch is found to be on.
      165*   * The lines that check for ",direct" may be deleted after all parts of the answering service have been changed to
      166*   * eliminate that string from the pathname and turn on the switch.
      167**/
      168 
      169 	po_len = -1 + index (pp -> pit.login_responder, ",direct"); /* look for ",direct" */
      170 	if po_len >= 0 then goto direct;		/* ",direct" is there, and
      171*						   po_len is the length of the pathname that preceeds it */
      172 
      173 	if pp -> pit.dont_call_init_admin then do;	/* check for the "direct" option */
      174 						/* compute length of pathname without trailing blanks */
      175 	     po_len = length (rtrim (pp -> pit.login_responder));
      176 
      177 direct:						/* come here if ",direct" is in the process overseer pathname */
      178 
      179 /* If string contains any ">" or "<" characters, it is a pathname */
      180 	     e_len = -1 + search (reverse (substr (pp -> pit.login_responder, 1, po_len)), "<>"); /* see if it does */
      181 
      182 	     if e_len >= 0 then do;			/* it is a pathname, and e_len is the length of the entryname */
      183 		d_len = po_len - e_len - 1;		/* compute length of dirname part */
      184 
      185 /* * Since expand_path_ is not available in ring zero, and it does not have
      186*   * an ideal interface for use in this stage of process initialization anyway,
      187*   * we do the equivalent pathname parsing in-line. This algorithm is copied from
      188*   * expand_path_, modified to avoid unnecessary generality.
      189**/
      190 
      191 		initial_proc = substr (pp -> pit.login_responder, d_len + 2, e_len); /* copy the entryname */
      192 		if substr (pp -> pit.login_responder, 1, 1) = ">" then /* if we have a full pathname */
      193 		     dirname = substr (pp -> pit.login_responder, 1, d_len); /* just copy the directory portion */
      194 
      195 		else do;				/* relative pathname - build dirname, using pit.homedir */
      196 		     hd_len = length (pp -> pit.homedir) - verify (reverse (pp -> pit.homedir), " ") + 1;
      197 						/* compute length of home directory */
      198 		     less_thans = -1 + verify (substr (pp -> pit.login_responder, 1, d_len + 2), "<");
      199 						/* count leading "<"s */
      200 						/* if there is nothing but "<"s before the entry name, the verify
      201*						   gives the index of the first char of the entry name,
      202*						   and the -1 makes the less_than count correct */
      203 		     if index (substr (pp -> pit.login_responder, 1 + less_thans, d_len - less_thans + 1), "<") > 0 then do;
      204 						/* if any non-leading less thans, bad syntax in path */
      205 bad_path:			call syserr (4, "init_proc: bad syntax in initial procedure name: ^a for ^a",
      206 			     pp -> pit.login_responder, pds$process_group_id);
      207 			call terminate_proc$init_failure (error_table_$badpath);
      208 		     end;
      209 
      210 		     do i = 1 to less_thans;		/* if there are no less thans, this loop is skipped */
      211 			j = index (reverse (substr (pp -> pit.homedir, 1, hd_len)), ">");
      212 						/* back up thru "less_thans" components and ">"s */
      213 			if j = 0 then		/* if no more left, too many "<"s */
      214 			     goto bad_path;		/* just say bad path - don't bother with details */
      215 			hd_len = hd_len - j;	/* shorten hd len by length of component and its leading ">" */
      216 		     end;				/* end less thans loop */
      217 
      218 		     if hd_len > 166 then		/* just a formality */
      219 			goto bad_path;
      220 		     if hd_len + d_len - less_thans + e_len + 2 > 168 then /* not just a formality */
      221 			goto bad_path;		/* path too long */
      222 
      223 /* now build the directory portion of the pathname */
      224 
      225 		     if hd_len > 0 then		/* if the less thans did not get us back to the root */
      226 			substr (dirname, 1, hd_len) = substr (pp -> pit.homedir, 1, hd_len);
      227 		     if d_len - less_thans > 0 then do; /* if <dir>ent rather than <ent */
      228 			substr (dirname, hd_len + 1, 1) = ">"; /* fill in ">dir" */
      229 			substr (dirname, hd_len + 2) = substr (pp -> pit.login_responder, less_thans + 1, d_len - less_thans);
      230 		     end;
      231 
      232 		end;				/* end relative pathname */
      233 
      234 
      235 /* * Try to initiate the segment specified by that pathname. Note that the pointer to it goes into caller_ptr,
      236*   * which is used below, in the call to call_outer_ring_, to indicate the referencing directory.
      237**/
      238 
      239 		call initiate (dirname, initial_proc, initial_proc, 0, 0, caller_ptr, code);
      240 		if caller_ptr = null then do;		/* code could be error_table_$segknown if process is prelinked */
      241 		     call syserr$error_code (4, code, "init_proc: can not get pointer to initial procedure: ^a>^a for ^a",
      242 			dirname, initial_proc, pds$process_group_id);
      243 		     call terminate_proc$init_failure (code);
      244 		end;
      245 	     end;					/* end pathname */
      246 
      247 /* End of in-line expand_path_   */
      248 
      249 	     else initial_proc = substr (pp -> pit.login_responder, 1, po_len); /* must be an entry name */
      250 
      251 	end;					/* end dont_call_init_admin (call process overseer directly) */
      252 
      253 	call terminate_$noname (pp, code);		/* terminate the pit */
      254 
      255 /**** The following code sets the value of apte.ipc_r_factor used in
      256*      conjunction with apte.ipc_r_offset for IPC event channel
      257*      validation.  apte.ipc_r_offset was set in act_proc, and
      258*      apte.ipc_r_factor is set here to allow for an unpredictable delay
      259*      between setting the two values.  This makes it difficult to
      260*      guess the value of apte.ipc_r_factor given the value of
      261*      apte.ipc_r_offset.
      262*
      263*      Note we are modifying our own apte here.  This should be ok since
      264*      we can be sure that no one else will attempt to modify this value,
      265*      and that the apte is not going anywhere while we are executing
      266*      here in ring-0. */
      267 
      268 	aptep = pds$apt_ptr;
      269 	apte.ipc_r_factor =
      270 	     binary (substr (bit (binary (clock (), 54), 54), 19, 36), 35);
      271 
      272 /* Now call out. this program does all the work of snapping the link */
      273 /* caller_ptr will be nonnull if there was a pathname */
      274 
      275 	call call_outer_ring_ (caller_ptr, initial_proc, initial_proc, (pds$initial_ring), code);
      276 
      277 	if code ^= 0 then do;
      278 	     call syserr$error_code (4, code, "init_proc: can not call out to initial procedure: ^a for ^a",
      279 		initial_proc, pds$process_group_id);
      280 	     call terminate_proc$init_failure (code);
      281 	end;
      282 
      283 /* format: off */
      284  /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  1     2 
  1     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  1     4 
  1     5 dcl  aptep pointer;
  1     6 
  1     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  1     8     2 thread unaligned,				/* List thread */
  1     9       3 fp bit (18),				/* Forward pointer */
  1    10       3 bp bit (18),				/* Backward pointer */
  1    11     2 flags unaligned,				/* Flags and miscellaneous */
  1    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  1    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  1    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  1    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  1    16       3 hproc bit (1),				/* ON if process is hardcore process */
  1    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  1    18       3 eligible bit (1),				/* ON if process is eligible */
  1    19       3 idle bit (1),				/* ON if  this is an idle process */
  1    20       3 interaction bit (1),				/* ON if process has interacted recently */
  1    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  1    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  1    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  1    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  1    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  1    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  1    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  1    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  1    29       3 firstsw bit (1),				/* OFF until process is intialized */
  1    30       3 state bit (18),				/* execution state */
  1    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  1    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  1    33 						/* bit 18-35: sequential number */
  1    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  1    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  1    36     2 ti fixed bin (35),				/* virtual time since interaction */
  1    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  1    38 
  1    39 /* * * * * * * * */
  1    40 
  1    41     2 ipc_pointers unaligned,
  1    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  1    43       3 pad3 bit (18),
  1    44     2 ips_message bit (36),				/* IPS signals pending */
  1    45     2 asteps unaligned,				/* relative ASTE pointers */
  1    46       3 pds bit (18),				/* PDS (per-process) */
  1    47       3 dseg bit (18),				/* DSEG (per-process) */
  1    48       3 prds bit (18),				/* PRDS (per-processor) */
  1    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  1    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  1    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  1    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  1    53 
  1    54 /* * * * * * * * */
  1    55 
  1    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  1    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  1    58     2 flags2 unaligned,
  1    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  1    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  1    61       3 pad7 bit (7),
  1    62       3 batch bit (1),				/* ON if absentee */
  1    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  1    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  1    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  1    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  1    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  1    68 
  1    69 /* * * * * * */
  1    70 
  1    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  1    72     2 ws_size fixed bin,				/* working set estimate for the process */
  1    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  1    74     2 deadline fixed bin (71),			/* time of next run */
  1    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  1    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  1    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  1    78*						/* reaches this (units = 1/1024 sec) */
  1    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  1    80     2 access_authorization bit (72),			/* authorization of this process */
  1    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  1    82 
  1    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  1    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  1    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  1    86 
  1    87 /*  Cells used to drive and instrument finite-state model for response time
  1    88*    measurement. Maintained by meter_response_time */
  1    89 
  1    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  1    91     2 pad18 bit (18) unaligned,
  1    92     2 number_processing fixed bin (35),			/* Number interactions */
  1    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  1    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  1    95 
  1    96 /* * * * * * */
  1    97 
  1    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  1    99 
  1   100 /*  End of cells for finite-state model */
  1   101 
  1   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  1   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  1   104     2 pad4 bit (28) unaligned,
  1   105     2 ipc_r_offset fixed bin (18) unsigned,
  1   106     2 ipc_r_factor fixed bin (35) unsigned,
  1   107     2 apad (10) fixed bin (35);
  1   108 
  1   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      284 
      285  /* BEGIN INCLUDE FILE ... pit.incl.pl1 */
  2     2 
  2     3 /****^  ********************************************
  2     4*        *                                          *
  2     5*        * Copyright, (C) Honeywell Bull Inc., 1988 *
  2     6*        *                                          *
  2     7*        ******************************************** */
  2     8 
  2     9 /* Requires user_attributes.incl.pl1 */
  2    10 /* Declaration of the Process Inititalization Table  (PIT) */
  2    11 
  2    12 /****^  HISTORY COMMENTS:
  2    13*  1) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
  2    14*     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
  2    15*     First comment for hcom. Modified 750430 by PG to add terminal_access_class
  2    16*     Modified 6/20/77 by J. Stern to add term_type_name Modified Feb 1980 by M.
  2    17*     B. Armstrong to implement multiple rate structures. (UNCA) Modified by R.
  2    18*     McDonald  May 1980 to include page charges, replaces cpu in iod (UNCA)
  2    19*     Modified by Benson I. Margulies November 1981 do declare pit_$, pit_ptr,
  2    20*     and unaligned character strings. Modified by E. N. Kittlitz January 1982
  2    21*     for user_attributes.incl.pl1 changes Modified by E. N. Kittlitz October
  2    22*     1982 for request_id. Modified by BIM 1984-09-12 for auth range. The max
  2    23*     copies the pds, but this is the only home of the min.
  2    24*  2) change(86-03-01,Gilcrease), approve(86-03-27,MCR7370),
  2    25*     audit(86-06-25,Lippard), install(86-06-30,MR12.0-1082):
  2    26*               Add the truncate_absout and restarted bits for the
  2    27*               -truncate .absout SCP 6297, version 3.
  2    28*  3) change(86-12-11,GDixon), approve(87-07-16,MCR7741),
  2    29*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  2    30*     Changed structure under pit.abs_attributes to use like structure in
  2    31*     abs_attributes.incl.pl1.  This allows the same attributes to be used
  2    32*     in abs_message_format.incl.pl1 and user_table_entry.incl.pl1 as well as
  2    33*     this include file.
  2    34*  4) change(88-06-03,Parisek), approve(88-06-10,MCR7920),
  2    35*     audit(88-06-23,Hunter), install(87-07-05,MR12.2-1053):
  2    36*     Remove "pitmsg" in END comment string.  pitmsg.incl.pl1 is no longer a
  2    37*     name of pit.incl.pl1.
  2    38*  5) change(88-07-11,Parisek), approve(88-07-11,MCR7849),
  2    39*     audit(88-07-03,Lippard), install(88-07-13,MR12.2-1047):
  2    40*     Removed the ringpad element and added the min_ring & max_ring elements so
  2    41*     users may access their lowest and/or highest possible login ring value.
  2    42*     SCP6367.
  2    43*                                                   END HISTORY COMMENTS */
  2    44 
  2    45 
  2    46 /* format: style4 */
  2    47 declare  pit_$ bit (36) aligned external static;
  2    48 declare  pit_ptr pointer;
  2    49 
  2    50 dcl  1 pit aligned based (pit_ptr),
  2    51        2 version fixed bin,				/* indicates which version of the pit */
  2    52        2 process_type fixed bin,			/* initializer, interactive, or absentee process */
  2    53        2 login_responder char (64) unal,		/* path name of login responder */
  2    54 
  2    55 /*  All of these are going to be word aligned whether or not they are declared aligned,
  2    56*   and unaligning them cleans up code in many places */
  2    57 
  2    58        2 homedir char (64) unal,			/* path name of home directory */
  2    59        2 project char (28) unal,			/* name of this process' project affiliation */
  2    60        2 account char (32) unal,			/* name of account to which this process is charged */
  2    61        2 n_processes fixed bin,			/* number of previous processes for this session */
  2    62        2 login_time fixed bin (71),			/* clock time at login */
  2    63        2 proc_creation_time fixed bin (71),		/* clock time at creation of this process */
  2    64        2 old_proc_cpu fixed bin (71),			/* cpu time used by previous processes in this session */
  2    65        2 user_weight fixed bin,			/* weight of this process */
  2    66        2 anonymous fixed bin,				/* 1 if anonymous user */
  2    67        2 login_name char (28) unal,			/* name of user given at login */
  2    68        2 logout_pid bit (36),				/* process id of answering service */
  2    69        2 logout_channel fixed bin (71),			/* channel for signalling logouts to answering service */
  2    70        2 group char (8) unal,				/* party group */
  2    71        2 min_ring fixed bin,				/* min ring */
  2    72        2 max_ring fixed bin,				/* max ring */
  2    73        2 at like user_attributes aligned,		/* include user_attributes.incl.pl1 */
  2    74        2 whox fixed bin,				/* this process's index in whotab (or 0) */
  2    75        2 outer_module char (32) unaligned,
  2    76        2 pad (2) fixed bin,
  2    77        2 dont_call_init_admin bit (1) aligned,		/* Call process_overseer_ directly */
  2    78        2 terminal_access_class bit (72) aligned,		/* access class of user's terminal */
  2    79        2 dollar_charge float bin,			/* Month-to-date expenditure */
  2    80        2 dollar_limit float bin,			/* Limit stop on usage */
  2    81        2 shift_limit (0:7) float bin,			/* Stops on each shift's usage */
  2    82        2 logins fixed bin,				/* Number of logins this month */
  2    83        2 crashes fixed bin,				/* Number of sessions crashed */
  2    84        2 interactive (0:7),				/* interactive usage by shift */
  2    85          3 charge float bin,				/* Total charge */
  2    86          3 xxx fixed bin,
  2    87          3 cpu fixed bin (71),			/* CPU usage in microseconds */
  2    88          3 core fixed bin (71),			/* Memory usage in page-microseconds */
  2    89          3 connect fixed bin (71),			/* Connect time in microseconds */
  2    90          3 io_ops fixed bin (71),			/* Terminal I/O operations */
  2    91        2 absentee (4),				/* Absentee usage by queue */
  2    92          3 charge float bin,				/* Total absentee charge */
  2    93          3 jobs fixed bin,				/* Number of jobs */
  2    94          3 cpu fixed bin (71),			/* CPU usage in microseconds */
  2    95          3 memory fixed bin (71),			/* Memory usage in mu */
  2    96        2 iod (4),					/* IO Daemon usage, by queue */
  2    97          3 charge float bin,				/* Total charge */
  2    98          3 pieces fixed bin,				/* Number of requests */
  2    99          3 pad fixed bin (35),
  2   100          3 pages fixed bin (35),			/* number of pages output */
  2   101          3 lines fixed bin (71),			/* Record count */
  2   102        2 devices (16) float bin,			/* Usage of attached devices */
  2   103        2 time_last_reset fixed bin (71),		/* time last updated the PDT */
  2   104        2 absolute_limit float bin,			/* Limit, not reset monthly */
  2   105        2 absolute_spent float bin,			/* Spending against this */
  2   106        2 absolute_cutoff fixed bin (71),		/* Spending will be reset on this date */
  2   107        2 absolute_increm fixed bin,			/* .. time increment code. 0 = don't reset */
  2   108        2 rs_number fixed bin (9) unsigned unaligned,	/* rate structure number (0= default rates) */
  2   109        2 pad1a fixed bin (27) unsigned unaligned,		/* remainder of word */
  2   110        2 request_id fixed bin (71),			/* absentee request id */
  2   111        2 authorization_range (2) bit (72) aligned,
  2   112        2 pad1 (73) fixed bin,				/* extra space */
  2   113        2 charge_type fixed bin,			/* device charge type of console */
  2   114        2 term_type_name char (32) unal,			/* terminal type name */
  2   115        2 line_type fixed bin,				/* line type of user's console */
  2   116        2 tty_type fixed bin,				/* old terminal type (obsolete, kept for compatibility) */
  2   117        2 service_type fixed bin,			/* type of service console is performing */
  2   118        2 tty_answerback char (4) unaligned,		/* original answerback of user's console */
  2   119        2 old_tty char (6),				/* (obsolete) attachment name of user's console */
  2   120        2 standby fixed bin,				/* 1 if standby user */
  2   121        2 login_line char (120) unal,			/* line typed at login */
  2   122        2 cant_bump_until fixed bin (71),		/* cannot be preempted until this time (0 for abs) */
  2   123        2 input_seg char (168) unal,			/* path name of absentee input file */
  2   124        2 output_seg char (168) unal,			/* path name of absentee output file */
  2   125        2 max_cpu_time fixed bin,			/* max number of seconds allowed to this absentee proc */
  2   126        2 abs_queue fixed bin,				/* absentee queue if absentee, else -1 */
  2   127        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
  2   128        2 arg_info_ptr fixed bin (18) unsigned,		/* Relative pointer to information on absentee args. */
  2   129        2 old_proc_core fixed bin (71),			/* Memory usage by previous processes in this session */
  2   130        2 old_proc_io_ops fixed bin (71),		/* I/O operations from previous processes in this session */
  2   131        2 tty char (32) unaligned,			/* Attachment name of users channel */
  2   132        2 start_arg_info fixed bin;			/* Put absentee args information here. */
  2   133 
  2   134 
  2   135 /* Structure to contain information on absentee arguments */
  2   136 dcl  1 arg_info aligned based,
  2   137        2 arg_count fixed bin,				/* Number of arguments for replacement in absentee segment */
  2   138        2 ln_args fixed bin,				/* Length of string containing arguments. */
  2   139        2 arg_lengths (25 refer (arg_info.arg_count)) fixed bin, /* Array of argument lengths */
  2   140        2 args char (128 refer (arg_info.ln_args)) unal;
  2   141 						/* Args used for replacement in absentee control segment. */
  2   142 
  2   143 declare PIT_version_3 fixed bin int static options (constant) init (3);
  2   144 
  2   145 /* END INCLUDE FILE ... pit.incl.pl1 */
      285 
      286  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  3     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  3     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  3     8*     attribute switches.
  3     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  3    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  3    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  3    12*         be deleted.
  3    13*      B) Add constants identifying attributes that can be changed by user at
  3    14*         login, etc.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 
  3    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  3    19 
  3    20 /* format: style4 */
  3    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  3    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  3    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  3    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  3    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  3    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  3    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  3    28*						   .  of same project (distinct from "nobump") */
  3    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  3    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  3    31        2 multip bit (1),				/* 9  user may have several processes */
  3    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  3    33        2 brief bit (1),				/* 11 no login or logout message */
  3    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  3    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  3    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  3    37        2 sb_ok bit (1),				/* 15 user may be standby */
  3    38        2 pm_ok bit (1),				/* 16 user may be primary */
  3    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  3    40        2 daemon bit (1),				/* 18 user may login as daemon */
  3    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  3    42        2 no_warning bit (1),				/* 20 no warning message */
  3    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  3    44*						   .  in PDT: this user has an individual load control group */
  3    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  3    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  3    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  3    48        2 pad bit (12)) unaligned;
  3    49 
  3    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  3    51     ("none",					/* 0 */
  3    52      "administrator",				/* 1 */
  3    53      "primary_line",				/* 2 */
  3    54      "nobump",					/* 3 */
  3    55      "guaranteed_login",				/* 4 */
  3    56      "anonymous",					/* 5 */
  3    57      "nopreempt",					/* 6 */
  3    58      "nolist",					/* 7 */
  3    59      "dialok",					/* 8 */
  3    60      "multip",					/* 9 */
  3    61      "bumping",					/* 10 */
  3    62      "brief",					/* 11 */
  3    63      "vinitproc",					/* 12 */
  3    64      "vhomedir",					/* 13 */
  3    65      "nostartup",					/* 14 */
  3    66      "no_secondary",				/* 15 */
  3    67      "no_prime",					/* 16 */
  3    68      "no_eo",					/* 17 */
  3    69      "daemon",					/* 18 */
  3    70      "",						/* 19 vdim OBSOLETE */
  3    71      "no_warning",					/* 20 */
  3    72      "igroup",					/* 21 */
  3    73      "save_pdir",					/* 22 */
  3    74      "disconnect_ok",				/* 23 */
  3    75      "save_on_disconnect");				/* 24 */
  3    76 
  3    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  3    78     ("null",					/* 0 */
  3    79      "admin",					/* 1 */
  3    80      "", "",					/* 2 - 3 */
  3    81      "guar",					/* 4 */
  3    82      "anon",					/* 5 */
  3    83      "", "",					/* 6 - 7 */
  3    84      "dial",					/* 8 */
  3    85      "multi_login",					/* 9 */
  3    86      "preempting",					/* 10 */
  3    87      "",						/* 11 */
  3    88      "v_process_overseer",				/* 12 */
  3    89      "v_home_dir",					/* 13 */
  3    90      "no_start_up",					/* 14 */
  3    91      "no_sec",					/* 15 */
  3    92      "no_primary",					/* 16 */
  3    93      "no_edit_only",				/* 17 */
  3    94      "op_login",					/* 18 */
  3    95      "",						/* 19 */
  3    96      "nowarn",					/* 20 */
  3    97      "", "", "",					/* 21 - 23 */
  3    98      "save");					/* 24 */
  3    99 
  3   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  3   101      options(constant) init("000000000010000000010000000000000000"b);
  3   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  3   103 
  3   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  3   105      options(constant) init("000000000010000000010000000000000000"b);
  3   106     /* PDT value for (brief, no_warning) is default */
  3   107 
  3   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  3   109      options(constant) init("000100000110010000010000000000000000"b);	
  3   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  3   111 
  4     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  4     2 
  4     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 /*							       */
  4     5 /* This include file describes the attributes of an absentee job.  It is     */
  4     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  4     7 /* and PIT.incl.pl1.   */
  4     8 /*							       */
  4     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    10 
  4    11 /****^  HISTORY COMMENTS:
  4    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  4    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    14*     Separated abs_attributes from the request structure
  4    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  4    16*     used in the ute structure (user_table_entry.incl.pl1).
  4    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  4    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    19*     Added ABS_ATTRIBUTE_NAMES array.
  4    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  4    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  4    22*     Added the no_start_up flag. SCP6367
  4    23*                                                   END HISTORY COMMENTS */
  4    24 
  4    25 dcl 1 user_abs_attributes		aligned based,
  4    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  4    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  4    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  4    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  4    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  4    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  4    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  4    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  4    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  4    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  4    36       2 attributes_pad		bit (26) unaligned;
  4    37 
  4    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  4    39 	"restartable",
  4    40 	"user_deferred_until_time",
  4    41 	"proxy",
  4    42 	"set_bit_cnt",
  4    43 	"time_in_gmt",
  4    44 	"user_deferred_indefinitely",
  4    45 	"secondary_ok",
  4    46 	"truncate_absout",
  4    47 	"restarted",
  4    48 	"no_start_up");
  4    49 
  4    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  4    51 
  3   112 
  3   113 
  3   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      286 
      287 
      288 /* BEGIN MESSAGE DOCUMENTATION
      289*
      290*   Message:
      291*   init_proc: could not get pointer to pit for PERSON.PROJ.T ERROR_MESSAGE
      292*
      293*   S:	$beep
      294*
      295*   T:	$run
      296*
      297*   M:	The answering service has created
      298*   the process directory for a new process incorrectly.
      299*   The user cannot be logged in.
      300*
      301*   A:	$contact
      302*
      303*
      304*   Message:
      305*   init_proc: bad process type (N) given for PERSON.PROJ.T
      306*
      307*   S:	$beep
      308*
      309*   T:	$run
      310*
      311*   M:	The answering service has specified an
      312*   unknown integer in the process type field.
      313*   Incorrect arguments were passed to hphcs_$create_proc.
      314*   The user cannot be logged in.
      315*
      316*   A:	$contact
      317*
      318*
      319*   Message:
      320*   init_proc: bad syntax in initial procedure name: STRING for PERSON.PROJ.T
      321*
      322*   S:	$log
      323*
      324*   T:	$run
      325*
      326*   M:	An illegal initial procedure name was specified for the user.
      327*   The user may have given an incorrect -po argument, or the project's PDT may be wrong.
      328*   No process is created.
      329*
      330*   A:	$ignore
      331*
      332*
      333*   Message:
      334*   init_proc: can not get pointer to initial procedure: PATH for PERSON.PROJ.T ERROR_MESSAGE
      335*
      336*   S:	$log
      337*
      338*   T:	$run
      339*
      340*   M:	The supervisor could not initiate the specified initial procedure PATH.
      341*   The process overseer may be in invalid form, inaccessible, or missing.
      342*   The user may have given an incorrect -po argument, or the project's PDT may be incorrect.
      343*
      344*   A:	$ignore
      345*
      346*
      347*   Message:
      348*   init_proc: can not call out to initial procedure: NAME for PERSON.PROJ.T ERROR_MESSAGE
      349*
      350*   S:	$log
      351*
      352*   T:	$run
      353*
      354*   M:	The supervisor could not snap a link to NAME$NAME.
      355*   The process overseer may be in invalid form, inaccessible, or missing.
      356*   The user may have given an incorrect -po argument, or the project's PDT may be incorrect.
      357*
      358*   A:	$ignore
      359*
      360*
      361*   END MESSAGE DOCUMENTATION */
      362 /* format: on */
      363 
      364      end init_proc;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0804.6  init_proc.pl1                     >spec>install>1111>init_proc.pl1
284          1    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
285          2    07/14/88  2015.0  pit.incl.pl1                      >ldd>include>pit.incl.pl1
286          3    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
3-112        4    07/14/88  2015.0  user_abs_attributes.incl.pl1      >ldd>include>user_abs_attributes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
apte                                   based           structure                level 1 dcl 1-7
aptep                           000200 automatic       pointer                  dcl 1-5 set ref 268* 269
at                      110            based           structure                level 2 dcl 2-50
call_outer_ring_                000036 constant        entry                    external dcl 64 ref 275
caller_ptr                      000102 automatic       pointer                  dcl 44 set ref 155* 239* 240 275*
code                            000113 automatic       fixed bin(35,0)          dcl 47 set ref 101* 103* 104* 239* 241* 243* 253*
                                                                                  275* 277 278* 280*
d_len                           000106 automatic       fixed bin(17,0)          dcl 46 set ref 183* 191 192 198 203 220 227 229
dirname                         000114 automatic       char(168)                packed unaligned dcl 48 set ref 192* 225* 228* 229*
                                                                                  239* 241*
dont_call_init_admin    124            based           bit(1)                   level 2 dcl 2-50 ref 173
e_len                           000107 automatic       fixed bin(17,0)          dcl 46 set ref 177* 182 183 191 220
error_table_$bad_process_type   000060 external static fixed bin(35,0)          dcl 76 set ref 116*
error_table_$badpath            000056 external static fixed bin(35,0)          dcl 75 set ref 207*
fs_search$set_wdir              000012 constant        entry                    external dcl 55 ref 119
hd_len                          000110 automatic       fixed bin(17,0)          dcl 46 set ref 196* 211 215* 215 218 220 225 225 225
                                                                                  228 229
homedir                  22            based           char(64)                 level 2 packed packed unaligned dcl 2-50 set ref
                                                                                  119* 196 196 211 225
i                               000104 automatic       fixed bin(17,0)          dcl 45 set ref 210*
index                                                  builtin function         dcl 80 ref 169 203 211
initial_proc                    000166 automatic       char(32)                 packed unaligned dcl 49 set ref 107* 110* 119 191*
                                                                                  239* 239* 241* 249* 275* 275* 278*
initialize_kst                  000032 constant        entry                    external dcl 62 ref 85
initiate                        000030 constant        entry                    external dcl 61 ref 101 239
ipc_r_factor             65            based           fixed bin(35,0)          level 2 unsigned dcl 1-7 set ref 269*
j                               000105 automatic       fixed bin(17,0)          dcl 45 set ref 211* 213 215
length                                                 builtin function         dcl 80 ref 175 196
less_thans                      000111 automatic       fixed bin(17,0)          dcl 46 set ref 198* 203 203 210 220 227 229 229
level$set                       000020 constant        entry                    external dcl 58 ref 89
login_responder           2            based           char(64)                 level 2 packed packed unaligned dcl 2-50 set ref 169
                                                                                  175 177 191 192 192 198 203 205* 229 249
makestack                       000010 constant        entry                    external dcl 54 ref 129
null                                                   builtin function         dcl 80 ref 102 155 240
pathname_am$initialize          000034 constant        entry                    external dcl 63 ref 84
pds$apt_ptr                     000054 external static pointer                  dcl 74 ref 268
pds$initial_ring                000052 external static fixed bin(17,0)          dcl 73 set ref 89* 129* 275
pds$process_dir_name            000046 external static char(32)                 dcl 71 ref 101
pds$process_group_id            000050 external static char(32)                 dcl 72 set ref 103* 114* 205* 241* 278*
pds$stack_0_ptr                 000042 external static pointer                  dcl 69 ref 87
pds$stacks                      000044 external static pointer                  array dcl 70 set ref 87*
pit                                    based           structure                level 1 dcl 2-50
pmut$set_mask                   000016 constant        entry                    external dcl 57 ref 90
po_len                          000112 automatic       fixed bin(17,0)          dcl 46 set ref 169* 170 175* 177 183 249
pp                              000100 automatic       pointer                  dcl 44 set ref 101* 102 107 110 114 119 119 169 173
                                                                                  175 177 191 192 192 196 196 198 203 205 211 225
                                                                                  229 249 253*
process_type              1            based           fixed bin(17,0)          level 2 dcl 2-50 set ref 107 110 114*
reverse                                                builtin function         dcl 80 ref 177 196 211
rtrim                                                  builtin function         dcl 80 ref 175
scs$open_level                  000040 external static fixed bin(71,0)          dcl 68 set ref 90*
search                                                 builtin function         dcl 80 ref 177
substr                                                 builtin function         dcl 80 set ref 177 191 192 192 198 203 211 225* 225
                                                                                  228* 229* 229 249 269
syserr                          000022 constant        entry                    external dcl 59 ref 205
syserr$error_code               000024 constant        entry                    external dcl 59 ref 103 114 241 278
temp                            000176 automatic       fixed bin(71,0)          dcl 50 set ref 90*
terminate_$noname               000014 constant        entry                    external dcl 56 ref 253
terminate_proc$init_failure     000026 constant        entry                    external dcl 60 ref 104 116 207 243 280
user_abs_attributes                    based           structure                level 1 dcl 4-25
user_attributes                        based           structure                level 1 dcl 3-21
verify                                                 builtin function         dcl 80 ref 196 198
vinitproc               110(11)        based           bit(1)                   level 3 packed packed unaligned dcl 2-50 ref 119

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 4-38
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 3-77
PIT_version_3                          internal static fixed bin(17,0)          initial dcl 2-143
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 3-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 3-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 3-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 3-50
addr                                                   builtin function         dcl 80
arg_info                               based           structure                level 1 dcl 2-136
pit_$                                  external static bit(36)                  dcl 2-47
pit_ptr                                automatic       pointer                  dcl 2-48

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_path                        000574 constant        label                    dcl 205 ref 213 218 220
direct                          000473 constant        label                    dcl 177 ref 170
init_proc                       000151 constant        entry                    external dcl 13

NAMES DECLARED BY CONTEXT OR IMPLICATION.
binary                                                 builtin function         ref 269 269
bit                                                    builtin function         ref 269
clock                                                  builtin function         ref 269

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1660        1742    1403        1670
Length      2232    1403        62         253     255           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
init_proc                           204 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
init_proc                000100 pp                          init_proc
                         000102 caller_ptr                  init_proc
                         000104 i                           init_proc
                         000105 j                           init_proc
                         000106 d_len                       init_proc
                         000107 e_len                       init_proc
                         000110 hd_len                      init_proc
                         000111 less_thans                  init_proc
                         000112 po_len                      init_proc
                         000113 code                        init_proc
                         000114 dirname                     init_proc
                         000166 initial_proc                init_proc
                         000176 temp                        init_proc
                         000200 aptep                       init_proc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           set_chars_eis       index_chars_eis
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
call_outer_ring_              fs_search$set_wdir            initialize_kst                initiate
level$set                     makestack                     pathname_am$initialize        pmut$set_mask
syserr                        syserr$error_code             terminate_$noname             terminate_proc$init_failure

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_process_type error_table_$badpath          pds$apt_ptr                   pds$initial_ring
pds$process_dir_name          pds$process_group_id          pds$stack_0_ptr               pds$stacks
scs$open_level




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000150        84 000156        85 000162        87 000167        89 000173        90 000201       101 000212
    102 000263       103 000267       104 000321       107 000330       110 000337       114 000345       116 000377
    119 000406       129 000434       155 000443       169 000445       170 000456       173 000457       175 000461
    177 000473       182 000504       183 000505       191 000511       192 000515       196 000526       198 000544
    203 000557       205 000574       207 000627       210 000636       211 000645       213 000660       215 000661
    216 000663       218 000665       220 000670       225 000676       227 000704       228 000707       229 000713
    239 000731       240 000772       241 000776       243 001040       245 001047       249 001050       253 001054
    268 001065       269 001071       275 001102       277 001133       278 001135       280 001173       364 001202


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
