	COMPILATION LISTING OF SEGMENT ncp_lock_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/02/84  1320.1 mst Mon
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ncp_lock_:
       12           procedure ();
       13 
       14 /*             "ncp_lock_" -- this module contains the functions which          */
       15 /*        implement the locking strategies of the NCP.  Notice that these do    */
       16 /*        not include use of the system lock module due to the fact that that   */
       17 /*        module is not willing to include an "unlock all" function.            */
       18 
       19 /*        Originally coded by E. W. Meyer.                                      */
       20 /*        Modified by D. M. Wells for conversion to Version II PL/I.            */
       21 /*        Modified by D. M. Wells on 18 June, 1974, to add verify_lock          */
       22 /*             entry point.                                                     */
       23 /*        Modified by D. M. Wells, August 1977, to use new PL/I builtins.       */
       24 
       25 /*        Current locking order (from first to last) is:                        */
       26 /*             host_table               -- for host additions, state changes    */
       27 /*             socket_table             -- whenever new sockets are added       */
       28 /*             socket_entry             -- whenever socket attributes changed   */
       29 /*             host entry               -- whenever links are assigned          */
       30 /*             rfc entry                -- (not locked) for resource assignment */
       31 /*                                                                              */
       32 /*        The following dependencies exist:                                     */
       33 /*             socket-activation:       socket-tbl -> socket-entry              */
       34 /*             link-assignment:         socket-entry -> host-entry              */
       35 /*             host-state-change:       host-table -> socket-entry              */
       36 /*                  (incl link unassignment)      -> host-entry                 */
       37 
       38           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
       39 
       40      declare
       41          (P_error_code fixed binary (35),                   /* standard Multics status code                   */
       42           P_lock_ptr pointer)                              /* pointer to the lock in question                */
       43                parameter;
       44 
       45           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
       46 
       47      declare
       48          (processid_code fixed bin (35),
       49           processid bit (36) aligned,
       50           tbl_indx fixed binary (17),                       /* index for looping through arrays               */
       51           wait_times fixed binary (17),                     /* count of calls to pxss$wait this time          */
       52           start_clock fixed binary (71),                    /* maybe has entry time in it           */
       53           npr pointer,
       54           lock_ptr pointer)                                      /* copy of P_lock_ptr internally                 */
       55                automatic;
       56 
       57           /* * * * * BASED & TEMPLATE REFERENCES * * * * * */
       58 
       59      declare
       60           based_lock bit (36) aligned
       61                based;
       62 
       63           /* * * * * EXTERNAL STATIC DECLARATIONS  * * * * */
       64 
       65      declare
       66          (ncp_params_$syserr_report_error fixed binary (17),
       67           ncp_params_$wait_event fixed binary (35),
       68           ncp_tables_$tracing_info bit (36) aligned,
       69           pds$process_id bit (36) aligned)		
       70                external static;
       71 
       72      declare
       73           ncp_tables_$ncp_data
       74                external static;
       75 
       76      declare
       77           1 ncp_tables_$lock_tbl external static,           /* the NCP lock table array                       */
       78              2 lock_count fixed binary (17),                /* count of locks locked now                      */
       79              2 wait_count fixed binary (17),                /* count of processes waiting on locks            */
       80              2 lock_array (1 : 10) aligned,
       81                 3 process_id bit (36) aligned,                 /* the process id of a process waiting               */
       82                 3 num_times_slot_used fixed binary (30),    /* number of times this lock slot was used        */
       83                 3 lock_ptr pointer;                         /* pointer to the lock process has locked      */
       84 
       85      declare
       86          (error_table_$invalid_lock_reset,
       87           error_table_$lock_not_locked,
       88           error_table_$locked_by_other_process,
       89           error_table_$locked_by_this_process,
       90           error_table_$net_not_up,
       91           error_table_$net_table_space,
       92           error_table_$net_timeout)
       93                fixed binary (35) external static;
       94 
       95           /* * * * * ENTRY & PROCEDURE DECLARATIONS  * * * */
       96 
       97      declare
       98           ncp_error_ constant entry (fixed bin (35), char (*)),
       99           ncp_trace_ constant entry options (variable),
      100           pxss$addevent constant entry (fixed bin (35)),
      101           pxss$notify constant entry (fixed bin (35)),
      102           pxss$wait constant entry (),
      103           syserr constant entry options (variable),
      104 	tc_util$validate_processid entry (bit (36) aligned, fixed bin (35));
      105 
      106      declare
      107           (addr, clock, hbound, lbound, null, stacq)
      108                builtin;
      109 
      110           /* * * * * INCLUDE FILES * * * * * * * * * * * * */
      111 
      112           
  1     2 /*             "ncp_constants_dcls.incl.pl1" -- include file to       */
  1     3 /*        declare some constants used throughout the Multics Network  */
  1     4 /*        Control Program (NCP).                                      */
  1     5 
  1     6 /*        Originally created by D. M. Wells, 1975, May 19.            */
  1     7 
  1     8      declare
  1     9          (NCP_DOWN            initial (0),                  /* the NCP has been shutdown normally             */
  1    10           NCP_UP_IMP_DOWN     initial (1),                  /* the NCP is up, but the IMP is unreachable      */
  1    11           NCP_UP              initial (2),                  /* the NCP is up and running normally             */
  1    12           NCP_CRASHED         initial (-1))                 /* the NCP has crashed itself                     */
  1    13                fixed binary (3) internal static options (constant);
  1    14 
  1    15      declare
  1    16          (READ_GENDER         initial ("0"b),               /* Read sockets are even numbers                  */
  1    17           WRITE_GENDER        initial ("1"b))               /* Write sockets ar odd numbers                   */
  1    18                bit (1) internal static options (constant);
  1    19 
  1    20      declare
  1    21          (HOST_OFF            initial (0),                  /* this host is not enabled for communications    */
  1    22           HOST_UP             initial (1),                  /* Host is up and everything ok                   */
  1    23           HOST_RST            initial (2),                  /* a Host-Host RST command has been sent          */
  1    24           HOST_DOWN           initial (3),                  /* Foreign host is down                           */
  1    25           HOST_ON             initial (4))                  /* Foreign host is enabled, but not RST yet       */
  1    26                fixed binary (6) internal static options (constant);
  1    27 
  1    28      declare
  1    29          (SOCK_UNASSIGNED     initial (0),                  /* This socket entry is not in use currently      */
  1    30           SOCK_ASSIGNED       initial (1),                  /* Socket has been assigned and is quiescent      */
  1    31           SOCK_LISTENING      initial (2),                  /* Socket is listening for incoming-RFCs          */
  1    32           SOCK_RFC_RCVD       initial (3),                  /* Socket has received RFC from foreign socket    */
  1    33           SOCK_RFC_ABORTED    initial (4),                  /* CLS  received for unacknowledged RFC           */
  1    34           SOCK_RFC_SENT       initial (5),                  /* RFC sent to foreign socket, but no reply       */
  1    35           SOCK_CONNECTED      initial (6),                  /* Socket is connected to foreign socket          */
  1    36           SOCK_CLS_WAIT       initial (7),                  /* CLS issued, waiting for reply CLS              */
  1    37                                                             /* State 8 is not currently defined               */
  1    38           SOCK_DATA_WAIT      initial (9),                  /* User requested close, but data still here      */
  1    39           SOCK_RFNM_WAIT      initial (10),                 /* User requested close, but waiting on last RFNM */
  1    40           SOCK_CLS_READ       initial (11),                 /* CLS received, but data still in buffers        */
  1    41                                                             /* State 12 is not currently defined              */
  1    42           SOCK_BROKEN         initial (13),                 /* Socket has been involved in some NCP anomaly   */
  1    43           SOCK_RESET          initial (14))                 /* Socket was connected to host that was reset    */
  1    44                fixed binary (6) internal static options (constant);
  1    45 
  1    46      declare
  1    47          (SOCK_INDX_MASK      initial ("000000777777"b3),   /* mask to get out actual array index             */
  1    48           SOCK_UNIQUE_MASK    initial ("377777000000"b3))   /* mask to get out incrementing part of indx      */
  1    49                bit (36) internal static options (constant);
  1    50 
  1    51      declare
  1    52          (ANY_TRACING         initial ("400000000000"b3),             /* if any tracing is occurring          */
  1    53           PRINTER_TRACING     initial ("200000000000"b3),             /* if tracing to the ptr is happening   */
  1    54           SYSERR_LOG_TRACING  initial ("100000000000"b3),             /* if tracing to syserr log mechanism   */
  1    55 
  1    56           TRACE_CTL_MSGS      initial ("004000000000"b3),             /* if host-host ctl msgs should be trcd */
  1    57           TRACE_PROCESS_INFO  initial ("002000000000"b3),             /* if process control should be trcd    */
  1    58           TRACE_DATA_FLOW     initial ("001000000000"b3),             /* if flow of user data to be traced    */
  1    59 
  1    60           TRACE_NCP_RING      initial ("000400000000"b3),             /* if ncp_ring_ should be traced        */
  1    61           TRACE_NCP_ACCESS    initial ("000200000000"b3),             /* if ncp_access_ should be traced      */
  1    62           TRACE_NCP_DAEMON    initial ("000100000000"b3),             /* if ncp_daemon_ should be traced      */
  1    63           TRACE_NCP_CONTROL   initial ("000040000000"b3),             /* if ncp_control_ should be traced     */
  1    64           TRACE_NCP_TBOP      initial ("000020000000"b3),             /* if ncp_tbop_ should be traced        */
  1    65           TRACE_NCP_IO        initial ("000010000000"b3))             /* if ncp_io_ should be traced          */
  1    66                bit (36) aligned internal static options (constant);
  1    67 
  1    68 /*        end of include file "ncp_constants_dcls.incl.pl1            */
  1    69 
      112 
      113           
  2     2 /*        BEGIN include file ncp_data_dcls.incl.pl1 --                          */
  2     3 
  2     4 /*             This include file contains declarations of structures kept       */
  2     5 /*        in the NCP data base which aren't associated directly with            */
  2     6 /*        Network connections or process control.                               */
  2     7 
  2     8 /*        Originally created by D. M. Wells, Jan., 1976 by altering a           */
  2     9 /*                  previously existing include file.                           */
  2    10      declare
  2    11           1 ncp_dt aligned based,                           /* Information about global state of NCP          */
  2    12              2 ncp_ev_chan fixed binary (71),               /* event channel id of NCP Daemon process         */
  2    13              2 ncp_procid bit (36),                         /* process id of NCP Daemon process               */
  2    14              2 ncp_up fixed binary (2),                     /* -1 crashed, 0 uninit, 1 imp down, 2 up         */
  2    15              2 htbl_size fixed binary (17),                 /* max size of host table in entries              */
  2    16              2 rtbl_size fixed binary (17),                 /* max size of RFC table in entries               */
  2    17              2 stbl_size fixed binary (17),                 /* max size of socket table in entries            */
  2    18              2 size_pad fixed binary (17),
  2    19 
  2    20              2 htbl_gent fixed binary (17),                 /* max host entry used                            */
  2    21              2 rtbl_gent fixed binary (17),                 /* max RFC entry used                             */
  2    22              2 stbl_gent fixed binary (17),                 /* max socket entry used                          */
  2    23              2 gent_pad fixed binary (17),
  2    24 
  2    25              2 htbl_lock bit (36) aligned,                  /* lock for host table                            */
  2    26              2 rtbl_lock bit (36) aligned,                  /* lock for RFC table                             */
  2    27              2 stbl_lock bit (36) aligned,                  /* lock for socket table                          */
  2    28              2 lock_pad bit (36) aligned,
  2    29 
  2    30              2 state_change_reason character (32) unaligned,          /* reason for last state change         */
  2    31 
  2    32              2 ncp_devx fixed binary (12),                  /* IOAM devx of NCP pseudo-device                 */
  2    33              2 ncp_state_changes fixed binary (17),         /* number of times NCP has changed state          */
  2    34              2 spacen1 (14) fixed fixed binary (35),
  2    35 
  2    36              2 host_id fixed binary (32),                   /* network identifier of this Multics System      */
  2    37              2 crash_on_ncp_error bit (1) aligned,          /* on if should crash to trap ncp error */
  2    38              2 imp_state char (8) aligned,
  2    39              2 time_imp_state_changed fixed binary (71),
  2    40              2 time_ncp_state_changed fixed binary (71),
  2    41 
  2    42              2 imp_special_message bit (32),
  2    43              2 imp_state_change_count fixed binary (17),
  2    44              2 spacen3 (3) fixed binary (17),
  2    45              2 ptbl_size fixed binary (17),                 /* number of entries in process table             */
  2    46              2 ptbl_gent fixed binary (17),                 /* index of highest slot in use                   */
  2    47              2 ptbl_lock bit (36) aligned,                  /* lock word for "proc_tb"                        */
  2    48 
  2    49              2 access_dirname character (168) unaligned,              /* dir of access defining segment       */
  2    50              2 access_ename character (32) unaligned;                 /* entry of access defining segment     */
  2    51 
  2    52      declare
  2    53           1 meter_dt aligned based,                         /* various meters kept by the NCP                 */
  2    54              2 prev_user_call_time fixed binary (71),
  2    55              2 prev_daemon_call_time fixed binary (71),
  2    56              2 accu_time_in_ncp fixed binary (71),
  2    57              2 accu_time_since_user_call fixed binary (71),
  2    58 
  2    59              2 nprocs_in_ncp fixed binary (17),
  2    60              2 nprocs_inconsistent bit (1),
  2    61              2 ndaemon_calls fixed binary (17),
  2    62              2 ncalls (5) fixed binary (17),
  2    63 
  2    64              2 net_error_count fixed binary (17),
  2    65              2 ncp_wakeup_count (7) fixed binary (17),
  2    66 
  2    67              2 call_count (0: 31) fixed binary (17),
  2    68 
  2    69              2 ctl_mess_count (0: 15) fixed binary (17),
  2    70 
  2    71              2 tbop_mf_count (48) fixed binary (17),
  2    72 
  2    73              2 eco_time fixed binary (71),
  2    74              2 erp_time fixed binary (71),
  2    75              2 eco_host fixed binary (16),
  2    76              2 erp_host fixed binary (16),
  2    77              2 num_activations fixed binary (30),           /* number of socket activations performed         */
  2    78              2 num_processes fixed binary (30);             /* number of processes using the NCP              */
  2    79 
  2    80 /*        END include file ncp_data_dcls.incl.pl1 --                            */
  2    81 
      113 
      114 
      115 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      116 
      117                                         /*      Entry point to lock a specified lock (waiting if necessary)   */
      118                                         /* of the Network Control Program.  Currently, all error conditions   */
      119                                         /* are handled by calling ncp_error which will crawlout               */
      120 
      121 lock_wait:
      122           entry (P_lock_ptr, P_error_code);
      123 
      124           lock_ptr = P_lock_ptr;
      125           P_error_code = 0;
      126 
      127           npr = addr (ncp_tables_$ncp_data);
      128 
      129           wait_times = 0;
      130           start_clock = 0;
      131 
      132           if ncp_tables_$tracing_info ^= ""b
      133           then call ncp_trace_ (TRACE_NCP_RING, "locking lock at ^p", lock_ptr);
      134 
      135           do while (^ stacq (lock_ptr -> based_lock, pds$process_id, (36)"0"b));
      136                if start_clock = 0
      137                then start_clock = clock ();
      138 
      139                if lock_ptr -> based_lock = pds$process_id
      140                then do;
      141                     P_error_code = error_table_$locked_by_this_process;
      142                     call ncp_error_ (P_error_code, "LOCK_attempt_to_relock_same_lock");
      143                     return;
      144                     end;
      145 
      146                ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count + 1;
      147                call pxss$addevent (ncp_params_$wait_event);
      148                if lock_ptr -> based_lock ^= ""b
      149                then do;
      150                     wait_times = wait_times + 1;
      151                     if (wait_times >= 100) | (clock () > start_clock + 300000000)
      152                     then do;                                          /* something must be wrong, give up               */
      153                          ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count - 1;
      154                          P_error_code = error_table_$net_timeout;
      155                          call ncp_error_ (P_error_code, "LOCK_waited_too_long_for_lock");
      156                          return;
      157                          end;
      158 
      159                     call pxss$wait ();
      160                     end;
      161                ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count - 1;
      162 
      163                if npr -> ncp_dt.ncp_up <= NCP_DOWN
      164                then do;
      165                     P_error_code = error_table_$net_not_up;
      166                     return;
      167                     end;
      168                end;
      169 
      170                                                             /* the lock is now locked                         */
      171           do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1)
      172                     while (^ stacq (ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id, pds$process_id, (36)"0"b));
      173                end;
      174           if tbl_indx > hbound (ncp_tables_$lock_tbl.lock_array, 1)
      175           then do;                                          /* we couldn't find an empty lock slot entry      */
      176                call unlock (lbound (ncp_tables_$lock_tbl.lock_array, 1) - 1, lock_ptr);
      177                P_error_code = error_table_$net_table_space;
      178                call ncp_error_ (P_error_code, "LOCK_not_free_memory_slots");
      179                return;
      180                end;
      181 
      182           ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr = lock_ptr;
      183           ncp_tables_$lock_tbl.lock_array (tbl_indx).num_times_slot_used
      184                     = ncp_tables_$lock_tbl.lock_array (tbl_indx).num_times_slot_used + 1;
      185           ncp_tables_$lock_tbl.lock_count = ncp_tables_$lock_tbl.lock_count + 1;
      186 
      187           return;
      188 
      189           /* * * * * * * * * * * * * * * * * * * * * * * * */
      190 
      191                                         /*      Entry point to unlock a specified lock (which must be         */
      192                                         /* locked).  Error conditions are handled by calling ncp_error        */
      193                                         /* which will crawlout.                                               */
      194 
      195 lock_unlock:
      196           entry (P_lock_ptr, P_error_code);
      197 
      198           P_error_code = 0;
      199 
      200           lock_ptr = P_lock_ptr;
      201 
      202           do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1)
      203                     while ((pds$process_id ^= ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id)
      204                     | (lock_ptr ^= ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr));
      205                end;
      206           if tbl_indx > hbound (ncp_tables_$lock_tbl.lock_array, 1)
      207           then do;                                          /* we failed to find the lock, -- error           */
      208                P_error_code = error_table_$lock_not_locked;
      209                call ncp_error_ (P_error_code, "LOCK_lock_already_unlocked");
      210                return;
      211                end;
      212 
      213           call unlock (tbl_indx, lock_ptr);
      214 
      215           if ncp_tables_$lock_tbl.wait_count ^= 0
      216           then call pxss$notify (ncp_params_$wait_event);
      217 
      218           return;
      219 
      220           /* * * * * * * * * * * * * * * * * * * * * * * * */
      221 
      222                                         /*      Entry point to unlock any (zero or more) NCP locks which      */
      223                                         /* have been locked by this mechanism.                                */
      224 
      225 unlock_all:
      226           entry (P_error_code);
      227 
      228           P_error_code = 0;
      229           lock_ptr = null ();                               /* check for any programming errors               */
      230 
      231           do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1);
      232                                                             /* loop through the entire table                  */
      233                if pds$process_id = ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id
      234                then do;
      235                     lock_ptr = ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr;      /* make pointer for nulling   */
      236 
      237                     call unlock (tbl_indx, lock_ptr);
      238                     end;
      239                end;
      240 
      241           if ncp_tables_$lock_tbl.wait_count ^= 0
      242           then call pxss$notify (ncp_params_$wait_event);
      243 
      244           return;
      245 
      246           /* * * * * * * * * * * * * * * * * * * * * * * * */
      247 
      248 verify_lock:
      249           entry (P_lock_ptr, P_error_code);
      250 
      251           P_error_code = 0;
      252 
      253 verify_lock_retry:
      254 	processid = P_lock_ptr -> based_lock;
      255 	if processid = ""b
      256 	     then do;
      257 	     P_error_code = error_table_$lock_not_locked;
      258 	     return;
      259 	end;
      260 	if processid = pds$process_id then do;
      261 	     P_error_code = error_table_$locked_by_this_process;
      262 	     return;
      263 	end;
      264 
      265 	call tc_util$validate_processid (processid, processid_code);
      266 	if processid_code = 0 then do;
      267 	     P_error_code = error_table_$locked_by_other_process;
      268 	     return;
      269 	end;
      270 
      271 	if stacq (P_lock_ptr -> based_lock, pds$process_id, processid) then do;
      272 	     P_error_code = error_table_$invalid_lock_reset;
      273 	     return;
      274 	end;
      275 	else goto verify_lock_retry;
      276 
      277 
      278 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      279 
      280 unlock:
      281           procedure (p_tbl_indx, p_lock_ptr);
      282 
      283           /* * * * * PARAMETER DECLARATIONS  * * * * * * * */
      284 
      285      declare
      286          (p_tbl_indx fixed binary (17),
      287           p_lock_ptr pointer)
      288                parameter;
      289 
      290           /* * * * * AUTOMATIC STORAGE DECLARATIONS  * * * */
      291 
      292      declare
      293           slot_id_ptr pointer
      294                automatic;
      295 
      296           /* * * * * * * * * * * * * * * * * * * * * * * * */
      297 
      298           if ncp_tables_$tracing_info ^= ""b
      299           then call ncp_trace_ (TRACE_NCP_RING, "unlocking lock at ^p", p_lock_ptr);
      300 
      301           if p_tbl_indx >= 0
      302           then do;
      303                ncp_tables_$lock_tbl.lock_array (p_tbl_indx).lock_ptr = null ();
      304 
      305                slot_id_ptr = addr (ncp_tables_$lock_tbl.lock_array (p_tbl_indx).process_id);
      306                if ^ stacq (slot_id_ptr -> based_lock, (36)"0"b, pds$process_id)
      307                then call syserr (ncp_params_$syserr_report_error,
      308                               "NCP:  lock array removal failed at ^p (on lock at ^p)", slot_id_ptr, p_lock_ptr);
      309                end;
      310 
      311           ncp_tables_$lock_tbl.lock_count = ncp_tables_$lock_tbl.lock_count - 1;
      312 
      313           if ^ stacq (p_lock_ptr -> based_lock, (36)"0"b, pds$process_id)
      314           then call syserr (ncp_params_$syserr_report_error,
      315                          "NCP:  unlock failed at ^p", p_lock_ptr);
      316 
      317           return;
      318 
      319 end;      /* end unlock                                    */
      320 
      321 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      322 
      323 /* BEGIN MESSAGE DOCUMENTATION
      324*
      325*   Message:
      326*   NCP:  lock array removal failed at LOC (on lock at LOC)
      327*
      328*   S: $log
      329*
      330*   T: $run
      331*
      332*   M: $err
      333*   The Network Control Program attempts to recover and keep running.
      334*
      335*   A: $note
      336*   If this problem persists, it might indicate that the stacq
      337*   instruction is failing.
      338*
      339*   Message:
      340*   NCP:  unlock failed at LOC
      341*
      342*   S: $log
      343*
      344*   T: $run
      345*
      346*   M: $err
      347*   The Network Control Program attempts to recover and continue running.
      348*
      349*   A: $note
      350*   If this problem persists, if might indicate that the stacq
      351*   instruction is failing.
      352*
      353*
      354*   END MESSAGE DOCUMENTATION */
      355 
      356 end;      /* end ncp_lock_                                 */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/02/84  1129.4  ncp_lock_.pl1                     >dumps>old_dumps>hardcore>ncp_lock_.pl1
112          1    10/07/77  1700.0  ncp_constants_dcls.incl.pl1       >ldd>include>ncp_constants_dcls.incl.pl1
113          2    07/24/78  1704.7  ncp_data_dcls.incl.pl1            >ldd>include>ncp_data_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NCP_DOWN                               constant        fixed bin(3,0)           initial dcl 1-8 ref 163
P_error_code                           parameter       fixed bin(35,0)          dcl 40 set ref 121 125* 141* 142* 154* 155* 165*
                                                                                  177* 178* 195 198* 208* 209* 225 228* 248 251*
                                                                                  257* 261* 267* 272*
P_lock_ptr                             parameter       pointer                  dcl 40 ref 121 124 195 200 248 253 271
TRACE_NCP_RING                  000000 constant        bit(36)                  initial dcl 1-51 set ref 132* 298*
addr                                                   builtin function         dcl 106 ref 127 305
based_lock                             based           bit(36)                  dcl 59 ref 135 139 148 253 271 306 313
clock                                                  builtin function         dcl 106 ref 136 151
error_table_$invalid_lock_reset 000024 external static fixed bin(35,0)          dcl 85 ref 272
error_table_$lock_not_locked    000026 external static fixed bin(35,0)          dcl 85 ref 208 257
error_table_$locked_by_other_process
                                000030 external static fixed bin(35,0)          dcl 85 ref 267
error_table_$locked_by_this_process
                                000032 external static fixed bin(35,0)          dcl 85 ref 141 261
error_table_$net_not_up         000034 external static fixed bin(35,0)          dcl 85 ref 165
error_table_$net_table_space    000036 external static fixed bin(35,0)          dcl 85 ref 177
error_table_$net_timeout        000040 external static fixed bin(35,0)          dcl 85 ref 154
hbound                                                 builtin function         dcl 106 ref 171 174 202 206 231
lbound                                                 builtin function         dcl 106 ref 171 176 202 231
lock_array                2     000022 external static structure                array level 2 dcl 76 set ref 171 171 174 176 202 202
                                                                                  206 231 231
lock_count                      000022 external static fixed bin(17,0)          level 2 dcl 76 set ref 185* 185 311* 311
lock_ptr                        000110 automatic       pointer                  dcl 47 in procedure "ncp_lock_" set ref 124* 132*
                                                                                  135 139 148 176* 182 200* 202 213* 229* 235* 237*
lock_ptr                  4     000022 external static pointer                  array level 3 in structure "ncp_tables_$lock_tbl"
                                                                                  dcl 76 in procedure "ncp_lock_" set ref 182* 202
                                                                                  235 303*
ncp_dt                                 based           structure                level 1 dcl 2-10
ncp_error_                      000042 constant        entry                    external dcl 97 ref 142 155 178 209
ncp_params_$syserr_report_error 000010 external static fixed bin(17,0)          dcl 65 set ref 306* 313*
ncp_params_$wait_event          000012 external static fixed bin(35,0)          dcl 65 set ref 147* 215* 241*
ncp_tables_$lock_tbl            000022 external static structure                level 1 unaligned dcl 76
ncp_tables_$ncp_data            000020 external static fixed bin(17,0)          dcl 72 set ref 127
ncp_tables_$tracing_info        000014 external static bit(36)                  dcl 65 ref 132 298
ncp_trace_                      000044 constant        entry                    external dcl 97 ref 132 298
ncp_up                    3            based           fixed bin(2,0)           level 2 dcl 2-10 ref 163
npr                             000106 automatic       pointer                  dcl 47 set ref 127* 163
null                                                   builtin function         dcl 106 ref 229 303
num_times_slot_used       3     000022 external static fixed bin(30,0)          array level 3 dcl 76 set ref 183* 183
p_lock_ptr                             parameter       pointer                  dcl 285 set ref 280 298* 306* 313 313*
p_tbl_indx                             parameter       fixed bin(17,0)          dcl 285 ref 280 301 303 305
pds$process_id                  000016 external static bit(36)                  dcl 65 ref 135 139 171 202 233 260 271 306 313
process_id                2     000022 external static bit(36)                  array level 3 dcl 76 set ref 171 202 233 305
processid                       000101 automatic       bit(36)                  dcl 47 set ref 253* 255 260 265* 271
processid_code                  000100 automatic       fixed bin(35,0)          dcl 47 set ref 265* 266
pxss$addevent                   000046 constant        entry                    external dcl 97 ref 147
pxss$notify                     000050 constant        entry                    external dcl 97 ref 215 241
pxss$wait                       000052 constant        entry                    external dcl 97 ref 159
slot_id_ptr                     000122 automatic       pointer                  dcl 292 set ref 305* 306 306*
stacq                                                  builtin function         dcl 106 ref 135 171 271 306 313
start_clock                     000104 automatic       fixed bin(71,0)          dcl 47 set ref 130* 136 136* 151
syserr                          000054 constant        entry                    external dcl 97 ref 306 313
tbl_indx                        000102 automatic       fixed bin(17,0)          dcl 47 set ref 171* 171* 174 182 183 183 202* 202
                                                                                  202* 206 213* 231* 233 235 237*
tc_util$validate_processid      000056 constant        entry                    external dcl 97 ref 265
wait_count                1     000022 external static fixed bin(17,0)          level 2 dcl 76 set ref 146* 146 153* 153 161* 161
                                                                                  215 241
wait_times                      000103 automatic       fixed bin(17,0)          dcl 47 set ref 129* 150* 150 151

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANY_TRACING                            internal static bit(36)                  initial dcl 1-51
HOST_DOWN                              internal static fixed bin(6,0)           initial dcl 1-20
HOST_OFF                               internal static fixed bin(6,0)           initial dcl 1-20
HOST_ON                                internal static fixed bin(6,0)           initial dcl 1-20
HOST_RST                               internal static fixed bin(6,0)           initial dcl 1-20
HOST_UP                                internal static fixed bin(6,0)           initial dcl 1-20
NCP_CRASHED                            internal static fixed bin(3,0)           initial dcl 1-8
NCP_UP                                 internal static fixed bin(3,0)           initial dcl 1-8
NCP_UP_IMP_DOWN                        internal static fixed bin(3,0)           initial dcl 1-8
PRINTER_TRACING                        internal static bit(36)                  initial dcl 1-51
READ_GENDER                            internal static bit(1)                   initial unaligned dcl 1-15
SOCK_ASSIGNED                          internal static fixed bin(6,0)           initial dcl 1-28
SOCK_BROKEN                            internal static fixed bin(6,0)           initial dcl 1-28
SOCK_CLS_READ                          internal static fixed bin(6,0)           initial dcl 1-28
SOCK_CLS_WAIT                          internal static fixed bin(6,0)           initial dcl 1-28
SOCK_CONNECTED                         internal static fixed bin(6,0)           initial dcl 1-28
SOCK_DATA_WAIT                         internal static fixed bin(6,0)           initial dcl 1-28
SOCK_INDX_MASK                         internal static bit(36)                  initial unaligned dcl 1-46
SOCK_LISTENING                         internal static fixed bin(6,0)           initial dcl 1-28
SOCK_RESET                             internal static fixed bin(6,0)           initial dcl 1-28
SOCK_RFC_ABORTED                       internal static fixed bin(6,0)           initial dcl 1-28
SOCK_RFC_RCVD                          internal static fixed bin(6,0)           initial dcl 1-28
SOCK_RFC_SENT                          internal static fixed bin(6,0)           initial dcl 1-28
SOCK_RFNM_WAIT                         internal static fixed bin(6,0)           initial dcl 1-28
SOCK_UNASSIGNED                        internal static fixed bin(6,0)           initial dcl 1-28
SOCK_UNIQUE_MASK                       internal static bit(36)                  initial unaligned dcl 1-46
SYSERR_LOG_TRACING                     internal static bit(36)                  initial dcl 1-51
TRACE_CTL_MSGS                         internal static bit(36)                  initial dcl 1-51
TRACE_DATA_FLOW                        internal static bit(36)                  initial dcl 1-51
TRACE_NCP_ACCESS                       internal static bit(36)                  initial dcl 1-51
TRACE_NCP_CONTROL                      internal static bit(36)                  initial dcl 1-51
TRACE_NCP_DAEMON                       internal static bit(36)                  initial dcl 1-51
TRACE_NCP_IO                           internal static bit(36)                  initial dcl 1-51
TRACE_NCP_TBOP                         internal static bit(36)                  initial dcl 1-51
TRACE_PROCESS_INFO                     internal static bit(36)                  initial dcl 1-51
WRITE_GENDER                           internal static bit(1)                   initial unaligned dcl 1-15
meter_dt                               based           structure                level 1 dcl 2-52

NAMES DECLARED BY EXPLICIT CONTEXT.
lock_unlock                     000423 constant        entry                    external dcl 195
lock_wait                       000132 constant        entry                    external dcl 121
ncp_lock_                       000120 constant        entry                    external dcl 11
unlock                          000664 constant        entry                    internal dcl 280 ref 176 213 237
unlock_all                      000531 constant        entry                    external dcl 225
verify_lock                     000603 constant        entry                    external dcl 248
verify_lock_retry               000614 constant        label                    dcl 253 ref 271

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1340        1420    1040        1350
Length      1676    1040        60         242     277           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ncp_lock_                           154 external procedure  is an external procedure.  
unlock                                  internal procedure  shares stack frame of external procedure ncp_lock_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ncp_lock_                000100 processid_code              ncp_lock_
                         000101 processid                   ncp_lock_
                         000102 tbl_indx                    ncp_lock_
                         000103 wait_times                  ncp_lock_
                         000104 start_clock                 ncp_lock_
                         000106 npr                         ncp_lock_
                         000110 lock_ptr                    ncp_lock_
                         000122 slot_id_ptr                 unlock

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ge_a              call_ext_out_desc   call_ext_out        return              ext_entry
stacq               clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ncp_error_                    ncp_trace_                    pxss$addevent                 pxss$notify
pxss$wait                     syserr                        tc_util$validate_processid

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_lock_reset                             error_table_$lock_not_locked
error_table_$locked_by_other_process                        error_table_$locked_by_this_process
error_table_$net_not_up       error_table_$net_table_space  error_table_$net_timeout
ncp_params_$syserr_report_error                             ncp_params_$wait_event        ncp_tables_$lock_tbl
ncp_tables_$ncp_data          ncp_tables_$tracing_info      pds$process_id


CONSTANTS
001024  aa     000004000000
001025  aa     000000000000
001026  aa     600000000041
001027  aa     000102000000
001030  aa     600000000041
001031  aa     000110000000

001032  aa     000004000000
001033  aa     000000000000
001034  aa     600000000041
001035  aa     000131000000
001036  aa     600000000041
001037  aa     000110000000

000000  aa     000400000000

000001  aa     524000000031

000002  aa     524000000065

000003  aa     524000000024

000004  aa     404000000021

000005  aa     524000000032

000006  aa     524000000035

000007  aa     002170321400

000010  aa     524000000040

000011  aa     524000000022

000012  aa     514000000044

000013  aa     464000000000

000014  aa     404000000043

000016  aa     077777000043
000017  aa     000001000000

000020  aa     000000000000
000021  aa     000000000000

000022  aa  165 156 154 157	unlo
000023  aa  143 153 151 156	ckin
000024  aa  147 040 154 157	g lo
000025  aa  143 153 040 141	ck a
000026  aa  164 040 136 160	t ^p

000027  aa  154 157 143 153	lock
000030  aa  151 156 147 040	ing 
000031  aa  154 157 143 153	lock
000032  aa  040 141 164 040	 at 
000033  aa  136 160 000 000	^p

000034  aa  116 103 120 072	NCP:
000035  aa  040 040 165 156	  un
000036  aa  154 157 143 153	lock
000037  aa  040 146 141 151	 fai
000040  aa  154 145 144 040	led 
000041  aa  141 164 040 136	at ^
000042  aa  160 000 000 000	p

000043  aa  114 117 103 113	LOCK
000044  aa  137 154 157 143	_loc
000045  aa  153 137 141 154	k_al
000046  aa  162 145 141 144	read
000047  aa  171 137 165 156	y_un
000050  aa  154 157 143 153	lock
000051  aa  145 144 000 000	ed

000052  aa  114 117 103 113	LOCK
000053  aa  137 156 157 164	_not
000054  aa  137 146 162 145	_fre
000055  aa  145 137 155 145	e_me
000056  aa  155 157 162 171	mory
000057  aa  137 163 154 157	_slo
000060  aa  164 163 000 000	ts

000061  aa  114 117 103 113	LOCK
000062  aa  137 167 141 151	_wai
000063  aa  164 145 144 137	ted_
000064  aa  164 157 157 137	too_
000065  aa  154 157 156 147	long
000066  aa  137 146 157 162	_for
000067  aa  137 154 157 143	_loc
000070  aa  153 000 000 000	k

000071  aa  114 117 103 113	LOCK
000072  aa  137 141 164 164	_att
000073  aa  145 155 160 164	empt
000074  aa  137 164 157 137	_to_
000075  aa  162 145 154 157	relo
000076  aa  143 153 137 163	ck_s
000077  aa  141 155 145 137	ame_
000100  aa  154 157 143 153	lock

000101  aa  116 103 120 072	NCP:
000102  aa  040 040 154 157	  lo
000103  aa  143 153 040 141	ck a
000104  aa  162 162 141 171	rray
000105  aa  040 162 145 155	 rem
000106  aa  157 166 141 154	oval
000107  aa  040 146 141 151	 fai
000110  aa  154 145 144 040	led 
000111  aa  141 164 040 136	at ^
000112  aa  160 040 050 157	p (o
000113  aa  156 040 154 157	n lo
000114  aa  143 153 040 141	ck a
000115  aa  164 040 136 160	t ^p
000116  aa  051 000 000 000	)

BEGIN PROCEDURE ncp_lock_
ENTRY TO ncp_lock_                                          STATEMENT 1 ON LINE 11
ncp_lock_:
          procedure ();

000117  da     000243200000
000120  aa   000240 6270 00	eax7 	160
000121  aa  7 00034 3521 20	epp2 	pr7|28,*
000122  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000123  aa     000000000000
000124  aa     000000000000
						STATEMENT 1 ON LINE 121
lock_wait:
          entry (P_lock_ptr, P_error_code);

000125  aa   000015 7100 04	tra  	13,ic		000142
ENTRY TO lock_wait                                          STATEMENT 1 ON LINE 121
lock_wait:
          entry (P_lock_ptr, P_error_code);

000126  at     000002000013
000127  ta     000014000000
000130  ta     000126000000
000131  da     000251300000
000132  aa   000240 6270 00	eax7 	160
000133  aa  7 00034 3521 20	epp2 	pr7|28,*
000134  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000135  aa     000004000000
000136  aa     000000000000
000137  aa  6 00032 3735 20	epp7 	pr6|26,*
000140  aa  7 00004 3715 20	epp5 	pr7|4,*
000141  aa  6 00112 6515 00	spri5	pr6|74
						STATEMENT 1 ON LINE 124
          lock_ptr = P_lock_ptr;

000142  aa  6 00032 3735 20	epp7 	pr6|26,*
000143  aa  7 00002 3715 20	epp5 	pr7|2,*		P_lock_ptr
000144  aa  5 00000 3715 20	epp5 	pr5|0,*		P_lock_ptr
000145  aa  6 00110 6515 00	spri5	pr6|72		lock_ptr
						STATEMENT 1 ON LINE 125
          P_error_code = 0;

000146  aa  6 00112 4501 20	stz  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 127
          npr = addr (ncp_tables_$ncp_data);

000147  la  4 00020 3535 20	epp3 	pr4|16,*		ncp_tables_$ncp_data
000150  aa  6 00106 2535 00	spri3	pr6|70		npr
						STATEMENT 1 ON LINE 129
          wait_times = 0;

000151  aa  6 00103 4501 00	stz  	pr6|67		wait_times
						STATEMENT 1 ON LINE 130
          start_clock = 0;

000152  aa   777646 2370 04	ldaq 	-90,ic		000020 = 000000000000 000000000000
000153  aa  6 00104 7571 00	staq 	pr6|68		start_clock
						STATEMENT 1 ON LINE 132
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_NCP_RING, "locking lock at ^p", lock_ptr);

000154  la  4 00014 2351 20	lda  	pr4|12,*		ncp_tables_$tracing_info
000155  aa   000024 6000 04	tze  	20,ic		000201
000156  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000157  aa   777651 00 0024	desc9a	-87,20		000027 = 154157143153
000160  aa  6 00124 00 0024	desc9a	pr6|84,20
000161  aa   777617 3520 04	epp2 	-113,ic		000000 = 000400000000
000162  aa  6 00134 2521 00	spri2	pr6|92
000163  aa  6 00124 3521 00	epp2 	pr6|84
000164  aa  6 00136 2521 00	spri2	pr6|94
000165  aa  6 00110 3521 00	epp2 	pr6|72		lock_ptr
000166  aa  6 00140 2521 00	spri2	pr6|96
000167  aa   777623 3520 04	epp2 	-109,ic		000012 = 514000000044
000170  aa  6 00142 2521 00	spri2	pr6|98
000171  aa   777620 3520 04	epp2 	-112,ic		000011 = 524000000022
000172  aa  6 00144 2521 00	spri2	pr6|100
000173  aa   777620 3520 04	epp2 	-112,ic		000013 = 464000000000
000174  aa  6 00146 2521 00	spri2	pr6|102
000175  aa  6 00132 6211 00	eax1 	pr6|90
000176  aa   014000 4310 07	fld  	6144,dl
000177  la  4 00044 3521 20	epp2 	pr4|36,*		ncp_trace_
000200  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 135
          do while (^ stacq (lock_ptr -> based_lock, pds$process_id, (36)"0"b));

000201  aa   000000 0110 03	nop  	0,du
000202  aa  6 00044 3701 20	epp4 	pr6|36,*
000203  la  4 00016 2351 20	lda  	pr4|14,*		pds$process_id
000204  aa  6 00110 3521 20	epp2 	pr6|72,*		based_lock
000205  aa   000000 2360 07	ldq  	0,dl
000206  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000207  aa   000130 6010 04	tnz  	88,ic		000337
						STATEMENT 1 ON LINE 136
               if start_clock = 0
               then start_clock = clock ();

000210  aa  6 00104 2371 00	ldaq 	pr6|68		start_clock
000211  aa   000003 6010 04	tnz  	3,ic		000214
000212  aa  0 01435 7001 00	tsx0 	pr0|797		clock
000213  aa  6 00104 7571 00	staq 	pr6|68		start_clock
						STATEMENT 1 ON LINE 139
               if lock_ptr -> based_lock = pds$process_id
               then do;

000214  aa  6 00110 2351 20	lda  	pr6|72,*		based_lock
000215  aa  6 00044 3701 20	epp4 	pr6|36,*
000216  la  4 00016 1151 20	cmpa 	pr4|14,*		pds$process_id
000217  aa   000023 6010 04	tnz  	19,ic		000242
						STATEMENT 1 ON LINE 141
                    P_error_code = error_table_$locked_by_this_process;

000220  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$locked_by_this_process
000221  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 142
                    call ncp_error_ (P_error_code, "LOCK_attempt_to_relock_same_lock");

000222  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000223  aa   777647 00 0040	desc9a	-89,32		000071 = 114117103113
000224  aa  6 00132 00 0040	desc9a	pr6|90,32
000225  aa  6 00112 3521 20	epp2 	pr6|74,*		P_error_code
000226  aa  6 00152 2521 00	spri2	pr6|106
000227  aa  6 00132 3521 00	epp2 	pr6|90
000230  aa  6 00154 2521 00	spri2	pr6|108
000231  aa   777563 3520 04	epp2 	-141,ic		000014 = 404000000043
000232  aa  6 00156 2521 00	spri2	pr6|110
000233  aa   777555 3520 04	epp2 	-147,ic		000010 = 524000000040
000234  aa  6 00160 2521 00	spri2	pr6|112
000235  aa  6 00150 6211 00	eax1 	pr6|104
000236  aa   010000 4310 07	fld  	4096,dl
000237  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_
000240  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 143
                    return;

000241  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 144
                    end;

						STATEMENT 1 ON LINE 146
               ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count + 1;

000242  la  4 00022 3735 20	epp7 	pr4|18,*
000243  aa  7 00001 0541 00	aos  	pr7|1		ncp_tables_$lock_tbl.wait_count
						STATEMENT 1 ON LINE 147
               call pxss$addevent (ncp_params_$wait_event);

000244  la  4 00012 3521 20	epp2 	pr4|10,*		ncp_params_$wait_event
000245  aa  6 00126 2521 00	spri2	pr6|86
000246  aa  6 00124 6211 00	eax1 	pr6|84
000247  aa   004000 4310 07	fld  	2048,dl
000250  la  4 00046 3521 20	epp2 	pr4|38,*		pxss$addevent
000251  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 148
               if lock_ptr -> based_lock ^= ""b
               then do;

000252  aa  6 00110 2351 20	lda  	pr6|72,*		based_lock
000253  aa   000051 6000 04	tze  	41,ic		000324
						STATEMENT 1 ON LINE 150
                    wait_times = wait_times + 1;

000254  aa  6 00103 0541 00	aos  	pr6|67		wait_times
						STATEMENT 1 ON LINE 151
                    if (wait_times >= 100) | (clock () > start_clock + 300000000)
                    then do;

000255  aa  6 00104 2371 00	ldaq 	pr6|68		start_clock
000256  aa   777531 0330 04	adl  	-167,ic		000007 = 002170321400
000257  aa  6 00162 7571 00	staq 	pr6|114
000260  aa  0 01435 7001 00	tsx0 	pr0|797		clock
000261  aa  6 00162 1171 00	cmpaq	pr6|114
000262  aa  0 00503 7001 00	tsx0 	pr0|323		r_g_a
000263  aa  6 00131 7551 00	sta  	pr6|89
000264  aa  6 00103 2361 00	ldq  	pr6|67		wait_times
000265  aa   000144 1160 07	cmpq 	100,dl
000266  aa  0 00527 7001 00	tsx0 	pr0|343		r_ge_a
000267  aa  6 00131 2751 00	ora  	pr6|89
000270  aa   000027 6000 04	tze  	23,ic		000317
						STATEMENT 1 ON LINE 153
                         ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count - 1;

000271  aa   000001 3360 07	lcq  	1,dl
000272  aa  6 00044 3701 20	epp4 	pr6|36,*
000273  la  4 00022 3735 20	epp7 	pr4|18,*
000274  aa  7 00001 0561 00	asq  	pr7|1		ncp_tables_$lock_tbl.wait_count
						STATEMENT 1 ON LINE 154
                         P_error_code = error_table_$net_timeout;

000275  la  4 00040 2361 20	ldq  	pr4|32,*		error_table_$net_timeout
000276  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 155
                         call ncp_error_ (P_error_code, "LOCK_waited_too_long_for_lock");

000277  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000300  aa   777562 00 0040	desc9a	-142,32		000061 = 114117103113
000301  aa  6 00150 00 0040	desc9a	pr6|104,32
000302  aa  6 00112 3521 20	epp2 	pr6|74,*		P_error_code
000303  aa  6 00134 2521 00	spri2	pr6|92
000304  aa  6 00150 3521 00	epp2 	pr6|104
000305  aa  6 00136 2521 00	spri2	pr6|94
000306  aa   777506 3520 04	epp2 	-186,ic		000014 = 404000000043
000307  aa  6 00140 2521 00	spri2	pr6|96
000310  aa   777476 3520 04	epp2 	-194,ic		000006 = 524000000035
000311  aa  6 00142 2521 00	spri2	pr6|98
000312  aa  6 00132 6211 00	eax1 	pr6|90
000313  aa   010000 4310 07	fld  	4096,dl
000314  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_
000315  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 156
                         return;

000316  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 157
                         end;

						STATEMENT 1 ON LINE 159
                    call pxss$wait ();

000317  aa  6 00056 6211 00	eax1 	pr6|46
000320  aa   000000 4310 07	fld  	0,dl
000321  aa  6 00044 3701 20	epp4 	pr6|36,*
000322  la  4 00052 3521 20	epp2 	pr4|42,*		pxss$wait
000323  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 160
                    end;

						STATEMENT 1 ON LINE 161
               ncp_tables_$lock_tbl.wait_count = ncp_tables_$lock_tbl.wait_count - 1;

000324  aa   000001 3360 07	lcq  	1,dl
000325  aa  6 00044 3701 20	epp4 	pr6|36,*
000326  la  4 00022 3735 20	epp7 	pr4|18,*
000327  aa  7 00001 0561 00	asq  	pr7|1		ncp_tables_$lock_tbl.wait_count
						STATEMENT 1 ON LINE 163
               if npr -> ncp_dt.ncp_up <= NCP_DOWN
               then do;

000330  aa  6 00106 3715 20	epp5 	pr6|70,*		npr
000331  aa  5 00003 2361 00	ldq  	pr5|3		ncp_dt.ncp_up
000332  aa   777650 6054 04	tpnz 	-88,ic		000202
						STATEMENT 1 ON LINE 165
                    P_error_code = error_table_$net_not_up;

000333  la  4 00034 2361 20	ldq  	pr4|28,*		error_table_$net_not_up
000334  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 166
                    return;

000335  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 167
                    end;

						STATEMENT 1 ON LINE 168
               end;

000336  aa   777644 7100 04	tra  	-92,ic		000202
						STATEMENT 1 ON LINE 171
          do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1)
                    while (^ stacq (ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id, pds$process_id, (36)"0"b));

000337  aa   000001 2360 07	ldq  	1,dl
000340  aa  6 00102 7561 00	stq  	pr6|66		tbl_indx
000341  aa   000000 0110 03	nop  	0,du
000342  aa  6 00102 2361 00	ldq  	pr6|66		tbl_indx
000343  aa   000012 1160 07	cmpq 	10,dl
000344  aa   000013 6054 04	tpnz 	11,ic		000357
000345  aa   000002 7360 00	qls  	2
000346  aa  6 00044 3701 20	epp4 	pr6|36,*
000347  la  4 00016 2351 20	lda  	pr4|14,*		pds$process_id
000350  la  4 00022 3735 20	epp7 	pr4|18,*
000351  aa  7 77776 3521 06	epp2 	pr7|-2,ql		ncp_tables_$lock_tbl.process_id
000352  aa   000000 2360 07	ldq  	0,dl
000353  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000354  aa   000003 6010 04	tnz  	3,ic		000357
						STATEMENT 1 ON LINE 173
               end;

000355  aa  6 00102 0541 00	aos  	pr6|66		tbl_indx
000356  aa   777764 7100 04	tra  	-12,ic		000342
						STATEMENT 1 ON LINE 174
          if tbl_indx > hbound (ncp_tables_$lock_tbl.lock_array, 1)
          then do;

000357  aa  6 00102 2361 00	ldq  	pr6|66		tbl_indx
000360  aa   000012 1160 07	cmpq 	10,dl
000361  aa   000030 6044 04	tmoz 	24,ic		000411
						STATEMENT 1 ON LINE 176
               call unlock (lbound (ncp_tables_$lock_tbl.lock_array, 1) - 1, lock_ptr);

000362  aa   000000 2360 07	ldq  	0,dl
000363  aa  6 00131 7561 00	stq  	pr6|89
000364  aa   000446 3520 04	epp2 	294,ic		001032 = 000004000000
000365  aa   000277 6700 04	tsp4 	191,ic		000664
						STATEMENT 1 ON LINE 177
               P_error_code = error_table_$net_table_space;

000366  aa  6 00044 3701 20	epp4 	pr6|36,*
000367  la  4 00036 2361 20	ldq  	pr4|30,*		error_table_$net_table_space
000370  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 178
               call ncp_error_ (P_error_code, "LOCK_not_free_memory_slots");

000371  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000372  aa   777461 00 0034	desc9a	-207,28		000052 = 114117103113
000373  aa  6 00150 00 0034	desc9a	pr6|104,28
000374  aa  6 00112 3521 20	epp2 	pr6|74,*		P_error_code
000375  aa  6 00134 2521 00	spri2	pr6|92
000376  aa  6 00150 3521 00	epp2 	pr6|104
000377  aa  6 00136 2521 00	spri2	pr6|94
000400  aa   777414 3520 04	epp2 	-244,ic		000014 = 404000000043
000401  aa  6 00140 2521 00	spri2	pr6|96
000402  aa   777403 3520 04	epp2 	-253,ic		000005 = 524000000032
000403  aa  6 00142 2521 00	spri2	pr6|98
000404  aa  6 00132 6211 00	eax1 	pr6|90
000405  aa   010000 4310 07	fld  	4096,dl
000406  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_
000407  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 179
               return;

000410  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 180
               end;

						STATEMENT 1 ON LINE 182
          ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr = lock_ptr;

000411  aa   000002 7360 00	qls  	2
000412  aa  6 00110 3735 20	epp7 	pr6|72,*		lock_ptr
000413  aa  6 00044 3701 20	epp4 	pr6|36,*
000414  la  4 00022 6535 66	spri7	pr4|18,*ql	ncp_tables_$lock_tbl.lock_ptr
						STATEMENT 1 ON LINE 183
          ncp_tables_$lock_tbl.lock_array (tbl_indx).num_times_slot_used
                    = ncp_tables_$lock_tbl.lock_array (tbl_indx).num_times_slot_used + 1;

000415  la  4 00022 3715 20	epp5 	pr4|18,*
000416  aa  5 77777 0541 06	aos  	pr5|-1,ql		ncp_tables_$lock_tbl.num_times_slot_used
						STATEMENT 1 ON LINE 185
          ncp_tables_$lock_tbl.lock_count = ncp_tables_$lock_tbl.lock_count + 1;

000417  la  4 00022 0541 20	aos  	pr4|18,*		ncp_tables_$lock_tbl.lock_count
						STATEMENT 1 ON LINE 187
          return;

000420  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO lock_unlock                                        STATEMENT 1 ON LINE 195
lock_unlock:
          entry (P_lock_ptr, P_error_code);

000421  ta     000126000000
000422  da     000257300000
000423  aa   000240 6270 00	eax7 	160
000424  aa  7 00034 3521 20	epp2 	pr7|28,*
000425  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000426  aa     000004000000
000427  aa     000000000000
000430  aa  6 00032 3735 20	epp7 	pr6|26,*
000431  aa  7 00004 3715 20	epp5 	pr7|4,*
000432  aa  6 00112 6515 00	spri5	pr6|74
						STATEMENT 1 ON LINE 198
          P_error_code = 0;

000433  aa  6 00112 4501 20	stz  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 200
          lock_ptr = P_lock_ptr;

000434  aa  6 00032 3735 20	epp7 	pr6|26,*
000435  aa  7 00002 3715 20	epp5 	pr7|2,*		P_lock_ptr
000436  aa  5 00000 3715 20	epp5 	pr5|0,*		P_lock_ptr
000437  aa  6 00110 6515 00	spri5	pr6|72		lock_ptr
						STATEMENT 1 ON LINE 202
          do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1)
                    while ((pds$process_id ^= ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id)
                    | (lock_ptr ^= ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr));

000440  aa   000001 2360 07	ldq  	1,dl
000441  aa  6 00102 7561 00	stq  	pr6|66		tbl_indx
000442  aa  6 00102 2361 00	ldq  	pr6|66		tbl_indx
000443  aa   000012 1160 07	cmpq 	10,dl
000444  aa   000017 6054 04	tpnz 	15,ic		000463
000445  aa   000002 7360 00	qls  	2
000446  aa  6 00044 3701 20	epp4 	pr6|36,*
000447  la  4 00016 2351 20	lda  	pr4|14,*		pds$process_id
000450  la  4 00022 3735 20	epp7 	pr4|18,*
000451  aa  7 77776 1151 06	cmpa 	pr7|-2,ql		ncp_tables_$lock_tbl.process_id
000452  aa  6 00131 7561 00	stq  	pr6|89
000453  aa   000006 6010 04	tnz  	6,ic		000461
000454  aa  6 00110 2371 00	ldaq 	pr6|72		lock_ptr
000455  aa  6 00131 7271 00	lxl7 	pr6|89
000456  la  4 00022 6771 77	eraq 	pr4|18,*7		ncp_tables_$lock_tbl.lock_ptr
000457  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000460  aa   000003 6000 04	tze  	3,ic		000463
						STATEMENT 1 ON LINE 205
               end;

000461  aa  6 00102 0541 00	aos  	pr6|66		tbl_indx
000462  aa   777760 7100 04	tra  	-16,ic		000442
						STATEMENT 1 ON LINE 206
          if tbl_indx > hbound (ncp_tables_$lock_tbl.lock_array, 1)
          then do;

000463  aa  6 00102 2361 00	ldq  	pr6|66		tbl_indx
000464  aa   000012 1160 07	cmpq 	10,dl
000465  aa   000024 6044 04	tmoz 	20,ic		000511
						STATEMENT 1 ON LINE 208
               P_error_code = error_table_$lock_not_locked;

000466  aa  6 00044 3701 20	epp4 	pr6|36,*
000467  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$lock_not_locked
000470  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 209
               call ncp_error_ (P_error_code, "LOCK_lock_already_unlocked");

000471  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000472  aa   777352 00 0034	desc9a	-278,28		000043 = 114117103113
000473  aa  6 00150 00 0034	desc9a	pr6|104,28
000474  aa  6 00112 3521 20	epp2 	pr6|74,*		P_error_code
000475  aa  6 00134 2521 00	spri2	pr6|92
000476  aa  6 00150 3521 00	epp2 	pr6|104
000477  aa  6 00136 2521 00	spri2	pr6|94
000500  aa   777314 3520 04	epp2 	-308,ic		000014 = 404000000043
000501  aa  6 00140 2521 00	spri2	pr6|96
000502  aa   777303 3520 04	epp2 	-317,ic		000005 = 524000000032
000503  aa  6 00142 2521 00	spri2	pr6|98
000504  aa  6 00132 6211 00	eax1 	pr6|90
000505  aa   010000 4310 07	fld  	4096,dl
000506  la  4 00042 3521 20	epp2 	pr4|34,*		ncp_error_
000507  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 210
               return;

000510  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 211
               end;

						STATEMENT 1 ON LINE 213
          call unlock (tbl_indx, lock_ptr);

000511  aa   000313 3520 04	epp2 	203,ic		001024 = 000004000000
000512  aa   000152 6700 04	tsp4 	106,ic		000664
						STATEMENT 1 ON LINE 215
          if ncp_tables_$lock_tbl.wait_count ^= 0
          then call pxss$notify (ncp_params_$wait_event);

000513  aa  6 00044 3701 20	epp4 	pr6|36,*
000514  la  4 00022 3735 20	epp7 	pr4|18,*
000515  aa  7 00001 2361 00	ldq  	pr7|1		ncp_tables_$lock_tbl.wait_count
000516  aa   000007 6000 04	tze  	7,ic		000525
000517  la  4 00012 3521 20	epp2 	pr4|10,*		ncp_params_$wait_event
000520  aa  6 00126 2521 00	spri2	pr6|86
000521  aa  6 00124 6211 00	eax1 	pr6|84
000522  aa   004000 4310 07	fld  	2048,dl
000523  la  4 00050 3521 20	epp2 	pr4|40,*		pxss$notify
000524  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 218
          return;

000525  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO unlock_all                                         STATEMENT 1 ON LINE 225
unlock_all:
          entry (P_error_code);

000526  at     000001000014
000527  ta     000526000000
000530  da     000265300000
000531  aa   000240 6270 00	eax7 	160
000532  aa  7 00034 3521 20	epp2 	pr7|28,*
000533  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000534  aa     000002000000
000535  aa     000000000000
000536  aa  6 00032 3735 20	epp7 	pr6|26,*
000537  aa  7 00002 3715 20	epp5 	pr7|2,*
000540  aa  6 00112 6515 00	spri5	pr6|74
						STATEMENT 1 ON LINE 228
          P_error_code = 0;

000541  aa  6 00112 4501 20	stz  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 229
          lock_ptr = null ();

000542  aa   777254 2370 04	ldaq 	-340,ic		000016 = 077777000043 000001000000
000543  aa  6 00110 7571 00	staq 	pr6|72		lock_ptr
						STATEMENT 1 ON LINE 231
          do tbl_indx = lbound (ncp_tables_$lock_tbl.lock_array, 1) by 1 to hbound (ncp_tables_$lock_tbl.lock_array, 1);

000544  aa   000001 2360 07	ldq  	1,dl
000545  aa  6 00102 7561 00	stq  	pr6|66		tbl_indx
000546  aa  6 00102 2361 00	ldq  	pr6|66		tbl_indx
000547  aa   000012 1160 07	cmpq 	10,dl
000550  aa   000016 6054 04	tpnz 	14,ic		000566
						STATEMENT 1 ON LINE 233
               if pds$process_id = ncp_tables_$lock_tbl.lock_array (tbl_indx).process_id
               then do;

000551  aa   000002 7360 00	qls  	2
000552  aa  6 00044 3701 20	epp4 	pr6|36,*
000553  la  4 00016 2351 20	lda  	pr4|14,*		pds$process_id
000554  la  4 00022 3735 20	epp7 	pr4|18,*
000555  aa  7 77776 1151 06	cmpa 	pr7|-2,ql		ncp_tables_$lock_tbl.process_id
000556  aa   000006 6010 04	tnz  	6,ic		000564
						STATEMENT 1 ON LINE 235
                    lock_ptr = ncp_tables_$lock_tbl.lock_array (tbl_indx).lock_ptr;

000557  la  4 00022 3715 66	epp5 	pr4|18,*ql	ncp_tables_$lock_tbl.lock_ptr
000560  aa  5 00000 3715 20	epp5 	pr5|0,*		ncp_tables_$lock_tbl.lock_ptr
000561  aa  6 00110 6515 00	spri5	pr6|72		lock_ptr
						STATEMENT 1 ON LINE 237
                    call unlock (tbl_indx, lock_ptr);

000562  aa   000242 3520 04	epp2 	162,ic		001024 = 000004000000
000563  aa   000101 6700 04	tsp4 	65,ic		000664
						STATEMENT 1 ON LINE 238
                    end;

						STATEMENT 1 ON LINE 239
               end;

000564  aa  6 00102 0541 00	aos  	pr6|66		tbl_indx
000565  aa   777761 7100 04	tra  	-15,ic		000546
						STATEMENT 1 ON LINE 241
          if ncp_tables_$lock_tbl.wait_count ^= 0
          then call pxss$notify (ncp_params_$wait_event);

000566  aa  6 00044 3701 20	epp4 	pr6|36,*
000567  la  4 00022 3735 20	epp7 	pr4|18,*
000570  aa  7 00001 2361 00	ldq  	pr7|1		ncp_tables_$lock_tbl.wait_count
000571  aa   000007 6000 04	tze  	7,ic		000600
000572  la  4 00012 3521 20	epp2 	pr4|10,*		ncp_params_$wait_event
000573  aa  6 00126 2521 00	spri2	pr6|86
000574  aa  6 00124 6211 00	eax1 	pr6|84
000575  aa   004000 4310 07	fld  	2048,dl
000576  la  4 00050 3521 20	epp2 	pr4|40,*		pxss$notify
000577  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 244
          return;

000600  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO verify_lock                                        STATEMENT 1 ON LINE 248
verify_lock:
          entry (P_lock_ptr, P_error_code);

000601  ta     000126000000
000602  da     000273300000
000603  aa   000240 6270 00	eax7 	160
000604  aa  7 00034 3521 20	epp2 	pr7|28,*
000605  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000606  aa     000004000000
000607  aa     000000000000
000610  aa  6 00032 3735 20	epp7 	pr6|26,*
000611  aa  7 00004 3715 20	epp5 	pr7|4,*
000612  aa  6 00112 6515 00	spri5	pr6|74
						STATEMENT 1 ON LINE 251
          P_error_code = 0;

000613  aa  6 00112 4501 20	stz  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 253
verify_lock_retry:
	processid = P_lock_ptr -> based_lock;

000614  aa  6 00032 3735 20	epp7 	pr6|26,*
000615  aa  7 00002 3715 20	epp5 	pr7|2,*		P_lock_ptr
000616  aa  5 00000 2351 20	lda  	pr5|0,*		based_lock
000617  aa  6 00101 7551 00	sta  	pr6|65		processid
						STATEMENT 1 ON LINE 255
	if processid = ""b
	     then do;

000620  aa   000005 6010 04	tnz  	5,ic		000625
						STATEMENT 1 ON LINE 257
	     P_error_code = error_table_$lock_not_locked;

000621  aa  6 00044 3701 20	epp4 	pr6|36,*
000622  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$lock_not_locked
000623  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 258
	     return;

000624  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 259
	end;

						STATEMENT 1 ON LINE 260
	if processid = pds$process_id then do;

000625  aa  6 00044 3701 20	epp4 	pr6|36,*
000626  la  4 00016 1151 20	cmpa 	pr4|14,*		pds$process_id
000627  aa   000004 6010 04	tnz  	4,ic		000633
						STATEMENT 1 ON LINE 261
	     P_error_code = error_table_$locked_by_this_process;

000630  la  4 00032 2361 20	ldq  	pr4|26,*		error_table_$locked_by_this_process
000631  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 262
	     return;

000632  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 263
	end;

						STATEMENT 1 ON LINE 265
	call tc_util$validate_processid (processid, processid_code);

000633  aa  6 00101 3521 00	epp2 	pr6|65		processid
000634  aa  6 00152 2521 00	spri2	pr6|106
000635  aa  6 00100 3521 00	epp2 	pr6|64		processid_code
000636  aa  6 00154 2521 00	spri2	pr6|108
000637  aa  6 00150 6211 00	eax1 	pr6|104
000640  aa   010000 4310 07	fld  	4096,dl
000641  la  4 00056 3521 20	epp2 	pr4|46,*		tc_util$validate_processid
000642  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 266
	if processid_code = 0 then do;

000643  aa  6 00100 2361 00	ldq  	pr6|64		processid_code
000644  aa   000005 6010 04	tnz  	5,ic		000651
						STATEMENT 1 ON LINE 267
	     P_error_code = error_table_$locked_by_other_process;

000645  aa  6 00044 3701 20	epp4 	pr6|36,*
000646  la  4 00030 2361 20	ldq  	pr4|24,*		error_table_$locked_by_other_process
000647  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 268
	     return;

000650  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 269
	end;

						STATEMENT 1 ON LINE 271
	if stacq (P_lock_ptr -> based_lock, pds$process_id, processid) then do;

000651  aa  6 00044 3701 20	epp4 	pr6|36,*
000652  la  4 00016 2351 20	lda  	pr4|14,*		pds$process_id
000653  aa  6 00032 3735 20	epp7 	pr6|26,*
000654  aa  7 00002 3715 20	epp5 	pr7|2,*		P_lock_ptr
000655  aa  5 00000 3521 20	epp2 	pr5|0,*		based_lock
000656  aa  6 00101 2361 00	ldq  	pr6|65		processid
000657  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000660  aa   777734 6000 04	tze  	-36,ic		000614
						STATEMENT 1 ON LINE 272
	     P_error_code = error_table_$invalid_lock_reset;

000661  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$invalid_lock_reset
000662  aa  6 00112 7561 20	stq  	pr6|74,*		P_error_code
						STATEMENT 1 ON LINE 273
	     return;

000663  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 274
	end;

						STATEMENT 1 ON LINE 356
end;

BEGIN PROCEDURE unlock
ENTRY TO unlock                                             STATEMENT 1 ON LINE 280
unlock:
          procedure (p_tbl_indx, p_lock_ptr);

000664  aa  6 00114 6501 00	spri4	pr6|76
000665  aa  6 00116 2521 00	spri2	pr6|78
						STATEMENT 1 ON LINE 298
          if ncp_tables_$tracing_info ^= ""b
          then call ncp_trace_ (TRACE_NCP_RING, "unlocking lock at ^p", p_lock_ptr);

000666  aa  6 00044 3701 20	epp4 	pr6|36,*
000667  la  4 00014 2351 20	lda  	pr4|12,*		ncp_tables_$tracing_info
000670  aa   000030 6000 04	tze  	24,ic		000720
000671  aa   777131 2370 04	ldaq 	-423,ic		000022 = 165156154157 143153151156
000672  aa  6 00164 7571 00	staq 	pr6|116
000673  aa   777131 2370 04	ldaq 	-423,ic		000024 = 147040154157 143153040141
000674  aa  6 00166 7571 00	staq 	pr6|118
000675  aa   777131 2350 04	lda  	-423,ic		000026 = 164040136160
000676  aa  6 00170 7551 00	sta  	pr6|120
000677  aa   777101 3520 04	epp2 	-447,ic		000000 = 000400000000
000700  aa  6 00174 2521 00	spri2	pr6|124
000701  aa  6 00164 3521 00	epp2 	pr6|116
000702  aa  6 00176 2521 00	spri2	pr6|126
000703  aa  6 00116 3735 20	epp7 	pr6|78,*
000704  aa  7 00004 3521 20	epp2 	pr7|4,*		p_lock_ptr
000705  aa  6 00200 2521 00	spri2	pr6|128
000706  aa   777104 3520 04	epp2 	-444,ic		000012 = 514000000044
000707  aa  6 00202 2521 00	spri2	pr6|130
000710  aa   777073 3520 04	epp2 	-453,ic		000003 = 524000000024
000711  aa  6 00204 2521 00	spri2	pr6|132
000712  aa   777101 3520 04	epp2 	-447,ic		000013 = 464000000000
000713  aa  6 00206 2521 00	spri2	pr6|134
000714  aa  6 00172 6211 00	eax1 	pr6|122
000715  aa   014000 4310 07	fld  	6144,dl
000716  la  4 00044 3521 20	epp2 	pr4|36,*		ncp_trace_
000717  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 301
          if p_tbl_indx >= 0
          then do;

000720  aa  6 00116 3735 20	epp7 	pr6|78,*
000721  aa  7 00002 2361 20	ldq  	pr7|2,*		p_tbl_indx
000722  aa   000044 6040 04	tmi  	36,ic		000766
						STATEMENT 1 ON LINE 303
               ncp_tables_$lock_tbl.lock_array (p_tbl_indx).lock_ptr = null ();

000723  aa   000002 7360 00	qls  	2
000724  aa   000000 6270 06	eax7 	0,ql
000725  aa   777071 2370 04	ldaq 	-455,ic		000016 = 077777000043 000001000000
000726  aa  6 00044 3701 20	epp4 	pr6|36,*
000727  la  4 00022 7571 77	staq 	pr4|18,*7		ncp_tables_$lock_tbl.lock_ptr
						STATEMENT 1 ON LINE 305
               slot_id_ptr = addr (ncp_tables_$lock_tbl.lock_array (p_tbl_indx).process_id);

000730  la  4 00022 3715 20	epp5 	pr4|18,*
000731  aa  5 77776 3715 17	epp5 	pr5|-2,7		ncp_tables_$lock_tbl.process_id
000732  aa  6 00122 6515 00	spri5	pr6|82		slot_id_ptr
						STATEMENT 1 ON LINE 306
               if ^ stacq (slot_id_ptr -> based_lock, (36)"0"b, pds$process_id)
               then call syserr (ncp_params_$syserr_report_error,
                              "NCP:  lock array removal failed at ^p (on lock at ^p)", slot_id_ptr, p_lock_ptr);

000733  aa   000000 2350 07	lda  	0,dl
000734  aa  5 00000 3521 00	epp2 	pr5|0		based_lock
000735  la  4 00016 2361 20	ldq  	pr4|14,*		pds$process_id
000736  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000737  aa   000027 6010 04	tnz  	23,ic		000766
000740  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000741  aa   777141 00 0070	desc9a	-415,56		000101 = 116103120072
000742  aa  6 00172 00 0070	desc9a	pr6|122,56
000743  la  4 00010 3521 20	epp2 	pr4|8,*		ncp_params_$syserr_report_error
000744  aa  6 00212 2521 00	spri2	pr6|138
000745  aa  6 00172 3521 00	epp2 	pr6|122
000746  aa  6 00214 2521 00	spri2	pr6|140
000747  aa  6 00122 3521 00	epp2 	pr6|82		slot_id_ptr
000750  aa  6 00216 2521 00	spri2	pr6|142
000751  aa  7 00004 3521 20	epp2 	pr7|4,*		p_lock_ptr
000752  aa  6 00220 2521 00	spri2	pr6|144
000753  aa   777031 3520 04	epp2 	-487,ic		000004 = 404000000021
000754  aa  6 00222 2521 00	spri2	pr6|146
000755  aa   777025 3520 04	epp2 	-491,ic		000002 = 524000000065
000756  aa  6 00224 2521 00	spri2	pr6|148
000757  aa   777034 3520 04	epp2 	-484,ic		000013 = 464000000000
000760  aa  6 00226 2521 00	spri2	pr6|150
000761  aa  6 00230 2521 00	spri2	pr6|152
000762  aa  6 00210 6211 00	eax1 	pr6|136
000763  aa   020000 4310 07	fld  	8192,dl
000764  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
000765  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 309
               end;

						STATEMENT 1 ON LINE 311
          ncp_tables_$lock_tbl.lock_count = ncp_tables_$lock_tbl.lock_count - 1;

000766  aa   000001 3360 07	lcq  	1,dl
000767  aa  6 00044 3701 20	epp4 	pr6|36,*
000770  la  4 00022 0561 20	asq  	pr4|18,*		ncp_tables_$lock_tbl.lock_count
						STATEMENT 1 ON LINE 313
          if ^ stacq (p_lock_ptr -> based_lock, (36)"0"b, pds$process_id)
          then call syserr (ncp_params_$syserr_report_error,
                         "NCP:  unlock failed at ^p", p_lock_ptr);

000771  aa   000000 2350 07	lda  	0,dl
000772  aa  6 00116 3735 20	epp7 	pr6|78,*
000773  aa  7 00004 3715 20	epp5 	pr7|4,*		p_lock_ptr
000774  aa  5 00000 3521 20	epp2 	pr5|0,*		based_lock
000775  la  4 00016 2361 20	ldq  	pr4|14,*		pds$process_id
000776  aa  0 01434 7001 00	tsx0 	pr0|796		stacq
000777  aa   000024 6010 04	tnz  	20,ic		001023
001000  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
001001  aa   777034 00 0034	desc9a	-484,28		000034 = 116103120072
001002  aa  6 00172 00 0034	desc9a	pr6|122,28
001003  la  4 00010 3521 20	epp2 	pr4|8,*		ncp_params_$syserr_report_error
001004  aa  6 00212 2521 00	spri2	pr6|138
001005  aa  6 00172 3521 00	epp2 	pr6|122
001006  aa  6 00214 2521 00	spri2	pr6|140
001007  aa  7 00004 3521 20	epp2 	pr7|4,*		p_lock_ptr
001010  aa  6 00216 2521 00	spri2	pr6|142
001011  aa   776773 3520 04	epp2 	-517,ic		000004 = 404000000021
001012  aa  6 00220 2521 00	spri2	pr6|144
001013  aa   776766 3520 04	epp2 	-522,ic		000001 = 524000000031
001014  aa  6 00222 2521 00	spri2	pr6|146
001015  aa   776776 3520 04	epp2 	-514,ic		000013 = 464000000000
001016  aa  6 00224 2521 00	spri2	pr6|148
001017  aa  6 00210 6211 00	eax1 	pr6|136
001020  aa   014000 4310 07	fld  	6144,dl
001021  la  4 00054 3521 20	epp2 	pr4|44,*		syserr
001022  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 317
          return;

001023  aa  6 00114 6101 00	rtcd 	pr6|76
						STATEMENT 1 ON LINE 319
end;

  END PROCEDURE unlock
  END PROCEDURE ncp_lock_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
