	COMPILATION LISTING OF SEGMENT find_command_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1013.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
       18*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
       19*     Modified to call object_lib_$initiate to initiate segments and object MSFs
       20*     when executing commands specified by pathname.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* This subroutine interprets a character string as the name of an entrypoint and returns a pointer to that entry.  It is
       25*   intended to be called by command processors to find commands and active functions.
       26*
       27*   An associative memory of recently used commands is maintained in order to avoid using the linker when possible */
       28 
       29 /* Initial coding:  December 1969 by R. C. Daley */
       30 /* Rewritten:  August 1978 by G. Palter to eliminate past changes made for fast command loop */
       31 /* Modified:  8 May 1980 by G. Palter to fix metering to avoid calling hcs_$make_ptr if metering is not enabled when first
       32*   invoked */
       33 
       34 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       35 find_command_:
       36      procedure (a_input_name_ptr, a_input_name_lth, a_entrypoint_ptr, a_code);
       37 
       38 
       39 /* Parameters */
       40 
       41 dcl  a_input_name_ptr pointer;			/* -> input string to interpret */
       42 dcl  a_input_name_lth fixed binary (21);		/* length of same */
       43 dcl  a_entrypoint_ptr pointer;			/* -> entrypoint found (Output) */
       44 dcl  a_code fixed binary (35);
       45 
       46 dcl  a_input_name character (a_input_name_lth) based (a_input_name_ptr);
       47 
       48 
       49 /* Remaining declarations */
       50 
       51 dcl  input_name character (input_name_lth) based (input_name_ptr);
       52 dcl  input_name_ptr pointer;
       53 dcl  input_name_lth fixed binary (21);
       54 
       55 dcl  (
       56      pathname_sw,					/* ON if pathname used */
       57      entrypoint_sw,					/* ON if entrypoint given */
       58      print_sw
       59      ) bit (1) aligned;				/* ON if should prin errors */
       60 
       61 dcl  full_name character (256) varying;			/* complete name given */
       62 dcl  1 full_name_value aligned based (addr (full_name)),
       63        2 lth fixed binary (21),
       64        2 str character (0 refer (full_name_value.lth)) unaligned;
       65 
       66 dcl  directory_name character (168);			/* directory supplied (if any) */
       67 dcl  segment_name character (32);			/* segment name given */
       68 dcl  entrypoint_name character (32);			/* entrypoint suplied or "segment_name" */
       69 
       70 dcl  code fixed binary (35);
       71 dcl  segment_ptr pointer;
       72 dcl  (am_idx, idx) fixed binary;
       73 
       74 
       75 /* The associative memory */
       76 
       77 dcl  1 memory aligned internal static,
       78        2 e (0:15),					/* 16 entries */
       79          3 name character (32) initial ((16) ("")),
       80          3 entrypoint_ptr pointer initial ((16) null ()),	/* -> entry for this name */
       81          3 usage fixed binary initial ((16) 0);		/* least-recently used counter */
       82 
       83 dcl  HIT fixed binary static options (constant) initial (16);
       84 						/* usage counter of just used entry */
       85 
       86 
       87 dcl  SPACES character (2) static options (constant) initial (" 	");
       88 						/* SP HT */
       89 dcl  BREAKS character (3) static options (constant) initial ("<>$");
       90 
       91 dcl  NAME character (18) static options (constant) initial ("command_processor_");
       92 dcl  BlankCommand character (19) static options (constant) initial ("Blank command name.");
       93 dcl  SegNotFound character (21) static options (constant) initial ("Segment ^a not found.");
       94 dcl  NoEntryPoint character (39) static options (constant) initial ("Entry point ^a not found in segment ^a.");
       95 
       96 dcl  (
       97      error_table_$bad_command_name,
       98      error_table_$badpath,
       99      error_table_$dirseg,
      100      error_table_$entlong,
      101      error_table_$namedup,
      102      error_table_$no_ext_sym,
      103      error_table_$noentry,
      104      error_table_$seg_not_found
      105      ) fixed binary (35) external;
      106 
      107 dcl  (
      108      com_err_,
      109      com_err_$suppress_name
      110      ) entry () options (variable);
      111 dcl  continue_to_signal_ entry (fixed binary (35));
      112 dcl  find_condition_info_ entry (pointer, pointer, fixed binary (35));
      113 dcl  expand_pathname_ entry (character (*), character (*), character (*), fixed binary (35));
      114 dcl  get_group_id_$tag_star entry () returns (character (32) aligned);
      115 dcl  hcs_$initiate
      116 	entry (character (*), character (*), character (*), fixed binary (1), fixed binary (2), pointer,
      117 	fixed binary (35));
      118 dcl  hcs_$make_ptr entry (pointer, character (*), character (*), pointer, fixed binary (35));
      119 dcl  hcs_$terminate_noname entry (pointer, fixed binary (35));
      120 dcl  object_lib_$init_no_clear entry (char(*), char(*), char(*), bit(1), ptr, fixed bin(24), bit(1), fixed bin(35));
      121 
      122 dcl  any_other condition;
      123 
      124 dcl  (addr, hbound, lbound, length, null, reverse, rtrim, search, substr) builtin;
      125 
      126 /* find_command_: procedure (a_input_name_ptr, a_input_name_lth, a_entrypoint_ptr, a_code); */
      127 
      128 	print_sw = "1"b;
      129 
      130 	go to COMMON;
      131 
      132 
      133 /* This entry is identical to find_command_, but does not print error messages */
      134 
      135 fc_no_message:
      136      entry (a_input_name_ptr, a_input_name_lth, a_entrypoint_ptr, a_code);
      137 
      138 	print_sw = "0"b;
      139 
      140 
      141 COMMON:
      142 	a_code = 0;				/* initialize it sometime */
      143 
      144 	input_name_ptr = a_input_name_ptr;		/* get input arguments */
      145 
      146 	input_name_lth = length (rtrim (a_input_name, SPACES));
      147 						/* strip trailing whitespace right away */
      148 	if input_name_lth = 0 then do;		/* blank command name */
      149 	     if print_sw then call com_err_ (0, NAME, BlankCommand);
      150 	     a_code = error_table_$seg_not_found;	/* for lack of something better */
      151 	     return;
      152 	     end;
      153 
      154 
      155 /* Parse input name into segment name, entrypoint (optional), and pathname (optional) */
      156 
      157 	if search (input_name, BREAKS) = 0 then do;	/* simple case, a segment name only */
      158 	     if input_name_lth > length (segment_name) then call abort (error_table_$entlong, input_name);
      159 	     pathname_sw, entrypoint_sw = "0"b;
      160 	     segment_name = input_name;		/* make compiler generate better code */
      161 	     entrypoint_name = input_name;
      162 	     full_name = input_name;			/* for error messages later on */
      163 	     end;
      164 
      165 	else call parse_complex_name ();		/* out of main path for efficiency */
      166 
      167 	call meter_usage (segment_name);		/* meter its usage whether or not it works */
      168 
      169 
      170 	if ^pathname_sw
      171 	then					/* No pathname was supplied:  This is the simple case and is handled completely by the internal
      172*						   procedure search_entry */
      173 	     call search_entry ();
      174 
      175 
      176 	else do;
      177 
      178 /* A pathname was supplied:  It may be necessary to terminate some other segment if the reference
      179*   name "segment_name" is already in use.  In addition, it may be necessary to clear the associative
      180*   memory to reflect this termination. */
      181 
      182 	     call object_lib_$init_no_clear (directory_name, segment_name, segment_name, ""b, segment_ptr, 0, (""b), code);
      183 	     if code ^= 0
      184 	     then if code ^= error_table_$namedup then call abort (code, full_name_value.str);
      185 
      186 		else if search_am (segment_name, am_idx) then call set_am (am_idx, "", null (), 0);
      187 						/* clear this entry */
      188 	     call search_entry ();			/* now try to find the entrypoint */
      189 	     end;
      190 
      191 
      192 /* Here only if the entrypoint was found */
      193 
      194 	a_code = 0;				/* a_entrypoint_ptr already set */
      195 
      196 RETURN:
      197 	return;
      198 
      199 /* Clear the associative memory:  It should be called after changes are made to the address space */
      200 
      201 clear:
      202      entry ();
      203 
      204 	do idx = lbound (memory.e, 1) to hbound (memory.e, 1);
      205 	     call set_am (idx, "", null (), 0);
      206 	end;
      207 
      208 	return;
      209 
      210 /* This internal procedure parses a command name containing pathnames and entrypoints */
      211 
      212 parse_complex_name:
      213      procedure ();
      214 
      215 dcl  (entry_idx, segment_lth, entrypoint_idx, entrypoint_lth) fixed binary (21);
      216 dcl  pathname character (entry_idx + segment_lth - 1) unaligned based (input_name_ptr);
      217 
      218 
      219 	entry_idx = search (reverse (input_name), "<>");	/* find end of pathname */
      220 
      221 	if entry_idx = 0 then do;			/* no pathname */
      222 	     entry_idx = 1;
      223 	     pathname_sw = "0"b;
      224 	     entrypoint_sw = "1"b;			/* tentatively must have an entrypoint */
      225 	     end;
      226 
      227 	else do;					/* pathname given */
      228 	     if entry_idx = 1
      229 	     then if input_name = ">"
      230 		then				/* trap the root right here */
      231 		     call abort (error_table_$dirseg, input_name);
      232 		else call abort (error_table_$badpath, input_name);
      233 	     pathname_sw = "1"b;
      234 	     entry_idx = input_name_lth + 2 - entry_idx;	/* index of first char after > */
      235 	     entrypoint_sw = (search (substr (input_name, entry_idx), "$") ^= 0);
      236 	     end;
      237 
      238 
      239 /* Check validity of syntax of entrypoint and pathname now that it is known
      240*   what was supplied */
      241 
      242 	if entrypoint_sw then do;
      243 	     segment_lth = search (substr (input_name, entry_idx), "$") - 1;
      244 	     entrypoint_idx = entry_idx + segment_lth + 1;
      245 	     entrypoint_lth = input_name_lth - entrypoint_idx + 1;
      246 	     if (segment_lth = 0) | (entrypoint_lth = 0) then call abort (error_table_$bad_command_name, input_name);
      247 	     if entrypoint_lth > length (entrypoint_name)
      248 	     then call abort (error_table_$entlong, substr (input_name, (entrypoint_idx - 1)));
      249 	     end;
      250 
      251 	else segment_lth = input_name_lth - entry_idx + 1;
      252 
      253 
      254 	if pathname_sw then do;
      255 	     call expand_pathname_ (pathname, directory_name, segment_name, code);
      256 						/* expand, but exclude entrypoint */
      257 	     if code ^= 0 then call abort (code, input_name);
      258 	     end;
      259 
      260 	else do;
      261 	     if segment_lth > length (segment_name)
      262 	     then call abort (error_table_$entlong, substr (input_name, 1, segment_lth));
      263 	     segment_name = substr (input_name, entry_idx, segment_lth);
      264 	     end;
      265 
      266 
      267 /* Fill in the entrypoint name, defaulting to the segment name if necessary */
      268 
      269 	if entrypoint_sw then do;
      270 	     entrypoint_name = substr (input_name, entrypoint_idx);
      271 	     if search (entrypoint_name, "$") ^= 0 then call abort (error_table_$bad_command_name, input_name);
      272 	     end;
      273 	else entrypoint_name = segment_name;
      274 
      275 	if entrypoint_name = segment_name then entrypoint_sw = "0"b;
      276 						/* insure off in case he said foo$foo */
      277 
      278 
      279 /* Set full name to include the pathname only if pathname explicitly given */
      280 
      281 	if pathname_sw
      282 	then if directory_name = ">"
      283 	     then full_name = ">";
      284 	     else do;
      285 		full_name = rtrim (directory_name);	/* separate for better code */
      286 		full_name = full_name || ">";
      287 		end;
      288 	else full_name = "";
      289 
      290 	if entrypoint_sw then do;			/* separate statements for better code */
      291 	     full_name = full_name || rtrim (segment_name);
      292 	     full_name = full_name || "$";
      293 	     full_name = full_name || entrypoint_name;
      294 	     end;
      295 	else full_name = full_name || segment_name;
      296 
      297 	return;
      298 
      299      end parse_complex_name;
      300 
      301 /* This internal procedure does the main work of find_command_.  It attempts to find the specified entrypoint, first
      302*   searching the associative memory, if possible */
      303 
      304 search_entry:
      305      procedure ();
      306 
      307 dcl  am_idx fixed binary;
      308 
      309 
      310 /* Try the assocate memory first */
      311 
      312 	if ^entrypoint_sw
      313 	then if search_am (segment_name, am_idx) then do;
      314 		a_entrypoint_ptr = memory.e (am_idx).entrypoint_ptr;
      315 		return;
      316 		end;
      317 
      318 
      319 /* Must call the linker */
      320 
      321 	call hcs_$make_ptr (null (), segment_name, entrypoint_name, a_entrypoint_ptr, code);
      322 	if code ^= 0 then call abort (code, full_name_value.str);
      323 
      324 
      325 /* Place entry into associative memory if no entrypoint was given */
      326 
      327 	if ^entrypoint_sw then call set_am (am_idx, segment_name, a_entrypoint_ptr, HIT);
      328 
      329 	return;
      330 
      331      end search_entry;
      332 
      333 /* These two internal procedures manage the associative memory */
      334 
      335 /* This internal procedure searches the associative memory, returning "1"b if the given name is in the memory.  In all
      336*   cases it returns an index, which when the entry is not found, is the index of the least-recently used entry */
      337 
      338 search_am:
      339      procedure (name, am_idx) returns (bit (1) aligned);
      340 
      341 dcl  name character (32);
      342 dcl  am_idx fixed binary;
      343 dcl  (oldest, idx, jdx) fixed binary;
      344 
      345 	oldest = hbound (memory.e, 1) + 1;
      346 
      347 	do idx = lbound (memory.e, 1) to hbound (memory.e, 1);
      348 
      349 	     if memory.e (idx).name = name then do;
      350 		am_idx = idx;
      351 		memory.e (idx).usage = HIT;
      352 		do jdx = idx + 1 to hbound (memory.e, 1);
      353 		     memory.e (jdx).usage = memory.e (jdx).usage - 1;
      354 		end;				/* decrement usage of rest */
      355 		return ("1"b);			/* success */
      356 		end;
      357 
      358 	     memory.e (idx).usage = memory.e (idx).usage - 1;
      359 						/* miss */
      360 	     if memory.e (idx).usage < oldest then do;
      361 		oldest = memory.e (idx).usage;
      362 		am_idx = idx;
      363 		end;
      364 	end;
      365 
      366 	return ("0"b);				/* not found */
      367 
      368      end search_am;
      369 
      370 
      371 
      372 /* This internal procedure sets an entry in the associative memory */
      373 
      374 set_am:
      375      procedure (am_idx, name, entrypoint_ptr, usage);
      376 
      377 dcl  (am_idx, usage) fixed binary;
      378 dcl  name character (32);
      379 dcl  entrypoint_ptr pointer;
      380 
      381 	memory.e (am_idx).name = name;
      382 	memory.e (am_idx).entrypoint_ptr = entrypoint_ptr;
      383 	memory.e (am_idx).usage = usage;
      384 
      385 	return;
      386 
      387      end set_am;
      388 
      389 /* This internal procedure aborts find_command_, printing an error message if print_sw is ON */
      390 
      391 abort:
      392      procedure (code, text);
      393 
      394 dcl  code fixed binary (35);
      395 dcl  text character (*);
      396 
      397 	a_entrypoint_ptr = null ();
      398 	a_code = code;
      399 
      400 	if print_sw
      401 	then if (code = error_table_$seg_not_found) | (code = error_table_$noentry)
      402 	     then call com_err_$suppress_name (0, NAME, SegNotFound, segment_name);
      403 	     else if code = error_table_$no_ext_sym
      404 	     then call com_err_$suppress_name (0, NAME, NoEntryPoint, entrypoint_name, segment_name);
      405 	     else call com_err_ (code, NAME, "^a", text);
      406 
      407 	go to RETURN;
      408 
      409      end abort;
      410 
      411 /* This internal procedure enters the current segment name into the command usage metering information */
      412 
      413 meter_usage:
      414      procedure (command_name);
      415 
      416 dcl  command_name character (32);
      417 
      418 dcl  first_call bit (1) aligned internal static initial ("1"b);
      419 dcl  metering bit (1) aligned internal static initial ("1"b);
      420 						/* ON => metering still in operation */
      421 
      422 dcl  user_name character (32) internal static;
      423 
      424 dcl  (usage_list_ptr, usage_totals_ptr) pointer internal static;
      425 dcl  user_list_ptr pointer;
      426 
      427 dcl  UsageList character (19) static options (constant) initial ("command_usage_list_");
      428 dcl  UsageTotals character (21) static options (constant) initial ("command_usage_totals_");
      429 
      430 dcl  code fixed binary (35);
      431 dcl  idx fixed binary;
      432 dcl  found bit (1) aligned;
      433 
  1     1 /* BEGIN INCLUDE FILE ... command_usage.incl.pl1 ... GMP 780812 */
  1     2 
  1     3 /* Modified in July, 1983 by G. Dixon - add usage_list_size variable */
  1     4 
  1     5 dcl 1 usage_list aligned based (usage_list_ptr),		/* control structure for usage counting */
  1     6     2 n_commands fixed binary,			/* number of commands and aliases */
  1     7     2 locked bit (1) aligned,				/* ON => list being edited */
  1     8     2 directory character (168) unaligned,		/* containing dir for .usage segments */
  1     9     2 commands (usage_list_size refer (usage_list.n_commands)),
  1    10       3 name character (32) varying,			/* command/alias name */
  1    11       3 slot fixed binary unaligned,			/* if primary, index of totals;
  1    12*						   if alias, index of primary */
  1    13       3 primary bit (1) unaligned,			/* ON => first command of group */
  1    14       3 count_users bit (1) unaligned;			/* ON => count usage by user */
  1    15 
  1    16 dcl  usage_totals (1) fixed binary (35) based (usage_totals_ptr);
  1    17 						/* usage count for each command group */
  1    18 
  1    19 dcl 1 user_list (user_list_size) aligned based (user_list_ptr),
  1    20     2 name character (32),				/* Person.Project.* */
  1    21     2 count fixed binary (35);			/* count for this user */
  1    22 
  1    23 dcl  usage_list_size fixed binary;
  1    24 dcl  user_list_size fixed binary static options (constant) initial (200);
  1    25 
  1    26 /* END INCLUDE FILE ... command_usage.incl.pl1 */
  1    27 
      434 
      435 
      436 
      437 	if ^metering then return;			/* metering was turned off */
      438 
      439 
      440 	if first_call then do;			/* must initialize */
      441 
      442 	     call hcs_$make_ptr (null (), UsageList, "", usage_list_ptr, code);
      443 	     if code ^= 0 then do;
      444 disable_metering:
      445 		metering = "0"b;			/* shut off metering on an error */
      446 		return;
      447 		end;
      448 
      449 	     call hcs_$make_ptr (null (), UsageTotals, "", usage_totals_ptr, code);
      450 	     if code ^= 0 then go to disable_metering;
      451 
      452 	     user_name = get_group_id_$tag_star ();	/* if metering by user name */
      453 	     first_call = "0"b;			/* initialized */
      454 	     end;
      455 
      456 
      457 /* Search command/alias list to see if this name is being metered */
      458 
      459 	on any_other call check_for_error ();		/* disable metering on faults */
      460 
      461 	found = "0"b;
      462 
      463 	do idx = 1 to usage_list.n_commands while (^found);
      464 	     if usage_list.commands (idx).name = command_name then found = "1"b;
      465 	end;
      466 
      467 	if found
      468 	then idx = idx - 1;				/* will be one too large from loop */
      469 	else return;				/* not being metered */
      470 
      471 
      472 /* This name is being metered */
      473 
      474 	if ^usage_list.commands (idx).primary then idx = usage_list.commands (idx).slot;
      475 						/* this is an alias */
      476 
      477 	usage_totals (usage_list.commands (idx).slot) = usage_totals (usage_list.commands (idx).slot) + 1;
      478 						/* count it */
      479 
      480 	if ^usage_list.commands (idx).count_users then return;
      481 						/* recording finished */
      482 
      483 	call hcs_$initiate (usage_list.directory, (usage_list.commands (idx).name || ".usage"), "", 0b, 01b,
      484 	     user_list_ptr, (0));
      485 	if user_list_ptr = null () then return;
      486 
      487 	found = "0"b;
      488 
      489 	do idx = 1 to user_list_size while (^found);
      490 	     if user_list (idx).name = user_name then found = "1"b;
      491 	     else if user_list (idx).count = 0 then do;	/* not in list, add in new slot */
      492 		user_list (idx).name = user_name;
      493 		found = "1"b;
      494 		end;
      495 	end;
      496 
      497 	if found then user_list (idx - 1).count = user_list (idx - 1).count + 1;
      498 
      499 	call hcs_$terminate_noname (user_list_ptr, (0));
      500 
      501 	return;
      502 
      503 
      504 /* This internal procedure of meter_usage is called on an error to decide
      505*   if metering should be disabled */
      506 
      507 check_for_error:
      508 	procedure ();
      509 
      510 dcl  code fixed binary (35);
      511 
      512 dcl  1 info aligned,
  2     1 	/* BEGIN INCLUDE FILE ... cond_info.incl.pl1
  2     2*	   coded by M. Weaver 12 July 1973 */
  2     3 
  2     4 	  2 mcptr ptr,				/* ptr to machine conditions at time of fault */
  2     5 	  2 version fixed bin,			/* version of this structure (now=1) */
  2     6 	  2 condition_name char(32) var,		/* name of condition */
  2     7 	  2 infoptr ptr,				/* ptr to software info structure */
  2     8 	  2 wcptr ptr,				/* ptr to wall crossing machine conditions */
  2     9 	  2 loc_ptr ptr,				/* ptr to location where condition occurred */
  2    10 	  2 flags aligned,
  2    11 	    3 crawlout bit(1) unal,			/* = "1"b if condition occurred in inner ring */
  2    12 	    3 pad1 bit(35) unal,
  2    13 	  2 pad_word bit(36) aligned,
  2    14 	  2 user_loc_ptr ptr,			/* ptr to last non-support loc before condition */
  2    15 	  2 pad (4) bit(36) aligned;
  2    16 
  2    17 	/* END INCLUDE FILE ... cond_info.incl.pl1 */
      513 
      514 
      515 
      516 	     info.version = 1;
      517 
      518 	     call find_condition_info_ (null (), addr (info), code);
      519 	     if code ^= 0 then go to disable_metering;	/* can't get info, bad error */
      520 
      521 	     if (info.condition_name = "alrm") | (info.condition_name = "cput") | (info.condition_name = "finish")
      522 		| (info.condition_name = "mme2") | (info.condition_name = "program_interrupt")
      523 		| (info.condition_name = "quit") | (info.condition_name = "trm_") | (info.condition_name = "sus_")
      524 	     then call continue_to_signal_ ((0));	/* these conditions are allright */
      525 
      526 	     go to disable_metering;			/* fault: turn of metering */
      527 
      528 	end check_for_error;
      529 
      530      end meter_usage;
      531 
      532      end find_command_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0803.7  find_command_.pl1                 >spec>install>1111>find_command_.pl1
434          1    09/09/83  1151.9  command_usage.incl.pl1            >ldd>include>command_usage.incl.pl1
513          2    05/06/74  1741.0  cond_info.incl.pl1                >ldd>include>cond_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BREAKS                          000045 constant        char(3)                  initial packed unaligned dcl 89 ref 157
BlankCommand                    000033 constant        char(19)                 initial packed unaligned dcl 92 set ref 149*
HIT                             000046 constant        fixed bin(17,0)          initial dcl 83 set ref 327* 351
NAME                            000040 constant        char(18)                 initial packed unaligned dcl 91 set ref 149* 400*
                                                                                  403* 405*
NoEntryPoint                    000013 constant        char(39)                 initial packed unaligned dcl 94 set ref 403*
SPACES                                 constant        char(2)                  initial packed unaligned dcl 87 ref 146
SegNotFound                     000025 constant        char(21)                 initial packed unaligned dcl 93 set ref 400*
UsageList                       000006 constant        char(19)                 initial packed unaligned dcl 427 set ref 442*
UsageTotals                     000000 constant        char(21)                 initial packed unaligned dcl 428 set ref 449*
a_code                                 parameter       fixed bin(35,0)          dcl 44 set ref 35 135 141* 150* 194* 398*
a_entrypoint_ptr                       parameter       pointer                  dcl 43 set ref 35 135 314* 321* 327* 397*
a_input_name                           based           char                     packed unaligned dcl 46 ref 146
a_input_name_lth                       parameter       fixed bin(21,0)          dcl 42 ref 35 135 146
a_input_name_ptr                       parameter       pointer                  dcl 41 ref 35 135 144 146
addr                                                   builtin function         dcl 124 ref 183 322 518 518
am_idx                          000326 automatic       fixed bin(17,0)          dcl 307 in procedure "search_entry" set ref 312* 314
                                                                                  327*
am_idx                          000304 automatic       fixed bin(17,0)          dcl 72 in procedure "find_command_" set ref 186*
                                                                                  186*
am_idx                                 parameter       fixed bin(17,0)          dcl 342 in procedure "search_am" set ref 338 350*
                                                                                  362*
am_idx                                 parameter       fixed bin(17,0)          dcl 377 in procedure "set_am" ref 374 381 382 383
any_other                       000000 stack reference condition                dcl 122 ref 459
code                            000301 automatic       fixed bin(35,0)          dcl 70 in procedure "find_command_" set ref 182* 183
                                                                                  183 183* 255* 257 257* 321* 322 322*
code                            000106 automatic       fixed bin(35,0)          dcl 510 in procedure "check_for_error" set ref 518*
                                                                                  519
code                            000102 automatic       fixed bin(35,0)          dcl 430 in procedure "meter_usage" set ref 442* 443
                                                                                  449* 450
code                                   parameter       fixed bin(35,0)          dcl 394 in procedure "abort" set ref 391 398 400 400
                                                                                  403 405*
com_err_                        000346 constant        entry                    external dcl 107 ref 149 405
com_err_$suppress_name          000350 constant        entry                    external dcl 107 ref 400 403
command_name                           parameter       char(32)                 packed unaligned dcl 416 ref 413 464
commands                 54            based           structure                array level 2 dcl 1-5
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 512 set ref 521 521 521 521 521 521 521
                                                                                  521
continue_to_signal_             000352 constant        entry                    external dcl 111 ref 521
count                    10            based           fixed bin(35,0)          array level 2 dcl 1-19 set ref 491 497* 497
count_users              65(19)        based           bit(1)                   array level 3 packed packed unaligned dcl 1-5 ref
                                                                                  480
directory                 2            based           char(168)                level 2 packed packed unaligned dcl 1-5 set ref 483*
directory_name                  000207 automatic       char(168)                packed unaligned dcl 66 set ref 182* 255* 281 285
e                               000010 internal static structure                array level 2 dcl 77 set ref 204 204 345 347 347 352
entry_idx                       000314 automatic       fixed bin(21,0)          dcl 215 set ref 219* 221 222* 228 234* 234 235 243
                                                                                  244 251 255 255 263
entrypoint_idx                  000316 automatic       fixed bin(21,0)          dcl 215 set ref 244* 245 247 247 270
entrypoint_lth                  000317 automatic       fixed bin(21,0)          dcl 215 set ref 245* 246 247
entrypoint_name                 000271 automatic       char(32)                 packed unaligned dcl 68 set ref 161* 247 270* 271
                                                                                  273* 275 293 321* 403*
entrypoint_ptr           10     000010 internal static pointer                  initial array level 3 in structure "memory" dcl 77
                                                                                  in procedure "find_command_" set ref 314 382*
entrypoint_ptr                         parameter       pointer                  dcl 379 in procedure "set_am" ref 374 382
entrypoint_sw                   000104 automatic       bit(1)                   dcl 55 set ref 159* 224* 235* 242 269 275* 290 312
                                                                                  327
error_table_$bad_command_name   000326 external static fixed bin(35,0)          dcl 96 set ref 246* 271*
error_table_$badpath            000330 external static fixed bin(35,0)          dcl 96 set ref 232*
error_table_$dirseg             000332 external static fixed bin(35,0)          dcl 96 set ref 228*
error_table_$entlong            000334 external static fixed bin(35,0)          dcl 96 set ref 158* 247* 261*
error_table_$namedup            000336 external static fixed bin(35,0)          dcl 96 ref 183
error_table_$no_ext_sym         000340 external static fixed bin(35,0)          dcl 96 ref 403
error_table_$noentry            000342 external static fixed bin(35,0)          dcl 96 ref 400
error_table_$seg_not_found      000344 external static fixed bin(35,0)          dcl 96 ref 150 400
expand_pathname_                000356 constant        entry                    external dcl 113 ref 255
find_condition_info_            000354 constant        entry                    external dcl 112 ref 518
first_call                      000310 internal static bit(1)                   initial dcl 418 set ref 440 453*
found                           000104 automatic       bit(1)                   dcl 432 set ref 461* 463 464* 467 487* 489 490* 493*
                                                                                  497
full_name                       000106 automatic       varying char(256)        dcl 61 set ref 162* 183 281* 285* 286* 286 288* 291*
                                                                                  291 292* 292 293* 293 295* 295 322
full_name_value                        based           structure                level 1 dcl 62
get_group_id_$tag_star          000360 constant        entry                    external dcl 114 ref 452
hbound                                                 builtin function         dcl 124 ref 204 345 347 352
hcs_$initiate                   000362 constant        entry                    external dcl 115 ref 483
hcs_$make_ptr                   000364 constant        entry                    external dcl 118 ref 321 442 449
hcs_$terminate_noname           000366 constant        entry                    external dcl 119 ref 499
idx                             000305 automatic       fixed bin(17,0)          dcl 72 in procedure "find_command_" set ref 204*
                                                                                  205*
idx                             000103 automatic       fixed bin(17,0)          dcl 431 in procedure "meter_usage" set ref 463* 464*
                                                                                  467* 467 474 474* 474 477 477 480 483 489* 490 491
                                                                                  492* 497 497
idx                             000337 automatic       fixed bin(17,0)          dcl 343 in procedure "search_am" set ref 347* 349
                                                                                  350 351 352 358 358 360 361 362*
info                            000110 automatic       structure                level 1 dcl 512 set ref 518 518
input_name                             based           char                     packed unaligned dcl 51 set ref 157 158* 160 161 162
                                                                                  219 228 228* 232* 235 243 246* 247 247 257* 261
                                                                                  261 263 270 271*
input_name_lth                  000102 automatic       fixed bin(21,0)          dcl 53 set ref 146* 148 157 158 158 158 160 161 162
                                                                                  219 228 228 228 232 232 234 235 243 245 246 246
                                                                                  247 247 251 257 257 261 261 263 270 271 271
input_name_ptr                  000100 automatic       pointer                  dcl 52 set ref 144* 157 158 160 161 162 219 228 228
                                                                                  232 235 243 246 247 247 255 257 261 261 263 270
                                                                                  271
jdx                             000340 automatic       fixed bin(17,0)          dcl 343 set ref 352* 353 353*
lbound                                                 builtin function         dcl 124 ref 204 347
length                                                 builtin function         dcl 124 ref 146 158 247 261
lth                                    based           fixed bin(21,0)          level 2 dcl 62 ref 183 183 322 322
memory                          000010 internal static structure                level 1 dcl 77
metering                        000311 internal static bit(1)                   initial dcl 419 set ref 437 444*
n_commands                             based           fixed bin(17,0)          level 2 dcl 1-5 ref 463
name                                   based           char(32)                 array level 2 in structure "user_list" dcl 1-19
                                                                                  in procedure "meter_usage" set ref 490 492*
name                                   parameter       char(32)                 packed unaligned dcl 378 in procedure "set_am" ref
                                                                                  374 381
name                                   parameter       char(32)                 packed unaligned dcl 341 in procedure "search_am"
                                                                                  ref 338 349
name                     54            based           varying char(32)         array level 3 in structure "usage_list" dcl 1-5
                                                                                  in procedure "meter_usage" ref 464 483
name                            000010 internal static char(32)                 initial array level 3 in structure "memory" dcl 77
                                                                                  in procedure "find_command_" set ref 349 381*
null                                                   builtin function         dcl 124 ref 186 186 205 205 321 321 397 442 442 449
                                                                                  449 485 518 518
object_lib_$init_no_clear       000370 constant        entry                    external dcl 120 ref 182
oldest                          000336 automatic       fixed bin(17,0)          dcl 343 set ref 345* 360 361*
pathname                               based           char                     packed unaligned dcl 216 set ref 255*
pathname_sw                     000103 automatic       bit(1)                   dcl 55 set ref 159* 170 223* 233* 254 281
primary                  65(18)        based           bit(1)                   array level 3 packed packed unaligned dcl 1-5 ref
                                                                                  474
print_sw                        000105 automatic       bit(1)                   dcl 55 set ref 128* 138* 149 400
reverse                                                builtin function         dcl 124 ref 219
rtrim                                                  builtin function         dcl 124 ref 146 285 291
search                                                 builtin function         dcl 124 ref 157 219 235 243 271
segment_lth                     000315 automatic       fixed bin(21,0)          dcl 215 set ref 243* 244 246 251* 255 255 261 261
                                                                                  261 263
segment_name                    000261 automatic       char(32)                 packed unaligned dcl 67 set ref 158 160* 167* 182*
                                                                                  182* 186* 255* 261 263* 273 275 291 295 312* 321*
                                                                                  327* 400* 403*
segment_ptr                     000302 automatic       pointer                  dcl 71 set ref 182*
slot                     65            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 1-5 ref
                                                                                  474 477 477
str                       1            based           char                     level 2 packed packed unaligned dcl 62 set ref 183*
                                                                                  322*
substr                                                 builtin function         dcl 124 ref 235 243 247 247 261 261 263 270
text                                   parameter       char                     packed unaligned dcl 395 set ref 391 405*
usage                                  parameter       fixed bin(17,0)          dcl 377 in procedure "set_am" ref 374 383
usage                    12     000010 internal static fixed bin(17,0)          initial array level 3 in structure "memory" dcl 77
                                                                                  in procedure "find_command_" set ref 351* 353* 353
                                                                                  358* 358 360 361 383*
usage_list                             based           structure                level 1 dcl 1-5
usage_list_ptr                  000322 internal static pointer                  dcl 424 set ref 442* 463 464 474 474 477 477 480 483
                                                                                  483
usage_totals                           based           fixed bin(35,0)          array dcl 1-16 set ref 477* 477
usage_totals_ptr                000324 internal static pointer                  dcl 424 set ref 449* 477 477
user_list                              based           structure                array level 1 dcl 1-19
user_list_ptr                   000100 automatic       pointer                  dcl 425 set ref 483* 485 490 491 492 497 497 499*
user_list_size                         constant        fixed bin(17,0)          initial dcl 1-24 ref 489
user_name                       000312 internal static char(32)                 packed unaligned dcl 422 set ref 452* 490 492
version                   2     000110 automatic       fixed bin(17,0)          level 2 dcl 512 set ref 516*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
usage_list_size                        automatic       fixed bin(17,0)          dcl 1-23

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          000145 constant        label                    dcl 141 ref 130
RETURN                          000426 constant        label                    dcl 196 ref 407
abort                           001464 constant        entry                    internal dcl 391 ref 158 183 228 232 246 247 257 261
                                                                                  271 322
check_for_error                 002233 constant        entry                    internal dcl 507 ref 459
clear                           000430 constant        entry                    external dcl 201
disable_metering                001674 constant        label                    dcl 444 ref 450 519 526
fc_no_message                   000137 constant        entry                    external dcl 135
find_command_                   000125 constant        entry                    external dcl 35
meter_usage                     001630 constant        entry                    internal dcl 413 ref 167
parse_complex_name              000454 constant        entry                    internal dcl 212 ref 165
search_am                       001352 constant        entry                    internal dcl 338 ref 186 312
search_entry                    001240 constant        entry                    internal dcl 304 ref 170 188
set_am                          001442 constant        entry                    internal dcl 374 ref 186 205 327

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3700        4272    3414        3710
Length      4546    3414       372         240     264         316

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
find_command_                       349 external procedure  is an external procedure.  
parse_complex_name                      internal procedure  shares stack frame of external procedure find_command_.  
search_entry                            internal procedure  shares stack frame of external procedure find_command_.  
search_am                               internal procedure  shares stack frame of external procedure find_command_.  
set_am                                  internal procedure  shares stack frame of external procedure find_command_.  
abort                               106 internal procedure  is called during a stack extension.  
meter_usage                         142 internal procedure  enables or reverts conditions.  
on unit on line 459                 111 on unit               
check_for_error                         internal procedure  shares stack frame of on unit on line 459.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 memory                      find_command_
000310 first_call                  meter_usage
000311 metering                    meter_usage
000312 user_name                   meter_usage
000322 usage_list_ptr              meter_usage
000324 usage_totals_ptr            meter_usage

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
find_command_            000100 input_name_ptr              find_command_
                         000102 input_name_lth              find_command_
                         000103 pathname_sw                 find_command_
                         000104 entrypoint_sw               find_command_
                         000105 print_sw                    find_command_
                         000106 full_name                   find_command_
                         000207 directory_name              find_command_
                         000261 segment_name                find_command_
                         000271 entrypoint_name             find_command_
                         000301 code                        find_command_
                         000302 segment_ptr                 find_command_
                         000304 am_idx                      find_command_
                         000305 idx                         find_command_
                         000314 entry_idx                   parse_complex_name
                         000315 segment_lth                 parse_complex_name
                         000316 entrypoint_idx              parse_complex_name
                         000317 entrypoint_lth              parse_complex_name
                         000326 am_idx                      search_entry
                         000336 oldest                      search_am
                         000337 idx                         search_am
                         000340 jdx                         search_am
meter_usage              000100 user_list_ptr               meter_usage
                         000102 code                        meter_usage
                         000103 idx                         meter_usage
                         000104 found                       meter_usage
on unit on line 459      000106 code                        check_for_error
                         000110 info                        check_for_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        continue_to_signal_           expand_pathname_
find_condition_info_          get_group_id_$tag_star        hcs_$initiate                 hcs_$make_ptr
hcs_$terminate_noname         object_lib_$init_no_clear

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_command_name error_table_$badpath          error_table_$dirseg           error_table_$entlong
error_table_$namedup          error_table_$no_ext_sym       error_table_$noentry          error_table_$seg_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     35 000120       128 000132       130 000134       135 000135       138 000144       141 000145       144 000147
    146 000152       148 000165       149 000166       150 000212       151 000216       157 000217       158 000232
    159 000254       160 000256       161 000263       162 000266       163 000276       165 000277       167 000300
    170 000306       182 000312       183 000361       186 000406       188 000423       194 000424       196 000426
    201 000427       204 000435       205 000441       206 000451       208 000453       212 000454       219 000455
    221 000471       222 000472       223 000474       224 000475       225 000477       228 000500       232 000527
    233 000547       234 000551       235 000554       242 000576       243 000577       244 000616       245 000621
    246 000625       247 000651       249 000707       251 000711       254 000715       255 000717       257 000752
    258 000773       261 000774       263 001023       269 001032       270 001034       271 001046       272 001100
    273 001101       275 001104       281 001111       285 001124       286 001144       287 001153       288 001154
    290 001155       291 001157       292 001203       293 001212       294 001224       295 001225       297 001237
    304 001240       312 001241       314 001250       315 001256       321 001257       322 001311       327 001332
    329 001351       338 001352       345 001354       347 001356       349 001363       350 001375       351 001377
    352 001402       353 001411       354 001416       355 001420       358 001424       360 001427       361 001432
    362 001433       364 001435       366 001437       374 001442       381 001444       382 001454       383 001457
    385 001462       391 001463       397 001477       398 001503       400 001506       403 001543       405 001576
    407 001624       413 001627       437 001635       440 001637       442 001641       443 001672       444 001674
    446 001676       449 001677       450 001731       452 001733       453 001746       459 001747       461 001765
    463 001766       464 002001       465 002017       467 002021       469 002026       474 002027       477 002041
    480 002052       483 002055       485 002140       487 002145       489 002146       490 002157       491 002173
    492 002176       493 002203       495 002205       497 002207       499 002220       501 002232       507 002233
    516 002234       518 002236       519 002255       521 002262       526 002342


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
