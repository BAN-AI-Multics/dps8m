	COMPILATION LISTING OF SEGMENT makestack
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1044.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       12*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       13*     Correct error message documentation.
       14*                                                   END HISTORY COMMENTS */
       15 
       16 
       17 /*			MAKESTACK
       18*   *
       19*   *	This is a  ring (0)  procedure which is called to make a stack for a ring.
       20*   *	The number of the ring for which the stack is being made is passed as an argument to
       21*   *	makestack.    All of the operations performed by  makestack  will be in behalf of this
       22*   *	 ring.
       23*   *
       24*   * Last modified (date and reason):
       25*   *		3/85 by Keith Loepere to not append stacks through links.
       26*   *		6/79 by C. Hornig to do less for prelinked rings
       27*   *		11/77 by M. Weaver to set aside a special area for ref names
       28*   *		6/77 by M. Weaver to set static handlers for isot_fault and lot_fault
       29*   *		3/77 by M. Weaver to add initialize_rnt code and to initialize ect_ptr
       30*   *		11/76 by M. Weaver to extend stack header
       31*   *		10/75 by R. Bratt for prelinking and to cleanup
       32*   *		9/74    by S.Webber as part of combining stacks, lots, and clrs
       33*   *		Modified 12/73 by E. Stone to remove assumption that pl1_operators_ is the same in all rings
       34*   *		,i.e. the placing of pointers to the alm operators in the stack header.
       35*   *		Modified 10/73 by E. Stone to set the max_length of the stack less than 256K
       36*   *		and to terminate the process if the stack exists or if the segment number has been used
       37*   *		and to place a pointer to operator_pointers_ in the stack header for B. Wolman
       38*   *		Recoded to include new stack format  -  3/72  by  Bill Silver
       39*   *		Recoded in  PL/I  -  8/70  by  N. I. Morris
       40*   */
       41 
       42 
       43 makestack: procedure (a_ring_num);
       44 
       45 
       46 dcl  a_ring_num fixed bin (3);			/* ring number for stack */
       47 
       48 dcl 1 instruction based aligned,
       49     2 tra_offset bit (18) unaligned,			/* References  offset  portion of  tra  instruction
       50*						   *  in transfer vector table in pl1_operators_.   These
       51*						   *  tra   instructions transfer to  ALM linkage operators. */
       52     2 rest bit (18) unaligned;
       53 
       54 
       55 dcl  ring_num fixed bin (3),				/* Work variable where the   ring number argument
       56*						   is  copied.  */
       57      save_val fixed bin (3),				/* Used to save the current validation level when the
       58*						   procedure is entered.  */
       59      segno fixed bin,				/* segment number of new stack */
       60      dirname char (168),
       61      stack_name char (8),				/* The reference name  ( and entry name ) of the new
       62*						   stack  segment.  */
       63      pl1_op_ptr ptr,				/* A pointer to the pl1 operators table. */
       64      workptr ptr,					/* A work pointer used in calls to  link_snap$make_ptr */
       65 						/* And to construct ptrs to operators in the stack header. */
       66      sctp (0:1) ptr unaligned based,
       67      1 local_create_branch_info aligned like create_branch_info,
       68      code fixed bin (35);				/* An internal  error  code.  */
       69 
       70 
       71 /*	The following declarations are made in order to reference data in the
       72*   *	process  data  segment.
       73*   */
       74 
       75 dcl  pds$stacks (0:7) pointer external;			/* An array of stack pointers for all possible rings. */
       76 dcl  pds$prelinked_ring (7) bit (1) unaligned ext;
       77 dcl  active_all_rings_data$stack_base_segno fixed bin (18) ext; /* Segment number of ring 0 stack. */
       78 dcl  pds$process_dir_name char (32) ext;
       79 dcl  pds$process_group_id char (32) ext;
       80 dcl 1 pds$useable_lot aligned ext,
       81     2 flags (0:7) bit (1) unal;
       82 
       83 
       84 
       85 /*	MAKESTACK uses the following external  entry points.
       86*   */
       87 
       88 dcl  level$get ext entry (fixed bin (3)),
       89      level$set ext entry (fixed bin (3)),
       90      link_man$get_initial_linkage entry (fixed bin (3)),
       91      link_snap$make_ptr ext entry (ptr, char (*), char (*), ptr, fixed bin (35)),
       92      append$create_branch_ ext entry (char (*), char (*), ptr, fixed bin (35)),
       93      initiate ext entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
       94      ref_name_$insert entry (char (32) varying, fixed bin, fixed bin (35)),
       95      set$max_length_ptr ext entry (ptr, fixed bin (19), fixed bin (35)),
       96      syserr$error_code ext entry options (variable),
       97      terminate_proc ext entry (fixed bin (35));
       98 
       99 dcl  sys_info$default_stack_length fixed bin (19) ext;
      100 dcl  error_table_$invalid_stack_creation ext fixed bin (35);
      101 
      102 dcl (addr,
      103      addrel,
      104      baseno,
      105      baseptr,
      106      fixed,
      107      null,
      108      ptr,
      109      rel,
      110      size,
      111      string,
      112      substr,
      113      unspec) builtin;
      114 
      115 	ring_num = a_ring_num;
      116 	sb, pds$stacks (ring_num)
      117 	     = baseptr (ring_num + active_all_rings_data$stack_base_segno); /* Compute expected stack pointer. */
      118 	segno = fixed (baseno (sb), 17);
      119 
      120 	if pds$prelinked_ring (ring_num)
      121 	then do;
      122 	     stack_header.null_ptr = null ();		/* force the stack to be copied */
      123 	     pds$useable_lot.flags (ring_num) = "1"b;	/* this saves trouble later */
      124 	     return;
      125 	end;
      126 
      127 	call level$get (save_val);
      128 	call level$set (ring_num);
      129 	dirname = pds$process_dir_name;
      130 	stack_name = "stack_" || substr ("1234567", ring_num, 1);
      131 
      132 	unspec (local_create_branch_info) = "0"b;	/* describe new stack, no chasing allowed */
      133 	local_create_branch_info.version = create_branch_version_2;
      134 	local_create_branch_info.parent_ac_sw = "1"b;
      135 	local_create_branch_info.mode = REW_ACCESS;
      136 	local_create_branch_info.rings (*) = ring_num;
      137 	local_create_branch_info.userid = pds$process_group_id;
      138 
      139 	call append$create_branch_ (dirname, stack_name, addr (local_create_branch_info), code);
      140 	if code ^= 0 then do;			/* User cannot make his own stack */
      141 	     call syserr$error_code (4, code, "makestack: error appending ^a", stack_name);
      142 	     call terminate_proc (error_table_$invalid_stack_creation);
      143 	end;
      144 	call initiate (dirname, stack_name, "", 1, 1, sb, code);
      145 						/* can't use reference names yet */
      146 	if code ^= 0 then do;			/* Prevent user from using reserved segment number */
      147 	     call syserr$error_code (4, code, "makestack: error initiating ^a", stack_name);
      148 	     call terminate_proc (error_table_$invalid_stack_creation);
      149 	end;
      150 	call set$max_length_ptr (sb, sys_info$default_stack_length, code);
      151 	if code ^= 0
      152 	then call syserr$error_code (2, code, "makestack: error from set$max_length_ptr on ^a.", stack_name);
      153 
      154 	stack_header.null_ptr,
      155 	     stack_header.ect_ptr = null ();
      156 	stack_header.stack_begin_ptr,
      157 	     stack_header.stack_end_ptr = ptr (sb, size (stack_header));
      158 	call link_man$get_initial_linkage (ring_num);
      159 	pds$useable_lot.flags (ring_num) = "1"b;
      160 	unspec (stack_header.lot_ptr -> lot.lp (segno)) = lot_fault;
      161 	call initialize_rnt;			/* allocate RNT and set search rules */
      162 	call ref_name_$insert ((stack_name), segno, code); /* now we can add reference name */
      163 
      164 /*	Now fill in the fields in the  header  of the  new  stack.  */
      165 
      166 	stack_header.signal_ptr = get_ptr ("signal_", "signal_");
      167 	stack_header.unwinder_ptr = get_ptr ("unwinder_", "unwinder_");
      168 	stack_header.trans_op_tv_ptr = get_ptr ("operator_pointers_", "operator_pointers_");
      169 	pl1_op_ptr = get_ptr ("pl1_operators_", "operator_table");
      170 
      171 
      172 
      173 /*	Get the following pl1 operator pointers from offsets within the pl1 operator table transfer vector */
      174 
      175 	workptr = addrel (pl1_op_ptr, tv_offset);
      176 
      177 	stack_header.pl1_operators_ptr = pl1_op_ptr;
      178 	stack_header.call_op_ptr =
      179 	     ptr (workptr, addrel (workptr, call_offset) -> instruction.tra_offset);
      180 	stack_header.push_op_ptr =
      181 	     ptr (workptr, addrel (workptr, push_offset) -> instruction.tra_offset);
      182 	stack_header.return_op_ptr =
      183 	     ptr (workptr, addrel (workptr, return_offset) -> instruction.tra_offset);
      184 	stack_header.return_no_pop_op_ptr =
      185 	     ptr (workptr, addrel (workptr, return_no_pop_offset) -> instruction.tra_offset);
      186 	stack_header.entry_op_ptr =
      187 	     ptr (workptr, addrel (workptr, entry_offset) -> instruction.tra_offset);
      188 
      189 /*	set up essential static handlers */
      190 
      191 	call link_snap$make_ptr (null (), "copy_on_write_handler_", "copy_on_write_handler_", workptr, code);
      192 	ptr (sb, rel (stack_header.sct_ptr)) -> sctp (no_write_permission_sct_index) = workptr;
      193 	ptr (sb, rel (stack_header.sct_ptr)) -> sctp (not_in_write_bracket_sct_index) = workptr;
      194 	call link_snap$make_ptr (null (), "isot_fault_handler_", "isot_fault_handler_", workptr, code);
      195 	ptr (sb, rel (stack_header.sct_ptr)) -> sctp (isot_fault_sct_index) = workptr;
      196 	call link_snap$make_ptr (null (), "lot_fault_handler_", "lot_fault_handler_", workptr, code);
      197 	ptr (sb, rel (stack_header.sct_ptr)) -> sctp (lot_fault_sct_index) = workptr;
      198 
      199 /*	We have finished setting up the header of the new  stack.   There are no more calls to be
      200*   *	made  so we will reset the validation level of this procedure to what it was when the procedure
      201*   *	was  called.    Then we will set up the two thread pointers in the first stack frame of the
      202*   *	new  stack.   Note the previous frame pointer is null since there is no previous frame.
      203*   *	The pointer to the first stack frame has been set up above in the stack_begin_ptr.
      204*   */
      205 
      206 	call level$set (save_val);
      207 	sp = stack_header.stack_end_ptr;
      208 	sp -> stack_frame.prev_sp = null;
      209 	sp -> stack_frame.next_sp = addrel (stack_header.stack_end_ptr, stack_frame_min_length);
      210 
      211 
      212 get_ptr:	proc (refname, defname) returns (ptr);
      213 dcl (refname, defname) char (*);
      214 	     call link_snap$make_ptr (null (), refname, defname, workptr, code);
      215 	     if code ^= 0 then do;
      216 		call syserr$error_code (0, code, "makestack: error finding ^a$^a for ^a.", refname, defname, stack_name);
      217 		call terminate_proc (error_table_$invalid_stack_creation);
      218 	     end;
      219 	     return (workptr);
      220 	end get_ptr;
      221 
      222 initialize_rnt: proc;
      223 
      224 dcl  rnt_space (2048) bit (36) aligned based;
      225 dcl 1 ainfo aligned like area_info;
      226 
      227 dcl  size builtin;
      228 
      229 dcl  error_table_$termination_requested ext fixed bin (35);
      230 dcl  terminate_proc entry (fixed bin (35));
      231 dcl  define_area_ entry (ptr, fixed bin (35));
      232 dcl  pds$processid bit (36) aligned ext;
      233 dcl  initiate_search_rules$init_ring entry (ptr, fixed bin (35));
      234 dcl  syserr$error_code entry options (variable);
      235 
  1     1 /* BEGIN INCLUDE FILE RNT.INCL.PL1 - WRITTEN SEPTEMBER 1974 BY R. BRATT */
  1     2 /* modified July 1976 by R. Bratt; updated March 1977 by M. Weaver */
  1     3 /* modified November 1977 by M. Weaver to use PL/I offsets instead of pointers */
  1     4 
  1     5 dcl (rntp, rntep) ptr;
  1     6 dcl lth fixed bin (17);
  1     7 dcl based_rnt_area area based;
  1     8 
  1     9 dcl 1 rnt aligned based (rntp),
  1    10     2 areap ptr,					/* pointer to area for rnte allocations */
  1    11     2 meters,
  1    12       3 insert,
  1    13         4 trys fixed bin (17) unaligned,
  1    14         4 wins fixed bin (17) unaligned,
  1    15       3 get_segno like insert,
  1    16       3 get_refnames like insert,
  1    17       3 delete_segno like insert,
  1    18       3 delete_name like insert,
  1    19     2 rnt_area_size fixed bin,
  1    20     2 srulep ptr,
  1    21     2 name_hash_table (0:127) offset (rnt.areap -> based_rnt_area),
  1    22     2 segno_hash_table (0:127) offset (rnt.areap -> based_rnt_area);
  1    23 
  1    24 dcl 1 rnte aligned based (rntep),
  1    25     2 name_fp offset (rnt.areap -> based_rnt_area),
  1    26     2 segno_fp offset (rnt.areap -> based_rnt_area),
  1    27     (2 segno fixed bin (17),
  1    28     2 length fixed bin (17),
  1    29     2 name char (lth refer (rnte.length)))unaligned;
  1    30 
  1    31 /* --------------------END RNT.INCL.PL1--------------------- */
      236 
      237 
  2     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  2     2 
  2     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  2     4 
  2     5 dcl  area_infop ptr;
  2     6 
  2     7 dcl 1 area_info aligned based (area_infop),
  2     8     2 version fixed bin,				/* version number for this structure is 1 */
  2     9     2 control aligned like area_control,		/* control bits for the area */
  2    10     2 owner char (32) unal,				/* creator of the area */
  2    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  2    12     2 size fixed bin (18),				/* size of the area in words */
  2    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  2    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  2    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  2    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  2    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  2    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  2    19 
  2    20 dcl 1 area_control aligned based,
  2    21     2 extend bit (1) unal,				/* says area is extensible */
  2    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  2    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  2    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  2    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  2    26     2 system bit (1) unal,				/* says area is managed by system */
  2    27     2 pad bit (30) unal;
  2    28 
  2    29 /* END INCLUDE FILE area_info.incl.pl1 */
      238 
      239 
      240 dcl 1 default_rules static options (constant) aligned,
      241     2 number fixed bin init (1),
      242     2 name char (168) init ("default");
      243 
      244 /* obtain an rnt area */
      245 
      246 	     ainfo.version = area_info_version_1;
      247 	     string (ainfo.control) = "0"b;
      248 	     ainfo.control.zero_on_free = "1"b;
      249 	     ainfo.control.system = "1"b;
      250 	     ainfo.owner = "rnt";
      251 	     ainfo.size = size (rnt_space);
      252 	     allocate rnt_space in (stack_header.clr_ptr -> based_rnt_area) set (ainfo.areap);
      253 	     call define_area_ (addr (ainfo), code);
      254 	     if code ^= 0 then call terminate_proc (error_table_$termination_requested);
      255 
      256 
      257 /*	initialize the RNT itself */
      258 
      259 	     allocate rnt in (ainfo.areap -> based_rnt_area) set (rntp);
      260 	     unspec (rnt) = "0"b;
      261 	     rnt.areap = ainfo.areap;
      262 	     rnt.rnt_area_size = ainfo.size;
      263 	     rnt.name_hash_table (*) = null ();
      264 	     rnt.segno_hash_table (*) = null ();
      265 	     rnt.srulep = null;
      266 	     stack_header.rnt_ptr = rntp;
      267 
      268 /*	initialize the search rules */
      269 
      270 	     call initiate_search_rules$init_ring (addr (default_rules), code);
      271 	     if code ^= 0 then do;
      272 		call syserr$error_code (0, code, "makestack: error from initiate_search_rules.");
      273 		call terminate_proc (error_table_$termination_requested);
      274 		end;
      275 
      276 	     return;
      277 	end initialize_rnt;
      278 
  3     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  3     2*
  3     3*   Values for the "access mode" argument so often used in hardcore
  3     4*   James R. Davis 26 Jan 81  MCR 4844
  3     5*   Added constants for SM access 4/28/82 Jay Pattin
  3     6*   Added text strings 03/19/85 Chris Jones
  3     7**/
  3     8 
  3     9 
  3    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  3    11 dcl	(
  3    12 	N_ACCESS		   init ("000"b),
  3    13 	R_ACCESS		   init ("100"b),
  3    14 	E_ACCESS		   init ("010"b),
  3    15 	W_ACCESS		   init ("001"b),
  3    16 	RE_ACCESS		   init ("110"b),
  3    17 	REW_ACCESS	   init ("111"b),
  3    18 	RW_ACCESS		   init ("101"b),
  3    19 	S_ACCESS		   init ("100"b),
  3    20 	M_ACCESS		   init ("010"b),
  3    21 	A_ACCESS		   init ("001"b),
  3    22 	SA_ACCESS		   init ("101"b),
  3    23 	SM_ACCESS		   init ("110"b),
  3    24 	SMA_ACCESS	   init ("111"b)
  3    25 	)		   bit (3) internal static options (constant);
  3    26 
  3    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  3    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  3    29 
  3    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  3    31 			   static options (constant);
  3    32 
  3    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  3    34 			   static options (constant);
  3    35 
  3    36 dcl	(
  3    37 	N_ACCESS_BIN	   init (00000b),
  3    38 	R_ACCESS_BIN	   init (01000b),
  3    39 	E_ACCESS_BIN	   init (00100b),
  3    40 	W_ACCESS_BIN	   init (00010b),
  3    41 	RW_ACCESS_BIN	   init (01010b),
  3    42 	RE_ACCESS_BIN	   init (01100b),
  3    43 	REW_ACCESS_BIN	   init (01110b),
  3    44 	S_ACCESS_BIN	   init (01000b),
  3    45 	M_ACCESS_BIN	   init (00010b),
  3    46 	A_ACCESS_BIN	   init (00001b),
  3    47 	SA_ACCESS_BIN	   init (01001b),
  3    48 	SM_ACCESS_BIN	   init (01010b),
  3    49 	SMA_ACCESS_BIN	   init (01011b)
  3    50 	)		   fixed bin (5) internal static options (constant);
  3    51 
  3    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      279 
  4     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  4     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  4     7*       1. Declare version constant properly.
  4     8*       2. Remove version 1 since it was never referenced and to force
  4     9*          callers to upgrade their programs.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  4    14 
  4    15 /* this include files gives the argument structure for create_branch_ */
  4    16 
  4    17 dcl 1 create_branch_info aligned based,
  4    18     2 version fixed bin,				/* set this to the largest value given below */
  4    19     2 switches unaligned,
  4    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  4    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  4    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  4    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  4    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  4    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  4    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  4    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  4    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  4    29     2 userid char (32),				/* user's access control name */
  4    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  4    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  4    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  4    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  4    34 
  4    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  4    36 
  4    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  4    38 
      280 
  5     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  5     2 /* modified by M. Weaver 3/77 */
  5     3 
  5     4 dcl  lotp ptr;
  5     5 
  5     6 dcl 1 lot based (lotp) aligned,
  5     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  5     8 
  5     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  5    10 						/* lot fault has fault code = 0 and offset = 0 */
  5    11 
  5    12 dcl  isotp ptr;
  5    13 dcl 1 isot based (isotp) aligned,
  5    14     2 isp (0:9999) ptr unaligned;
  5    15 
  5    16 dcl 1 isot1 (0 :9999) aligned based,
  5    17     2 flags unaligned,
  5    18       3 fault bit (2) unaligned,
  5    19       3 system bit (1) unaligned,
  5    20       3 mbz bit (6) unaligned,
  5    21     2 fault_code fixed bin (8) unaligned,
  5    22     2 static_offset bit (18) unaligned;
  5    23 
  5    24 
  5    25 /* END INCLUDE FILE  lot.incl.pl1 */
      281 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  6     2 
  6     3 /* format: off */
  6     4 
  6     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  6     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  6     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  6     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  6     9 
  6    10 
  6    11 /****^  HISTORY COMMENTS:
  6    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  6    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  6    14*     Modified to add constants for the translator_id field in the stack_frame
  6    15*     structure.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 
  6    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  6    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  6    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  6    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  6    23 
  6    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  6    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  6    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  6    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  6    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  6    29 
  6    30 
  6    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  6    32 
  6    33 dcl  stack_frame_min_length fixed bin static init(48);
  6    34 
  6    35 
  6    36 dcl 1 stack_frame based(sp) aligned,
  6    37     2 pointer_registers(0 : 7) ptr,
  6    38     2 prev_sp pointer,
  6    39     2 next_sp pointer,
  6    40     2 return_ptr pointer,
  6    41     2 entry_ptr pointer,
  6    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  6    43     2 arg_ptr pointer,
  6    44     2 static_ptr ptr unaligned,
  6    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  6    46     2 on_unit_relp1 bit(18) unaligned,
  6    47     2 on_unit_relp2 bit(18) unaligned,
  6    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  6    49*						   0 => PL/I version II
  6    50*						   1 => ALM
  6    51*						   2 => PL/I version I   
  6    52*						   3 => signal caller frame
  6    53*						   4 => signaller frame */
  6    54     2 operator_return_offset bit(18) unaligned,
  6    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  6    56     2 a bit(36),					/* accumulator */
  6    57     2 q bit(36),					/* q-register */
  6    58     2 e bit(36),					/* exponent */
  6    59     2 timer bit(27) unaligned,				/* timer */
  6    60     2 pad bit(6) unaligned,
  6    61     2 ring_alarm_reg bit(3) unaligned;
  6    62 
  6    63 
  6    64 dcl 1 stack_frame_flags based(sp) aligned,
  6    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  6    66     2 xx0 bit(22) unal,
  6    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  6    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  6    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  6    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  6    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  6    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  6    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  6    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  6    75     2 xx0a bit(6) unal,
  6    76     2 xx1 fixed bin,
  6    77     2 xx2 fixed bin,
  6    78     2 xx3 bit(25) unal,
  6    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  6    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  6    81     2 xx3a bit(9) unaligned,
  6    82     2 xx4(9) bit(72) aligned,
  6    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  6    84*						*  operator puts a pointer to the base of
  6    85*						*  the calling procedure here. (text base ptr)  */
  6    86     2 xx5 bit(72) aligned,
  6    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  6    88 
  6    89 /* format: on */
  6    90 
  6    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      282 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  7     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  7     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  7     4 /*	Modified April 1983 by C. Hornig for tasking */
  7     5 
  7     6 /****^  HISTORY COMMENTS:
  7     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  7     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  7     9*     added the heap_header_ptr definition.
  7    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  7    12*     Modified to support control point management.  These changes were actually
  7    13*     made in February 1985 by G. Palter.
  7    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  7    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  7    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  7    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  7    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  7    19*     (ITS pair).
  7    20*                                                   END HISTORY COMMENTS */
  7    21 
  7    22 /* format: style2 */
  7    23 
  7    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  7    25 
  7    26      dcl	   1 stack_header	      based (sb) aligned,
  7    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  7    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  7    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  7    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  7    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  7    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  7    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  7    34 	     2 pad4	      bit (2) unal,
  7    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  7    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  7    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  7    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  7    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  7    40 	     2 null_ptr	      ptr,		/*  (16)  */
  7    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  7    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  7    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  7    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  7    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  7    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  7    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  7    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  7    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  7    50 	     2 return_no_pop_op_ptr
  7    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  7    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  7    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  7    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  7    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  7    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  7    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  7    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  7    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  7    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  7    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  7    62 	     2 trace,
  7    63 	       3 frames,
  7    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  7    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  7    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  7    67 	     2 pad2	      bit (36),		/*  (61) */
  7    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  7    69 
  7    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  7    71 
  7    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  7    73 						/* (551) octal */
  7    74 
  7    75 
  7    76 /*	The following constants are offsets within this transfer vector table.  */
  7    77 
  7    78      dcl	   (
  7    79 	   call_offset	      fixed bin init (271),
  7    80 	   push_offset	      fixed bin init (272),
  7    81 	   return_offset	      fixed bin init (273),
  7    82 	   return_no_pop_offset   fixed bin init (274),
  7    83 	   entry_offset	      fixed bin init (275)
  7    84 	   )		      internal static;
  7    85 
  7    86 
  7    87 
  7    88 
  7    89 
  7    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  7    91*	move the whole stack header should use this overlay.
  7    92**/
  7    93 
  7    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  7    95 
  7    96 
  7    97 
  7    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      283 
  8     1 /* BEGIN INCLUDE FILE  static_handlers.incl.pl1  */
  8     2 
  8     3 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
  8     4 
  8     5 /* HISTORY:
  8     6*Written by S. H. Webber, 06/20/75.
  8     7*Modified:
  8     8*12/15/83 by Benson Margulies:  added undefined_pointer_sct_index and
  8     9*	  pgt_sct_index.
  8    10*06/11/84 by Lee A. Newcomb:  added dm_shutdown_warning_sct_index and
  8    11*            dm_user_shutdown_sct_index for handling of Data Management
  8    12*            shutdown.
  8    13*08/22/84 by R. Michael Tague:  Removed dm_shutdown_warning_sct_index and
  8    14*            dm_user_shutdown_sct_index.  Added
  8    15*            system_shutdown_scheduled_sct_index and
  8    16*            dm_shutdown_scheduled_sct_index.
  8    17**/
  8    18 
  8    19 
  8    20 /****^  HISTORY COMMENTS:
  8    21*  1) change(85-11-13,Herbst), approve(87-07-21,MCR7697),
  8    22*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
  8    23*     Add system_message_sct_index.
  8    24*                                                   END HISTORY COMMENTS */
  8    25 
  8    26 
  8    27 dcl  (
  8    28      shutdown_sct_index	        init (0),
  8    29      store_sct_index	        init (1),
  8    30      mme1_sct_index		        init (2),
  8    31      fault_tag_1_sct_index	        init (3),
  8    32      timer_runout_sct_index	        init (4),
  8    33      command_sct_index	        init (5),
  8    34      derail_sct_index	        init (6),
  8    35      lockup_sct_index	        init (7),
  8    36      connect_sct_index	        init (8),
  8    37      parity_sct_index	        init (9),
  8    38      illegal_procedure_sct_index      init (10),
  8    39      op_not_complete_sct_index        init (11),
  8    40      startup_sct_index	        init (12),
  8    41      ovrflo_sct_index	        init (13),
  8    42      zerodivide_sct_index	        init (14),
  8    43      execute_sct_index	        init (15),
  8    44      seg_fault_error_sct_index        init (16),
  8    45      page_fault_error_sct_index       init (17),
  8    46      directed_fault_2_sct_index       init (18),
  8    47      directed_fault_3_sct_index       init (19),
  8    48      accessviolation_sct_index        init (20),
  8    49      mme2_sct_index		        init (21),
  8    50      mme3_sct_index		        init (22),
  8    51      mme4_sct_index		        init (23),
  8    52      linkage_error_sct_index	        init (24),
  8    53      fault_tag_3_sct_index	        init (25),
  8    54      undefined_fault_sct_index        init (26),
  8    55      trouble_sct_index	        init (31),
  8    56      illegal_opcode_sct_index	        init (32),
  8    57      simfault_000000_sct_index        init (33),
  8    58      illegal_modifier_sct_index       init (34),
  8    59      illegal_ring_order_sct_index     init (35),
  8    60      not_in_execute_bracket_sct_index init (36),
  8    61      no_execute_permission_sct_index  init (37),
  8    62      not_in_read_bracket_sct_index    init (38),
  8    63      no_read_permission_sct_index     init (39),
  8    64      not_in_write_bracket_sct_index   init (40),
  8    65      no_write_permission_sct_index    init (41),
  8    66      not_a_gate_sct_index	        init (42),
  8    67      not_in_call_bracket_sct_index    init (43),
  8    68      outward_call_sct_index	        init (44),
  8    69      bad_outward_call_sct_index       init (45),
  8    70      inward_return_sct_index	        init (46),
  8    71      cross_ring_transfer_sct_index    init (47),
  8    72      ring_alarm_fault_sct_index       init (48),
  8    73      am_fault_sct_index	        init (49),
  8    74      out_of_bounds_sct_index	        init (50),
  8    75      fixedoverflow_sct_index	        init (51),
  8    76      overflow_sct_index	        init (52),
  8    77      underflow_sct_index	        init (53),
  8    78      stringsize_sct_index	        init (54),
  8    79      other_illegal_proc_sct_index     init (55),
  8    80      storage_sct_index	        init (56),
  8    81      packed_pointer_fault_sct_index   init (57),
  8    82      lot_fault_sct_index	        init (58),
  8    83      isot_fault_sct_index	        init (59),
  8    84      system_packed_pointer_sct_index  init (60),
  8    85      quit_sct_index		        init (61),
  8    86      alrm_sct_index		        init (62),
  8    87      cput_sct_index		        init (63),
  8    88      record_quota_overflow_sct_index  init (64),
  8    89      size_sct_index		        init (65),
  8    90      neti_sct_index		        init (66),
  8    91      other_command_sct_index	        init (67),
  8    92      susp_sct_index		        init (68),
  8    93      term_sct_index		        init (69),
  8    94      wkp_sct_index		        init (70),
  8    95      undefined_pointer_sct_index      init (71),
  8    96      pgt_sct_index		        init (72),
  8    97      system_shutdown_scheduled_sct_index
  8    98 	                            init (73),
  8    99      dm_shutdown_scheduled_sct_index  init (74),
  8   100      system_message_sct_index	        init (75)
  8   101      )			        fixed bin (17) int static options (constant);
  8   102 
  8   103 /* END INCLUDE FILE  static_handlers.incl.pl1 */
      284 
      285 
      286 /* BEGIN MESSAGE DOCUMENTATION
      287*
      288*   Message:
      289*   makestack: error from set$max_length_ptr on STACKNAME.
      290*
      291*   S:	$term
      292*
      293*   T:	$init
      294*   Process/ring initialization.  Just prior to using a new ring.
      295*
      296*   M:	The process directory is probably messed up.
      297*
      298*   A:	Ignore unless it's the initializer, in which case bring the system back up.
      299*   If problem persists, contact the system administrator.
      300*
      301*   Message:
      302*   makestack: error appending STACKNAME
      303*
      304*   S:	$term
      305*
      306*   T:	$init
      307*   Process/ring initialization.  Just prior to using a new ring.
      308*
      309*   M:	The process directory is probably messed up.
      310*
      311*   A:	Ignore unless it's the initializer, in which case bring the system back up.
      312*   If problem persists, contact the system administrator.
      313*
      314*   Message:
      315*   makestack: error getting bit count for original prelinked STACK_NAME
      316*
      317*   S:	$term
      318*
      319*   T:	$init
      320*   Process/ring initialization.  Just prior to using a new ring.
      321*
      322*   M:	A directory containing a prelinked subsystem is probably messed up.
      323*
      324*   A:	The directory should be prelinked again.
      325*
      326*   Message:
      327*   makestack: error initiating STACKNAME
      328*
      329*   S:	$term
      330*
      331*   T:	$init
      332*   Process/ring initialization.  Just prior to using a new ring.
      333*
      334*   A:	Ignore unless it's the initializer, in which case bring the system back up.
      335*   If problem persists, contact the system administrator.
      336*
      337*   Message:
      338*   makestack: error finding DIRNAME>ENAME for STACKNAME.
      339*
      340*   S:	$term
      341*
      342*   T:	$init
      343*   Process/ring initialization.
      344*
      345*   A:	Ignore unless it's the initializer, in which case bring the system back up.
      346*   If problem persists, contact the system administrator.
      347*
      348*   Message:
      349*   makestack: error from initiate_search_rules.
      350*
      351*   S:	$term
      352*
      353*   T:	Process/ring initialization.  Just prior to using new ring.
      354*
      355*   M:	The default search rules are missing from ahd (active hardcore data).
      356*   These are usually loaded by the command set_system_search_rules.
      357*
      358*   A:	$contact_sa
      359*
      360*   END MESSAGE DOCUMENTATION */
      361 
      362      end makestack;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.6  makestack.pl1                     >spec>install>1110>makestack.pl1
236          1    01/27/78  1711.4  rnt.incl.pl1                      >ldd>include>rnt.incl.pl1
238          2    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
279          3    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
280          4    03/16/89  2012.8  create_branch_info.incl.pl1       >ldd>include>create_branch_info.incl.pl1
281          5    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
282          6    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
283          7    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
284          8    08/06/87  0913.5  static_handlers.incl.pl1          >ldd>include>static_handlers.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
REW_ACCESS                             constant        bit(3)                   initial packed unaligned dcl 3-11 ref 135
a_ring_num                             parameter       fixed bin(3,0)           dcl 46 ref 43 115
active_all_rings_data$stack_base_segno
                                000014 external static fixed bin(18,0)          dcl 77 ref 116
addr                                                   builtin function         dcl 102 ref 139 139 253 253 270 270
addrel                                                 builtin function         dcl 102 ref 175 178 180 182 184 186 209
ainfo                           000232 automatic       structure                level 1 dcl 225 set ref 253 253
append$create_branch_           000034 constant        entry                    external dcl 88 ref 139
area_control                           based           structure                level 1 dcl 2-20
area_info                              based           structure                level 1 dcl 2-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 2-3 ref 246
areap                                  based           pointer                  level 2 in structure "rnt" dcl 1-9 in procedure
                                                                                  "initialize_rnt" set ref 261*
areap                    16     000232 automatic       pointer                  level 2 in structure "ainfo" dcl 225 in procedure
                                                                                  "initialize_rnt" set ref 252* 259 261
based_rnt_area                         based           area(1024)               dcl 1-7 ref 252 259
baseno                                                 builtin function         dcl 102 ref 118
baseptr                                                builtin function         dcl 102 ref 116
call_offset                            constant        fixed bin(17,0)          initial dcl 7-78 ref 178
call_op_ptr              36            based           pointer                  level 2 dcl 7-26 set ref 178*
clr_ptr                  10            based           pointer                  level 2 dcl 7-26 ref 252
code                            000207 automatic       fixed bin(35,0)          dcl 55 set ref 139* 140 141* 144* 146 147* 150* 151
                                                                                  151* 162* 191* 194* 196* 214* 215 216* 253* 254
                                                                                  270* 271 272*
control                   1     000232 automatic       structure                level 2 dcl 225 set ref 247*
create_branch_info                     based           structure                level 1 dcl 4-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 4-35 ref 133
default_rules                   000000 constant        structure                level 1 dcl 240 set ref 270 270
define_area_                    000060 constant        entry                    external dcl 231 ref 253
defname                                parameter       char                     packed unaligned dcl 213 set ref 212 214* 216*
dirname                         000103 automatic       char(168)                packed unaligned dcl 55 set ref 129* 139* 144*
ect_ptr                  64            based           pointer                  level 2 dcl 7-26 set ref 154*
entry_offset                           constant        fixed bin(17,0)          initial dcl 7-78 ref 186
entry_op_ptr             46            based           pointer                  level 2 dcl 7-26 set ref 186*
error_table_$invalid_stack_creation
                                000052 external static fixed bin(35,0)          dcl 100 set ref 142* 148* 217*
error_table_$termination_requested
                                000054 external static fixed bin(35,0)          dcl 229 set ref 254* 273*
fixed                                                  builtin function         dcl 102 ref 118
flags                           000022 external static bit(1)                   array level 2 packed packed unaligned dcl 80 set ref
                                                                                  123* 159*
initiate                        000036 constant        entry                    external dcl 88 ref 144
initiate_search_rules$init_ring 000062 constant        entry                    external dcl 233 ref 270
insert                    2            based           structure                level 3 dcl 1-9
instruction                            based           structure                level 1 dcl 48
isot_fault_sct_index                   constant        fixed bin(17,0)          initial dcl 8-27 ref 195
level$get                       000024 constant        entry                    external dcl 88 ref 127
level$set                       000026 constant        entry                    external dcl 88 ref 128 206
link_man$get_initial_linkage    000030 constant        entry                    external dcl 88 ref 158
link_snap$make_ptr              000032 constant        entry                    external dcl 88 ref 191 194 196 214
local_create_branch_info        000164 automatic       structure                level 1 dcl 55 set ref 132* 139 139
lot                                    based           structure                level 1 dcl 5-6
lot_fault                              constant        bit(36)                  initial dcl 5-9 ref 160
lot_fault_sct_index                    constant        fixed bin(17,0)          initial dcl 8-27 ref 197
lot_ptr                  26            based           pointer                  level 2 dcl 7-26 ref 160
lp                                     based           pointer                  array level 2 packed packed unaligned dcl 5-6 set
                                                                                  ref 160*
meters                    2            based           structure                level 2 dcl 1-9
mode                      2     000164 automatic       bit(3)                   level 2 packed packed unaligned dcl 55 set ref 135*
name_hash_table          12            based           offset                   array level 2 dcl 1-9 set ref 263*
next_sp                  22            based           pointer                  level 2 dcl 6-36 set ref 209*
no_write_permission_sct_index          constant        fixed bin(17,0)          initial dcl 8-27 ref 192
not_in_write_bracket_sct_index         constant        fixed bin(17,0)          initial dcl 8-27 ref 193
null                                                   builtin function         dcl 102 ref 122 154 191 191 194 194 196 196 208 214
                                                                                  214 263 264 265
null_ptr                 20            based           pointer                  level 2 dcl 7-26 set ref 122* 154*
owner                     2     000232 automatic       char(32)                 level 2 packed packed unaligned dcl 225 set ref 250*
parent_ac_sw              1(04) 000164 automatic       bit(1)                   level 3 packed packed unaligned dcl 55 set ref 134*
pds$prelinked_ring              000012 external static bit(1)                   array packed unaligned dcl 76 ref 120
pds$process_dir_name            000016 external static char(32)                 packed unaligned dcl 78 ref 129
pds$process_group_id            000020 external static char(32)                 packed unaligned dcl 79 ref 137
pds$stacks                      000010 external static pointer                  array dcl 75 set ref 116*
pds$useable_lot                 000022 external static structure                level 1 dcl 80
pl1_op_ptr                      000160 automatic       pointer                  dcl 55 set ref 169* 175 177
pl1_operators_ptr        34            based           pointer                  level 2 dcl 7-26 set ref 177*
prev_sp                  20            based           pointer                  level 2 dcl 6-36 set ref 208*
ptr                                                    builtin function         dcl 102 ref 156 178 180 182 184 186 192 193 195 197
push_offset                            constant        fixed bin(17,0)          initial dcl 7-78 ref 180
push_op_ptr              40            based           pointer                  level 2 dcl 7-26 set ref 180*
ref_name_$insert                000040 constant        entry                    external dcl 88 ref 162
refname                                parameter       char                     packed unaligned dcl 213 set ref 212 214* 216*
rel                                                    builtin function         dcl 102 ref 192 193 195 197
return_no_pop_offset                   constant        fixed bin(17,0)          initial dcl 7-78 ref 184
return_no_pop_op_ptr     44            based           pointer                  level 2 dcl 7-26 set ref 184*
return_offset                          constant        fixed bin(17,0)          initial dcl 7-78 ref 182
return_op_ptr            42            based           pointer                  level 2 dcl 7-26 set ref 182*
ring_num                        000100 automatic       fixed bin(3,0)           dcl 55 set ref 115* 116 116 120 123 128* 130 136
                                                                                  158* 159
rings                     3     000164 automatic       fixed bin(3,0)           array level 2 dcl 55 set ref 136*
rnt                                    based           structure                level 1 dcl 1-9 set ref 259 260*
rnt_area_size             7            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 262*
rnt_ptr                  62            based           pointer                  level 2 dcl 7-26 set ref 266*
rnt_space                              based           bit(36)                  array dcl 224 ref 251 252
rntp                            000256 automatic       pointer                  dcl 1-5 set ref 259* 260 261 262 263 264 265 266
save_val                        000101 automatic       fixed bin(3,0)           dcl 55 set ref 127* 206*
sb                              000212 automatic       pointer                  dcl 7-24 set ref 116* 118 122 144* 150* 154 154 156
                                                                                  156 156 156 160 166 167 168 177 178 180 182 184
                                                                                  186 192 192 193 193 195 195 197 197 207 209 252
                                                                                  266
sct_ptr                  54            based           pointer                  level 2 dcl 7-26 ref 192 193 195 197
sctp                                   based           pointer                  array packed unaligned dcl 55 set ref 192* 193* 195*
                                                                                  197*
segno                           000102 automatic       fixed bin(17,0)          dcl 55 set ref 118* 160 162*
segno_hash_table        212            based           offset                   array level 2 dcl 1-9 set ref 264*
set$max_length_ptr              000042 constant        entry                    external dcl 88 ref 150
signal_ptr               30            based           pointer                  level 2 dcl 7-26 set ref 166*
size                     13     000232 automatic       fixed bin(18,0)          level 2 in structure "ainfo" dcl 225 in procedure
                                                                                  "initialize_rnt" set ref 251* 262
size                                                   builtin function         dcl 102 in procedure "makestack" ref 156
size                                                   builtin function         dcl 227 in procedure "initialize_rnt" ref 251
sp                              000210 automatic       pointer                  dcl 6-31 set ref 207* 208 209
srulep                   10            based           pointer                  level 2 dcl 1-9 set ref 265*
stack_begin_ptr          22            based           pointer                  level 2 dcl 7-26 set ref 156*
stack_end_ptr            24            based           pointer                  level 2 dcl 7-26 set ref 156* 207 209
stack_frame                            based           structure                level 1 dcl 6-36
stack_frame_min_length                 constant        fixed bin(17,0)          initial dcl 6-33 ref 209
stack_header                           based           structure                level 1 dcl 7-26 set ref 156
stack_name                      000156 automatic       char(8)                  packed unaligned dcl 55 set ref 130* 139* 141* 144*
                                                                                  147* 151* 162 216*
string                                                 builtin function         dcl 102 set ref 247*
substr                                                 builtin function         dcl 102 ref 130
switches                  1     000164 automatic       structure                level 2 packed packed unaligned dcl 55
sys_info$default_stack_length   000050 external static fixed bin(19,0)          dcl 99 set ref 150*
syserr$error_code               000064 constant        entry                    external dcl 234 in procedure "initialize_rnt" ref
                                                                                  272
syserr$error_code               000044 constant        entry                    external dcl 88 in procedure "makestack" ref 141 147
                                                                                  151 216
system                    1(05) 000232 automatic       bit(1)                   level 3 packed packed unaligned dcl 225 set ref 249*
terminate_proc                  000056 constant        entry                    external dcl 230 in procedure "initialize_rnt" ref
                                                                                  254 273
terminate_proc                  000046 constant        entry                    external dcl 88 in procedure "makestack" ref 142 148
                                                                                  217
tra_offset                             based           bit(18)                  level 2 packed packed unaligned dcl 48 ref 178 180
                                                                                  182 184 186
trans_op_tv_ptr          50            based           pointer                  level 2 dcl 7-26 set ref 168*
tv_offset                              constant        fixed bin(17,0)          initial dcl 7-72 ref 175
unspec                                                 builtin function         dcl 102 set ref 132* 160* 260*
unwinder_ptr             56            based           pointer                  level 2 dcl 7-26 set ref 167*
userid                    6     000164 automatic       char(32)                 level 2 dcl 55 set ref 137*
version                         000232 automatic       fixed bin(17,0)          level 2 in structure "ainfo" dcl 225 in procedure
                                                                                  "initialize_rnt" set ref 246*
version                         000164 automatic       fixed bin(17,0)          level 2 in structure "local_create_branch_info"
                                                                                  dcl 55 in procedure "makestack" set ref 133*
workptr                         000162 automatic       pointer                  dcl 55 set ref 175* 178 178 180 180 182 182 184 184
                                                                                  186 186 191* 192 193 194* 195 196* 197 214* 219
zero_on_free              1(02) 000232 automatic       bit(1)                   level 3 packed packed unaligned dcl 225 set ref 248*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 6-19
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 3-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 3-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 3-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 3-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 3-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 6-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 6-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 6-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 6-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 6-27
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 3-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 3-36
accessviolation_sct_index              internal static fixed bin(17,0)          initial dcl 8-27
alrm_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
am_fault_sct_index                     internal static fixed bin(17,0)          initial dcl 8-27
area_infop                             automatic       pointer                  dcl 2-5
bad_outward_call_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
command_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
connect_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
cput_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
cross_ring_transfer_sct_index          internal static fixed bin(17,0)          initial dcl 8-27
derail_sct_index                       internal static fixed bin(17,0)          initial dcl 8-27
directed_fault_2_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
directed_fault_3_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
dm_shutdown_scheduled_sct_index        internal static fixed bin(17,0)          initial dcl 8-27
execute_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
fault_tag_1_sct_index                  internal static fixed bin(17,0)          initial dcl 8-27
fault_tag_3_sct_index                  internal static fixed bin(17,0)          initial dcl 8-27
fixedoverflow_sct_index                internal static fixed bin(17,0)          initial dcl 8-27
illegal_modifier_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
illegal_opcode_sct_index               internal static fixed bin(17,0)          initial dcl 8-27
illegal_procedure_sct_index            internal static fixed bin(17,0)          initial dcl 8-27
illegal_ring_order_sct_index           internal static fixed bin(17,0)          initial dcl 8-27
inward_return_sct_index                internal static fixed bin(17,0)          initial dcl 8-27
isot                                   based           structure                level 1 dcl 5-13
isot1                                  based           structure                array level 1 dcl 5-16
isotp                                  automatic       pointer                  dcl 5-12
linkage_error_sct_index                internal static fixed bin(17,0)          initial dcl 8-27
lockup_sct_index                       internal static fixed bin(17,0)          initial dcl 8-27
lotp                                   automatic       pointer                  dcl 5-4
lth                                    automatic       fixed bin(17,0)          dcl 1-6
mme1_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
mme2_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
mme3_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
mme4_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
neti_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
no_execute_permission_sct_index        internal static fixed bin(17,0)          initial dcl 8-27
no_read_permission_sct_index           internal static fixed bin(17,0)          initial dcl 8-27
not_a_gate_sct_index                   internal static fixed bin(17,0)          initial dcl 8-27
not_in_call_bracket_sct_index          internal static fixed bin(17,0)          initial dcl 8-27
not_in_execute_bracket_sct_index       internal static fixed bin(17,0)          initial dcl 8-27
not_in_read_bracket_sct_index          internal static fixed bin(17,0)          initial dcl 8-27
op_not_complete_sct_index              internal static fixed bin(17,0)          initial dcl 8-27
other_command_sct_index                internal static fixed bin(17,0)          initial dcl 8-27
other_illegal_proc_sct_index           internal static fixed bin(17,0)          initial dcl 8-27
out_of_bounds_sct_index                internal static fixed bin(17,0)          initial dcl 8-27
outward_call_sct_index                 internal static fixed bin(17,0)          initial dcl 8-27
overflow_sct_index                     internal static fixed bin(17,0)          initial dcl 8-27
ovrflo_sct_index                       internal static fixed bin(17,0)          initial dcl 8-27
packed_pointer_fault_sct_index         internal static fixed bin(17,0)          initial dcl 8-27
page_fault_error_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
parity_sct_index                       internal static fixed bin(17,0)          initial dcl 8-27
pds$processid                          external static bit(36)                  dcl 232
pgt_sct_index                          internal static fixed bin(17,0)          initial dcl 8-27
quit_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
record_quota_overflow_sct_index        internal static fixed bin(17,0)          initial dcl 8-27
ring_alarm_fault_sct_index             internal static fixed bin(17,0)          initial dcl 8-27
rnte                                   based           structure                level 1 dcl 1-24
rntep                                  automatic       pointer                  dcl 1-5
seg_fault_error_sct_index              internal static fixed bin(17,0)          initial dcl 8-27
shutdown_sct_index                     internal static fixed bin(17,0)          initial dcl 8-27
simfault_000000_sct_index              internal static fixed bin(17,0)          initial dcl 8-27
size_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
stack_frame_flags                      based           structure                level 1 dcl 6-64
stack_header_overlay                   based           fixed bin(17,0)          array dcl 7-94
startup_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
storage_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
store_sct_index                        internal static fixed bin(17,0)          initial dcl 8-27
stringsize_sct_index                   internal static fixed bin(17,0)          initial dcl 8-27
susp_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
system_message_sct_index               internal static fixed bin(17,0)          initial dcl 8-27
system_packed_pointer_sct_index        internal static fixed bin(17,0)          initial dcl 8-27
system_shutdown_scheduled_sct_index    internal static fixed bin(17,0)          initial dcl 8-27
term_sct_index                         internal static fixed bin(17,0)          initial dcl 8-27
timer_runout_sct_index                 internal static fixed bin(17,0)          initial dcl 8-27
trouble_sct_index                      internal static fixed bin(17,0)          initial dcl 8-27
undefined_fault_sct_index              internal static fixed bin(17,0)          initial dcl 8-27
undefined_pointer_sct_index            internal static fixed bin(17,0)          initial dcl 8-27
underflow_sct_index                    internal static fixed bin(17,0)          initial dcl 8-27
wkp_sct_index                          internal static fixed bin(17,0)          initial dcl 8-27
zerodivide_sct_index                   internal static fixed bin(17,0)          initial dcl 8-27

NAMES DECLARED BY EXPLICIT CONTEXT.
get_ptr                         001341 constant        entry                    internal dcl 212 ref 166 167 168 169
initialize_rnt                  001473 constant        entry                    internal dcl 222 ref 161
makestack                       000236 constant        entry                    external dcl 43

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2212        2300    1676        2222
Length      2660    1676        66         343     313           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
makestack                           344 external procedure  is an external procedure.  
get_ptr                                 internal procedure  shares stack frame of external procedure makestack.  
initialize_rnt                          internal procedure  shares stack frame of external procedure makestack.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
makestack                000100 ring_num                    makestack
                         000101 save_val                    makestack
                         000102 segno                       makestack
                         000103 dirname                     makestack
                         000156 stack_name                  makestack
                         000160 pl1_op_ptr                  makestack
                         000162 workptr                     makestack
                         000164 local_create_branch_info    makestack
                         000207 code                        makestack
                         000210 sp                          makestack
                         000212 sb                          makestack
                         000232 ainfo                       initialize_rnt
                         000256 rntp                        initialize_rnt

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
append$create_branch_         define_area_                  initiate
initiate_search_rules$init_ring                             level$get                     level$set
link_man$get_initial_linkage  link_snap$make_ptr            ref_name_$insert              set$max_length_ptr
syserr$error_code             syserr$error_code             terminate_proc                terminate_proc

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data$stack_base_segno                      error_table_$invalid_stack_creation
error_table_$termination_requested                          pds$prelinked_ring            pds$process_dir_name
pds$process_group_id          pds$stacks                    pds$useable_lot               sys_info$default_stack_length




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000233       115 000243       116 000246       118 000256       120 000262       122 000270       123 000273
    124 000277       127 000300       128 000306       129 000315       130 000322       132 000334       133 000337
    134 000341       135 000343       136 000345       137 000357       139 000364       140 000412       141 000414
    142 000446       144 000455       146 000522       147 000524       148 000556       150 000565       151 000600
    154 000634       156 000640       158 000645       159 000654       160 000662       161 000666       162 000667
    166 000707       167 000732       168 000762       169 001010       175 001027       177 001032       178 001035
    180 001044       182 001053       184 001062       186 001071       191 001100       192 001145       193 001160
    194 001166       195 001233       196 001246       197 001305       206 001320       207 001327       208 001332
    209 001334       362 001340       212 001341       214 001357       215 001413       216 001415       217 001460
    219 001467       222 001473       246 001474       247 001476       248 001477       249 001501       250 001503
    251 001506       252 001510       253 001516       254 001531       259 001542       260 001547       261 001552
    262 001554       263 001556       264 001570       265 001602       266 001604       270 001606       271 001621
    272 001623       273 001650       276 001657


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
