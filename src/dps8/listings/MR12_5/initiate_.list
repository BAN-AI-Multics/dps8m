	COMPILATION LISTING OF SEGMENT initiate_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1046.1 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* format: off */  /* This program was formatted via emacs. */
       10 
       11 initiate_:
       12 initiate:
       13     procedure (a_dname, a_ename, a_rname, a_segsw, a_copysw, a_segptr, a_code);
       14 
       15 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       16 /*							       */
       17 /* History of earlier versions of the program:			       */
       18 /* Modified on 05/74 by E Stone to call status_$long when copy made	       */
       19 /*    (to get curlen and to cause a branch update)		       */
       20 /* Modified by Kobziar July 74 to call new entry in access_mode	       */
       21 /*    and to add privileged initate entries			       */
       22 /* Modified on 03/76 by R. Bratt to check mountedness of LV before okaying   */
       23 /*    makeknown						       */
       24 /* Modified on 06/01/76 by R. Bratt to call find_$finished		       */
       25 /* Modified on 06/02/76 by R. Bratt to cleanup a piece of trash!	       */
       26 /* Modified 760317 by L. Scheffler to properly call dir_control_error	       */
       27 /*    entries						       */
       28 /* Modified on 03/29/77 by M. Weaver to set lot fault when segment is first  */
       29 /*    initiated in ring					       */
       30 /* Modified on 78/02/21 by M. Weaver to call link_man$grow_lot at proper     */
       31 /*    boundary						       */
       32 /* Modified on 79/08/29 by Mike Grady to fix bug handling reserved segno's   */
       33 /*    and copy sw						       */
       34 /* Modified on 81/04/06 by J. Bongiovanni to fix max lot size check	       */
       35 /* Modified May 1981 by C. Hornig to remove references to the copy switch.   */
       36 /* Modified 04/30/84 by S. Herbst to add $get_segment_ptr_path	       */
       37 /* Modified 07/18/84 by Keith Loepere to use the new dc_find.	       */
       38 /* Modified 10/19/84 by Keith Loepere to do the right thing for initiating   */
       39 /*    directories.						       */
       40 /*							       */
       41 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       42 
       43 
       44 /****^  HISTORY COMMENTS:
       45*  1) change(85-12-10,GDixon), approve(86-08-09,MCR7388),
       46*     audit(86-09-12,Farley), install(86-09-08,MR12.0-1150):
       47*     Completely rewritten to:
       48*      a) improve program structure and reduce number of switches used in code;
       49*      b) keep directory locked while calling makeknown_, so that the pointer to
       50*         dir entry remains valid;
       51*      c) use dc_find$finished for most directory unlocking.
       52*                                                   END HISTORY COMMENTS */
       53 
       54 
       55 /* Parameters */
       56 
       57 dcl  a_code fixed bin (35) parameter;
       58 dcl  a_copysw fixed bin (2) parameter;
       59 dcl  a_dname char (*) parameter;
       60 dcl  a_dp ptr parameter;
       61 dcl  a_ename char (*) parameter;
       62 dcl  a_rname char (*) parameter;
       63 dcl  a_count fixed bin (17);
       64 dcl  a_segptr ptr parameter;
       65 dcl  a_segsw fixed bin (1) parameter;
       66 dcl  a_uid bit (36) parameter;
       67 
       68 /* Variables */
       69 
       70 dcl  1 in aligned,				/* copies of input parms.  */
       71        2 segp ptr,
       72        2 dirp ptr,
       73        2 dname char(168) unal,
       74        2 ename char(32) unal,
       75        2 rname char(32) varying;
       76 dcl  1 entrypoint aligned,			/* per-entrypoint controls */
       77        2 dc_find entry (char(168), char(32), ptr, fixed bin(35)) variable,
       78        2 should_call_find_finished bit(1),
       79        2 should_unlock_dir bit(1),
       80        2 priv bit(1);
       81 dcl  1 seg aligned,				/* intermediate data for   */
       82        2 dirp ptr,				/* segment being initiated.*/
       83        2 entp ptr,
       84        2 directory bit(1),
       85        2 hash_bucket fixed bin(17);
       86 dcl  1 out aligned,				/* copies of output data.  */
       87        2 segp ptr,
       88        2 bc fixed bin(24),
       89        2 uid bit(36),
       90        2 code fixed bin(35);
       91 
       92 /* External */
       93 
       94 dcl  error_table_$dirseg external fixed bin (35);
       95 dcl  error_table_$invalid_copy external fixed bin (35);
       96 dcl  error_table_$seg_unknown external fixed bin (35);
       97 dcl  error_table_$segknown external fixed bin (35);
       98 
       99 /* Entries */
      100 
      101 dcl  kstsrch entry (bit (36) aligned, fixed bin (17), ptr);
      102 
      103 /* Misc */
      104 
      105 dcl  (addr, baseno, baseptr, fixed, null, ptr, rtrim, unspec) builtin;
      106 dcl  (FALSE init("0"b),
      107       TRUE  init("1"b)) bit(1) int static options(constant);
      108 
      109 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      110 /*							       */
      111 /* NAME:	initiate						       */
      112 /*							       */
      113 /* This module is a primitive which calls other routines to make a segment   */
      114 /* known, i.e., to assign a segment number to the segment or a copy of the   */
      115 /* segment.						       */
      116 /*							       */
      117 /* ENTRY:	initiate						       */
      118 /*							       */
      119 /* This is the main entrypoint.  Besides making a segment identified by      */
      120 /* pathname known (optionally by a given reference name), it allows the      */
      121 /* caller to optionally specify the segment number by which the segment      */
      122 /* will be known.  The copysw argument is obsolete; a value of 2 (always     */
      123 /* make a copy of the segment in the pdir) is diagnosed as an error;	       */
      124 /* otherwise the switch is ignored.				       */
      125 /*							       */
      126 /* USAGE: call initiate (a_dname, a_ename, a_rname, a_segsw, a_copysw,       */
      127 /*	  a_segptr, a_code);				       */
      128 /*							       */
      129 /* a_dname (char(*))					       */
      130 /*    pathname of parent directory of the segment to be initiated (Input)    */
      131 /* a_ename (char(*))					       */
      132 /*    entryname of the segment to be initiated (Input)		       */
      133 /* a_rname (char(*))					       */
      134 /*    reference name by which the segment is to be made known if this	       */
      135 /*    argument is of zero length, then the segment is made known by a null   */
      136 /*    name (Input)						       */
      137 /* a_segsw (fixed bin (1))					       */
      138 /*    reserve segment switch  (Input)				       */
      139 /*    (= 0 if no segment number reserved,			       */
      140 /*     = 1 if segment number reserved)				       */
      141 /* a_copysw (fixed bin (2))					       */
      142 /*    formerly copy switch (Input)				       */
      143 /*    (= 0 if default setting of copy switch to be used,		       */
      144 /*     = 1 if segment never to be copied,			       */
      145 /*     = 2 if segment always to be copied into process dir prior to	       */
      146 /*	 initiation. This alternative is no longer implemented.  It	       */
      147 /*	 produces an error.)				       */
      148 /* a_segptr (pointer)					       */
      149 /*    normally output.  If segsw = 1 then input pointer to previously known  */
      150 /*    segment (used to input reserve segment number) .		       */
      151 /* a_code (fixed bin (35))					       */
      152 /*    status code (Output)					       */
      153 /*							       */
      154 /* ENTRY: priv_init						       */
      155 /*							       */
      156 /* This entry is identical to the initiate entrypoint, except that it	       */
      157 /* ignores the impact of AIM and ring brackets when determining whether the  */
      158 /* user has access to initiate the segment.			       */
      159 /*							       */
      160 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      161 
      162 /* The real procedure statement is up above.  This one is useful documentation.
      163*
      164*initiate_:
      165*initiate:
      166*    proc (a_dname, a_ename, a_rname, a_segsw, a_copysw, a_segptr, a_code); */
      167 
      168     call setup_args$initiate();
      169     entrypoint.dc_find = dc_find$obj_initiate;
      170     go to INITIATE_COMMON;
      171 
      172 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      173 
      174 
      175 priv_init:
      176     entry (a_dname, a_ename, a_rname, a_segsw, a_copysw, a_segptr, a_code);
      177 
      178     call setup_args$initiate();
      179     entrypoint.dc_find = dc_find$obj_initiate_raw;
      180     entrypoint.priv = TRUE;
      181 
      182 INITIATE_COMMON:
      183     if out.code = 0 then do;
      184        call entrypoint.dc_find (in.dname, in.ename, seg.entp, out.code);
      185        if out.code = 0 then do;
      186 	entrypoint.should_call_find_finished = TRUE;
      187 	entrypoint.should_unlock_dir = FALSE;
      188 	call check_entry();
      189 	call make_entry_known_and_unlock_dir();
      190 	end;
      191        end;
      192     a_segptr = out.segp;
      193     a_code = out.code;
      194     return;
      195 
      196 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      197 
      198 
      199 
      200 
      201 
      202 setup_args$initiate:
      203     proc;
      204 
      205 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      206 /*							       */
      207 /* Input Args:						       */
      208 /* a_dname, a_ename, a_rname,					       */
      209 /* a_segsw, a_copysw, a_seg_ptr				       */
      210 /*    input parameters, to be copied and tested.  Meanings of these parms    */
      211 /*    are given in entrypoint descriptions above.			       */
      212 /*							       */
      213 /* Function:						       */
      214 /* 1) copy a_dname, a_ename, a_rname.				       */
      215 /* 2) copy, test and apply a_segsw to initial value of in.segp.	       */
      216 /* 3) initialize out.segp, out.bc out.uid & entrypoint.priv.	       */
      217 /* 4) copy and test a_copysw.  Set out.code according to test results.       */
      218 /*							       */
      219 
      220 /* Output Args:						       */
      221 /* in.dname, in.ename, in.rname				       */
      222 /*    copies of input parameters.				       */
      223 /* in.segp						       */
      224 /*    copy of a_segptr if a_segsw is on; otherwise set to null.	       */
      225 /* out.segp						       */
      226 /*    initialized to null (default output value if error occurs).	       */
      227 /* out.bc							       */
      228 /*    set to 0 (unused return argument).			       */
      229 /* out.uid						       */
      230 /*    set to "0"b (unused return argument).			       */
      231 /* out.code						       */
      232 /*    result of test of a_copysw.				       */
      233 /* entrypoint.priv						       */
      234 /*    set to off, assuming not entered at privileged		       */
      235 /*							       */
      236 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      237 
      238 dcl  copysw fixed bin (2);
      239 dcl  segsw fixed bin (1);
      240 
      241     copysw = a_copysw;
      242     segsw = a_segsw;
      243     in.dname = a_dname;
      244     in.ename = a_ename;
      245     in.rname = rtrim(a_rname);
      246 
      247     if segsw = 0 then			/* a_segptr can only be    */
      248        in.segp = null;			/* copied if segsw ^= 0.   */
      249     else					/* Otherwise, it must not  */
      250        in.segp = a_segptr;			/* be touched, since its   */
      251 					/* storage may not be in   */
      252 					/* ptr format.	       */
      253     out.segp = null;
      254     out.bc = 0;
      255     out.uid = "0"b;
      256     if copysw = 2 then 
      257        out.code = error_table_$invalid_copy;
      258     else 
      259        out.code = 0;
      260     entrypoint.priv = FALSE;
      261 
      262     end setup_args$initiate;
      263 
      264 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      265 
      266 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      267 
      268 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      269 /*							       */
      270 /* ENTRY:	initiate_count					       */
      271 /*							       */
      272 /* This entry is the same as initiate except that a bit count parameter      */
      273 /* replaces the a_segsw parm.					       */
      274 /*							       */
      275 /* USAGE:	call initiate$initiate_count				       */
      276 /*	  (a_dname, a_ename, a_rname, a_count, a_copysw, a_segptr, a_code);*/
      277 /*							       */
      278 /* a_count (fixed bin(24))					       */
      279 /*    bit count of initiated segment (Output)			       */
      280 /*							       */
      281 /* ENTRY: priv_init_count					       */
      282 /*							       */
      283 /* This entry is like initiate_count, except that it ignores the impact of   */
      284 /* AIM and ring brackets when determining whether the user has access to     */
      285 /* initiate the segment.					       */
      286 /*							       */
      287 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      288 
      289 initiate_count:
      290     entry (a_dname, a_ename, a_rname, a_count, a_copysw, a_segptr, a_code);
      291 
      292     call setup_args$initiate_count();
      293     entrypoint.dc_find = dc_find$obj_initiate;
      294     go to INITIATE_COUNT_COMMON;
      295 
      296 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      297 
      298 
      299 priv_init_count:
      300     entry (a_dname, a_ename, a_rname, a_count, a_copysw, a_segptr, a_code);
      301 
      302     call setup_args$initiate_count();
      303     entrypoint.dc_find = dc_find$obj_initiate_raw;
      304     entrypoint.priv = TRUE;
      305 
      306 INITIATE_COUNT_COMMON:
      307     if out.code = 0 then do;
      308        call entrypoint.dc_find (in.dname, in.ename, seg.entp, out.code);
      309        if out.code = 0 then do;
      310 	entrypoint.should_call_find_finished = TRUE;
      311 	entrypoint.should_unlock_dir = FALSE;
      312 	call check_entry();
      313 	call make_entry_known_and_unlock_dir();
      314 	end;
      315        end;
      316     a_count = out.bc;
      317     a_segptr = out.segp;
      318     a_code = out.code;
      319     return;
      320 
      321 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      322 
      323 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      324 
      325 setup_args$initiate_count:
      326     proc;
      327 
      328 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      329 /*							       */
      330 /* Input Args:						       */
      331 /* a_dname, a_ename, a_rname, a_copysw				       */
      332 /*    input parameters, to be copied and tested.  Meanings of these parms    */
      333 /*    are given in entrypoint descriptions above.			       */
      334 /*							       */
      335 /* Function:						       */
      336 /* 1) copy a_dname, a_ename, a_rname.				       */
      337 /* 2) initialize in.segp, out.segp, out.bc, out.uid & entrypoint.priv.       */
      338 /* 3) copy and test a_copysw.  Set out.code according to test results.       */
      339 /*							       */
      340 /* Output Args:						       */
      341 /* in.dname, in.ename, in.rname				       */
      342 /*    copies of input parameters.				       */
      343 /* in.segp						       */
      344 /*    set to null (no reserved segment number specified).		       */
      345 /* out.segp						       */
      346 /*    set to null (default output value if error occurs).		       */
      347 /* out.bc							       */
      348 /*    set to value for bit count to be output if error occurs (0).	       */
      349 /* out.uid						       */
      350 /*    set to "0"b (unused output value).			       */
      351 /* out.code						       */
      352 /*    result of test of a_copysw.				       */
      353 /* entrypoint.priv						       */
      354 /*    set to off, assuming not entered at privileged entrypoint.	       */
      355 /*							       */
      356 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      357 
      358 dcl  copysw fixed bin (2);
      359 
      360     copysw = a_copysw;
      361     in.dname = a_dname;
      362     in.ename = a_ename;
      363     in.rname = rtrim(a_rname);
      364     in.segp = null;
      365 
      366     out.segp = null;
      367     out.bc = 0;
      368     out.uid = "0"b;
      369     if copysw = 2 then 
      370        out.code = error_table_$invalid_copy;
      371     else 
      372        out.code = 0;
      373     entrypoint.priv = FALSE;
      374 
      375     end setup_args$initiate_count;
      376 
      377 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      378 
      379 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      380 
      381 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      382 /*							       */
      383 /* ENTRY:	initiate_seg_count					       */
      384 /*							       */
      385 /* This entry is the same as initiate_count except that it takes a	       */
      386 /* directory pointer instead of a directory path name.  It is used solely    */
      387 /* by fs_search.						       */
      388 /*							       */
      389 /* NOTE: a contract has been made that this entry can only be called by      */
      390 /* fs_search.  dc_find knows this.  As such, dc_find does not do its normal  */
      391 /* name lookup access check for this routine, and merely returns no_info     */
      392 /* if the name doesn't exist or if the user doesn't have access.	       */
      393 /*							       */
      394 /* USAGE:	call initiate$initiate_seg_count			       */
      395 /*	  (a_dp, a_ename, a_rname, a_count, a_copysw, a_segptr, a_code);   */
      396 /*							       */
      397 /* a_dp (ptr)						       */
      398 /*    pointer to directory of entry ename. (Input)		       */
      399 /*							       */
      400 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      401 
      402 initiate_seg_count:
      403     entry (a_dp, a_ename, a_rname, a_count, a_copysw, a_segptr, a_code);
      404 
      405     call setup_args$initiate_seg_count();
      406     if out.code = 0 then do;
      407 
      408 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      409 /*							       */
      410 /* Note that dc_find$obj_initiate_for_linker_dp, knowing it is called only   */
      411 /* for fs_search, does not perform its normal name lookup access checks.     */
      412 /* If the entry is not found, dc_find will return no_info, as it will (for   */
      413 /* this one entry only) if the user lacks access to see the object.	       */
      414 /*							       */
      415 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      416 
      417        call dc_find$obj_initiate_for_linker_dp (in.dirp, in.ename, seg.entp, out.code);
      418        if out.code = 0 then do;
      419 	if in.dirp = null then do;
      420 
      421 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      422 /*							       */
      423 /* This means ename was a link to an object in another directory besides     */
      424 /* that pointed to by in.dirp.  Therefore, we cannot unlock the dir but      */
      425 /* must instead tell dc_find to do it.				       */
      426 /*							       */
      427 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      428 
      429 	   entrypoint.should_unlock_dir = FALSE;
      430 	   entrypoint.should_call_find_finished = TRUE;
      431 	   end;
      432 
      433 	else do;
      434 
      435 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      436 /*							       */
      437 /* This is the normal case, in which we can unlock in.dirp directly without  */
      438 /* having to call dc_find.					       */
      439 /*							       */
      440 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      441 
      442 	   entrypoint.should_call_find_finished = FALSE;
      443 	   entrypoint.should_unlock_dir = TRUE;
      444 	   end;
      445 
      446 	call check_entry();
      447 	call make_entry_known_and_unlock_dir();
      448 	end;
      449        end;
      450     a_count = out.bc;
      451     a_segptr = out.segp;
      452     a_code = out.code;
      453     return;
      454 
      455 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      456 
      457 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      458 
      459 setup_args$initiate_seg_count:
      460     proc;
      461 
      462 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      463 /*							       */
      464 /* Input Args:						       */
      465 /* a_dp, a_ename, a_rname,					       */
      466 /* a_copysw						       */
      467 /*    input parameters, to be copied and tested.  Meanings of these parms    */
      468 /*    are given in entrypoint descriptions above.			       */
      469 /*							       */
      470 /* Function:						       */
      471 /* 1) copy a_dp, a_ename, a_rname.				       */
      472 /* 2) initialize in.segp, out.segp, out.bc, out.uid & entrypoint.priv.       */
      473 /* 3) copy and test a_copysw.  Set out.code according to test results.       */
      474 /*							       */
      475 /* Output Args:						       */
      476 /* in.dirp, in.ename, in.rname				       */
      477 /*    copies of input parameters.				       */
      478 /* in.segp						       */
      479 /*    set to null (no reserved segment number specified).		       */
      480 /* out.segp						       */
      481 /*    set to null (default output value if error occurs).		       */
      482 /* out.bc							       */
      483 /*    set to value for bit count to be output if error occurs (0).	       */
      484 /* out.uid						       */
      485 /*    set to "0"b (unused output value).			       */
      486 /* out.code						       */
      487 /*    result of test of a_copysw.				       */
      488 /* entrypoint.priv						       */
      489 /*    set to off, not a privileged entrypoint.			       */
      490 /*							       */
      491 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      492 
      493 dcl  copysw fixed bin (2);
      494 
      495     in.dirp = a_dp;
      496     in.ename = a_ename;
      497     in.rname = rtrim(a_rname);
      498     in.segp = null;
      499 
      500     out.segp = null;
      501     out.bc = 0;
      502     out.uid = "0"b;
      503     copysw = a_copysw;
      504     if copysw = 2 then 
      505        out.code = error_table_$invalid_copy;
      506     else 
      507        out.code = 0;
      508     entrypoint.priv = FALSE;
      509 
      510     end setup_args$initiate_seg_count;
      511 
      512 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      513 
      514 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      515 
      516 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      517 /*							       */
      518 /* ENTRY: get_segment_ptr_path				       */
      519 /*							       */
      520 /* This entry point returns a ptr and uid if the segment is already	       */
      521 /* initiated; it returns an error if the segment is not already initiated.   */
      522 /*							       */
      523 /* USAGE: call initiate_$get_segment_ptr_path (a_dname, a_ename, a_segptr,   */
      524 /*	   a_uid, a_code);					       */
      525 /*							       */
      526 /* a_dname (char(*))					       */
      527 /*    parent directory. (Input)				       */
      528 /* a_ename (char(*))					       */
      529 /*    entry name. (Input)					       */
      530 /* a_segptr (ptr)						       */
      531 /*    pointer to the segment, or null. (Output)			       */
      532 /* a_uid (bit(36))						       */
      533 /*    file system uid. (Output)				       */
      534 /* a_code (fixed(35))					       */
      535 /*    zero or error_table_$seg_unknown. (Output)			       */
      536 /*							       */
      537 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      538 
      539 get_segment_ptr_path:
      540     entry (a_dname, a_ename, a_segptr, a_uid, a_code);
      541 
      542     call setup_args$get_segment_ptr_path();
      543     call dc_find$obj_initiate (in.dname, in.ename, seg.entp, out.code);
      544     if out.code = 0 then do;
      545        entrypoint.should_call_find_finished = TRUE;
      546        entrypoint.should_unlock_dir = FALSE;
      547        call check_entry();
      548        if seg.directory then do;
      549 	out.code = error_table_$dirseg;
      550 	out.uid = "0"b;
      551 	end;
      552        else do;
      553 	call kstsrch (out.uid, seg.hash_bucket, kstep);
      554 	if kstep = null then do;
      555 	   out.code = error_table_$seg_unknown;
      556 	   out.uid = "0"b;
      557 	   end;
      558 	else 
      559 	   out.segp = baseptr (kste.segno);
      560 	end;
      561        call unlock_dir();
      562        end;
      563     a_uid = out.uid;
      564     a_segptr = out.segp;
      565     a_code = out.code;
      566     return;
      567 
      568 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      569 
      570 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      571 
      572 
      573 setup_args$get_segment_ptr_path:
      574     proc;
      575 
      576 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      577 /*							       */
      578 /* Input Args:						       */
      579 /* a_dname, a_ename						       */
      580 /*    input parameters, to be copied.  Meanings of these parms are given in  */
      581 /*    entrypoint descriptions above.				       */
      582 /*							       */
      583 /* Function:						       */
      584 /* 1) copy a_dname and a_ename				       */
      585 /* 2) initialize in.segp, out.segp, out.bc, out.uid, out.code and	       */
      586 /*    entrypoint.priv.					       */
      587 /*							       */
      588 /* Output Args:						       */
      589 /* in.dname, in.ename					       */
      590 /*    copies of input parameters.				       */
      591 /* in.segp						       */
      592 /*    set to null (no reserved segment number specified).		       */
      593 /* out.segp						       */
      594 /*    set to null (default output value if segment not known).	       */
      595 /* out.bc							       */
      596 /*    set to 0 (unused return argument).			       */
      597 /* out.uid						       */
      598 /*    set to uid value to output if error occurs (0).		       */
      599 /* out.code						       */
      600 /*    set to 0.						       */
      601 /* entrypoint.priv						       */
      602 /*    set to off, not a privileged entrypoint.			       */
      603 /*							       */
      604 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      605 
      606     in.dname = a_dname;
      607     in.ename = a_ename;
      608     in.segp = null;
      609 
      610     out.segp = null;
      611     out.bc = 0;
      612     out.uid = "0"b;
      613     out.code = 0;
      614     entrypoint.priv = FALSE;
      615 
      616     end setup_args$get_segment_ptr_path;
      617 
      618 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      619 
      620 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      621 
      622 check_entry:
      623     proc;
      624 
      625 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      626 /*							       */
      627 /* Input Args:						       */
      628 /* seg.entp						       */
      629 /*    pointer to the dir branch for the entry to be initiated.	       */
      630 /*							       */
      631 /* Function:						       */
      632 /* 1) Check if target entry being initiated is the root dir.  If so	       */
      633 /*    fabricate information.					       */
      634 /* 2) Otherwise, extract output information from dir branch for the entry.   */
      635 /*							       */
      636 /* Output Args:						       */
      637 /* seg.dirp						       */
      638 /*    pointer to the containing dir.				       */
      639 /* seg.directory						       */
      640 /*    on if entry being initiated is a directory.			       */
      641 /* out.uid						       */
      642 /*    entry's unique ID					       */
      643 /* out.bc							       */
      644 /*    entry's bit count					       */
      645 /* entrypoint.should_call_find_finished,		       	       */
      646 /* entrypoint.should_unlock_dir				       */
      647 /*    switches controlling whether/how directory is unlocked.  These are     */
      648 /*    turned off if the entry is the root dir.			       */
      649 /*							       */
      650 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      651 
      652     if seg.entp = null then do;		/* root		       */
      653        seg.dirp = null;
      654        seg.directory = TRUE;
      655        out.uid = "777777777777"b3;
      656        out.bc = 0;
      657        entrypoint.should_call_find_finished,	/* didn't lock anything    */
      658 	entrypoint.should_unlock_dir = FALSE;
      659        end;
      660     else do;
      661        seg.dirp = ptr (seg.entp, 0);
      662        seg.directory = seg.entp -> entry.dirsw;
      663        out.uid = seg.entp -> entry.uid;
      664        out.bc = seg.entp -> entry.bc;
      665        end;
      666     end check_entry;
      667 
      668 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      669 
      670 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      671 
      672 make_entry_known_and_unlock_dir:
      673     proc;
      674 
      675 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      676 /*							       */
      677 /* Input Args:						       */
      678 /* in.segp						       */
      679 /*    reserved segment number to use for initiate_ entrypoint	       */
      680 /* in.rname						       */
      681 /*    name by which segment is to be referenced (for ref_name_$insert)       */
      682 /* seg.dirp						       */
      683 /*    pointer to dir containing entry.				       */
      684 /* seg.entp						       */
      685 /*    pointer to entry's dir branch.				       */
      686 /* seg.directory						       */
      687 /*    on if entry being initiated is a directory.			       */
      688 /* entrypoint.priv						       */
      689 /*    on if calling entrypoint is privileged (for call to makeknown_)	       */
      690 /* out.uid						       */
      691 /*    entry's unique ID (for call to makeknown_)			       */
      692 /*							       */
      693 /* Function:						       */
      694 /* 1) Ensures disk holding target entry is mounted.		       */
      695 /* 2) Makes target entry known to process.			       */
      696 /* 3) Unlocks containing directory.				       */
      697 /* 4) Adds reference name table (RNT) entry for the known segment.	       */
      698 /* 5) Sets LOT entry for the segment (in target ring) to lot_fault value.    */
      699 /*							       */
      700 /* Output Args:						       */
      701 /* out.segp						       */
      702 /*    pointer to initiated segment (remains unchanged if makeknown_ fails).  */
      703 /* out.bc							       */
      704 /*    bit count (set to 0 if makeknown_ fails).			       */
      705 /* out.code						       */
      706 /*    results from call to mountedp, makeknown_ and ref_name_$insert.	       */
      707 /*							       */
      708 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      709 
      710 /* Variables */
      711 dcl  ecode fixed bin (35);
      712 dcl  1 mk_info aligned like makeknown_info;
      713 dcl  ring fixed bin (3);
      714 dcl  segno fixed bin;
      715 dcl  use_count fixed bin (17);
      716 
      717 /* External */
      718 dcl  pds$stacks (0:7) ptr ext;
      719 dcl  1 pds$useable_lot aligned ext,
      720        2 flags (0:7) bit (1) unal;
      721 
      722 /* Entries */
      723 dcl  level$get entry returns (fixed bin (3));
      724 dcl  link_man$grow_lot entry (fixed bin (3));
      725 dcl  makeknown_ entry (ptr, fixed bin, fixed bin, fixed bin (35));
      726 dcl  mountedp entry (bit (36) aligned, fixed bin (35));
      727 dcl  ref_name_$insert entry (char (32) varying, fixed bin, fixed bin (35));
      728 
      729     if ^seg.directory then do;		/* ensure LV is mounted    */
      730        call mountedp (seg.dirp -> dir.sons_lvid, out.code);
      731        if out.code ^= 0 then do;
      732 	call unlock_dir();
      733 	out.bc = 0;			/* Don't return bit count  */
      734 	return;				/* if errors occur.	       */
      735 	end;
      736        end;
      737 
      738     unspec (mk_info) = FALSE;
      739     mk_info.uid = out.uid;
      740     mk_info.entryp = seg.entp;		/* dir locked, seg.entp    */
      741 					/* has been validated by   */
      742 					/*  dc_find.	       */
      743     mk_info.dirsw = seg.directory;
      744     mk_info.priv_init = entrypoint.priv;
      745     mk_info.allow_write = TRUE;
      746 
      747     if in.segp ^= null then do;
      748        mk_info.rsw = TRUE;
      749        segno = fixed (baseno (in.segp), 17);
      750        end;
      751     else mk_info.rsw = FALSE;
      752 
      753     call makeknown_ (addr (mk_info), segno, use_count, out.code);
      754     call unlock_dir();			/* The dir must stay       */
      755 					/* locked until after      */
      756     if out.code = 0 then;			/* makeknown_ returns, as  */
      757     else if out.code = error_table_$segknown then;/* per interface specs.    */
      758     else do;
      759        out.bc = 0;				/* Don't return bit count  */
      760        return;				/* if errors occur.	       */
      761        end;
      762     out.segp = baseptr (segno);		/* From this point on,     */
      763 					/* makeknown_ has succeeded*/
      764 
      765     if in.rname ^= "" then do;		/* Add ref name to segment.*/
      766        call ref_name_$insert (in.rname, segno, ecode);
      767        if ecode ^= 0 then out.code = ecode;	/* Be careful not to zero  */
      768        end;				/* segknown code needlessly*/
      769 
      770     if use_count = 1 then do;			/* Made known for first    */
      771        ring = level$get ();			/* time in a ring?	       */
      772        if pds$useable_lot.flags (ring) then do;	/* diddle user ring lot    */
      773 	if segno >= pds$stacks (ring) -> stack_header.cur_lot_size then
      774 	   if segno < pds$stacks (ring) -> stack_header.max_lot_size then do;
      775 	      call link_man$grow_lot (ring);
      776 	      unspec (pds$stacks (ring) -> stack_header.lot_ptr -> lot.lp (segno)) = lot_fault;
      777 					/* flag lot entry to tell  */
      778 	      end;			/* run unit seg is known.  */
      779 	   else;				/* high segno might be OK  */
      780 					/* if seg not linked to.   */
      781 	else  unspec (pds$stacks (ring) -> stack_header.lot_ptr -> lot.lp (segno)) = lot_fault;
      782 	end;
      783        end;
      784     end make_entry_known_and_unlock_dir;
      785 
      786 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      787 
      788 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      789 
      790 unlock_dir:
      791     proc;
      792 
      793 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      794 /*							       */
      795 /* Input Args:						       */
      796 /* seg.dirp						       */
      797 /*    pointer to dir containing entry.				       */
      798 /* seg.entp						       */
      799 /*    pointer to entry's dir branch.				       */
      800 /* entrypoint.should_call_find_finished				       */
      801 /*    on to call dc_find$finished to unlock and unhold dir.		       */
      802 /* entrypoint.should_unlock_dir				       */
      803 /*    on to call lock$unlock_dir to unlock dir.			       */
      804 /*							       */
      805 /* Function: unlock dir containing target entry.  Normally, it was locked    */
      806 /* by dc_find$obj_initiate, which also holds the directory (by incrementing  */
      807 /* its usage count) to keep it from being KST-garbage-collected.  So	       */
      808 /* dc_find$finished must be called to undo this dir holding.	       */
      809 /*							       */
      810 /* However, the linker calls $initiate_seg_count, which uses	       */
      811 /* dc_find$obj_initiate_for_linker_dp, which does NOT hold the containing    */
      812 /* dir unless ename matches a link in the containing dir and the link gets   */
      813 /* chased.  If no links were chased, then the dir is NOT held and	       */
      814 /* lock$dir_unlock can be called directly.  If links were chased, then       */
      815 /* dc_find$finished must be called to unhold the dir containing the chased   */
      816 /* link target.						       */
      817 /*							       */
      818 /* Finally, if the entry being initiated is the root, then there is no       */
      819 /* containing directory to unlock.  The input flags are set appropriately    */
      820 /* by callers to cause the correct operation to occur.		       */
      821 /*							       */
      822 /* Output Args:						       */
      823 /* entrypoint.should_call_find_finished,			       */
      824 /* entrypoint.should_unlock_dir				       */
      825 /*    turned off on output.					       */
      826 /*							       */
      827 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      828 
      829 /* Entries */
      830 
      831 dcl  lock$dir_unlock entry (pointer);
      832 
      833     if entrypoint.should_call_find_finished then
      834        call dc_find$finished (seg.entp, DC_FIND_UNLOCK_DIR);
      835     else if entrypoint.should_unlock_dir then
      836        call lock$dir_unlock(seg.dirp);
      837     entrypoint.should_call_find_finished, entrypoint.should_unlock_dir = FALSE;
      838 
      839     end unlock_dir;
      840 
      841 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
      842 
  1     1 /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      843 
      844 
  2     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      845 
      846 
  3     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      847 
      848 
  4     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  4     2 
  4     3 /*
  4     4*Modified March 1976 by R. Bratt 
  4     5*Modified November 1984 to remove hdr, Keith Loepere. */
  4     6 
  4     7 
  4     8 /****^  HISTORY COMMENTS:
  4     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  4    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  4    11*     Add warning on use of kste.entryp.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 dcl  pds$kstp ext ptr,
  4    16     (kstp, kstep) ptr;
  4    17 
  4    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  4    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  4    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  4    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  4    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  4    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  4    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  4    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  4    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  4    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  4    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  4    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  4    30     2 unused_2 bit (9) unaligned,
  4    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  4    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  4    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  4    34     2 end_of_kst bit (36);
  4    35 
  4    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  4    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  4    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  4    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  4    40     2 entryp ptr unaligned,				/* branch pointer */
  4    41 						/* See WARNING below for requirements to use entryp. */
  4    42     2 uid bit (36) aligned,				/* unique identifier */
  4    43     2 access_information unaligned,
  4    44       3 dtbm bit (36),				/* date time branch modified */
  4    45       3 extended_access bit (33),			/* extended access from the branch */
  4    46       3 access bit (3),				/* rew */
  4    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  4    48     2 pad1 bit (3) unaligned,
  4    49     2 flags unaligned,
  4    50       3 dirsw bit (1),				/* directory switch */
  4    51       3 allow_write bit (1),				/* set if initiated with write permission */
  4    52       3 priv_init bit (1),				/* privileged initiation */
  4    53       3 tms bit (1),				/* transparent modification switch */
  4    54       3 tus bit (1),				/* transparent usage switch */
  4    55       3 tpd bit (1),				/* transparent paging device switch */
  4    56       3 audit bit (1),				/* audit switch */
  4    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  4    58       3 pad bit (3),
  4    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  4    60 
  4    61 
  4    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    63 /*							       */
  4    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  4    65 /* entry associated with the kst entry, you must first validate its value    */
  4    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  4    67 /* the containing directory.  The containing directory must remain locked    */
  4    68 /* during the entire period when kste.entryp and the directory entry are     */
  4    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  4    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  4    71 /* directory since the dir entry could have been moved within the directory  */
  4    72 /* by another processor.					       */
  4    73 /*							       */
  4    74 /* If you only need a pointer to the directory containing the associated     */
  4    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  4    76 /*    pointer (kste.entryp, 0)				       */
  4    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  4    78 /*							       */
  4    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    80 
  4    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      849 
      850 
  5     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  5     2 /* modified by M. Weaver 3/77 */
  5     3 
  5     4 dcl  lotp ptr;
  5     5 
  5     6 dcl 1 lot based (lotp) aligned,
  5     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  5     8 
  5     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  5    10 						/* lot fault has fault code = 0 and offset = 0 */
  5    11 
  5    12 dcl  isotp ptr;
  5    13 dcl 1 isot based (isotp) aligned,
  5    14     2 isp (0:9999) ptr unaligned;
  5    15 
  5    16 dcl 1 isot1 (0 :9999) aligned based,
  5    17     2 flags unaligned,
  5    18       3 fault bit (2) unaligned,
  5    19       3 system bit (1) unaligned,
  5    20       3 mbz bit (6) unaligned,
  5    21     2 fault_code fixed bin (8) unaligned,
  5    22     2 static_offset bit (18) unaligned;
  5    23 
  5    24 
  5    25 /* END INCLUDE FILE  lot.incl.pl1 */
      851 
      852 
  6     1 /*  BEGIN INCLUDE FILE - - - makeknown_info.incl.pl1 - - - last modified March 1975 by R. Bratt - - - */
  6     2 /* Modified October 1984 for explicit activate flag and to remove 
  6     3*   detectable flag, Keith Loepere. */
  6     4 
  6     5 dcl  makeknown_infop ptr;
  6     6 
  6     7 dcl 1 makeknown_info aligned based (makeknown_infop),
  6     8     2 uid bit (36) aligned,
  6     9     2 entryp ptr unaligned,
  6    10     2 flags unaligned,
  6    11       3 dirsw bit (1),
  6    12       3 rsw bit (1),
  6    13       3 allow_write bit (1),
  6    14       3 priv_init bit (1),
  6    15       3 audit bit (1),
  6    16       3 activate bit (1);			/* Use only for directory initiation within directory control */
  6    17 
  6    18 /*   END INCLUDE FILE makeknown_info.incl.pl1 - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      853 
      854 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  7     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  7     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  7     4 /*	Modified April 1983 by C. Hornig for tasking */
  7     5 
  7     6 /****^  HISTORY COMMENTS:
  7     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  7     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  7     9*     added the heap_header_ptr definition.
  7    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  7    12*     Modified to support control point management.  These changes were actually
  7    13*     made in February 1985 by G. Palter.
  7    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  7    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  7    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  7    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  7    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  7    19*     (ITS pair).
  7    20*                                                   END HISTORY COMMENTS */
  7    21 
  7    22 /* format: style2 */
  7    23 
  7    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  7    25 
  7    26      dcl	   1 stack_header	      based (sb) aligned,
  7    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  7    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  7    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  7    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  7    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  7    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  7    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  7    34 	     2 pad4	      bit (2) unal,
  7    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  7    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  7    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  7    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  7    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  7    40 	     2 null_ptr	      ptr,		/*  (16)  */
  7    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  7    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  7    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  7    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  7    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  7    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  7    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  7    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  7    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  7    50 	     2 return_no_pop_op_ptr
  7    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  7    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  7    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  7    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  7    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  7    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  7    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  7    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  7    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  7    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  7    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  7    62 	     2 trace,
  7    63 	       3 frames,
  7    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  7    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  7    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  7    67 	     2 pad2	      bit (36),		/*  (61) */
  7    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  7    69 
  7    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  7    71 
  7    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  7    73 						/* (551) octal */
  7    74 
  7    75 
  7    76 /*	The following constants are offsets within this transfer vector table.  */
  7    77 
  7    78      dcl	   (
  7    79 	   call_offset	      fixed bin init (271),
  7    80 	   push_offset	      fixed bin init (272),
  7    81 	   return_offset	      fixed bin init (273),
  7    82 	   return_no_pop_offset   fixed bin init (274),
  7    83 	   entry_offset	      fixed bin init (275)
  7    84 	   )		      internal static;
  7    85 
  7    86 
  7    87 
  7    88 
  7    89 
  7    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  7    91*	move the whole stack header should use this overlay.
  7    92**/
  7    93 
  7    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  7    95 
  7    96 
  7    97 
  7    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      855 
      856      end initiate_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.0  initiate_.pl1                     >spec>install>1110>initiate_.pl1
843          1    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
845          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
847          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
849          4    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
851          5    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
853          6    01/30/85  1523.9  makeknown_info.incl.pl1           >ldd>include>makeknown_info.incl.pl1
855          7    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_UNLOCK_DIR              000000 constant        bit(1)                   initial dcl 1-13 set ref 833*
FALSE                                  constant        bit(1)                   initial packed unaligned dcl 106 ref 187 260 311 373
                                                                                  429 442 508 546 614 657 738 751 837
TRUE                            000000 constant        bit(1)                   initial packed unaligned dcl 106 ref 180 186 304 310
                                                                                  430 443 545 654 745 748
a_code                                 parameter       fixed bin(35,0)          dcl 57 set ref 11 11 175 193* 289 299 318* 402 452*
                                                                                  539 565*
a_copysw                               parameter       fixed bin(2,0)           dcl 58 ref 11 11 175 241 289 299 360 402 503
a_count                                parameter       fixed bin(17,0)          dcl 63 set ref 289 299 316* 402 450*
a_dname                                parameter       char                     packed unaligned dcl 59 ref 11 11 175 243 289 299
                                                                                  361 539 606
a_dp                                   parameter       pointer                  dcl 60 ref 402 495
a_ename                                parameter       char                     packed unaligned dcl 61 ref 11 11 175 244 289 299
                                                                                  362 402 496 539 607
a_rname                                parameter       char                     packed unaligned dcl 62 ref 11 11 175 245 289 299
                                                                                  363 402 497
a_segptr                               parameter       pointer                  dcl 64 set ref 11 11 175 192* 249 289 299 317* 402
                                                                                  451* 539 564*
a_segsw                                parameter       fixed bin(1,0)           dcl 65 ref 11 11 175 242
a_uid                                  parameter       bit(36)                  packed unaligned dcl 66 set ref 539 563*
addr                                                   builtin function         dcl 105 ref 753 753
allow_write               2(02) 000305 automatic       bit(1)                   level 3 packed packed unaligned dcl 712 set ref 745*
baseno                                                 builtin function         dcl 105 ref 749
baseptr                                                builtin function         dcl 105 ref 558 762
bc                        2     000216 automatic       fixed bin(24,0)          level 2 in structure "out" dcl 86 in procedure
                                                                                  "initiate" set ref 254* 316 367* 450 501* 611*
                                                                                  656* 664* 733* 759*
bc                       40(11)        based           fixed bin(24,0)          level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "initiate" ref 664
code                      4     000216 automatic       fixed bin(35,0)          level 2 dcl 86 set ref 182 184* 185 193 256* 258*
                                                                                  306 308* 309 318 369* 371* 406 417* 418 452 504*
                                                                                  506* 543* 544 549* 555* 565 613* 730* 731 753* 756
                                                                                  757 767*
copysw                          000250 automatic       fixed bin(2,0)           dcl 358 in procedure "setup_args$initiate_count" set
                                                                                  ref 360* 369
copysw                          000260 automatic       fixed bin(2,0)           dcl 493 in procedure "setup_args$initiate_seg_count"
                                                                                  set ref 503* 504
copysw                          000240 automatic       fixed bin(2,0)           dcl 238 in procedure "setup_args$initiate" set ref
                                                                                  241* 256
cur_lot_size             13            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 ref 773
dc_find                         000200 automatic       entry variable           level 2 dcl 76 set ref 169* 179* 184 293* 303* 308
dc_find$finished                000022 constant        entry                    external dcl 1-33 ref 833
dc_find$obj_initiate            000024 constant        entry                    external dcl 1-63 ref 169 293 543
dc_find$obj_initiate_for_linker_dp
                                000026 constant        entry                    external dcl 1-64 ref 417
dc_find$obj_initiate_raw        000030 constant        entry                    external dcl 1-65 ref 179 303
dir                                    based           structure                level 1 dcl 3-11
directory                 4     000210 automatic       bit(1)                   level 2 dcl 81 set ref 548 654* 662* 729 743
dirp                            000210 automatic       pointer                  level 2 in structure "seg" dcl 81 in procedure
                                                                                  "initiate" set ref 653* 661* 730 835*
dirp                      2     000100 automatic       pointer                  level 2 in structure "in" dcl 70 in procedure
                                                                                  "initiate" set ref 417* 419 495*
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "initiate" ref 662
dirsw                     2     000305 automatic       bit(1)                   level 3 in structure "mk_info" packed packed
                                                                                  unaligned dcl 712 in procedure
                                                                                  "make_entry_known_and_unlock_dir" set ref 743*
dname                     4     000100 automatic       char(168)                level 2 packed packed unaligned dcl 70 set ref 184*
                                                                                  243* 308* 361* 543* 606*
ecode                           000304 automatic       fixed bin(35,0)          dcl 711 set ref 766* 767 767
ename                    56     000100 automatic       char(32)                 level 2 packed packed unaligned dcl 70 set ref 184*
                                                                                  244* 308* 362* 417* 496* 543* 607*
entp                      2     000210 automatic       pointer                  level 2 dcl 81 set ref 184* 308* 417* 543* 652 661
                                                                                  662 663 664 740 833*
entry                                  based           structure                level 1 dcl 2-8
entryp                    1     000305 automatic       pointer                  level 2 packed packed unaligned dcl 712 set ref 740*
entrypoint                      000200 automatic       structure                level 1 dcl 76
error_table_$dirseg             000010 external static fixed bin(35,0)          dcl 94 ref 549
error_table_$invalid_copy       000012 external static fixed bin(35,0)          dcl 95 ref 256 369 504
error_table_$seg_unknown        000014 external static fixed bin(35,0)          dcl 96 ref 555
error_table_$segknown           000016 external static fixed bin(35,0)          dcl 97 ref 757
fixed                                                  builtin function         dcl 105 ref 749
flags                           000034 external static bit(1)                   array level 2 in structure "pds$useable_lot" packed
                                                                                  packed unaligned dcl 719 in procedure
                                                                                  "make_entry_known_and_unlock_dir" ref 772
flags                     2     000305 automatic       structure                level 2 in structure "mk_info" packed packed
                                                                                  unaligned dcl 712 in procedure
                                                                                  "make_entry_known_and_unlock_dir"
hash_bucket               5     000210 automatic       fixed bin(17,0)          level 2 dcl 81 set ref 553*
in                              000100 automatic       structure                level 1 dcl 70
kste                                   based           structure                level 1 dcl 4-36
kstep                           000224 automatic       pointer                  dcl 4-15 set ref 553* 554 558
kstsrch                         000020 constant        entry                    external dcl 101 ref 553
level$get                       000036 constant        entry                    external dcl 723 ref 771
link_man$grow_lot               000040 constant        entry                    external dcl 724 ref 775
lock$dir_unlock                 000050 constant        entry                    external dcl 831 ref 835
lot                                    based           structure                level 1 dcl 5-6
lot_fault                              constant        bit(36)                  initial dcl 5-9 ref 776 781
lot_ptr                  26            based           pointer                  level 2 dcl 7-26 ref 776 781
lp                                     based           pointer                  array level 2 packed packed unaligned dcl 5-6 set
                                                                                  ref 776* 781*
makeknown_                      000042 constant        entry                    external dcl 725 ref 753
makeknown_info                         based           structure                level 1 dcl 6-7
max_lot_size             12            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 ref 773
mk_info                         000305 automatic       structure                level 1 dcl 712 set ref 738* 753 753
mountedp                        000044 constant        entry                    external dcl 726 ref 730
null                                                   builtin function         dcl 105 ref 247 253 364 366 419 498 500 554 608 610
                                                                                  652 653 747
out                             000216 automatic       structure                level 1 dcl 86
pds$stacks                      000032 external static pointer                  array dcl 718 ref 773 773 776 781
pds$useable_lot                 000034 external static structure                level 1 dcl 719
priv                      6     000200 automatic       bit(1)                   level 2 dcl 76 set ref 180* 260* 304* 373* 508* 614*
                                                                                  744
priv_init                 2(03) 000305 automatic       bit(1)                   level 3 packed packed unaligned dcl 712 set ref 744*
ptr                                                    builtin function         dcl 105 ref 661
ref_name_$insert                000046 constant        entry                    external dcl 727 ref 766
ring                            000310 automatic       fixed bin(3,0)           dcl 713 set ref 771* 772 773 773 775* 776 781
rname                    66     000100 automatic       varying char(32)         level 2 dcl 70 set ref 245* 363* 497* 765 766*
rsw                       2(01) 000305 automatic       bit(1)                   level 3 packed packed unaligned dcl 712 set ref 748*
                                                                                  751*
rtrim                                                  builtin function         dcl 105 ref 245 363 497
seg                             000210 automatic       structure                level 1 dcl 81
segno                           000311 automatic       fixed bin(17,0)          dcl 714 in procedure
                                                                                  "make_entry_known_and_unlock_dir" set ref 749*
                                                                                  753* 762 766* 773 773 776 781
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 4-36 in procedure "initiate" ref 558
segp                            000100 automatic       pointer                  level 2 in structure "in" dcl 70 in procedure
                                                                                  "initiate" set ref 247* 249* 364* 498* 608* 747
                                                                                  749
segp                            000216 automatic       pointer                  level 2 in structure "out" dcl 86 in procedure
                                                                                  "initiate" set ref 192 253* 317 366* 451 500* 558*
                                                                                  564 610* 762*
segsw                           000241 automatic       fixed bin(1,0)           dcl 239 set ref 242* 247
should_call_find_finished
                          4     000200 automatic       bit(1)                   level 2 dcl 76 set ref 186* 310* 430* 442* 545* 657*
                                                                                  833 837*
should_unlock_dir         5     000200 automatic       bit(1)                   level 2 dcl 76 set ref 187* 311* 429* 443* 546* 657*
                                                                                  835 837*
sons_lvid                12            based           bit(36)                  level 2 dcl 3-11 set ref 730*
stack_header                           based           structure                level 1 dcl 7-26
uid                       3     000216 automatic       bit(36)                  level 2 in structure "out" dcl 86 in procedure
                                                                                  "initiate" set ref 255* 368* 502* 550* 553* 556*
                                                                                  563 612* 655* 663* 739
uid                             000305 automatic       bit(36)                  level 2 in structure "mk_info" dcl 712 in procedure
                                                                                  "make_entry_known_and_unlock_dir" set ref 739*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "initiate" ref 663
unspec                                                 builtin function         dcl 105 set ref 738* 776* 781*
use_count                       000312 automatic       fixed bin(17,0)          dcl 715 set ref 753* 770

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 1-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
call_offset                            internal static fixed bin(17,0)          initial dcl 7-78
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_read                000000 constant        entry                    external dcl 1-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 1-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$link_target             000000 constant        entry                    external dcl 1-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 1-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 1-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 1-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 1-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 1-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 1-51
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 1-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 1-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 1-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 1-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 1-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 1-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 1-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 1-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 1-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 1-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 1-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 1-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 1-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
dp                                     automatic       pointer                  dcl 3-9
entry_offset                           internal static fixed bin(17,0)          initial dcl 7-78
ep                                     automatic       pointer                  dcl 2-6
isot                                   based           structure                level 1 dcl 5-13
isot1                                  based           structure                array level 1 dcl 5-16
isotp                                  automatic       pointer                  dcl 5-12
kst                                    based           structure                level 1 dcl 4-18
kstp                                   automatic       pointer                  dcl 4-15
lotp                                   automatic       pointer                  dcl 5-4
makeknown_infop                        automatic       pointer                  dcl 6-5
pds$kstp                               external static pointer                  dcl 4-15
push_offset                            internal static fixed bin(17,0)          initial dcl 7-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 7-78
return_offset                          internal static fixed bin(17,0)          initial dcl 7-78
sb                                     automatic       pointer                  dcl 7-24
stack_header_overlay                   based           fixed bin(17,0)          array dcl 7-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 7-72
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
INITIATE_COMMON                 000164 constant        label                    dcl 182 ref 170
INITIATE_COUNT_COMMON           000331 constant        label                    dcl 306 ref 294
check_entry                     001071 constant        entry                    internal dcl 622 ref 188 312 446 547
get_segment_ptr_path            000475 constant        entry                    external dcl 539
initiate                        000022 constant        entry                    external dcl 11
initiate_                       000057 constant        entry                    external dcl 11
initiate_count                  000224 constant        entry                    external dcl 289
initiate_seg_count              000374 constant        entry                    external dcl 402
make_entry_known_and_unlock_dir 001126 constant        entry                    internal dcl 672 ref 189 313 447
priv_init                       000122 constant        entry                    external dcl 175
priv_init_count                 000267 constant        entry                    external dcl 299
setup_args$get_segment_ptr_path 001045 constant        entry                    internal dcl 573 ref 542
setup_args$initiate             000622 constant        entry                    internal dcl 202 ref 168 178
setup_args$initiate_count       000712 constant        entry                    internal dcl 325 ref 292 302
setup_args$initiate_seg_count   000771 constant        entry                    internal dcl 459 ref 405
unlock_dir                      001350 constant        entry                    internal dcl 790 ref 561 732 754

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1700        1752    1407        1710
Length      2312    1407        52         323     270           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
initiate                            256 external procedure  is an external procedure.  
setup_args$initiate                     internal procedure  shares stack frame of external procedure initiate.  
setup_args$initiate_count               internal procedure  shares stack frame of external procedure initiate.  
setup_args$initiate_seg_count           internal procedure  shares stack frame of external procedure initiate.  
setup_args$get_segment_ptr_path
                                        internal procedure  shares stack frame of external procedure initiate.  
check_entry                             internal procedure  shares stack frame of external procedure initiate.  
make_entry_known_and_unlock_dir
                                        internal procedure  shares stack frame of external procedure initiate.  
unlock_dir                              internal procedure  shares stack frame of external procedure initiate.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
initiate                 000100 in                          initiate
                         000200 entrypoint                  initiate
                         000210 seg                         initiate
                         000216 out                         initiate
                         000224 kstep                       initiate
                         000240 copysw                      setup_args$initiate
                         000241 segsw                       setup_args$initiate
                         000250 copysw                      setup_args$initiate_count
                         000260 copysw                      setup_args$initiate_seg_count
                         000304 ecode                       make_entry_known_and_unlock_dir
                         000305 mk_info                     make_entry_known_and_unlock_dir
                         000310 ring                        make_entry_known_and_unlock_dir
                         000311 segno                       make_entry_known_and_unlock_dir
                         000312 use_count                   make_entry_known_and_unlock_dir

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out        return_mac          ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dc_find$finished              dc_find$obj_initiate          dc_find$obj_initiate_for_linker_dp
dc_find$obj_initiate_raw      kstsrch                       level$get                     link_man$grow_lot
lock$dir_unlock               makeknown_                    mountedp                      ref_name_$insert

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dirseg           error_table_$invalid_copy     error_table_$seg_unknown      error_table_$segknown
pds$stacks                    pds$useable_lot




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000014       168 000111       169 000112       170 000117       175 000120       178 000154       179 000155
    180 000162       182 000164       184 000166       185 000202       186 000204       187 000206       188 000207
    189 000210       192 000211       193 000213       194 000215       289 000216       292 000256       293 000257
    294 000264       299 000265       302 000321       303 000322       304 000327       306 000331       308 000333
    309 000347       310 000351       311 000353       312 000354       313 000355       316 000356       317 000361
    318 000363       319 000365       402 000366       405 000421       406 000422       417 000424       418 000441
    419 000443       429 000447       430 000450       431 000452       442 000453       443 000454       446 000456
    447 000457       450 000460       451 000463       452 000465       453 000467       539 000470       542 000522
    543 000523       544 000540       545 000542       546 000544       547 000545       548 000546       549 000550
    550 000553       551 000554       553 000555       554 000570       555 000574       556 000577       557 000600
    558 000601       561 000607       563 000610       564 000615       565 000617       566 000621       202 000622
    241 000623       242 000626       243 000630       244 000635       245 000642       247 000664       249 000671
    253 000674       254 000676       255 000677       256 000700       258 000707       260 000710       262 000711
    325 000712       360 000713       361 000716       362 000723       363 000730       364 000752       366 000754
    367 000755       368 000756       369 000757       371 000766       373 000767       375 000770       459 000771
    495 000772       496 000776       497 001003       498 001025       500 001027       501 001030       502 001031
    503 001032       504 001034       506 001042       508 001043       510 001044       573 001045       606 001046
    607 001054       608 001061       610 001063       611 001064       612 001065       613 001066       614 001067
    616 001070       622 001071       652 001072       653 001076       654 001100       655 001102       656 001104
    657 001105       659 001110       661 001111       662 001113       663 001117       664 001121       666 001125
    672 001126       729 001127       730 001131       731 001143       732 001145       733 001146       734 001147
    738 001150       739 001153       740 001155       743 001157       744 001163       745 001170       747 001172
    748 001176       749 001200       750 001204       751 001205       753 001207       754 001226       756 001227
    757 001232       759 001236       760 001237       762 001240       765 001244       766 001251       767 001264
    770 001267       771 001272       772 001301       773 001310       775 001325       776 001333       779 001343
    781 001344       784 001347       790 001350       833 001351       835 001365       837 001376       839 001401


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
