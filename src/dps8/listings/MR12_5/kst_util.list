	COMPILATION LISTING OF SEGMENT kst_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1009.3 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 /* format: style4 */
        9 /* 82-12-13 hewn from raw bits by E. N. Kittlitz */
       10 /* 84-11-05 renamed terminate_ to makeunknown_ by Keith Loepere */
       11 
       12 kst_util: proc;
       13 
       14 dcl  a_segno fixed bin (17);				/* first segment number in range/allocated (input/output) */
       15 dcl  a_count fixed bin (17);				/* number of segments required */
       16 dcl  a_code fixed bin (35);				/* status code */
       17 dcl  a_kstep ptr;					/* pointer to kste */
       18 dcl  a_new_sw bit (2) aligned;			/* set_256K_switch input */
       19 dcl  a_old_sw bit (2) aligned;			/* set_256K_switch output */
       20 
       21 dcl  code fixed bin (35);
       22 dcl  collected fixed bin;				/* count of KSTEs grabbed during a GC */
       23 dcl  count fixed bin;				/* copy of a_count */
       24 dcl  first_segno fixed bin;				/* first segno assigned */
       25 dcl  free_range_trip fixed bin;			/* scanning segnos or actually freeing them */
       26 dcl  headp ptr;					/* pointer to KSTE list head */
       27 dcl  last_segno fixed bin;				/* last segno assigned */
       28 dcl  level fixed bin (3);
       29 dcl  new_sw bit (2) aligned;
       30 dcl  rel_kstep bit (18) aligned;
       31 dcl  run fixed bin;
       32 dcl  segno fixed bin;				/* temporary index */
       33 dcl  tries fixed bin;
       34 
       35 dcl  head bit (18) unaligned based (headp);		/* head of KSTE list */
       36 
       37 dcl  level$get entry returns (fixed bin (3));
       38 dcl  makeunknown_ entry (fixed bin, bit (36) aligned, bit (1) aligned, fixed bin (35));
       39 dcl  setfaults$if_256K entry (fixed bin);
       40 
       41 dcl  error_table_$action_not_performed fixed bin (35) ext static;
       42 dcl  error_table_$bad_arg fixed bin (35) ext static;
       43 dcl  error_table_$invalidsegno fixed bin (35) ext static;
       44 dcl  error_table_$nrmkst fixed bin (35) ext static;
       45 dcl  error_table_$segno_in_use fixed bin (35) ext static;
       46 
       47 dcl  pds$initial_ring fixed bin (3) static external;
       48 
       49 dcl  N_STACKS fixed bin init (8) static options (constant);
       50 
       51 dcl  (addr, baseno, binary, copy, dim, fixed, index, min, mod, null, ptr, rel, reverse, substr, unspec) builtin;
       52 
       53 	return;					/* there is no kst_util */
       54 
       55 /* free_range: put all the specified segnos back on the free list. They must ALL be reserved segnos */
       56 
       57 free_range: entry (a_segno, a_count, a_code);
       58 
       59 	kstp = pds$kstp;
       60 	first_segno = a_segno;
       61 	count = a_count;
       62 	if count < 1 then
       63 	     call abort (error_table_$bad_arg);
       64 	last_segno = first_segno + count - 1;
       65 	level = level$get ();
       66 	if first_segno - kst.lowseg < level |		/* lower ring stack or hardcore */
       67 	     last_segno > kst.highest_used_segno then	/* too big */
       68 	     call abort (error_table_$invalidsegno);
       69 	do free_range_trip = 1 to 2;
       70 	     do segno = first_segno to last_segno;	/* check the whole bunch */
       71 		kstep = addr (kst.kst_entry (segno));
       72 		if kste.fp ^= "777777"b3 |		/* this should never happen on second trip, but let's be sure */
       73 		     unspec (kste.entryp) ^= ""b then
       74 		     call abort (error_table_$action_not_performed);
       75 		if free_range_trip = 2 then do;
       76 		     kste.fp = kst.free_list;
       77 		     kst.free_list = rel (kstep);
       78 		end;
       79 	     end;
       80 	end;
       81 	a_code = 0;
       82 	return;
       83 
       84 
       85 /* garbage_collect: tidy up process address space by terminating directory segments
       86*   that have no known inferiors, or segments not known in any ring */
       87 
       88 garbage_collect: entry (a_code);
       89 
       90 	kstp = pds$kstp;
       91 	collected = 0;
       92 	do segno = kst.lowseg + N_STACKS to kst.highest_used_segno;
       93 	     call try_to_remove (segno, segno);		/* out, damn' spot */
       94 	end;
       95 	kst.garbage_collections = kst.garbage_collections + 1;
       96 	if collected > 0 then do;
       97 	     kst.entries_collected = kst.entries_collected + collected;
       98 	     a_code = 0;
       99 	end;
      100 	else a_code = error_table_$nrmkst;
      101 	return;
      102 
      103 /* get_range: reserve from 1 to the largest conceivable number of consecutive
      104*   segment numbers. */
      105 
      106 get_range: entry (a_count, a_segno, a_code);
      107 
      108 	kstp = pds$kstp;				/* setup */
      109 	count = a_count;				/* copy argument */
      110 	if count < 1 then				/* tsk tsk */
      111 	     call abort (error_table_$bad_arg);
      112 	code, run = 0;
      113 	do tries = 1 to 2 while (code = 0 & run < count); /* up to two tries */
      114 	     first_segno = -1;
      115 	     do segno = kst.lowseg + N_STACKS to kst.highest_used_segno while (run < count);
      116 		kstep = addr (kst.kst_entry (segno));
      117 		if unspec (kste.entryp) ^= ""b |
      118 		     kste.fp = "777777"b3 then do;	/* forget it */
      119 		     first_segno = -1;
      120 		     run = 0;
      121 		end;
      122 		else if first_segno < 0 then do;	/* starting a group */
      123 		     first_segno = segno;
      124 		     run = 1;
      125 		end;
      126 		else run = run + 1;			/* got a streak going */
      127 	     end;					/* perusal of kst */
      128 	     if first_segno < 0 then			/* try for space at end */
      129 		first_segno = kst.highest_used_segno + 1;
      130 	     last_segno = first_segno + count - 1;	/* just how far would we go? */
      131 	     if run < count & tries = 1 then		/* don't have a free range yet */
      132 		if last_segno <= kst.highseg then	/* we can fit at the top */
      133 		     run = count;			/* blast out of loop */
      134 		else call garbage_collect (code);	/* desperation measures */
      135 	end;
      136 	if last_segno > kst.highseg then		/* no space */
      137 	     call abort (error_table_$nrmkst);
      138 	if last_segno > kst.highest_used_segno then	/* expand! */
      139 	     call initialize_region (last_segno);
      140 
      141 	do segno = first_segno to last_segno;		/* now get the segment numbers off the free list */
      142 	     kstep = addr (kst.kst_entry (segno));
      143 	     call unthread_kste (kstep);		/* off the free list */
      144 	     kste.fp = "777777"b3;			/* and now it's reserved */
      145 	end;
      146 
      147 	a_segno = first_segno;			/* why not tell the fella */
      148 	a_code = 0;
      149 
      150 RETURN:	return;
      151 
      152 /* initialize_region: expand kst up through segment a_segno */
      153 
      154 initialize_region: entry (a_segno);
      155 	kstp = pds$kstp;
      156 	last_segno = a_segno;
      157 	do segno = kst.highest_used_segno + 1 to last_segno; /* initialize any new kstes and thread on free list */
      158 	     kstep = addr (kst.kst_entry (segno));
      159 	     kste.segno = segno;
      160 	     unspec (kste.entryp) = "0"b;
      161 	     kste.fp = kst.free_list;
      162 	     kst.free_list = rel (kstep);
      163 	     kst.highest_used_segno = segno;
      164 	end;
      165 	return;
      166 
      167 
      168 /* set_256K_switch controls the use of 256K segments. if the KST switch is "1"b, you can
      169*   talk to them. Otherwise, the limit is sys_info$max_seg_size, buster. */
      170 
      171 set_256K_switch: entry (a_new_sw, a_old_sw, a_code);
      172 
      173 	kstp = pds$kstp;
      174 	new_sw = a_new_sw;
      175 	a_old_sw = "1"b || kst.allow_256K_connect;	/* indicate old value valid */
      176 	if substr (new_sw, 1, 1) ^= "1"b then		/* first bit not set, do nothing */
      177 	     call abort (error_table_$action_not_performed);
      178 	level = level$get ();
      179 	if level > pds$initial_ring then
      180 	     call abort (error_table_$action_not_performed);
      181 	if substr (new_sw, 2, 1) = "1"b then
      182 	     kst.allow_256K_connect = "1"b;
      183 	else if kst.allow_256K_connect then do;		/* must disconnect existing 256K items */
      184 	     kst.allow_256K_connect = "0"b;
      185 	     do segno = kst.lowseg to kst.highest_used_segno;
      186 		call setfaults$if_256K (segno);
      187 	     end;
      188 	end;
      189 	a_code = 0;
      190 	return;
      191 
      192 /* Unthread_kste removes a  kste  from  the  list  on   which   it   is  threaded.
      193*   If kste.entryp = 0 then the kste is assumed to be threaded onto the free list.
      194*   Otherwise, the kste is assumed to be threaded onto a hash class list. */
      195 
      196 unthread_kste: entry (a_kstep);
      197 	kstp = pds$kstp;
      198 	if a_kstep -> kste.fp = "777777"b3 then
      199 	     return;
      200 	if unspec (a_kstep -> kste.entryp) = "0"b then
      201 	     headp = addr (kst.free_list);
      202 	else headp = addr (kst.uid_hash_bucket (mod (fixed (a_kstep -> kste.uid), dim (kst.uid_hash_bucket, 1))));
      203 
      204 	rel_kstep = rel (a_kstep);
      205 	if head = rel_kstep
      206 	then head = a_kstep -> kste.fp;
      207 	else do kstep = ptr (a_kstep, head) repeat (ptr (kstep, kste.fp)) while (rel (kstep) ^= "0"b);
      208 	     if kste.fp = rel_kstep then do;
      209 		kste.fp = a_kstep -> kste.fp;
      210 		return;
      211 	     end;
      212 	end;
      213 	return;
      214 
      215 /* INTERNAL PROCEDURES */
      216 
      217 abort: proc (abort_code);				/* the prefered punter */
      218 dcl  abort_code fixed bin (35);
      219 
      220 	a_code = abort_code;
      221 	go to RETURN;
      222      end abort;
      223 
      224 
      225 try_to_remove: proc (rsegno, tsegno);
      226 dcl  rsegno fixed bin;				/* segno to attempt to remove */
      227 dcl  tsegno fixed bin;				/* highest segno caller has attemted to remove */
      228 
      229 dcl  code fixed bin (35);
      230 dcl  psegno fixed bin;
      231 dcl  entryp ptr;
      232 dcl  lkstep ptr;
      233 dcl  1 lkste aligned like kste based (lkstep);
      234 
      235 	lkstep = addr (kst.kst_entry (rsegno));
      236 	if unspec (lkste.usage_count) ^= ""b then return; /* known in some ring */
      237 	if unspec (lkste.entryp) = ""b then return;
      238 	entryp = lkste.entryp;
      239 	call makeunknown_ (rsegno, "0"b, ("0"b), code);
      240 	if code ^= 0 then return;
      241 	collected = collected + 1;			/* count it */
      242 	if entryp ^= null then do;
      243 	     psegno = binary (baseno (entryp));
      244 	     if psegno < tsegno then			/* caller has already 'seen' our parent, so we must attack it */
      245 		call try_to_remove (psegno, tsegno);
      246 	end;
      247 	return;
      248      end try_to_remove;
      249 
      250 
  1     1 /*	BEGIN INCLUDE FILE ...aste.incl.pl1 ... */
  1     2 
  1     3 /* Template for an AST entry. Length = 12 words. */
  1     4 
  1     5 /* Words 0 to 7, and 11 are read by PC; they are read and modified by SC.
  1     6*   Words 8, 9 and 10 are modified by PC; they should never be modified without locking the PC lock */
  1     7 /* Modified January 1985 by Keith Loepere for multi_class. */
  1     8 
  1     9 dcl  astep ptr;
  1    10 
  1    11 dcl 1 aste based (astep) aligned,
  1    12 
  1    13     (2 fp bit (18),					/* forward  used list rel pointer */
  1    14     2 bp bit (18),					/* backward used list rel pointer */
  1    15 
  1    16     2 infl bit (18),				/* ptr to NEXT  in list of ASTE's of my brothers */
  1    17     2 infp bit (18),				/* ptr to FIRST in list of ASTE's of my children */
  1    18 
  1    19     2 strp bit (18),				/* rel pointer to process trailer */
  1    20     2 par_astep bit (18),				/* rel pointer to parent aste */
  1    21 
  1    22     2 uid bit (36),					/* segment unique id */
  1    23 
  1    24     2 msl bit (9),					/* maximum segment length in 1024 word units */
  1    25     2 pvtx fixed bin (8),				/* physical volume table index */
  1    26     2 vtocx fixed bin (17),				/* vtoc entry index */
  1    27 
  1    28     2 usedf bit (1),				/* ast entry is being used if non-zero */
  1    29     2 init bit (1),					/* used bit - insure 1 lap */
  1    30     2 gtus bit (1),					/* global transparent usage switch */
  1    31     2 gtms bit (1),					/* global transparent modified switch */
  1    32     2 hc bit (1),					/* hard core segment */
  1    33     2 hc_sdw bit (1),				/* aste with sdw for hardcore seg if non-zero */
  1    34     2 any_access_on bit (1),				/* any sdw allows access, unless write_access_on */
  1    35     2 write_access_on bit (1),			/* any sdw allows write access */
  1    36     2 inhibit_cache bit (1),				/* flag not to reset above bits */
  1    37     2 explicit_deact_ok bit (1),			/* set if user can deactivate seg */
  1    38     2 deact_error bit (1),				/* set if error occurred while deactivating */
  1    39     2 hc_part bit (1),				/* set if pages are in a hardcore partition */
  1    40     2 fm_damaged bit (1),				/* set if filemap checksum was ever bad */
  1    41     2 multi_class bit (1),				/* set if page_control should watch state changes to this segment */
  1    42     2 pad1 bit (2),					/* OO */
  1    43     2 dius bit (1),					/* dumper in use switch */
  1    44     2 nid bit (1),					/* if on prevents addtion to incremental dump map */
  1    45     2 dmpr_pad bit (1),
  1    46     2 ehs bit (1),					/* entry hold switch */
  1    47     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  1    48     2 dirsw bit (1),				/* directory switch */
  1    49     2 master_dir bit (1),				/* master dir - a root for the log volume */
  1    50     2 volmap_seg bit (1),				/* volmap_seg for some volume */
  1    51     2 tqsw (0:1) bit (1),				/* terminal quota switch - (0) for non dir pages */
  1    52     2 pad_ic bit (10),				/* Used to be aste.ic */
  1    53 
  1    54     2 dtu bit (36),					/* date and time segment last used */
  1    55 
  1    56     2 dtm bit (36),					/* date and time segment last modified */
  1    57 
  1    58 
  1    59     2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  1    60 
  1    61     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  1    62 
  1    63     2 csl bit (9),					/* current segment length in 1024 words units */
  1    64     2 fmchanged bit (1),				/* turned on by page if file map changed */
  1    65     2 fms bit (1),					/* file modified switch */
  1    66     2 npfs bit (1),					/* no page fault switch */
  1    67     2 gtpd bit (1),					/* global transparent paging device switch */
  1    68     2 dnzp bit (1),					/* don't null out if zero page switch */
  1    69     2 per_process bit (1),				/* use master quota for this entry */
  1    70     2 ddnp bit (1),					/* don't deposit nulled pages */
  1    71     2 pad2 bit (2),
  1    72     2 records bit (9),				/* number of records used by the seg in sec storage */
  1    73     2 np bit (9),					/* number of pages in core */
  1    74 
  1    75 
  1    76     2 ht_fp bit (18),				/* hash table forward rel pointer */
  1    77     2 fmchanged1 bit (1),				/* value of "fmchanged" saved by pc$get_file_map */
  1    78     2 damaged bit (1),				/* PC declared segment unusable */
  1    79     2 pack_ovfl bit (1),				/* page fault on seg would cause pack overflow */
  1    80     2 synchronized bit (1),				/* Data Management synchronized segment */
  1    81     2 pad3 bit (6),					/* OOOOOOOOO */
  1    82     2 ptsi bit (2),					/* page table size index */
  1    83     2 marker bit (6)) unaligned;			/* marker to indicate last word of ASTE */
  1    84 
  1    85 
  1    86 dcl  asta (0 : 8000) bit (36*12 /* sst-> sst.astsize */) based aligned;
  1    87 
  1    88 
  1    89 dcl 1 aste_part aligned based (astep),
  1    90 
  1    91     2 one bit (36) unaligned,				/* fp and bp */
  1    92     2 two bit (36*11 - 8) unaligned,			/* part that has to be zeroed when ASTE is freed */
  1    93     2 three bit (8) unaligned;			/* ptsi and marker */
  1    94 
  1    95 
  1    96 dcl 1 seg_aste based (astep) aligned,			/* Overlay because quota is only for dirs */
  1    97     2 pad1 bit (8*36),
  1    98     2 usage fixed bin (35),				/* page fault count: overlays quota */
  1    99     2 pad2 bit (3*36);
  1   100 
  1   101 /*	END INCLUDE FILE ... aste.incl.pl1 */
      251 
      252 
  2     1 /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  2     2 
  2     3 /*
  2     4*Modified March 1976 by R. Bratt 
  2     5*Modified November 1984 to remove hdr, Keith Loepere. */
  2     6 
  2     7 
  2     8 /****^  HISTORY COMMENTS:
  2     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  2    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  2    11*     Add warning on use of kste.entryp.
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 
  2    15 dcl  pds$kstp ext ptr,
  2    16     (kstp, kstep) ptr;
  2    17 
  2    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  2    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  2    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  2    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  2    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  2    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  2    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  2    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  2    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  2    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  2    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  2    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  2    30     2 unused_2 bit (9) unaligned,
  2    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  2    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  2    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  2    34     2 end_of_kst bit (36);
  2    35 
  2    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  2    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  2    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  2    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  2    40     2 entryp ptr unaligned,				/* branch pointer */
  2    41 						/* See WARNING below for requirements to use entryp. */
  2    42     2 uid bit (36) aligned,				/* unique identifier */
  2    43     2 access_information unaligned,
  2    44       3 dtbm bit (36),				/* date time branch modified */
  2    45       3 extended_access bit (33),			/* extended access from the branch */
  2    46       3 access bit (3),				/* rew */
  2    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  2    48     2 pad1 bit (3) unaligned,
  2    49     2 flags unaligned,
  2    50       3 dirsw bit (1),				/* directory switch */
  2    51       3 allow_write bit (1),				/* set if initiated with write permission */
  2    52       3 priv_init bit (1),				/* privileged initiation */
  2    53       3 tms bit (1),				/* transparent modification switch */
  2    54       3 tus bit (1),				/* transparent usage switch */
  2    55       3 tpd bit (1),				/* transparent paging device switch */
  2    56       3 audit bit (1),				/* audit switch */
  2    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  2    58       3 pad bit (3),
  2    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  2    60 
  2    61 
  2    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    63 /*							       */
  2    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  2    65 /* entry associated with the kst entry, you must first validate its value    */
  2    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  2    67 /* the containing directory.  The containing directory must remain locked    */
  2    68 /* during the entire period when kste.entryp and the directory entry are     */
  2    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  2    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  2    71 /* directory since the dir entry could have been moved within the directory  */
  2    72 /* by another processor.					       */
  2    73 /*							       */
  2    74 /* If you only need a pointer to the directory containing the associated     */
  2    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  2    76 /*    pointer (kste.entryp, 0)				       */
  2    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  2    78 /*							       */
  2    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    80 
  2    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      253 
      254 
      255 
      256      end kst_util;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.4  kst_util.pl1                      >special_ldd>install>MR12.3-1114>kst_util.pl1
251          1    01/30/85  1523.9  aste.incl.pl1                     >ldd>include>aste.incl.pl1
253          2    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
N_STACKS                               constant        fixed bin(17,0)          initial dcl 49 ref 92 115
a_code                                 parameter       fixed bin(35,0)          dcl 16 set ref 57 81* 88 98* 100* 106 148* 171 189*
                                                                                  220*
a_count                                parameter       fixed bin(17,0)          dcl 15 ref 57 61 106 109
a_kstep                                parameter       pointer                  dcl 17 ref 196 198 200 202 204 205 207 209
a_new_sw                               parameter       bit(2)                   dcl 18 ref 171 174
a_old_sw                               parameter       bit(2)                   dcl 19 set ref 171 175*
a_segno                                parameter       fixed bin(17,0)          dcl 14 set ref 57 60 106 147* 154 156
abort_code                             parameter       fixed bin(35,0)          dcl 218 ref 217 220
addr                                                   builtin function         dcl 51 ref 71 116 142 158 200 202 235
allow_256K_connect        7(26)        based           bit(1)                   level 2 packed packed unaligned dcl 2-18 set ref 175
                                                                                  181* 183 184*
baseno                                                 builtin function         dcl 51 ref 243
binary                                                 builtin function         dcl 51 ref 243
code                            000100 automatic       fixed bin(35,0)          dcl 229 in procedure "try_to_remove" set ref 239*
                                                                                  240
code                            000100 automatic       fixed bin(35,0)          dcl 21 in procedure "kst_util" set ref 112* 113 134*
collected                       000101 automatic       fixed bin(17,0)          dcl 22 set ref 91* 96 97 241* 241
count                           000102 automatic       fixed bin(17,0)          dcl 23 set ref 61* 62 64 109* 110 113 115 130 131
                                                                                  131
dim                                                    builtin function         dcl 51 ref 202
entries_collected         6(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-18 set ref 97*
                                                                                  97
entryp                    3            based           pointer                  level 2 in structure "lkste" packed packed unaligned
                                                                                  dcl 233 in procedure "try_to_remove" ref 237 238
entryp                    3            based           pointer                  level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 2-36 in procedure "kst_util" set ref 72 117
                                                                                  160* 200
entryp                          000102 automatic       pointer                  dcl 231 in procedure "try_to_remove" set ref 238*
                                                                                  242 243
error_table_$action_not_performed
                                000016 external static fixed bin(35,0)          dcl 41 set ref 72* 176* 179*
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 42 set ref 62* 110*
error_table_$invalidsegno       000022 external static fixed bin(35,0)          dcl 43 set ref 66*
error_table_$nrmkst             000024 external static fixed bin(35,0)          dcl 44 set ref 100 136*
first_segno                     000103 automatic       fixed bin(17,0)          dcl 24 set ref 60* 64 66 70 114* 119* 122 123* 128
                                                                                  128* 130 141 147
fixed                                                  builtin function         dcl 51 ref 202
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 2-36 set ref 72
                                                                                  76* 117 144* 161* 198 205 208 209* 209 212
free_list                 7            based           bit(18)                  level 2 packed packed unaligned dcl 2-18 set ref 76
                                                                                  77* 161 162* 200
free_range_trip                 000104 automatic       fixed bin(17,0)          dcl 25 set ref 69* 75*
garbage_collections       6            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 2-18 set ref 95*
                                                                                  95
head                                   based           bit(18)                  packed unaligned dcl 35 set ref 205 205* 207
headp                           000106 automatic       pointer                  dcl 26 set ref 200* 202* 205 205 207
highest_used_segno        2            based           fixed bin(17,0)          level 2 dcl 2-18 set ref 66 92 115 128 138 157 163*
                                                                                  185
highseg                   1            based           fixed bin(17,0)          level 2 dcl 2-18 ref 131 136
kst                                    based           structure                level 1 dcl 2-18
kst_entry               110            based           structure                array level 2 dcl 2-18 set ref 71 116 142 158 235
kste                                   based           structure                level 1 dcl 2-36
kstep                           000122 automatic       pointer                  dcl 2-15 set ref 71* 72 72 76 77 116* 117 117 142*
                                                                                  143* 144 158* 159 160 161 162 207* 207* 208 209*
                                                                                  212 212
kstp                            000120 automatic       pointer                  dcl 2-15 set ref 59* 66 66 71 76 77 90* 92 92 95 95
                                                                                  97 97 108* 115 115 116 128 131 136 138 142 155*
                                                                                  157 158 161 162 163 173* 175 181 183 184 185 185
                                                                                  197* 200 202 202 235
last_segno                      000110 automatic       fixed bin(17,0)          dcl 27 set ref 64* 66 70 130* 131 136 138 138* 141
                                                                                  156* 157
level                           000111 automatic       fixed bin(3,0)           dcl 28 set ref 65* 66 178* 179
level$get                       000010 constant        entry                    external dcl 37 ref 65 178
lkste                                  based           structure                level 1 dcl 233
lkstep                          000104 automatic       pointer                  dcl 232 set ref 235* 236 237 238
lowseg                                 based           fixed bin(17,0)          level 2 dcl 2-18 ref 66 71 92 115 116 142 158 185
                                                                                  235
makeunknown_                    000012 constant        entry                    external dcl 38 ref 239
mod                                                    builtin function         dcl 51 ref 202
new_sw                          000112 automatic       bit(2)                   dcl 29 set ref 174* 176 181
null                                                   builtin function         dcl 51 ref 242
pds$initial_ring                000026 external static fixed bin(3,0)           dcl 47 ref 179
pds$kstp                        000030 external static pointer                  dcl 2-15 ref 59 90 108 155 173 197
psegno                          000101 automatic       fixed bin(17,0)          dcl 230 set ref 243* 244 244*
ptr                                                    builtin function         dcl 51 ref 207 212
rel                                                    builtin function         dcl 51 ref 77 162 204 207
rel_kstep                       000113 automatic       bit(18)                  dcl 30 set ref 204* 205 208
rsegno                                 parameter       fixed bin(17,0)          dcl 226 set ref 225 235 239*
run                             000114 automatic       fixed bin(17,0)          dcl 31 set ref 112* 113 115 120* 124* 126* 126 131
                                                                                  131*
segno                     0(18)        based           fixed bin(17,0)          level 2 in structure "kste" packed packed unaligned
                                                                                  dcl 2-36 in procedure "kst_util" set ref 159*
segno                           000115 automatic       fixed bin(17,0)          dcl 32 in procedure "kst_util" set ref 70* 71* 92*
                                                                                  93* 93* 115* 116 123* 141* 142* 157* 158 159 163*
                                                                                  185* 186*
setfaults$if_256K               000014 constant        entry                    external dcl 39 ref 186
substr                                                 builtin function         dcl 51 ref 176 181
tries                           000116 automatic       fixed bin(17,0)          dcl 33 set ref 113* 131*
tsegno                                 parameter       fixed bin(17,0)          dcl 227 set ref 225 244 244*
uid                       4            based           bit(36)                  level 2 dcl 2-36 ref 202
uid_hash_bucket          10            based           bit(18)                  array level 2 packed packed unaligned dcl 2-18 set
                                                                                  ref 202 202
unspec                                                 builtin function         dcl 51 set ref 72 117 160* 200 236 237
usage_count               1            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 233 ref
                                                                                  236

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
asta                                   based           bit(432)                 array dcl 1-86
aste                                   based           structure                level 1 dcl 1-11
aste_part                              based           structure                level 1 dcl 1-89
astep                                  automatic       pointer                  dcl 1-9
copy                                                   builtin function         dcl 51
error_table_$segno_in_use              external static fixed bin(35,0)          dcl 45
index                                                  builtin function         dcl 51
min                                                    builtin function         dcl 51
reverse                                                builtin function         dcl 51
seg_aste                               based           structure                level 1 dcl 1-96

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN                          000526 constant        label                    dcl 150 ref 221
abort                           001042 constant        entry                    internal dcl 217 ref 62 66 72 110 136 176 179
free_range                      000023 constant        entry                    external dcl 57
garbage_collect                 000177 constant        entry                    external dcl 88 ref 134
get_range                       000263 constant        entry                    external dcl 106
initialize_region               000532 constant        entry                    external dcl 154 ref 138
kst_util                        000011 constant        entry                    external dcl 12
set_256K_switch                 000612 constant        entry                    external dcl 171
try_to_remove                   001050 constant        entry                    internal dcl 225 ref 93 244
unthread_kste                   000741 constant        entry                    external dcl 196 ref 143

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1360        1412    1153        1370
Length      1640    1153        32         212     204           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
kst_util                            118 external procedure  is an external procedure.  
abort                                   internal procedure  shares stack frame of external procedure kst_util.  
try_to_remove                        82 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
kst_util                 000100 code                        kst_util
                         000101 collected                   kst_util
                         000102 count                       kst_util
                         000103 first_segno                 kst_util
                         000104 free_range_trip             kst_util
                         000106 headp                       kst_util
                         000110 last_segno                  kst_util
                         000111 level                       kst_util
                         000112 new_sw                      kst_util
                         000113 rel_kstep                   kst_util
                         000114 run                         kst_util
                         000115 segno                       kst_util
                         000116 tries                       kst_util
                         000120 kstp                        kst_util
                         000122 kstep                       kst_util
try_to_remove            000100 code                        try_to_remove
                         000101 psegno                      try_to_remove
                         000102 entryp                      try_to_remove
                         000104 lkstep                      try_to_remove

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         call_ext_out        call_int_this       call_int_other      return_mac          mdfx3
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
level$get                     makeunknown_                  setfaults$if_256K

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_arg          error_table_$invalidsegno
error_table_$nrmkst           pds$initial_ring              pds$kstp




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000010        53 000016        57 000017        59 000037        60 000043        61 000045        62 000047
     64 000057        65 000063        66 000072        69 000111        70 000117        71 000127        72 000140
     75 000155        76 000160        77 000164        79 000166        80 000170        81 000172        82 000173
     88 000174        90 000207        91 000213        92 000214        93 000225        94 000234        95 000236
     96 000244        97 000246        98 000253        99 000254       100 000255       101 000260       106 000261
    108 000277       109 000303       110 000305       112 000315       113 000317       114 000332       115 000334
    116 000350       117 000361       119 000367       120 000371       121 000372       122 000373       123 000375
    124 000377       125 000401       126 000402       127 000403       128 000405       130 000413       131 000416
    134 000433       135 000441       136 000443       138 000456       141 000470       142 000477       143 000510
    144 000516       145 000521       147 000523       148 000525       150 000526       154 000527       155 000542
    156 000546       157 000550       158 000561       159 000572       160 000574       161 000575       162 000600
    163 000602       164 000603       165 000605       171 000606       173 000622       174 000626       175 000632
    176 000641       178 000653       179 000662       181 000674       183 000705       184 000711       185 000713
    186 000723       187 000732       189 000734       190 000735       196 000736       197 000746       198 000752
    200 000760       202 000770       204 001001       205 001003       207 001015       208 001022       209 001027
    210 001034       212 001035       213 001041       217 001042       220 001044       221 001046       225 001047
    235 001055       236 001070       237 001074       238 001076       239 001100       240 001120       241 001122
    242 001124       243 001130       244 001134       247 001150


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
