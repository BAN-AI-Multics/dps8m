	COMPILATION LISTING OF SEGMENT tty_space_man
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1028.9 mst Sat
	    Options: optimize map

        1 /****^  ******************************************************
        2*        *                                                    *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987           *
        4*        *                                                    *
        5*        * Copyright (c) 1987 by Massachusetts Institute of   *
        6*        * Technology and Honeywell Information Systems, Inc. *
        7*        *                                                    *
        8*        * Copyright (c) 1972 by Massachusetts Institute of   *
        9*        * Technology and Honeywell Information Systems, Inc. *
       10*        *                                                    *
       11*        ****************************************************** */
       12 
       13 /* TTY_SPACE_MAN: Entries for managing the ring-0 tty buffer */
       14 /* Written January 1978 by Larry Johnson to replace tty_free */
       15 /* Modified 8/25/78 by J. Stern for multiplexing changes */
       16 /* Modified March 1981 by Robert Coren to add get_perm_space entry */
       17 /* Modified April 1981 by Robert Coren to add switch_chain entry */
       18 /* Modified May 19, 1982 by Robert Coren to fix argument-copying bug in switch_chain entry */
       19 
       20 /* format: style4,delnl,insnl,^ifthendo */
       21 
       22 tty_space_man:
       23      proc;
       24 
       25 /* Parameters */
       26 
       27 dcl  arg_devx fixed bin;				/* Index of lcte */
       28 dcl  arg_from_devx fixed bin;
       29 dcl  arg_to_devx fixed bin;
       30 dcl  arg_size fixed bin;				/* Size of buffer request */
       31 dcl  arg_output_flag bit (1);				/* On for output buffers */
       32 dcl  arg_from_type bit (1);				/* On if switching from output */
       33 dcl  arg_to_type bit (1);				/* On if switching to output */
       34 dcl  arg_blockp ptr;				/* Pointer to a buffer */
       35 dcl  arg_count fixed bin;				/* Length of a buffer chain */
       36 
       37 /* Automatic */
       38 
       39 dcl  output_flag bit (1);				/* Copy of arg_output_flag argument */
       40 dcl  perm bit (1);					/* on for get_perm_space entry */
       41 dcl  buffer_size fixed bin;
       42 dcl  count fixed bin;
       43 dcl  word_count fixed bin;
       44 dcl  i fixed bin;
       45 dcl  prev_blockp ptr;
       46 dcl  first_blockp ptr;
       47 dcl  devx fixed bin;				/* Copy of arg_devx */
       48 dcl  from_devx fixed bin;
       49 dcl  to_devx fixed bin;
       50 dcl  from_type bit (1);
       51 dcl  to_type bit (1);
       52 dcl  total_freed fixed bin;				/* Amount of space freed during call */
       53 dcl  wire_mask fixed bin (71);			/* For pmut$wire calls */
       54 dcl  wire_ptr ptr;					/* This too */
       55 dcl  enter_time fixed bin (71);			/* clock time at entry (for metering) */
       56 
       57 /* External */
       58 
       59 dcl  pds$processid bit (36) external;
       60 
       61 dcl  caller entry returns (ptr);
       62 dcl  mcs_trace entry options (variable);
       63 dcl  pmut$wire_and_mask entry (fixed bin (71), ptr);
       64 dcl  pmut$unwire_unmask entry (fixed bin (71), ptr);
       65 dcl  pxss$unique_ring_0_wakeup entry (bit (36) aligned, fixed bin (71), fixed bin (71), fixed bin (35));
       66 dcl  syserr entry options (variable);
       67 
       68 /* Internal static */
       69 
       70 dcl  RESERVED_SPACE internal static options (constant) init (256);
       71 
       72 /* Builtins */
       73 
       74 dcl  (addr, addrel, baseno, bin, bit, clock, divide, mod, null, ptr, rel, stac, stacq, unspec) builtin;
       75 
       76 /* Entry to get a single buffer */
       77 
       78 get_buffer:
       79      entry (arg_devx, arg_size, arg_output_flag, arg_blockp);
       80 
       81 	devx = arg_devx;
       82 	buffer_size = arg_size;
       83 	output_flag = arg_output_flag;
       84 	call setup;
       85 	tty_buf.alloc_calls = tty_buf.alloc_calls + 1;
       86 
       87 	call buffer_getter (buffer_size);		/* Allocate the buffer */
       88 	if blockp ^= null
       89 	then call update_lcte (buffer_size);		/* Fix wtcb if it worked */
       90 	call clean_up;
       91 	arg_blockp = blockp;
       92 	tty_buf.alloc_time = tty_buf.alloc_time + clock () - enter_time;
       93 	return;
       94 
       95 /* Entry to get a chain of buffers */
       96 
       97 get_chain:
       98      entry (arg_devx, arg_size, arg_count, arg_output_flag, arg_blockp);
       99 
      100 	devx = arg_devx;
      101 	buffer_size = arg_size;
      102 	count = arg_count;
      103 	output_flag = arg_output_flag;
      104 	call setup;
      105 	tty_buf.alloc_calls = tty_buf.alloc_calls + 1;
      106 
      107 	first_blockp, prev_blockp = null;
      108 	do i = 1 to count;				/* Allocate number requested */
      109 	     call buffer_getter (buffer_size);
      110 	     if blockp = null
      111 	     then go to get_chain_failed;		/* Ran out of room */
      112 	     if i = 1
      113 	     then first_blockp = blockp;		/* Remember pointer to first block */
      114 	     else prev_blockp -> buffer.next = bin (rel (blockp));
      115 						/* And thread the rest */
      116 	     prev_blockp = blockp;
      117 	end;
      118 	call update_lcte (count * buffer_size);		/* Charge to device */
      119 	call clean_up;
      120 	arg_blockp = first_blockp;			/* Return pointer to first in chain */
      121 	tty_buf.alloc_time = tty_buf.alloc_time + clock () - enter_time;
      122 	return;
      123 
      124 get_chain_failed:					/* Not enough buffers */
      125 	blockp = first_blockp;
      126 	if blockp ^= null
      127 	then call chain_freer;			/* Release partial chain */
      128 	call clean_up;
      129 	arg_blockp = null;
      130 	tty_buf.alloc_time = tty_buf.alloc_time + clock () - enter_time;
      131 	return;
      132 
      133 /* Entry to free a single buffer */
      134 
      135 free_buffer:
      136      entry (arg_devx, arg_output_flag, arg_blockp);
      137 
      138 	devx = arg_devx;
      139 	output_flag = arg_output_flag;
      140 	blockp = arg_blockp;
      141 	call setup;
      142 	tty_buf.free_calls = tty_buf.free_calls + 1;
      143 
      144 	call buffer_freer;				/* This does the work */
      145 	call update_lcte (-total_freed);
      146 	call clean_up;
      147 	arg_blockp = null;
      148 	tty_buf.free_time = tty_buf.free_time + clock () - enter_time;
      149 	return;
      150 
      151 /* Entry to free a buffer chain */
      152 
      153 free_chain:
      154      entry (arg_devx, arg_output_flag, arg_blockp);
      155 
      156 	devx = arg_devx;
      157 	output_flag = arg_output_flag;
      158 	blockp = arg_blockp;
      159 	call setup;
      160 	tty_buf.free_calls = tty_buf.free_calls + 1;
      161 
      162 	call chain_freer;				/* This does the work */
      163 	call update_lcte (-total_freed);
      164 	call clean_up;
      165 	arg_blockp = null;
      166 	tty_buf.free_time = tty_buf.free_time + clock () - enter_time;
      167 	return;
      168 
      169 /* Entry to get space of arbitrary size */
      170 
      171 get_space:
      172      entry (arg_size, arg_blockp);
      173 
      174 	perm = "0"b;
      175 	go to get_space_join;
      176 
      177 /* Entry to get permanent space of arbitrary size (used to allocate LCT); point
      178*   is to not count it against buffer pool for metering */
      179 get_perm_space:
      180      entry (arg_size, arg_blockp);
      181 
      182 	perm = "1"b;
      183 get_space_join:
      184 	buffer_size = arg_size + mod (arg_size, 2);
      185 	call setup;
      186 	tty_buf.alloc_calls = tty_buf.alloc_calls + 1;
      187 
      188 	blockp = space_getter (buffer_size);
      189 	call clean_up;
      190 	arg_blockp = blockp;
      191 	tty_buf.alloc_time = tty_buf.alloc_time + clock () - enter_time;
      192 	if ^perm
      193 	then call update_control (buffer_size);
      194 	return;
      195 
      196 /* Entry to free space of arbitrary size */
      197 
      198 free_space:
      199      entry (arg_size, arg_blockp);
      200 
      201 	buffer_size = arg_size + mod (arg_size, 2);	/* Make it even */
      202 	blockp = arg_blockp;
      203 	call setup;
      204 	tty_buf.free_calls = tty_buf.free_calls + 1;
      205 
      206 	call space_freer (blockp, buffer_size);
      207 	call clean_up;
      208 	arg_blockp = null;
      209 	tty_buf.free_time = tty_buf.free_time + clock () - enter_time;
      210 	call update_control (-buffer_size);
      211 	return;
      212 
      213 
      214 
      215 /* This entry is called when a process needs an interrupt when buffer space becomes available */
      216 
      217 needs_space:
      218      entry (arg_devx);
      219 
      220 	devx = arg_devx;
      221 	call setup;
      222 
      223 	lctep = addr (lct.lcte_array (devx));
      224 	lcte.space_needed = "1"b;			/* Remember this process needs an interrupt */
      225 	tty_buf.space_needed = "1"b;			/* Remember that at least one process needs an interrupt */
      226 	tty_buf.space_needed_calls = tty_buf.space_needed_calls + 1;
      227 						/* Leave some evidence */
      228 	call clean_up;
      229 	return;
      230 
      231 /* Entry to update metering information if a multiplexer changes a chain from input to
      232*   output (or vice versa) and/or from one channel to another */
      233 
      234 switch_chain:
      235      entry (arg_from_devx, arg_to_devx, arg_from_type, arg_to_type, arg_blockp);
      236 
      237 	from_devx = arg_from_devx;
      238 	to_devx = arg_to_devx;
      239 	from_type = arg_from_type;
      240 	to_type = arg_to_type;
      241 	blockp = arg_blockp;
      242 	call setup;
      243 	word_count = 0;
      244 	do while (blockp ^= null ());			/* ascertain the length of the chain */
      245 	     word_count = word_count + 16 * (buffer.size_code + 1);
      246 	     if buffer.next = 0
      247 	     then blockp = null ();
      248 	     else blockp = ptr (ttybp, buffer.next);
      249 	end;
      250 
      251 	devx = from_devx;				/* take it away from old one */
      252 	output_flag = from_type;
      253 	call update_lcte (-word_count);
      254 	devx = to_devx;				/* and give it to new one */
      255 	output_flag = to_type;
      256 	call update_lcte (word_count);
      257 	call clean_up;
      258 
      259 	if tty_buf.trace.enable
      260 	then if tty_buf.trace.space_man
      261 	     then call mcs_trace (from_devx, "switch_chain: ^d words to devx ^o by ^p", word_count, to_devx, caller ());
      262 
      263 	return;
      264 
      265 /* Procedure to allocate one buffer */
      266 
      267 buffer_getter:
      268      proc (n);
      269 
      270 dcl  n fixed bin;					/* The size */
      271 
      272 	if tty_buf.bleft <= RESERVED_SPACE		/* always save some for critical functions */
      273 	then blockp = null;
      274 	else do;
      275 	     blockp = space_getter (n);		/* Get the space */
      276 	     if blockp = null
      277 	     then return;				/* Error */
      278 	     buffer.size_code = divide (n, 16, 17, 0) - 1;
      279 	end;
      280 
      281 	if tty_buf.trace.enable
      282 	then if tty_buf.trace.space_man
      283 	     then call mcs_trace (devx, "get_buffer: ^d words at ^p by ^p", n, blockp, caller ());
      284 
      285 	return;
      286      end buffer_getter;
      287 
      288 /* Procedure to free a single buffer pointed to by blockp */
      289 
      290 buffer_freer:
      291      proc;
      292 
      293 dcl  n fixed bin;
      294 
      295 	n = 16 * (buffer.size_code + 1);
      296 
      297 	if tty_buf.trace.enable
      298 	then if tty_buf.trace.space_man
      299 	     then call mcs_trace (devx, "free_buffer: ^d words at ^p by ^p", n, blockp, caller ());
      300 
      301 	call space_freer (blockp, n);
      302 	total_freed = total_freed + n;
      303 	return;
      304 
      305      end buffer_freer;
      306 
      307 /* Procedure to free a buffer chain */
      308 
      309 chain_freer:
      310      proc;
      311 
      312 dcl  next_rel bit (18);
      313 
      314 	if tty_buf.trace.enable
      315 	then if tty_buf.trace.space_man
      316 	     then call mcs_trace (devx, "free_chain: at ^p by ^p", blockp, caller ());
      317 
      318 	next_rel = rel (blockp);			/* Start non-zero */
      319 	do while (next_rel);			/* Loop to end of chain */
      320 	     next_rel = bit (bin (buffer.next, 18), 18);	/* Hold foward pointer */
      321 	     call buffer_freer;
      322 	     blockp = ptr (ttybp, next_rel);
      323 	end;
      324 	blockp = null;
      325 	return;
      326 
      327      end chain_freer;
      328 
      329 /* Procedure to find a block of any size. It is extracted from the smallest free block which can hold it */
      330 
      331 space_getter:
      332      proc (n) returns (ptr);
      333 
      334 dcl  n fixed bin;					/* The size in words */
      335 
      336 dcl  best_blockp ptr init (null);			/* Ptr to smallest free block large enough for request */
      337 dcl  best_block_size fixed bin init (0);		/* Size of that block */
      338 dcl  prev_best_blockp ptr init (null);			/* Block before best_blockp -> free_block */
      339 dcl  prev_blockp ptr init (null);			/* Block before current block during scan */
      340 dcl  next_rel bit (18);				/* For updating threading */
      341 dcl  p ptr;
      342 dcl  free_space (n) bit (36) aligned based (free_blockp);	/* The space finially allocated */
      343 dcl  nsteps fixed bin init (0);			/* Number of steps in free chain */
      344 
      345 	do free_blockp = ptr (ttybp, tty_buf.free) repeat (ptr (ttybp, free_block.next)) while (rel (free_blockp));
      346 						/* Check each free block */
      347 	     nsteps = nsteps + 1;
      348 	     if free_block.size = n
      349 	     then do;				/* Found block just right */
      350 		next_rel = free_block.next;		/* Will unthread whole block */
      351 		go to fit_found;
      352 	     end;
      353 	     if free_block.size > n
      354 	     then do;				/* This block is large enough */
      355 		if (best_block_size = 0) | (free_block.size < best_block_size)
      356 		then do;				/* If either the first block, or a better one */
      357 		     best_blockp = free_blockp;	/* Remember this block */
      358 		     best_block_size = free_block.size;
      359 		     prev_best_blockp = prev_blockp;	/* Remember preceding block */
      360 		end;
      361 	     end;
      362 	     prev_blockp = free_blockp;
      363 	end;
      364 
      365 	if best_block_size = 0
      366 	then do;					/* No space large enough */
      367 	     tty_buf.alloc_failures = tty_buf.alloc_failures + 1;
      368 	     return (null);
      369 	end;
      370 
      371 	free_blockp = best_blockp;			/* Block to use */
      372 	prev_blockp = prev_best_blockp;
      373 	p = addrel (free_blockp, n);			/* Get pointer to new free block */
      374 	next_rel = rel (p);
      375 	p -> free_block.next = free_block.next;
      376 	p -> free_block.size = free_block.size - n;
      377 fit_found:
      378 	if prev_blockp = null
      379 	then tty_buf.free = next_rel;			/* Have unthreaded from head */
      380 	else prev_blockp -> free_block.next = next_rel;	/* Unthreaded from middle */
      381 
      382 	unspec (free_space) = "0"b;			/* Clear the buffer */
      383 	tty_buf.bleft = tty_buf.bleft - n;		/* Total free space */
      384 	if tty_buf.minimum_free_space = 0 | tty_buf.bleft < tty_buf.minimum_free_space
      385 	then tty_buf.minimum_free_space = tty_buf.bleft;	/* metering */
      386 	tty_buf.total_alloc_steps = tty_buf.total_alloc_steps + nsteps;
      387 	return (free_blockp);			/* Return the answer */
      388 
      389      end space_getter;
      390 
      391 /* Procedure to free space of arbitrary size */
      392 
      393 space_freer:
      394      proc (p, n);
      395 
      396 dcl  p ptr;					/* Address of block to free */
      397 dcl  n fixed bin;					/* Word count */
      398 dcl  (prev_blockp, next_blockp) ptr;
      399 dcl  next_rel fixed bin (18);
      400 
      401 	if (baseno (p) ^= baseno (ttybp)) | (rel (p) < tty_buf.borig)
      402 	then call err (3);
      403 	free_blockp = p;
      404 	free_block.size = n;			/* Initialize free block */
      405 	free_block.next = "0"b;
      406 	prev_blockp = null;
      407 	do free_blockp = ptr (ttybp, tty_buf.free) repeat (ptr (ttybp, free_block.next)) while (rel (free_blockp));
      408 						/* Find spot in chain before this block */
      409 	     if rel (p) < rel (free_blockp)
      410 	     then go to found_hole;			/* Block goes before here */
      411 	     else if rel (p) = rel (free_blockp)
      412 	     then call err (4);
      413 	     prev_blockp = free_blockp;
      414 	end;
      415 
      416 /* Block goes at end */
      417 
      418 	free_blockp = p;
      419 	go to chain_back;
      420 
      421 /* Found hole in middle for this block */
      422 
      423 found_hole:
      424 	next_blockp = free_blockp;
      425 	free_blockp = p;
      426 	next_rel = bin (rel (free_blockp)) + free_block.size;
      427 						/* Word after current block */
      428 	if next_rel > bin (rel (next_blockp))
      429 	then call err (4);				/* Overlap */
      430 	else if next_rel = bin (rel (next_blockp))
      431 	then do;					/* Can combine with next */
      432 	     free_block.next = next_blockp -> free_block.next;
      433 	     free_block.size = free_block.size + next_blockp -> free_block.size;
      434 	end;
      435 	else free_block.next = rel (next_blockp);	/* Point current at next */
      436 
      437 /* Chain back to preceding block  */
      438 
      439 chain_back:
      440 	if prev_blockp = null
      441 	then tty_buf.free = rel (free_blockp);		/* This is first block */
      442 	else do;
      443 	     next_rel = bin (rel (prev_blockp)) + prev_blockp -> free_block.size;
      444 						/* Word after previous block */
      445 	     if next_rel > bin (rel (free_blockp))
      446 	     then call err (4);			/* Overlap */
      447 	     else if next_rel = bin (rel (free_blockp))
      448 	     then do;				/* Can combine */
      449 		prev_blockp -> free_block.next = free_block.next;
      450 		prev_blockp -> free_block.size = prev_blockp -> free_block.size + free_block.size;
      451 	     end;
      452 	     else prev_blockp -> free_block.next = rel (free_blockp);
      453 						/* Make previous point at this one */
      454 	end;
      455 
      456 	tty_buf.bleft = tty_buf.bleft + n;
      457 	if tty_buf.space_needed
      458 	then					/* Somebody needs space */
      459 	     if tty_buf.bleft >= abs_buf_limit
      460 	     then call interrupt_waiting_procs;
      461 	return;
      462 
      463      end space_freer;
      464 
      465 /* Initialize by doing required masking and locking */
      466 
      467 setup:
      468      proc;
      469 
      470 	ttybp = addr (tty_buf$);
      471 	lctp = tty_buf.lct_ptr;
      472 	call pmut$wire_and_mask (wire_mask, wire_ptr);
      473 	enter_time = clock ();
      474 	call lock;
      475 	total_freed = 0;
      476 	return;
      477 
      478      end setup;
      479 
      480 /* Procedures that manage the tty_buffer lock word */
      481 
      482 lock:
      483      proc;
      484 
      485 dcl  start_time fixed bin (71);
      486 
      487 	if tty_buf.slock = pds$processid
      488 	then call err (1);				/* Already locked to this process */
      489 	if ^stac (addr (tty_buf.slock), pds$processid)
      490 	then do;					/* Didn't lock at first attempt */
      491 	     start_time = clock ();			/* Record time we started to loop */
      492 	     tty_buf.space_lock_wait_count = tty_buf.space_lock_wait_count + 1;
      493 	     do while (^stac (addr (tty_buf.slock), pds$processid));
      494 	     end;
      495 	     tty_buf.space_lock_wait_time = tty_buf.space_lock_wait_time + clock () - start_time;
      496 	end;
      497 	tty_buf.space_lock_count = tty_buf.space_lock_count + 1;
      498 	return;
      499 
      500 unlock:
      501      entry;
      502 
      503 	if ^stacq (tty_buf.slock, "0"b, pds$processid)
      504 	then call err (2);
      505 	return;
      506 
      507      end lock;
      508 
      509 /* Unwire and unlock and unmask as required */
      510 
      511 clean_up:
      512      proc;
      513 
      514 	call unlock;
      515 	call pmut$unwire_unmask (wire_mask, wire_ptr);
      516 	return;
      517 
      518      end clean_up;
      519 
      520 /* Procedure to update a channels space usage counts */
      521 
      522 update_lcte:
      523      proc (n);
      524 
      525 dcl  n fixed bin;					/* The increment (+ or -) */
      526 dcl  pc_devx fixed bin;
      527 
      528 	if devx < 1 | devx > lct.max_no_lctes
      529 	then return;
      530 	lctep = addr (lct.lcte_array (devx));
      531 	pc_devx = lcte.physical_channel_devx;
      532 	lctep = addr (lct.lcte_array (pc_devx));
      533 	if output_flag
      534 	then do;
      535 	     lcte.output_words = lcte.output_words + n;
      536 	     tty_buf.current_output_space = tty_buf.current_output_space + n;
      537 	     tty_buf.cumulative_output_space = tty_buf.cumulative_output_space + tty_buf.current_output_space;
      538 	     tty_buf.output_space_updates = tty_buf.output_space_updates + 1;
      539 	end;
      540 
      541 	else do;
      542 	     lcte.input_words = lcte.input_words + n;
      543 	     tty_buf.current_input_space = tty_buf.current_input_space + n;
      544 	     tty_buf.cumulative_input_space = tty_buf.cumulative_input_space + tty_buf.current_input_space;
      545 	     tty_buf.input_space_updates = tty_buf.input_space_updates + 1;
      546 	end;
      547 	return;
      548 
      549      end update_lcte;
      550 
      551 
      552 /* Procedure to update control space usage counts (for metering) */
      553 
      554 update_control:
      555      proc (n);
      556 
      557 dcl  n fixed bin;					/* The increment (+ or -) */
      558 
      559 	tty_buf.current_control_space = tty_buf.current_control_space + n;
      560 	tty_buf.cumulative_control_space = tty_buf.cumulative_control_space + tty_buf.current_control_space;
      561 	tty_buf.control_space_updates = tty_buf.control_space_updates + 1;
      562      end update_control;
      563 
      564 /* Send an interrupt to all processes who are waiting for space to become free */
      565 
      566 interrupt_waiting_procs:
      567      proc;
      568 
      569 dcl  i fixed bin;
      570 
      571 	do i = 1 to lct.max_no_lctes;
      572 	     lctep = addr (lct.lcte_array (i));
      573 	     if lcte.initialized
      574 	     then					/* this is a live lcte */
      575 		if lcte.space_needed
      576 		then do;
      577 		     lcte.space_needed = "0"b;
      578 		     call unlock;
      579 		     call channel_manager$interrupt (i, SPACE_AVAILABLE, ""b);
      580 		     call lock;
      581 		end;
      582 	end;
      583 
      584 	do i = 1 to lct.max_no_lctes;			/* Be sure no bits were set during our unlocks */
      585 	     lctep = addr (lct.lcte_array (i));
      586 	     if lcte.initialized
      587 	     then if lcte.space_needed
      588 		then return;			/* Leave global flag set */
      589 	end;
      590 
      591 	tty_buf.space_needed = "0"b;			/* All bits are truly off */
      592 	return;
      593 
      594      end interrupt_waiting_procs;
      595 
      596 
      597 
      598 /* Crash the system on error in tty_buf */
      599 
      600 err:
      601      proc (n);
      602 
      603 dcl  n fixed bin;
      604 
      605 call_syserr:
      606 	call syserr (1,
      607 	     "tty_space_man: ^[Lock already locked to process^;Lock not locked to process^;Adress not in buffer pool^;Tried to free space already free^]."
      608 	     , n);
      609 	go to call_syserr;
      610 
      611      end err;
      612 
  1     1 /* BEGIN INCLUDE FILE ... tty_buf.incl.pl1 */
  1     2 
  1     3 /* Date Last Modified and Reason
  1     4*   Created 04/19/77 by J. Stern (from part of tty.incl.pl1)
  1     5*   Modified January 1978 by Robert Coren and Larry Johnson for variable-size buffers
  1     6*   Modified 2/6/78 by Robert Coren to make circular_queue size settable
  1     7*   Modified Aug 78 by J. Nicholls to move the buffer block format to a file of its own
  1     8*   and wtcb to its own plus other modification for ring 0 multiplexing, tty_buffer_block.incl.pl1
  1     9*   Modified 7/17/79 by B. Greenberg for echo negotiation meters.
  1    10*   Modified November 1979 by C. Hornig for MCS tracing.
  1    11*   Modified December 1979 by Robert Coren to add FNP channel lock meter
  1    12*   Modified February 1980 by Robert Coren to remove all references to circular buffer
  1    13*   Modified March 1980 by Robert Coren to reorganize metering information
  1    14*   Modified December 1980 by Robert Coren to add FNP-specific events
  1    15*   Modified 24 March 1982, W. Olin Sibert, to add mcs_timer support, recoverable_error_severity
  1    16*   Modified November 1984 by Robert Coren to add tty_area_lock
  1    17**/
  1    18 
  1    19 dcl  ttybp ptr,
  1    20      tty_buf$ ext static,				/* tty buffer segment */
  1    21      tty_ev fixed bin int static options (constant) init (57), /* event used for wait and notify */
  1    22      abs_buf_limit fixed bin (18) static options (constant) init (64), /* minimum number of words we will leave free */
  1    23      input_bpart fixed bin (18) static options (constant) init (2), /* fraction of bleft we will allow for input */
  1    24      output_bpart fixed bin (18) static options (constant) init (4); /* fraction of bleft we will allow for output */
  1    25 
  1    26 
  1    27 dcl  qblock_size fixed bin int static options (constant) init (16); /* size in words of a delay queue block */
  1    28 dcl  bsizec fixed bin int static options (constant) init (60); /* number of characters in smallest buffer */
  1    29 dcl  buf_per_second fixed bin int static options (constant) init (10); /* for figuring out max. buffer size based on speed */
  1    30 
  1    31 dcl  FNP_DUMP_PATCH_EVENT fixed bin int static options (constant) init (58);
  1    32 dcl  FNP_METER_EVENT fixed bin int static options (constant) init (59);
  1    33 dcl  TTY_AREA_LOCK_EVENT bit (36) aligned int static options (constant) init ("74"b3);
  1    34 
  1    35 dcl 1 tty_buf aligned based (ttybp),			/* declaration of tty buffer seg */
  1    36     2 slock bit (36),				/* per system lock */
  1    37     2 absorig fixed bin (24),				/* abs address of this seg */
  1    38     2 borig bit (18),				/* index of start of buffer area */
  1    39     2 bleft fixed bin (18),				/* words left in pool */
  1    40     2 free bit (18),				/* pointer to start of free pool */
  1    41     2 fnp_config_flags (8) bit (1) unal,		/* flag(i) ON if fnp(i) configured */
  1    42     2 padb1 bit (28) unaligned,
  1    43     2 lct_ptr ptr,					/* pointer to logical channel table */
  1    44 
  1    45     2 nrawread fixed bin (35),			/* number of raw chars input, total */
  1    46     2 nrawwrite fixed bin (35),			/* number of raw characters output */
  1    47     2 ninchars fixed bin (35),			/* total input chars after conversion */
  1    48     2 noutchars fixed bin (35),			/* total output chars before conversion */
  1    49     2 readblocked fixed bin (35),			/* number of times go input blocked */
  1    50     2 nblocked fixed bin (35),			/* number of times process output blocked */
  1    51     2 minbuf fixed bin (18),				/* min output buffer size */
  1    52     2 totbuf fixed bin (35),				/* divide by nblocked to get ave buffer size */
  1    53 
  1    54     2 preconverted fixed bin (35),			/* number of converted chars held in tty_buf */
  1    55     2 input_restart fixed bin,			/* number of times tty_read had to start over */
  1    56     2 output_restart fixed bin,			/* number of times tty_write has had to start over */
  1    57     2 output_buffer_overflow fixed bin,			/* number of times tty_write has run out of buffers */
  1    58     2 read_time fixed bin (71),			/* total time spent in tty_read */
  1    59     2 write_time fixed bin (71),			/* total time spent in tty_write */
  1    60 
  1    61     2 read_calls fixed bin (35),			/* number of calls to tty_read */
  1    62     2 write_calls fixed bin (35),			/* number of calls to tty_write */
  1    63     2 bfx fixed bin,				/* used in calls to iobm */
  1    64     2 nquits fixed bin (35),				/* number of quits */
  1    65     2 space_needed_data,
  1    66       3 space_needed bit (1) unal,			/* space_needed bit on in at least 1 lcte */
  1    67       3 space_needed_calls fixed bin (34) unal,		/* meter of uses of this facility */
  1    68     2 space_lock_count fixed bin (35),			/* count of times tty_buf.slock locked */
  1    69     2 space_lock_wait_count fixed bin (35),		/* count of times necessary to loop to lock it */
  1    70     2 space_lock_wait_time fixed bin (35),		/* total time looped trying to lock it */
  1    71 
  1    72     2 alloc_calls fixed bin (35),			/* total number of allocations performed in tty_buf */
  1    73     2 free_calls fixed bin (35),			/* total number of freeings in tty_buf */
  1    74     2 alloc_time fixed bin (35),			/* time spent masked in tty_space_man$get entries */
  1    75     2 free_time fixed bin (35),			/* time spent masked in tty_space_man$free entries */
  1    76     2 total_alloc_steps fixed bin (35),			/* number of steps thru free chain while doing above */
  1    77     2 alloc_failures fixed bin (35),			/* number of unsuccessful attempts to allocate space */
  1    78     2 cumulative_input_space fixed bin (71),		/* cumulative amount of space allocated for input */
  1    79 
  1    80     2 cumulative_output_space fixed bin (71),		/* cumulative amount of space allocated for output */
  1    81     2 cumulative_control_space fixed bin (71),		/* cumulative amount of space allocated by tty_space_man$get_space */
  1    82     2 input_space_updates fixed bin (35),		/* number of increments to cumulative_input_space */
  1    83     2 output_space_updates fixed bin (35),		/* number of increments to cumulative_output_space */
  1    84     2 control_space_updates fixed bin (35),		/* number of increments to cumulative_control_space */
  1    85     2 minimum_free_space fixed bin (18),		/* smallest amount of free space ever available */
  1    86 
  1    87     2 current_input_space fixed bin (18),		/* amount of space currently allocated for input */
  1    88     2 current_output_space fixed bin (18),		/* amount of space currently allocated for output */
  1    89     2 current_control_space fixed bin (18),		/* amount of space currently allocated by get_space */
  1    90     2 tty_lock_calls fixed bin (35),			/* number of calls to tty_lock$lock entries */
  1    91     2 found_channel_locked fixed bin (35),		/* number of times tty_lock found channel already locked */
  1    92     2 max_wait_time fixed bin (35),			/* longest time waited for any channel lock */
  1    93     2 total_wait_time fixed bin (71),			/* total amount of time spent waiting for channel locks */
  1    94 
  1    95     2 echo_neg_time fixed bin (71),			/* cumulative time spent doing echo negotiation */
  1    96     2 echo_neg_interrupts fixed bin (35),		/* Echo-negotiated shipments */
  1    97     2 echo_neg_r0_chars fixed bin (35),			/* Chars echoed by ring 0 */
  1    98     2 echo_neg_mux_chars fixed bin (35),		/* Chars echoed by mux */
  1    99     2 echo_neg_sndopt_restarts fixed bin (35),		/* Echo reinits */
  1   100     2 echo_neg_mux_nonecho fixed bin (35),
  1   101     2 echo_neg_entries fixed bin (35),			/* Entries into negotiate */
  1   102 
  1   103     2 echo_neg_mux_inhibit bit (1) aligned,		/* For testing */
  1   104     2 n_queued_interrupts fixed bin (35),		/* number of interrupts queued by tty_lock */
  1   105     2 trace unaligned,				/* tracing information */
  1   106       3 flags,
  1   107       4 enable bit,					/* global tracing control */
  1   108       4 default_mode bit,				/* whether to trace channels by default */
  1   109       4 read bit,					/* read */
  1   110       4 write bit,					/* write */
  1   111       4 data bit,					/* buffers on reads and writes */
  1   112       4 control bit,				/* control, priv_control, and hpriv_control */
  1   113       4 modes bit,					/* (get set check)_modes */
  1   114       4 interrupt bit,				/* interrupt, interrupt_later */
  1   115       4 init bit,					/* init_multiplexer, terminate_multiplexer */
  1   116       4 start bit,					/* start, stop */
  1   117       4 shutdown bit,				/* shutdown */
  1   118       4 space_man bit,				/* tty_space_man$* */
  1   119       4 pad_flags bit (6),
  1   120       3 data_offset bit (18),				/* offset of tracing data */
  1   121 
  1   122     2 recoverable_error_severity fixed bin,		/* Syserr severity for recoverable MCS errors */
  1   123 
  1   124     2 timer_lock bit (36) aligned,			/* Lock owned by mcs_timer */
  1   125     2 next_timer_offset bit (18) aligned,		/* Offset of next timer to come due */
  1   126     2 timer_count fixed bin,				/* Number of timers outstanding */
  1   127     2 timer_process bit (36) aligned,			/* Who is doing timers? */
  1   128 
  1   129     2 timer_ev_chn fixed bin (71),			/* How get get him */
  1   130     2 timer_lock_wait_time fixed bin (71),		/* CPU time spent spinning on timer lock */
  1   131 
  1   132     2 timer_lock_count fixed bin (35),			/* Number of times timer lock locked */
  1   133     2 timer_lock_wait_count fixed bin (35),		/* Number of times imer lock waited on */
  1   134     2 timer_call_time fixed bin (71),			/* CPU time spent in call side timer operations */
  1   135 
  1   136     2 timer_polling_time fixed bin (71),		/* CPU time spent polling (including channel_manager) */
  1   137     2 timer_set_calls fixed bin (35),			/* Number of calls to mcs_timer$set, set_wired */
  1   138     2 timer_reset_calls fixed bin (35), 		/* Number of calls to mcs_timer$reset, reset_wired */
  1   139 
  1   140     2 timer_change_calls fixed bin (35),		/* Number of calls to mcs_timer$change, change_wired */
  1   141     2 timer_poll_calls fixed bin (35),			/* Number of calls to mcs_timer$poll */
  1   142     2 timer_error_calls fixed bin (35), 		/* Number of mcs_timer calls ending with recoverable errors */
  1   143     2 timer_duplicate_pollings fixed bin (35),		/* Number of timer polling found in progress on other CPU */
  1   144 
  1   145     2 tty_area_lock like hc_fast_lock,			/* to prevent contention in allocating/freeing in tty_area */
  1   146 
  1   147     2 pad2 (13) fixed bin (35),
  1   148 
  1   149     2 free_space fixed bin;				/* start of free space region */
  1   150 
  1   151 
  2     1 /* BEGIN INCLUDE FILE...hc_fast_lock.incl.pl1 */
  2     2 
  2     3 /* Created November 1984 by Robert Coren to replace hc_lock.incl.pl1 */
  2     4 
  2     5 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     6 
  2     7 /* format: style3 */
  2     8 
  2     9 declare	lock_ptr		pointer;
  2    10 declare	1 hc_fast_lock	aligned based (lock_ptr),
  2    11 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    12 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    13 	  2 flags		aligned,
  2    14 	    3 notify_sw	bit (1) unaligned,
  2    15 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    16 
  2    17 /* END INCLUDE FILE...hc_fast_lock.incl.pl1 */
  1   152 
  1   153 
  1   154 /* END INCLUDE FILE ... tty_buf.incl.pl1 */
      613 
      614 
  3     1 /* BEGIN INCLUDE FILE ... tty_buffer_block.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-06-15,Berno), approve(88-07-13,MCR7928),
  3     7*     audit(88-06-15,Parisek), install(88-07-19,MR12.2-1061):
  3     8*     Add data needed for the uncp multiplexer (DSA gateway) interface
  3     9*     implementation.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /*
  3    14*   Separated from tty_buf.incl.pl1 aug 78 by J. Nicholls
  3    15*   Modified May 1979 by Larry Johnson to add max_buffer_tally array and to use unsigned variables.
  3    16*   Reported in February 1982 the modifications to add the "turn" bit in flags.
  3    17**/
  3    18 
  3    19 dcl  blockp ptr;					/* pointer which block entry is based on */
  3    20 dcl  free_blockp ptr;				/* pointer to head of free space chain */
  3    21 
  3    22 
  3    23 dcl 1 free_block aligned based (free_blockp),		/* format of start of free block */
  3    24     2 next bit (18),				/* foward pointer to next free block */
  3    25     2 size fixed bin;				/* number of words in this block */
  3    26 
  3    27 
  3    28 dcl 1 buffer based (blockp) aligned,			/* buffer definition */
  3    29     2 next fixed bin (18) unal uns,			/* addr of next buffer */
  3    30     2 flags unaligned,
  3    31       3 end_of_page bit (1) unaligned,			/* buffer contains end of page */
  3    32       3 converted bit (1) unaligned,			/* buffer contains converted input */
  3    33       3 break bit (1) unaligned,			/* buffer contains break character */
  3    34       3 mark bit (1) unaligned,			/* buffer contains first character after "mark" */
  3    35       3 turn bit (1) unaligned,			/* ON if the turn must be sent */
  3    36       3 pad bit (1) unaligned,
  3    37     2 size_code fixed bin (3) unal uns,			/* (nwords/16) - 1 */
  3    38     2 tally fixed bin (9) unal uns,			/* number of characters in buffer */
  3    39     2 chars (0:59) char (1) unaligned;			/* room for 60 data characters */
  3    40 
  3    41 /* the following array, if indexed by buffer.size_code will give maximum number of characters permitted in that buffer */
  3    42 
  3    43 dcl  max_buffer_tally (0:7) fixed bin int static options (constant) init (60, 124, 188, 252, 316, 380, 444, 508);
  3    44 
  3    45 /* END INCLUDE FILE ... tty_buffer_block.incl.pl1 */
      615 
      616 
  4     1 /* BEGIN INCLUDE FILE ... lct.incl.pl1 */
  4     2 
  4     3 /* Created by J. Stern 7/26/78 */
  4     4 /* Metering information added by C. Hornig, March 1980. */
  4     5 /* Unwired saved meters added by Robert Coren, December 1980 */
  4     6 
  4     7 dcl  lctp ptr;					/* ptr to logical channel table */
  4     8 dcl  lctep ptr;					/* ptr to logical channel table entry */
  4     9 dcl  lct_size fixed bin;				/* size of lcte_array when allocated */
  4    10 
  4    11 dcl 1 lct aligned based (lctp),			/* logical channel table */
  4    12     2 max_no_lctes fixed bin,				/* maximum number of lct entries */
  4    13     2 cur_no_lctes fixed bin,				/* current number of lct entries used */
  4    14     2 lcnt_ptr ptr,					/* ptr to logical channel name table */
  4    15     2 queue_lock bit (36),				/* lock used to serialize queueing operations */
  4    16     2 pad (11) fixed bin,
  4    17     2 lcte_array (lct_size refer (lct.max_no_lctes)) like lcte; /* lct entries */
  4    18 
  4    19 
  4    20 dcl 1 lcte aligned based (lctep),			/* logical channel table entry */
  4    21     2 lock bit (36),				/* channel lock */
  4    22     2 data_base_ptr ptr unal,				/* ptr to channel data base */
  4    23     2 channel_type fixed bin (8) unal,			/* identifies channel manager program */
  4    24     2 flags unal,
  4    25       3 entry_in_use bit (1) unal,			/* ON if this entry in use */
  4    26       3 initialized bit (1) unal,			/* ON if this channel initialized */
  4    27       3 notify_reqd bit (1) unal,			/* ON if must notify when unlocking this channel */
  4    28       3 locked_for_interrupt bit (1) unal,		/* ON if lock set by interrupt handler */
  4    29       3 space_needed bit (1) unal,			/* ON if this channel needs buffer space */
  4    30       3 special_lock bit (1) unal,			/* ON if lock is managed by multiplexer */
  4    31       3 trace_force bit (1) unal,			/* ON to trace based on next bit only */
  4    32 						/* OFF to XOR next bit with tty_buf.default_tracing */
  4    33       3 trace bit (1) unal,				/* ON to trace this channel */
  4    34       3 unused bit (1) unal,
  4    35     2 physical_channel_devx fixed bin (17) unal,		/* devx of physical chan from which logical chan is derived */
  4    36     2 major_channel_info,
  4    37       3 major_channel_devx fixed bin unal,		/* major channel device index */
  4    38       3 subchannel fixed bin (17) unal,			/* subchannel id (or data ptr) wrt major channel */
  4    39     2 queue_entries,
  4    40       3 queue_head bit (18) unal,			/* ptr to first queue entry for this channel */
  4    41       3 queue_tail bit (18) unal,			/* ptr to last queue entry for this channel */
  4    42     2 word_counts,
  4    43       3 input_words fixed bin (17) unal,		/* number of input words charged to this channel */
  4    44       3 output_words fixed bin (17) unal,		/* number of output words charged to this channel */
  4    45 
  4    46     2 meters,
  4    47       3 in_bytes fixed bin (35),
  4    48       3 out_bytes fixed bin (35),
  4    49       3 in,
  4    50         4 calls fixed bin (35),
  4    51         4 interrupts fixed bin (35),
  4    52         4 call_time fixed bin (71),
  4    53         4 interrupt_time fixed bin (71),
  4    54       3 out like lcte.meters.in,
  4    55       3 control like lcte.meters.in,
  4    56     2 saved_meters_ptr ptr,				/* pointer to unwired copy of meters saved at last dialup */
  4    57 
  4    58     2 timer_offset bit (18) aligned,			/* Head of list of timers for this channel */
  4    59 
  4    60     2 pad (3) fixed bin (35);
  4    61 
  4    62 
  4    63 dcl  lcntp ptr;					/* ptr to logical channel name table */
  4    64 
  4    65 dcl 1 lcnt aligned based (lcntp),			/* logical channel name table */
  4    66     2 names (lct.max_no_lctes) char (32) unal;		/* channel names */
  4    67 
  4    68 dcl 1 saved_meters aligned based like lcte.meters;	/* meters saved at dialup, allocated in tty_area */
  4    69 
  4    70 
  4    71 /* END INCLUDE FILE ... lct.incl.pl1 */
      617 
      618 
  5     1 /* BEGIN INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
  5     2 
  5     3 /* Created 8/25/78 by J. Stern */
  5     4 
  5     5 
  5     6 /* call channel_manager$read (devx, chain_ptr, more_input_flag, code) */
  5     7 dcl channel_manager$read entry (fixed bin, ptr, bit (1) aligned, fixed bin (35));
  5     8 
  5     9 /* call channel_manager$write (devx, output_ptr, code) */
  5    10 dcl channel_manager$write entry (fixed bin, ptr, fixed bin (35));
  5    11 
  5    12 /* call channel_manager$control (devx, control_type, info_ptr, code) */
  5    13 dcl channel_manager$control entry (fixed bin, char (*), ptr, fixed bin (35));
  5    14 
  5    15 /* call channel_manager$set_modes (devx, mode_change_list_ptr, code) */
  5    16 dcl channel_manager$set_modes entry (fixed bin, ptr, fixed bin (35));
  5    17 
  5    18 /* call channel_manager$check_modes (devx, mode_change_list_ptr, code) */
  5    19 dcl channel_manager$check_modes entry (fixed bin, ptr, fixed bin (35));
  5    20 
  5    21 /* call channel_manager$get_modes (devx, modes, code) */
  5    22 dcl channel_manager$get_modes entry (fixed bin, char (*), fixed bin (35));
  5    23 
  5    24 /* call channel_manager$interrupt (devx, int_type, int_data) */
  5    25 dcl channel_manager$interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    26 
  5    27 /* call channel_manager$interrupt_later (devx, int_type, int_data) */
  5    28 dcl channel_manager$interrupt_later entry (fixed bin, fixed bin, bit (72) aligned);
  5    29 
  5    30 /* call channel_manager$queued_interrupt (devx, int_type, int_data) */
  5    31 dcl channel_manager$queued_interrupt entry (fixed bin, fixed bin, bit (72) aligned);
  5    32 
  5    33 
  5    34 /* END INCLUDE FILE ... channel_manager_dcls.incl.pl1 */
      619 
      620 
  6     1 /* BEGIN INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
  6     2 
  6     3 /* Defines constants and structures  used by MCS interrupt handlers */
  6     4 
  6     5 /* Created 08/21/78 by Robert Coren */
  6     6 /* Echo negotiation types added sometime by Bernie Greenberg */
  6     7 /* TIMER and USER_INTERRUPT added in spring of 1982 by Olin Sibert */
  6     8 /* MASKED type added June 23, 1982, by Robert Coren */
  6     9 
  6    10 dcl  DIALUP fixed bin int static options (constant) init (1);
  6    11 dcl  HANGUP fixed bin int static options (constant) init (2);
  6    12 dcl  CRASH fixed bin int static options (constant) init (3);
  6    13 dcl  SEND_OUTPUT fixed bin int static options (constant) init (4);
  6    14 dcl  INPUT_AVAILABLE fixed bin int static options (constant) init (5);
  6    15 dcl  ACCEPT_INPUT fixed bin int static options (constant) init (6);
  6    16 dcl  INPUT_REJECTED fixed bin int static options (constant) init (7);
  6    17 dcl  QUIT fixed bin int static options (constant) init (8);
  6    18 dcl  LINE_STATUS fixed bin int static options (constant) init (9);
  6    19 dcl  DIAL_STATUS fixed bin int static options (constant) init (10);
  6    20 dcl  WRU_TIMEOUT fixed bin int static options (constant) init (11);
  6    21 dcl  SPACE_AVAILABLE fixed bin int static options (constant) init (12);
  6    22 dcl  ACKNOWLEDGE_ECHNEGO_INIT fixed bin int static options (constant) init (13);
  6    23 dcl  ACKNOWLEDGE_ECHNEGO_STOP fixed bin int static options (constant) init (14);
  6    24 dcl  TIMER fixed bin int static options (constant) init (15);
  6    25 dcl  USER_INTERRUPT fixed bin int static options (constant) init (16);
  6    26 dcl  MASKED fixed bin int static options (constant) init (17);
  6    27 
  6    28 dcl  interrupt_info bit (72) aligned;
  6    29 
  6    30 dcl 1 dialup_info aligned,				/* for use with DIALUP interrupt */
  6    31     2 line_type fixed bin (9) unal uns,
  6    32     2 buffer_pad fixed bin (9) unal uns,		/* free space multiplexer would like in output bufs */
  6    33     2 baud_rate fixed bin (18) unal uns,
  6    34     2 max_buf_size fixed bin (9) unal uns,
  6    35     2 receive_mode_device bit (1) unal,			/* device must be told to enter receive mode */
  6    36     2 pad bit (26) unal;
  6    37 
  6    38 dcl 1 rtx_info aligned,				/* for use with ACCEPT_INPUT interrupt */
  6    39     2 input_chain unaligned,
  6    40       3 chain_head bit (18) unaligned,
  6    41       3 chain_tail bit (18) unaligned,
  6    42     2 input_count fixed bin (18) unal uns,
  6    43     2 flags unaligned,
  6    44       3 break_char bit (1),				/* data contains a break character */
  6    45       3 output_in_fnp bit (1),			/* there is output in the FNP */
  6    46       3 output_in_ring_0 bit (1),			/* there is output in ring 0 */
  6    47       3 formfeed_present bit (1),			/* input contains a formfeed character */
  6    48       3 pad bit (14);
  6    49 
  6    50 dcl 1 timer_info aligned,				/* Info supplied with TIMER interrupt */
  6    51     2 id bit (36) aligned,				/* ID which was supplied in call to mcs_timer$set */
  6    52     2 subchan_idx fixed bin;				/* Index of subchannel on whose behalf timer was set */
  6    53 
  6    54 /* END INCLUDE FILE ... mcs_interrupt_info.incl.pl1 */
      621 
      622 
      623 /* BEGIN MESSAGE DOCUMENTATION
      624*
      625*   Message:
      626*   tty_space_man: Lock already locked to process.
      627*
      628*   S:	$crash
      629*
      630*   T:	$run
      631*
      632*   M:	A process that had the global tty_buf lock locked attempted to lock
      633*   it again.
      634*
      635*   A:	$inform
      636*
      637*
      638*   Message:
      639*   tty_space_man: Lock not locked to process.
      640*
      641*   S:	$crash
      642*
      643*   T:	$run
      644*
      645*   M:	A process attempted to unlock the global tty_buf lock when that process
      646*   did not have it locked.
      647*
      648*   A:	$inform
      649*
      650*
      651*   Message:
      652*   tty_space_man: Address not in buffer pool.
      653*
      654*   S:	$crash
      655*
      656*   T:	$run
      657*
      658*   M:	An attempt was made to free space at an address not included in the free
      659*   space pool of tty_buf.
      660*
      661*   A:	$inform
      662*
      663*
      664*   Message:
      665*   tty_space_man: Tried to free space already free.
      666*
      667*   S:	$crash
      668*
      669*   T:	$run
      670*
      671*   M:	An attempt was made to free space in tty_buf that was included in or
      672*   overlapped space that was already free.
      673*
      674*   A:	$inform
      675*
      676*   END MESSAGE DOCUMENTATION */
      677 
      678      end tty_space_man;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0825.4  tty_space_man.pl1                 >special_ldd>install>MR12.3-1114>tty_space_man.pl1
613          1    01/06/85  1422.1  tty_buf.incl.pl1                  >ldd>include>tty_buf.incl.pl1
1-152        2    01/06/85  1422.1  hc_fast_lock.incl.pl1             >ldd>include>hc_fast_lock.incl.pl1
615          3    07/21/88  2036.0  tty_buffer_block.incl.pl1         >ldd>include>tty_buffer_block.incl.pl1
617          4    11/08/82  1005.8  lct.incl.pl1                      >ldd>include>lct.incl.pl1
619          5    05/06/80  0958.2  channel_manager_dcls.incl.pl1     >ldd>include>channel_manager_dcls.incl.pl1
621          6    10/20/82  0938.6  mcs_interrupt_info.incl.pl1       >ldd>include>mcs_interrupt_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
RESERVED_SPACE                         constant        fixed bin(17,0)          initial dcl 70 ref 272
SPACE_AVAILABLE                 000000 constant        fixed bin(17,0)          initial dcl 6-21 set ref 579*
abs_buf_limit                          constant        fixed bin(18,0)          initial dcl 1-19 ref 457
addr                                                   builtin function         dcl 74 ref 223 470 489 493 530 532 572 585
addrel                                                 builtin function         dcl 74 ref 373
alloc_calls              40            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 85* 85 105* 105 186* 186
alloc_failures           45            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 367* 367
alloc_time               42            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 92* 92 121* 121 130* 130
                                                                                  191* 191
arg_blockp                             parameter       pointer                  dcl 34 set ref 78 91* 97 120* 129* 135 140 147* 153
                                                                                  158 165* 171 179 190* 198 202 208* 234 241
arg_count                              parameter       fixed bin(17,0)          dcl 35 ref 97 102
arg_devx                               parameter       fixed bin(17,0)          dcl 27 ref 78 81 97 100 135 138 153 156 217 220
arg_from_devx                          parameter       fixed bin(17,0)          dcl 28 ref 234 237
arg_from_type                          parameter       bit(1)                   packed unaligned dcl 32 ref 234 239
arg_output_flag                        parameter       bit(1)                   packed unaligned dcl 31 ref 78 83 97 103 135 139 153
                                                                                  157
arg_size                               parameter       fixed bin(17,0)          dcl 30 ref 78 82 97 101 171 179 183 183 198 201 201
arg_to_devx                            parameter       fixed bin(17,0)          dcl 29 ref 234 238
arg_to_type                            parameter       bit(1)                   packed unaligned dcl 33 ref 234 240
baseno                                                 builtin function         dcl 74 ref 401 401
best_block_size                 000206 automatic       fixed bin(17,0)          initial dcl 337 set ref 337* 355 355 358* 365
best_blockp                     000204 automatic       pointer                  initial dcl 336 set ref 336* 357* 371
bin                                                    builtin function         dcl 74 ref 114 320 426 428 430 443 445 447
bit                                                    builtin function         dcl 74 ref 320
bleft                     3            based           fixed bin(18,0)          level 2 dcl 1-35 set ref 272 383* 383 384 384 456*
                                                                                  456 457
blockp                          000130 automatic       pointer                  dcl 3-19 set ref 88 91 110 112 114 116 124* 126 140*
                                                                                  158* 188* 190 202* 206* 241* 244 245 246 246* 248*
                                                                                  248 272* 275* 276 278 281* 295 297* 301* 314* 318
                                                                                  320 322* 324*
borig                     2            based           bit(18)                  level 2 dcl 1-35 ref 401
buffer                                 based           structure                level 1 dcl 3-28
buffer_size                     000102 automatic       fixed bin(17,0)          dcl 41 set ref 82* 87* 88* 101* 109* 118 183* 188*
                                                                                  192* 201* 206* 210
caller                          000012 constant        entry                    external dcl 61 ref 259 259 281 281 297 297 314 314
channel_manager$interrupt       000026 constant        entry                    external dcl 5-25 ref 579
clock                                                  builtin function         dcl 74 ref 92 121 130 148 166 191 209 473 491 495
control_space_updates
                         56            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 561* 561
count                           000103 automatic       fixed bin(17,0)          dcl 42 set ref 102* 108 118
cumulative_control_space
                         52            based           fixed bin(71,0)          level 2 dcl 1-35 set ref 560* 560
cumulative_input_space
                         46            based           fixed bin(71,0)          level 2 dcl 1-35 set ref 544* 544
cumulative_output_space
                         50            based           fixed bin(71,0)          level 2 dcl 1-35 set ref 537* 537
current_control_space
                         62            based           fixed bin(18,0)          level 2 dcl 1-35 set ref 559* 559 560
current_input_space      60            based           fixed bin(18,0)          level 2 dcl 1-35 set ref 543* 543 544
current_output_space     61            based           fixed bin(18,0)          level 2 dcl 1-35 set ref 536* 536 537
devx                            000112 automatic       fixed bin(17,0)          dcl 47 set ref 81* 100* 138* 156* 220* 223 251* 254*
                                                                                  281* 297* 314* 528 528 530
divide                                                 builtin function         dcl 74 ref 278
enable                  102            based           bit(1)                   level 4 packed packed unaligned dcl 1-35 ref 259 281
                                                                                  297 314
enter_time                      000124 automatic       fixed bin(71,0)          dcl 55 set ref 92 121 130 148 166 191 209 473*
first_blockp                    000110 automatic       pointer                  dcl 46 set ref 107* 112* 120 124
flags                     2(09)        based           structure                level 2 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "tty_space_man"
flags                   102            based           structure                level 3 in structure "tty_buf" packed packed
                                                                                  unaligned dcl 1-35 in procedure "tty_space_man"
free                      4            based           bit(18)                  level 2 dcl 1-35 set ref 345 377* 407 439*
free_block                             based           structure                level 1 dcl 3-23
free_blockp                     000132 automatic       pointer                  dcl 3-20 set ref 345* 345* 348 350 353 355 357 358
                                                                                  362* 363 371* 373 375 376 382 387 403* 404 405
                                                                                  407* 407* 409 411 413* 414 418* 423 425* 426 426
                                                                                  432 433 433 435 439 445 447 449 450 452
free_calls               41            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 142* 142 160* 160 204* 204
free_space                             based           bit(36)                  array dcl 342 set ref 382*
free_time                43            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 148* 148 166* 166 209* 209
from_devx                       000113 automatic       fixed bin(17,0)          dcl 48 set ref 237* 251 259*
from_type                       000115 automatic       bit(1)                   packed unaligned dcl 50 set ref 239* 252
hc_fast_lock                           based           structure                level 1 dcl 2-10
i                               000306 automatic       fixed bin(17,0)          dcl 569 in procedure "interrupt_waiting_procs" set
                                                                                  ref 571* 572 579* 584* 585*
i                               000105 automatic       fixed bin(17,0)          dcl 44 in procedure "tty_space_man" set ref 108*
                                                                                  112*
in                       30            based           structure                array level 4 in structure "lct" dcl 4-11
                                                                                  in procedure "tty_space_man"
in                       10            based           structure                level 3 in structure "lcte" dcl 4-20 in procedure
                                                                                  "tty_space_man"
in                        2            based           structure                level 2 in structure "saved_meters" dcl 4-68
                                                                                  in procedure "tty_space_man"
initialized               2(10)        based           bit(1)                   level 3 packed packed unaligned dcl 4-20 ref 573 586
input_space_updates      54            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 545* 545
input_words               5            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-20 set ref
                                                                                  542* 542
lct                                    based           structure                level 1 dcl 4-11
lct_ptr                   6            based           pointer                  level 2 dcl 1-35 ref 471
lcte                                   based           structure                level 1 dcl 4-20
lcte_array               20            based           structure                array level 2 dcl 4-11 set ref 223 530 532 572 585
lctep                           000136 automatic       pointer                  dcl 4-8 set ref 223* 224 530* 531 532* 535 535 542
                                                                                  542 572* 573 573 577 585* 586 586
lctp                            000134 automatic       pointer                  dcl 4-7 set ref 223 471* 528 530 532 571 572 584 585
max_no_lctes                           based           fixed bin(17,0)          level 2 dcl 4-11 ref 528 571 584
mcs_trace                       000014 constant        entry                    external dcl 62 ref 259 281 297 314
meters                    6            based           structure                level 2 in structure "lcte" dcl 4-20 in procedure
                                                                                  "tty_space_man"
meters                   26            based           structure                array level 3 in structure "lct" dcl 4-11
                                                                                  in procedure "tty_space_man"
minimum_free_space       57            based           fixed bin(18,0)          level 2 dcl 1-35 set ref 384 384 384*
mod                                                    builtin function         dcl 74 ref 183 201
n                                      parameter       fixed bin(17,0)          dcl 334 in procedure "space_getter" ref 331 348 353
                                                                                  373 376 382 383
n                                      parameter       fixed bin(17,0)          dcl 525 in procedure "update_lcte" ref 522 535 536
                                                                                  542 543
n                                      parameter       fixed bin(17,0)          dcl 270 in procedure "buffer_getter" set ref 267
                                                                                  275* 278 281*
n                                      parameter       fixed bin(17,0)          dcl 603 in procedure "err" set ref 600 605*
n                               000164 automatic       fixed bin(17,0)          dcl 293 in procedure "buffer_freer" set ref 295*
                                                                                  297* 301* 302
n                                      parameter       fixed bin(17,0)          dcl 397 in procedure "space_freer" ref 393 404 456
n                                      parameter       fixed bin(17,0)          dcl 557 in procedure "update_control" ref 554 559
next                                   based           bit(18)                  level 2 in structure "free_block" dcl 3-23
                                                                                  in procedure "tty_space_man" set ref 350 363 375*
                                                                                  375 380* 405* 414 432* 432 435* 449* 449 452*
next                                   based           fixed bin(18,0)          level 2 in structure "buffer" packed packed unsigned
                                                                                  unaligned dcl 3-28 in procedure "tty_space_man"
                                                                                  set ref 114* 246 248 320
next_blockp                     000232 automatic       pointer                  dcl 398 set ref 423* 428 430 432 433 435
next_rel                        000234 automatic       fixed bin(18,0)          dcl 399 in procedure "space_freer" set ref 426* 428
                                                                                  430 443* 445 447
next_rel                        000214 automatic       bit(18)                  packed unaligned dcl 340 in procedure "space_getter"
                                                                                  set ref 350* 374* 377 380
next_rel                        000174 automatic       bit(18)                  packed unaligned dcl 312 in procedure "chain_freer"
                                                                                  set ref 318* 319 320* 322
nsteps                          000220 automatic       fixed bin(17,0)          initial dcl 343 set ref 343* 347* 347 386
null                                                   builtin function         dcl 74 ref 88 107 110 126 129 147 165 208 244 246
                                                                                  272 276 324 336 338 339 368 377 406 439
output_flag                     000100 automatic       bit(1)                   packed unaligned dcl 39 set ref 83* 103* 139* 157*
                                                                                  252* 255* 533
output_space_updates     55            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 538* 538
output_words              5(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 4-20 set ref
                                                                                  535* 535
p                               000216 automatic       pointer                  dcl 341 in procedure "space_getter" set ref 373* 374
                                                                                  375 376
p                                      parameter       pointer                  dcl 396 in procedure "space_freer" ref 393 401 401
                                                                                  403 409 411 418 425
pc_devx                         000270 automatic       fixed bin(17,0)          dcl 526 set ref 531* 532
pds$processid                   000010 external static bit(36)                  packed unaligned dcl 59 ref 487 489 493 503
perm                            000101 automatic       bit(1)                   packed unaligned dcl 40 set ref 174* 182* 192
physical_channel_devx
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-20 ref 531
pmut$unwire_unmask              000020 constant        entry                    external dcl 64 ref 515
pmut$wire_and_mask              000016 constant        entry                    external dcl 63 ref 472
prev_best_blockp                000210 automatic       pointer                  initial dcl 338 set ref 338* 359* 372
prev_blockp                     000106 automatic       pointer                  dcl 45 in procedure "tty_space_man" set ref 107* 114
                                                                                  116*
prev_blockp                     000230 automatic       pointer                  dcl 398 in procedure "space_freer" set ref 406* 413*
                                                                                  439 443 443 449 450 450 452
prev_blockp                     000212 automatic       pointer                  initial dcl 339 in procedure "space_getter" set ref
                                                                                  339* 359 362* 372* 377 380
ptr                                                    builtin function         dcl 74 ref 248 322 345 363 407 414
rel                                                    builtin function         dcl 74 ref 114 318 345 374 401 407 409 409 411 411
                                                                                  426 428 430 435 439 443 445 447 452
size                      1            based           fixed bin(17,0)          level 2 dcl 3-23 set ref 348 353 355 358 376* 376
                                                                                  404* 426 433* 433 433 443 450* 450 450
size_code                 0(24)        based           fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 3-28
                                                                                  set ref 245 278* 295
slock                                  based           bit(36)                  level 2 dcl 1-35 set ref 487 489 493 503
space_lock_count         35            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 497* 497
space_lock_wait_count
                         36            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 492* 492
space_lock_wait_time     37            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 495* 495
space_man               102(11)        based           bit(1)                   level 4 packed packed unaligned dcl 1-35 ref 259 281
                                                                                  297 314
space_needed             34            based           bit(1)                   level 3 in structure "tty_buf" packed packed
                                                                                  unaligned dcl 1-35 in procedure "tty_space_man"
                                                                                  set ref 225* 457 591*
space_needed              2(13)        based           bit(1)                   level 3 in structure "lcte" packed packed unaligned
                                                                                  dcl 4-20 in procedure "tty_space_man" set ref 224*
                                                                                  573 577* 586
space_needed_calls       34(01)        based           fixed bin(34,0)          level 3 packed packed unaligned dcl 1-35 set ref
                                                                                  226* 226
space_needed_data        34            based           structure                level 2 dcl 1-35
stac                                                   builtin function         dcl 74 ref 489 493
stacq                                                  builtin function         dcl 74 ref 503
start_time                      000252 automatic       fixed bin(71,0)          dcl 485 set ref 491* 495
syserr                          000022 constant        entry                    external dcl 66 ref 605
to_devx                         000114 automatic       fixed bin(17,0)          dcl 49 set ref 238* 254 259*
to_type                         000116 automatic       bit(1)                   packed unaligned dcl 51 set ref 240* 255
total_alloc_steps        44            based           fixed bin(35,0)          level 2 dcl 1-35 set ref 386* 386
total_freed                     000117 automatic       fixed bin(17,0)          dcl 52 set ref 145 163 302* 302 475*
trace                   102            based           structure                level 2 packed packed unaligned dcl 1-35
tty_buf                                based           structure                level 1 dcl 1-35
tty_buf$                        000024 external static fixed bin(17,0)          dcl 1-19 set ref 470
ttybp                           000126 automatic       pointer                  dcl 1-19 set ref 85 85 92 92 105 105 121 121 130 130
                                                                                  142 142 148 148 160 160 166 166 186 186 191 191
                                                                                  204 204 209 209 225 226 226 248 259 259 272 281
                                                                                  281 297 297 314 314 322 345 345 363 367 367 377
                                                                                  383 383 384 384 384 384 384 386 386 401 401 407
                                                                                  407 414 439 456 456 457 457 470* 471 487 489 492
                                                                                  492 493 495 495 497 497 503 536 536 537 537 537
                                                                                  538 538 543 543 544 544 544 545 545 559 559 560
                                                                                  560 560 561 561 591
unspec                                                 builtin function         dcl 74 set ref 382*
wire_mask                       000120 automatic       fixed bin(71,0)          dcl 53 set ref 472* 515*
wire_ptr                        000122 automatic       pointer                  dcl 54 set ref 472* 515*
word_count                      000104 automatic       fixed bin(17,0)          dcl 43 set ref 243* 245* 245 253 256* 259*
word_counts               5            based           structure                level 2 dcl 4-20

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCEPT_INPUT                           internal static fixed bin(17,0)          initial dcl 6-15
ACKNOWLEDGE_ECHNEGO_INIT               internal static fixed bin(17,0)          initial dcl 6-22
ACKNOWLEDGE_ECHNEGO_STOP               internal static fixed bin(17,0)          initial dcl 6-23
CRASH                                  internal static fixed bin(17,0)          initial dcl 6-12
DIALUP                                 internal static fixed bin(17,0)          initial dcl 6-10
DIAL_STATUS                            internal static fixed bin(17,0)          initial dcl 6-19
FNP_DUMP_PATCH_EVENT                   internal static fixed bin(17,0)          initial dcl 1-31
FNP_METER_EVENT                        internal static fixed bin(17,0)          initial dcl 1-32
HANGUP                                 internal static fixed bin(17,0)          initial dcl 6-11
INPUT_AVAILABLE                        internal static fixed bin(17,0)          initial dcl 6-14
INPUT_REJECTED                         internal static fixed bin(17,0)          initial dcl 6-16
LINE_STATUS                            internal static fixed bin(17,0)          initial dcl 6-18
MASKED                                 internal static fixed bin(17,0)          initial dcl 6-26
QUIT                                   internal static fixed bin(17,0)          initial dcl 6-17
SEND_OUTPUT                            internal static fixed bin(17,0)          initial dcl 6-13
TIMER                                  internal static fixed bin(17,0)          initial dcl 6-24
TTY_AREA_LOCK_EVENT                    internal static bit(36)                  initial dcl 1-33
USER_INTERRUPT                         internal static fixed bin(17,0)          initial dcl 6-25
WRU_TIMEOUT                            internal static fixed bin(17,0)          initial dcl 6-20
bsizec                                 internal static fixed bin(17,0)          initial dcl 1-28
buf_per_second                         internal static fixed bin(17,0)          initial dcl 1-29
channel_manager$check_modes     000000 constant        entry                    external dcl 5-19
channel_manager$control         000000 constant        entry                    external dcl 5-13
channel_manager$get_modes       000000 constant        entry                    external dcl 5-22
channel_manager$interrupt_later 000000 constant        entry                    external dcl 5-28
channel_manager$queued_interrupt
                                000000 constant        entry                    external dcl 5-31
channel_manager$read            000000 constant        entry                    external dcl 5-7
channel_manager$set_modes       000000 constant        entry                    external dcl 5-16
channel_manager$write           000000 constant        entry                    external dcl 5-10
dialup_info                            automatic       structure                level 1 dcl 6-30
input_bpart                            internal static fixed bin(18,0)          initial dcl 1-19
interrupt_info                         automatic       bit(72)                  dcl 6-28
lcnt                                   based           structure                level 1 dcl 4-65
lcntp                                  automatic       pointer                  dcl 4-63
lct_size                               automatic       fixed bin(17,0)          dcl 4-9
lock_ptr                               automatic       pointer                  dcl 2-9
max_buffer_tally                       internal static fixed bin(17,0)          initial array dcl 3-43
output_bpart                           internal static fixed bin(18,0)          initial dcl 1-19
pxss$unique_ring_0_wakeup       000000 constant        entry                    external dcl 65
qblock_size                            internal static fixed bin(17,0)          initial dcl 1-27
rtx_info                               automatic       structure                level 1 dcl 6-38
saved_meters                           based           structure                level 1 dcl 4-68
timer_info                             automatic       structure                level 1 dcl 6-50
tty_ev                                 internal static fixed bin(17,0)          initial dcl 1-19

NAMES DECLARED BY EXPLICIT CONTEXT.
buffer_freer                    001173 constant        entry                    internal dcl 290 ref 144 321
buffer_getter                   001063 constant        entry                    internal dcl 267 ref 87 109
call_syserr                     002262 constant        label                    dcl 605 ref 609
chain_back                      001653 constant        label                    dcl 439 ref 419
chain_freer                     001257 constant        entry                    internal dcl 309 ref 126 162
clean_up                        002043 constant        entry                    internal dcl 511 ref 90 119 128 146 164 189 207 228
                                                                                  257
err                             002260 constant        entry                    internal dcl 600 ref 401 411 428 445 487 503
fit_found                       001461 constant        label                    dcl 377 ref 351
found_hole                      001617 constant        label                    dcl 423 ref 409
free_buffer                     000360 constant        entry                    external dcl 135
free_chain                      000433 constant        entry                    external dcl 153
free_space                      000576 constant        entry                    external dcl 198
get_buffer                      000136 constant        entry                    external dcl 78
get_chain                       000220 constant        entry                    external dcl 97
get_chain_failed                000334 constant        label                    dcl 124 ref 110
get_perm_space                  000526 constant        entry                    external dcl 179
get_space                       000510 constant        entry                    external dcl 171
get_space_join                  000542 constant        label                    dcl 183 ref 175
interrupt_waiting_procs         002162 constant        entry                    internal dcl 566 ref 457
lock                            001754 constant        entry                    internal dcl 482 ref 474 580
needs_space                     000650 constant        entry                    external dcl 217
setup                           001731 constant        entry                    internal dcl 467 ref 84 104 141 159 185 203 221 242
space_freer                     001523 constant        entry                    internal dcl 393 ref 206 301
space_getter                    001354 constant        entry                    internal dcl 331 ref 188 275
switch_chain                    000711 constant        entry                    external dcl 234
tty_space_man                   000123 constant        entry                    external dcl 22
unlock                          002027 constant        entry                    internal dcl 500 ref 514 578
update_control                  002145 constant        entry                    internal dcl 554 ref 192 210
update_lcte                     002057 constant        entry                    internal dcl 522 ref 88 118 145 163 253 256

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2574        2624    2371        2604
Length      3152    2371        30         312     203           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tty_space_man                       436 external procedure  is an external procedure.  
buffer_getter                           internal procedure  shares stack frame of external procedure tty_space_man.  
buffer_freer                            internal procedure  shares stack frame of external procedure tty_space_man.  
chain_freer                             internal procedure  shares stack frame of external procedure tty_space_man.  
space_getter                            internal procedure  shares stack frame of external procedure tty_space_man.  
space_freer                             internal procedure  shares stack frame of external procedure tty_space_man.  
setup                                   internal procedure  shares stack frame of external procedure tty_space_man.  
lock                                    internal procedure  shares stack frame of external procedure tty_space_man.  
clean_up                                internal procedure  shares stack frame of external procedure tty_space_man.  
update_lcte                             internal procedure  shares stack frame of external procedure tty_space_man.  
update_control                          internal procedure  shares stack frame of external procedure tty_space_man.  
interrupt_waiting_procs                 internal procedure  shares stack frame of external procedure tty_space_man.  
err                                     internal procedure  shares stack frame of external procedure tty_space_man.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tty_space_man            000100 output_flag                 tty_space_man
                         000101 perm                        tty_space_man
                         000102 buffer_size                 tty_space_man
                         000103 count                       tty_space_man
                         000104 word_count                  tty_space_man
                         000105 i                           tty_space_man
                         000106 prev_blockp                 tty_space_man
                         000110 first_blockp                tty_space_man
                         000112 devx                        tty_space_man
                         000113 from_devx                   tty_space_man
                         000114 to_devx                     tty_space_man
                         000115 from_type                   tty_space_man
                         000116 to_type                     tty_space_man
                         000117 total_freed                 tty_space_man
                         000120 wire_mask                   tty_space_man
                         000122 wire_ptr                    tty_space_man
                         000124 enter_time                  tty_space_man
                         000126 ttybp                       tty_space_man
                         000130 blockp                      tty_space_man
                         000132 free_blockp                 tty_space_man
                         000134 lctp                        tty_space_man
                         000136 lctep                       tty_space_man
                         000164 n                           buffer_freer
                         000174 next_rel                    chain_freer
                         000204 best_blockp                 space_getter
                         000206 best_block_size             space_getter
                         000210 prev_best_blockp            space_getter
                         000212 prev_blockp                 space_getter
                         000214 next_rel                    space_getter
                         000216 p                           space_getter
                         000220 nsteps                      space_getter
                         000230 prev_blockp                 space_freer
                         000232 next_blockp                 space_freer
                         000234 next_rel                    space_freer
                         000252 start_time                  lock
                         000270 pc_devx                     update_lcte
                         000306 i                           interrupt_waiting_procs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          stac_mac            mdfx1               ext_entry
stacq_mac           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
caller                        channel_manager$interrupt     mcs_trace                     pmut$unwire_unmask
pmut$wire_and_mask            syserr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pds$processid                 tty_buf$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000122        78 000130        81 000152        82 000155        83 000157        84 000164        85 000165
     87 000172        88 000174        90 000202        91 000203        92 000205        93 000212        97 000213
    100 000234       101 000237       102 000241       103 000243       104 000250       105 000251       107 000256
    108 000261       109 000271       110 000273       112 000277       114 000305       116 000312       117 000314
    118 000316       119 000323       120 000324       121 000326       122 000333       124 000334       126 000336
    128 000343       129 000344       130 000346       131 000353       135 000354       138 000372       139 000375
    140 000402       141 000405       142 000406       144 000413       145 000414       146 000420       147 000421
    148 000423       149 000430       153 000431       156 000445       157 000450       158 000455       159 000460
    160 000461       162 000466       163 000467       164 000473       165 000474       166 000476       167 000503
    171 000504       174 000522       175 000523       179 000524       182 000540       183 000542       185 000547
    186 000550       188 000555       189 000557       190 000560       191 000562       192 000567       194 000573
    198 000574       201 000610       202 000615       203 000620       204 000621       206 000626       207 000630
    208 000631       209 000633       210 000640       211 000644       217 000645       220 000655       221 000660
    223 000661       224 000666       225 000670       226 000673       228 000702       229 000703       234 000704
    237 000721       238 000724       239 000726       240 000733       241 000740       242 000743       243 000744
    244 000745       245 000752       246 000760       248 000767       249 000772       251 000773       252 000775
    253 000777       254 001003       255 001005       256 001007       257 001011       259 001012       263 001062
    267 001063       272 001065       275 001074       276 001104       278 001111       281 001121       285 001172
    290 001173       295 001174       297 001202       301 001252       302 001254       303 001256       309 001257
    314 001260       318 001330       319 001332       320 001334       321 001343       322 001344       323 001350
    324 001351       325 001353       331 001354       336 001356       337 001360       338 001361       339 001362
    343 001363       345 001364       347 001374       348 001375       350 001402       351 001404       353 001405
    355 001406       357 001412       358 001413       359 001415       362 001417       363 001420       365 001425
    367 001427       368 001434       371 001440       372 001442       373 001444       374 001451       375 001453
    376 001455       377 001461       380 001471       382 001473       383 001504       384 001507       386 001515
    387 001521       393 001523       401 001525       403 001546       404 001552       405 001554       406 001555
    407 001557       409 001567       411 001576       413 001603       414 001605       418 001612       419 001616
    423 001617       425 001621       426 001622       428 001626       430 001642       432 001643       433 001645
    434 001650       435 001651       439 001653       443 001663       445 001670       447 001704       449 001705
    450 001707       451 001712       452 001713       456 001715       457 001721       461 001730       467 001731
    470 001732       471 001735       472 001737       473 001747       474 001751       475 001752       476 001753
    482 001754       487 001755       489 001765       491 001774       492 001776       493 002003       494 002013
    495 002014       497 002021       498 002026       500 002027       503 002030       505 002042       511 002043
    514 002044       515 002045       516 002056       522 002057       528 002061       530 002067       531 002073
    532 002077       533 002103       535 002105       536 002112       537 002115       538 002120       539 002124
    542 002125       543 002132       544 002135       545 002140       547 002144       554 002145       559 002147
    560 002152       561 002155       562 002161       566 002162       571 002163       572 002173       573 002177
    577 002205       578 002207       579 002210       580 002225       582 002226       584 002230       585 002237
    586 002243       589 002252       591 002254       592 002257       600 002260       605 002262       609 002311


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
