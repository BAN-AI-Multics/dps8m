	COMPILATION LISTING OF SEGMENT set_alarm_timer
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1001.2 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 /* SET_ALARM_TIMER - This procedure establishes a simulated wakeup at
       15*   a designated clock time.
       16*
       17*   declare set_alarm_timer ext entry(fixed bin(71),fixed bin,fixed bin(71));
       18*   call set_alarm_timer(time,asw,event_channel);
       19*
       20*   1. time		time of event or wakeup(Input).
       21*
       22*   2. asw		1 if time is relative to current time, 2 if time is absolute(Input).
       23*
       24*   3. event_channel	is event channel over which wakeup is to be sent; 0 if IPS signal
       25*   is to be sent(Input).
       26*
       27*   Modified January 1985 by Keith Loepere to fix argument copying while masked.
       28*   Modified November 1984 by M. Pandolf to include hc_lock
       29*   Modified Spring '77 by RE Mullen for concurrent scheduler
       30*   Coded by R. J. Feiertag on July 25, 1971		*/
       31 
       32 set_alarm_timer: proc (atime, asw, aevent);
       33 
       34 /* Parameters */
       35 
       36 dcl  aevent			fixed bin (71) parameter; /* event channel for wakeup */
       37 dcl  asw				fixed bin parameter;/* absolute or relative time */
       38 dcl  atime			fixed bin (71) parameter; /* time of wakeup */
       39 
       40 /* Variables */
       41 
       42 dcl  current_time			fixed bin (71);	/* current clock time */
       43 dcl  esw				fixed bin;	/* internal copy of absolute-relative time switch */
       44 dcl  event			fixed bin (71);	/* internal copy of event channel */
       45 dcl  naptep			ptr;		/* pointer to APT entry of next process in list */
       46 dcl  oaptep			ptr;		/* pointer to APT entry of last process in list */
       47 dcl  time				fixed bin (71);	/* internal copy of time of wakeup */
       48 dcl  wire_arg			bit (72) aligned;	/* mask with pmut's nasty note or'ed into it */
       49 dcl  wired_stack_ptr		pointer;		/* ptp, actually */
       50 
       51 /* Based */
       52 
       53 dcl  bit20			bit (20) based;
       54 
       55 /* External */
       56 
       57 dcl  pds$apt_ptr			ext ptr;		/* pointer to APT entry of this process */
       58 dcl  tc_data$			ext;		/* traffic controller data base */
       59 dcl  tc_data$alarm_timer_list		ext bit (18) aligned; /* offset to list of processes with alarms pending */
       60 dcl  tc_data$next_alarm_time		ext fixed bin (71); /* time of next simulated alarm */
       61 
       62 /* Entries */
       63 
       64 dcl  pxss$lock_apt			entry ();		/* only way to touch apt lock */
       65 dcl  pxss$unlock_apt		entry ();		/* only way to touch apt lock */
       66 dcl  pmut$unwire_unmask		entry (bit (72) aligned, pointer);
       67 dcl  pmut$wire_and_mask		entry (bit (72) aligned, pointer);
       68 
       69 /* Misc */
       70 
       71 dcl  (addr, bit, clock, fixed, ptr, rel) builtin;
       72 
       73 	esw = asw;				/* copy relative-absolute time switch */
       74 	go to join;				/* join common code */
       75 
       76 /* SET_ALARM - This procedure is identical to set_alarm_timer except that only
       77*   absolute times are accepted.				*/
       78 
       79 set_alarm: entry (atime, aevent);
       80 
       81 	esw = 2;					/* only absolute times */
       82 
       83 join:
       84 	current_time = clock;			/* get current time */
       85 	if esw = 1 then time = current_time + atime;	/* calculate absolute time from relative */
       86 	else time = atime;
       87 	if time < current_time then time = current_time;	/* make sure time is current */
       88 	event = aevent;				/* copy event channel */
       89 
       90 	call pmut$wire_and_mask (wire_arg, wired_stack_ptr);
       91 
       92 	aptep = pds$apt_ptr;			/* get pointer to APT entry */
       93 	tcmp = addr (tc_data$);			/* get pointer to traffic controller meters */
       94 	call pxss$lock_apt ();			/* TRAFFIC CONTROLLER LOCKED */
       95 	if aptep -> apte.alarm_time then do;		/* this process already has a timer pending */
       96 	     if tc_data$alarm_timer_list = rel (aptep) then
       97 		tc_data$alarm_timer_list = aptep -> apte.alarm_time_thread;
       98 						/* if this process first on list then thread it out */
       99 	     else do;				/* not first on list */
      100 		naptep = ptr (aptep, tc_data$alarm_timer_list); /* get pointer to first entry */
      101 		do while (naptep -> apte.alarm_time_thread ^= rel (aptep));
      102 						/* find this process's position in list */
      103 		     naptep = ptr (naptep, naptep -> apte.alarm_time_thread); /* go to next entry */
      104 		end;
      105 		naptep -> apte.alarm_time_thread = aptep -> apte.alarm_time_thread; /* thread out of list */
      106 	     end;
      107 	     aptep -> apte.alarm_time_thread = ""b;	/* no alarm pending */
      108 	     aptep -> apte.alarm_time = ""b;
      109 	end;
      110 	if addr (time) -> bit20 then go to finish;	/* time too large */
      111 	oaptep, naptep = ptr (aptep, tc_data$alarm_timer_list); /* get pointer to first entry on list */
      112 	if time <= fixed (oaptep -> apte.alarm_time, 54) | rel (oaptep) = ""b then
      113 	     tc_data$alarm_timer_list = rel (aptep);	/* thread in at head of list */
      114 	else do;					/* not first on list */
      115 	     naptep = ptr (oaptep, oaptep -> apte.alarm_time_thread); /* get pointer to next entry */
      116 	     do while (time > fixed (naptep -> apte.alarm_time, 54) & rel (naptep) ^= ""b);
      117 						/* find position in list for this entry */
      118 		oaptep = naptep;			/* new last entry is current entry */
      119 		naptep = ptr (naptep, naptep -> apte.alarm_time_thread); /* get next entry */
      120 	     end;
      121 	     oaptep -> apte.alarm_time_thread = rel (aptep); /* thread into list */
      122 	end;
      123 	aptep -> apte.alarm_time_thread = rel (naptep);	/* complete the thread */
      124 	aptep -> apte.alarm_time = bit (fixed (time, 54));/* fill in time of alarm */
      125 	aptep -> apte.alarm_event = event;		/* fill in event channel */
      126 	if time < tc_data$next_alarm_time then tc_data$next_alarm_time = time;
      127 						/* update time of next alarm */
      128 finish:
      129 
      130 	call pxss$unlock_apt ();			/* TRAFFIC CONTROLLER UNLOCKED */
      131 	call pmut$unwire_unmask (wire_arg, wired_stack_ptr);
      132 	return;
      133 
      134 
      135 /* GET_ALARM_TIMER - This entry returns the current value of the pending timer
      136*and the associated event channel.
      137*
      138*   declare get_alarm_timer ext entry(fixed bin(71),fixed bin(71));
      139*   call get_alarm_timer(time,event_channel);
      140*
      141*   1. time		timer of alarm(Output).
      142*
      143*   2. event_channel		event channel for wakeup(Output).
      144*						   */
      145 
      146 get_alarm_timer: entry (atime, aevent);
      147 
      148 	call pmut$wire_and_mask (wire_arg, wired_stack_ptr);
      149 
      150 	aptep = pds$apt_ptr;			/* get pointer to APT entry */
      151 	tcmp = addr (tc_data$);			/* get pointer to traffic control meters */
      152 	call pxss$lock_apt ();			/* TRAFFIC CONTROLLER LOCKED */
      153 	time = fixed (aptep -> apte.alarm_time, 54);	/* get time of alarm */
      154 	event = aptep -> apte.alarm_event;		/* get event channel */
      155 	call pxss$unlock_apt ();			/* TRAFFIC CONTROLLER UNLOCKED */
      156 	call pmut$unwire_unmask (wire_arg, wired_stack_ptr);
      157 
      158 	atime = time;				/* return values */
      159 	aevent = event;
      160 	return;
      161  /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  1     2 
  1     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  1     4 
  1     5 dcl  aptep pointer;
  1     6 
  1     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  1     8     2 thread unaligned,				/* List thread */
  1     9       3 fp bit (18),				/* Forward pointer */
  1    10       3 bp bit (18),				/* Backward pointer */
  1    11     2 flags unaligned,				/* Flags and miscellaneous */
  1    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  1    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  1    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  1    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  1    16       3 hproc bit (1),				/* ON if process is hardcore process */
  1    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  1    18       3 eligible bit (1),				/* ON if process is eligible */
  1    19       3 idle bit (1),				/* ON if  this is an idle process */
  1    20       3 interaction bit (1),				/* ON if process has interacted recently */
  1    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  1    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  1    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  1    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  1    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  1    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  1    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  1    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  1    29       3 firstsw bit (1),				/* OFF until process is intialized */
  1    30       3 state bit (18),				/* execution state */
  1    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  1    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  1    33 						/* bit 18-35: sequential number */
  1    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  1    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  1    36     2 ti fixed bin (35),				/* virtual time since interaction */
  1    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  1    38 
  1    39 /* * * * * * * * */
  1    40 
  1    41     2 ipc_pointers unaligned,
  1    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  1    43       3 pad3 bit (18),
  1    44     2 ips_message bit (36),				/* IPS signals pending */
  1    45     2 asteps unaligned,				/* relative ASTE pointers */
  1    46       3 pds bit (18),				/* PDS (per-process) */
  1    47       3 dseg bit (18),				/* DSEG (per-process) */
  1    48       3 prds bit (18),				/* PRDS (per-processor) */
  1    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  1    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  1    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  1    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  1    53 
  1    54 /* * * * * * * * */
  1    55 
  1    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  1    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  1    58     2 flags2 unaligned,
  1    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  1    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  1    61       3 pad7 bit (7),
  1    62       3 batch bit (1),				/* ON if absentee */
  1    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  1    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  1    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  1    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  1    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  1    68 
  1    69 /* * * * * * */
  1    70 
  1    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  1    72     2 ws_size fixed bin,				/* working set estimate for the process */
  1    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  1    74     2 deadline fixed bin (71),			/* time of next run */
  1    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  1    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  1    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  1    78*						/* reaches this (units = 1/1024 sec) */
  1    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  1    80     2 access_authorization bit (72),			/* authorization of this process */
  1    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  1    82 
  1    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  1    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  1    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  1    86 
  1    87 /*  Cells used to drive and instrument finite-state model for response time
  1    88*    measurement. Maintained by meter_response_time */
  1    89 
  1    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  1    91     2 pad18 bit (18) unaligned,
  1    92     2 number_processing fixed bin (35),			/* Number interactions */
  1    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  1    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  1    95 
  1    96 /* * * * * * */
  1    97 
  1    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  1    99 
  1   100 /*  End of cells for finite-state model */
  1   101 
  1   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  1   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  1   104     2 pad4 bit (28) unaligned,
  1   105     2 ipc_r_offset fixed bin (18) unsigned,
  1   106     2 ipc_r_factor fixed bin (35) unsigned,
  1   107     2 apad (10) fixed bin (35);
  1   108 
  1   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      161 
      162  /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  2     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  2     3*   encourages name conflicts.
  2     4*   USE HC_FAST_LOCK INSTEAD!
  2     5**/
  2     6 
  2     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  2     8 
  2     9 /* format: style3 */
  2    10 
  2    11 declare	lock_ptr		pointer;
  2    12 declare	1 lock		aligned based (lock_ptr),
  2    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  2    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  2    15 	  2 flags		aligned,
  2    16 	    3 notify_sw	bit (1) unaligned,
  2    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  2    18 
  2    19 /* End include file hc_lock.incl.pl1 */
      162 
      163  /* BEGIN INCLUDE FILE ... tcm.incl.pl1 ... used to generate tc_data cds */
  3     2 /* NOTE -- This include file has TWO counterparts in ALM: tc_meters.incl.alm and */
  3     3 /* wcte.incl.alm. They cannot be produced with cif, and must be kept up to date manually. */
  3     4 /* Modified 830914 to replace tty_polling_time with opc_polling_time... -E. A. Ranzenbach */
  3     5 /* Modified 1984.05.21 by M. Pandolf to add tc_suspend_lock */
  3     6 /* Modified 1984.11.26 by Keith Loepere for uid_array. */
  3     7 /* Modified 1984.12.06 by Keith Loepere for page create delaying. */
  3     8 
  3     9 dcl  tcmp ptr;
  3    10 
  3    11 dcl 1 tcm aligned based (tcmp),
  3    12     2 tc_suspend_lock like lock,			/* when locked, tc is suspended */
  3    13     2 cid2 fixed bin (18),
  3    14     2 cid3 fixed bin (18),
  3    15     2 cid4 fixed bin (18),
  3    16     2 depth_count fixed bin (18),			/* depth last process run */
  3    17     2 loadings fixed bin (18),			/* number of process loadings */
  3    18 
  3    19     2 blocks fixed bin (18),				/* number of calls to block */
  3    20     2 wakeups fixed bin (18),				/* number of calls to wakeup */
  3    21     2 waits fixed bin (18),				/* number of calls to wait */
  3    22     2 notifies fixed bin (18),			/* number of calls to notify */
  3    23     2 schedulings fixed bin (18),
  3    24     2 interactions fixed bin (18),			/* number of interactive schedulings */
  3    25     2 avequeue fixed bin (35, 18),			/* recent time average of number in queue */
  3    26     2 te_wait fixed bin (18),				/* times te called from wait */
  3    27 
  3    28     2 te_block fixed bin (18),			/* times te updated from block */
  3    29     2 te_i_stop fixed bin (18),			/* times te updated from i_stop */
  3    30     2 te_pre_empt fixed bin (18),			/* times te updated from pre_empt */
  3    31     2 p_interactions fixed bin,			/* times interaction bit turned off because of high priority */
  3    32     2 idle fixed bin (71),				/* total idle time */
  3    33     2 mp_idle fixed bin (71),				/* multi-programming idle */
  3    34 
  3    35     2 nmp_idle fixed bin (71),			/* non-multi-programming idle time */
  3    36     2 zero_idle fixed bin (71),			/* zero idle time */
  3    37     2 last_time fixed bin (71),			/* last time a process was run */
  3    38     2 loop_locks fixed bin (18),			/* times looped on the APT lock */
  3    39     2 loop_lock_time fixed bin (18),			/* time looping on the APT lock */
  3    40     2 ave_eligible fixed bin (35, 18),			/* average length of eligible queue */
  3    41     2 sort_to_elhead fixed bin (18),			/* 0=> no one,1 => int've only, 2 => everybody */
  3    42     2 processor_time fixed bin (71),			/* total processor time on system */
  3    43     2 response_time fixed bin (71),			/* estimate of response time */
  3    44     2 eligible_time fixed bin (71),			/* estimate of eligible time */
  3    45     2 response_count fixed bin,			/* count of response meters */
  3    46     2 eligible_count fixed bin,			/* count of eligible meters */
  3    47     2 quit_counts (0:5) fixed bin,			/* array of buckets indexed by state */
  3    48     2 loading_idle fixed bin (71),			/* loading_idle time */
  3    49     2 delta_vcpu fixed bin (71),			/* delta virtual CPU time for the system */
  3    50     2 post_purge_switch fixed bin,			/* ON if post purging is to be done */
  3    51     2 time_out_severity fixed bin,			/* syserr first arg for notify time outs */
  3    52     2 notify_check fixed bin,				/* obsolete */
  3    53     2 quit_priority fixed bin,			/* factor for scheduler quit response */
  3    54     2 iobm_polling_time fixed bin (71),			/* time to poll iobm */
  3    55     2 end_of_time fixed bin (71),			/* very large time */
  3    56     2 gp_at_notify fixed bin (18),			/* 0 => just do get_idle_processor */
  3    57     2 gp_at_ptlnotify fixed bin (18),			/* 0 => just do get_idle_processor */
  3    58     2 int_q_enabled fixed bin (18),			/* 0 => no intv q in percent mode */
  3    59     2 fnp_buffer_threshold fixed bin (18),		/* if fewer free buffs then stingy alloc strategy */
  3    60 						/* set this to >= half n_ttylines/fnp for safety */
  3    61 
  3    62 /* 100 octal */
  3    63 
  3    64     2 depths (8) fixed bin (18),			/* histogram of run depths */
  3    65     2 tdepths (8) fixed bin (71),			/* histogram of times run per depth */
  3    66     2 pfdepth (8) fixed bin (18),			/* histogram of page faults per depth */
  3    67 
  3    68     2 ptl_not_waits fixed bin (18),			/* times ptl_wait noticed ptl was unlocked */
  3    69     2 gw_gp_window_count fixed bin (18),		/* times window noticed */
  3    70     2 metering_lock fixed bin (18),			/* 0=locked, else unlocked */
  3    71     2 ptl_waits fixed bin (18),			/* num calls to ptl_wait */
  3    72     2 gp_start_count fixed bin (18),			/*  to detect gw_gp window lossage */
  3    73     2 gp_done_count fixed bin (18),
  3    74     2 nto_check_time fixed bin (71),			/* next time at which nto code will be called */
  3    75     2 nto_delta fixed bin (35),			/* microsec between nto checks */
  3    76     2 nto_count fixed bin (18),			/* number of times nto detected */
  3    77     2 tcpu_scheduling fixed bin (18),			/* obsolete				*/
  3    78     2 nto_event bit (36),				/* last event which NTO'd */
  3    79     2 page_notifies fixed bin (18),
  3    80     2 notify_nobody_count fixed bin (18),
  3    81     2 notify_nobody_event bit (36),
  3    82     2 system_type fixed bin,				/* used to be tcm.inter */
  3    83 
  3    84     2 stat (0:15) fixed bin (18),			/* num apte's in each state */
  3    85 
  3    86 /* 200 octal */
  3    87 
  3    88     2 wait (8),
  3    89       3 time fixed bin (18),				/* histogram of page fault waiting times versus did */
  3    90       3 count fixed bin (18),
  3    91 
  3    92     2 ready (8),
  3    93       3 time fixed bin (18),				/* histogram of times in ready queue */
  3    94       3 count fixed bin (18),
  3    95 
  3    96     2 total_pf_time fixed bin (71),			/* total time spent from start to end of
  3    97*						   all page faults */
  3    98     2 total_pf_count fixed bin (18),			/* total number of page faults metered */
  3    99     2 auto_tune_ws fixed bin (18),			/* 0=> dont, atherwise compensate for quantum len */
  3   100     2 ocore_delta fixed bin (18),			/* number of pages reserved for int users */
  3   101     2 ws_sum fixed bin (18),				/* total of eligible's ws_sizes */
  3   102     2 nonidle_force_count fixed bin (18),		/* count of eligibilities forced */
  3   103     2 itt_list_lock bit (36) aligned,			/* Lock on ITT free list */
  3   104     2 cpu_pf_time fixed bin (71),			/* total cpu time spent handling page faults */
  3   105     2 cpu_pf_count fixed bin (18),			/* total count of cpu time meterings */
  3   106     2 special_offsets unaligned,
  3   107       3 apt_offset bit (18),
  3   108       3 pad bit (18),
  3   109     2 getwork_time fixed bin (71),			/* total time spent in getwork */
  3   110     2 getwork_count fixed bin (18),			/* total times through getwork */
  3   111     2 short_pf_count fixed bin (18),			/* number of short page faults */
  3   112     2 interrupt_time fixed bin (71),			/* total time spent in interrupt */
  3   113     2 interrupt_count fixed bin (71),			/* total number of metered interrupts */
  3   114     2 ocore fixed bin (35, 18),			/* fraction of core for int've users */
  3   115     2 pre_empt_flag bit (36) aligned,			/* controls whether preempting at done time */
  3   116     2 cumulative_memory_usage fixed binary (71),		/* total number of memory usage units */
  3   117     2 processor_time_at_define_wc fixed bin (71),		/* value of processor_time when WC's last defined */
  3   118     2 boost_priority fixed bin,			/* number of times priority process given high priority */
  3   119     2 lost_priority fixed bin,			/* number of times priority process lost eligibility */
  3   120     2 total_clock_lag fixed bin (71),			/* sum of all simulated clock delays */
  3   121     2 clock_simulations fixed bin,			/* number of times alarm clock interrupt was simulated */
  3   122     2 max_clock_lag fixed bin,			/* largest simulated alarm clock delay */
  3   123 
  3   124 /* 300 octal */
  3   125 
  3   126     2 pdscopyl fixed bin (18),			/* amount of pds to copy for new process */
  3   127     2 max_hproc_segno fixed bin,			/* largest allowed hardcore segment number */
  3   128     2 prds_length fixed bin (18),			/* length of PRDS */
  3   129     2 pds_length fixed bin (18),			/* length of PDS */
  3   130     2 lock fixed bin (18),				/* process id generator lock */
  3   131     2 id bit (36) aligned,				/* next uid to be added to uid_array */
  3   132     2 system_shutdown fixed bin (18),
  3   133     2 working_set_factor fixed bin (35, 18),		/* working set factor */
  3   134 
  3   135     2 ncpu fixed bin (18),				/* number of processors currently being used */
  3   136     2 last_eligible bit (18),				/* last process to gain eligibility */
  3   137     2 apt_lock fixed bin (35),			/* + write; 0 hidden; -1 unlocked; -(N+1) Nreaders */
  3   138     2 apt_size fixed bin (18),			/* number of APT entries */
  3   139     2 realtime_q aligned like based_sentinel,		/* processes with realtime deadlines */
  3   140     2 aht_size fixed bin (18),			/* APT hash table size */
  3   141     2 itt_size fixed bin (18),			/* number of ITT entries */
  3   142 
  3   143     2 dst_size fixed bin (18),			/* number of allowed DST entries */
  3   144     2 itt_free_list bit (18),				/* pointer to ITT free list */
  3   145     2 used_itt fixed bin (18),			/* number of used ITT entries */
  3   146     2 initializer_id bit (36) aligned,			/* process id of initializer */
  3   147     2 n_eligible fixed bin (18),			/* number of processes eligible */
  3   148     2 max_eligible fixed bin (30),			/* maximum allowed number of eligible processes */
  3   149     2 wait_enable fixed bin (18),			/* turned on when waiting mechanism works */
  3   150     2 apt_entry_size fixed bin (18),			/* size of an APT entry */
  3   151 
  3   152     2 interactive_q aligned like based_sentinel,		/* head of interactive queue */
  3   153     2 dst_ptr ptr,					/* pointer to device signal table */
  3   154     2 old_user ptr,					/* last process to run (apt ptr ) */
  3   155     2 initialize_time fixed bin (71),			/* time of initialization */
  3   156 
  3   157     2 init_event fixed bin (18),			/* wait event during initialization */
  3   158     2 oldt fixed bin (18),				/* timer reading from previous process */
  3   159     2 newt fixed bin (18),				/* timer setting for new process */
  3   160     2 tefirst fixed bin (30),				/* first eligible time */
  3   161     2 telast fixed bin (30),				/* last eligible time */
  3   162     2 timax fixed bin (35),				/* time in queue for lowest level */
  3   163     2 empty_q bit (18),				/* thread of empty APT entries */
  3   164     2 working_set_addend fixed bin (18),		/* additive working set parameter */
  3   165     2 ready_q_head bit (0) aligned,			/* for added segdef */
  3   166     2 eligible_q_head aligned like based_sentinel,	/* head of eligible queue */
  3   167     2 ready_q_tail bit (0) aligned,			/* for added segdef */
  3   168     2 eligible_q_tail aligned like based_sentinel,	/* tail of eligible queue */
  3   169     2 idle_tail aligned like based_sentinel,		/* tail of idle list */
  3   170     2 min_eligible fixed bin (30),
  3   171     2 alarm_timer_list bit (18) aligned,		/* rel pointer to apt entry for next alarm timer */
  3   172     2 guaranteed_elig_inc fixed bin (35),		/* amount of guaranteed eligibility time in microsecs. */
  3   173     2 priority_sched_inc fixed bin (35),		/* amount of block time before process is given priority */
  3   174     2 next_alarm_time fixed bin (71),			/* clock time for next alarm timer */
  3   175     2 priority_sched_time fixed bin (71),		/* time for priority process to be given priority */
  3   176     2 opc_polling_time fixed bin (71),			/* time to poll console DIM */
  3   177     2 disk_polling_time fixed bin (71),			/* time to poll disk DIM */
  3   178     2 tape_polling_time fixed bin (71),			/* time to poll tape DIM */
  3   179     2 imp_polling_time fixed bin (71),			/* time to poll imp */
  3   180     2 imp_polling_lock fixed bin (18),			/* do not poll if lock set */
  3   181     2 max_channels fixed bin (18),			/* num special channels per process */
  3   182 
  3   183 /* 400 octal */
  3   184 
  3   185     2 system_virtual_time fixed bin (71),		/* non-idle virtual time */
  3   186     2 credit_bank fixed bin (71),			/* credits not yet passed out */
  3   187     2 min_wct_index bit (18) aligned,			/* offset of initializer work class table entry */
  3   188     2 max_wct_index bit (18) aligned,			/* offset of highest wcte currently defined */
  3   189     2 delta_vt fixed bin (71),			/* temp used by pxss.compute_virtual_clocks */
  3   190     2 gross_idle_time fixed bin (71),			/* idle time_used_clock */
  3   191     2 credits_per_scatter fixed bin (35),		/* total number of credits awarded at once */
  3   192     2 best_credit_value fixed bin (18),			/* temp for pxss.find_next_eligible */
  3   193     2 define_wc_time fixed bin (71),			/* clock time when workclasses last degined */
  3   194     2 max_batch_elig fixed bin (35),
  3   195     2 num_batch_elig fixed bin (35),
  3   196     2 deadline_mode fixed bin (35),			/* 0=> ti sorts, else deadline sorts */
  3   197     2 credits_scattered fixed bin (35),
  3   198     2 max_max_eligible fixed bin (30),			/* Maximum of maxe */
  3   199     2 max_stopped_stack_0 fixed bin (35),		/* Maximum stack_0's suspended by stopped procs	*/
  3   200     2 stopped_stack_0 fixed bin (35),			/* Number stack_0's suspended by stopped procs	*/
  3   201     2 mos_polling_interval fixed bin (35),		/* for heals */
  3   202     2 mos_polling_time fixed bin (71),			/* for heals */
  3   203     2 vcpu_response_bounds (VCPU_RESPONSE_BOUNDS) fixed bin (35),
  3   204     2 vcpu_response_bounds_size fixed bin (35),
  3   205     2 meter_response_time_calls fixed bin (35),
  3   206     2 meter_response_time_invalid fixed bin (35),
  3   207     2 meter_response_time_overhead fixed bin (71),
  3   208     2 init_wait_time fixed bin (71),			/* used by wait/notify during initialization	*/
  3   209     2 init_wait_timeout fixed bin (71),			/* notify-timeout interval during initialization	*/
  3   210     2 init_timeout_severity fixed bin,			/* notify-timeout severity during initialization	*/
  3   211     2 init_timeout_recurse fixed bin,			/* count of NTO recursion during initialization	*/
  3   212     2 max_timer_register fixed bin (71),		/* max cpu burst = # cpus x pre_empt_sample_time	*/
  3   213     2 pre_empt_sample_time fixed bin (35),		/* tuning parameter - max time between samples	*/
  3   214     2 governing_credit_bank fixed bin (35),		/* used for limiting eligibility on governed work classes*/
  3   215     2 process_initial_quantum fixed bin (35),		/* eligibility quantum first eligibility	*/
  3   216     2 default_procs_required bit (8) aligned,		/* default mask of CPUs required */
  3   217     2 work_class_idle fixed bin (71),			/* idle time due to work class restrictions */
  3   218 
  3   219 /* Tuning Parameters for Stack Truncation */
  3   220 
  3   221     2 stk_truncate bit (1) aligned,
  3   222     2 stk_truncate_always bit (1) aligned,
  3   223     2 stk_trunc_avg_f1 fixed bin (35, 18),
  3   224     2 stk_trunc_avg_f2 fixed bin (35, 18),
  3   225     2 lock_error_severity fixed bin,                        /* syserr severity */
  3   226 
  3   227     2 gv_integration fixed bin (35),			/* Integration interval for governing */
  3   228     2 gv_integration_set bit (1) aligned,		/* ON => gv_integration set by ctp */
  3   229     2 pauses fixed bin (35),				/* Calls to pause (reschedule) */
  3   230     2 volmap_polling_time fixed bin (71),
  3   231     2 next_ring0_timer fixed bin (71),			/* next time that ring 0 timer goes off */
  3   232     2 realtime_io_priority_switch fixed bin,		/* 0 => give I/O interrupt wakeups realtime priotiry */
  3   233     2 realtime_io_deadline fixed bin (35),		/* Delta to clock for I/O realtime deadline */
  3   234     2 realtime_io_quantum fixed bin (35),		/* Quantum for I/O realtime burst */
  3   235     2 realtime_priorities fixed bin (35),		/* Count for metering */
  3   236     2 relinquishes fixed bin (35),			/* Calls to relinquish_priority */
  3   237     2 abort_ips_mask bit (36) aligned,			/* IPS mask for tc_util$check_abort */
  3   238 
  3   239 /* 500 octal */
  3   240 
  3   241     2 uid_array (0:15) bit (36) aligned,		/* array from which a uid is chosen (randomly) */
  3   242     2 pad5 (176) fixed bin (35),			/* room for expansion compatibly		*/
  3   243 
  3   244 /* 1000 octal */
  3   245 
  3   246     2 pad7 (64) fixed bin (35),
  3   247 
  3   248 /* 1100 octal */
  3   249 
  3   250     2 pad6 (8) fixed bin (35),
  3   251     2 work_class_table aligned,			/* array of per workclass information */
  3   252       3 wcte (0:16) aligned like wct_entry,
  3   253 
  3   254 /* 3000 octal */
  3   255 
  3   256     2 apt fixed bin;
  3   257 
  3   258 dcl  wctep ptr;
  3   259 
  3   260 dcl 1 wct_entry aligned based (wctep),			/* Work class entry */
  3   261     2 thread unaligned,				/* Ready list */
  3   262       3 fp bit (18),				/* Head of ready list */
  3   263       3 bp bit (18),				/* Tail of ready list */
  3   264     2 flags unaligned,
  3   265       3 mnbz bit (1),				/* Sentinel bit must not be zero. */
  3   266       3 defined bit (1),
  3   267       3 io_priority bit (1),
  3   268       3 governed bit (1),
  3   269       3 interactive_q bit (1),
  3   270       3 pad bit (31),
  3   271     2 credits fixed bin (35),				/* Current worthiness of group */
  3   272     2 minf fixed bin (35),				/* min fraction of cpu */
  3   273     2 pin_weight fixed bin (35),			/* number of cycles to pin pages */
  3   274     2 eligibilities fixed bin (35),			/* Count of eligibilities awarded */
  3   275     2 cpu_sum fixed bin (71),				/* CPU used by members */
  3   276     2 resp1 fixed bin (71),
  3   277     2 resp2 fixed bin (71),
  3   278     2 quantum1 fixed bin (35),
  3   279     2 quantum2 fixed bin (35),
  3   280     2 rmeter1 fixed bin (71),
  3   281     2 rmeter2 fixed bin (71),
  3   282     2 rcount1 fixed bin (35),
  3   283     2 rcount2 fixed bin (35),
  3   284     2 realtime fixed bin (35),
  3   285     2 purging fixed bin (35),
  3   286     2 maxel fixed bin (35),
  3   287     2 nel fixed bin (35),
  3   288     2 number_thinks fixed bin (35),			/* number times process entered "think" state	*/
  3   289     2 number_queues fixed bin (35),			/* number times process entered "queued" state	*/
  3   290     2 total_think_time fixed bin (71),
  3   291     2 total_queue_time fixed bin (71),
  3   292 
  3   293 /*  The next three arrays  correspond to the array vcpu_response_bounds				*/
  3   294 
  3   295     2 number_processing (VCPU_RESPONSE_BOUNDS+1) fixed bin (35), /* number times entered "processing" state	*/
  3   296     2 total_processing_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  3   297     2 total_vcpu_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  3   298     2 maxf fixed bin (35),				/* maximum fraction of cpu time		*/
  3   299     2 governing_credits fixed bin (35),			/* for limiting cpu resources			*/
  3   300     2 pad1 (4) fixed bin (35);
  3   301 	
  3   302 
  3   303 dcl 1 based_sentinel aligned based,			/* format of pxss-style sentinel */
  3   304     2 fp bit (18) unal,
  3   305     2 bp bit (18) unal,
  3   306     2 sentinel bit (36) aligned;
  3   307 
  3   308 dcl VCPU_RESPONSE_BOUNDS fixed bin init (3) int static options (constant);
  3   309 
  3   310 /* END INCLUDE FILE tcm.incl.pl1 */
      163 
      164      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0813.4  set_alarm_timer.pl1               >spec>install>1112>set_alarm_timer.pl1
161          1    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
162          2    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
163          3    01/30/85  1523.9  tcm.incl.pl1                      >ldd>include>tcm.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 71 ref 93 110 151
aevent                                 parameter       fixed bin(71,0)          dcl 36 set ref 32 79 88 146 159*
alarm_event              24            based           fixed bin(71,0)          level 2 dcl 1-7 set ref 125* 154
alarm_time               26(18)        based           bit(54)                  level 2 packed packed unaligned dcl 1-7 set ref 95
                                                                                  108* 112 116 124* 153
alarm_time_thread        26            based           bit(18)                  level 2 packed packed unaligned dcl 1-7 set ref 96
                                                                                  101 103 105* 105 107* 115 119 121* 123*
apte                                   based           structure                level 1 dcl 1-7
aptep                           000120 automatic       pointer                  dcl 1-5 set ref 92* 95 96 96 100 101 105 107 108 111
                                                                                  112 121 123 124 125 150* 153 154
asw                                    parameter       fixed bin(17,0)          dcl 37 ref 32 73
atime                                  parameter       fixed bin(71,0)          dcl 38 set ref 32 79 85 86 146 158*
based_sentinel                         based           structure                level 1 dcl 3-303
bit                                                    builtin function         dcl 71 ref 124
bit20                                  based           bit(20)                  packed unaligned dcl 53 ref 110
clock                                                  builtin function         dcl 71 ref 83
current_time                    000100 automatic       fixed bin(71,0)          dcl 42 set ref 83* 85 87 87
esw                             000102 automatic       fixed bin(17,0)          dcl 43 set ref 73* 81* 85
event                           000104 automatic       fixed bin(71,0)          dcl 44 set ref 88* 125 154* 159
fixed                                                  builtin function         dcl 71 ref 112 116 124 153
lock                                   based           structure                level 1 dcl 2-12
naptep                          000106 automatic       pointer                  dcl 45 set ref 100* 101 103* 103 103 105 111* 115*
                                                                                  116 116 118 119* 119 119 123
oaptep                          000110 automatic       pointer                  dcl 46 set ref 111* 112 112 115 115 118* 121
pds$apt_ptr                     000010 external static pointer                  dcl 57 ref 92 150
pmut$unwire_unmask              000024 constant        entry                    external dcl 66 ref 131 156
pmut$wire_and_mask              000026 constant        entry                    external dcl 67 ref 90 148
ptr                                                    builtin function         dcl 71 ref 100 103 111 115 119
pxss$lock_apt                   000020 constant        entry                    external dcl 64 ref 94 152
pxss$unlock_apt                 000022 constant        entry                    external dcl 65 ref 128 155
rel                                                    builtin function         dcl 71 ref 96 101 112 112 116 121 123
tc_data$                        000012 external static fixed bin(17,0)          dcl 58 set ref 93 151
tc_data$alarm_timer_list        000014 external static bit(18)                  dcl 59 set ref 96 96* 100 111 112*
tc_data$next_alarm_time         000016 external static fixed bin(71,0)          dcl 60 set ref 126 126*
tcmp                            000122 automatic       pointer                  dcl 3-9 set ref 93* 151*
time                            000112 automatic       fixed bin(71,0)          dcl 47 set ref 85* 86* 87 87* 110 112 116 124 126
                                                                                  126 153* 158
wct_entry                              based           structure                level 1 dcl 3-260
wire_arg                        000114 automatic       bit(72)                  dcl 48 set ref 90* 131* 148* 156*
wired_stack_ptr                 000116 automatic       pointer                  dcl 49 set ref 90* 131* 148* 156*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VCPU_RESPONSE_BOUNDS                   internal static fixed bin(17,0)          initial dcl 3-308
lock_ptr                               automatic       pointer                  dcl 2-11
tcm                                    based           structure                level 1 dcl 3-11
wctep                                  automatic       pointer                  dcl 3-258

NAMES DECLARED BY EXPLICIT CONTEXT.
finish                          000247 constant        label                    dcl 128 ref 110
get_alarm_timer                 000270 constant        entry                    external dcl 146
join                            000041 constant        label                    dcl 83 ref 74
set_alarm                       000027 constant        entry                    external dcl 79
set_alarm_timer                 000010 constant        entry                    external dcl 32

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       516         546     364         526
Length       776     364        30         213     132           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
set_alarm_timer                      96 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
set_alarm_timer          000100 current_time                set_alarm_timer
                         000102 esw                         set_alarm_timer
                         000104 event                       set_alarm_timer
                         000106 naptep                      set_alarm_timer
                         000110 oaptep                      set_alarm_timer
                         000112 time                        set_alarm_timer
                         000114 wire_arg                    set_alarm_timer
                         000116 wired_stack_ptr             set_alarm_timer
                         000120 aptep                       set_alarm_timer
                         000122 tcmp                        set_alarm_timer

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
pmut$unwire_unmask            pmut$wire_and_mask            pxss$lock_apt                 pxss$unlock_apt

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
pds$apt_ptr                   tc_data$                      tc_data$alarm_timer_list      tc_data$next_alarm_time




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     32 000004        73 000020        74 000022        79 000023        81 000037        83 000041        85 000043
     86 000053        87 000056        88 000062        90 000064        92 000075        93 000101        94 000103
     95 000107        96 000114       100 000124       101 000130       103 000137       104 000142       105 000143
    107 000146       108 000151       110 000154       111 000157       112 000166       115 000201       116 000206
    118 000216       119 000217       120 000223       121 000224       123 000227       124 000232       125 000240
    126 000242       128 000247       131 000254       132 000265       146 000266       148 000300       150 000311
    151 000315       152 000317       153 000323       154 000330       155 000332       156 000337       158 000350
    159 000353       160 000355


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
