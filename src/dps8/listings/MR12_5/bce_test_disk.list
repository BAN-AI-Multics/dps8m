	COMPILATION LISTING OF SEGMENT bce_test_disk
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1021.7 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-01-17,Fawcett), approve(86-01-17,MCR7220),
       12*     audit(86-05-14,Farley), install(86-07-17,MR12.0-1097):
       13*     Keith Loepere to extract disk spec parsing code and
       14*     call bce_parse_disk_spec (created for bce_copy_disk).
       15*  2) change(86-01-17,Fawcett), approve(86-04-11,MCR7383),
       16*     audit(86-05-14,Farley), install(86-07-17,MR12.0-1097):
       17*     Changed to support subvolumes by adding call to disk_name_pvtx.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 bce_test_disk: proc (p_ss_info_ptr);
       22 
       23 /* Written by Allen Ball June of 1984 to replace BOS command TEST. */
       24 /* Modified 85-01-09 ADB to fix d451. 'last' still refers to last record number
       25*                         before alt partition but user can still refer to
       26*                         records past the beginning of the alt partition. */
       27 /* Modified 85-02-09 Keith Loepere, to use bootload disk i/o for performance. */
       28 /* Modified 85-03-10 Keith Loepere to extract disk spec parsing code. */
       29 
       30 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       31 
       32 /* Constants */
       33 
       34 dcl  Me				char (32) static options (constant) init ("test_disk");
       35 
       36 /* Parameters */
       37 
       38 dcl  p_ss_info_ptr			ptr parameter;
       39 
       40 /* Variables */
       41 
       42 dcl  arg_count			fixed bin;
       43 dcl  arg_len			fixed bin (21);
       44 dcl  arg_num			fixed bin;
       45 dcl  arg_ptr			ptr;
       46 dcl  code				fixed bin (35);
       47 dcl  device_type			fixed bin;	/* as in fs_dev_types */
       48 dcl  drive			char (8);		/* device name */
       49 dcl  error_on_write			bit (1);		/* report error for write op, not read */
       50 dcl  f_record			fixed bin (18);	/* first record to be read or written */
       51 dcl  force			bit (1) aligned;	/* don't ask questions */
       52 dcl  key				char (2);
       53 dcl  l_record			fixed bin (18);	/* last record to be read or written */
       54 dcl  1 my_label			aligned like label;
       55 dcl  new_record			fixed bin (18);	/* first record of new set to read/write */
       56 dcl  page_num			fixed bin;
       57 dcl  1 pattern			aligned,
       58        2 word_pattern_len		fixed bin,
       59        2 pattern_buffer		bit (1024 * 36) aligned; /* build area for pattern to write to disk */
       60 dcl  pattern_buffer_ptr		ptr;
       61 dcl  prev_record			fixed bin (18);	/* last record read/written */
       62 dcl  prev_record_in_cylinder		fixed bin;	/* (0 origin) record number within cylinder (used for detecting cylinder crossing) */
       63 dcl  pvtx				fixed bin;
       64 dcl  read_sw			bit (1);
       65 dcl  read_then_write		bit (1);
       66 dcl  records_this_cylinder		fixed bin;
       67 dcl  temp_astep			ptr;		/* to temp_seg in use */
       68 dcl  temp_seg_ptr			ptr;		/* to temp_seg (which we wire) */
       69 dcl  write_then_read		bit (1);
       70 dcl  write_sw			bit (1);
       71 dcl  yes_no			bit (1);
       72 
       73 /* External */
       74 
       75 dcl  error_table_$bad_arg		fixed bin (35) ext static;
       76 dcl  error_table_$noarg		fixed bin (35) ext static;
       77 
       78 /* Entries */
       79 
       80 dcl  bce_check_abort		entry;
       81 dcl  disk_name_pvtx			entry (char (8), fixed bin (17), fixed bin (35));
       82 dcl  bce_parse_disk_spec		entry (char (32), ptr, fixed bin, fixed bin, ptr, fixed bin (18), fixed bin (18), entry (ptr, fixed bin, ptr, fixed bin (35)), ptr, fixed bin (35));
       83 dcl  bce_query$yes_no		entry options (variable);
       84 dcl  bootload_disk_io$read		entry (fixed bin, fixed bin (18), fixed bin, ptr, fixed bin (35));
       85 dcl  bootload_disk_io$write		entry (fixed bin, fixed bin (18), fixed bin, ptr, fixed bin (35));
       86 dcl  com_err_			entry () options (variable);
       87 dcl  cu_$arg_count_rel		entry (fixed bin, ptr, fixed bin (35));
       88 dcl  cu_$arg_ptr_rel		entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
       89 dcl  cv_oct_check_			entry (char (*), fixed bin (35)) returns (fixed bin (35));
       90 dcl  get_ptrs_$given_segno		entry (fixed bin (15)) returns (ptr);
       91 dcl  get_temp_segment_		entry (char (*), ptr, fixed bin (35));
       92 dcl  ioa_				entry () options (variable);
       93 dcl  pc_abs$unwire_abs		entry (ptr, fixed bin, fixed bin);
       94 dcl  pc_abs$wire_abs_contig		entry (ptr, fixed bin, fixed bin, fixed bin (35));
       95 dcl  read_disk			entry (fixed bin, fixed bin (18), ptr, fixed bin (35));
       96 dcl  release_temp_segment_		entry (char (*), ptr, fixed bin (35));
       97 
       98 /* Based */
       99 
      100 dcl  arg				char (arg_len) based (arg_ptr);
      101 dcl  bootload_disk_buffer		(0:2) bit (1024 * 36) aligned based (temp_seg_ptr);
      102 dcl  word				bit (36) aligned based;
      103 dcl  word_pattern			bit (word_pattern_len * 36) based (pattern_buffer_ptr) aligned;
      104 
      105 /* Misc */
      106 
      107 dcl  cleanup			condition;
      108 
      109 dcl  (addr, addrel, copy, divide, max, min, mod, null, segno, unspec) builtin;
      110 
      111 	ss_info_ptr = p_ss_info_ptr;
      112 	pattern_buffer_ptr = addr (pattern.pattern_buffer);
      113 	pvtp = addr (pvt$);
      114 	pvt_arrayp = addr (pvt.array);
      115 	call cu_$arg_count_rel (arg_count, ss_info.arg_list_ptr, code);
      116 	if code ^= 0 then do;
      117 	     call com_err_ (code, Me);
      118 	     return;
      119 	end;
      120 	if arg_count < 2 then do;
      121 	     call ioa_ ("Usage:^/  ^a <key> <device> (<arg1> <arg2> ...)", Me);
      122 	     return;
      123 	end;
      124 	arg_num = 1;
      125 	call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, ss_info.arg_list_ptr);
      126 	if code ^= 0 then do;
      127 	     call com_err_ (code, Me, "Can't get arg");
      128 	     return;
      129 	end;
      130 	if arg_len < 1 | arg_len > 2 then goto bad_key;
      131 	key = arg;
      132 	if ^(key = "r" | key = "w" | key = "rw" | key = "wr") then do;
      133 bad_key:	     call ioa_ ("^a: Unrecognized key - ^a", Me, arg);
      134 	     return;
      135 	end;
      136 	read_sw = (key = "r");
      137 	write_sw = (key = "w");
      138 	read_then_write = (key = "rw");
      139 	write_then_read = (key = "wr");
      140 
      141 	arg_num = 2;
      142 	call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, ss_info.arg_list_ptr);
      143 
      144 	drive = arg;
      145 	call disk_name_pvtx (drive, pvtx, code);
      146 	if code ^= 0 then do;
      147 	     call com_err_ (code, Me, "^a", arg);
      148 	     return;
      149 	end;
      150 
      151 	pattern.word_pattern_len = 0;
      152 	force = "0"b;
      153 
      154 	labelp = addr (my_label);
      155 	call read_disk (pvtx, (LABEL_ADDR), labelp, code);
      156 	if code ^= 0 then do;
      157 	     call com_err_ (code, Me, "Could not read label of ^a.", drive);
      158 	     return;
      159 	end;
      160 
      161 	device_type = pvt_array (pvtx).device_type;
      162 
      163 	arg_num = 3;
      164 	call bce_parse_disk_spec (Me, ss_info.arg_list_ptr, arg_num, device_type, labelp, f_record, l_record, pattern_parse, addr (pattern), code);
      165 	if code ^= 0 then return;
      166 
      167 /* Now that f_record and l_record are assigned we will give them their chance to turn back. */
      168 
      169 	if write_sw | write_then_read then do;
      170 	     if f_record = l_record then call ioa_ ("Writing to record number ^oo on ^a.", f_record, drive);
      171 	     else call ioa_ ("Writing to records ^oo through ^oo (inclusive) on ^a.", f_record, l_record, drive);
      172 	     if ^force then do;
      173 		call bce_query$yes_no (yes_no, "Do you wish to write to the ^[non ^;^]^a - ^a? ",
      174 		     (label.Multics ^= Multics_ID_String), Multics_ID_String, drive);
      175 		if ^yes_no then return;
      176 	     end;
      177 	end;
      178 
      179 	if pattern.word_pattern_len = 0 then unspec (pattern.pattern_buffer) = "0"b;
      180 	else pattern.pattern_buffer = copy (word_pattern, divide (1024, pattern.word_pattern_len, 17) + 1);
      181 
      182 
      183 /* Now for the real work.  The basic loop structure below implements the 4
      184*keys as follows.  For "r", we simply keep reading into our wired buffer.
      185*For "w", we copy our pattern into the wired buffer once, and then keep
      186*writing from it.  For "rw", we read into and write back from the wired buffer.
      187*For "wr", though, we must copy the pattern into the wired buffer each time
      188*through.
      189*
      190*The i/o is done backwards, and (normally) three pages at a time.  This is
      191*to minimize latency between i/o's, to maximize the time we have between i/o's
      192*to get our next request in, within the constraints that bootload_disk_io
      193*can handle a maximum of 4 pages at a time.  Three pages is optimal both for
      194*451 and 501 style drives.
      195*
      196*However, we don't want to read/write a set of pages that cross a cylinder
      197*boundary, so we check for this.  Also, if an i/o error occurs, we go back
      198*to reading/writing a single page, so that we can eventually track down which
      199*page(s) really can't be read/written. */
      200 
      201 /* try to find wired work area */
      202 
      203 	temp_seg_ptr = null;
      204 	call get_temp_segment_ (Me, temp_seg_ptr, code);
      205 	if code ^= 0 then do;
      206 	     call com_err_ (code, Me, "Unable to get temp disk buffer.");
      207 	     return;
      208 	end;
      209 
      210 	temp_astep = get_ptrs_$given_segno (segno (temp_seg_ptr));
      211 	call pc_abs$wire_abs_contig (temp_astep, 0, 3, code);
      212 	if code ^= 0 then do;
      213 	     call com_err_ (code, Me, "Unable to wire temp disk buffer.");
      214 	     call release_temp_segment_ (Me, temp_seg_ptr, code);
      215 	     return;
      216 	end;
      217 
      218 	on cleanup call clean_up;			/* remember, this is only called during bce_check_abort */
      219 
      220 	if write_sw then do page_num = 0 to 2;
      221 	     bootload_disk_buffer (page_num) = pattern.pattern_buffer;
      222 	end;
      223 
      224 	prev_record = l_record + 1;
      225 	prev_record_in_cylinder = mod (prev_record, rec_per_cyl (device_type));
      226 	do while (prev_record > f_record);		/* stop when processed lowest record */
      227 	     if prev_record_in_cylinder = 0 then prev_record_in_cylinder = rec_per_cyl (device_type); /* next cylinder */
      228 	     records_this_cylinder = min (prev_record_in_cylinder, 3); /* num pages to do this time around */
      229 	     new_record = max (prev_record - records_this_cylinder, f_record); /* don't go over requested area */
      230 	     records_this_cylinder = prev_record - new_record; /* real amt to do */
      231 
      232 retry:	     call bce_check_abort;
      233 	     if write_then_read then do;
      234 		do page_num = 0 to records_this_cylinder - 1;
      235 		     bootload_disk_buffer (page_num) = pattern.pattern_buffer;
      236 		end;
      237 		call bootload_disk_io$write (pvtx, new_record, records_this_cylinder, temp_seg_ptr, code);
      238 		if code ^= 0 then do;
      239 		     error_on_write = "1"b;
      240 		     go to io_error;
      241 		end;
      242 	     end;
      243 	     if ^write_sw then do;
      244 		call bootload_disk_io$read (pvtx, new_record, records_this_cylinder, temp_seg_ptr, code);
      245 		if code ^= 0 then do;
      246 		     error_on_write = "0"b;
      247 		     go to io_error;
      248 		end;
      249 	     end;
      250 	     if read_then_write | write_sw then do;
      251 		call bootload_disk_io$write (pvtx, new_record, records_this_cylinder, temp_seg_ptr, code);
      252 		if code ^= 0 then do;
      253 		     error_on_write = "1"b;
      254 io_error:		     if records_this_cylinder > 1 then do; /* try i/o on just 1 record to find fault one */
      255 			new_record = prev_record - 1;
      256 			records_this_cylinder = 1;
      257 			go to retry;
      258 		     end;
      259 		     else do;
      260 			call com_err_ (0, Me, "Could not ^[write^;read^] record ^oo on ^a.", error_on_write, new_record, drive);
      261 			go to next_record;
      262 		     end;
      263 		end;
      264 	     end;
      265 	     if write_then_read then
      266 		do page_num = 0 to records_this_cylinder - 1;
      267 		if bootload_disk_buffer (page_num) ^= pattern.pattern_buffer then
      268 		     call ioa_ ("^a: What was read did not match what was written at record ^oo of ^a.", Me, new_record + page_num, drive);
      269 	     end;
      270 
      271 next_record:   prev_record = new_record;
      272 	     prev_record_in_cylinder = prev_record_in_cylinder - records_this_cylinder;
      273 	end;
      274 
      275 	call clean_up;
      276 	return;
      277 
      278 clean_up: proc;
      279 
      280 	call pc_abs$unwire_abs (temp_astep, 0, 3);
      281 	call release_temp_segment_ (Me, temp_seg_ptr, code);
      282 	return;
      283      end;
      284 
      285 pattern_parse: proc (arg_list_ptr, arg_num, info_ptr, code);
      286 
      287 /* called by bce_parse_disk_spec when it doesn't like something,
      288*most likely a pattern spec */
      289 
      290 dcl  arg_list_ptr			ptr parameter;
      291 dcl  arg_num			fixed bin parameter;
      292 dcl  code				fixed bin (35) parameter;
      293 dcl  info_ptr			ptr parameter;
      294 
      295 dcl  number			fixed bin (35);
      296 
      297 	call cu_$arg_count_rel (arg_count, arg_list_ptr, code);
      298 	call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, arg_list_ptr);
      299 	if arg = "-force" | arg = "-fc" then force = "1"b;
      300 	else if arg = "-pattern" | arg = "-pat" then do;
      301 	     pattern.word_pattern_len = 0;
      302 	     if key = "rw" | key = "r" then do;
      303 		code = error_table_$bad_arg;
      304 		call com_err_ (code, Me, "-pattern is incompatible with the ^a key.", key);
      305 		return;
      306 	     end;
      307 next_word:     arg_num = arg_num + 1;
      308 	     if arg_num > arg_count then go to end_pattern;
      309 	     call cu_$arg_ptr_rel (arg_num, arg_ptr, arg_len, code, arg_list_ptr);
      310 	     number = cv_oct_check_ (arg, code);
      311 	     if code ^= 0 then do;			/* not a number */
      312 		arg_num = arg_num - 1;		/* most likely a new control arg */
      313 
      314 end_pattern:	if pattern.word_pattern_len ^= 0 then code = 0;
      315 		else do;				/* pattern spec missing */
      316 		     code = error_table_$noarg;
      317 		     call com_err_ (code, Me, "pattern");
      318 		end;
      319 		return;
      320 	     end;
      321 	     else do;
      322 		addrel (pattern_buffer_ptr, pattern.word_pattern_len) -> word = unspec (number);
      323 		pattern.word_pattern_len = pattern.word_pattern_len + 1;
      324 		goto next_word;
      325 	     end;
      326 	end;
      327 	else do;
      328 	     code = error_table_$bad_arg;
      329 	     call com_err_ (code, Me, "^a", arg);
      330 	     return;
      331 	end;
      332 	code = 0;
      333 	return;
      334      end pattern_parse;
      335  /* Begin include file bce_subsystem_info_.incl.pl1 BIM 11/82 */
  1     2 
  1     3 /* format: style3 */
  1     4 
  1     5 /* Deleted unused items, Keith Loepere, 5/84 */
  1     6 
  1     7 
  1     8 /****^  HISTORY COMMENTS:
  1     9*  1) change(86-04-22,Farley), approve(86-07-18,MCR7439),
  1    10*     audit(86-10-08,Fawcett), install(86-10-20,MR12.0-1189):
  1    11*     Added request_handling_opr_aborts flag for save/restore.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 declare	ss_info_ptr	pointer;
  1    15 declare	1 ss_info		aligned based (ss_info_ptr),
  1    16 	  2 request_table_ptr
  1    17 			pointer,
  1    18 	  2 abort_label	label,
  1    19 	  2 name		char (32) unaligned,
  1    20 	  2 arg_list_ptr	pointer,
  1    21 	  2 info_ptr	pointer,
  1    22 	  2 flags           aligned,
  1    23 	    3 forbid_semicolons bit (1) unaligned,
  1    24 	    3 request_handling_opr_aborts bit (1) unaligned;
  1    25 
  1    26 /* End include file bce_subsystem_info_ */
      335 
      336  /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  2     2 
  2     3 
  2     4 
  2     5 
  2     6 /****^  HISTORY COMMENTS:
  2     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  2    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  2    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  2    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  2    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  2    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  2    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 
  2    19 /*
  2    20*   All disk packs have the standard layout described below:
  2    21*
  2    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  2    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  2    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  2    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  2    26*   Record  7		: formerly contained bad track list; no longer used.
  2    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  2    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  2    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  2    30*
  2    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  2    32*   of the particular partition.
  2    33*
  2    34*
  2    35*
  2    36*   A conceptual declaration for a disk pack could be:
  2    37*
  2    38*   dcl 1 disk_pack,
  2    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  2    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  2    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  2    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  2    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  2    44*   2 vtoc_array_records	(8 : n-1),
  2    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  2    46*   3 unused				bit(36 * 64),
  2    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  2    48*
  2    49*
  2    50*
  2    51*
  2    52**/
  2    53 
  2    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  2    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  2    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  2    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  2    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  2    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  2    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  2    61 		         fixed bin (17) int static options (constant);
  2    62 
  2    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  2    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  2    65 /* or the physical volume table entry (pvte) device type.		      */
  2    66 
  2    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  2    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  2    69 
  2    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  2    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  2    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  2    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    76 
  2    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      336 
      337  /* Begin include file ...... fs_dev_types.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  3     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  3     6*     Add support for FIPS
  3     7*     3380.
  3     8*  2) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  3     9*     audit(86-05-15,Coppola), install(86-07-18,MR12.0-1098):
  3    10*     Add the support for subvolumes for the MSU3380 and MSU3390.
  3    11*  3) change(86-10-02,Fawcett), approve(86-10-02,PBF7383),
  3    12*     audit(86-10-23,Farley), install(86-10-28,MR12.0-1200):
  3    13*     Changed 3390 to 3381, "d338" to "3380" & "d339" to "3381".
  3    14*                                                   END HISTORY COMMENTS */
  3    15 
  3    16 /* Modified 5/19/76 by N. I. Morris */
  3    17 /* Modified 12/27/78 by Michael R. Jordan to correct MSS0500 information */
  3    18 /* Modified 4/79 by R.J.C. Kissel to add msu0501 information. */
  3    19 /* Modified '82 by BIM for needs_alt_part */
  3    20 /* Modified 4/84 by Chris Jones for FIPS disks */
  3    21 /* Modified 12/84 by Paul Farley for FIPS disks formatted for 512wd sectors */
  3    22 /* Modified 1/85 by Paul Farley to decrease the size of the 3380, until the
  3    23*   volmap and record stock can be expanded. */
  3    24 
  3    25 /*
  3    26********************************************************************************
  3    27**							        *
  3    28**                           WARNING:                                          *
  3    29**							        *
  3    30**   There exists fs_dev_types.incl.alm that must me updated when a new device *
  3    31**   type is added.						        *
  3    32**							        *
  3    33**   There are other include files that contain arrays indexed by the device   *
  3    34**   index obtained by references to MODELX or MODELN in this include file.    *
  3    35**   These must be modified when a new device type is added:		        *
  3    36**   disk_pack.incl.pl1					        *
  3    37**   fs_dev_types_sector.incl.pl1 (included in this include)		        *
  3    38**							        *
  3    39********************************************************************************
  3    40**/
  3    41 
  3    42 
  3    43 dcl (maxdevt init (9),				/* maximum legal devt */
  3    44      bulkdevt init (1),				/* bulk store devt */
  3    45      msu0500devt init (2),				/* MSU0500 device type */
  3    46      msu0451devt init (3),				/* MSU0451 device type */
  3    47      msu0450devt init (3),				/* MSU0450 device type */
  3    48      msu0400devt init (4),				/* MSU0400 device type */
  3    49      dsu191devt init (4),				/* DSU191 device type */
  3    50      dsu190devt init (5),				/* DSU190 device type */
  3    51      dsu181devt init (6),				/* DSU181 device type */
  3    52      msu0501devt init (7),				/* MSU0501 device type */
  3    53      fips3380devt init (8),				/* 3380D FIPS device type */
  3    54      fips3381devt init (9)				/* 3380E FIPS device type */
  3    55      ) fixed bin (4) static options (constant);
  3    56 
  3    57 dcl  MODEL (12) fixed bin static options (constant) init	/* Known device model numbers */
  3    58      (0, 500, 451, 450, 400, 402, 191, 190, 181, 501, 3380, 3381);
  3    59 
  3    60 dcl  MODELX (12) fixed bin static options (constant) init	/* translation from model number to device type */
  3    61      (1, 2, 3, 3, 4, 4, 4, 5, 6, 7, 8, 9);
  3    62 
  3    63 dcl  MODELN (9) fixed bin static options (constant) init	/* translation from device type to model number */
  3    64      (0, 500, 451, 400, 190, 181, 501, 3380, 3381);
  3    65 
  3    66 dcl  device_names (9) char (4) aligned static options (constant) init /* device names indexed by device type */
  3    67      ("bulk", "d500", "d451", "d400", "d190", "d181", "d501", "3380", "3381");
  3    68 
  3    69 dcl  first_dev_number (9) fixed bin (17) static options (constant) init /* First valid device_number */
  3    70      (1, 1, 1, 1, 1, 1, 1, 0, 0);
  3    71 
  3    72 dcl  fips_type_disk (9) bit (1) unal static options (constant) init /* ON => FIPS disk */
  3    73      ("0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"0"b,"1"b,"1"b);
  3    74 
  3    75 dcl  media_removable (9) bit (1) static options (constant) init /* ON => demountable pack on device */
  3    76      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    77 
  3    78 dcl  shared_spindle (9) bit (1) static options (constant) init /* ON => 2 devices per spindle */
  3    79      ("0"b, "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b);
  3    80 
  3    81 dcl  needs_alt_part (9) bit (1) static options (constant) init /* ON => needs alternate partition to run alternate tracks */
  3    82      ("0"b, "0"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b);
  3    83 
  3    84 dcl  seek_command (9) bit (6) init /* Seek command: 00 => N/A, 30 => Seek_512, 34 => seek_64 */
  3    85      ("00"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"34"b3,"30"b3, "30"b3);
  3    86 
  3    87 dcl  rec_per_dev (9) fixed bin (21) static options (constant) init /* table of # of records on each device */
  3    88      (0, 38258, 38258, 19270, 14760, 4444, 67200, 112395, 224790);
  3    89 
  3    90 dcl  rec_per_sv (9) fixed bin static options (constant) init /* table of  # of records on each subvol */
  3    91      (0, 38258, 38258, 19270, 14760, 4444, 67200, 56134, 74930);
  3    92 
  3    93 dcl  number_of_sv (9) fixed bin static options (constant) init /* table of subvolumes */
  3    94      (0, 0, 0, 0, 0, 0, 0, 2, 3);
  3    95 
  3    96 dcl  valid_sv_string char (3) static options (constant) init  /* string of valid subvolume names */
  3    97      ("abc");
  3    98 
  3    99 dcl  valid_sv_array (0:2) char (1) static options (constant) /* array of valid subvolume names */
  3   100      init ("a","b","c");
  3   101 
  3   102 dcl  cyl_per_dev (9) fixed bin static options (constant) init /* table of # of cylinders on each device */
  3   103      (0, 814, 814, 410, 410, 202, 840, 885, 1770);
  3   104 
  3   105 dcl  cyl_per_sv (9) fixed bin static options (constant) init /* table of # of cylinders on each subvolume */
  3   106      (0, 814, 814, 410, 410, 202, 840, 442, 590);
  3   107 
  3   108 dcl  rec_per_cyl (9) fixed bin static options (constant) init /* table of # of records per cylinder on each device */
  3   109      (0, 47, 47, 47, 36, 22, 80, 127, 127);
  3   110 
  3   111 dcl  tracks_per_cyl (9) fixed bin static options (constant) init /* table of # of tracks per cylinder on each device */
  3   112      (0, 19, 19, 19, 19, 20, 20, 15, 15);
  3   113 
  3   114 
  3   115 dcl  first_rec_num (9) fixed bin static options (constant) init /* table of # of first record on each device */
  3   116      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   117 
  3   118 dcl  last_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each device */
  3   119      (0, 38257, 38116, 19128, 14651, 4399, 67199, 112394, 224789);
  3   120 
  3   121 dcl  last_sv_rec_num (9) fixed bin (18) static options (constant) init /* table of # of last record on each subvolume */
  3   122      (0, 38257, 38116, 19128, 14651, 4399, 67199, 56133, 74929);
  3   123 
  3   124 dcl  first_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector for each device */
  3   125      (0, 0, 0, 0, 0, 0, 0, 0, 0);
  3   126 
  3   127 dcl  last_sect_num (9) fixed bin (24) static options (constant) init /* table of # last sector number for each device */
  3   128      (0, 618639, 616359, 309319, 239722, 71999, 1075199, 225674, 451349);
  3   129 
  3   130 dcl  first_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of first sector of alt partition */
  3   131      (0, 638400, 616360, 309320, 239723, 72000, 1075200, 225675, 451350);
  3   132 
  3   133 dcl  last_alt_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector of alt partition */
  3   134      (0, 639919, 618639, 311599, 241489, 72719, 1077759, 225930, 451605);
  3   135 
  3   136 dcl  last_physical_sect_num (9) fixed bin (24) static options (constant) init /* table of # of last sector on device (includes T&D cylinders) */
  3   137      (0, 639919, 619399, 312359, 242249, 72359, 1077759, 225674, 451859);
  3   138 
  3   139 dcl  dev_time (9) float bin (27) static options (constant) init /* table of average access times for each device */
  3   140      (384e0, 33187e0, 33187e0, 34722e0, 46935e0, 52631e0, 33187e0, 26260e0, 26260e0);
  3   141 
  4     1 /* Begin fs_dev_types_sector.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  4     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  4     7*     Add the sector differance for devices that do 64 word IO and devices that
  4     8*     do 512 word IO.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  4    12*	 need all the data in fs_dev_types. This is also included in
  4    13*	 fs_dev_types.incl.pl1  */
  4    14 
  4    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  4    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  4    17 
  4    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  4    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  4    20 
  4    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  4    22  /* table of # of sectors per record on each device */
  4    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  4    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    25 
  4    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  4    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    28 	
  4    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  4    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  4    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    32 
  4    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  4    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  4    35 
  4    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  4    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  4    38 
  4    39 /* End fs_dev_types_sector.incl.pl1 */
  4    40 
  3   142 
  3   143 
  3   144 /* End of include file ...... fs_dev_types.incl.pl1 */
      337 
      338  /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  5     2 
  5     3 /****^  HISTORY COMMENTS:
  5     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  5     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  5     6*     Add the subvolume info.
  5     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  5     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  5     9*     Added inconsistent_dbm bit used to determine consistency of volume
  5    10*     dumper bit maps.
  5    11*                                                   END HISTORY COMMENTS */
  5    12 
  5    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  5    14 /* Note: fsout_vol clears pad fields before writing the label */
  5    15 
  5    16 dcl  labelp ptr;
  5    17 
  5    18 dcl 1 label based (labelp) aligned,
  5    19 
  5    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  5    21 
  5    22     2 gcos (5*64) fixed bin,
  5    23 
  5    24 /* Now we have the Multics label */
  5    25 
  5    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  5    27     2 version fixed bin,				/* Version 1 */
  5    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  5    29     2 pv_name char (32),				/* Physical volume name. */
  5    30     2 lv_name char (32),				/* Name of logical volume for pack */
  5    31     2 pvid bit (36),				/* Unique ID of this pack */
  5    32     2 lvid bit (36),				/* unique ID of its logical vol */
  5    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  5    34     2 time_registered fixed bin (71),			/* time imported to system */
  5    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  5    36     2 vol_size fixed bin,				/* total size of volume, in records */
  5    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  5    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  5    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  5    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  5    41     2 flagpad bit (33) unal,
  5    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  5    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  5    44     2 password bit (72),				/* not yet used */
  5    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  5    46     2 this_sv fixed bin,				/* what subvolume number it is */
  5    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  5    48     2 pad1 (13) fixed bin,
  5    49     2 time_mounted fixed bin (71),			/* time mounted */
  5    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  5    51 
  5    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  5    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  5    54* */
  5    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  5    56     2 pad6 fixed bin,				
  5    57 
  5    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  5    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  5    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  5    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  5    62     2 pad1a (2) fixed bin,
  5    63     2 err_hist_size fixed bin,			/* size of pack error history */
  5    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  5    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  5    66     2 pad2 (40) fixed bin,
  5    67     2 root,
  5    68       3 here bit (1),				/* TRUE if the root is on this pack */
  5    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  5    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  5    71       3 pad7 bit (1) aligned,				
  5    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  5    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  5    74       3 esd_state fixed bin,				/* State of esd */
  5    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  5    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  5    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  5    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  5    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  5    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  5    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  5    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  5    83     2 pad3 (52) fixed bin,
  5    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  5    85     2 parts (47),
  5    86       3 part char (4),				/* Name of partition */
  5    87       3 frec fixed bin,				/* First record */
  5    88       3 nrec fixed bin,				/* Number of records */
  5    89       3 pad5 fixed bin,
  5    90     2 pad4 (5*64) fixed bin;
  5    91 
  5    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  5    93 
  5    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      338 
      339  /*	BEGIN INCLUDE FILE ... pvt.incl.pl1 ... last modified January 1982 */
  6     2 
  6     3 
  6     4 /* The physical volume table (PVT) is a wired-down table.
  6     5*   It has one entry for each spindle present, be it for
  6     6*   Storage System or "I/O" use.
  6     7**/
  6     8 
  6     9      dcl	   pvt$		      ext,
  6    10 	   pvtp		      ptr;
  6    11 
  6    12 
  6    13      dcl	   1 pvt		      based (pvtp) aligned,
  6    14 
  6    15 	     2 n_entries	      fixed bin (17),	/* number of PVT entries */
  6    16 	     2 max_n_entries      fixed bin (17),	/* max number of PVT entries */
  6    17 	     2 n_in_use	      fixed bin (17),	/* number of PVT entries in use */
  6    18 	     2 rwun_pvtx	      fixed bin,		/* rewind_unloading pvtx */
  6    19 	     2 shutdown_state     fixed bin,		/* state of previous shutdown */
  6    20 	     2 esd_state	      fixed bin,		/* state of ESD, >0 iff in ESD */
  6    21 	     2 prev_shutdown_state fixed bin,		/* shutdown state of previous bootload */
  6    22 	     2 prev_esd_state     fixed bin,		/* ESD state of previous bootload */
  6    23 
  6    24 	     2 time_of_bootload fixed bin (71),		/* Time of bootload */
  6    25 	     2 root_lvid	      bit (36) aligned,	/* Logical volume ID of Root Logical Volume (RLV) */
  6    26 	     2 root_pvid	      bit (36) aligned,	/* Physical volume ID of Root Physical Volume (RPV) */
  6    27 	     2 root_pvtx	      fixed bin,		/* Index to PVTE for Root Physical Volume (RPV) */
  6    28 	     2 root_vtocx	      fixed bin,		/* VTOCE index for root (>) */
  6    29 	     2 disk_table_vtocx   fixed bin,		/* VTOCE index for disk table on RPV */
  6    30 	     2 disk_table_uid     bit (36) aligned,	/* File System UID for disk_table */
  6    31 
  6    32 	     2 rpvs_requested     bit (1) aligned,	/* RPVS keyword given on BOOT */
  6    33 	     2 rpv_needs_salv     bit (1) aligned,	/* RPV required (not requested) salvage */
  6    34 	     2 rlv_needs_salv     bit (1) aligned,	/* RLV required (not requested) salvage */
  6    35 	     2 volmap_lock_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  6    36 	     2 volmap_idle_wait_constant bit (36) aligned,/* For constructing wait event: OR pvte_rel into lower */
  6    37 	     2 vtoc_map_lock_wait_constant bit (36) aligned, /* For constructing wait event: OR pvte_rel into lower */
  6    38 	     2 n_volmap_locks_held fixed bin (17),	/* Current number of volmap locks held */
  6    39 	     2 n_vtoc_map_locks_held fixed bin (17),	/* Current number of VTOC Map locks held */
  6    40 
  6    41 	     2 last_volmap_time   fixed bin (71),	/* Time a volmap was last locked/unlocked */
  6    42 	     2 last_vtoc_map_time fixed bin (71),	/* Time a VTOC Map was last locked/unlocked */
  6    43 	     2 total_volmap_lock_time fixed bin (71),	/* Total time volmap's were locked (integral) */
  6    44 	     2 total_vtoc_map_lock_time fixed bin (71),	/* Total time VTOC Maps were locked (integral) */
  6    45 
  6    46 	     2 n_volmap_locks     fixed bin (35),	/* Number times a volmap was locked */
  6    47 	     2 n_vtoc_map_locks   fixed bin (35),	/* Number times a vtoc_map was locked */
  6    48 	     2 volmap_lock_nowait_calls fixed bin (35),	/* Number calls to lock volmap, no wait */
  6    49 	     2 volmap_lock_nowait_fails fixed bin (35),	/* Number times lock failed */
  6    50 	     2 volmap_lock_wait_calls fixed bin (35),	/* Number calls to lock volmap, wait */
  6    51 	     2 volmap_lock_wait_fails fixed bin (35),	/* Number times lock failed */
  6    52 	     2 pad (2) bit (36) aligned,
  6    53 
  6    54 	     2 array	      fixed bin (71);	/* Array of PVTE's -- must be double-word aligned */
  6    55 
  6    56 
  6    57 
  6    58 /*	END INCLUDE FILE ...pvt.incl.pl1 */
      339 
      340  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  7     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7     8*     Add the support for subvolumes
  7     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  7    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  7    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  7    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  7    14*     Added inconsistent_dbm bit for determining the status of volume
  7    15*     dumper bit maps.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18      dcl	   pvt$array	      aligned external;
  7    19      dcl	   pvt$max_n_entries      fixed bin external;
  7    20 
  7    21      dcl	   pvt_arrayp	      ptr;
  7    22      dcl	   pvtep		      ptr;
  7    23 
  7    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  7    25 
  7    26      dcl	   1 pvte		      based (pvtep) aligned,
  7    27 
  7    28 	     2 pvid	      bit (36),		/* physical volume ID */
  7    29 
  7    30 	     2 lvid	      bit (36),		/* logical volume ID */
  7    31 
  7    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  7    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  7    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  7    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  7    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  7    37 	     2 pad3	      bit (2) unaligned,
  7    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  7    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  7    40 
  7    41 
  7    42 
  7    43 	     2 devname	      char (4),		/* device name */
  7    44 
  7    45 	     (2 device_type	      fixed bin (8),	/* device type */
  7    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  7    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  7    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  7    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  7    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  7    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  7    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  7    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  7    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  7    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  7    56 	     2 scav_check_address
  7    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  7    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  7    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  7    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  7    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  7    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  7    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  7    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  7    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  7    66 
  7    67 
  7    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  7    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  7    70 
  7    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  7    72 
  7    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  7    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  7    75 
  7    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  7    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  7    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  7    79 	     2 records_per_cyl    fixed bin,
  7    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  7    81 	     2 sv_name            char (2) aligned,
  7    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  7    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  7    84 
  7    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  7    86 	     2 pad2	      bit (18) unaligned,
  7    87 
  7    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  7    89 
  7    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  7    91 
  7    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  7    93 
  7    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  7    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  7    96 
  7    97 
  7    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  7    99 
  7   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  7   101 
  7   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  7   103 
  7   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  7   105 
  7   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  7   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  7   108 
  7   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  7   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  7   111 
  7   112 
  7   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  7   114 	   VOLMAP_ASYNC_READ      init (1),
  7   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  7   116 
  7   117 
  7   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      340 
      341      end bce_test_disk;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0826.3  bce_test_disk.pl1                 >special_ldd>install>MR12.3-1114>bce_test_disk.pl1
335          1    10/21/86  1251.6  bce_subsystem_info_.incl.pl1      >ldd>include>bce_subsystem_info_.incl.pl1
336          2    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
337          3    10/30/86  2010.5  fs_dev_types.incl.pl1             >ldd>include>fs_dev_types.incl.pl1
3-142        4    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
338          5    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
339          6    05/27/82  1525.8  pvt.incl.pl1                      >ldd>include>pvt.incl.pl1
340          7    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
LABEL_ADDR                             constant        fixed bin(17,0)          initial dcl 2-54 ref 155
Me                              000011 constant        char(32)                 initial packed unaligned dcl 34 set ref 117* 121*
                                                                                  127* 133* 147* 157* 164* 204* 206* 213* 214* 260*
                                                                                  267* 281* 304* 317* 329*
Multics                 500     000120 automatic       char(32)                 initial level 2 in structure "my_label" dcl 54
                                                                                  in procedure "bce_test_disk" set ref 54*
Multics                 500            based           char(32)                 initial level 2 in structure "label" dcl 5-18
                                                                                  in procedure "bce_test_disk" ref 173
Multics_ID_String               000010 internal static char(32)                 initial packed unaligned dcl 5-92 set ref 173 173*
addr                                                   builtin function         dcl 109 ref 112 113 114 154 164 164
addrel                                                 builtin function         dcl 109 ref 322
arg                                    based           char                     packed unaligned dcl 100 set ref 131 133* 144 147*
                                                                                  299 299 300 300 310* 329*
arg_count                       000100 automatic       fixed bin(17,0)          dcl 42 set ref 115* 120 297* 308
arg_len                         000101 automatic       fixed bin(21,0)          dcl 43 set ref 125* 130 130 131 133 133 142* 144 147
                                                                                  147 298* 299 299 300 300 309* 310 310 329 329
arg_list_ptr             16            based           pointer                  level 2 in structure "ss_info" dcl 1-15 in procedure
                                                                                  "bce_test_disk" set ref 115* 125* 142* 164*
arg_list_ptr                           parameter       pointer                  dcl 290 in procedure "pattern_parse" set ref 285
                                                                                  297* 298* 309*
arg_num                                parameter       fixed bin(17,0)          dcl 291 in procedure "pattern_parse" set ref 285
                                                                                  298* 307* 307 308 309* 312* 312
arg_num                         000102 automatic       fixed bin(17,0)          dcl 44 in procedure "bce_test_disk" set ref 124*
                                                                                  125* 141* 142* 163* 164*
arg_ptr                         000104 automatic       pointer                  dcl 45 set ref 125* 131 133 142* 144 147 298* 299
                                                                                  299 300 300 309* 310 329
array                    50            based           fixed bin(71,0)          level 2 dcl 6-13 set ref 114
bce_check_abort                 000024 constant        entry                    external dcl 80 ref 232
bce_parse_disk_spec             000030 constant        entry                    external dcl 82 ref 164
bce_query$yes_no                000032 constant        entry                    external dcl 83 ref 173
bootload_disk_buffer                   based           bit(36864)               array dcl 101 set ref 221* 235* 267
bootload_disk_io$read           000034 constant        entry                    external dcl 84 ref 244
bootload_disk_io$write          000036 constant        entry                    external dcl 85 ref 237 251
cleanup                         004144 stack reference condition                dcl 107 ref 218
code                                   parameter       fixed bin(35,0)          dcl 292 in procedure "pattern_parse" set ref 285
                                                                                  297* 298* 303* 304* 309* 310* 311 314* 316* 317*
                                                                                  328* 329* 332*
code                            000106 automatic       fixed bin(35,0)          dcl 46 in procedure "bce_test_disk" set ref 115* 116
                                                                                  117* 125* 126 127* 142* 145* 146 147* 155* 156
                                                                                  157* 164* 165 204* 205 206* 211* 212 213* 214*
                                                                                  237* 238 244* 245 251* 252 281*
com_err_                        000040 constant        entry                    external dcl 86 ref 117 127 147 157 206 213 260 304
                                                                                  317 329
copy                                                   builtin function         dcl 109 ref 180
cu_$arg_count_rel               000042 constant        entry                    external dcl 87 ref 115 297
cu_$arg_ptr_rel                 000044 constant        entry                    external dcl 88 ref 125 142 298 309
cv_oct_check_                   000046 constant        entry                    external dcl 89 ref 310
device_type               4            based           fixed bin(8,0)           array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 7-24 in procedure "bce_test_disk"
                                                                                  ref 161
device_type                     000107 automatic       fixed bin(17,0)          dcl 47 in procedure "bce_test_disk" set ref 161*
                                                                                  164* 225 227
disk_name_pvtx                  000026 constant        entry                    external dcl 81 ref 145
divide                                                 builtin function         dcl 109 ref 180
drive                           000110 automatic       char(8)                  packed unaligned dcl 48 set ref 144* 145* 157* 170*
                                                                                  171* 173* 260* 267*
error_on_write                  000112 automatic       bit(1)                   packed unaligned dcl 49 set ref 239* 246* 253* 260*
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 75 ref 303 328
error_table_$noarg              000022 external static fixed bin(35,0)          dcl 76 ref 316
f_record                        000113 automatic       fixed bin(18,0)          dcl 50 set ref 164* 170 170* 171* 226 229
force                           000114 automatic       bit(1)                   dcl 51 set ref 152* 172 299*
get_ptrs_$given_segno           000050 constant        entry                    external dcl 90 ref 210
get_temp_segment_               000052 constant        entry                    external dcl 91 ref 204
info_ptr                               parameter       pointer                  dcl 293 ref 285
ioa_                            000054 constant        entry                    external dcl 92 ref 121 133 170 171 267
key                             000115 automatic       char(2)                  packed unaligned dcl 52 set ref 131* 132 132 132 132
                                                                                  136 137 138 139 302 302 304*
l_record                        000116 automatic       fixed bin(18,0)          dcl 53 set ref 164* 170 171* 224
label                                  based           structure                level 1 dcl 5-18
labelp                          004156 automatic       pointer                  dcl 5-16 set ref 154* 155* 164* 173
max                                                    builtin function         dcl 109 ref 229
min                                                    builtin function         dcl 109 ref 228
mod                                                    builtin function         dcl 109 ref 225
my_label                        000120 automatic       structure                level 1 dcl 54 set ref 154
new_record                      002120 automatic       fixed bin(18,0)          dcl 55 set ref 229* 230 237* 244* 251* 255* 260* 267
                                                                                  271
null                                                   builtin function         dcl 109 ref 203
number                          000100 automatic       fixed bin(35,0)          dcl 295 set ref 310* 322
p_ss_info_ptr                          parameter       pointer                  dcl 38 ref 21 111
page_num                        002121 automatic       fixed bin(17,0)          dcl 56 set ref 220* 221* 234* 235* 265* 267 267*
pattern                         002122 automatic       structure                level 1 dcl 57 set ref 164 164
pattern_buffer            1     002122 automatic       bit(36864)               level 2 dcl 57 set ref 112 179* 180* 221 235 267
pattern_buffer_ptr              004124 automatic       pointer                  dcl 60 set ref 112* 180 322
pc_abs$unwire_abs               000056 constant        entry                    external dcl 93 ref 280
pc_abs$wire_abs_contig          000060 constant        entry                    external dcl 94 ref 211
prev_record                     004126 automatic       fixed bin(18,0)          dcl 61 set ref 224* 225 226 229 230 255 271*
prev_record_in_cylinder         004127 automatic       fixed bin(17,0)          dcl 62 set ref 225* 227 227* 228 272* 272
pvt                                    based           structure                level 1 dcl 6-13
pvt$                            000066 external static fixed bin(17,0)          dcl 6-9 set ref 113
pvt_array                              based           structure                array level 1 dcl 7-24
pvt_arrayp                      004162 automatic       pointer                  dcl 7-21 set ref 114* 161
pvte                                   based           structure                level 1 dcl 7-26
pvtp                            004160 automatic       pointer                  dcl 6-9 set ref 113* 114
pvtx                            004130 automatic       fixed bin(17,0)          dcl 63 set ref 145* 155* 161 237* 244* 251*
read_disk                       000062 constant        entry                    external dcl 95 ref 155
read_sw                         004131 automatic       bit(1)                   packed unaligned dcl 64 set ref 136*
read_then_write                 004132 automatic       bit(1)                   packed unaligned dcl 65 set ref 138* 250
rec_per_cyl                     000000 constant        fixed bin(17,0)          initial array dcl 3-108 ref 225 227
records_this_cylinder           004133 automatic       fixed bin(17,0)          dcl 66 set ref 228* 229 230* 234 237* 244* 251* 254
                                                                                  256* 265 272
release_temp_segment_           000064 constant        entry                    external dcl 96 ref 214 281
seek_command                    004154 automatic       bit(6)                   initial array packed unaligned dcl 3-84 set ref
                                                                                  3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84* 3-84*
                                                                                  3-84*
segno                                                  builtin function         dcl 109 ref 210 210
ss_info                                based           structure                level 1 dcl 1-15
ss_info_ptr                     004152 automatic       pointer                  dcl 1-14 set ref 111* 115 125 142 164
temp_astep                      004134 automatic       pointer                  dcl 67 set ref 210* 211* 280*
temp_seg_ptr                    004136 automatic       pointer                  dcl 68 set ref 203* 204* 210 210 214* 221 235 237*
                                                                                  244* 251* 267 281*
unspec                                                 builtin function         dcl 109 set ref 179* 322
word                                   based           bit(36)                  dcl 102 set ref 322*
word_pattern                           based           bit                      dcl 103 ref 180
word_pattern_len                002122 automatic       fixed bin(17,0)          level 2 dcl 57 set ref 151* 179 180 180 301* 314 322
                                                                                  323* 323
write_sw                        004141 automatic       bit(1)                   packed unaligned dcl 70 set ref 137* 169 220 243 250
write_then_read                 004140 automatic       bit(1)                   packed unaligned dcl 69 set ref 139* 169 233 265
yes_no                          004142 automatic       bit(1)                   packed unaligned dcl 71 set ref 173* 175

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 2-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 2-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 2-54
MODEL                                  internal static fixed bin(17,0)          initial array dcl 3-57
MODELN                                 internal static fixed bin(17,0)          initial array dcl 3-63
MODELX                                 internal static fixed bin(17,0)          initial array dcl 3-60
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 2-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 2-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 2-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 2-54
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 7-113
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 2-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 2-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 2-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 2-54
bulkdevt                               internal static fixed bin(4,0)           initial dcl 3-43
cyl_per_dev                            internal static fixed bin(17,0)          initial array dcl 3-102
cyl_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-105
dev_time                               internal static float bin(27)            initial array dcl 3-139
device_names                           internal static char(4)                  initial array dcl 3-66
dsu181devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu190devt                             internal static fixed bin(4,0)           initial dcl 3-43
dsu191devt                             internal static fixed bin(4,0)           initial dcl 3-43
fips3380devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips3381devt                           internal static fixed bin(4,0)           initial dcl 3-43
fips_type_disk                         internal static bit(1)                   initial array packed unaligned dcl 3-72
first_alt_sect_num                     internal static fixed bin(24,0)          initial array dcl 3-130
first_dev_number                       internal static fixed bin(17,0)          initial array dcl 3-69
first_rec_num                          internal static fixed bin(17,0)          initial array dcl 3-115
first_sect_num                         internal static fixed bin(24,0)          initial array dcl 3-124
last_alt_sect_num                      internal static fixed bin(24,0)          initial array dcl 3-133
last_physical_sect_num                 internal static fixed bin(24,0)          initial array dcl 3-136
last_rec_num                           internal static fixed bin(18,0)          initial array dcl 3-118
last_sect_num                          internal static fixed bin(24,0)          initial array dcl 3-127
last_sv_rec_num                        internal static fixed bin(18,0)          initial array dcl 3-121
maxdevt                                internal static fixed bin(4,0)           initial dcl 3-43
media_removable                        internal static bit(1)                   initial array packed unaligned dcl 3-75
msu0400devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0450devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0451devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0500devt                            internal static fixed bin(4,0)           initial dcl 3-43
msu0501devt                            internal static fixed bin(4,0)           initial dcl 3-43
needs_alt_part                         internal static bit(1)                   initial array packed unaligned dcl 3-81
number_of_sv                           internal static fixed bin(17,0)          initial array dcl 3-93
pvt$array                              external static fixed bin(17,0)          dcl 7-18
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 7-19
pvtep                                  automatic       pointer                  dcl 7-22
rec_per_dev                            internal static fixed bin(21,0)          initial array dcl 3-87
rec_per_sv                             internal static fixed bin(17,0)          initial array dcl 3-90
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 4-15
sect_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-21
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 4-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 4-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 4-26
shared_spindle                         internal static bit(1)                   initial array packed unaligned dcl 3-78
tracks_per_cyl                         internal static fixed bin(17,0)          initial array dcl 3-111
valid_sv_array                         internal static char(1)                  initial array packed unaligned dcl 3-99
valid_sv_string                        internal static char(3)                  initial packed unaligned dcl 3-96
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 4-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 4-36

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_key                         000574 constant        label                    dcl 133 ref 130
bce_test_disk                   000272 constant        entry                    external dcl 21
clean_up                        002034 constant        entry                    internal dcl 278 ref 218 275
end_pattern                     002321 constant        label                    dcl 314 ref 308
io_error                        001670 constant        label                    dcl 254 ref 240 247
next_record                     002021 constant        label                    dcl 271 ref 261
next_word                       002242 constant        label                    dcl 307 ref 324
pattern_parse                   002103 constant        entry                    internal dcl 285 ref 164 164
retry                           001541 constant        label                    dcl 232 ref 257

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2716        3006    2430        2726
Length      3370    2430        70         345     266          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bce_test_disk                      2284 external procedure  is an external procedure.  
on unit on line 218                  64 on unit               
clean_up                             88 internal procedure  is called by several nonquick procedures.  
pattern_parse                       107 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Multics_ID_String           bce_test_disk

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bce_test_disk            000100 arg_count                   bce_test_disk
                         000101 arg_len                     bce_test_disk
                         000102 arg_num                     bce_test_disk
                         000104 arg_ptr                     bce_test_disk
                         000106 code                        bce_test_disk
                         000107 device_type                 bce_test_disk
                         000110 drive                       bce_test_disk
                         000112 error_on_write              bce_test_disk
                         000113 f_record                    bce_test_disk
                         000114 force                       bce_test_disk
                         000115 key                         bce_test_disk
                         000116 l_record                    bce_test_disk
                         000120 my_label                    bce_test_disk
                         002120 new_record                  bce_test_disk
                         002121 page_num                    bce_test_disk
                         002122 pattern                     bce_test_disk
                         004124 pattern_buffer_ptr          bce_test_disk
                         004126 prev_record                 bce_test_disk
                         004127 prev_record_in_cylinder     bce_test_disk
                         004130 pvtx                        bce_test_disk
                         004131 read_sw                     bce_test_disk
                         004132 read_then_write             bce_test_disk
                         004133 records_this_cylinder       bce_test_disk
                         004134 temp_astep                  bce_test_disk
                         004136 temp_seg_ptr                bce_test_disk
                         004140 write_then_read             bce_test_disk
                         004141 write_sw                    bce_test_disk
                         004142 yes_no                      bce_test_disk
                         004152 ss_info_ptr                 bce_test_disk
                         004154 seek_command                bce_test_disk
                         004156 labelp                      bce_test_disk
                         004160 pvtp                        bce_test_disk
                         004162 pvt_arrayp                  bce_test_disk
pattern_parse            000100 number                      pattern_parse

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          mdfx1               enable_op           shorten_stack       ext_entry           int_entry
repeat              set_bits_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bce_check_abort               bce_parse_disk_spec           bce_query$yes_no              bootload_disk_io$read
bootload_disk_io$write        com_err_                      cu_$arg_count_rel             cu_$arg_ptr_rel
cv_oct_check_                 disk_name_pvtx                get_ptrs_$given_segno         get_temp_segment_
ioa_                          pc_abs$unwire_abs             pc_abs$wire_abs_contig        read_disk
release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$noarg            pvt$




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000267        54 000277    3   84 000302       111 000371       112 000375       113 000377       114 000401
    115 000403       116 000416       117 000420       118 000435       120 000436       121 000441       122 000461
    124 000462       125 000464       126 000504       127 000506       128 000533       130 000534       131 000541
    132 000546       133 000574       134 000623       136 000624       137 000635       138 000646       139 000653
    141 000660       142 000662       144 000702       145 000707       146 000722       147 000724       148 000756
    151 000757       152 000760       154 000761       155 000763       156 001002       157 001004       158 001034
    161 001035       163 001043       164 001045       165 001104       169 001106       170 001112       171 001142
    172 001171       173 001173       175 001235       179 001240       180 001247       203 001265       204 001270
    205 001311       206 001313       207 001337       210 001340       211 001355       212 001375       213 001377
    214 001423       215 001444       218 001445       220 001467       221 001475       222 001503       224 001505
    225 001510       226 001514       227 001517       228 001524       229 001530       230 001536       232 001541
    233 001546       234 001550       235 001557       236 001565       237 001567       238 001606       239 001610
    240 001612       243 001613       244 001615       245 001634       246 001636       247 001640       250 001641
    251 001645       252 001664       253 001666       254 001670       255 001673       256 001676       257 001700
    260 001701       261 001742       265 001743       267 001755       269 002017       271 002021       272 002023
    273 002025       275 002026       276 002032       278 002033       280 002041       281 002057       282 002101
    285 002102       297 002110       298 002124       299 002145       300 002163       301 002173       302 002174
    303 002206       304 002212       305 002241       307 002242       308 002244       309 002250       310 002267
    311 002314       312 002317       314 002321       316 002326       317 002331       319 002353       322 002354
    323 002362       324 002363       328 002364       329 002370       330 002421       332 002422       333 002424


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
