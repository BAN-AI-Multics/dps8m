	COMPILATION LISTING OF SEGMENT uid_path_util
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1040.0 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       13 
       14 /* Procedure which contains some entires that now how to deal with uid pathnames.
       15*   This module was written for use by Master directory Control. */
       16 
       17 /* UID_PATH_UTIL has the following entries:
       18*
       19*   1. uid_path_util$get: Given a pointer to a directory, this entry returns the uidpathname of its parent
       20*
       21*   2. uid_path_util$get_uid_path: A gate entry which, given a pathname, returns
       22*   a uid pathname.
       23*
       24*   3. uid_path_util$decode_uidpath: A gate entry which, given a uid pathanme,
       25*   returns a directory and entry name.
       26*
       27*
       28**/
       29 
       30 /* Written March 1975 by Larry Johnson */
       31 /* Modified July 1984 by Keith Loepere to use the new dc_find. */
       32 /* Modified January 1985 by EJ Sharpe to handle et_$root */
       33 /* Modified May 1985 by EJ Sharpe to add decode_uidpath_raw and decode_uidpath_priv,
       34*	the decode_uidpath entry now requires "S" on parent */
       35 
       36 uid_path_util: proc;
       37 
       38 /* Parameters */
       39 
       40 dcl  a_code			fixed bin (35);
       41 dcl  a_dirname			char (*);		/* Name of directory to return */
       42 dcl  a_dp				ptr;		/* Returned pointer to the directory */
       43 dcl  a_ename			char (*);		/* Entry name to return */
       44 dcl  a_uidpath			(0:15) bit (36) aligned; /* Pathname of directory to find */
       45 
       46 /* Variables */
       47 
       48 dcl  build_dir			char (168) var init ("");
       49 dcl  code				fixed bin (35);
       50 dcl  decodesw			bit (1) init ("0"b);/* Set if entered thru decode_uidpath entry */
       51 dcl  dirsw			bit (1) init ("0"b);/* Set if entered thru dir entry */
       52 dcl  dname			char (168);
       53 dcl  ename			char (32);
       54 dcl  i				fixed bin;
       55 dcl  segnum			fixed bin;
       56 dcl  uidpath			(0:15) bit (36) aligned;
       57 
       58 /* Misc */
       59 
       60 dcl  (ptr, segno, unspec)		builtin;
       61 
       62 /* External */
       63 
       64 dcl  error_table_$bad_uidpath		ext fixed bin (35);
       65 dcl  error_table_$root		ext fixed bin (35);
       66 
       67 /* Entries */
       68 
       69 dcl  get_kstep$dir			entry (fixed bin, ptr, fixed bin (35));
       70 dcl  uid_path_util$get		entry (ptr, dim (0:15) bit (36) aligned, fixed bin (35));
       71 
       72 
       73 /* This entry will get a uid pathname from a directory pointer */
       74 
       75 get: entry (a_dp, a_uidpath, a_code);
       76 
       77 	a_code = 0;
       78 	dp = a_dp;
       79 	a_uidpath = "0"b;
       80 
       81 	do i = dir.tree_depth to 0 by -1;		/* Scan backwards thru all parents */
       82 	     segnum = segno (dp);
       83 	     call get_kstep$dir (segnum, kstep, code);	/* Find the kst entry */
       84 	     if code ^= 0 then go to err;
       85 	     a_uidpath (i) = kste.uid;
       86 	     dp = kste.entryp;			/* Back to parent */
       87 	end;
       88 	return;
       89 
       90 
       91 /* This entry is called thru a gate. Given a directory and entry name,
       92*   it returns the uidpath */
       93 
       94 get_uidpath: entry (a_dirname, a_ename, a_uidpath, a_code);
       95 
       96 	dname = a_dirname;
       97 	ename = a_ename;
       98 	unspec (a_uidpath) = "0"b;
       99 	call dc_find$obj_status_read_priv (dname, ename, DC_FIND_NO_CHASE, ep, code); /* Find my seg */
      100 	if code ^= 0 then go to err;
      101 	dp = ptr (ep, 0);
      102 	call uid_path_util$get (dp, uidpath, code);	/* Get uidpath of parent */
      103 	if code ^= 0 then do;
      104 	     call dc_find$finished (dp, "1"b);
      105 	     go to err;
      106 	end;
      107 	uidpath (dir.tree_depth + 1) = entry.uid;	/* Finish up with uid of entry */
      108 	call dc_find$finished (dp, "1"b);
      109 	a_uidpath = uidpath;
      110 	return;
      111 
      112 err:	a_code = code;
      113 	return;
      114 
      115 /* This entry, called thru a gate, will return a directory and entry name,
      116*   given a uidpath name.  The caller must have "S" access on parent of the entry.
      117*   It is used by master directory control via admin_gate_. */
      118 
      119 decode_uidpath: entry (a_uidpath, a_dirname, a_ename, a_code);
      120 
      121 	uidpath = a_uidpath;
      122 	a_dirname, a_ename = "";
      123 	a_code = 0;
      124 
      125 	call dc_find$obj_status_read_uid (uidpath, dname, ename, ep, code);
      126 	goto decode_common;
      127 
      128 /* This entry, called thru a gate, will return a directory and entry name,
      129*   given a uidpath name.  The caller need not have "S" access on parent of the entry. */
      130 
      131 decode_uidpath_priv: entry (a_uidpath, a_dirname, a_ename, a_code);
      132 
      133 	uidpath = a_uidpath;
      134 	a_dirname, a_ename = "";
      135 	a_code = 0;
      136 
      137 	call dc_find$obj_status_read_priv_uid (uidpath, dname, ename, ep, code);
      138 	goto decode_common;
      139 
      140 /* This entry, called thru a gate, will return a directory and entry name,
      141*   given a uidpath name.  It allows access to the names of aim isolated dirs.
      142*   It is called from the volume backup system via the hc_backup_ gate. */
      143 
      144 decode_uidpath_raw: entry (a_uidpath, a_dirname, a_ename, a_code);
      145 
      146 	uidpath = a_uidpath;
      147 	a_dirname, a_ename = "";
      148 	a_code = 0;
      149 
      150 	call dc_find$obj_status_read_raw_uid (uidpath, dname, ename, ep, code);
      151 
      152 
      153 decode_common:
      154 	if code = error_table_$root
      155 	then do;
      156 	     code = 0;
      157 	     ename = "";				/* no entry */
      158 	end;
      159 	else if code = error_table_$bad_uidpath then do;	/* return what we know */
      160 	     a_dirname = dname;
      161 	     a_ename = "";
      162 	     go to err;
      163 	end;
      164 	else if code ^= 0
      165 	     then go to err;			/* return the error */
      166 	else call dc_find$finished (ptr (ep, 0), "1"b);	/* we're finished */
      167 
      168 	a_dirname = dname;
      169 	a_ename = ename;
      170 	a_code = 0;
      171 	return;
      172  /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      172 
      173  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      173 
      174  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      174 
      175  /*  START OF:	kst.incl.pl1			  *  *  *  *  *  */
  4     2 
  4     3 /*
  4     4*Modified March 1976 by R. Bratt 
  4     5*Modified November 1984 to remove hdr, Keith Loepere. */
  4     6 
  4     7 
  4     8 /****^  HISTORY COMMENTS:
  4     9*  1) change(86-08-08,GDixon), approve(86-08-08,MCR7388),
  4    10*     audit(86-09-02,Farley), install(86-09-08,MR12.0-1150):
  4    11*     Add warning on use of kste.entryp.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 dcl  pds$kstp ext ptr,
  4    16     (kstp, kstep) ptr;
  4    17 
  4    18 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  4    19     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  4    20     2 highseg fixed bin (17),				/* highest segment number described by kst */
  4    21     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  4    22     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  4    23     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  4    24     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  4    25     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  4    26     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  4    27     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  4    28     2 template bit (1) unaligned,			/* this is a template kst if set */
  4    29     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  4    30     2 unused_2 bit (9) unaligned,
  4    31     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  4    32     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  4    33     2 lv (1:256) bit (36),				/* private logical volume connection list */
  4    34     2 end_of_kst bit (36);
  4    35 
  4    36 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  4    37     2 fp bit (18) unaligned,				/* forward rel pointer */
  4    38     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  4    39     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  4    40     2 entryp ptr unaligned,				/* branch pointer */
  4    41 						/* See WARNING below for requirements to use entryp. */
  4    42     2 uid bit (36) aligned,				/* unique identifier */
  4    43     2 access_information unaligned,
  4    44       3 dtbm bit (36),				/* date time branch modified */
  4    45       3 extended_access bit (33),			/* extended access from the branch */
  4    46       3 access bit (3),				/* rew */
  4    47       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  4    48     2 pad1 bit (3) unaligned,
  4    49     2 flags unaligned,
  4    50       3 dirsw bit (1),				/* directory switch */
  4    51       3 allow_write bit (1),				/* set if initiated with write permission */
  4    52       3 priv_init bit (1),				/* privileged initiation */
  4    53       3 tms bit (1),				/* transparent modification switch */
  4    54       3 tus bit (1),				/* transparent usage switch */
  4    55       3 tpd bit (1),				/* transparent paging device switch */
  4    56       3 audit bit (1),				/* audit switch */
  4    57       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  4    58       3 pad bit (3),
  4    59     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  4    60 
  4    61 
  4    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    63 /*							       */
  4    64 /* WARNING: Before using kste.entryp to get a pointer to the directory       */
  4    65 /* entry associated with the kst entry, you must first validate its value    */
  4    66 /* by calling sum$getbranch or sum$getbranch_root_my.  This call also locks  */
  4    67 /* the containing directory.  The containing directory must remain locked    */
  4    68 /* during the entire period when kste.entryp and the directory entry are     */
  4    69 /* being referenced.  Once the directory is unlocked, kste.entryp can no     */
  4    70 /* longer be used to get a pointer to the entry within the unlocked	       */
  4    71 /* directory since the dir entry could have been moved within the directory  */
  4    72 /* by another processor.					       */
  4    73 /*							       */
  4    74 /* If you only need a pointer to the directory containing the associated     */
  4    75 /* dir entry (but not to the dir entry itself), you can use:	       */
  4    76 /*    pointer (kste.entryp, 0)				       */
  4    77 /* without calling sum to lock the directory and validate entryp.  GDixon    */
  4    78 /*							       */
  4    79 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    80 
  4    81 /*  END OF:	kst.incl.pl1			  *  *  *  *  *  */
      175 
      176      end uid_path_util;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0800.7  uid_path_util.pl1                 >spec>install>1110>uid_path_util.pl1
172          1    05/20/85  0848.1  dc_find_dcls.incl.pl1             >ldd>include>dc_find_dcls.incl.pl1
173          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
174          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
175          4    09/18/86  1308.1  kst.incl.pl1                      >ldd>include>kst.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DC_FIND_NO_CHASE                000000 constant        fixed bin(1,0)           initial dcl 1-11 set ref 99*
a_code                                 parameter       fixed bin(35,0)          dcl 40 set ref 75 77* 94 112* 119 123* 131 135* 144
                                                                                  148* 170*
a_dirname                              parameter       char                     packed unaligned dcl 41 set ref 94 96 119 122* 131
                                                                                  134* 144 147* 160* 168*
a_dp                                   parameter       pointer                  dcl 42 ref 75 78
a_ename                                parameter       char                     packed unaligned dcl 43 set ref 94 97 119 122* 131
                                                                                  134* 144 147* 161* 169*
a_uidpath                              parameter       bit(36)                  array dcl 44 set ref 75 79* 85* 94 98* 109* 119 121
                                                                                  131 133 144 146
build_dir                       000100 automatic       varying char(168)        initial dcl 48 set ref 48*
code                            000153 automatic       fixed bin(35,0)          dcl 49 set ref 83* 84 99* 100 102* 103 112 125* 137*
                                                                                  150* 153 156* 159 164
dc_find$finished                000020 constant        entry                    external dcl 1-33 ref 104 108 166
dc_find$obj_status_read_priv    000024 constant        entry                    external dcl 1-77 ref 99
dc_find$obj_status_read_priv_uid
                                000026 constant        entry                    external dcl 1-79 ref 137
dc_find$obj_status_read_raw_uid 000030 constant        entry                    external dcl 1-80 ref 150
dc_find$obj_status_read_uid     000022 constant        entry                    external dcl 1-76 ref 125
decodesw                        000154 automatic       bit(1)                   initial packed unaligned dcl 50 set ref 50*
dir                                    based           structure                level 1 dcl 3-11
dirsw                           000155 automatic       bit(1)                   initial packed unaligned dcl 51 set ref 51*
dname                           000156 automatic       char(168)                packed unaligned dcl 52 set ref 96* 99* 125* 137*
                                                                                  150* 160 168
dp                              000264 automatic       pointer                  dcl 3-9 set ref 78* 81 82 86* 101* 102* 104* 107
                                                                                  108*
ename                           000230 automatic       char(32)                 packed unaligned dcl 53 set ref 97* 99* 125* 137*
                                                                                  150* 157* 169
entry                                  based           structure                level 1 dcl 2-8
entryp                    3            based           pointer                  level 2 packed packed unaligned dcl 4-36 ref 86
ep                              000262 automatic       pointer                  dcl 2-6 set ref 99* 101 107 125* 137* 150* 166 166
error_table_$bad_uidpath        000010 external static fixed bin(35,0)          dcl 64 ref 159
error_table_$root               000012 external static fixed bin(35,0)          dcl 65 ref 153
get_kstep$dir                   000014 constant        entry                    external dcl 69 ref 83
i                               000240 automatic       fixed bin(17,0)          dcl 54 set ref 81* 85*
kste                                   based           structure                level 1 dcl 4-36
kstep                           000266 automatic       pointer                  dcl 4-15 set ref 83* 85 86
ptr                                                    builtin function         dcl 60 ref 101 166 166
segno                                                  builtin function         dcl 60 ref 82
segnum                          000241 automatic       fixed bin(17,0)          dcl 55 set ref 82* 83*
tree_depth               57            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 81 107
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "uid_path_util" ref 107
uid                       4            based           bit(36)                  level 2 in structure "kste" dcl 4-36 in procedure
                                                                                  "uid_path_util" ref 85
uid_path_util$get               000016 constant        entry                    external dcl 70 ref 102
uidpath                         000242 automatic       bit(36)                  array dcl 56 set ref 102* 107* 109 121* 125* 133*
                                                                                  137* 146* 150*
unspec                                                 builtin function         dcl 60 set ref 98*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 1-13
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_read                000000 constant        entry                    external dcl 1-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 1-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$link_target             000000 constant        entry                    external dcl 1-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 1-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 1-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 1-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 1-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 1-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 1-51
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 1-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 1-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 1-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 1-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 1-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_write        000000 constant        entry                    external dcl 1-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 1-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 1-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 1-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_truncate            000000 constant        entry                    external dcl 1-91
dc_find$obj_truncate_ptr        000000 constant        entry                    external dcl 1-92
dc_find$obj_truncate_raw_ptr    000000 constant        entry                    external dcl 1-93
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
kst                                    based           structure                level 1 dcl 4-18
kstp                                   automatic       pointer                  dcl 4-15
pds$kstp                               external static pointer                  dcl 4-15
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
decode_common                   000571 constant        label                    dcl 153 ref 126 138
decode_uidpath                  000313 constant        entry                    external dcl 119
decode_uidpath_priv             000406 constant        entry                    external dcl 131
decode_uidpath_raw              000501 constant        entry                    external dcl 144
err                             000303 constant        label                    dcl 112 ref 84 100 105 162 164
get                             000032 constant        entry                    external dcl 75
get_uidpath                     000132 constant        entry                    external dcl 94
uid_path_util                   000017 constant        entry                    external dcl 36

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1060        1112     665        1070
Length      1364     665        32         235     173           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
uid_path_util                       222 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
uid_path_util            000100 build_dir                   uid_path_util
                         000153 code                        uid_path_util
                         000154 decodesw                    uid_path_util
                         000155 dirsw                       uid_path_util
                         000156 dname                       uid_path_util
                         000230 ename                       uid_path_util
                         000240 i                           uid_path_util
                         000241 segnum                      uid_path_util
                         000242 uidpath                     uid_path_util
                         000262 ep                          uid_path_util
                         000264 dp                          uid_path_util
                         000266 kstep                       uid_path_util

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dc_find$finished              dc_find$obj_status_read_priv  dc_find$obj_status_read_priv_uid
dc_find$obj_status_read_raw_uid                             dc_find$obj_status_read_uid   get_kstep$dir
uid_path_util$get

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_uidpath      error_table_$root




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     48 000011        50 000012        51 000013        36 000016        75 000025        77 000045        78 000046
     79 000052        81 000063        82 000072        83 000076        84 000111        85 000113        86 000117
     87 000121        88 000124        94 000125        96 000156        97 000166        98 000176        99 000202
    100 000221       101 000223       102 000225       103 000240       104 000242       105 000255       107 000256
    108 000263       109 000276       110 000302       112 000303       113 000305       119 000306       121 000337
    122 000343       123 000363       125 000364       126 000403       131 000404       133 000432       134 000436
    135 000456       137 000457       138 000476       144 000477       146 000525       147 000531       148 000551
    150 000552       153 000571       156 000575       157 000576       158 000601       159 000602       160 000604
    161 000614       162 000624       164 000625       166 000627       168 000643       169 000653       170 000663
    171 000664


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
