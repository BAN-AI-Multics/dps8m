	COMPILATION LISTING OF SEGMENT create_vtoce
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0954.7 mst Sat
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /*
       14*   create_vtoce (branchp, pvid, vtocx, code)
       15*
       16*
       17*   FUNCTION -
       18*
       19*   This procedure creates a vtoc entry for the segment whose branch is  pointed  to
       20*   by  the input argument (branchp). It returns the uid of physical volume in which
       21*   the vtoc entry was created (pvid) and the vtoc index (vtocx) of this vtoc entry.
       22*
       23*   If the operation is successful the code returned is zero. If it fails, then  one
       24*   possible returned value is error_table_$log_vol_full.      In this case, no vtoc
       25*   entry was created and pvid=0, vtocx = -1.
       26*
       27*   The logical volume assigned to the vtoc entry is defined as follows: if the vtoc
       28*   entry is for a directory, the logical volume is the system logical volume, where
       29*   all  directories  reside;  if the vtoc entry is for a non directory segment, the
       30*   logical volume is specified in the header of the parent directory.
       31*
       32*
       33*   IMPLEMENTATION -
       34*
       35*   The parent directory is supposed to be locked before this procedure  is  called.
       36*   Also the branch is supposed to be initialized.
       37*
       38*   The  physical  volume where the vtoc entry is created is the first member of the
       39*   logical volume which is not full. The file map is initialized with zeros.
       40*
       41*   MODIFIED BY *
       42*
       43*   03/10/75	Andre Bensoussan for the new storage system.
       44*   08/11/75 Bernard Greenberg - most-space allocation algorithm.
       45*   10/01/75 RE Mullen - optimize filemap nulling.
       46*   10/21/75 by Greenberg for allocation by recs available, seg mover.
       47*   02/06/76 by Greenberg for dynamic demounter.
       48*   02/18/76 by Richard Bratt for LVT
       49*   03/22/76 by Larry Johnson to set master_dir switch in vtoce, and to call uid_path_util for uid pathname
       50*   06/76 by D.Vinograd to update volume dumper bit map when creating new vtoce.
       51*   09/27/76 by RE Mullen for (cycling | pro-rata) PV selection to reduce io contention
       52*   29 Jan 79 by D. Spector to allocate vtoces for deciduous segments on the RPV
       53*   10/03/79 by J. A. Bush to copy terminal quota info  when copying vtoce for segment_mover
       54*   01/09/80 by Mike Grady to fix try_cycle bug for inop devices and speed up fm nuller code
       55*   03/22/81 by J. Bongiovanni for bug fix
       56*            for volume being salvaged, avoid per-process creation on saturated units
       57*   06/24/81 by J. Bongiovanni for random selection of PV within LV, weighted
       58*            by fraction of space left
       59*   03/06/82 by J. Bongiovanni to eliminate vtoce.infqcnt, for new PVTE, and for
       60*            optimize parameter for segmove
       61*   06/02/82 by J. Bongiovanni to set vtoce.perm_flags.per_bootload
       62*   83-12-06 by BIM to correctly check LV access class and audit violations.
       63*   84-12-05 by EJ Sharpe to use access_audit_ instead of protection_audit_
       64*   85-04-01 by Keith Loepere for access_audit_check_ep_.
       65**/
       66 
       67 
       68 create_vtoce : procedure (branchp, pvid, vtocx, code);
       69 
       70 
       71 dcl  branchp ptr;					/* Input  - ptr to the branch */
       72 dcl  pvid bit (36);					/* Output - uid of the phys. vol. where vtoc entry is created */
       73 dcl  vtocx fixed bin (17);				/* Output - index of the vtoc entry that was created */
       74 dcl  code fixed bin (35);				/* Output - error code */
       75 
       76 /* Arguments for segmove entry */
       77 
       78 dcl  corout_pvtx fixed bin;				/* Input/Output - next pvtx to be tried */
       79 dcl  a_skip_pvtx fixed bin;
       80 dcl  skip_pvtx fixed bin;				/* Input - original segment pvtx */
       81 dcl  a_nreq fixed bin;				/* Input - required number of records */
       82 dcl  a_optimize bit (1) aligned;			/* Input - optimize allocation of PV */
       83 
       84 dcl (i, pvtx, msl) fixed bin (17);
       85 dcl  first_pvtx fixed bin (17);
       86 dcl  nreq fixed bin (17);
       87 dcl (mover, looped, looping, try_cycle, held) bit (1);
       88 dcl  1 event_flags aligned like audit_event_flags;
       89 dcl  force_rpv bit (1);
       90 dcl  optimizing bit (1);
       91 dcl  lvid bit (36);
       92 dcl  queue_length fixed bin;
       93 dcl (working_sum, random_number, sum_fract_empty) fixed bin (35, 18);
       94 dcl  n_pvs fixed bin;
       95 dcl  pv_found bit (1);
       96 dcl  pv_alloc_x fixed bin;
       97 dcl  1 pv_alloc (MAX_PV_PER_LV) aligned,
       98      2 pvtx fixed bin,
       99      2 fract_empty fixed bin (35, 18);
      100 
      101 dcl  vtoc_buffer (96) fixed bin (71);
      102 dcl 1 local_vtoce like vtoce aligned based (addr (vtoc_buffer));
      103 dcl  based_class_range (2) bit (72) aligned based;
      104 
      105 dcl  access_operations_$fs_obj_create bit (36) aligned ext;
      106 dcl  sys_info$initialization_state fixed bin ext;
      107 dcl  sst$cycle_pv_allocation fixed bin (35) external;
      108 dcl  pvt$root_lvid bit (36) aligned external;
      109 dcl  error_table_$log_vol_full ext fixed bin (35);
      110 dcl  error_table_$pvid_not_found ext fixed bin (35);
      111 dcl  error_table_$ai_restricted ext fixed bin (35);
      112 dcl  sys_info$default_max_length ext fixed bin (19);
      113 dcl  sys_info$default_dir_max_length ext fixed bin (19);
      114 dcl  active_hardcore_data$sl1_uid bit (36) aligned external;
      115 
      116 dcl  access_audit_check_ep_$self entry (bit (36) aligned, bit (36) aligned, ptr) returns (bit (1));
      117 dcl  access_audit_$log_entry_ptr entry options (variable);
      118 dcl  display_access_class_$range entry ((2) bit(72) aligned) returns(char(32) aligned);
      119 dcl  vtoc_man$alloc_and_put_vtoce entry (bit (36) aligned, fixed bin (17), ptr, fixed bin (35)) returns (fixed bin);
      120 dcl  logical_volume_manager$lvtep entry (bit (36) aligned, ptr, fixed bin (35));
      121 dcl  clock_ entry returns (fixed bin (52));
      122 dcl  level$get entry () returns (fixed bin);
      123 dcl  read_allowed_ entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
      124 dcl  write_allowed_ entry (bit(72) aligned, bit(72) aligned) returns(bit(1) aligned);
      125 dcl  get_pvtx$hold_pvtx entry (bit (36) aligned, fixed bin, fixed bin (35));
      126 dcl  get_pvtx$release_pvtx entry (bit (36) aligned, fixed bin);
      127 dcl  dbm_man$set_incr entry (fixed bin, fixed bin, fixed bin (35));
      128 dcl  uid_path_util$get entry (ptr, dim (0:15) bit (36) aligned, fixed bin (35));
      129 dcl  disk_control$queue_length_given_pvtx entry entry (fixed bin, fixed bin);
      130 
      131 dcl  (addr, bit, clock, divide, fixed, high9, mod, multiply, null, ptr, rel, string, unspec) builtin;
      132 	     
      133 
      134 dcl  fm_nullifier char (256*2) aligned based (fmn_ptr);
      135 dcl  fmn_ptr ptr;
      136 dcl  uid_path (0:15) bit (36) aligned;
      137 
      138 dcl  MAXQ_FOR_PDIR_CYCLE fixed bin int static options (constant) init (7);	/* number disk queue entries for saturation*/
      139 dcl  MAX_PV_PER_LV fixed bin int static options (constant) init (32); /* maximum number of physical volumes on an LV*/
      140 dcl  MODULUS fixed bin int static options (constant) init (1024);	/* for generating random number from clock*/
      141 	     
      142 	     
      143 
      144 /* PREPARE A LOCAL COPY OF THE VTOCE USING THE BRANCH INFORMATION */
      145 
      146 	mover = "0"b;				/* entry switch */
      147 	skip_pvtx = 0;
      148 	nreq = 0;
      149 	optimizing = "1"b;
      150 join:	code = 0;
      151 	vtocep = addr (local_vtoce);
      152 	ep = branchp;
      153 	dp = ptr (ep, 0);
      154 
      155 	if entry.dirsw then msl = divide (sys_info$default_dir_max_length, 1024, 17, 0);
      156 	else msl = divide (sys_info$default_max_length, 1024, 17, 0);
      157 
      158 	unspec (local_vtoce) = "0"b;
      159 	local_vtoce.uid = entry.uid;
      160 	local_vtoce.msl = bit (fixed (msl, 9));
      161 	local_vtoce.dirsw = entry.dirsw;
      162 	local_vtoce.primary_name = addr (entry.primary_name) -> names.name;
      163 	local_vtoce.time_created = bit (clock_ (), 52);
      164 	local_vtoce.dtu = local_vtoce.time_created;
      165 	local_vtoce.dtm = local_vtoce.dtu;
      166 	local_vtoce.par_pvid = dir.pvid;
      167 	local_vtoce.par_vtocx = dir.vtocx;
      168 	local_vtoce.per_process = entry.per_process_sw;
      169 	local_vtoce.branch_rp = rel (ep);
      170 	local_vtoce.access_class = entry.access_class;
      171 	local_vtoce.master_dir = entry.master_dir;
      172 	if dp -> dir.uid = active_hardcore_data$sl1_uid	/* parent is current >sl1 */
      173 	     then local_vtoce.perm_flags.per_bootload = "1"b;
      174 	if mover then				/* if called from segment_mover */
      175 	     if tq_infop ^= null then			/* and we need to copy term quota attributes */
      176 		do i = 0 to 1;			/* do it like this for efficiency */
      177 		local_vtoce.trp (i) = tq_info.trp (i);	/* copy pertinent data */
      178 		local_vtoce.trp_time (i) = tq_info.tup (i);
      179 		local_vtoce.received (i) = tq_info.received (i);
      180 	     end;
      181 
      182 /* Fill the filemap with appropriate null addresses.  This is done using a */
      183 /* based overlay in order to generate efficient code.  We are simulating */
      184 /* do i = 0 to 255; local_vtoce.fm(i) = create_vtoce_null_addr; end; */
      185 /* which is about 2500% slower. fm (0) MUST BE DOUBLE WORD ALIGNED */
      186 
      187 	fmn_ptr = addr (local_vtoce.fm (0));		/* get ptr to base of filemap */
      188 	fm_nullifier = high9(256*2);			/* set whole string - 256 bit (18)'s to */
      189 						/* all one bits, done with single mlr */
      190 
      191 /* GET THE UID_PATH OF THE PARENT FROM THE KST AND STORE IT IN THE VTOCE - THE UID_PATH IS AN ARRAY OF 16 ENTRIES
      192*   NUMBERED FROM 0 TO 15 - ANY DIRECTORY WHICH IS IN THE PATH OF THE PARENT AND WHOSE TREE DEPTH IS i HAS ITS UID RECORDED
      193*   IN UID_PATH(i)  - ANY ELEMENT OF THE UID_PATH THAT DOES NOT HOLD A UID HAS THE VALUE ZERO. */
      194 
      195 
      196 	force_rpv = (dir.tree_depth = 0)		/* set for level 1 creations to go on rpv */
      197 	     | dir.force_rpv			/* Better be on RLV ! */
      198 	     | sys_info$initialization_state < 3;	/* make_sdw carefully placed deciduous
      199*						   segments on the RPV. If we are creating segments
      200*						   during collection 2, make sure the vtoce is allocated
      201*						   on the RPV */
      202 
      203 	call uid_path_util$get (dp, uid_path, code);	/* get uid path of parent */
      204 	if code ^= 0 then return;
      205 	local_vtoce.uid_path = uid_path;
      206 
      207 
      208 /* If per process and not constrained attempt to cycle through PV's */
      209 
      210 	try_cycle = ^mover & ^force_rpv 
      211 	     & (dir.per_process_sw | sst$cycle_pv_allocation ^= 0);
      212 
      213 /* DETERMINE IN WHICH LOGICAL VOLUME THE VTOCE IS TO BE CREATED. */
      214 
      215 	if entry.dirsw = "0"b then lvid = dir.sons_lvid;
      216 	else lvid = pvt$root_lvid;
      217 
      218 
      219 restart:	call logical_volume_manager$lvtep ((lvid), lvtep, code);
      220 	if code ^= 0 then return;
      221 	if ^(read_allowed_ (entry.access_class, lvte.access_class.min) &
      222 	     write_allowed_ (entry.access_class, lvte.access_class.max))
      223 	then do;		
      224 	     pvid = "0"b;
      225 	     vtocx = -1;
      226 	     code = error_table_$ai_restricted;
      227 	     string(event_flags) = ""b;
      228 	     if access_audit_check_ep_$self (string (event_flags), access_operations_$fs_obj_create, ep) then
      229 		call access_audit_$log_entry_ptr ("create_vtoce", level$get(), string(event_flags),
      230 		access_operations_$fs_obj_create, ep, code, null(), 0,
      231 		"entry class range outside LV (^a LVID ^w)",
      232 		display_access_class_$range (addr(lvte.access_class)->based_class_range), lvte.lvid);
      233 	     return;
      234 	end;
      235 
      236 /* ALLOCATE A VTOCE ON SOME PV WITH A FREE VTOCE.  ALGORITHM:
      237*   Satisfy segment_mover or force_rpv constraints if any.
      238*   Else if per_process then try to cycle among the PV's. (always spread heavy I/O segments)
      239*      Skip any PV whose disk queue is larger than MAXQ_FOR_PDIR_CYCLE, as this
      240*      indicates local saturation in this cycle.
      241*   Else place randomly (biased by fraction of space left on each PV).
      242*
      243*   This algorithm attempts to gracefully handle the cases where some
      244*   PV's are either empty (newly added?) or larger than others.
      245*   It used to happen that if one PV was 2x larger, it would fill
      246*   halfway before anything was placed on the others.
      247*   It used to be that if one PV was by far the emptiest, then
      248*   it would obtain all per-process segments thus creating an
      249*   I/O bottleneck. --REM */
      250 
      251 
      252           pvt_arrayp = addr (pvt$array);
      253 retry:
      254 	held = "0"b;
      255 	if try_cycle then do;			/* attempt to use cycle_pvtx */
      256 	     try_cycle = "0"b;			/* don't do this more than once per creation */
      257 
      258 	     looped, looping = "0"b;			/* not yet passed head of list */
      259 	     pvtx = lvte.cycle_pvtx;			/* See if cycle has reasonable value */
      260 	     if pvtx = 0 then looped = "1"b;		/* not good, reset and note */
      261 	     else do;				/* maybe good */
      262 		pvtep = addr (pvt_array (pvtx));	/* examine in detail */
      263 		if pvte.lvid ^= lvid then looped = "1"b; /* not good, reset and note */
      264 	     end;
      265 	     if looped then pvtx, lvte.cycle_pvtx = lvte.pvtex; /* do the reset of cycle */
      266 						/* Now pvtx and cycle_pvtx as good as can be, LV_wise */
      267 
      268 	     do while (^looping);			/* dont loop forever if cant cycle */
      269 		pvtep = addr (pvt_array (pvtx));
      270 		call disk_control$queue_length_given_pvtx (pvtx, queue_length);
      271 		if ^pvte.vacating
      272 		& ^pvte.device_inoperative		/* bad idea if down */
      273 		& pvte.n_free_vtoce > 0
      274 		& pvte.nleft > 32 then do;		/* cycle not to cause immediate segmoves */
      275 		     if dir.per_process_sw
      276 			& queue_length>MAXQ_FOR_PDIR_CYCLE /* drive looks saturated		*/
      277 			then do;			/* meter these				*/
      278 			if pvte.skip_queue_count=262143    /* dont want overflow of meter		*/
      279 			     then pvte.skip_queue_count = 0;
      280 			else pvte.skip_queue_count = pvte.skip_queue_count + 1;
      281 		     end;
      282 		     else do;
      283 			lvte.cycle_pvtx = pvte.brother_pvtx; /* leave cycle at next, may be Zero */
      284 			pvid = pvte.pvid;
      285 			go to got;
      286 		     end;
      287 		end;
      288 		pvtx = pvte.brother_pvtx;	/* chase to next */
      289 		if pvtx = 0 then do;		/* must wrap around */
      290 		     if looped then looping = "1"b; /* wrap around only once */
      291 		     else do;
      292 			looped = "1"b;		/* note this first time */
      293 			pvtx = lvte.pvtex;
      294 		     end;
      295 		end;
      296 	     end;
      297 	end;					/* end of try_cycle code */
      298 
      299 	n_pvs = 0;
      300 	sum_fract_empty = 0;
      301 	pvtx = -1;
      302 
      303 	if mover 
      304 	then if corout_pvtx = 0
      305 	     then first_pvtx = lvte.pvtex;		/* initialize */
      306 	     else do;
      307 		first_pvtx = pvt_array (corout_pvtx).brother_pvtx; /* pick up where we left off */
      308 		corout_pvtx = 0;			/* reinitialize coroutine hack if scan is restarted */
      309 	     end;
      310 	else first_pvtx = lvte.pvtex;
      311 
      312 	do i = first_pvtx repeat (pvte.brother_pvtx) while (i ^= 0);
      313 	     pvtep = addr (pvt_array (i));
      314 	     if pvte.lvid ^= lvid then go to restart;	/* LVT must have changed during scan */
      315 	     if (^force_rpv | pvte.rpv)		/* Want to use rpv? */
      316 	     then if pvte.n_free_vtoce > 0 & ^pvte.vacating /* Must be space for 1 new seg */
      317 		then if (^mover | (pvte.nleft > nreq) & (i ^= skip_pvtx)) /* If moving, need nreq, not orig PV */
      318 		     & ^pvte.device_inoperative	/* bad idea if down */
      319 		     then do;
      320 			if ^optimizing then do;	/* not trying to optimize			*/
      321 			     pvtx = i;
      322 			     goto got;
      323 			end;
      324 			else do;
      325 			     n_pvs = n_pvs + 1;
      326 			     pv_alloc (n_pvs).pvtx = i;
      327 			     pv_alloc (n_pvs).fract_empty
      328 				= divide (pvte.nleft, pvte.totrec, 35, 18);
      329 			     sum_fract_empty = sum_fract_empty
      330 				+ pv_alloc (n_pvs).fract_empty;
      331 			end;
      332 		     end;
      333 	end;
      334 
      335 /* Select a physical volume randomly biased by the fraction of space
      336*   left on each physical volume.  The random number used is a modulus
      337*   of the current clock.  This algorithm has the effect (for a reasonable
      338*   number of segment creations) of cycling among physical volumes which
      339*   are balanced in space used.  As a physical volume's space becomes
      340*   exhausted (relative to other physical volumes in the same logical
      341*   volume), it becomes progressively less favored for segment creation.				*/
      342 	
      343 	if n_pvs > 0 then do;
      344 	     random_number = divide (multiply (mod (clock (), MODULUS), sum_fract_empty, 35, 18),
      345 		MODULUS, 35, 18);			/* between 0 and sum_fract_empty		*/
      346 	     working_sum = 0;
      347 	     pv_found = "0"b;
      348 	     do pv_alloc_x = 1 repeat pv_alloc_x + 1 
      349 		while (^pv_found & pv_alloc_x < n_pvs);
      350 		working_sum = working_sum + pv_alloc (pv_alloc_x).fract_empty;
      351 		if working_sum >= random_number then do;
      352 		     pv_found = "1"b;
      353 		     pvtx = pv_alloc (pv_alloc_x).pvtx;
      354 		end;
      355 	     end;
      356 	     if ^pv_found then pvtx = pv_alloc (n_pvs).pvtx;
      357 	end;
      358 	     
      359 	
      360 
      361 	if pvtx = -1 then
      362 	     do ;
      363 no_room:	     vtocx = -1;
      364 	     pvid = "0"b;
      365 	     code = error_table_$log_vol_full;
      366 	     return;
      367 	end;
      368 
      369 got:	pvtep = addr (pvt_array (pvtx));
      370 	if pvte.lvid ^= lvid then go to retry;
      371 	pvid = pvte.pvid;
      372 	
      373 
      374 	call get_pvtx$hold_pvtx ((pvid), pvtx, code);
      375 	if code ^= 0 then goto not_there;
      376 	held = "1"b;
      377 
      378 	vtocx = vtoc_man$alloc_and_put_vtoce ((pvid), pvtx, addr (local_vtoce), code);
      379 	if code ^= 0 then do;
      380 not_there:
      381 	     vtocx = -1;
      382 	     if held then call get_pvtx$release_pvtx ((pvid), pvtx);
      383 	     pvid = "0"b;
      384 	     return;
      385 	end;
      386 	if vtocx = -1 then do;			/* lost in window. There must be a better volume,
      387*						   or LV is full, and we will find this out. */
      388 	     if held then call get_pvtx$release_pvtx ((pvid), pvtx);
      389 	     goto retry;
      390 	end;
      391 	call dbm_man$set_incr (pvtx, vtocx, code);
      392 
      393 	call get_pvtx$release_pvtx ((pvid), pvtx);
      394 
      395 	if mover then corout_pvtx = pvtx;		/* Start there next */
      396 	return;
      397 
      398 /*  */
      399 
      400 /* create_vtoce$createv_for_segmove
      401*
      402*   This entry is used to try to find a home for a segment which
      403*   cannot allocate for a pendant page fault. segment_mover calls this
      404*   entry maintaining the variable corout_pvtx for us. This enables us to
      405*   scan the PVT. a_nreq is a minimum record requirement on a potential
      406*   trial volume */
      407 
      408 
      409 createv_for_segmove: entry (branchp, pvid, vtocx, code,	/* as regular */
      410 	     corout_pvtx,				/* control state/pvtx answer */
      411 	     a_skip_pvtx,				/* original pvtx, do not use */
      412 	     a_nreq,				/* number or records needed */
      413 	     tq_infop,				/* ptr to tq_info structure (null if no term quota) */
      414 	     a_optimize);				/* ON => optimize allocation of PV */
      415 
      416 
      417 	skip_pvtx = a_skip_pvtx;
      418 	nreq = a_nreq;				/* copy args */
      419 	mover = "1"b;				/* entry switch */
      420 	optimizing = a_optimize;
      421 	go to join;
      422  /* BEGIN INCLUDE FILE ... backup_static_variables.incl.pl1 ... March 1976 */
  1     2 
  1     3 
  1     4 dcl  incr fixed bin init (1) internal static options (constant); /* incremental dump mode */
  1     5 dcl  cons fixed bin init (2) internal static options (constant); /* consolidated dump mode */
  1     6 dcl  comp fixed bin init (3) internal static options (constant); /* complete dump mode */
  1     7 dcl  backup_version_1 fixed bin init (1) static internal options (constant); /* backup_version_1 of input/output structures */
  1     8 
  1     9 
  1    10 
  1    11 /* END INCLUDE FILE ... backup_static_variables.incl.pl1 */
      422 
      423  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      423 
      424  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      424 
      425  /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  4     2 
  4     3 /* Template for names of branches or links. Length = 14 words. */
  4     4 
  4     5 dcl np ptr;
  4     6 
  4     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  4     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  4     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  4    10 
  4    11     2 type bit (18) unaligned,			/* type = dir name */
  4    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  4    13 
  4    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  4    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  4    16 
  4    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  4    18     2 pad3 bit (18) unal,
  4    19 
  4    20     2 name char(32) aligned,
  4    21 
  4    22     2 checksum bit (36),				/* checksum from entry_rp */
  4    23 
  4    24     2 owner bit (36);				/* uid of entry */
  4    25 
  4    26 
  4    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      425 
      426  /* BEGIN INCLUDE FILE lvt.incl.pl1 -- Written Jan. 1976 by R. Bratt       */
  5     2 /*
  5     3*   This include file defines the format of the hardcore L_ogical V_olume T_able (LVT).
  5     4**/
  5     5 
  5     6 dcl  lvt$ ext;
  5     7 dcl  lvtp ptr;
  5     8 dcl  lvtep ptr;
  5     9 
  5    10 dcl 1 lvt aligned based (lvtp),
  5    11     2 max_lvtex fixed bin (17),			/* maximum number of LVs describable */
  5    12     2 high_water_lvtex fixed bin (17),			/* highest LVT index assigned */
  5    13     2 free_lvtep ptr,				/* pointer to  first free lvte  */
  5    14     2 pad1 (4) bit (36),
  5    15     2 ht (0:63) ptr unal,				/* lvid hash table */
  5    16     2 lvtes (1:1 refer (lvt.max_lvtex)) like lvte;	/* LVT entries */
  5    17 
  5    18 dcl 1 lvte aligned based (lvtep),			/* logical volume table entry */
  5    19     2 lvtep ptr unaligned,				/* lvid hash thread */
  5    20     2 pvtex fixed bin (17),				/* thread of mounted PVs */
  5    21     2 lvid bit (36),				/* logical volume id */
  5    22     2 access_class aligned,				/* access isolation mechanism stuff */
  5    23       3 min bit (72),				/* minimum access class allowed on LV */
  5    24       3 max bit (72),				/* maximum access class allowed on volume */
  5    25     2 flags unaligned,				/* flags */
  5    26       3 public bit (1),				/* => anyone can connect to this LV */
  5    27       3 read_only bit (1),				/* => no writes on this LV */
  5    28       3 pad bit (16),
  5    29       3 cycle_pvtx fixed bin (17);			/* pvtx for next per_process seg */
  5    30 
  5    31 /* END INCLUDE FILE lvt.incl.pl1                                                    */
      426 
      427  /* BEGIN INCLUDE FILE  null_addresses.incl.pl1 */
  6     2 /* Added segmove values, Benson Margulies, 84-01 */
  6     3 
  6     4 dcl (pc_move_page_table_1_null_addr init	("3770070"b3),
  6     5      pc_move_page_table_2_null_addr init	("3770100"b3),
  6     6      get_aste_null_addr init			("3770110"b3),
  6     7      make_sdw_null_addr init			("3770120"b3),
  6     8      put_aste_null_addr init			("3770130"b3),
  6     9      page_bad_pd_null_addr init		("3770150"b3),
  6    10      list_deposit_null_addr init		("3770160"b3),
  6    11      get_file_map_null_addr init		("3770170"b3),
  6    12      fill_page_table_null_addr init		("3770200"b3),
  6    13      init_sst_null_addr init			("3770210"b3),
  6    14      get_file_map_vt_null_addr init		("3770220"b3),
  6    15      unprotected_null_addr init		("3770230"b3),
  6    16      page_bad_null_addr init			("3770240"b3),
  6    17      page_problem_null_addr init		("3770250"b3),
  6    18      page_parity_null_addr init		("3770260"b3),
  6    19      page_devparity_null_addr init		("3770270"b3),
  6    20      segmove_old_addr_null_addr init              ("3770300"b3),
  6    21      segmove_new_addr_null_addr init		("3770310"b3),
  6    22      get_file_map_dumper_non_null_addr init	("3777720"b3),
  6    23      append_null_addr	         init       ("3777770"b3)) bit (22) aligned static options (constant);
  6    24 dcl create_vtoce_four_null_addrs fixed bin (71) int static init (-1);/* 777777 777777 777777 777777 */
  6    25 
  6    26 dcl (create_vtoce_null_addr init		("777777"b3),
  6    27      update_vtoce_null_addr init		("777776"b3),
  6    28      truncate_vtoce_fill_null_addr init		("777775"b3),
  6    29      truncate_vtoce_null_addr init		("777002"b3),
  6    30      pv_salv_null_addr init			("777004"b3),
  6    31      pv_scav_null_addr init			("777006"b3),
  6    32      volume_reloader_null_addr init		("777774"b3),
  6    33      volume_retriever_null_addr init		("777773"b3),
  6    34      salv_truncate_null_addr init		("777005"b3)) bit (18) aligned static options (constant);
  6    35 
  6    36 /* END INCLUDE FILE null_addresses.incl.pl1 */
      427 
      428  /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  7     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7     8*     Add the support for subvolumes
  7     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  7    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  7    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  7    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  7    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  7    14*     Added inconsistent_dbm bit for determining the status of volume
  7    15*     dumper bit maps.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18      dcl	   pvt$array	      aligned external;
  7    19      dcl	   pvt$max_n_entries      fixed bin external;
  7    20 
  7    21      dcl	   pvt_arrayp	      ptr;
  7    22      dcl	   pvtep		      ptr;
  7    23 
  7    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  7    25 
  7    26      dcl	   1 pvte		      based (pvtep) aligned,
  7    27 
  7    28 	     2 pvid	      bit (36),		/* physical volume ID */
  7    29 
  7    30 	     2 lvid	      bit (36),		/* logical volume ID */
  7    31 
  7    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  7    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  7    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  7    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  7    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  7    37 	     2 pad3	      bit (2) unaligned,
  7    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  7    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  7    40 
  7    41 
  7    42 
  7    43 	     2 devname	      char (4),		/* device name */
  7    44 
  7    45 	     (2 device_type	      fixed bin (8),	/* device type */
  7    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  7    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  7    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  7    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  7    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  7    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  7    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  7    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  7    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  7    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  7    56 	     2 scav_check_address
  7    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  7    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  7    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  7    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  7    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  7    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  7    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  7    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  7    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  7    66 
  7    67 
  7    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  7    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  7    70 
  7    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  7    72 
  7    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  7    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  7    75 
  7    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  7    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  7    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  7    79 	     2 records_per_cyl    fixed bin,
  7    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  7    81 	     2 sv_name            char (2) aligned,
  7    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  7    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  7    84 
  7    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  7    86 	     2 pad2	      bit (18) unaligned,
  7    87 
  7    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  7    89 
  7    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  7    91 
  7    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  7    93 
  7    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  7    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  7    96 
  7    97 
  7    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  7    99 
  7   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  7   101 
  7   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  7   103 
  7   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  7   105 
  7   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  7   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  7   108 
  7   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  7   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  7   111 
  7   112 
  7   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  7   114 	   VOLMAP_ASYNC_READ      init (1),
  7   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  7   116 
  7   117 
  7   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      428 
      429  /* BEGIN INCLUDE FILE ... tq_info.incl.pl1 */
  8     2 /* created by J. A. Bush 10/03/79 */
  8     3 
  8     4 dcl  tq_infop ptr;					/* ptr to structure below */
  8     5 
  8     6 dcl 1 tq_info based (tq_infop) aligned,			/* structure defining terminal quota attributes */
  8     7     2 trp (0:1) fixed bin (71),			/* time record product (0 is seg quota) */
  8     8     2 tup (0:1) bit (36),				/* clock time of update */
  8     9     2 received (0:1) fixed bin (35),			/* quota moved down */
  8    10     2 pad (0:1) fixed bin;				/* inferier quota count */
  8    11 
  8    12 /* END INCLUDE FILE ... tq_info.incl.pl1 */
      429 
      430  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  9     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  9     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  9     4 
  9     5 dcl  vtocep ptr;
  9     6 
  9     7 dcl 1 vtoce based (vtocep) aligned,
  9     8 
  9     9 
  9    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  9    11 
  9    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  9    13 
  9    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  9    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  9    16     2 records bit (9),				/* number of records used by the seg in second storage */
  9    17     2 pad2 bit (9),
  9    18 
  9    19     2 dtu bit (36),					/* date and time segment was last used */
  9    20 
  9    21     2 dtm bit (36),					/* date and time segment was last modified */
  9    22 
  9    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  9    24     2 deciduous bit (1),				/* true if hc_sdw */
  9    25     2 nid bit (1),					/* no incremental dump switch */
  9    26     2 dnzp bit (1),					/* Dont null zero pages */
  9    27     2 gtpd bit (1),					/* Global transparent paging device */
  9    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  9    29     2 damaged bit (1),				/* TRUE if contents damaged */
  9    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  9    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  9    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  9    33     2 pad3 bit (8),
  9    34     2 dirsw bit (1),				/* directory switch */
  9    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  9    36     2 pad4 bit (16)) unaligned,			/* not used */
  9    37 
  9    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  9    39 
  9    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  9    41 
  9    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  9    43 
  9    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  9    45 
  9    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  9    47 
  9    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  9    49 
  9    50 
  9    51 
  9    52 
  9    53 
  9    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  9    55 
  9    56     2 pad6 (10) bit (36),				/* not used */
  9    57 
  9    58     2 ncd bit (1),					/* no complete dump switch */
  9    59     2 pad7 bit (17),
  9    60     2 pad8 bit (18),
  9    61 
  9    62     2 dtd bit (36),					/* date-time-dumped */
  9    63 
  9    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  9    65 
  9    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  9    67 
  9    68 
  9    69 
  9    70 
  9    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  9    72 
  9    73     2 primary_name char (32),				/* primary name of the segment */
  9    74 
  9    75     2 time_created bit (36),				/* time the segment was created */
  9    76 
  9    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  9    78 
  9    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  9    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  9    81 
  9    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  9    83 
  9    84     2 access_class bit (72),				/* access class in branch */
  9    85     2 perm_flags aligned,
  9    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  9    87       3 pad9 bit (35) unal,
  9    88     2 owner bit (36);				/* pvid of this volume */
  9    89 
  9    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  9    91 
  9    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  9    93     2 pad1 bit (7*36),
  9    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  9    95     2 pad2 bit (184*36);
  9    96 
  9    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      430 
      431  /* begin include file - access_audit_eventflags.incl.pl1 */
 10     2 /* NOTE: This include file has an ALM counterpart made with cif.
 10     3*Keep it up to date. */
 10     4 
 10     5 dcl 1 audit_event_flags	based aligned,
 10     6       2 special_op	bit (1) unal,  /* special sys operation */
 10     7       2 grant	bit (1) unal,  /* operation was successful */
 10     8       2 admin_op	bit (1) unal,  /* administrative operation */
 10     9       2 priv_op	bit (1) unal,  /* privileged operation */
 10    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
 10    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
 10    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
 10    13       2 pad	bit (29) unal;
 10    14 
 10    15 /* end include file - access_audit_eventflags.incl.pl1 */
      431 
      432 
      433 
      434 /* BEGIN MESSAGE DOCUMENTATION
      435*
      436*   Message:
      437*   AUDIT (create_vtoce): DENIED creation of file system object ADDED_INFO entry class range outside LV (CLASS_RANGE lvid LVID)
      438*
      439*   S:	$access_audit
      440*
      441*   T:	$run
      442*
      443*   M:	The specified user attempted to create a segment whose access class
      444*	is outside the range accepted by the logical volume.
      445*
      446*   A:	$inform_ssa
      447*
      448*   END MESSAGE DOCUMENTATION */
      449 
      450      end create_vtoce;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0851.5  create_vtoce.pl1                  >spec>install>1115>create_vtoce.pl1
422          1    09/05/80  1136.5  backup_static_variables.incl.pl1  >ldd>include>backup_static_variables.incl.pl1
423          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
424          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
425          4    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
426          5    11/30/76  1555.4  lvt.incl.pl1                      >ldd>include>lvt.incl.pl1
427          6    07/11/84  0937.3  null_addresses.incl.pl1           >ldd>include>null_addresses.incl.pl1
428          7    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
429          8    05/27/82  1525.9  tq_info.incl.pl1                  >ldd>include>tq_info.incl.pl1
430          9    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
431         10    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
MAXQ_FOR_PDIR_CYCLE                    constant        fixed bin(17,0)          initial dcl 138 ref 275
MAX_PV_PER_LV                          constant        fixed bin(17,0)          initial dcl 139 ref 97
MODULUS                         001441 constant        fixed bin(17,0)          initial dcl 140 ref 344 344
a_nreq                                 parameter       fixed bin(17,0)          dcl 81 ref 409 418
a_optimize                             parameter       bit(1)                   dcl 82 ref 409 420
a_skip_pvtx                            parameter       fixed bin(17,0)          dcl 79 ref 409 417
access_audit_$log_entry_ptr     000034 constant        entry                    external dcl 117 ref 228
access_audit_check_ep_$self     000032 constant        entry                    external dcl 116 ref 228
access_class              3            based           structure                level 2 in structure "lvte" dcl 5-18 in procedure
                                                                                  "create_vtoce" set ref 228 228
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "create_vtoce" set ref 170 221* 221*
access_class            274            based           bit(72)                  level 2 in structure "local_vtoce" dcl 102
                                                                                  in procedure "create_vtoce" set ref 170*
access_operations_$fs_obj_create
                                000010 external static bit(36)                  dcl 105 set ref 228* 228*
active_hardcore_data$sl1_uid    000030 external static bit(36)                  dcl 114 ref 172
addr                                                   builtin function         dcl 131 ref 151 151 158 159 160 161 162 162 163 164
                                                                                  164 165 165 166 167 168 169 170 171 172 177 178
                                                                                  179 187 187 205 228 228 252 262 269 313 369 378
                                                                                  378 378 378
audit_event_flags                      based           structure                level 1 dcl 10-5
based_class_range                      based           bit(72)                  array dcl 103 set ref 228* 228*
bit                                                    builtin function         dcl 131 ref 160 163
branch_rp               272(18)        based           bit(18)                  level 2 packed packed unaligned dcl 102 set ref 169*
branchp                                parameter       pointer                  dcl 71 ref 68 152 409
brother_pvtx              2(09)        based           fixed bin(8,0)           array level 2 in structure "pvt_array" packed packed
                                                                                  unaligned dcl 7-24 in procedure "create_vtoce" set
                                                                                  ref 307
brother_pvtx              2(09)        based           fixed bin(8,0)           level 2 in structure "pvte" packed packed unaligned
                                                                                  dcl 7-26 in procedure "create_vtoce" ref 283 288
                                                                                  333
clock                                                  builtin function         dcl 131 ref 344
clock_                          000044 constant        entry                    external dcl 121 ref 163
code                                   parameter       fixed bin(35,0)          dcl 74 set ref 68 150* 203* 204 219* 220 226* 228*
                                                                                  365* 374* 375 378* 379 391* 409
corout_pvtx                            parameter       fixed bin(17,0)          dcl 78 set ref 303 307 308* 395* 409
cycle_pvtx                7(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 5-18 set ref 259
                                                                                  265* 283*
dbm_man$set_incr                000060 constant        entry                    external dcl 127 ref 391
device_inoperative        4(25)        based           bit(1)                   level 2 packed packed unaligned dcl 7-26 ref 271 315
dir                                    based           structure                level 1 dcl 3-11
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "create_vtoce" ref 155 161
                                                                                  215
dirsw                     5(18)        based           bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 102 in procedure "create_vtoce" set
                                                                                  ref 161*
disk_control$queue_length_given_pvtx
                                000064 constant        entry                    external dcl 129 ref 270
display_access_class_$range     000036 constant        entry                    external dcl 118 ref 228 228
divide                                                 builtin function         dcl 131 ref 155 156 327 344
dp                              000452 automatic       pointer                  dcl 3-9 set ref 153* 166 167 172 196 196 203* 210
                                                                                  215 275
dtm                       4            based           bit(36)                  level 2 packed packed unaligned dcl 102 set ref 165*
dtu                       3            based           bit(36)                  level 2 packed packed unaligned dcl 102 set ref 164*
                                                                                  165
entry                                  based           structure                level 1 dcl 2-8
ep                              000450 automatic       pointer                  dcl 2-6 set ref 152* 153 155 159 161 162 168 169 170
                                                                                  171 215 221 221 228* 228*
error_table_$ai_restricted      000022 external static fixed bin(35,0)          dcl 111 ref 226
error_table_$log_vol_full       000020 external static fixed bin(35,0)          dcl 109 ref 365
event_flags                     000113 automatic       structure                level 1 dcl 88 set ref 227* 228 228 228 228
first_pvtx                      000104 automatic       fixed bin(17,0)          dcl 85 set ref 303* 307* 310* 312
fixed                                                  builtin function         dcl 131 ref 160
flags                     7            based           structure                level 2 packed packed unaligned dcl 5-18
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 102 set
                                                                                  ref 187
fm_nullifier                           based           char(512)                dcl 134 set ref 188*
fmn_ptr                         000426 automatic       pointer                  dcl 135 set ref 187* 188
force_rpv                       000114 automatic       bit(1)                   packed unaligned dcl 89 in procedure "create_vtoce"
                                                                                  set ref 196* 210 315
force_rpv                24(20)        based           bit(1)                   level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 3-11 in procedure "create_vtoce" ref 196
fract_empty               1     000126 automatic       fixed bin(35,18)         array level 2 dcl 97 set ref 327* 329 350
get_pvtx$hold_pvtx              000054 constant        entry                    external dcl 125 ref 374
get_pvtx$release_pvtx           000056 constant        entry                    external dcl 126 ref 382 388 393
held                            000112 automatic       bit(1)                   packed unaligned dcl 87 set ref 253* 376* 382 388
high9                                                  builtin function         dcl 131 ref 188
i                               000101 automatic       fixed bin(17,0)          dcl 84 set ref 174* 177 177 178 178 179 179* 312*
                                                                                  312* 313 315 321 326*
level$get                       000046 constant        entry                    external dcl 122 ref 228 228
local_vtoce                            based           structure                level 1 dcl 102 set ref 151 158* 378 378
logical_volume_manager$lvtep    000042 constant        entry                    external dcl 120 ref 219
looped                          000107 automatic       bit(1)                   packed unaligned dcl 87 set ref 258* 260* 263* 265
                                                                                  290 292*
looping                         000110 automatic       bit(1)                   packed unaligned dcl 87 set ref 258* 268 290*
lvid                            000116 automatic       bit(36)                  packed unaligned dcl 91 in procedure "create_vtoce"
                                                                                  set ref 215* 216* 219 263 314 370
lvid                      2            based           bit(36)                  level 2 in structure "lvte" dcl 5-18 in procedure
                                                                                  "create_vtoce" set ref 228*
lvid                      1            based           bit(36)                  level 2 in structure "pvte" dcl 7-26 in procedure
                                                                                  "create_vtoce" ref 263 314 370
lvte                                   based           structure                level 1 dcl 5-18
lvtep                           000454 automatic       pointer                  dcl 5-8 set ref 219* 221 221 228 228 228 259 265 265
                                                                                  283 293 303 310
master_dir               32(09)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "create_vtoce" ref 171
master_dir                5(19)        based           bit(1)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 102 in procedure "create_vtoce" set
                                                                                  ref 171*
max                       5            based           bit(72)                  level 3 dcl 5-18 set ref 221*
min                       3            based           bit(72)                  level 3 dcl 5-18 set ref 221*
mod                                                    builtin function         dcl 131 ref 344
mover                           000106 automatic       bit(1)                   packed unaligned dcl 87 set ref 146* 174 210 303 315
                                                                                  395 419*
msl                             000103 automatic       fixed bin(17,0)          dcl 84 in procedure "create_vtoce" set ref 155* 156*
                                                                                  160
msl                       2            based           bit(9)                   level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 102 in procedure "create_vtoce" set
                                                                                  ref 160*
multiply                                               builtin function         dcl 131 ref 344
n_free_vtoce              5            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 ref 271 315
n_pvs                           000123 automatic       fixed bin(17,0)          dcl 94 set ref 299* 325* 325 326 327 329 343 348 356
name                      4            based           char(32)                 level 2 dcl 4-7 ref 162
names                                  based           structure                level 1 dcl 4-7
nleft                     7            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 ref 271 315
                                                                                  327
nreq                            000105 automatic       fixed bin(17,0)          dcl 86 set ref 148* 315 418*
null                                                   builtin function         dcl 131 ref 174 228 228
optimizing                      000115 automatic       bit(1)                   packed unaligned dcl 90 set ref 149* 320 420*
par_pvid                271            based           bit(36)                  level 2 packed packed unaligned dcl 102 set ref 166*
par_vtocx               272            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 102 set ref 167*
per_bootload            276            based           bit(1)                   level 3 packed packed unaligned dcl 102 set ref 172*
per_process               5(05)        based           bit(1)                   level 2 packed packed unaligned dcl 102 set ref 168*
per_process_sw           32(02)        based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "create_vtoce" ref 168
per_process_sw           24(18)        based           bit(1)                   level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 3-11 in procedure "create_vtoce" ref 210 275
perm_flags              276            based           structure                level 2 dcl 102
primary_name             10            based           bit(504)                 level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 2-8 in procedure "create_vtoce" set ref 162
primary_name            260            based           char(32)                 level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 102 in procedure "create_vtoce" set
                                                                                  ref 162*
ptr                                                    builtin function         dcl 131 ref 153
pv_alloc                        000126 automatic       structure                array level 1 dcl 97
pv_alloc_x                      000125 automatic       fixed bin(17,0)          dcl 96 set ref 348* 348* 350 353* 355
pv_found                        000124 automatic       bit(1)                   packed unaligned dcl 95 set ref 347* 348 352* 356
pvid                                   parameter       bit(36)                  packed unaligned dcl 72 in procedure "create_vtoce"
                                                                                  set ref 68 224* 284* 364* 371* 374 378 382 383*
                                                                                  388 393 409
pvid                                   based           bit(36)                  level 2 in structure "pvte" dcl 7-26 in procedure
                                                                                  "create_vtoce" ref 284 371
pvid                     11            based           bit(36)                  level 2 in structure "dir" dcl 3-11 in procedure
                                                                                  "create_vtoce" ref 166
pvt$array                       000066 external static fixed bin(17,0)          dcl 7-18 set ref 252
pvt$root_lvid                   000016 external static bit(36)                  dcl 108 ref 216
pvt_array                              based           structure                array level 1 dcl 7-24 set ref 262 269 313 369
pvt_arrayp                      000456 automatic       pointer                  dcl 7-21 set ref 252* 262 269 307 313 369
pvte                                   based           structure                level 1 dcl 7-26
pvtep                           000460 automatic       pointer                  dcl 7-22 set ref 262* 263 269* 271 271 271 271 278
                                                                                  278 280 280 283 284 288 313* 314 315 315 315 315
                                                                                  315 327 327 333 369* 370 371
pvtex                     1            based           fixed bin(17,0)          level 2 dcl 5-18 ref 265 293 303 310
pvtx                            000102 automatic       fixed bin(17,0)          dcl 84 in procedure "create_vtoce" set ref 259* 260
                                                                                  262 265* 269 270* 288* 289 293* 301* 321* 353*
                                                                                  356* 361 369 374* 378* 382* 388* 391* 393* 395
pvtx                            000126 automatic       fixed bin(17,0)          array level 2 in structure "pv_alloc" dcl 97
                                                                                  in procedure "create_vtoce" set ref 326* 353 356
queue_length                    000117 automatic       fixed bin(17,0)          dcl 92 set ref 270* 275
random_number                   000121 automatic       fixed bin(35,18)         dcl 93 set ref 344* 351
read_allowed_                   000050 constant        entry                    external dcl 123 ref 221
received                 11            based           fixed bin(18,0)          array level 2 in structure "local_vtoce" packed
                                                                                  packed unsigned unaligned dcl 102 in procedure
                                                                                  "create_vtoce" set ref 179*
received                  6            based           fixed bin(35,0)          array level 2 in structure "tq_info" dcl 8-6
                                                                                  in procedure "create_vtoce" ref 179
rel                                                    builtin function         dcl 131 ref 169
rpv                       4(26)        based           bit(1)                   level 2 packed packed unaligned dcl 7-26 ref 315
skip_pvtx                       000100 automatic       fixed bin(17,0)          dcl 80 set ref 147* 315 417*
skip_queue_count          2(18)        based           fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 7-26
                                                                                  set ref 278 278* 280* 280
sons_lvid                12            based           bit(36)                  level 2 dcl 3-11 ref 215
sst$cycle_pv_allocation         000014 external static fixed bin(35,0)          dcl 107 ref 210
string                                                 builtin function         dcl 131 set ref 227* 228 228 228 228
sum_fract_empty                 000122 automatic       fixed bin(35,18)         dcl 93 set ref 300* 329* 329 344
sys_info$default_dir_max_length 000026 external static fixed bin(19,0)          dcl 113 ref 155
sys_info$default_max_length     000024 external static fixed bin(19,0)          dcl 112 ref 156
sys_info$initialization_state   000012 external static fixed bin(17,0)          dcl 106 ref 196
time_created            270            based           bit(36)                  level 2 packed packed unaligned dcl 102 set ref 163*
                                                                                  164
totrec                    7(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-26 ref 327
tq_info                                based           structure                level 1 dcl 8-6
tq_infop                               parameter       pointer                  dcl 8-4 ref 174 177 178 179 409
tree_depth               57            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-11 ref 196
trp                      12            based           fixed bin(71,0)          array level 2 in structure "local_vtoce" packed
                                                                                  packed unaligned dcl 102 in procedure
                                                                                  "create_vtoce" set ref 177*
trp                                    based           fixed bin(71,0)          array level 2 in structure "tq_info" dcl 8-6
                                                                                  in procedure "create_vtoce" ref 177
trp_time                 16            based           bit(36)                  array level 2 packed packed unaligned dcl 102 set
                                                                                  ref 178*
try_cycle                       000111 automatic       bit(1)                   packed unaligned dcl 87 set ref 210* 255 256*
tup                       4            based           bit(36)                  array level 2 dcl 8-6 ref 178
uid                      10            based           bit(36)                  level 2 in structure "dir" dcl 3-11 in procedure
                                                                                  "create_vtoce" ref 172
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 2-8 in procedure
                                                                                  "create_vtoce" ref 159
uid                       1            based           bit(36)                  level 2 in structure "local_vtoce" packed packed
                                                                                  unaligned dcl 102 in procedure "create_vtoce" set
                                                                                  ref 159*
uid_path                        000430 automatic       bit(36)                  array dcl 136 in procedure "create_vtoce" set ref
                                                                                  203* 205
uid_path                240            based           bit(36)                  array level 2 in structure "local_vtoce" packed
                                                                                  packed unaligned dcl 102 in procedure
                                                                                  "create_vtoce" set ref 205*
uid_path_util$get               000062 constant        entry                    external dcl 128 ref 203
unspec                                                 builtin function         dcl 131 set ref 158*
vacating                  4(31)        based           bit(1)                   level 2 packed packed unaligned dcl 7-26 ref 271 315
vtoc_buffer                     000126 automatic       fixed bin(71,0)          array dcl 101 set ref 151 158 159 160 161 162 163
                                                                                  164 164 165 165 166 167 168 169 170 171 172 177
                                                                                  178 179 187 205 378 378
vtoc_man$alloc_and_put_vtoce    000040 constant        entry                    external dcl 119 ref 378
vtoce                                  based           structure                level 1 dcl 9-7
vtocep                          000462 automatic       pointer                  dcl 9-5 set ref 151*
vtocx                    15            based           fixed bin(17,0)          level 2 in structure "dir" packed packed unaligned
                                                                                  dcl 3-11 in procedure "create_vtoce" ref 167
vtocx                                  parameter       fixed bin(17,0)          dcl 73 in procedure "create_vtoce" set ref 68 225*
                                                                                  363* 378* 380* 386 391* 409
working_sum                     000120 automatic       fixed bin(35,18)         dcl 93 set ref 346* 350* 350 351
write_allowed_                  000052 constant        entry                    external dcl 124 ref 221

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 7-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 7-113
append_null_addr                       internal static bit(22)                  initial dcl 6-4
backup_version_1                       internal static fixed bin(17,0)          initial dcl 1-7
comp                                   internal static fixed bin(17,0)          initial dcl 1-6
cons                                   internal static fixed bin(17,0)          initial dcl 1-5
create_vtoce_four_null_addrs           internal static fixed bin(71,0)          initial dcl 6-24
create_vtoce_null_addr                 internal static bit(18)                  initial dcl 6-26
error_table_$pvid_not_found            external static fixed bin(35,0)          dcl 110
fill_page_table_null_addr              internal static bit(22)                  initial dcl 6-4
get_aste_null_addr                     internal static bit(22)                  initial dcl 6-4
get_file_map_dumper_non_null_addr      internal static bit(22)                  initial dcl 6-4
get_file_map_null_addr                 internal static bit(22)                  initial dcl 6-4
get_file_map_vt_null_addr              internal static bit(22)                  initial dcl 6-4
incr                                   internal static fixed bin(17,0)          initial dcl 1-4
init_sst_null_addr                     internal static bit(22)                  initial dcl 6-4
list_deposit_null_addr                 internal static bit(22)                  initial dcl 6-4
lvt                                    based           structure                level 1 dcl 5-10
lvt$                                   external static fixed bin(17,0)          dcl 5-6
lvtp                                   automatic       pointer                  dcl 5-7
make_sdw_null_addr                     internal static bit(22)                  initial dcl 6-4
np                                     automatic       pointer                  dcl 4-5
page_bad_null_addr                     internal static bit(22)                  initial dcl 6-4
page_bad_pd_null_addr                  internal static bit(22)                  initial dcl 6-4
page_devparity_null_addr               internal static bit(22)                  initial dcl 6-4
page_parity_null_addr                  internal static bit(22)                  initial dcl 6-4
page_problem_null_addr                 internal static bit(22)                  initial dcl 6-4
pc_move_page_table_1_null_addr         internal static bit(22)                  initial dcl 6-4
pc_move_page_table_2_null_addr         internal static bit(22)                  initial dcl 6-4
put_aste_null_addr                     internal static bit(22)                  initial dcl 6-4
pv_salv_null_addr                      internal static bit(18)                  initial dcl 6-26
pv_scav_null_addr                      internal static bit(18)                  initial dcl 6-26
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 7-19
salv_truncate_null_addr                internal static bit(18)                  initial dcl 6-26
seg_vtoce                              based           structure                level 1 dcl 9-92
segmove_new_addr_null_addr             internal static bit(22)                  initial dcl 6-4
segmove_old_addr_null_addr             internal static bit(22)                  initial dcl 6-4
truncate_vtoce_fill_null_addr          internal static bit(18)                  initial dcl 6-26
truncate_vtoce_null_addr               internal static bit(18)                  initial dcl 6-26
unprotected_null_addr                  internal static bit(22)                  initial dcl 6-4
update_vtoce_null_addr                 internal static bit(18)                  initial dcl 6-26
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84
volume_reloader_null_addr              internal static bit(18)                  initial dcl 6-26
volume_retriever_null_addr             internal static bit(18)                  initial dcl 6-26
vtoce_parts                            based           bit(2304)                array dcl 9-90

NAMES DECLARED BY EXPLICIT CONTEXT.
create_vtoce                    000051 constant        entry                    external dcl 68
createv_for_segmove             001420 constant        entry                    external dcl 409
got                             001210 constant        label                    dcl 369 ref 285 322
join                            000064 constant        label                    dcl 150 ref 421
no_room                         001175 constant        label                    dcl 363
not_there                       001300 constant        label                    dcl 380 ref 375
restart                         000356 constant        label                    dcl 219 ref 314
retry                           000615 constant        label                    dcl 253 ref 370 389

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2030        2120    1443        2040
Length      2534    1443        70         400     364           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_vtoce                        398 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_vtoce             000100 skip_pvtx                   create_vtoce
                         000101 i                           create_vtoce
                         000102 pvtx                        create_vtoce
                         000103 msl                         create_vtoce
                         000104 first_pvtx                  create_vtoce
                         000105 nreq                        create_vtoce
                         000106 mover                       create_vtoce
                         000107 looped                      create_vtoce
                         000110 looping                     create_vtoce
                         000111 try_cycle                   create_vtoce
                         000112 held                        create_vtoce
                         000113 event_flags                 create_vtoce
                         000114 force_rpv                   create_vtoce
                         000115 optimizing                  create_vtoce
                         000116 lvid                        create_vtoce
                         000117 queue_length                create_vtoce
                         000120 working_sum                 create_vtoce
                         000121 random_number               create_vtoce
                         000122 sum_fract_empty             create_vtoce
                         000123 n_pvs                       create_vtoce
                         000124 pv_found                    create_vtoce
                         000125 pv_alloc_x                  create_vtoce
                         000126 vtoc_buffer                 create_vtoce
                         000126 pv_alloc                    create_vtoce
                         000426 fmn_ptr                     create_vtoce
                         000430 uid_path                    create_vtoce
                         000450 ep                          create_vtoce
                         000452 dp                          create_vtoce
                         000454 lvtep                       create_vtoce
                         000456 pvt_arrayp                  create_vtoce
                         000460 pvtep                       create_vtoce
                         000462 vtocep                      create_vtoce

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return_mac
alloc_auto_adj      mdfx3               ext_entry           divide_fx1          clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_$log_entry_ptr   access_audit_check_ep_$self   clock_                        dbm_man$set_incr
disk_control$queue_length_given_pvtx                        display_access_class_$range   get_pvtx$hold_pvtx
get_pvtx$release_pvtx         level$get                     logical_volume_manager$lvtep  read_allowed_
uid_path_util$get             vtoc_man$alloc_and_put_vtoce  write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$fs_obj_create                            active_hardcore_data$sl1_uid  error_table_$ai_restricted
error_table_$log_vol_full     pvt$array                     pvt$root_lvid                 sst$cycle_pv_allocation
sys_info$default_dir_max_length                             sys_info$default_max_length   sys_info$initialization_state


CONSTANTS
000000  aa     524000000051

000001  aa     404000000005

000002  aa     514000000044

000003  aa     524000000014

001442  aa     777777777777

001441  aa     000000002000

000004  aa     410000000064

000005  aa     524000000040

000006  aa     516000000001

000007  aa     514000000001

000010  aa     404000000043

000011  aa     404000000021

000012  aa     516000000044

000013  aa     464000000000

000014  aa     077777000043
000015  aa     000001000000

000016  aa  143 162 145 141	crea
000017  aa  164 145 137 166	te_v
000020  aa  164 157 143 145	toce

000021  aa  145 156 164 162	entr
000022  aa  171 040 143 154	y cl
000023  aa  141 163 163 040	ass 
000024  aa  162 141 156 147	rang
000025  aa  145 040 157 165	e ou
000026  aa  164 163 151 144	tsid
000027  aa  145 040 114 126	e LV
000030  aa  040 050 136 141	 (^a
000031  aa  040 114 126 111	 LVI
000032  aa  104 040 136 167	D ^w
000033  aa  051 000 000 000	)

BEGIN PROCEDURE create_vtoce
PROLOGUE SEQUENCE
000034  aa  6 00470 4401 00	sxl0 	pr6|312
						STATEMENT 1 ON LINE 97
000035  aa   000040 2360 07	ldq  	32,dl
000036  aa  6 00466 7561 00	stq  	pr6|310
000037  aa   000001 7360 00	qls  	1
000040  aa  0 00661 7001 00	tsx0 	pr0|433		alloc_auto_adj
000041  aa  6 00464 2521 00	spri2	pr6|308
000042  aa  6 00470 7201 00	lxl0 	pr6|312
000043  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO create_vtoce                                       STATEMENT 1 ON LINE 68
create_vtoce : procedure (branchp, pvid, vtocx, code);

000044  at     000004000013
000045  tt     000012000011
000046  ta     000010000000
000047  ta     000044000000
000050  da     000350300000
000051  aa   000620 6270 00	eax7 	400
000052  aa  7 00034 3521 20	epp2 	pr7|28,*
000053  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000054  aa     000010000000
000055  aa     000000000000
000056  aa   777756 7000 04	tsx0 	-18,ic		000034
						STATEMENT 1 ON LINE 146
	mover = "0"b;

000057  aa  6 00106 4501 00	stz  	pr6|70		mover
						STATEMENT 1 ON LINE 147
	skip_pvtx = 0;

000060  aa  6 00100 4501 00	stz  	pr6|64		skip_pvtx
						STATEMENT 1 ON LINE 148
	nreq = 0;

000061  aa  6 00105 4501 00	stz  	pr6|69		nreq
						STATEMENT 1 ON LINE 149
	optimizing = "1"b;

000062  aa   400000 2350 03	lda  	131072,du
000063  aa  6 00115 7551 00	sta  	pr6|77		optimizing
						STATEMENT 1 ON LINE 150
join:	code = 0;

000064  aa  6 00032 3735 20	epp7 	pr6|26,*
000065  aa  7 00010 4501 20	stz  	pr7|8,*		code
						STATEMENT 1 ON LINE 151
	vtocep = addr (local_vtoce);

000066  aa  6 00126 3715 00	epp5 	pr6|86		local_vtoce
000067  aa  6 00462 6515 00	spri5	pr6|306		vtocep
						STATEMENT 1 ON LINE 152
	ep = branchp;

000070  aa  7 00002 3535 20	epp3 	pr7|2,*		branchp
000071  aa  3 00000 3535 20	epp3 	pr3|0,*		branchp
000072  aa  6 00450 2535 00	spri3	pr6|296		ep
						STATEMENT 1 ON LINE 153
	dp = ptr (ep, 0);

000073  aa  3 00000 3525 00	epbp2	pr3|0
000074  aa  6 00452 2521 00	spri2	pr6|298		dp
						STATEMENT 1 ON LINE 155
	if entry.dirsw then msl = divide (sys_info$default_dir_max_length, 1024, 17, 0);

000075  aa  6 00126 3515 00	epp1 	pr6|86		vtoc_buffer
000076  aa  6 00472 2515 00	spri1	pr6|314
000077  aa  3 00032 2351 00	lda  	pr3|26		entry.dirsw
000100  aa   400000 3150 03	cana 	131072,du
000101  aa   000006 6000 04	tze  	6,ic		000107
000102  aa  6 00044 3701 20	epp4 	pr6|36,*
000103  la  4 00026 2361 20	ldq  	pr4|22,*		sys_info$default_dir_max_length
000104  aa   002000 5060 07	div  	1024,dl
000105  aa  6 00103 7561 00	stq  	pr6|67		msl
000106  aa   000005 7100 04	tra  	5,ic		000113
						STATEMENT 1 ON LINE 156
	else msl = divide (sys_info$default_max_length, 1024, 17, 0);

000107  aa  6 00044 3701 20	epp4 	pr6|36,*
000110  la  4 00024 2361 20	ldq  	pr4|20,*		sys_info$default_max_length
000111  aa   002000 5060 07	div  	1024,dl
000112  aa  6 00103 7561 00	stq  	pr6|67		msl
						STATEMENT 1 ON LINE 158
	unspec (local_vtoce) = "0"b;

000113  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000114  aa   000000 00 0000	desc9a	0,0
000115  aa  1 00000 00 1400	desc9a	pr1|0,768
						STATEMENT 1 ON LINE 159
	local_vtoce.uid = entry.uid;

000116  aa  3 00002 2351 00	lda  	pr3|2		entry.uid
000117  aa  1 00001 7551 00	sta  	pr1|1		local_vtoce.uid
						STATEMENT 1 ON LINE 160
	local_vtoce.msl = bit (fixed (msl, 9));

000120  aa  6 00103 2351 00	lda  	pr6|67		msl
000121  aa   000002 6050 04	tpl  	2,ic		000123
000122  aa   000000 5310 00	neg  	0
000123  aa   000033 7350 00	als  	27
000124  aa  1 00002 5511 40	stba 	pr1|2,40		local_vtoce.msl
						STATEMENT 1 ON LINE 161
	local_vtoce.dirsw = entry.dirsw;

000125  aa  3 00032 2351 00	lda  	pr3|26		entry.dirsw
000126  aa   000022 7710 00	arl  	18
000127  aa  1 00005 6751 00	era  	pr1|5		local_vtoce.dirsw
000130  aa   400000 3750 07	ana  	131072,dl
000131  aa  1 00005 6551 00	ersa 	pr1|5		local_vtoce.dirsw
						STATEMENT 1 ON LINE 162
	local_vtoce.primary_name = addr (entry.primary_name) -> names.name;

000132  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000133  aa  3 00014 00 0040	desc9a	pr3|12,32		names.name
000134  aa  1 00260 00 0040	desc9a	pr1|176,32	local_vtoce.primary_name
						STATEMENT 1 ON LINE 163
	local_vtoce.time_created = bit (clock_ (), 52);

000135  aa  6 00472 3521 00	epp2 	pr6|314
000136  aa  6 00476 2521 00	spri2	pr6|318
000137  aa  6 00474 6211 00	eax1 	pr6|316
000140  aa   004000 4310 07	fld  	2048,dl
000141  la  4 00044 3521 20	epp2 	pr4|36,*		clock_
000142  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000143  aa  6 00472 2371 00	ldaq 	pr6|314
000144  aa   000002 6050 04	tpl  	2,ic		000146
000145  aa   000000 5330 00	negl 	0
000146  aa   000024 7370 00	lls  	20
000147  aa  6 00416 7551 00	sta  	pr6|270		local_vtoce.time_created
						STATEMENT 1 ON LINE 164
	local_vtoce.dtu = local_vtoce.time_created;

000150  aa  6 00131 7551 00	sta  	pr6|89		local_vtoce.dtu
						STATEMENT 1 ON LINE 165
	local_vtoce.dtm = local_vtoce.dtu;

000151  aa  6 00132 7551 00	sta  	pr6|90		local_vtoce.dtm
						STATEMENT 1 ON LINE 166
	local_vtoce.par_pvid = dir.pvid;

000152  aa  6 00452 3735 20	epp7 	pr6|298,*		dp
000153  aa  7 00011 2351 00	lda  	pr7|9		dir.pvid
000154  aa  6 00417 7551 00	sta  	pr6|271		local_vtoce.par_pvid
						STATEMENT 1 ON LINE 167
	local_vtoce.par_vtocx = dir.vtocx;

000155  aa  7 00015 2351 00	lda  	pr7|13		dir.vtocx
000156  aa  6 00420 5511 60	stba 	pr6|272,60	local_vtoce.par_vtocx
						STATEMENT 1 ON LINE 168
	local_vtoce.per_process = entry.per_process_sw;

000157  aa  6 00450 3715 20	epp5 	pr6|296,*		ep
000160  aa  5 00032 2351 00	lda  	pr5|26		entry.per_process_sw
000161  aa   000003 7710 00	arl  	3
000162  aa  6 00133 6751 00	era  	pr6|91		local_vtoce.per_process
000163  aa   010000 3750 03	ana  	4096,du
000164  aa  6 00133 6551 00	ersa 	pr6|91		local_vtoce.per_process
						STATEMENT 1 ON LINE 169
	local_vtoce.branch_rp = rel (ep);

000165  aa  5 00000 6351 00	eaa  	pr5|0		ep
000166  aa   000022 7710 00	arl  	18
000167  aa  6 00420 5511 14	stba 	pr6|272,14	local_vtoce.branch_rp
						STATEMENT 1 ON LINE 170
	local_vtoce.access_class = entry.access_class;

000170  aa  5 00033 2351 00	lda  	pr5|27		entry.access_class
000171  aa  5 00034 2361 00	ldq  	pr5|28		entry.access_class
000172  aa  6 00422 7571 00	staq 	pr6|274		local_vtoce.access_class
						STATEMENT 1 ON LINE 171
	local_vtoce.master_dir = entry.master_dir;

000173  aa  5 00032 2351 00	lda  	pr5|26		entry.master_dir
000174  aa   000012 7710 00	arl  	10
000175  aa  6 00133 6751 00	era  	pr6|91		local_vtoce.master_dir
000176  aa   200000 3750 07	ana  	65536,dl
000177  aa  6 00133 6551 00	ersa 	pr6|91		local_vtoce.master_dir
						STATEMENT 1 ON LINE 172
	if dp -> dir.uid = active_hardcore_data$sl1_uid	/* parent is current >sl1 */
	     then local_vtoce.perm_flags.per_bootload = "1"b;

000200  aa  7 00010 2351 00	lda  	pr7|8		dir.uid
000201  aa  6 00044 3701 20	epp4 	pr6|36,*
000202  la  4 00030 1151 20	cmpa 	pr4|24,*		active_hardcore_data$sl1_uid
000203  aa   000003 6010 04	tnz  	3,ic		000206
000204  aa   400000 2350 03	lda  	131072,du
000205  aa  6 00424 2551 00	orsa 	pr6|276		local_vtoce.per_bootload
						STATEMENT 1 ON LINE 174
	if mover then				/* if called from segment_mover */
	     if tq_infop ^= null then			/* and we need to copy term quota attributes */
		do i = 0 to 1;

000206  aa  6 00106 2351 00	lda  	pr6|70		mover
000207  aa   000040 6000 04	tze  	32,ic		000247
000210  aa  6 00032 3535 20	epp3 	pr6|26,*
000211  aa  3 00020 2371 20	ldaq 	pr3|16,*		tq_infop
000212  aa   777602 6770 04	eraq 	-126,ic		000014 = 077777000043 000001000000
000213  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000214  aa   000033 6000 04	tze  	27,ic		000247
000215  aa  6 00101 4501 00	stz  	pr6|65		i
000216  aa  6 00101 2361 00	ldq  	pr6|65		i
000217  aa   000001 1160 07	cmpq 	1,dl
000220  aa   000027 6054 04	tpnz 	23,ic		000247
						STATEMENT 1 ON LINE 177
		local_vtoce.trp (i) = tq_info.trp (i);

000221  aa   000001 7360 00	qls  	1
000222  aa  6 00032 3735 20	epp7 	pr6|26,*
000223  aa  7 00020 3715 20	epp5 	pr7|16,*		tq_infop
000224  aa   000000 6270 06	eax7 	0,ql
000225  aa  5 00000 2371 66	ldaq 	pr5|0,*ql		tq_info.trp
000226  aa  6 00140 7551 17	sta  	pr6|96,7		local_vtoce.trp
000227  aa  6 00141 7561 17	stq  	pr6|97,7		local_vtoce.trp
						STATEMENT 1 ON LINE 178
		local_vtoce.trp_time (i) = tq_info.tup (i);

000230  aa  6 00101 7261 00	lxl6 	pr6|65		i
000231  aa  5 00000 3535 20	epp3 	pr5|0,*		tq_infop
000232  aa  3 00004 2351 16	lda  	pr3|4,6		tq_info.tup
000233  aa  6 00144 7551 16	sta  	pr6|100,6		local_vtoce.trp_time
						STATEMENT 1 ON LINE 179
		local_vtoce.received (i) = tq_info.received (i);

000234  aa  6 00101 2361 00	ldq  	pr6|65		i
000235  aa   000022 4020 07	mpy  	18,dl
000236  aa   000000 6250 06	eax5 	0,ql
000237  aa  3 00006 2361 16	ldq  	pr3|6,6		tq_info.received
000240  aa   000066 7370 00	lls  	54
000241  aa  6 00056 7551 00	sta  	pr6|46
000242  aa  003 115 060 500	csl  	(pr),(pr,x5),fill(0),bool(move)
000243  aa  6 00056 00 0022	descb	pr6|46,18
000244  aa  6 00137 00 0022	descb	pr6|95,18		local_vtoce.received
						STATEMENT 1 ON LINE 180
	     end;

000245  aa  6 00101 0541 00	aos  	pr6|65		i
000246  aa   777750 7100 04	tra  	-24,ic		000216
						STATEMENT 1 ON LINE 187
	fmn_ptr = addr (local_vtoce.fm (0));

000247  aa  6 00146 3735 00	epp7 	pr6|102		local_vtoce.fm
000250  aa  6 00426 6535 00	spri7	pr6|278		fmn_ptr
						STATEMENT 1 ON LINE 188
	fm_nullifier = high9(256*2);

000251  aa  777 100 100 400	mlr  	(),(pr),fill(777)
000252  aa   000000 00 0000	desc9a	0,0
000253  aa  7 00000 00 1000	desc9a	pr7|0,512		fm_nullifier
						STATEMENT 1 ON LINE 196
	force_rpv = (dir.tree_depth = 0)		/* set for level 1 creations to go on rpv */
	     | dir.force_rpv			/* Better be on RLV ! */
	     | sys_info$initialization_state < 3;

000254  aa  6 00044 3701 20	epp4 	pr6|36,*
000255  la  4 00012 2361 20	ldq  	pr4|10,*		sys_info$initialization_state
000256  aa   000003 1160 07	cmpq 	3,dl
000257  aa  0 00474 7001 00	tsx0 	pr0|316		r_l_a
000260  aa  6 00471 7551 00	sta  	pr6|313
000261  aa  6 00452 3715 20	epp5 	pr6|298,*		dp
000262  aa  5 00024 2351 00	lda  	pr5|20		dir.force_rpv
000263  aa   000024 7350 00	als  	20
000264  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000265  aa  6 00500 7551 00	sta  	pr6|320		dir.force_rpv
000266  aa  5 00057 2351 00	lda  	pr5|47		dir.tree_depth
000267  aa   000066 7330 00	lrs  	54
000270  aa  0 00512 7001 00	tsx0 	pr0|330		r_e_as
000271  aa  6 00500 2751 00	ora  	pr6|320		dir.force_rpv
000272  aa  6 00471 2751 00	ora  	pr6|313
000273  aa  6 00114 7551 00	sta  	pr6|76		force_rpv
						STATEMENT 1 ON LINE 203
	call uid_path_util$get (dp, uid_path, code);

000274  aa  6 00452 3521 00	epp2 	pr6|298		dp
000275  aa  6 00504 2521 00	spri2	pr6|324
000276  aa  6 00430 3521 00	epp2 	pr6|280		uid_path
000277  aa  6 00506 2521 00	spri2	pr6|326
000300  aa  6 00032 3535 20	epp3 	pr6|26,*
000301  aa  3 00010 3521 20	epp2 	pr3|8,*		code
000302  aa  6 00510 2521 00	spri2	pr6|328
000303  aa  6 00502 6211 00	eax1 	pr6|322
000304  aa   014000 4310 07	fld  	6144,dl
000305  la  4 00062 3521 20	epp2 	pr4|50,*		uid_path_util$get
000306  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 204
	if code ^= 0 then return;

000307  aa  6 00032 3735 20	epp7 	pr6|26,*
000310  aa  7 00010 2361 20	ldq  	pr7|8,*		code
000311  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 205
	local_vtoce.uid_path = uid_path;

000312  aa   000001 2360 07	ldq  	1,dl
000313  aa  6 00467 7561 00	stq  	pr6|311
000314  aa  6 00467 7271 00	lxl7 	pr6|311
000315  aa  6 00427 2351 17	lda  	pr6|279,7		uid_path
000316  aa  6 00365 7551 17	sta  	pr6|245,7		local_vtoce.uid_path
000317  aa  6 00467 2361 00	ldq  	pr6|311
000320  aa  6 00467 0541 00	aos  	pr6|311
000321  aa   000020 1160 07	cmpq 	16,dl
000322  aa   777772 6040 04	tmi  	-6,ic		000314
						STATEMENT 1 ON LINE 210
	try_cycle = ^mover & ^force_rpv 
	     & (dir.per_process_sw | sst$cycle_pv_allocation ^= 0);

000323  aa  6 00044 3701 20	epp4 	pr6|36,*
000324  la  4 00014 2361 20	ldq  	pr4|12,*		sst$cycle_pv_allocation
000325  aa  0 00515 7001 00	tsx0 	pr0|333		r_ne_as
000326  aa  6 00501 7551 00	sta  	pr6|321
000327  aa  6 00452 3735 20	epp7 	pr6|298,*		dp
000330  aa  7 00024 2351 00	lda  	pr7|20		dir.per_process_sw
000331  aa   000022 7350 00	als  	18
000332  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000333  aa  6 00501 2751 00	ora  	pr6|321
000334  aa  6 00501 7551 00	sta  	pr6|321
000335  aa  6 00114 2351 00	lda  	pr6|76		force_rpv
000336  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000337  aa  6 00471 7551 00	sta  	pr6|313
000340  aa  6 00106 2351 00	lda  	pr6|70		mover
000341  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
000342  aa  6 00471 3751 00	ana  	pr6|313
000343  aa  6 00501 3751 00	ana  	pr6|321
000344  aa  6 00111 7551 00	sta  	pr6|73		try_cycle
						STATEMENT 1 ON LINE 215
	if entry.dirsw = "0"b then lvid = dir.sons_lvid;

000345  aa  6 00450 3715 20	epp5 	pr6|296,*		ep
000346  aa  5 00032 2351 00	lda  	pr5|26		entry.dirsw
000347  aa   400000 3150 03	cana 	131072,du
000350  aa   000004 6010 04	tnz  	4,ic		000354
000351  aa  7 00012 2351 00	lda  	pr7|10		dir.sons_lvid
000352  aa  6 00116 7551 00	sta  	pr6|78		lvid
000353  aa   000003 7100 04	tra  	3,ic		000356
						STATEMENT 1 ON LINE 216
	else lvid = pvt$root_lvid;

000354  la  4 00016 2351 20	lda  	pr4|14,*		pvt$root_lvid
000355  aa  6 00116 7551 00	sta  	pr6|78		lvid
						STATEMENT 1 ON LINE 219
restart:	call logical_volume_manager$lvtep ((lvid), lvtep, code);

000356  aa  6 00116 2351 00	lda  	pr6|78		lvid
000357  aa  6 00501 7551 00	sta  	pr6|321
000360  aa  6 00501 3521 00	epp2 	pr6|321
000361  aa  6 00504 2521 00	spri2	pr6|324
000362  aa  6 00454 3521 00	epp2 	pr6|300		lvtep
000363  aa  6 00506 2521 00	spri2	pr6|326
000364  aa  6 00032 3735 20	epp7 	pr6|26,*
000365  aa  7 00010 3521 20	epp2 	pr7|8,*		code
000366  aa  6 00510 2521 00	spri2	pr6|328
000367  aa  6 00502 6211 00	eax1 	pr6|322
000370  aa   014000 4310 07	fld  	6144,dl
000371  aa  6 00044 3701 20	epp4 	pr6|36,*
000372  la  4 00042 3521 20	epp2 	pr4|34,*		logical_volume_manager$lvtep
000373  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 220
	if code ^= 0 then return;

000374  aa  6 00032 3735 20	epp7 	pr6|26,*
000375  aa  7 00010 2361 20	ldq  	pr7|8,*		code
000376  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 221
	if ^(read_allowed_ (entry.access_class, lvte.access_class.min) &
	     write_allowed_ (entry.access_class, lvte.access_class.max))
	then do;

000377  aa  6 00450 3715 20	epp5 	pr6|296,*		ep
000400  aa  5 00033 3521 00	epp2 	pr5|27		entry.access_class
000401  aa  6 00504 2521 00	spri2	pr6|324
000402  aa  6 00454 3535 20	epp3 	pr6|300,*		lvtep
000403  aa  3 00005 3521 00	epp2 	pr3|5		lvte.max
000404  aa  6 00506 2521 00	spri2	pr6|326
000405  aa  6 00501 3521 00	epp2 	pr6|321
000406  aa  6 00510 2521 00	spri2	pr6|328
000407  aa  6 00502 6211 00	eax1 	pr6|322
000410  aa   014000 4310 07	fld  	6144,dl
000411  aa  6 00044 3701 20	epp4 	pr6|36,*
000412  la  4 00052 3521 20	epp2 	pr4|42,*		write_allowed_
000413  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000414  aa  6 00450 3735 20	epp7 	pr6|296,*		ep
000415  aa  7 00033 3521 00	epp2 	pr7|27		entry.access_class
000416  aa  6 00504 2521 00	spri2	pr6|324
000417  aa  6 00454 3715 20	epp5 	pr6|300,*		lvtep
000420  aa  5 00003 3521 00	epp2 	pr5|3		lvte.min
000421  aa  6 00506 2521 00	spri2	pr6|326
000422  aa  6 00471 3521 00	epp2 	pr6|313
000423  aa  6 00510 2521 00	spri2	pr6|328
000424  aa  6 00502 6211 00	eax1 	pr6|322
000425  aa   014000 4310 07	fld  	6144,dl
000426  aa  6 00044 3701 20	epp4 	pr6|36,*
000427  la  4 00050 3521 20	epp2 	pr4|40,*		read_allowed_
000430  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000431  aa  6 00501 2351 00	lda  	pr6|321
000432  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000433  aa  6 00501 7551 00	sta  	pr6|321
000434  aa  6 00471 2351 00	lda  	pr6|313
000435  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000436  aa  6 00501 3151 00	cana 	pr6|321
000437  aa   000153 6010 04	tnz  	107,ic		000612
						STATEMENT 1 ON LINE 224
	     pvid = "0"b;

000440  aa  6 00032 3735 20	epp7 	pr6|26,*
000441  aa  7 00004 3715 20	epp5 	pr7|4,*
000442  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
000443  aa   000000 00 0000	descb	0,0
000444  aa  5 00000 00 0044	descb	pr5|0,36		pvid
						STATEMENT 1 ON LINE 225
	     vtocx = -1;

000445  aa   000001 3360 07	lcq  	1,dl
000446  aa  7 00006 7561 20	stq  	pr7|6,*		vtocx
						STATEMENT 1 ON LINE 226
	     code = error_table_$ai_restricted;

000447  aa  6 00044 3701 20	epp4 	pr6|36,*
000450  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$ai_restricted
000451  aa  7 00010 7561 20	stq  	pr7|8,*		code
						STATEMENT 1 ON LINE 227
	     string(event_flags) = ""b;

000452  aa  6 00113 4501 00	stz  	pr6|75
						STATEMENT 1 ON LINE 228
	     if access_audit_check_ep_$self (string (event_flags), access_operations_$fs_obj_create, ep) then
		call access_audit_$log_entry_ptr ("create_vtoce", level$get(), string(event_flags),
		access_operations_$fs_obj_create, ep, code, null(), 0,
		"entry class range outside LV (^a LVID ^w)",
		display_access_class_$range (addr(lvte.access_class)->based_class_range), lvte.lvid);

000453  aa  6 00113 2351 00	lda  	pr6|75
000454  aa  6 00501 7551 00	sta  	pr6|321
000455  aa  6 00501 3521 00	epp2 	pr6|321
000456  aa  6 00514 2521 00	spri2	pr6|332
000457  la  4 00010 3521 20	epp2 	pr4|8,*		access_operations_$fs_obj_create
000460  aa  6 00516 2521 00	spri2	pr6|334
000461  aa  6 00450 3521 00	epp2 	pr6|296		ep
000462  aa  6 00520 2521 00	spri2	pr6|336
000463  aa  6 00471 3521 00	epp2 	pr6|313
000464  aa  6 00522 2521 00	spri2	pr6|338
000465  aa  6 00512 6211 00	eax1 	pr6|330
000466  aa   020000 4310 07	fld  	8192,dl
000467  la  4 00032 3521 20	epp2 	pr4|26,*		access_audit_check_ep_$self
000470  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000471  aa  6 00471 2351 00	lda  	pr6|313
000472  aa   400000 3150 03	cana 	131072,du
000473  aa   000116 6000 04	tze  	78,ic		000611
000474  aa   777322 2370 04	ldaq 	-302,ic		000016 = 143162145141 164145137166
000475  aa  6 00474 7571 00	staq 	pr6|316
000476  aa   777322 2350 04	lda  	-302,ic		000020 = 164157143145
000477  aa  6 00476 7551 00	sta  	pr6|318
000500  aa  6 00471 3521 00	epp2 	pr6|313
000501  aa  6 00504 2521 00	spri2	pr6|324
000502  aa  6 00502 6211 00	eax1 	pr6|322
000503  aa   004000 4310 07	fld  	2048,dl
000504  aa  6 00044 3701 20	epp4 	pr6|36,*
000505  la  4 00046 3521 20	epp2 	pr4|38,*		level$get
000506  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000507  aa  6 00113 2351 00	lda  	pr6|75
000510  aa  6 00501 7551 00	sta  	pr6|321
000511  aa   777303 3734 24	epp7 	-317,ic*
000512  aa  6 00472 6535 00	spri7	pr6|314
000513  aa  6 00500 4501 00	stz  	pr6|320
000514  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000515  aa   777305 00 0054	desc9a	-315,44		000021 = 145156164162
000516  aa  6 00524 00 0054	desc9a	pr6|340,44
000517  aa  6 00454 3715 20	epp5 	pr6|300,*		lvtep
000520  aa  5 00003 3521 00	epp2 	pr5|3		based_class_range
000521  aa  6 00514 2521 00	spri2	pr6|332
000522  aa  6 00502 3521 00	epp2 	pr6|322
000523  aa  6 00516 2521 00	spri2	pr6|334
000524  aa  6 00512 6211 00	eax1 	pr6|330
000525  aa   010000 4310 07	fld  	4096,dl
000526  aa  6 00044 3701 20	epp4 	pr6|36,*
000527  la  4 00036 3521 20	epp2 	pr4|30,*		display_access_class_$range
000530  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000531  aa  6 00474 3521 00	epp2 	pr6|316
000532  aa  6 00542 2521 00	spri2	pr6|354
000533  aa  6 00471 3521 00	epp2 	pr6|313
000534  aa  6 00544 2521 00	spri2	pr6|356
000535  aa  6 00501 3521 00	epp2 	pr6|321
000536  aa  6 00546 2521 00	spri2	pr6|358
000537  aa  6 00044 3701 20	epp4 	pr6|36,*
000540  la  4 00010 3521 20	epp2 	pr4|8,*		access_operations_$fs_obj_create
000541  aa  6 00550 2521 00	spri2	pr6|360
000542  aa  6 00450 3521 00	epp2 	pr6|296		ep
000543  aa  6 00552 2521 00	spri2	pr6|362
000544  aa  6 00032 3735 20	epp7 	pr6|26,*
000545  aa  7 00010 3521 20	epp2 	pr7|8,*		code
000546  aa  6 00554 2521 00	spri2	pr6|364
000547  aa  6 00472 3521 00	epp2 	pr6|314
000550  aa  6 00556 2521 00	spri2	pr6|366
000551  aa  6 00500 3521 00	epp2 	pr6|320
000552  aa  6 00560 2521 00	spri2	pr6|368
000553  aa  6 00524 3521 00	epp2 	pr6|340
000554  aa  6 00562 2521 00	spri2	pr6|370
000555  aa  6 00502 3521 00	epp2 	pr6|322
000556  aa  6 00564 2521 00	spri2	pr6|372
000557  aa  6 00454 3715 20	epp5 	pr6|300,*		lvtep
000560  aa  5 00002 3521 00	epp2 	pr5|2		lvte.lvid
000561  aa  6 00566 2521 00	spri2	pr6|374
000562  aa   777221 3520 04	epp2 	-367,ic		000003 = 524000000014
000563  aa  6 00570 2521 00	spri2	pr6|376
000564  aa   777225 3520 04	epp2 	-363,ic		000011 = 404000000021
000565  aa  6 00572 2521 00	spri2	pr6|378
000566  aa   777214 3520 04	epp2 	-372,ic		000002 = 514000000044
000567  aa  6 00574 2521 00	spri2	pr6|380
000570  aa  6 00576 2521 00	spri2	pr6|382
000571  aa  6 00614 2521 00	spri2	pr6|396
000572  aa   777221 3520 04	epp2 	-367,ic		000013 = 464000000000
000573  aa  6 00600 2521 00	spri2	pr6|384
000574  aa  6 00604 2521 00	spri2	pr6|388
000575  aa   777213 3520 04	epp2 	-373,ic		000010 = 404000000043
000576  aa  6 00602 2521 00	spri2	pr6|386
000577  aa   777202 3520 04	epp2 	-382,ic		000001 = 404000000005
000600  aa  6 00606 2521 00	spri2	pr6|390
000601  aa   777177 3520 04	epp2 	-385,ic		000000 = 524000000051
000602  aa  6 00610 2521 00	spri2	pr6|392
000603  aa   777202 3520 04	epp2 	-382,ic		000005 = 524000000040
000604  aa  6 00612 2521 00	spri2	pr6|394
000605  aa  6 00540 6211 00	eax1 	pr6|352
000606  aa   054000 4310 07	fld  	22528,dl
000607  la  4 00034 3521 20	epp2 	pr4|28,*		access_audit_$log_entry_ptr
000610  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 233
	     return;

000611  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 234
	end;

						STATEMENT 1 ON LINE 252
          pvt_arrayp = addr (pvt$array);

000612  aa  6 00044 3701 20	epp4 	pr6|36,*
000613  la  4 00066 3735 20	epp7 	pr4|54,*		pvt$array
000614  aa  6 00456 6535 00	spri7	pr6|302		pvt_arrayp
						STATEMENT 1 ON LINE 253
retry:
	held = "0"b;

000615  aa  6 00112 4501 00	stz  	pr6|74		held
						STATEMENT 1 ON LINE 255
	if try_cycle then do;

000616  aa  6 00111 2351 00	lda  	pr6|73		try_cycle
000617  aa   000144 6000 04	tze  	100,ic		000763
						STATEMENT 1 ON LINE 256
	     try_cycle = "0"b;

000620  aa  6 00111 4501 00	stz  	pr6|73		try_cycle
						STATEMENT 1 ON LINE 258
	     looped, looping = "0"b;

000621  aa  6 00107 4501 00	stz  	pr6|71		looped
000622  aa  6 00110 4501 00	stz  	pr6|72		looping
						STATEMENT 1 ON LINE 259
	     pvtx = lvte.cycle_pvtx;

000623  aa  6 00454 3735 20	epp7 	pr6|300,*		lvtep
000624  aa  7 00007 2351 00	lda  	pr7|7		lvte.cycle_pvtx
000625  aa   000022 7350 00	als  	18
000626  aa   000066 7330 00	lrs  	54
000627  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 260
	     if pvtx = 0 then looped = "1"b;

000630  aa   000004 6010 04	tnz  	4,ic		000634
000631  aa   400000 2350 03	lda  	131072,du
000632  aa  6 00107 7551 00	sta  	pr6|71		looped
000633  aa   000012 7100 04	tra  	10,ic		000645
						STATEMENT 1 ON LINE 261
	     else do;

						STATEMENT 1 ON LINE 262
		pvtep = addr (pvt_array (pvtx));

000634  aa   000034 4020 07	mpy  	28,dl
000635  aa  6 00456 3715 20	epp5 	pr6|302,*		pvt_arrayp
000636  aa  5 77744 3715 06	epp5 	pr5|-28,ql	pvt_array
000637  aa  6 00460 6515 00	spri5	pr6|304		pvtep
						STATEMENT 1 ON LINE 263
		if pvte.lvid ^= lvid then looped = "1"b;

000640  aa  5 00001 2351 00	lda  	pr5|1		pvte.lvid
000641  aa  6 00116 1151 00	cmpa 	pr6|78		lvid
000642  aa   000003 6000 04	tze  	3,ic		000645
000643  aa   400000 2350 03	lda  	131072,du
000644  aa  6 00107 7551 00	sta  	pr6|71		looped
						STATEMENT 1 ON LINE 264
	     end;

						STATEMENT 1 ON LINE 265
	     if looped then pvtx, lvte.cycle_pvtx = lvte.pvtex;

000645  aa  6 00107 2351 00	lda  	pr6|71		looped
000646  aa   000004 6000 04	tze  	4,ic		000652
000647  aa  7 00001 2361 00	ldq  	pr7|1		lvte.pvtex
000650  aa  6 00102 7561 00	stq  	pr6|66		pvtx
000651  aa  7 00007 5521 14	stbq 	pr7|7,14		lvte.cycle_pvtx
						STATEMENT 1 ON LINE 268
	     do while (^looping);

000652  aa  6 00110 2351 00	lda  	pr6|72		looping
000653  aa   000110 6010 04	tnz  	72,ic		000763
						STATEMENT 1 ON LINE 269
		pvtep = addr (pvt_array (pvtx));

000654  aa  6 00102 2361 00	ldq  	pr6|66		pvtx
000655  aa   000034 4020 07	mpy  	28,dl
000656  aa  6 00456 3735 20	epp7 	pr6|302,*		pvt_arrayp
000657  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
000660  aa  6 00460 6535 00	spri7	pr6|304		pvtep
						STATEMENT 1 ON LINE 270
		call disk_control$queue_length_given_pvtx (pvtx, queue_length);

000661  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
000662  aa  6 00504 2521 00	spri2	pr6|324
000663  aa  6 00117 3521 00	epp2 	pr6|79		queue_length
000664  aa  6 00506 2521 00	spri2	pr6|326
000665  aa  6 00502 6211 00	eax1 	pr6|322
000666  aa   010000 4310 07	fld  	4096,dl
000667  aa  6 00044 3701 20	epp4 	pr6|36,*
000670  la  4 00064 3521 20	epp2 	pr4|52,*		disk_control$queue_length_given_pvtx
000671  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 271
		if ^pvte.vacating
		& ^pvte.device_inoperative		/* bad idea if down */
		& pvte.n_free_vtoce > 0
		& pvte.nleft > 32 then do;

000672  aa  6 00460 3735 20	epp7 	pr6|304,*		pvtep
000673  aa  7 00004 2351 00	lda  	pr7|4		pvte.device_inoperative
000674  aa   002020 3150 07	cana 	1040,dl
000675  aa   000046 6010 04	tnz  	38,ic		000743
000676  aa  7 00005 2351 00	lda  	pr7|5		pvte.n_free_vtoce
000677  aa   000066 7330 00	lrs  	54
000700  aa   000043 6044 04	tmoz 	35,ic		000743
000701  aa  7 00007 2351 00	lda  	pr7|7		pvte.nleft
000702  aa   000066 7330 00	lrs  	54
000703  aa   000040 1160 07	cmpq 	32,dl
000704  aa   000037 6044 04	tmoz 	31,ic		000743
						STATEMENT 1 ON LINE 275
		     if dir.per_process_sw
			& queue_length>MAXQ_FOR_PDIR_CYCLE /* drive looks saturated		*/
			then do;

000705  aa  6 00452 3715 20	epp5 	pr6|298,*		dp
000706  aa  5 00024 2351 00	lda  	pr5|20		dir.per_process_sw
000707  aa   400000 3150 07	cana 	131072,dl
000710  aa   000017 6000 04	tze  	15,ic		000727
000711  aa  6 00117 2361 00	ldq  	pr6|79		queue_length
000712  aa   000007 1160 07	cmpq 	7,dl
000713  aa   000014 6044 04	tmoz 	12,ic		000727
						STATEMENT 1 ON LINE 278
			if pvte.skip_queue_count=262143    /* dont want overflow of meter		*/
			     then pvte.skip_queue_count = 0;

000714  aa  7 00002 2361 00	ldq  	pr7|2		pvte.skip_queue_count
000715  aa  0 00374 3771 00	anaq 	pr0|252		= 000000000000 000000777777
000716  aa  6 00500 7561 00	stq  	pr6|320		pvte.skip_queue_count
000717  aa   777777 1160 07	cmpq 	262143,dl
000720  aa   000004 6010 04	tnz  	4,ic		000724
000721  aa   000000 2350 03	lda  	0,du
000722  aa  7 00002 5511 14	stba 	pr7|2,14		pvte.skip_queue_count
000723  aa   000020 7100 04	tra  	16,ic		000743
						STATEMENT 1 ON LINE 280
			else pvte.skip_queue_count = pvte.skip_queue_count + 1;

000724  aa   000001 0760 07	adq  	1,dl
000725  aa  7 00002 5521 14	stbq 	pr7|2,14		pvte.skip_queue_count
						STATEMENT 1 ON LINE 281
		     end;

000726  aa   000015 7100 04	tra  	13,ic		000743
						STATEMENT 1 ON LINE 282
		     else do;

						STATEMENT 1 ON LINE 283
			lvte.cycle_pvtx = pvte.brother_pvtx;

000727  aa  7 00002 2351 00	lda  	pr7|2		pvte.brother_pvtx
000730  aa   000011 7350 00	als  	9
000731  aa   000011 7330 00	lrs  	9
000732  aa   000022 7710 00	arl  	18
000733  aa  6 00454 3535 20	epp3 	pr6|300,*		lvtep
000734  aa  3 00007 5511 14	stba 	pr3|7,14		lvte.cycle_pvtx
						STATEMENT 1 ON LINE 284
			pvid = pvte.pvid;

000735  aa  6 00032 3515 20	epp1 	pr6|26,*
000736  aa  1 00004 3715 20	epp5 	pr1|4,*
000737  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
000740  aa  7 00000 00 0044	descb	pr7|0,36		pvte.pvid
000741  aa  5 00000 00 0044	descb	pr5|0,36		pvid
						STATEMENT 1 ON LINE 285
			go to got;

000742  aa   000246 7100 04	tra  	166,ic		001210
						STATEMENT 1 ON LINE 286
		     end;

						STATEMENT 1 ON LINE 287
		end;

						STATEMENT 1 ON LINE 288
		pvtx = pvte.brother_pvtx;

000743  aa  7 00002 2351 00	lda  	pr7|2		pvte.brother_pvtx
000744  aa   000011 7350 00	als  	9
000745  aa   000077 7330 00	lrs  	63
000746  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 289
		if pvtx = 0 then do;

000747  aa   777703 6010 04	tnz  	-61,ic		000652
						STATEMENT 1 ON LINE 290
		     if looped then looping = "1"b;

000750  aa  6 00107 2351 00	lda  	pr6|71		looped
000751  aa   000004 6000 04	tze  	4,ic		000755
000752  aa   400000 2350 03	lda  	131072,du
000753  aa  6 00110 7551 00	sta  	pr6|72		looping
000754  aa   777676 7100 04	tra  	-66,ic		000652
						STATEMENT 1 ON LINE 291
		     else do;

						STATEMENT 1 ON LINE 292
			looped = "1"b;

000755  aa   400000 2350 03	lda  	131072,du
000756  aa  6 00107 7551 00	sta  	pr6|71		looped
						STATEMENT 1 ON LINE 293
			pvtx = lvte.pvtex;

000757  aa  6 00454 3715 20	epp5 	pr6|300,*		lvtep
000760  aa  5 00001 2361 00	ldq  	pr5|1		lvte.pvtex
000761  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 294
		     end;

						STATEMENT 1 ON LINE 295
		end;

						STATEMENT 1 ON LINE 296
	     end;

000762  aa   777670 7100 04	tra  	-72,ic		000652
						STATEMENT 1 ON LINE 297
	end;

						STATEMENT 1 ON LINE 299
	n_pvs = 0;

000763  aa  6 00123 4501 00	stz  	pr6|83		n_pvs
						STATEMENT 1 ON LINE 300
	sum_fract_empty = 0;

000764  aa   000000 2360 07	ldq  	0,dl
000765  aa  6 00122 7561 00	stq  	pr6|82		sum_fract_empty
						STATEMENT 1 ON LINE 301
	pvtx = -1;

000766  aa   000001 3360 07	lcq  	1,dl
000767  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 303
	if mover 
	then if corout_pvtx = 0
	     then first_pvtx = lvte.pvtex;

000770  aa  6 00106 2351 00	lda  	pr6|70		mover
000771  aa   000020 6000 04	tze  	16,ic		001011
000772  aa  6 00032 3735 20	epp7 	pr6|26,*
000773  aa  7 00012 2361 20	ldq  	pr7|10,*		corout_pvtx
000774  aa   000005 6010 04	tnz  	5,ic		001001
000775  aa  6 00454 3715 20	epp5 	pr6|300,*		lvtep
000776  aa  5 00001 2361 00	ldq  	pr5|1		lvte.pvtex
000777  aa  6 00104 7561 00	stq  	pr6|68		first_pvtx
001000  aa   000014 7100 04	tra  	12,ic		001014
						STATEMENT 1 ON LINE 306
	     else do;

						STATEMENT 1 ON LINE 307
		first_pvtx = pvt_array (corout_pvtx).brother_pvtx;

001001  aa   000034 4020 07	mpy  	28,dl
001002  aa  6 00456 3715 20	epp5 	pr6|302,*		pvt_arrayp
001003  aa  5 77746 2351 06	lda  	pr5|-26,ql	pvt_array.brother_pvtx
001004  aa   000011 7350 00	als  	9
001005  aa   000077 7330 00	lrs  	63
001006  aa  6 00104 7561 00	stq  	pr6|68		first_pvtx
						STATEMENT 1 ON LINE 308
		corout_pvtx = 0;

001007  aa  7 00012 4501 20	stz  	pr7|10,*		corout_pvtx
						STATEMENT 1 ON LINE 309
	     end;

001010  aa   000004 7100 04	tra  	4,ic		001014
						STATEMENT 1 ON LINE 310
	else first_pvtx = lvte.pvtex;

001011  aa  6 00454 3735 20	epp7 	pr6|300,*		lvtep
001012  aa  7 00001 2361 00	ldq  	pr7|1		lvte.pvtex
001013  aa  6 00104 7561 00	stq  	pr6|68		first_pvtx
						STATEMENT 1 ON LINE 312
	do i = first_pvtx repeat (pvte.brother_pvtx) while (i ^= 0);

001014  aa  6 00101 7561 00	stq  	pr6|65		i
001015  aa   000000 0110 03	nop  	0,du
001016  aa  6 00101 2361 00	ldq  	pr6|65		i
001017  aa   000076 6000 04	tze  	62,ic		001115
						STATEMENT 1 ON LINE 313
	     pvtep = addr (pvt_array (i));

001020  aa   000034 4020 07	mpy  	28,dl
001021  aa  6 00456 3735 20	epp7 	pr6|302,*		pvt_arrayp
001022  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
001023  aa  6 00460 6535 00	spri7	pr6|304		pvtep
						STATEMENT 1 ON LINE 314
	     if pvte.lvid ^= lvid then go to restart;

001024  aa  7 00001 2351 00	lda  	pr7|1		pvte.lvid
001025  aa  6 00116 1151 00	cmpa 	pr6|78		lvid
001026  aa   777330 6010 04	tnz  	-296,ic		000356
						STATEMENT 1 ON LINE 315
	     if (^force_rpv | pvte.rpv)		/* Want to use rpv? */
	     then if pvte.n_free_vtoce > 0 & ^pvte.vacating /* Must be space for 1 new seg */
		then if (^mover | (pvte.nleft > nreq) & (i ^= skip_pvtx)) /* If moving, need nreq, not orig PV */
		     & ^pvte.device_inoperative	/* bad idea if down */
		     then do;

001027  aa  6 00114 2351 00	lda  	pr6|76		force_rpv
001030  aa   000004 6000 04	tze  	4,ic		001034
001031  aa  7 00004 2351 00	lda  	pr7|4		pvte.rpv
001032  aa   001000 3150 07	cana 	512,dl
001033  aa   000055 6000 04	tze  	45,ic		001110
001034  aa  7 00005 2351 00	lda  	pr7|5		pvte.n_free_vtoce
001035  aa   000066 7330 00	lrs  	54
001036  aa   000052 6044 04	tmoz 	42,ic		001110
001037  aa  7 00004 2351 00	lda  	pr7|4		pvte.vacating
001040  aa   000020 3150 07	cana 	16,dl
001041  aa   000047 6010 04	tnz  	39,ic		001110
001042  aa  7 00007 2351 00	lda  	pr7|7		pvte.nleft
001043  aa   000066 7330 00	lrs  	54
001044  aa  6 00500 7561 00	stq  	pr6|320		pvte.nleft
001045  aa  6 00106 2351 00	lda  	pr6|70		mover
001046  aa   000006 6000 04	tze  	6,ic		001054
001047  aa  6 00105 1161 00	cmpq 	pr6|69		nreq
001050  aa   000040 6044 04	tmoz 	32,ic		001110
001051  aa  6 00101 2361 00	ldq  	pr6|65		i
001052  aa  6 00100 1161 00	cmpq 	pr6|64		skip_pvtx
001053  aa   000035 6000 04	tze  	29,ic		001110
001054  aa  7 00004 2351 00	lda  	pr7|4		pvte.device_inoperative
001055  aa   002000 3150 07	cana 	1024,dl
001056  aa   000032 6010 04	tnz  	26,ic		001110
						STATEMENT 1 ON LINE 320
			if ^optimizing then do;

001057  aa  6 00115 2351 00	lda  	pr6|77		optimizing
001060  aa   000004 6010 04	tnz  	4,ic		001064
						STATEMENT 1 ON LINE 321
			     pvtx = i;

001061  aa  6 00101 2361 00	ldq  	pr6|65		i
001062  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 322
			     goto got;

001063  aa   000125 7100 04	tra  	85,ic		001210
						STATEMENT 1 ON LINE 323
			end;

						STATEMENT 1 ON LINE 324
			else do;

						STATEMENT 1 ON LINE 325
			     n_pvs = n_pvs + 1;

001064  aa  6 00123 0541 00	aos  	pr6|83		n_pvs
						STATEMENT 1 ON LINE 326
			     pv_alloc (n_pvs).pvtx = i;

001065  aa  6 00123 2361 00	ldq  	pr6|83		n_pvs
001066  aa   000001 7360 00	qls  	1
001067  aa   000000 6270 06	eax7 	0,ql
001070  aa  6 00101 2361 00	ldq  	pr6|65		i
001071  aa  6 00464 3715 20	epp5 	pr6|308,*
001072  aa  5 77776 7561 17	stq  	pr5|-2,7		pv_alloc.pvtx
						STATEMENT 1 ON LINE 327
			     pv_alloc (n_pvs).fract_empty
				= divide (pvte.nleft, pvte.totrec, 35, 18);

001073  aa  7 00007 2351 00	lda  	pr7|7		pvte.totrec
001074  aa   000022 7350 00	als  	18
001075  aa   000066 7330 00	lrs  	54
001076  aa  6 00501 7561 00	stq  	pr6|321		pvte.totrec
001077  aa  6 00500 2361 00	ldq  	pr6|320		pvte.nleft
001100  aa  6 00501 3521 00	epp2 	pr6|321		pvte.totrec
001101  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001102  aa     000000000022
001103  aa  5 77777 7561 17	stq  	pr5|-1,7		pv_alloc.fract_empty
						STATEMENT 1 ON LINE 329
			     sum_fract_empty = sum_fract_empty
				+ pv_alloc (n_pvs).fract_empty;

001104  aa   000044 7770 00	llr  	36
001105  aa   000044 7330 00	lrs  	36
001106  aa  6 00122 0331 00	adl  	pr6|82		sum_fract_empty
001107  aa  6 00122 7561 00	stq  	pr6|82		sum_fract_empty
						STATEMENT 1 ON LINE 331
			end;

						STATEMENT 1 ON LINE 332
		     end;

						STATEMENT 1 ON LINE 333
	end;

001110  aa  7 00002 2351 00	lda  	pr7|2		pvte.brother_pvtx
001111  aa   000011 7350 00	als  	9
001112  aa   000077 7330 00	lrs  	63
001113  aa  6 00101 7561 00	stq  	pr6|65		i
001114  aa   777702 7100 04	tra  	-62,ic		001016
						STATEMENT 1 ON LINE 343
	if n_pvs > 0 then do;

001115  aa  6 00123 2361 00	ldq  	pr6|83		n_pvs
001116  aa   000054 6044 04	tmoz 	44,ic		001172
						STATEMENT 1 ON LINE 344
	     random_number = divide (multiply (mod (clock (), MODULUS), sum_fract_empty, 35, 18),
		MODULUS, 35, 18);

001117  aa  0 01435 7001 00	tsx0 	pr0|797		clock_mac
001120  aa   000321 3520 04	epp2 	209,ic		001441 = 000000002000
001121  aa  0 00706 7001 00	tsx0 	pr0|454		mdfx3
001122  aa  6 00122 4021 00	mpy  	pr6|82		sum_fract_empty
001123  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001124  aa     000000000000
001125  aa  6 00121 7561 00	stq  	pr6|81		random_number
						STATEMENT 1 ON LINE 346
	     working_sum = 0;

001126  aa   000000 2360 07	ldq  	0,dl
001127  aa  6 00120 7561 00	stq  	pr6|80		working_sum
						STATEMENT 1 ON LINE 347
	     pv_found = "0"b;

001130  aa  6 00124 4501 00	stz  	pr6|84		pv_found
						STATEMENT 1 ON LINE 348
	     do pv_alloc_x = 1 repeat pv_alloc_x + 1 
		while (^pv_found & pv_alloc_x < n_pvs);

001131  aa   000001 2360 07	ldq  	1,dl
001132  aa  6 00125 7561 00	stq  	pr6|85		pv_alloc_x
001133  aa   000000 0110 03	nop  	0,du
001134  aa  6 00124 2351 00	lda  	pr6|84		pv_found
001135  aa  0 00002 6751 00	era  	pr0|2		= 400000000000
001136  aa  6 00501 7551 00	sta  	pr6|321
001137  aa   000024 6000 04	tze  	20,ic		001163
001140  aa  6 00125 2361 00	ldq  	pr6|85		pv_alloc_x
001141  aa  6 00123 1161 00	cmpq 	pr6|83		n_pvs
001142  aa   000021 6050 04	tpl  	17,ic		001163
						STATEMENT 1 ON LINE 350
		working_sum = working_sum + pv_alloc (pv_alloc_x).fract_empty;

001143  aa   000001 7360 00	qls  	1
001144  aa   000000 6270 06	eax7 	0,ql
001145  aa  6 00120 2351 00	lda  	pr6|80		working_sum
001146  aa   000044 7330 00	lrs  	36
001147  aa  6 00464 3735 20	epp7 	pr6|308,*
001150  aa  7 77777 0331 17	adl  	pr7|-1,7		pv_alloc.fract_empty
001151  aa  6 00120 7561 00	stq  	pr6|80		working_sum
						STATEMENT 1 ON LINE 351
		if working_sum >= random_number then do;

001152  aa  6 00500 7471 00	stx7 	pr6|320
001153  aa  6 00121 1161 00	cmpq 	pr6|81		random_number
001154  aa   000005 6040 04	tmi  	5,ic		001161
						STATEMENT 1 ON LINE 352
		     pv_found = "1"b;

001155  aa   400000 2350 03	lda  	131072,du
001156  aa  6 00124 7551 00	sta  	pr6|84		pv_found
						STATEMENT 1 ON LINE 353
		     pvtx = pv_alloc (pv_alloc_x).pvtx;

001157  aa  7 77776 2361 17	ldq  	pr7|-2,7		pv_alloc.pvtx
001160  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 354
		end;

						STATEMENT 1 ON LINE 355
	     end;

001161  aa  6 00125 0541 00	aos  	pr6|85		pv_alloc_x
001162  aa   777752 7100 04	tra  	-22,ic		001134
						STATEMENT 1 ON LINE 356
	     if ^pv_found then pvtx = pv_alloc (n_pvs).pvtx;

001163  aa   400000 3150 03	cana 	131072,du
001164  aa   000006 6000 04	tze  	6,ic		001172
001165  aa  6 00123 2361 00	ldq  	pr6|83		n_pvs
001166  aa   000001 7360 00	qls  	1
001167  aa  6 00464 3735 20	epp7 	pr6|308,*
001170  aa  7 77776 2361 06	ldq  	pr7|-2,ql		pv_alloc.pvtx
001171  aa  6 00102 7561 00	stq  	pr6|66		pvtx
						STATEMENT 1 ON LINE 357
	end;

						STATEMENT 1 ON LINE 361
	if pvtx = -1 then
	     do ;

001172  aa  6 00102 2361 00	ldq  	pr6|66		pvtx
001173  aa   000247 1160 04	cmpq 	167,ic		001442 = 777777777777
001174  aa   000014 6010 04	tnz  	12,ic		001210
						STATEMENT 1 ON LINE 363
no_room:	     vtocx = -1;

001175  aa   000001 3360 07	lcq  	1,dl
001176  aa  6 00032 3735 20	epp7 	pr6|26,*
001177  aa  7 00006 7561 20	stq  	pr7|6,*		vtocx
						STATEMENT 1 ON LINE 364
	     pvid = "0"b;

001200  aa  7 00004 3715 20	epp5 	pr7|4,*
001201  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001202  aa   000000 00 0000	descb	0,0
001203  aa  5 00000 00 0044	descb	pr5|0,36		pvid
						STATEMENT 1 ON LINE 365
	     code = error_table_$log_vol_full;

001204  aa  6 00044 3701 20	epp4 	pr6|36,*
001205  la  4 00020 2361 20	ldq  	pr4|16,*		error_table_$log_vol_full
001206  aa  7 00010 7561 20	stq  	pr7|8,*		code
						STATEMENT 1 ON LINE 366
	     return;

001207  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 367
	end;

						STATEMENT 1 ON LINE 369
got:	pvtep = addr (pvt_array (pvtx));

001210  aa  6 00102 2361 00	ldq  	pr6|66		pvtx
001211  aa   000034 4020 07	mpy  	28,dl
001212  aa  6 00456 3735 20	epp7 	pr6|302,*		pvt_arrayp
001213  aa  7 77744 3735 06	epp7 	pr7|-28,ql	pvt_array
001214  aa  6 00460 6535 00	spri7	pr6|304		pvtep
						STATEMENT 1 ON LINE 370
	if pvte.lvid ^= lvid then go to retry;

001215  aa  7 00001 2351 00	lda  	pr7|1		pvte.lvid
001216  aa  6 00116 1151 00	cmpa 	pr6|78		lvid
001217  aa   777376 6010 04	tnz  	-258,ic		000615
						STATEMENT 1 ON LINE 371
	pvid = pvte.pvid;

001220  aa  6 00032 3715 20	epp5 	pr6|26,*
001221  aa  5 00004 3535 20	epp3 	pr5|4,*
001222  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001223  aa  7 00000 00 0044	descb	pr7|0,36		pvte.pvid
001224  aa  3 00000 00 0044	descb	pr3|0,36		pvid
						STATEMENT 1 ON LINE 374
	call get_pvtx$hold_pvtx ((pvid), pvtx, code);

001225  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001226  aa  3 00000 00 0044	descb	pr3|0,36		pvid
001227  aa  6 00501 00 0044	descb	pr6|321,36
001230  aa  6 00501 3521 00	epp2 	pr6|321
001231  aa  6 00504 2521 00	spri2	pr6|324
001232  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001233  aa  6 00506 2521 00	spri2	pr6|326
001234  aa  5 00010 3521 20	epp2 	pr5|8,*		code
001235  aa  6 00510 2521 00	spri2	pr6|328
001236  aa  6 00502 6211 00	eax1 	pr6|322
001237  aa   014000 4310 07	fld  	6144,dl
001240  aa  6 00044 3701 20	epp4 	pr6|36,*
001241  la  4 00054 3521 20	epp2 	pr4|44,*		get_pvtx$hold_pvtx
001242  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 375
	if code ^= 0 then goto not_there;

001243  aa  6 00032 3735 20	epp7 	pr6|26,*
001244  aa  7 00010 2361 20	ldq  	pr7|8,*		code
001245  aa   000033 6010 04	tnz  	27,ic		001300
						STATEMENT 1 ON LINE 376
	held = "1"b;

001246  aa   400000 2350 03	lda  	131072,du
001247  aa  6 00112 7551 00	sta  	pr6|74		held
						STATEMENT 1 ON LINE 378
	vtocx = vtoc_man$alloc_and_put_vtoce ((pvid), pvtx, addr (local_vtoce), code);

001250  aa  7 00004 3715 20	epp5 	pr7|4,*
001251  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001252  aa  5 00000 00 0044	descb	pr5|0,36		pvid
001253  aa  6 00501 00 0044	descb	pr6|321,36
001254  aa  6 00126 3535 00	epp3 	pr6|86		local_vtoce
001255  aa  6 00472 2535 00	spri3	pr6|314
001256  aa  6 00501 3521 00	epp2 	pr6|321
001257  aa  6 00542 2521 00	spri2	pr6|354
001260  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001261  aa  6 00544 2521 00	spri2	pr6|356
001262  aa  6 00472 3521 00	epp2 	pr6|314
001263  aa  6 00546 2521 00	spri2	pr6|358
001264  aa  7 00010 3521 20	epp2 	pr7|8,*		code
001265  aa  6 00550 2521 00	spri2	pr6|360
001266  aa  7 00006 3521 20	epp2 	pr7|6,*		vtocx
001267  aa  6 00552 2521 00	spri2	pr6|362
001270  aa  6 00540 6211 00	eax1 	pr6|352
001271  aa   024000 4310 07	fld  	10240,dl
001272  aa  6 00044 3701 20	epp4 	pr6|36,*
001273  la  4 00040 3521 20	epp2 	pr4|32,*		vtoc_man$alloc_and_put_vtoce
001274  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 379
	if code ^= 0 then do;

001275  aa  6 00032 3735 20	epp7 	pr6|26,*
001276  aa  7 00010 2361 20	ldq  	pr7|8,*		code
001277  aa   000030 6000 04	tze  	24,ic		001327
						STATEMENT 1 ON LINE 380
not_there:
	     vtocx = -1;

001300  aa   000001 3360 07	lcq  	1,dl
001301  aa  7 00006 7561 20	stq  	pr7|6,*		vtocx
						STATEMENT 1 ON LINE 382
	     if held then call get_pvtx$release_pvtx ((pvid), pvtx);

001302  aa  6 00112 2351 00	lda  	pr6|74		held
001303  aa   000016 6000 04	tze  	14,ic		001321
001304  aa  7 00004 3715 20	epp5 	pr7|4,*
001305  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001306  aa  5 00000 00 0044	descb	pr5|0,36		pvid
001307  aa  6 00501 00 0044	descb	pr6|321,36
001310  aa  6 00501 3521 00	epp2 	pr6|321
001311  aa  6 00504 2521 00	spri2	pr6|324
001312  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001313  aa  6 00506 2521 00	spri2	pr6|326
001314  aa  6 00502 6211 00	eax1 	pr6|322
001315  aa   010000 4310 07	fld  	4096,dl
001316  aa  6 00044 3701 20	epp4 	pr6|36,*
001317  la  4 00056 3521 20	epp2 	pr4|46,*		get_pvtx$release_pvtx
001320  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 383
	     pvid = "0"b;

001321  aa  6 00032 3735 20	epp7 	pr6|26,*
001322  aa  7 00004 3715 20	epp5 	pr7|4,*
001323  aa  003 100 060 400	csl  	(),(pr),fill(0),bool(move)
001324  aa   000000 00 0000	descb	0,0
001325  aa  5 00000 00 0044	descb	pr5|0,36		pvid
						STATEMENT 1 ON LINE 384
	     return;

001326  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 385
	end;

						STATEMENT 1 ON LINE 386
	if vtocx = -1 then do;

001327  aa  7 00006 2361 20	ldq  	pr7|6,*		vtocx
001330  aa   000112 1160 04	cmpq 	74,ic		001442 = 777777777777
001331  aa   000021 6010 04	tnz  	17,ic		001352
						STATEMENT 1 ON LINE 388
	     if held then call get_pvtx$release_pvtx ((pvid), pvtx);

001332  aa  6 00112 2351 00	lda  	pr6|74		held
001333  aa   777262 6000 04	tze  	-334,ic		000615
001334  aa  7 00004 3715 20	epp5 	pr7|4,*
001335  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001336  aa  5 00000 00 0044	descb	pr5|0,36		pvid
001337  aa  6 00501 00 0044	descb	pr6|321,36
001340  aa  6 00501 3521 00	epp2 	pr6|321
001341  aa  6 00504 2521 00	spri2	pr6|324
001342  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001343  aa  6 00506 2521 00	spri2	pr6|326
001344  aa  6 00502 6211 00	eax1 	pr6|322
001345  aa   010000 4310 07	fld  	4096,dl
001346  aa  6 00044 3701 20	epp4 	pr6|36,*
001347  la  4 00056 3521 20	epp2 	pr4|46,*		get_pvtx$release_pvtx
001350  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 389
	     goto retry;

001351  aa   777244 7100 04	tra  	-348,ic		000615
						STATEMENT 1 ON LINE 390
	end;

						STATEMENT 1 ON LINE 391
	call dbm_man$set_incr (pvtx, vtocx, code);

001352  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001353  aa  6 00504 2521 00	spri2	pr6|324
001354  aa  7 00006 3521 20	epp2 	pr7|6,*		vtocx
001355  aa  6 00506 2521 00	spri2	pr6|326
001356  aa  7 00010 3521 20	epp2 	pr7|8,*		code
001357  aa  6 00510 2521 00	spri2	pr6|328
001360  aa  6 00502 6211 00	eax1 	pr6|322
001361  aa   014000 4310 07	fld  	6144,dl
001362  aa  6 00044 3701 20	epp4 	pr6|36,*
001363  la  4 00060 3521 20	epp2 	pr4|48,*		dbm_man$set_incr
001364  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 393
	call get_pvtx$release_pvtx ((pvid), pvtx);

001365  aa  6 00032 3735 20	epp7 	pr6|26,*
001366  aa  7 00004 3715 20	epp5 	pr7|4,*
001367  aa  003 100 060 500	csl  	(pr),(pr),fill(0),bool(move)
001370  aa  5 00000 00 0044	descb	pr5|0,36		pvid
001371  aa  6 00501 00 0044	descb	pr6|321,36
001372  aa  6 00501 3521 00	epp2 	pr6|321
001373  aa  6 00504 2521 00	spri2	pr6|324
001374  aa  6 00102 3521 00	epp2 	pr6|66		pvtx
001375  aa  6 00506 2521 00	spri2	pr6|326
001376  aa  6 00502 6211 00	eax1 	pr6|322
001377  aa   010000 4310 07	fld  	4096,dl
001400  aa  6 00044 3701 20	epp4 	pr6|36,*
001401  la  4 00056 3521 20	epp2 	pr4|46,*		get_pvtx$release_pvtx
001402  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 395
	if mover then corout_pvtx = pvtx;

001403  aa  6 00106 2351 00	lda  	pr6|70		mover
001404  aa   000004 6000 04	tze  	4,ic		001410
001405  aa  6 00102 2361 00	ldq  	pr6|66		pvtx
001406  aa  6 00032 3735 20	epp7 	pr6|26,*
001407  aa  7 00012 7561 20	stq  	pr7|10,*		corout_pvtx
						STATEMENT 1 ON LINE 396
	return;

001410  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO createv_for_segmove                                STATEMENT 1 ON LINE 409
createv_for_segmove: entry (branchp, pvid, vtocx, code,	/* as regular */
	     corout_pvtx,				/* control state/pvtx answer */
	     a_skip_pvtx,				/* original pvtx, do not use */
	     a_nreq,				/* number or records needed */
	     tq_infop,				/* ptr to tq_info structure (null if no term quota) */
	     a_optimize);

001411  at     000011000013
001412  tt     000012000011
001413  tt     000010000011
001414  tt     000011000011
001415  tt     000013000007
001416  ta     001411000000
001417  da     000360300000
001420  aa   000620 6270 00	eax7 	400
001421  aa  7 00034 3521 20	epp2 	pr7|28,*
001422  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
001423  aa     000022000000
001424  aa     000000000000
001425  aa   776407 7000 04	tsx0 	-761,ic		000034
						STATEMENT 1 ON LINE 417
	skip_pvtx = a_skip_pvtx;

001426  aa  6 00032 3735 20	epp7 	pr6|26,*
001427  aa  7 00014 2361 20	ldq  	pr7|12,*		a_skip_pvtx
001430  aa  6 00100 7561 00	stq  	pr6|64		skip_pvtx
						STATEMENT 1 ON LINE 418
	nreq = a_nreq;

001431  aa  7 00016 2361 20	ldq  	pr7|14,*		a_nreq
001432  aa  6 00105 7561 00	stq  	pr6|69		nreq
						STATEMENT 1 ON LINE 419
	mover = "1"b;

001433  aa   400000 2350 03	lda  	131072,du
001434  aa  6 00106 7551 00	sta  	pr6|70		mover
						STATEMENT 1 ON LINE 420
	optimizing = a_optimize;

001435  aa  7 00022 2351 20	lda  	pr7|18,*		a_optimize
001436  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
001437  aa  6 00115 7551 00	sta  	pr6|77		optimizing
						STATEMENT 1 ON LINE 421
	go to join;

001440  aa   776424 7100 04	tra  	-748,ic		000064
						STATEMENT 1 ON LINE 450
     end create_vtoce;

  END PROCEDURE create_vtoce


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
