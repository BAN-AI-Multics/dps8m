	COMPILATION LISTING OF SEGMENT acl_
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  1010.8 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 acl_: proc;					/* performs function on a specified acl entry */
       14 
       15 /* Converted to v2 by E. Stone 12/73 */
       16 /* Modified by e Stone Nov 1974 to fix a bug in deleting whole acl */
       17 /* perm acls removed and new fields set 6/76 THVV */
       18 /* Modified 07/77 by THVV for bad_dir_ check */
       19 
       20 /*
       21*   entry:
       22*
       23*   add_entry(acl_start_ptr, acl_entry_ptr, a_add_sw, uid, code)
       24*
       25*   .  given the addr of the entry acl frp and the acl entry str , add to acl list or insert new mode.
       26*
       27*   del_entry(acl_start_ptr, acl_entry_ptr, code)
       28*
       29*   .  given the addr of the entry acl frp and the acl str (name components are used here) delete the
       30*   .  acl entry if it exists.
       31*
       32*   del_acl(acl_start_ptr, code)
       33*
       34*   .  delete the entire acl specified by the addr of the entry acl frp.
       35*
       36*   list_entry(acl_start_ptr, acl_entry_ptr, offset, code)
       37*
       38*   .  given the addr of the entry acl frp, then if offset ^= 0 then list the
       39*   .  offset'th acl entry in the str pointed to by acl_entry_ptr, else match the access name given
       40*   .  in the acl_entry_ptr structure and return the mode and ex_mode if a match exists.
       41*
       42*   Arguments:
       43*
       44*   1. acl_start_ptr ptr	points to the acl forward rel ptr in the entry.
       45*   2. acl_entry_ptr ptr	points to the following structure:
       46*   |	dcl 1 acl1 based aligned,
       47*   |	    2 ac_name,
       48*   |	    3 person char(32),
       49*   |	    3 project char(32),
       50*   |	    3 tag char(1),
       51*   |	    2 mode bit(36),
       52*   |	    2 ex_mode bit(36);
       53*   3. offset fixed bin	is used to specify which acl entry to list if the ac_name isn't used
       54*   .			as a matching criterion.
       55*   4. a_add_sw bit(1) aligned	used to indicate if added an acl entry (= "1"b) or just replaced mode (="0"b).
       56*   5. uid bit (36)		uid of owning entry
       57*   6. code fixed bin(35)	standard error code.
       58*
       59**/
       60 
       61 dcl  a_offset fixed bin;				/* parameter */
       62 dcl  entry_uid bit (36) aligned;			/* parameter */
       63 dcl  entry_acl_count fixed bin;			/* Parameter */
       64 dcl  code fixed bin (35);				/* parameter */
       65 dcl (acl_start_ptr, acl_entry_ptr) ptr;			/* parameter */
       66 dcl  a_add_sw bit (1);				/* parameter */
       67 
       68 dcl 1 ptr_list based aligned,				/* dummy overlay for frp and brp */
       69     2 frp bit (18) unaligned,
       70     2 brp bit (18) unaligned;
       71 
       72 dcl 1 acl1 based (acl_entry_ptr) aligned,
       73     2 ac_name,
       74       3 person char (32),
       75       3 project char (32),
       76       3 tag char (1),
       77     2 mode bit (36),
       78     2 ex_mode bit (36);
       79 
       80 dcl (i, offset, point) fixed bin;
       81 dcl  np ptr;
       82 dcl  area_ptr ptr;
       83 dcl (rp, next_aclrp) bit (18) aligned;
       84 
       85 dcl  acc_list_$match ext entry (fixed bin, bit (36) aligned, ptr, ptr, ptr, fixed bin, fixed bin (35));
       86 dcl  acc_name_$delete ext entry (ptr);
       87 dcl  acc_name_$encode ext entry (ptr, ptr, fixed bin (35));
       88 dcl (fs_alloc$alloc, fs_alloc$free) ext entry (ptr, fixed bin, ptr);
       89 
       90 dcl (error_table_$user_not_found, error_table_$empty_acl) ext fixed bin (35);
       91 dcl (error_table_$argerr, error_table_$noalloc) ext fixed bin (35) ext;
       92 dcl  active_hardcore_data$aclsize ext fixed bin;
       93 
       94 dcl (addr, addrel, null, rel, ptr, unspec) builtin;
       95 dcl  bad_dir_ condition;
       96 
  1     1 /* BEGIN INCLUDE FILE ... fs_types.incl.pl1 */
  1     2 
  1     3 dcl  ACCESS_NAME_TYPE bit (18) static options (constant) init ("000001"b3);
  1     4 dcl  ACLE_TYPE bit (18) static options (constant) init ("000002"b3);
  1     5 dcl  DIR_HEADER_TYPE bit (18) static options (constant) init ("000003"b3);
  1     6 dcl  DIR_TYPE bit (18) static options (constant) init ("000004"b3);
  1     7 dcl  LINK_TYPE bit (18) static options (constant) init ("000005"b3);
  1     8 dcl  NAME_TYPE bit (18) static options (constant) init ("000006"b3);
  1     9 dcl  SEG_TYPE bit (18) static options (constant) init ("000007"b3);
  1    10 dcl  HASH_TABLE_TYPE bit (18) static options (constant) init ("000013"b3);
  1    11 
  1    12 dcl  access_name_type fixed bin static options (constant) init (1);
  1    13 dcl  acle_type fixed bin static options (constant) init (2);
  1    14 dcl  dir_header_type fixed bin static options (constant) init (3);
  1    15 dcl  dir_type fixed bin static options (constant) init (4);
  1    16 dcl  link_type fixed bin static options (constant) init (5);
  1    17 dcl  name_type fixed bin static options (constant) init (6);
  1    18 dcl  seg_type fixed bin static options (constant) init (7);
  1    19 dcl  hash_table_type fixed bin static options (constant) init (11);
  1    20 
  1    21 /* END INCLUDE FILE ... fs_types.incl.pl1 */
       97 
  2     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  2     2 /* Modified 8/74 for NSS */
  2     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  2     4 /* Modified 3/82 BIM for change pclock */
  2     5 /* format: style3 */
  2     6 
  2     7 /* Template for the directory header. Length = 64 words. */
  2     8 
  2     9 dcl  dp ptr;
  2    10 
  2    11 dcl 1 dir based (dp) aligned,
  2    12 
  2    13    2 modify bit (36),				/* Process ID of last modifier */
  2    14    2 type bit (18) unaligned,			/* type of object = dir header */
  2    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  2    16     2 dtc (3),					/* date-time checked by salvager array */
  2    17       3 date bit (36),				/* the date */
  2    18       3 error bit (36),				/* what errors were discovered */
  2    19 
  2    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  2    21 
  2    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  2    23 
  2    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  2    25 
  2    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  2    27 
  2    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  2    29     2 version_number fixed bin (17),			/* version number of header */
  2    30 
  2    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  2    32     2 pad2 bit (18),
  2    33 
  2    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  2    35     2 pad3 bit (18),
  2    36 
  2    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  2    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  2    39 
  2    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  2    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  2    42 
  2    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  2    44     2 dir_count fixed bin (17),			/* number of directory branches */
  2    45 
  2    46     2 lcount fixed bin (17),				/* number of links */
  2    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  2    48 
  2    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  2    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  2    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  2    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  2    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  2    54     2 pad4 bit (14),
  2    55 
  2    56     2 iacl_count (0:7),
  2    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  2    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  2    59 
  2    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  2    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  2    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  2    63 
  2    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  2    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  2    66 
  2    67     2 htsize fixed bin (17),				/* size of hash table */
  2    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  2    69 
  2    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  2    71     2 pad6 fixed bin (17),
  2    72 
  2    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  2    74     2 pad7 bit (18)) unaligned,
  2    75 
  2    76     2 dts bit (36),					/* date-time directory last salvaged */
  2    77 
  2    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  2    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  2    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  2    81     2 checksum bit (36),				/* checksummed from uid on */
  2    82     2 owner bit (36);				/* uid of parent dir */
  2    83 
  2    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  2    85 
  2    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
       98 
  3     1 /*     BEGIN INCLUDE FILE ... dir_acl.incl.pl1 ... last modified Nov 1975 for nss */
  3     2 
  3     3 /* Template for an ACL entry. Length = 8 words */
  3     4 
  3     5 dcl aclep ptr;
  3     6 
  3     7 dcl 1 acl_entry based (aclep) aligned,			/* length is 8 words */
  3     8     2 frp bit(18) unaligned,				/* rel ptr to next entry */
  3     9     2 brp bit(18) unaligned,				/* rel ptr to previous entry */
  3    10 
  3    11     2 type bit (18) unaligned,			/* type = dir acl */
  3    12     2 size fixed bin (17) unaligned,			/* size of acl entry */
  3    13 
  3    14 
  3    15     2 name unaligned,				/* user name associated with this ACL entry */
  3    16         3 pers_rp bit(18) unaligned,			/* name of user */
  3    17         3 proj_rp bit(18) unaligned,			/* project of user */
  3    18         3 tag char(1) unaligned,			/* tag of user */
  3    19     2 mode bit (3) unaligned,				/* mode for userid */
  3    20     2 pad24 bit(24) unaligned,
  3    21 
  3    22     2 ex_mode bit(36),				/* extended access modes */
  3    23 
  3    24     2 checksum bit (36),				/* checksum from acl_entry.name */
  3    25     2  owner bit (36);				/* uid of owning entry */
  3    26 
  3    27 /* Template for a person or project name on ACL. Length = 14 words. */
  3    28 
  3    29 dcl 1 access_name aligned based,			/* person or project name */
  3    30     2 frp bit(18) unaligned,				/* rel ptr to next name structure */
  3    31     2 brp bit(18) unaligned,				/* rel ptr to prev name structure */
  3    32 
  3    33     2 type bit (18) unaligned,			/* type = access name */
  3    34     2 size fixed bin (17) unaligned,			/* size of access name */
  3    35 
  3    36     2 salv_flag fixed bin(17) unaligned,		/* used by salvager to check for ascii names */
  3    37     2 usage fixed bin(17) unaligned,			/* number of ACL entries that refer to this name */
  3    38 
  3    39     2 pad1 bit (36),
  3    40 
  3    41     2 name char(32) aligned,				/* person or project name itself */
  3    42 
  3    43     2 checksum bit (36),				/* checksum from salv_flag */
  3    44 
  3    45     2 owner bit (36);				/* uid of containing directory */
  3    46 
  3    47 /*     END INCLUDE FILE ... dir_acl.incl.pl1 */
       99 
      100 /*  */
      101 
      102 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      103 
      104 list_entry: entry (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr, a_offset, code);
      105 
      106 	code = 0;
      107 	point = a_offset;
      108 
      109 	if point = 0 then do;			/* want to match entry */
      110 	     call acc_list_$match (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr,
      111 		aclep, a_offset, code);
      112 	     if code ^= 0 then return;
      113 						/* a normal match return */
      114 	     acl_entry_ptr -> acl1.mode = aclep -> acl_entry.mode;
      115 	     acl_entry_ptr -> acl1.ex_mode = aclep -> acl_entry.ex_mode;
      116 	     return;
      117 
      118 	end;
      119 						/* now for given index case */
      120 	aclep = acl_start_ptr;
      121 
      122 	do i = 1 to point;
      123 	     if aclep -> acl_entry.frp = "0"b then do;
      124 		a_offset = i;
      125 		code = error_table_$argerr;
      126 		return;
      127 	     end;
      128 
      129 	     aclep = ptr (aclep, aclep -> acl_entry.frp); /* move to next entry */
      130 	end;
      131 
      132 
      133 	if aclep -> acl_entry.name.pers_rp = "0"b then acl_entry_ptr -> acl1.ac_name.person = "*";
      134 	else acl_entry_ptr -> acl1.ac_name.person = ptr (aclep, aclep -> acl_entry.name.pers_rp) -> access_name.name;
      135 	if aclep -> acl_entry.name.proj_rp = "0"b then acl_entry_ptr -> acl1.ac_name.project = "*";
      136 	else acl_entry_ptr -> acl1.ac_name.project = ptr (aclep, aclep -> acl_entry.name.proj_rp) -> access_name.name;
      137 	acl_entry_ptr -> acl1.ac_name.tag = aclep -> acl_entry.name.tag;
      138 	acl_entry_ptr -> acl1.mode = aclep -> acl_entry.mode;
      139 	acl_entry_ptr -> acl1.ex_mode = aclep -> acl_entry.ex_mode;
      140 
      141 	return;
      142 
      143 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      144 /*  */
      145 del_entry: entry (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr, code);
      146 
      147 /* First the correct acl entry is found, then if it
      148*   is allocated the space is freed, while special casing
      149*   last, only, and first acl entry. */
      150 
      151 	code = 0;
      152 
      153 	dp = ptr (acl_start_ptr, 0);
      154 	area_ptr = ptr (dp, dp -> dir.arearp);
      155 
      156 	call acc_list_$match (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr, aclep, point, code);
      157 						/* point has the offset value of where match occured */
      158 	if code ^= 0 then return;
      159 
      160 	call acc_name_$delete (addr (aclep -> acl_entry.name));
      161 
      162 	if aclep -> acl_entry.frp = "0"b then do;	/* End of list. */
      163 	     if aclep -> acl_entry.brp = "0"b then do;	/* only reset acl frp if no prev slots */
      164 		acl_start_ptr -> ptr_list.frp,
      165 		     acl_start_ptr -> ptr_list.brp = "0"b;
      166 	     end;
      167 	     else do;
      168 		ptr (aclep, aclep -> acl_entry.brp) -> acl_entry.frp = "0"b;
      169 		acl_start_ptr -> ptr_list.brp = aclep -> acl_entry.brp;
      170 	     end;
      171 	end;
      172 	else do;
      173 	     ptr (aclep, aclep -> acl_entry.frp) -> acl_entry.brp = aclep -> acl_entry.brp;
      174 	     if aclep -> acl_entry.brp = "0"b then acl_start_ptr -> ptr_list.frp = aclep -> acl_entry.frp;
      175 	     else ptr (aclep, aclep -> acl_entry.brp) -> acl_entry.frp = aclep -> acl_entry.frp;
      176 	end;
      177 
      178 	call fs_alloc$free (area_ptr, active_hardcore_data$aclsize, aclep);
      179 
      180 	return;
      181 
      182 /*  *  *  *  *  *  *  *  *  *  *  *  */
      183 
      184 del_acl:	entry (entry_acl_count, entry_uid, acl_start_ptr); /* delete whole acl */
      185 
      186 	if acl_start_ptr -> ptr_list.brp = "0"b then return; /* empty acl */
      187 
      188 	dp = ptr (acl_start_ptr, 0);
      189 	area_ptr = ptr (dp, dp -> dir.arearp);
      190 
      191 	i = 0;
      192 	do rp = acl_start_ptr -> acl_entry.frp repeat next_aclrp while (rp);
      193 	     aclep = ptr (dp, rp);
      194 	     i = i + 1;
      195 	     if i > entry_acl_count
      196 	     | aclep -> acl_entry.owner ^= entry_uid
      197 	     | aclep -> acl_entry.type ^= ACLE_TYPE then signal bad_dir_;
      198 	     call acc_name_$delete (addr (aclep -> acl_entry.name));
      199 
      200 	     next_aclrp = aclep -> acl_entry.frp;	/* get offset of next acl before freeing */
      201 
      202 	     call fs_alloc$free (area_ptr, active_hardcore_data$aclsize, aclep);
      203 
      204 	end;					/* i loop */
      205 
      206 	acl_start_ptr -> ptr_list.frp,		/* adjust start ptrs */
      207 	     acl_start_ptr -> ptr_list.brp = "0"b;
      208 	return;
      209 
      210 /*  */
      211 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      212 
      213 add_entry: entry (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr, a_add_sw, code);
      214 						/* add or replace an acl */
      215 
      216 /* First an empty acl is handled, then adding to the bottom
      217*   of the list, then inserting into the list. */
      218 
      219 	code = 0;
      220 	dp = ptr (acl_start_ptr, 0);
      221 	area_ptr = ptr (dp, dp -> dir.arearp);
      222 	a_add_sw = "0"b;
      223 
      224 	call acc_list_$match (entry_acl_count, entry_uid, acl_start_ptr, acl_entry_ptr, np, (0), code);
      225 	if code = 0 then do;			/* a normal replacement of mode */
      226 	     np -> acl_entry.mode = acl_entry_ptr -> acl1.mode;
      227 	     np -> acl_entry.ex_mode = acl_entry_ptr -> acl1.ex_mode;
      228 	     return;
      229 	end;
      230 	else if code = error_table_$empty_acl | code = error_table_$user_not_found then do;
      231 	     call fs_alloc$alloc (area_ptr, active_hardcore_data$aclsize, aclep);
      232 	     if aclep = null then go to alloc_err;
      233 	     if code = error_table_$empty_acl then do;
      234 		acl_start_ptr -> ptr_list.frp, acl_start_ptr -> ptr_list.brp = rel (aclep);
      235 		aclep -> acl_entry.frp, aclep -> acl_entry.brp = "0"b;
      236 	     end;
      237 	     else if np = null then do;		/* must add to end of list */
      238 		np = ptr (dp, acl_start_ptr -> ptr_list.brp);
      239 						/* move to last entry */
      240 		acl_start_ptr -> ptr_list.brp = rel (aclep);
      241 		np -> acl_entry.frp = rel (aclep);
      242 		aclep -> acl_entry.frp = "0"b;
      243 		aclep -> acl_entry.brp = rel (np);
      244 	     end;
      245 	     else do;				/* an insertion, add before entry ptd to */
      246 		aclep -> acl_entry.frp = rel (np);
      247 		aclep -> acl_entry.brp = np -> acl_entry.brp;
      248 		if aclep -> acl_entry.brp = "0"b then acl_start_ptr -> ptr_list.frp = rel (aclep);
      249 		else ptr (aclep, aclep -> acl_entry.brp) -> acl_entry.frp = rel (aclep);
      250 		np -> acl_entry.brp = rel (aclep);
      251 	     end;
      252 	end;
      253 	else return;				/* some other code */
      254 
      255 	a_add_sw = "1"b;				/* set to indicate entry added */
      256 	aclep -> acl_entry.type = ACLE_TYPE;
      257 	aclep -> acl_entry.size = active_hardcore_data$aclsize;
      258 	aclep -> acl_entry.owner = entry_uid;
      259 	call acc_name_$encode (addr (aclep -> acl_entry.name), acl_entry_ptr, code);
      260 	if code ^= 0 then return;
      261 
      262 	aclep -> acl_entry.mode = acl_entry_ptr -> acl1.mode;
      263 	aclep -> acl_entry.ex_mode = acl_entry_ptr -> acl1.ex_mode;
      264 	return;
      265 
      266 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      267 
      268 alloc_err:
      269 	code = error_table_$noalloc;
      270 	return;
      271 
      272      end acl_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0839.4  acl_.pl1                          >special_ldd>install>MR12.3-1114>acl_.pl1
97           1    05/26/77  0922.2  fs_types.incl.pl1                 >ldd>include>fs_types.incl.pl1
98           2    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
99           3    04/29/76  1048.9  dir_acl.incl.pl1                  >ldd>include>dir_acl.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACLE_TYPE                              constant        bit(18)                  initial packed unaligned dcl 1-4 ref 195 256
a_add_sw                               parameter       bit(1)                   packed unaligned dcl 66 set ref 213 222* 255*
a_offset                               parameter       fixed bin(17,0)          dcl 61 set ref 104 107 110* 124*
ac_name                                based           structure                level 2 dcl 72
acc_list_$match                 000010 constant        entry                    external dcl 85 ref 110 156 224
acc_name_$delete                000012 constant        entry                    external dcl 86 ref 160 198
acc_name_$encode                000014 constant        entry                    external dcl 87 ref 259
access_name                            based           structure                level 1 dcl 3-29
acl1                                   based           structure                level 1 dcl 72
acl_entry                              based           structure                level 1 dcl 3-7
acl_entry_ptr                          parameter       pointer                  dcl 65 set ref 104 110* 114 115 133 134 135 136 137
                                                                                  138 139 145 156* 213 224* 226 227 259* 262 263
acl_start_ptr                          parameter       pointer                  dcl 65 set ref 104 110* 120 145 153 156* 164 164 169
                                                                                  174 184 186 188 192 206 206 213 220 224* 234 234
                                                                                  238 240 248
aclep                           000120 automatic       pointer                  dcl 3-5 set ref 110* 114 115 120* 123 129* 129 129
                                                                                  133 134 134 135 136 136 137 138 139 156* 160 160
                                                                                  162 163 168 168 169 173 173 173 174 174 175 175
                                                                                  175 178* 193* 195 195 198 198 200 202* 231* 232
                                                                                  234 235 235 240 241 242 243 246 247 248 248 249
                                                                                  249 249 250 256 257 258 259 259 262 263
active_hardcore_data$aclsize    000032 external static fixed bin(17,0)          dcl 92 set ref 178* 202* 231* 257
addr                                                   builtin function         dcl 94 ref 160 160 198 198 259 259
area_ptr                        000104 automatic       pointer                  dcl 82 set ref 154* 178* 189* 202* 221* 231*
arearp                   24            based           bit(18)                  level 2 packed packed unaligned dcl 2-11 ref 154 189
                                                                                  221
bad_dir_                        000110 stack reference condition                dcl 95 ref 195
brp                       0(18)        based           bit(18)                  level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 3-7 in procedure "acl_" set ref 163
                                                                                  168 169 173* 173 174 175 235* 243* 247* 247 248
                                                                                  249 250*
brp                       0(18)        based           bit(18)                  level 2 in structure "ptr_list" packed packed
                                                                                  unaligned dcl 68 in procedure "acl_" set ref 164*
                                                                                  169* 186 206* 234* 238 240*
code                                   parameter       fixed bin(35,0)          dcl 64 set ref 104 106* 110* 112 125* 145 151* 156*
                                                                                  158 213 219* 224* 225 230 230 233 259* 260 268*
dir                                    based           structure                level 1 dcl 2-11
dp                              000116 automatic       pointer                  dcl 2-9 set ref 153* 154 154 188* 189 189 193 220*
                                                                                  221 221 238
entry_acl_count                        parameter       fixed bin(17,0)          dcl 63 set ref 104 110* 145 156* 184 195 213 224*
entry_uid                              parameter       bit(36)                  dcl 62 set ref 104 110* 145 156* 184 195 213 224*
                                                                                  258
error_table_$argerr             000026 external static fixed bin(35,0)          dcl 91 ref 125
error_table_$empty_acl          000024 external static fixed bin(35,0)          dcl 90 ref 230 233
error_table_$noalloc            000030 external static fixed bin(35,0)          dcl 91 ref 268
error_table_$user_not_found     000022 external static fixed bin(35,0)          dcl 90 ref 230
ex_mode                   4            based           bit(36)                  level 2 in structure "acl_entry" dcl 3-7
                                                                                  in procedure "acl_" set ref 115 139 227* 263*
ex_mode                  22            based           bit(36)                  level 2 in structure "acl1" dcl 72 in procedure
                                                                                  "acl_" set ref 115* 139* 227 263
frp                                    based           bit(18)                  level 2 in structure "ptr_list" packed packed
                                                                                  unaligned dcl 68 in procedure "acl_" set ref 164*
                                                                                  174* 206* 234* 248*
frp                                    based           bit(18)                  level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 3-7 in procedure "acl_" set ref 123
                                                                                  129 162 168* 173 174 175* 175 192 200 235* 241*
                                                                                  242* 246* 249*
fs_alloc$alloc                  000016 constant        entry                    external dcl 88 ref 231
fs_alloc$free                   000020 constant        entry                    external dcl 88 ref 178 202
i                               000100 automatic       fixed bin(17,0)          dcl 80 set ref 122* 124* 191* 194* 194 195
mode                     21            based           bit(36)                  level 2 in structure "acl1" dcl 72 in procedure
                                                                                  "acl_" set ref 114* 138* 226 262
mode                      3(09)        based           bit(3)                   level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 3-7 in procedure "acl_" set ref 114
                                                                                  138 226* 262*
name                      2            based           structure                level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 3-7 in procedure "acl_" set ref 160
                                                                                  160 198 198 259 259
name                      4            based           char(32)                 level 2 in structure "access_name" dcl 3-29
                                                                                  in procedure "acl_" ref 134 136
next_aclrp                      000107 automatic       bit(18)                  dcl 83 set ref 200* 204
np                              000102 automatic       pointer                  dcl 81 set ref 224* 226 227 237 238* 241 243 246 247
                                                                                  250
null                                                   builtin function         dcl 94 ref 232 237
owner                     6            based           bit(36)                  level 2 dcl 3-7 set ref 195 258*
pers_rp                   2            based           bit(18)                  level 3 packed packed unaligned dcl 3-7 set ref 133
                                                                                  134
person                                 based           char(32)                 level 3 dcl 72 set ref 133* 134*
point                           000101 automatic       fixed bin(17,0)          dcl 80 set ref 107* 109 122 156*
proj_rp                   2(18)        based           bit(18)                  level 3 packed packed unaligned dcl 3-7 set ref 135
                                                                                  136
project                  10            based           char(32)                 level 3 dcl 72 set ref 135* 136*
ptr                                                    builtin function         dcl 94 ref 129 134 136 153 154 168 173 175 188 189
                                                                                  193 220 221 238 249
ptr_list                               based           structure                level 1 dcl 68
rel                                                    builtin function         dcl 94 ref 234 240 241 243 246 248 249 250
rp                              000106 automatic       bit(18)                  dcl 83 set ref 192* 192* 193*
size                      1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 3-7 set ref 257*
tag                       3            based           char(1)                  level 3 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 3-7 in procedure "acl_" set ref 137
tag                      20            based           char(1)                  level 3 in structure "acl1" dcl 72 in procedure
                                                                                  "acl_" set ref 137*
type                      1            based           bit(18)                  level 2 packed packed unaligned dcl 3-7 set ref 195
                                                                                  256*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACCESS_NAME_TYPE                       internal static bit(18)                  initial packed unaligned dcl 1-3
DIR_HEADER_TYPE                        internal static bit(18)                  initial packed unaligned dcl 1-5
DIR_TYPE                               internal static bit(18)                  initial packed unaligned dcl 1-6
HASH_TABLE_TYPE                        internal static bit(18)                  initial packed unaligned dcl 1-10
LINK_TYPE                              internal static bit(18)                  initial packed unaligned dcl 1-7
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 1-8
SEG_TYPE                               internal static bit(18)                  initial packed unaligned dcl 1-9
access_name_type                       internal static fixed bin(17,0)          initial dcl 1-12
acle_type                              internal static fixed bin(17,0)          initial dcl 1-13
addrel                                                 builtin function         dcl 94
dir_header_type                        internal static fixed bin(17,0)          initial dcl 1-14
dir_type                               internal static fixed bin(17,0)          initial dcl 1-15
hash_table_type                        internal static fixed bin(17,0)          initial dcl 1-19
link_type                              internal static fixed bin(17,0)          initial dcl 1-16
name_type                              internal static fixed bin(17,0)          initial dcl 1-17
offset                                 automatic       fixed bin(17,0)          dcl 80
seg_type                               internal static fixed bin(17,0)          initial dcl 1-18
unspec                                                 builtin function         dcl 94
version_number_2                       internal static fixed bin(17,0)          initial dcl 2-84

NAMES DECLARED BY EXPLICIT CONTEXT.
acl_                            000013 constant        entry                    external dcl 13
add_entry                       000520 constant        entry                    external dcl 213
alloc_err                       001003 constant        label                    dcl 268 ref 232
del_acl                         000377 constant        entry                    external dcl 184
del_entry                       000223 constant        entry                    external dcl 145
list_entry                      000027 constant        entry                    external dcl 104

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1172        1226    1010        1202
Length      1466    1010        34         223     162           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
acl_                                105 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
acl_                     000100 i                           acl_
                         000101 point                       acl_
                         000102 np                          acl_
                         000104 area_ptr                    acl_
                         000106 rp                          acl_
                         000107 next_aclrp                  acl_
                         000116 dp                          acl_
                         000120 aclep                       acl_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          signal_op           ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
acc_list_$match               acc_name_$delete              acc_name_$encode              fs_alloc$alloc
fs_alloc$free

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_hardcore_data$aclsize  error_table_$argerr           error_table_$empty_acl        error_table_$noalloc
error_table_$user_not_found




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     13 000012       104 000020       106 000037       107 000040       109 000043       110 000044       112 000066
    114 000070       115 000100       116 000102       120 000103       122 000106       123 000115       124 000121
    125 000124       126 000127       129 000130       130 000133       133 000135       134 000151       135 000161
    136 000173       137 000202       138 000207       139 000213       141 000215       145 000216       151 000233
    153 000234       154 000240       156 000245       158 000270       160 000272       162 000304       163 000310
    164 000314       166 000322       168 000323       169 000327       171 000334       173 000335       174 000341
    175 000353       178 000357       180 000372       184 000373       186 000404       188 000411       189 000413
    191 000420       192 000421       193 000426       194 000431       195 000432       198 000450       200 000462
    202 000465       204 000500       206 000503       208 000511       213 000512       219 000530       220 000531
    221 000535       222 000542       224 000546       225 000572       226 000574       227 000605       228 000607
    230 000610       231 000615       232 000627       233 000633       234 000637       235 000647       236 000653
    237 000654       238 000660       240 000667       241 000673       242 000675       243 000677       244 000703
    246 000704       247 000707       248 000712       249 000723       250 000727       252 000733       253 000734
    255 000735       256 000742       257 000745       258 000747       259 000751       260 000765       262 000767
    263 001000       264 001002       268 001003       270 001006


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
