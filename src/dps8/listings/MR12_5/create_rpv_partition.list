	COMPILATION LISTING OF SEGMENT create_rpv_partition
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 11/11/89  0959.6 mst Sat
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-05-13,GJohnson), approve(86-05-13,MCR7387),
       12*     audit(86-05-13,Martinson), install(86-05-14,MR12.0-1056):
       13*     Correct error message documentation.
       14*  2) change(86-05-29,Fawcett), approve(86-04-11,MCR7383),
       15*     audit(86-05-29,GDixon), install(86-07-17,MR12.0-1097):
       16*     Implement support of devices using 512 word IO.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 create_rpv_partition: proc (rpv_pvtx, rpv_labelp, n_records, part_name, code);
       20 
       21 /* routine to move pages around on the rpv (as yet not by any means
       22*accepted for paging) so as to be able to create the named partition.
       23*
       24*This program is very cautious about moving pages around and always writes
       25*everything once it modifies it.
       26*
       27*The idea is to find where the partition must go (high only), find segments
       28*with pages in that area, move them elsewhere, update their vtoces and file
       29*maps accordingly, and then get to updating the label to show the partition.
       30*
       31*Everything is done so as to be interruptable without affecting the state of
       32*the disk, with the possible exception of marking a few extra pages as used.
       33*
       34*Initially coded by Keith Loepere, March 1983, against everyone's better 
       35*judgment, including mine. */
       36 
       37 /* format: style4,indattr,ifthenstmt,ifthen,idind33,^indcomtxt */
       38 
       39 dcl  ME			        char (20) init ("create_rpv_partition") static options (constant);
       40 dcl  bit_map_string		        bit (32) var;	/* a word of a bit map; used for counting bits therein */
       41 dcl  bottom_to_vacate	        fixed bin;		/* lowest record in area to become new partition */
       42 dcl  code			        fixed bin (35) parameter; /* standard */
       43 dcl  error_table_$noalloc	        fixed bin (35) ext;
       44 dcl  filemap_checksum_	        entry (ptr, fixed bin, bit (36) aligned);
       45 dcl  first_free_rec		        fixed bin;		/* first record after low partitions */
       46 dcl  have_vtoce		        bit (1) aligned;	/* true => rpv_vtoce_page contains the current vtoce */
       47 dcl  last_free_rec		        fixed bin;		/* record just at start of high partitions */
       48 dcl  n_records		        fixed bin parameter;	/* how big to make partition */
       49 dcl  new_disk_record	        fixed bin;		/* record number to where to move page */
       50 dcl  old_disk_record	        fixed bin;		/* of page we are to move */
       51 dcl  part_name		        char (4) parameter;	/* for new partition */
       52 dcl  part_num		        fixed bin;		/* loop counter on partitions */
       53 dcl  read_disk$read_disk_no_test      entry (fixed bin, fixed bin, ptr, fixed bin (35));
       54 dcl  1 rpv_label		        aligned like label based (rpv_labelp); /* label of rpv */
       55 dcl  rpv_labelp		        ptr parameter;
       56 dcl  rpv_page		        (1024) bit (36) aligned; /* page being moved around */
       57 dcl  rpv_pvtx		        fixed bin parameter;	/* we trust this to point into pvt */
       58 dcl  1 rpv_vol_map		        aligned like vol_map; /* work copy of vol_map */
       59 dcl  1 rpv_vtoc_map		        aligned like vtoc_map;/* work copy of this */
       60 dcl  rpv_vtoce_page		        (1024) bit (36) aligned; /* area to read a page of vtoces into */
       61 dcl  seg_rec_num		        fixed bin;		/* loop counter on record num in a segment */
       62 dcl  syserr		        entry options (variable);
       63 dcl  syserr$error_code	        entry options (variable);
       64 dcl  top_to_vacate		        fixed bin;		/* address of last record in area to become new partition */
       65 dcl  vol_map_bit		        fixed bin;		/* bit in vol_map bit map word for record being considered */
       66 dcl  vol_map_page		        fixed bin;		/* which page of vol_map we are putting used page bit into */
       67 dcl  vol_map_word		        fixed bin;		/* pts to vol_map word being considered to find free page */
       68 dcl  vtoc_filemap_checksum	        bit (36) aligned;	/* what checksum should be for vtoce test */
       69 dcl  vtoc_map_bit		        fixed bin;		/* bit in vtoc bit map for this vtoce */
       70 dcl  vtoc_map_word		        fixed bin;		/* word in vtoc bit map containing bit for this vtoce */
       71 dcl  vtoc_num		        fixed bin;		/* loop counter thereon */
       72 dcl  vtoc_record		        fixed bin;		/* record containing vtoce being considered */
       73 dcl  vtoce_mod		        bit (1) aligned;	/* true => we moved a page of this seg and need to update vtoce on disk */
       74 dcl  write_disk$write_disk_no_test    entry (fixed bin, fixed bin, ptr, fixed bin (35));
       75 
       76 dcl (addr, addrel, bin, bit, dimension, divide, fixed, index, min, mod, size, substr) builtin;
       77 
       78 	pvt_arrayp = addr (pvt$array);		/* so we can look at the device_type */
       79 
       80 
       81 /* start by reading appropriate parts of disk header into work areas */
       82 
       83 	call read_disk$read_disk_no_test (rpv_pvtx, VOLMAP_ADDR, addr (rpv_vol_map), code);
       84 	if code ^= 0 then call bad_io (VOLMAP_ADDR);	/* first page */
       85 	call read_disk$read_disk_no_test (rpv_pvtx, VOLMAP_ADDR + 1, addrel (addr (rpv_vol_map), 1024), code);
       86 	if code ^= 0 then call bad_io (VOLMAP_ADDR + 1);	/* 2nd page thereof */
       87 	call read_disk$read_disk_no_test (rpv_pvtx, VOLMAP_ADDR + 2, addrel (addr (rpv_vol_map), 2048), code);
       88 	if code ^= 0 then call bad_io (VOLMAP_ADDR + 2);	/* 3rd page thereof */
       89 	call read_disk$read_disk_no_test (rpv_pvtx, VTOC_MAP_ADDR, addr (rpv_vtoc_map), code);
       90 	if code ^= 0 then call bad_io (VTOC_MAP_ADDR);
       91 
       92 	if rpv_label.nparts >= dimension (rpv_label.parts, 1) then do;
       93 	     call syserr (ANNOUNCE, "^a: No room in partition map for ^a.", ME, part_name);
       94 	     code = error_table_$noalloc;
       95 	     return;
       96 	end;
       97 
       98 /* Now we want to find where this space must go.  We do this completely from
       99*the partition map.  The obvious method of just shaving the space from the
      100*paging region described in the vol map may not work if we are on a second
      101*try through this and have updated the vol map (shrunk it) but not updated
      102*the partition map.  We would then reshrink the paging region.  So, we 
      103*determine the partition's location from the last thing we would have written
      104*before, the volume label. */
      105 
      106 	first_free_rec = rpv_label.vtoc_size;		/* beginning of paging region or low partition area */
      107 update_first:
      108 
      109 /* this loop will try to find the end of the last low partition */
      110 
      111 	do part_num = 1 to rpv_label.nparts;		/* look for low partitions */
      112 	     if rpv_label.parts (part_num).frec = first_free_rec then do;
      113 		first_free_rec = rpv_label.parts (part_num).frec + rpv_label.parts (part_num).nrec;
      114 						/* where next low part should start */
      115 		goto update_first;			/* start again to find a later low part */
      116 	     end;
      117 	end;
      118 
      119 /* we now know the end of the last low partition and can therefore see
      120*which partitions are high, in particular, which of them is lowest. */
      121 
      122 	last_free_rec = rpv_label.vol_size;		/* end of paging or high part region */
      123 	do part_num = 1 to rpv_label.nparts;
      124 	     if rpv_label.parts (part_num).frec > first_free_rec then
      125 						/* a high partition */
      126 		last_free_rec = min (last_free_rec, rpv_label.parts (part_num).frec);
      127 	end;
      128 
      129 	bottom_to_vacate = last_free_rec - n_records;
      130 	top_to_vacate = last_free_rec - 1;		/* these are the limits of the new partition */
      131 
      132 	if rpv_vol_map.base_add < first_free_rec then do;
      133 	     call syserr (ANNOUNCE, "^a: Paging region starts below end of low partitions.", ME);
      134 	     code = error_table_$noalloc;
      135 	     return;
      136 	end;
      137 	if rpv_vol_map.base_add + rpv_vol_map.n_rec > last_free_rec then do;
      138 	     call syserr (ANNOUNCE, "^a: Paging region ends past start of high partitions.", ME);
      139 	     code = error_table_$noalloc;
      140 	     return;
      141 	end;
      142 
      143 	call compute_free_recs;			/* make sure we fit */
      144 	if n_records > rpv_vol_map.n_free_rec then go to out_of_disk;
      145 
      146 /* Mark as used all pages in this new partition region.  Some of these are
      147*already so marked.  This marking helps keep future boots of a previous
      148*release following our failure from grabbing them. */
      149 
      150 	vol_map_word = divide (bottom_to_vacate - rpv_vol_map.base_add, 32, 17) + 1;
      151 						/* start of bits for partition */
      152 	if vol_map_word <= rpv_vol_map.bit_map_n_words then do;
      153 	     vol_map_bit = mod (bottom_to_vacate - rpv_vol_map.base_add, 32) + 2;
      154 	     substr (rpv_vol_map.bit_map (vol_map_word), vol_map_bit) = "0"b;
      155 	     do vol_map_word = vol_map_word + 1 to rpv_vol_map.bit_map_n_words;
      156 		rpv_vol_map.bit_map (vol_map_word) = "0"b; /* all used */
      157 	     end;
      158 	end;
      159 	call compute_free_recs;			/* write this out */
      160 	call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR, addr (rpv_vol_map), code);
      161 	if code ^= 0 then call bad_io (VOLMAP_ADDR);	/* first page */
      162 	call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR + 1, addrel (addr (rpv_vol_map), 1024), code);
      163 	if code ^= 0 then call bad_io (VOLMAP_ADDR + 1);	/* 2nd page thereof */
      164 	call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR + 2, addrel (addr (rpv_vol_map), 2048), code);
      165 	if code ^= 0 then call bad_io (VOLMAP_ADDR + 2);	/* 3rd page thereof */
      166 
      167 /* we don't ask at this time if vol_map shows enough room since we may have 
      168*left its count bad from the last attempt through here so we just march on */
      169 
      170 /* start up to look at segments */
      171 
      172 	vol_map_word = 1;				/* place to start looking for free pages */
      173 	vtoc_record = VTOC_ORIGIN - 1;		/* we'll read the next record for vtoces */
      174 
      175 	have_vtoce = "0"b;
      176 	vtocep = addr (rpv_vtoce_page);
      177 	do vtoc_num = 0 to rpv_vtoc_map.n_vtoce - 1;
      178 
      179 /* loop, getting vtoces, to look at segments */
      180 
      181 	     if mod (vtoc_num, VTOCES_PER_RECORD (pvt_array (rpv_pvtx).device_type)) = 0 then do;
      182 		have_vtoce = "0"b;			/* read in a set next time we need one */
      183 		vtocep = addr (rpv_vtoce_page);
      184 		vtoc_record = vtoc_record + 1;
      185 	     end;
      186 	     else vtocep = addrel (vtocep, size (vtoce));
      187 	     vtoc_map_word = divide (vtoc_num, 32, 17);
      188 	     vtoc_map_bit = mod (vtoc_num, 32) + 2;	/* find map bit */
      189 	     if substr (rpv_vtoc_map.bit_map (vtoc_map_word), vtoc_map_bit, 1) then ; /* free vtoce */
      190 	     else do;
      191 		if have_vtoce then ;
      192 		else do;				/* need to read */
      193 		     call read_disk$read_disk_no_test (rpv_pvtx, vtoc_record, addr (rpv_vtoce_page), code);
      194 		     if code ^= 0 then call bad_io (vtoc_record);
      195 		     have_vtoce = "1"b;
      196 		end;
      197 
      198 		vtoce_mod = "0"b;			/* check out vtoce */
      199 		call filemap_checksum_ (addr (vtoce.fm), fixed (vtoce.csl, 9), vtoc_filemap_checksum);
      200 		if vtoce.fm_damaged | (vtoce.fm_checksum_valid & vtoc_filemap_checksum ^= vtoce.fm_checksum) then do;
      201 		     call syserr (ANNOUNCE, "^a: vtoce ^d's file map is damaged.  Volume will need salvaging.", ME, vtoc_num);
      202 		     code = error_table_$noalloc;
      203 		     return;
      204 		end;
      205 
      206 /* now that we have found a real segment on disk, does it have pages in the
      207*new partition area to be moved? */
      208 
      209 		do seg_rec_num = 0 to fixed (vtoce.csl, 9) - 1;
      210 		     if substr (vtoce.fm (seg_rec_num), 1, 1) then ; /* null page */
      211 		     else do;
      212 			old_disk_record = bin (substr (vtoce.fm (seg_rec_num), 2, 17), 17);
      213 			if old_disk_record >= bottom_to_vacate & old_disk_record <= top_to_vacate then do; /* must move page out of region */
      214 
      215 /* find a free page on the disk */
      216 
      217 			     do vol_map_word = vol_map_word to rpv_vol_map.bit_map_n_words
      218 				while (substr (rpv_vol_map.bit_map (vol_map_word), 2, 32) = "0"b); end;
      219 			     if vol_map_word > rpv_vol_map.bit_map_n_words then go to out_of_disk;
      220 			     vol_map_bit = index (substr (rpv_vol_map.bit_map (vol_map_word), 2, 32), "1"b) + 1;
      221 			     new_disk_record = rpv_vol_map.base_add + (vol_map_word - 1) * 32 + vol_map_bit - 2;
      222 			     if new_disk_record >= bottom_to_vacate then go to out_of_disk;
      223 
      224 /* found a free page */
      225 
      226 			     substr (rpv_vol_map.bit_map (vol_map_word), vol_map_bit, 1) = "0"b; /* use up page */
      227 			     vol_map_page = divide (vol_map_word + 63, /* get wordno in vol_map */ 1024, 17);
      228 			     call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR + vol_map_page, addrel (addr (rpv_vol_map), vol_map_page * 1024), code);
      229 			     if code ^= 0 then call bad_io (VOLMAP_ADDR + vol_map_page); /* paranoid - force bit change out */
      230 
      231 /* now move page of segment from old to new */
      232 
      233 			     call read_disk$read_disk_no_test (rpv_pvtx, old_disk_record, addr (rpv_page), code);
      234 			     if code ^= 0 then call bad_io (old_disk_record);
      235 			     call write_disk$write_disk_no_test (rpv_pvtx, new_disk_record, addr (rpv_page), code);
      236 			     if code ^= 0 then call bad_io (new_disk_record);
      237 
      238 /* now to get vtoce updated */
      239 
      240 			     vtoce_mod = "1"b;
      241 			     vtoce.fm (seg_rec_num) = bit (fixed (new_disk_record, 18), 18);
      242 			end;
      243 		     end;
      244 		end;
      245 
      246 /* update vtoce on disk */
      247 
      248 		if vtoce_mod then do;
      249 		     vtoce.fm_checksum_valid = "1"b;
      250 		     call filemap_checksum_ (addr (vtoce.fm), fixed (vtoce.csl, 9), vtoce.fm_checksum);
      251 		     call write_disk$write_disk_no_test (rpv_pvtx, vtoc_record, addr (rpv_vtoce_page), code);
      252 		     if code ^= 0 then call bad_io (vtoc_record);
      253 		end;
      254 	     end;
      255 	end;
      256 
      257 /* update vol_map header */
      258 
      259 	rpv_vol_map.n_rec = bottom_to_vacate - rpv_vol_map.base_add;
      260 	rpv_vol_map.bit_map_n_words = divide (rpv_vol_map.n_rec + 31, 32, 17);
      261 
      262 /* we will count free records to avoid case where we just subtract records used
      263*on each attempt and thereby screw up totals */
      264 
      265 	call compute_free_recs;
      266 
      267 /* update disk */
      268 
      269 	call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR, addr (rpv_vol_map), code);
      270 	if code ^= 0 then call bad_io (VOLMAP_ADDR);	/* updated volmap */
      271 
      272 /* now we can put partition into header! */
      273 
      274 	rpv_label.nparts = rpv_label.nparts + 1;
      275 	rpv_label.parts (rpv_label.nparts).part = part_name;
      276 	rpv_label.parts (rpv_label.nparts).frec = bottom_to_vacate;
      277 	rpv_label.parts (rpv_label.nparts).nrec = n_records;
      278 
      279 /* done!!! */
      280 
      281 	code = 0;
      282 	return;
      283 
      284 out_of_disk:
      285 
      286 /* help out next bootload of previous release that must free some disk */
      287 
      288 	call compute_free_recs;
      289 	call write_disk$write_disk_no_test (rpv_pvtx, VOLMAP_ADDR, addr (rpv_vol_map), code);
      290 	call syserr (ANNOUNCE, "^a: Out of disk.", ME);
      291 	code = error_table_$noalloc;
      292 TERMINATE:
      293 	return;
      294 
      295 bad_io: proc (record_num);
      296 dcl  record_num		        fixed bin parameter;
      297 	call syserr$error_code (ANNOUNCE, code, "^a: Error accessing record ^d.", ME, record_num);
      298 	goto TERMINATE;
      299      end;
      300 
      301 compute_free_recs: proc;
      302 
      303 /* look through bits to see new free figure */
      304 
      305 	rpv_vol_map.n_free_rec = 0;
      306 	do vol_map_word = 1 to rpv_vol_map.bit_map_n_words;
      307 	     if vol_map_word < rpv_vol_map.bit_map_n_words then bit_map_string = substr (rpv_vol_map.bit_map (vol_map_word), 2, 32);
      308 	     else bit_map_string = substr (rpv_vol_map.bit_map (vol_map_word), 2, mod (rpv_vol_map.n_rec - 1, 32) + 1);
      309 	     vol_map_bit = index (bit_map_string, "1"b);
      310 	     do while (vol_map_bit > 0);
      311 		rpv_vol_map.n_free_rec = rpv_vol_map.n_free_rec + 1;
      312 		bit_map_string = substr (bit_map_string, vol_map_bit + 1);
      313 		vol_map_bit = index (bit_map_string, "1"b);
      314 	     end;
      315 	end;
      316 	return;
      317      end;
      318 
  1     1 /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  1     2 
  1     3 
  1     4 
  1     5 
  1     6 /****^  HISTORY COMMENTS:
  1     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  1     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  1     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  1    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  1    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  1    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  1    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  1    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  1    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18 
  1    19 /*
  1    20*   All disk packs have the standard layout described below:
  1    21*
  1    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  1    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  1    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  1    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  1    26*   Record  7		: formerly contained bad track list; no longer used.
  1    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  1    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  1    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  1    30*
  1    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  1    32*   of the particular partition.
  1    33*
  1    34*
  1    35*
  1    36*   A conceptual declaration for a disk pack could be:
  1    37*
  1    38*   dcl 1 disk_pack,
  1    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  1    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  1    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  1    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  1    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  1    44*   2 vtoc_array_records	(8 : n-1),
  1    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  1    46*   3 unused				bit(36 * 64),
  1    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  1    48*
  1    49*
  1    50*
  1    51*
  1    52**/
  1    53 
  1    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  1    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  1    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  1    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  1    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  1    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  1    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  1    61 		         fixed bin (17) int static options (constant);
  1    62 
  1    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  1    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  1    65 /* or the physical volume table entry (pvte) device type.		      */
  1    66 
  1    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  1    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  1    69 
  1    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  1    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  1    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  1    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  1    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  1    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  1    76 
  1    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      319 
  2     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  2     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  2     6*     Add the subvolume info.
  2     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2     9*     Added inconsistent_dbm bit used to determine consistency of volume
  2    10*     dumper bit maps.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  2    14 /* Note: fsout_vol clears pad fields before writing the label */
  2    15 
  2    16 dcl  labelp ptr;
  2    17 
  2    18 dcl 1 label based (labelp) aligned,
  2    19 
  2    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  2    21 
  2    22     2 gcos (5*64) fixed bin,
  2    23 
  2    24 /* Now we have the Multics label */
  2    25 
  2    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  2    27     2 version fixed bin,				/* Version 1 */
  2    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  2    29     2 pv_name char (32),				/* Physical volume name. */
  2    30     2 lv_name char (32),				/* Name of logical volume for pack */
  2    31     2 pvid bit (36),				/* Unique ID of this pack */
  2    32     2 lvid bit (36),				/* unique ID of its logical vol */
  2    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  2    34     2 time_registered fixed bin (71),			/* time imported to system */
  2    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  2    36     2 vol_size fixed bin,				/* total size of volume, in records */
  2    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  2    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  2    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  2    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  2    41     2 flagpad bit (33) unal,
  2    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  2    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  2    44     2 password bit (72),				/* not yet used */
  2    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  2    46     2 this_sv fixed bin,				/* what subvolume number it is */
  2    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  2    48     2 pad1 (13) fixed bin,
  2    49     2 time_mounted fixed bin (71),			/* time mounted */
  2    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  2    51 
  2    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  2    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  2    54* */
  2    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  2    56     2 pad6 fixed bin,				
  2    57 
  2    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  2    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  2    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  2    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  2    62     2 pad1a (2) fixed bin,
  2    63     2 err_hist_size fixed bin,			/* size of pack error history */
  2    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  2    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  2    66     2 pad2 (40) fixed bin,
  2    67     2 root,
  2    68       3 here bit (1),				/* TRUE if the root is on this pack */
  2    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  2    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  2    71       3 pad7 bit (1) aligned,				
  2    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  2    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  2    74       3 esd_state fixed bin,				/* State of esd */
  2    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  2    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  2    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  2    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  2    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  2    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  2    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  2    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  2    83     2 pad3 (52) fixed bin,
  2    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  2    85     2 parts (47),
  2    86       3 part char (4),				/* Name of partition */
  2    87       3 frec fixed bin,				/* First record */
  2    88       3 nrec fixed bin,				/* Number of records */
  2    89       3 pad5 fixed bin,
  2    90     2 pad4 (5*64) fixed bin;
  2    91 
  2    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  2    93 
  2    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      320 
  3     1 /*  START OF:	pvte.incl.pl1	July 1982	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /* Added pc_vacating, Benson Margulies 84-10-17 */
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-04-11,Fawcett), approve(86-04-11,MCR7383),
  3     7*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3     8*     Add the support for subvolumes
  3     9*  2) change(86-04-11,Lippard), approve(86-04-11,MCR7309),
  3    10*     audit(86-05-29,GDixon), install(86-07-18,MR12.0-1098):
  3    11*     Add root_lv flag to mount RLVs that do not have hardcore partitions.
  3    12*  3) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  3    13*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  3    14*     Added inconsistent_dbm bit for determining the status of volume
  3    15*     dumper bit maps.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18      dcl	   pvt$array	      aligned external;
  3    19      dcl	   pvt$max_n_entries      fixed bin external;
  3    20 
  3    21      dcl	   pvt_arrayp	      ptr;
  3    22      dcl	   pvtep		      ptr;
  3    23 
  3    24      dcl	   1 pvt_array	      (pvt$max_n_entries) aligned like pvte based (pvt_arrayp);
  3    25 
  3    26      dcl	   1 pvte		      based (pvtep) aligned,
  3    27 
  3    28 	     2 pvid	      bit (36),		/* physical volume ID */
  3    29 
  3    30 	     2 lvid	      bit (36),		/* logical volume ID */
  3    31 
  3    32 	     2 dmpr_in_use	      (3) bit (1) unaligned,	/* physical volume dumper interlock */
  3    33                2 is_sv              bit (1) unaligned,	/* true if this entry defines a subvolume */
  3    34 	     2 root_lv	      bit (1) unaligned,	/* true if this is on the root LV */
  3    35                2 removable_pack     bit (1) unaligned,	/* true if packs are eremoveable */
  3    36 	     2 inconsistent_dbm   bit (1) unaligned,      /* true if trouble count is incremented */
  3    37 	     2 pad3	      bit (2) unaligned,
  3    38 	     2 brother_pvtx	      fixed bin (8) unaligned,/* next pvte in lv chain */
  3    39 	     2 skip_queue_count   fixed bin (18) unsigned unaligned, /* number of times this pv skipped for per-proc allocation due to saturation */
  3    40 
  3    41 
  3    42 
  3    43 	     2 devname	      char (4),		/* device name */
  3    44 
  3    45 	     (2 device_type	      fixed bin (8),	/* device type */
  3    46 	     2 logical_area_number fixed bin (8),	/* disk drive number */
  3    47 	     2 used	      bit (1),		/* TRUE if this entry is used */
  3    48 	     2 storage_system     bit (1),		/* TRUE for storage system (vs io disk) */
  3    49 	     2 permanent	      bit (1),		/* TRUE if cannot be demounted */
  3    50 	     2 testing	      bit (1),		/* Protocol bit for read_disk$test */
  3    51 	     2 being_mounted      bit (1),		/* TRUE if the physical volume is being mounted */
  3    52 	     2 being_demounted    bit (1),		/* TRUE if the pysical volume is being demounted */
  3    53 	     2 check_read_incomplete bit (1),		/* page control should check read incomplete */
  3    54 	     2 device_inoperative bit (1),		/* TRUE if disk_control decides dev busted */
  3    55 	     2 rpv	      bit (1),		/* TRUE if this is the root physical volume */
  3    56 	     2 scav_check_address
  3    57                                     bit (1),		/* TRUE is page control should check deposits/withdrawals against scavenger table */
  3    58 	     2 deposit_to_volmap  bit (1),		/* TRUE if deposits should got to volume map, not stock */
  3    59 	     2 being_demounted2   bit (1),		/* No more vtoc I/O during demount */
  3    60 	     2 pc_vacating	      bit (1),		/* No more withdraws from this volume -- for debugging */
  3    61 	     2 vacating	      bit (1),		/* don't put new segs on this vol */
  3    62 	     2 hc_part_used	      bit (1),		/* HC part set up by init_pvt */
  3    63 	     2 volmap_lock_notify bit (1) unal,		/* TRUE if notify required when volmap lock is unlocked */
  3    64 	     2 volmap_idle_notify bit (1) unal,		/* TRUE if notify required when volmap state is idle */
  3    65 	     2 vtoc_map_lock_notify bit (1) unal,	/* TRUE if notify required when vtoc map lock is unlocked */
  3    66 
  3    67 
  3    68 	     2 n_free_vtoce	      fixed bin (17),	/* number of free VTOC entries */
  3    69 	     2 vtoc_size	      fixed bin (17),	/* size of the VTOC part of the disk - in records */
  3    70 
  3    71 	     2 dbmrp	      (2) bit (18),		/* rel ptr to dumber bit maps for this volume */
  3    72 
  3    73 	     2 nleft	      fixed bin (17),	/* number of records left */
  3    74 	     2 totrec	      fixed bin (17)) unaligned, /* Total records in this map */
  3    75 
  3    76 	     2 dim_info	      bit (36),		/* Information peculiar to DIM */
  3    77 	     2 sv_num	      fixed bin,		/* the number of this subvolume starting at 0 */
  3    78 	     2 num_of_svs	      fixed bin,              /* number of subvolumes for this device */
  3    79 	     2 records_per_cyl    fixed bin,
  3    80                2 record_factor      fixed bin,		/* the record factor for logical to real seek calculation */
  3    81 	     2 sv_name            char (2) aligned,
  3    82 	     2 curn_dmpr_vtocx    (3) fixed bin unaligned,/* current vtocx being dumped */
  3    83 	     2 n_vtoce	      fixed bin unaligned,	/* number of vtoce on this volume */
  3    84 
  3    85 	     2 baseadd	      fixed bin (18) uns unaligned, /* Base of paging region */
  3    86 	     2 pad2	      bit (18) unaligned,
  3    87 
  3    88                2 pad_for_mod_2      fixed bin (35),	/* Make volmap_seg_sdw double word aligned */
  3    89 
  3    90 	     2 volmap_seg_sdw     fixed bin (71),	/* SDW describing volmap_seg */
  3    91 
  3    92 	     2 volmap_astep	      ptr unal,		/* Packed pointer to ASTE for volmap_seg */
  3    93 
  3    94 	     2 volmap_offset      bit (18) unal,	/* Offset in volmap_seg of volume map */
  3    95 	     2 vtoc_map_offset    bit (18) unal,	/* Offset in volmap_seg of VTOC map */
  3    96 
  3    97 
  3    98 	     2 volmap_lock	      bit (36) aligned,	/* Lock on volume map operations */
  3    99 
  3   100 	     2 vtoc_map_lock      bit (36) aligned,	/* Lock on VTOC map operations */
  3   101 
  3   102 	     2 volmap_stock_ptr   ptr unal,		/* Packed pointer to record stock */
  3   103 
  3   104 	     2 vtoc_map_stock_ptr ptr unal,		/* Packed pointer to VTOCE stock */
  3   105 
  3   106 	     2 volmap_async_state fixed bin (17) unaligned, /* Asynchronous update state of Volume Map */
  3   107 	     2 volmap_async_page  fixed bin (17) unaligned, /* Page number for asynchronous update */
  3   108 
  3   109 	     2 vol_trouble_count  fixed bin (17) unaligned, /* Count of inconsistencies since last salvage */
  3   110 	     2 scavenger_block_rel bit (18) unaligned;	  /* Offset to scavenger block,  ^0 => scavenging */
  3   111 
  3   112 
  3   113      dcl	   (VOLMAP_ASYNC_IDLE     init (0),		/* for volmap_async_state */
  3   114 	   VOLMAP_ASYNC_READ      init (1),
  3   115 	   VOLMAP_ASYNC_WRITE     init (2)) fixed bin int static options (constant);
  3   116 
  3   117 
  3   118 /*  END OF:	pvte.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      321 
  4     1 /* BEGIN INCLUDE FILE syserr_constants.incl.pl1 ... 11/11/80 W. Olin Sibert */
  4     2 /* 85-02-12, EJ Sharpe - Added sorting class constants, removed AIM_MESSAGE, added new action code names. */
  4     3 /* 85-04-24, G. Palter - Renamed SYSERR_UNUSED_10 to SYSERR_RING1_ERROR to reflect its actual use. */
  4     4 
  4     5 /* This include file has an ALM version.  Keep 'em in sync! */
  4     6 
  4     7 dcl (
  4     8 
  4     9 /* The following constants define the message action codes.  This indicates
  4    10*how a message is to be handled.  */
  4    11 
  4    12      SYSERR_CRASH_SYSTEM	init (1),			
  4    13      CRASH		init (1), 		/* Crash the system, and bleat plaintively. */
  4    14 
  4    15      SYSERR_TERMINATE_PROCESS	init (2),
  4    16      TERMINATE_PROCESS	init (2), 		/* Terminate the process, print the message, and beep. */
  4    17 
  4    18      SYSERR_PRINT_WITH_ALARM	init (3),
  4    19      BEEP 		init (3), 		/* Beep and print the message on the console. */
  4    20 
  4    21      SYSERR_PRINT_ON_CONSOLE	init (0),
  4    22      ANNOUNCE		init (0), 		/* Just print the message on the console. */
  4    23 
  4    24      SYSERR_LOG_OR_PRINT	init (4),
  4    25      LOG			init (4), 		/* Log the message, or print it if it can't be logged */
  4    26 
  4    27      SYSERR_LOG_OR_DISCARD	init (5),
  4    28      JUST_LOG		init (5), 		/* Just try to log the message, and discard it if it can't be */
  4    29 
  4    30 
  4    31 /* The following constants are added to the normal severities to indicate
  4    32*different sorting classes of messages.  */
  4    33 
  4    34      SYSERR_SYSTEM_ERROR	init (00),		/* indicates a standard level system error */
  4    35      SYSERR_RING1_ERROR	init (10),		/* indicates an error detected in ring 1 (mseg_, RCP) */
  4    36      SYSERR_COVERT_CHANNEL	init (20),		/* indicates covert channel audit trail message */
  4    37      SYSERR_UNSUCCESSFUL_ACCESS init (30),		/* indicates access denial audit trail message */
  4    38      SYSERR_SUCCESSFUL_ACCESS	init (40)			/* indicates access grant audit trail message */
  4    39 	) fixed bin internal static options (constant);
  4    40 
  4    41 /* END INCLUDE FILE syserr_constants.incl.pl1 */
      322 
  5     1 /* BEGIN INCLUDE FILE ... vol_map.incl.pl1 */
  5     2 
  5     3 dcl   vol_mapp	ptr;
  5     4 
  5     5 dcl 1 vol_map based (vol_mapp) aligned,
  5     6 
  5     7     2 n_rec fixed bin(17),				/* number of records represented in the map */
  5     8     2 base_add fixed bin(17),				/* record number for first bit in bit map */
  5     9     2 n_free_rec fixed bin(17),			/* number of free records */
  5    10     2 bit_map_n_words fixed bin(17),			/* number of words of the bit map */
  5    11     2 pad (60) bit(36),				/* pad to 64 words */
  5    12     2 bit_map (3*1024 - 64) bit(36) ;			/* bit map - the entire vol map occupies 3 records */
  5    13 
  5    14 /* END INCLUDE ... vol_map */
      323 
  6     1 /*  START OF:	vtoc_map.incl.pl1	... March 1982 ...	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3      dcl	   vtoc_mapp	      ptr;
  6     4      dcl	   bit_map_wordp	      ptr;
  6     5 
  6     6      dcl	   1 vtoc_map	      aligned based (vtoc_mapp),
  6     7 	     2 n_vtoce	      fixed bin,		/* Number of VTOCEs on the device */
  6     8 	     2 n_free_vtoce	      fixed bin,		/* Number of free VTOCEs */
  6     9 	     2 bit_map_n_words    fixed bin,		/* Number of words in the bit map below */
  6    10 	     2 vtoc_last_recno    fixed bin,		/* Last record number in VTOC */
  6    11 	     2 pad	      (4) fixed bin,
  6    12 	     2 bit_map	      (0:1024 - 9) bit (36);	/* This structure consumes exactly 1 page */
  6    13 
  6    14      dcl	   1 bit_map_word	      aligned based (bit_map_wordp),
  6    15 	     2 pad1	      bit (1) unal,
  6    16 	     2 bits	      bit (32) unal,	/* 32 VTOCES ON => free */
  6    17 	     2 pad2	      bit (3) unal;
  6    18 
  6    19 
  6    20 
  6    21 /*  END OF:	vtoc_map.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      324 
  7     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
  7     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
  7     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
  7     4 
  7     5 dcl  vtocep ptr;
  7     6 
  7     7 dcl 1 vtoce based (vtocep) aligned,
  7     8 
  7     9 
  7    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
  7    11 
  7    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
  7    13 
  7    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
  7    15     2 csl bit (9),					/* current segment length - in 1024 word units */
  7    16     2 records bit (9),				/* number of records used by the seg in second storage */
  7    17     2 pad2 bit (9),
  7    18 
  7    19     2 dtu bit (36),					/* date and time segment was last used */
  7    20 
  7    21     2 dtm bit (36),					/* date and time segment was last modified */
  7    22 
  7    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
  7    24     2 deciduous bit (1),				/* true if hc_sdw */
  7    25     2 nid bit (1),					/* no incremental dump switch */
  7    26     2 dnzp bit (1),					/* Dont null zero pages */
  7    27     2 gtpd bit (1),					/* Global transparent paging device */
  7    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
  7    29     2 damaged bit (1),				/* TRUE if contents damaged */
  7    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
  7    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
  7    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
  7    33     2 pad3 bit (8),
  7    34     2 dirsw bit (1),				/* directory switch */
  7    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
  7    36     2 pad4 bit (16)) unaligned,			/* not used */
  7    37 
  7    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
  7    39 
  7    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
  7    41 
  7    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
  7    43 
  7    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
  7    45 
  7    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
  7    47 
  7    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
  7    49 
  7    50 
  7    51 
  7    52 
  7    53 
  7    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
  7    55 
  7    56     2 pad6 (10) bit (36),				/* not used */
  7    57 
  7    58     2 ncd bit (1),					/* no complete dump switch */
  7    59     2 pad7 bit (17),
  7    60     2 pad8 bit (18),
  7    61 
  7    62     2 dtd bit (36),					/* date-time-dumped */
  7    63 
  7    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
  7    65 
  7    66     2 master_dir_uid bit (36),			/* superior master directory uid */
  7    67 
  7    68 
  7    69 
  7    70 
  7    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
  7    72 
  7    73     2 primary_name char (32),				/* primary name of the segment */
  7    74 
  7    75     2 time_created bit (36),				/* time the segment was created */
  7    76 
  7    77     2 par_pvid bit (36),				/* physical volume id of the parent */
  7    78 
  7    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
  7    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
  7    81 
  7    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
  7    83 
  7    84     2 access_class bit (72),				/* access class in branch */
  7    85     2 perm_flags aligned,
  7    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
  7    87       3 pad9 bit (35) unal,
  7    88     2 owner bit (36);				/* pvid of this volume */
  7    89 
  7    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
  7    91 
  7    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
  7    93     2 pad1 bit (7*36),
  7    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
  7    95     2 pad2 bit (184*36);
  7    96 
  7    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      325 
      326 
      327 /* BEGIN MESSAGE DOCUMENTATION
      328*
      329*   Message:
      330*   create_rpv_partition: Paging region starts below end of low partitions.
      331*
      332*   S: $crash
      333*
      334*   T: $init
      335*
      336*   M: An inconsistency was found in the partition map when adding a new 
      337*   partition to the rpv.
      338*
      339*   A: The rpv will need to be rebuilt.
      340*
      341*   Message:
      342*   create_rpv_partition: Paging region ends past start of high partitions.
      343*
      344*   S: $crash
      345*
      346*   T: $init
      347*
      348*   M: An inconsistency was found in the partition map when adding a new
      349*   partition to the rpv.
      350*
      351*   A: The rpv will need to be rebuilt.
      352*
      353*   Message:
      354*   create_rpv_partition: vtoce NNN's file map is damaged.  Volume will need salvaging.
      355*
      356*   S: $crash
      357*
      358*   T: $init
      359*
      360*   M: The vtoce named was found to be damaged when adding a new partition
      361*   to the rpv.
      362*
      363*   A: Salvage the rpv using a boot of the previous release.
      364*
      365*   Message:
      366*   create_rpv_partition: No room in partition map for NAME.
      367*
      368*   S: $crash
      369*
      370*   T: $init
      371*
      372*   M: The partition map of the rpv was full.  The partition could not be 
      373*   added.
      374*
      375*   A: The rpv will need to be rebuilt.
      376*
      377*   Message:
      378*   create_rpv_partition: Out of disk.
      379*
      380*   S: $crash
      381*
      382*   T: $init
      383*
      384*   M: Not enough free space existed on the rpv to add the new partition.
      385*
      386*   A: The rlv will have to be rebuilt.
      387*
      388*   Message:
      389*   create_rpv_partition: Error accessing record NNN.
      390*
      391*   S: $crash
      392*
      393*   T: $init
      394*
      395*   M: An i/o error occured when accessing record NNN of the rpv while 
      396*   attempting to add a new partition.
      397*
      398*   A: Try again.  IF the error persists, the rpv will need to be rebuilt.
      399*
      400*   END MESSAGE DOCUMENTATION */
      401 
      402      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/89  0815.7  create_rpv_partition.pl1          >spec>install>1112>create_rpv_partition.pl1
319          1    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
320          2    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
321          3    07/21/88  2036.0  pvte.incl.pl1                     >ldd>include>pvte.incl.pl1
322          4    05/17/85  0615.7  syserr_constants.incl.pl1         >ldd>include>syserr_constants.incl.pl1
323          5    04/29/76  1050.5  vol_map.incl.pl1                  >ldd>include>vol_map.incl.pl1
324          6    05/27/82  1525.9  vtoc_map.incl.pl1                 >ldd>include>vtoc_map.incl.pl1
325          7    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANNOUNCE                        000000 constant        fixed bin(17,0)          initial dcl 4-7 set ref 93* 133* 138* 201* 290* 297*
ME                              000012 constant        char(20)                 initial packed unaligned dcl 39 set ref 93* 133*
                                                                                  138* 201* 290* 297*
VOLMAP_ADDR                     000026 constant        fixed bin(17,0)          initial dcl 1-54 set ref 83* 84* 85 86 87 88 160*
                                                                                  161* 162 163 164 165 228 229 269* 270* 289*
VTOCES_PER_RECORD               000000 constant        fixed bin(17,0)          initial array dcl 1-72 ref 181
VTOC_MAP_ADDR                   000011 constant        fixed bin(17,0)          initial dcl 1-54 set ref 89* 90*
VTOC_ORIGIN                            constant        fixed bin(17,0)          initial dcl 1-54 ref 173
addr                                                   builtin function         dcl 76 ref 78 83 83 85 85 87 87 89 89 160 160 162
                                                                                  162 164 164 176 183 193 193 199 199 228 228 233
                                                                                  233 235 235 250 250 251 251 269 269 289 289
addrel                                                 builtin function         dcl 76 ref 85 85 87 87 162 162 164 164 186 228 228
base_add                  1     002111 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 132 137 150 153 221 259
bin                                                    builtin function         dcl 76 ref 212
bit                                                    builtin function         dcl 76 ref 241
bit_map                  10     010111 automatic       bit(36)                  array level 2 in structure "rpv_vtoc_map" dcl 59
                                                                                  in procedure "create_rpv_partition" set ref 189
bit_map                 100     002111 automatic       bit(36)                  array level 2 in structure "rpv_vol_map" dcl 58
                                                                                  in procedure "create_rpv_partition" set ref 154*
                                                                                  156* 217 220 226* 307 308
bit_map_n_words           3     002111 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 152 155 217 219 260* 306 307
bit_map_string                  000100 automatic       varying bit(32)          dcl 40 set ref 307* 308* 309 312* 312 313
bottom_to_vacate                000102 automatic       fixed bin(17,0)          dcl 41 set ref 129* 150 153 213 222 259 276
code                                   parameter       fixed bin(35,0)          dcl 42 set ref 19 83* 84 85* 86 87* 88 89* 90 94*
                                                                                  134* 139* 160* 161 162* 163 164* 165 193* 194 202*
                                                                                  228* 229 233* 234 235* 236 251* 252 269* 270 281*
                                                                                  289* 291* 297*
csl                       2(09)        based           bit(9)                   level 2 packed packed unaligned dcl 7-7 ref 199 199
                                                                                  209 250 250
device_type               4            based           fixed bin(8,0)           array level 2 packed packed unaligned dcl 3-24 ref
                                                                                  181
dimension                                              builtin function         dcl 76 ref 92
divide                                                 builtin function         dcl 76 ref 150 187 227 260
error_table_$noalloc            000010 external static fixed bin(35,0)          dcl 43 ref 94 134 139 202 291
filemap_checksum_               000012 constant        entry                    external dcl 44 ref 199 250
first_free_rec                  000103 automatic       fixed bin(17,0)          dcl 45 set ref 106* 112 113* 124 132
fixed                                                  builtin function         dcl 76 ref 199 199 209 241 250 250
fm                       20            based           bit(18)                  array level 2 packed packed unaligned dcl 7-7 set
                                                                                  ref 199 199 210 212 241* 250 250
fm_checksum               6            based           bit(36)                  level 2 dcl 7-7 set ref 200 250*
fm_checksum_valid         5(08)        based           bit(1)                   level 2 packed packed unaligned dcl 7-7 set ref 200
                                                                                  249*
fm_damaged                5(07)        based           bit(1)                   level 2 packed packed unaligned dcl 7-7 ref 200
frec                   1005            based           fixed bin(17,0)          array level 3 dcl 54 set ref 112 113 124 124 276*
have_vtoce                      000104 automatic       bit(1)                   dcl 46 set ref 175* 182* 191 195*
index                                                  builtin function         dcl 76 ref 220 309 313
label                                  based           structure                level 1 dcl 2-18
last_free_rec                   000105 automatic       fixed bin(17,0)          dcl 47 set ref 122* 124* 124 129 130 137
min                                                    builtin function         dcl 76 ref 124
mod                                                    builtin function         dcl 76 ref 153 181 188 308
n_free_rec                2     002111 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 144 305* 311* 311
n_rec                           002111 automatic       fixed bin(17,0)          level 2 dcl 58 set ref 137 259* 260 308
n_records                              parameter       fixed bin(17,0)          dcl 48 ref 19 129 144 277
n_vtoce                         010111 automatic       fixed bin(17,0)          level 2 dcl 59 set ref 177
new_disk_record                 000106 automatic       fixed bin(17,0)          dcl 49 set ref 221* 222 235* 236* 241
nparts                 1003            based           fixed bin(17,0)          level 2 dcl 54 set ref 92 107 123 274* 274 275 276
                                                                                  277
nrec                   1006            based           fixed bin(17,0)          array level 3 dcl 54 set ref 113 277*
old_disk_record                 000107 automatic       fixed bin(17,0)          dcl 50 set ref 212* 213 213 233* 234*
part                   1004            based           char(4)                  array level 3 dcl 54 set ref 275*
part_name                              parameter       char(4)                  packed unaligned dcl 51 set ref 19 93* 275
part_num                        000110 automatic       fixed bin(17,0)          dcl 52 set ref 107* 112 113 113* 123* 124 124*
parts                  1004            based           structure                array level 2 dcl 54 set ref 92
pvt$array                       000024 external static fixed bin(17,0)          dcl 3-18 set ref 78
pvt_array                              based           structure                array level 1 dcl 3-24
pvt_arrayp                      014124 automatic       pointer                  dcl 3-21 set ref 78* 181
pvte                                   based           structure                level 1 dcl 3-26
read_disk$read_disk_no_test     000014 constant        entry                    external dcl 53 ref 83 85 87 89 193 233
record_num                             parameter       fixed bin(17,0)          dcl 296 set ref 295 297*
rpv_label                              based           structure                level 1 dcl 54
rpv_labelp                             parameter       pointer                  dcl 55 ref 19 92 92 106 107 112 113 113 122 123 124
                                                                                  124 274 274 275 275 276 276 277 277
rpv_page                        000111 automatic       bit(36)                  array dcl 56 set ref 233 233 235 235
rpv_pvtx                               parameter       fixed bin(17,0)          dcl 57 set ref 19 83* 85* 87* 89* 160* 162* 164* 181
                                                                                  193* 228* 233* 235* 251* 269* 289*
rpv_vol_map                     002111 automatic       structure                level 1 dcl 58 set ref 83 83 85 85 87 87 160 160 162
                                                                                  162 164 164 228 228 269 269 289 289
rpv_vtoc_map                    010111 automatic       structure                level 1 dcl 59 set ref 89 89
rpv_vtoce_page                  012111 automatic       bit(36)                  array dcl 60 set ref 176 183 193 193 251 251
seg_rec_num                     014111 automatic       fixed bin(17,0)          dcl 61 set ref 209* 210 212 241*
size                                                   builtin function         dcl 76 ref 186
substr                                                 builtin function         dcl 76 set ref 154* 189 210 212 217 220 226* 307 308
                                                                                  312
syserr                          000016 constant        entry                    external dcl 62 ref 93 133 138 201 290
syserr$error_code               000020 constant        entry                    external dcl 63 ref 297
top_to_vacate                   014112 automatic       fixed bin(17,0)          dcl 64 set ref 130* 213
vol_map                                based           structure                level 1 dcl 5-5
vol_map_bit                     014113 automatic       fixed bin(17,0)          dcl 65 set ref 153* 154 220* 221 226 309* 310 312
                                                                                  313*
vol_map_page                    014114 automatic       fixed bin(17,0)          dcl 66 set ref 227* 228 228 228 229
vol_map_word                    014115 automatic       fixed bin(17,0)          dcl 67 set ref 150* 152 154 155* 155* 156* 172* 217*
                                                                                  217 217* 219 220 221 226 227 306* 307 307 308*
vol_size                547            based           fixed bin(17,0)          level 2 dcl 54 ref 122
vtoc_filemap_checksum           014116 automatic       bit(36)                  dcl 68 set ref 199* 200
vtoc_map                               based           structure                level 1 dcl 6-6
vtoc_map_bit                    014117 automatic       fixed bin(17,0)          dcl 69 set ref 188* 189
vtoc_map_word                   014120 automatic       fixed bin(17,0)          dcl 70 set ref 187* 189
vtoc_num                        014121 automatic       fixed bin(17,0)          dcl 71 set ref 177* 181 187 188 201*
vtoc_record                     014122 automatic       fixed bin(17,0)          dcl 72 set ref 173* 184* 184 193* 194* 251* 252*
vtoc_size               550            based           fixed bin(17,0)          level 2 dcl 54 ref 106
vtoce                                  based           structure                level 1 dcl 7-7 set ref 186
vtoce_mod                       014123 automatic       bit(1)                   dcl 73 set ref 198* 240* 248
vtocep                          014126 automatic       pointer                  dcl 7-5 set ref 176* 183* 186* 186 186 199 199 199
                                                                                  199 200 200 200 209 210 212 241 249 250 250 250
                                                                                  250 250
write_disk$write_disk_no_test   000022 constant        entry                    external dcl 74 ref 160 162 164 228 235 251 269 289

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEEP                                   internal static fixed bin(17,0)          initial dcl 4-7
CRASH                                  internal static fixed bin(17,0)          initial dcl 4-7
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 1-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 1-54
JUST_LOG                               internal static fixed bin(17,0)          initial dcl 4-7
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 1-54
LOG                                    internal static fixed bin(17,0)          initial dcl 4-7
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 1-54
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 2-92
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 1-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 1-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 1-70
SYSERR_COVERT_CHANNEL                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_CRASH_SYSTEM                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_DISCARD                  internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_LOG_OR_PRINT                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_ON_CONSOLE                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_PRINT_WITH_ALARM                internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_RING1_ERROR                     internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SUCCESSFUL_ACCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_SYSTEM_ERROR                    internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_TERMINATE_PROCESS               internal static fixed bin(17,0)          initial dcl 4-7
SYSERR_UNSUCCESSFUL_ACCESS             internal static fixed bin(17,0)          initial dcl 4-7
TERMINATE_PROCESS                      internal static fixed bin(17,0)          initial dcl 4-7
VOLMAP_ASYNC_IDLE                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_READ                      internal static fixed bin(17,0)          initial dcl 3-113
VOLMAP_ASYNC_WRITE                     internal static fixed bin(17,0)          initial dcl 3-113
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 1-68
bit_map_word                           based           structure                level 1 dcl 6-14
bit_map_wordp                          automatic       pointer                  dcl 6-4
labelp                                 automatic       pointer                  dcl 2-16
pvt$max_n_entries                      external static fixed bin(17,0)          dcl 3-19
pvtep                                  automatic       pointer                  dcl 3-22
seg_vtoce                              based           structure                level 1 dcl 7-92
vol_mapp                               automatic       pointer                  dcl 5-3
vtoc_mapp                              automatic       pointer                  dcl 6-3
vtoce_parts                            based           bit(2304)                array dcl 7-90

NAMES DECLARED BY EXPLICIT CONTEXT.
TERMINATE                       001603 constant        label                    dcl 292 ref 298
bad_io                          001604 constant        entry                    internal dcl 295 ref 84 86 88 90 161 163 165 194 229
                                                                                  234 236 252 270
compute_free_recs               001644 constant        entry                    internal dcl 301 ref 143 159 265 284
create_rpv_partition            000140 constant        entry                    external dcl 19
out_of_disk                     001531 constant        label                    dcl 284 ref 144 219 222
update_first                    000355 constant        label                    dcl 107 ref 115

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2120        2146    2001        2130
Length      2466    2001        26         304     117           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_rpv_partition               6358 external procedure  is an external procedure.  
bad_io                                  internal procedure  shares stack frame of external procedure create_rpv_partition.  
compute_free_recs                       internal procedure  shares stack frame of external procedure create_rpv_partition.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_rpv_partition     000100 bit_map_string              create_rpv_partition
                         000102 bottom_to_vacate            create_rpv_partition
                         000103 first_free_rec              create_rpv_partition
                         000104 have_vtoce                  create_rpv_partition
                         000105 last_free_rec               create_rpv_partition
                         000106 new_disk_record             create_rpv_partition
                         000107 old_disk_record             create_rpv_partition
                         000110 part_num                    create_rpv_partition
                         000111 rpv_page                    create_rpv_partition
                         002111 rpv_vol_map                 create_rpv_partition
                         010111 rpv_vtoc_map                create_rpv_partition
                         012111 rpv_vtoce_page              create_rpv_partition
                         014111 seg_rec_num                 create_rpv_partition
                         014112 top_to_vacate               create_rpv_partition
                         014113 vol_map_bit                 create_rpv_partition
                         014114 vol_map_page                create_rpv_partition
                         014115 vol_map_word                create_rpv_partition
                         014116 vtoc_filemap_checksum       create_rpv_partition
                         014117 vtoc_map_bit                create_rpv_partition
                         014120 vtoc_map_word               create_rpv_partition
                         014121 vtoc_num                    create_rpv_partition
                         014122 vtoc_record                 create_rpv_partition
                         014123 vtoce_mod                   create_rpv_partition
                         014124 pvt_arrayp                  create_rpv_partition
                         014126 vtocep                      create_rpv_partition

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mdfx1               ext_entry           index_bs_1_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
filemap_checksum_             read_disk$read_disk_no_test   syserr                        syserr$error_code
write_disk$write_disk_no_test

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noalloc          pvt$array




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     19 000133        78 000145        83 000147        84 000166        85 000173        86 000220        87 000227
     88 000254        89 000263        90 000303        92 000310        93 000316        94 000346        95 000352
    106 000353       107 000355       112 000367       113 000377       115 000402       117 000403       122 000405
    123 000412       124 000421       127 000435       129 000437       130 000443       132 000446       133 000451
    134 000475       135 000501       137 000502       138 000505       139 000531       140 000535       143 000536
    144 000537       150 000543       152 000551       153 000553       154 000560       155 000573       156 000601
    157 000602       159 000604       160 000605       161 000625       162 000632       163 000657       164 000666
    165 000713       172 000722       173 000724       175 000726       176 000727       177 000731       181 000741
    182 000754       183 000755       184 000757       185 000760       186 000761       187 000764       188 000767
    189 000774       191 001007       193 001012       194 001031       195 001036       198 001040       199 001041
    200 001064       201 001076       202 001125       203 001131       209 001132       210 001143       212 001153
    213 001162       217 001166       218 001200       219 001202       220 001204       221 001215       222 001224
    226 001226       227 001237       228 001243       229 001272       233 001302       234 001322       235 001327
    236 001347       240 001354       241 001356       244 001371       248 001373       249 001375       250 001400
    251 001421       252 001441       255 001446       259 001450       260 001453       265 001456       269 001457
    270 001477       274 001504       275 001510       276 001517       277 001522       281 001527       282 001530
    284 001531       289 001532       290 001552       291 001577       292 001603       295 001604       297 001606
    298 001643       301 001644       305 001645       306 001646       307 001655       308 001666       309 001707
    310 001714       311 001716       312 001717       313 001731       314 001736       315 001737       316 001741


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
